{"sha": "a9decbdc443f120d1ca2efb1798bfc20bad7c2d4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE5ZGVjYmRjNDQzZjEyMGQxY2EyZWZiMTc5OGJmYzIwYmFkN2MyZDQ=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-01-15T18:47:17Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-01-16T16:38:24Z"}, "message": "rustc: Move the privacy pass to its own crate", "tree": {"sha": "2464f2df4234bf9a9c19b9b98598f3c443ded95a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2464f2df4234bf9a9c19b9b98598f3c443ded95a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a9decbdc443f120d1ca2efb1798bfc20bad7c2d4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a9decbdc443f120d1ca2efb1798bfc20bad7c2d4", "html_url": "https://github.com/rust-lang/rust/commit/a9decbdc443f120d1ca2efb1798bfc20bad7c2d4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a9decbdc443f120d1ca2efb1798bfc20bad7c2d4/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ee2bfae011e368e224d6d4f4c9fad13606ee99da", "url": "https://api.github.com/repos/rust-lang/rust/commits/ee2bfae011e368e224d6d4f4c9fad13606ee99da", "html_url": "https://github.com/rust-lang/rust/commit/ee2bfae011e368e224d6d4f4c9fad13606ee99da"}], "stats": {"total": 3176, "additions": 1611, "deletions": 1565}, "files": [{"sha": "d6cc3598bd51d32666574d8c95b53b4bea02cfb0", "filename": "mk/crates.mk", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a9decbdc443f120d1ca2efb1798bfc20bad7c2d4/mk%2Fcrates.mk", "raw_url": "https://github.com/rust-lang/rust/raw/a9decbdc443f120d1ca2efb1798bfc20bad7c2d4/mk%2Fcrates.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcrates.mk?ref=a9decbdc443f120d1ca2efb1798bfc20bad7c2d4", "patch": "@@ -54,7 +54,7 @@ TARGET_CRATES := libc std flate arena term \\\n                  log regex graphviz core rbml alloc \\\n                  unicode\n RUSTC_CRATES := rustc rustc_typeck rustc_borrowck rustc_resolve rustc_driver \\\n-                rustc_trans rustc_back rustc_llvm\n+                rustc_trans rustc_back rustc_llvm rustc_privacy\n HOST_CRATES := syntax $(RUSTC_CRATES) rustdoc fmt_macros\n CRATES := $(TARGET_CRATES) $(HOST_CRATES)\n TOOLS := compiletest rustdoc rustc rustbook\n@@ -68,12 +68,15 @@ DEPS_std := core libc rand alloc collections unicode \\\n DEPS_graphviz := std\n DEPS_syntax := std term serialize log fmt_macros arena libc\n DEPS_rustc_driver := arena flate getopts graphviz libc rustc rustc_back rustc_borrowck \\\n-                     rustc_typeck rustc_resolve log syntax serialize rustc_llvm rustc_trans\n+                     rustc_typeck rustc_resolve log syntax serialize rustc_llvm \\\n+\t\t     rustc_trans rustc_privacy\n+\n DEPS_rustc_trans := arena flate getopts graphviz libc rustc rustc_back \\\n \t                log syntax serialize rustc_llvm\n DEPS_rustc_typeck := rustc syntax\n DEPS_rustc_borrowck := rustc log graphviz syntax\n DEPS_rustc_resolve := rustc log syntax\n+DEPS_rustc_privacy := rustc log syntax\n DEPS_rustc := syntax flate arena serialize getopts rbml \\\n               log graphviz rustc_llvm rustc_back\n DEPS_rustc_llvm := native:rustllvm libc std\n@@ -122,12 +125,13 @@ DOC_CRATES := $(filter-out rustc, \\\n               $(filter-out rustc_borrowck, \\\n               $(filter-out rustc_resolve, \\\n               $(filter-out rustc_driver, \\\n+              $(filter-out rustc_privacy, \\\n               $(filter-out log, \\\n               $(filter-out regex, \\\n               $(filter-out getopts, \\\n-              $(filter-out syntax, $(CRATES)))))))))))\n+              $(filter-out syntax, $(CRATES))))))))))))\n COMPILER_DOC_CRATES := rustc rustc_trans rustc_borrowck rustc_resolve \\\n-                       rustc_typeck rustc_driver syntax\n+                       rustc_typeck rustc_driver syntax rustc_privacy\n \n # This macro creates some simple definitions for each crate being built, just\n # some munging of all of the parameters above."}, {"sha": "74797dfd77a425895805c62aba07273a77b00ef6", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 2, "deletions": 1560, "changes": 1562, "blob_url": "https://github.com/rust-lang/rust/blob/a9decbdc443f120d1ca2efb1798bfc20bad7c2d4/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9decbdc443f120d1ca2efb1798bfc20bad7c2d4/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=a9decbdc443f120d1ca2efb1798bfc20bad7c2d4", "patch": "@@ -11,28 +11,14 @@\n //! A pass that checks to make sure private fields and methods aren't used\n //! outside their scopes. This pass will also generate a set of exported items\n //! which are available for use externally when compiled as a library.\n+\n pub use self::PrivateDep::*;\n pub use self::ImportUse::*;\n pub use self::LastPrivate::*;\n-use self::PrivacyResult::*;\n-use self::FieldName::*;\n-\n-use std::mem::replace;\n \n-use metadata::csearch;\n-use middle::def;\n-use middle::ty::{self, Ty};\n-use middle::ty::{MethodCall, MethodMap, MethodOrigin, MethodParam, MethodTypeParam};\n-use middle::ty::{MethodStatic, MethodStaticUnboxedClosure, MethodObject, MethodTraitObject};\n use util::nodemap::{DefIdSet, NodeMap, NodeSet};\n \n-use syntax::{ast, ast_map};\n-use syntax::ast_util::{is_local, local_def, PostExpansionMethod};\n-use syntax::codemap::Span;\n-use syntax::parse::token;\n-use syntax::visit::{self, Visitor};\n-\n-type Context<'a, 'tcx> = (&'a MethodMap<'tcx>, &'a def::ExportMap);\n+use syntax::ast;\n \n /// A set of AST nodes exported by the crate.\n pub type ExportedItems = NodeSet;\n@@ -84,1547 +70,3 @@ impl LastPrivate {\n         }\n     }\n }\n-\n-/// Result of a checking operation - None => no errors were found. Some => an\n-/// error and contains the span and message for reporting that error and\n-/// optionally the same for a note about the error.\n-type CheckResult = Option<(Span, String, Option<(Span, String)>)>;\n-\n-////////////////////////////////////////////////////////////////////////////////\n-/// The parent visitor, used to determine what's the parent of what (node-wise)\n-////////////////////////////////////////////////////////////////////////////////\n-\n-struct ParentVisitor {\n-    parents: NodeMap<ast::NodeId>,\n-    curparent: ast::NodeId,\n-}\n-\n-impl<'v> Visitor<'v> for ParentVisitor {\n-    fn visit_item(&mut self, item: &ast::Item) {\n-        self.parents.insert(item.id, self.curparent);\n-\n-        let prev = self.curparent;\n-        match item.node {\n-            ast::ItemMod(..) => { self.curparent = item.id; }\n-            // Enum variants are parented to the enum definition itself because\n-            // they inherit privacy\n-            ast::ItemEnum(ref def, _) => {\n-                for variant in def.variants.iter() {\n-                    // The parent is considered the enclosing enum because the\n-                    // enum will dictate the privacy visibility of this variant\n-                    // instead.\n-                    self.parents.insert(variant.node.id, item.id);\n-                }\n-            }\n-\n-            // Trait methods are always considered \"public\", but if the trait is\n-            // private then we need some private item in the chain from the\n-            // method to the root. In this case, if the trait is private, then\n-            // parent all the methods to the trait to indicate that they're\n-            // private.\n-            ast::ItemTrait(_, _, _, ref methods) if item.vis != ast::Public => {\n-                for m in methods.iter() {\n-                    match *m {\n-                        ast::ProvidedMethod(ref m) => {\n-                            self.parents.insert(m.id, item.id);\n-                        }\n-                        ast::RequiredMethod(ref m) => {\n-                            self.parents.insert(m.id, item.id);\n-                        }\n-                        ast::TypeTraitItem(_) => {}\n-                    };\n-                }\n-            }\n-\n-            _ => {}\n-        }\n-        visit::walk_item(self, item);\n-        self.curparent = prev;\n-    }\n-\n-    fn visit_foreign_item(&mut self, a: &ast::ForeignItem) {\n-        self.parents.insert(a.id, self.curparent);\n-        visit::walk_foreign_item(self, a);\n-    }\n-\n-    fn visit_fn(&mut self, a: visit::FnKind<'v>, b: &'v ast::FnDecl,\n-                c: &'v ast::Block, d: Span, id: ast::NodeId) {\n-        // We already took care of some trait methods above, otherwise things\n-        // like impl methods and pub trait methods are parented to the\n-        // containing module, not the containing trait.\n-        if !self.parents.contains_key(&id) {\n-            self.parents.insert(id, self.curparent);\n-        }\n-        visit::walk_fn(self, a, b, c, d);\n-    }\n-\n-    fn visit_struct_def(&mut self, s: &ast::StructDef, _: ast::Ident,\n-                        _: &'v ast::Generics, n: ast::NodeId) {\n-        // Struct constructors are parented to their struct definitions because\n-        // they essentially are the struct definitions.\n-        match s.ctor_id {\n-            Some(id) => { self.parents.insert(id, n); }\n-            None => {}\n-        }\n-\n-        // While we have the id of the struct definition, go ahead and parent\n-        // all the fields.\n-        for field in s.fields.iter() {\n-            self.parents.insert(field.node.id, self.curparent);\n-        }\n-        visit::walk_struct_def(self, s)\n-    }\n-}\n-\n-////////////////////////////////////////////////////////////////////////////////\n-/// The embargo visitor, used to determine the exports of the ast\n-////////////////////////////////////////////////////////////////////////////////\n-\n-struct EmbargoVisitor<'a, 'tcx: 'a> {\n-    tcx: &'a ty::ctxt<'tcx>,\n-    export_map: &'a def::ExportMap,\n-\n-    // This flag is an indicator of whether the previous item in the\n-    // hierarchical chain was exported or not. This is the indicator of whether\n-    // children should be exported as well. Note that this can flip from false\n-    // to true if a reexported module is entered (or an action similar).\n-    prev_exported: bool,\n-\n-    // This is a list of all exported items in the AST. An exported item is any\n-    // function/method/item which is usable by external crates. This essentially\n-    // means that the result is \"public all the way down\", but the \"path down\"\n-    // may jump across private boundaries through reexport statements.\n-    exported_items: ExportedItems,\n-\n-    // This sets contains all the destination nodes which are publicly\n-    // re-exported. This is *not* a set of all reexported nodes, only a set of\n-    // all nodes which are reexported *and* reachable from external crates. This\n-    // means that the destination of the reexport is exported, and hence the\n-    // destination must also be exported.\n-    reexports: NodeSet,\n-\n-    // These two fields are closely related to one another in that they are only\n-    // used for generation of the 'PublicItems' set, not for privacy checking at\n-    // all\n-    public_items: PublicItems,\n-    prev_public: bool,\n-}\n-\n-impl<'a, 'tcx> EmbargoVisitor<'a, 'tcx> {\n-    // There are checks inside of privacy which depend on knowing whether a\n-    // trait should be exported or not. The two current consumers of this are:\n-    //\n-    //  1. Should default methods of a trait be exported?\n-    //  2. Should the methods of an implementation of a trait be exported?\n-    //\n-    // The answer to both of these questions partly rely on whether the trait\n-    // itself is exported or not. If the trait is somehow exported, then the\n-    // answers to both questions must be yes. Right now this question involves\n-    // more analysis than is currently done in rustc, so we conservatively\n-    // answer \"yes\" so that all traits need to be exported.\n-    fn exported_trait(&self, _id: ast::NodeId) -> bool {\n-        true\n-    }\n-}\n-\n-impl<'a, 'tcx, 'v> Visitor<'v> for EmbargoVisitor<'a, 'tcx> {\n-    fn visit_item(&mut self, item: &ast::Item) {\n-        let orig_all_pub = self.prev_public;\n-        self.prev_public = orig_all_pub && item.vis == ast::Public;\n-        if self.prev_public {\n-            self.public_items.insert(item.id);\n-        }\n-\n-        let orig_all_exported = self.prev_exported;\n-        match item.node {\n-            // impls/extern blocks do not break the \"public chain\" because they\n-            // cannot have visibility qualifiers on them anyway\n-            ast::ItemImpl(..) | ast::ItemForeignMod(..) => {}\n-\n-            // Traits are a little special in that even if they themselves are\n-            // not public they may still be exported.\n-            ast::ItemTrait(..) => {\n-                self.prev_exported = self.exported_trait(item.id);\n-            }\n-\n-            // Private by default, hence we only retain the \"public chain\" if\n-            // `pub` is explicitly listed.\n-            _ => {\n-                self.prev_exported =\n-                    (orig_all_exported && item.vis == ast::Public) ||\n-                     self.reexports.contains(&item.id);\n-            }\n-        }\n-\n-        let public_first = self.prev_exported &&\n-                           self.exported_items.insert(item.id);\n-\n-        match item.node {\n-            // Enum variants inherit from their parent, so if the enum is\n-            // public all variants are public unless they're explicitly priv\n-            ast::ItemEnum(ref def, _) if public_first => {\n-                for variant in def.variants.iter() {\n-                    self.exported_items.insert(variant.node.id);\n-                }\n-            }\n-\n-            // Implementations are a little tricky to determine what's exported\n-            // out of them. Here's a few cases which are currently defined:\n-            //\n-            // * Impls for private types do not need to export their methods\n-            //   (either public or private methods)\n-            //\n-            // * Impls for public types only have public methods exported\n-            //\n-            // * Public trait impls for public types must have all methods\n-            //   exported.\n-            //\n-            // * Private trait impls for public types can be ignored\n-            //\n-            // * Public trait impls for private types have their methods\n-            //   exported. I'm not entirely certain that this is the correct\n-            //   thing to do, but I have seen use cases of where this will cause\n-            //   undefined symbols at linkage time if this case is not handled.\n-            //\n-            // * Private trait impls for private types can be completely ignored\n-            ast::ItemImpl(_, _, _, _, ref ty, ref impl_items) => {\n-                let public_ty = match ty.node {\n-                    ast::TyPath(_, id) => {\n-                        match self.tcx.def_map.borrow()[id].clone() {\n-                            def::DefPrimTy(..) => true,\n-                            def => {\n-                                let did = def.def_id();\n-                                !is_local(did) ||\n-                                 self.exported_items.contains(&did.node)\n-                            }\n-                        }\n-                    }\n-                    _ => true,\n-                };\n-                let tr = ty::impl_trait_ref(self.tcx, local_def(item.id));\n-                let public_trait = tr.clone().map_or(false, |tr| {\n-                    !is_local(tr.def_id) ||\n-                     self.exported_items.contains(&tr.def_id.node)\n-                });\n-\n-                if public_ty || public_trait {\n-                    for impl_item in impl_items.iter() {\n-                        match *impl_item {\n-                            ast::MethodImplItem(ref method) => {\n-                                let meth_public =\n-                                    match method.pe_explicit_self().node {\n-                                        ast::SelfStatic => public_ty,\n-                                        _ => true,\n-                                    } && method.pe_vis() == ast::Public;\n-                                if meth_public || tr.is_some() {\n-                                    self.exported_items.insert(method.id);\n-                                }\n-                            }\n-                            ast::TypeImplItem(_) => {}\n-                        }\n-                    }\n-                }\n-            }\n-\n-            // Default methods on traits are all public so long as the trait\n-            // is public\n-            ast::ItemTrait(_, _, _, ref methods) if public_first => {\n-                for method in methods.iter() {\n-                    match *method {\n-                        ast::ProvidedMethod(ref m) => {\n-                            debug!(\"provided {}\", m.id);\n-                            self.exported_items.insert(m.id);\n-                        }\n-                        ast::RequiredMethod(ref m) => {\n-                            debug!(\"required {}\", m.id);\n-                            self.exported_items.insert(m.id);\n-                        }\n-                        ast::TypeTraitItem(ref t) => {\n-                            debug!(\"typedef {}\", t.ty_param.id);\n-                            self.exported_items.insert(t.ty_param.id);\n-                        }\n-                    }\n-                }\n-            }\n-\n-            // Struct constructors are public if the struct is all public.\n-            ast::ItemStruct(ref def, _) if public_first => {\n-                match def.ctor_id {\n-                    Some(id) => { self.exported_items.insert(id); }\n-                    None => {}\n-                }\n-            }\n-\n-            ast::ItemTy(ref ty, _) if public_first => {\n-                if let ast::TyPath(_, id) = ty.node {\n-                    match self.tcx.def_map.borrow()[id].clone() {\n-                        def::DefPrimTy(..) | def::DefTyParam(..) => {},\n-                        def => {\n-                            let did = def.def_id();\n-                            if is_local(did) {\n-                                self.exported_items.insert(did.node);\n-                            }\n-                        }\n-                    }\n-                }\n-            }\n-\n-            _ => {}\n-        }\n-\n-        visit::walk_item(self, item);\n-\n-        self.prev_exported = orig_all_exported;\n-        self.prev_public = orig_all_pub;\n-    }\n-\n-    fn visit_foreign_item(&mut self, a: &ast::ForeignItem) {\n-        if (self.prev_exported && a.vis == ast::Public) || self.reexports.contains(&a.id) {\n-            self.exported_items.insert(a.id);\n-        }\n-    }\n-\n-    fn visit_mod(&mut self, m: &ast::Mod, _sp: Span, id: ast::NodeId) {\n-        // This code is here instead of in visit_item so that the\n-        // crate module gets processed as well.\n-        if self.prev_exported {\n-            assert!(self.export_map.contains_key(&id), \"wut {}\", id);\n-            for export in self.export_map[id].iter() {\n-                if is_local(export.def_id) {\n-                    self.reexports.insert(export.def_id.node);\n-                }\n-            }\n-        }\n-        visit::walk_mod(self, m)\n-    }\n-}\n-\n-////////////////////////////////////////////////////////////////////////////////\n-/// The privacy visitor, where privacy checks take place (violations reported)\n-////////////////////////////////////////////////////////////////////////////////\n-\n-struct PrivacyVisitor<'a, 'tcx: 'a> {\n-    tcx: &'a ty::ctxt<'tcx>,\n-    curitem: ast::NodeId,\n-    in_foreign: bool,\n-    parents: NodeMap<ast::NodeId>,\n-    external_exports: ExternalExports,\n-    last_private_map: LastPrivateMap,\n-}\n-\n-enum PrivacyResult {\n-    Allowable,\n-    ExternallyDenied,\n-    DisallowedBy(ast::NodeId),\n-}\n-\n-enum FieldName {\n-    UnnamedField(uint), // index\n-    // FIXME #6993: change type (and name) from Ident to Name\n-    NamedField(ast::Ident),\n-}\n-\n-impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n-    // used when debugging\n-    fn nodestr(&self, id: ast::NodeId) -> String {\n-        self.tcx.map.node_to_string(id).to_string()\n-    }\n-\n-    // Determines whether the given definition is public from the point of view\n-    // of the current item.\n-    fn def_privacy(&self, did: ast::DefId) -> PrivacyResult {\n-        if !is_local(did) {\n-            if self.external_exports.contains(&did) {\n-                debug!(\"privacy - {:?} was externally exported\", did);\n-                return Allowable;\n-            }\n-            debug!(\"privacy - is {:?} a public method\", did);\n-\n-            return match self.tcx.impl_or_trait_items.borrow().get(&did) {\n-                Some(&ty::MethodTraitItem(ref meth)) => {\n-                    debug!(\"privacy - well at least it's a method: {:?}\",\n-                           *meth);\n-                    match meth.container {\n-                        ty::TraitContainer(id) => {\n-                            debug!(\"privacy - recursing on trait {:?}\", id);\n-                            self.def_privacy(id)\n-                        }\n-                        ty::ImplContainer(id) => {\n-                            match ty::impl_trait_ref(self.tcx, id) {\n-                                Some(t) => {\n-                                    debug!(\"privacy - impl of trait {:?}\", id);\n-                                    self.def_privacy(t.def_id)\n-                                }\n-                                None => {\n-                                    debug!(\"privacy - found a method {:?}\",\n-                                            meth.vis);\n-                                    if meth.vis == ast::Public {\n-                                        Allowable\n-                                    } else {\n-                                        ExternallyDenied\n-                                    }\n-                                }\n-                            }\n-                        }\n-                    }\n-                }\n-                Some(&ty::TypeTraitItem(ref typedef)) => {\n-                    match typedef.container {\n-                        ty::TraitContainer(id) => {\n-                            debug!(\"privacy - recursing on trait {:?}\", id);\n-                            self.def_privacy(id)\n-                        }\n-                        ty::ImplContainer(id) => {\n-                            match ty::impl_trait_ref(self.tcx, id) {\n-                                Some(t) => {\n-                                    debug!(\"privacy - impl of trait {:?}\", id);\n-                                    self.def_privacy(t.def_id)\n-                                }\n-                                None => {\n-                                    debug!(\"privacy - found a typedef {:?}\",\n-                                            typedef.vis);\n-                                    if typedef.vis == ast::Public {\n-                                        Allowable\n-                                    } else {\n-                                        ExternallyDenied\n-                                    }\n-                                }\n-                            }\n-                        }\n-                    }\n-                }\n-                None => {\n-                    debug!(\"privacy - nope, not even a method\");\n-                    ExternallyDenied\n-                }\n-            };\n-        }\n-\n-        debug!(\"privacy - local {} not public all the way down\",\n-               self.tcx.map.node_to_string(did.node));\n-        // return quickly for things in the same module\n-        if self.parents.get(&did.node) == self.parents.get(&self.curitem) {\n-            debug!(\"privacy - same parent, we're done here\");\n-            return Allowable;\n-        }\n-\n-        // We now know that there is at least one private member between the\n-        // destination and the root.\n-        let mut closest_private_id = did.node;\n-        loop {\n-            debug!(\"privacy - examining {}\", self.nodestr(closest_private_id));\n-            let vis = match self.tcx.map.find(closest_private_id) {\n-                // If this item is a method, then we know for sure that it's an\n-                // actual method and not a static method. The reason for this is\n-                // that these cases are only hit in the ExprMethodCall\n-                // expression, and ExprCall will have its path checked later\n-                // (the path of the trait/impl) if it's a static method.\n-                //\n-                // With this information, then we can completely ignore all\n-                // trait methods. The privacy violation would be if the trait\n-                // couldn't get imported, not if the method couldn't be used\n-                // (all trait methods are public).\n-                //\n-                // However, if this is an impl method, then we dictate this\n-                // decision solely based on the privacy of the method\n-                // invocation.\n-                // FIXME(#10573) is this the right behavior? Why not consider\n-                //               where the method was defined?\n-                Some(ast_map::NodeImplItem(ii)) => {\n-                    match *ii {\n-                        ast::MethodImplItem(ref m) => {\n-                            let imp = self.tcx.map\n-                                          .get_parent_did(closest_private_id);\n-                            match ty::impl_trait_ref(self.tcx, imp) {\n-                                Some(..) => return Allowable,\n-                                _ if m.pe_vis() == ast::Public => {\n-                                    return Allowable\n-                                }\n-                                _ => m.pe_vis()\n-                            }\n-                        }\n-                        ast::TypeImplItem(_) => return Allowable,\n-                    }\n-                }\n-                Some(ast_map::NodeTraitItem(_)) => {\n-                    return Allowable;\n-                }\n-\n-                // This is not a method call, extract the visibility as one\n-                // would normally look at it\n-                Some(ast_map::NodeItem(it)) => it.vis,\n-                Some(ast_map::NodeForeignItem(_)) => {\n-                    self.tcx.map.get_foreign_vis(closest_private_id)\n-                }\n-                Some(ast_map::NodeVariant(..)) => {\n-                    ast::Public // need to move up a level (to the enum)\n-                }\n-                _ => ast::Public,\n-            };\n-            if vis != ast::Public { break }\n-            // if we've reached the root, then everything was allowable and this\n-            // access is public.\n-            if closest_private_id == ast::CRATE_NODE_ID { return Allowable }\n-            closest_private_id = self.parents[closest_private_id];\n-\n-            // If we reached the top, then we were public all the way down and\n-            // we can allow this access.\n-            if closest_private_id == ast::DUMMY_NODE_ID { return Allowable }\n-        }\n-        debug!(\"privacy - closest priv {}\", self.nodestr(closest_private_id));\n-        if self.private_accessible(closest_private_id) {\n-            Allowable\n-        } else {\n-            DisallowedBy(closest_private_id)\n-        }\n-    }\n-\n-    /// For a local private node in the AST, this function will determine\n-    /// whether the node is accessible by the current module that iteration is\n-    /// inside.\n-    fn private_accessible(&self, id: ast::NodeId) -> bool {\n-        let parent = self.parents[id];\n-        debug!(\"privacy - accessible parent {}\", self.nodestr(parent));\n-\n-        // After finding `did`'s closest private member, we roll ourselves back\n-        // to see if this private member's parent is anywhere in our ancestry.\n-        // By the privacy rules, we can access all of our ancestor's private\n-        // members, so that's why we test the parent, and not the did itself.\n-        let mut cur = self.curitem;\n-        loop {\n-            debug!(\"privacy - questioning {}, {}\", self.nodestr(cur), cur);\n-            match cur {\n-                // If the relevant parent is in our history, then we're allowed\n-                // to look inside any of our ancestor's immediate private items,\n-                // so this access is valid.\n-                x if x == parent => return true,\n-\n-                // If we've reached the root, then we couldn't access this item\n-                // in the first place\n-                ast::DUMMY_NODE_ID => return false,\n-\n-                // Keep going up\n-                _ => {}\n-            }\n-\n-            cur = self.parents[cur];\n-        }\n-    }\n-\n-    fn report_error(&self, result: CheckResult) -> bool {\n-        match result {\n-            None => true,\n-            Some((span, msg, note)) => {\n-                self.tcx.sess.span_err(span, &msg[]);\n-                match note {\n-                    Some((span, msg)) => {\n-                        self.tcx.sess.span_note(span, &msg[])\n-                    }\n-                    None => {},\n-                }\n-                false\n-            },\n-        }\n-    }\n-\n-    /// Guarantee that a particular definition is public. Returns a CheckResult\n-    /// which contains any errors found. These can be reported using `report_error`.\n-    /// If the result is `None`, no errors were found.\n-    fn ensure_public(&self, span: Span, to_check: ast::DefId,\n-                     source_did: Option<ast::DefId>, msg: &str) -> CheckResult {\n-        let id = match self.def_privacy(to_check) {\n-            ExternallyDenied => {\n-                return Some((span, format!(\"{} is private\", msg), None))\n-            }\n-            Allowable => return None,\n-            DisallowedBy(id) => id,\n-        };\n-\n-        // If we're disallowed by a particular id, then we attempt to give a\n-        // nice error message to say why it was disallowed. It was either\n-        // because the item itself is private or because its parent is private\n-        // and its parent isn't in our ancestry.\n-        let (err_span, err_msg) = if id == source_did.unwrap_or(to_check).node {\n-            return Some((span, format!(\"{} is private\", msg), None));\n-        } else {\n-            (span, format!(\"{} is inaccessible\", msg))\n-        };\n-        let item = match self.tcx.map.find(id) {\n-            Some(ast_map::NodeItem(item)) => {\n-                match item.node {\n-                    // If an impl disallowed this item, then this is resolve's\n-                    // way of saying that a struct/enum's static method was\n-                    // invoked, and the struct/enum itself is private. Crawl\n-                    // back up the chains to find the relevant struct/enum that\n-                    // was private.\n-                    ast::ItemImpl(_, _, _, _, ref ty, _) => {\n-                        let id = match ty.node {\n-                            ast::TyPath(_, id) => id,\n-                            _ => return Some((err_span, err_msg, None)),\n-                        };\n-                        let def = self.tcx.def_map.borrow()[id].clone();\n-                        let did = def.def_id();\n-                        assert!(is_local(did));\n-                        match self.tcx.map.get(did.node) {\n-                            ast_map::NodeItem(item) => item,\n-                            _ => self.tcx.sess.span_bug(item.span,\n-                                                        \"path is not an item\")\n-                        }\n-                    }\n-                    _ => item\n-                }\n-            }\n-            Some(..) | None => return Some((err_span, err_msg, None)),\n-        };\n-        let desc = match item.node {\n-            ast::ItemMod(..) => \"module\",\n-            ast::ItemTrait(..) => \"trait\",\n-            ast::ItemStruct(..) => \"struct\",\n-            ast::ItemEnum(..) => \"enum\",\n-            _ => return Some((err_span, err_msg, None))\n-        };\n-        let msg = format!(\"{} `{}` is private\", desc,\n-                          token::get_ident(item.ident));\n-        Some((err_span, err_msg, Some((span, msg))))\n-    }\n-\n-    // Checks that a field is in scope.\n-    fn check_field(&mut self,\n-                   span: Span,\n-                   id: ast::DefId,\n-                   name: FieldName) {\n-        let fields = ty::lookup_struct_fields(self.tcx, id);\n-        let field = match name {\n-            NamedField(ident) => {\n-                debug!(\"privacy - check named field {} in struct {:?}\", ident.name, id);\n-                fields.iter().find(|f| f.name == ident.name).unwrap()\n-            }\n-            UnnamedField(idx) => &fields[idx]\n-        };\n-        if field.vis == ast::Public ||\n-            (is_local(field.id) && self.private_accessible(field.id.node)) {\n-            return\n-        }\n-\n-        let struct_type = ty::lookup_item_type(self.tcx, id).ty;\n-        let struct_desc = match struct_type.sty {\n-            ty::ty_struct(_, _) =>\n-                format!(\"struct `{}`\", ty::item_path_str(self.tcx, id)),\n-            // struct variant fields have inherited visibility\n-            ty::ty_enum(..) => return,\n-            _ => self.tcx.sess.span_bug(span, \"can't find struct for field\")\n-        };\n-        let msg = match name {\n-            NamedField(name) => format!(\"field `{}` of {} is private\",\n-                                        token::get_ident(name), struct_desc),\n-            UnnamedField(idx) => format!(\"field #{} of {} is private\",\n-                                         idx + 1, struct_desc),\n-        };\n-        self.tcx.sess.span_err(span, &msg[]);\n-    }\n-\n-    // Given the ID of a method, checks to ensure it's in scope.\n-    fn check_static_method(&mut self,\n-                           span: Span,\n-                           method_id: ast::DefId,\n-                           name: ast::Ident) {\n-        // If the method is a default method, we need to use the def_id of\n-        // the default implementation.\n-        let method_id = match ty::impl_or_trait_item(self.tcx, method_id) {\n-            ty::MethodTraitItem(method_type) => {\n-                method_type.provided_source.unwrap_or(method_id)\n-            }\n-            ty::TypeTraitItem(_) => method_id,\n-        };\n-\n-        let string = token::get_ident(name);\n-        self.report_error(self.ensure_public(span,\n-                                             method_id,\n-                                             None,\n-                                             &format!(\"method `{}`\",\n-                                                     string)[]));\n-    }\n-\n-    // Checks that a path is in scope.\n-    fn check_path(&mut self, span: Span, path_id: ast::NodeId, path: &ast::Path) {\n-        debug!(\"privacy - path {}\", self.nodestr(path_id));\n-        let orig_def = self.tcx.def_map.borrow()[path_id].clone();\n-        let ck = |&: tyname: &str| {\n-            let ck_public = |&: def: ast::DefId| {\n-                let name = token::get_ident(path.segments.last().unwrap().identifier);\n-                let origdid = orig_def.def_id();\n-                self.ensure_public(span,\n-                                   def,\n-                                   Some(origdid),\n-                                   &format!(\"{} `{}`\", tyname, name)[])\n-            };\n-\n-            match self.last_private_map[path_id] {\n-                LastMod(AllPublic) => {},\n-                LastMod(DependsOn(def)) => {\n-                    self.report_error(ck_public(def));\n-                },\n-                LastImport { value_priv,\n-                             value_used: check_value,\n-                             type_priv,\n-                             type_used: check_type } => {\n-                    // This dance with found_error is because we don't want to report\n-                    // a privacy error twice for the same directive.\n-                    let found_error = match (type_priv, check_type) {\n-                        (Some(DependsOn(def)), Used) => {\n-                            !self.report_error(ck_public(def))\n-                        },\n-                        _ => false,\n-                    };\n-                    if !found_error {\n-                        match (value_priv, check_value) {\n-                            (Some(DependsOn(def)), Used) => {\n-                                self.report_error(ck_public(def));\n-                            },\n-                            _ => {},\n-                        }\n-                    }\n-                    // If an import is not used in either namespace, we still\n-                    // want to check that it could be legal. Therefore we check\n-                    // in both namespaces and only report an error if both would\n-                    // be illegal. We only report one error, even if it is\n-                    // illegal to import from both namespaces.\n-                    match (value_priv, check_value, type_priv, check_type) {\n-                        (Some(p), Unused, None, _) |\n-                        (None, _, Some(p), Unused) => {\n-                            let p = match p {\n-                                AllPublic => None,\n-                                DependsOn(def) => ck_public(def),\n-                            };\n-                            if p.is_some() {\n-                                self.report_error(p);\n-                            }\n-                        },\n-                        (Some(v), Unused, Some(t), Unused) => {\n-                            let v = match v {\n-                                AllPublic => None,\n-                                DependsOn(def) => ck_public(def),\n-                            };\n-                            let t = match t {\n-                                AllPublic => None,\n-                                DependsOn(def) => ck_public(def),\n-                            };\n-                            if let (Some(_), Some(t)) = (v, t) {\n-                                self.report_error(Some(t));\n-                            }\n-                        },\n-                        _ => {},\n-                    }\n-                },\n-            }\n-        };\n-        // FIXME(#12334) Imports can refer to definitions in both the type and\n-        // value namespaces. The privacy information is aware of this, but the\n-        // def map is not. Therefore the names we work out below will not always\n-        // be accurate and we can get slightly wonky error messages (but type\n-        // checking is always correct).\n-        match self.tcx.def_map.borrow()[path_id].clone() {\n-            def::DefStaticMethod(..) => ck(\"static method\"),\n-            def::DefFn(..) => ck(\"function\"),\n-            def::DefStatic(..) => ck(\"static\"),\n-            def::DefConst(..) => ck(\"const\"),\n-            def::DefVariant(..) => ck(\"variant\"),\n-            def::DefTy(_, false) => ck(\"type\"),\n-            def::DefTy(_, true) => ck(\"enum\"),\n-            def::DefTrait(..) => ck(\"trait\"),\n-            def::DefStruct(..) => ck(\"struct\"),\n-            def::DefMethod(_, Some(..), _) => ck(\"trait method\"),\n-            def::DefMethod(..) => ck(\"method\"),\n-            def::DefMod(..) => ck(\"module\"),\n-            _ => {}\n-        }\n-    }\n-\n-    // Checks that a method is in scope.\n-    fn check_method(&mut self, span: Span, origin: &MethodOrigin,\n-                    ident: ast::Ident) {\n-        match *origin {\n-            MethodStatic(method_id) => {\n-                self.check_static_method(span, method_id, ident)\n-            }\n-            MethodStaticUnboxedClosure(_) => {}\n-            // Trait methods are always all public. The only controlling factor\n-            // is whether the trait itself is accessible or not.\n-            MethodTypeParam(MethodParam { ref trait_ref, .. }) |\n-            MethodTraitObject(MethodObject { ref trait_ref, .. }) => {\n-                self.report_error(self.ensure_public(span, trait_ref.def_id,\n-                                                     None, \"source trait\"));\n-            }\n-        }\n-    }\n-}\n-\n-impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n-    fn visit_item(&mut self, item: &ast::Item) {\n-        let orig_curitem = replace(&mut self.curitem, item.id);\n-        visit::walk_item(self, item);\n-        self.curitem = orig_curitem;\n-    }\n-\n-    fn visit_expr(&mut self, expr: &ast::Expr) {\n-        match expr.node {\n-            ast::ExprField(ref base, ident) => {\n-                if let ty::ty_struct(id, _) = ty::expr_ty_adjusted(self.tcx, &**base).sty {\n-                    self.check_field(expr.span, id, NamedField(ident.node));\n-                }\n-            }\n-            ast::ExprTupField(ref base, idx) => {\n-                if let ty::ty_struct(id, _) = ty::expr_ty_adjusted(self.tcx, &**base).sty {\n-                    self.check_field(expr.span, id, UnnamedField(idx.node));\n-                }\n-            }\n-            ast::ExprMethodCall(ident, _, _) => {\n-                let method_call = MethodCall::expr(expr.id);\n-                match self.tcx.method_map.borrow().get(&method_call) {\n-                    None => {\n-                        self.tcx.sess.span_bug(expr.span,\n-                                                \"method call not in \\\n-                                                method map\");\n-                    }\n-                    Some(method) => {\n-                        debug!(\"(privacy checking) checking impl method\");\n-                        self.check_method(expr.span, &method.origin, ident.node);\n-                    }\n-                }\n-            }\n-            ast::ExprStruct(_, ref fields, _) => {\n-                match ty::expr_ty(self.tcx, expr).sty {\n-                    ty::ty_struct(id, _) => {\n-                        for field in (*fields).iter() {\n-                            self.check_field(expr.span, id,\n-                                             NamedField(field.ident.node));\n-                        }\n-                    }\n-                    ty::ty_enum(_, _) => {\n-                        match self.tcx.def_map.borrow()[expr.id].clone() {\n-                            def::DefVariant(_, variant_id, _) => {\n-                                for field in fields.iter() {\n-                                    self.check_field(expr.span, variant_id,\n-                                                     NamedField(field.ident.node));\n-                                }\n-                            }\n-                            _ => self.tcx.sess.span_bug(expr.span,\n-                                                        \"resolve didn't \\\n-                                                         map enum struct \\\n-                                                         constructor to a \\\n-                                                         variant def\"),\n-                        }\n-                    }\n-                    _ => self.tcx.sess.span_bug(expr.span, \"struct expr \\\n-                                                            didn't have \\\n-                                                            struct type?!\"),\n-                }\n-            }\n-            ast::ExprPath(_) | ast::ExprQPath(_) => {\n-                let guard = |&: did: ast::DefId| {\n-                    let fields = ty::lookup_struct_fields(self.tcx, did);\n-                    let any_priv = fields.iter().any(|f| {\n-                        f.vis != ast::Public && (\n-                            !is_local(f.id) ||\n-                            !self.private_accessible(f.id.node))\n-                    });\n-                    if any_priv {\n-                        self.tcx.sess.span_err(expr.span,\n-                            \"cannot invoke tuple struct constructor \\\n-                             with private fields\");\n-                    }\n-                };\n-                match self.tcx.def_map.borrow().get(&expr.id) {\n-                    Some(&def::DefStruct(did)) => {\n-                        guard(if is_local(did) {\n-                            local_def(self.tcx.map.get_parent(did.node))\n-                        } else {\n-                            // \"tuple structs\" with zero fields (such as\n-                            // `pub struct Foo;`) don't have a ctor_id, hence\n-                            // the unwrap_or to the same struct id.\n-                            let maybe_did =\n-                                csearch::get_tuple_struct_definition_if_ctor(\n-                                    &self.tcx.sess.cstore, did);\n-                            maybe_did.unwrap_or(did)\n-                        })\n-                    }\n-                    _ => {}\n-                }\n-            }\n-            _ => {}\n-        }\n-\n-        visit::walk_expr(self, expr);\n-    }\n-\n-    fn visit_view_item(&mut self, a: &ast::ViewItem) {\n-        match a.node {\n-            ast::ViewItemExternCrate(..) => {}\n-            ast::ViewItemUse(ref vpath) => {\n-                match vpath.node {\n-                    ast::ViewPathSimple(..) | ast::ViewPathGlob(..) => {}\n-                    ast::ViewPathList(ref prefix, ref list, _) => {\n-                        for pid in list.iter() {\n-                            match pid.node {\n-                                ast::PathListIdent { id, name } => {\n-                                    debug!(\"privacy - ident item {}\", id);\n-                                    let seg = ast::PathSegment {\n-                                        identifier: name,\n-                                        parameters: ast::PathParameters::none(),\n-                                    };\n-                                    let segs = vec![seg];\n-                                    let path = ast::Path {\n-                                        global: false,\n-                                        span: pid.span,\n-                                        segments: segs,\n-                                    };\n-                                    self.check_path(pid.span, id, &path);\n-                                }\n-                                ast::PathListMod { id } => {\n-                                    debug!(\"privacy - mod item {}\", id);\n-                                    self.check_path(pid.span, id, prefix);\n-                                }\n-                            }\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-        visit::walk_view_item(self, a);\n-    }\n-\n-    fn visit_pat(&mut self, pattern: &ast::Pat) {\n-        // Foreign functions do not have their patterns mapped in the def_map,\n-        // and there's nothing really relevant there anyway, so don't bother\n-        // checking privacy. If you can name the type then you can pass it to an\n-        // external C function anyway.\n-        if self.in_foreign { return }\n-\n-        match pattern.node {\n-            ast::PatStruct(_, ref fields, _) => {\n-                match ty::pat_ty(self.tcx, pattern).sty {\n-                    ty::ty_struct(id, _) => {\n-                        for field in fields.iter() {\n-                            self.check_field(pattern.span, id,\n-                                             NamedField(field.node.ident));\n-                        }\n-                    }\n-                    ty::ty_enum(_, _) => {\n-                        match self.tcx.def_map.borrow().get(&pattern.id) {\n-                            Some(&def::DefVariant(_, variant_id, _)) => {\n-                                for field in fields.iter() {\n-                                    self.check_field(pattern.span, variant_id,\n-                                                     NamedField(field.node.ident));\n-                                }\n-                            }\n-                            _ => self.tcx.sess.span_bug(pattern.span,\n-                                                        \"resolve didn't \\\n-                                                         map enum struct \\\n-                                                         pattern to a \\\n-                                                         variant def\"),\n-                        }\n-                    }\n-                    _ => self.tcx.sess.span_bug(pattern.span,\n-                                                \"struct pattern didn't have \\\n-                                                 struct type?!\"),\n-                }\n-            }\n-\n-            // Patterns which bind no fields are allowable (the path is check\n-            // elsewhere).\n-            ast::PatEnum(_, Some(ref fields)) => {\n-                match ty::pat_ty(self.tcx, pattern).sty {\n-                    ty::ty_struct(id, _) => {\n-                        for (i, field) in fields.iter().enumerate() {\n-                            if let ast::PatWild(..) = field.node {\n-                                continue\n-                            }\n-                            self.check_field(field.span, id, UnnamedField(i));\n-                        }\n-                    }\n-                    ty::ty_enum(..) => {\n-                        // enum fields have no privacy at this time\n-                    }\n-                    _ => {}\n-                }\n-\n-            }\n-            _ => {}\n-        }\n-\n-        visit::walk_pat(self, pattern);\n-    }\n-\n-    fn visit_foreign_item(&mut self, fi: &ast::ForeignItem) {\n-        self.in_foreign = true;\n-        visit::walk_foreign_item(self, fi);\n-        self.in_foreign = false;\n-    }\n-\n-    fn visit_path(&mut self, path: &ast::Path, id: ast::NodeId) {\n-        self.check_path(path.span, id, path);\n-        visit::walk_path(self, path);\n-    }\n-}\n-\n-////////////////////////////////////////////////////////////////////////////////\n-/// The privacy sanity check visitor, ensures unnecessary visibility isn't here\n-////////////////////////////////////////////////////////////////////////////////\n-\n-struct SanePrivacyVisitor<'a, 'tcx: 'a> {\n-    tcx: &'a ty::ctxt<'tcx>,\n-    in_fn: bool,\n-}\n-\n-impl<'a, 'tcx, 'v> Visitor<'v> for SanePrivacyVisitor<'a, 'tcx> {\n-    fn visit_item(&mut self, item: &ast::Item) {\n-        if self.in_fn {\n-            self.check_all_inherited(item);\n-        } else {\n-            self.check_sane_privacy(item);\n-        }\n-\n-        let in_fn = self.in_fn;\n-        let orig_in_fn = replace(&mut self.in_fn, match item.node {\n-            ast::ItemMod(..) => false, // modules turn privacy back on\n-            _ => in_fn,           // otherwise we inherit\n-        });\n-        visit::walk_item(self, item);\n-        self.in_fn = orig_in_fn;\n-    }\n-\n-    fn visit_fn(&mut self, fk: visit::FnKind<'v>, fd: &'v ast::FnDecl,\n-                b: &'v ast::Block, s: Span, _: ast::NodeId) {\n-        // This catches both functions and methods\n-        let orig_in_fn = replace(&mut self.in_fn, true);\n-        visit::walk_fn(self, fk, fd, b, s);\n-        self.in_fn = orig_in_fn;\n-    }\n-\n-    fn visit_view_item(&mut self, i: &ast::ViewItem) {\n-        match i.vis {\n-            ast::Inherited => {}\n-            ast::Public => {\n-                if self.in_fn {\n-                    self.tcx.sess.span_err(i.span, \"unnecessary `pub`, imports \\\n-                                                    in functions are never \\\n-                                                    reachable\");\n-                } else if let ast::ViewItemExternCrate(..) = i.node {\n-                    self.tcx.sess.span_err(i.span, \"`pub` visibility \\\n-                                                    is not allowed\");\n-                }\n-            }\n-        }\n-        visit::walk_view_item(self, i);\n-    }\n-}\n-\n-impl<'a, 'tcx> SanePrivacyVisitor<'a, 'tcx> {\n-    /// Validates all of the visibility qualifiers placed on the item given. This\n-    /// ensures that there are no extraneous qualifiers that don't actually do\n-    /// anything. In theory these qualifiers wouldn't parse, but that may happen\n-    /// later on down the road...\n-    fn check_sane_privacy(&self, item: &ast::Item) {\n-        let tcx = self.tcx;\n-        let check_inherited = |&: sp: Span, vis: ast::Visibility, note: &str| {\n-            if vis != ast::Inherited {\n-                tcx.sess.span_err(sp, \"unnecessary visibility qualifier\");\n-                if note.len() > 0 {\n-                    tcx.sess.span_note(sp, note);\n-                }\n-            }\n-        };\n-        match item.node {\n-            // implementations of traits don't need visibility qualifiers because\n-            // that's controlled by having the trait in scope.\n-            ast::ItemImpl(_, _, _, Some(..), _, ref impl_items) => {\n-                check_inherited(item.span, item.vis,\n-                                \"visibility qualifiers have no effect on trait \\\n-                                 impls\");\n-                for impl_item in impl_items.iter() {\n-                    match *impl_item {\n-                        ast::MethodImplItem(ref m) => {\n-                            check_inherited(m.span, m.pe_vis(), \"\");\n-                        }\n-                        ast::TypeImplItem(_) => {}\n-                    }\n-                }\n-            }\n-\n-            ast::ItemImpl(..) => {\n-                check_inherited(item.span, item.vis,\n-                                \"place qualifiers on individual methods instead\");\n-            }\n-            ast::ItemForeignMod(..) => {\n-                check_inherited(item.span, item.vis,\n-                                \"place qualifiers on individual functions \\\n-                                 instead\");\n-            }\n-\n-            ast::ItemEnum(ref def, _) => {\n-                for v in def.variants.iter() {\n-                    match v.node.vis {\n-                        ast::Public => {\n-                            if item.vis == ast::Public {\n-                                tcx.sess.span_err(v.span, \"unnecessary `pub` \\\n-                                                           visibility\");\n-                            }\n-                        }\n-                        ast::Inherited => {}\n-                    }\n-                }\n-            }\n-\n-            ast::ItemTrait(_, _, _, ref methods) => {\n-                for m in methods.iter() {\n-                    match *m {\n-                        ast::ProvidedMethod(ref m) => {\n-                            check_inherited(m.span, m.pe_vis(),\n-                                            \"unnecessary visibility\");\n-                        }\n-                        ast::RequiredMethod(ref m) => {\n-                            check_inherited(m.span, m.vis,\n-                                            \"unnecessary visibility\");\n-                        }\n-                        ast::TypeTraitItem(_) => {}\n-                    }\n-                }\n-            }\n-\n-            ast::ItemConst(..) | ast::ItemStatic(..) | ast::ItemStruct(..) |\n-            ast::ItemFn(..) | ast::ItemMod(..) | ast::ItemTy(..) |\n-            ast::ItemMac(..) => {}\n-        }\n-    }\n-\n-    /// When inside of something like a function or a method, visibility has no\n-    /// control over anything so this forbids any mention of any visibility\n-    fn check_all_inherited(&self, item: &ast::Item) {\n-        let tcx = self.tcx;\n-        fn check_inherited(tcx: &ty::ctxt, sp: Span, vis: ast::Visibility) {\n-            if vis != ast::Inherited {\n-                tcx.sess.span_err(sp, \"visibility has no effect inside functions\");\n-            }\n-        }\n-        let check_struct = |&: def: &ast::StructDef| {\n-            for f in def.fields.iter() {\n-               match f.node.kind {\n-                    ast::NamedField(_, p) => check_inherited(tcx, f.span, p),\n-                    ast::UnnamedField(..) => {}\n-                }\n-            }\n-        };\n-        check_inherited(tcx, item.span, item.vis);\n-        match item.node {\n-            ast::ItemImpl(_, _, _, _, _, ref impl_items) => {\n-                for impl_item in impl_items.iter() {\n-                    match *impl_item {\n-                        ast::MethodImplItem(ref m) => {\n-                            check_inherited(tcx, m.span, m.pe_vis());\n-                        }\n-                        ast::TypeImplItem(_) => {}\n-                    }\n-                }\n-            }\n-            ast::ItemForeignMod(ref fm) => {\n-                for i in fm.items.iter() {\n-                    check_inherited(tcx, i.span, i.vis);\n-                }\n-            }\n-            ast::ItemEnum(ref def, _) => {\n-                for v in def.variants.iter() {\n-                    check_inherited(tcx, v.span, v.node.vis);\n-                }\n-            }\n-\n-            ast::ItemStruct(ref def, _) => check_struct(&**def),\n-\n-            ast::ItemTrait(_, _, _, ref methods) => {\n-                for m in methods.iter() {\n-                    match *m {\n-                        ast::RequiredMethod(..) => {}\n-                        ast::ProvidedMethod(ref m) => check_inherited(tcx, m.span,\n-                                                                m.pe_vis()),\n-                        ast::TypeTraitItem(_) => {}\n-                    }\n-                }\n-            }\n-\n-            ast::ItemStatic(..) | ast::ItemConst(..) |\n-            ast::ItemFn(..) | ast::ItemMod(..) | ast::ItemTy(..) |\n-            ast::ItemMac(..) => {}\n-        }\n-    }\n-}\n-\n-struct VisiblePrivateTypesVisitor<'a, 'tcx: 'a> {\n-    tcx: &'a ty::ctxt<'tcx>,\n-    exported_items: &'a ExportedItems,\n-    public_items: &'a PublicItems,\n-    in_variant: bool,\n-}\n-\n-struct CheckTypeForPrivatenessVisitor<'a, 'b: 'a, 'tcx: 'b> {\n-    inner: &'a VisiblePrivateTypesVisitor<'b, 'tcx>,\n-    /// whether the type refers to private types.\n-    contains_private: bool,\n-    /// whether we've recurred at all (i.e. if we're pointing at the\n-    /// first type on which visit_ty was called).\n-    at_outer_type: bool,\n-    // whether that first type is a public path.\n-    outer_type_is_public_path: bool,\n-}\n-\n-impl<'a, 'tcx> VisiblePrivateTypesVisitor<'a, 'tcx> {\n-    fn path_is_private_type(&self, path_id: ast::NodeId) -> bool {\n-        let did = match self.tcx.def_map.borrow().get(&path_id).cloned() {\n-            // `int` etc. (None doesn't seem to occur.)\n-            None | Some(def::DefPrimTy(..)) => return false,\n-            Some(def) => def.def_id()\n-        };\n-        // A path can only be private if:\n-        // it's in this crate...\n-        if !is_local(did) {\n-            return false\n-        }\n-        // .. and it corresponds to a private type in the AST (this returns\n-        // None for type parameters)\n-        match self.tcx.map.find(did.node) {\n-            Some(ast_map::NodeItem(ref item)) => item.vis != ast::Public,\n-            Some(_) | None => false,\n-        }\n-    }\n-\n-    fn trait_is_public(&self, trait_id: ast::NodeId) -> bool {\n-        // FIXME: this would preferably be using `exported_items`, but all\n-        // traits are exported currently (see `EmbargoVisitor.exported_trait`)\n-        self.public_items.contains(&trait_id)\n-    }\n-\n-    fn check_ty_param_bound(&self,\n-                            ty_param_bound: &ast::TyParamBound) {\n-        if let ast::TraitTyParamBound(ref trait_ref, _) = *ty_param_bound {\n-            if !self.tcx.sess.features.borrow().visible_private_types &&\n-                self.path_is_private_type(trait_ref.trait_ref.ref_id) {\n-                    let span = trait_ref.trait_ref.path.span;\n-                    self.tcx.sess.span_err(span,\n-                                           \"private trait in exported type \\\n-                                            parameter bound\");\n-            }\n-        }\n-    }\n-}\n-\n-impl<'a, 'b, 'tcx, 'v> Visitor<'v> for CheckTypeForPrivatenessVisitor<'a, 'b, 'tcx> {\n-    fn visit_ty(&mut self, ty: &ast::Ty) {\n-        if let ast::TyPath(_, path_id) = ty.node {\n-            if self.inner.path_is_private_type(path_id) {\n-                self.contains_private = true;\n-                // found what we're looking for so let's stop\n-                // working.\n-                return\n-            } else if self.at_outer_type {\n-                self.outer_type_is_public_path = true;\n-            }\n-        }\n-        self.at_outer_type = false;\n-        visit::walk_ty(self, ty)\n-    }\n-\n-    // don't want to recurse into [, .. expr]\n-    fn visit_expr(&mut self, _: &ast::Expr) {}\n-}\n-\n-impl<'a, 'tcx, 'v> Visitor<'v> for VisiblePrivateTypesVisitor<'a, 'tcx> {\n-    fn visit_item(&mut self, item: &ast::Item) {\n-        match item.node {\n-            // contents of a private mod can be reexported, so we need\n-            // to check internals.\n-            ast::ItemMod(_) => {}\n-\n-            // An `extern {}` doesn't introduce a new privacy\n-            // namespace (the contents have their own privacies).\n-            ast::ItemForeignMod(_) => {}\n-\n-            ast::ItemTrait(_, _, ref bounds, _) => {\n-                if !self.trait_is_public(item.id) {\n-                    return\n-                }\n-\n-                for bound in bounds.iter() {\n-                    self.check_ty_param_bound(bound)\n-                }\n-            }\n-\n-            // impls need some special handling to try to offer useful\n-            // error messages without (too many) false positives\n-            // (i.e. we could just return here to not check them at\n-            // all, or some worse estimation of whether an impl is\n-            // publicly visible.\n-            ast::ItemImpl(_, _, ref g, ref trait_ref, ref self_, ref impl_items) => {\n-                // `impl [... for] Private` is never visible.\n-                let self_contains_private;\n-                // impl [... for] Public<...>, but not `impl [... for]\n-                // ~[Public]` or `(Public,)` etc.\n-                let self_is_public_path;\n-\n-                // check the properties of the Self type:\n-                {\n-                    let mut visitor = CheckTypeForPrivatenessVisitor {\n-                        inner: self,\n-                        contains_private: false,\n-                        at_outer_type: true,\n-                        outer_type_is_public_path: false,\n-                    };\n-                    visitor.visit_ty(&**self_);\n-                    self_contains_private = visitor.contains_private;\n-                    self_is_public_path = visitor.outer_type_is_public_path;\n-                }\n-\n-                // miscellaneous info about the impl\n-\n-                // `true` iff this is `impl Private for ...`.\n-                let not_private_trait =\n-                    trait_ref.as_ref().map_or(true, // no trait counts as public trait\n-                                              |tr| {\n-                        let did = ty::trait_ref_to_def_id(self.tcx, tr);\n-\n-                        !is_local(did) || self.trait_is_public(did.node)\n-                    });\n-\n-                // `true` iff this is a trait impl or at least one method is public.\n-                //\n-                // `impl Public { $( fn ...() {} )* }` is not visible.\n-                //\n-                // This is required over just using the methods' privacy\n-                // directly because we might have `impl<T: Foo<Private>> ...`,\n-                // and we shouldn't warn about the generics if all the methods\n-                // are private (because `T` won't be visible externally).\n-                let trait_or_some_public_method =\n-                    trait_ref.is_some() ||\n-                    impl_items.iter()\n-                              .any(|impl_item| {\n-                                  match *impl_item {\n-                                      ast::MethodImplItem(ref m) => {\n-                                          self.exported_items.contains(&m.id)\n-                                      }\n-                                      ast::TypeImplItem(_) => false,\n-                                  }\n-                              });\n-\n-                if !self_contains_private &&\n-                        not_private_trait &&\n-                        trait_or_some_public_method {\n-\n-                    visit::walk_generics(self, g);\n-\n-                    match *trait_ref {\n-                        None => {\n-                            for impl_item in impl_items.iter() {\n-                                match *impl_item {\n-                                    ast::MethodImplItem(ref method) => {\n-                                        visit::walk_method_helper(self, &**method)\n-                                    }\n-                                    ast::TypeImplItem(_) => {}\n-                                }\n-                            }\n-                        }\n-                        Some(ref tr) => {\n-                            // Any private types in a trait impl fall into two\n-                            // categories.\n-                            // 1. mentioned in the trait definition\n-                            // 2. mentioned in the type params/generics\n-                            //\n-                            // Those in 1. can only occur if the trait is in\n-                            // this crate and will've been warned about on the\n-                            // trait definition (there's no need to warn twice\n-                            // so we don't check the methods).\n-                            //\n-                            // Those in 2. are warned via walk_generics and this\n-                            // call here.\n-                            self.visit_trait_ref(tr)\n-                        }\n-                    }\n-                } else if trait_ref.is_none() && self_is_public_path {\n-                    // impl Public<Private> { ... }. Any public static\n-                    // methods will be visible as `Public::foo`.\n-                    let mut found_pub_static = false;\n-                    for impl_item in impl_items.iter() {\n-                        match *impl_item {\n-                            ast::MethodImplItem(ref method) => {\n-                                if method.pe_explicit_self().node ==\n-                                        ast::SelfStatic &&\n-                                        self.exported_items\n-                                            .contains(&method.id) {\n-                                    found_pub_static = true;\n-                                    visit::walk_method_helper(self, &**method);\n-                                }\n-                            }\n-                            ast::TypeImplItem(_) => {}\n-                        }\n-                    }\n-                    if found_pub_static {\n-                        visit::walk_generics(self, g)\n-                    }\n-                }\n-                return\n-            }\n-\n-            // `type ... = ...;` can contain private types, because\n-            // we're introducing a new name.\n-            ast::ItemTy(..) => return,\n-\n-            // not at all public, so we don't care\n-            _ if !self.exported_items.contains(&item.id) => return,\n-\n-            _ => {}\n-        }\n-\n-        // we've carefully constructed it so that if we're here, then\n-        // any `visit_ty`'s will be called on things that are in\n-        // public signatures, i.e. things that we're interested in for\n-        // this visitor.\n-        visit::walk_item(self, item);\n-    }\n-\n-    fn visit_generics(&mut self, generics: &ast::Generics) {\n-        for ty_param in generics.ty_params.iter() {\n-            for bound in ty_param.bounds.iter() {\n-                self.check_ty_param_bound(bound)\n-            }\n-        }\n-        for predicate in generics.where_clause.predicates.iter() {\n-            match predicate {\n-                &ast::WherePredicate::BoundPredicate(ref bound_pred) => {\n-                    for bound in bound_pred.bounds.iter() {\n-                        self.check_ty_param_bound(bound)\n-                    }\n-                }\n-                &ast::WherePredicate::RegionPredicate(_) => {}\n-                &ast::WherePredicate::EqPredicate(ref eq_pred) => {\n-                    self.visit_ty(&*eq_pred.ty);\n-                }\n-            }\n-        }\n-    }\n-\n-    fn visit_foreign_item(&mut self, item: &ast::ForeignItem) {\n-        if self.exported_items.contains(&item.id) {\n-            visit::walk_foreign_item(self, item)\n-        }\n-    }\n-\n-    fn visit_fn(&mut self, fk: visit::FnKind<'v>, fd: &'v ast::FnDecl,\n-                b: &'v ast::Block, s: Span, id: ast::NodeId) {\n-        // needs special handling for methods.\n-        if self.exported_items.contains(&id) {\n-            visit::walk_fn(self, fk, fd, b, s);\n-        }\n-    }\n-\n-    fn visit_ty(&mut self, t: &ast::Ty) {\n-        if let ast::TyPath(ref p, path_id) = t.node {\n-            if !self.tcx.sess.features.borrow().visible_private_types &&\n-                self.path_is_private_type(path_id) {\n-                self.tcx.sess.span_err(p.span,\n-                                       \"private type in exported type signature\");\n-            }\n-        }\n-        visit::walk_ty(self, t)\n-    }\n-\n-    fn visit_variant(&mut self, v: &ast::Variant, g: &ast::Generics) {\n-        if self.exported_items.contains(&v.node.id) {\n-            self.in_variant = true;\n-            visit::walk_variant(self, v, g);\n-            self.in_variant = false;\n-        }\n-    }\n-\n-    fn visit_struct_field(&mut self, s: &ast::StructField) {\n-        match s.node.kind {\n-            ast::NamedField(_, vis) if vis == ast::Public || self.in_variant => {\n-                visit::walk_struct_field(self, s);\n-            }\n-            _ => {}\n-        }\n-    }\n-\n-\n-    // we don't need to introspect into these at all: an\n-    // expression/block context can't possibly contain exported\n-    // things, and neither do view_items. (Making them no-ops stops us\n-    // from traversing the whole AST without having to be super\n-    // careful about our `walk_...` calls above.)\n-    fn visit_view_item(&mut self, _: &ast::ViewItem) {}\n-    fn visit_block(&mut self, _: &ast::Block) {}\n-    fn visit_expr(&mut self, _: &ast::Expr) {}\n-}\n-\n-pub fn check_crate(tcx: &ty::ctxt,\n-                   export_map: &def::ExportMap,\n-                   external_exports: ExternalExports,\n-                   last_private_map: LastPrivateMap)\n-                   -> (ExportedItems, PublicItems) {\n-    let krate = tcx.map.krate();\n-\n-    // Figure out who everyone's parent is\n-    let mut visitor = ParentVisitor {\n-        parents: NodeMap::new(),\n-        curparent: ast::DUMMY_NODE_ID,\n-    };\n-    visit::walk_crate(&mut visitor, krate);\n-\n-    // Use the parent map to check the privacy of everything\n-    let mut visitor = PrivacyVisitor {\n-        curitem: ast::DUMMY_NODE_ID,\n-        in_foreign: false,\n-        tcx: tcx,\n-        parents: visitor.parents,\n-        external_exports: external_exports,\n-        last_private_map: last_private_map,\n-    };\n-    visit::walk_crate(&mut visitor, krate);\n-\n-    // Sanity check to make sure that all privacy usage and controls are\n-    // reasonable.\n-    let mut visitor = SanePrivacyVisitor {\n-        in_fn: false,\n-        tcx: tcx,\n-    };\n-    visit::walk_crate(&mut visitor, krate);\n-\n-    tcx.sess.abort_if_errors();\n-\n-    // Build up a set of all exported items in the AST. This is a set of all\n-    // items which are reachable from external crates based on visibility.\n-    let mut visitor = EmbargoVisitor {\n-        tcx: tcx,\n-        exported_items: NodeSet::new(),\n-        public_items: NodeSet::new(),\n-        reexports: NodeSet::new(),\n-        export_map: export_map,\n-        prev_exported: true,\n-        prev_public: true,\n-    };\n-    loop {\n-        let before = visitor.exported_items.len();\n-        visit::walk_crate(&mut visitor, krate);\n-        if before == visitor.exported_items.len() {\n-            break\n-        }\n-    }\n-\n-    let EmbargoVisitor { exported_items, public_items, .. } = visitor;\n-\n-    {\n-        let mut visitor = VisiblePrivateTypesVisitor {\n-            tcx: tcx,\n-            exported_items: &exported_items,\n-            public_items: &public_items,\n-            in_variant: false,\n-        };\n-        visit::walk_crate(&mut visitor, krate);\n-    }\n-    return (exported_items, public_items);\n-}"}, {"sha": "3fac5ba9674c3f95d66f0772469265719f068e2e", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a9decbdc443f120d1ca2efb1798bfc20bad7c2d4/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9decbdc443f120d1ca2efb1798bfc20bad7c2d4/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=a9decbdc443f120d1ca2efb1798bfc20bad7c2d4", "patch": "@@ -26,6 +26,7 @@ use rustc_trans::back::link;\n use rustc_trans::back::write;\n use rustc_trans::trans;\n use rustc_typeck as typeck;\n+use rustc_privacy;\n \n use serialize::json;\n \n@@ -630,7 +631,7 @@ pub fn phase_3_run_analysis_passes<'tcx>(sess: Session,\n     let maps = (external_exports, last_private_map);\n     let (exported_items, public_items) =\n             time(time_passes, \"privacy checking\", maps, |(a, b)|\n-                 middle::privacy::check_crate(&ty_cx, &export_map, a, b));\n+                 rustc_privacy::check_crate(&ty_cx, &export_map, a, b));\n \n     time(time_passes, \"intrinsic checking\", (), |_|\n          middle::intrinsicck::check_crate(&ty_cx));"}, {"sha": "5b6c64c1beea6148780d877d44e31b5e76df85b1", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a9decbdc443f120d1ca2efb1798bfc20bad7c2d4/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9decbdc443f120d1ca2efb1798bfc20bad7c2d4/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=a9decbdc443f120d1ca2efb1798bfc20bad7c2d4", "patch": "@@ -38,6 +38,7 @@ extern crate libc;\n extern crate rustc;\n extern crate rustc_back;\n extern crate rustc_borrowck;\n+extern crate rustc_privacy;\n extern crate rustc_resolve;\n extern crate rustc_trans;\n extern crate rustc_typeck;"}, {"sha": "85ca3b05d12c1f71432b3ecb0a0be717500e6467", "filename": "src/librustc_privacy/lib.rs", "status": "added", "additions": 1598, "deletions": 0, "changes": 1598, "blob_url": "https://github.com/rust-lang/rust/blob/a9decbdc443f120d1ca2efb1798bfc20bad7c2d4/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9decbdc443f120d1ca2efb1798bfc20bad7c2d4/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=a9decbdc443f120d1ca2efb1798bfc20bad7c2d4", "patch": "@@ -0,0 +1,1598 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![crate_name = \"rustc_privacy\"]\n+#![unstable]\n+#![staged_api]\n+#![crate_type = \"dylib\"]\n+#![crate_type = \"rlib\"]\n+#![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n+      html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n+      html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n+\n+#![feature(rustc_diagnostic_macros)]\n+#![allow(unknown_features)] #![feature(int_uint)]\n+\n+#[macro_use] extern crate log;\n+#[macro_use] extern crate syntax;\n+\n+extern crate rustc;\n+\n+use self::PrivacyResult::*;\n+use self::FieldName::*;\n+\n+use std::mem::replace;\n+\n+use rustc::metadata::csearch;\n+use rustc::middle::def;\n+use rustc::middle::privacy::ImportUse::*;\n+use rustc::middle::privacy::LastPrivate::*;\n+use rustc::middle::privacy::PrivateDep::*;\n+use rustc::middle::privacy::{ExportedItems, PublicItems, LastPrivateMap};\n+use rustc::middle::privacy::{ExternalExports};\n+use rustc::middle::ty::{MethodTypeParam, MethodStatic};\n+use rustc::middle::ty::{MethodCall, MethodMap, MethodOrigin, MethodParam};\n+use rustc::middle::ty::{MethodStaticUnboxedClosure, MethodObject};\n+use rustc::middle::ty::{MethodTraitObject};\n+use rustc::middle::ty::{self, Ty};\n+use rustc::util::nodemap::{NodeMap, NodeSet};\n+\n+use syntax::{ast, ast_map};\n+use syntax::ast_util::{is_local, local_def, PostExpansionMethod};\n+use syntax::codemap::Span;\n+use syntax::parse::token;\n+use syntax::visit::{self, Visitor};\n+\n+type Context<'a, 'tcx> = (&'a MethodMap<'tcx>, &'a def::ExportMap);\n+\n+/// Result of a checking operation - None => no errors were found. Some => an\n+/// error and contains the span and message for reporting that error and\n+/// optionally the same for a note about the error.\n+type CheckResult = Option<(Span, String, Option<(Span, String)>)>;\n+\n+////////////////////////////////////////////////////////////////////////////////\n+/// The parent visitor, used to determine what's the parent of what (node-wise)\n+////////////////////////////////////////////////////////////////////////////////\n+\n+struct ParentVisitor {\n+    parents: NodeMap<ast::NodeId>,\n+    curparent: ast::NodeId,\n+}\n+\n+impl<'v> Visitor<'v> for ParentVisitor {\n+    fn visit_item(&mut self, item: &ast::Item) {\n+        self.parents.insert(item.id, self.curparent);\n+\n+        let prev = self.curparent;\n+        match item.node {\n+            ast::ItemMod(..) => { self.curparent = item.id; }\n+            // Enum variants are parented to the enum definition itself because\n+            // they inherit privacy\n+            ast::ItemEnum(ref def, _) => {\n+                for variant in def.variants.iter() {\n+                    // The parent is considered the enclosing enum because the\n+                    // enum will dictate the privacy visibility of this variant\n+                    // instead.\n+                    self.parents.insert(variant.node.id, item.id);\n+                }\n+            }\n+\n+            // Trait methods are always considered \"public\", but if the trait is\n+            // private then we need some private item in the chain from the\n+            // method to the root. In this case, if the trait is private, then\n+            // parent all the methods to the trait to indicate that they're\n+            // private.\n+            ast::ItemTrait(_, _, _, ref methods) if item.vis != ast::Public => {\n+                for m in methods.iter() {\n+                    match *m {\n+                        ast::ProvidedMethod(ref m) => {\n+                            self.parents.insert(m.id, item.id);\n+                        }\n+                        ast::RequiredMethod(ref m) => {\n+                            self.parents.insert(m.id, item.id);\n+                        }\n+                        ast::TypeTraitItem(_) => {}\n+                    };\n+                }\n+            }\n+\n+            _ => {}\n+        }\n+        visit::walk_item(self, item);\n+        self.curparent = prev;\n+    }\n+\n+    fn visit_foreign_item(&mut self, a: &ast::ForeignItem) {\n+        self.parents.insert(a.id, self.curparent);\n+        visit::walk_foreign_item(self, a);\n+    }\n+\n+    fn visit_fn(&mut self, a: visit::FnKind<'v>, b: &'v ast::FnDecl,\n+                c: &'v ast::Block, d: Span, id: ast::NodeId) {\n+        // We already took care of some trait methods above, otherwise things\n+        // like impl methods and pub trait methods are parented to the\n+        // containing module, not the containing trait.\n+        if !self.parents.contains_key(&id) {\n+            self.parents.insert(id, self.curparent);\n+        }\n+        visit::walk_fn(self, a, b, c, d);\n+    }\n+\n+    fn visit_struct_def(&mut self, s: &ast::StructDef, _: ast::Ident,\n+                        _: &'v ast::Generics, n: ast::NodeId) {\n+        // Struct constructors are parented to their struct definitions because\n+        // they essentially are the struct definitions.\n+        match s.ctor_id {\n+            Some(id) => { self.parents.insert(id, n); }\n+            None => {}\n+        }\n+\n+        // While we have the id of the struct definition, go ahead and parent\n+        // all the fields.\n+        for field in s.fields.iter() {\n+            self.parents.insert(field.node.id, self.curparent);\n+        }\n+        visit::walk_struct_def(self, s)\n+    }\n+}\n+\n+////////////////////////////////////////////////////////////////////////////////\n+/// The embargo visitor, used to determine the exports of the ast\n+////////////////////////////////////////////////////////////////////////////////\n+\n+struct EmbargoVisitor<'a, 'tcx: 'a> {\n+    tcx: &'a ty::ctxt<'tcx>,\n+    export_map: &'a def::ExportMap,\n+\n+    // This flag is an indicator of whether the previous item in the\n+    // hierarchical chain was exported or not. This is the indicator of whether\n+    // children should be exported as well. Note that this can flip from false\n+    // to true if a reexported module is entered (or an action similar).\n+    prev_exported: bool,\n+\n+    // This is a list of all exported items in the AST. An exported item is any\n+    // function/method/item which is usable by external crates. This essentially\n+    // means that the result is \"public all the way down\", but the \"path down\"\n+    // may jump across private boundaries through reexport statements.\n+    exported_items: ExportedItems,\n+\n+    // This sets contains all the destination nodes which are publicly\n+    // re-exported. This is *not* a set of all reexported nodes, only a set of\n+    // all nodes which are reexported *and* reachable from external crates. This\n+    // means that the destination of the reexport is exported, and hence the\n+    // destination must also be exported.\n+    reexports: NodeSet,\n+\n+    // These two fields are closely related to one another in that they are only\n+    // used for generation of the 'PublicItems' set, not for privacy checking at\n+    // all\n+    public_items: PublicItems,\n+    prev_public: bool,\n+}\n+\n+impl<'a, 'tcx> EmbargoVisitor<'a, 'tcx> {\n+    // There are checks inside of privacy which depend on knowing whether a\n+    // trait should be exported or not. The two current consumers of this are:\n+    //\n+    //  1. Should default methods of a trait be exported?\n+    //  2. Should the methods of an implementation of a trait be exported?\n+    //\n+    // The answer to both of these questions partly rely on whether the trait\n+    // itself is exported or not. If the trait is somehow exported, then the\n+    // answers to both questions must be yes. Right now this question involves\n+    // more analysis than is currently done in rustc, so we conservatively\n+    // answer \"yes\" so that all traits need to be exported.\n+    fn exported_trait(&self, _id: ast::NodeId) -> bool {\n+        true\n+    }\n+}\n+\n+impl<'a, 'tcx, 'v> Visitor<'v> for EmbargoVisitor<'a, 'tcx> {\n+    fn visit_item(&mut self, item: &ast::Item) {\n+        let orig_all_pub = self.prev_public;\n+        self.prev_public = orig_all_pub && item.vis == ast::Public;\n+        if self.prev_public {\n+            self.public_items.insert(item.id);\n+        }\n+\n+        let orig_all_exported = self.prev_exported;\n+        match item.node {\n+            // impls/extern blocks do not break the \"public chain\" because they\n+            // cannot have visibility qualifiers on them anyway\n+            ast::ItemImpl(..) | ast::ItemForeignMod(..) => {}\n+\n+            // Traits are a little special in that even if they themselves are\n+            // not public they may still be exported.\n+            ast::ItemTrait(..) => {\n+                self.prev_exported = self.exported_trait(item.id);\n+            }\n+\n+            // Private by default, hence we only retain the \"public chain\" if\n+            // `pub` is explicitly listed.\n+            _ => {\n+                self.prev_exported =\n+                    (orig_all_exported && item.vis == ast::Public) ||\n+                     self.reexports.contains(&item.id);\n+            }\n+        }\n+\n+        let public_first = self.prev_exported &&\n+                           self.exported_items.insert(item.id);\n+\n+        match item.node {\n+            // Enum variants inherit from their parent, so if the enum is\n+            // public all variants are public unless they're explicitly priv\n+            ast::ItemEnum(ref def, _) if public_first => {\n+                for variant in def.variants.iter() {\n+                    self.exported_items.insert(variant.node.id);\n+                }\n+            }\n+\n+            // Implementations are a little tricky to determine what's exported\n+            // out of them. Here's a few cases which are currently defined:\n+            //\n+            // * Impls for private types do not need to export their methods\n+            //   (either public or private methods)\n+            //\n+            // * Impls for public types only have public methods exported\n+            //\n+            // * Public trait impls for public types must have all methods\n+            //   exported.\n+            //\n+            // * Private trait impls for public types can be ignored\n+            //\n+            // * Public trait impls for private types have their methods\n+            //   exported. I'm not entirely certain that this is the correct\n+            //   thing to do, but I have seen use cases of where this will cause\n+            //   undefined symbols at linkage time if this case is not handled.\n+            //\n+            // * Private trait impls for private types can be completely ignored\n+            ast::ItemImpl(_, _, _, _, ref ty, ref impl_items) => {\n+                let public_ty = match ty.node {\n+                    ast::TyPath(_, id) => {\n+                        match self.tcx.def_map.borrow()[id].clone() {\n+                            def::DefPrimTy(..) => true,\n+                            def => {\n+                                let did = def.def_id();\n+                                !is_local(did) ||\n+                                 self.exported_items.contains(&did.node)\n+                            }\n+                        }\n+                    }\n+                    _ => true,\n+                };\n+                let tr = ty::impl_trait_ref(self.tcx, local_def(item.id));\n+                let public_trait = tr.clone().map_or(false, |tr| {\n+                    !is_local(tr.def_id) ||\n+                     self.exported_items.contains(&tr.def_id.node)\n+                });\n+\n+                if public_ty || public_trait {\n+                    for impl_item in impl_items.iter() {\n+                        match *impl_item {\n+                            ast::MethodImplItem(ref method) => {\n+                                let meth_public =\n+                                    match method.pe_explicit_self().node {\n+                                        ast::SelfStatic => public_ty,\n+                                        _ => true,\n+                                    } && method.pe_vis() == ast::Public;\n+                                if meth_public || tr.is_some() {\n+                                    self.exported_items.insert(method.id);\n+                                }\n+                            }\n+                            ast::TypeImplItem(_) => {}\n+                        }\n+                    }\n+                }\n+            }\n+\n+            // Default methods on traits are all public so long as the trait\n+            // is public\n+            ast::ItemTrait(_, _, _, ref methods) if public_first => {\n+                for method in methods.iter() {\n+                    match *method {\n+                        ast::ProvidedMethod(ref m) => {\n+                            debug!(\"provided {}\", m.id);\n+                            self.exported_items.insert(m.id);\n+                        }\n+                        ast::RequiredMethod(ref m) => {\n+                            debug!(\"required {}\", m.id);\n+                            self.exported_items.insert(m.id);\n+                        }\n+                        ast::TypeTraitItem(ref t) => {\n+                            debug!(\"typedef {}\", t.ty_param.id);\n+                            self.exported_items.insert(t.ty_param.id);\n+                        }\n+                    }\n+                }\n+            }\n+\n+            // Struct constructors are public if the struct is all public.\n+            ast::ItemStruct(ref def, _) if public_first => {\n+                match def.ctor_id {\n+                    Some(id) => { self.exported_items.insert(id); }\n+                    None => {}\n+                }\n+            }\n+\n+            ast::ItemTy(ref ty, _) if public_first => {\n+                if let ast::TyPath(_, id) = ty.node {\n+                    match self.tcx.def_map.borrow()[id].clone() {\n+                        def::DefPrimTy(..) | def::DefTyParam(..) => {},\n+                        def => {\n+                            let did = def.def_id();\n+                            if is_local(did) {\n+                                self.exported_items.insert(did.node);\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+\n+            _ => {}\n+        }\n+\n+        visit::walk_item(self, item);\n+\n+        self.prev_exported = orig_all_exported;\n+        self.prev_public = orig_all_pub;\n+    }\n+\n+    fn visit_foreign_item(&mut self, a: &ast::ForeignItem) {\n+        if (self.prev_exported && a.vis == ast::Public) || self.reexports.contains(&a.id) {\n+            self.exported_items.insert(a.id);\n+        }\n+    }\n+\n+    fn visit_mod(&mut self, m: &ast::Mod, _sp: Span, id: ast::NodeId) {\n+        // This code is here instead of in visit_item so that the\n+        // crate module gets processed as well.\n+        if self.prev_exported {\n+            assert!(self.export_map.contains_key(&id), \"wut {}\", id);\n+            for export in self.export_map[id].iter() {\n+                if is_local(export.def_id) {\n+                    self.reexports.insert(export.def_id.node);\n+                }\n+            }\n+        }\n+        visit::walk_mod(self, m)\n+    }\n+}\n+\n+////////////////////////////////////////////////////////////////////////////////\n+/// The privacy visitor, where privacy checks take place (violations reported)\n+////////////////////////////////////////////////////////////////////////////////\n+\n+struct PrivacyVisitor<'a, 'tcx: 'a> {\n+    tcx: &'a ty::ctxt<'tcx>,\n+    curitem: ast::NodeId,\n+    in_foreign: bool,\n+    parents: NodeMap<ast::NodeId>,\n+    external_exports: ExternalExports,\n+    last_private_map: LastPrivateMap,\n+}\n+\n+enum PrivacyResult {\n+    Allowable,\n+    ExternallyDenied,\n+    DisallowedBy(ast::NodeId),\n+}\n+\n+enum FieldName {\n+    UnnamedField(uint), // index\n+    // FIXME #6993: change type (and name) from Ident to Name\n+    NamedField(ast::Ident),\n+}\n+\n+impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n+    // used when debugging\n+    fn nodestr(&self, id: ast::NodeId) -> String {\n+        self.tcx.map.node_to_string(id).to_string()\n+    }\n+\n+    // Determines whether the given definition is public from the point of view\n+    // of the current item.\n+    fn def_privacy(&self, did: ast::DefId) -> PrivacyResult {\n+        if !is_local(did) {\n+            if self.external_exports.contains(&did) {\n+                debug!(\"privacy - {:?} was externally exported\", did);\n+                return Allowable;\n+            }\n+            debug!(\"privacy - is {:?} a public method\", did);\n+\n+            return match self.tcx.impl_or_trait_items.borrow().get(&did) {\n+                Some(&ty::MethodTraitItem(ref meth)) => {\n+                    debug!(\"privacy - well at least it's a method: {:?}\",\n+                           *meth);\n+                    match meth.container {\n+                        ty::TraitContainer(id) => {\n+                            debug!(\"privacy - recursing on trait {:?}\", id);\n+                            self.def_privacy(id)\n+                        }\n+                        ty::ImplContainer(id) => {\n+                            match ty::impl_trait_ref(self.tcx, id) {\n+                                Some(t) => {\n+                                    debug!(\"privacy - impl of trait {:?}\", id);\n+                                    self.def_privacy(t.def_id)\n+                                }\n+                                None => {\n+                                    debug!(\"privacy - found a method {:?}\",\n+                                            meth.vis);\n+                                    if meth.vis == ast::Public {\n+                                        Allowable\n+                                    } else {\n+                                        ExternallyDenied\n+                                    }\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+                Some(&ty::TypeTraitItem(ref typedef)) => {\n+                    match typedef.container {\n+                        ty::TraitContainer(id) => {\n+                            debug!(\"privacy - recursing on trait {:?}\", id);\n+                            self.def_privacy(id)\n+                        }\n+                        ty::ImplContainer(id) => {\n+                            match ty::impl_trait_ref(self.tcx, id) {\n+                                Some(t) => {\n+                                    debug!(\"privacy - impl of trait {:?}\", id);\n+                                    self.def_privacy(t.def_id)\n+                                }\n+                                None => {\n+                                    debug!(\"privacy - found a typedef {:?}\",\n+                                            typedef.vis);\n+                                    if typedef.vis == ast::Public {\n+                                        Allowable\n+                                    } else {\n+                                        ExternallyDenied\n+                                    }\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+                None => {\n+                    debug!(\"privacy - nope, not even a method\");\n+                    ExternallyDenied\n+                }\n+            };\n+        }\n+\n+        debug!(\"privacy - local {} not public all the way down\",\n+               self.tcx.map.node_to_string(did.node));\n+        // return quickly for things in the same module\n+        if self.parents.get(&did.node) == self.parents.get(&self.curitem) {\n+            debug!(\"privacy - same parent, we're done here\");\n+            return Allowable;\n+        }\n+\n+        // We now know that there is at least one private member between the\n+        // destination and the root.\n+        let mut closest_private_id = did.node;\n+        loop {\n+            debug!(\"privacy - examining {}\", self.nodestr(closest_private_id));\n+            let vis = match self.tcx.map.find(closest_private_id) {\n+                // If this item is a method, then we know for sure that it's an\n+                // actual method and not a static method. The reason for this is\n+                // that these cases are only hit in the ExprMethodCall\n+                // expression, and ExprCall will have its path checked later\n+                // (the path of the trait/impl) if it's a static method.\n+                //\n+                // With this information, then we can completely ignore all\n+                // trait methods. The privacy violation would be if the trait\n+                // couldn't get imported, not if the method couldn't be used\n+                // (all trait methods are public).\n+                //\n+                // However, if this is an impl method, then we dictate this\n+                // decision solely based on the privacy of the method\n+                // invocation.\n+                // FIXME(#10573) is this the right behavior? Why not consider\n+                //               where the method was defined?\n+                Some(ast_map::NodeImplItem(ii)) => {\n+                    match *ii {\n+                        ast::MethodImplItem(ref m) => {\n+                            let imp = self.tcx.map\n+                                          .get_parent_did(closest_private_id);\n+                            match ty::impl_trait_ref(self.tcx, imp) {\n+                                Some(..) => return Allowable,\n+                                _ if m.pe_vis() == ast::Public => {\n+                                    return Allowable\n+                                }\n+                                _ => m.pe_vis()\n+                            }\n+                        }\n+                        ast::TypeImplItem(_) => return Allowable,\n+                    }\n+                }\n+                Some(ast_map::NodeTraitItem(_)) => {\n+                    return Allowable;\n+                }\n+\n+                // This is not a method call, extract the visibility as one\n+                // would normally look at it\n+                Some(ast_map::NodeItem(it)) => it.vis,\n+                Some(ast_map::NodeForeignItem(_)) => {\n+                    self.tcx.map.get_foreign_vis(closest_private_id)\n+                }\n+                Some(ast_map::NodeVariant(..)) => {\n+                    ast::Public // need to move up a level (to the enum)\n+                }\n+                _ => ast::Public,\n+            };\n+            if vis != ast::Public { break }\n+            // if we've reached the root, then everything was allowable and this\n+            // access is public.\n+            if closest_private_id == ast::CRATE_NODE_ID { return Allowable }\n+            closest_private_id = self.parents[closest_private_id];\n+\n+            // If we reached the top, then we were public all the way down and\n+            // we can allow this access.\n+            if closest_private_id == ast::DUMMY_NODE_ID { return Allowable }\n+        }\n+        debug!(\"privacy - closest priv {}\", self.nodestr(closest_private_id));\n+        if self.private_accessible(closest_private_id) {\n+            Allowable\n+        } else {\n+            DisallowedBy(closest_private_id)\n+        }\n+    }\n+\n+    /// For a local private node in the AST, this function will determine\n+    /// whether the node is accessible by the current module that iteration is\n+    /// inside.\n+    fn private_accessible(&self, id: ast::NodeId) -> bool {\n+        let parent = self.parents[id];\n+        debug!(\"privacy - accessible parent {}\", self.nodestr(parent));\n+\n+        // After finding `did`'s closest private member, we roll ourselves back\n+        // to see if this private member's parent is anywhere in our ancestry.\n+        // By the privacy rules, we can access all of our ancestor's private\n+        // members, so that's why we test the parent, and not the did itself.\n+        let mut cur = self.curitem;\n+        loop {\n+            debug!(\"privacy - questioning {}, {}\", self.nodestr(cur), cur);\n+            match cur {\n+                // If the relevant parent is in our history, then we're allowed\n+                // to look inside any of our ancestor's immediate private items,\n+                // so this access is valid.\n+                x if x == parent => return true,\n+\n+                // If we've reached the root, then we couldn't access this item\n+                // in the first place\n+                ast::DUMMY_NODE_ID => return false,\n+\n+                // Keep going up\n+                _ => {}\n+            }\n+\n+            cur = self.parents[cur];\n+        }\n+    }\n+\n+    fn report_error(&self, result: CheckResult) -> bool {\n+        match result {\n+            None => true,\n+            Some((span, msg, note)) => {\n+                self.tcx.sess.span_err(span, &msg[]);\n+                match note {\n+                    Some((span, msg)) => {\n+                        self.tcx.sess.span_note(span, &msg[])\n+                    }\n+                    None => {},\n+                }\n+                false\n+            },\n+        }\n+    }\n+\n+    /// Guarantee that a particular definition is public. Returns a CheckResult\n+    /// which contains any errors found. These can be reported using `report_error`.\n+    /// If the result is `None`, no errors were found.\n+    fn ensure_public(&self, span: Span, to_check: ast::DefId,\n+                     source_did: Option<ast::DefId>, msg: &str) -> CheckResult {\n+        let id = match self.def_privacy(to_check) {\n+            ExternallyDenied => {\n+                return Some((span, format!(\"{} is private\", msg), None))\n+            }\n+            Allowable => return None,\n+            DisallowedBy(id) => id,\n+        };\n+\n+        // If we're disallowed by a particular id, then we attempt to give a\n+        // nice error message to say why it was disallowed. It was either\n+        // because the item itself is private or because its parent is private\n+        // and its parent isn't in our ancestry.\n+        let (err_span, err_msg) = if id == source_did.unwrap_or(to_check).node {\n+            return Some((span, format!(\"{} is private\", msg), None));\n+        } else {\n+            (span, format!(\"{} is inaccessible\", msg))\n+        };\n+        let item = match self.tcx.map.find(id) {\n+            Some(ast_map::NodeItem(item)) => {\n+                match item.node {\n+                    // If an impl disallowed this item, then this is resolve's\n+                    // way of saying that a struct/enum's static method was\n+                    // invoked, and the struct/enum itself is private. Crawl\n+                    // back up the chains to find the relevant struct/enum that\n+                    // was private.\n+                    ast::ItemImpl(_, _, _, _, ref ty, _) => {\n+                        let id = match ty.node {\n+                            ast::TyPath(_, id) => id,\n+                            _ => return Some((err_span, err_msg, None)),\n+                        };\n+                        let def = self.tcx.def_map.borrow()[id].clone();\n+                        let did = def.def_id();\n+                        assert!(is_local(did));\n+                        match self.tcx.map.get(did.node) {\n+                            ast_map::NodeItem(item) => item,\n+                            _ => self.tcx.sess.span_bug(item.span,\n+                                                        \"path is not an item\")\n+                        }\n+                    }\n+                    _ => item\n+                }\n+            }\n+            Some(..) | None => return Some((err_span, err_msg, None)),\n+        };\n+        let desc = match item.node {\n+            ast::ItemMod(..) => \"module\",\n+            ast::ItemTrait(..) => \"trait\",\n+            ast::ItemStruct(..) => \"struct\",\n+            ast::ItemEnum(..) => \"enum\",\n+            _ => return Some((err_span, err_msg, None))\n+        };\n+        let msg = format!(\"{} `{}` is private\", desc,\n+                          token::get_ident(item.ident));\n+        Some((err_span, err_msg, Some((span, msg))))\n+    }\n+\n+    // Checks that a field is in scope.\n+    fn check_field(&mut self,\n+                   span: Span,\n+                   id: ast::DefId,\n+                   name: FieldName) {\n+        let fields = ty::lookup_struct_fields(self.tcx, id);\n+        let field = match name {\n+            NamedField(ident) => {\n+                debug!(\"privacy - check named field {} in struct {:?}\", ident.name, id);\n+                fields.iter().find(|f| f.name == ident.name).unwrap()\n+            }\n+            UnnamedField(idx) => &fields[idx]\n+        };\n+        if field.vis == ast::Public ||\n+            (is_local(field.id) && self.private_accessible(field.id.node)) {\n+            return\n+        }\n+\n+        let struct_type = ty::lookup_item_type(self.tcx, id).ty;\n+        let struct_desc = match struct_type.sty {\n+            ty::ty_struct(_, _) =>\n+                format!(\"struct `{}`\", ty::item_path_str(self.tcx, id)),\n+            // struct variant fields have inherited visibility\n+            ty::ty_enum(..) => return,\n+            _ => self.tcx.sess.span_bug(span, \"can't find struct for field\")\n+        };\n+        let msg = match name {\n+            NamedField(name) => format!(\"field `{}` of {} is private\",\n+                                        token::get_ident(name), struct_desc),\n+            UnnamedField(idx) => format!(\"field #{} of {} is private\",\n+                                         idx + 1, struct_desc),\n+        };\n+        self.tcx.sess.span_err(span, &msg[]);\n+    }\n+\n+    // Given the ID of a method, checks to ensure it's in scope.\n+    fn check_static_method(&mut self,\n+                           span: Span,\n+                           method_id: ast::DefId,\n+                           name: ast::Ident) {\n+        // If the method is a default method, we need to use the def_id of\n+        // the default implementation.\n+        let method_id = match ty::impl_or_trait_item(self.tcx, method_id) {\n+            ty::MethodTraitItem(method_type) => {\n+                method_type.provided_source.unwrap_or(method_id)\n+            }\n+            ty::TypeTraitItem(_) => method_id,\n+        };\n+\n+        let string = token::get_ident(name);\n+        self.report_error(self.ensure_public(span,\n+                                             method_id,\n+                                             None,\n+                                             &format!(\"method `{}`\",\n+                                                     string)[]));\n+    }\n+\n+    // Checks that a path is in scope.\n+    fn check_path(&mut self, span: Span, path_id: ast::NodeId, path: &ast::Path) {\n+        debug!(\"privacy - path {}\", self.nodestr(path_id));\n+        let orig_def = self.tcx.def_map.borrow()[path_id].clone();\n+        let ck = |&: tyname: &str| {\n+            let ck_public = |&: def: ast::DefId| {\n+                debug!(\"privacy - ck_public {:?}\", def);\n+                let name = token::get_ident(path.segments.last().unwrap().identifier);\n+                let origdid = orig_def.def_id();\n+                self.ensure_public(span,\n+                                   def,\n+                                   Some(origdid),\n+                                   &format!(\"{} `{}`\", tyname, name)[])\n+            };\n+\n+            match self.last_private_map[path_id] {\n+                LastMod(AllPublic) => {},\n+                LastMod(DependsOn(def)) => {\n+                    self.report_error(ck_public(def));\n+                },\n+                LastImport { value_priv,\n+                             value_used: check_value,\n+                             type_priv,\n+                             type_used: check_type } => {\n+                    // This dance with found_error is because we don't want to\n+                    // report a privacy error twice for the same directive.\n+                    let found_error = match (type_priv, check_type) {\n+                        (Some(DependsOn(def)), Used) => {\n+                            !self.report_error(ck_public(def))\n+                        },\n+                        _ => false,\n+                    };\n+                    if !found_error {\n+                        match (value_priv, check_value) {\n+                            (Some(DependsOn(def)), Used) => {\n+                                self.report_error(ck_public(def));\n+                            },\n+                            _ => {},\n+                        }\n+                    }\n+                    // If an import is not used in either namespace, we still\n+                    // want to check that it could be legal. Therefore we check\n+                    // in both namespaces and only report an error if both would\n+                    // be illegal. We only report one error, even if it is\n+                    // illegal to import from both namespaces.\n+                    match (value_priv, check_value, type_priv, check_type) {\n+                        (Some(p), Unused, None, _) |\n+                        (None, _, Some(p), Unused) => {\n+                            let p = match p {\n+                                AllPublic => None,\n+                                DependsOn(def) => ck_public(def),\n+                            };\n+                            if p.is_some() {\n+                                self.report_error(p);\n+                            }\n+                        },\n+                        (Some(v), Unused, Some(t), Unused) => {\n+                            let v = match v {\n+                                AllPublic => None,\n+                                DependsOn(def) => ck_public(def),\n+                            };\n+                            let t = match t {\n+                                AllPublic => None,\n+                                DependsOn(def) => ck_public(def),\n+                            };\n+                            if let (Some(_), Some(t)) = (v, t) {\n+                                self.report_error(Some(t));\n+                            }\n+                        },\n+                        _ => {},\n+                    }\n+                },\n+            }\n+        };\n+        // FIXME(#12334) Imports can refer to definitions in both the type and\n+        // value namespaces. The privacy information is aware of this, but the\n+        // def map is not. Therefore the names we work out below will not always\n+        // be accurate and we can get slightly wonky error messages (but type\n+        // checking is always correct).\n+        match self.tcx.def_map.borrow()[path_id].clone() {\n+            def::DefStaticMethod(..) => ck(\"static method\"),\n+            def::DefFn(..) => ck(\"function\"),\n+            def::DefStatic(..) => ck(\"static\"),\n+            def::DefConst(..) => ck(\"const\"),\n+            def::DefVariant(..) => ck(\"variant\"),\n+            def::DefTy(_, false) => ck(\"type\"),\n+            def::DefTy(_, true) => ck(\"enum\"),\n+            def::DefTrait(..) => ck(\"trait\"),\n+            def::DefStruct(..) => ck(\"struct\"),\n+            def::DefMethod(_, Some(..), _) => ck(\"trait method\"),\n+            def::DefMethod(..) => ck(\"method\"),\n+            def::DefMod(..) => ck(\"module\"),\n+            _ => {}\n+        }\n+    }\n+\n+    // Checks that a method is in scope.\n+    fn check_method(&mut self, span: Span, origin: &MethodOrigin,\n+                    ident: ast::Ident) {\n+        match *origin {\n+            MethodStatic(method_id) => {\n+                self.check_static_method(span, method_id, ident)\n+            }\n+            MethodStaticUnboxedClosure(_) => {}\n+            // Trait methods are always all public. The only controlling factor\n+            // is whether the trait itself is accessible or not.\n+            MethodTypeParam(MethodParam { ref trait_ref, .. }) |\n+            MethodTraitObject(MethodObject { ref trait_ref, .. }) => {\n+                self.report_error(self.ensure_public(span, trait_ref.def_id,\n+                                                     None, \"source trait\"));\n+            }\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n+    fn visit_item(&mut self, item: &ast::Item) {\n+        let orig_curitem = replace(&mut self.curitem, item.id);\n+        visit::walk_item(self, item);\n+        self.curitem = orig_curitem;\n+    }\n+\n+    fn visit_expr(&mut self, expr: &ast::Expr) {\n+        match expr.node {\n+            ast::ExprField(ref base, ident) => {\n+                if let ty::ty_struct(id, _) = ty::expr_ty_adjusted(self.tcx, &**base).sty {\n+                    self.check_field(expr.span, id, NamedField(ident.node));\n+                }\n+            }\n+            ast::ExprTupField(ref base, idx) => {\n+                if let ty::ty_struct(id, _) = ty::expr_ty_adjusted(self.tcx, &**base).sty {\n+                    self.check_field(expr.span, id, UnnamedField(idx.node));\n+                }\n+            }\n+            ast::ExprMethodCall(ident, _, _) => {\n+                let method_call = MethodCall::expr(expr.id);\n+                match self.tcx.method_map.borrow().get(&method_call) {\n+                    None => {\n+                        self.tcx.sess.span_bug(expr.span,\n+                                                \"method call not in \\\n+                                                method map\");\n+                    }\n+                    Some(method) => {\n+                        debug!(\"(privacy checking) checking impl method\");\n+                        self.check_method(expr.span, &method.origin, ident.node);\n+                    }\n+                }\n+            }\n+            ast::ExprStruct(_, ref fields, _) => {\n+                match ty::expr_ty(self.tcx, expr).sty {\n+                    ty::ty_struct(id, _) => {\n+                        for field in (*fields).iter() {\n+                            self.check_field(expr.span, id,\n+                                             NamedField(field.ident.node));\n+                        }\n+                    }\n+                    ty::ty_enum(_, _) => {\n+                        match self.tcx.def_map.borrow()[expr.id].clone() {\n+                            def::DefVariant(_, variant_id, _) => {\n+                                for field in fields.iter() {\n+                                    self.check_field(expr.span, variant_id,\n+                                                     NamedField(field.ident.node));\n+                                }\n+                            }\n+                            _ => self.tcx.sess.span_bug(expr.span,\n+                                                        \"resolve didn't \\\n+                                                         map enum struct \\\n+                                                         constructor to a \\\n+                                                         variant def\"),\n+                        }\n+                    }\n+                    _ => self.tcx.sess.span_bug(expr.span, \"struct expr \\\n+                                                            didn't have \\\n+                                                            struct type?!\"),\n+                }\n+            }\n+            ast::ExprPath(..) => {\n+                let guard = |&: did: ast::DefId| {\n+                    let fields = ty::lookup_struct_fields(self.tcx, did);\n+                    let any_priv = fields.iter().any(|f| {\n+                        f.vis != ast::Public && (\n+                            !is_local(f.id) ||\n+                            !self.private_accessible(f.id.node))\n+                    });\n+                    if any_priv {\n+                        self.tcx.sess.span_err(expr.span,\n+                            \"cannot invoke tuple struct constructor \\\n+                             with private fields\");\n+                    }\n+                };\n+                match self.tcx.def_map.borrow().get(&expr.id) {\n+                    Some(&def::DefStruct(did)) => {\n+                        guard(if is_local(did) {\n+                            local_def(self.tcx.map.get_parent(did.node))\n+                        } else {\n+                            // \"tuple structs\" with zero fields (such as\n+                            // `pub struct Foo;`) don't have a ctor_id, hence\n+                            // the unwrap_or to the same struct id.\n+                            let maybe_did =\n+                                csearch::get_tuple_struct_definition_if_ctor(\n+                                    &self.tcx.sess.cstore, did);\n+                            maybe_did.unwrap_or(did)\n+                        })\n+                    }\n+                    _ => {}\n+                }\n+            }\n+            _ => {}\n+        }\n+\n+        visit::walk_expr(self, expr);\n+    }\n+\n+    fn visit_view_item(&mut self, a: &ast::ViewItem) {\n+        match a.node {\n+            ast::ViewItemExternCrate(..) => {}\n+            ast::ViewItemUse(ref vpath) => {\n+                match vpath.node {\n+                    ast::ViewPathSimple(..) | ast::ViewPathGlob(..) => {}\n+                    ast::ViewPathList(ref prefix, ref list, _) => {\n+                        for pid in list.iter() {\n+                            match pid.node {\n+                                ast::PathListIdent { id, name } => {\n+                                    debug!(\"privacy - ident item {}\", id);\n+                                    let seg = ast::PathSegment {\n+                                        identifier: name,\n+                                        parameters: ast::PathParameters::none(),\n+                                    };\n+                                    let segs = vec![seg];\n+                                    let path = ast::Path {\n+                                        global: false,\n+                                        span: pid.span,\n+                                        segments: segs,\n+                                    };\n+                                    self.check_path(pid.span, id, &path);\n+                                }\n+                                ast::PathListMod { id } => {\n+                                    debug!(\"privacy - mod item {}\", id);\n+                                    self.check_path(pid.span, id, prefix);\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+        visit::walk_view_item(self, a);\n+    }\n+\n+    fn visit_pat(&mut self, pattern: &ast::Pat) {\n+        // Foreign functions do not have their patterns mapped in the def_map,\n+        // and there's nothing really relevant there anyway, so don't bother\n+        // checking privacy. If you can name the type then you can pass it to an\n+        // external C function anyway.\n+        if self.in_foreign { return }\n+\n+        match pattern.node {\n+            ast::PatStruct(_, ref fields, _) => {\n+                match ty::pat_ty(self.tcx, pattern).sty {\n+                    ty::ty_struct(id, _) => {\n+                        for field in fields.iter() {\n+                            self.check_field(pattern.span, id,\n+                                             NamedField(field.node.ident));\n+                        }\n+                    }\n+                    ty::ty_enum(_, _) => {\n+                        match self.tcx.def_map.borrow().get(&pattern.id) {\n+                            Some(&def::DefVariant(_, variant_id, _)) => {\n+                                for field in fields.iter() {\n+                                    self.check_field(pattern.span, variant_id,\n+                                                     NamedField(field.node.ident));\n+                                }\n+                            }\n+                            _ => self.tcx.sess.span_bug(pattern.span,\n+                                                        \"resolve didn't \\\n+                                                         map enum struct \\\n+                                                         pattern to a \\\n+                                                         variant def\"),\n+                        }\n+                    }\n+                    _ => self.tcx.sess.span_bug(pattern.span,\n+                                                \"struct pattern didn't have \\\n+                                                 struct type?!\"),\n+                }\n+            }\n+\n+            // Patterns which bind no fields are allowable (the path is check\n+            // elsewhere).\n+            ast::PatEnum(_, Some(ref fields)) => {\n+                match ty::pat_ty(self.tcx, pattern).sty {\n+                    ty::ty_struct(id, _) => {\n+                        for (i, field) in fields.iter().enumerate() {\n+                            if let ast::PatWild(..) = field.node {\n+                                continue\n+                            }\n+                            self.check_field(field.span, id, UnnamedField(i));\n+                        }\n+                    }\n+                    ty::ty_enum(..) => {\n+                        // enum fields have no privacy at this time\n+                    }\n+                    _ => {}\n+                }\n+\n+            }\n+            _ => {}\n+        }\n+\n+        visit::walk_pat(self, pattern);\n+    }\n+\n+    fn visit_foreign_item(&mut self, fi: &ast::ForeignItem) {\n+        self.in_foreign = true;\n+        visit::walk_foreign_item(self, fi);\n+        self.in_foreign = false;\n+    }\n+\n+    fn visit_path(&mut self, path: &ast::Path, id: ast::NodeId) {\n+        self.check_path(path.span, id, path);\n+        visit::walk_path(self, path);\n+    }\n+}\n+\n+////////////////////////////////////////////////////////////////////////////////\n+/// The privacy sanity check visitor, ensures unnecessary visibility isn't here\n+////////////////////////////////////////////////////////////////////////////////\n+\n+struct SanePrivacyVisitor<'a, 'tcx: 'a> {\n+    tcx: &'a ty::ctxt<'tcx>,\n+    in_fn: bool,\n+}\n+\n+impl<'a, 'tcx, 'v> Visitor<'v> for SanePrivacyVisitor<'a, 'tcx> {\n+    fn visit_item(&mut self, item: &ast::Item) {\n+        if self.in_fn {\n+            self.check_all_inherited(item);\n+        } else {\n+            self.check_sane_privacy(item);\n+        }\n+\n+        let in_fn = self.in_fn;\n+        let orig_in_fn = replace(&mut self.in_fn, match item.node {\n+            ast::ItemMod(..) => false, // modules turn privacy back on\n+            _ => in_fn,           // otherwise we inherit\n+        });\n+        visit::walk_item(self, item);\n+        self.in_fn = orig_in_fn;\n+    }\n+\n+    fn visit_fn(&mut self, fk: visit::FnKind<'v>, fd: &'v ast::FnDecl,\n+                b: &'v ast::Block, s: Span, _: ast::NodeId) {\n+        // This catches both functions and methods\n+        let orig_in_fn = replace(&mut self.in_fn, true);\n+        visit::walk_fn(self, fk, fd, b, s);\n+        self.in_fn = orig_in_fn;\n+    }\n+\n+    fn visit_view_item(&mut self, i: &ast::ViewItem) {\n+        match i.vis {\n+            ast::Inherited => {}\n+            ast::Public => {\n+                if self.in_fn {\n+                    self.tcx.sess.span_err(i.span, \"unnecessary `pub`, imports \\\n+                                                    in functions are never \\\n+                                                    reachable\");\n+                } else if let ast::ViewItemExternCrate(..) = i.node {\n+                    self.tcx.sess.span_err(i.span, \"`pub` visibility \\\n+                                                    is not allowed\");\n+                }\n+            }\n+        }\n+        visit::walk_view_item(self, i);\n+    }\n+}\n+\n+impl<'a, 'tcx> SanePrivacyVisitor<'a, 'tcx> {\n+    /// Validates all of the visibility qualifiers placed on the item given. This\n+    /// ensures that there are no extraneous qualifiers that don't actually do\n+    /// anything. In theory these qualifiers wouldn't parse, but that may happen\n+    /// later on down the road...\n+    fn check_sane_privacy(&self, item: &ast::Item) {\n+        let tcx = self.tcx;\n+        let check_inherited = |&: sp: Span, vis: ast::Visibility, note: &str| {\n+            if vis != ast::Inherited {\n+                tcx.sess.span_err(sp, \"unnecessary visibility qualifier\");\n+                if note.len() > 0 {\n+                    tcx.sess.span_note(sp, note);\n+                }\n+            }\n+        };\n+        match item.node {\n+            // implementations of traits don't need visibility qualifiers because\n+            // that's controlled by having the trait in scope.\n+            ast::ItemImpl(_, _, _, Some(..), _, ref impl_items) => {\n+                check_inherited(item.span, item.vis,\n+                                \"visibility qualifiers have no effect on trait \\\n+                                 impls\");\n+                for impl_item in impl_items.iter() {\n+                    match *impl_item {\n+                        ast::MethodImplItem(ref m) => {\n+                            check_inherited(m.span, m.pe_vis(), \"\");\n+                        }\n+                        ast::TypeImplItem(_) => {}\n+                    }\n+                }\n+            }\n+\n+            ast::ItemImpl(..) => {\n+                check_inherited(item.span, item.vis,\n+                                \"place qualifiers on individual methods instead\");\n+            }\n+            ast::ItemForeignMod(..) => {\n+                check_inherited(item.span, item.vis,\n+                                \"place qualifiers on individual functions \\\n+                                 instead\");\n+            }\n+\n+            ast::ItemEnum(ref def, _) => {\n+                for v in def.variants.iter() {\n+                    match v.node.vis {\n+                        ast::Public => {\n+                            if item.vis == ast::Public {\n+                                tcx.sess.span_err(v.span, \"unnecessary `pub` \\\n+                                                           visibility\");\n+                            }\n+                        }\n+                        ast::Inherited => {}\n+                    }\n+                }\n+            }\n+\n+            ast::ItemTrait(_, _, _, ref methods) => {\n+                for m in methods.iter() {\n+                    match *m {\n+                        ast::ProvidedMethod(ref m) => {\n+                            check_inherited(m.span, m.pe_vis(),\n+                                            \"unnecessary visibility\");\n+                        }\n+                        ast::RequiredMethod(ref m) => {\n+                            check_inherited(m.span, m.vis,\n+                                            \"unnecessary visibility\");\n+                        }\n+                        ast::TypeTraitItem(_) => {}\n+                    }\n+                }\n+            }\n+\n+            ast::ItemConst(..) | ast::ItemStatic(..) | ast::ItemStruct(..) |\n+            ast::ItemFn(..) | ast::ItemMod(..) | ast::ItemTy(..) |\n+            ast::ItemMac(..) => {}\n+        }\n+    }\n+\n+    /// When inside of something like a function or a method, visibility has no\n+    /// control over anything so this forbids any mention of any visibility\n+    fn check_all_inherited(&self, item: &ast::Item) {\n+        let tcx = self.tcx;\n+        fn check_inherited(tcx: &ty::ctxt, sp: Span, vis: ast::Visibility) {\n+            if vis != ast::Inherited {\n+                tcx.sess.span_err(sp, \"visibility has no effect inside functions\");\n+            }\n+        }\n+        let check_struct = |&: def: &ast::StructDef| {\n+            for f in def.fields.iter() {\n+               match f.node.kind {\n+                    ast::NamedField(_, p) => check_inherited(tcx, f.span, p),\n+                    ast::UnnamedField(..) => {}\n+                }\n+            }\n+        };\n+        check_inherited(tcx, item.span, item.vis);\n+        match item.node {\n+            ast::ItemImpl(_, _, _, _, _, ref impl_items) => {\n+                for impl_item in impl_items.iter() {\n+                    match *impl_item {\n+                        ast::MethodImplItem(ref m) => {\n+                            check_inherited(tcx, m.span, m.pe_vis());\n+                        }\n+                        ast::TypeImplItem(_) => {}\n+                    }\n+                }\n+            }\n+            ast::ItemForeignMod(ref fm) => {\n+                for i in fm.items.iter() {\n+                    check_inherited(tcx, i.span, i.vis);\n+                }\n+            }\n+            ast::ItemEnum(ref def, _) => {\n+                for v in def.variants.iter() {\n+                    check_inherited(tcx, v.span, v.node.vis);\n+                }\n+            }\n+\n+            ast::ItemStruct(ref def, _) => check_struct(&**def),\n+\n+            ast::ItemTrait(_, _, _, ref methods) => {\n+                for m in methods.iter() {\n+                    match *m {\n+                        ast::RequiredMethod(..) => {}\n+                        ast::ProvidedMethod(ref m) => check_inherited(tcx, m.span,\n+                                                                m.pe_vis()),\n+                        ast::TypeTraitItem(_) => {}\n+                    }\n+                }\n+            }\n+\n+            ast::ItemStatic(..) | ast::ItemConst(..) |\n+            ast::ItemFn(..) | ast::ItemMod(..) | ast::ItemTy(..) |\n+            ast::ItemMac(..) => {}\n+        }\n+    }\n+}\n+\n+struct VisiblePrivateTypesVisitor<'a, 'tcx: 'a> {\n+    tcx: &'a ty::ctxt<'tcx>,\n+    exported_items: &'a ExportedItems,\n+    public_items: &'a PublicItems,\n+    in_variant: bool,\n+}\n+\n+struct CheckTypeForPrivatenessVisitor<'a, 'b: 'a, 'tcx: 'b> {\n+    inner: &'a VisiblePrivateTypesVisitor<'b, 'tcx>,\n+    /// whether the type refers to private types.\n+    contains_private: bool,\n+    /// whether we've recurred at all (i.e. if we're pointing at the\n+    /// first type on which visit_ty was called).\n+    at_outer_type: bool,\n+    // whether that first type is a public path.\n+    outer_type_is_public_path: bool,\n+}\n+\n+impl<'a, 'tcx> VisiblePrivateTypesVisitor<'a, 'tcx> {\n+    fn path_is_private_type(&self, path_id: ast::NodeId) -> bool {\n+        let did = match self.tcx.def_map.borrow().get(&path_id).cloned() {\n+            // `int` etc. (None doesn't seem to occur.)\n+            None | Some(def::DefPrimTy(..)) => return false,\n+            Some(def) => def.def_id()\n+        };\n+        // A path can only be private if:\n+        // it's in this crate...\n+        if !is_local(did) {\n+            return false\n+        }\n+        // .. and it corresponds to a private type in the AST (this returns\n+        // None for type parameters)\n+        match self.tcx.map.find(did.node) {\n+            Some(ast_map::NodeItem(ref item)) => item.vis != ast::Public,\n+            Some(_) | None => false,\n+        }\n+    }\n+\n+    fn trait_is_public(&self, trait_id: ast::NodeId) -> bool {\n+        // FIXME: this would preferably be using `exported_items`, but all\n+        // traits are exported currently (see `EmbargoVisitor.exported_trait`)\n+        self.public_items.contains(&trait_id)\n+    }\n+\n+    fn check_ty_param_bound(&self,\n+                            ty_param_bound: &ast::TyParamBound) {\n+        if let ast::TraitTyParamBound(ref trait_ref, _) = *ty_param_bound {\n+            if !self.tcx.sess.features.borrow().visible_private_types &&\n+                self.path_is_private_type(trait_ref.trait_ref.ref_id) {\n+                    let span = trait_ref.trait_ref.path.span;\n+                    self.tcx.sess.span_err(span,\n+                                           \"private trait in exported type \\\n+                                            parameter bound\");\n+            }\n+        }\n+    }\n+}\n+\n+impl<'a, 'b, 'tcx, 'v> Visitor<'v> for CheckTypeForPrivatenessVisitor<'a, 'b, 'tcx> {\n+    fn visit_ty(&mut self, ty: &ast::Ty) {\n+        if let ast::TyPath(_, path_id) = ty.node {\n+            if self.inner.path_is_private_type(path_id) {\n+                self.contains_private = true;\n+                // found what we're looking for so let's stop\n+                // working.\n+                return\n+            } else if self.at_outer_type {\n+                self.outer_type_is_public_path = true;\n+            }\n+        }\n+        self.at_outer_type = false;\n+        visit::walk_ty(self, ty)\n+    }\n+\n+    // don't want to recurse into [, .. expr]\n+    fn visit_expr(&mut self, _: &ast::Expr) {}\n+}\n+\n+impl<'a, 'tcx, 'v> Visitor<'v> for VisiblePrivateTypesVisitor<'a, 'tcx> {\n+    fn visit_item(&mut self, item: &ast::Item) {\n+        match item.node {\n+            // contents of a private mod can be reexported, so we need\n+            // to check internals.\n+            ast::ItemMod(_) => {}\n+\n+            // An `extern {}` doesn't introduce a new privacy\n+            // namespace (the contents have their own privacies).\n+            ast::ItemForeignMod(_) => {}\n+\n+            ast::ItemTrait(_, _, ref bounds, _) => {\n+                if !self.trait_is_public(item.id) {\n+                    return\n+                }\n+\n+                for bound in bounds.iter() {\n+                    self.check_ty_param_bound(bound)\n+                }\n+            }\n+\n+            // impls need some special handling to try to offer useful\n+            // error messages without (too many) false positives\n+            // (i.e. we could just return here to not check them at\n+            // all, or some worse estimation of whether an impl is\n+            // publicly visible.\n+            ast::ItemImpl(_, _, ref g, ref trait_ref, ref self_, ref impl_items) => {\n+                // `impl [... for] Private` is never visible.\n+                let self_contains_private;\n+                // impl [... for] Public<...>, but not `impl [... for]\n+                // ~[Public]` or `(Public,)` etc.\n+                let self_is_public_path;\n+\n+                // check the properties of the Self type:\n+                {\n+                    let mut visitor = CheckTypeForPrivatenessVisitor {\n+                        inner: self,\n+                        contains_private: false,\n+                        at_outer_type: true,\n+                        outer_type_is_public_path: false,\n+                    };\n+                    visitor.visit_ty(&**self_);\n+                    self_contains_private = visitor.contains_private;\n+                    self_is_public_path = visitor.outer_type_is_public_path;\n+                }\n+\n+                // miscellaneous info about the impl\n+\n+                // `true` iff this is `impl Private for ...`.\n+                let not_private_trait =\n+                    trait_ref.as_ref().map_or(true, // no trait counts as public trait\n+                                              |tr| {\n+                        let did = ty::trait_ref_to_def_id(self.tcx, tr);\n+\n+                        !is_local(did) || self.trait_is_public(did.node)\n+                    });\n+\n+                // `true` iff this is a trait impl or at least one method is public.\n+                //\n+                // `impl Public { $( fn ...() {} )* }` is not visible.\n+                //\n+                // This is required over just using the methods' privacy\n+                // directly because we might have `impl<T: Foo<Private>> ...`,\n+                // and we shouldn't warn about the generics if all the methods\n+                // are private (because `T` won't be visible externally).\n+                let trait_or_some_public_method =\n+                    trait_ref.is_some() ||\n+                    impl_items.iter()\n+                              .any(|impl_item| {\n+                                  match *impl_item {\n+                                      ast::MethodImplItem(ref m) => {\n+                                          self.exported_items.contains(&m.id)\n+                                      }\n+                                      ast::TypeImplItem(_) => false,\n+                                  }\n+                              });\n+\n+                if !self_contains_private &&\n+                        not_private_trait &&\n+                        trait_or_some_public_method {\n+\n+                    visit::walk_generics(self, g);\n+\n+                    match *trait_ref {\n+                        None => {\n+                            for impl_item in impl_items.iter() {\n+                                match *impl_item {\n+                                    ast::MethodImplItem(ref method) => {\n+                                        visit::walk_method_helper(self, &**method)\n+                                    }\n+                                    ast::TypeImplItem(_) => {}\n+                                }\n+                            }\n+                        }\n+                        Some(ref tr) => {\n+                            // Any private types in a trait impl fall into two\n+                            // categories.\n+                            // 1. mentioned in the trait definition\n+                            // 2. mentioned in the type params/generics\n+                            //\n+                            // Those in 1. can only occur if the trait is in\n+                            // this crate and will've been warned about on the\n+                            // trait definition (there's no need to warn twice\n+                            // so we don't check the methods).\n+                            //\n+                            // Those in 2. are warned via walk_generics and this\n+                            // call here.\n+                            self.visit_trait_ref(tr)\n+                        }\n+                    }\n+                } else if trait_ref.is_none() && self_is_public_path {\n+                    // impl Public<Private> { ... }. Any public static\n+                    // methods will be visible as `Public::foo`.\n+                    let mut found_pub_static = false;\n+                    for impl_item in impl_items.iter() {\n+                        match *impl_item {\n+                            ast::MethodImplItem(ref method) => {\n+                                if method.pe_explicit_self().node ==\n+                                        ast::SelfStatic &&\n+                                        self.exported_items\n+                                            .contains(&method.id) {\n+                                    found_pub_static = true;\n+                                    visit::walk_method_helper(self, &**method);\n+                                }\n+                            }\n+                            ast::TypeImplItem(_) => {}\n+                        }\n+                    }\n+                    if found_pub_static {\n+                        visit::walk_generics(self, g)\n+                    }\n+                }\n+                return\n+            }\n+\n+            // `type ... = ...;` can contain private types, because\n+            // we're introducing a new name.\n+            ast::ItemTy(..) => return,\n+\n+            // not at all public, so we don't care\n+            _ if !self.exported_items.contains(&item.id) => return,\n+\n+            _ => {}\n+        }\n+\n+        // we've carefully constructed it so that if we're here, then\n+        // any `visit_ty`'s will be called on things that are in\n+        // public signatures, i.e. things that we're interested in for\n+        // this visitor.\n+        visit::walk_item(self, item);\n+    }\n+\n+    fn visit_generics(&mut self, generics: &ast::Generics) {\n+        for ty_param in generics.ty_params.iter() {\n+            for bound in ty_param.bounds.iter() {\n+                self.check_ty_param_bound(bound)\n+            }\n+        }\n+        for predicate in generics.where_clause.predicates.iter() {\n+            match predicate {\n+                &ast::WherePredicate::BoundPredicate(ref bound_pred) => {\n+                    for bound in bound_pred.bounds.iter() {\n+                        self.check_ty_param_bound(bound)\n+                    }\n+                }\n+                &ast::WherePredicate::RegionPredicate(_) => {}\n+                &ast::WherePredicate::EqPredicate(ref eq_pred) => {\n+                    self.visit_ty(&*eq_pred.ty);\n+                }\n+            }\n+        }\n+    }\n+\n+    fn visit_foreign_item(&mut self, item: &ast::ForeignItem) {\n+        if self.exported_items.contains(&item.id) {\n+            visit::walk_foreign_item(self, item)\n+        }\n+    }\n+\n+    fn visit_fn(&mut self, fk: visit::FnKind<'v>, fd: &'v ast::FnDecl,\n+                b: &'v ast::Block, s: Span, id: ast::NodeId) {\n+        // needs special handling for methods.\n+        if self.exported_items.contains(&id) {\n+            visit::walk_fn(self, fk, fd, b, s);\n+        }\n+    }\n+\n+    fn visit_ty(&mut self, t: &ast::Ty) {\n+        if let ast::TyPath(ref p, path_id) = t.node {\n+            if !self.tcx.sess.features.borrow().visible_private_types &&\n+                self.path_is_private_type(path_id) {\n+                self.tcx.sess.span_err(p.span,\n+                                       \"private type in exported type signature\");\n+            }\n+        }\n+        visit::walk_ty(self, t)\n+    }\n+\n+    fn visit_variant(&mut self, v: &ast::Variant, g: &ast::Generics) {\n+        if self.exported_items.contains(&v.node.id) {\n+            self.in_variant = true;\n+            visit::walk_variant(self, v, g);\n+            self.in_variant = false;\n+        }\n+    }\n+\n+    fn visit_struct_field(&mut self, s: &ast::StructField) {\n+        match s.node.kind {\n+            ast::NamedField(_, vis) if vis == ast::Public || self.in_variant => {\n+                visit::walk_struct_field(self, s);\n+            }\n+            _ => {}\n+        }\n+    }\n+\n+\n+    // we don't need to introspect into these at all: an\n+    // expression/block context can't possibly contain exported\n+    // things, and neither do view_items. (Making them no-ops stops us\n+    // from traversing the whole AST without having to be super\n+    // careful about our `walk_...` calls above.)\n+    fn visit_view_item(&mut self, _: &ast::ViewItem) {}\n+    fn visit_block(&mut self, _: &ast::Block) {}\n+    fn visit_expr(&mut self, _: &ast::Expr) {}\n+}\n+\n+pub fn check_crate(tcx: &ty::ctxt,\n+                   export_map: &def::ExportMap,\n+                   external_exports: ExternalExports,\n+                   last_private_map: LastPrivateMap)\n+                   -> (ExportedItems, PublicItems) {\n+    let krate = tcx.map.krate();\n+\n+    // Figure out who everyone's parent is\n+    let mut visitor = ParentVisitor {\n+        parents: NodeMap::new(),\n+        curparent: ast::DUMMY_NODE_ID,\n+    };\n+    visit::walk_crate(&mut visitor, krate);\n+\n+    // Use the parent map to check the privacy of everything\n+    let mut visitor = PrivacyVisitor {\n+        curitem: ast::DUMMY_NODE_ID,\n+        in_foreign: false,\n+        tcx: tcx,\n+        parents: visitor.parents,\n+        external_exports: external_exports,\n+        last_private_map: last_private_map,\n+    };\n+    visit::walk_crate(&mut visitor, krate);\n+\n+    // Sanity check to make sure that all privacy usage and controls are\n+    // reasonable.\n+    let mut visitor = SanePrivacyVisitor {\n+        in_fn: false,\n+        tcx: tcx,\n+    };\n+    visit::walk_crate(&mut visitor, krate);\n+\n+    tcx.sess.abort_if_errors();\n+\n+    // Build up a set of all exported items in the AST. This is a set of all\n+    // items which are reachable from external crates based on visibility.\n+    let mut visitor = EmbargoVisitor {\n+        tcx: tcx,\n+        exported_items: NodeSet::new(),\n+        public_items: NodeSet::new(),\n+        reexports: NodeSet::new(),\n+        export_map: export_map,\n+        prev_exported: true,\n+        prev_public: true,\n+    };\n+    loop {\n+        let before = visitor.exported_items.len();\n+        visit::walk_crate(&mut visitor, krate);\n+        if before == visitor.exported_items.len() {\n+            break\n+        }\n+    }\n+\n+    let EmbargoVisitor { exported_items, public_items, .. } = visitor;\n+\n+    {\n+        let mut visitor = VisiblePrivateTypesVisitor {\n+            tcx: tcx,\n+            exported_items: &exported_items,\n+            public_items: &public_items,\n+            in_variant: false,\n+        };\n+        visit::walk_crate(&mut visitor, krate);\n+    }\n+    return (exported_items, public_items);\n+}"}]}