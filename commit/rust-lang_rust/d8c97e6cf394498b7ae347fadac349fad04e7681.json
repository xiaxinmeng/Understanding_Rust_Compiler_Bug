{"sha": "d8c97e6cf394498b7ae347fadac349fad04e7681", "node_id": "C_kwDOAAsO6NoAKGQ4Yzk3ZTZjZjM5NDQ5OGI3YWUzNDdmYWRhYzM0OWZhZDA0ZTc2ODE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-04-12T18:38:45Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-04-12T18:38:45Z"}, "message": "Auto merge of #8645 - Jarcho:manual_non_exhaustive_5714, r=Jarcho\n\nDon't lint `manual_non_exhaustive` when the enum variant is used\n\nfixes #5714\n\nchangelog: Don't lint `manual_non_exhaustive` when the enum variant is used", "tree": {"sha": "6f9e0a80fb4e59a826dbf0eca81393215f0415f1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6f9e0a80fb4e59a826dbf0eca81393215f0415f1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d8c97e6cf394498b7ae347fadac349fad04e7681", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d8c97e6cf394498b7ae347fadac349fad04e7681", "html_url": "https://github.com/rust-lang/rust/commit/d8c97e6cf394498b7ae347fadac349fad04e7681", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d8c97e6cf394498b7ae347fadac349fad04e7681/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "849668ad718ad90ed8a61147968fde2eef772479", "url": "https://api.github.com/repos/rust-lang/rust/commits/849668ad718ad90ed8a61147968fde2eef772479", "html_url": "https://github.com/rust-lang/rust/commit/849668ad718ad90ed8a61147968fde2eef772479"}, {"sha": "b0f8a3155159286af233577aa0f50d933770dc47", "url": "https://api.github.com/repos/rust-lang/rust/commits/b0f8a3155159286af233577aa0f50d933770dc47", "html_url": "https://github.com/rust-lang/rust/commit/b0f8a3155159286af233577aa0f50d933770dc47"}], "stats": {"total": 441, "additions": 247, "deletions": 194}, "files": [{"sha": "b4821e1d6061473995d8a52391ddd344805d164d", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d8c97e6cf394498b7ae347fadac349fad04e7681/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8c97e6cf394498b7ae347fadac349fad04e7681/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=d8c97e6cf394498b7ae347fadac349fad04e7681", "patch": "@@ -573,7 +573,8 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(move || Box::new(approx_const::ApproxConstant::new(msrv)));\n     store.register_late_pass(move || Box::new(methods::Methods::new(avoid_breaking_exported_api, msrv)));\n     store.register_late_pass(move || Box::new(matches::Matches::new(msrv)));\n-    store.register_early_pass(move || Box::new(manual_non_exhaustive::ManualNonExhaustive::new(msrv)));\n+    store.register_early_pass(move || Box::new(manual_non_exhaustive::ManualNonExhaustiveStruct::new(msrv)));\n+    store.register_late_pass(move || Box::new(manual_non_exhaustive::ManualNonExhaustiveEnum::new(msrv)));\n     store.register_late_pass(move || Box::new(manual_strip::ManualStrip::new(msrv)));\n     store.register_early_pass(move || Box::new(redundant_static_lifetimes::RedundantStaticLifetimes::new(msrv)));\n     store.register_early_pass(move || Box::new(redundant_field_names::RedundantFieldNames::new(msrv)));"}, {"sha": "2501dd5bed4b738dc19df66c2ae2983e109b5f8a", "filename": "clippy_lints/src/manual_non_exhaustive.rs", "status": "modified", "additions": 116, "deletions": 82, "changes": 198, "blob_url": "https://github.com/rust-lang/rust/blob/d8c97e6cf394498b7ae347fadac349fad04e7681/clippy_lints%2Fsrc%2Fmanual_non_exhaustive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8c97e6cf394498b7ae347fadac349fad04e7681/clippy_lints%2Fsrc%2Fmanual_non_exhaustive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmanual_non_exhaustive.rs?ref=d8c97e6cf394498b7ae347fadac349fad04e7681", "patch": "@@ -1,13 +1,17 @@\n use clippy_utils::attrs::is_doc_hidden;\n use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::source::snippet_opt;\n-use clippy_utils::{meets_msrv, msrvs};\n-use if_chain::if_chain;\n-use rustc_ast::ast::{FieldDef, Item, ItemKind, Variant, VariantData, VisibilityKind};\n+use clippy_utils::{is_lint_allowed, meets_msrv, msrvs};\n+use rustc_ast::ast::{self, VisibilityKind};\n+use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::Applicability;\n-use rustc_lint::{EarlyContext, EarlyLintPass, LintContext};\n+use rustc_hir::def::{CtorKind, CtorOf, DefKind, Res};\n+use rustc_hir::{self as hir, Expr, ExprKind, QPath};\n+use rustc_lint::{EarlyContext, EarlyLintPass, LateContext, LateLintPass, LintContext};\n+use rustc_middle::ty::DefIdTree;\n use rustc_semver::RustcVersion;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n+use rustc_span::def_id::{DefId, LocalDefId};\n use rustc_span::{sym, Span};\n \n declare_clippy_lint! {\n@@ -58,129 +62,159 @@ declare_clippy_lint! {\n     \"manual implementations of the non-exhaustive pattern can be simplified using #[non_exhaustive]\"\n }\n \n-#[derive(Clone)]\n-pub struct ManualNonExhaustive {\n+#[allow(clippy::module_name_repetitions)]\n+pub struct ManualNonExhaustiveStruct {\n     msrv: Option<RustcVersion>,\n }\n \n-impl ManualNonExhaustive {\n+impl ManualNonExhaustiveStruct {\n     #[must_use]\n     pub fn new(msrv: Option<RustcVersion>) -> Self {\n         Self { msrv }\n     }\n }\n \n-impl_lint_pass!(ManualNonExhaustive => [MANUAL_NON_EXHAUSTIVE]);\n+impl_lint_pass!(ManualNonExhaustiveStruct => [MANUAL_NON_EXHAUSTIVE]);\n \n-impl EarlyLintPass for ManualNonExhaustive {\n-    fn check_item(&mut self, cx: &EarlyContext<'_>, item: &Item) {\n-        if !meets_msrv(self.msrv.as_ref(), &msrvs::NON_EXHAUSTIVE) {\n-            return;\n-        }\n-\n-        match &item.kind {\n-            ItemKind::Enum(def, _) => {\n-                check_manual_non_exhaustive_enum(cx, item, &def.variants);\n-            },\n-            ItemKind::Struct(variant_data, _) => {\n-                if let VariantData::Unit(..) = variant_data {\n-                    return;\n-                }\n+#[allow(clippy::module_name_repetitions)]\n+pub struct ManualNonExhaustiveEnum {\n+    msrv: Option<RustcVersion>,\n+    constructed_enum_variants: FxHashSet<(DefId, DefId)>,\n+    potential_enums: Vec<(LocalDefId, LocalDefId, Span, Span)>,\n+}\n \n-                check_manual_non_exhaustive_struct(cx, item, variant_data);\n-            },\n-            _ => {},\n+impl ManualNonExhaustiveEnum {\n+    #[must_use]\n+    pub fn new(msrv: Option<RustcVersion>) -> Self {\n+        Self {\n+            msrv,\n+            constructed_enum_variants: FxHashSet::default(),\n+            potential_enums: Vec::new(),\n         }\n     }\n-\n-    extract_msrv_attr!(EarlyContext);\n }\n \n-fn check_manual_non_exhaustive_enum(cx: &EarlyContext<'_>, item: &Item, variants: &[Variant]) {\n-    fn is_non_exhaustive_marker(variant: &Variant) -> bool {\n-        matches!(variant.data, VariantData::Unit(_))\n-            && variant.ident.as_str().starts_with('_')\n-            && is_doc_hidden(&variant.attrs)\n-    }\n+impl_lint_pass!(ManualNonExhaustiveEnum => [MANUAL_NON_EXHAUSTIVE]);\n \n-    let mut markers = variants.iter().filter(|v| is_non_exhaustive_marker(v));\n-    if_chain! {\n-        if let Some(marker) = markers.next();\n-        if markers.count() == 0 && variants.len() > 1;\n-        then {\n-            span_lint_and_then(\n-                cx,\n-                MANUAL_NON_EXHAUSTIVE,\n-                item.span,\n-                \"this seems like a manual implementation of the non-exhaustive pattern\",\n-                |diag| {\n-                    if_chain! {\n-                        if !item.attrs.iter().any(|attr| attr.has_name(sym::non_exhaustive));\n-                        let header_span = cx.sess().source_map().span_until_char(item.span, '{');\n-                        if let Some(snippet) = snippet_opt(cx, header_span);\n-                        then {\n+impl EarlyLintPass for ManualNonExhaustiveStruct {\n+    fn check_item(&mut self, cx: &EarlyContext<'_>, item: &ast::Item) {\n+        if !meets_msrv(self.msrv.as_ref(), &msrvs::NON_EXHAUSTIVE) {\n+            return;\n+        }\n+\n+        if let ast::ItemKind::Struct(variant_data, _) = &item.kind {\n+            let (fields, delimiter) = match variant_data {\n+                ast::VariantData::Struct(fields, _) => (&**fields, '{'),\n+                ast::VariantData::Tuple(fields, _) => (&**fields, '('),\n+                ast::VariantData::Unit(_) => return,\n+            };\n+            if fields.len() <= 1 {\n+                return;\n+            }\n+            let mut iter = fields.iter().filter_map(|f| match f.vis.kind {\n+                VisibilityKind::Public => None,\n+                VisibilityKind::Inherited => Some(Ok(f)),\n+                _ => Some(Err(())),\n+            });\n+            if let Some(Ok(field)) = iter.next()\n+                && iter.next().is_none()\n+                && field.ty.kind.is_unit()\n+                && field.ident.map_or(true, |name| name.as_str().starts_with('_'))\n+            {\n+                span_lint_and_then(\n+                    cx,\n+                    MANUAL_NON_EXHAUSTIVE,\n+                    item.span,\n+                    \"this seems like a manual implementation of the non-exhaustive pattern\",\n+                    |diag| {\n+                        if !item.attrs.iter().any(|attr| attr.has_name(sym::non_exhaustive))\n+                            && let header_span = cx.sess().source_map().span_until_char(item.span, delimiter)\n+                            && let Some(snippet) = snippet_opt(cx, header_span)\n+                        {\n                             diag.span_suggestion(\n                                 header_span,\n                                 \"add the attribute\",\n                                 format!(\"#[non_exhaustive] {}\", snippet),\n                                 Applicability::Unspecified,\n                             );\n                         }\n+                        diag.span_help(field.span, \"remove this field\");\n                     }\n-                    diag.span_help(marker.span, \"remove this variant\");\n-                });\n+                );\n+            }\n         }\n     }\n+\n+    extract_msrv_attr!(EarlyContext);\n }\n \n-fn check_manual_non_exhaustive_struct(cx: &EarlyContext<'_>, item: &Item, data: &VariantData) {\n-    fn is_private(field: &FieldDef) -> bool {\n-        matches!(field.vis.kind, VisibilityKind::Inherited)\n-    }\n+impl<'tcx> LateLintPass<'tcx> for ManualNonExhaustiveEnum {\n+    fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx hir::Item<'_>) {\n+        if !meets_msrv(self.msrv.as_ref(), &msrvs::NON_EXHAUSTIVE) {\n+            return;\n+        }\n \n-    fn is_non_exhaustive_marker(field: &FieldDef) -> bool {\n-        is_private(field) && field.ty.kind.is_unit() && field.ident.map_or(true, |n| n.as_str().starts_with('_'))\n+        if let hir::ItemKind::Enum(def, _) = &item.kind\n+            && def.variants.len() > 1\n+        {\n+            let mut iter = def.variants.iter().filter_map(|v| {\n+                let id = cx.tcx.hir().local_def_id(v.id);\n+                (matches!(v.data, hir::VariantData::Unit(_))\n+                    && v.ident.as_str().starts_with('_')\n+                    && is_doc_hidden(cx.tcx.get_attrs(id.to_def_id())))\n+                .then(|| (id, v.span))\n+            });\n+            if let Some((id, span)) = iter.next()\n+                && iter.next().is_none()\n+            {\n+                self.potential_enums.push((item.def_id, id, item.span, span));\n+            }\n+        }\n     }\n \n-    fn find_header_span(cx: &EarlyContext<'_>, item: &Item, data: &VariantData) -> Span {\n-        let delimiter = match data {\n-            VariantData::Struct(..) => '{',\n-            VariantData::Tuple(..) => '(',\n-            VariantData::Unit(_) => unreachable!(\"`VariantData::Unit` is already handled above\"),\n-        };\n-\n-        cx.sess().source_map().span_until_char(item.span, delimiter)\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) {\n+        if let ExprKind::Path(QPath::Resolved(None, p)) = &e.kind\n+            && let [.., name] = p.segments\n+            && let Res::Def(DefKind::Ctor(CtorOf::Variant, CtorKind::Const), id) = p.res\n+            && name.ident.as_str().starts_with('_')\n+            && let Some(variant_id) = cx.tcx.parent(id)\n+            && let Some(enum_id) = cx.tcx.parent(variant_id)\n+        {\n+            self.constructed_enum_variants.insert((enum_id, variant_id));\n+        }\n     }\n \n-    let fields = data.fields();\n-    let private_fields = fields.iter().filter(|f| is_private(f)).count();\n-    let public_fields = fields.iter().filter(|f| f.vis.kind.is_pub()).count();\n-\n-    if_chain! {\n-        if private_fields == 1 && public_fields >= 1 && public_fields == fields.len() - 1;\n-        if let Some(marker) = fields.iter().find(|f| is_non_exhaustive_marker(f));\n-        then {\n+    fn check_crate_post(&mut self, cx: &LateContext<'tcx>) {\n+        for &(enum_id, _, enum_span, variant_span) in\n+            self.potential_enums.iter().filter(|&&(enum_id, variant_id, _, _)| {\n+                !self\n+                    .constructed_enum_variants\n+                    .contains(&(enum_id.to_def_id(), variant_id.to_def_id()))\n+                    && !is_lint_allowed(cx, MANUAL_NON_EXHAUSTIVE, cx.tcx.hir().local_def_id_to_hir_id(enum_id))\n+            })\n+        {\n             span_lint_and_then(\n                 cx,\n                 MANUAL_NON_EXHAUSTIVE,\n-                item.span,\n+                enum_span,\n                 \"this seems like a manual implementation of the non-exhaustive pattern\",\n                 |diag| {\n-                    if_chain! {\n-                        if !item.attrs.iter().any(|attr| attr.has_name(sym::non_exhaustive));\n-                        let header_span = find_header_span(cx, item, data);\n-                        if let Some(snippet) = snippet_opt(cx, header_span);\n-                        then {\n+                    if !cx.tcx.adt_def(enum_id).is_variant_list_non_exhaustive()\n+                        && let header_span = cx.sess().source_map().span_until_char(enum_span, '{')\n+                        && let Some(snippet) = snippet_opt(cx, header_span)\n+                    {\n                             diag.span_suggestion(\n                                 header_span,\n                                 \"add the attribute\",\n                                 format!(\"#[non_exhaustive] {}\", snippet),\n                                 Applicability::Unspecified,\n                             );\n-                        }\n                     }\n-                    diag.span_help(marker.span, \"remove this field\");\n-                });\n+                    diag.span_help(variant_span, \"remove this variant\");\n+                },\n+            );\n         }\n     }\n+\n+    extract_msrv_attr!(LateContext);\n }"}, {"sha": "f23c6d69b4c6a4142c008597588e656711c4e2bd", "filename": "tests/ui/manual_non_exhaustive_enum.rs", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/d8c97e6cf394498b7ae347fadac349fad04e7681/tests%2Fui%2Fmanual_non_exhaustive_enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8c97e6cf394498b7ae347fadac349fad04e7681/tests%2Fui%2Fmanual_non_exhaustive_enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_non_exhaustive_enum.rs?ref=d8c97e6cf394498b7ae347fadac349fad04e7681", "patch": "@@ -0,0 +1,78 @@\n+#![warn(clippy::manual_non_exhaustive)]\n+#![allow(unused)]\n+\n+enum E {\n+    A,\n+    B,\n+    #[doc(hidden)]\n+    _C,\n+}\n+\n+// user forgot to remove the marker\n+#[non_exhaustive]\n+enum Ep {\n+    A,\n+    B,\n+    #[doc(hidden)]\n+    _C,\n+}\n+\n+// marker variant does not have doc hidden attribute, should be ignored\n+enum NoDocHidden {\n+    A,\n+    B,\n+    _C,\n+}\n+\n+// name of variant with doc hidden does not start with underscore, should be ignored\n+enum NoUnderscore {\n+    A,\n+    B,\n+    #[doc(hidden)]\n+    C,\n+}\n+\n+// variant with doc hidden is not unit, should be ignored\n+enum NotUnit {\n+    A,\n+    B,\n+    #[doc(hidden)]\n+    _C(bool),\n+}\n+\n+// variant with doc hidden is the only one, should be ignored\n+enum OnlyMarker {\n+    #[doc(hidden)]\n+    _A,\n+}\n+\n+// variant with multiple markers, should be ignored\n+enum MultipleMarkers {\n+    A,\n+    #[doc(hidden)]\n+    _B,\n+    #[doc(hidden)]\n+    _C,\n+}\n+\n+// already non_exhaustive and no markers, should be ignored\n+#[non_exhaustive]\n+enum NonExhaustive {\n+    A,\n+    B,\n+}\n+\n+// marked is used, don't lint\n+enum UsedHidden {\n+    #[doc(hidden)]\n+    _A,\n+    B,\n+    C,\n+}\n+fn foo(x: &mut UsedHidden) {\n+    if matches!(*x, UsedHidden::B) {\n+        *x = UsedHidden::_A;\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "317a45d2cbd596ab306cae15880279b1c49d8dff", "filename": "tests/ui/manual_non_exhaustive_enum.stderr", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/d8c97e6cf394498b7ae347fadac349fad04e7681/tests%2Fui%2Fmanual_non_exhaustive_enum.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d8c97e6cf394498b7ae347fadac349fad04e7681/tests%2Fui%2Fmanual_non_exhaustive_enum.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_non_exhaustive_enum.stderr?ref=d8c97e6cf394498b7ae347fadac349fad04e7681", "patch": "@@ -0,0 +1,41 @@\n+error: this seems like a manual implementation of the non-exhaustive pattern\n+  --> $DIR/manual_non_exhaustive_enum.rs:4:1\n+   |\n+LL |   enum E {\n+   |   ^-----\n+   |   |\n+   |  _help: add the attribute: `#[non_exhaustive] enum E`\n+   | |\n+LL | |     A,\n+LL | |     B,\n+LL | |     #[doc(hidden)]\n+LL | |     _C,\n+LL | | }\n+   | |_^\n+   |\n+   = note: `-D clippy::manual-non-exhaustive` implied by `-D warnings`\n+help: remove this variant\n+  --> $DIR/manual_non_exhaustive_enum.rs:8:5\n+   |\n+LL |     _C,\n+   |     ^^\n+\n+error: this seems like a manual implementation of the non-exhaustive pattern\n+  --> $DIR/manual_non_exhaustive_enum.rs:13:1\n+   |\n+LL | / enum Ep {\n+LL | |     A,\n+LL | |     B,\n+LL | |     #[doc(hidden)]\n+LL | |     _C,\n+LL | | }\n+   | |_^\n+   |\n+help: remove this variant\n+  --> $DIR/manual_non_exhaustive_enum.rs:17:5\n+   |\n+LL |     _C,\n+   |     ^^\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "498eee4447b8841cf275d462abf3d957e3c8403f", "filename": "tests/ui/manual_non_exhaustive_struct.rs", "status": "renamed", "additions": 0, "deletions": 63, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/d8c97e6cf394498b7ae347fadac349fad04e7681/tests%2Fui%2Fmanual_non_exhaustive_struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8c97e6cf394498b7ae347fadac349fad04e7681/tests%2Fui%2Fmanual_non_exhaustive_struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_non_exhaustive_struct.rs?ref=d8c97e6cf394498b7ae347fadac349fad04e7681", "patch": "@@ -1,69 +1,6 @@\n #![warn(clippy::manual_non_exhaustive)]\n #![allow(unused)]\n \n-mod enums {\n-    enum E {\n-        A,\n-        B,\n-        #[doc(hidden)]\n-        _C,\n-    }\n-\n-    // user forgot to remove the marker\n-    #[non_exhaustive]\n-    enum Ep {\n-        A,\n-        B,\n-        #[doc(hidden)]\n-        _C,\n-    }\n-\n-    // marker variant does not have doc hidden attribute, should be ignored\n-    enum NoDocHidden {\n-        A,\n-        B,\n-        _C,\n-    }\n-\n-    // name of variant with doc hidden does not start with underscore, should be ignored\n-    enum NoUnderscore {\n-        A,\n-        B,\n-        #[doc(hidden)]\n-        C,\n-    }\n-\n-    // variant with doc hidden is not unit, should be ignored\n-    enum NotUnit {\n-        A,\n-        B,\n-        #[doc(hidden)]\n-        _C(bool),\n-    }\n-\n-    // variant with doc hidden is the only one, should be ignored\n-    enum OnlyMarker {\n-        #[doc(hidden)]\n-        _A,\n-    }\n-\n-    // variant with multiple markers, should be ignored\n-    enum MultipleMarkers {\n-        A,\n-        #[doc(hidden)]\n-        _B,\n-        #[doc(hidden)]\n-        _C,\n-    }\n-\n-    // already non_exhaustive and no markers, should be ignored\n-    #[non_exhaustive]\n-    enum NonExhaustive {\n-        A,\n-        B,\n-    }\n-}\n-\n mod structs {\n     struct S {\n         pub a: i32,", "previous_filename": "tests/ui/manual_non_exhaustive.rs"}, {"sha": "e0766c17b758038c5cbf7a4ef007a3005c91f5c9", "filename": "tests/ui/manual_non_exhaustive_struct.stderr", "status": "renamed", "additions": 10, "deletions": 48, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/d8c97e6cf394498b7ae347fadac349fad04e7681/tests%2Fui%2Fmanual_non_exhaustive_struct.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d8c97e6cf394498b7ae347fadac349fad04e7681/tests%2Fui%2Fmanual_non_exhaustive_struct.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_non_exhaustive_struct.stderr?ref=d8c97e6cf394498b7ae347fadac349fad04e7681", "patch": "@@ -1,44 +1,5 @@\n error: this seems like a manual implementation of the non-exhaustive pattern\n-  --> $DIR/manual_non_exhaustive.rs:5:5\n-   |\n-LL |       enum E {\n-   |       ^-----\n-   |       |\n-   |  _____help: add the attribute: `#[non_exhaustive] enum E`\n-   | |\n-LL | |         A,\n-LL | |         B,\n-LL | |         #[doc(hidden)]\n-LL | |         _C,\n-LL | |     }\n-   | |_____^\n-   |\n-   = note: `-D clippy::manual-non-exhaustive` implied by `-D warnings`\n-help: remove this variant\n-  --> $DIR/manual_non_exhaustive.rs:9:9\n-   |\n-LL |         _C,\n-   |         ^^\n-\n-error: this seems like a manual implementation of the non-exhaustive pattern\n-  --> $DIR/manual_non_exhaustive.rs:14:5\n-   |\n-LL | /     enum Ep {\n-LL | |         A,\n-LL | |         B,\n-LL | |         #[doc(hidden)]\n-LL | |         _C,\n-LL | |     }\n-   | |_____^\n-   |\n-help: remove this variant\n-  --> $DIR/manual_non_exhaustive.rs:18:9\n-   |\n-LL |         _C,\n-   |         ^^\n-\n-error: this seems like a manual implementation of the non-exhaustive pattern\n-  --> $DIR/manual_non_exhaustive.rs:68:5\n+  --> $DIR/manual_non_exhaustive_struct.rs:5:5\n    |\n LL |       struct S {\n    |       ^-------\n@@ -51,14 +12,15 @@ LL | |         _c: (),\n LL | |     }\n    | |_____^\n    |\n+   = note: `-D clippy::manual-non-exhaustive` implied by `-D warnings`\n help: remove this field\n-  --> $DIR/manual_non_exhaustive.rs:71:9\n+  --> $DIR/manual_non_exhaustive_struct.rs:8:9\n    |\n LL |         _c: (),\n    |         ^^^^^^\n \n error: this seems like a manual implementation of the non-exhaustive pattern\n-  --> $DIR/manual_non_exhaustive.rs:76:5\n+  --> $DIR/manual_non_exhaustive_struct.rs:13:5\n    |\n LL | /     struct Sp {\n LL | |         pub a: i32,\n@@ -68,36 +30,36 @@ LL | |     }\n    | |_____^\n    |\n help: remove this field\n-  --> $DIR/manual_non_exhaustive.rs:79:9\n+  --> $DIR/manual_non_exhaustive_struct.rs:16:9\n    |\n LL |         _c: (),\n    |         ^^^^^^\n \n error: this seems like a manual implementation of the non-exhaustive pattern\n-  --> $DIR/manual_non_exhaustive.rs:117:5\n+  --> $DIR/manual_non_exhaustive_struct.rs:54:5\n    |\n LL |     struct T(pub i32, pub i32, ());\n    |     --------^^^^^^^^^^^^^^^^^^^^^^^\n    |     |\n    |     help: add the attribute: `#[non_exhaustive] struct T`\n    |\n help: remove this field\n-  --> $DIR/manual_non_exhaustive.rs:117:32\n+  --> $DIR/manual_non_exhaustive_struct.rs:54:32\n    |\n LL |     struct T(pub i32, pub i32, ());\n    |                                ^^\n \n error: this seems like a manual implementation of the non-exhaustive pattern\n-  --> $DIR/manual_non_exhaustive.rs:121:5\n+  --> $DIR/manual_non_exhaustive_struct.rs:58:5\n    |\n LL |     struct Tp(pub i32, pub i32, ());\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n help: remove this field\n-  --> $DIR/manual_non_exhaustive.rs:121:33\n+  --> $DIR/manual_non_exhaustive_struct.rs:58:33\n    |\n LL |     struct Tp(pub i32, pub i32, ());\n    |                                 ^^\n \n-error: aborting due to 6 previous errors\n+error: aborting due to 4 previous errors\n ", "previous_filename": "tests/ui/manual_non_exhaustive.stderr"}]}