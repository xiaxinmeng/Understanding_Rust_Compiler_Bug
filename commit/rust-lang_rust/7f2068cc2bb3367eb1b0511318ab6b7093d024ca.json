{"sha": "7f2068cc2bb3367eb1b0511318ab6b7093d024ca", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdmMjA2OGNjMmJiMzM2N2ViMWIwNTExMzE4YWI2YjcwOTNkMDI0Y2E=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-04-16T16:45:59Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-04-16T16:45:59Z"}, "message": "Auto merge of #6568 - Jarcho:redundant_pattern_matching, r=flip1995\n\nFix: redundant_pattern_matching drop order\n\nFixes #5746\n\nA note about the change in drop order is added when the scrutinee (or any temporary in the expression) isn't known to be safe to drop in any order (i.e. doesn't implement the `Drop` trait, or contain such a type). There is a whitelist for some `std` types, but it's incomplete. Currently just `Vec<_>`, `Box<_>`, `Rc<_>` and `Arc<_>`, but only if the contained type is also safe to drop in any order.\n\nAnother lint for when the drop order changes could be added as allowed by default, but the drop order requirement is pretty subtle in this case. I think the note added to the lint should be enough to make someone think before applying the change.\n\nchangelog: Added a note to `redundant_pattern_matching` when the change in drop order might matter", "tree": {"sha": "727628b3317d5dae8eb08f88ece1d30ff983e773", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/727628b3317d5dae8eb08f88ece1d30ff983e773"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7f2068cc2bb3367eb1b0511318ab6b7093d024ca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7f2068cc2bb3367eb1b0511318ab6b7093d024ca", "html_url": "https://github.com/rust-lang/rust/commit/7f2068cc2bb3367eb1b0511318ab6b7093d024ca", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7f2068cc2bb3367eb1b0511318ab6b7093d024ca/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1e0a3ff55c494dcb660e4cdae2dc4b697815dc86", "url": "https://api.github.com/repos/rust-lang/rust/commits/1e0a3ff55c494dcb660e4cdae2dc4b697815dc86", "html_url": "https://github.com/rust-lang/rust/commit/1e0a3ff55c494dcb660e4cdae2dc4b697815dc86"}, {"sha": "c02baba1dcd9847d07762f42412d10eed7cff3e9", "url": "https://api.github.com/repos/rust-lang/rust/commits/c02baba1dcd9847d07762f42412d10eed7cff3e9", "html_url": "https://github.com/rust-lang/rust/commit/c02baba1dcd9847d07762f42412d10eed7cff3e9"}], "stats": {"total": 670, "additions": 581, "deletions": 89}, "files": [{"sha": "9268834d8fd39bafcddb32864f5114046b1a22ed", "filename": "clippy_lints/src/matches.rs", "status": "modified", "additions": 207, "deletions": 24, "changes": 231, "blob_url": "https://github.com/rust-lang/rust/blob/7f2068cc2bb3367eb1b0511318ab6b7093d024ca/clippy_lints%2Fsrc%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f2068cc2bb3367eb1b0511318ab6b7093d024ca/clippy_lints%2Fsrc%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches.rs?ref=7f2068cc2bb3367eb1b0511318ab6b7093d024ca", "patch": "@@ -423,7 +423,12 @@ declare_clippy_lint! {\n     /// **Why is this bad?** It's more concise and clear to just use the proper\n     /// utility function\n     ///\n-    /// **Known problems:** None.\n+    /// **Known problems:** This will change the drop order for the matched type. Both `if let` and\n+    /// `while let` will drop the value at the end of the block, both `if` and `while` will drop the\n+    /// value before entering the block. For most types this change will not matter, but for a few\n+    /// types this will not be an acceptable change (e.g. locks). See the\n+    /// [reference](https://doc.rust-lang.org/reference/destructors.html#drop-scopes) for more about\n+    /// drop order.\n     ///\n     /// **Example:**\n     ///\n@@ -1703,55 +1708,206 @@ where\n mod redundant_pattern_match {\n     use super::REDUNDANT_PATTERN_MATCHING;\n     use clippy_utils::diagnostics::span_lint_and_then;\n-    use clippy_utils::source::snippet;\n+    use clippy_utils::source::{snippet, snippet_with_applicability};\n+    use clippy_utils::ty::{implements_trait, is_type_diagnostic_item, is_type_lang_item, match_type};\n     use clippy_utils::{is_lang_ctor, is_qpath_def_path, is_trait_method, paths};\n     use if_chain::if_chain;\n     use rustc_ast::ast::LitKind;\n     use rustc_errors::Applicability;\n     use rustc_hir::LangItem::{OptionNone, OptionSome, PollPending, PollReady, ResultErr, ResultOk};\n-    use rustc_hir::{Arm, Expr, ExprKind, MatchSource, PatKind, QPath};\n+    use rustc_hir::{\n+        intravisit::{walk_expr, ErasedMap, NestedVisitorMap, Visitor},\n+        Arm, Block, Expr, ExprKind, LangItem, MatchSource, Node, PatKind, QPath,\n+    };\n     use rustc_lint::LateContext;\n+    use rustc_middle::ty::{self, subst::GenericArgKind, Ty};\n     use rustc_span::sym;\n \n     pub fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         if let ExprKind::Match(op, arms, ref match_source) = &expr.kind {\n             match match_source {\n                 MatchSource::Normal => find_sugg_for_match(cx, expr, op, arms),\n-                MatchSource::IfLetDesugar { .. } => find_sugg_for_if_let(cx, expr, op, arms, \"if\"),\n-                MatchSource::WhileLetDesugar => find_sugg_for_if_let(cx, expr, op, arms, \"while\"),\n+                MatchSource::IfLetDesugar { contains_else_clause } => {\n+                    find_sugg_for_if_let(cx, expr, op, &arms[0], \"if\", *contains_else_clause)\n+                },\n+                MatchSource::WhileLetDesugar => find_sugg_for_if_let(cx, expr, op, &arms[0], \"while\", false),\n                 _ => {},\n             }\n         }\n     }\n \n+    /// Checks if the drop order for a type matters. Some std types implement drop solely to\n+    /// deallocate memory. For these types, and composites containing them, changing the drop order\n+    /// won't result in any observable side effects.\n+    fn type_needs_ordered_drop(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n+        if !ty.needs_drop(cx.tcx, cx.param_env) {\n+            false\n+        } else if !cx\n+            .tcx\n+            .lang_items()\n+            .drop_trait()\n+            .map_or(false, |id| implements_trait(cx, ty, id, &[]))\n+        {\n+            // This type doesn't implement drop, so no side effects here.\n+            // Check if any component type has any.\n+            match ty.kind() {\n+                ty::Tuple(_) => ty.tuple_fields().any(|ty| type_needs_ordered_drop(cx, ty)),\n+                ty::Array(ty, _) => type_needs_ordered_drop(cx, ty),\n+                ty::Adt(adt, subs) => adt\n+                    .all_fields()\n+                    .map(|f| f.ty(cx.tcx, subs))\n+                    .any(|ty| type_needs_ordered_drop(cx, ty)),\n+                _ => true,\n+            }\n+        }\n+        // Check for std types which implement drop, but only for memory allocation.\n+        else if is_type_diagnostic_item(cx, ty, sym::vec_type)\n+            || is_type_lang_item(cx, ty, LangItem::OwnedBox)\n+            || is_type_diagnostic_item(cx, ty, sym::Rc)\n+            || is_type_diagnostic_item(cx, ty, sym::Arc)\n+            || is_type_diagnostic_item(cx, ty, sym::cstring_type)\n+            || match_type(cx, ty, &paths::BTREEMAP)\n+            || match_type(cx, ty, &paths::LINKED_LIST)\n+            || match_type(cx, ty, &paths::WEAK_RC)\n+            || match_type(cx, ty, &paths::WEAK_ARC)\n+        {\n+            // Check all of the generic arguments.\n+            if let ty::Adt(_, subs) = ty.kind() {\n+                subs.types().any(|ty| type_needs_ordered_drop(cx, ty))\n+            } else {\n+                true\n+            }\n+        } else {\n+            true\n+        }\n+    }\n+\n+    // Extract the generic arguments out of a type\n+    fn try_get_generic_ty(ty: Ty<'_>, index: usize) -> Option<Ty<'_>> {\n+        if_chain! {\n+            if let ty::Adt(_, subs) = ty.kind();\n+            if let Some(sub) = subs.get(index);\n+            if let GenericArgKind::Type(sub_ty) = sub.unpack();\n+            then {\n+                Some(sub_ty)\n+            } else {\n+                None\n+            }\n+        }\n+    }\n+\n+    // Checks if there are any temporaries created in the given expression for which drop order\n+    // matters.\n+    fn temporaries_need_ordered_drop(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) -> bool {\n+        struct V<'a, 'tcx> {\n+            cx: &'a LateContext<'tcx>,\n+            res: bool,\n+        }\n+        impl<'a, 'tcx> Visitor<'tcx> for V<'a, 'tcx> {\n+            type Map = ErasedMap<'tcx>;\n+            fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+                NestedVisitorMap::None\n+            }\n+\n+            fn visit_expr(&mut self, expr: &'tcx Expr<'tcx>) {\n+                match expr.kind {\n+                    // Taking the reference of a value leaves a temporary\n+                    // e.g. In `&String::new()` the string is a temporary value.\n+                    // Remaining fields are temporary values\n+                    // e.g. In `(String::new(), 0).1` the string is a temporary value.\n+                    ExprKind::AddrOf(_, _, expr) | ExprKind::Field(expr, _) => {\n+                        if !matches!(expr.kind, ExprKind::Path(_)) {\n+                            if type_needs_ordered_drop(self.cx, self.cx.typeck_results().expr_ty(expr)) {\n+                                self.res = true;\n+                            } else {\n+                                self.visit_expr(expr);\n+                            }\n+                        }\n+                    },\n+                    // the base type is alway taken by reference.\n+                    // e.g. In `(vec![0])[0]` the vector is a temporary value.\n+                    ExprKind::Index(base, index) => {\n+                        if !matches!(base.kind, ExprKind::Path(_)) {\n+                            if type_needs_ordered_drop(self.cx, self.cx.typeck_results().expr_ty(base)) {\n+                                self.res = true;\n+                            } else {\n+                                self.visit_expr(base);\n+                            }\n+                        }\n+                        self.visit_expr(index);\n+                    },\n+                    // Method calls can take self by reference.\n+                    // e.g. In `String::new().len()` the string is a temporary value.\n+                    ExprKind::MethodCall(_, _, [self_arg, args @ ..], _) => {\n+                        if !matches!(self_arg.kind, ExprKind::Path(_)) {\n+                            let self_by_ref = self\n+                                .cx\n+                                .typeck_results()\n+                                .type_dependent_def_id(expr.hir_id)\n+                                .map_or(false, |id| self.cx.tcx.fn_sig(id).skip_binder().inputs()[0].is_ref());\n+                            if self_by_ref\n+                                && type_needs_ordered_drop(self.cx, self.cx.typeck_results().expr_ty(self_arg))\n+                            {\n+                                self.res = true;\n+                            } else {\n+                                self.visit_expr(self_arg)\n+                            }\n+                        }\n+                        args.iter().for_each(|arg| self.visit_expr(arg));\n+                    },\n+                    // Either explicitly drops values, or changes control flow.\n+                    ExprKind::DropTemps(_)\n+                    | ExprKind::Ret(_)\n+                    | ExprKind::Break(..)\n+                    | ExprKind::Yield(..)\n+                    | ExprKind::Block(Block { expr: None, .. }, _)\n+                    | ExprKind::Loop(..) => (),\n+\n+                    // Only consider the final expression.\n+                    ExprKind::Block(Block { expr: Some(expr), .. }, _) => self.visit_expr(expr),\n+\n+                    _ => walk_expr(self, expr),\n+                }\n+            }\n+        }\n+\n+        let mut v = V { cx, res: false };\n+        v.visit_expr(expr);\n+        v.res\n+    }\n+\n     fn find_sugg_for_if_let<'tcx>(\n         cx: &LateContext<'tcx>,\n         expr: &'tcx Expr<'_>,\n-        op: &Expr<'_>,\n-        arms: &[Arm<'_>],\n+        op: &'tcx Expr<'tcx>,\n+        arm: &Arm<'_>,\n         keyword: &'static str,\n+        has_else: bool,\n     ) {\n         // also look inside refs\n-        let mut kind = &arms[0].pat.kind;\n+        let mut kind = &arm.pat.kind;\n         // if we have &None for example, peel it so we can detect \"if let None = x\"\n         if let PatKind::Ref(inner, _mutability) = kind {\n             kind = &inner.kind;\n         }\n-        let good_method = match kind {\n+        let op_ty = cx.typeck_results().expr_ty(op);\n+        // Determine which function should be used, and the type contained by the corresponding\n+        // variant.\n+        let (good_method, inner_ty) = match kind {\n             PatKind::TupleStruct(ref path, [sub_pat], _) => {\n                 if let PatKind::Wild = sub_pat.kind {\n                     if is_lang_ctor(cx, path, ResultOk) {\n-                        \"is_ok()\"\n+                        (\"is_ok()\", try_get_generic_ty(op_ty, 0).unwrap_or(op_ty))\n                     } else if is_lang_ctor(cx, path, ResultErr) {\n-                        \"is_err()\"\n+                        (\"is_err()\", try_get_generic_ty(op_ty, 1).unwrap_or(op_ty))\n                     } else if is_lang_ctor(cx, path, OptionSome) {\n-                        \"is_some()\"\n+                        (\"is_some()\", op_ty)\n                     } else if is_lang_ctor(cx, path, PollReady) {\n-                        \"is_ready()\"\n+                        (\"is_ready()\", op_ty)\n                     } else if is_qpath_def_path(cx, path, sub_pat.hir_id, &paths::IPADDR_V4) {\n-                        \"is_ipv4()\"\n+                        (\"is_ipv4()\", op_ty)\n                     } else if is_qpath_def_path(cx, path, sub_pat.hir_id, &paths::IPADDR_V6) {\n-                        \"is_ipv6()\"\n+                        (\"is_ipv6()\", op_ty)\n                     } else {\n                         return;\n                     }\n@@ -1760,17 +1916,36 @@ mod redundant_pattern_match {\n                 }\n             },\n             PatKind::Path(ref path) => {\n-                if is_lang_ctor(cx, path, OptionNone) {\n+                let method = if is_lang_ctor(cx, path, OptionNone) {\n                     \"is_none()\"\n                 } else if is_lang_ctor(cx, path, PollPending) {\n                     \"is_pending()\"\n                 } else {\n                     return;\n-                }\n+                };\n+                // `None` and `Pending` don't have an inner type.\n+                (method, cx.tcx.types.unit)\n             },\n             _ => return,\n         };\n \n+        // If this is the last expression in a block or there is an else clause then the whole\n+        // type needs to be considered, not just the inner type of the branch being matched on.\n+        // Note the last expression in a block is dropped after all local bindings.\n+        let check_ty = if has_else\n+            || (keyword == \"if\" && matches!(cx.tcx.hir().parent_iter(expr.hir_id).next(), Some((_, Node::Block(..)))))\n+        {\n+            op_ty\n+        } else {\n+            inner_ty\n+        };\n+\n+        // All temporaries created in the scrutinee expression are dropped at the same time as the\n+        // scrutinee would be, so they have to be considered as well.\n+        // e.g. in `if let Some(x) = foo.lock().unwrap().baz.as_ref() { .. }` the lock will be held\n+        // for the duration if body.\n+        let needs_drop = type_needs_ordered_drop(cx, check_ty) || temporaries_need_ordered_drop(cx, op);\n+\n         // check that `while_let_on_iterator` lint does not trigger\n         if_chain! {\n             if keyword == \"while\";\n@@ -1789,7 +1964,7 @@ mod redundant_pattern_match {\n         span_lint_and_then(\n             cx,\n             REDUNDANT_PATTERN_MATCHING,\n-            arms[0].pat.span,\n+            arm.pat.span,\n             &format!(\"redundant pattern matching, consider using `{}`\", good_method),\n             |diag| {\n                 // while let ... = ... { ... }\n@@ -1803,12 +1978,20 @@ mod redundant_pattern_match {\n                 // while let ... = ... { ... }\n                 // ^^^^^^^^^^^^^^^^^^^\n                 let span = expr_span.until(op_span.shrink_to_hi());\n-                diag.span_suggestion(\n-                    span,\n-                    \"try this\",\n-                    format!(\"{} {}.{}\", keyword, snippet(cx, op_span, \"_\"), good_method),\n-                    Applicability::MachineApplicable, // snippet\n-                );\n+\n+                let mut app = if needs_drop {\n+                    Applicability::MaybeIncorrect\n+                } else {\n+                    Applicability::MachineApplicable\n+                };\n+                let sugg = snippet_with_applicability(cx, op_span, \"_\", &mut app);\n+\n+                diag.span_suggestion(span, \"try this\", format!(\"{} {}.{}\", keyword, sugg, good_method), app);\n+\n+                if needs_drop {\n+                    diag.note(\"this will change drop order of the result, as well as all temporaries\");\n+                    diag.note(\"add `#[allow(clippy::redundant_pattern_matching)]` if this is important\");\n+                }\n             },\n         );\n     }"}, {"sha": "794ed542435d149910e44c4ecf712185b7df2355", "filename": "tests/ui/redundant_pattern_matching_drop_order.fixed", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/7f2068cc2bb3367eb1b0511318ab6b7093d024ca/tests%2Fui%2Fredundant_pattern_matching_drop_order.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/7f2068cc2bb3367eb1b0511318ab6b7093d024ca/tests%2Fui%2Fredundant_pattern_matching_drop_order.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fredundant_pattern_matching_drop_order.fixed?ref=7f2068cc2bb3367eb1b0511318ab6b7093d024ca", "patch": "@@ -0,0 +1,58 @@\n+// run-rustfix\n+\n+// Issue #5746\n+#![warn(clippy::redundant_pattern_matching)]\n+#![allow(clippy::if_same_then_else)]\n+use std::task::Poll::{Pending, Ready};\n+\n+fn main() {\n+    let m = std::sync::Mutex::new((0, 0));\n+\n+    // Result\n+    if m.lock().is_ok() {}\n+    if Err::<(), _>(m.lock().unwrap().0).is_err() {}\n+\n+    {\n+        if Ok::<_, std::sync::MutexGuard<()>>(()).is_ok() {}\n+    }\n+    if Ok::<_, std::sync::MutexGuard<()>>(()).is_ok() {\n+    } else {\n+    }\n+    if Ok::<_, std::sync::MutexGuard<()>>(()).is_ok() {}\n+    if Err::<std::sync::MutexGuard<()>, _>(()).is_err() {}\n+\n+    if Ok::<_, ()>(String::new()).is_ok() {}\n+    if Err::<(), _>((String::new(), ())).is_err() {}\n+\n+    // Option\n+    if Some(m.lock()).is_some() {}\n+    if Some(m.lock().unwrap().0).is_some() {}\n+\n+    {\n+        if None::<std::sync::MutexGuard<()>>.is_none() {}\n+    }\n+    if None::<std::sync::MutexGuard<()>>.is_none() {\n+    } else {\n+    }\n+\n+    if None::<std::sync::MutexGuard<()>>.is_none() {}\n+\n+    if Some(String::new()).is_some() {}\n+    if Some((String::new(), ())).is_some() {}\n+\n+    // Poll\n+    if Ready(m.lock()).is_ready() {}\n+    if Ready(m.lock().unwrap().0).is_ready() {}\n+\n+    {\n+        if Pending::<std::sync::MutexGuard<()>>.is_pending() {}\n+    }\n+    if Pending::<std::sync::MutexGuard<()>>.is_pending() {\n+    } else {\n+    }\n+\n+    if Pending::<std::sync::MutexGuard<()>>.is_pending() {}\n+\n+    if Ready(String::new()).is_ready() {}\n+    if Ready((String::new(), ())).is_ready() {}\n+}"}, {"sha": "b9c82d86f618b4041f6bb568d52e2d652e4934be", "filename": "tests/ui/redundant_pattern_matching_drop_order.rs", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/7f2068cc2bb3367eb1b0511318ab6b7093d024ca/tests%2Fui%2Fredundant_pattern_matching_drop_order.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f2068cc2bb3367eb1b0511318ab6b7093d024ca/tests%2Fui%2Fredundant_pattern_matching_drop_order.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fredundant_pattern_matching_drop_order.rs?ref=7f2068cc2bb3367eb1b0511318ab6b7093d024ca", "patch": "@@ -0,0 +1,58 @@\n+// run-rustfix\n+\n+// Issue #5746\n+#![warn(clippy::redundant_pattern_matching)]\n+#![allow(clippy::if_same_then_else)]\n+use std::task::Poll::{Pending, Ready};\n+\n+fn main() {\n+    let m = std::sync::Mutex::new((0, 0));\n+\n+    // Result\n+    if let Ok(_) = m.lock() {}\n+    if let Err(_) = Err::<(), _>(m.lock().unwrap().0) {}\n+\n+    {\n+        if let Ok(_) = Ok::<_, std::sync::MutexGuard<()>>(()) {}\n+    }\n+    if let Ok(_) = Ok::<_, std::sync::MutexGuard<()>>(()) {\n+    } else {\n+    }\n+    if let Ok(_) = Ok::<_, std::sync::MutexGuard<()>>(()) {}\n+    if let Err(_) = Err::<std::sync::MutexGuard<()>, _>(()) {}\n+\n+    if let Ok(_) = Ok::<_, ()>(String::new()) {}\n+    if let Err(_) = Err::<(), _>((String::new(), ())) {}\n+\n+    // Option\n+    if let Some(_) = Some(m.lock()) {}\n+    if let Some(_) = Some(m.lock().unwrap().0) {}\n+\n+    {\n+        if let None = None::<std::sync::MutexGuard<()>> {}\n+    }\n+    if let None = None::<std::sync::MutexGuard<()>> {\n+    } else {\n+    }\n+\n+    if let None = None::<std::sync::MutexGuard<()>> {}\n+\n+    if let Some(_) = Some(String::new()) {}\n+    if let Some(_) = Some((String::new(), ())) {}\n+\n+    // Poll\n+    if let Ready(_) = Ready(m.lock()) {}\n+    if let Ready(_) = Ready(m.lock().unwrap().0) {}\n+\n+    {\n+        if let Pending = Pending::<std::sync::MutexGuard<()>> {}\n+    }\n+    if let Pending = Pending::<std::sync::MutexGuard<()>> {\n+    } else {\n+    }\n+\n+    if let Pending = Pending::<std::sync::MutexGuard<()>> {}\n+\n+    if let Ready(_) = Ready(String::new()) {}\n+    if let Ready(_) = Ready((String::new(), ())) {}\n+}"}, {"sha": "eb7aa70ee27385ba7da308fdb1c6bae86afb97ff", "filename": "tests/ui/redundant_pattern_matching_drop_order.stderr", "status": "added", "additions": 171, "deletions": 0, "changes": 171, "blob_url": "https://github.com/rust-lang/rust/blob/7f2068cc2bb3367eb1b0511318ab6b7093d024ca/tests%2Fui%2Fredundant_pattern_matching_drop_order.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7f2068cc2bb3367eb1b0511318ab6b7093d024ca/tests%2Fui%2Fredundant_pattern_matching_drop_order.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fredundant_pattern_matching_drop_order.stderr?ref=7f2068cc2bb3367eb1b0511318ab6b7093d024ca", "patch": "@@ -0,0 +1,171 @@\n+error: redundant pattern matching, consider using `is_ok()`\n+  --> $DIR/redundant_pattern_matching_drop_order.rs:12:12\n+   |\n+LL |     if let Ok(_) = m.lock() {}\n+   |     -------^^^^^----------- help: try this: `if m.lock().is_ok()`\n+   |\n+   = note: `-D clippy::redundant-pattern-matching` implied by `-D warnings`\n+   = note: this will change drop order of the result, as well as all temporaries\n+   = note: add `#[allow(clippy::redundant_pattern_matching)]` if this is important\n+\n+error: redundant pattern matching, consider using `is_err()`\n+  --> $DIR/redundant_pattern_matching_drop_order.rs:13:12\n+   |\n+LL |     if let Err(_) = Err::<(), _>(m.lock().unwrap().0) {}\n+   |     -------^^^^^^------------------------------------ help: try this: `if Err::<(), _>(m.lock().unwrap().0).is_err()`\n+   |\n+   = note: this will change drop order of the result, as well as all temporaries\n+   = note: add `#[allow(clippy::redundant_pattern_matching)]` if this is important\n+\n+error: redundant pattern matching, consider using `is_ok()`\n+  --> $DIR/redundant_pattern_matching_drop_order.rs:16:16\n+   |\n+LL |         if let Ok(_) = Ok::<_, std::sync::MutexGuard<()>>(()) {}\n+   |         -------^^^^^----------------------------------------- help: try this: `if Ok::<_, std::sync::MutexGuard<()>>(()).is_ok()`\n+   |\n+   = note: this will change drop order of the result, as well as all temporaries\n+   = note: add `#[allow(clippy::redundant_pattern_matching)]` if this is important\n+\n+error: redundant pattern matching, consider using `is_ok()`\n+  --> $DIR/redundant_pattern_matching_drop_order.rs:18:12\n+   |\n+LL |     if let Ok(_) = Ok::<_, std::sync::MutexGuard<()>>(()) {\n+   |     -------^^^^^----------------------------------------- help: try this: `if Ok::<_, std::sync::MutexGuard<()>>(()).is_ok()`\n+   |\n+   = note: this will change drop order of the result, as well as all temporaries\n+   = note: add `#[allow(clippy::redundant_pattern_matching)]` if this is important\n+\n+error: redundant pattern matching, consider using `is_ok()`\n+  --> $DIR/redundant_pattern_matching_drop_order.rs:21:12\n+   |\n+LL |     if let Ok(_) = Ok::<_, std::sync::MutexGuard<()>>(()) {}\n+   |     -------^^^^^----------------------------------------- help: try this: `if Ok::<_, std::sync::MutexGuard<()>>(()).is_ok()`\n+\n+error: redundant pattern matching, consider using `is_err()`\n+  --> $DIR/redundant_pattern_matching_drop_order.rs:22:12\n+   |\n+LL |     if let Err(_) = Err::<std::sync::MutexGuard<()>, _>(()) {}\n+   |     -------^^^^^^------------------------------------------ help: try this: `if Err::<std::sync::MutexGuard<()>, _>(()).is_err()`\n+\n+error: redundant pattern matching, consider using `is_ok()`\n+  --> $DIR/redundant_pattern_matching_drop_order.rs:24:12\n+   |\n+LL |     if let Ok(_) = Ok::<_, ()>(String::new()) {}\n+   |     -------^^^^^----------------------------- help: try this: `if Ok::<_, ()>(String::new()).is_ok()`\n+\n+error: redundant pattern matching, consider using `is_err()`\n+  --> $DIR/redundant_pattern_matching_drop_order.rs:25:12\n+   |\n+LL |     if let Err(_) = Err::<(), _>((String::new(), ())) {}\n+   |     -------^^^^^^------------------------------------ help: try this: `if Err::<(), _>((String::new(), ())).is_err()`\n+\n+error: redundant pattern matching, consider using `is_some()`\n+  --> $DIR/redundant_pattern_matching_drop_order.rs:28:12\n+   |\n+LL |     if let Some(_) = Some(m.lock()) {}\n+   |     -------^^^^^^^----------------- help: try this: `if Some(m.lock()).is_some()`\n+   |\n+   = note: this will change drop order of the result, as well as all temporaries\n+   = note: add `#[allow(clippy::redundant_pattern_matching)]` if this is important\n+\n+error: redundant pattern matching, consider using `is_some()`\n+  --> $DIR/redundant_pattern_matching_drop_order.rs:29:12\n+   |\n+LL |     if let Some(_) = Some(m.lock().unwrap().0) {}\n+   |     -------^^^^^^^---------------------------- help: try this: `if Some(m.lock().unwrap().0).is_some()`\n+   |\n+   = note: this will change drop order of the result, as well as all temporaries\n+   = note: add `#[allow(clippy::redundant_pattern_matching)]` if this is important\n+\n+error: redundant pattern matching, consider using `is_none()`\n+  --> $DIR/redundant_pattern_matching_drop_order.rs:32:16\n+   |\n+LL |         if let None = None::<std::sync::MutexGuard<()>> {}\n+   |         -------^^^^------------------------------------ help: try this: `if None::<std::sync::MutexGuard<()>>.is_none()`\n+   |\n+   = note: this will change drop order of the result, as well as all temporaries\n+   = note: add `#[allow(clippy::redundant_pattern_matching)]` if this is important\n+\n+error: redundant pattern matching, consider using `is_none()`\n+  --> $DIR/redundant_pattern_matching_drop_order.rs:34:12\n+   |\n+LL |     if let None = None::<std::sync::MutexGuard<()>> {\n+   |     -------^^^^------------------------------------ help: try this: `if None::<std::sync::MutexGuard<()>>.is_none()`\n+   |\n+   = note: this will change drop order of the result, as well as all temporaries\n+   = note: add `#[allow(clippy::redundant_pattern_matching)]` if this is important\n+\n+error: redundant pattern matching, consider using `is_none()`\n+  --> $DIR/redundant_pattern_matching_drop_order.rs:38:12\n+   |\n+LL |     if let None = None::<std::sync::MutexGuard<()>> {}\n+   |     -------^^^^------------------------------------ help: try this: `if None::<std::sync::MutexGuard<()>>.is_none()`\n+\n+error: redundant pattern matching, consider using `is_some()`\n+  --> $DIR/redundant_pattern_matching_drop_order.rs:40:12\n+   |\n+LL |     if let Some(_) = Some(String::new()) {}\n+   |     -------^^^^^^^---------------------- help: try this: `if Some(String::new()).is_some()`\n+\n+error: redundant pattern matching, consider using `is_some()`\n+  --> $DIR/redundant_pattern_matching_drop_order.rs:41:12\n+   |\n+LL |     if let Some(_) = Some((String::new(), ())) {}\n+   |     -------^^^^^^^---------------------------- help: try this: `if Some((String::new(), ())).is_some()`\n+\n+error: redundant pattern matching, consider using `is_ready()`\n+  --> $DIR/redundant_pattern_matching_drop_order.rs:44:12\n+   |\n+LL |     if let Ready(_) = Ready(m.lock()) {}\n+   |     -------^^^^^^^^------------------ help: try this: `if Ready(m.lock()).is_ready()`\n+   |\n+   = note: this will change drop order of the result, as well as all temporaries\n+   = note: add `#[allow(clippy::redundant_pattern_matching)]` if this is important\n+\n+error: redundant pattern matching, consider using `is_ready()`\n+  --> $DIR/redundant_pattern_matching_drop_order.rs:45:12\n+   |\n+LL |     if let Ready(_) = Ready(m.lock().unwrap().0) {}\n+   |     -------^^^^^^^^----------------------------- help: try this: `if Ready(m.lock().unwrap().0).is_ready()`\n+   |\n+   = note: this will change drop order of the result, as well as all temporaries\n+   = note: add `#[allow(clippy::redundant_pattern_matching)]` if this is important\n+\n+error: redundant pattern matching, consider using `is_pending()`\n+  --> $DIR/redundant_pattern_matching_drop_order.rs:48:16\n+   |\n+LL |         if let Pending = Pending::<std::sync::MutexGuard<()>> {}\n+   |         -------^^^^^^^--------------------------------------- help: try this: `if Pending::<std::sync::MutexGuard<()>>.is_pending()`\n+   |\n+   = note: this will change drop order of the result, as well as all temporaries\n+   = note: add `#[allow(clippy::redundant_pattern_matching)]` if this is important\n+\n+error: redundant pattern matching, consider using `is_pending()`\n+  --> $DIR/redundant_pattern_matching_drop_order.rs:50:12\n+   |\n+LL |     if let Pending = Pending::<std::sync::MutexGuard<()>> {\n+   |     -------^^^^^^^--------------------------------------- help: try this: `if Pending::<std::sync::MutexGuard<()>>.is_pending()`\n+   |\n+   = note: this will change drop order of the result, as well as all temporaries\n+   = note: add `#[allow(clippy::redundant_pattern_matching)]` if this is important\n+\n+error: redundant pattern matching, consider using `is_pending()`\n+  --> $DIR/redundant_pattern_matching_drop_order.rs:54:12\n+   |\n+LL |     if let Pending = Pending::<std::sync::MutexGuard<()>> {}\n+   |     -------^^^^^^^--------------------------------------- help: try this: `if Pending::<std::sync::MutexGuard<()>>.is_pending()`\n+\n+error: redundant pattern matching, consider using `is_ready()`\n+  --> $DIR/redundant_pattern_matching_drop_order.rs:56:12\n+   |\n+LL |     if let Ready(_) = Ready(String::new()) {}\n+   |     -------^^^^^^^^----------------------- help: try this: `if Ready(String::new()).is_ready()`\n+\n+error: redundant pattern matching, consider using `is_ready()`\n+  --> $DIR/redundant_pattern_matching_drop_order.rs:57:12\n+   |\n+LL |     if let Ready(_) = Ready((String::new(), ())) {}\n+   |     -------^^^^^^^^----------------------------- help: try this: `if Ready((String::new(), ())).is_ready()`\n+\n+error: aborting due to 22 previous errors\n+"}, {"sha": "997144772669be4fdabd45a0834deebf1c8c3388", "filename": "tests/ui/redundant_pattern_matching_option.fixed", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7f2068cc2bb3367eb1b0511318ab6b7093d024ca/tests%2Fui%2Fredundant_pattern_matching_option.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/7f2068cc2bb3367eb1b0511318ab6b7093d024ca/tests%2Fui%2Fredundant_pattern_matching_option.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fredundant_pattern_matching_option.fixed?ref=7f2068cc2bb3367eb1b0511318ab6b7093d024ca", "patch": "@@ -2,7 +2,12 @@\n \n #![warn(clippy::all)]\n #![warn(clippy::redundant_pattern_matching)]\n-#![allow(unused_must_use, clippy::needless_bool, clippy::match_like_matches_macro)]\n+#![allow(\n+    unused_must_use,\n+    clippy::needless_bool,\n+    clippy::match_like_matches_macro,\n+    clippy::if_same_then_else\n+)]\n \n fn main() {\n     if None::<()>.is_none() {}"}, {"sha": "8309847e18162796d787c4bb771bb5ffd7f58600", "filename": "tests/ui/redundant_pattern_matching_option.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7f2068cc2bb3367eb1b0511318ab6b7093d024ca/tests%2Fui%2Fredundant_pattern_matching_option.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f2068cc2bb3367eb1b0511318ab6b7093d024ca/tests%2Fui%2Fredundant_pattern_matching_option.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fredundant_pattern_matching_option.rs?ref=7f2068cc2bb3367eb1b0511318ab6b7093d024ca", "patch": "@@ -2,7 +2,12 @@\n \n #![warn(clippy::all)]\n #![warn(clippy::redundant_pattern_matching)]\n-#![allow(unused_must_use, clippy::needless_bool, clippy::match_like_matches_macro)]\n+#![allow(\n+    unused_must_use,\n+    clippy::needless_bool,\n+    clippy::match_like_matches_macro,\n+    clippy::if_same_then_else\n+)]\n \n fn main() {\n     if let None = None::<()> {}"}, {"sha": "613a30d4a48453bbede0d3c9f4386a7b304938a3", "filename": "tests/ui/redundant_pattern_matching_option.stderr", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/7f2068cc2bb3367eb1b0511318ab6b7093d024ca/tests%2Fui%2Fredundant_pattern_matching_option.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7f2068cc2bb3367eb1b0511318ab6b7093d024ca/tests%2Fui%2Fredundant_pattern_matching_option.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fredundant_pattern_matching_option.stderr?ref=7f2068cc2bb3367eb1b0511318ab6b7093d024ca", "patch": "@@ -1,49 +1,49 @@\n error: redundant pattern matching, consider using `is_none()`\n-  --> $DIR/redundant_pattern_matching_option.rs:8:12\n+  --> $DIR/redundant_pattern_matching_option.rs:13:12\n    |\n LL |     if let None = None::<()> {}\n    |     -------^^^^------------- help: try this: `if None::<()>.is_none()`\n    |\n    = note: `-D clippy::redundant-pattern-matching` implied by `-D warnings`\n \n error: redundant pattern matching, consider using `is_some()`\n-  --> $DIR/redundant_pattern_matching_option.rs:10:12\n+  --> $DIR/redundant_pattern_matching_option.rs:15:12\n    |\n LL |     if let Some(_) = Some(42) {}\n    |     -------^^^^^^^----------- help: try this: `if Some(42).is_some()`\n \n error: redundant pattern matching, consider using `is_some()`\n-  --> $DIR/redundant_pattern_matching_option.rs:12:12\n+  --> $DIR/redundant_pattern_matching_option.rs:17:12\n    |\n LL |     if let Some(_) = Some(42) {\n    |     -------^^^^^^^----------- help: try this: `if Some(42).is_some()`\n \n error: redundant pattern matching, consider using `is_some()`\n-  --> $DIR/redundant_pattern_matching_option.rs:18:15\n+  --> $DIR/redundant_pattern_matching_option.rs:23:15\n    |\n LL |     while let Some(_) = Some(42) {}\n    |     ----------^^^^^^^----------- help: try this: `while Some(42).is_some()`\n \n error: redundant pattern matching, consider using `is_none()`\n-  --> $DIR/redundant_pattern_matching_option.rs:20:15\n+  --> $DIR/redundant_pattern_matching_option.rs:25:15\n    |\n LL |     while let None = Some(42) {}\n    |     ----------^^^^----------- help: try this: `while Some(42).is_none()`\n \n error: redundant pattern matching, consider using `is_none()`\n-  --> $DIR/redundant_pattern_matching_option.rs:22:15\n+  --> $DIR/redundant_pattern_matching_option.rs:27:15\n    |\n LL |     while let None = None::<()> {}\n    |     ----------^^^^------------- help: try this: `while None::<()>.is_none()`\n \n error: redundant pattern matching, consider using `is_some()`\n-  --> $DIR/redundant_pattern_matching_option.rs:25:15\n+  --> $DIR/redundant_pattern_matching_option.rs:30:15\n    |\n LL |     while let Some(_) = v.pop() {\n    |     ----------^^^^^^^---------- help: try this: `while v.pop().is_some()`\n \n error: redundant pattern matching, consider using `is_some()`\n-  --> $DIR/redundant_pattern_matching_option.rs:33:5\n+  --> $DIR/redundant_pattern_matching_option.rs:38:5\n    |\n LL | /     match Some(42) {\n LL | |         Some(_) => true,\n@@ -52,7 +52,7 @@ LL | |     };\n    | |_____^ help: try this: `Some(42).is_some()`\n \n error: redundant pattern matching, consider using `is_none()`\n-  --> $DIR/redundant_pattern_matching_option.rs:38:5\n+  --> $DIR/redundant_pattern_matching_option.rs:43:5\n    |\n LL | /     match None::<()> {\n LL | |         Some(_) => false,\n@@ -61,7 +61,7 @@ LL | |     };\n    | |_____^ help: try this: `None::<()>.is_none()`\n \n error: redundant pattern matching, consider using `is_none()`\n-  --> $DIR/redundant_pattern_matching_option.rs:43:13\n+  --> $DIR/redundant_pattern_matching_option.rs:48:13\n    |\n LL |       let _ = match None::<()> {\n    |  _____________^\n@@ -71,49 +71,49 @@ LL | |     };\n    | |_____^ help: try this: `None::<()>.is_none()`\n \n error: redundant pattern matching, consider using `is_some()`\n-  --> $DIR/redundant_pattern_matching_option.rs:49:20\n+  --> $DIR/redundant_pattern_matching_option.rs:54:20\n    |\n LL |     let _ = if let Some(_) = opt { true } else { false };\n    |             -------^^^^^^^------ help: try this: `if opt.is_some()`\n \n error: redundant pattern matching, consider using `is_some()`\n-  --> $DIR/redundant_pattern_matching_option.rs:53:20\n+  --> $DIR/redundant_pattern_matching_option.rs:58:20\n    |\n LL |     let _ = if let Some(_) = gen_opt() {\n    |             -------^^^^^^^------------ help: try this: `if gen_opt().is_some()`\n \n error: redundant pattern matching, consider using `is_none()`\n-  --> $DIR/redundant_pattern_matching_option.rs:55:19\n+  --> $DIR/redundant_pattern_matching_option.rs:60:19\n    |\n LL |     } else if let None = gen_opt() {\n    |            -------^^^^------------ help: try this: `if gen_opt().is_none()`\n \n error: redundant pattern matching, consider using `is_some()`\n-  --> $DIR/redundant_pattern_matching_option.rs:74:12\n+  --> $DIR/redundant_pattern_matching_option.rs:79:12\n    |\n LL |     if let Some(_) = Some(42) {}\n    |     -------^^^^^^^----------- help: try this: `if Some(42).is_some()`\n \n error: redundant pattern matching, consider using `is_none()`\n-  --> $DIR/redundant_pattern_matching_option.rs:76:12\n+  --> $DIR/redundant_pattern_matching_option.rs:81:12\n    |\n LL |     if let None = None::<()> {}\n    |     -------^^^^------------- help: try this: `if None::<()>.is_none()`\n \n error: redundant pattern matching, consider using `is_some()`\n-  --> $DIR/redundant_pattern_matching_option.rs:78:15\n+  --> $DIR/redundant_pattern_matching_option.rs:83:15\n    |\n LL |     while let Some(_) = Some(42) {}\n    |     ----------^^^^^^^----------- help: try this: `while Some(42).is_some()`\n \n error: redundant pattern matching, consider using `is_none()`\n-  --> $DIR/redundant_pattern_matching_option.rs:80:15\n+  --> $DIR/redundant_pattern_matching_option.rs:85:15\n    |\n LL |     while let None = None::<()> {}\n    |     ----------^^^^------------- help: try this: `while None::<()>.is_none()`\n \n error: redundant pattern matching, consider using `is_some()`\n-  --> $DIR/redundant_pattern_matching_option.rs:82:5\n+  --> $DIR/redundant_pattern_matching_option.rs:87:5\n    |\n LL | /     match Some(42) {\n LL | |         Some(_) => true,\n@@ -122,7 +122,7 @@ LL | |     };\n    | |_____^ help: try this: `Some(42).is_some()`\n \n error: redundant pattern matching, consider using `is_none()`\n-  --> $DIR/redundant_pattern_matching_option.rs:87:5\n+  --> $DIR/redundant_pattern_matching_option.rs:92:5\n    |\n LL | /     match None::<()> {\n LL | |         Some(_) => false,"}, {"sha": "c297745380404030beee5b4487083387349af196", "filename": "tests/ui/redundant_pattern_matching_poll.fixed", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7f2068cc2bb3367eb1b0511318ab6b7093d024ca/tests%2Fui%2Fredundant_pattern_matching_poll.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/7f2068cc2bb3367eb1b0511318ab6b7093d024ca/tests%2Fui%2Fredundant_pattern_matching_poll.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fredundant_pattern_matching_poll.fixed?ref=7f2068cc2bb3367eb1b0511318ab6b7093d024ca", "patch": "@@ -2,7 +2,12 @@\n \n #![warn(clippy::all)]\n #![warn(clippy::redundant_pattern_matching)]\n-#![allow(unused_must_use, clippy::needless_bool, clippy::match_like_matches_macro)]\n+#![allow(\n+    unused_must_use,\n+    clippy::needless_bool,\n+    clippy::match_like_matches_macro,\n+    clippy::if_same_then_else\n+)]\n \n use std::task::Poll::{self, Pending, Ready};\n "}, {"sha": "665c8c417504dbb1b54b4c48e1ef39216c6d6a83", "filename": "tests/ui/redundant_pattern_matching_poll.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7f2068cc2bb3367eb1b0511318ab6b7093d024ca/tests%2Fui%2Fredundant_pattern_matching_poll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f2068cc2bb3367eb1b0511318ab6b7093d024ca/tests%2Fui%2Fredundant_pattern_matching_poll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fredundant_pattern_matching_poll.rs?ref=7f2068cc2bb3367eb1b0511318ab6b7093d024ca", "patch": "@@ -2,7 +2,12 @@\n \n #![warn(clippy::all)]\n #![warn(clippy::redundant_pattern_matching)]\n-#![allow(unused_must_use, clippy::needless_bool, clippy::match_like_matches_macro)]\n+#![allow(\n+    unused_must_use,\n+    clippy::needless_bool,\n+    clippy::match_like_matches_macro,\n+    clippy::if_same_then_else\n+)]\n \n use std::task::Poll::{self, Pending, Ready};\n "}, {"sha": "5ecf024a733a31a376e589f87898357995aceb97", "filename": "tests/ui/redundant_pattern_matching_poll.stderr", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/7f2068cc2bb3367eb1b0511318ab6b7093d024ca/tests%2Fui%2Fredundant_pattern_matching_poll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7f2068cc2bb3367eb1b0511318ab6b7093d024ca/tests%2Fui%2Fredundant_pattern_matching_poll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fredundant_pattern_matching_poll.stderr?ref=7f2068cc2bb3367eb1b0511318ab6b7093d024ca", "patch": "@@ -1,43 +1,43 @@\n error: redundant pattern matching, consider using `is_pending()`\n-  --> $DIR/redundant_pattern_matching_poll.rs:10:12\n+  --> $DIR/redundant_pattern_matching_poll.rs:15:12\n    |\n LL |     if let Pending = Pending::<()> {}\n    |     -------^^^^^^^---------------- help: try this: `if Pending::<()>.is_pending()`\n    |\n    = note: `-D clippy::redundant-pattern-matching` implied by `-D warnings`\n \n error: redundant pattern matching, consider using `is_ready()`\n-  --> $DIR/redundant_pattern_matching_poll.rs:12:12\n+  --> $DIR/redundant_pattern_matching_poll.rs:17:12\n    |\n LL |     if let Ready(_) = Ready(42) {}\n    |     -------^^^^^^^^------------ help: try this: `if Ready(42).is_ready()`\n \n error: redundant pattern matching, consider using `is_ready()`\n-  --> $DIR/redundant_pattern_matching_poll.rs:14:12\n+  --> $DIR/redundant_pattern_matching_poll.rs:19:12\n    |\n LL |     if let Ready(_) = Ready(42) {\n    |     -------^^^^^^^^------------ help: try this: `if Ready(42).is_ready()`\n \n error: redundant pattern matching, consider using `is_ready()`\n-  --> $DIR/redundant_pattern_matching_poll.rs:20:15\n+  --> $DIR/redundant_pattern_matching_poll.rs:25:15\n    |\n LL |     while let Ready(_) = Ready(42) {}\n    |     ----------^^^^^^^^------------ help: try this: `while Ready(42).is_ready()`\n \n error: redundant pattern matching, consider using `is_pending()`\n-  --> $DIR/redundant_pattern_matching_poll.rs:22:15\n+  --> $DIR/redundant_pattern_matching_poll.rs:27:15\n    |\n LL |     while let Pending = Ready(42) {}\n    |     ----------^^^^^^^------------ help: try this: `while Ready(42).is_pending()`\n \n error: redundant pattern matching, consider using `is_pending()`\n-  --> $DIR/redundant_pattern_matching_poll.rs:24:15\n+  --> $DIR/redundant_pattern_matching_poll.rs:29:15\n    |\n LL |     while let Pending = Pending::<()> {}\n    |     ----------^^^^^^^---------------- help: try this: `while Pending::<()>.is_pending()`\n \n error: redundant pattern matching, consider using `is_ready()`\n-  --> $DIR/redundant_pattern_matching_poll.rs:30:5\n+  --> $DIR/redundant_pattern_matching_poll.rs:35:5\n    |\n LL | /     match Ready(42) {\n LL | |         Ready(_) => true,\n@@ -46,7 +46,7 @@ LL | |     };\n    | |_____^ help: try this: `Ready(42).is_ready()`\n \n error: redundant pattern matching, consider using `is_pending()`\n-  --> $DIR/redundant_pattern_matching_poll.rs:35:5\n+  --> $DIR/redundant_pattern_matching_poll.rs:40:5\n    |\n LL | /     match Pending::<()> {\n LL | |         Ready(_) => false,\n@@ -55,7 +55,7 @@ LL | |     };\n    | |_____^ help: try this: `Pending::<()>.is_pending()`\n \n error: redundant pattern matching, consider using `is_pending()`\n-  --> $DIR/redundant_pattern_matching_poll.rs:40:13\n+  --> $DIR/redundant_pattern_matching_poll.rs:45:13\n    |\n LL |       let _ = match Pending::<()> {\n    |  _____________^\n@@ -65,49 +65,49 @@ LL | |     };\n    | |_____^ help: try this: `Pending::<()>.is_pending()`\n \n error: redundant pattern matching, consider using `is_ready()`\n-  --> $DIR/redundant_pattern_matching_poll.rs:46:20\n+  --> $DIR/redundant_pattern_matching_poll.rs:51:20\n    |\n LL |     let _ = if let Ready(_) = poll { true } else { false };\n    |             -------^^^^^^^^------- help: try this: `if poll.is_ready()`\n \n error: redundant pattern matching, consider using `is_ready()`\n-  --> $DIR/redundant_pattern_matching_poll.rs:50:20\n+  --> $DIR/redundant_pattern_matching_poll.rs:55:20\n    |\n LL |     let _ = if let Ready(_) = gen_poll() {\n    |             -------^^^^^^^^------------- help: try this: `if gen_poll().is_ready()`\n \n error: redundant pattern matching, consider using `is_pending()`\n-  --> $DIR/redundant_pattern_matching_poll.rs:52:19\n+  --> $DIR/redundant_pattern_matching_poll.rs:57:19\n    |\n LL |     } else if let Pending = gen_poll() {\n    |            -------^^^^^^^------------- help: try this: `if gen_poll().is_pending()`\n \n error: redundant pattern matching, consider using `is_ready()`\n-  --> $DIR/redundant_pattern_matching_poll.rs:68:12\n+  --> $DIR/redundant_pattern_matching_poll.rs:73:12\n    |\n LL |     if let Ready(_) = Ready(42) {}\n    |     -------^^^^^^^^------------ help: try this: `if Ready(42).is_ready()`\n \n error: redundant pattern matching, consider using `is_pending()`\n-  --> $DIR/redundant_pattern_matching_poll.rs:70:12\n+  --> $DIR/redundant_pattern_matching_poll.rs:75:12\n    |\n LL |     if let Pending = Pending::<()> {}\n    |     -------^^^^^^^---------------- help: try this: `if Pending::<()>.is_pending()`\n \n error: redundant pattern matching, consider using `is_ready()`\n-  --> $DIR/redundant_pattern_matching_poll.rs:72:15\n+  --> $DIR/redundant_pattern_matching_poll.rs:77:15\n    |\n LL |     while let Ready(_) = Ready(42) {}\n    |     ----------^^^^^^^^------------ help: try this: `while Ready(42).is_ready()`\n \n error: redundant pattern matching, consider using `is_pending()`\n-  --> $DIR/redundant_pattern_matching_poll.rs:74:15\n+  --> $DIR/redundant_pattern_matching_poll.rs:79:15\n    |\n LL |     while let Pending = Pending::<()> {}\n    |     ----------^^^^^^^---------------- help: try this: `while Pending::<()>.is_pending()`\n \n error: redundant pattern matching, consider using `is_ready()`\n-  --> $DIR/redundant_pattern_matching_poll.rs:76:5\n+  --> $DIR/redundant_pattern_matching_poll.rs:81:5\n    |\n LL | /     match Ready(42) {\n LL | |         Ready(_) => true,\n@@ -116,7 +116,7 @@ LL | |     };\n    | |_____^ help: try this: `Ready(42).is_ready()`\n \n error: redundant pattern matching, consider using `is_pending()`\n-  --> $DIR/redundant_pattern_matching_poll.rs:81:5\n+  --> $DIR/redundant_pattern_matching_poll.rs:86:5\n    |\n LL | /     match Pending::<()> {\n LL | |         Ready(_) => false,"}, {"sha": "d7af5d762ae4a9f8485feba9e4ae915c95f76100", "filename": "tests/ui/redundant_pattern_matching_result.fixed", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7f2068cc2bb3367eb1b0511318ab6b7093d024ca/tests%2Fui%2Fredundant_pattern_matching_result.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/7f2068cc2bb3367eb1b0511318ab6b7093d024ca/tests%2Fui%2Fredundant_pattern_matching_result.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fredundant_pattern_matching_result.fixed?ref=7f2068cc2bb3367eb1b0511318ab6b7093d024ca", "patch": "@@ -7,7 +7,8 @@\n     clippy::needless_bool,\n     clippy::match_like_matches_macro,\n     clippy::unnecessary_wraps,\n-    deprecated\n+    deprecated,\n+    clippy::if_same_then_else\n )]\n \n fn main() {"}, {"sha": "e06d4485ae4f295e98ff223ebb04a48084c07ffe", "filename": "tests/ui/redundant_pattern_matching_result.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7f2068cc2bb3367eb1b0511318ab6b7093d024ca/tests%2Fui%2Fredundant_pattern_matching_result.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f2068cc2bb3367eb1b0511318ab6b7093d024ca/tests%2Fui%2Fredundant_pattern_matching_result.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fredundant_pattern_matching_result.rs?ref=7f2068cc2bb3367eb1b0511318ab6b7093d024ca", "patch": "@@ -7,7 +7,8 @@\n     clippy::needless_bool,\n     clippy::match_like_matches_macro,\n     clippy::unnecessary_wraps,\n-    deprecated\n+    deprecated,\n+    clippy::if_same_then_else\n )]\n \n fn main() {"}, {"sha": "e06f095da20c6a723f19ef019ca64de33684072b", "filename": "tests/ui/redundant_pattern_matching_result.stderr", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/7f2068cc2bb3367eb1b0511318ab6b7093d024ca/tests%2Fui%2Fredundant_pattern_matching_result.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7f2068cc2bb3367eb1b0511318ab6b7093d024ca/tests%2Fui%2Fredundant_pattern_matching_result.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fredundant_pattern_matching_result.stderr?ref=7f2068cc2bb3367eb1b0511318ab6b7093d024ca", "patch": "@@ -1,37 +1,37 @@\n error: redundant pattern matching, consider using `is_ok()`\n-  --> $DIR/redundant_pattern_matching_result.rs:15:12\n+  --> $DIR/redundant_pattern_matching_result.rs:16:12\n    |\n LL |     if let Ok(_) = &result {}\n    |     -------^^^^^---------- help: try this: `if result.is_ok()`\n    |\n    = note: `-D clippy::redundant-pattern-matching` implied by `-D warnings`\n \n error: redundant pattern matching, consider using `is_ok()`\n-  --> $DIR/redundant_pattern_matching_result.rs:17:12\n+  --> $DIR/redundant_pattern_matching_result.rs:18:12\n    |\n LL |     if let Ok(_) = Ok::<i32, i32>(42) {}\n    |     -------^^^^^--------------------- help: try this: `if Ok::<i32, i32>(42).is_ok()`\n \n error: redundant pattern matching, consider using `is_err()`\n-  --> $DIR/redundant_pattern_matching_result.rs:19:12\n+  --> $DIR/redundant_pattern_matching_result.rs:20:12\n    |\n LL |     if let Err(_) = Err::<i32, i32>(42) {}\n    |     -------^^^^^^---------------------- help: try this: `if Err::<i32, i32>(42).is_err()`\n \n error: redundant pattern matching, consider using `is_ok()`\n-  --> $DIR/redundant_pattern_matching_result.rs:21:15\n+  --> $DIR/redundant_pattern_matching_result.rs:22:15\n    |\n LL |     while let Ok(_) = Ok::<i32, i32>(10) {}\n    |     ----------^^^^^--------------------- help: try this: `while Ok::<i32, i32>(10).is_ok()`\n \n error: redundant pattern matching, consider using `is_err()`\n-  --> $DIR/redundant_pattern_matching_result.rs:23:15\n+  --> $DIR/redundant_pattern_matching_result.rs:24:15\n    |\n LL |     while let Err(_) = Ok::<i32, i32>(10) {}\n    |     ----------^^^^^^--------------------- help: try this: `while Ok::<i32, i32>(10).is_err()`\n \n error: redundant pattern matching, consider using `is_ok()`\n-  --> $DIR/redundant_pattern_matching_result.rs:33:5\n+  --> $DIR/redundant_pattern_matching_result.rs:34:5\n    |\n LL | /     match Ok::<i32, i32>(42) {\n LL | |         Ok(_) => true,\n@@ -40,7 +40,7 @@ LL | |     };\n    | |_____^ help: try this: `Ok::<i32, i32>(42).is_ok()`\n \n error: redundant pattern matching, consider using `is_err()`\n-  --> $DIR/redundant_pattern_matching_result.rs:38:5\n+  --> $DIR/redundant_pattern_matching_result.rs:39:5\n    |\n LL | /     match Ok::<i32, i32>(42) {\n LL | |         Ok(_) => false,\n@@ -49,7 +49,7 @@ LL | |     };\n    | |_____^ help: try this: `Ok::<i32, i32>(42).is_err()`\n \n error: redundant pattern matching, consider using `is_err()`\n-  --> $DIR/redundant_pattern_matching_result.rs:43:5\n+  --> $DIR/redundant_pattern_matching_result.rs:44:5\n    |\n LL | /     match Err::<i32, i32>(42) {\n LL | |         Ok(_) => false,\n@@ -58,7 +58,7 @@ LL | |     };\n    | |_____^ help: try this: `Err::<i32, i32>(42).is_err()`\n \n error: redundant pattern matching, consider using `is_ok()`\n-  --> $DIR/redundant_pattern_matching_result.rs:48:5\n+  --> $DIR/redundant_pattern_matching_result.rs:49:5\n    |\n LL | /     match Err::<i32, i32>(42) {\n LL | |         Ok(_) => true,\n@@ -67,73 +67,73 @@ LL | |     };\n    | |_____^ help: try this: `Err::<i32, i32>(42).is_ok()`\n \n error: redundant pattern matching, consider using `is_ok()`\n-  --> $DIR/redundant_pattern_matching_result.rs:53:20\n+  --> $DIR/redundant_pattern_matching_result.rs:54:20\n    |\n LL |     let _ = if let Ok(_) = Ok::<usize, ()>(4) { true } else { false };\n    |             -------^^^^^--------------------- help: try this: `if Ok::<usize, ()>(4).is_ok()`\n \n error: redundant pattern matching, consider using `is_ok()`\n-  --> $DIR/redundant_pattern_matching_result.rs:59:20\n+  --> $DIR/redundant_pattern_matching_result.rs:60:20\n    |\n LL |     let _ = if let Ok(_) = gen_res() {\n    |             -------^^^^^------------ help: try this: `if gen_res().is_ok()`\n \n error: redundant pattern matching, consider using `is_err()`\n-  --> $DIR/redundant_pattern_matching_result.rs:61:19\n+  --> $DIR/redundant_pattern_matching_result.rs:62:19\n    |\n LL |     } else if let Err(_) = gen_res() {\n    |            -------^^^^^^------------ help: try this: `if gen_res().is_err()`\n \n error: redundant pattern matching, consider using `is_some()`\n-  --> $DIR/redundant_pattern_matching_result.rs:84:19\n+  --> $DIR/redundant_pattern_matching_result.rs:85:19\n    |\n LL |         while let Some(_) = r#try!(result_opt()) {}\n    |         ----------^^^^^^^----------------------- help: try this: `while r#try!(result_opt()).is_some()`\n \n error: redundant pattern matching, consider using `is_some()`\n-  --> $DIR/redundant_pattern_matching_result.rs:85:16\n+  --> $DIR/redundant_pattern_matching_result.rs:86:16\n    |\n LL |         if let Some(_) = r#try!(result_opt()) {}\n    |         -------^^^^^^^----------------------- help: try this: `if r#try!(result_opt()).is_some()`\n \n error: redundant pattern matching, consider using `is_some()`\n-  --> $DIR/redundant_pattern_matching_result.rs:91:12\n+  --> $DIR/redundant_pattern_matching_result.rs:92:12\n    |\n LL |     if let Some(_) = m!() {}\n    |     -------^^^^^^^------- help: try this: `if m!().is_some()`\n \n error: redundant pattern matching, consider using `is_some()`\n-  --> $DIR/redundant_pattern_matching_result.rs:92:15\n+  --> $DIR/redundant_pattern_matching_result.rs:93:15\n    |\n LL |     while let Some(_) = m!() {}\n    |     ----------^^^^^^^------- help: try this: `while m!().is_some()`\n \n error: redundant pattern matching, consider using `is_ok()`\n-  --> $DIR/redundant_pattern_matching_result.rs:110:12\n+  --> $DIR/redundant_pattern_matching_result.rs:111:12\n    |\n LL |     if let Ok(_) = Ok::<i32, i32>(42) {}\n    |     -------^^^^^--------------------- help: try this: `if Ok::<i32, i32>(42).is_ok()`\n \n error: redundant pattern matching, consider using `is_err()`\n-  --> $DIR/redundant_pattern_matching_result.rs:112:12\n+  --> $DIR/redundant_pattern_matching_result.rs:113:12\n    |\n LL |     if let Err(_) = Err::<i32, i32>(42) {}\n    |     -------^^^^^^---------------------- help: try this: `if Err::<i32, i32>(42).is_err()`\n \n error: redundant pattern matching, consider using `is_ok()`\n-  --> $DIR/redundant_pattern_matching_result.rs:114:15\n+  --> $DIR/redundant_pattern_matching_result.rs:115:15\n    |\n LL |     while let Ok(_) = Ok::<i32, i32>(10) {}\n    |     ----------^^^^^--------------------- help: try this: `while Ok::<i32, i32>(10).is_ok()`\n \n error: redundant pattern matching, consider using `is_err()`\n-  --> $DIR/redundant_pattern_matching_result.rs:116:15\n+  --> $DIR/redundant_pattern_matching_result.rs:117:15\n    |\n LL |     while let Err(_) = Ok::<i32, i32>(10) {}\n    |     ----------^^^^^^--------------------- help: try this: `while Ok::<i32, i32>(10).is_err()`\n \n error: redundant pattern matching, consider using `is_ok()`\n-  --> $DIR/redundant_pattern_matching_result.rs:118:5\n+  --> $DIR/redundant_pattern_matching_result.rs:119:5\n    |\n LL | /     match Ok::<i32, i32>(42) {\n LL | |         Ok(_) => true,\n@@ -142,7 +142,7 @@ LL | |     };\n    | |_____^ help: try this: `Ok::<i32, i32>(42).is_ok()`\n \n error: redundant pattern matching, consider using `is_err()`\n-  --> $DIR/redundant_pattern_matching_result.rs:123:5\n+  --> $DIR/redundant_pattern_matching_result.rs:124:5\n    |\n LL | /     match Err::<i32, i32>(42) {\n LL | |         Ok(_) => false,"}]}