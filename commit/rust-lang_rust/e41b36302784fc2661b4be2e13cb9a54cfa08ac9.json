{"sha": "e41b36302784fc2661b4be2e13cb9a54cfa08ac9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU0MWIzNjMwMjc4NGZjMjY2MWI0YmUyZTEzY2I5YTU0Y2ZhMDhhYzk=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-01-13T10:38:30Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-01-13T10:38:30Z"}, "message": "Merge #7251\n\n7251: Group references by FileId r=matklad a=Veykril\n\nFixes #4901\r\n\r\nThis doesn't address https://github.com/rust-analyzer/rust-analyzer/pull/7032/files#diff-a7e1e771e911237bb893e1b0f5e0f2c2a856b54ca06f95ef0818a922f1a8b5ebR266\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>", "tree": {"sha": "34e38f7297ab93686f270bb03607e9e3590a6597", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/34e38f7297ab93686f270bb03607e9e3590a6597"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e41b36302784fc2661b4be2e13cb9a54cfa08ac9", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJf/s2mCRBK7hj4Ov3rIwAAdHIIABBgV/G/qG7w16lMoVzu/3VD\n7p0EFDxfsLpW+cT9ce48VOo++sMhtLC96iC0OusAP57c2JzC0BOWSxekssznNc4f\ncxeMeLANAgeY/jwcUpDlcHZ+b6v7HIYMRk9DmZJ6bOvoW4bknYSWH3/5MGoTGF7d\nj81Qqo9yxd12paNGgiJIQVhJ4cp4t4L/ILzKu5smCin/M2Gv7EgLf0/BB17LY0aM\njNaxD/l2tXsIt6vvOr2EaK+J7OxC7URTytu7RhvU9lru2EMfIywiMGjm7arc9wSM\nOUTCzEOl7hdUSCsc489Vv2+0Y5/2L/5bo1zGUrUk4AV0dKdVFnFC3n1d2ROyCdA=\n=AdBZ\n-----END PGP SIGNATURE-----\n", "payload": "tree 34e38f7297ab93686f270bb03607e9e3590a6597\nparent 52fa926f005890f07dffc789c84c2be57a6bdccc\nparent aff9102afb2b6756b3935dedb9be30401975b262\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1610534310 +0000\ncommitter GitHub <noreply@github.com> 1610534310 +0000\n\nMerge #7251\n\n7251: Group references by FileId r=matklad a=Veykril\n\nFixes #4901\r\n\r\nThis doesn't address https://github.com/rust-analyzer/rust-analyzer/pull/7032/files#diff-a7e1e771e911237bb893e1b0f5e0f2c2a856b54ca06f95ef0818a922f1a8b5ebR266\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e41b36302784fc2661b4be2e13cb9a54cfa08ac9", "html_url": "https://github.com/rust-lang/rust/commit/e41b36302784fc2661b4be2e13cb9a54cfa08ac9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e41b36302784fc2661b4be2e13cb9a54cfa08ac9/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "52fa926f005890f07dffc789c84c2be57a6bdccc", "url": "https://api.github.com/repos/rust-lang/rust/commits/52fa926f005890f07dffc789c84c2be57a6bdccc", "html_url": "https://github.com/rust-lang/rust/commit/52fa926f005890f07dffc789c84c2be57a6bdccc"}, {"sha": "aff9102afb2b6756b3935dedb9be30401975b262", "url": "https://api.github.com/repos/rust-lang/rust/commits/aff9102afb2b6756b3935dedb9be30401975b262", "html_url": "https://github.com/rust-lang/rust/commit/aff9102afb2b6756b3935dedb9be30401975b262"}], "stats": {"total": 570, "additions": 319, "deletions": 251}, "files": [{"sha": "e3ef04932f93fbb04c3d8e1a83cf75fe7199fcfe", "filename": "crates/assists/src/handlers/extract_struct_from_enum_variant.rs", "status": "modified", "additions": 32, "deletions": 27, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/e41b36302784fc2661b4be2e13cb9a54cfa08ac9/crates%2Fassists%2Fsrc%2Fhandlers%2Fextract_struct_from_enum_variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e41b36302784fc2661b4be2e13cb9a54cfa08ac9/crates%2Fassists%2Fsrc%2Fhandlers%2Fextract_struct_from_enum_variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fhandlers%2Fextract_struct_from_enum_variant.rs?ref=e41b36302784fc2661b4be2e13cb9a54cfa08ac9", "patch": "@@ -2,12 +2,16 @@ use std::iter;\n \n use either::Either;\n use hir::{AsName, Module, ModuleDef, Name, Variant};\n-use ide_db::helpers::{\n-    insert_use::{insert_use, ImportScope},\n-    mod_path_to_ast,\n+use ide_db::{\n+    defs::Definition,\n+    helpers::{\n+        insert_use::{insert_use, ImportScope},\n+        mod_path_to_ast,\n+    },\n+    search::FileReference,\n+    RootDatabase,\n };\n-use ide_db::{defs::Definition, search::Reference, RootDatabase};\n-use rustc_hash::{FxHashMap, FxHashSet};\n+use rustc_hash::FxHashSet;\n use syntax::{\n     algo::{find_node_at_offset, SyntaxRewriter},\n     ast::{self, edit::IndentLevel, make, AstNode, NameOwner, VisibilityOwner},\n@@ -58,29 +62,29 @@ pub(crate) fn extract_struct_from_enum_variant(\n             let mut visited_modules_set = FxHashSet::default();\n             let current_module = enum_hir.module(ctx.db());\n             visited_modules_set.insert(current_module);\n-            let mut rewriters = FxHashMap::default();\n-            for reference in usages {\n-                let rewriter = rewriters\n-                    .entry(reference.file_range.file_id)\n-                    .or_insert_with(SyntaxRewriter::default);\n-                let source_file = ctx.sema.parse(reference.file_range.file_id);\n-                update_reference(\n-                    ctx,\n-                    rewriter,\n-                    reference,\n-                    &source_file,\n-                    &enum_module_def,\n-                    &variant_hir_name,\n-                    &mut visited_modules_set,\n-                );\n-            }\n-            let mut rewriter =\n-                rewriters.remove(&ctx.frange.file_id).unwrap_or_else(SyntaxRewriter::default);\n-            for (file_id, rewriter) in rewriters {\n+            let mut def_rewriter = None;\n+            for (file_id, references) in usages {\n+                let mut rewriter = SyntaxRewriter::default();\n+                let source_file = ctx.sema.parse(file_id);\n+                for reference in references {\n+                    update_reference(\n+                        ctx,\n+                        &mut rewriter,\n+                        reference,\n+                        &source_file,\n+                        &enum_module_def,\n+                        &variant_hir_name,\n+                        &mut visited_modules_set,\n+                    );\n+                }\n+                if file_id == ctx.frange.file_id {\n+                    def_rewriter = Some(rewriter);\n+                    continue;\n+                }\n                 builder.edit_file(file_id);\n                 builder.rewrite(rewriter);\n             }\n-            builder.edit_file(ctx.frange.file_id);\n+            let mut rewriter = def_rewriter.unwrap_or_default();\n             update_variant(&mut rewriter, &variant);\n             extract_struct_def(\n                 &mut rewriter,\n@@ -90,6 +94,7 @@ pub(crate) fn extract_struct_from_enum_variant(\n                 &variant.parent_enum().syntax().clone().into(),\n                 enum_ast.visibility(),\n             );\n+            builder.edit_file(ctx.frange.file_id);\n             builder.rewrite(rewriter);\n         },\n     )\n@@ -205,13 +210,13 @@ fn update_variant(rewriter: &mut SyntaxRewriter, variant: &ast::Variant) -> Opti\n fn update_reference(\n     ctx: &AssistContext,\n     rewriter: &mut SyntaxRewriter,\n-    reference: Reference,\n+    reference: FileReference,\n     source_file: &SourceFile,\n     enum_module_def: &ModuleDef,\n     variant_hir_name: &Name,\n     visited_modules_set: &mut FxHashSet<Module>,\n ) -> Option<()> {\n-    let offset = reference.file_range.range.start();\n+    let offset = reference.range.start();\n     let (segment, expr) = if let Some(path_expr) =\n         find_node_at_offset::<ast::PathExpr>(source_file.syntax(), offset)\n     {"}, {"sha": "dc798daaade681cbd3bded4c7ed7d8f087970a78", "filename": "crates/assists/src/handlers/inline_local_variable.rs", "status": "modified", "additions": 50, "deletions": 49, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/e41b36302784fc2661b4be2e13cb9a54cfa08ac9/crates%2Fassists%2Fsrc%2Fhandlers%2Finline_local_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e41b36302784fc2661b4be2e13cb9a54cfa08ac9/crates%2Fassists%2Fsrc%2Fhandlers%2Finline_local_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fhandlers%2Finline_local_variable.rs?ref=e41b36302784fc2661b4be2e13cb9a54cfa08ac9", "patch": "@@ -1,4 +1,7 @@\n-use ide_db::{defs::Definition, search::ReferenceKind};\n+use ide_db::{\n+    defs::Definition,\n+    search::{FileReference, ReferenceKind},\n+};\n use syntax::{\n     ast::{self, AstNode, AstToken},\n     TextRange,\n@@ -44,8 +47,8 @@ pub(crate) fn inline_local_variable(acc: &mut Assists, ctx: &AssistContext) -> O\n \n     let def = ctx.sema.to_def(&bind_pat)?;\n     let def = Definition::Local(def);\n-    let refs = def.usages(&ctx.sema).all();\n-    if refs.is_empty() {\n+    let usages = def.usages(&ctx.sema).all();\n+    if usages.is_empty() {\n         mark::hit!(test_not_applicable_if_variable_unused);\n         return None;\n     };\n@@ -63,48 +66,45 @@ pub(crate) fn inline_local_variable(acc: &mut Assists, ctx: &AssistContext) -> O\n         let_stmt.syntax().text_range()\n     };\n \n-    let mut wrap_in_parens = vec![true; refs.len()];\n-\n-    for (i, desc) in refs.iter().enumerate() {\n-        let usage_node = ctx\n-            .covering_node_for_range(desc.file_range.range)\n-            .ancestors()\n-            .find_map(ast::PathExpr::cast)?;\n-        let usage_parent_option = usage_node.syntax().parent().and_then(ast::Expr::cast);\n-        let usage_parent = match usage_parent_option {\n-            Some(u) => u,\n-            None => {\n-                wrap_in_parens[i] = false;\n-                continue;\n-            }\n-        };\n-\n-        wrap_in_parens[i] = match (&initializer_expr, usage_parent) {\n-            (ast::Expr::CallExpr(_), _)\n-            | (ast::Expr::IndexExpr(_), _)\n-            | (ast::Expr::MethodCallExpr(_), _)\n-            | (ast::Expr::FieldExpr(_), _)\n-            | (ast::Expr::TryExpr(_), _)\n-            | (ast::Expr::RefExpr(_), _)\n-            | (ast::Expr::Literal(_), _)\n-            | (ast::Expr::TupleExpr(_), _)\n-            | (ast::Expr::ArrayExpr(_), _)\n-            | (ast::Expr::ParenExpr(_), _)\n-            | (ast::Expr::PathExpr(_), _)\n-            | (ast::Expr::BlockExpr(_), _)\n-            | (ast::Expr::EffectExpr(_), _)\n-            | (_, ast::Expr::CallExpr(_))\n-            | (_, ast::Expr::TupleExpr(_))\n-            | (_, ast::Expr::ArrayExpr(_))\n-            | (_, ast::Expr::ParenExpr(_))\n-            | (_, ast::Expr::ForExpr(_))\n-            | (_, ast::Expr::WhileExpr(_))\n-            | (_, ast::Expr::BreakExpr(_))\n-            | (_, ast::Expr::ReturnExpr(_))\n-            | (_, ast::Expr::MatchExpr(_)) => false,\n-            _ => true,\n-        };\n-    }\n+    let wrap_in_parens = usages\n+        .references\n+        .values()\n+        .flatten()\n+        .map(|&FileReference { range, .. }| {\n+            let usage_node =\n+                ctx.covering_node_for_range(range).ancestors().find_map(ast::PathExpr::cast)?;\n+            let usage_parent_option = usage_node.syntax().parent().and_then(ast::Expr::cast);\n+            let usage_parent = match usage_parent_option {\n+                Some(u) => u,\n+                None => return Ok(false),\n+            };\n+\n+            Ok(!matches!((&initializer_expr, usage_parent),\n+                (ast::Expr::CallExpr(_), _)\n+                | (ast::Expr::IndexExpr(_), _)\n+                | (ast::Expr::MethodCallExpr(_), _)\n+                | (ast::Expr::FieldExpr(_), _)\n+                | (ast::Expr::TryExpr(_), _)\n+                | (ast::Expr::RefExpr(_), _)\n+                | (ast::Expr::Literal(_), _)\n+                | (ast::Expr::TupleExpr(_), _)\n+                | (ast::Expr::ArrayExpr(_), _)\n+                | (ast::Expr::ParenExpr(_), _)\n+                | (ast::Expr::PathExpr(_), _)\n+                | (ast::Expr::BlockExpr(_), _)\n+                | (ast::Expr::EffectExpr(_), _)\n+                | (_, ast::Expr::CallExpr(_))\n+                | (_, ast::Expr::TupleExpr(_))\n+                | (_, ast::Expr::ArrayExpr(_))\n+                | (_, ast::Expr::ParenExpr(_))\n+                | (_, ast::Expr::ForExpr(_))\n+                | (_, ast::Expr::WhileExpr(_))\n+                | (_, ast::Expr::BreakExpr(_))\n+                | (_, ast::Expr::ReturnExpr(_))\n+                | (_, ast::Expr::MatchExpr(_))\n+            ))\n+        })\n+        .collect::<Result<Vec<_>, _>>()?;\n \n     let init_str = initializer_expr.syntax().text().to_string();\n     let init_in_paren = format!(\"({})\", &init_str);\n@@ -116,15 +116,16 @@ pub(crate) fn inline_local_variable(acc: &mut Assists, ctx: &AssistContext) -> O\n         target,\n         move |builder| {\n             builder.delete(delete_range);\n-            for (desc, should_wrap) in refs.iter().zip(wrap_in_parens) {\n+            for (reference, should_wrap) in usages.references.values().flatten().zip(wrap_in_parens)\n+            {\n                 let replacement =\n                     if should_wrap { init_in_paren.clone() } else { init_str.clone() };\n-                match desc.kind {\n+                match reference.kind {\n                     ReferenceKind::FieldShorthandForLocal => {\n                         mark::hit!(inline_field_shorthand);\n-                        builder.insert(desc.file_range.range.end(), format!(\": {}\", replacement))\n+                        builder.insert(reference.range.end(), format!(\": {}\", replacement))\n                     }\n-                    _ => builder.replace(desc.file_range.range, replacement),\n+                    _ => builder.replace(reference.range, replacement),\n                 }\n             }\n         },"}, {"sha": "c961680e22a02bcbb05b805a49634f51d96518e6", "filename": "crates/assists/src/handlers/remove_unused_param.rs", "status": "modified", "additions": 25, "deletions": 16, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/e41b36302784fc2661b4be2e13cb9a54cfa08ac9/crates%2Fassists%2Fsrc%2Fhandlers%2Fremove_unused_param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e41b36302784fc2661b4be2e13cb9a54cfa08ac9/crates%2Fassists%2Fsrc%2Fhandlers%2Fremove_unused_param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fhandlers%2Fremove_unused_param.rs?ref=e41b36302784fc2661b4be2e13cb9a54cfa08ac9", "patch": "@@ -1,8 +1,8 @@\n-use ide_db::{defs::Definition, search::Reference};\n+use ide_db::{base_db::FileId, defs::Definition, search::FileReference};\n use syntax::{\n     algo::find_node_at_range,\n     ast::{self, ArgListOwner},\n-    AstNode, SyntaxKind, SyntaxNode, TextRange, T,\n+    AstNode, SourceFile, SyntaxKind, SyntaxNode, TextRange, T,\n };\n use test_utils::mark;\n use SyntaxKind::WHITESPACE;\n@@ -58,32 +58,41 @@ pub(crate) fn remove_unused_param(acc: &mut Assists, ctx: &AssistContext) -> Opt\n         param.syntax().text_range(),\n         |builder| {\n             builder.delete(range_to_remove(param.syntax()));\n-            for usage in fn_def.usages(&ctx.sema).all() {\n-                process_usage(ctx, builder, usage, param_position);\n+            for (file_id, references) in fn_def.usages(&ctx.sema).all() {\n+                process_usages(ctx, builder, file_id, references, param_position);\n             }\n         },\n     )\n }\n \n-fn process_usage(\n+fn process_usages(\n     ctx: &AssistContext,\n     builder: &mut AssistBuilder,\n-    usage: Reference,\n+    file_id: FileId,\n+    references: Vec<FileReference>,\n     arg_to_remove: usize,\n-) -> Option<()> {\n-    let source_file = ctx.sema.parse(usage.file_range.file_id);\n-    let call_expr: ast::CallExpr =\n-        find_node_at_range(source_file.syntax(), usage.file_range.range)?;\n+) {\n+    let source_file = ctx.sema.parse(file_id);\n+    builder.edit_file(file_id);\n+    for usage in references {\n+        if let Some(text_range) = process_usage(&source_file, usage, arg_to_remove) {\n+            builder.delete(text_range);\n+        }\n+    }\n+}\n+\n+fn process_usage(\n+    source_file: &SourceFile,\n+    FileReference { range, .. }: FileReference,\n+    arg_to_remove: usize,\n+) -> Option<TextRange> {\n+    let call_expr: ast::CallExpr = find_node_at_range(source_file.syntax(), range)?;\n     let call_expr_range = call_expr.expr()?.syntax().text_range();\n-    if !call_expr_range.contains_range(usage.file_range.range) {\n+    if !call_expr_range.contains_range(range) {\n         return None;\n     }\n     let arg = call_expr.arg_list()?.args().nth(arg_to_remove)?;\n-\n-    builder.edit_file(usage.file_range.file_id);\n-    builder.delete(range_to_remove(arg.syntax()));\n-\n-    Some(())\n+    Some(range_to_remove(arg.syntax()))\n }\n \n fn range_to_remove(node: &SyntaxNode) -> TextRange {"}, {"sha": "e8999a7f39c8c90f9b6e23e4386d373728f0f08c", "filename": "crates/ide/src/call_hierarchy.rs", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/e41b36302784fc2661b4be2e13cb9a54cfa08ac9/crates%2Fide%2Fsrc%2Fcall_hierarchy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e41b36302784fc2661b4be2e13cb9a54cfa08ac9/crates%2Fide%2Fsrc%2Fcall_hierarchy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fcall_hierarchy.rs?ref=e41b36302784fc2661b4be2e13cb9a54cfa08ac9", "patch": "@@ -47,22 +47,23 @@ pub(crate) fn incoming_calls(db: &RootDatabase, position: FilePosition) -> Optio\n \n     let mut calls = CallLocations::default();\n \n-    for reference in refs.info.references() {\n-        let file_id = reference.file_range.file_id;\n+    for (&file_id, references) in refs.info.references().iter() {\n         let file = sema.parse(file_id);\n         let file = file.syntax();\n-        let token = file.token_at_offset(reference.file_range.range.start()).next()?;\n-        let token = sema.descend_into_macros(token);\n-        let syntax = token.parent();\n-\n-        // This target is the containing function\n-        if let Some(nav) = syntax.ancestors().find_map(|node| {\n-            let fn_ = ast::Fn::cast(node)?;\n-            let def = sema.to_def(&fn_)?;\n-            def.try_to_nav(sema.db)\n-        }) {\n-            let relative_range = reference.file_range.range;\n-            calls.add(&nav, relative_range);\n+        for reference in references {\n+            let token = file.token_at_offset(reference.range.start()).next()?;\n+            let token = sema.descend_into_macros(token);\n+            let syntax = token.parent();\n+\n+            // This target is the containing function\n+            if let Some(nav) = syntax.ancestors().find_map(|node| {\n+                let fn_ = ast::Fn::cast(node)?;\n+                let def = sema.to_def(&fn_)?;\n+                def.try_to_nav(sema.db)\n+            }) {\n+                let relative_range = reference.range;\n+                calls.add(&nav, relative_range);\n+            }\n         }\n     }\n "}, {"sha": "1e03832ece885275c36e53335afbba7b99e6f893", "filename": "crates/ide/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e41b36302784fc2661b4be2e13cb9a54cfa08ac9/crates%2Fide%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e41b36302784fc2661b4be2e13cb9a54cfa08ac9/crates%2Fide%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Flib.rs?ref=e41b36302784fc2661b4be2e13cb9a54cfa08ac9", "patch": "@@ -92,7 +92,7 @@ pub use ide_db::base_db::{\n };\n pub use ide_db::{\n     call_info::CallInfo,\n-    search::{Reference, ReferenceAccess, ReferenceKind},\n+    search::{FileReference, ReferenceAccess, ReferenceKind},\n };\n pub use ide_db::{\n     label::Label,"}, {"sha": "7d4757e02523e817e807fc965c49aaeb1d23d7f5", "filename": "crates/ide/src/references.rs", "status": "modified", "additions": 42, "deletions": 37, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/e41b36302784fc2661b4be2e13cb9a54cfa08ac9/crates%2Fide%2Fsrc%2Freferences.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e41b36302784fc2661b4be2e13cb9a54cfa08ac9/crates%2Fide%2Fsrc%2Freferences.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Freferences.rs?ref=e41b36302784fc2661b4be2e13cb9a54cfa08ac9", "patch": "@@ -13,9 +13,9 @@ pub(crate) mod rename;\n \n use hir::Semantics;\n use ide_db::{\n+    base_db::FileId,\n     defs::{Definition, NameClass, NameRefClass},\n-    search::Reference,\n-    search::{ReferenceAccess, ReferenceKind, SearchScope},\n+    search::{FileReference, ReferenceAccess, ReferenceKind, SearchScope, UsageSearchResult},\n     RootDatabase,\n };\n use syntax::{\n@@ -29,7 +29,7 @@ use crate::{display::TryToNav, FilePosition, FileRange, NavigationTarget, RangeI\n #[derive(Debug, Clone)]\n pub struct ReferenceSearchResult {\n     declaration: Declaration,\n-    references: Vec<Reference>,\n+    references: UsageSearchResult,\n }\n \n #[derive(Debug, Clone)]\n@@ -48,10 +48,21 @@ impl ReferenceSearchResult {\n         &self.declaration.nav\n     }\n \n-    pub fn references(&self) -> &[Reference] {\n+    pub fn references(&self) -> &UsageSearchResult {\n         &self.references\n     }\n \n+    pub fn references_with_declaration(mut self) -> UsageSearchResult {\n+        let decl_ref = FileReference {\n+            range: self.declaration.nav.focus_or_full_range(),\n+            kind: self.declaration.kind,\n+            access: self.declaration.access,\n+        };\n+        let file_id = self.declaration.nav.file_id;\n+        self.references.references.entry(file_id).or_default().push(decl_ref);\n+        self.references\n+    }\n+\n     /// Total number of references\n     /// At least 1 since all valid references should\n     /// Have a declaration\n@@ -63,21 +74,11 @@ impl ReferenceSearchResult {\n // allow turning ReferenceSearchResult into an iterator\n // over References\n impl IntoIterator for ReferenceSearchResult {\n-    type Item = Reference;\n-    type IntoIter = std::vec::IntoIter<Reference>;\n-\n-    fn into_iter(mut self) -> Self::IntoIter {\n-        let mut v = Vec::with_capacity(self.len());\n-        v.push(Reference {\n-            file_range: FileRange {\n-                file_id: self.declaration.nav.file_id,\n-                range: self.declaration.nav.focus_or_full_range(),\n-            },\n-            kind: self.declaration.kind,\n-            access: self.declaration.access,\n-        });\n-        v.append(&mut self.references);\n-        v.into_iter()\n+    type Item = (FileId, Vec<FileReference>);\n+    type IntoIter = std::collections::hash_map::IntoIter<FileId, Vec<FileReference>>;\n+\n+    fn into_iter(self) -> Self::IntoIter {\n+        self.references_with_declaration().into_iter()\n     }\n }\n \n@@ -109,13 +110,12 @@ pub(crate) fn find_all_refs(\n \n     let RangeInfo { range, info: def } = find_name(&sema, &syntax, position, opt_name)?;\n \n-    let references = def\n-        .usages(sema)\n-        .set_scope(search_scope)\n-        .all()\n-        .into_iter()\n-        .filter(|r| search_kind == ReferenceKind::Other || search_kind == r.kind)\n-        .collect();\n+    let mut usages = def.usages(sema).set_scope(search_scope).all();\n+    usages\n+        .references\n+        .values_mut()\n+        .for_each(|it| it.retain(|r| search_kind == ReferenceKind::Other || search_kind == r.kind));\n+    usages.references.retain(|_, it| !it.is_empty());\n \n     let nav = def.try_to_nav(sema.db)?;\n     let decl_range = nav.focus_or_full_range();\n@@ -139,7 +139,7 @@ pub(crate) fn find_all_refs(\n \n     let declaration = Declaration { nav, kind, access: decl_access(&def, &syntax, decl_range) };\n \n-    Some(RangeInfo::new(range, ReferenceSearchResult { declaration, references }))\n+    Some(RangeInfo::new(range, ReferenceSearchResult { declaration, references: usages }))\n }\n \n fn find_name(\n@@ -255,7 +255,8 @@ fn try_find_self_references(\n     syntax: &SyntaxNode,\n     position: FilePosition,\n ) -> Option<RangeInfo<ReferenceSearchResult>> {\n-    let self_token = syntax.token_at_offset(position.offset).find(|t| t.kind() == T![self])?;\n+    let FilePosition { file_id, offset } = position;\n+    let self_token = syntax.token_at_offset(offset).find(|t| t.kind() == T![self])?;\n     let parent = self_token.parent();\n     match_ast! {\n         match parent {\n@@ -276,7 +277,7 @@ fn try_find_self_references(\n \n     let declaration = Declaration {\n         nav: NavigationTarget {\n-            file_id: position.file_id,\n+            file_id,\n             full_range: self_param.syntax().text_range(),\n             focus_range: Some(param_self_token.text_range()),\n             name: param_self_token.text().clone(),\n@@ -292,7 +293,7 @@ fn try_find_self_references(\n             ReferenceAccess::Read\n         }),\n     };\n-    let references = function\n+    let refs = function\n         .body()\n         .map(|body| {\n             body.syntax()\n@@ -306,14 +307,16 @@ fn try_find_self_references(\n                         None\n                     }\n                 })\n-                .map(|token| Reference {\n-                    file_range: FileRange { file_id: position.file_id, range: token.text_range() },\n+                .map(|token| FileReference {\n+                    range: token.text_range(),\n                     kind: ReferenceKind::SelfKw,\n                     access: declaration.access, // FIXME: properly check access kind here instead of copying it from the declaration\n                 })\n                 .collect()\n         })\n         .unwrap_or_default();\n+    let mut references = UsageSearchResult::default();\n+    references.references.insert(file_id, refs);\n \n     Some(RangeInfo::new(\n         param_self_token.text_range(),\n@@ -1018,12 +1021,14 @@ impl Foo {\n             actual += \"\\n\\n\";\n         }\n \n-        for r in &refs.references {\n-            format_to!(actual, \"{:?} {:?} {:?}\", r.file_range.file_id, r.file_range.range, r.kind);\n-            if let Some(access) = r.access {\n-                format_to!(actual, \" {:?}\", access);\n+        for (file_id, references) in refs.references {\n+            for r in references {\n+                format_to!(actual, \"{:?} {:?} {:?}\", file_id, r.range, r.kind);\n+                if let Some(access) = r.access {\n+                    format_to!(actual, \" {:?}\", access);\n+                }\n+                actual += \"\\n\";\n             }\n-            actual += \"\\n\";\n         }\n         expect.assert_eq(&actual)\n     }"}, {"sha": "5207388b5219e63d555a28beb3880d20c64d03ed", "filename": "crates/ide/src/references/rename.rs", "status": "modified", "additions": 52, "deletions": 48, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/e41b36302784fc2661b4be2e13cb9a54cfa08ac9/crates%2Fide%2Fsrc%2Freferences%2Frename.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e41b36302784fc2661b4be2e13cb9a54cfa08ac9/crates%2Fide%2Fsrc%2Freferences%2Frename.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Freferences%2Frename.rs?ref=e41b36302784fc2661b4be2e13cb9a54cfa08ac9", "patch": "@@ -6,9 +6,10 @@ use std::{\n };\n \n use hir::{Module, ModuleDef, ModuleSource, Semantics};\n-use ide_db::base_db::{AnchoredPathBuf, FileId, FileRange, SourceDatabaseExt};\n use ide_db::{\n+    base_db::{AnchoredPathBuf, FileId, FileRange, SourceDatabaseExt},\n     defs::{Definition, NameClass, NameRefClass},\n+    search::FileReference,\n     RootDatabase,\n };\n use syntax::{\n@@ -20,8 +21,8 @@ use test_utils::mark;\n use text_edit::TextEdit;\n \n use crate::{\n-    FilePosition, FileSystemEdit, RangeInfo, Reference, ReferenceKind, ReferenceSearchResult,\n-    SourceChange, SourceFileEdit, TextRange, TextSize,\n+    FilePosition, FileSystemEdit, RangeInfo, ReferenceKind, ReferenceSearchResult, SourceChange,\n+    SourceFileEdit, TextRange, TextSize,\n };\n \n type RenameResult<T> = Result<T, RenameError>;\n@@ -173,39 +174,46 @@ fn find_all_refs(\n         .ok_or_else(|| format_err!(\"No references found at position\"))\n }\n \n-fn source_edit_from_reference(\n+fn source_edit_from_references(\n     sema: &Semantics<RootDatabase>,\n-    reference: Reference,\n+    file_id: FileId,\n+    references: &[FileReference],\n     new_name: &str,\n ) -> SourceFileEdit {\n-    let mut replacement_text = String::new();\n-    let range = match reference.kind {\n-        ReferenceKind::FieldShorthandForField => {\n-            mark::hit!(test_rename_struct_field_for_shorthand);\n-            replacement_text.push_str(new_name);\n-            replacement_text.push_str(\": \");\n-            TextRange::new(reference.file_range.range.start(), reference.file_range.range.start())\n-        }\n-        ReferenceKind::FieldShorthandForLocal => {\n-            mark::hit!(test_rename_local_for_field_shorthand);\n-            replacement_text.push_str(\": \");\n-            replacement_text.push_str(new_name);\n-            TextRange::new(reference.file_range.range.end(), reference.file_range.range.end())\n-        }\n-        ReferenceKind::RecordFieldExprOrPat => {\n-            mark::hit!(test_rename_field_expr_pat);\n-            replacement_text.push_str(new_name);\n-            edit_text_range_for_record_field_expr_or_pat(sema, reference.file_range, new_name)\n-        }\n-        _ => {\n-            replacement_text.push_str(new_name);\n-            reference.file_range.range\n-        }\n-    };\n-    SourceFileEdit {\n-        file_id: reference.file_range.file_id,\n-        edit: TextEdit::replace(range, replacement_text),\n+    let mut edit = TextEdit::builder();\n+    for reference in references {\n+        let mut replacement_text = String::new();\n+        let range = match reference.kind {\n+            ReferenceKind::FieldShorthandForField => {\n+                mark::hit!(test_rename_struct_field_for_shorthand);\n+                replacement_text.push_str(new_name);\n+                replacement_text.push_str(\": \");\n+                TextRange::new(reference.range.start(), reference.range.start())\n+            }\n+            ReferenceKind::FieldShorthandForLocal => {\n+                mark::hit!(test_rename_local_for_field_shorthand);\n+                replacement_text.push_str(\": \");\n+                replacement_text.push_str(new_name);\n+                TextRange::new(reference.range.end(), reference.range.end())\n+            }\n+            ReferenceKind::RecordFieldExprOrPat => {\n+                mark::hit!(test_rename_field_expr_pat);\n+                replacement_text.push_str(new_name);\n+                edit_text_range_for_record_field_expr_or_pat(\n+                    sema,\n+                    FileRange { file_id, range: reference.range },\n+                    new_name,\n+                )\n+            }\n+            _ => {\n+                replacement_text.push_str(new_name);\n+                reference.range\n+            }\n+        };\n+        edit.replace(range, replacement_text);\n     }\n+\n+    SourceFileEdit { file_id, edit: edit.finish() }\n }\n \n fn edit_text_range_for_record_field_expr_or_pat(\n@@ -276,10 +284,9 @@ fn rename_mod(\n     }\n \n     let RangeInfo { range, info: refs } = find_all_refs(sema, position)?;\n-    let ref_edits = refs\n-        .references\n-        .into_iter()\n-        .map(|reference| source_edit_from_reference(sema, reference, new_name));\n+    let ref_edits = refs.references().iter().map(|(&file_id, references)| {\n+        source_edit_from_references(sema, file_id, references, new_name)\n+    });\n     source_file_edits.extend(ref_edits);\n \n     Ok(RangeInfo::new(range, SourceChange::from_edits(source_file_edits, file_system_edits)))\n@@ -331,17 +338,12 @@ fn rename_to_self(\n \n     let RangeInfo { range, info: refs } = find_all_refs(sema, position)?;\n \n-    let (param_ref, usages): (Vec<Reference>, Vec<Reference>) = refs\n-        .into_iter()\n-        .partition(|reference| param_range.intersect(reference.file_range.range).is_some());\n-\n-    if param_ref.is_empty() {\n-        bail!(\"Parameter to rename not found\");\n-    }\n-\n-    let mut edits = usages\n-        .into_iter()\n-        .map(|reference| source_edit_from_reference(sema, reference, \"self\"))\n+    let mut edits = refs\n+        .references()\n+        .iter()\n+        .map(|(&file_id, references)| {\n+            source_edit_from_references(sema, file_id, references, \"self\")\n+        })\n         .collect::<Vec<_>>();\n \n     edits.push(SourceFileEdit {\n@@ -467,7 +469,9 @@ fn rename_reference(\n \n     let edit = refs\n         .into_iter()\n-        .map(|reference| source_edit_from_reference(sema, reference, new_name))\n+        .map(|(file_id, references)| {\n+            source_edit_from_references(sema, file_id, &references, new_name)\n+        })\n         .collect::<Vec<_>>();\n \n     Ok(RangeInfo::new(range, SourceChange::from(edit)))"}, {"sha": "b5fa466427aaa2521653baa8962d1f61f0666e2e", "filename": "crates/ide_db/src/search.rs", "status": "modified", "additions": 73, "deletions": 37, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/e41b36302784fc2661b4be2e13cb9a54cfa08ac9/crates%2Fide_db%2Fsrc%2Fsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e41b36302784fc2661b4be2e13cb9a54cfa08ac9/crates%2Fide_db%2Fsrc%2Fsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fsearch.rs?ref=e41b36302784fc2661b4be2e13cb9a54cfa08ac9", "patch": "@@ -18,9 +18,43 @@ use crate::{\n     RootDatabase,\n };\n \n+#[derive(Debug, Default, Clone)]\n+pub struct UsageSearchResult {\n+    pub references: FxHashMap<FileId, Vec<FileReference>>,\n+}\n+\n+impl UsageSearchResult {\n+    pub fn is_empty(&self) -> bool {\n+        self.references.is_empty()\n+    }\n+\n+    pub fn len(&self) -> usize {\n+        self.references.len()\n+    }\n+\n+    pub fn iter(&self) -> impl Iterator<Item = (&FileId, &Vec<FileReference>)> + '_ {\n+        self.references.iter()\n+    }\n+\n+    pub fn file_ranges(&self) -> impl Iterator<Item = FileRange> + '_ {\n+        self.references.iter().flat_map(|(&file_id, refs)| {\n+            refs.iter().map(move |&FileReference { range, .. }| FileRange { file_id, range })\n+        })\n+    }\n+}\n+\n+impl IntoIterator for UsageSearchResult {\n+    type Item = (FileId, Vec<FileReference>);\n+    type IntoIter = <FxHashMap<FileId, Vec<FileReference>> as IntoIterator>::IntoIter;\n+\n+    fn into_iter(self) -> Self::IntoIter {\n+        self.references.into_iter()\n+    }\n+}\n+\n #[derive(Debug, Clone)]\n-pub struct Reference {\n-    pub file_range: FileRange,\n+pub struct FileReference {\n+    pub range: TextRange,\n     pub kind: ReferenceKind,\n     pub access: Option<ReferenceAccess>,\n }\n@@ -252,23 +286,23 @@ impl<'a> FindUsages<'a> {\n \n     pub fn at_least_one(self) -> bool {\n         let mut found = false;\n-        self.search(&mut |_reference| {\n+        self.search(&mut |_, _| {\n             found = true;\n             true\n         });\n         found\n     }\n \n-    pub fn all(self) -> Vec<Reference> {\n-        let mut res = Vec::new();\n-        self.search(&mut |reference| {\n-            res.push(reference);\n+    pub fn all(self) -> UsageSearchResult {\n+        let mut res = UsageSearchResult::default();\n+        self.search(&mut |file_id, reference| {\n+            res.references.entry(file_id).or_default().push(reference);\n             false\n         });\n         res\n     }\n \n-    fn search(self, sink: &mut dyn FnMut(Reference) -> bool) {\n+    fn search(self, sink: &mut dyn FnMut(FileId, FileReference) -> bool) {\n         let _p = profile::span(\"FindUsages:search\");\n         let sema = self.sema;\n \n@@ -320,16 +354,14 @@ impl<'a> FindUsages<'a> {\n     fn found_lifetime(\n         &self,\n         lifetime: &ast::Lifetime,\n-        sink: &mut dyn FnMut(Reference) -> bool,\n+        sink: &mut dyn FnMut(FileId, FileReference) -> bool,\n     ) -> bool {\n         match NameRefClass::classify_lifetime(self.sema, lifetime) {\n             Some(NameRefClass::Definition(def)) if &def == self.def => {\n-                let reference = Reference {\n-                    file_range: self.sema.original_range(lifetime.syntax()),\n-                    kind: ReferenceKind::Lifetime,\n-                    access: None,\n-                };\n-                sink(reference)\n+                let FileRange { file_id, range } = self.sema.original_range(lifetime.syntax());\n+                let reference =\n+                    FileReference { range, kind: ReferenceKind::Lifetime, access: None };\n+                sink(file_id, reference)\n             }\n             _ => false, // not a usage\n         }\n@@ -338,7 +370,7 @@ impl<'a> FindUsages<'a> {\n     fn found_name_ref(\n         &self,\n         name_ref: &ast::NameRef,\n-        sink: &mut dyn FnMut(Reference) -> bool,\n+        sink: &mut dyn FnMut(FileId, FileReference) -> bool,\n     ) -> bool {\n         match NameRefClass::classify(self.sema, &name_ref) {\n             Some(NameRefClass::Definition(def)) if &def == self.def => {\n@@ -352,46 +384,50 @@ impl<'a> FindUsages<'a> {\n                     ReferenceKind::Other\n                 };\n \n-                let reference = Reference {\n-                    file_range: self.sema.original_range(name_ref.syntax()),\n-                    kind,\n-                    access: reference_access(&def, &name_ref),\n-                };\n-                sink(reference)\n+                let FileRange { file_id, range } = self.sema.original_range(name_ref.syntax());\n+                let reference =\n+                    FileReference { range, kind, access: reference_access(&def, &name_ref) };\n+                sink(file_id, reference)\n             }\n             Some(NameRefClass::FieldShorthand { local_ref: local, field_ref: field }) => {\n+                let FileRange { file_id, range } = self.sema.original_range(name_ref.syntax());\n                 let reference = match self.def {\n-                    Definition::Field(_) if &field == self.def => Reference {\n-                        file_range: self.sema.original_range(name_ref.syntax()),\n+                    Definition::Field(_) if &field == self.def => FileReference {\n+                        range,\n                         kind: ReferenceKind::FieldShorthandForField,\n                         access: reference_access(&field, &name_ref),\n                     },\n-                    Definition::Local(l) if &local == l => Reference {\n-                        file_range: self.sema.original_range(name_ref.syntax()),\n+                    Definition::Local(l) if &local == l => FileReference {\n+                        range,\n                         kind: ReferenceKind::FieldShorthandForLocal,\n                         access: reference_access(&Definition::Local(local), &name_ref),\n                     },\n                     _ => return false, // not a usage\n                 };\n-                sink(reference)\n+                sink(file_id, reference)\n             }\n             _ => false, // not a usage\n         }\n     }\n \n-    fn found_name(&self, name: &ast::Name, sink: &mut dyn FnMut(Reference) -> bool) -> bool {\n+    fn found_name(\n+        &self,\n+        name: &ast::Name,\n+        sink: &mut dyn FnMut(FileId, FileReference) -> bool,\n+    ) -> bool {\n         match NameClass::classify(self.sema, name) {\n             Some(NameClass::PatFieldShorthand { local_def: _, field_ref }) => {\n-                let reference = match self.def {\n-                    Definition::Field(_) if &field_ref == self.def => Reference {\n-                        file_range: self.sema.original_range(name.syntax()),\n-                        kind: ReferenceKind::FieldShorthandForField,\n-                        // FIXME: mutable patterns should have `Write` access\n-                        access: Some(ReferenceAccess::Read),\n-                    },\n-                    _ => return false, // not a usage\n+                if !matches!(self.def, Definition::Field(_) if &field_ref == self.def) {\n+                    return false;\n+                }\n+                let FileRange { file_id, range } = self.sema.original_range(name.syntax());\n+                let reference = FileReference {\n+                    range,\n+                    kind: ReferenceKind::FieldShorthandForField,\n+                    // FIXME: mutable patterns should have `Write` access\n+                    access: Some(ReferenceAccess::Read),\n                 };\n-                sink(reference)\n+                sink(file_id, reference)\n             }\n             _ => false, // not a usage\n         }"}, {"sha": "2cc57f0224287cb57ec950d0180646cda725fdef", "filename": "crates/rust-analyzer/src/handlers.rs", "status": "modified", "additions": 19, "deletions": 12, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/e41b36302784fc2661b4be2e13cb9a54cfa08ac9/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e41b36302784fc2661b4be2e13cb9a54cfa08ac9/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs?ref=e41b36302784fc2661b4be2e13cb9a54cfa08ac9", "patch": "@@ -812,14 +812,15 @@ pub(crate) fn handle_references(\n     };\n \n     let locations = if params.context.include_declaration {\n-        refs.into_iter()\n-            .filter_map(|reference| to_proto::location(&snap, reference.file_range).ok())\n+        refs.references_with_declaration()\n+            .file_ranges()\n+            .filter_map(|frange| to_proto::location(&snap, frange).ok())\n             .collect()\n     } else {\n         // Only iterate over the references if include_declaration was false\n         refs.references()\n-            .iter()\n-            .filter_map(|reference| to_proto::location(&snap, reference.file_range).ok())\n+            .file_ranges()\n+            .filter_map(|frange| to_proto::location(&snap, frange).ok())\n             .collect()\n     };\n \n@@ -1175,8 +1176,8 @@ pub(crate) fn handle_code_lens_resolve(\n                 .unwrap_or(None)\n                 .map(|r| {\n                     r.references()\n-                        .iter()\n-                        .filter_map(|it| to_proto::location(&snap, it.file_range).ok())\n+                        .file_ranges()\n+                        .filter_map(|frange| to_proto::location(&snap, frange).ok())\n                         .collect_vec()\n                 })\n                 .unwrap_or_default();\n@@ -1220,13 +1221,19 @@ pub(crate) fn handle_document_highlight(\n     };\n \n     let res = refs\n-        .into_iter()\n-        .filter(|reference| reference.file_range.file_id == position.file_id)\n-        .map(|reference| DocumentHighlight {\n-            range: to_proto::range(&line_index, reference.file_range.range),\n-            kind: reference.access.map(to_proto::document_highlight_kind),\n+        .references_with_declaration()\n+        .references\n+        .get(&position.file_id)\n+        .map(|file_refs| {\n+            file_refs\n+                .into_iter()\n+                .map(|r| DocumentHighlight {\n+                    range: to_proto::range(&line_index, r.range),\n+                    kind: r.access.map(to_proto::document_highlight_kind),\n+                })\n+                .collect()\n         })\n-        .collect();\n+        .unwrap_or_default();\n     Ok(Some(res))\n }\n "}, {"sha": "836eb94b2e22797f2ddb235a6d67bc137d5a2571", "filename": "crates/ssr/src/search.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e41b36302784fc2661b4be2e13cb9a54cfa08ac9/crates%2Fssr%2Fsrc%2Fsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e41b36302784fc2661b4be2e13cb9a54cfa08ac9/crates%2Fssr%2Fsrc%2Fsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fssr%2Fsrc%2Fsearch.rs?ref=e41b36302784fc2661b4be2e13cb9a54cfa08ac9", "patch": "@@ -5,10 +5,10 @@ use crate::{\n     resolving::{ResolvedPath, ResolvedPattern, ResolvedRule},\n     Match, MatchFinder,\n };\n-use ide_db::base_db::{FileId, FileRange};\n use ide_db::{\n+    base_db::{FileId, FileRange},\n     defs::Definition,\n-    search::{Reference, SearchScope},\n+    search::{SearchScope, UsageSearchResult},\n };\n use rustc_hash::FxHashSet;\n use syntax::{ast, AstNode, SyntaxKind, SyntaxNode};\n@@ -20,7 +20,7 @@ use test_utils::mark;\n /// them more than once.\n #[derive(Default)]\n pub(crate) struct UsageCache {\n-    usages: Vec<(Definition, Vec<Reference>)>,\n+    usages: Vec<(Definition, UsageSearchResult)>,\n }\n \n impl<'db> MatchFinder<'db> {\n@@ -58,8 +58,8 @@ impl<'db> MatchFinder<'db> {\n     ) {\n         if let Some(resolved_path) = pick_path_for_usages(pattern) {\n             let definition: Definition = resolved_path.resolution.clone().into();\n-            for reference in self.find_usages(usage_cache, definition) {\n-                if let Some(node_to_match) = self.find_node_to_match(resolved_path, reference) {\n+            for file_range in self.find_usages(usage_cache, definition).file_ranges() {\n+                if let Some(node_to_match) = self.find_node_to_match(resolved_path, file_range) {\n                     if !is_search_permitted_ancestors(&node_to_match) {\n                         mark::hit!(use_declaration_with_braces);\n                         continue;\n@@ -73,11 +73,11 @@ impl<'db> MatchFinder<'db> {\n     fn find_node_to_match(\n         &self,\n         resolved_path: &ResolvedPath,\n-        reference: &Reference,\n+        file_range: FileRange,\n     ) -> Option<SyntaxNode> {\n-        let file = self.sema.parse(reference.file_range.file_id);\n+        let file = self.sema.parse(file_range.file_id);\n         let depth = resolved_path.depth as usize;\n-        let offset = reference.file_range.range.start();\n+        let offset = file_range.range.start();\n         if let Some(path) =\n             self.sema.find_node_at_offset_with_descend::<ast::Path>(file.syntax(), offset)\n         {\n@@ -108,7 +108,7 @@ impl<'db> MatchFinder<'db> {\n         &self,\n         usage_cache: &'a mut UsageCache,\n         definition: Definition,\n-    ) -> &'a [Reference] {\n+    ) -> &'a UsageSearchResult {\n         // Logically if a lookup succeeds we should just return it. Unfortunately returning it would\n         // extend the lifetime of the borrow, then we wouldn't be able to do the insertion on a\n         // cache miss. This is a limitation of NLL and is fixed with Polonius. For now we do two\n@@ -250,7 +250,7 @@ fn is_search_permitted(node: &SyntaxNode) -> bool {\n }\n \n impl UsageCache {\n-    fn find(&mut self, definition: &Definition) -> Option<&[Reference]> {\n+    fn find(&mut self, definition: &Definition) -> Option<&UsageSearchResult> {\n         // We expect a very small number of cache entries (generally 1), so a linear scan should be\n         // fast enough and avoids the need to implement Hash for Definition.\n         for (d, refs) in &self.usages {"}]}