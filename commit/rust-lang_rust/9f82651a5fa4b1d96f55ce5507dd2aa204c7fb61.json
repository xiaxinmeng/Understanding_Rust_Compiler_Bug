{"sha": "9f82651a5fa4b1d96f55ce5507dd2aa204c7fb61", "node_id": "C_kwDOAAsO6NoAKDlmODI2NTFhNWZhNGIxZDk2ZjU1Y2U1NTA3ZGQyYWEyMDRjN2ZiNjE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-01-28T22:11:11Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-01-28T22:11:11Z"}, "message": "Auto merge of #103659 - clubby789:improve-partialord-derive, r=nagisa\n\nSpecial-case deriving `PartialOrd` for enums with dataless variants\n\nI was able to get slightly better codegen by flipping the derived `PartialOrd` logic for two-variant enums.  I also tried to document the implementation of the derive macro to make the special-case logic a little clearer.\n```rs\n#[derive(PartialEq, PartialOrd)]\npub enum A<T> {\n    A,\n    B(T)\n}\n```\n```diff\nimpl<T: ::core::cmp::PartialOrd> ::core::cmp::PartialOrd for A<T> {\n   #[inline]\n   fn partial_cmp(\n       &self,\n       other: &A<T>,\n   ) -> ::core::option::Option<::core::cmp::Ordering> {\n       let __self_tag = ::core::intrinsics::discriminant_value(self);\n       let __arg1_tag = ::core::intrinsics::discriminant_value(other);\n-      match ::core::cmp::PartialOrd::partial_cmp(&__self_tag, &__arg1_tag) {\n-          ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {\n-              match (self, other) {\n-                  (A::B(__self_0), A::B(__arg1_0)) => {\n-                      ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)\n-                  }\n-                  _ => ::core::option::Option::Some(::core::cmp::Ordering::Equal),\n-              }\n+      match (self, other) {\n+          (A::B(__self_0), A::B(__arg1_0)) => {\n+              ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)\n           }\n-          cmp => cmp,\n+          _ => ::core::cmp::PartialOrd::partial_cmp(&__self_tag, &__arg1_tag),\n       }\n   }\n}\n```\nGodbolt: [Current](https://godbolt.org/z/GYjEzG1T8), [New](https://godbolt.org/z/GoK78qx15)\nI'm not sure how common a case comparing two enums like this (such as `Option`) is, and if it's worth the slowdown of adding a special case to the derive. If it causes overall regressions it might be worth just manually implementing this for `Option`.", "tree": {"sha": "abfc4e7c71dc1de1731ca4f985203059d644078b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/abfc4e7c71dc1de1731ca4f985203059d644078b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9f82651a5fa4b1d96f55ce5507dd2aa204c7fb61", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9f82651a5fa4b1d96f55ce5507dd2aa204c7fb61", "html_url": "https://github.com/rust-lang/rust/commit/9f82651a5fa4b1d96f55ce5507dd2aa204c7fb61", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9f82651a5fa4b1d96f55ce5507dd2aa204c7fb61/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1e225413a21fa69570bd3fefea9eb05e33f8b917", "url": "https://api.github.com/repos/rust-lang/rust/commits/1e225413a21fa69570bd3fefea9eb05e33f8b917", "html_url": "https://github.com/rust-lang/rust/commit/1e225413a21fa69570bd3fefea9eb05e33f8b917"}, {"sha": "2883148e60603ce42ed296b9d9f1913083748f3a", "url": "https://api.github.com/repos/rust-lang/rust/commits/2883148e60603ce42ed296b9d9f1913083748f3a", "html_url": "https://github.com/rust-lang/rust/commit/2883148e60603ce42ed296b9d9f1913083748f3a"}], "stats": {"total": 133, "additions": 96, "deletions": 37}, "files": [{"sha": "2fc30d8e05f2c6748c4e03ed0a07d056105e3439", "filename": "compiler/rustc_builtin_macros/src/deriving/cmp/partial_ord.rs", "status": "modified", "additions": 73, "deletions": 9, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/9f82651a5fa4b1d96f55ce5507dd2aa204c7fb61/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f82651a5fa4b1d96f55ce5507dd2aa204c7fb61/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_ord.rs?ref=9f82651a5fa4b1d96f55ce5507dd2aa204c7fb61", "patch": "@@ -1,7 +1,7 @@\n use crate::deriving::generic::ty::*;\n use crate::deriving::generic::*;\n use crate::deriving::{path_std, pathvec_std};\n-use rustc_ast::MetaItem;\n+use rustc_ast::{ExprKind, ItemKind, MetaItem, PatKind};\n use rustc_expand::base::{Annotatable, ExtCtxt};\n use rustc_span::symbol::{sym, Ident};\n use rustc_span::Span;\n@@ -21,6 +21,27 @@ pub fn expand_deriving_partial_ord(\n \n     let attrs = thin_vec![cx.attr_word(sym::inline, span)];\n \n+    // Order in which to perform matching\n+    let tag_then_data = if let Annotatable::Item(item) = item\n+        && let ItemKind::Enum(def, _) = &item.kind {\n+            let dataful: Vec<bool> = def.variants.iter().map(|v| !v.data.fields().is_empty()).collect();\n+            match dataful.iter().filter(|&&b| b).count() {\n+                // No data, placing the tag check first makes codegen simpler\n+                0 => true,\n+                1..=2 => false,\n+                _ => {\n+                    (0..dataful.len()-1).any(|i| {\n+                        if dataful[i] && let Some(idx) = dataful[i+1..].iter().position(|v| *v) {\n+                            idx >= 2\n+                        } else {\n+                            false\n+                        }\n+                    })\n+                }\n+            }\n+        } else {\n+            true\n+        };\n     let partial_cmp_def = MethodDef {\n         name: sym::partial_cmp,\n         generics: Bounds::empty(),\n@@ -30,7 +51,7 @@ pub fn expand_deriving_partial_ord(\n         attributes: attrs,\n         fieldless_variants_strategy: FieldlessVariantsStrategy::Unify,\n         combine_substructure: combine_substructure(Box::new(|cx, span, substr| {\n-            cs_partial_cmp(cx, span, substr)\n+            cs_partial_cmp(cx, span, substr, tag_then_data)\n         })),\n     };\n \n@@ -47,7 +68,12 @@ pub fn expand_deriving_partial_ord(\n     trait_def.expand(cx, mitem, item, push)\n }\n \n-pub fn cs_partial_cmp(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>) -> BlockOrExpr {\n+fn cs_partial_cmp(\n+    cx: &mut ExtCtxt<'_>,\n+    span: Span,\n+    substr: &Substructure<'_>,\n+    tag_then_data: bool,\n+) -> BlockOrExpr {\n     let test_id = Ident::new(sym::cmp, span);\n     let equal_path = cx.path_global(span, cx.std_path(&[sym::cmp, sym::Ordering, sym::Equal]));\n     let partial_cmp_path = cx.std_path(&[sym::cmp, sym::PartialOrd, sym::partial_cmp]);\n@@ -74,12 +100,50 @@ pub fn cs_partial_cmp(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_\n                 let args = vec![field.self_expr.clone(), other_expr.clone()];\n                 cx.expr_call_global(field.span, partial_cmp_path.clone(), args)\n             }\n-            CsFold::Combine(span, expr1, expr2) => {\n-                let eq_arm =\n-                    cx.arm(span, cx.pat_some(span, cx.pat_path(span, equal_path.clone())), expr1);\n-                let neq_arm =\n-                    cx.arm(span, cx.pat_ident(span, test_id), cx.expr_ident(span, test_id));\n-                cx.expr_match(span, expr2, vec![eq_arm, neq_arm])\n+            CsFold::Combine(span, mut expr1, expr2) => {\n+                // When the item is an enum, this expands to\n+                // ```\n+                // match (expr2) {\n+                //     Some(Ordering::Equal) => expr1,\n+                //     cmp => cmp\n+                // }\n+                // ```\n+                // where `expr2` is `partial_cmp(self_tag, other_tag)`, and `expr1` is a `match`\n+                //  against the enum variants. This means that we begin by comparing the enum tags,\n+                // before either inspecting their contents (if they match), or returning\n+                // the `cmp::Ordering` of comparing the enum tags.\n+                // ```\n+                // match partial_cmp(self_tag, other_tag) {\n+                //     Some(Ordering::Equal) => match (self, other)  {\n+                //         (Self::A(self_0), Self::A(other_0)) => partial_cmp(self_0, other_0),\n+                //         (Self::B(self_0), Self::B(other_0)) => partial_cmp(self_0, other_0),\n+                //         _ => Some(Ordering::Equal)\n+                //     }\n+                //     cmp => cmp\n+                // }\n+                // ```\n+                // If we have any certain enum layouts, flipping this results in better codegen\n+                // ```\n+                // match (self, other) {\n+                //     (Self::A(self_0), Self::A(other_0)) => partial_cmp(self_0, other_0),\n+                //     _ => partial_cmp(self_tag, other_tag)\n+                // }\n+                // ```\n+                // Reference: https://github.com/rust-lang/rust/pull/103659#issuecomment-1328126354\n+\n+                if !tag_then_data\n+                    && let ExprKind::Match(_, arms) = &mut expr1.kind\n+                    && let Some(last) = arms.last_mut()\n+                    && let PatKind::Wild = last.pat.kind {\n+                        last.body = expr2;\n+                        expr1\n+                } else {\n+                    let eq_arm =\n+                        cx.arm(span, cx.pat_some(span, cx.pat_path(span, equal_path.clone())), expr1);\n+                    let neq_arm =\n+                        cx.arm(span, cx.pat_ident(span, test_id), cx.expr_ident(span, test_id));\n+                    cx.expr_match(span, expr2, vec![eq_arm, neq_arm])\n+                }\n             }\n             CsFold::Fieldless => cx.expr_some(span, cx.expr_path(equal_path.clone())),\n         },"}, {"sha": "2a93a05c627698a2e1eb03e57133fed99215a508", "filename": "tests/ui/deriving/deriving-all-codegen.stdout", "status": "modified", "additions": 23, "deletions": 28, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/9f82651a5fa4b1d96f55ce5507dd2aa204c7fb61/tests%2Fui%2Fderiving%2Fderiving-all-codegen.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/9f82651a5fa4b1d96f55ce5507dd2aa204c7fb61/tests%2Fui%2Fderiving%2Fderiving-all-codegen.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fderiving%2Fderiving-all-codegen.stdout?ref=9f82651a5fa4b1d96f55ce5507dd2aa204c7fb61", "patch": "@@ -889,23 +889,20 @@ impl ::core::cmp::PartialOrd for Mixed {\n         -> ::core::option::Option<::core::cmp::Ordering> {\n         let __self_tag = ::core::intrinsics::discriminant_value(self);\n         let __arg1_tag = ::core::intrinsics::discriminant_value(other);\n-        match ::core::cmp::PartialOrd::partial_cmp(&__self_tag, &__arg1_tag) {\n-            ::core::option::Option::Some(::core::cmp::Ordering::Equal) =>\n-                match (self, other) {\n-                    (Mixed::R(__self_0), Mixed::R(__arg1_0)) =>\n-                        ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),\n-                    (Mixed::S { d1: __self_0, d2: __self_1 }, Mixed::S {\n-                        d1: __arg1_0, d2: __arg1_1 }) =>\n-                        match ::core::cmp::PartialOrd::partial_cmp(__self_0,\n-                                __arg1_0) {\n-                            ::core::option::Option::Some(::core::cmp::Ordering::Equal)\n-                                => ::core::cmp::PartialOrd::partial_cmp(__self_1, __arg1_1),\n-                            cmp => cmp,\n-                        },\n-                    _ =>\n-                        ::core::option::Option::Some(::core::cmp::Ordering::Equal),\n+        match (self, other) {\n+            (Mixed::R(__self_0), Mixed::R(__arg1_0)) =>\n+                ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),\n+            (Mixed::S { d1: __self_0, d2: __self_1 }, Mixed::S {\n+                d1: __arg1_0, d2: __arg1_1 }) =>\n+                match ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)\n+                    {\n+                    ::core::option::Option::Some(::core::cmp::Ordering::Equal)\n+                        => ::core::cmp::PartialOrd::partial_cmp(__self_1, __arg1_1),\n+                    cmp => cmp,\n                 },\n-            cmp => cmp,\n+            _ =>\n+                ::core::cmp::PartialOrd::partial_cmp(&__self_tag,\n+                    &__arg1_tag),\n         }\n     }\n }\n@@ -1019,18 +1016,16 @@ impl ::core::cmp::PartialOrd for Fielded {\n         -> ::core::option::Option<::core::cmp::Ordering> {\n         let __self_tag = ::core::intrinsics::discriminant_value(self);\n         let __arg1_tag = ::core::intrinsics::discriminant_value(other);\n-        match ::core::cmp::PartialOrd::partial_cmp(&__self_tag, &__arg1_tag) {\n-            ::core::option::Option::Some(::core::cmp::Ordering::Equal) =>\n-                match (self, other) {\n-                    (Fielded::X(__self_0), Fielded::X(__arg1_0)) =>\n-                        ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),\n-                    (Fielded::Y(__self_0), Fielded::Y(__arg1_0)) =>\n-                        ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),\n-                    (Fielded::Z(__self_0), Fielded::Z(__arg1_0)) =>\n-                        ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),\n-                    _ => unsafe { ::core::intrinsics::unreachable() }\n-                },\n-            cmp => cmp,\n+        match (self, other) {\n+            (Fielded::X(__self_0), Fielded::X(__arg1_0)) =>\n+                ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),\n+            (Fielded::Y(__self_0), Fielded::Y(__arg1_0)) =>\n+                ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),\n+            (Fielded::Z(__self_0), Fielded::Z(__arg1_0)) =>\n+                ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),\n+            _ =>\n+                ::core::cmp::PartialOrd::partial_cmp(&__self_tag,\n+                    &__arg1_tag),\n         }\n     }\n }"}]}