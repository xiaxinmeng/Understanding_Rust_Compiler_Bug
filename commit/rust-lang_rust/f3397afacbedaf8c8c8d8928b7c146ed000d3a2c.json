{"sha": "f3397afacbedaf8c8c8d8928b7c146ed000d3a2c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYzMzk3YWZhY2JlZGFmOGM4YzhkODkyOGI3YzE0NmVkMDAwZDNhMmM=", "commit": {"author": {"name": "llogiq", "email": "bogusandre@gmail.com", "date": "2016-06-16T17:00:43Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-06-16T17:00:43Z"}, "message": "Merge pull request #994 from oli-obk/stuttter\n\nStuttter lint", "tree": {"sha": "95cd6607df121b7269747133b8fb008913448611", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/95cd6607df121b7269747133b8fb008913448611"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f3397afacbedaf8c8c8d8928b7c146ed000d3a2c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f3397afacbedaf8c8c8d8928b7c146ed000d3a2c", "html_url": "https://github.com/rust-lang/rust/commit/f3397afacbedaf8c8c8d8928b7c146ed000d3a2c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f3397afacbedaf8c8c8d8928b7c146ed000d3a2c/comments", "author": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4e8c87ad081c193b2bcdb5ec83a5b0fcb43ef4b7", "url": "https://api.github.com/repos/rust-lang/rust/commits/4e8c87ad081c193b2bcdb5ec83a5b0fcb43ef4b7", "html_url": "https://github.com/rust-lang/rust/commit/4e8c87ad081c193b2bcdb5ec83a5b0fcb43ef4b7"}, {"sha": "e628e4d513ac9d85e7dd98740ec107b4d103bb27", "url": "https://api.github.com/repos/rust-lang/rust/commits/e628e4d513ac9d85e7dd98740ec107b4d103bb27", "html_url": "https://github.com/rust-lang/rust/commit/e628e4d513ac9d85e7dd98740ec107b4d103bb27"}], "stats": {"total": 401, "additions": 240, "deletions": 161}, "files": [{"sha": "3c2f9e1a622e8e7a08b32a393cfed2896cc014a8", "filename": "CHANGELOG.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f3397afacbedaf8c8c8d8928b7c146ed000d3a2c/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/f3397afacbedaf8c8c8d8928b7c146ed000d3a2c/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=f3397afacbedaf8c8c8d8928b7c146ed000d3a2c", "patch": "@@ -240,6 +240,7 @@ All notable changes to this project will be documented in this file.\n [`string_add_assign`]: https://github.com/Manishearth/rust-clippy/wiki#string_add_assign\n [`string_lit_as_bytes`]: https://github.com/Manishearth/rust-clippy/wiki#string_lit_as_bytes\n [`string_to_string`]: https://github.com/Manishearth/rust-clippy/wiki#string_to_string\n+[`stutter`]: https://github.com/Manishearth/rust-clippy/wiki#stutter\n [`suspicious_assignment_formatting`]: https://github.com/Manishearth/rust-clippy/wiki#suspicious_assignment_formatting\n [`suspicious_else_formatting`]: https://github.com/Manishearth/rust-clippy/wiki#suspicious_else_formatting\n [`temporary_assignment`]: https://github.com/Manishearth/rust-clippy/wiki#temporary_assignment"}, {"sha": "a8e8cbb3a5adeaa5f3a568cb9939cee1e44b214a", "filename": "README.md", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f3397afacbedaf8c8c8d8928b7c146ed000d3a2c/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/f3397afacbedaf8c8c8d8928b7c146ed000d3a2c/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=f3397afacbedaf8c8c8d8928b7c146ed000d3a2c", "patch": "@@ -17,7 +17,7 @@ Table of contents:\n \n ## Lints\n \n-There are 153 lints included in this crate:\n+There are 154 lints included in this crate:\n \n name                                                                                                                 | default | meaning\n ---------------------------------------------------------------------------------------------------------------------|---------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n@@ -144,6 +144,7 @@ name\n [string_add](https://github.com/Manishearth/rust-clippy/wiki#string_add)                                             | allow   | using `x + ..` where x is a `String`; suggests using `push_str()` instead\n [string_add_assign](https://github.com/Manishearth/rust-clippy/wiki#string_add_assign)                               | allow   | using `x = x + ..` where x is a `String`; suggests using `push_str()` instead\n [string_lit_as_bytes](https://github.com/Manishearth/rust-clippy/wiki#string_lit_as_bytes)                           | warn    | calling `as_bytes` on a string literal; suggests using a byte string literal instead\n+[stutter](https://github.com/Manishearth/rust-clippy/wiki#stutter)                                                   | allow   | finds type names prefixed/postfixed with their containing module's name\n [suspicious_assignment_formatting](https://github.com/Manishearth/rust-clippy/wiki#suspicious_assignment_formatting) | warn    | suspicious formatting of `*=`, `-=` or `!=`\n [suspicious_else_formatting](https://github.com/Manishearth/rust-clippy/wiki#suspicious_else_formatting)             | warn    | suspicious formatting of `else if`\n [temporary_assignment](https://github.com/Manishearth/rust-clippy/wiki#temporary_assignment)                         | warn    | assignments to temporaries"}, {"sha": "967fd8b47c606fd2c9c1e54cee0af72632885c13", "filename": "clippy_lints/src/approx_const.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f3397afacbedaf8c8c8d8928b7c146ed000d3a2c/clippy_lints%2Fsrc%2Fapprox_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3397afacbedaf8c8c8d8928b7c146ed000d3a2c/clippy_lints%2Fsrc%2Fapprox_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fapprox_const.rs?ref=f3397afacbedaf8c8c8d8928b7c146ed000d3a2c", "patch": "@@ -37,15 +37,15 @@ const KNOWN_CONSTS: &'static [(f64, &'static str, usize)] = &[(f64::E, \"E\", 4),\n                                                               (f64::SQRT_2, \"SQRT_2\", 5)];\n \n #[derive(Copy,Clone)]\n-pub struct ApproxConstant;\n+pub struct Pass;\n \n-impl LintPass for ApproxConstant {\n+impl LintPass for Pass {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(APPROX_CONSTANT)\n     }\n }\n \n-impl LateLintPass for ApproxConstant {\n+impl LateLintPass for Pass {\n     fn check_expr(&mut self, cx: &LateContext, e: &Expr) {\n         if let ExprLit(ref lit) = e.node {\n             check_lit(cx, lit, e);"}, {"sha": "4306204e52706eb96e9b6e2482fab7ebb3e4b390", "filename": "clippy_lints/src/doc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f3397afacbedaf8c8c8d8928b7c146ed000d3a2c/clippy_lints%2Fsrc%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3397afacbedaf8c8c8d8928b7c146ed000d3a2c/clippy_lints%2Fsrc%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdoc.rs?ref=f3397afacbedaf8c8c8d8928b7c146ed000d3a2c", "patch": "@@ -80,7 +80,7 @@ pub fn check_attrs<'a>(cx: &EarlyContext, valid_idents: &[String], attrs: &'a [a\n }\n \n #[allow(while_let_loop)] // #362\n-pub fn check_doc(cx: &EarlyContext, valid_idents: &[String], docs: &[(&str, Span)]) -> Result<(), ()> {\n+fn check_doc(cx: &EarlyContext, valid_idents: &[String], docs: &[(&str, Span)]) -> Result<(), ()> {\n     // In markdown, `_` can be used to emphasize something, or, is a raw `_` depending on context.\n     // There really is no markdown specification that would disambiguate this properly. This is\n     // what GitHub and Rustdoc do:"}, {"sha": "8c299b8f2d6d4e8c504fef67e137c966ac840f41", "filename": "clippy_lints/src/drop_ref.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f3397afacbedaf8c8c8d8928b7c146ed000d3a2c/clippy_lints%2Fsrc%2Fdrop_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3397afacbedaf8c8c8d8928b7c146ed000d3a2c/clippy_lints%2Fsrc%2Fdrop_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdrop_ref.rs?ref=f3397afacbedaf8c8c8d8928b7c146ed000d3a2c", "patch": "@@ -23,15 +23,15 @@ declare_lint! {\n }\n \n #[allow(missing_copy_implementations)]\n-pub struct DropRefPass;\n+pub struct Pass;\n \n-impl LintPass for DropRefPass {\n+impl LintPass for Pass {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(DROP_REF)\n     }\n }\n \n-impl LateLintPass for DropRefPass {\n+impl LateLintPass for Pass {\n     fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n         if let ExprCall(ref path, ref args) = expr.node {\n             if let ExprPath(None, _) = path.node {"}, {"sha": "0390cd6c5d64d1cc538eb717d1c734a673a0ddf6", "filename": "clippy_lints/src/enum_clike.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f3397afacbedaf8c8c8d8928b7c146ed000d3a2c/clippy_lints%2Fsrc%2Fenum_clike.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3397afacbedaf8c8c8d8928b7c146ed000d3a2c/clippy_lints%2Fsrc%2Fenum_clike.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fenum_clike.rs?ref=f3397afacbedaf8c8c8d8928b7c146ed000d3a2c", "patch": "@@ -18,15 +18,15 @@ declare_lint! {\n     \"finds C-like enums that are `repr(isize/usize)` and have values that don't fit into an `i32`\"\n }\n \n-pub struct EnumClikeUnportableVariant;\n+pub struct UnportableVariant;\n \n-impl LintPass for EnumClikeUnportableVariant {\n+impl LintPass for UnportableVariant {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(ENUM_CLIKE_UNPORTABLE_VARIANT)\n     }\n }\n \n-impl LateLintPass for EnumClikeUnportableVariant {\n+impl LateLintPass for UnportableVariant {\n     #[allow(cast_possible_truncation, cast_sign_loss)]\n     fn check_item(&mut self, cx: &LateContext, item: &Item) {\n         if let ItemEnum(ref def, _) = item.node {"}, {"sha": "4bf65ec42973482d79fa5abca3f250aeef743cf3", "filename": "clippy_lints/src/enum_variants.rs", "status": "modified", "additions": 123, "deletions": 56, "changes": 179, "blob_url": "https://github.com/rust-lang/rust/blob/f3397afacbedaf8c8c8d8928b7c146ed000d3a2c/clippy_lints%2Fsrc%2Fenum_variants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3397afacbedaf8c8c8d8928b7c146ed000d3a2c/clippy_lints%2Fsrc%2Fenum_variants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fenum_variants.rs?ref=f3397afacbedaf8c8c8d8928b7c146ed000d3a2c", "patch": "@@ -2,9 +2,10 @@\n \n use rustc::lint::*;\n use syntax::ast::*;\n+use syntax::codemap::Span;\n use syntax::parse::token::InternedString;\n-use utils::span_help_and_lint;\n-use utils::{camel_case_from, camel_case_until};\n+use utils::{span_help_and_lint, span_lint};\n+use utils::{camel_case_from, camel_case_until, in_macro};\n \n /// **What it does:** Warns on enum variants that are prefixed or suffixed by the same characters\n ///\n@@ -18,87 +19,153 @@ declare_lint! {\n     \"finds enums where all variants share a prefix/postfix\"\n }\n \n-pub struct EnumVariantNames;\n+/// **What it does:** Warns on type names that are prefixed or suffixed by the containing module's name\n+///\n+/// **Why is this bad?** It requires the user to type the module name twice\n+///\n+/// **Known problems:** None\n+///\n+/// **Example:** mod cake { struct BlackForestCake; }\n+declare_lint! {\n+    pub STUTTER, Allow,\n+    \"finds type names prefixed/postfixed with their containing module's name\"\n+}\n+\n+#[derive(Default)]\n+pub struct EnumVariantNames {\n+    modules: Vec<String>,\n+}\n \n impl LintPass for EnumVariantNames {\n     fn get_lints(&self) -> LintArray {\n-        lint_array!(ENUM_VARIANT_NAMES)\n+        lint_array!(ENUM_VARIANT_NAMES, STUTTER)\n     }\n }\n \n fn var2str(var: &Variant) -> InternedString {\n     var.node.name.name.as_str()\n }\n \n-// FIXME: waiting for https://github.com/rust-lang/rust/pull/31700\n-// fn partial_match(pre: &str, name: &str) -> usize {\n-//    // skip(1) to ensure that the prefix never takes the whole variant name\n-//     pre.chars().zip(name.chars().rev().skip(1).rev()).take_while(|&(l, r)| l == r).count()\n-// }\n-//\n-// fn partial_rmatch(post: &str, name: &str) -> usize {\n-//     // skip(1) to ensure that the postfix never takes the whole variant name\n-//     post.chars().rev().zip(name.chars().skip(1).rev()).take_while(|&(l, r)| l == r).count()\n-// }\n-\n+/// Returns the number of chars that match from the start\n fn partial_match(pre: &str, name: &str) -> usize {\n     let mut name_iter = name.chars();\n     let _ = name_iter.next_back(); // make sure the name is never fully matched\n     pre.chars().zip(name_iter).take_while(|&(l, r)| l == r).count()\n }\n \n+/// Returns the number of chars that match from the end\n fn partial_rmatch(post: &str, name: &str) -> usize {\n     let mut name_iter = name.chars();\n     let _ = name_iter.next(); // make sure the name is never fully matched\n     post.chars().rev().zip(name_iter.rev()).take_while(|&(l, r)| l == r).count()\n }\n \n-impl EarlyLintPass for EnumVariantNames {\n-    // FIXME: #600\n-    #[allow(while_let_on_iterator)]\n-    fn check_item(&mut self, cx: &EarlyContext, item: &Item) {\n-        if let ItemKind::Enum(ref def, _) = item.node {\n-            if def.variants.len() < 2 {\n-                return;\n+// FIXME: #600\n+#[allow(while_let_on_iterator)]\n+fn check_variant(cx: &EarlyContext, def: &EnumDef, item_name: &str, item_name_chars: usize, span: Span) {\n+    for var in &def.variants {\n+        let name = var2str(var);\n+        if partial_match(item_name, &name) == item_name_chars {\n+            span_lint(cx, ENUM_VARIANT_NAMES, var.span, \"Variant name starts with the enum's name\");\n+        }\n+        if partial_rmatch(item_name, &name) == item_name_chars {\n+            span_lint(cx, ENUM_VARIANT_NAMES, var.span, \"Variant name ends with the enum's name\");\n+        }\n+    }\n+    if def.variants.len() < 2 {\n+        return;\n+    }\n+    let first = var2str(&def.variants[0]);\n+    let mut pre = &first[..camel_case_until(&*first)];\n+    let mut post = &first[camel_case_from(&*first)..];\n+    for var in &def.variants {\n+        let name = var2str(var);\n+\n+        let pre_match = partial_match(pre, &name);\n+        pre = &pre[..pre_match];\n+        let pre_camel = camel_case_until(pre);\n+        pre = &pre[..pre_camel];\n+        while let Some((next, last)) = name[pre.len()..].chars().zip(pre.chars().rev()).next() {\n+            if next.is_lowercase() {\n+                let last = pre.len() - last.len_utf8();\n+                let last_camel = camel_case_until(&pre[..last]);\n+                pre = &pre[..last_camel];\n+            } else {\n+                break;\n             }\n-            let first = var2str(&def.variants[0]);\n-            let mut pre = &first[..camel_case_until(&*first)];\n-            let mut post = &first[camel_case_from(&*first)..];\n-            for var in &def.variants {\n-                let name = var2str(var);\n+        }\n \n-                let pre_match = partial_match(pre, &name);\n-                pre = &pre[..pre_match];\n-                let pre_camel = camel_case_until(pre);\n-                pre = &pre[..pre_camel];\n-                while let Some((next, last)) = name[pre.len()..].chars().zip(pre.chars().rev()).next() {\n-                    if next.is_lowercase() {\n-                        let last = pre.len() - last.len_utf8();\n-                        let last_camel = camel_case_until(&pre[..last]);\n-                        pre = &pre[..last_camel];\n-                    } else {\n-                        break;\n+        let post_match = partial_rmatch(post, &name);\n+        let post_end = post.len() - post_match;\n+        post = &post[post_end..];\n+        let post_camel = camel_case_from(post);\n+        post = &post[post_camel..];\n+    }\n+    let (what, value) = match (pre.is_empty(), post.is_empty()) {\n+        (true, true) => return,\n+        (false, _) => (\"pre\", pre),\n+        (true, false) => (\"post\", post),\n+    };\n+    span_help_and_lint(cx,\n+                       ENUM_VARIANT_NAMES,\n+                       span,\n+                       &format!(\"All variants have the same {}fix: `{}`\", what, value),\n+                       &format!(\"remove the {}fixes and use full paths to \\\n+                                 the variants instead of glob imports\",\n+                                what));\n+}\n+\n+fn to_camel_case(item_name: &str) -> String {\n+    let mut s = String::new();\n+    let mut up = true;\n+    for c in item_name.chars() {\n+        if c.is_uppercase() {\n+            // we only turn snake case text into CamelCase\n+            return item_name.to_string();\n+        }\n+        if c == '_' {\n+            up = true;\n+            continue;\n+        }\n+        if up {\n+            up = false;\n+            s.extend(c.to_uppercase());\n+        } else {\n+            s.push(c);\n+        }\n+    }\n+    s\n+}\n+\n+impl EarlyLintPass for EnumVariantNames {\n+    fn check_item_post(&mut self, _cx: &EarlyContext, _item: &Item) {\n+        let last = self.modules.pop();\n+        assert!(last.is_some());\n+    }\n+\n+    fn check_item(&mut self, cx: &EarlyContext, item: &Item) {\n+        let item_name = item.ident.name.as_str();\n+        let item_name_chars = item_name.chars().count();\n+        let item_camel = to_camel_case(&item_name);\n+        if item.vis == Visibility::Public && !in_macro(cx, item.span) {\n+            if let Some(mod_camel) = self.modules.last() {\n+                // constants don't have surrounding modules\n+                if !mod_camel.is_empty() {\n+                    let matching = partial_match(mod_camel, &item_camel);\n+                    let rmatching = partial_rmatch(mod_camel, &item_camel);\n+                    let nchars = mod_camel.chars().count();\n+                    if matching == nchars {\n+                        span_lint(cx, STUTTER, item.span, &format!(\"Item name ({}) starts with its containing module's name ({})\", item_camel, mod_camel));\n+                    }\n+                    if rmatching == nchars {\n+                        span_lint(cx, STUTTER, item.span, &format!(\"Item name ({}) ends with its containing module's name ({})\", item_camel, mod_camel));\n                     }\n                 }\n-\n-                let post_match = partial_rmatch(post, &name);\n-                let post_end = post.len() - post_match;\n-                post = &post[post_end..];\n-                let post_camel = camel_case_from(post);\n-                post = &post[post_camel..];\n             }\n-            let (what, value) = match (pre.is_empty(), post.is_empty()) {\n-                (true, true) => return,\n-                (false, _) => (\"pre\", pre),\n-                (true, false) => (\"post\", post),\n-            };\n-            span_help_and_lint(cx,\n-                               ENUM_VARIANT_NAMES,\n-                               item.span,\n-                               &format!(\"All variants have the same {}fix: `{}`\", what, value),\n-                               &format!(\"remove the {}fixes and use full paths to \\\n-                                         the variants instead of glob imports\",\n-                                        what));\n         }\n+        if let ItemKind::Enum(ref def, _) = item.node {\n+            check_variant(cx, def, &item_name, item_name_chars, item.span);\n+        }\n+        self.modules.push(item_camel);\n     }\n }"}, {"sha": "2bdfe91a9086ba9b3a3a4c4cba940a17910d55c5", "filename": "clippy_lints/src/escape.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f3397afacbedaf8c8c8d8928b7c146ed000d3a2c/clippy_lints%2Fsrc%2Fescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3397afacbedaf8c8c8d8928b7c146ed000d3a2c/clippy_lints%2Fsrc%2Fescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fescape.rs?ref=f3397afacbedaf8c8c8d8928b7c146ed000d3a2c", "patch": "@@ -11,7 +11,7 @@ use syntax::ast::NodeId;\n use syntax::codemap::Span;\n use utils::span_lint;\n \n-pub struct EscapePass;\n+pub struct Pass;\n \n /// **What it does:** This lint checks for usage of `Box<T>` where an unboxed `T` would work fine.\n ///\n@@ -44,13 +44,13 @@ struct EscapeDelegate<'a, 'tcx: 'a> {\n     set: NodeSet,\n }\n \n-impl LintPass for EscapePass {\n+impl LintPass for Pass {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(BOXED_LOCAL)\n     }\n }\n \n-impl LateLintPass for EscapePass {\n+impl LateLintPass for Pass {\n     fn check_fn(&mut self, cx: &LateContext, _: visit::FnKind, decl: &FnDecl, body: &Block, _: Span, id: NodeId) {\n         let param_env = ty::ParameterEnvironment::for_item(cx.tcx, id);\n "}, {"sha": "2b3835d780fa10f8a77b9927cbfabbdc86db512f", "filename": "clippy_lints/src/format.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f3397afacbedaf8c8c8d8928b7c146ed000d3a2c/clippy_lints%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3397afacbedaf8c8c8d8928b7c146ed000d3a2c/clippy_lints%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fformat.rs?ref=f3397afacbedaf8c8c8d8928b7c146ed000d3a2c", "patch": "@@ -23,15 +23,15 @@ declare_lint! {\n }\n \n #[derive(Copy, Clone, Debug)]\n-pub struct FormatMacLint;\n+pub struct Pass;\n \n-impl LintPass for FormatMacLint {\n+impl LintPass for Pass {\n     fn get_lints(&self) -> LintArray {\n         lint_array![USELESS_FORMAT]\n     }\n }\n \n-impl LateLintPass for FormatMacLint {\n+impl LateLintPass for Pass {\n     fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n         if let Some(span) = is_expn_of(cx, expr.span, \"format\") {\n             match expr.node {"}, {"sha": "b68596f253558350363c8f93c8482c9284764363", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 22, "deletions": 21, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/f3397afacbedaf8c8c8d8928b7c146ed000d3a2c/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3397afacbedaf8c8c8d8928b7c146ed000d3a2c/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=f3397afacbedaf8c8c8d8928b7c146ed000d3a2c", "patch": "@@ -132,7 +132,7 @@ mod reexport {\n \n #[cfg_attr(rustfmt, rustfmt_skip)]\n pub fn register_plugins(reg: &mut rustc_plugin::Registry) {\n-    let conf = match utils::conf::conf_file(reg.args()) {\n+    let conf = match utils::conf::file(reg.args()) {\n         Ok(file_name) => {\n             // if the user specified a file, it must exist, otherwise default to `clippy.toml` but\n             // do not require the file to exist\n@@ -142,7 +142,7 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry) {\n                 (\"clippy.toml\", false)\n             };\n \n-            let (conf, errors) = utils::conf::read_conf(file_name, must_exist);\n+            let (conf, errors) = utils::conf::read(file_name, must_exist);\n \n             // all conf errors are non-fatal, we just use the default conf in case of error\n             for error in errors {\n@@ -171,14 +171,14 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry) {\n     reg.register_late_lint_pass(box misc::TopLevelRefPass);\n     reg.register_late_lint_pass(box misc::CmpNan);\n     reg.register_late_lint_pass(box eq_op::EqOp);\n-    reg.register_early_lint_pass(box enum_variants::EnumVariantNames);\n+    reg.register_early_lint_pass(box enum_variants::EnumVariantNames::default());\n     reg.register_late_lint_pass(box enum_glob_use::EnumGlobUse);\n-    reg.register_late_lint_pass(box enum_clike::EnumClikeUnportableVariant);\n+    reg.register_late_lint_pass(box enum_clike::UnportableVariant);\n     reg.register_late_lint_pass(box bit_mask::BitMask);\n     reg.register_late_lint_pass(box ptr_arg::PtrArg);\n     reg.register_late_lint_pass(box needless_bool::NeedlessBool);\n     reg.register_late_lint_pass(box needless_bool::BoolComparison);\n-    reg.register_late_lint_pass(box approx_const::ApproxConstant);\n+    reg.register_late_lint_pass(box approx_const::Pass);\n     reg.register_late_lint_pass(box misc::FloatCmp);\n     reg.register_early_lint_pass(box precedence::Precedence);\n     reg.register_late_lint_pass(box eta_reduction::EtaPass);\n@@ -195,11 +195,11 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry) {\n     reg.register_late_lint_pass(box unicode::Unicode);\n     reg.register_late_lint_pass(box strings::StringAdd);\n     reg.register_early_lint_pass(box returns::ReturnPass);\n-    reg.register_late_lint_pass(box methods::MethodsPass);\n-    reg.register_late_lint_pass(box shadow::ShadowPass);\n+    reg.register_late_lint_pass(box methods::Pass);\n+    reg.register_late_lint_pass(box shadow::Pass);\n     reg.register_late_lint_pass(box types::LetPass);\n     reg.register_late_lint_pass(box types::UnitCmp);\n-    reg.register_late_lint_pass(box loops::LoopsPass);\n+    reg.register_late_lint_pass(box loops::Pass);\n     reg.register_late_lint_pass(box lifetimes::LifetimePass);\n     reg.register_late_lint_pass(box entry::HashMapLint);\n     reg.register_late_lint_pass(box ranges::StepByZero);\n@@ -208,35 +208,35 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry) {\n     reg.register_late_lint_pass(box matches::MatchPass);\n     reg.register_late_lint_pass(box misc::PatternPass);\n     reg.register_late_lint_pass(box minmax::MinMaxPass);\n-    reg.register_late_lint_pass(box open_options::NonSensicalOpenOptions);\n-    reg.register_late_lint_pass(box zero_div_zero::ZeroDivZeroPass);\n+    reg.register_late_lint_pass(box open_options::NonSensical);\n+    reg.register_late_lint_pass(box zero_div_zero::Pass);\n     reg.register_late_lint_pass(box mutex_atomic::MutexAtomic);\n-    reg.register_late_lint_pass(box needless_update::NeedlessUpdatePass);\n+    reg.register_late_lint_pass(box needless_update::Pass);\n     reg.register_late_lint_pass(box needless_borrow::NeedlessBorrow);\n-    reg.register_late_lint_pass(box no_effect::NoEffectPass);\n-    reg.register_late_lint_pass(box map_clone::MapClonePass);\n-    reg.register_late_lint_pass(box temporary_assignment::TemporaryAssignmentPass);\n+    reg.register_late_lint_pass(box no_effect::Pass);\n+    reg.register_late_lint_pass(box map_clone::Pass);\n+    reg.register_late_lint_pass(box temporary_assignment::Pass);\n     reg.register_late_lint_pass(box transmute::Transmute);\n     reg.register_late_lint_pass(box cyclomatic_complexity::CyclomaticComplexity::new(conf.cyclomatic_complexity_threshold));\n-    reg.register_late_lint_pass(box escape::EscapePass);\n+    reg.register_late_lint_pass(box escape::Pass);\n     reg.register_early_lint_pass(box misc_early::MiscEarly);\n     reg.register_late_lint_pass(box misc::UsedUnderscoreBinding);\n     reg.register_late_lint_pass(box array_indexing::ArrayIndexing);\n-    reg.register_late_lint_pass(box panic::PanicPass);\n+    reg.register_late_lint_pass(box panic::Pass);\n     reg.register_late_lint_pass(box strings::StringLitAsBytes);\n     reg.register_late_lint_pass(box derive::Derive);\n     reg.register_late_lint_pass(box types::CharLitAsU8);\n-    reg.register_late_lint_pass(box print::PrintLint);\n-    reg.register_late_lint_pass(box vec::UselessVec);\n+    reg.register_late_lint_pass(box print::Pass);\n+    reg.register_late_lint_pass(box vec::Pass);\n     reg.register_early_lint_pass(box non_expressive_names::NonExpressiveNames {\n         max_single_char_names: conf.max_single_char_names,\n     });\n-    reg.register_late_lint_pass(box drop_ref::DropRefPass);\n+    reg.register_late_lint_pass(box drop_ref::Pass);\n     reg.register_late_lint_pass(box types::AbsurdExtremeComparisons);\n     reg.register_late_lint_pass(box types::InvalidUpcastComparisons);\n-    reg.register_late_lint_pass(box regex::RegexPass::default());\n+    reg.register_late_lint_pass(box regex::Pass::default());\n     reg.register_late_lint_pass(box copies::CopyAndPaste);\n-    reg.register_late_lint_pass(box format::FormatMacLint);\n+    reg.register_late_lint_pass(box format::Pass);\n     reg.register_early_lint_pass(box formatting::Formatting);\n     reg.register_late_lint_pass(box swap::Swap);\n     reg.register_early_lint_pass(box if_not_else::IfNotElse);\n@@ -263,6 +263,7 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry) {\n         array_indexing::INDEXING_SLICING,\n         booleans::NONMINIMAL_BOOL,\n         enum_glob_use::ENUM_GLOB_USE,\n+        enum_variants::STUTTER,\n         if_not_else::IF_NOT_ELSE,\n         items_after_statements::ITEMS_AFTER_STATEMENTS,\n         matches::SINGLE_MATCH_ELSE,"}, {"sha": "1816d88bddb59d4cff30e7690a16830b1169ca24", "filename": "clippy_lints/src/loops.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f3397afacbedaf8c8c8d8928b7c146ed000d3a2c/clippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3397afacbedaf8c8c8d8928b7c146ed000d3a2c/clippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops.rs?ref=f3397afacbedaf8c8c8d8928b7c146ed000d3a2c", "patch": "@@ -205,9 +205,9 @@ declare_lint! {\n }\n \n #[derive(Copy, Clone)]\n-pub struct LoopsPass;\n+pub struct Pass;\n \n-impl LintPass for LoopsPass {\n+impl LintPass for Pass {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(NEEDLESS_RANGE_LOOP,\n                     EXPLICIT_ITER_LOOP,\n@@ -222,7 +222,7 @@ impl LintPass for LoopsPass {\n     }\n }\n \n-impl LateLintPass for LoopsPass {\n+impl LateLintPass for Pass {\n     fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n         if let Some((pat, arg, body)) = recover_for_loop(expr) {\n             check_for_loop(cx, pat, arg, body, expr);"}, {"sha": "5959d70d9bcb36721fb706acafca638205354252", "filename": "clippy_lints/src/map_clone.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f3397afacbedaf8c8c8d8928b7c146ed000d3a2c/clippy_lints%2Fsrc%2Fmap_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3397afacbedaf8c8c8d8928b7c146ed000d3a2c/clippy_lints%2Fsrc%2Fmap_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmap_clone.rs?ref=f3397afacbedaf8c8c8d8928b7c146ed000d3a2c", "patch": "@@ -18,9 +18,9 @@ declare_lint! {\n }\n \n #[derive(Copy, Clone)]\n-pub struct MapClonePass;\n+pub struct Pass;\n \n-impl LateLintPass for MapClonePass {\n+impl LateLintPass for Pass {\n     fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n         // call to .map()\n         if let ExprMethodCall(name, _, ref args) = expr.node {\n@@ -119,7 +119,7 @@ fn only_derefs(cx: &LateContext, expr: &Expr, id: ast::Name) -> bool {\n     }\n }\n \n-impl LintPass for MapClonePass {\n+impl LintPass for Pass {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(MAP_CLONE)\n     }"}, {"sha": "45d2e259dfadadf2086bd6301f12407ff273323c", "filename": "clippy_lints/src/methods.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f3397afacbedaf8c8c8d8928b7c146ed000d3a2c/clippy_lints%2Fsrc%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3397afacbedaf8c8c8d8928b7c146ed000d3a2c/clippy_lints%2Fsrc%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods.rs?ref=f3397afacbedaf8c8c8d8928b7c146ed000d3a2c", "patch": "@@ -17,7 +17,7 @@ use utils::MethodArgs;\n use utils::paths;\n \n #[derive(Clone)]\n-pub struct MethodsPass;\n+pub struct Pass;\n \n /// **What it does:** This lint checks for `.unwrap()` calls on `Option`s.\n ///\n@@ -336,7 +336,7 @@ declare_lint! {\n     \"using `.iter().nth()` on a slice or Vec\"\n }\n \n-impl LintPass for MethodsPass {\n+impl LintPass for Pass {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(EXTEND_FROM_SLICE,\n                     OPTION_UNWRAP_USED,\n@@ -359,7 +359,7 @@ impl LintPass for MethodsPass {\n     }\n }\n \n-impl LateLintPass for MethodsPass {\n+impl LateLintPass for Pass {\n     fn check_expr(&mut self, cx: &LateContext, expr: &hir::Expr) {\n         if in_macro(cx, expr.span) {\n             return;"}, {"sha": "f46cfc5f123b2d0d98bd78725a0a9e072a8dc880", "filename": "clippy_lints/src/needless_update.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f3397afacbedaf8c8c8d8928b7c146ed000d3a2c/clippy_lints%2Fsrc%2Fneedless_update.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3397afacbedaf8c8c8d8928b7c146ed000d3a2c/clippy_lints%2Fsrc%2Fneedless_update.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_update.rs?ref=f3397afacbedaf8c8c8d8928b7c146ed000d3a2c", "patch": "@@ -17,15 +17,15 @@ declare_lint! {\n }\n \n #[derive(Copy, Clone)]\n-pub struct NeedlessUpdatePass;\n+pub struct Pass;\n \n-impl LintPass for NeedlessUpdatePass {\n+impl LintPass for Pass {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(NEEDLESS_UPDATE)\n     }\n }\n \n-impl LateLintPass for NeedlessUpdatePass {\n+impl LateLintPass for Pass {\n     fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n         if let ExprStruct(_, ref fields, Some(ref base)) = expr.node {\n             let ty = cx.tcx.expr_ty(expr);"}, {"sha": "5b34348219c8de847cb9745efbc622a89d8ab130", "filename": "clippy_lints/src/no_effect.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f3397afacbedaf8c8c8d8928b7c146ed000d3a2c/clippy_lints%2Fsrc%2Fno_effect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3397afacbedaf8c8c8d8928b7c146ed000d3a2c/clippy_lints%2Fsrc%2Fno_effect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fno_effect.rs?ref=f3397afacbedaf8c8c8d8928b7c146ed000d3a2c", "patch": "@@ -78,15 +78,15 @@ fn has_no_effect(cx: &LateContext, expr: &Expr) -> bool {\n }\n \n #[derive(Copy, Clone)]\n-pub struct NoEffectPass;\n+pub struct Pass;\n \n-impl LintPass for NoEffectPass {\n+impl LintPass for Pass {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(NO_EFFECT, UNNECESSARY_OPERATION)\n     }\n }\n \n-impl LateLintPass for NoEffectPass {\n+impl LateLintPass for Pass {\n     fn check_stmt(&mut self, cx: &LateContext, stmt: &Stmt) {\n         if let StmtSemi(ref expr, _) = stmt.node {\n             if has_no_effect(cx, expr) {"}, {"sha": "935edbb1f562067521609a88b032904ae0e282b9", "filename": "clippy_lints/src/open_options.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f3397afacbedaf8c8c8d8928b7c146ed000d3a2c/clippy_lints%2Fsrc%2Fopen_options.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3397afacbedaf8c8c8d8928b7c146ed000d3a2c/clippy_lints%2Fsrc%2Fopen_options.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fopen_options.rs?ref=f3397afacbedaf8c8c8d8928b7c146ed000d3a2c", "patch": "@@ -19,15 +19,15 @@ declare_lint! {\n \n \n #[derive(Copy,Clone)]\n-pub struct NonSensicalOpenOptions;\n+pub struct NonSensical;\n \n-impl LintPass for NonSensicalOpenOptions {\n+impl LintPass for NonSensical {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(NONSENSICAL_OPEN_OPTIONS)\n     }\n }\n \n-impl LateLintPass for NonSensicalOpenOptions {\n+impl LateLintPass for NonSensical {\n     fn check_expr(&mut self, cx: &LateContext, e: &Expr) {\n         if let ExprMethodCall(ref name, _, ref arguments) = e.node {\n             let (obj_ty, _) = walk_ptrs_ty_depth(cx.tcx.expr_ty(&arguments[0]));"}, {"sha": "d3306b4bc6fe7d05fb07e656e0139aeea9c7fbeb", "filename": "clippy_lints/src/panic.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f3397afacbedaf8c8c8d8928b7c146ed000d3a2c/clippy_lints%2Fsrc%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3397afacbedaf8c8c8d8928b7c146ed000d3a2c/clippy_lints%2Fsrc%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fpanic.rs?ref=f3397afacbedaf8c8c8d8928b7c146ed000d3a2c", "patch": "@@ -17,15 +17,15 @@ declare_lint! {\n }\n \n #[allow(missing_copy_implementations)]\n-pub struct PanicPass;\n+pub struct Pass;\n \n-impl LintPass for PanicPass {\n+impl LintPass for Pass {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(PANIC_PARAMS)\n     }\n }\n \n-impl LateLintPass for PanicPass {\n+impl LateLintPass for Pass {\n     fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n         if_let_chain! {[\n             let ExprBlock(ref block) = expr.node,"}, {"sha": "56fefb24f75652f9b3a4070e7a1978b97e0f8441", "filename": "clippy_lints/src/print.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f3397afacbedaf8c8c8d8928b7c146ed000d3a2c/clippy_lints%2Fsrc%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3397afacbedaf8c8c8d8928b7c146ed000d3a2c/clippy_lints%2Fsrc%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fprint.rs?ref=f3397afacbedaf8c8c8d8928b7c146ed000d3a2c", "patch": "@@ -31,15 +31,15 @@ declare_lint! {\n }\n \n #[derive(Copy, Clone, Debug)]\n-pub struct PrintLint;\n+pub struct Pass;\n \n-impl LintPass for PrintLint {\n+impl LintPass for Pass {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(PRINT_STDOUT, USE_DEBUG)\n     }\n }\n \n-impl LateLintPass for PrintLint {\n+impl LateLintPass for Pass {\n     fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n         if let ExprCall(ref fun, ref args) = expr.node {\n             if let ExprPath(_, ref path) = fun.node {"}, {"sha": "26c8568473dd13ff16327c067dabc557907d732a", "filename": "clippy_lints/src/regex.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f3397afacbedaf8c8c8d8928b7c146ed000d3a2c/clippy_lints%2Fsrc%2Fregex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3397afacbedaf8c8c8d8928b7c146ed000d3a2c/clippy_lints%2Fsrc%2Fregex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fregex.rs?ref=f3397afacbedaf8c8c8d8928b7c146ed000d3a2c", "patch": "@@ -56,18 +56,18 @@ declare_lint! {\n }\n \n #[derive(Clone, Default)]\n-pub struct RegexPass {\n+pub struct Pass {\n     spans: HashSet<Span>,\n     last: Option<NodeId>,\n }\n \n-impl LintPass for RegexPass {\n+impl LintPass for Pass {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(INVALID_REGEX, REGEX_MACRO, TRIVIAL_REGEX)\n     }\n }\n \n-impl LateLintPass for RegexPass {\n+impl LateLintPass for Pass {\n     fn check_crate(&mut self, _: &LateContext, _: &Crate) {\n         self.spans.clear();\n     }"}, {"sha": "c42f9cb32d87f6c93d13ba1cbb6d4911cf1b55a6", "filename": "clippy_lints/src/shadow.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f3397afacbedaf8c8c8d8928b7c146ed000d3a2c/clippy_lints%2Fsrc%2Fshadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3397afacbedaf8c8c8d8928b7c146ed000d3a2c/clippy_lints%2Fsrc%2Fshadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fshadow.rs?ref=f3397afacbedaf8c8c8d8928b7c146ed000d3a2c", "patch": "@@ -45,15 +45,15 @@ declare_lint! {\n }\n \n #[derive(Copy, Clone)]\n-pub struct ShadowPass;\n+pub struct Pass;\n \n-impl LintPass for ShadowPass {\n+impl LintPass for Pass {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(SHADOW_SAME, SHADOW_REUSE, SHADOW_UNRELATED)\n     }\n }\n \n-impl LateLintPass for ShadowPass {\n+impl LateLintPass for Pass {\n     fn check_fn(&mut self, cx: &LateContext, _: FnKind, decl: &FnDecl, block: &Block, _: Span, _: NodeId) {\n         if in_external_macro(cx, block.span) {\n             return;"}, {"sha": "5bc3853ac5e068fd0a867f0ce2f90bf28abda2c4", "filename": "clippy_lints/src/temporary_assignment.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f3397afacbedaf8c8c8d8928b7c146ed000d3a2c/clippy_lints%2Fsrc%2Ftemporary_assignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3397afacbedaf8c8c8d8928b7c146ed000d3a2c/clippy_lints%2Fsrc%2Ftemporary_assignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftemporary_assignment.rs?ref=f3397afacbedaf8c8c8d8928b7c146ed000d3a2c", "patch": "@@ -24,15 +24,15 @@ fn is_temporary(expr: &Expr) -> bool {\n }\n \n #[derive(Copy, Clone)]\n-pub struct TemporaryAssignmentPass;\n+pub struct Pass;\n \n-impl LintPass for TemporaryAssignmentPass {\n+impl LintPass for Pass {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(TEMPORARY_ASSIGNMENT)\n     }\n }\n \n-impl LateLintPass for TemporaryAssignmentPass {\n+impl LateLintPass for Pass {\n     fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n         if let ExprAssign(ref target, _) = expr.node {\n             match target.node {"}, {"sha": "323c65364961ed4642d102339203246e59d0f202", "filename": "clippy_lints/src/utils/conf.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/f3397afacbedaf8c8c8d8928b7c146ed000d3a2c/clippy_lints%2Fsrc%2Futils%2Fconf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3397afacbedaf8c8c8d8928b7c146ed000d3a2c/clippy_lints%2Fsrc%2Futils%2Fconf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fconf.rs?ref=f3397afacbedaf8c8c8d8928b7c146ed000d3a2c", "patch": "@@ -5,7 +5,7 @@ use syntax::parse::token;\n use toml;\n \n /// Get the configuration file from arguments.\n-pub fn conf_file(args: &[ptr::P<ast::MetaItem>]) -> Result<Option<token::InternedString>, (&'static str, codemap::Span)> {\n+pub fn file(args: &[ptr::P<ast::MetaItem>]) -> Result<Option<token::InternedString>, (&'static str, codemap::Span)> {\n     for arg in args {\n         match arg.node {\n             ast::MetaItemKind::Word(ref name) |\n@@ -31,18 +31,18 @@ pub fn conf_file(args: &[ptr::P<ast::MetaItem>]) -> Result<Option<token::Interne\n \n /// Error from reading a configuration file.\n #[derive(Debug)]\n-pub enum ConfError {\n-    IoError(io::Error),\n-    TomlError(Vec<toml::ParserError>),\n-    TypeError(&'static str, &'static str, &'static str),\n+pub enum Error {\n+    Io(io::Error),\n+    Toml(Vec<toml::ParserError>),\n+    Type(&'static str, &'static str, &'static str),\n     UnknownKey(String),\n }\n \n-impl fmt::Display for ConfError {\n+impl fmt::Display for Error {\n     fn fmt(&self, f: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n         match *self {\n-            ConfError::IoError(ref err) => err.fmt(f),\n-            ConfError::TomlError(ref errs) => {\n+            Error::Io(ref err) => err.fmt(f),\n+            Error::Toml(ref errs) => {\n                 let mut first = true;\n                 for err in errs {\n                     if !first {\n@@ -55,17 +55,17 @@ impl fmt::Display for ConfError {\n \n                 Ok(())\n             }\n-            ConfError::TypeError(ref key, ref expected, ref got) => {\n+            Error::Type(ref key, ref expected, ref got) => {\n                 write!(f, \"`{}` is expected to be a `{}` but is a `{}`\", key, expected, got)\n             }\n-            ConfError::UnknownKey(ref key) => write!(f, \"unknown key `{}`\", key),\n+            Error::UnknownKey(ref key) => write!(f, \"unknown key `{}`\", key),\n         }\n     }\n }\n \n-impl From<io::Error> for ConfError {\n+impl From<io::Error> for Error {\n     fn from(e: io::Error) -> Self {\n-        ConfError::IoError(e)\n+        Error::Io(e)\n     }\n }\n \n@@ -87,17 +87,17 @@ macro_rules! define_Conf {\n         impl Conf {\n             /// Set the property `name` (which must be the `toml` name) to the given value\n             #[allow(cast_sign_loss)]\n-            fn set(&mut self, name: String, value: toml::Value) -> Result<(), ConfError> {\n+            fn set(&mut self, name: String, value: toml::Value) -> Result<(), Error> {\n                 match name.as_str() {\n                     $(\n                         define_Conf!(PAT $toml_name) => {\n                             if let Some(value) = define_Conf!(CONV $($ty)+, value) {\n                                 self.$rust_name = value;\n                             }\n                             else {\n-                                return Err(ConfError::TypeError(define_Conf!(EXPR $toml_name),\n-                                                                stringify!($($ty)+),\n-                                                                value.type_str()));\n+                                return Err(Error::Type(define_Conf!(EXPR $toml_name),\n+                                                       stringify!($($ty)+),\n+                                                       value.type_str()));\n                             }\n                         },\n                     )+\n@@ -106,7 +106,7 @@ macro_rules! define_Conf {\n                         return Ok(());\n                     }\n                     _ => {\n-                        return Err(ConfError::UnknownKey(name));\n+                        return Err(Error::UnknownKey(name));\n                     }\n                 }\n \n@@ -163,7 +163,7 @@ define_Conf! {\n /// Read the `toml` configuration file. The function will ignore \u201cFile not found\u201d errors iif\n /// `!must_exist`, in which case, it will return the default configuration.\n /// In case of error, the function tries to continue as much as possible.\n-pub fn read_conf(path: &str, must_exist: bool) -> (Conf, Vec<ConfError>) {\n+pub fn read(path: &str, must_exist: bool) -> (Conf, Vec<Error>) {\n     let mut conf = Conf::default();\n     let mut errors = Vec::new();\n \n@@ -191,7 +191,7 @@ pub fn read_conf(path: &str, must_exist: bool) -> (Conf, Vec<ConfError>) {\n     let toml = if let Some(toml) = parser.parse() {\n         toml\n     } else {\n-        errors.push(ConfError::TomlError(parser.errors));\n+        errors.push(Error::Toml(parser.errors));\n         return (conf, errors);\n     };\n "}, {"sha": "73f2fb7caa819b27d58b634cff85037e9b128ae9", "filename": "clippy_lints/src/vec.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f3397afacbedaf8c8c8d8928b7c146ed000d3a2c/clippy_lints%2Fsrc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3397afacbedaf8c8c8d8928b7c146ed000d3a2c/clippy_lints%2Fsrc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fvec.rs?ref=f3397afacbedaf8c8c8d8928b7c146ed000d3a2c", "patch": "@@ -22,15 +22,15 @@ declare_lint! {\n }\n \n #[derive(Copy, Clone, Debug)]\n-pub struct UselessVec;\n+pub struct Pass;\n \n-impl LintPass for UselessVec {\n+impl LintPass for Pass {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(USELESS_VEC)\n     }\n }\n \n-impl LateLintPass for UselessVec {\n+impl LateLintPass for Pass {\n     fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n         // search for `&vec![_]` expressions where the adjusted type is `&[_]`\n         if_let_chain!{[\n@@ -51,12 +51,12 @@ impl LateLintPass for UselessVec {\n }\n \n fn check_vec_macro(cx: &LateContext, vec: &Expr, span: Span) {\n-    if let Some(vec_args) = unexpand_vec(cx, vec) {\n+    if let Some(vec_args) = unexpand(cx, vec) {\n         let snippet = match vec_args {\n-            VecArgs::Repeat(elem, len) => {\n+            Args::Repeat(elem, len) => {\n                 format!(\"&[{}; {}]\", snippet(cx, elem.span, \"elem\"), snippet(cx, len.span, \"len\")).into()\n             }\n-            VecArgs::Vec(args) => {\n+            Args::Vec(args) => {\n                 if let Some(last) = args.iter().last() {\n                     let span = Span {\n                         lo: args[0].span.lo,\n@@ -78,31 +78,31 @@ fn check_vec_macro(cx: &LateContext, vec: &Expr, span: Span) {\n }\n \n /// Represent the pre-expansion arguments of a `vec!` invocation.\n-pub enum VecArgs<'a> {\n+pub enum Args<'a> {\n     /// `vec![elem; len]`\n     Repeat(&'a P<Expr>, &'a P<Expr>),\n     /// `vec![a, b, c]`\n     Vec(&'a [P<Expr>]),\n }\n \n /// Returns the arguments of the `vec!` macro if this expression was expanded from `vec!`.\n-pub fn unexpand_vec<'e>(cx: &LateContext, expr: &'e Expr) -> Option<VecArgs<'e>> {\n+pub fn unexpand<'e>(cx: &LateContext, expr: &'e Expr) -> Option<Args<'e>> {\n     if_let_chain!{[\n         let ExprCall(ref fun, ref args) = expr.node,\n         let ExprPath(_, ref path) = fun.node,\n         is_expn_of(cx, fun.span, \"vec\").is_some()\n     ], {\n         return if match_path(path, &paths::VEC_FROM_ELEM) && args.len() == 2 {\n             // `vec![elem; size]` case\n-            Some(VecArgs::Repeat(&args[0], &args[1]))\n+            Some(Args::Repeat(&args[0], &args[1]))\n         }\n         else if match_path(path, &[\"into_vec\"]) && args.len() == 1 {\n             // `vec![a, b, c]` case\n             if_let_chain!{[\n                 let ExprBox(ref boxed) = args[0].node,\n                 let ExprVec(ref args) = boxed.node\n             ], {\n-                return Some(VecArgs::Vec(&*args));\n+                return Some(Args::Vec(&*args));\n             }}\n \n             None"}, {"sha": "8c9f9871228851c961288cb24feadb74a2e336dc", "filename": "clippy_lints/src/zero_div_zero.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f3397afacbedaf8c8c8d8928b7c146ed000d3a2c/clippy_lints%2Fsrc%2Fzero_div_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3397afacbedaf8c8c8d8928b7c146ed000d3a2c/clippy_lints%2Fsrc%2Fzero_div_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fzero_div_zero.rs?ref=f3397afacbedaf8c8c8d8928b7c146ed000d3a2c", "patch": "@@ -3,10 +3,10 @@ use rustc::lint::*;\n use rustc::hir::*;\n use utils::span_help_and_lint;\n \n-/// `ZeroDivZeroPass` is a pass that checks for a binary expression that consists\n+/// `Pass` is a pass that checks for a binary expression that consists\n /// `of 0.0/0.0`, which is always `NaN`. It is more clear to replace instances of\n /// `0.0/0.0` with `std::f32::NaN` or `std::f64::NaN`, depending on the precision.\n-pub struct ZeroDivZeroPass;\n+pub struct Pass;\n \n /// **What it does:** This lint checks for `0.0 / 0.0`.\n ///\n@@ -21,13 +21,13 @@ declare_lint! {\n     \"usage of `0.0 / 0.0` to obtain NaN instead of std::f32::NaN or std::f64::NaN\"\n }\n \n-impl LintPass for ZeroDivZeroPass {\n+impl LintPass for Pass {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(ZERO_DIVIDED_BY_ZERO)\n     }\n }\n \n-impl LateLintPass for ZeroDivZeroPass {\n+impl LateLintPass for Pass {\n     fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n         // check for instances of 0.0/0.0\n         if_let_chain! {["}, {"sha": "ed7f7823f8fa24a2b3d7468b25e2bd97f56a0695", "filename": "tests/compile-fail/enum_variants.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f3397afacbedaf8c8c8d8928b7c146ed000d3a2c/tests%2Fcompile-fail%2Fenum_variants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3397afacbedaf8c8c8d8928b7c146ed000d3a2c/tests%2Fcompile-fail%2Fenum_variants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fenum_variants.rs?ref=f3397afacbedaf8c8c8d8928b7c146ed000d3a2c", "patch": "@@ -11,7 +11,8 @@ enum FakeCallType2 {\n }\n \n enum Foo {\n-    cFoo, cBar,\n+    cFoo, //~ ERROR: Variant name ends with the enum's name\n+    cBar,\n }\n \n enum BadCallType { //~ ERROR: All variants have the same prefix: `CallType`\n@@ -68,4 +69,12 @@ enum NonCaps { //~ ERROR: All variants have the same prefix: `Prefix`\n     PrefixCake,\n }\n \n+enum Stuff {\n+    BadStuff, //~ ERROR: Variant name ends with the enum's name\n+}\n+\n+enum Food {\n+    FoodGood, //~ ERROR: Variant name starts with the enum's name\n+}\n+\n fn main() {}"}]}