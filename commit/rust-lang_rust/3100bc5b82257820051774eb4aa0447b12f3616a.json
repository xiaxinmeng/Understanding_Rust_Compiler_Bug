{"sha": "3100bc5b82257820051774eb4aa0447b12f3616a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMxMDBiYzViODIyNTc4MjAwNTE3NzRlYjRhYTA0NDdiMTJmMzYxNmE=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-05-24T18:56:38Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-05-25T20:26:46Z"}, "message": "rustdoc: Move inlining to its own module", "tree": {"sha": "73e95db17bd57c0f2f6df19d336cfaa6323ce256", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/73e95db17bd57c0f2f6df19d336cfaa6323ce256"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3100bc5b82257820051774eb4aa0447b12f3616a", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3100bc5b82257820051774eb4aa0447b12f3616a", "html_url": "https://github.com/rust-lang/rust/commit/3100bc5b82257820051774eb4aa0447b12f3616a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3100bc5b82257820051774eb4aa0447b12f3616a/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bd339ced3615c89d439b33f6d6ab7bd04c002f74", "url": "https://api.github.com/repos/rust-lang/rust/commits/bd339ced3615c89d439b33f6d6ab7bd04c002f74", "html_url": "https://github.com/rust-lang/rust/commit/bd339ced3615c89d439b33f6d6ab7bd04c002f74"}], "stats": {"total": 758, "additions": 406, "deletions": 352}, "files": [{"sha": "1034c776ea6dd59137c305e66e84bc79f9e064fa", "filename": "src/doc/rustdoc.md", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3100bc5b82257820051774eb4aa0447b12f3616a/src%2Fdoc%2Frustdoc.md", "raw_url": "https://github.com/rust-lang/rust/raw/3100bc5b82257820051774eb4aa0447b12f3616a/src%2Fdoc%2Frustdoc.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustdoc.md?ref=3100bc5b82257820051774eb4aa0447b12f3616a", "patch": "@@ -41,7 +41,9 @@ pub fn recalibrate() {\n # }\n ~~~\n \n-Documentation can also be controlled via the `doc` attribute on items.\n+Documentation can also be controlled via the `doc` attribute on items. This is\n+implicitly done by the compiler when using the above form of doc comments\n+(converting the slash-based comments to `#[doc]` attributes).\n \n ~~~\n #[doc = \"\n@@ -50,6 +52,7 @@ Calculates the factorial of a number.\n Given the input integer `n`, this function will calculate `n!` and return it.\n \"]\n pub fn factorial(n: int) -> int { if n < 2 {1} else {n * factorial(n)} }\n+# fn main() {}\n ~~~\n \n The `doc` attribute can also be used to control how rustdoc emits documentation\n@@ -60,6 +63,7 @@ in some cases.\n // `pub use` reaches across crates, but this behavior can also be disabled.\n #[doc(no_inline)]\n pub use std::option::Option;\n+# fn main() {}\n ```\n \n Doc comments are markdown, and are currently parsed with the"}, {"sha": "d407cc046807b650973bf726bea468ee8f50b720", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3100bc5b82257820051774eb4aa0447b12f3616a/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3100bc5b82257820051774eb4aa0447b12f3616a/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=3100bc5b82257820051774eb4aa0447b12f3616a", "patch": "@@ -308,7 +308,7 @@ pub fn get_missing_lang_items(cstore: &cstore::CStore, cnum: ast::CrateNum)\n }\n \n pub fn get_method_arg_names(cstore: &cstore::CStore, did: ast::DefId)\n-    -> Vec<StrBuf>\n+    -> Vec<String>\n {\n     let cdata = cstore.get_crate_data(did.krate);\n     decoder::get_method_arg_names(&*cdata, did.node)"}, {"sha": "e8be05feae80630af665fd359c974c59d7543165", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3100bc5b82257820051774eb4aa0447b12f3616a/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3100bc5b82257820051774eb4aa0447b12f3616a/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=3100bc5b82257820051774eb4aa0447b12f3616a", "patch": "@@ -1310,7 +1310,7 @@ pub fn get_missing_lang_items(cdata: Cmd)\n     return result;\n }\n \n-pub fn get_method_arg_names(cdata: Cmd, id: ast::NodeId) -> Vec<StrBuf> {\n+pub fn get_method_arg_names(cdata: Cmd, id: ast::NodeId) -> Vec<String> {\n     let mut ret = Vec::new();\n     let method_doc = lookup_item(id, cdata.data());\n     match reader::maybe_get_doc(method_doc, tag_method_argument_names) {"}, {"sha": "dd5fddca0db8a02da915808534507fab1766c2cf", "filename": "src/librustdoc/clean/inline.rs", "status": "added", "additions": 278, "deletions": 0, "changes": 278, "blob_url": "https://github.com/rust-lang/rust/blob/3100bc5b82257820051774eb4aa0447b12f3616a/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3100bc5b82257820051774eb4aa0447b12f3616a/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=3100bc5b82257820051774eb4aa0447b12f3616a", "patch": "@@ -0,0 +1,278 @@\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Support for inlining external documentation into the current AST.\n+\n+use syntax::ast;\n+use syntax::ast_util;\n+use syntax::attr::AttrMetaMethods;\n+\n+use rustc::metadata::csearch;\n+use rustc::metadata::decoder;\n+use rustc::middle::ty;\n+\n+use core;\n+use doctree;\n+use clean;\n+\n+use super::Clean;\n+\n+/// Attempt to inline the definition of a local node id into this AST.\n+///\n+/// This function will fetch the definition of the id specified, and if it is\n+/// from another crate it will attempt to inline the documentation from the\n+/// other crate into this crate.\n+///\n+/// This is primarily used for `pub use` statements which are, in general,\n+/// implementation details. Inlining the documentation should help provide a\n+/// better experience when reading the documentation in this use case.\n+///\n+/// The returned value is `None` if the `id` could not be inlined, and `Some`\n+/// of a vector of items if it was successfully expanded.\n+pub fn try_inline(id: ast::NodeId) -> Option<Vec<clean::Item>> {\n+    let cx = ::ctxtkey.get().unwrap();\n+    let tcx = match cx.maybe_typed {\n+        core::Typed(ref tycx) => tycx,\n+        core::NotTyped(_) => return None,\n+    };\n+    let def = match tcx.def_map.borrow().find(&id) {\n+        Some(def) => *def,\n+        None => return None,\n+    };\n+    let did = ast_util::def_id_of_def(def);\n+    if ast_util::is_local(did) { return None }\n+    try_inline_def(&**cx, tcx, def)\n+}\n+\n+fn try_inline_def(cx: &core::DocContext,\n+                  tcx: &ty::ctxt,\n+                  def: ast::Def) -> Option<Vec<clean::Item>> {\n+    let mut ret = Vec::new();\n+    let did = ast_util::def_id_of_def(def);\n+    let inner = match def {\n+        ast::DefTrait(did) => {\n+            record_extern_fqn(cx, did, clean::TypeTrait);\n+            clean::TraitItem(build_external_trait(tcx, did))\n+        }\n+        ast::DefFn(did, style) => {\n+            record_extern_fqn(cx, did, clean::TypeFunction);\n+            clean::FunctionItem(build_external_function(tcx, did, style))\n+        }\n+        ast::DefStruct(did) => {\n+            record_extern_fqn(cx, did, clean::TypeStruct);\n+            ret.extend(build_impls(tcx, did).move_iter());\n+            clean::StructItem(build_struct(tcx, did))\n+        }\n+        ast::DefTy(did) => {\n+            record_extern_fqn(cx, did, clean::TypeEnum);\n+            ret.extend(build_impls(tcx, did).move_iter());\n+            build_type(tcx, did)\n+        }\n+        // Assume that the enum type is reexported next to the variant, and\n+        // variants don't show up in documentation specially.\n+        ast::DefVariant(..) => return Some(Vec::new()),\n+        ast::DefMod(did) => {\n+            record_extern_fqn(cx, did, clean::TypeModule);\n+            clean::ModuleItem(build_module(cx, tcx, did))\n+        }\n+        _ => return None,\n+    };\n+    let fqn = csearch::get_item_path(tcx, did);\n+    ret.push(clean::Item {\n+        source: clean::Span::empty(),\n+        name: Some(fqn.last().unwrap().to_str().to_strbuf()),\n+        attrs: load_attrs(tcx, did),\n+        inner: inner,\n+        visibility: Some(ast::Public),\n+        def_id: did,\n+    });\n+    Some(ret)\n+}\n+\n+pub fn load_attrs(tcx: &ty::ctxt, did: ast::DefId) -> Vec<clean::Attribute> {\n+    let mut attrs = Vec::new();\n+    csearch::get_item_attrs(&tcx.sess.cstore, did, |v| {\n+        attrs.extend(v.move_iter().map(|mut a| {\n+            // FIXME this isn't quite always true, it's just true about 99% of\n+            //       the time when dealing with documentation. For example,\n+            //       this would treat doc comments of the form `#[doc = \"foo\"]`\n+            //       incorrectly.\n+            if a.name().get() == \"doc\" && a.value_str().is_some() {\n+                a.node.is_sugared_doc = true;\n+            }\n+            a.clean()\n+        }));\n+    });\n+    attrs\n+}\n+\n+/// Record an external fully qualified name in the external_paths cache.\n+///\n+/// These names are used later on by HTML rendering to generate things like\n+/// source links back to the original item.\n+pub fn record_extern_fqn(cx: &core::DocContext,\n+                         did: ast::DefId,\n+                         kind: clean::TypeKind) {\n+    match cx.maybe_typed {\n+        core::Typed(ref tcx) => {\n+            let fqn = csearch::get_item_path(tcx, did);\n+            let fqn = fqn.move_iter().map(|i| i.to_str().to_strbuf()).collect();\n+            cx.external_paths.borrow_mut().get_mut_ref().insert(did, (fqn, kind));\n+        }\n+        core::NotTyped(..) => {}\n+    }\n+}\n+\n+pub fn build_external_trait(tcx: &ty::ctxt, did: ast::DefId) -> clean::Trait {\n+    let def = ty::lookup_trait_def(tcx, did);\n+    let methods = ty::trait_methods(tcx, did);\n+    clean::Trait {\n+        generics: def.generics.clean(),\n+        methods: methods.iter().map(|i| i.clean()).collect(),\n+        parents: Vec::new(), // FIXME: this is likely wrong\n+    }\n+}\n+\n+fn build_external_function(tcx: &ty::ctxt,\n+                           did: ast::DefId,\n+                           style: ast::FnStyle) -> clean::Function {\n+    let t = ty::lookup_item_type(tcx, did);\n+    clean::Function {\n+        decl: match ty::get(t.ty).sty {\n+            ty::ty_bare_fn(ref f) => (did, &f.sig).clean(),\n+            _ => fail!(\"bad function\"),\n+        },\n+        generics: t.generics.clean(),\n+        fn_style: style,\n+    }\n+}\n+\n+fn build_struct(tcx: &ty::ctxt, did: ast::DefId) -> clean::Struct {\n+    use syntax::parse::token::special_idents::unnamed_field;\n+\n+    let t = ty::lookup_item_type(tcx, did);\n+    let fields = ty::lookup_struct_fields(tcx, did);\n+\n+    clean::Struct {\n+        struct_type: match fields.as_slice() {\n+            [] => doctree::Unit,\n+            [ref f] if f.name == unnamed_field.name => doctree::Newtype,\n+            [ref f, ..] if f.name == unnamed_field.name => doctree::Tuple,\n+            _ => doctree::Plain,\n+        },\n+        generics: t.generics.clean(),\n+        fields: fields.iter().map(|f| f.clean()).collect(),\n+        fields_stripped: false,\n+    }\n+}\n+\n+fn build_type(tcx: &ty::ctxt, did: ast::DefId) -> clean::ItemEnum {\n+    let t = ty::lookup_item_type(tcx, did);\n+    match ty::get(t.ty).sty {\n+        ty::ty_enum(edid, _) => {\n+            return clean::EnumItem(clean::Enum {\n+                generics: t.generics.clean(),\n+                variants_stripped: false,\n+                variants: ty::enum_variants(tcx, edid).clean(),\n+            })\n+        }\n+        _ => {}\n+    }\n+\n+    clean::TypedefItem(clean::Typedef {\n+        type_: t.ty.clean(),\n+        generics: t.generics.clean(),\n+    })\n+}\n+\n+fn build_impls(tcx: &ty::ctxt,\n+               did: ast::DefId) -> Vec<clean::Item> {\n+    ty::populate_implementations_for_type_if_necessary(tcx, did);\n+    let mut impls = Vec::new();\n+\n+    match tcx.inherent_impls.borrow().find(&did) {\n+        None => {}\n+        Some(i) => {\n+            impls.extend(i.borrow().iter().map(|&did| { build_impl(tcx, did) }));\n+        }\n+    }\n+\n+    impls\n+}\n+\n+fn build_impl(tcx: &ty::ctxt, did: ast::DefId) -> clean::Item {\n+    let associated_trait = csearch::get_impl_trait(tcx, did);\n+    let attrs = load_attrs(tcx, did);\n+    let ty = ty::lookup_item_type(tcx, did);\n+    let methods = csearch::get_impl_methods(&tcx.sess.cstore, did).iter().map(|did| {\n+        let mut item = match ty::method(tcx, *did).clean() {\n+            clean::Provided(item) => item,\n+            clean::Required(item) => item,\n+        };\n+        item.inner = match item.inner.clone() {\n+            clean::TyMethodItem(clean::TyMethod {\n+                fn_style, decl, self_, generics\n+            }) => {\n+                clean::MethodItem(clean::Method {\n+                    fn_style: fn_style,\n+                    decl: decl,\n+                    self_: self_,\n+                    generics: generics,\n+                })\n+            }\n+            _ => fail!(\"not a tymethod\"),\n+        };\n+        item\n+    }).collect();\n+    clean::Item {\n+        inner: clean::ImplItem(clean::Impl {\n+            derived: clean::detect_derived(attrs.as_slice()),\n+            trait_: associated_trait.clean().map(|bound| {\n+                match bound {\n+                    clean::TraitBound(ty) => ty,\n+                    clean::RegionBound => unreachable!(),\n+                }\n+            }),\n+            for_: ty.ty.clean(),\n+            generics: ty.generics.clean(),\n+            methods: methods,\n+        }),\n+        source: clean::Span::empty(),\n+        name: None,\n+        attrs: attrs,\n+        visibility: Some(ast::Inherited),\n+        def_id: did,\n+    }\n+}\n+\n+fn build_module(cx: &core::DocContext, tcx: &ty::ctxt,\n+                did: ast::DefId) -> clean::Module {\n+    let mut items = Vec::new();\n+\n+    // FIXME: this doesn't handle reexports inside the module itself.\n+    //        Should they be handled?\n+    csearch::each_child_of_item(&tcx.sess.cstore, did, |def, _, _| {\n+        match def {\n+            decoder::DlDef(def) => {\n+                match try_inline_def(cx, tcx, def) {\n+                    Some(i) => items.extend(i.move_iter()),\n+                    None => {}\n+                }\n+            }\n+            decoder::DlImpl(did) => items.push(build_impl(tcx, did)),\n+            decoder::DlField => fail!(\"unimplemented field\"),\n+        }\n+    });\n+\n+    clean::Module {\n+        items: items,\n+        is_crate: false,\n+    }\n+}"}, {"sha": "f0f6842642534ed3e098c2590d43f32ff903c896", "filename": "src/librustdoc/clean/mod.rs", "status": "renamed", "additions": 28, "deletions": 281, "changes": 309, "blob_url": "https://github.com/rust-lang/rust/blob/3100bc5b82257820051774eb4aa0447b12f3616a/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3100bc5b82257820051774eb4aa0447b12f3616a/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=3100bc5b82257820051774eb4aa0447b12f3616a", "patch": "@@ -37,6 +37,8 @@ use visit_ast;\n /// Increment this when the `Crate` and related structures change.\n pub static SCHEMA_VERSION: &'static str = \"0.8.2\";\n \n+mod inline;\n+\n pub trait Clean<T> {\n     fn clean(&self) -> T;\n }\n@@ -727,7 +729,7 @@ impl<'a> Clean<FnDecl> for (ast::DefId, &'a ty::FnSig) {\n         let cx = super::ctxtkey.get().unwrap();\n         let tcx = match cx.maybe_typed {\n             core::Typed(ref tcx) => tcx,\n-            core::NotTyped(_) => fail!(),\n+            core::NotTyped(_) => unreachable!(),\n         };\n         let (did, sig) = *self;\n         let mut names = if did.node != 0 {\n@@ -738,9 +740,6 @@ impl<'a> Clean<FnDecl> for (ast::DefId, &'a ty::FnSig) {\n         if names.peek().map(|s| s.as_slice()) == Some(\"self\") {\n             let _ = names.next();\n         }\n-        if did.node == 0 {\n-            let _ = names.len();\n-        }\n         FnDecl {\n             output: sig.output.clean(),\n             cf: Return,\n@@ -862,7 +861,7 @@ impl Clean<TraitMethod> for ty::Method {\n         let cx = super::ctxtkey.get().unwrap();\n         let tcx = match cx.maybe_typed {\n             core::Typed(ref tcx) => tcx,\n-            core::NotTyped(_) => fail!(),\n+            core::NotTyped(_) => unreachable!(),\n         };\n         let (self_, sig) = match self.explicit_self {\n             ast::SelfStatic => (ast::SelfStatic.clean(), self.fty.sig.clone()),\n@@ -890,7 +889,7 @@ impl Clean<TraitMethod> for ty::Method {\n             name: Some(self.ident.clean()),\n             visibility: Some(ast::Inherited),\n             def_id: self.def_id,\n-            attrs: load_attrs(tcx, self.def_id),\n+            attrs: inline::load_attrs(tcx, self.def_id),\n             source: Span::empty(),\n             inner: TyMethodItem(TyMethod {\n                 fn_style: self.fty.fn_style,\n@@ -1035,7 +1034,7 @@ impl Clean<Type> for ty::t {\n                 let cx = super::ctxtkey.get().unwrap();\n                 let tcx = match cx.maybe_typed {\n                     core::Typed(ref tycx) => tycx,\n-                    core::NotTyped(_) => fail!(),\n+                    core::NotTyped(_) => unreachable!(),\n                 };\n                 let fqn = csearch::get_item_path(tcx, did);\n                 let fqn: Vec<String> = fqn.move_iter().map(|i| {\n@@ -1110,12 +1109,12 @@ impl Clean<Item> for ty::field_ty {\n         let cx = super::ctxtkey.get().unwrap();\n         let tcx = match cx.maybe_typed {\n             core::Typed(ref tycx) => tycx,\n-            core::NotTyped(_) => fail!(),\n+            core::NotTyped(_) => unreachable!(),\n         };\n         let ty = ty::lookup_item_type(tcx, self.id);\n         Item {\n             name: name.clean(),\n-            attrs: load_attrs(tcx, self.id),\n+            attrs: inline::load_attrs(tcx, self.id),\n             source: Span::empty(),\n             visibility: Some(self.vis),\n             def_id: self.id,\n@@ -1245,7 +1244,11 @@ impl Clean<Item> for ty::VariantInfo {\n                             name: Some(name.clean()),\n                             attrs: Vec::new(),\n                             visibility: Some(ast::Public),\n-                            def_id: self.id, // FIXME: this is not accurate\n+                            // FIXME: this is not accurate, we need an id for\n+                            //        the specific field but we're using the id\n+                            //        for the whole variant. Nothing currently\n+                            //        uses this so we should be good for now.\n+                            def_id: self.id,\n                             inner: StructFieldItem(\n                                 TypedStructField(ty.clean())\n                             )\n@@ -1256,7 +1259,7 @@ impl Clean<Item> for ty::VariantInfo {\n         };\n         Item {\n             name: Some(self.name.clean()),\n-            attrs: load_attrs(tcx, self.id),\n+            attrs: inline::load_attrs(tcx, self.id),\n             source: Span::empty(),\n             visibility: Some(ast::Public),\n             def_id: self.id,\n@@ -1377,8 +1380,8 @@ impl Clean<String> for ast::Ident {\n     }\n }\n \n-impl Clean<StrBuf> for ast::Name {\n-    fn clean(&self) -> StrBuf {\n+impl Clean<String> for ast::Name {\n+    fn clean(&self) -> String {\n         token::get_name(*self).get().to_strbuf()\n     }\n }\n@@ -1480,9 +1483,7 @@ pub struct Impl {\n }\n \n fn detect_derived<M: AttrMetaMethods>(attrs: &[M]) -> bool {\n-    attrs.iter().any(|attr| {\n-        attr.name().get() == \"automatically_derived\"\n-    })\n+    attr::contains_name(attrs, \"automatically_derived\")\n }\n \n impl Clean<Item> for doctree::Impl {\n@@ -1511,9 +1512,12 @@ pub struct ViewItem {\n \n impl Clean<Vec<Item>> for ast::ViewItem {\n     fn clean(&self) -> Vec<Item> {\n+        // We consider inlining the documentation of `pub use` statments, but we\n+        // forcefully don't inline if this is not public or if the\n+        // #[doc(no_inline)] attribute is present.\n         let denied = self.vis != ast::Public || self.attrs.iter().any(|a| {\n             a.name().get() == \"doc\" && match a.meta_item_list() {\n-                Some(l) => attr::contains_name(l, \"noinline\"),\n+                Some(l) => attr::contains_name(l, \"no_inline\"),\n                 None => false,\n             }\n         });\n@@ -1533,8 +1537,11 @@ impl Clean<Vec<Item>> for ast::ViewItem {\n                 match path.node {\n                     ast::ViewPathGlob(..) => ret.push(convert(&self.node)),\n                     ast::ViewPathList(ref a, ref list, ref b) => {\n+                        // Attempt to inline all reexported items, but be sure\n+                        // to keep any non-inlineable reexports so they can be\n+                        // listed in the documentation.\n                         let remaining = list.iter().filter(|path| {\n-                            match try_inline(path.node.id) {\n+                            match inline::try_inline(path.node.id) {\n                                 Some(items) => {\n                                     ret.extend(items.move_iter()); false\n                                 }\n@@ -1550,7 +1557,7 @@ impl Clean<Vec<Item>> for ast::ViewItem {\n                         }\n                     }\n                     ast::ViewPathSimple(_, _, id) => {\n-                        match try_inline(id) {\n+                        match inline::try_inline(id) {\n                             Some(items) => ret.extend(items.move_iter()),\n                             None => ret.push(convert(&self.node)),\n                         }\n@@ -1563,82 +1570,6 @@ impl Clean<Vec<Item>> for ast::ViewItem {\n     }\n }\n \n-fn try_inline(id: ast::NodeId) -> Option<Vec<Item>> {\n-    let cx = super::ctxtkey.get().unwrap();\n-    let tcx = match cx.maybe_typed {\n-        core::Typed(ref tycx) => tycx,\n-        core::NotTyped(_) => return None,\n-    };\n-    let def = match tcx.def_map.borrow().find(&id) {\n-        Some(def) => *def,\n-        None => return None,\n-    };\n-    let did = ast_util::def_id_of_def(def);\n-    if ast_util::is_local(did) { return None }\n-    try_inline_def(&**cx, tcx, def)\n-}\n-\n-fn try_inline_def(cx: &core::DocContext,\n-                  tcx: &ty::ctxt,\n-                  def: ast::Def) -> Option<Vec<Item>> {\n-    let mut ret = Vec::new();\n-    let did = ast_util::def_id_of_def(def);\n-    let inner = match def {\n-        ast::DefTrait(did) => {\n-            record_extern_fqn(cx, did, TypeTrait);\n-            TraitItem(build_external_trait(tcx, did))\n-        }\n-        ast::DefFn(did, style) => {\n-            record_extern_fqn(cx, did, TypeFunction);\n-            FunctionItem(build_external_function(tcx, did, style))\n-        }\n-        ast::DefStruct(did) => {\n-            record_extern_fqn(cx, did, TypeStruct);\n-            ret.extend(build_impls(tcx, did).move_iter());\n-            StructItem(build_struct(tcx, did))\n-        }\n-        ast::DefTy(did) => {\n-            record_extern_fqn(cx, did, TypeEnum);\n-            ret.extend(build_impls(tcx, did).move_iter());\n-            build_type(tcx, did)\n-        }\n-        // Assume that the enum type is reexported next to the variant, and\n-        // variants don't show up in documentation specially.\n-        ast::DefVariant(..) => return Some(Vec::new()),\n-        ast::DefMod(did) => {\n-            record_extern_fqn(cx, did, TypeModule);\n-            ModuleItem(build_module(cx, tcx, did))\n-        }\n-        _ => return None,\n-    };\n-    let fqn = csearch::get_item_path(tcx, did);\n-    ret.push(Item {\n-        source: Span::empty(),\n-        name: Some(fqn.last().unwrap().to_str().to_strbuf()),\n-        attrs: load_attrs(tcx, did),\n-        inner: inner,\n-        visibility: Some(ast::Public),\n-        def_id: did,\n-    });\n-    Some(ret)\n-}\n-\n-fn load_attrs(tcx: &ty::ctxt, did: ast::DefId) -> Vec<Attribute> {\n-    let mut attrs = Vec::new();\n-    csearch::get_item_attrs(&tcx.sess.cstore, did, |v| {\n-        attrs.extend(v.move_iter().map(|item| {\n-            let mut a = attr::mk_attr_outer(item);\n-            // FIXME this isn't quite always true, it's just true about 99% of\n-            //       the time when dealing with documentation\n-            if a.name().get() == \"doc\" && a.value_str().is_some() {\n-                a.node.is_sugared_doc = true;\n-            }\n-            a.clean()\n-        }));\n-    });\n-    attrs\n-}\n-\n #[deriving(Clone, Encodable, Decodable)]\n pub enum ViewItemInner {\n     ExternCrate(String, Option<String>, ast::NodeId),\n@@ -1850,201 +1781,17 @@ fn register_def(cx: &core::DocContext, def: ast::Def) -> ast::DefId {\n         core::Typed(ref t) => t,\n         core::NotTyped(_) => return did\n     };\n-    record_extern_fqn(cx, did, kind);\n+    inline::record_extern_fqn(cx, did, kind);\n     match kind {\n         TypeTrait => {\n-            let t = build_external_trait(tcx, did);\n+            let t = inline::build_external_trait(tcx, did);\n             cx.external_traits.borrow_mut().get_mut_ref().insert(did, t);\n         }\n         _ => {}\n     }\n     return did;\n }\n \n-fn record_extern_fqn(cx: &core::DocContext,\n-                     did: ast::DefId,\n-                     kind: TypeKind) {\n-    match cx.maybe_typed {\n-        core::Typed(ref tcx) => {\n-            let fqn = csearch::get_item_path(tcx, did);\n-            let fqn = fqn.move_iter().map(|i| i.to_str().to_strbuf()).collect();\n-            cx.external_paths.borrow_mut().get_mut_ref().insert(did, (fqn, kind));\n-        }\n-        core::NotTyped(..) => {}\n-    }\n-}\n-\n-fn build_external_trait(tcx: &ty::ctxt, did: ast::DefId) -> Trait {\n-    let def = ty::lookup_trait_def(tcx, did);\n-    let methods = ty::trait_methods(tcx, did);\n-    Trait {\n-        generics: def.generics.clean(),\n-        methods: methods.iter().map(|i| i.clean()).collect(),\n-        parents: Vec::new(), // FIXME: this is likely wrong\n-    }\n-}\n-\n-fn build_external_function(tcx: &ty::ctxt,\n-                           did: ast::DefId,\n-                           style: ast::FnStyle) -> Function {\n-    let t = ty::lookup_item_type(tcx, did);\n-    Function {\n-        decl: match ty::get(t.ty).sty {\n-            ty::ty_bare_fn(ref f) => (did, &f.sig).clean(),\n-            _ => fail!(\"bad function\"),\n-        },\n-        generics: t.generics.clean(),\n-        fn_style: style,\n-    }\n-}\n-\n-fn build_struct(tcx: &ty::ctxt, did: ast::DefId) -> Struct {\n-    use syntax::parse::token::special_idents::unnamed_field;\n-\n-    let t = ty::lookup_item_type(tcx, did);\n-    let fields = ty::lookup_struct_fields(tcx, did);\n-\n-    Struct {\n-        struct_type: match fields.as_slice() {\n-            [] => doctree::Unit,\n-            [ref f] if f.name == unnamed_field.name => doctree::Newtype,\n-            [ref f, ..] if f.name == unnamed_field.name => doctree::Tuple,\n-            _ => doctree::Plain,\n-        },\n-        generics: t.generics.clean(),\n-        fields: fields.iter().map(|f| f.clean()).collect(),\n-        fields_stripped: false,\n-    }\n-}\n-\n-fn build_type(tcx: &ty::ctxt, did: ast::DefId) -> ItemEnum {\n-    let t = ty::lookup_item_type(tcx, did);\n-    match ty::get(t.ty).sty {\n-        ty::ty_enum(edid, _) => {\n-            return EnumItem(Enum {\n-                generics: t.generics.clean(),\n-                variants_stripped: false,\n-                variants: ty::enum_variants(tcx, edid).clean(),\n-            })\n-        }\n-        _ => {}\n-    }\n-\n-    TypedefItem(Typedef {\n-        type_: t.ty.clean(),\n-        generics: t.generics.clean(),\n-    })\n-}\n-\n-fn build_impls(tcx: &ty::ctxt,\n-               did: ast::DefId) -> Vec<Item> {\n-    ty::populate_implementations_for_type_if_necessary(tcx, did);\n-    let mut impls = Vec::new();\n-\n-    match tcx.inherent_impls.borrow().find(&did) {\n-        None => {}\n-        Some(i) => {\n-            impls.extend(i.borrow().iter().map(|&did| { build_impl(tcx, did) }));\n-        }\n-    }\n-\n-    // csearch::each_impl(&tcx.sess.cstore, did.krate, |imp| {\n-    //     // if imp.krate\n-    //     let t = ty::lookup_item_type(tcx, imp);\n-    //     println!(\"{}\", ::rustc::util::ppaux::ty_to_str(tcx, t.ty));\n-    //     match ty::get(t.ty).sty {\n-    //         ty::ty_struct(tdid, _) |\n-    //         ty::ty_enum(tdid, _) if tdid == did => {\n-    //             impls.push(build_impl(tcx, imp));\n-    //         }\n-    //         _ => {}\n-    //     }\n-    // });\n-    // for (k, v) in tcx.trait_impls.borrow().iter() {\n-    //     if k.krate != did.krate { continue }\n-    //     for imp in v.borrow().iter() {\n-    //         if imp.krate != did.krate { continue }\n-    //         let t = ty::lookup_item_type(tcx, *imp);\n-    //         println!(\"{}\", ::rustc::util::ppaux::ty_to_str(tcx, t.ty));\n-    //         match ty::get(t.ty).sty {\n-    //             ty::ty_struct(tdid, _) |\n-    //             ty::ty_enum(tdid, _) if tdid == did => {\n-    //                 impls.push(build_impl(tcx, *imp));\n-    //             }\n-    //             _ => {}\n-    //         }\n-    //     }\n-    // }\n-\n-    impls\n-}\n-\n-fn build_impl(tcx: &ty::ctxt, did: ast::DefId) -> Item {\n-    let associated_trait = csearch::get_impl_trait(tcx, did);\n-    let attrs = load_attrs(tcx, did);\n-    let ty = ty::lookup_item_type(tcx, did);\n-    let methods = csearch::get_impl_methods(&tcx.sess.cstore, did).iter().map(|did| {\n-        let mut item = match ty::method(tcx, *did).clean() {\n-            Provided(item) => item,\n-            Required(item) => item,\n-        };\n-        item.inner = match item.inner.clone() {\n-            TyMethodItem(TyMethod { fn_style, decl, self_, generics }) => {\n-                MethodItem(Method {\n-                    fn_style: fn_style,\n-                    decl: decl,\n-                    self_: self_,\n-                    generics: generics,\n-                })\n-            }\n-            _ => fail!(\"not a tymethod\"),\n-        };\n-        item\n-    }).collect();\n-    Item {\n-        inner: ImplItem(Impl {\n-            derived: detect_derived(attrs.as_slice()),\n-            trait_: associated_trait.clean().map(|bound| {\n-                match bound {\n-                    TraitBound(ty) => ty,\n-                    RegionBound => fail!(),\n-                }\n-            }),\n-            for_: ty.ty.clean(),\n-            generics: ty.generics.clean(),\n-            methods: methods,\n-        }),\n-        source: Span::empty(),\n-        name: None,\n-        attrs: attrs,\n-        visibility: Some(ast::Inherited),\n-        def_id: did,\n-    }\n-}\n-\n-fn build_module(cx: &core::DocContext, tcx: &ty::ctxt,\n-                did: ast::DefId) -> Module {\n-    let mut items = Vec::new();\n-\n-    csearch::each_child_of_item(&tcx.sess.cstore, did, |def, _, _| {\n-        match def {\n-            decoder::DlDef(def) => {\n-                match try_inline_def(cx, tcx, def) {\n-                    Some(i) => items.extend(i.move_iter()),\n-                    None => {}\n-                }\n-            }\n-            decoder::DlImpl(did) => items.push(build_impl(tcx, did)),\n-            decoder::DlField => fail!(\"unimplemented field\"),\n-        }\n-    });\n-\n-    Module {\n-        items: items,\n-        is_crate: false,\n-    }\n-}\n-\n fn resolve_use_source(path: Path, id: ast::NodeId) -> ImportSource {\n     ImportSource {\n         path: path,", "previous_filename": "src/librustdoc/clean.rs"}, {"sha": "d601d2ae957feb5563a7d1cdd828fce5d0f629cc", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 34, "deletions": 5, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/3100bc5b82257820051774eb4aa0447b12f3616a/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3100bc5b82257820051774eb4aa0447b12f3616a/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=3100bc5b82257820051774eb4aa0447b12f3616a", "patch": "@@ -143,7 +143,7 @@ pub struct Cache {\n \n     /// Similar to `paths`, but only holds external paths. This is only used for\n     /// generating explicit hyperlinks to other crates.\n-    pub external_paths: HashMap<ast::DefId, Vec<StrBuf>>,\n+    pub external_paths: HashMap<ast::DefId, Vec<String>>,\n \n     /// This map contains information about all known traits of this crate.\n     /// Implementations of a crate should inherit the documentation of the\n@@ -253,7 +253,7 @@ pub fn run(mut krate: clean::Crate, dst: Path) -> io::IoResult<()> {\n     let analysis = ::analysiskey.get();\n     let public_items = analysis.as_ref().map(|a| a.public_items.clone());\n     let public_items = public_items.unwrap_or(NodeSet::new());\n-    let paths: HashMap<ast::DefId, (Vec<StrBuf>, ItemType)> =\n+    let paths: HashMap<ast::DefId, (Vec<String>, ItemType)> =\n       analysis.as_ref().map(|a| {\n         let paths = a.external_paths.borrow_mut().take_unwrap();\n         paths.move_iter().map(|(k, (v, t))| {\n@@ -1041,7 +1041,19 @@ impl<'a> Item<'a> {\n         }\n     }\n \n-    fn link(&self) -> Option<String> {\n+    /// Generate a url appropriate for an `href` attribute back to the source of\n+    /// this item.\n+    ///\n+    /// The url generated, when clicked, will redirect the browser back to the\n+    /// original source code.\n+    ///\n+    /// If `None` is returned, then a source link couldn't be generated. This\n+    /// may happen, for example, with externally inlined items where the source\n+    /// of their crate documentation isn't known.\n+    fn href(&self) -> Option<String> {\n+        // If this item is part of the local crate, then we're guaranteed to\n+        // know the span, so we plow forward and generate a proper url. The url\n+        // has anchors for the line numbers that we're linking to.\n         if ast_util::is_local(self.item.def_id) {\n             let mut path = Vec::new();\n             clean_srcpath(self.item.source.filename.as_bytes(), |component| {\n@@ -1059,6 +1071,18 @@ impl<'a> Item<'a> {\n                          krate = self.cx.layout.krate,\n                          path = path.connect(\"/\"),\n                          href = href))\n+\n+        // If this item is not part of the local crate, then things get a little\n+        // trickier. We don't actually know the span of the external item, but\n+        // we know that the documentation on the other end knows the span!\n+        //\n+        // In this case, we generate a link to the *documentation* for this type\n+        // in the original crate. There's an extra URL parameter which says that\n+        // we want to go somewhere else, and the JS on the destination page will\n+        // pick it up and instantly redirect the browser to the source code.\n+        //\n+        // If we don't know where the external documentation for this crate is\n+        // located, then we return `None`.\n         } else {\n             let cache = cache_key.get().unwrap();\n             let path = cache.external_paths.get(&self.item.def_id);\n@@ -1120,8 +1144,13 @@ impl<'a> fmt::Show for Item<'a> {\n         }\n \n         // Write `src` tag\n+        //\n+        // When this item is part of a `pub use` in a downstream crate, the\n+        // [src] link in the downstream documentation will actually come back to\n+        // this page, and this link will be auto-clicked. The `id` attribute is\n+        // used to find the link to auto-click.\n         if self.cx.include_sources {\n-            match self.link() {\n+            match self.href() {\n                 Some(l) => {\n                     try!(write!(fmt,\n                                 \"<a class='source' id='src-{}' \\\n@@ -1288,7 +1317,7 @@ fn item_module(w: &mut fmt::Formatter, cx: &Context,\n                         try!(write!(f, \"<code> = </code>\"));\n                         if s.contains(\"\\n\") {\n                             write!(f, \"<a href='{}'>[definition]</a>\",\n-                                   item.link())\n+                                   item.href())\n                         } else {\n                             write!(f, \"<code>{}</code>\", s.as_slice())\n                         }"}, {"sha": "2fb824653d3dbd4df42bbe7bf82d4939479f6278", "filename": "src/librustdoc/html/static/main.js", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3100bc5b82257820051774eb4aa0447b12f3616a/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/3100bc5b82257820051774eb4aa0447b12f3616a/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js?ref=3100bc5b82257820051774eb4aa0447b12f3616a", "patch": "@@ -676,13 +676,9 @@\n         window.register_implementors(window.pending_implementors);\n     }\n \n-\n-    var query = window.location.search.substring(1);\n-    var vars = query.split('&');\n-    for (var i = 0; i < vars.length; i++) {\n-        var pair = vars[i].split('=');\n-        if (pair[0] == 'gotosrc') {\n-            window.location = $('#src-' + pair[1]).attr('href');\n-        }\n+    // See documentaiton in html/render.rs for what this is doing.\n+    var query = getQueryStringParams();\n+    if (query['gotosrc']) {\n+        window.location = $('#src-' + query['gotosrc']).attr('href');\n     }\n }());"}, {"sha": "1786cc8062e214181d21224cf662403aba23e95c", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3100bc5b82257820051774eb4aa0447b12f3616a/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3100bc5b82257820051774eb4aa0447b12f3616a/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=3100bc5b82257820051774eb4aa0447b12f3616a", "patch": "@@ -16,10 +16,10 @@\n //!\n //! ## Intrinsic types and operations\n //!\n-//! The [`ptr`](../core/ptr/index.html) and [`mem`](../core/mem/index.html)\n+//! The [`ptr`](ptr/index.html) and [`mem`](mem/index.html)\n //! modules deal with unsafe pointers and memory manipulation.\n-//! [`kinds`](../core/kinds/index.html) defines the special built-in traits,\n-//! and [`raw`](../core/raw/index.html) the runtime representation of Rust types.\n+//! [`kinds`](kinds/index.html) defines the special built-in traits,\n+//! and [`raw`](raw/index.html) the runtime representation of Rust types.\n //! These are some of the lowest-level building blocks in Rust.\n //!\n //! ## Math on primitive types and math traits\n@@ -31,11 +31,11 @@\n //!\n //! ## Pervasive types\n //!\n-//! The [`option`](option/index.html) and [`result`](../core/result/index.html)\n+//! The [`option`](option/index.html) and [`result`](result/index.html)\n //! modules define optional and error-handling types, `Option` and `Result`.\n-//! [`iter`](../core/iter/index.html) defines Rust's iterator protocol\n+//! [`iter`](iter/index.html) defines Rust's iterator protocol\n //! along with a wide variety of iterators.\n-//! [`Cell` and `RefCell`](../core/cell/index.html) are for creating types that\n+//! [`Cell` and `RefCell`](cell/index.html) are for creating types that\n //! manage their own mutability.\n //!\n //! ## Vectors, slices and strings"}, {"sha": "07aaeac64be1c811caa19284bc1e3add7e91d839", "filename": "src/libstd/prelude.rs", "status": "modified", "additions": 49, "deletions": 49, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/3100bc5b82257820051774eb4aa0447b12f3616a/src%2Flibstd%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3100bc5b82257820051774eb4aa0447b12f3616a/src%2Flibstd%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude.rs?ref=3100bc5b82257820051774eb4aa0447b12f3616a", "patch": "@@ -38,62 +38,62 @@\n //! `drop`, `spawn`, and `channel`.\n \n // Reexported core operators\n-#[doc(noinline)] pub use kinds::{Copy, Send, Sized, Share};\n-#[doc(noinline)] pub use ops::{Add, Sub, Mul, Div, Rem, Neg, Not};\n-#[doc(noinline)] pub use ops::{BitAnd, BitOr, BitXor};\n-#[doc(noinline)] pub use ops::{Drop, Deref, DerefMut};\n-#[doc(noinline)] pub use ops::{Shl, Shr, Index};\n-#[doc(noinline)] pub use option::{Option, Some, None};\n-#[doc(noinline)] pub use result::{Result, Ok, Err};\n+#[doc(no_inline)] pub use kinds::{Copy, Send, Sized, Share};\n+#[doc(no_inline)] pub use ops::{Add, Sub, Mul, Div, Rem, Neg, Not};\n+#[doc(no_inline)] pub use ops::{BitAnd, BitOr, BitXor};\n+#[doc(no_inline)] pub use ops::{Drop, Deref, DerefMut};\n+#[doc(no_inline)] pub use ops::{Shl, Shr, Index};\n+#[doc(no_inline)] pub use option::{Option, Some, None};\n+#[doc(no_inline)] pub use result::{Result, Ok, Err};\n \n // Reexported functions\n-#[doc(noinline)] pub use from_str::from_str;\n-#[doc(noinline)] pub use iter::range;\n-#[doc(noinline)] pub use mem::drop;\n+#[doc(no_inline)] pub use from_str::from_str;\n+#[doc(no_inline)] pub use iter::range;\n+#[doc(no_inline)] pub use mem::drop;\n \n // Reexported types and traits\n \n-#[doc(noinline)] pub use ascii::{Ascii, AsciiCast, OwnedAsciiCast, AsciiStr};\n-#[doc(noinline)] pub use ascii::IntoBytes;\n-#[doc(noinline)] pub use c_str::ToCStr;\n-#[doc(noinline)] pub use char::Char;\n-#[doc(noinline)] pub use clone::Clone;\n-#[doc(noinline)] pub use cmp::{Eq, Ord, TotalEq, TotalOrd};\n-#[doc(noinline)] pub use cmp::{Ordering, Less, Equal, Greater, Equiv};\n-#[doc(noinline)] pub use container::{Container, Mutable, Map, MutableMap};\n-#[doc(noinline)] pub use container::{Set, MutableSet};\n-#[doc(noinline)] pub use iter::{FromIterator, Extendable, ExactSize};\n-#[doc(noinline)] pub use iter::{Iterator, DoubleEndedIterator};\n-#[doc(noinline)] pub use iter::{RandomAccessIterator, CloneableIterator};\n-#[doc(noinline)] pub use iter::{OrdIterator, MutableDoubleEndedIterator};\n-#[doc(noinline)] pub use num::{Num, NumCast, CheckedAdd, CheckedSub, CheckedMul};\n-#[doc(noinline)] pub use num::{Signed, Unsigned, Primitive, Int, Float};\n-#[doc(noinline)] pub use num::{FloatMath, ToPrimitive, FromPrimitive};\n-#[doc(noinline)] pub use option::Expect;\n-#[doc(noinline)] pub use owned::Box;\n-#[doc(noinline)] pub use path::{GenericPath, Path, PosixPath, WindowsPath};\n-#[doc(noinline)] pub use ptr::RawPtr;\n-#[doc(noinline)] pub use io::{Buffer, Writer, Reader, Seek};\n-#[doc(noinline)] pub use str::{Str, StrVector, StrSlice, OwnedStr};\n-#[doc(noinline)] pub use str::{IntoMaybeOwned, StrAllocating};\n-#[doc(noinline)] pub use to_str::{ToStr, IntoStr};\n-#[doc(noinline)] pub use tuple::{Tuple1, Tuple2, Tuple3, Tuple4};\n-#[doc(noinline)] pub use tuple::{Tuple5, Tuple6, Tuple7, Tuple8};\n-#[doc(noinline)] pub use tuple::{Tuple9, Tuple10, Tuple11, Tuple12};\n-#[doc(noinline)] pub use slice::{CloneableVector, ImmutableCloneableVector};\n-#[doc(noinline)] pub use slice::{MutableCloneableVector, MutableTotalOrdVector};\n-#[doc(noinline)] pub use slice::{ImmutableVector, MutableVector};\n-#[doc(noinline)] pub use slice::{ImmutableEqVector, ImmutableTotalOrdVector};\n-#[doc(noinline)] pub use slice::{Vector, VectorVector, OwnedVector};\n-#[doc(noinline)] pub use slice::MutableVectorAllocating;\n-#[doc(noinline)] pub use string::String;\n-#[doc(noinline)] pub use vec::Vec;\n+#[doc(no_inline)] pub use ascii::{Ascii, AsciiCast, OwnedAsciiCast, AsciiStr};\n+#[doc(no_inline)] pub use ascii::IntoBytes;\n+#[doc(no_inline)] pub use c_str::ToCStr;\n+#[doc(no_inline)] pub use char::Char;\n+#[doc(no_inline)] pub use clone::Clone;\n+#[doc(no_inline)] pub use cmp::{Eq, Ord, TotalEq, TotalOrd};\n+#[doc(no_inline)] pub use cmp::{Ordering, Less, Equal, Greater, Equiv};\n+#[doc(no_inline)] pub use container::{Container, Mutable, Map, MutableMap};\n+#[doc(no_inline)] pub use container::{Set, MutableSet};\n+#[doc(no_inline)] pub use iter::{FromIterator, Extendable, ExactSize};\n+#[doc(no_inline)] pub use iter::{Iterator, DoubleEndedIterator};\n+#[doc(no_inline)] pub use iter::{RandomAccessIterator, CloneableIterator};\n+#[doc(no_inline)] pub use iter::{OrdIterator, MutableDoubleEndedIterator};\n+#[doc(no_inline)] pub use num::{Num, NumCast, CheckedAdd, CheckedSub, CheckedMul};\n+#[doc(no_inline)] pub use num::{Signed, Unsigned, Primitive, Int, Float};\n+#[doc(no_inline)] pub use num::{FloatMath, ToPrimitive, FromPrimitive};\n+#[doc(no_inline)] pub use option::Expect;\n+#[doc(no_inline)] pub use owned::Box;\n+#[doc(no_inline)] pub use path::{GenericPath, Path, PosixPath, WindowsPath};\n+#[doc(no_inline)] pub use ptr::RawPtr;\n+#[doc(no_inline)] pub use io::{Buffer, Writer, Reader, Seek};\n+#[doc(no_inline)] pub use str::{Str, StrVector, StrSlice, OwnedStr};\n+#[doc(no_inline)] pub use str::{IntoMaybeOwned, StrAllocating};\n+#[doc(no_inline)] pub use to_str::{ToStr, IntoStr};\n+#[doc(no_inline)] pub use tuple::{Tuple1, Tuple2, Tuple3, Tuple4};\n+#[doc(no_inline)] pub use tuple::{Tuple5, Tuple6, Tuple7, Tuple8};\n+#[doc(no_inline)] pub use tuple::{Tuple9, Tuple10, Tuple11, Tuple12};\n+#[doc(no_inline)] pub use slice::{CloneableVector, ImmutableCloneableVector};\n+#[doc(no_inline)] pub use slice::{MutableCloneableVector, MutableTotalOrdVector};\n+#[doc(no_inline)] pub use slice::{ImmutableVector, MutableVector};\n+#[doc(no_inline)] pub use slice::{ImmutableEqVector, ImmutableTotalOrdVector};\n+#[doc(no_inline)] pub use slice::{Vector, VectorVector, OwnedVector};\n+#[doc(no_inline)] pub use slice::MutableVectorAllocating;\n+#[doc(no_inline)] pub use string::String;\n+#[doc(no_inline)] pub use vec::Vec;\n \n // Reexported runtime types\n-#[doc(noinline)] pub use comm::{sync_channel, channel};\n-#[doc(noinline)] pub use comm::{SyncSender, Sender, Receiver};\n-#[doc(noinline)] pub use task::spawn;\n+#[doc(no_inline)] pub use comm::{sync_channel, channel};\n+#[doc(no_inline)] pub use comm::{SyncSender, Sender, Receiver};\n+#[doc(no_inline)] pub use task::spawn;\n \n // Reexported statics\n #[cfg(not(test))]\n-#[doc(noinline)] pub use gc::GC;\n+#[doc(no_inline)] pub use gc::GC;"}]}