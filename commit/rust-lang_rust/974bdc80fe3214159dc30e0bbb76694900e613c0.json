{"sha": "974bdc80fe3214159dc30e0bbb76694900e613c0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk3NGJkYzgwZmUzMjE0MTU5ZGMzMGUwYmJiNzY2OTQ5MDBlNjEzYzA=", "commit": {"author": {"name": "Without Boats", "email": "boats@mozilla.com", "date": "2018-09-01T04:12:10Z"}, "committer": {"name": "Without Boats", "email": "boats@mozilla.com", "date": "2018-09-01T04:57:58Z"}, "message": "Update to a new pinning API.", "tree": {"sha": "a4ce3c775b9c740ffffb0d7609fe14520fe1ec94", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a4ce3c775b9c740ffffb0d7609fe14520fe1ec94"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/974bdc80fe3214159dc30e0bbb76694900e613c0", "comment_count": 0, "verification": {"verified": false, "reason": "no_user", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQB1BAAWCAAdFiEEcsU1MS52w+AyCfaTF0Yl5eh3wNkFAluKHFcACgkQF0Yl5eh3wNlLfwEA0URD\nSNfFg7sersdfgt0l4YaRLXAnEh6zvRXkyQCZKLIBAO5QYVtUeHzwd0+qPWeyupwcgM7BzzLZzRx8\n078+Il4A\n=fttz\n-----END PGP SIGNATURE-----\n", "payload": "tree a4ce3c775b9c740ffffb0d7609fe14520fe1ec94\nparent e6b35b0e1115f008796e8313574e4a4739b6d39d\nauthor Without Boats <boats@mozilla.com> 1535775130 +0200\ncommitter Without Boats <boats@mozilla.com> 1535777878 +0200\n\nUpdate to a new pinning API.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/974bdc80fe3214159dc30e0bbb76694900e613c0", "html_url": "https://github.com/rust-lang/rust/commit/974bdc80fe3214159dc30e0bbb76694900e613c0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/974bdc80fe3214159dc30e0bbb76694900e613c0/comments", "author": null, "committer": null, "parents": [{"sha": "e6b35b0e1115f008796e8313574e4a4739b6d39d", "url": "https://api.github.com/repos/rust-lang/rust/commits/e6b35b0e1115f008796e8313574e4a4739b6d39d", "html_url": "https://github.com/rust-lang/rust/commit/e6b35b0e1115f008796e8313574e4a4739b6d39d"}], "stats": {"total": 729, "additions": 309, "deletions": 420}, "files": [{"sha": "fce6417186fc6816739631fcb7e9baeb9c8befe4", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 28, "deletions": 10, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/974bdc80fe3214159dc30e0bbb76694900e613c0/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/974bdc80fe3214159dc30e0bbb76694900e613c0/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=974bdc80fe3214159dc30e0bbb76694900e613c0", "patch": "@@ -65,13 +65,12 @@ use core::hash::{Hash, Hasher};\n use core::iter::FusedIterator;\n use core::marker::{Unpin, Unsize};\n use core::mem;\n-use core::pin::PinMut;\n+use core::pin::Pin;\n use core::ops::{CoerceUnsized, Deref, DerefMut, Generator, GeneratorState};\n use core::ptr::{self, NonNull, Unique};\n use core::task::{Context, Poll, Spawn, SpawnErrorKind, SpawnObjError};\n \n use raw_vec::RawVec;\n-use pin::PinBox;\n use str::from_boxed_utf8_unchecked;\n \n /// A pointer type for heap allocation.\n@@ -97,6 +96,11 @@ impl<T> Box<T> {\n     pub fn new(x: T) -> Box<T> {\n         box x\n     }\n+\n+    #[unstable(feature = \"pin\", issue = \"49150\")]\n+    pub fn pinned(x: T) -> Pin<Box<T>> {\n+        unsafe { Pin::new_unchecked(box x) }\n+    }\n }\n \n impl<T: ?Sized> Box<T> {\n@@ -427,6 +431,13 @@ impl<T> From<T> for Box<T> {\n     }\n }\n \n+#[unstable(feature = \"pin\", issue = \"49150\")]\n+impl<T> From<Box<T>> for Pin<Box<T>> {\n+    fn from(boxed: Box<T>) -> Self {\n+        unsafe { Pin::new_unchecked(boxed) }\n+    }\n+}\n+\n #[stable(feature = \"box_from_slice\", since = \"1.17.0\")]\n impl<'a, T: Copy> From<&'a [T]> for Box<[T]> {\n     fn from(slice: &'a [T]) -> Box<[T]> {\n@@ -764,8 +775,8 @@ impl<T> Generator for Box<T>\n impl<F: ?Sized + Future + Unpin> Future for Box<F> {\n     type Output = F::Output;\n \n-    fn poll(mut self: PinMut<Self>, cx: &mut Context) -> Poll<Self::Output> {\n-        PinMut::new(&mut **self).poll(cx)\n+    fn poll(mut self: Pin<&mut Self>, cx: &mut Context) -> Poll<Self::Output> {\n+        F::poll(Pin::new(&mut *self), cx)\n     }\n }\n \n@@ -779,8 +790,8 @@ unsafe impl<'a, T, F> UnsafeFutureObj<'a, T> for Box<F>\n \n     unsafe fn poll(ptr: *mut (), cx: &mut Context) -> Poll<T> {\n         let ptr = ptr as *mut F;\n-        let pin: PinMut<F> = PinMut::new_unchecked(&mut *ptr);\n-        pin.poll(cx)\n+        let pin: Pin<&mut F> = Pin::new_unchecked(&mut *ptr);\n+        F::poll(pin, cx)\n     }\n \n     unsafe fn drop(ptr: *mut ()) {\n@@ -818,9 +829,16 @@ impl<'a, F: Future<Output = ()> + 'a> From<Box<F>> for LocalFutureObj<'a, ()> {\n     }\n }\n \n-#[unstable(feature = \"pin\", issue = \"49150\")]\n-impl<T: Unpin + ?Sized> From<PinBox<T>> for Box<T> {\n-    fn from(pinned: PinBox<T>) -> Box<T> {\n-        unsafe { PinBox::unpin(pinned) }\n+#[unstable(feature = \"futures_api\", issue = \"50547\")]\n+impl<'a, F: Future<Output = ()> + Send + 'a> From<Pin<Box<F>>> for FutureObj<'a, ()> {\n+    fn from(boxed: Pin<Box<F>>) -> Self {\n+        FutureObj::new(boxed)\n+    }\n+}\n+\n+#[unstable(feature = \"futures_api\", issue = \"50547\")]\n+impl<'a, F: Future<Output = ()> + 'a> From<Pin<Box<F>>> for LocalFutureObj<'a, ()> {\n+    fn from(boxed: Pin<Box<F>>) -> Self {\n+        LocalFutureObj::new(boxed)\n     }\n }"}, {"sha": "18d8cd773eba9f96af3a6ee13875e995dd0c7521", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/974bdc80fe3214159dc30e0bbb76694900e613c0/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/974bdc80fe3214159dc30e0bbb76694900e613c0/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=974bdc80fe3214159dc30e0bbb76694900e613c0", "patch": "@@ -160,7 +160,6 @@ pub mod collections;\n pub mod sync;\n pub mod rc;\n pub mod raw_vec;\n-pub mod pin;\n pub mod prelude;\n pub mod borrow;\n pub mod fmt;"}, {"sha": "17bbc9882d976d95c2992060f80cc08dede994ce", "filename": "src/liballoc/pin.rs", "status": "removed", "additions": 0, "deletions": 302, "changes": 302, "blob_url": "https://github.com/rust-lang/rust/blob/e6b35b0e1115f008796e8313574e4a4739b6d39d/src%2Fliballoc%2Fpin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6b35b0e1115f008796e8313574e4a4739b6d39d/src%2Fliballoc%2Fpin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fpin.rs?ref=e6b35b0e1115f008796e8313574e4a4739b6d39d", "patch": "@@ -1,302 +0,0 @@\n-//! Types which pin data to its location in memory\n-//!\n-//! It is sometimes useful to have objects that are guaranteed to not move,\n-//! in the sense that their placement in memory does not change, and can thus be relied upon.\n-//!\n-//! A prime example of such a scenario would be building self-referencial structs,\n-//! since moving an object with pointers to itself will invalidate them,\n-//! which could cause undefined behavior.\n-//!\n-//! In order to prevent objects from moving, they must be *pinned*,\n-//! by wrapping the data in pinning pointer types, such as [`PinMut`] and [`PinBox`],\n-//! which are otherwise equivalent to `& mut` and [`Box`], respectively.\n-//!\n-//! First of all, these are pointer types because pinned data mustn't be passed around by value\n-//! (that would change its location in memory).\n-//! Secondly, since data can be moved out of `&mut` and [`Box`] with functions such as [`swap`],\n-//! which causes their contents to swap places in memory,\n-//! we need dedicated types that prohibit such operations.\n-//!\n-//! However, these restrictions are usually not necessary,\n-//! so most types implement the [`Unpin`] auto-trait,\n-//! which indicates that the type can be moved out safely.\n-//! Doing so removes the limitations of pinning types,\n-//! making them the same as their non-pinning counterparts.\n-//!\n-//! [`PinMut`]: struct.PinMut.html\n-//! [`PinBox`]: struct.PinBox.html\n-//! [`Unpin`]: trait.Unpin.html\n-//! [`swap`]: ../../std/mem/fn.swap.html\n-//! [`Box`]: ../boxed/struct.Box.html\n-//!\n-//! # Examples\n-//!\n-//! ```rust\n-//! #![feature(pin)]\n-//!\n-//! use std::pin::PinBox;\n-//! use std::marker::Pinned;\n-//! use std::ptr::NonNull;\n-//!\n-//! // This is a self referencial struct since the slice field points to the data field.\n-//! // We cannot inform the compiler about that with a normal reference,\n-//! // since this pattern cannot be described with the usual borrowing rules.\n-//! // Instead we use a raw pointer, though one which is known to not be null,\n-//! // since we know it's pointing at the string.\n-//! struct Unmovable {\n-//!     data: String,\n-//!     slice: NonNull<String>,\n-//!     _pin: Pinned,\n-//! }\n-//!\n-//! impl Unmovable {\n-//!     // To ensure the data doesn't move when the function returns,\n-//!     // we place it in the heap where it will stay for the lifetime of the object,\n-//!     // and the only way to access it would be through a pointer to it.\n-//!     fn new(data: String) -> PinBox<Self> {\n-//!         let res = Unmovable {\n-//!             data,\n-//!             // we only create the pointer once the data is in place\n-//!             // otherwise it will have already moved before we even started\n-//!             slice: NonNull::dangling(),\n-//!             _pin: Pinned,\n-//!         };\n-//!         let mut boxed = PinBox::new(res);\n-//!\n-//!         let slice = NonNull::from(&boxed.data);\n-//!         // we know this is safe because modifying a field doesn't move the whole struct\n-//!         unsafe { PinBox::get_mut(&mut boxed).slice = slice };\n-//!         boxed\n-//!     }\n-//! }\n-//!\n-//! let unmoved = Unmovable::new(\"hello\".to_string());\n-//! // The pointer should point to the correct location,\n-//! // so long as the struct hasn't moved.\n-//! // Meanwhile, we are free to move the pointer around.\n-//! # #[allow(unused_mut)]\n-//! let mut still_unmoved = unmoved;\n-//! assert_eq!(still_unmoved.slice, NonNull::from(&still_unmoved.data));\n-//!\n-//! // Since our type doesn't implement Unpin, this will fail to compile:\n-//! // let new_unmoved = Unmovable::new(\"world\".to_string());\n-//! // std::mem::swap(&mut *still_unmoved, &mut *new_unmoved);\n-//! ```\n-\n-#![unstable(feature = \"pin\", issue = \"49150\")]\n-\n-pub use core::pin::*;\n-pub use core::marker::Unpin;\n-\n-use core::convert::From;\n-use core::fmt;\n-use core::future::{Future, FutureObj, LocalFutureObj, UnsafeFutureObj};\n-use core::marker::Unsize;\n-use core::ops::{CoerceUnsized, Deref, DerefMut};\n-use core::task::{Context, Poll};\n-\n-use boxed::Box;\n-\n-/// A pinned, heap allocated reference.\n-///\n-/// This type is similar to [`Box`], except that it pins its value,\n-/// which prevents it from moving out of the reference, unless it implements [`Unpin`].\n-///\n-/// See the [module documentation] for furthur explaination on pinning.\n-///\n-/// [`Box`]: ../boxed/struct.Box.html\n-/// [`Unpin`]: ../../std/marker/trait.Unpin.html\n-/// [module documentation]: index.html\n-#[unstable(feature = \"pin\", issue = \"49150\")]\n-#[fundamental]\n-#[repr(transparent)]\n-pub struct PinBox<T: ?Sized> {\n-    inner: Box<T>,\n-}\n-\n-#[unstable(feature = \"pin\", issue = \"49150\")]\n-impl<T> PinBox<T> {\n-    /// Allocate memory on the heap, move the data into it and pin it.\n-    #[unstable(feature = \"pin\", issue = \"49150\")]\n-    pub fn new(data: T) -> PinBox<T> {\n-        PinBox { inner: Box::new(data) }\n-    }\n-}\n-\n-#[unstable(feature = \"pin\", issue = \"49150\")]\n-impl<T: ?Sized> PinBox<T> {\n-    /// Get a pinned reference to the data in this PinBox.\n-    #[inline]\n-    pub fn as_pin_mut<'a>(&'a mut self) -> PinMut<'a, T> {\n-        unsafe { PinMut::new_unchecked(&mut *self.inner) }\n-    }\n-\n-    /// Constructs a `PinBox` from a raw pointer.\n-    ///\n-    /// After calling this function, the raw pointer is owned by the\n-    /// resulting `PinBox`. Specifically, the `PinBox` destructor will call\n-    /// the destructor of `T` and free the allocated memory. Since the\n-    /// way `PinBox` allocates and releases memory is unspecified, the\n-    /// only valid pointer to pass to this function is the one taken\n-    /// from another `PinBox` via the [`PinBox::into_raw`] function.\n-    ///\n-    /// This function is unsafe because improper use may lead to\n-    /// memory problems. For example, a double-free may occur if the\n-    /// function is called twice on the same raw pointer.\n-    ///\n-    /// [`PinBox::into_raw`]: struct.PinBox.html#method.into_raw\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(pin)]\n-    /// use std::pin::PinBox;\n-    /// let x = PinBox::new(5);\n-    /// let ptr = PinBox::into_raw(x);\n-    /// let x = unsafe { PinBox::from_raw(ptr) };\n-    /// ```\n-    #[inline]\n-    pub unsafe fn from_raw(raw: *mut T) -> Self {\n-        PinBox { inner: Box::from_raw(raw) }\n-    }\n-\n-    /// Consumes the `PinBox`, returning the wrapped raw pointer.\n-    ///\n-    /// After calling this function, the caller is responsible for the\n-    /// memory previously managed by the `PinBox`. In particular, the\n-    /// caller should properly destroy `T` and release the memory. The\n-    /// proper way to do so is to convert the raw pointer back into a\n-    /// `PinBox` with the [`PinBox::from_raw`] function.\n-    ///\n-    /// Note: this is an associated function, which means that you have\n-    /// to call it as `PinBox::into_raw(b)` instead of `b.into_raw()`. This\n-    /// is so that there is no conflict with a method on the inner type.\n-    ///\n-    /// [`PinBox::from_raw`]: struct.PinBox.html#method.from_raw\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(pin)]\n-    /// use std::pin::PinBox;\n-    /// let x = PinBox::new(5);\n-    /// let ptr = PinBox::into_raw(x);\n-    /// ```\n-    #[inline]\n-    pub fn into_raw(b: PinBox<T>) -> *mut T {\n-        Box::into_raw(b.inner)\n-    }\n-\n-    /// Get a mutable reference to the data inside this PinBox.\n-    ///\n-    /// This function is unsafe. Users must guarantee that the data is never\n-    /// moved out of this reference.\n-    #[inline]\n-    pub unsafe fn get_mut<'a>(this: &'a mut PinBox<T>) -> &'a mut T {\n-        &mut *this.inner\n-    }\n-\n-    /// Convert this PinBox into an unpinned Box.\n-    ///\n-    /// This function is unsafe. Users must guarantee that the data is never\n-    /// moved out of the box.\n-    #[inline]\n-    pub unsafe fn unpin(this: PinBox<T>) -> Box<T> {\n-        this.inner\n-    }\n-}\n-\n-#[unstable(feature = \"pin\", issue = \"49150\")]\n-impl<T: ?Sized> From<Box<T>> for PinBox<T> {\n-    fn from(boxed: Box<T>) -> PinBox<T> {\n-        PinBox { inner: boxed }\n-    }\n-}\n-\n-#[unstable(feature = \"pin\", issue = \"49150\")]\n-impl<T: ?Sized> Deref for PinBox<T> {\n-    type Target = T;\n-\n-    fn deref(&self) -> &T {\n-        &*self.inner\n-    }\n-}\n-\n-#[unstable(feature = \"pin\", issue = \"49150\")]\n-impl<T: Unpin + ?Sized> DerefMut for PinBox<T> {\n-    fn deref_mut(&mut self) -> &mut T {\n-        &mut *self.inner\n-    }\n-}\n-\n-#[unstable(feature = \"pin\", issue = \"49150\")]\n-impl<T: fmt::Display + ?Sized> fmt::Display for PinBox<T> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::Display::fmt(&*self.inner, f)\n-    }\n-}\n-\n-#[unstable(feature = \"pin\", issue = \"49150\")]\n-impl<T: fmt::Debug + ?Sized> fmt::Debug for PinBox<T> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::Debug::fmt(&*self.inner, f)\n-    }\n-}\n-\n-#[unstable(feature = \"pin\", issue = \"49150\")]\n-impl<T: ?Sized> fmt::Pointer for PinBox<T> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        // It's not possible to extract the inner Uniq directly from the Box,\n-        // instead we cast it to a *const which aliases the Unique\n-        let ptr: *const T = &*self.inner;\n-        fmt::Pointer::fmt(&ptr, f)\n-    }\n-}\n-\n-#[unstable(feature = \"pin\", issue = \"49150\")]\n-impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<PinBox<U>> for PinBox<T> {}\n-\n-#[unstable(feature = \"pin\", issue = \"49150\")]\n-impl<T: ?Sized> Unpin for PinBox<T> {}\n-\n-#[unstable(feature = \"futures_api\", issue = \"50547\")]\n-impl<F: ?Sized + Future> Future for PinBox<F> {\n-    type Output = F::Output;\n-\n-    fn poll(mut self: PinMut<Self>, cx: &mut Context) -> Poll<Self::Output> {\n-        self.as_pin_mut().poll(cx)\n-    }\n-}\n-\n-#[unstable(feature = \"futures_api\", issue = \"50547\")]\n-unsafe impl<'a, T, F> UnsafeFutureObj<'a, T> for PinBox<F>\n-    where F: Future<Output = T> + 'a\n-{\n-    fn into_raw(self) -> *mut () {\n-        PinBox::into_raw(self) as *mut ()\n-    }\n-\n-    unsafe fn poll(ptr: *mut (), cx: &mut Context) -> Poll<T> {\n-        let ptr = ptr as *mut F;\n-        let pin: PinMut<F> = PinMut::new_unchecked(&mut *ptr);\n-        pin.poll(cx)\n-    }\n-\n-    unsafe fn drop(ptr: *mut ()) {\n-        drop(PinBox::from_raw(ptr as *mut F))\n-    }\n-}\n-\n-#[unstable(feature = \"futures_api\", issue = \"50547\")]\n-impl<'a, F: Future<Output = ()> + Send + 'a> From<PinBox<F>> for FutureObj<'a, ()> {\n-    fn from(boxed: PinBox<F>) -> Self {\n-        FutureObj::new(boxed)\n-    }\n-}\n-\n-#[unstable(feature = \"futures_api\", issue = \"50547\")]\n-impl<'a, F: Future<Output = ()> + 'a> From<PinBox<F>> for LocalFutureObj<'a, ()> {\n-    fn from(boxed: PinBox<F>) -> Self {\n-        LocalFutureObj::new(boxed)\n-    }\n-}"}, {"sha": "3b8b65dc3142ca24a7fb269b9b8496b9cec8d279", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/974bdc80fe3214159dc30e0bbb76694900e613c0/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/974bdc80fe3214159dc30e0bbb76694900e613c0/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=974bdc80fe3214159dc30e0bbb76694900e613c0", "patch": "@@ -256,6 +256,7 @@ use core::marker::{Unsize, PhantomData};\n use core::mem::{self, align_of_val, forget, size_of_val};\n use core::ops::Deref;\n use core::ops::CoerceUnsized;\n+use core::pin::Pin;\n use core::ptr::{self, NonNull};\n use core::convert::From;\n use core::usize;\n@@ -321,6 +322,11 @@ impl<T> Rc<T> {\n         }\n     }\n \n+    #[unstable(feature = \"pin\", issue = \"49150\")]\n+    pub fn pinned(value: T) -> Pin<Rc<T>> {\n+        unsafe { Pin::new_unchecked(Rc::new(value)) }\n+    }\n+\n     /// Returns the contained value, if the `Rc` has exactly one strong reference.\n     ///\n     /// Otherwise, an [`Err`][result] is returned with the same `Rc` that was"}, {"sha": "d9607af1902144db06e6baebf3e64e79278100e0", "filename": "src/liballoc/sync.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/974bdc80fe3214159dc30e0bbb76694900e613c0/src%2Fliballoc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/974bdc80fe3214159dc30e0bbb76694900e613c0/src%2Fliballoc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fsync.rs?ref=974bdc80fe3214159dc30e0bbb76694900e613c0", "patch": "@@ -26,6 +26,7 @@ use core::intrinsics::abort;\n use core::mem::{self, align_of_val, size_of_val};\n use core::ops::Deref;\n use core::ops::CoerceUnsized;\n+use core::pin::Pin;\n use core::ptr::{self, NonNull};\n use core::marker::{Unsize, PhantomData};\n use core::hash::{Hash, Hasher};\n@@ -296,6 +297,11 @@ impl<T> Arc<T> {\n         Arc { ptr: Box::into_raw_non_null(x), phantom: PhantomData }\n     }\n \n+    #[unstable(feature = \"pin\", issue = \"49150\")]\n+    pub fn pinned(data: T) -> Pin<Arc<T>> {\n+        unsafe { Pin::new_unchecked(Arc::new(data)) }\n+    }\n+\n     /// Returns the contained value, if the `Arc` has exactly one strong reference.\n     ///\n     /// Otherwise, an [`Err`][result] is returned with the same `Arc` that was"}, {"sha": "6cf1925000e95ae463a82b07037435685bf6cf6e", "filename": "src/libcore/future/future.rs", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/974bdc80fe3214159dc30e0bbb76694900e613c0/src%2Flibcore%2Ffuture%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/974bdc80fe3214159dc30e0bbb76694900e613c0/src%2Flibcore%2Ffuture%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffuture%2Ffuture.rs?ref=974bdc80fe3214159dc30e0bbb76694900e613c0", "patch": "@@ -12,8 +12,9 @@\n             reason = \"futures in libcore are unstable\",\n             issue = \"50547\")]\n \n-use pin::PinMut;\n use marker::Unpin;\n+use ops;\n+use pin::Pin;\n use task::{self, Poll};\n \n /// A future represents an asychronous computation.\n@@ -92,21 +93,25 @@ pub trait Future {\n     /// [`Poll::Pending`]: ../task/enum.Poll.html#variant.Pending\n     /// [`Poll::Ready(val)`]: ../task/enum.Poll.html#variant.Ready\n     /// [`cx.waker()`]: ../task/struct.Context.html#method.waker\n-    fn poll(self: PinMut<Self>, cx: &mut task::Context) -> Poll<Self::Output>;\n+    fn poll(self: Pin<&mut Self>, cx: &mut task::Context) -> Poll<Self::Output>;\n }\n \n impl<'a, F: ?Sized + Future + Unpin> Future for &'a mut F {\n     type Output = F::Output;\n \n-    fn poll(mut self: PinMut<Self>, cx: &mut task::Context) -> Poll<Self::Output> {\n-        F::poll(PinMut::new(&mut **self), cx)\n+    fn poll(mut self: Pin<&mut Self>, cx: &mut task::Context) -> Poll<Self::Output> {\n+        F::poll(Pin::new(&mut **self), cx)\n     }\n }\n \n-impl<'a, F: ?Sized + Future> Future for PinMut<'a, F> {\n+impl<P, F> Future for Pin<P> where\n+    P: ops::DerefMut<Target = F> + Unpin,\n+    F: Future + ?Sized,\n+{\n     type Output = F::Output;\n \n-    fn poll(mut self: PinMut<Self>, cx: &mut task::Context) -> Poll<Self::Output> {\n-        F::poll((*self).reborrow(), cx)\n+    fn poll(mut self: Pin<&mut Self>, cx: &mut task::Context) -> Poll<Self::Output> {\n+        let pin: Pin<&mut F> = Pin::as_mut(&mut *self);\n+        F::poll(pin, cx)\n     }\n }"}, {"sha": "b335cac6c1d8ca4ca832412a225ee3fd23bd8c08", "filename": "src/libcore/future/future_obj.rs", "status": "modified", "additions": 28, "deletions": 7, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/974bdc80fe3214159dc30e0bbb76694900e613c0/src%2Flibcore%2Ffuture%2Ffuture_obj.rs", "raw_url": "https://github.com/rust-lang/rust/raw/974bdc80fe3214159dc30e0bbb76694900e613c0/src%2Flibcore%2Ffuture%2Ffuture_obj.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffuture%2Ffuture_obj.rs?ref=974bdc80fe3214159dc30e0bbb76694900e613c0", "patch": "@@ -15,7 +15,8 @@\n use fmt;\n use future::Future;\n use marker::{PhantomData, Unpin};\n-use pin::PinMut;\n+use ops;\n+use pin::Pin;\n use task::{Context, Poll};\n \n /// A custom trait object for polling futures, roughly akin to\n@@ -78,9 +79,9 @@ impl<'a, T> Future for LocalFutureObj<'a, T> {\n     type Output = T;\n \n     #[inline]\n-    fn poll(self: PinMut<Self>, cx: &mut Context) -> Poll<T> {\n+    fn poll(self: Pin<&mut Self>, cx: &mut Context) -> Poll<T> {\n         unsafe {\n-            (self.poll_fn)(self.ptr, cx)\n+            ((*self).poll_fn)((*self).ptr, cx)\n         }\n     }\n }\n@@ -128,9 +129,11 @@ impl<'a, T> Future for FutureObj<'a, T> {\n     type Output = T;\n \n     #[inline]\n-    fn poll(self: PinMut<Self>, cx: &mut Context) -> Poll<T> {\n-        let pinned_field = unsafe { PinMut::map_unchecked(self, |x| &mut x.0) };\n-        pinned_field.poll(cx)\n+    fn poll(self: Pin<&mut Self>, cx: &mut Context) -> Poll<T> {\n+        let pinned_field: Pin<&mut LocalFutureObj<'a, T>> = unsafe {\n+            Pin::map_unchecked_mut(self, |x| &mut x.0)\n+        };\n+        LocalFutureObj::poll(pinned_field, cx)\n     }\n }\n \n@@ -175,7 +178,25 @@ unsafe impl<'a, T, F> UnsafeFutureObj<'a, T> for &'a mut F\n     }\n \n     unsafe fn poll(ptr: *mut (), cx: &mut Context) -> Poll<T> {\n-        PinMut::new_unchecked(&mut *(ptr as *mut F)).poll(cx)\n+        let p: Pin<&mut F> = Pin::new_unchecked(&mut *(ptr as *mut F));\n+        F::poll(p, cx)\n+    }\n+\n+    unsafe fn drop(_ptr: *mut ()) {}\n+}\n+\n+#[unstable(feature = \"futures_api\", issue = \"50547\")]\n+unsafe impl<'a, T, P, F> UnsafeFutureObj<'a, T> for Pin<P> where\n+    P: ops::DerefMut<Target = F> + 'a,\n+    F: Future<Output = T> + 'a,\n+{\n+    fn into_raw(mut self) -> *mut () {\n+        unsafe { Pin::get_mut_unchecked(Pin::as_mut(&mut self)) as *mut F as *mut () }\n+    }\n+\n+    unsafe fn poll(ptr: *mut (), cx: &mut Context) -> Poll<T> {\n+        let future: Pin<&mut F> = Pin::new_unchecked(&mut *(ptr as *mut F));\n+        F::poll(future, cx)\n     }\n \n     unsafe fn drop(_ptr: *mut ()) {}"}, {"sha": "5572fe1512cbbaca498f2841d939e074c97053ae", "filename": "src/libcore/marker.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/974bdc80fe3214159dc30e0bbb76694900e613c0/src%2Flibcore%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/974bdc80fe3214159dc30e0bbb76694900e613c0/src%2Flibcore%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmarker.rs?ref=974bdc80fe3214159dc30e0bbb76694900e613c0", "patch": "@@ -609,7 +609,7 @@ unsafe impl<'a, T: ?Sized> Freeze for &'a mut T {}\n /// this trait cannot prevent types from moving by itself.\n ///\n /// Instead it can be used to prevent moves through the type system,\n-/// by controlling the behavior of special pointer types like [`PinMut`],\n+/// by controlling the behavior of pointers wrapped in the [`Pin`] wrapper,\n /// which \"pin\" the type in place by not allowing it to be moved out of them.\n /// See the [`pin module`] documentation for more information on pinning.\n ///\n@@ -621,10 +621,10 @@ unsafe impl<'a, T: ?Sized> Freeze for &'a mut T {}\n /// ```rust\n /// #![feature(pin)]\n /// use std::mem::replace;\n-/// use std::pin::PinMut;\n+/// use std::pin::Pin;\n ///\n /// let mut string = \"this\".to_string();\n-/// let mut pinned_string = PinMut::new(&mut string);\n+/// let mut pinned_string = Pin::new(&mut string);\n ///\n /// // dereferencing the pointer mutably is only possible because String implements Unpin\n /// replace(&mut *pinned_string, \"other\".to_string());\n@@ -633,7 +633,7 @@ unsafe impl<'a, T: ?Sized> Freeze for &'a mut T {}\n /// This trait is automatically implemented for almost every type.\n ///\n /// [`replace`]: ../../std/mem/fn.replace.html\n-/// [`PinMut`]: ../pin/struct.PinMut.html\n+/// [`Pin`]: ../pin/struct.Pin.html\n /// [`pin module`]: ../../std/pin/index.html\n #[unstable(feature = \"pin\", issue = \"49150\")]\n pub auto trait Unpin {}"}, {"sha": "83b1999f18b1a6be4c7c9d23c0f2f5c75cf7b409", "filename": "src/libcore/option.rs", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/974bdc80fe3214159dc30e0bbb76694900e613c0/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/974bdc80fe3214159dc30e0bbb76694900e613c0/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=974bdc80fe3214159dc30e0bbb76694900e613c0", "patch": "@@ -147,7 +147,7 @@\n \n use iter::{FromIterator, FusedIterator, TrustedLen};\n use {hint, mem, ops::{self, Deref}};\n-use pin::PinMut;\n+use pin::Pin;\n \n // Note that this is not a lang item per se, but it has a hidden dependency on\n // `Iterator`, which is one. The compiler assumes that the `next` method of\n@@ -270,12 +270,24 @@ impl<T> Option<T> {\n         }\n     }\n \n-    /// Converts from `Option<T>` to `Option<PinMut<'_, T>>`\n+\n+    /// Converts from `Pin<&Option<T>>` to `Option<Pin<&T>>`\n+    #[inline]\n+    #[unstable(feature = \"pin\", issue = \"49150\")]\n+    pub fn as_pin_ref<'a>(self: Pin<&'a Option<T>>) -> Option<Pin<&'a T>> {\n+        unsafe {\n+            let option: Option<&'a T> = Pin::get(self).as_ref();\n+            option.map(|x| Pin::new_unchecked(x))\n+        }\n+    }\n+\n+    /// Converts from `Pin<&mut Option<T>>` to `Option<Pin<&mut T>>`\n     #[inline]\n     #[unstable(feature = \"pin\", issue = \"49150\")]\n-    pub fn as_pin_mut<'a>(self: PinMut<'a, Self>) -> Option<PinMut<'a, T>> {\n+    pub fn as_pin_mut<'a>(self: Pin<&'a mut Option<T>>) -> Option<Pin<&'a mut T>> {\n         unsafe {\n-            PinMut::get_mut_unchecked(self).as_mut().map(|x| PinMut::new_unchecked(x))\n+            let option: Option<&'a mut T> = Pin::get_mut_unchecked(self).as_mut();\n+            option.map(|x| Pin::new_unchecked(x))\n         }\n     }\n "}, {"sha": "29fc52fe3a02f4af82cc4af4e36365c5600cb53d", "filename": "src/libcore/pin.rs", "status": "modified", "additions": 198, "deletions": 74, "changes": 272, "blob_url": "https://github.com/rust-lang/rust/blob/974bdc80fe3214159dc30e0bbb76694900e613c0/src%2Flibcore%2Fpin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/974bdc80fe3214159dc30e0bbb76694900e613c0/src%2Flibcore%2Fpin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpin.rs?ref=974bdc80fe3214159dc30e0bbb76694900e613c0", "patch": "@@ -1,160 +1,284 @@\n //! Types which pin data to its location in memory\n //!\n-//! See the [standard library module] for more information.\n+//! It is sometimes useful to have objects that are guaranteed to not move,\n+//! in the sense that their placement in memory does not change, and can thus be relied upon.\n //!\n-//! [standard library module]: ../../std/pin/index.html\n+//! A prime example of such a scenario would be building self-referencial structs,\n+//! since moving an object with pointers to itself will invalidate them,\n+//! which could cause undefined behavior.\n+//!\n+//! In order to prevent objects from moving, they must be *pinned*,\n+//! by wrapping a pointer to the data in the [`Pin`] type. A pointer wrapped\n+//! in a `Pin` is otherwise equivalent to its normal version, e.g. `Pin<Box<T>>`\n+//! and `Box<T>` work the same way except that the first is pinning the value\n+//! of `T` in place.\n+//!\n+//! First of all, these are pointer types because pinned data mustn't be passed around by value\n+//! (that would change its location in memory).\n+//! Secondly, since data can be moved out of `&mut` and [`Box`] with functions such as [`swap`],\n+//! which causes their contents to swap places in memory,\n+//! we need dedicated types that prohibit such operations.\n+//!\n+//! However, these restrictions are usually not necessary,\n+//! so most types implement the [`Unpin`] auto-trait,\n+//! which indicates that the type can be moved out safely.\n+//! Doing so removes the limitations of pinning types,\n+//! making them the same as their non-pinning counterparts.\n+//!\n+//! [`Pin`]: struct.Pin.html\n+//! [`Unpin`]: trait.Unpin.html\n+//! [`swap`]: ../../std/mem/fn.swap.html\n+//! [`Box`]: ../boxed/struct.Box.html\n+//!\n+//! # Examples\n+//!\n+//! ```rust\n+//! #![feature(pin)]\n+//!\n+//! use std::pin::Pin;\n+//! use std::marker::Pinned;\n+//! use std::ptr::NonNull;\n+//!\n+//! // This is a self referencial struct since the slice field points to the data field.\n+//! // We cannot inform the compiler about that with a normal reference,\n+//! // since this pattern cannot be described with the usual borrowing rules.\n+//! // Instead we use a raw pointer, though one which is known to not be null,\n+//! // since we know it's pointing at the string.\n+//! struct Unmovable {\n+//!     data: String,\n+//!     slice: NonNull<String>,\n+//!     _pin: Pinned,\n+//! }\n+//!\n+//! impl Unmovable {\n+//!     // To ensure the data doesn't move when the function returns,\n+//!     // we place it in the heap where it will stay for the lifetime of the object,\n+//!     // and the only way to access it would be through a pointer to it.\n+//!     fn new(data: String) -> Pin<Box<Self>> {\n+//!         let res = Unmovable {\n+//!             data,\n+//!             // we only create the pointer once the data is in place\n+//!             // otherwise it will have already moved before we even started\n+//!             slice: NonNull::dangling(),\n+//!             _pin: Pinned,\n+//!         };\n+//!         let mut boxed = Box::pinned(res);\n+//!\n+//!         let slice = NonNull::from(&boxed.data);\n+//!         // we know this is safe because modifying a field doesn't move the whole struct\n+//!         unsafe { \n+//!             let mut_ref: Pin<&mut Self> = Pin::as_mut(&mut boxed);\n+//!             Pin::get_mut_unchecked(mut_ref).slice = slice;\n+//!         }\n+//!         boxed\n+//!     }\n+//! }\n+//!\n+//! let unmoved = Unmovable::new(\"hello\".to_string());\n+//! // The pointer should point to the correct location,\n+//! // so long as the struct hasn't moved.\n+//! // Meanwhile, we are free to move the pointer around.\n+//! # #[allow(unused_mut)]\n+//! let mut still_unmoved = unmoved;\n+//! assert_eq!(still_unmoved.slice, NonNull::from(&still_unmoved.data));\n+//!\n+//! // Since our type doesn't implement Unpin, this will fail to compile:\n+//! // let new_unmoved = Unmovable::new(\"world\".to_string());\n+//! // std::mem::swap(&mut *still_unmoved, &mut *new_unmoved);\n+//! ```\n \n #![unstable(feature = \"pin\", issue = \"49150\")]\n \n use fmt;\n-use future::{Future, UnsafeFutureObj};\n use marker::{Sized, Unpin, Unsize};\n-use task::{Context, Poll};\n use ops::{Deref, DerefMut, CoerceUnsized};\n \n-/// A pinned reference.\n+/// A pinned pointer.\n ///\n-/// This type is similar to a mutable reference, except that it pins its value,\n-/// which prevents it from moving out of the reference, unless it implements [`Unpin`].\n+/// This is a wrapper around a kind of pointer which makes that pointer \"pin\" its\n+/// value in place, preventing the value referenced by that pointer from being moved\n+/// unless it implements [`Unpin`].\n ///\n /// See the [`pin` module] documentation for furthur explanation on pinning.\n ///\n /// [`Unpin`]: ../../std/marker/trait.Unpin.html\n /// [`pin` module]: ../../std/pin/index.html\n #[unstable(feature = \"pin\", issue = \"49150\")]\n #[fundamental]\n-pub struct PinMut<'a, T: ?Sized + 'a> {\n-    inner: &'a mut T,\n+#[derive(Copy, Clone, Hash, Eq, PartialEq, Ord, PartialOrd)]\n+pub struct Pin<P> {\n+    pointer: P,\n }\n \n-#[unstable(feature = \"pin\", issue = \"49150\")]\n-impl<'a, T: ?Sized + Unpin> PinMut<'a, T> {\n-    /// Construct a new `PinMut` around a reference to some data of a type that\n+impl<P, T> Pin<P> where\n+    P: Deref<Target = T>,\n+    T: ?Sized + Unpin,\n+{\n+    /// Construct a new `Pin` around a pointer to some data of a type that\n     /// implements `Unpin`.\n     #[unstable(feature = \"pin\", issue = \"49150\")]\n-    pub fn new(reference: &'a mut T) -> PinMut<'a, T> {\n-        PinMut { inner: reference }\n+    pub fn new(pointer: P) -> Pin<P> {\n+        unsafe { Pin::new_unchecked(pointer) }\n+    }\n+}\n+\n+impl<P, T> Pin<P> where\n+    P: Deref<Target = T>,\n+    T: ?Sized,\n+{\n+    /// Construct a new `Pin` around a reference to some data of a type that\n+    /// may or may not implement `Unpin`.\n+    ///\n+    /// # Safety\n+    ///\n+    /// This constructor is unsafe because we cannot guarantee that the target data\n+    /// is properly pinned by this pointer. If the constructed `Pin<P>` does not guarantee\n+    /// that the data is \"pinned,\" constructing a `Pin<P>` is undefined behavior and could lead\n+    /// to segmentation faults or worse.\n+    #[unstable(feature = \"pin\", issue = \"49150\")]\n+    pub unsafe fn new_unchecked(pointer: P) -> Pin<P> {\n+        Pin { pointer }\n     }\n \n-    /// Get a mutable reference to the data inside of this `PinMut`.\n+\n+    /// Get a pinned shared reference from this pinned pointer.\n     #[unstable(feature = \"pin\", issue = \"49150\")]\n-    pub fn get_mut(this: PinMut<'a, T>) -> &'a mut T {\n-        this.inner\n+    pub fn as_ref(this: &Pin<P>) -> Pin<&T> {\n+        unsafe { Pin::new_unchecked(&**this) }\n     }\n }\n \n+impl<P, T> Pin<P> where\n+    P: DerefMut<Target = T>,\n+    T: ?Sized,\n+{\n+    /// Get a pinned mutable reference from this pinned pointer.\n+    #[unstable(feature = \"pin\", issue = \"49150\")]\n+    pub fn as_mut(this: &mut Pin<P>) -> Pin<&mut T> {\n+        unsafe { Pin::new_unchecked(&mut *this.pointer) }\n+    }\n \n-#[unstable(feature = \"pin\", issue = \"49150\")]\n-impl<'a, T: ?Sized> PinMut<'a, T> {\n-    /// Construct a new `PinMut` around a reference to some data of a type that\n-    /// may or may not implement `Unpin`.\n-    ///\n-    /// This constructor is unsafe because we do not know what will happen with\n-    /// that data after the lifetime of the reference ends. If you cannot guarantee that the\n-    /// data will never move again, calling this constructor is invalid.\n+    /// Assign a new value to the memory behind the pinned reference.\n     #[unstable(feature = \"pin\", issue = \"49150\")]\n-    pub unsafe fn new_unchecked(reference: &'a mut T) -> PinMut<'a, T> {\n-        PinMut { inner: reference }\n+    pub fn set(this: Pin<&mut T>, value: T)\n+        where T: Sized,\n+    {\n+        *this.pointer = value;\n     }\n+}\n \n-    /// Reborrow a `PinMut` for a shorter lifetime.\n+impl<'a, T> Pin<&'a T> {\n+    /// Construct a new pin by mapping the interior value.\n+    ///\n+    /// For example, if you  wanted to get a `Pin` of a field of something,\n+    /// you could use this to get access to that field in one line of code.\n     ///\n-    /// For example, `PinMut::get_mut(x.reborrow())` (unsafely) returns a\n-    /// short-lived mutable reference reborrowing from `x`.\n+    /// # Safety\n+    ///\n+    /// This function is unsafe. You must guarantee that the data you return\n+    /// will not move so long as the argument value does not move (for example,\n+    /// because it is one of the fields of that value), and also that you do\n+    /// not move out of the argument you receive to the interior function.\n+    #[unstable(feature = \"pin\", issue = \"49150\")]\n+    pub unsafe fn map_unchecked<U, F>(this: Pin<&'a T>, func: F) -> Pin<&'a U> where\n+        F: FnOnce(&T) -> &U,\n+    {\n+        let pointer = &*this.pointer;\n+        let new_pointer = func(pointer);\n+        Pin::new_unchecked(new_pointer)\n+    }\n+\n+    /// Get a safe reference out of a pin.\n     #[unstable(feature = \"pin\", issue = \"49150\")]\n-    pub fn reborrow<'b>(&'b mut self) -> PinMut<'b, T> {\n-        PinMut { inner: self.inner }\n+    pub fn get(this: Pin<&'a T>) -> &'a T {\n+        this.pointer\n     }\n+}\n \n-    /// Get a mutable reference to the data inside of this `PinMut`.\n+impl<'a, T> Pin<&'a mut T> {\n+    /// Get a mutable reference to the data inside of this `Pin`.\n+    ///\n+    /// # Safety\n     ///\n     /// This function is unsafe. You must guarantee that you will never move\n     /// the data out of the mutable reference you receive when you call this\n-    /// function.\n+    /// function, so that the invariants on the `Pin` type can be upheld.\n     #[unstable(feature = \"pin\", issue = \"49150\")]\n-    pub unsafe fn get_mut_unchecked(this: PinMut<'a, T>) -> &'a mut T {\n-        this.inner\n+    pub unsafe fn get_mut_unchecked(this: Pin<&'a mut T>) -> &'a mut T {\n+        this.pointer\n     }\n \n     /// Construct a new pin by mapping the interior value.\n     ///\n-    /// For example, if you  wanted to get a `PinMut` of a field of something,\n+    /// For example, if you  wanted to get a `Pin` of a field of something,\n     /// you could use this to get access to that field in one line of code.\n     ///\n+    /// # Safety\n+    ///\n     /// This function is unsafe. You must guarantee that the data you return\n     /// will not move so long as the argument value does not move (for example,\n     /// because it is one of the fields of that value), and also that you do\n     /// not move out of the argument you receive to the interior function.\n     #[unstable(feature = \"pin\", issue = \"49150\")]\n-    pub unsafe fn map_unchecked<U, F>(this: PinMut<'a, T>, f: F) -> PinMut<'a, U> where\n-        F: FnOnce(&mut T) -> &mut U\n+    pub unsafe fn map_unchecked_mut<U, F>(this: Pin<&'a mut T>, func: F) -> Pin<&'a mut U> where\n+        F: FnOnce(&mut T) -> &mut U,\n     {\n-        PinMut { inner: f(this.inner) }\n-    }\n-\n-    /// Assign a new value to the memory behind the pinned reference.\n-    #[unstable(feature = \"pin\", issue = \"49150\")]\n-    pub fn set(this: PinMut<'a, T>, value: T)\n-        where T: Sized,\n-    {\n-        *this.inner = value;\n+        let pointer = Pin::get_mut_unchecked(this);\n+        let new_pointer = func(pointer);\n+        Pin::new_unchecked(new_pointer)\n     }\n }\n \n #[unstable(feature = \"pin\", issue = \"49150\")]\n-impl<'a, T: ?Sized> Deref for PinMut<'a, T> {\n+impl<P, T> Deref for Pin<P> where\n+    P: Deref<Target = T>,\n+    T: ?Sized,\n+{\n     type Target = T;\n-\n     fn deref(&self) -> &T {\n-        &*self.inner\n+        &*self.pointer\n     }\n }\n \n #[unstable(feature = \"pin\", issue = \"49150\")]\n-impl<'a, T: ?Sized + Unpin> DerefMut for PinMut<'a, T> {\n+impl<P, T> DerefMut for Pin<P> where\n+    P: DerefMut<Target = T>,\n+    T: ?Sized + Unpin,\n+{\n     fn deref_mut(&mut self) -> &mut T {\n-        self.inner\n+        &mut *self.pointer\n     }\n }\n \n #[unstable(feature = \"pin\", issue = \"49150\")]\n-impl<'a, T: fmt::Debug + ?Sized> fmt::Debug for PinMut<'a, T> {\n+impl<'a, P: fmt::Debug> fmt::Debug for Pin<P> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::Debug::fmt(&**self, f)\n+        fmt::Debug::fmt(&self.pointer, f)\n     }\n }\n \n #[unstable(feature = \"pin\", issue = \"49150\")]\n-impl<'a, T: fmt::Display + ?Sized> fmt::Display for PinMut<'a, T> {\n+impl<'a, P: fmt::Display> fmt::Display for Pin<P> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::Display::fmt(&**self, f)\n+        fmt::Display::fmt(&self.pointer, f)\n     }\n }\n \n #[unstable(feature = \"pin\", issue = \"49150\")]\n-impl<'a, T: ?Sized> fmt::Pointer for PinMut<'a, T> {\n+impl<'a, P: fmt::Pointer> fmt::Pointer for Pin<P> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::Pointer::fmt(&(&*self.inner as *const T), f)\n+        fmt::Pointer::fmt(&self.pointer, f)\n     }\n }\n \n #[unstable(feature = \"pin\", issue = \"49150\")]\n-impl<'a, T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<PinMut<'a, U>> for PinMut<'a, T> {}\n+impl<'a, T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<Pin<&'a U>> for Pin<&'a T> {}\n \n #[unstable(feature = \"pin\", issue = \"49150\")]\n-impl<'a, T: ?Sized> Unpin for PinMut<'a, T> {}\n-\n-#[unstable(feature = \"futures_api\", issue = \"50547\")]\n-unsafe impl<'a, T, F> UnsafeFutureObj<'a, T> for PinMut<'a, F>\n-    where F: Future<Output = T> + 'a\n-{\n-    fn into_raw(self) -> *mut () {\n-        unsafe { PinMut::get_mut_unchecked(self) as *mut F as *mut () }\n-    }\n+impl<'a, T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<Pin<&'a mut U>> for Pin<&'a mut T> {}\n \n-    unsafe fn poll(ptr: *mut (), cx: &mut Context) -> Poll<T> {\n-        PinMut::new_unchecked(&mut *(ptr as *mut F)).poll(cx)\n-    }\n+#[unstable(feature = \"pin\", issue = \"49150\")]\n+impl<'a, T: ?Sized> Unpin for Pin<&'a T> {}\n \n-    unsafe fn drop(_ptr: *mut ()) {}\n-}\n+#[unstable(feature = \"pin\", issue = \"49150\")]\n+impl<'a, T: ?Sized> Unpin for Pin<&'a mut T> {}"}, {"sha": "262646738cf06d10fe267ce9530a16137d0b830c", "filename": "src/libstd/future.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/974bdc80fe3214159dc30e0bbb76694900e613c0/src%2Flibstd%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/974bdc80fe3214159dc30e0bbb76694900e613c0/src%2Flibstd%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffuture.rs?ref=974bdc80fe3214159dc30e0bbb76694900e613c0", "patch": "@@ -12,7 +12,7 @@\n \n use core::cell::Cell;\n use core::marker::Unpin;\n-use core::pin::PinMut;\n+use core::pin::Pin;\n use core::option::Option;\n use core::ptr::NonNull;\n use core::task::{self, Poll};\n@@ -42,8 +42,8 @@ impl<T: Generator<Yield = ()>> !Unpin for GenFuture<T> {}\n #[unstable(feature = \"gen_future\", issue = \"50547\")]\n impl<T: Generator<Yield = ()>> Future for GenFuture<T> {\n     type Output = T::Return;\n-    fn poll(self: PinMut<Self>, cx: &mut task::Context) -> Poll<Self::Output> {\n-        set_task_cx(cx, || match unsafe { PinMut::get_mut_unchecked(self).0.resume() } {\n+    fn poll(self: Pin<&mut Self>, cx: &mut task::Context) -> Poll<Self::Output> {\n+        set_task_cx(cx, || match unsafe { Pin::get_mut_unchecked(self).0.resume() } {\n             GeneratorState::Yielded(()) => Poll::Pending,\n             GeneratorState::Complete(x) => Poll::Ready(x),\n         })\n@@ -108,9 +108,9 @@ where\n \n #[unstable(feature = \"gen_future\", issue = \"50547\")]\n /// Polls a future in the current thread-local task context.\n-pub fn poll_in_task_cx<F>(f: PinMut<F>) -> Poll<F::Output>\n+pub fn poll_in_task_cx<F>(f: Pin<&mut F>) -> Poll<F::Output>\n where\n     F: Future\n {\n-    get_task_cx(|cx| f.poll(cx))\n+    get_task_cx(|cx| F::poll(f, cx))\n }"}, {"sha": "fac8c35b9c9d54843827baab6214aca1a4521b2f", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/974bdc80fe3214159dc30e0bbb76694900e613c0/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/974bdc80fe3214159dc30e0bbb76694900e613c0/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=974bdc80fe3214159dc30e0bbb76694900e613c0", "patch": "@@ -436,7 +436,7 @@ pub use alloc_crate::fmt;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use alloc_crate::format;\n #[unstable(feature = \"pin\", issue = \"49150\")]\n-pub use alloc_crate::pin;\n+pub use core::pin;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use alloc_crate::slice;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "b9a709d80be389636e441f9194e57bd5f5f05b35", "filename": "src/libstd/macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/974bdc80fe3214159dc30e0bbb76694900e613c0/src%2Flibstd%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/974bdc80fe3214159dc30e0bbb76694900e613c0/src%2Flibstd%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros.rs?ref=974bdc80fe3214159dc30e0bbb76694900e613c0", "patch": "@@ -230,7 +230,7 @@ macro_rules! await {\n         loop {\n             if let $crate::task::Poll::Ready(x) =\n                 $crate::future::poll_in_task_cx(unsafe {\n-                    $crate::pin::PinMut::new_unchecked(&mut pinned)\n+                    $crate::pin::Pin::new_unchecked(&mut pinned)\n                 })\n             {\n                 break x;"}, {"sha": "bd7a92e9b3f0f904584aeeec58c619a21cfd6672", "filename": "src/libstd/panic.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/974bdc80fe3214159dc30e0bbb76694900e613c0/src%2Flibstd%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/974bdc80fe3214159dc30e0bbb76694900e613c0/src%2Flibstd%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpanic.rs?ref=974bdc80fe3214159dc30e0bbb76694900e613c0", "patch": "@@ -16,7 +16,7 @@ use any::Any;\n use cell::UnsafeCell;\n use fmt;\n use future::Future;\n-use pin::PinMut;\n+use pin::Pin;\n use ops::{Deref, DerefMut};\n use panicking;\n use ptr::{Unique, NonNull};\n@@ -327,9 +327,9 @@ impl<T: fmt::Debug> fmt::Debug for AssertUnwindSafe<T> {\n impl<'a, F: Future> Future for AssertUnwindSafe<F> {\n     type Output = F::Output;\n \n-    fn poll(self: PinMut<Self>, cx: &mut task::Context) -> Poll<Self::Output> {\n-        let pinned_field = unsafe { PinMut::map_unchecked(self, |x| &mut x.0) };\n-        pinned_field.poll(cx)\n+    fn poll(self: Pin<&mut Self>, cx: &mut task::Context) -> Poll<Self::Output> {\n+        let pinned_field = unsafe { Pin::map_unchecked_mut(self, |x| &mut x.0) };\n+        F::poll(pinned_field, cx)\n     }\n }\n "}]}