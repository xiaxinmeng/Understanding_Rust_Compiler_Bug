{"sha": "84813d3fbc12e15fed3507510682805644856088", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg0ODEzZDNmYmMxMmUxNWZlZDM1MDc1MTA2ODI4MDU2NDQ4NTYwODg=", "commit": {"author": {"name": "Erick Rivas", "email": "chemical.rivas@gmail.com", "date": "2015-01-11T16:40:16Z"}, "committer": {"name": "Erick Rivas", "email": "chemical.rivas@gmail.com", "date": "2015-01-11T16:40:16Z"}, "message": "Merge branch 'master' of git://github.com/rust-lang/rust into rust", "tree": {"sha": "e76ae679954d7840b5ad35b303331c329f542192", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e76ae679954d7840b5ad35b303331c329f542192"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/84813d3fbc12e15fed3507510682805644856088", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/84813d3fbc12e15fed3507510682805644856088", "html_url": "https://github.com/rust-lang/rust/commit/84813d3fbc12e15fed3507510682805644856088", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/84813d3fbc12e15fed3507510682805644856088/comments", "author": {"login": "charmeleon", "id": 107972322, "node_id": "U_kgDOBm-G4g", "avatar_url": "https://avatars.githubusercontent.com/u/107972322?v=4", "gravatar_id": "", "url": "https://api.github.com/users/charmeleon", "html_url": "https://github.com/charmeleon", "followers_url": "https://api.github.com/users/charmeleon/followers", "following_url": "https://api.github.com/users/charmeleon/following{/other_user}", "gists_url": "https://api.github.com/users/charmeleon/gists{/gist_id}", "starred_url": "https://api.github.com/users/charmeleon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/charmeleon/subscriptions", "organizations_url": "https://api.github.com/users/charmeleon/orgs", "repos_url": "https://api.github.com/users/charmeleon/repos", "events_url": "https://api.github.com/users/charmeleon/events{/privacy}", "received_events_url": "https://api.github.com/users/charmeleon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "charmeleon", "id": 107972322, "node_id": "U_kgDOBm-G4g", "avatar_url": "https://avatars.githubusercontent.com/u/107972322?v=4", "gravatar_id": "", "url": "https://api.github.com/users/charmeleon", "html_url": "https://github.com/charmeleon", "followers_url": "https://api.github.com/users/charmeleon/followers", "following_url": "https://api.github.com/users/charmeleon/following{/other_user}", "gists_url": "https://api.github.com/users/charmeleon/gists{/gist_id}", "starred_url": "https://api.github.com/users/charmeleon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/charmeleon/subscriptions", "organizations_url": "https://api.github.com/users/charmeleon/orgs", "repos_url": "https://api.github.com/users/charmeleon/repos", "events_url": "https://api.github.com/users/charmeleon/events{/privacy}", "received_events_url": "https://api.github.com/users/charmeleon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8e42f1e6c3e4954ee8a05ce8f4f732fd612e782f", "url": "https://api.github.com/repos/rust-lang/rust/commits/8e42f1e6c3e4954ee8a05ce8f4f732fd612e782f", "html_url": "https://github.com/rust-lang/rust/commit/8e42f1e6c3e4954ee8a05ce8f4f732fd612e782f"}, {"sha": "9d2e9b9be62316f0bae4ac833c2485f55915ee6c", "url": "https://api.github.com/repos/rust-lang/rust/commits/9d2e9b9be62316f0bae4ac833c2485f55915ee6c", "html_url": "https://github.com/rust-lang/rust/commit/9d2e9b9be62316f0bae4ac833c2485f55915ee6c"}], "stats": {"total": 91, "additions": 76, "deletions": 15}, "files": [{"sha": "e30e7e8600dcbc773117078d6957ee077c71c9ea", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/84813d3fbc12e15fed3507510682805644856088/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84813d3fbc12e15fed3507510682805644856088/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=84813d3fbc12e15fed3507510682805644856088", "patch": "@@ -302,6 +302,7 @@ impl String {\n     /// assert_eq!(String::from_utf16_lossy(v),\n     ///            \"\ud834\udd1emus\\u{FFFD}ic\\u{FFFD}\".to_string());\n     /// ```\n+    #[inline]\n     #[stable]\n     pub fn from_utf16_lossy(v: &[u16]) -> String {\n         unicode_str::utf16_items(v).map(|c| c.to_char_lossy()).collect()\n@@ -556,6 +557,7 @@ impl String {\n     /// assert_eq!(s.remove(1), 'o');\n     /// assert_eq!(s.remove(0), 'o');\n     /// ```\n+    #[inline]\n     #[stable]\n     pub fn remove(&mut self, idx: uint) -> char {\n         let len = self.len();\n@@ -582,6 +584,7 @@ impl String {\n     ///\n     /// If `idx` does not lie on a character boundary or is out of bounds, then\n     /// this function will panic.\n+    #[inline]\n     #[stable]\n     pub fn insert(&mut self, idx: uint, ch: char) {\n         let len = self.len();\n@@ -618,6 +621,7 @@ impl String {\n     /// }\n     /// assert_eq!(s.as_slice(), \"olleh\");\n     /// ```\n+    #[inline]\n     #[stable]\n     pub unsafe fn as_mut_vec<'a>(&'a mut self) -> &'a mut Vec<u8> {\n         &mut self.vec\n@@ -645,6 +649,7 @@ impl String {\n     /// v.push('a');\n     /// assert!(!v.is_empty());\n     /// ```\n+    #[inline]\n     #[stable]\n     pub fn is_empty(&self) -> bool { self.len() == 0 }\n \n@@ -801,6 +806,7 @@ impl Str for String {\n \n #[stable]\n impl Default for String {\n+    #[inline]\n     #[stable]\n     fn default() -> String {\n         String::new()\n@@ -809,13 +815,15 @@ impl Default for String {\n \n #[stable]\n impl fmt::String for String {\n+    #[inline]\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         fmt::String::fmt(&**self, f)\n     }\n }\n \n #[unstable = \"waiting on fmt stabilization\"]\n impl fmt::Show for String {\n+    #[inline]\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         fmt::Show::fmt(&**self, f)\n     }\n@@ -842,6 +850,7 @@ impl<H: hash::Writer + hash::Hasher> hash::Hash<H> for String {\n impl<'a> Add<&'a str> for String {\n     type Output = String;\n \n+    #[inline]\n     fn add(mut self, other: &str) -> String {\n         self.push_str(other);\n         self\n@@ -881,6 +890,7 @@ impl ops::Index<ops::FullRange> for String {\n impl ops::Deref for String {\n     type Target = str;\n \n+    #[inline]\n     fn deref<'a>(&'a self) -> &'a str {\n         unsafe { mem::transmute(&self.vec[]) }\n     }\n@@ -895,6 +905,7 @@ pub struct DerefString<'a> {\n impl<'a> Deref for DerefString<'a> {\n     type Target = String;\n \n+    #[inline]\n     fn deref<'b>(&'b self) -> &'b String {\n         unsafe { mem::transmute(&*self.x) }\n     }\n@@ -933,6 +944,7 @@ pub trait ToString {\n }\n \n impl<T: fmt::String + ?Sized> ToString for T {\n+    #[inline]\n     fn to_string(&self) -> String {\n         use core::fmt::Writer;\n         let mut buf = String::new();\n@@ -943,12 +955,14 @@ impl<T: fmt::String + ?Sized> ToString for T {\n }\n \n impl IntoCow<'static, String, str> for String {\n+    #[inline]\n     fn into_cow(self) -> CowString<'static> {\n         Cow::Owned(self)\n     }\n }\n \n impl<'a> IntoCow<'a, String, str> for &'a str {\n+    #[inline]\n     fn into_cow(self) -> CowString<'a> {\n         Cow::Borrowed(self)\n     }\n@@ -966,6 +980,7 @@ impl<'a> Str for CowString<'a> {\n }\n \n impl fmt::Writer for String {\n+    #[inline]\n     fn write_str(&mut self, s: &str) -> fmt::Result {\n         self.push_str(s);\n         Ok(())"}, {"sha": "ea98d6bb74e9504b502c5f41e8aff2424aede395", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/84813d3fbc12e15fed3507510682805644856088/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84813d3fbc12e15fed3507510682805644856088/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=84813d3fbc12e15fed3507510682805644856088", "patch": "@@ -1054,6 +1054,11 @@ pub fn load_ty<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n         C_undef(type_of::type_of(cx.ccx(), t))\n     } else if ty::type_is_bool(t) {\n         Trunc(cx, LoadRangeAssert(cx, ptr, 0, 2, llvm::False), Type::i1(cx.ccx()))\n+    } else if type_is_immediate(cx.ccx(), t) && type_of::type_of(cx.ccx(), t).is_aggregate() {\n+        // We want to pass small aggregates as immediate values, but using an aggregate LLVM type\n+        // for this leads to bad optimizations, so its arg type is an appropriately sized integer\n+        // and we have to convert it\n+        Load(cx, BitCast(cx, ptr, type_of::arg_type_of(cx.ccx(), t).ptr_to()))\n     } else if ty::type_is_char(t) {\n         // a char is a Unicode codepoint, and so takes values from 0\n         // to 0x10FFFF inclusive only.\n@@ -1065,9 +1070,14 @@ pub fn load_ty<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n \n /// Helper for storing values in memory. Does the necessary conversion if the in-memory type\n /// differs from the type used for SSA values.\n-pub fn store_ty(cx: Block, v: ValueRef, dst: ValueRef, t: Ty) {\n+pub fn store_ty<'blk, 'tcx>(cx: Block<'blk, 'tcx>, v: ValueRef, dst: ValueRef, t: Ty<'tcx>) {\n     if ty::type_is_bool(t) {\n         Store(cx, ZExt(cx, v, Type::i8(cx.ccx())), dst);\n+    } else if type_is_immediate(cx.ccx(), t) && type_of::type_of(cx.ccx(), t).is_aggregate() {\n+        // We want to pass small aggregates as immediate values, but using an aggregate LLVM type\n+        // for this leads to bad optimizations, so its arg type is an appropriately sized integer\n+        // and we have to convert it\n+        Store(cx, v, BitCast(cx, dst, type_of::arg_type_of(cx.ccx(), t).ptr_to()));\n     } else {\n         Store(cx, v, dst);\n     };"}, {"sha": "f59e70d099a638342005c300f5c02ed8e3574abe", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/84813d3fbc12e15fed3507510682805644856088/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84813d3fbc12e15fed3507510682805644856088/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=84813d3fbc12e15fed3507510682805644856088", "patch": "@@ -222,10 +222,7 @@ fn type_is_newtype_immediate<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     match ty.sty {\n         ty::ty_struct(def_id, substs) => {\n             let fields = ty::struct_fields(ccx.tcx(), def_id, substs);\n-            fields.len() == 1 &&\n-                fields[0].name ==\n-                    token::special_idents::unnamed_field.name &&\n-                type_is_immediate(ccx, fields[0].mt.ty)\n+            fields.len() == 1 && type_is_immediate(ccx, fields[0].mt.ty)\n         }\n         _ => false\n     }\n@@ -247,7 +244,7 @@ pub fn type_is_immediate<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>) -\n         return false;\n     }\n     match ty.sty {\n-        ty::ty_struct(..) | ty::ty_enum(..) | ty::ty_tup(..) |\n+        ty::ty_struct(..) | ty::ty_enum(..) | ty::ty_tup(..) | ty::ty_vec(_, Some(_)) |\n         ty::ty_unboxed_closure(..) => {\n             let llty = sizing_type_of(ccx, ty);\n             llsize_of_alloc(ccx, llty) <= llsize_of_alloc(ccx, ccx.int_type())"}, {"sha": "fb61bab6ade2c4e18e432bc61aa95c73e1682b82", "filename": "src/librustc_trans/trans/foreign.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/84813d3fbc12e15fed3507510682805644856088/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84813d3fbc12e15fed3507510682805644856088/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs?ref=84813d3fbc12e15fed3507510682805644856088", "patch": "@@ -736,6 +736,13 @@ pub fn trans_rust_fn_with_foreign_abi<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                 if ty::type_is_bool(rust_ty) {\n                     let tmp = builder.load_range_assert(llforeign_arg, 0, 2, llvm::False);\n                     builder.trunc(tmp, Type::i1(ccx))\n+                } else if type_of::type_of(ccx, rust_ty).is_aggregate() {\n+                    // We want to pass small aggregates as immediate values, but using an aggregate\n+                    // LLVM type for this leads to bad optimizations, so its arg type is an\n+                    // appropriately sized integer and we have to convert it\n+                    let tmp = builder.bitcast(llforeign_arg,\n+                                              type_of::arg_type_of(ccx, rust_ty).ptr_to());\n+                    builder.load(tmp)\n                 } else {\n                     builder.load(llforeign_arg)\n                 }\n@@ -834,10 +841,10 @@ fn foreign_signature<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                fn_sig: &ty::FnSig<'tcx>,\n                                arg_tys: &[Ty<'tcx>])\n                                -> LlvmSignature {\n-    let llarg_tys = arg_tys.iter().map(|&arg| arg_type_of(ccx, arg)).collect();\n+    let llarg_tys = arg_tys.iter().map(|&arg| foreign_arg_type_of(ccx, arg)).collect();\n     let (llret_ty, ret_def) = match fn_sig.output {\n         ty::FnConverging(ret_ty) =>\n-            (type_of::arg_type_of(ccx, ret_ty), !return_type_is_void(ccx, ret_ty)),\n+            (type_of::foreign_arg_type_of(ccx, ret_ty), !return_type_is_void(ccx, ret_ty)),\n         ty::FnDiverging =>\n             (Type::nil(ccx), false)\n     };"}, {"sha": "a79bb6ca1647068f5887056cd13f3590af614439", "filename": "src/librustc_trans/trans/glue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/84813d3fbc12e15fed3507510682805644856088/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84813d3fbc12e15fed3507510682805644856088/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fglue.rs?ref=84813d3fbc12e15fed3507510682805644856088", "patch": "@@ -138,7 +138,7 @@ pub fn drop_ty_immediate<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                      -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"drop_ty_immediate\");\n     let vp = alloca(bcx, type_of(bcx.ccx(), t), \"\");\n-    Store(bcx, v, vp);\n+    store_ty(bcx, v, vp, t);\n     drop_ty(bcx, vp, t, source_location)\n }\n "}, {"sha": "91c7409182df6827a14836a9ea17f16cec99d8b6", "filename": "src/librustc_trans/trans/intrinsic.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/84813d3fbc12e15fed3507510682805644856088/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84813d3fbc12e15fed3507510682805644856088/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs?ref=84813d3fbc12e15fed3507510682805644856088", "patch": "@@ -357,11 +357,11 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                 &ccx.link_meta().crate_hash);\n             // NB: This needs to be kept in lockstep with the TypeId struct in\n             //     the intrinsic module\n-            C_named_struct(llret_ty, &[C_u64(ccx, hash)])\n+            C_u64(ccx, hash)\n         }\n         (_, \"init\") => {\n             let tp_ty = *substs.types.get(FnSpace, 0);\n-            let lltp_ty = type_of::type_of(ccx, tp_ty);\n+            let lltp_ty = type_of::arg_type_of(ccx, tp_ty);\n             if return_type_is_void(ccx, tp_ty) {\n                 C_nil(ccx)\n             } else {\n@@ -686,6 +686,11 @@ fn with_overflow_intrinsic<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, name: &'static st\n     let ret = C_undef(type_of::type_of(bcx.ccx(), t));\n     let ret = InsertValue(bcx, ret, result, 0);\n     let ret = InsertValue(bcx, ret, overflow, 1);\n-\n-    ret\n+    if type_is_immediate(bcx.ccx(), t) {\n+        let tmp = alloc_ty(bcx, t, \"tmp\");\n+        Store(bcx, ret, tmp);\n+        load_ty(bcx, tmp, t)\n+    } else {\n+        ret\n+    }\n }"}, {"sha": "9cae142c03ac14ae6f402f6991ae43100a69e256", "filename": "src/librustc_trans/trans/type_.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/84813d3fbc12e15fed3507510682805644856088/src%2Flibrustc_trans%2Ftrans%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84813d3fbc12e15fed3507510682805644856088/src%2Flibrustc_trans%2Ftrans%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftype_.rs?ref=84813d3fbc12e15fed3507510682805644856088", "patch": "@@ -82,6 +82,11 @@ impl Type {\n         ty!(llvm::LLVMInt64TypeInContext(ccx.llcx()))\n     }\n \n+    // Creates an integer type with the given number of bits, e.g. i24\n+    pub fn ix(ccx: &CrateContext, num_bits: u64) -> Type {\n+        ty!(llvm::LLVMIntTypeInContext(ccx.llcx(), num_bits as c_uint))\n+    }\n+\n     pub fn f32(ccx: &CrateContext) -> Type {\n         ty!(llvm::LLVMFloatTypeInContext(ccx.llcx()))\n     }\n@@ -260,6 +265,13 @@ impl Type {\n         ty!(llvm::LLVMPointerType(self.to_ref(), 0))\n     }\n \n+    pub fn is_aggregate(&self) -> bool {\n+        match self.kind() {\n+            TypeKind::Struct | TypeKind::Array => true,\n+            _ =>  false\n+        }\n+    }\n+\n     pub fn is_packed(&self) -> bool {\n         unsafe {\n             llvm::LLVMIsPackedStruct(self.to_ref()) == True"}, {"sha": "76e0e0d0545572bfade131cbde87b8b53c259f71", "filename": "src/librustc_trans/trans/type_of.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/84813d3fbc12e15fed3507510682805644856088/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84813d3fbc12e15fed3507510682805644856088/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs?ref=84813d3fbc12e15fed3507510682805644856088", "patch": "@@ -243,9 +243,24 @@ pub fn sizing_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Typ\n     llsizingty\n }\n \n+pub fn foreign_arg_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Type {\n+    if ty::type_is_bool(t) {\n+        Type::i1(cx)\n+    } else {\n+        type_of(cx, t)\n+    }\n+}\n+\n pub fn arg_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Type {\n     if ty::type_is_bool(t) {\n         Type::i1(cx)\n+    } else if type_is_immediate(cx, t) && type_of(cx, t).is_aggregate() {\n+        // We want to pass small aggregates as immediate values, but using an aggregate LLVM type\n+        // for this leads to bad optimizations, so its arg type is an appropriately sized integer\n+        match machine::llsize_of_alloc(cx, sizing_type_of(cx, t)) {\n+            0 => type_of(cx, t),\n+            n => Type::ix(cx, n * 8),\n+        }\n     } else {\n         type_of(cx, t)\n     }"}, {"sha": "74802c156a262459b7e1013aa8f7efaa42bb9c20", "filename": "src/test/run-pass/unwind-unique.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/84813d3fbc12e15fed3507510682805644856088/src%2Ftest%2Frun-pass%2Funwind-unique.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84813d3fbc12e15fed3507510682805644856088/src%2Ftest%2Frun-pass%2Funwind-unique.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funwind-unique.rs?ref=84813d3fbc12e15fed3507510682805644856088", "patch": "@@ -19,5 +19,5 @@ fn f() {\n }\n \n pub fn main() {\n-    let _t = Thread::spawn(f);\n+    let _t = Thread::scoped(f);\n }"}, {"sha": "b1c65d322ab2009555e55d08be141b3823a9d722", "filename": "src/test/run-pass/weak-lang-item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/84813d3fbc12e15fed3507510682805644856088/src%2Ftest%2Frun-pass%2Fweak-lang-item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84813d3fbc12e15fed3507510682805644856088/src%2Ftest%2Frun-pass%2Fweak-lang-item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fweak-lang-item.rs?ref=84813d3fbc12e15fed3507510682805644856088", "patch": "@@ -15,7 +15,7 @@ extern crate \"weak-lang-items\" as other;\n use std::thread::Thread;\n \n fn main() {\n-    let _ = Thread::spawn(move|| {\n+    let _ = Thread::scoped(move|| {\n         other::foo()\n     });\n }"}]}