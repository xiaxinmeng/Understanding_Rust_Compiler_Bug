{"sha": "8614d1694cda26118c2f44a2acd986f137935816", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg2MTRkMTY5NGNkYTI2MTE4YzJmNDRhMmFjZDk4NmYxMzc5MzU4MTY=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2013-07-10T00:18:02Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2013-07-11T20:15:52Z"}, "message": "extra: factor ConsoleTestState methods into an impl, fix perf bug.\n\nIt was re-reading terminfo on each line of output.", "tree": {"sha": "8849549fa24bf5f9253d14b8068f17561ec0b1dd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8849549fa24bf5f9253d14b8068f17561ec0b1dd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8614d1694cda26118c2f44a2acd986f137935816", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8614d1694cda26118c2f44a2acd986f137935816", "html_url": "https://github.com/rust-lang/rust/commit/8614d1694cda26118c2f44a2acd986f137935816", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8614d1694cda26118c2f44a2acd986f137935816/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bf1f69c1565acfb33ea02389e2c6d6c87ee63e3a", "url": "https://api.github.com/repos/rust-lang/rust/commits/bf1f69c1565acfb33ea02389e2c6d6c87ee63e3a", "html_url": "https://github.com/rust-lang/rust/commit/bf1f69c1565acfb33ea02389e2c6d6c87ee63e3a"}], "stats": {"total": 287, "additions": 148, "deletions": 139}, "files": [{"sha": "6ef03744366ad6673ab4fb65bd99876393114a4a", "filename": "src/libextra/test.rs", "status": "modified", "additions": 148, "deletions": 139, "changes": 287, "blob_url": "https://github.com/rust-lang/rust/blob/8614d1694cda26118c2f44a2acd986f137935816/src%2Flibextra%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8614d1694cda26118c2f44a2acd986f137935816/src%2Flibextra%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftest.rs?ref=8614d1694cda26118c2f44a2acd986f137935816", "patch": "@@ -31,7 +31,6 @@ use std::result;\n use std::task;\n use std::to_str::ToStr;\n use std::u64;\n-use std::uint;\n \n \n // The name of a test. By convention this follows the rules for rust\n@@ -191,6 +190,7 @@ pub enum TestResult { TrOk, TrFailed, TrIgnored, TrBench(BenchSamples) }\n struct ConsoleTestState {\n     out: @io::Writer,\n     log_out: Option<@io::Writer>,\n+    term: Option<term::Terminal>,\n     use_color: bool,\n     total: uint,\n     passed: uint,\n@@ -200,171 +200,180 @@ struct ConsoleTestState {\n     failures: ~[TestDesc]\n }\n \n-// A simple console test runner\n-pub fn run_tests_console(opts: &TestOpts,\n-                         tests: ~[TestDescAndFn]) -> bool {\n-    fn callback(event: &TestEvent, st: &mut ConsoleTestState) {\n-        debug!(\"callback(event=%?)\", event);\n-        match copy *event {\n-          TeFiltered(ref filtered_tests) => {\n-            st.total = filtered_tests.len();\n-            let noun = if st.total != 1 { ~\"tests\" } else { ~\"test\" };\n-            st.out.write_line(fmt!(\"\\nrunning %u %s\", st.total, noun));\n-          }\n-          TeWait(ref test) => st.out.write_str(\n-              fmt!(\"test %s ... \", test.name.to_str())),\n-          TeResult(test, result) => {\n-            match st.log_out {\n-                Some(f) => write_log(f, copy result, &test),\n-                None => ()\n-            }\n-            match result {\n-              TrOk => {\n-                st.passed += 1;\n-                write_ok(st.out, st.use_color);\n-                st.out.write_line(\"\");\n-              }\n-              TrFailed => {\n-                st.failed += 1;\n-                write_failed(st.out, st.use_color);\n-                st.out.write_line(\"\");\n-                st.failures.push(test);\n-              }\n-              TrIgnored => {\n-                st.ignored += 1;\n-                write_ignored(st.out, st.use_color);\n-                st.out.write_line(\"\");\n-              }\n-              TrBench(bs) => {\n-                st.benchmarked += 1u;\n-                write_bench(st.out, st.use_color);\n-                st.out.write_line(fmt!(\": %s\",\n-                                       fmt_bench_samples(&bs)));\n-              }\n-            }\n-          }\n+impl ConsoleTestState {\n+    pub fn new(opts: &TestOpts) -> ConsoleTestState {\n+        let log_out = match opts.logfile {\n+            Some(ref path) => match io::file_writer(path,\n+                                                    [io::Create,\n+                                                     io::Truncate]) {\n+                result::Ok(w) => Some(w),\n+                result::Err(ref s) => {\n+                    fail!(\"can't open output file: %s\", *s)\n+                }\n+            },\n+            None => None\n+        };\n+        let out = io::stdout();\n+        let term = match term::Terminal::new(out) {\n+            Err(_) => None,\n+            Ok(t) => Some(t)\n+        };\n+        ConsoleTestState {\n+            out: out,\n+            log_out: log_out,\n+            use_color: use_color(),\n+            term: term,\n+            total: 0u,\n+            passed: 0u,\n+            failed: 0u,\n+            ignored: 0u,\n+            benchmarked: 0u,\n+            failures: ~[]\n         }\n     }\n \n-    let log_out = match opts.logfile {\n-        Some(ref path) => match io::file_writer(path,\n-                                                [io::Create,\n-                                                 io::Truncate]) {\n-          result::Ok(w) => Some(w),\n-          result::Err(ref s) => {\n-              fail!(\"can't open output file: %s\", *s)\n-          }\n-        },\n-        None => None\n-    };\n-\n-    let st = @mut ConsoleTestState {\n-        out: io::stdout(),\n-        log_out: log_out,\n-        use_color: use_color(),\n-        total: 0u,\n-        passed: 0u,\n-        failed: 0u,\n-        ignored: 0u,\n-        benchmarked: 0u,\n-        failures: ~[]\n-    };\n-\n-    run_tests(opts, tests, |x| callback(&x, st));\n-\n-    assert!(st.passed + st.failed +\n-                 st.ignored + st.benchmarked == st.total);\n-    let success = st.failed == 0u;\n+    pub fn write_ok(&self) {\n+        self.write_pretty(\"ok\", term::color::GREEN);\n+    }\n \n-    if !success {\n-        print_failures(st);\n+    pub fn write_failed(&self) {\n+        self.write_pretty(\"FAILED\", term::color::RED);\n     }\n \n-    {\n-      let st: &mut ConsoleTestState = st;\n-      st.out.write_str(fmt!(\"\\nresult: \"));\n-      if success {\n-          // There's no parallelism at this point so it's safe to use color\n-          write_ok(st.out, true);\n-      } else {\n-          write_failed(st.out, true);\n-      }\n-      st.out.write_str(fmt!(\". %u passed; %u failed; %u ignored\\n\\n\",\n-                            st.passed, st.failed, st.ignored));\n+    pub fn write_ignored(&self) {\n+        self.write_pretty(\"ignored\", term::color::YELLOW);\n     }\n \n-    return success;\n+    pub fn write_bench(&self) {\n+        self.write_pretty(\"bench\", term::color::CYAN);\n+    }\n \n-    fn fmt_bench_samples(bs: &BenchSamples) -> ~str {\n-        if bs.mb_s != 0 {\n-            fmt!(\"%u ns/iter (+/- %u) = %u MB/s\",\n-                 bs.ns_iter_summ.median as uint,\n-                 (bs.ns_iter_summ.max - bs.ns_iter_summ.min) as uint,\n-                 bs.mb_s)\n-        } else {\n-            fmt!(\"%u ns/iter (+/- %u)\",\n-                 bs.ns_iter_summ.median as uint,\n-                 (bs.ns_iter_summ.max - bs.ns_iter_summ.min) as uint)\n+    pub fn write_pretty(&self,\n+                        word: &str,\n+                        color: term::color::Color) {\n+        match self.term {\n+            None => self.out.write_str(word),\n+            Some(ref t) => {\n+                if self.use_color {\n+                    t.fg(color);\n+                }\n+                self.out.write_str(word);\n+                if self.use_color {\n+                    t.reset();\n+                }\n+            }\n         }\n     }\n \n-    fn write_log(out: @io::Writer, result: TestResult, test: &TestDesc) {\n-        out.write_line(fmt!(\"%s %s\",\n-                    match result {\n-                        TrOk => ~\"ok\",\n-                        TrFailed => ~\"failed\",\n-                        TrIgnored => ~\"ignored\",\n-                        TrBench(ref bs) => fmt_bench_samples(bs)\n-                    }, test.name.to_str()));\n+    pub fn write_run_start(&mut self, len: uint) {\n+        self.total = len;\n+        let noun = if len != 1 { &\"tests\" } else { &\"test\" };\n+        self.out.write_line(fmt!(\"\\nrunning %u %s\", len, noun));\n     }\n \n-    fn write_ok(out: @io::Writer, use_color: bool) {\n-        write_pretty(out, \"ok\", term::color::GREEN, use_color);\n+    pub fn write_test_start(&self, test: &TestDesc) {\n+        self.out.write_str(fmt!(\"test %s ... \", test.name.to_str()));\n     }\n \n-    fn write_failed(out: @io::Writer, use_color: bool) {\n-        write_pretty(out, \"FAILED\", term::color::RED, use_color);\n+    pub fn write_result(&self, result: &TestResult) {\n+        match *result {\n+            TrOk => self.write_ok(),\n+            TrFailed => self.write_failed(),\n+            TrIgnored => self.write_ignored(),\n+            TrBench(ref bs) => {\n+                self.write_bench();\n+                self.out.write_str(\": \" + fmt_bench_samples(bs))\n+            }\n+        }\n+        self.out.write_str(&\"\\n\");\n+    }\n+\n+    pub fn write_log(&self, test: &TestDesc, result: &TestResult) {\n+        match self.log_out {\n+            None => (),\n+            Some(out) => {\n+                out.write_line(fmt!(\"%s %s\",\n+                                    match *result {\n+                                        TrOk => ~\"ok\",\n+                                        TrFailed => ~\"failed\",\n+                                        TrIgnored => ~\"ignored\",\n+                                        TrBench(ref bs) => fmt_bench_samples(bs)\n+                                    }, test.name.to_str()));\n+            }\n+        }\n     }\n \n-    fn write_ignored(out: @io::Writer, use_color: bool) {\n-        write_pretty(out, \"ignored\", term::color::YELLOW, use_color);\n+    pub fn write_failures(&self) {\n+        self.out.write_line(\"\\nfailures:\");\n+        let mut failures = ~[];\n+        for self.failures.iter().advance() |f| {\n+            failures.push(f.name.to_str());\n+        }\n+        sort::tim_sort(failures);\n+        for failures.iter().advance |name| {\n+            self.out.write_line(fmt!(\"    %s\", name.to_str()));\n+        }\n     }\n \n-    fn write_bench(out: @io::Writer, use_color: bool) {\n-        write_pretty(out, \"bench\", term::color::CYAN, use_color);\n-    }\n+    pub fn write_run_finish(&self) -> bool {\n+        assert!(self.passed + self.failed + self.ignored + self.benchmarked == self.total);\n+        let success = self.failed == 0u;\n+        if !success {\n+            self.write_failures();\n+        }\n \n-    fn write_pretty(out: @io::Writer,\n-                    word: &str,\n-                    color: term::color::Color,\n-                    use_color: bool) {\n-        let t = term::Terminal::new(out);\n-        match t {\n-            Ok(term)  => {\n-                if use_color {\n-                    term.fg(color);\n-                }\n-                out.write_str(word);\n-                if use_color {\n-                    term.reset();\n-                }\n-            },\n-            Err(_) => out.write_str(word)\n+        self.out.write_str(\"\\nresult: \");\n+        if success {\n+            // There's no parallelism at this point so it's safe to use color\n+            self.write_ok();\n+        } else {\n+            self.write_failed();\n         }\n+        self.out.write_str(fmt!(\". %u passed; %u failed; %u ignored, %u benchmarked\\n\\n\",\n+                                self.passed, self.failed, self.ignored, self.benchmarked));\n+        return success;\n     }\n }\n \n-fn print_failures(st: &ConsoleTestState) {\n-    st.out.write_line(\"\\nfailures:\");\n-    let mut failures = ~[];\n-    for uint::range(0, st.failures.len()) |i| {\n-        let name = copy st.failures[i].name;\n-        failures.push(name.to_str());\n+pub fn fmt_bench_samples(bs: &BenchSamples) -> ~str {\n+    if bs.mb_s != 0 {\n+        fmt!(\"%u ns/iter (+/- %u) = %u MB/s\",\n+             bs.ns_iter_summ.median as uint,\n+             (bs.ns_iter_summ.max - bs.ns_iter_summ.min) as uint,\n+             bs.mb_s)\n+    } else {\n+        fmt!(\"%u ns/iter (+/- %u)\",\n+             bs.ns_iter_summ.median as uint,\n+             (bs.ns_iter_summ.max - bs.ns_iter_summ.min) as uint)\n     }\n-    sort::tim_sort(failures);\n-    for failures.iter().advance |name| {\n-        st.out.write_line(fmt!(\"    %s\", name.to_str()));\n+}\n+\n+// A simple console test runner\n+pub fn run_tests_console(opts: &TestOpts,\n+                         tests: ~[TestDescAndFn]) -> bool {\n+    fn callback(event: &TestEvent, st: &mut ConsoleTestState) {\n+        debug!(\"callback(event=%?)\", event);\n+        match copy *event {\n+            TeFiltered(ref filtered_tests) => st.write_run_start(filtered_tests.len()),\n+            TeWait(ref test) => st.write_test_start(test),\n+            TeResult(test, result) => {\n+                st.write_log(&test, &result);\n+                st.write_result(&result);\n+                match result {\n+                    TrOk => st.passed += 1,\n+                    TrIgnored => st.ignored += 1,\n+                    TrBench(_) => st.benchmarked += 1,\n+                    TrFailed => {\n+                        st.failed += 1;\n+                        st.failures.push(test);\n+                    }\n+                }\n+            }\n+        }\n     }\n+    let st = @mut ConsoleTestState::new(opts);\n+    run_tests(opts, tests, |x| callback(&x, st));\n+    return st.write_run_finish();\n }\n \n #[test]"}]}