{"sha": "e0d5c19dbbecaabaa4f0fe802e8e4138178f38f9", "node_id": "C_kwDOAAsO6NoAKGUwZDVjMTlkYmJlY2FhYmFhNGYwZmU4MDJlOGU0MTM4MTc4ZjM4Zjk", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-07-31T02:00:46Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-08-01T13:28:35Z"}, "message": "check that Scalar layout is newtype around a suitable type", "tree": {"sha": "889ed6cb6ad10a37b43eb56b43f0be4da82006e1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/889ed6cb6ad10a37b43eb56b43f0be4da82006e1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e0d5c19dbbecaabaa4f0fe802e8e4138178f38f9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e0d5c19dbbecaabaa4f0fe802e8e4138178f38f9", "html_url": "https://github.com/rust-lang/rust/commit/e0d5c19dbbecaabaa4f0fe802e8e4138178f38f9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e0d5c19dbbecaabaa4f0fe802e8e4138178f38f9/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1f5d8d49eb6111931091f700d07518cd2b80bc18", "url": "https://api.github.com/repos/rust-lang/rust/commits/1f5d8d49eb6111931091f700d07518cd2b80bc18", "html_url": "https://github.com/rust-lang/rust/commit/1f5d8d49eb6111931091f700d07518cd2b80bc18"}], "stats": {"total": 175, "additions": 135, "deletions": 40}, "files": [{"sha": "3dd66ab644245a7b4203e019bef184420f0f3451", "filename": "compiler/rustc_middle/src/ty/layout.rs", "status": "modified", "additions": 135, "deletions": 40, "changes": 175, "blob_url": "https://github.com/rust-lang/rust/blob/e0d5c19dbbecaabaa4f0fe802e8e4138178f38f9/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0d5c19dbbecaabaa4f0fe802e8e4138178f38f9/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs?ref=e0d5c19dbbecaabaa4f0fe802e8e4138178f38f9", "patch": "@@ -222,13 +222,9 @@ impl<'tcx> fmt::Display for LayoutError<'tcx> {\n }\n \n /// Enforce some basic invariants on layouts.\n-fn sanity_check_layout<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n-    layout: &TyAndLayout<'tcx>,\n-) {\n+fn sanity_check_layout<'tcx>(cx: &LayoutCx<'tcx, TyCtxt<'tcx>>, layout: &TyAndLayout<'tcx>) {\n     // Type-level uninhabitedness should always imply ABI uninhabitedness.\n-    if tcx.conservative_is_privately_uninhabited(param_env.and(layout.ty)) {\n+    if cx.tcx.conservative_is_privately_uninhabited(cx.param_env.and(layout.ty)) {\n         assert!(layout.abi.is_uninhabited());\n     }\n \n@@ -237,83 +233,182 @@ fn sanity_check_layout<'tcx>(\n     }\n \n     if cfg!(debug_assertions) {\n-        fn check_layout_abi<'tcx>(tcx: TyCtxt<'tcx>, layout: Layout<'tcx>) {\n-            match layout.abi() {\n+        /// Yields non-1-ZST fields of the type\n+        fn non_zst_fields<'tcx, 'a>(\n+            cx: &'a LayoutCx<'tcx, TyCtxt<'tcx>>,\n+            layout: &'a TyAndLayout<'tcx>,\n+        ) -> impl Iterator<Item = (Size, TyAndLayout<'tcx>)> + 'a {\n+            (0..layout.layout.fields().count()).filter_map(|i| {\n+                let field = layout.field(cx, i);\n+                let zst = field.is_zst() && field.align.abi.bytes() == 1;\n+                (!zst).then(|| (layout.fields.offset(i), field))\n+            })\n+        }\n+\n+        fn skip_newtypes<'tcx>(\n+            cx: &LayoutCx<'tcx, TyCtxt<'tcx>>,\n+            layout: &TyAndLayout<'tcx>,\n+        ) -> TyAndLayout<'tcx> {\n+            if matches!(layout.layout.variants(), Variants::Multiple { .. }) {\n+                // Definitely not a newtype of anything.\n+                return *layout;\n+            }\n+            let mut fields = non_zst_fields(cx, layout);\n+            let Some(first) = fields.next() else {\n+                // No fields here, so this could be a primitive or enum -- either way it's not a newtype around a thing\n+                return *layout\n+            };\n+            if fields.next().is_none() {\n+                let (offset, first) = first;\n+                if offset == Size::ZERO && first.layout.size() == layout.size {\n+                    // This is a newtype, so keep recursing.\n+                    // FIXME(RalfJung): I don't think it would be correct to do any checks for\n+                    // alignment here, so we don't. Is that correct?\n+                    return skip_newtypes(cx, &first);\n+                }\n+            }\n+            // No more newtypes here.\n+            *layout\n+        }\n+\n+        fn check_layout_abi<'tcx>(cx: &LayoutCx<'tcx, TyCtxt<'tcx>>, layout: &TyAndLayout<'tcx>) {\n+            match layout.layout.abi() {\n                 Abi::Scalar(scalar) => {\n                     // No padding in scalars.\n+                    let size = scalar.size(cx);\n+                    let align = scalar.align(cx).abi;\n                     assert_eq!(\n-                        layout.align().abi,\n-                        scalar.align(&tcx).abi,\n-                        \"alignment mismatch between ABI and layout in {layout:#?}\"\n+                        layout.layout.size(),\n+                        size,\n+                        \"size mismatch between ABI and layout in {layout:#?}\"\n                     );\n                     assert_eq!(\n-                        layout.size(),\n-                        scalar.size(&tcx),\n-                        \"size mismatch between ABI and layout in {layout:#?}\"\n+                        layout.layout.align().abi,\n+                        align,\n+                        \"alignment mismatch between ABI and layout in {layout:#?}\"\n                     );\n+                    // Check that this matches the underlying field.\n+                    let inner = skip_newtypes(cx, layout);\n+                    assert!(\n+                        matches!(inner.layout.abi(), Abi::Scalar(_)),\n+                        \"`Scalar` type {} is newtype around non-`Scalar` type {}\",\n+                        layout.ty,\n+                        inner.ty\n+                    );\n+                    match inner.layout.fields() {\n+                        FieldsShape::Primitive => {\n+                            // Fine.\n+                        }\n+                        FieldsShape::Arbitrary { .. } => {\n+                            // Should be an enum, the only field is the discriminant.\n+                            assert!(\n+                                inner.ty.is_enum(),\n+                                \"`Scalar` layout for non-primitive non-enum type {}\",\n+                                inner.ty\n+                            );\n+                            assert_eq!(\n+                                inner.layout.fields().count(),\n+                                1,\n+                                \"`Scalar` layout for multiple-field type in {inner:#?}\",\n+                            );\n+                            let offset = inner.layout.fields().offset(0);\n+                            let field = inner.field(cx, 0);\n+                            // The field should be at the right offset, and match the `scalar` layout.\n+                            assert_eq!(\n+                                offset,\n+                                Size::ZERO,\n+                                \"`Scalar` field at non-0 offset in {inner:#?}\",\n+                            );\n+                            assert_eq!(\n+                                field.size, size,\n+                                \"`Scalar` field with bad size in {inner:#?}\",\n+                            );\n+                            assert_eq!(\n+                                field.align.abi, align,\n+                                \"`Scalar` field with bad align in {inner:#?}\",\n+                            );\n+                        }\n+                        _ => {\n+                            panic!(\"`Scalar` layout for non-primitive non-enum type {}\", inner.ty);\n+                        }\n+                    }\n                 }\n                 Abi::Vector { count, element } => {\n                     // No padding in vectors. Alignment can be strengthened, though.\n                     assert!(\n-                        layout.align().abi >= element.align(&tcx).abi,\n+                        layout.layout.align().abi >= element.align(cx).abi,\n                         \"alignment mismatch between ABI and layout in {layout:#?}\"\n                     );\n-                    let size = element.size(&tcx) * count;\n+                    let size = element.size(cx) * count;\n                     assert_eq!(\n-                        layout.size(),\n-                        size.align_to(tcx.data_layout().vector_align(size).abi),\n+                        layout.layout.size(),\n+                        size.align_to(cx.data_layout().vector_align(size).abi),\n                         \"size mismatch between ABI and layout in {layout:#?}\"\n                     );\n                 }\n                 Abi::ScalarPair(scalar1, scalar2) => {\n                     // Sanity-check scalar pairs. These are a bit more flexible and support\n                     // padding, but we can at least ensure both fields actually fit into the layout\n                     // and the alignment requirement has not been weakened.\n-                    let align1 = scalar1.align(&tcx).abi;\n-                    let align2 = scalar2.align(&tcx).abi;\n+                    let align1 = scalar1.align(cx).abi;\n+                    let align2 = scalar2.align(cx).abi;\n                     assert!(\n-                        layout.align().abi >= cmp::max(align1, align2),\n+                        layout.layout.align().abi >= cmp::max(align1, align2),\n                         \"alignment mismatch between ABI and layout in {layout:#?}\",\n                     );\n-                    let field2_offset = scalar1.size(&tcx).align_to(align2);\n+                    let field2_offset = scalar1.size(cx).align_to(align2);\n                     assert!(\n-                        layout.size() >= field2_offset + scalar2.size(&tcx),\n+                        layout.layout.size() >= field2_offset + scalar2.size(cx),\n                         \"size mismatch between ABI and layout in {layout:#?}\"\n                     );\n                 }\n                 Abi::Uninhabited | Abi::Aggregate { .. } => {} // Nothing to check.\n             }\n         }\n \n-        check_layout_abi(tcx, layout.layout);\n+        check_layout_abi(cx, layout);\n \n         if let Variants::Multiple { variants, .. } = &layout.variants {\n-            for variant in variants {\n-                check_layout_abi(tcx, *variant);\n+            for variant in variants.iter() {\n                 // No nested \"multiple\".\n                 assert!(matches!(variant.variants(), Variants::Single { .. }));\n-                // Skip empty variants.\n-                if variant.size() == Size::ZERO\n-                    || variant.fields().count() == 0\n-                    || variant.abi().is_uninhabited()\n-                {\n-                    // These are never actually accessed anyway, so we can skip them. (Note that\n-                    // sometimes, variants with fields have size 0, and sometimes, variants without\n-                    // fields have non-0 size.)\n-                    continue;\n-                }\n-                // Variants should have the same or a smaller size as the full thing.\n+                // Variants should have the same or a smaller size as the full thing,\n+                // and same for alignment.\n                 if variant.size() > layout.size {\n                     bug!(\n                         \"Type with size {} bytes has variant with size {} bytes: {layout:#?}\",\n                         layout.size.bytes(),\n                         variant.size().bytes(),\n                     )\n                 }\n+                if variant.align().abi > layout.align.abi {\n+                    bug!(\n+                        \"Type with alignment {} bytes has variant with alignment {} bytes: {layout:#?}\",\n+                        layout.align.abi.bytes(),\n+                        variant.align().abi.bytes(),\n+                    )\n+                }\n+                // Skip empty variants.\n+                if variant.size() == Size::ZERO\n+                    || variant.fields().count() == 0\n+                    || variant.abi().is_uninhabited()\n+                {\n+                    // These are never actually accessed anyway, so we can skip the coherence check\n+                    // for them. They also fail that check, since they have\n+                    // `Aggregate`/`Uninhbaited` ABI even when the main type is\n+                    // `Scalar`/`ScalarPair`. (Note that sometimes, variants with fields have size\n+                    // 0, and sometimes, variants without fields have non-0 size.)\n+                    continue;\n+                }\n                 // The top-level ABI and the ABI of the variants should be coherent.\n+                let scalar_coherent = |s1: Scalar, s2: Scalar| {\n+                    s1.size(cx) == s2.size(cx) && s1.align(cx) == s2.align(cx)\n+                };\n                 let abi_coherent = match (layout.abi, variant.abi()) {\n-                    (Abi::Scalar(..), Abi::Scalar(..)) => true,\n-                    (Abi::ScalarPair(..), Abi::ScalarPair(..)) => true,\n+                    (Abi::Scalar(s1), Abi::Scalar(s2)) => scalar_coherent(s1, s2),\n+                    (Abi::ScalarPair(a1, b1), Abi::ScalarPair(a2, b2)) => {\n+                        scalar_coherent(a1, a2) && scalar_coherent(b1, b2)\n+                    }\n                     (Abi::Uninhabited, _) => true,\n                     (Abi::Aggregate { .. }, _) => true,\n                     _ => false,\n@@ -372,7 +467,7 @@ fn layout_of<'tcx>(\n \n             cx.record_layout_for_printing(layout);\n \n-            sanity_check_layout(tcx, param_env, &layout);\n+            sanity_check_layout(&cx, &layout);\n \n             Ok(layout)\n         })"}]}