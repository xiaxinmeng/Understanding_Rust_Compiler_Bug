{"sha": "81d7cbbbe23ae85e9f9003fec65ba1959af16513", "node_id": "C_kwDOAAsO6NoAKDgxZDdjYmJiZTIzYWU4NWU5ZjkwMDNmZWM2NWJhMTk1OWFmMTY1MTM", "commit": {"author": {"name": "Wang Ruochen", "email": "wrc@ruo-chen.wang", "date": "2022-05-05T17:14:11Z"}, "committer": {"name": "Wang Ruochen", "email": "wrc@ruo-chen.wang", "date": "2022-05-05T17:14:11Z"}, "message": "Avoid allocations", "tree": {"sha": "f8e19e7bd85a61e64803686c25396d34db2a57b8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f8e19e7bd85a61e64803686c25396d34db2a57b8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/81d7cbbbe23ae85e9f9003fec65ba1959af16513", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/81d7cbbbe23ae85e9f9003fec65ba1959af16513", "html_url": "https://github.com/rust-lang/rust/commit/81d7cbbbe23ae85e9f9003fec65ba1959af16513", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/81d7cbbbe23ae85e9f9003fec65ba1959af16513/comments", "author": {"login": "weirane", "id": 37568244, "node_id": "MDQ6VXNlcjM3NTY4MjQ0", "avatar_url": "https://avatars.githubusercontent.com/u/37568244?v=4", "gravatar_id": "", "url": "https://api.github.com/users/weirane", "html_url": "https://github.com/weirane", "followers_url": "https://api.github.com/users/weirane/followers", "following_url": "https://api.github.com/users/weirane/following{/other_user}", "gists_url": "https://api.github.com/users/weirane/gists{/gist_id}", "starred_url": "https://api.github.com/users/weirane/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/weirane/subscriptions", "organizations_url": "https://api.github.com/users/weirane/orgs", "repos_url": "https://api.github.com/users/weirane/repos", "events_url": "https://api.github.com/users/weirane/events{/privacy}", "received_events_url": "https://api.github.com/users/weirane/received_events", "type": "User", "site_admin": false}, "committer": {"login": "weirane", "id": 37568244, "node_id": "MDQ6VXNlcjM3NTY4MjQ0", "avatar_url": "https://avatars.githubusercontent.com/u/37568244?v=4", "gravatar_id": "", "url": "https://api.github.com/users/weirane", "html_url": "https://github.com/weirane", "followers_url": "https://api.github.com/users/weirane/followers", "following_url": "https://api.github.com/users/weirane/following{/other_user}", "gists_url": "https://api.github.com/users/weirane/gists{/gist_id}", "starred_url": "https://api.github.com/users/weirane/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/weirane/subscriptions", "organizations_url": "https://api.github.com/users/weirane/orgs", "repos_url": "https://api.github.com/users/weirane/repos", "events_url": "https://api.github.com/users/weirane/events{/privacy}", "received_events_url": "https://api.github.com/users/weirane/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a70beea9e9c0ffd226708abdb6a2860f7a32be19", "url": "https://api.github.com/repos/rust-lang/rust/commits/a70beea9e9c0ffd226708abdb6a2860f7a32be19", "html_url": "https://github.com/rust-lang/rust/commit/a70beea9e9c0ffd226708abdb6a2860f7a32be19"}], "stats": {"total": 69, "additions": 37, "deletions": 32}, "files": [{"sha": "e7560b0c18bf10f6535d9ef1c9602e0ba3a62985", "filename": "crates/ide-assists/src/handlers/convert_let_else_to_match.rs", "status": "modified", "additions": 37, "deletions": 32, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/81d7cbbbe23ae85e9f9003fec65ba1959af16513/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_let_else_to_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81d7cbbbe23ae85e9f9003fec65ba1959af16513/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_let_else_to_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_let_else_to_match.rs?ref=81d7cbbbe23ae85e9f9003fec65ba1959af16513", "patch": "@@ -1,73 +1,77 @@\n-use syntax::ast::{edit::AstNodeEdit, AstNode, HasName, LetStmt, Pat};\n+use hir::Semantics;\n+use ide_db::RootDatabase;\n+use syntax::ast::{edit::AstNodeEdit, AstNode, HasName, LetStmt, Name, Pat};\n use syntax::T;\n \n use crate::{AssistContext, AssistId, AssistKind, Assists};\n \n /// Gets a list of binders in a pattern, and whether they are mut.\n-fn binders_in_pat(pat: &Pat) -> Option<Vec<(String, bool)>> {\n+fn binders_in_pat(\n+    acc: &mut Vec<(Name, bool)>,\n+    pat: &Pat,\n+    sem: &Semantics<RootDatabase>,\n+) -> Option<()> {\n     use Pat::*;\n     match pat {\n         IdentPat(p) => {\n-            let ident = p.name()?.text().to_string();\n+            let ident = p.name()?;\n             let ismut = p.ref_token().is_none() && p.mut_token().is_some();\n-            let mut res = vec![(ident, ismut)];\n+            acc.push((ident, ismut));\n             if let Some(inner) = p.pat() {\n-                res.extend(binders_in_pat(&inner)?);\n+                binders_in_pat(acc, &inner, sem)?;\n             }\n-            Some(res)\n+            Some(())\n         }\n-        BoxPat(p) => p.pat().and_then(|p| binders_in_pat(&p)),\n-        RestPat(_) | LiteralPat(_) | PathPat(_) | WildcardPat(_) | ConstBlockPat(_) => Some(vec![]),\n+        BoxPat(p) => p.pat().and_then(|p| binders_in_pat(acc, &p, sem)),\n+        RestPat(_) | LiteralPat(_) | PathPat(_) | WildcardPat(_) | ConstBlockPat(_) => Some(()),\n         OrPat(p) => {\n-            let mut v = vec![];\n             for p in p.pats() {\n-                v.extend(binders_in_pat(&p)?);\n+                binders_in_pat(acc, &p, sem)?;\n             }\n-            Some(v)\n+            Some(())\n         }\n-        ParenPat(p) => p.pat().and_then(|p| binders_in_pat(&p)),\n+        ParenPat(p) => p.pat().and_then(|p| binders_in_pat(acc, &p, sem)),\n         RangePat(p) => {\n-            let mut start = if let Some(st) = p.start() { binders_in_pat(&st)? } else { vec![] };\n-            let end = if let Some(st) = p.end() { binders_in_pat(&st)? } else { vec![] };\n-            start.extend(end);\n-            Some(start)\n+            if let Some(st) = p.start() {\n+                binders_in_pat(acc, &st, sem)?\n+            }\n+            if let Some(ed) = p.end() {\n+                binders_in_pat(acc, &ed, sem)?\n+            }\n+            Some(())\n         }\n         RecordPat(p) => {\n-            let mut v = vec![];\n             for f in p.record_pat_field_list()?.fields() {\n                 let pat = f.pat()?;\n-                v.extend(binders_in_pat(&pat)?);\n+                binders_in_pat(acc, &pat, sem)?;\n             }\n-            Some(v)\n+            Some(())\n         }\n-        RefPat(p) => p.pat().and_then(|p| binders_in_pat(&p)),\n+        RefPat(p) => p.pat().and_then(|p| binders_in_pat(acc, &p, sem)),\n         SlicePat(p) => {\n-            let mut v = vec![];\n             for p in p.pats() {\n-                v.extend(binders_in_pat(&p)?);\n+                binders_in_pat(acc, &p, sem)?;\n             }\n-            Some(v)\n+            Some(())\n         }\n         TuplePat(p) => {\n-            let mut v = vec![];\n             for p in p.fields() {\n-                v.extend(binders_in_pat(&p)?);\n+                binders_in_pat(acc, &p, sem)?;\n             }\n-            Some(v)\n+            Some(())\n         }\n         TupleStructPat(p) => {\n-            let mut v = vec![];\n             for p in p.fields() {\n-                v.extend(binders_in_pat(&p)?);\n+                binders_in_pat(acc, &p, sem)?;\n             }\n-            Some(v)\n+            Some(())\n         }\n         // don't support macro pat yet\n         MacroPat(_) => None,\n     }\n }\n \n-fn binders_to_str(binders: &[(String, bool)], addmut: bool) -> String {\n+fn binders_to_str(binders: &[(Name, bool)], addmut: bool) -> String {\n     let vars = binders\n         .iter()\n         .map(\n@@ -119,7 +123,8 @@ pub(crate) fn convert_let_else_to_match(acc: &mut Assists, ctx: &AssistContext)\n         return None;\n     }\n     let pat = let_stmt.pat()?;\n-    let binders = binders_in_pat(&pat)?;\n+    let mut binders = Vec::new();\n+    binders_in_pat(&mut binders, &pat, &ctx.sema)?;\n \n     let target = let_stmt.syntax().text_range();\n     acc.add(\n@@ -139,7 +144,7 @@ pub(crate) fn convert_let_else_to_match(acc: &mut Assists, ctx: &AssistContext)\n             // remove the mut from the pattern\n             for (b, ismut) in binders.iter() {\n                 if *ismut {\n-                    pat_no_mut = pat_no_mut.replace(&format!(\"mut {b}\"), b);\n+                    pat_no_mut = pat_no_mut.replace(&format!(\"mut {b}\"), &b.to_string());\n                 }\n             }\n "}]}