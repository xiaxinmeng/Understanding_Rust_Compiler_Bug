{"sha": "dbf0372b722fe2137cca22504b23de2bd3a87eef", "node_id": "C_kwDOAAsO6NoAKGRiZjAzNzJiNzIyZmUyMTM3Y2NhMjI1MDRiMjNkZTJiZDNhODdlZWY", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-03-03T10:02:51Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-03-03T10:02:51Z"}, "message": "Rollup merge of #94484 - c410-f3r:more-let-chains, r=jackh726\n\n8 - Make more use of `let_chains`\n\nContinuation of #94376.\n\ncc #53667", "tree": {"sha": "d96031b9e760e6217062d107e789565d16283f70", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d96031b9e760e6217062d107e789565d16283f70"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dbf0372b722fe2137cca22504b23de2bd3a87eef", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiIJJLCRBK7hj4Ov3rIwAAmM4IACNQZTHxwnZtppIs7dBjWmV3\n1vqr+7hrlaLdJm3b8UyDqazZqybPG3V4AxeaCSpUjueL6zRhmAeE0FneOfGrdFAg\nOFq/w9D4QC8kC2Zkk+tLr1HaHcUfKtAGDBgr8BiefX0KHnikj6YthhTLVGcBmhbe\n+Ad0ETalAk9UdXYqlIJoMhdSR6L4hzSD7Iu1W2ZBwLfmxvz+vu+xyvNdk+8Qn6Nd\no0sKRraZWVE2qkvIh6xpKKuCSChHocCrnzNYoA9LmXl4vBUkCBLqwAUg6YlWQdVv\nd0sLnpMT+T37Zxw4scleqG2S0DH0YUoDcRl3P4IGtQIHDrR/qe5wTN9nBTrrCTw=\n=VmR1\n-----END PGP SIGNATURE-----\n", "payload": "tree d96031b9e760e6217062d107e789565d16283f70\nparent 850511d483a730ea10f77df5cbf2367ae33f93ce\nparent 658ff942b04d288b346a7e89ac425216688fac78\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1646301771 +0100\ncommitter GitHub <noreply@github.com> 1646301771 +0100\n\nRollup merge of #94484 - c410-f3r:more-let-chains, r=jackh726\n\n8 - Make more use of `let_chains`\n\nContinuation of #94376.\n\ncc #53667\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dbf0372b722fe2137cca22504b23de2bd3a87eef", "html_url": "https://github.com/rust-lang/rust/commit/dbf0372b722fe2137cca22504b23de2bd3a87eef", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dbf0372b722fe2137cca22504b23de2bd3a87eef/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "850511d483a730ea10f77df5cbf2367ae33f93ce", "url": "https://api.github.com/repos/rust-lang/rust/commits/850511d483a730ea10f77df5cbf2367ae33f93ce", "html_url": "https://github.com/rust-lang/rust/commit/850511d483a730ea10f77df5cbf2367ae33f93ce"}, {"sha": "658ff942b04d288b346a7e89ac425216688fac78", "url": "https://api.github.com/repos/rust-lang/rust/commits/658ff942b04d288b346a7e89ac425216688fac78", "html_url": "https://github.com/rust-lang/rust/commit/658ff942b04d288b346a7e89ac425216688fac78"}], "stats": {"total": 330, "additions": 145, "deletions": 185}, "files": [{"sha": "bf4882d4595730537318ffde91e49cdb1d86e048", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 35, "deletions": 42, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/dbf0372b722fe2137cca22504b23de2bd3a87eef/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbf0372b722fe2137cca22504b23de2bd3a87eef/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=dbf0372b722fe2137cca22504b23de2bd3a87eef", "patch": "@@ -606,17 +606,16 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     // don't show type `_`\n                     err.span_label(span, format!(\"this expression has type `{}`\", ty));\n                 }\n-                if let Some(ty::error::ExpectedFound { found, .. }) = exp_found {\n-                    if ty.is_box() && ty.boxed_ty() == found {\n-                        if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(span) {\n-                            err.span_suggestion(\n-                                span,\n-                                \"consider dereferencing the boxed value\",\n-                                format!(\"*{}\", snippet),\n-                                Applicability::MachineApplicable,\n-                            );\n-                        }\n-                    }\n+                if let Some(ty::error::ExpectedFound { found, .. }) = exp_found\n+                    && ty.is_box() && ty.boxed_ty() == found\n+                    && let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(span)\n+                {\n+                    err.span_suggestion(\n+                        span,\n+                        \"consider dereferencing the boxed value\",\n+                        format!(\"*{}\", snippet),\n+                        Applicability::MachineApplicable,\n+                    );\n                 }\n             }\n             ObligationCauseCode::Pattern { origin_expr: false, span: Some(span), .. } => {\n@@ -1748,13 +1747,12 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         self.check_and_note_conflicting_crates(diag, terr);\n         self.tcx.note_and_explain_type_err(diag, terr, cause, span, body_owner_def_id.to_def_id());\n \n-        if let Some(ValuePairs::PolyTraitRefs(exp_found)) = values {\n-            if let ty::Closure(def_id, _) = exp_found.expected.skip_binder().self_ty().kind() {\n-                if let Some(def_id) = def_id.as_local() {\n-                    let span = self.tcx.def_span(def_id);\n-                    diag.span_note(span, \"this closure does not fulfill the lifetime requirements\");\n-                }\n-            }\n+        if let Some(ValuePairs::PolyTraitRefs(exp_found)) = values\n+            && let ty::Closure(def_id, _) = exp_found.expected.skip_binder().self_ty().kind()\n+            && let Some(def_id) = def_id.as_local()\n+        {\n+            let span = self.tcx.def_span(def_id);\n+            diag.span_note(span, \"this closure does not fulfill the lifetime requirements\");\n         }\n \n         // It reads better to have the error origin as the final\n@@ -2046,19 +2044,16 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                         // containing a single character, perhaps the user meant to write `'c'` to\n                         // specify a character literal (issue #92479)\n                         (ty::Char, ty::Ref(_, r, _)) if r.is_str() => {\n-                            if let Ok(code) = self.tcx.sess().source_map().span_to_snippet(span) {\n-                                if let Some(code) =\n-                                    code.strip_prefix('\"').and_then(|s| s.strip_suffix('\"'))\n-                                {\n-                                    if code.chars().count() == 1 {\n-                                        err.span_suggestion(\n-                                            span,\n-                                            \"if you meant to write a `char` literal, use single quotes\",\n-                                            format!(\"'{}'\", code),\n-                                            Applicability::MachineApplicable,\n-                                        );\n-                                    }\n-                                }\n+                            if let Ok(code) = self.tcx.sess().source_map().span_to_snippet(span)\n+                                && let Some(code) = code.strip_prefix('\"').and_then(|s| s.strip_suffix('\"'))\n+                                && code.chars().count() == 1\n+                            {\n+                                err.span_suggestion(\n+                                    span,\n+                                    \"if you meant to write a `char` literal, use single quotes\",\n+                                    format!(\"'{}'\", code),\n+                                    Applicability::MachineApplicable,\n+                                );\n                             }\n                         }\n                         // If a string was expected and the found expression is a character literal,\n@@ -2080,18 +2075,16 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                         _ => {}\n                     }\n                 }\n-                if let MatchExpressionArm(box MatchExpressionArmCause { source, .. }) =\n-                    *trace.cause.code()\n+                let code = trace.cause.code();\n+                if let &MatchExpressionArm(box MatchExpressionArmCause { source, .. }) = code\n+                    && let hir::MatchSource::TryDesugar = source\n+                    && let Some((expected_ty, found_ty)) = self.values_str(trace.values)\n                 {\n-                    if let hir::MatchSource::TryDesugar = source {\n-                        if let Some((expected_ty, found_ty)) = self.values_str(trace.values) {\n-                            err.note(&format!(\n-                                \"`?` operator cannot convert from `{}` to `{}`\",\n-                                found_ty.content(),\n-                                expected_ty.content(),\n-                            ));\n-                        }\n-                    }\n+                    err.note(&format!(\n+                        \"`?` operator cannot convert from `{}` to `{}`\",\n+                        found_ty.content(),\n+                        expected_ty.content(),\n+                    ));\n                 }\n                 err\n             }"}, {"sha": "3bc30f0220d40f64217375936a9bcf802d7f1d32", "filename": "compiler/rustc_infer/src/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 41, "deletions": 48, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/dbf0372b722fe2137cca22504b23de2bd3a87eef/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbf0372b722fe2137cca22504b23de2bd3a87eef/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=dbf0372b722fe2137cca22504b23de2bd3a87eef", "patch": "@@ -114,28 +114,25 @@ impl<'a, 'tcx> Visitor<'tcx> for FindHirNodeVisitor<'a, 'tcx> {\n     }\n \n     fn visit_expr(&mut self, expr: &'tcx Expr<'tcx>) {\n-        if let ExprKind::Match(scrutinee, [_, arm], MatchSource::ForLoopDesugar) = expr.kind {\n-            if let Some(pat) = arm.pat.for_loop_some() {\n-                if let Some(ty) = self.node_ty_contains_target(pat.hir_id) {\n-                    self.found_for_loop_iter = Some(scrutinee);\n-                    self.found_node_ty = Some(ty);\n-                    return;\n-                }\n-            }\n+        if let ExprKind::Match(scrutinee, [_, arm], MatchSource::ForLoopDesugar) = expr.kind\n+            && let Some(pat) = arm.pat.for_loop_some()\n+            && let Some(ty) = self.node_ty_contains_target(pat.hir_id)\n+        {\n+            self.found_for_loop_iter = Some(scrutinee);\n+            self.found_node_ty = Some(ty);\n+            return;\n         }\n-        if let ExprKind::MethodCall(segment, exprs, _) = expr.kind {\n-            if segment.ident.span == self.target_span\n-                && Some(self.target)\n-                    == self.infcx.in_progress_typeck_results.and_then(|typeck_results| {\n-                        typeck_results\n-                            .borrow()\n-                            .node_type_opt(exprs.first().unwrap().hir_id)\n-                            .map(Into::into)\n-                    })\n-            {\n-                self.found_exact_method_call = Some(&expr);\n-                return;\n-            }\n+        if let ExprKind::MethodCall(segment, exprs, _) = expr.kind\n+            && segment.ident.span == self.target_span\n+            && Some(self.target) == self.infcx.in_progress_typeck_results.and_then(|typeck_results| {\n+                typeck_results\n+                    .borrow()\n+                    .node_type_opt(exprs.first().unwrap().hir_id)\n+                    .map(Into::into)\n+            })\n+        {\n+            self.found_exact_method_call = Some(&expr);\n+            return;\n         }\n \n         // FIXME(const_generics): Currently, any uninferred `const` generics arguments\n@@ -602,10 +599,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         );\n \n         let use_diag = local_visitor.found_use_diagnostic.as_ref();\n-        if let Some(use_diag) = use_diag {\n-            if use_diag.applies_to(err_span) {\n-                use_diag.attach_note(&mut err);\n-            }\n+        if let Some(use_diag) = use_diag && use_diag.applies_to(err_span) {\n+            use_diag.attach_note(&mut err);\n         }\n \n         let param_type = arg_data.kind.descr();\n@@ -736,29 +731,27 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 //    |               help: specify type like: `<Impl as Into<u32>>::into(foo_impl)`\n                 //    |\n                 //    = note: cannot satisfy `Impl: Into<_>`\n-                if !impl_candidates.is_empty() && e.span.contains(span) {\n-                    if let Some(expr) = exprs.first() {\n-                        if let ExprKind::Path(hir::QPath::Resolved(_, path)) = expr.kind {\n-                            if let [path_segment] = path.segments {\n-                                let candidate_len = impl_candidates.len();\n-                                let suggestions = impl_candidates.iter().map(|candidate| {\n-                                    format!(\n-                                        \"{}::{}({})\",\n-                                        candidate, segment.ident, path_segment.ident\n-                                    )\n-                                });\n-                                err.span_suggestions(\n-                                    e.span,\n-                                    &format!(\n-                                        \"use the fully qualified path for the potential candidate{}\",\n-                                        pluralize!(candidate_len),\n-                                    ),\n-                                    suggestions,\n-                                    Applicability::MaybeIncorrect,\n-                                );\n-                            }\n-                        }\n-                    };\n+                if !impl_candidates.is_empty() && e.span.contains(span)\n+                    && let Some(expr) = exprs.first()\n+                    && let ExprKind::Path(hir::QPath::Resolved(_, path)) = expr.kind\n+                    && let [path_segment] = path.segments\n+                {\n+                    let candidate_len = impl_candidates.len();\n+                    let suggestions = impl_candidates.iter().map(|candidate| {\n+                        format!(\n+                            \"{}::{}({})\",\n+                            candidate, segment.ident, path_segment.ident\n+                        )\n+                    });\n+                    err.span_suggestions(\n+                        e.span,\n+                        &format!(\n+                            \"use the fully qualified path for the potential candidate{}\",\n+                            pluralize!(candidate_len),\n+                        ),\n+                        suggestions,\n+                        Applicability::MaybeIncorrect,\n+                    );\n                 }\n                 // Suggest specifying type params or point out the return type of the call:\n                 //"}, {"sha": "99dd418015b14e8fa3c43fbb625624aca29453d2", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/static_impl_trait.rs", "status": "modified", "additions": 22, "deletions": 25, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/dbf0372b722fe2137cca22504b23de2bd3a87eef/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbf0372b722fe2137cca22504b23de2bd3a87eef/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs?ref=dbf0372b722fe2137cca22504b23de2bd3a87eef", "patch": "@@ -223,35 +223,32 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n         let fn_returns = tcx.return_type_impl_or_dyn_traits(anon_reg_sup.def_id);\n \n         let mut override_error_code = None;\n-        if let SubregionOrigin::Subtype(box TypeTrace { cause, .. }) = &sup_origin {\n-            if let ObligationCauseCode::UnifyReceiver(ctxt) = cause.code() {\n-                // Handle case of `impl Foo for dyn Bar { fn qux(&self) {} }` introducing a\n-                // `'static` lifetime when called as a method on a binding: `bar.qux()`.\n-                if self.find_impl_on_dyn_trait(&mut err, param.param_ty, &ctxt) {\n-                    override_error_code = Some(ctxt.assoc_item.name);\n-                }\n-            }\n+        if let SubregionOrigin::Subtype(box TypeTrace { cause, .. }) = &sup_origin\n+            && let ObligationCauseCode::UnifyReceiver(ctxt) = cause.code()\n+            // Handle case of `impl Foo for dyn Bar { fn qux(&self) {} }` introducing a\n+            // `'static` lifetime when called as a method on a binding: `bar.qux()`.\n+            && self.find_impl_on_dyn_trait(&mut err, param.param_ty, &ctxt)\n+        {\n+            override_error_code = Some(ctxt.assoc_item.name);\n         }\n-        if let SubregionOrigin::Subtype(box TypeTrace { cause, .. }) = &sub_origin {\n-            let code = match cause.code() {\n+\n+        if let SubregionOrigin::Subtype(box TypeTrace { cause, .. }) = &sub_origin\n+            && let code = match cause.code() {\n                 ObligationCauseCode::MatchImpl(parent, ..) => parent.code(),\n                 _ => cause.code(),\n-            };\n-            if let (ObligationCauseCode::ItemObligation(item_def_id), None) =\n-                (code, override_error_code)\n+            }\n+            && let (ObligationCauseCode::ItemObligation(item_def_id), None) = (code, override_error_code)\n+        {\n+            // Same case of `impl Foo for dyn Bar { fn qux(&self) {} }` introducing a `'static`\n+            // lifetime as above, but called using a fully-qualified path to the method:\n+            // `Foo::qux(bar)`.\n+            let mut v = TraitObjectVisitor(FxHashSet::default());\n+            v.visit_ty(param.param_ty);\n+            if let Some((ident, self_ty)) =\n+                self.get_impl_ident_and_self_ty_from_trait(*item_def_id, &v.0)\n+                && self.suggest_constrain_dyn_trait_in_impl(&mut err, &v.0, ident, self_ty)\n             {\n-                // Same case of `impl Foo for dyn Bar { fn qux(&self) {} }` introducing a `'static`\n-                // lifetime as above, but called using a fully-qualified path to the method:\n-                // `Foo::qux(bar)`.\n-                let mut v = TraitObjectVisitor(FxHashSet::default());\n-                v.visit_ty(param.param_ty);\n-                if let Some((ident, self_ty)) =\n-                    self.get_impl_ident_and_self_ty_from_trait(*item_def_id, &v.0)\n-                {\n-                    if self.suggest_constrain_dyn_trait_in_impl(&mut err, &v.0, ident, self_ty) {\n-                        override_error_code = Some(ident.name);\n-                    }\n-                }\n+                override_error_code = Some(ident.name);\n             }\n         }\n         if let (Some(ident), true) = (override_error_code, fn_returns.is_empty()) {"}, {"sha": "3f0f50bb75af150f32cf25ae190e80142565047e", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/trait_impl_difference.rs", "status": "modified", "additions": 26, "deletions": 38, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/dbf0372b722fe2137cca22504b23de2bd3a87eef/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ftrait_impl_difference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbf0372b722fe2137cca22504b23de2bd3a87eef/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ftrait_impl_difference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ftrait_impl_difference.rs?ref=dbf0372b722fe2137cca22504b23de2bd3a87eef", "patch": "@@ -23,51 +23,39 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n         let error = self.error.as_ref()?;\n         debug!(\"try_report_impl_not_conforming_to_trait {:?}\", error);\n         if let RegionResolutionError::SubSupConflict(\n-            _,\n-            var_origin,\n-            sub_origin,\n-            _sub,\n-            sup_origin,\n-            _sup,\n-            _,\n-        ) = error.clone()\n+                _, var_origin, sub_origin, _sub, sup_origin, _sup, _,\n+            ) = error.clone()\n+            && let (&Subtype(ref sup_trace), &Subtype(ref sub_trace)) = (&sup_origin, &sub_origin)\n+            && let (\n+                sub_expected_found @ Some((sub_expected, sub_found)),\n+                sup_expected_found @ Some(_),\n+                CompareImplMethodObligation { trait_item_def_id, .. },\n+            ) = (sub_trace.values.ty(), sup_trace.values.ty(), sub_trace.cause.code())\n+            && sup_expected_found == sub_expected_found\n         {\n-            if let (&Subtype(ref sup_trace), &Subtype(ref sub_trace)) = (&sup_origin, &sub_origin) {\n-                if let (\n-                    sub_expected_found @ Some((sub_expected, sub_found)),\n-                    sup_expected_found @ Some(_),\n-                    CompareImplMethodObligation { trait_item_def_id, .. },\n-                ) = (&sub_trace.values.ty(), &sup_trace.values.ty(), sub_trace.cause.code())\n-                {\n-                    if sup_expected_found == sub_expected_found {\n-                        self.emit_err(\n-                            var_origin.span(),\n-                            *sub_expected,\n-                            *sub_found,\n-                            *trait_item_def_id,\n-                        );\n-                        return Some(ErrorGuaranteed);\n-                    }\n-                }\n-            }\n+            self.emit_err(\n+                var_origin.span(),\n+                sub_expected,\n+                sub_found,\n+                *trait_item_def_id,\n+            );\n+            return Some(ErrorGuaranteed);\n         }\n         if let RegionResolutionError::ConcreteFailure(origin, _, _)\n-        | RegionResolutionError::GenericBoundFailure(origin, _, _) = error.clone()\n-        {\n-            if let SubregionOrigin::CompareImplTypeObligation {\n+            | RegionResolutionError::GenericBoundFailure(origin, _, _) = error.clone()\n+            && let SubregionOrigin::CompareImplTypeObligation {\n                 span,\n                 impl_item_def_id,\n                 trait_item_def_id,\n             } = origin\n-            {\n-                self.emit_associated_type_err(\n-                    span,\n-                    self.infcx.tcx.item_name(impl_item_def_id),\n-                    impl_item_def_id,\n-                    trait_item_def_id,\n-                );\n-                return Some(ErrorGuaranteed);\n-            }\n+        {\n+            self.emit_associated_type_err(\n+                span,\n+                self.infcx.tcx.item_name(impl_item_def_id),\n+                impl_item_def_id,\n+                trait_item_def_id,\n+            );\n+            return Some(ErrorGuaranteed);\n         }\n         None\n     }"}, {"sha": "c5b90f79dc284645c6e2143ad24e47f51afcc402", "filename": "compiler/rustc_infer/src/infer/fudge.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/dbf0372b722fe2137cca22504b23de2bd3a87eef/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffudge.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbf0372b722fe2137cca22504b23de2bd3a87eef/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffudge.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffudge.rs?ref=dbf0372b722fe2137cca22504b23de2bd3a87eef", "patch": "@@ -220,12 +220,10 @@ impl<'a, 'tcx> TypeFolder<'tcx> for InferenceFudger<'a, 'tcx> {\n     }\n \n     fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n-        if let ty::ReVar(vid) = *r {\n-            if self.region_vars.0.contains(&vid) {\n-                let idx = vid.index() - self.region_vars.0.start.index();\n-                let origin = self.region_vars.1[idx];\n-                return self.infcx.next_region_var(origin);\n-            }\n+        if let ty::ReVar(vid) = *r && self.region_vars.0.contains(&vid) {\n+            let idx = vid.index() - self.region_vars.0.start.index();\n+            let origin = self.region_vars.1[idx];\n+            return self.infcx.next_region_var(origin);\n         }\n         r\n     }"}, {"sha": "0f341a947ad35c451ecf692a318e2b576863107a", "filename": "compiler/rustc_infer/src/infer/lexical_region_resolve/mod.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/dbf0372b722fe2137cca22504b23de2bd3a87eef/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbf0372b722fe2137cca22504b23de2bd3a87eef/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flexical_region_resolve%2Fmod.rs?ref=dbf0372b722fe2137cca22504b23de2bd3a87eef", "patch": "@@ -304,10 +304,8 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n                 // check below for a common case, here purely as an\n                 // optimization.\n                 let b_universe = self.var_infos[b_vid].universe;\n-                if let ReEmpty(a_universe) = *a_region {\n-                    if a_universe == b_universe {\n-                        return false;\n-                    }\n+                if let ReEmpty(a_universe) = *a_region && a_universe == b_universe {\n+                    return false;\n                 }\n \n                 let mut lub = self.lub_concrete_regions(a_region, cur_region);\n@@ -324,10 +322,8 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n                 // tighter bound than `'static`.\n                 //\n                 // (This might e.g. arise from being asked to prove `for<'a> { 'b: 'a }`.)\n-                if let ty::RePlaceholder(p) = *lub {\n-                    if b_universe.cannot_name(p.universe) {\n-                        lub = self.tcx().lifetimes.re_static;\n-                    }\n+                if let ty::RePlaceholder(p) = *lub && b_universe.cannot_name(p.universe) {\n+                    lub = self.tcx().lifetimes.re_static;\n                 }\n \n                 debug!(\"Expanding value of {:?} from {:?} to {:?}\", b_vid, cur_region, lub);"}, {"sha": "69db6509b798dfa098b1936a04fd41e1b0750cf8", "filename": "compiler/rustc_infer/src/infer/nll_relate/mod.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dbf0372b722fe2137cca22504b23de2bd3a87eef/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbf0372b722fe2137cca22504b23de2bd3a87eef/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs?ref=dbf0372b722fe2137cca22504b23de2bd3a87eef", "patch": "@@ -963,10 +963,8 @@ where\n     ) -> RelateResult<'tcx, ty::Region<'tcx>> {\n         debug!(\"TypeGeneralizer::regions(a={:?})\", a);\n \n-        if let ty::ReLateBound(debruijn, _) = *a {\n-            if debruijn < self.first_free_index {\n-                return Ok(a);\n-            }\n+        if let ty::ReLateBound(debruijn, _) = *a && debruijn < self.first_free_index {\n+            return Ok(a);\n         }\n \n         // For now, we just always create a fresh region variable to"}, {"sha": "6966f5014464ed7c63a69e6d7f89bdd1ecd06c9c", "filename": "compiler/rustc_infer/src/infer/region_constraints/mod.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dbf0372b722fe2137cca22504b23de2bd3a87eef/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbf0372b722fe2137cca22504b23de2bd3a87eef/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fmod.rs?ref=dbf0372b722fe2137cca22504b23de2bd3a87eef", "patch": "@@ -470,10 +470,8 @@ impl<'tcx> RegionConstraintCollector<'_, 'tcx> {\n         debug!(\"RegionConstraintCollector: add_verify({:?})\", verify);\n \n         // skip no-op cases known to be satisfied\n-        if let VerifyBound::AllBounds(ref bs) = verify.bound {\n-            if bs.is_empty() {\n-                return;\n-            }\n+        if let VerifyBound::AllBounds(ref bs) = verify.bound && bs.is_empty() {\n+            return;\n         }\n \n         let index = self.data.verifys.len();"}, {"sha": "08e005364ce6410f13d313976fe80424f92ed2b7", "filename": "compiler/rustc_infer/src/lib.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/dbf0372b722fe2137cca22504b23de2bd3a87eef/compiler%2Frustc_infer%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbf0372b722fe2137cca22504b23de2bd3a87eef/compiler%2Frustc_infer%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Flib.rs?ref=dbf0372b722fe2137cca22504b23de2bd3a87eef", "patch": "@@ -12,18 +12,19 @@\n //!\n //! This API is completely unstable and subject to change.\n \n+#![allow(rustc::potential_query_instability)]\n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\")]\n #![feature(bool_to_option)]\n #![feature(box_patterns)]\n+#![feature(control_flow_enum)]\n #![feature(derive_default_enum)]\n #![feature(extend_one)]\n+#![feature(label_break_value)]\n+#![feature(let_chains)]\n #![feature(let_else)]\n-#![feature(never_type)]\n-#![feature(control_flow_enum)]\n #![feature(min_specialization)]\n-#![feature(label_break_value)]\n+#![feature(never_type)]\n #![recursion_limit = \"512\"] // For rustdoc\n-#![allow(rustc::potential_query_instability)]\n \n #[macro_use]\n extern crate rustc_macros;"}, {"sha": "c8ef08f48b609b265bbe4b49f70def7dc24edc3a", "filename": "compiler/rustc_infer/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/dbf0372b722fe2137cca22504b23de2bd3a87eef/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbf0372b722fe2137cca22504b23de2bd3a87eef/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=dbf0372b722fe2137cca22504b23de2bd3a87eef", "patch": "@@ -60,12 +60,10 @@ pub fn report_object_safety_error<'tcx>(\n     let mut multi_span = vec![];\n     let mut messages = vec![];\n     for violation in violations {\n-        if let ObjectSafetyViolation::SizedSelf(sp) = &violation {\n-            if !sp.is_empty() {\n-                // Do not report `SizedSelf` without spans pointing at `SizedSelf` obligations\n-                // with a `Span`.\n-                reported_violations.insert(ObjectSafetyViolation::SizedSelf(vec![].into()));\n-            }\n+        if let ObjectSafetyViolation::SizedSelf(sp) = &violation && !sp.is_empty() {\n+            // Do not report `SizedSelf` without spans pointing at `SizedSelf` obligations\n+            // with a `Span`.\n+            reported_violations.insert(ObjectSafetyViolation::SizedSelf(vec![].into()));\n         }\n         if reported_violations.insert(violation.clone()) {\n             let spans = violation.spans();"}]}