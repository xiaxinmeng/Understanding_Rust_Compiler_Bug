{"sha": "626abc797704009e4683be5d95dbeb9417999c82", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYyNmFiYzc5NzcwNDAwOWU0NjgzYmU1ZDk1ZGJlYjk0MTc5OTljODI=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2020-03-23T04:04:03Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2020-04-06T18:55:51Z"}, "message": "ty: remove `{Existential,}Trait{Ref,Predicate}::input_types`.", "tree": {"sha": "1dc4ab5081c2d70333e44899bf260bdfa1d38fdf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1dc4ab5081c2d70333e44899bf260bdfa1d38fdf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/626abc797704009e4683be5d95dbeb9417999c82", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/626abc797704009e4683be5d95dbeb9417999c82", "html_url": "https://github.com/rust-lang/rust/commit/626abc797704009e4683be5d95dbeb9417999c82", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/626abc797704009e4683be5d95dbeb9417999c82/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b7fdc7b619622c1f0700e35e5cffd8c1ca5d4a6c", "url": "https://api.github.com/repos/rust-lang/rust/commits/b7fdc7b619622c1f0700e35e5cffd8c1ca5d4a6c", "html_url": "https://github.com/rust-lang/rust/commit/b7fdc7b619622c1f0700e35e5cffd8c1ca5d4a6c"}], "stats": {"total": 210, "additions": 103, "deletions": 107}, "files": [{"sha": "1870856150f50a4342cb15c228ab5c3677d7728a", "filename": "src/librustc_middle/ty/mod.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/626abc797704009e4683be5d95dbeb9417999c82/src%2Flibrustc_middle%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/626abc797704009e4683be5d95dbeb9417999c82/src%2Flibrustc_middle%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fmod.rs?ref=626abc797704009e4683be5d95dbeb9417999c82", "patch": "@@ -1365,10 +1365,6 @@ impl<'tcx> TraitPredicate<'tcx> {\n         self.trait_ref.def_id\n     }\n \n-    pub fn input_types<'a>(&'a self) -> impl DoubleEndedIterator<Item = Ty<'tcx>> + 'a {\n-        self.trait_ref.input_types()\n-    }\n-\n     pub fn self_ty(&self) -> Ty<'tcx> {\n         self.trait_ref.self_ty()\n     }"}, {"sha": "f09327886872ceb4ba4c5e196fcc7ed867e09803", "filename": "src/librustc_middle/ty/sty.rs", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/626abc797704009e4683be5d95dbeb9417999c82/src%2Flibrustc_middle%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/626abc797704009e4683be5d95dbeb9417999c82/src%2Flibrustc_middle%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fsty.rs?ref=626abc797704009e4683be5d95dbeb9417999c82", "patch": "@@ -754,14 +754,6 @@ impl<'tcx> TraitRef<'tcx> {\n         self.substs.type_at(0)\n     }\n \n-    pub fn input_types<'a>(&'a self) -> impl DoubleEndedIterator<Item = Ty<'tcx>> + 'a {\n-        // Select only the \"input types\" from a trait-reference. For\n-        // now this is all the types that appear in the\n-        // trait-reference, but it should eventually exclude\n-        // associated types.\n-        self.substs.types()\n-    }\n-\n     pub fn from_method(\n         tcx: TyCtxt<'tcx>,\n         trait_id: DefId,\n@@ -805,14 +797,6 @@ pub struct ExistentialTraitRef<'tcx> {\n }\n \n impl<'tcx> ExistentialTraitRef<'tcx> {\n-    pub fn input_types<'b>(&'b self) -> impl DoubleEndedIterator<Item = Ty<'tcx>> + 'b {\n-        // Select only the \"input types\" from a trait-reference. For\n-        // now this is all the types that appear in the\n-        // trait-reference, but it should eventually exclude\n-        // associated types.\n-        self.substs.types()\n-    }\n-\n     pub fn erase_self_ty(\n         tcx: TyCtxt<'tcx>,\n         trait_ref: ty::TraitRef<'tcx>,"}, {"sha": "f1311382c544771278c6adcbb34b33f1c301e7d9", "filename": "src/librustc_trait_selection/traits/coherence.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/626abc797704009e4683be5d95dbeb9417999c82/src%2Flibrustc_trait_selection%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/626abc797704009e4683be5d95dbeb9417999c82/src%2Flibrustc_trait_selection%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fcoherence.rs?ref=626abc797704009e4683be5d95dbeb9417999c82", "patch": "@@ -393,8 +393,11 @@ fn orphan_check_trait_ref<'tcx>(\n     }\n \n     let mut non_local_spans = vec![];\n-    for (i, input_ty) in\n-        trait_ref.input_types().flat_map(|ty| uncover_fundamental_ty(tcx, ty, in_crate)).enumerate()\n+    for (i, input_ty) in trait_ref\n+        .substs\n+        .types()\n+        .flat_map(|ty| uncover_fundamental_ty(tcx, ty, in_crate))\n+        .enumerate()\n     {\n         debug!(\"orphan_check_trait_ref: check ty `{:?}`\", input_ty);\n         let non_local_tys = ty_is_non_local(tcx, input_ty, in_crate);\n@@ -404,7 +407,8 @@ fn orphan_check_trait_ref<'tcx>(\n         } else if let ty::Param(_) = input_ty.kind {\n             debug!(\"orphan_check_trait_ref: uncovered ty: `{:?}`\", input_ty);\n             let local_type = trait_ref\n-                .input_types()\n+                .substs\n+                .types()\n                 .flat_map(|ty| uncover_fundamental_ty(tcx, ty, in_crate))\n                 .find(|ty| ty_is_non_local_constructor(ty, in_crate).is_none());\n "}, {"sha": "d9a5b68dc1eb9d84c5ae2d9b8f7ecbc8acabf72b", "filename": "src/librustc_trait_selection/traits/object_safety.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/626abc797704009e4683be5d95dbeb9417999c82/src%2Flibrustc_trait_selection%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/626abc797704009e4683be5d95dbeb9417999c82/src%2Flibrustc_trait_selection%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fobject_safety.rs?ref=626abc797704009e4683be5d95dbeb9417999c82", "patch": "@@ -16,7 +16,7 @@ use crate::traits::{self, Obligation, ObligationCause};\n use rustc_errors::{Applicability, FatalError};\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n-use rustc_middle::ty::subst::{GenericArgKind, InternalSubsts, Subst};\n+use rustc_middle::ty::subst::{GenericArg, GenericArgKind, InternalSubsts, Subst};\n use rustc_middle::ty::{self, Predicate, ToPredicate, Ty, TyCtxt, TypeFoldable, WithConstness};\n use rustc_session::lint::builtin::WHERE_CLAUSES_OBJECT_SAFETY;\n use rustc_span::symbol::Symbol;\n@@ -234,7 +234,7 @@ fn predicates_reference_self(\n         tcx.predicates_of(trait_def_id)\n     };\n     let self_ty = tcx.types.self_param;\n-    let has_self_ty = |t: Ty<'_>| t.walk().any(|arg| arg == self_ty.into());\n+    let has_self_ty = |arg: &GenericArg<'_>| arg.walk().any(|arg| arg == self_ty.into());\n     predicates\n         .predicates\n         .iter()\n@@ -243,7 +243,7 @@ fn predicates_reference_self(\n             match predicate {\n                 ty::Predicate::Trait(ref data, _) => {\n                     // In the case of a trait predicate, we can skip the \"self\" type.\n-                    if data.skip_binder().input_types().skip(1).any(has_self_ty) {\n+                    if data.skip_binder().trait_ref.substs[1..].iter().any(has_self_ty) {\n                         Some(sp)\n                     } else {\n                         None\n@@ -262,12 +262,8 @@ fn predicates_reference_self(\n                     //\n                     // This is ALT2 in issue #56288, see that for discussion of the\n                     // possible alternatives.\n-                    if data\n-                        .skip_binder()\n-                        .projection_ty\n-                        .trait_ref(tcx)\n-                        .input_types()\n-                        .skip(1)\n+                    if data.skip_binder().projection_ty.trait_ref(tcx).substs[1..]\n+                        .iter()\n                         .any(has_self_ty)\n                     {\n                         Some(sp)"}, {"sha": "84c264f06db287848cc04016ee396d32d56c0e17", "filename": "src/librustc_trait_selection/traits/select.rs", "status": "modified", "additions": 27, "deletions": 11, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/626abc797704009e4683be5d95dbeb9417999c82/src%2Flibrustc_trait_selection%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/626abc797704009e4683be5d95dbeb9417999c82/src%2Flibrustc_trait_selection%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fselect.rs?ref=626abc797704009e4683be5d95dbeb9417999c82", "patch": "@@ -652,7 +652,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         &mut self,\n         stack: &TraitObligationStack<'o, 'tcx>,\n     ) -> Result<EvaluationResult, OverflowError> {\n-        // In intercrate mode, whenever any of the types are unbound,\n+        // In intercrate mode, whenever any of the generics are unbound,\n         // there can always be an impl. Even if there are no impls in\n         // this crate, perhaps the type would be unified with\n         // something from another crate that does provide an impl.\n@@ -677,7 +677,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // terms of `Fn` etc, but we could probably make this more\n         // precise still.\n         let unbound_input_types =\n-            stack.fresh_trait_ref.skip_binder().input_types().any(|ty| ty.is_fresh());\n+            stack.fresh_trait_ref.skip_binder().substs.types().any(|ty| ty.is_fresh());\n         // This check was an imperfect workaround for a bug in the old\n         // intercrate mode; it should be removed when that goes away.\n         if unbound_input_types && self.intercrate {\n@@ -3262,15 +3262,31 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // substitution if we find that any of the input types, when\n         // simplified, do not match.\n \n-        obligation.predicate.skip_binder().input_types().zip(impl_trait_ref.input_types()).any(\n-            |(obligation_ty, impl_ty)| {\n-                let simplified_obligation_ty =\n-                    fast_reject::simplify_type(self.tcx(), obligation_ty, true);\n-                let simplified_impl_ty = fast_reject::simplify_type(self.tcx(), impl_ty, false);\n-\n-                simplified_obligation_ty.is_some()\n-                    && simplified_impl_ty.is_some()\n-                    && simplified_obligation_ty != simplified_impl_ty\n+        obligation.predicate.skip_binder().trait_ref.substs.iter().zip(impl_trait_ref.substs).any(\n+            |(obligation_arg, impl_arg)| {\n+                match (obligation_arg.unpack(), impl_arg.unpack()) {\n+                    (GenericArgKind::Type(obligation_ty), GenericArgKind::Type(impl_ty)) => {\n+                        let simplified_obligation_ty =\n+                            fast_reject::simplify_type(self.tcx(), obligation_ty, true);\n+                        let simplified_impl_ty =\n+                            fast_reject::simplify_type(self.tcx(), impl_ty, false);\n+\n+                        simplified_obligation_ty.is_some()\n+                            && simplified_impl_ty.is_some()\n+                            && simplified_obligation_ty != simplified_impl_ty\n+                    }\n+                    (GenericArgKind::Lifetime(_), GenericArgKind::Lifetime(_)) => {\n+                        // Lifetimes can never cause a rejection.\n+                        false\n+                    }\n+                    (GenericArgKind::Const(_), GenericArgKind::Const(_)) => {\n+                        // Conservatively ignore consts (i.e. assume they might\n+                        // unify later) until we have `fast_reject` support for\n+                        // them (if we'll ever need it, even).\n+                        false\n+                    }\n+                    _ => unreachable!(),\n+                }\n             },\n         )\n     }"}, {"sha": "ff3493eb6de6d642aa24cc0cddc79c91e0ef00ae", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/626abc797704009e4683be5d95dbeb9417999c82/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/626abc797704009e4683be5d95dbeb9417999c82/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=626abc797704009e4683be5d95dbeb9417999c82", "patch": "@@ -563,30 +563,30 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         while !queue.is_empty() {\n             let obligation = queue.remove(0);\n             debug!(\"coerce_unsized resolve step: {:?}\", obligation);\n-            let trait_ref = match obligation.predicate {\n-                ty::Predicate::Trait(ref tr, _) if traits.contains(&tr.def_id()) => {\n-                    if unsize_did == tr.def_id() {\n-                        let sty = &tr.skip_binder().input_types().nth(1).unwrap().kind;\n-                        if let ty::Tuple(..) = sty {\n+            let trait_pred = match obligation.predicate {\n+                ty::Predicate::Trait(trait_pred, _) if traits.contains(&trait_pred.def_id()) => {\n+                    if unsize_did == trait_pred.def_id() {\n+                        let unsize_ty = trait_pred.skip_binder().trait_ref.substs[1].expect_ty();\n+                        if let ty::Tuple(..) = unsize_ty.kind {\n                             debug!(\"coerce_unsized: found unsized tuple coercion\");\n                             has_unsized_tuple_coercion = true;\n                         }\n                     }\n-                    *tr\n+                    trait_pred\n                 }\n                 _ => {\n                     coercion.obligations.push(obligation);\n                     continue;\n                 }\n             };\n-            match selcx.select(&obligation.with(trait_ref)) {\n+            match selcx.select(&obligation.with(trait_pred)) {\n                 // Uncertain or unimplemented.\n                 Ok(None) => {\n-                    if trait_ref.def_id() == unsize_did {\n-                        let trait_ref = self.resolve_vars_if_possible(&trait_ref);\n-                        let self_ty = trait_ref.skip_binder().self_ty();\n-                        let unsize_ty = trait_ref.skip_binder().input_types().nth(1).unwrap();\n-                        debug!(\"coerce_unsized: ambiguous unsize case for {:?}\", trait_ref);\n+                    if trait_pred.def_id() == unsize_did {\n+                        let trait_pred = self.resolve_vars_if_possible(&trait_pred);\n+                        let self_ty = trait_pred.skip_binder().self_ty();\n+                        let unsize_ty = trait_pred.skip_binder().trait_ref.substs[1].expect_ty();\n+                        debug!(\"coerce_unsized: ambiguous unsize case for {:?}\", trait_pred);\n                         match (&self_ty.kind, &unsize_ty.kind) {\n                             (ty::Infer(ty::TyVar(v)), ty::Dynamic(..))\n                                 if self.type_var_is_sized(*v) =>"}, {"sha": "5c35dc5513266482dd4e63878e23ed637c601b3c", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 52, "deletions": 52, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/626abc797704009e4683be5d95dbeb9417999c82/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/626abc797704009e4683be5d95dbeb9417999c82/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=626abc797704009e4683be5d95dbeb9417999c82", "patch": "@@ -84,15 +84,6 @@ impl<T: Clean<U>, U> Clean<Option<U>> for Option<T> {\n     }\n }\n \n-impl<T, U> Clean<U> for ty::Binder<T>\n-where\n-    T: Clean<U>,\n-{\n-    fn clean(&self, cx: &DocContext<'_>) -> U {\n-        self.skip_binder().clean(cx)\n-    }\n-}\n-\n impl Clean<ExternalCrate> for CrateNum {\n     fn clean(&self, cx: &DocContext<'_>) -> ExternalCrate {\n         let root = DefId { krate: *self, index: CRATE_DEF_INDEX };\n@@ -305,59 +296,66 @@ impl Clean<GenericBound> for hir::GenericBound<'_> {\n     }\n }\n \n-impl<'a, 'tcx> Clean<GenericBound> for (&'a ty::TraitRef<'tcx>, Vec<TypeBinding>) {\n-    fn clean(&self, cx: &DocContext<'_>) -> GenericBound {\n-        let (trait_ref, ref bounds) = *self;\n+impl Clean<Type> for (ty::TraitRef<'_>, &[TypeBinding]) {\n+    fn clean(&self, cx: &DocContext<'_>) -> Type {\n+        let (trait_ref, bounds) = *self;\n         inline::record_extern_fqn(cx, trait_ref.def_id, TypeKind::Trait);\n         let path = external_path(\n             cx,\n             cx.tcx.item_name(trait_ref.def_id),\n             Some(trait_ref.def_id),\n             true,\n-            bounds.clone(),\n+            bounds.to_vec(),\n             trait_ref.substs,\n         );\n \n         debug!(\"ty::TraitRef\\n  subst: {:?}\\n\", trait_ref.substs);\n \n+        ResolvedPath { path, param_names: None, did: trait_ref.def_id, is_generic: false }\n+    }\n+}\n+\n+impl<'tcx> Clean<GenericBound> for ty::TraitRef<'tcx> {\n+    fn clean(&self, cx: &DocContext<'_>) -> GenericBound {\n+        GenericBound::TraitBound(\n+            PolyTrait { trait_: (*self, &[][..]).clean(cx), generic_params: vec![] },\n+            hir::TraitBoundModifier::None,\n+        )\n+    }\n+}\n+\n+impl Clean<GenericBound> for (ty::PolyTraitRef<'_>, &[TypeBinding]) {\n+    fn clean(&self, cx: &DocContext<'_>) -> GenericBound {\n+        let (poly_trait_ref, bounds) = *self;\n+        let poly_trait_ref = poly_trait_ref.lift_to_tcx(cx.tcx).unwrap();\n+\n         // collect any late bound regions\n-        let mut late_bounds = vec![];\n-        for ty_s in trait_ref.input_types().skip(1) {\n-            if let ty::Tuple(ts) = ty_s.kind {\n-                for &ty_s in ts {\n-                    if let ty::Ref(ref reg, _, _) = ty_s.expect_ty().kind {\n-                        if let &ty::RegionKind::ReLateBound(..) = *reg {\n-                            debug!(\"  hit an ReLateBound {:?}\", reg);\n-                            if let Some(Lifetime(name)) = reg.clean(cx) {\n-                                late_bounds.push(GenericParamDef {\n-                                    name,\n-                                    kind: GenericParamDefKind::Lifetime,\n-                                });\n-                            }\n-                        }\n-                    }\n-                }\n-            }\n-        }\n+        let late_bound_regions: Vec<_> = cx\n+            .tcx\n+            .collect_referenced_late_bound_regions(&poly_trait_ref)\n+            .into_iter()\n+            .filter_map(|br| match br {\n+                ty::BrNamed(_, name) => Some(GenericParamDef {\n+                    name: name.to_string(),\n+                    kind: GenericParamDefKind::Lifetime,\n+                }),\n+                _ => None,\n+            })\n+            .collect();\n \n         GenericBound::TraitBound(\n             PolyTrait {\n-                trait_: ResolvedPath {\n-                    path,\n-                    param_names: None,\n-                    did: trait_ref.def_id,\n-                    is_generic: false,\n-                },\n-                generic_params: late_bounds,\n+                trait_: (*poly_trait_ref.skip_binder(), bounds).clean(cx),\n+                generic_params: late_bound_regions,\n             },\n             hir::TraitBoundModifier::None,\n         )\n     }\n }\n \n-impl<'tcx> Clean<GenericBound> for ty::TraitRef<'tcx> {\n+impl<'tcx> Clean<GenericBound> for ty::PolyTraitRef<'tcx> {\n     fn clean(&self, cx: &DocContext<'_>) -> GenericBound {\n-        (self, vec![]).clean(cx)\n+        (*self, &[][..]).clean(cx)\n     }\n }\n \n@@ -495,16 +493,17 @@ impl<'a> Clean<Option<WherePredicate>> for ty::Predicate<'a> {\n     }\n }\n \n-impl<'a> Clean<WherePredicate> for ty::TraitPredicate<'a> {\n+impl<'a> Clean<WherePredicate> for ty::PolyTraitPredicate<'a> {\n     fn clean(&self, cx: &DocContext<'_>) -> WherePredicate {\n+        let poly_trait_ref = self.map_bound(|pred| pred.trait_ref);\n         WherePredicate::BoundPredicate {\n-            ty: self.trait_ref.self_ty().clean(cx),\n-            bounds: vec![self.trait_ref.clean(cx)],\n+            ty: poly_trait_ref.self_ty().clean(cx),\n+            bounds: vec![poly_trait_ref.clean(cx)],\n         }\n     }\n }\n \n-impl<'tcx> Clean<WherePredicate> for ty::SubtypePredicate<'tcx> {\n+impl<'tcx> Clean<WherePredicate> for ty::PolySubtypePredicate<'tcx> {\n     fn clean(&self, _cx: &DocContext<'_>) -> WherePredicate {\n         panic!(\n             \"subtype predicates are an internal rustc artifact \\\n@@ -514,10 +513,10 @@ impl<'tcx> Clean<WherePredicate> for ty::SubtypePredicate<'tcx> {\n }\n \n impl<'tcx> Clean<Option<WherePredicate>>\n-    for ty::OutlivesPredicate<ty::Region<'tcx>, ty::Region<'tcx>>\n+    for ty::PolyOutlivesPredicate<ty::Region<'tcx>, ty::Region<'tcx>>\n {\n     fn clean(&self, cx: &DocContext<'_>) -> Option<WherePredicate> {\n-        let ty::OutlivesPredicate(ref a, ref b) = *self;\n+        let ty::OutlivesPredicate(a, b) = self.skip_binder();\n \n         if let (ty::ReEmpty(_), ty::ReEmpty(_)) = (a, b) {\n             return None;\n@@ -530,9 +529,9 @@ impl<'tcx> Clean<Option<WherePredicate>>\n     }\n }\n \n-impl<'tcx> Clean<Option<WherePredicate>> for ty::OutlivesPredicate<Ty<'tcx>, ty::Region<'tcx>> {\n+impl<'tcx> Clean<Option<WherePredicate>> for ty::PolyOutlivesPredicate<Ty<'tcx>, ty::Region<'tcx>> {\n     fn clean(&self, cx: &DocContext<'_>) -> Option<WherePredicate> {\n-        let ty::OutlivesPredicate(ref ty, ref lt) = *self;\n+        let ty::OutlivesPredicate(ty, lt) = self.skip_binder();\n \n         if let ty::ReEmpty(_) = lt {\n             return None;\n@@ -545,9 +544,10 @@ impl<'tcx> Clean<Option<WherePredicate>> for ty::OutlivesPredicate<Ty<'tcx>, ty:\n     }\n }\n \n-impl<'tcx> Clean<WherePredicate> for ty::ProjectionPredicate<'tcx> {\n+impl<'tcx> Clean<WherePredicate> for ty::PolyProjectionPredicate<'tcx> {\n     fn clean(&self, cx: &DocContext<'_>) -> WherePredicate {\n-        WherePredicate::EqPredicate { lhs: self.projection_ty.clean(cx), rhs: self.ty.clean(cx) }\n+        let ty::ProjectionPredicate { projection_ty, ty } = *self.skip_binder();\n+        WherePredicate::EqPredicate { lhs: projection_ty.clean(cx), rhs: ty.clean(cx) }\n     }\n }\n \n@@ -1674,7 +1674,7 @@ impl<'tcx> Clean<Type> for Ty<'tcx> {\n                             }\n                         }\n \n-                        let bounds = bounds\n+                        let bounds: Vec<_> = bounds\n                             .predicates\n                             .iter()\n                             .filter_map(|pred| {\n@@ -1703,7 +1703,7 @@ impl<'tcx> Clean<Type> for Ty<'tcx> {\n                             })\n                             .collect();\n \n-                        Some((trait_ref.skip_binder(), bounds).clean(cx))\n+                        Some((trait_ref, &bounds[..]).clean(cx))\n                     })\n                     .collect::<Vec<_>>();\n                 bounds.extend(regions);"}]}