{"sha": "2adad1f7cde19bd3ff8fa519cfe749f7fbf4c7fa", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJhZGFkMWY3Y2RlMTliZDNmZjhmYTUxOWNmZTc0OWY3ZmJmNGM3ZmE=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-05-16T06:18:04Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-05-16T06:46:40Z"}, "message": "core: Generalize int-string conversions to all int types\n\nIssue #2239", "tree": {"sha": "45135b92a30b2774234fb723da7ea24f341eafca", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/45135b92a30b2774234fb723da7ea24f341eafca"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2adad1f7cde19bd3ff8fa519cfe749f7fbf4c7fa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2adad1f7cde19bd3ff8fa519cfe749f7fbf4c7fa", "html_url": "https://github.com/rust-lang/rust/commit/2adad1f7cde19bd3ff8fa519cfe749f7fbf4c7fa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2adad1f7cde19bd3ff8fa519cfe749f7fbf4c7fa/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cb6ed427174031f67f226da292aa85f8127f4513", "url": "https://api.github.com/repos/rust-lang/rust/commits/cb6ed427174031f67f226da292aa85f8127f4513", "html_url": "https://github.com/rust-lang/rust/commit/cb6ed427174031f67f226da292aa85f8127f4513"}], "stats": {"total": 201, "additions": 101, "deletions": 100}, "files": [{"sha": "0cc5ba5bb89104d43e039898c5a198e2cd46b849", "filename": "src/libcore/core.rc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2adad1f7cde19bd3ff8fa519cfe749f7fbf4c7fa/src%2Flibcore%2Fcore.rc", "raw_url": "https://github.com/rust-lang/rust/raw/2adad1f7cde19bd3ff8fa519cfe749f7fbf4c7fa/src%2Flibcore%2Fcore.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcore.rc?ref=2adad1f7cde19bd3ff8fa519cfe749f7fbf4c7fa", "patch": "@@ -56,8 +56,8 @@ export priv;\n #[doc = \"Operations and constants for `int`\"]\n #[path = \"int-template\"]\n mod int {\n-    import inst::{ hash, parse_buf, from_str, to_str, str, pow };\n-    export hash, parse_buf, from_str, to_str, str, pow;\n+    import inst::{ hash, pow };\n+    export hash, pow;\n     #[path = \"int.rs\"]\n     mod inst;\n }"}, {"sha": "e1ec3e9683b22dbdca909e6bf1513ec2e5aab713", "filename": "src/libcore/int-template.rs", "status": "modified", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/2adad1f7cde19bd3ff8fa519cfe749f7fbf4c7fa/src%2Flibcore%2Fint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2adad1f7cde19bd3ff8fa519cfe749f7fbf4c7fa/src%2Flibcore%2Fint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fint-template.rs?ref=2adad1f7cde19bd3ff8fa519cfe749f7fbf4c7fa", "patch": "@@ -9,6 +9,7 @@ export is_nonpositive, is_nonnegative;\n export range;\n export compl;\n export abs;\n+export parse_buf, from_str, to_str, str;\n \n const min_value: T = -1 as T << (inst::bits - 1 as T);\n const max_value: T = min_value - 1 as T;\n@@ -50,3 +51,101 @@ pure fn compl(i: T) -> T {\n pure fn abs(i: T) -> T {\n     if is_negative(i) { -i } else { i }\n }\n+\n+#[doc = \"\n+Parse a buffer of bytes\n+\n+# Arguments\n+\n+* buf - A byte buffer\n+* radix - The base of the number\n+\"]\n+fn parse_buf(buf: [u8], radix: uint) -> option<T> {\n+    if vec::len(buf) == 0u { ret none; }\n+    let mut i = vec::len(buf) - 1u;\n+    let mut start = 0u;\n+    let mut power = 1 as T;\n+\n+    if buf[0] == ('-' as u8) {\n+        power = -1 as T;\n+        start = 1u;\n+    }\n+    let mut n = 0 as T;\n+    loop {\n+        alt char::to_digit(buf[i] as char, radix) {\n+          some(d) { n += (d as T) * power; }\n+          none { ret none; }\n+        }\n+        power *= radix as T;\n+        if i <= start { ret some(n); }\n+        i -= 1u;\n+    };\n+}\n+\n+#[doc = \"Parse a string to an int\"]\n+fn from_str(s: str) -> option<T> { parse_buf(str::bytes(s), 10u) }\n+\n+#[doc = \"Convert to a string in a given base\"]\n+fn to_str(n: T, radix: uint) -> str {\n+    assert (0u < radix && radix <= 16u);\n+    ret if n < 0 as T {\n+            \"-\" + uint::to_str(-n as uint, radix)\n+        } else { uint::to_str(n as uint, radix) };\n+}\n+\n+#[doc = \"Convert to a string\"]\n+fn str(i: T) -> str { ret to_str(i, 10u); }\n+\n+\n+#[test]\n+fn test_from_str() {\n+    assert from_str(\"0\") == some(0 as T);\n+    assert from_str(\"3\") == some(3 as T);\n+    assert from_str(\"10\") == some(10 as T);\n+    assert from_str(\"123456789\") == some(123456789 as T);\n+    assert from_str(\"00100\") == some(100 as T);\n+\n+    assert from_str(\"-1\") == some(-1 as T);\n+    assert from_str(\"-3\") == some(-3 as T);\n+    assert from_str(\"-10\") == some(-10 as T);\n+    assert from_str(\"-123456789\") == some(-123456789 as T);\n+    assert from_str(\"-00100\") == some(-100 as T);\n+\n+    assert from_str(\" \") == none;\n+    assert from_str(\"x\") == none;\n+}\n+\n+#[test]\n+fn test_parse_buf() {\n+    import str::bytes;\n+    assert parse_buf(bytes(\"123\"), 10u) == some(123 as T);\n+    assert parse_buf(bytes(\"1001\"), 2u) == some(9 as T);\n+    assert parse_buf(bytes(\"123\"), 8u) == some(83 as T);\n+    assert parse_buf(bytes(\"123\"), 16u) == some(291 as T);\n+    assert parse_buf(bytes(\"ffff\"), 16u) == some(65535 as T);\n+    assert parse_buf(bytes(\"FFFF\"), 16u) == some(65535 as T);\n+    assert parse_buf(bytes(\"z\"), 36u) == some(35 as T);\n+    assert parse_buf(bytes(\"Z\"), 36u) == some(35 as T);\n+\n+    assert parse_buf(bytes(\"-123\"), 10u) == some(-123 as T);\n+    assert parse_buf(bytes(\"-1001\"), 2u) == some(-9 as T);\n+    assert parse_buf(bytes(\"-123\"), 8u) == some(-83 as T);\n+    assert parse_buf(bytes(\"-123\"), 16u) == some(-291 as T);\n+    assert parse_buf(bytes(\"-ffff\"), 16u) == some(-65535 as T);\n+    assert parse_buf(bytes(\"-FFFF\"), 16u) == some(-65535 as T);\n+    assert parse_buf(bytes(\"-z\"), 36u) == some(-35 as T);\n+    assert parse_buf(bytes(\"-Z\"), 36u) == some(-35 as T);\n+\n+    assert parse_buf(str::bytes(\"Z\"), 35u) == none;\n+    assert parse_buf(str::bytes(\"-9\"), 2u) == none;\n+}\n+\n+#[test]\n+fn test_to_str() {\n+    import str::eq;\n+    assert (eq(to_str(0 as T, 10u), \"0\"));\n+    assert (eq(to_str(1 as T, 10u), \"1\"));\n+    assert (eq(to_str(-1 as T, 10u), \"-1\"));\n+    assert (eq(to_str(127 as T, 16u), \"7f\"));\n+    assert (eq(to_str(100 as T, 10u), \"100\"));\n+}"}, {"sha": "b7c4d1717bbcad679a4d4a9cdbce6a9d4535b20f", "filename": "src/libcore/int-template/int.rs", "status": "modified", "additions": 0, "deletions": 98, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/2adad1f7cde19bd3ff8fa519cfe749f7fbf4c7fa/src%2Flibcore%2Fint-template%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2adad1f7cde19bd3ff8fa519cfe749f7fbf4c7fa/src%2Flibcore%2Fint-template%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fint-template%2Fint.rs?ref=2adad1f7cde19bd3ff8fa519cfe749f7fbf4c7fa", "patch": "@@ -9,50 +9,6 @@ const bits: T = 64 as T;\n #[doc = \"Produce a uint suitable for use in a hash table\"]\n pure fn hash(x: int) -> uint { ret x as uint; }\n \n-#[doc = \"\n-Parse a buffer of bytes\n-\n-# Arguments\n-\n-* buf - A byte buffer\n-* radix - The base of the number\n-\"]\n-fn parse_buf(buf: [u8], radix: uint) -> option<int> {\n-    if vec::len(buf) == 0u { ret none; }\n-    let mut i = vec::len(buf) - 1u;\n-    let mut start = 0u;\n-    let mut power = 1;\n-\n-    if buf[0] == ('-' as u8) {\n-        power = -1;\n-        start = 1u;\n-    }\n-    let mut n = 0;\n-    loop {\n-        alt char::to_digit(buf[i] as char, radix) {\n-          some(d) { n += (d as int) * power; }\n-          none { ret none; }\n-        }\n-        power *= radix as int;\n-        if i <= start { ret some(n); }\n-        i -= 1u;\n-    };\n-}\n-\n-#[doc = \"Parse a string to an int\"]\n-fn from_str(s: str) -> option<int> { parse_buf(str::bytes(s), 10u) }\n-\n-#[doc = \"Convert to a string in a given base\"]\n-fn to_str(n: int, radix: uint) -> str {\n-    assert (0u < radix && radix <= 16u);\n-    ret if n < 0 {\n-            \"-\" + uint::to_str(-n as uint, radix)\n-        } else { uint::to_str(n as uint, radix) };\n-}\n-\n-#[doc = \"Convert to a string\"]\n-fn str(i: int) -> str { ret to_str(i, 10u); }\n-\n #[doc = \"Returns `base` raised to the power of `exponent`\"]\n fn pow(base: int, exponent: uint) -> int {\n     if exponent == 0u { ret 1; } //Not mathemtically true if [base == 0]\n@@ -70,60 +26,6 @@ fn pow(base: int, exponent: uint) -> int {\n     ret acc;\n }\n \n-\n-#[test]\n-fn test_from_str() {\n-    assert from_str(\"0\") == some(0);\n-    assert from_str(\"3\") == some(3);\n-    assert from_str(\"10\") == some(10);\n-    assert from_str(\"123456789\") == some(123456789);\n-    assert from_str(\"00100\") == some(100);\n-\n-    assert from_str(\"-1\") == some(-1);\n-    assert from_str(\"-3\") == some(-3);\n-    assert from_str(\"-10\") == some(-10);\n-    assert from_str(\"-123456789\") == some(-123456789);\n-    assert from_str(\"-00100\") == some(-100);\n-\n-    assert from_str(\" \") == none;\n-    assert from_str(\"x\") == none;\n-}\n-\n-#[test]\n-fn test_parse_buf() {\n-    import str::bytes;\n-    assert parse_buf(bytes(\"123\"), 10u) == some(123);\n-    assert parse_buf(bytes(\"1001\"), 2u) == some(9);\n-    assert parse_buf(bytes(\"123\"), 8u) == some(83);\n-    assert parse_buf(bytes(\"123\"), 16u) == some(291);\n-    assert parse_buf(bytes(\"ffff\"), 16u) == some(65535);\n-    assert parse_buf(bytes(\"FFFF\"), 16u) == some(65535);\n-    assert parse_buf(bytes(\"z\"), 36u) == some(35);\n-    assert parse_buf(bytes(\"Z\"), 36u) == some(35);\n-\n-    assert parse_buf(bytes(\"-123\"), 10u) == some(-123);\n-    assert parse_buf(bytes(\"-1001\"), 2u) == some(-9);\n-    assert parse_buf(bytes(\"-123\"), 8u) == some(-83);\n-    assert parse_buf(bytes(\"-123\"), 16u) == some(-291);\n-    assert parse_buf(bytes(\"-ffff\"), 16u) == some(-65535);\n-    assert parse_buf(bytes(\"-FFFF\"), 16u) == some(-65535);\n-    assert parse_buf(bytes(\"-z\"), 36u) == some(-35);\n-    assert parse_buf(bytes(\"-Z\"), 36u) == some(-35);\n-\n-    assert parse_buf(str::bytes(\"Z\"), 35u) == none;\n-    assert parse_buf(str::bytes(\"-9\"), 2u) == none;\n-}\n-\n-#[test]\n-fn test_to_str() {\n-    import str::eq;\n-    assert (eq(to_str(0, 10u), \"0\"));\n-    assert (eq(to_str(1, 10u), \"1\"));\n-    assert (eq(to_str(-1, 10u), \"-1\"));\n-    assert (eq(to_str(255, 16u), \"ff\"));\n-    assert (eq(to_str(100, 10u), \"100\"));\n-}\n-\n #[test]\n fn test_pow() {\n     assert (pow(0, 0u) == 1);"}]}