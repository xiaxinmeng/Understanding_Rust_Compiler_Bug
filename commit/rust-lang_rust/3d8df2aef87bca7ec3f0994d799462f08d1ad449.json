{"sha": "3d8df2aef87bca7ec3f0994d799462f08d1ad449", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNkOGRmMmFlZjg3YmNhN2VjM2YwOTk0ZDc5OTQ2MmYwOGQxYWQ0NDk=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-06-13T14:09:41Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-06-13T14:09:41Z"}, "message": "Merge #9248\n\n9248: internal: refactor unresolved macro call diagnostic r=matklad a=matklad\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "a43b94510193f1f58ec7bfc39814ae58f673ceca", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a43b94510193f1f58ec7bfc39814ae58f673ceca"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3d8df2aef87bca7ec3f0994d799462f08d1ad449", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgxhGlCRBK7hj4Ov3rIwAAgP0IAFpFao+LPxlp4X04jkvyNvfh\nEX2hFqZ1olAhLKLZwShUewirKsaO8FxPE7fW8hjFFTOkFEXab1jElWn2+kW2Mc+p\nBoBOzR29swbPYA1e1PKck8mo80EjGf1MjySjo3Byut/jJzpU2QG3VbFkKUwAQlKO\na6ZeN8k1NqXzJTrItEDbUtHqkp/zHcfY65yWO+5SPfURNWFnE0opeL43ZVQfDeka\nrbnsDO2T3W6zYu2WPEynH+5wqquEtLVuOMIjP7gHOfY49LBnJvNXgEk7VBbUJAXv\neLjgvH8BOptUhIrkT8zCby+gITMQXh8q95G6I9Xe8UuXNCDS6k11l7qCaCEhVxg=\n=3SgG\n-----END PGP SIGNATURE-----\n", "payload": "tree a43b94510193f1f58ec7bfc39814ae58f673ceca\nparent e6fa9b016fab4bf38f4e2a798fcabcc13b58e9ab\nparent fa9ed4e0ce633e51d1411951bf044719e6837457\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1623593381 +0000\ncommitter GitHub <noreply@github.com> 1623593381 +0000\n\nMerge #9248\n\n9248: internal: refactor unresolved macro call diagnostic r=matklad a=matklad\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3d8df2aef87bca7ec3f0994d799462f08d1ad449", "html_url": "https://github.com/rust-lang/rust/commit/3d8df2aef87bca7ec3f0994d799462f08d1ad449", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3d8df2aef87bca7ec3f0994d799462f08d1ad449/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e6fa9b016fab4bf38f4e2a798fcabcc13b58e9ab", "url": "https://api.github.com/repos/rust-lang/rust/commits/e6fa9b016fab4bf38f4e2a798fcabcc13b58e9ab", "html_url": "https://github.com/rust-lang/rust/commit/e6fa9b016fab4bf38f4e2a798fcabcc13b58e9ab"}, {"sha": "fa9ed4e0ce633e51d1411951bf044719e6837457", "url": "https://api.github.com/repos/rust-lang/rust/commits/fa9ed4e0ce633e51d1411951bf044719e6837457", "html_url": "https://github.com/rust-lang/rust/commit/fa9ed4e0ce633e51d1411951bf044719e6837457"}], "stats": {"total": 406, "additions": 220, "deletions": 186}, "files": [{"sha": "718c86b3a1e0330a1aea02445046c108e3ddf8cc", "filename": "crates/hir/src/diagnostics.rs", "status": "modified", "additions": 10, "deletions": 50, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/3d8df2aef87bca7ec3f0994d799462f08d1ad449/crates%2Fhir%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d8df2aef87bca7ec3f0994d799462f08d1ad449/crates%2Fhir%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fdiagnostics.rs?ref=3d8df2aef87bca7ec3f0994d799462f08d1ad449", "patch": "@@ -17,7 +17,7 @@ pub use crate::diagnostics_sink::{\n };\n \n macro_rules! diagnostics {\n-    ($($diag:ident),*) => {\n+    ($($diag:ident,)*) => {\n         pub enum AnyDiagnostic {$(\n             $diag(Box<$diag>),\n         )*}\n@@ -32,7 +32,13 @@ macro_rules! diagnostics {\n     };\n }\n \n-diagnostics![UnresolvedModule, UnresolvedExternCrate, MissingFields];\n+diagnostics![\n+    UnresolvedModule,\n+    UnresolvedExternCrate,\n+    UnresolvedImport,\n+    UnresolvedMacroCall,\n+    MissingFields,\n+];\n \n #[derive(Debug)]\n pub struct UnresolvedModule {\n@@ -47,61 +53,15 @@ pub struct UnresolvedExternCrate {\n \n #[derive(Debug)]\n pub struct UnresolvedImport {\n-    pub file: HirFileId,\n-    pub node: AstPtr<ast::UseTree>,\n-}\n-\n-impl Diagnostic for UnresolvedImport {\n-    fn code(&self) -> DiagnosticCode {\n-        DiagnosticCode(\"unresolved-import\")\n-    }\n-    fn message(&self) -> String {\n-        \"unresolved import\".to_string()\n-    }\n-    fn display_source(&self) -> InFile<SyntaxNodePtr> {\n-        InFile::new(self.file, self.node.clone().into())\n-    }\n-    fn as_any(&self) -> &(dyn Any + Send + 'static) {\n-        self\n-    }\n-    fn is_experimental(&self) -> bool {\n-        // This currently results in false positives in the following cases:\n-        // - `cfg_if!`-generated code in libstd (we don't load the sysroot correctly)\n-        // - `core::arch` (we don't handle `#[path = \"../<path>\"]` correctly)\n-        // - proc macros and/or proc macro generated code\n-        true\n-    }\n+    pub decl: InFile<AstPtr<ast::UseTree>>,\n }\n \n-// Diagnostic: unresolved-macro-call\n-//\n-// This diagnostic is triggered if rust-analyzer is unable to resolve the path to a\n-// macro in a macro invocation.\n #[derive(Debug, Clone, Eq, PartialEq)]\n pub struct UnresolvedMacroCall {\n-    pub file: HirFileId,\n-    pub node: AstPtr<ast::MacroCall>,\n+    pub macro_call: InFile<AstPtr<ast::MacroCall>>,\n     pub path: ModPath,\n }\n \n-impl Diagnostic for UnresolvedMacroCall {\n-    fn code(&self) -> DiagnosticCode {\n-        DiagnosticCode(\"unresolved-macro-call\")\n-    }\n-    fn message(&self) -> String {\n-        format!(\"unresolved macro `{}!`\", self.path)\n-    }\n-    fn display_source(&self) -> InFile<SyntaxNodePtr> {\n-        InFile::new(self.file, self.node.clone().into())\n-    }\n-    fn as_any(&self) -> &(dyn Any + Send + 'static) {\n-        self\n-    }\n-    fn is_experimental(&self) -> bool {\n-        true\n-    }\n-}\n-\n // Diagnostic: inactive-code\n //\n // This diagnostic is shown for code with inactive `#[cfg]` attributes."}, {"sha": "0a94140133e2832ed7033e001333b952d6f8d446", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/3d8df2aef87bca7ec3f0994d799462f08d1ad449/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d8df2aef87bca7ec3f0994d799462f08d1ad449/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=3d8df2aef87bca7ec3f0994d799462f08d1ad449", "patch": "@@ -498,7 +498,10 @@ impl Module {\n                     let import = &item_tree[id.value];\n \n                     let use_tree = import.use_tree_to_ast(db.upcast(), file_id, *index);\n-                    sink.push(UnresolvedImport { file: file_id, node: AstPtr::new(&use_tree) });\n+                    acc.push(\n+                        UnresolvedImport { decl: InFile::new(file_id, AstPtr::new(&use_tree)) }\n+                            .into(),\n+                    );\n                 }\n \n                 DefDiagnosticKind::UnconfiguredCode { ast, cfg, opts } => {\n@@ -577,11 +580,13 @@ impl Module {\n \n                 DefDiagnosticKind::UnresolvedMacroCall { ast, path } => {\n                     let node = ast.to_node(db.upcast());\n-                    sink.push(UnresolvedMacroCall {\n-                        file: ast.file_id,\n-                        node: AstPtr::new(&node),\n-                        path: path.clone(),\n-                    });\n+                    acc.push(\n+                        UnresolvedMacroCall {\n+                            macro_call: InFile::new(ast.file_id, AstPtr::new(&node)),\n+                            path: path.clone(),\n+                        }\n+                        .into(),\n+                    );\n                 }\n \n                 DefDiagnosticKind::MacroError { ast, message } => {\n@@ -1057,13 +1062,9 @@ impl Function {\n                     precise_location: None,\n                     macro_name: None,\n                 }),\n-                BodyDiagnostic::UnresolvedMacroCall { node, path } => {\n-                    sink.push(UnresolvedMacroCall {\n-                        file: node.file_id,\n-                        node: node.value.clone(),\n-                        path: path.clone(),\n-                    })\n-                }\n+                BodyDiagnostic::UnresolvedMacroCall { node, path } => acc.push(\n+                    UnresolvedMacroCall { macro_call: node.clone(), path: path.clone() }.into(),\n+                ),\n             }\n         }\n "}, {"sha": "5a088b6e582008a38ee9e07401b0942bb9ab0fd9", "filename": "crates/hir_def/src/nameres/tests/diagnostics.rs", "status": "modified", "additions": 0, "deletions": 68, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/3d8df2aef87bca7ec3f0994d799462f08d1ad449/crates%2Fhir_def%2Fsrc%2Fnameres%2Ftests%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d8df2aef87bca7ec3f0994d799462f08d1ad449/crates%2Fhir_def%2Fsrc%2Fnameres%2Ftests%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fnameres%2Ftests%2Fdiagnostics.rs?ref=3d8df2aef87bca7ec3f0994d799462f08d1ad449", "patch": "@@ -12,43 +12,6 @@ fn check_no_diagnostics(ra_fixture: &str) {\n     db.check_no_diagnostics();\n }\n \n-#[test]\n-fn unresolved_import() {\n-    check_diagnostics(\n-        r\"\n-        use does_exist;\n-        use does_not_exist;\n-      //^^^^^^^^^^^^^^^^^^^ UnresolvedImport\n-\n-        mod does_exist {}\n-        \",\n-    );\n-}\n-\n-#[test]\n-fn dedup_unresolved_import_from_unresolved_crate() {\n-    check_diagnostics(\n-        r\"\n-        //- /main.rs crate:main\n-        mod a {\n-            extern crate doesnotexist;\n-          //^^^^^^^^^^^^^^^^^^^^^^^^^^ UnresolvedExternCrate\n-\n-            // Should not error, since we already errored for the missing crate.\n-            use doesnotexist::{self, bla, *};\n-\n-            use crate::doesnotexist;\n-          //^^^^^^^^^^^^^^^^^^^^^^^^ UnresolvedImport\n-        }\n-\n-        mod m {\n-            use super::doesnotexist;\n-          //^^^^^^^^^^^^^^^^^^^^^^^^ UnresolvedImport\n-        }\n-        \",\n-    );\n-}\n-\n #[test]\n fn inactive_item() {\n     // Additional tests in `cfg` crate. This only tests disabled cfgs.\n@@ -91,37 +54,6 @@ fn inactive_via_cfg_attr() {\n     );\n }\n \n-#[test]\n-fn unresolved_legacy_scope_macro() {\n-    check_diagnostics(\n-        r#\"\n-        //- /lib.rs\n-          macro_rules! m { () => {} }\n-\n-          m!();\n-          m2!();\n-        //^^^^^^ UnresolvedMacroCall\n-        \"#,\n-    );\n-}\n-\n-#[test]\n-fn unresolved_module_scope_macro() {\n-    check_diagnostics(\n-        r#\"\n-        //- /lib.rs\n-          mod mac {\n-            #[macro_export]\n-            macro_rules! m { () => {} }\n-          }\n-\n-          self::m!();\n-          self::m2!();\n-        //^^^^^^^^^^^^ UnresolvedMacroCall\n-        \"#,\n-    );\n-}\n-\n #[test]\n fn builtin_macro_fails_expansion() {\n     check_diagnostics("}, {"sha": "1a48008324cf390daaa35c35c3b9fb0e86de0d5e", "filename": "crates/ide/src/diagnostics.rs", "status": "modified", "additions": 33, "deletions": 55, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/3d8df2aef87bca7ec3f0994d799462f08d1ad449/crates%2Fide%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d8df2aef87bca7ec3f0994d799462f08d1ad449/crates%2Fide%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fdiagnostics.rs?ref=3d8df2aef87bca7ec3f0994d799462f08d1ad449", "patch": "@@ -6,6 +6,8 @@\n \n mod unresolved_module;\n mod unresolved_extern_crate;\n+mod unresolved_import;\n+mod unresolved_macro_call;\n mod missing_fields;\n \n mod fixes;\n@@ -15,9 +17,8 @@ mod unlinked_file;\n use std::cell::RefCell;\n \n use hir::{\n-    db::AstDatabase,\n     diagnostics::{AnyDiagnostic, Diagnostic as _, DiagnosticCode, DiagnosticSinkBuilder},\n-    InFile, Semantics,\n+    Semantics,\n };\n use ide_assists::AssistResolveStrategy;\n use ide_db::{base_db::SourceDatabase, RootDatabase};\n@@ -43,17 +44,39 @@ pub struct Diagnostic {\n     pub fixes: Option<Vec<Assist>>,\n     pub unused: bool,\n     pub code: Option<DiagnosticCode>,\n+    pub experimental: bool,\n }\n \n impl Diagnostic {\n     fn new(code: &'static str, message: impl Into<String>, range: TextRange) -> Diagnostic {\n         let message = message.into();\n         let code = Some(DiagnosticCode(code));\n-        Self { message, range, severity: Severity::Error, fixes: None, unused: false, code }\n+        Self {\n+            message,\n+            range,\n+            severity: Severity::Error,\n+            fixes: None,\n+            unused: false,\n+            code,\n+            experimental: false,\n+        }\n+    }\n+\n+    fn experimental(mut self) -> Diagnostic {\n+        self.experimental = true;\n+        self\n     }\n \n     fn error(range: TextRange, message: String) -> Self {\n-        Self { message, range, severity: Severity::Error, fixes: None, unused: false, code: None }\n+        Self {\n+            message,\n+            range,\n+            severity: Severity::Error,\n+            fixes: None,\n+            unused: false,\n+            code: None,\n+            experimental: false,\n+        }\n     }\n \n     fn hint(range: TextRange, message: String) -> Self {\n@@ -64,6 +87,7 @@ impl Diagnostic {\n             fixes: None,\n             unused: false,\n             code: None,\n+            experimental: false,\n         }\n     }\n \n@@ -179,20 +203,6 @@ pub(crate) fn diagnostics(\n             res.borrow_mut()\n                 .push(Diagnostic::hint(display_range, d.message()).with_code(Some(d.code())));\n         })\n-        .on::<hir::diagnostics::UnresolvedMacroCall, _>(|d| {\n-            let last_path_segment = sema.db.parse_or_expand(d.file).and_then(|root| {\n-                d.node\n-                    .to_node(&root)\n-                    .path()\n-                    .and_then(|it| it.segment())\n-                    .and_then(|it| it.name_ref())\n-                    .map(|it| InFile::new(d.file, SyntaxNodePtr::new(it.syntax())))\n-            });\n-            let diagnostics = last_path_segment.unwrap_or_else(|| d.display_source());\n-            let display_range = sema.diagnostics_display_range(diagnostics).range;\n-            res.borrow_mut()\n-                .push(Diagnostic::error(display_range, d.message()).with_code(Some(d.code())));\n-        })\n         .on::<hir::diagnostics::UnimplementedBuiltinMacro, _>(|d| {\n             let display_range = sema.diagnostics_display_range(d.display_source()).range;\n             res.borrow_mut()\n@@ -234,13 +244,18 @@ pub(crate) fn diagnostics(\n         let d = match diag {\n             AnyDiagnostic::UnresolvedModule(d) => unresolved_module::unresolved_module(&ctx, &d),\n             AnyDiagnostic::UnresolvedExternCrate(d) => unresolved_extern_crate::unresolved_extern_crate(&ctx, &d),\n+            AnyDiagnostic::UnresolvedImport(d) => unresolved_import::unresolved_import(&ctx, &d),\n+            AnyDiagnostic::UnresolvedMacroCall(d) => unresolved_macro_call::unresolved_macro_call(&ctx, &d),\n             AnyDiagnostic::MissingFields(d) => missing_fields::missing_fields(&ctx, &d),\n         };\n         if let Some(code) = d.code {\n             if ctx.config.disabled.contains(code.as_str()) {\n                 continue;\n             }\n         }\n+        if ctx.config.disable_experimental && d.experimental {\n+            continue;\n+        }\n         res.push(d)\n     }\n \n@@ -452,43 +467,6 @@ mod tests {\n         assert_eq!(expected, actual);\n     }\n \n-    #[test]\n-    fn test_unresolved_macro_range() {\n-        check_diagnostics(\n-            r#\"\n-foo::bar!(92);\n-   //^^^ unresolved macro `foo::bar!`\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn unresolved_import_in_use_tree() {\n-        // Only the relevant part of a nested `use` item should be highlighted.\n-        check_diagnostics(\n-            r#\"\n-use does_exist::{Exists, DoesntExist};\n-                       //^^^^^^^^^^^ unresolved import\n-\n-use {does_not_exist::*, does_exist};\n-   //^^^^^^^^^^^^^^^^^ unresolved import\n-\n-use does_not_exist::{\n-    a,\n-  //^ unresolved import\n-    b,\n-  //^ unresolved import\n-    c,\n-  //^ unresolved import\n-};\n-\n-mod does_exist {\n-    pub struct Exists;\n-}\n-\"#,\n-        );\n-    }\n-\n     #[test]\n     fn range_mapping_out_of_macros() {\n         // FIXME: this is very wrong, but somewhat tricky to fix."}, {"sha": "1cbf96ba1fc816b75d978a876538a265355f7217", "filename": "crates/ide/src/diagnostics/unresolved_import.rs", "status": "added", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/3d8df2aef87bca7ec3f0994d799462f08d1ad449/crates%2Fide%2Fsrc%2Fdiagnostics%2Funresolved_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d8df2aef87bca7ec3f0994d799462f08d1ad449/crates%2Fide%2Fsrc%2Fdiagnostics%2Funresolved_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fdiagnostics%2Funresolved_import.rs?ref=3d8df2aef87bca7ec3f0994d799462f08d1ad449", "patch": "@@ -0,0 +1,90 @@\n+use crate::diagnostics::{Diagnostic, DiagnosticsContext};\n+\n+// Diagnostic: unresolved-import\n+//\n+// This diagnostic is triggered if rust-analyzer is unable to resolve a path in\n+// a `use` declaration.\n+pub(super) fn unresolved_import(\n+    ctx: &DiagnosticsContext<'_>,\n+    d: &hir::UnresolvedImport,\n+) -> Diagnostic {\n+    Diagnostic::new(\n+        \"unresolved-import\",\n+        \"unresolved import\",\n+        ctx.sema.diagnostics_display_range(d.decl.clone().map(|it| it.into())).range,\n+    )\n+    // This currently results in false positives in the following cases:\n+    // - `cfg_if!`-generated code in libstd (we don't load the sysroot correctly)\n+    // - `core::arch` (we don't handle `#[path = \"../<path>\"]` correctly)\n+    // - proc macros and/or proc macro generated code\n+    .experimental()\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::diagnostics::tests::check_diagnostics;\n+\n+    #[test]\n+    fn unresolved_import() {\n+        check_diagnostics(\n+            r#\"\n+use does_exist;\n+use does_not_exist;\n+  //^^^^^^^^^^^^^^ unresolved import\n+\n+mod does_exist {}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn unresolved_import_in_use_tree() {\n+        // Only the relevant part of a nested `use` item should be highlighted.\n+        check_diagnostics(\n+            r#\"\n+use does_exist::{Exists, DoesntExist};\n+                       //^^^^^^^^^^^ unresolved import\n+\n+use {does_not_exist::*, does_exist};\n+   //^^^^^^^^^^^^^^^^^ unresolved import\n+\n+use does_not_exist::{\n+    a,\n+  //^ unresolved import\n+    b,\n+  //^ unresolved import\n+    c,\n+  //^ unresolved import\n+};\n+\n+mod does_exist {\n+    pub struct Exists;\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn dedup_unresolved_import_from_unresolved_crate() {\n+        check_diagnostics(\n+            r#\"\n+//- /main.rs crate:main\n+mod a {\n+    extern crate doesnotexist;\n+  //^^^^^^^^^^^^^^^^^^^^^^^^^^ unresolved extern crate\n+\n+    // Should not error, since we already errored for the missing crate.\n+    use doesnotexist::{self, bla, *};\n+\n+    use crate::doesnotexist;\n+      //^^^^^^^^^^^^^^^^^^^ unresolved import\n+}\n+\n+mod m {\n+    use super::doesnotexist;\n+      //^^^^^^^^^^^^^^^^^^^ unresolved import\n+}\n+\"#,\n+        );\n+    }\n+}"}, {"sha": "a3af332a4637c452db2d02a77ad0e2569b5546b5", "filename": "crates/ide/src/diagnostics/unresolved_macro_call.rs", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/3d8df2aef87bca7ec3f0994d799462f08d1ad449/crates%2Fide%2Fsrc%2Fdiagnostics%2Funresolved_macro_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d8df2aef87bca7ec3f0994d799462f08d1ad449/crates%2Fide%2Fsrc%2Fdiagnostics%2Funresolved_macro_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fdiagnostics%2Funresolved_macro_call.rs?ref=3d8df2aef87bca7ec3f0994d799462f08d1ad449", "patch": "@@ -0,0 +1,72 @@\n+use hir::{db::AstDatabase, InFile};\n+use syntax::{AstNode, SyntaxNodePtr};\n+\n+use crate::diagnostics::{Diagnostic, DiagnosticsContext};\n+\n+// Diagnostic: unresolved-macro-call\n+//\n+// This diagnostic is triggered if rust-analyzer is unable to resolve the path\n+// to a macro in a macro invocation.\n+pub(super) fn unresolved_macro_call(\n+    ctx: &DiagnosticsContext<'_>,\n+    d: &hir::UnresolvedMacroCall,\n+) -> Diagnostic {\n+    let last_path_segment = ctx.sema.db.parse_or_expand(d.macro_call.file_id).and_then(|root| {\n+        d.macro_call\n+            .value\n+            .to_node(&root)\n+            .path()\n+            .and_then(|it| it.segment())\n+            .and_then(|it| it.name_ref())\n+            .map(|it| InFile::new(d.macro_call.file_id, SyntaxNodePtr::new(it.syntax())))\n+    });\n+    let diagnostics = last_path_segment.unwrap_or_else(|| d.macro_call.clone().map(|it| it.into()));\n+\n+    Diagnostic::new(\n+        \"unresolved-macro-call\",\n+        format!(\"unresolved macro `{}!`\", d.path),\n+        ctx.sema.diagnostics_display_range(diagnostics).range,\n+    )\n+    .experimental()\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::diagnostics::tests::check_diagnostics;\n+\n+    #[test]\n+    fn test_unresolved_macro_range() {\n+        check_diagnostics(\n+            r#\"\n+foo::bar!(92);\n+   //^^^ unresolved macro `foo::bar!`\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn unresolved_legacy_scope_macro() {\n+        check_diagnostics(\n+            r#\"\n+macro_rules! m { () => {} }\n+\n+m!(); m2!();\n+    //^^ unresolved macro `self::m2!`\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn unresolved_module_scope_macro() {\n+        check_diagnostics(\n+            r#\"\n+mod mac {\n+#[macro_export]\n+macro_rules! m { () => {} } }\n+\n+self::m!(); self::m2!();\n+                //^^ unresolved macro `self::m2!`\n+\"#,\n+        );\n+    }\n+}"}, {"sha": "b1da8f0e1cb21732c28acc5efc83bb8d07f85ebe", "filename": "crates/ide/src/diagnostics/unresolved_module.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3d8df2aef87bca7ec3f0994d799462f08d1ad449/crates%2Fide%2Fsrc%2Fdiagnostics%2Funresolved_module.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d8df2aef87bca7ec3f0994d799462f08d1ad449/crates%2Fide%2Fsrc%2Fdiagnostics%2Funresolved_module.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fdiagnostics%2Funresolved_module.rs?ref=3d8df2aef87bca7ec3f0994d799462f08d1ad449", "patch": "@@ -104,6 +104,7 @@ mod baz {}\n                                 \"unresolved-module\",\n                             ),\n                         ),\n+                        experimental: false,\n                     },\n                 ]\n             \"#]],"}]}