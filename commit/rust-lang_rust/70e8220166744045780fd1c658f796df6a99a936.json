{"sha": "70e8220166744045780fd1c658f796df6a99a936", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcwZTgyMjAxNjY3NDQwNDU3ODBmZDFjNjU4Zjc5NmRmNmE5OWE5MzY=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-07-22T23:22:51Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-07-22T23:22:51Z"}, "message": "trans: Consolidate creating pass manager builders\n\nThe LTO pass in the compiler forgot to call the `LLVMRustAddBuilderLibraryInfo`\nfunction and configure other options such as merge_functions, vectorize_slp,\netc. This ended up causing linker errors on MSVC targets because the optimizer\ndidn't have the right knowledge that some system functions are missing on these\nplatforms.\n\nThis commit consolidates creation of PassManagerBuilder instances to one\nfunction which is then called when needed. This ensures that the pass manager is\nalways correctly configured with the various target-specific information that\nLLVM needs.\n\nOverall, this fixes `-C lto -C opt-level=3` on 32-bit MSVC targets.", "tree": {"sha": "82d358a773f840241f04c3584c84b6b7cc5d1cbf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/82d358a773f840241f04c3584c84b6b7cc5d1cbf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/70e8220166744045780fd1c658f796df6a99a936", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/70e8220166744045780fd1c658f796df6a99a936", "html_url": "https://github.com/rust-lang/rust/commit/70e8220166744045780fd1c658f796df6a99a936", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/70e8220166744045780fd1c658f796df6a99a936/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "55428306657c5b42a26183c90fcd06e1ee7b94f5", "url": "https://api.github.com/repos/rust-lang/rust/commits/55428306657c5b42a26183c90fcd06e1ee7b94f5", "html_url": "https://github.com/rust-lang/rust/commit/55428306657c5b42a26183c90fcd06e1ee7b94f5"}], "stats": {"total": 149, "additions": 70, "deletions": 79}, "files": [{"sha": "518add44b4c4a6b5622adad232e10daa0e8983ef", "filename": "src/librustc_trans/back/lto.rs", "status": "modified", "additions": 8, "deletions": 14, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/70e8220166744045780fd1c658f796df6a99a936/src%2Flibrustc_trans%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70e8220166744045780fd1c658f796df6a99a936/src%2Flibrustc_trans%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flto.rs?ref=70e8220166744045780fd1c658f796df6a99a936", "patch": "@@ -16,14 +16,16 @@ use llvm::archive_ro::ArchiveRO;\n use llvm::{ModuleRef, TargetMachineRef, True, False};\n use rustc::metadata::cstore;\n use rustc::util::common::time;\n+use back::write::{ModuleConfig, with_llvm_pmb};\n \n use libc;\n use flate;\n \n use std::ffi::CString;\n \n pub fn run(sess: &session::Session, llmod: ModuleRef,\n-           tm: TargetMachineRef, reachable: &[String]) {\n+           tm: TargetMachineRef, reachable: &[String],\n+           config: &ModuleConfig) {\n     if sess.opts.cg.prefer_dynamic {\n         sess.err(\"cannot prefer dynamic linking when performing LTO\");\n         sess.note(\"only 'staticlib' and 'bin' outputs are supported with LTO\");\n@@ -144,19 +146,11 @@ pub fn run(sess: &session::Session, llmod: ModuleRef,\n         llvm::LLVMRustAddAnalysisPasses(tm, pm, llmod);\n         llvm::LLVMRustAddPass(pm, \"verify\\0\".as_ptr() as *const _);\n \n-        let opt = match sess.opts.optimize {\n-            config::No => 0,\n-            config::Less => 1,\n-            config::Default => 2,\n-            config::Aggressive => 3,\n-        };\n-\n-        let builder = llvm::LLVMPassManagerBuilderCreate();\n-        llvm::LLVMPassManagerBuilderSetOptLevel(builder, opt);\n-        llvm::LLVMPassManagerBuilderPopulateLTOPassManager(builder, pm,\n-            /* Internalize = */ False,\n-            /* RunInliner = */ True);\n-        llvm::LLVMPassManagerBuilderDispose(builder);\n+        with_llvm_pmb(llmod, config, &mut |b| {\n+            llvm::LLVMPassManagerBuilderPopulateLTOPassManager(b, pm,\n+                /* Internalize = */ False,\n+                /* RunInliner = */ True);\n+        });\n \n         llvm::LLVMRustAddPass(pm, \"verify\\0\".as_ptr() as *const _);\n "}, {"sha": "b901e31a53a001861661355ee8b23b7c7a52fd24", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 62, "deletions": 65, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/70e8220166744045780fd1c658f796df6a99a936/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70e8220166744045780fd1c658f796df6a99a936/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=70e8220166744045780fd1c658f796df6a99a936", "patch": "@@ -249,7 +249,7 @@ pub fn create_target_machine(sess: &Session) -> TargetMachineRef {\n \n /// Module-specific configuration for `optimize_and_codegen`.\n #[derive(Clone)]\n-struct ModuleConfig {\n+pub struct ModuleConfig {\n     /// LLVM TargetMachine to use for codegen.\n     tm: TargetMachineRef,\n     /// Names of additional optimization passes to run.\n@@ -444,72 +444,72 @@ unsafe fn optimize_and_codegen(cgcx: &CodegenContext,\n         llvm::LLVMWriteBitcodeToFile(llmod, out.as_ptr());\n     }\n \n-    match config.opt_level {\n-        Some(opt_level) => {\n-            // Create the two optimizing pass managers. These mirror what clang\n-            // does, and are by populated by LLVM's default PassManagerBuilder.\n-            // Each manager has a different set of passes, but they also share\n-            // some common passes.\n-            let fpm = llvm::LLVMCreateFunctionPassManagerForModule(llmod);\n-            let mpm = llvm::LLVMCreatePassManager();\n-\n-            // If we're verifying or linting, add them to the function pass\n-            // manager.\n-            let addpass = |pass: &str| {\n-                let pass = CString::new(pass).unwrap();\n-                llvm::LLVMRustAddPass(fpm, pass.as_ptr())\n-            };\n+    if config.opt_level.is_some() {\n+        // Create the two optimizing pass managers. These mirror what clang\n+        // does, and are by populated by LLVM's default PassManagerBuilder.\n+        // Each manager has a different set of passes, but they also share\n+        // some common passes.\n+        let fpm = llvm::LLVMCreateFunctionPassManagerForModule(llmod);\n+        let mpm = llvm::LLVMCreatePassManager();\n+\n+        // If we're verifying or linting, add them to the function pass\n+        // manager.\n+        let addpass = |pass: &str| {\n+            let pass = CString::new(pass).unwrap();\n+            llvm::LLVMRustAddPass(fpm, pass.as_ptr())\n+        };\n \n-            if !config.no_verify { assert!(addpass(\"verify\")); }\n-            if !config.no_prepopulate_passes {\n-                llvm::LLVMRustAddAnalysisPasses(tm, fpm, llmod);\n-                llvm::LLVMRustAddAnalysisPasses(tm, mpm, llmod);\n-                populate_llvm_passes(fpm, mpm, llmod, opt_level, &config);\n-            }\n+        if !config.no_verify { assert!(addpass(\"verify\")); }\n+        if !config.no_prepopulate_passes {\n+            llvm::LLVMRustAddAnalysisPasses(tm, fpm, llmod);\n+            llvm::LLVMRustAddAnalysisPasses(tm, mpm, llmod);\n+            with_llvm_pmb(llmod, &config, &mut |b| {\n+                llvm::LLVMPassManagerBuilderPopulateFunctionPassManager(b, fpm);\n+                llvm::LLVMPassManagerBuilderPopulateModulePassManager(b, mpm);\n+            })\n+        }\n \n-            for pass in &config.passes {\n-                if !addpass(pass) {\n-                    cgcx.handler.warn(&format!(\"unknown pass `{}`, ignoring\",\n-                                               pass));\n-                }\n+        for pass in &config.passes {\n+            if !addpass(pass) {\n+                cgcx.handler.warn(&format!(\"unknown pass `{}`, ignoring\",\n+                                           pass));\n             }\n+        }\n \n-            for pass in &cgcx.plugin_passes {\n-                if !addpass(pass) {\n-                    cgcx.handler.err(&format!(\"a plugin asked for LLVM pass \\\n-                                               `{}` but LLVM does not \\\n-                                               recognize it\", pass));\n-                }\n+        for pass in &cgcx.plugin_passes {\n+            if !addpass(pass) {\n+                cgcx.handler.err(&format!(\"a plugin asked for LLVM pass \\\n+                                           `{}` but LLVM does not \\\n+                                           recognize it\", pass));\n             }\n+        }\n \n-            cgcx.handler.abort_if_errors();\n+        cgcx.handler.abort_if_errors();\n \n-            // Finally, run the actual optimization passes\n-            time(config.time_passes, \"llvm function passes\", (), |()|\n-                 llvm::LLVMRustRunFunctionPassManager(fpm, llmod));\n-            time(config.time_passes, \"llvm module passes\", (), |()|\n-                 llvm::LLVMRunPassManager(mpm, llmod));\n+        // Finally, run the actual optimization passes\n+        time(config.time_passes, \"llvm function passes\", (), |()|\n+             llvm::LLVMRustRunFunctionPassManager(fpm, llmod));\n+        time(config.time_passes, \"llvm module passes\", (), |()|\n+             llvm::LLVMRunPassManager(mpm, llmod));\n \n-            // Deallocate managers that we're now done with\n-            llvm::LLVMDisposePassManager(fpm);\n-            llvm::LLVMDisposePassManager(mpm);\n+        // Deallocate managers that we're now done with\n+        llvm::LLVMDisposePassManager(fpm);\n+        llvm::LLVMDisposePassManager(mpm);\n \n-            match cgcx.lto_ctxt {\n-                Some((sess, reachable)) if sess.lto() =>  {\n-                    time(sess.time_passes(), \"all lto passes\", (), |()|\n-                         lto::run(sess, llmod, tm, reachable));\n+        match cgcx.lto_ctxt {\n+            Some((sess, reachable)) if sess.lto() =>  {\n+                time(sess.time_passes(), \"all lto passes\", (), |()|\n+                     lto::run(sess, llmod, tm, reachable, &config));\n \n-                    if config.emit_lto_bc {\n-                        let name = format!(\"{}.lto.bc\", name_extra);\n-                        let out = output_names.with_extension(&name);\n-                        let out = path2cstr(&out);\n-                        llvm::LLVMWriteBitcodeToFile(llmod, out.as_ptr());\n-                    }\n-                },\n-                _ => {},\n-            }\n-        },\n-        None => {},\n+                if config.emit_lto_bc {\n+                    let name = format!(\"{}.lto.bc\", name_extra);\n+                    let out = output_names.with_extension(&name);\n+                    let out = path2cstr(&out);\n+                    llvm::LLVMWriteBitcodeToFile(llmod, out.as_ptr());\n+                }\n+            },\n+            _ => {},\n+        }\n     }\n \n     // A codegen-specific pass manager is used to generate object\n@@ -1001,15 +1001,14 @@ pub unsafe fn configure_llvm(sess: &Session) {\n                                  llvm_args.as_ptr());\n }\n \n-unsafe fn populate_llvm_passes(fpm: llvm::PassManagerRef,\n-                               mpm: llvm::PassManagerRef,\n-                               llmod: ModuleRef,\n-                               opt: llvm::CodeGenOptLevel,\n-                               config: &ModuleConfig) {\n+pub unsafe fn with_llvm_pmb(llmod: ModuleRef,\n+                            config: &ModuleConfig,\n+                            f: &mut FnMut(llvm::PassManagerBuilderRef)) {\n     // Create the PassManagerBuilder for LLVM. We configure it with\n     // reasonable defaults and prepare it to actually populate the pass\n     // manager.\n     let builder = llvm::LLVMPassManagerBuilderCreate();\n+    let opt = config.opt_level.unwrap_or(llvm::CodeGenLevelNone);\n \n     llvm::LLVMRustConfigurePassManagerBuilder(builder, opt,\n                                               config.merge_functions,\n@@ -1037,8 +1036,6 @@ unsafe fn populate_llvm_passes(fpm: llvm::PassManagerRef,\n         }\n     }\n \n-    // Use the builder to populate the function/module pass managers.\n-    llvm::LLVMPassManagerBuilderPopulateFunctionPassManager(builder, fpm);\n-    llvm::LLVMPassManagerBuilderPopulateModulePassManager(builder, mpm);\n+    f(builder);\n     llvm::LLVMPassManagerBuilderDispose(builder);\n }"}]}