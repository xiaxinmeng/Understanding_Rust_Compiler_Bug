{"sha": "d12ea3989649616437a7c1434f5c5a6438235eb7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQxMmVhMzk4OTY0OTYxNjQzN2E3YzE0MzRmNWM1YTY0MzgyMzVlYjc=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-05-30T21:10:54Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-05-31T18:00:47Z"}, "message": "Improve comment handling in pp.", "tree": {"sha": "87df43419acd4c48d25239c7b8b30b87c5c67a92", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/87df43419acd4c48d25239c7b8b30b87c5c67a92"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d12ea3989649616437a7c1434f5c5a6438235eb7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d12ea3989649616437a7c1434f5c5a6438235eb7", "html_url": "https://github.com/rust-lang/rust/commit/d12ea3989649616437a7c1434f5c5a6438235eb7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d12ea3989649616437a7c1434f5c5a6438235eb7/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "30f83484738f796e436e44111800ca26d5ca789f", "url": "https://api.github.com/repos/rust-lang/rust/commits/30f83484738f796e436e44111800ca26d5ca789f", "html_url": "https://github.com/rust-lang/rust/commit/30f83484738f796e436e44111800ca26d5ca789f"}], "stats": {"total": 538, "additions": 333, "deletions": 205}, "files": [{"sha": "d87df08745320769882e88f1a47f919bfa007964", "filename": "src/comp/front/lexer.rs", "status": "modified", "additions": 162, "deletions": 57, "changes": 219, "blob_url": "https://github.com/rust-lang/rust/blob/d12ea3989649616437a7c1434f5c5a6438235eb7/src%2Fcomp%2Ffront%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d12ea3989649616437a7c1434f5c5a6438235eb7/src%2Fcomp%2Ffront%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Flexer.rs?ref=d12ea3989649616437a7c1434f5c5a6438235eb7", "patch": "@@ -22,6 +22,7 @@ state type reader = state obj {\n     fn get_mark_chpos() -> uint;\n     fn get_interner() -> @interner::interner[str];\n     fn get_chpos() -> uint;\n+    fn get_col() -> uint;\n     fn get_filemap() -> codemap::filemap;\n     fn err(str m);\n };\n@@ -33,6 +34,7 @@ fn new_reader(session sess, io::reader rdr,\n     state obj reader(session sess,\n                      str file,\n                      uint len,\n+                     mutable uint col,\n                      mutable uint pos,\n                      mutable char ch,\n                      mutable uint mark_chpos,\n@@ -68,9 +70,11 @@ fn new_reader(session sess, io::reader rdr,\n \n         fn bump() {\n             if (pos < len) {\n+                col += 1u;\n                 chpos += 1u;\n                 if (ch == '\\n') {\n                     codemap::next_line(fm, chpos);\n+                    col = 0u;\n                 }\n                 auto next = str::char_range_at(file, pos);\n                 pos = next._1;\n@@ -82,6 +86,10 @@ fn new_reader(session sess, io::reader rdr,\n \n         fn get_interner() -> @interner::interner[str] { ret itr; }\n \n+        fn get_col() -> uint {\n+            ret col;\n+        }\n+\n         fn get_filemap() -> codemap::filemap {\n             ret fm;\n         }\n@@ -92,7 +100,8 @@ fn new_reader(session sess, io::reader rdr,\n     }\n     auto file = str::unsafe_from_bytes(rdr.read_whole_stream());\n     let vec[str] strs = [];\n-    auto rd = reader(sess, file, str::byte_len(file), 0u, -1 as char,\n+    auto rd = reader(sess, file, str::byte_len(file), 0u, 0u,\n+                     -1 as char,\n                      filemap.start_pos, filemap.start_pos,\n                      strs, filemap, itr);\n     rd.init();\n@@ -155,7 +164,7 @@ fn is_whitespace(char c) -> bool {\n     ret c == ' ' || c == '\\t' || c == '\\r' || c == '\\n';\n }\n \n-fn consume_any_whitespace(&reader rdr) {\n+fn consume_whitespace_and_comments(&reader rdr) {\n     while (is_whitespace(rdr.curr())) {\n         rdr.bump();\n     }\n@@ -170,7 +179,7 @@ fn consume_any_line_comment(&reader rdr) {\n                     rdr.bump();\n                 }\n                 // Restart whitespace munch.\n-                be consume_any_whitespace(rdr);\n+                be consume_whitespace_and_comments(rdr);\n             }\n             case ('*') {\n                 rdr.bump();\n@@ -207,7 +216,7 @@ fn consume_block_comment(&reader rdr) {\n         }\n     }\n     // restart whitespace munch.\n-    be consume_any_whitespace(rdr);\n+    be consume_whitespace_and_comments(rdr);\n }\n \n fn digits_to_string(str s) -> int {\n@@ -430,7 +439,7 @@ fn scan_numeric_escape(&reader rdr, uint n_hex_digits) -> char {\n fn next_token(&reader rdr) -> token::token {\n     auto accum_str = \"\";\n \n-    consume_any_whitespace(rdr);\n+    consume_whitespace_and_comments(rdr);\n \n     if (rdr.is_eof()) { ret token::EOF; }\n \n@@ -720,70 +729,161 @@ fn next_token(&reader rdr) -> token::token {\n     fail;\n }\n \n-tag cmnt_ {\n-    cmnt_line(str);\n-    cmnt_block(vec[str]);\n+\n+tag cmnt_style {\n+    isolated;  // No code on either side of each line of the comment\n+    trailing;  // Code exists to the left of the comment\n+    mixed;     // Code before /* foo */ and after the comment\n }\n \n-type cmnt = rec(cmnt_ val, uint pos, bool space_after);\n+type cmnt = rec(cmnt_style style, vec[str] lines, uint pos);\n \n-fn consume_whitespace(&reader rdr) -> uint {\n-    auto lines = 0u;\n-    while (is_whitespace(rdr.curr())) {\n-        if (rdr.curr() == '\\n') {lines += 1u;}\n+fn read_to_eol(&reader rdr) -> str {\n+    auto val = \"\";\n+    while (rdr.curr() != '\\n' && !rdr.is_eof()) {\n+        str::push_char(val, rdr.curr());\n+        rdr.bump();\n+    }\n+    if (rdr.curr() == '\\n') {\n         rdr.bump();\n+    } else {\n+        assert rdr.is_eof();\n     }\n-    ret lines;\n+    ret val;\n }\n \n-fn read_line_comment(&reader rdr) -> cmnt {\n-    auto p = rdr.get_chpos();\n-    rdr.bump(); rdr.bump();\n-    while (rdr.curr() == ' ') {rdr.bump();}\n-    auto val = \"\";\n-    while (rdr.curr() != '\\n' && !rdr.is_eof()) {\n-        str::push_char(val, rdr.curr());\n+fn read_one_line_comment(&reader rdr) -> str {\n+    auto val = read_to_eol(rdr);\n+    assert val.(0) == ('/' as u8) && val.(1) == ('/' as u8);\n+    ret val;\n+}\n+\n+fn consume_whitespace(&reader rdr) {\n+    while (is_whitespace(rdr.curr()) && !rdr.is_eof()) {\n         rdr.bump();\n     }\n-    ret rec(val=cmnt_line(val),\n-            pos=p,\n-            space_after=consume_whitespace(rdr) > 1u);\n }\n \n-fn read_block_comment(&reader rdr) -> cmnt {\n+\n+fn consume_non_eol_whitespace(&reader rdr) {\n+    while (is_whitespace(rdr.curr()) &&\n+           rdr.curr() != '\\n' && !rdr.is_eof()) {\n+        rdr.bump();\n+    }\n+}\n+\n+\n+fn read_line_comments(&reader rdr, bool code_to_the_left) -> cmnt {\n+    log \">>> line comments\";\n     auto p = rdr.get_chpos();\n-    rdr.bump(); rdr.bump();\n-    while (rdr.curr() == ' ') {rdr.bump();}\n     let vec[str] lines = [];\n-    auto val = \"\";\n-    auto level = 1;\n-    while (true) {\n-        if (rdr.curr() == '\\n') {\n-            vec::push[str](lines, val);\n-            val = \"\";\n-            consume_whitespace(rdr);\n+    while (rdr.curr() == '/' && rdr.next() == '/') {\n+        lines += [read_one_line_comment(rdr)];\n+        consume_non_eol_whitespace(rdr);\n+    }\n+    log \"<<< line comments\";\n+    ret rec(style = if (code_to_the_left) { trailing } else { isolated },\n+            lines = lines,\n+            pos=p);\n+}\n+\n+fn all_whitespace(&str s, uint begin, uint end) -> bool {\n+    let uint i = begin;\n+    while (i != end) {\n+        if (!is_whitespace(s.(i) as char)) {\n+            ret false;\n+        }\n+        i += 1u;\n+    }\n+    ret true;\n+}\n+\n+fn trim_whitespace_prefix_and_push_line(&mutable vec[str] lines,\n+                                        &str s, uint col) {\n+    auto s1;\n+    if (all_whitespace(s, 0u, col)) {\n+        if (col < str::byte_len(s)) {\n+            s1 = str::slice(s, col, str::byte_len(s));\n         } else {\n-            if (rdr.curr() == '*' && rdr.next() == '/') {\n-                level -= 1;\n-                if (level == 0) {\n-                    rdr.bump(); rdr.bump();\n-                    vec::push[str](lines, val);\n-                    break;\n-                }\n-            } else if (rdr.curr() == '/' && rdr.next() == '*') {\n-                level += 1;\n-            }\n-            str::push_char(val, rdr.curr());\n-            rdr.bump();\n+            s1 = \"\";\n         }\n+    } else {\n+        s1 = s;\n+    }\n+    log \"pushing line: \" + s1;\n+    lines += [s1];\n+}\n+\n+fn read_block_comment(&reader rdr,\n+                      bool code_to_the_left) -> cmnt {\n+    log \">>> block comment\";\n+    auto p = rdr.get_chpos();\n+    let vec[str] lines = [];\n+    let uint col = rdr.get_col();\n+    rdr.bump();\n+    rdr.bump();\n+    auto curr_line = \"/*\";\n+    let int level = 1;\n+    while (level > 0) {\n+        log #fmt(\"=== block comment level %d\", level);\n         if (rdr.is_eof()) {\n-            rdr.err(\"Unexpected end of file in block comment\");\n+            rdr.err(\"unterminated block comment\");\n             fail;\n         }\n+        if (rdr.curr() == '\\n') {\n+            trim_whitespace_prefix_and_push_line(lines, curr_line, col);\n+            curr_line = \"\";\n+            rdr.bump();\n+        } else {\n+            str::push_char(curr_line, rdr.curr());\n+            if (rdr.curr() == '/' && rdr.next() == '*') {\n+                rdr.bump();\n+                rdr.bump();\n+                curr_line += \"*\";\n+                level += 1;\n+            } else {\n+                if (rdr.curr() == '*' && rdr.next() == '/') {\n+                    rdr.bump();\n+                    rdr.bump();\n+                    curr_line += \"/\";\n+                    level -= 1;\n+                } else {\n+                    rdr.bump();\n+                }\n+            }\n+        }\n     }\n-    ret rec(val=cmnt_block(lines),\n-            pos=p,\n-            space_after=consume_whitespace(rdr) > 1u);\n+    if (str::byte_len(curr_line) != 0u) {\n+        trim_whitespace_prefix_and_push_line(lines, curr_line, col);\n+    }\n+\n+    auto style = if (code_to_the_left) { trailing } else { isolated };\n+    consume_non_eol_whitespace(rdr);\n+    if (!rdr.is_eof() &&\n+        rdr.curr() != '\\n' &&\n+        vec::len(lines) == 1u) {\n+        style = mixed;\n+    }\n+    log \"<<< block comment\";\n+    ret rec(style = style, lines = lines, pos=p);\n+}\n+\n+fn peeking_at_comment(&reader rdr) -> bool {\n+    ret (rdr.curr() == '/' && rdr.next() == '/') ||\n+        (rdr.curr() == '/' && rdr.next() == '*');\n+}\n+\n+fn consume_comment(&reader rdr, bool code_to_the_left,\n+                   &mutable vec[cmnt] comments) {\n+    log \">>> consume comment\";\n+    if (rdr.curr() == '/' && rdr.next() == '/') {\n+        vec::push[cmnt](comments,\n+                        read_line_comments(rdr, code_to_the_left));\n+    } else if (rdr.curr() == '/' && rdr.next() == '*') {\n+        vec::push[cmnt](comments,\n+                        read_block_comment(rdr, code_to_the_left));\n+    } else { fail; }\n+    log \"<<< consume comment\";\n }\n \n fn gather_comments(session sess, str path) -> vec[cmnt] {\n@@ -793,17 +893,22 @@ fn gather_comments(session sess, str path) -> vec[cmnt] {\n     let vec[cmnt] comments = [];\n     while (!rdr.is_eof()) {\n         while (true) {\n-            consume_whitespace(rdr);\n-            if (rdr.curr() == '/' && rdr.next() == '/') {\n-                vec::push[cmnt](comments, read_line_comment(rdr));\n-            } else if (rdr.curr() == '/' && rdr.next() == '*') {\n-                vec::push[cmnt](comments, read_block_comment(rdr));\n-            } else { break; }\n+            auto code_to_the_left = true;\n+            consume_non_eol_whitespace(rdr);\n+            if (rdr.next() == '\\n') {\n+                code_to_the_left = false;\n+                consume_whitespace(rdr);\n+            }\n+            while (peeking_at_comment(rdr)) {\n+                consume_comment(rdr, code_to_the_left, comments);\n+                consume_whitespace(rdr);\n+            }\n+            break;\n         }\n         next_token(rdr);\n     }\n     ret comments;\n-}\n+ }\n \n \n //"}, {"sha": "803d75250ac56ffb9cefc1e60ef2525f5fd453c3", "filename": "src/comp/front/parser.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d12ea3989649616437a7c1434f5c5a6438235eb7/src%2Fcomp%2Ffront%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d12ea3989649616437a7c1434f5c5a6438235eb7/src%2Fcomp%2Ffront%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fparser.rs?ref=d12ea3989649616437a7c1434f5c5a6438235eb7", "patch": "@@ -164,7 +164,7 @@ fn new_parser(session::session sess,\n     auto itr = @interner::mk[str](str::hash, str::eq);\n     auto rdr = lexer::new_reader(sess, srdr, filemap, itr);\n     // Make sure npos points at first actual token:\n-    lexer::consume_any_whitespace(rdr);\n+    lexer::consume_whitespace_and_comments(rdr);\n     auto npos = rdr.get_chpos();\n     ret stdio_parser(sess, env, ftype, lexer::next_token(rdr),\n                      npos, npos, npos, initial_def._1, UNRESTRICTED,"}, {"sha": "98b002a904d9efe7405933beeef1fb495f85db9f", "filename": "src/comp/pretty/pp.rs", "status": "modified", "additions": 35, "deletions": 12, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/d12ea3989649616437a7c1434f5c5a6438235eb7/src%2Fcomp%2Fpretty%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d12ea3989649616437a7c1434f5c5a6438235eb7/src%2Fcomp%2Fpretty%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fpretty%2Fpp.rs?ref=d12ea3989649616437a7c1434f5c5a6438235eb7", "patch": "@@ -34,14 +34,33 @@ import std::str;\n  * I also inverted the indentation arithmetic used in the print stack, since\n  * the Mesa implementation (somewhat randomly) stores the offset on the print\n  * stack in terms of margin-col rather than col itself. I store col.\n+ *\n+ * I also implemented a small change in the STRING token, in that I store an\n+ * explicit length for the string. For most tokens this is just the length of\n+ * the accompanying string. But it's necessary to permit it to differ, for\n+ * encoding things that are supposed to \"go on their own line\" -- certain\n+ * classes of comment and blank-line -- where relying on adjacent\n+ * hardbreak-like BREAK tokens with long blankness indication doesn't actually\n+ * work. To see why, consider when there is a \"thing that should be on its own\n+ * line\" between two long blocks, say functions. If you put a hardbreak after\n+ * each function (or before each) and the breaking algorithm decides to break\n+ * there anyways (because the functions themselves are long) you wind up with\n+ * extra blank lines. If you don't put hardbreaks you can wind up with the\n+ * \"thing which should be on its own line\" not getting its own line in the\n+ * rare case of \"really small functions\" or such. This re-occurs with comments\n+ * and explicit blank lines. So in those cases we use a string with a payload\n+ * we want isolated to a line and an explicit length that's huge, surrounded\n+ * by two zero-length breaks. The algorithm will try its best to fit it on a\n+ * line (which it can't) and so naturally place the content on its own line to\n+ * avoid combining it with other lines and making matters even worse.\n  */\n \n tag breaks { consistent; inconsistent; }\n type break_t = rec(int offset, int blank_space);\n type begin_t = rec(int offset, breaks breaks);\n \n tag token {\n-    STRING(str);\n+    STRING(str,int);\n     BREAK(break_t);\n     BEGIN(begin_t);\n     END;\n@@ -51,7 +70,7 @@ tag token {\n \n fn tok_str(token t) -> str {\n     alt (t) {\n-        case (STRING(?s)) { ret \"STR(\" + s + \")\"; }\n+        case (STRING(?s, ?len)) { ret #fmt(\"STR(%s,%d)\", s, len); }\n         case (BREAK(_)) { ret \"BREAK\"; }\n         case (BEGIN(_)) { ret \"BEGIN\"; }\n         case (END) { ret \"END\"; }\n@@ -279,8 +298,7 @@ obj printer(io::writer out,\n                 right_total += b.blank_space;\n             }\n \n-            case (STRING(?s)) {\n-                auto len = str::char_len(s) as int;\n+            case (STRING(?s, ?len)) {\n                 if (scan_stack_empty) {\n                     log #fmt(\"pp STRING/print [%u,%u]\", left, right);\n                     self.print(t, len);\n@@ -370,10 +388,9 @@ obj printer(io::writer out,\n                 case (BREAK(?b)) {\n                     left_total += b.blank_space;\n                 }\n-                case (STRING(?s)) {\n-                    // I think? paper says '1' here but 1 and L look same in\n-                    // it.\n-                    left_total += L;\n+                case (STRING(_, ?len)) {\n+                    assert len == L;\n+                    left_total += len;\n                 }\n                 case (_) {}\n             }\n@@ -486,11 +503,11 @@ obj printer(io::writer out,\n                 }\n             }\n \n-            case (STRING(?s)) {\n+            case (STRING(?s, ?len)) {\n                 log \"print STRING\";\n-                assert L as uint == str::char_len(s);\n+                assert L == len;\n                 // assert L <= space;\n-                space -= L;\n+                space -= len;\n                 out.write_str(s);\n             }\n \n@@ -527,8 +544,14 @@ fn break_offset(printer p, uint n, int off) {\n \n fn end(printer p) { p.pretty_print(END); }\n fn eof(printer p) { p.pretty_print(EOF); }\n-fn wrd(printer p, str wrd) { p.pretty_print(STRING(wrd)); }\n+fn word(printer p, str wrd) {\n+    p.pretty_print(STRING(wrd, str::char_len(wrd) as int));\n+}\n+fn word_and_eol(printer p, str wrd) {\n+    p.pretty_print(STRING(wrd, 0xffff));\n+}\n fn spaces(printer p, uint n) { break_offset(p, n, 0); }\n+fn zerobreak(printer p) { spaces(p, 0u); }\n fn space(printer p) { spaces(p, 1u); }\n fn hardbreak(printer p) { spaces(p, 0xffffu); }\n "}, {"sha": "e9275e4b4bfe88ece0f97189cf3c9081832a9cc3", "filename": "src/comp/pretty/pprust.rs", "status": "modified", "additions": 135, "deletions": 135, "changes": 270, "blob_url": "https://github.com/rust-lang/rust/blob/d12ea3989649616437a7c1434f5c5a6438235eb7/src%2Fcomp%2Fpretty%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d12ea3989649616437a7c1434f5c5a6438235eb7/src%2Fcomp%2Fpretty%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fpretty%2Fpprust.rs?ref=d12ea3989649616437a7c1434f5c5a6438235eb7", "patch": "@@ -14,8 +14,10 @@ import pp::break_offset;\n import pp::box;\n import pp::cbox;\n import pp::ibox;\n-import pp::wrd;\n+import pp::word;\n+import pp::word_and_eol;\n import pp::space;\n+import pp::zerobreak;\n import pp::hardbreak;\n import pp::breaks;\n import pp::consistent;\n@@ -82,42 +84,42 @@ fn pat_to_str(&@ast::pat p) -> str {\n     ret writer.get_str();\n }\n \n-fn word_nbsp(ps s, str word) {\n-    wrd(s.s, word);\n-    wrd(s.s, \" \");\n+fn word_nbsp(ps s, str w) {\n+    word(s.s, w);\n+    word(s.s, \" \");\n }\n \n-fn word_space(ps s, str word) {\n-    wrd(s.s, word);\n+fn word_space(ps s, str w) {\n+    word(s.s, w);\n     space(s.s);\n }\n \n fn popen(ps s) {\n-    wrd(s.s, \"(\");\n+    word(s.s, \"(\");\n }\n \n fn pclose(ps s) {\n-    wrd(s.s, \")\");\n+    word(s.s, \")\");\n }\n \n-fn head(ps s, str word) {\n+fn head(ps s, str w) {\n     // outer-box is consistent\n     cbox(s.s, indent_unit);\n     // head-box is inconsistent\n-    ibox(s.s, str::char_len(word) + 1u);\n+    ibox(s.s, str::char_len(w) + 1u);\n     // keyword that starts the head\n-    word_nbsp(s, word);\n+    word_nbsp(s, w);\n }\n \n fn bopen(ps s) {\n-    wrd(s.s, \"{\");\n+    word(s.s, \"{\");\n     end(s.s); // close the head-box\n }\n \n fn bclose(ps s, common::span span) {\n     maybe_print_comment(s, span.hi);\n     break_offset(s.s, 1u, -(indent_unit as int));\n-    wrd(s.s, \"}\");\n+    word(s.s, \"}\");\n     end(s.s); // close the outer-box\n }\n \n@@ -141,7 +143,7 @@ fn commasep_cmnt[IN](ps s, breaks b, vec[IN] elts, fn(ps, &IN) op,\n         op(s, elt);\n         i += 1u;\n         if (i < len) {\n-            wrd(s.s, \",\");\n+            word(s.s, \",\");\n             if (!maybe_print_line_comment(s, get_span(elt))) {space(s.s);}\n         }\n     }\n@@ -172,41 +174,41 @@ fn print_type(ps s, &@ast::ty ty) {\n     maybe_print_comment(s, ty.span.lo);\n     ibox(s.s, 0u);\n     alt (ty.node) {\n-        case (ast::ty_nil) {wrd(s.s, \"()\");}\n-        case (ast::ty_bool) {wrd(s.s, \"bool\");}\n-        case (ast::ty_bot) {wrd(s.s, \"_|_\");}\n-        case (ast::ty_int) {wrd(s.s, \"int\");}\n-        case (ast::ty_uint) {wrd(s.s, \"uint\");}\n-        case (ast::ty_float) {wrd(s.s, \"float\");}\n-        case (ast::ty_machine(?tm)) {wrd(s.s, common::ty_mach_to_str(tm));}\n-        case (ast::ty_char) {wrd(s.s, \"char\");}\n-        case (ast::ty_str) {wrd(s.s, \"str\");}\n-        case (ast::ty_box(?mt)) {wrd(s.s, \"@\"); print_mt(s, mt);}\n+        case (ast::ty_nil) {word(s.s, \"()\");}\n+        case (ast::ty_bool) {word(s.s, \"bool\");}\n+        case (ast::ty_bot) {word(s.s, \"_|_\");}\n+        case (ast::ty_int) {word(s.s, \"int\");}\n+        case (ast::ty_uint) {word(s.s, \"uint\");}\n+        case (ast::ty_float) {word(s.s, \"float\");}\n+        case (ast::ty_machine(?tm)) {word(s.s, common::ty_mach_to_str(tm));}\n+        case (ast::ty_char) {word(s.s, \"char\");}\n+        case (ast::ty_str) {word(s.s, \"str\");}\n+        case (ast::ty_box(?mt)) {word(s.s, \"@\"); print_mt(s, mt);}\n         case (ast::ty_vec(?mt)) {\n-            wrd(s.s, \"vec[\"); print_mt(s, mt); wrd(s.s, \"]\");\n+            word(s.s, \"vec[\"); print_mt(s, mt); word(s.s, \"]\");\n         }\n         case (ast::ty_port(?t)) {\n-            wrd(s.s, \"port[\"); print_type(s, t); wrd(s.s, \"]\");\n+            word(s.s, \"port[\"); print_type(s, t); word(s.s, \"]\");\n         }\n         case (ast::ty_chan(?t)) {\n-            wrd(s.s, \"chan[\"); print_type(s, t); wrd(s.s, \"]\");\n+            word(s.s, \"chan[\"); print_type(s, t); word(s.s, \"]\");\n         }\n-        case (ast::ty_type) {wrd(s.s, \"type\");}\n+        case (ast::ty_type) {word(s.s, \"type\");}\n         case (ast::ty_tup(?elts)) {\n-            wrd(s.s, \"tup\");\n+            word(s.s, \"tup\");\n             popen(s);\n             auto f = print_mt;\n             commasep[ast::mt](s, inconsistent, elts, f);\n             pclose(s);\n         }\n         case (ast::ty_rec(?fields)) {\n-            wrd(s.s, \"rec\");\n+            word(s.s, \"rec\");\n             popen(s);\n             fn print_field(ps s, &ast::ty_field f) {\n                 cbox(s.s, indent_unit);\n                 print_mt(s, f.mt);\n                 space(s.s);\n-                wrd(s.s, f.ident);\n+                word(s.s, f.ident);\n                 end(s.s);\n             }\n             fn get_span(&ast::ty_field f) -> common::span {\n@@ -227,7 +229,7 @@ fn print_type(ps s, &@ast::ty ty) {\n                 cbox(s.s, indent_unit);\n                 print_ty_fn(s, m.proto, option::some[str](m.ident),\n                             m.inputs, m.output, m.cf);\n-                wrd(s.s, \";\");\n+                word(s.s, \";\");\n                 end(s.s);\n             }\n             bclose(s, ty.span);\n@@ -255,12 +257,12 @@ fn print_item(ps s, @ast::item item) {\n             end(s.s); // end the head-ibox\n             word_space(s, \"=\");\n             print_expr(s, expr);\n-            wrd(s.s, \";\");\n+            word(s.s, \";\");\n             end(s.s); // end the outer cbox\n         }\n         case (ast::item_fn(?name,?_fn,?typarams,_,_)) {\n             print_fn(s, _fn.decl, name, typarams);\n-            wrd(s.s, \" \");\n+            word(s.s, \" \");\n             print_block(s, _fn.body);\n         }\n         case (ast::item_mod(?id,?_mod,_)) {\n@@ -287,7 +289,7 @@ fn print_item(ps s, @ast::item item) {\n                 alt (item.node) {\n                     case (ast::native_item_ty(?id,_)) {\n                         word_nbsp(s, \"type\");\n-                        wrd(s.s, id);\n+                        word(s.s, id);\n                     }\n                     case (ast::native_item_fn(?id,?lname,?decl,\n                                              ?typarams,_,_)) {\n@@ -301,7 +303,7 @@ fn print_item(ps s, @ast::item item) {\n                         }\n                     }\n                 }\n-                wrd(s.s, \";\");\n+                word(s.s, \";\");\n                 end(s.s);\n             }\n             bclose(s, item.span);\n@@ -310,26 +312,26 @@ fn print_item(ps s, @ast::item item) {\n             ibox(s.s, indent_unit);\n             ibox(s.s, 0u);\n             word_nbsp(s, \"type\");\n-            wrd(s.s, id);\n+            word(s.s, id);\n             print_type_params(s, params);\n             end(s.s); // end the inner ibox\n             space(s.s);\n             word_space(s, \"=\");\n             print_type(s, ty);\n-            wrd(s.s, \";\");\n+            word(s.s, \";\");\n             end(s.s); // end the outer ibox\n             break_offset(s.s, 0u, 0);\n         }\n         case (ast::item_tag(?id,?variants,?params,_,_)) {\n             head(s, \"tag\");\n-            wrd(s.s, id);\n+            word(s.s, id);\n             print_type_params(s, params);\n             space(s.s);\n             bopen(s);\n             for (ast::variant v in variants) {\n                 space(s.s);\n                 maybe_print_comment(s, v.span.lo);\n-                wrd(s.s, v.node.name);\n+                word(s.s, v.node.name);\n                 if (vec::len[ast::variant_arg](v.node.args) > 0u) {\n                     popen(s);\n                     fn print_variant_arg(ps s, &ast::variant_arg arg) {\n@@ -339,21 +341,21 @@ fn print_item(ps s, @ast::item item) {\n                     commasep[ast::variant_arg](s, consistent, v.node.args, f);\n                     pclose(s);\n                 }\n-                wrd(s.s, \";\");\n+                word(s.s, \";\");\n                 maybe_print_line_comment(s, v.span);\n             }\n             bclose(s, item.span);\n         }\n         case (ast::item_obj(?id,?_obj,?params,_,_)) {\n             head(s, \"obj\");\n-            wrd(s.s, id);\n+            word(s.s, id);\n             print_type_params(s, params);\n             popen(s);\n             fn print_field(ps s, &ast::obj_field field) {\n                 ibox(s.s, indent_unit);\n                 print_type(s, field.ty);\n                 space(s.s);\n-                wrd(s.s, field.ident);\n+                word(s.s, field.ident);\n                 end(s.s);\n             }\n             fn get_span(&ast::obj_field f) -> common::span {ret f.ty.span;}\n@@ -368,7 +370,7 @@ fn print_item(ps s, @ast::item item) {\n                 hardbreak(s.s);\n                 maybe_print_comment(s, meth.span.lo);\n                 print_fn(s, meth.node.meth.decl, meth.node.ident, typarams);\n-                wrd(s.s, \" \");\n+                word(s.s, \" \");\n                 print_block(s, meth.node.meth.body);\n             }\n             alt (_obj.dtor) {\n@@ -398,7 +400,7 @@ fn print_block(ps s, ast::block blk) {\n               print_expr(s, expr);\n           }\n         }\n-        if (front::parser::stmt_ends_with_semi(st)) {wrd(s.s, \";\");}\n+        if (front::parser::stmt_ends_with_semi(st)) {word(s.s, \";\");}\n         maybe_print_line_comment(s, st.span);\n     }\n     alt (blk.node.expr) {\n@@ -417,30 +419,30 @@ fn print_literal(ps s, @ast::lit lit) {\n     alt (lit.node) {\n         case (ast::lit_str(?st)) {print_string(s, st);}\n         case (ast::lit_char(?ch)) {\n-            wrd(s.s, \"'\" + escape_str(str::from_bytes([ch as u8]), '\\'')\n+            word(s.s, \"'\" + escape_str(str::from_bytes([ch as u8]), '\\'')\n                 + \"'\");\n         }\n         case (ast::lit_int(?val)) {\n-            wrd(s.s, common::istr(val));\n+            word(s.s, common::istr(val));\n         }\n         case (ast::lit_uint(?val)) { // FIXME clipping? uistr?\n-            wrd(s.s, common::istr(val as int) + \"u\");\n+            word(s.s, common::istr(val as int) + \"u\");\n         }\n         case (ast::lit_float(?fstr)) {\n-            wrd(s.s, fstr);\n+            word(s.s, fstr);\n         }\n         case (ast::lit_mach_int(?mach,?val)) {\n-            wrd(s.s, common::istr(val as int));\n-            wrd(s.s, common::ty_mach_to_str(mach));\n+            word(s.s, common::istr(val as int));\n+            word(s.s, common::ty_mach_to_str(mach));\n         }\n         case (ast::lit_mach_float(?mach,?val)) {\n             // val is already a str\n-            wrd(s.s, val);\n-            wrd(s.s, common::ty_mach_to_str(mach));\n+            word(s.s, val);\n+            word(s.s, common::ty_mach_to_str(mach));\n         }\n-        case (ast::lit_nil) {wrd(s.s, \"()\");}\n+        case (ast::lit_nil) {word(s.s, \"()\");}\n         case (ast::lit_bool(?val)) {\n-            if (val) {wrd(s.s, \"true\");} else {wrd(s.s, \"false\");}\n+            if (val) {word(s.s, \"true\");} else {word(s.s, \"false\");}\n         }\n     }\n }\n@@ -460,9 +462,9 @@ fn print_expr(ps s, &@ast::expr expr) {\n                 word_nbsp(s, \"mutable\");\n             }\n             ibox(s.s, indent_unit);\n-            wrd(s.s, \"[\");\n+            word(s.s, \"[\");\n             commasep_exprs(s, inconsistent, exprs);\n-            wrd(s.s, \"]\");\n+            word(s.s, \"]\");\n             end(s.s);\n         }\n         case (ast::expr_tup(?exprs,_)) {\n@@ -473,7 +475,7 @@ fn print_expr(ps s, &@ast::expr expr) {\n                 end(s.s);\n             }\n             fn get_span(&ast::elt elt) -> common::span {ret elt.expr.span;}\n-            wrd(s.s, \"tup\");\n+            word(s.s, \"tup\");\n             popen(s);\n             auto f = printElt;\n             auto gs = get_span;\n@@ -484,15 +486,15 @@ fn print_expr(ps s, &@ast::expr expr) {\n             fn print_field(ps s, &ast::field field) {\n                 ibox(s.s, indent_unit);\n                 if (field.mut == ast::mut) {word_nbsp(s, \"mutable\");}\n-                wrd(s.s, field.ident);\n-                wrd(s.s, \"=\");\n+                word(s.s, field.ident);\n+                word(s.s, \"=\");\n                 print_expr(s, field.expr);\n                 end(s.s);\n             }\n             fn get_span(&ast::field field) -> common::span {\n                 ret field.expr.span;\n             }\n-            wrd(s.s, \"rec\");\n+            word(s.s, \"rec\");\n             popen(s);\n             auto f = print_field;\n             auto gs = get_span;\n@@ -516,7 +518,7 @@ fn print_expr(ps s, &@ast::expr expr) {\n             pclose(s);\n         }\n         case (ast::expr_self_method(?ident,_)) {\n-            wrd(s.s, \"self.\");\n+            word(s.s, \"self.\");\n             print_ident(s, ident);\n         }\n         case (ast::expr_bind(?func,?args,_)) {\n@@ -525,7 +527,7 @@ fn print_expr(ps s, &@ast::expr expr) {\n                     case (option::some[@ast::expr](?expr)) {\n                         print_expr(s, expr);\n                     }\n-                    case (_) {wrd(s.s, \"_\");}\n+                    case (_) {word(s.s, \"_\");}\n                 }\n             }\n             word_nbsp(s, \"bind\");\n@@ -550,7 +552,7 @@ fn print_expr(ps s, &@ast::expr expr) {\n             print_maybe_parens(s, rhs, prec + 1);\n         }\n         case (ast::expr_unary(?op,?expr,_)) {\n-            wrd(s.s, ast::unop_to_str(op));\n+            word(s.s, ast::unop_to_str(op));\n             print_expr(s, expr);\n         }\n         case (ast::expr_lit(?lit,_)) {\n@@ -576,7 +578,7 @@ fn print_expr(ps s, &@ast::expr expr) {\n                     // wrong column.\n                     cbox(s.s, indent_unit-1u);\n                     ibox(s.s, 0u);\n-                    wrd(s.s, \" else \");\n+                    word(s.s, \" else \");\n                     alt (_else.node) {\n                         case (ast::expr_block(?b, _)) {\n                             print_block(s, block);\n@@ -658,7 +660,7 @@ fn print_expr(ps s, &@ast::expr expr) {\n         case (ast::expr_assign_op(?op,?lhs,?rhs,_)) {\n             print_expr(s, lhs);\n             space(s.s);\n-            wrd(s.s, ast::binop_to_str(op));\n+            word(s.s, ast::binop_to_str(op));\n             word_space(s, \"=\");\n             print_expr(s, rhs);\n         }\n@@ -676,12 +678,12 @@ fn print_expr(ps s, &@ast::expr expr) {\n         }\n         case (ast::expr_field(?expr,?id,_)) {\n             print_expr(s, expr);\n-            wrd(s.s, \".\");\n-            wrd(s.s, id);\n+            word(s.s, \".\");\n+            word(s.s, id);\n         }\n         case (ast::expr_index(?expr,?index,_)) {\n             print_expr(s, expr);\n-            wrd(s.s, \".\");\n+            word(s.s, \".\");\n             popen(s);\n             print_expr(s, index);\n             pclose(s);\n@@ -690,29 +692,29 @@ fn print_expr(ps s, &@ast::expr expr) {\n             print_path(s, path);\n         }\n         case (ast::expr_fail(_)) {\n-            wrd(s.s, \"fail\");\n+            word(s.s, \"fail\");\n         }\n         case (ast::expr_break(_)) {\n-            wrd(s.s, \"break\");\n+            word(s.s, \"break\");\n         }\n         case (ast::expr_cont(_)) {\n-            wrd(s.s, \"cont\");\n+            word(s.s, \"cont\");\n         }\n         case (ast::expr_ret(?result,_)) {\n-            wrd(s.s, \"ret\");\n+            word(s.s, \"ret\");\n             alt (result) {\n                 case (option::some[@ast::expr](?expr)) {\n-                    wrd(s.s, \" \");\n+                    word(s.s, \" \");\n                     print_expr(s, expr);\n                 }\n                 case (_) {}\n             }\n         }\n         case (ast::expr_put(?result,_)) {\n-            wrd(s.s, \"put\");\n+            word(s.s, \"put\");\n             alt (result) {\n                 case (option::some[@ast::expr](?expr)) {\n-                    wrd(s.s, \" \");\n+                    word(s.s, \" \");\n                     print_expr(s, expr);\n                 }\n                 case (_) {}\n@@ -742,7 +744,7 @@ fn print_expr(ps s, &@ast::expr expr) {\n             pclose(s);\n         }\n         case (ast::expr_ext(?path, ?args, ?body, _, _)) {\n-            wrd(s.s, \"#\");\n+            word(s.s, \"#\");\n             print_path(s, path);\n             if (vec::len[@ast::expr](args) > 0u) {\n                 popen(s);\n@@ -752,19 +754,19 @@ fn print_expr(ps s, &@ast::expr expr) {\n             // FIXME: extension 'body'\n         }\n         case (ast::expr_port(_)) {\n-            wrd(s.s, \"port\");\n+            word(s.s, \"port\");\n             popen(s);\n             pclose(s);\n         }\n         case (ast::expr_chan(?expr, _)) {\n-            wrd(s.s, \"chan\");\n+            word(s.s, \"chan\");\n             popen(s);\n             print_expr(s, expr);\n             pclose(s);\n         }\n \n         case (ast::expr_anon_obj(_,_,_,_)) {\n-            wrd(s.s, \"anon obj\");\n+            word(s.s, \"anon obj\");\n             // TODO: nicer pretty-printing of anon objs\n         }\n     }\n@@ -774,9 +776,9 @@ fn print_expr(ps s, &@ast::expr expr) {\n         case (mo_untyped) { /* no-op */ }\n         case (mo_typed(?tcx)) {\n             space(s.s);\n-            wrd(s.s, \"as\");\n+            word(s.s, \"as\");\n             space(s.s);\n-            wrd(s.s, ty::ty_to_str(tcx, ty::expr_ty(tcx, expr)));\n+            word(s.s, ty::ty_to_str(tcx, ty::expr_ty(tcx, expr)));\n             pclose(s);\n         }\n     }\n@@ -810,7 +812,7 @@ fn print_decl(ps s, @ast::decl decl) {\n                     }\n                 }\n             }\n-            wrd(s.s, loc.ident);\n+            word(s.s, loc.ident);\n             alt (loc.init) {\n                 case (option::some[ast::initializer](?init)) {\n                     space(s.s);\n@@ -835,15 +837,15 @@ fn print_decl(ps s, @ast::decl decl) {\n }\n \n fn print_ident(ps s, ast::ident ident) {\n-    wrd(s.s, ident);\n+    word(s.s, ident);\n }\n \n fn print_for_decl(ps s, @ast::decl decl) {\n     alt (decl.node) {\n         case (ast::decl_local(?loc)) {\n             print_type(s, option::get[@ast::ty](loc.ty));\n             space(s.s);\n-            wrd(s.s, loc.ident);\n+            word(s.s, loc.ident);\n         }\n     }\n }\n@@ -853,22 +855,22 @@ fn print_path(ps s, ast::path path) {\n     auto first = true;\n     for (str id in path.node.idents) {\n         if (first) {first = false;}\n-        else {wrd(s.s, \"::\");}\n-        wrd(s.s, id);\n+        else {word(s.s, \"::\");}\n+        word(s.s, id);\n     }\n     if (vec::len[@ast::ty](path.node.types) > 0u) {\n-        wrd(s.s, \"[\");\n+        word(s.s, \"[\");\n         auto f = print_type;\n         commasep[@ast::ty](s, inconsistent, path.node.types, f);\n-        wrd(s.s, \"]\");\n+        word(s.s, \"]\");\n     }\n }\n \n fn print_pat(ps s, &@ast::pat pat) {\n     maybe_print_comment(s, pat.span.lo);\n     alt (pat.node) {\n-        case (ast::pat_wild(_)) {wrd(s.s, \"_\");}\n-        case (ast::pat_bind(?id,_,_)) {wrd(s.s, \"?\" + id);}\n+        case (ast::pat_wild(_)) {word(s.s, \"_\");}\n+        case (ast::pat_bind(?id,_,_)) {word(s.s, \"?\" + id);}\n         case (ast::pat_lit(?lit,_)) {print_literal(s, lit);}\n         case (ast::pat_tag(?path,?args,_)) {\n             print_path(s, path);\n@@ -892,15 +894,15 @@ fn print_fn(ps s, ast::fn_decl decl, str name,\n             head(s, \"pred\");\n         }\n     }\n-    wrd(s.s, name);\n+    word(s.s, name);\n     print_type_params(s, typarams);\n     popen(s);\n     fn print_arg(ps s, &ast::arg x) {\n         ibox(s.s, indent_unit);\n-        if (x.mode == ast::alias) {wrd(s.s, \"&\");}\n+        if (x.mode == ast::alias) {word(s.s, \"&\");}\n         print_type(s, x.ty);\n         space(s.s);\n-        wrd(s.s, x.ident);\n+        word(s.s, x.ident);\n         end(s.s);\n     }\n     auto f = print_arg;\n@@ -916,13 +918,13 @@ fn print_fn(ps s, ast::fn_decl decl, str name,\n \n fn print_type_params(ps s, vec[ast::ty_param] params) {\n     if (vec::len[ast::ty_param](params) > 0u) {\n-        wrd(s.s, \"[\");\n+        word(s.s, \"[\");\n         fn printParam(ps s, &ast::ty_param param) {\n-            wrd(s.s, param);\n+            word(s.s, param);\n         }\n         auto f = printParam;\n         commasep[ast::ty_param](s, inconsistent, params, f);\n-        wrd(s.s, \"]\");\n+        word(s.s, \"]\");\n     }\n }\n \n@@ -932,7 +934,7 @@ fn print_view_item(ps s, @ast::view_item item) {\n     alt (item.node) {\n         case (ast::view_item_use(?id,?mta,_,_)) {\n             head(s, \"use\");\n-            wrd(s.s, id);\n+            word(s.s, id);\n             if (vec::len[@ast::meta_item](mta) > 0u) {\n                 popen(s);\n                 fn print_meta(ps s, &@ast::meta_item item) {\n@@ -956,16 +958,16 @@ fn print_view_item(ps s, @ast::view_item item) {\n             auto first = true;\n             for (str elt in ids) {\n                 if (first) {first = false;}\n-                else {wrd(s.s, \"::\");}\n-                wrd(s.s, elt);\n+                else {word(s.s, \"::\");}\n+                word(s.s, elt);\n             }\n         }\n         case (ast::view_item_export(?id)) {\n             head(s, \"export\");\n-            wrd(s.s, id);\n+            word(s.s, id);\n         }\n     }\n-    wrd(s.s, \";\");\n+    word(s.s, \";\");\n     end(s.s); // end inner head-block\n     end(s.s); // end outer head-block\n }\n@@ -1028,21 +1030,21 @@ fn print_mt(ps s, &ast::mt mt) {\n }\n \n fn print_string(ps s, str st) {\n-    wrd(s.s, \"\\\"\"); wrd(s.s, escape_str(st, '\"')); wrd(s.s, \"\\\"\");\n+    word(s.s, \"\\\"\"); word(s.s, escape_str(st, '\"')); word(s.s, \"\\\"\");\n }\n \n fn print_ty_fn(ps s, ast::proto proto, option::t[str] id,\n                vec[ast::ty_arg] inputs, @ast::ty output,\n                ast::controlflow cf) {\n-    if (proto == ast::proto_fn) {wrd(s.s, \"fn\");}\n-    else {wrd(s.s, \"iter\");}\n+    if (proto == ast::proto_fn) {word(s.s, \"fn\");}\n+    else {word(s.s, \"iter\");}\n     alt (id) {\n-        case (option::some[str](?id)) {space(s.s); wrd(s.s, id);}\n+        case (option::some[str](?id)) {space(s.s); word(s.s, id);}\n         case (_) {}\n     }\n     popen(s);\n     fn print_arg(ps s, &ast::ty_arg input) {\n-        if (input.mode == ast::alias) {wrd(s.s, \"&\");}\n+        if (input.mode == ast::alias) {word(s.s, \"&\");}\n         print_type(s, input.ty);\n     }\n     auto f = print_arg;\n@@ -1086,7 +1088,7 @@ fn maybe_print_comment(ps s, uint pos) {\n                         first = false;\n                         break_offset(s.s, 0u, 0);\n                     }\n-                    print_comment(s, cmnt.val);\n+                    print_comment(s, cmnt);\n                     s.cur_cmnt += 1u;\n                 } else { break; }\n             }\n@@ -1099,8 +1101,8 @@ fn maybe_print_line_comment(ps s, common::span span) -> bool {\n     alt (next_comment(s)) {\n         case (option::some[lexer::cmnt](?cmnt)) {\n             if (span.hi + 4u >= cmnt.pos) {\n-                wrd(s.s, \" \");\n-                print_comment(s, cmnt.val);\n+                word(s.s, \" \");\n+                print_comment(s, cmnt);\n                 s.cur_cmnt += 1u;\n                 ret true;\n             }\n@@ -1111,43 +1113,41 @@ fn maybe_print_line_comment(ps s, common::span span) -> bool {\n }\n \n fn print_remaining_comments(ps s) {\n-    auto first = true;\n     while (true) {\n         alt (next_comment(s)) {\n             case (option::some[lexer::cmnt](?cmnt)) {\n-                if (first) {\n-                    first = false;\n-                    break_offset(s.s, 0u, 0);\n-                }\n-                print_comment(s, cmnt.val);\n+                print_comment(s, cmnt);\n                 s.cur_cmnt += 1u;\n             }\n             case (_) {break;}\n         }\n     }\n }\n \n-fn print_comment(ps s, lexer::cmnt_ cmnt) {\n-    alt (cmnt) {\n-        case (lexer::cmnt_line(?val)) {\n-            wrd(s.s, \"// \" + val);\n-            hardbreak(s.s);\n-        }\n-        case (lexer::cmnt_block(?lines)) {\n-            cbox(s.s, 1u);\n-            wrd(s.s, \"/*\");\n-            auto first = true;\n-            for (str ln in lines) {\n-                if (first) {\n-                    first = false;\n-                } else {\n-                    hardbreak(s.s);\n-                }\n-                wrd(s.s, ln);\n+fn print_comment(ps s, lexer::cmnt cmnt) {\n+    alt (cmnt.style) {\n+        case (lexer::isolated) {\n+            cbox(s.s, 0u);\n+            for (str line in cmnt.lines) {\n+                zerobreak(s.s);\n+                word_and_eol(s.s, line);\n             }\n-            wrd(s.s, \"*/\");\n+            zerobreak(s.s);\n             end(s.s);\n-            hardbreak(s.s);\n+        }\n+        case (lexer::trailing) {\n+            cbox(s.s, 0u);\n+            for (str line in cmnt.lines) {\n+                word_and_eol(s.s, line);\n+                zerobreak(s.s);\n+            }\n+            end(s.s);\n+        }\n+        case (lexer::mixed) {\n+            assert vec::len(cmnt.lines) == 1u;\n+            zerobreak(s.s);\n+            word(s.s, cmnt.lines.(0));\n+            zerobreak(s.s);\n         }\n     }\n }"}]}