{"sha": "b50520835f3b14409797139eca23f401a529e711", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI1MDUyMDgzNWYzYjE0NDA5Nzk3MTM5ZWNhMjNmNDAxYTUyOWU3MTE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-09-02T22:07:40Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-09-02T22:07:40Z"}, "message": "Auto merge of #63561 - HeroicKatora:alloc-private-bytes, r=oli-obk\n\nMake Allocation::bytes private\n\nFixes #62931.\n\nDirect immutable access to the bytes is still possible but redirected through the new method `raw_bytes_with_undef_and_ptr`, similar to `get_bytes_with_undef_and_ptr` but without requiring an interpretation context and not doing *any* relocation or bounds checks. The `size` of the allocation is stored separately which makes access as `Size` and `usize` more ergonomic.\n\ncc: @RalfJung", "tree": {"sha": "bd72135671484fb70071b740c444396fa072682c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bd72135671484fb70071b740c444396fa072682c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b50520835f3b14409797139eca23f401a529e711", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b50520835f3b14409797139eca23f401a529e711", "html_url": "https://github.com/rust-lang/rust/commit/b50520835f3b14409797139eca23f401a529e711", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b50520835f3b14409797139eca23f401a529e711/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9af17757be1cc3f672928ecf06c40a662c5ec26d", "url": "https://api.github.com/repos/rust-lang/rust/commits/9af17757be1cc3f672928ecf06c40a662c5ec26d", "html_url": "https://github.com/rust-lang/rust/commit/9af17757be1cc3f672928ecf06c40a662c5ec26d"}, {"sha": "f3c435eb780dec5c1d390a3b43cdfb4f1528d70d", "url": "https://api.github.com/repos/rust-lang/rust/commits/f3c435eb780dec5c1d390a3b43cdfb4f1528d70d", "html_url": "https://github.com/rust-lang/rust/commit/f3c435eb780dec5c1d390a3b43cdfb4f1528d70d"}], "stats": {"total": 450, "additions": 311, "deletions": 139}, "files": [{"sha": "be7669fcad875aabb90e9d2cb2c9ad6660a0bd3f", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b50520835f3b14409797139eca23f401a529e711/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b50520835f3b14409797139eca23f401a529e711/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=b50520835f3b14409797139eca23f401a529e711", "patch": "@@ -168,25 +168,21 @@ impl<'a> HashStable<StableHashingContext<'a>> for mir::interpret::AllocId {\n     }\n }\n \n-// Allocations treat their relocations specially\n-impl<'a> HashStable<StableHashingContext<'a>> for mir::interpret::Allocation {\n+// `Relocations` with default type parameters is a sorted map.\n+impl<'a, Tag> HashStable<StableHashingContext<'a>>\n+for mir::interpret::Relocations<Tag>\n+where\n+    Tag: HashStable<StableHashingContext<'a>>,\n+{\n     fn hash_stable<W: StableHasherResult>(\n         &self,\n         hcx: &mut StableHashingContext<'a>,\n         hasher: &mut StableHasher<W>,\n     ) {\n-        let mir::interpret::Allocation {\n-            bytes, relocations, undef_mask, align, mutability,\n-            extra: _,\n-        } = self;\n-        bytes.hash_stable(hcx, hasher);\n-        relocations.len().hash_stable(hcx, hasher);\n-        for reloc in relocations.iter() {\n+        self.len().hash_stable(hcx, hasher);\n+        for reloc in self.iter() {\n             reloc.hash_stable(hcx, hasher);\n         }\n-        undef_mask.hash_stable(hcx, hasher);\n-        align.hash_stable(hcx, hasher);\n-        mutability.hash_stable(hcx, hasher);\n     }\n }\n "}, {"sha": "df1d9a987011d0891f75fe43cf4813d2eb22d8e1", "filename": "src/librustc/mir/interpret/allocation.rs", "status": "modified", "additions": 196, "deletions": 13, "changes": 209, "blob_url": "https://github.com/rust-lang/rust/blob/b50520835f3b14409797139eca23f401a529e711/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b50520835f3b14409797139eca23f401a529e711/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs?ref=b50520835f3b14409797139eca23f401a529e711", "patch": "@@ -13,18 +13,33 @@ use rustc_data_structures::sorted_map::SortedMap;\n use rustc_target::abi::HasDataLayout;\n use std::borrow::Cow;\n \n-#[derive(Clone, Debug, Eq, PartialEq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n+// NOTE: When adding new fields, make sure to adjust the Snapshot impl in\n+// `src/librustc_mir/interpret/snapshot.rs`.\n+#[derive(\n+    Clone,\n+    Debug,\n+    Eq,\n+    PartialEq,\n+    PartialOrd,\n+    Ord,\n+    Hash,\n+    RustcEncodable,\n+    RustcDecodable,\n+    HashStable,\n+)]\n pub struct Allocation<Tag=(),Extra=()> {\n     /// The actual bytes of the allocation.\n-    /// Note that the bytes of a pointer represent the offset of the pointer\n-    pub bytes: Vec<u8>,\n+    /// Note that the bytes of a pointer represent the offset of the pointer.\n+    bytes: Vec<u8>,\n     /// Maps from byte addresses to extra data for each pointer.\n     /// Only the first byte of a pointer is inserted into the map; i.e.,\n     /// every entry in this map applies to `pointer_size` consecutive bytes starting\n     /// at the given offset.\n-    pub relocations: Relocations<Tag>,\n-    /// Denotes undefined memory. Reading from undefined memory is forbidden in miri\n-    pub undef_mask: UndefMask,\n+    relocations: Relocations<Tag>,\n+    /// Denotes which part of this allocation is initialized.\n+    undef_mask: UndefMask,\n+    /// The size of the allocation. Currently, must always equal `bytes.len()`.\n+    pub size: Size,\n     /// The alignment of the allocation to detect unaligned reads.\n     pub align: Align,\n     /// Whether the allocation is mutable.\n@@ -85,11 +100,12 @@ impl<Tag> Allocation<Tag> {\n     /// Creates a read-only allocation initialized by the given bytes\n     pub fn from_bytes<'a>(slice: impl Into<Cow<'a, [u8]>>, align: Align) -> Self {\n         let bytes = slice.into().into_owned();\n-        let undef_mask = UndefMask::new(Size::from_bytes(bytes.len() as u64), true);\n+        let size = Size::from_bytes(bytes.len() as u64);\n         Self {\n             bytes,\n             relocations: Relocations::new(),\n-            undef_mask,\n+            undef_mask: UndefMask::new(size, true),\n+            size,\n             align,\n             mutability: Mutability::Immutable,\n             extra: (),\n@@ -106,13 +122,39 @@ impl<Tag> Allocation<Tag> {\n             bytes: vec![0; size.bytes() as usize],\n             relocations: Relocations::new(),\n             undef_mask: UndefMask::new(size, false),\n+            size,\n             align,\n             mutability: Mutability::Mutable,\n             extra: (),\n         }\n     }\n }\n \n+/// Raw accessors. Provide access to otherwise private bytes.\n+impl<Tag, Extra> Allocation<Tag, Extra> {\n+    pub fn len(&self) -> usize {\n+        self.size.bytes() as usize\n+    }\n+\n+    /// Looks at a slice which may describe undefined bytes or describe a relocation. This differs\n+    /// from `get_bytes_with_undef_and_ptr` in that it does no relocation checks (even on the\n+    /// edges) at all. It further ignores `AllocationExtra` callbacks.\n+    /// This must not be used for reads affecting the interpreter execution.\n+    pub fn inspect_with_undef_and_ptr_outside_interpreter(&self, range: Range<usize>) -> &[u8] {\n+        &self.bytes[range]\n+    }\n+\n+    /// Returns the undef mask.\n+    pub fn undef_mask(&self) -> &UndefMask {\n+        &self.undef_mask\n+    }\n+\n+    /// Returns the relocation list.\n+    pub fn relocations(&self) -> &Relocations<Tag> {\n+        &self.relocations\n+    }\n+}\n+\n impl<'tcx> rustc_serialize::UseSpecializedDecodable for &'tcx Allocation {}\n \n /// Byte accessors\n@@ -132,9 +174,9 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n         );\n         let end = end.bytes() as usize;\n         assert!(\n-            end <= self.bytes.len(),\n+            end <= self.len(),\n             \"Out-of-bounds access at offset {}, size {} in allocation of size {}\",\n-            offset.bytes(), size.bytes(), self.bytes.len()\n+            offset.bytes(), size.bytes(), self.len()\n         );\n         (offset.bytes() as usize)..end\n     }\n@@ -422,7 +464,7 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n /// Relocations\n impl<'tcx, Tag: Copy, Extra> Allocation<Tag, Extra> {\n     /// Returns all relocations overlapping with the given ptr-offset pair.\n-    pub fn relocations(\n+    pub fn get_relocations(\n         &self,\n         cx: &impl HasDataLayout,\n         ptr: Pointer<Tag>,\n@@ -443,7 +485,7 @@ impl<'tcx, Tag: Copy, Extra> Allocation<Tag, Extra> {\n         ptr: Pointer<Tag>,\n         size: Size,\n     ) -> InterpResult<'tcx> {\n-        if self.relocations(cx, ptr, size).is_empty() {\n+        if self.get_relocations(cx, ptr, size).is_empty() {\n             Ok(())\n         } else {\n             throw_unsup!(ReadPointerAsBytes)\n@@ -465,7 +507,7 @@ impl<'tcx, Tag: Copy, Extra> Allocation<Tag, Extra> {\n         // Find the start and end of the given range and its outermost relocations.\n         let (first, last) = {\n             // Find all relocations overlapping the given range.\n-            let relocations = self.relocations(cx, ptr, size);\n+            let relocations = self.get_relocations(cx, ptr, size);\n             if relocations.is_empty() {\n                 return Ok(());\n             }\n@@ -536,6 +578,94 @@ impl<'tcx, Tag, Extra> Allocation<Tag, Extra> {\n     }\n }\n \n+/// Run-length encoding of the undef mask.\n+/// Used to copy parts of a mask multiple times to another allocation.\n+pub struct AllocationDefinedness {\n+    /// The definedness of the first range.\n+    initial: bool,\n+    /// The lengths of ranges that are run-length encoded.\n+    /// The definedness of the ranges alternate starting with `initial`.\n+    ranges: smallvec::SmallVec::<[u64; 1]>,\n+}\n+\n+/// Transferring the definedness mask to other allocations.\n+impl<Tag, Extra> Allocation<Tag, Extra> {\n+    /// Creates a run-length encoding of the undef_mask.\n+    pub fn compress_undef_range(\n+        &self,\n+        src: Pointer<Tag>,\n+        size: Size,\n+    ) -> AllocationDefinedness {\n+        // Since we are copying `size` bytes from `src` to `dest + i * size` (`for i in 0..repeat`),\n+        // a naive undef mask copying algorithm would repeatedly have to read the undef mask from\n+        // the source and write it to the destination. Even if we optimized the memory accesses,\n+        // we'd be doing all of this `repeat` times.\n+        // Therefor we precompute a compressed version of the undef mask of the source value and\n+        // then write it back `repeat` times without computing any more information from the source.\n+\n+        // a precomputed cache for ranges of defined/undefined bits\n+        // 0000010010001110 will become\n+        // [5, 1, 2, 1, 3, 3, 1]\n+        // where each element toggles the state\n+\n+        let mut ranges = smallvec::SmallVec::<[u64; 1]>::new();\n+        let initial = self.undef_mask.get(src.offset);\n+        let mut cur_len = 1;\n+        let mut cur = initial;\n+\n+        for i in 1..size.bytes() {\n+            // FIXME: optimize to bitshift the current undef block's bits and read the top bit\n+            if self.undef_mask.get(src.offset + Size::from_bytes(i)) == cur {\n+                cur_len += 1;\n+            } else {\n+                ranges.push(cur_len);\n+                cur_len = 1;\n+                cur = !cur;\n+            }\n+        }\n+\n+        ranges.push(cur_len);\n+\n+        AllocationDefinedness { ranges, initial, }\n+    }\n+\n+    /// Apply multiple instances of the run-length encoding to the undef_mask.\n+    pub fn mark_compressed_undef_range(\n+        &mut self,\n+        defined: &AllocationDefinedness,\n+        dest: Pointer<Tag>,\n+        size: Size,\n+        repeat: u64,\n+    ) {\n+        // an optimization where we can just overwrite an entire range of definedness bits if\n+        // they are going to be uniformly `1` or `0`.\n+        if defined.ranges.len() <= 1 {\n+            self.undef_mask.set_range_inbounds(\n+                dest.offset,\n+                dest.offset + size * repeat,\n+                defined.initial,\n+            );\n+            return;\n+        }\n+\n+        for mut j in 0..repeat {\n+            j *= size.bytes();\n+            j += dest.offset.bytes();\n+            let mut cur = defined.initial;\n+            for range in &defined.ranges {\n+                let old_j = j;\n+                j += range;\n+                self.undef_mask.set_range_inbounds(\n+                    Size::from_bytes(old_j),\n+                    Size::from_bytes(j),\n+                    cur,\n+                );\n+                cur = !cur;\n+            }\n+        }\n+    }\n+}\n+\n /// Relocations\n #[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, RustcEncodable, RustcDecodable)]\n pub struct Relocations<Tag=(), Id=AllocId>(SortedMap<Size, (Tag, Id)>);\n@@ -566,6 +696,59 @@ impl<Tag> DerefMut for Relocations<Tag> {\n     }\n }\n \n+/// A partial, owned list of relocations to transfer into another allocation.\n+pub struct AllocationRelocations<Tag> {\n+    relative_relocations: Vec<(Size, (Tag, AllocId))>,\n+}\n+\n+impl<Tag: Copy, Extra> Allocation<Tag, Extra> {\n+    pub fn prepare_relocation_copy(\n+        &self,\n+        cx: &impl HasDataLayout,\n+        src: Pointer<Tag>,\n+        size: Size,\n+        dest: Pointer<Tag>,\n+        length: u64,\n+    ) -> AllocationRelocations<Tag> {\n+        let relocations = self.get_relocations(cx, src, size);\n+        if relocations.is_empty() {\n+            return AllocationRelocations { relative_relocations: Vec::new() };\n+        }\n+\n+        let mut new_relocations = Vec::with_capacity(relocations.len() * (length as usize));\n+\n+        for i in 0..length {\n+            new_relocations.extend(\n+                relocations\n+                .iter()\n+                .map(|&(offset, reloc)| {\n+                    // compute offset for current repetition\n+                    let dest_offset = dest.offset + (i * size);\n+                    (\n+                        // shift offsets from source allocation to destination allocation\n+                        offset + dest_offset - src.offset,\n+                        reloc,\n+                    )\n+                })\n+            );\n+        }\n+\n+        AllocationRelocations {\n+            relative_relocations: new_relocations,\n+        }\n+    }\n+\n+    /// Apply a relocation copy.\n+    /// The affected range, as defined in the parameters to `prepare_relocation_copy` is expected\n+    /// to be clear of relocations.\n+    pub fn mark_relocation_range(\n+        &mut self,\n+        relocations: AllocationRelocations<Tag>,\n+    ) {\n+        self.relocations.insert_presorted(relocations.relative_relocations);\n+    }\n+}\n+\n ////////////////////////////////////////////////////////////////////////////////\n // Undefined byte tracking\n ////////////////////////////////////////////////////////////////////////////////"}, {"sha": "a72ecdb5745bbcfe8c884e43b00c714576b7a000", "filename": "src/librustc/ty/print/pretty.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b50520835f3b14409797139eca23f401a529e711/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b50520835f3b14409797139eca23f401a529e711/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs?ref=b50520835f3b14409797139eca23f401a529e711", "patch": "@@ -944,10 +944,16 @@ pub trait PrettyPrinter<'tcx>:\n                         .get_bytes(&self.tcx(), ptr, Size::from_bytes(n)).unwrap())\n                 },\n                 (ConstValue::Slice { data, start, end }, ty::Slice(t)) if *t == u8 => {\n-                    Some(&data.bytes[start..end])\n+                    // The `inspect` here is okay since we checked the bounds, and there are no\n+                    // relocations (we have an active slice reference here). We don't use this\n+                    // result to affect interpreter execution.\n+                    Some(data.inspect_with_undef_and_ptr_outside_interpreter(start..end))\n                 },\n                 (ConstValue::Slice { data, start, end }, ty::Str) => {\n-                    let slice = &data.bytes[start..end];\n+                    // The `inspect` here is okay since we checked the bounds, and there are no\n+                    // relocations (we have an active `str` reference here). We don't use this\n+                    // result to affect interpreter execution.\n+                    let slice = data.inspect_with_undef_and_ptr_outside_interpreter(start..end);\n                     let s = ::std::str::from_utf8(slice)\n                         .expect(\"non utf8 str from miri\");\n                     p!(write(\"{:?}\", s));"}, {"sha": "958666cb8858a62fa1b71f6119e1fb58db2ea275", "filename": "src/librustc_codegen_llvm/consts.rs", "status": "modified", "additions": 50, "deletions": 9, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/b50520835f3b14409797139eca23f401a529e711/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b50520835f3b14409797139eca23f401a529e711/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fconsts.rs?ref=b50520835f3b14409797139eca23f401a529e711", "patch": "@@ -25,21 +25,31 @@ use rustc::hir::{self, CodegenFnAttrs, CodegenFnAttrFlags};\n use std::ffi::{CStr, CString};\n \n pub fn const_alloc_to_llvm(cx: &CodegenCx<'ll, '_>, alloc: &Allocation) -> &'ll Value {\n-    let mut llvals = Vec::with_capacity(alloc.relocations.len() + 1);\n+    let mut llvals = Vec::with_capacity(alloc.relocations().len() + 1);\n     let dl = cx.data_layout();\n     let pointer_size = dl.pointer_size.bytes() as usize;\n \n     let mut next_offset = 0;\n-    for &(offset, ((), alloc_id)) in alloc.relocations.iter() {\n+    for &(offset, ((), alloc_id)) in alloc.relocations().iter() {\n         let offset = offset.bytes();\n         assert_eq!(offset as usize as u64, offset);\n         let offset = offset as usize;\n         if offset > next_offset {\n-            llvals.push(cx.const_bytes(&alloc.bytes[next_offset..offset]));\n+            // This `inspect` is okay since we have checked that it is not within a relocation, it\n+            // is within the bounds of the allocation, and it doesn't affect interpreter execution\n+            // (we inspect the result after interpreter execution). Any undef byte is replaced with\n+            // some arbitrary byte value.\n+            //\n+            // FIXME: relay undef bytes to codegen as undef const bytes\n+            let bytes = alloc.inspect_with_undef_and_ptr_outside_interpreter(next_offset..offset);\n+            llvals.push(cx.const_bytes(bytes));\n         }\n         let ptr_offset = read_target_uint(\n             dl.endian,\n-            &alloc.bytes[offset..(offset + pointer_size)],\n+            // This `inspect` is okay since it is within the bounds of the allocation, it doesn't\n+            // affect interpreter execution (we inspect the result after interpreter execution),\n+            // and we properly interpret the relocation as a relocation pointer offset.\n+            alloc.inspect_with_undef_and_ptr_outside_interpreter(offset..(offset + pointer_size)),\n         ).expect(\"const_alloc_to_llvm: could not read relocation pointer\") as u64;\n         llvals.push(cx.scalar_to_backend(\n             Pointer::new(alloc_id, Size::from_bytes(ptr_offset)).into(),\n@@ -51,8 +61,16 @@ pub fn const_alloc_to_llvm(cx: &CodegenCx<'ll, '_>, alloc: &Allocation) -> &'ll\n         ));\n         next_offset = offset + pointer_size;\n     }\n-    if alloc.bytes.len() >= next_offset {\n-        llvals.push(cx.const_bytes(&alloc.bytes[next_offset ..]));\n+    if alloc.len() >= next_offset {\n+        let range = next_offset..alloc.len();\n+        // This `inspect` is okay since we have check that it is after all relocations, it is\n+        // within the bounds of the allocation, and it doesn't affect interpreter execution (we\n+        // inspect the result after interpreter execution). Any undef byte is replaced with some\n+        // arbitrary byte value.\n+        //\n+        // FIXME: relay undef bytes to codegen as undef const bytes\n+        let bytes = alloc.inspect_with_undef_and_ptr_outside_interpreter(range);\n+        llvals.push(cx.const_bytes(bytes));\n     }\n \n     cx.const_struct(&llvals, true)\n@@ -437,7 +455,23 @@ impl StaticMethods for CodegenCx<'ll, 'tcx> {\n                 //\n                 // We could remove this hack whenever we decide to drop macOS 10.10 support.\n                 if self.tcx.sess.target.target.options.is_like_osx {\n-                    let sect_name = if alloc.bytes.iter().all(|b| *b == 0) {\n+                    assert_eq!(alloc.relocations().len(), 0);\n+\n+                    let is_zeroed = {\n+                        // Treats undefined bytes as if they were defined with the byte value that\n+                        // happens to be currently assigned in mir. This is valid since reading\n+                        // undef bytes may yield arbitrary values.\n+                        //\n+                        // FIXME: ignore undef bytes even with representation `!= 0`.\n+                        //\n+                        // The `inspect` method is okay here because we checked relocations, and\n+                        // because we are doing this access to inspect the final interpreter state\n+                        // (not as part of the interpreter execution).\n+                        alloc.inspect_with_undef_and_ptr_outside_interpreter(0..alloc.len())\n+                            .iter()\n+                            .all(|b| *b == 0)\n+                    };\n+                    let sect_name = if is_zeroed {\n                         CStr::from_bytes_with_nul_unchecked(b\"__DATA,__thread_bss\\0\")\n                     } else {\n                         CStr::from_bytes_with_nul_unchecked(b\"__DATA,__thread_data\\0\")\n@@ -456,10 +490,17 @@ impl StaticMethods for CodegenCx<'ll, 'tcx> {\n                         section.as_str().as_ptr() as *const _,\n                         section.as_str().len() as c_uint,\n                     );\n+                    assert!(alloc.relocations().is_empty());\n+\n+                    // The `inspect` method is okay here because we checked relocations, and\n+                    // because we are doing this access to inspect the final interpreter state (not\n+                    // as part of the interpreter execution).\n+                    let bytes = alloc.inspect_with_undef_and_ptr_outside_interpreter(\n+                        0..alloc.len());\n                     let alloc = llvm::LLVMMDStringInContext(\n                         self.llcx,\n-                        alloc.bytes.as_ptr() as *const _,\n-                        alloc.bytes.len() as c_uint,\n+                        bytes.as_ptr() as *const _,\n+                        bytes.len() as c_uint,\n                     );\n                     let data = [section, alloc];\n                     let meta = llvm::LLVMMDNodeInContext(self.llcx, data.as_ptr(), 2);"}, {"sha": "4cbbc0ffe17cc4262462a27d977307710f0b64a1", "filename": "src/librustc_mir/interpret/intern.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b50520835f3b14409797139eca23f401a529e711/src%2Flibrustc_mir%2Finterpret%2Fintern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b50520835f3b14409797139eca23f401a529e711/src%2Flibrustc_mir%2Finterpret%2Fintern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintern.rs?ref=b50520835f3b14409797139eca23f401a529e711", "patch": "@@ -94,7 +94,7 @@ impl<'rt, 'mir, 'tcx> InternVisitor<'rt, 'mir, 'tcx> {\n         alloc.mutability = mutability;\n         // link the alloc id to the actual allocation\n         let alloc = tcx.intern_const_alloc(alloc);\n-        self.leftover_relocations.extend(alloc.relocations.iter().map(|&(_, ((), reloc))| reloc));\n+        self.leftover_relocations.extend(alloc.relocations().iter().map(|&(_, ((), reloc))| reloc));\n         tcx.alloc_map.lock().set_alloc_id_memory(ptr.alloc_id, alloc);\n         Ok(None)\n     }\n@@ -316,7 +316,7 @@ pub fn intern_const_alloc_recursive(\n             // So we hand-roll the interning logic here again\n             let alloc = tcx.intern_const_alloc(alloc);\n             tcx.alloc_map.lock().set_alloc_id_memory(alloc_id, alloc);\n-            for &(_, ((), reloc)) in alloc.relocations.iter() {\n+            for &(_, ((), reloc)) in alloc.relocations().iter() {\n                 if leftover_relocations.insert(reloc) {\n                     todo.push(reloc);\n                 }"}, {"sha": "0f2305e03ff33e74d4ff24a7aad639fb28662a1d", "filename": "src/librustc_mir/interpret/intrinsics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b50520835f3b14409797139eca23f401a529e711/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b50520835f3b14409797139eca23f401a529e711/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs?ref=b50520835f3b14409797139eca23f401a529e711", "patch": "@@ -81,7 +81,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 let alloc = alloc_type_name(self.tcx.tcx, substs.type_at(0));\n                 let name_id = self.tcx.alloc_map.lock().create_memory_alloc(alloc);\n                 let id_ptr = self.memory.tag_static_base_pointer(name_id.into());\n-                let alloc_len = alloc.bytes.len() as u64;\n+                let alloc_len = alloc.size.bytes();\n                 let name_val = Immediate::new_slice(Scalar::Ptr(id_ptr), alloc_len, self);\n                 self.write_immediate(name_val, dest)?;\n             }"}, {"sha": "032d16a49db4baa3d0f181e85c96292bbefa4f3c", "filename": "src/librustc_mir/interpret/intrinsics/type_name.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b50520835f3b14409797139eca23f401a529e711/src%2Flibrustc_mir%2Finterpret%2Fintrinsics%2Ftype_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b50520835f3b14409797139eca23f401a529e711/src%2Flibrustc_mir%2Finterpret%2Fintrinsics%2Ftype_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics%2Ftype_name.rs?ref=b50520835f3b14409797139eca23f401a529e711", "patch": "@@ -221,7 +221,7 @@ pub fn type_name<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> &'tcx ty::Const<'tcx>\n         val: ConstValue::Slice {\n             data: alloc,\n             start: 0,\n-            end: alloc.bytes.len(),\n+            end: alloc.len(),\n         },\n         ty: tcx.mk_static_str(),\n     })"}, {"sha": "62b1760508b4cd0d00bcb4214a5e5fa3b813e2ca", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 23, "deletions": 94, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/b50520835f3b14409797139eca23f401a529e711/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b50520835f3b14409797139eca23f401a529e711/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=b50520835f3b14409797139eca23f401a529e711", "patch": "@@ -210,7 +210,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         let new_ptr = self.allocate(new_size, new_align, kind);\n         let old_size = match old_size_and_align {\n             Some((size, _align)) => size,\n-            None => Size::from_bytes(self.get(ptr.alloc_id)?.bytes.len() as u64),\n+            None => self.get(ptr.alloc_id)?.size,\n         };\n         self.copy(\n             ptr,\n@@ -271,20 +271,20 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n             ))\n         }\n         if let Some((size, align)) = old_size_and_align {\n-            if size.bytes() != alloc.bytes.len() as u64 || align != alloc.align {\n-                let bytes = Size::from_bytes(alloc.bytes.len() as u64);\n+            if size != alloc.size || align != alloc.align {\n+                let bytes = alloc.size;\n                 throw_unsup!(IncorrectAllocationInformation(size, bytes, align, alloc.align))\n             }\n         }\n \n         // Let the machine take some extra action\n-        let size = Size::from_bytes(alloc.bytes.len() as u64);\n+        let size = alloc.size;\n         AllocationExtra::memory_deallocated(&mut alloc, ptr, size)?;\n \n         // Don't forget to remember size and align of this now-dead allocation\n         let old = self.dead_alloc_map.insert(\n             ptr.alloc_id,\n-            (Size::from_bytes(alloc.bytes.len() as u64), alloc.align)\n+            (alloc.size, alloc.align)\n         );\n         if old.is_some() {\n             bug!(\"Nothing can be deallocated twice\");\n@@ -555,7 +555,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         // a) cause cycles in case `id` refers to a static\n         // b) duplicate a static's allocation in miri\n         if let Some((_, alloc)) = self.alloc_map.get(id) {\n-            return Ok((Size::from_bytes(alloc.bytes.len() as u64), alloc.align));\n+            return Ok((alloc.size, alloc.align));\n         }\n \n         // # Function pointers\n@@ -583,7 +583,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n             Some(GlobalAlloc::Memory(alloc)) =>\n                 // Need to duplicate the logic here, because the global allocations have\n                 // different associated types than the interpreter-local ones.\n-                Ok((Size::from_bytes(alloc.bytes.len() as u64), alloc.align)),\n+                Ok((alloc.size, alloc.align)),\n             Some(GlobalAlloc::Function(_)) =>\n                 bug!(\"We already checked function pointers above\"),\n             // The rest must be dead.\n@@ -645,17 +645,22 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         let prefix_len = msg.len();\n         let mut relocations = vec![];\n \n-        for i in 0..(alloc.bytes.len() as u64) {\n+        for i in 0..alloc.size.bytes() {\n             let i = Size::from_bytes(i);\n-            if let Some(&(_, target_id)) = alloc.relocations.get(&i) {\n+            if let Some(&(_, target_id)) = alloc.relocations().get(&i) {\n                 if allocs_seen.insert(target_id) {\n                     allocs_to_print.push_back(target_id);\n                 }\n                 relocations.push((i, target_id));\n             }\n-            if alloc.undef_mask.is_range_defined(i, i + Size::from_bytes(1)).is_ok() {\n+            if alloc.undef_mask().is_range_defined(i, i + Size::from_bytes(1)).is_ok() {\n                 // this `as usize` is fine, since `i` came from a `usize`\n-                write!(msg, \"{:02x} \", alloc.bytes[i.bytes() as usize]).unwrap();\n+                let i = i.bytes() as usize;\n+\n+                // Checked definedness (and thus range) and relocations. This access also doesn't\n+                // influence interpreter execution but is only for debugging.\n+                let bytes = alloc.inspect_with_undef_and_ptr_outside_interpreter(i..i+1);\n+                write!(msg, \"{:02x} \", bytes[0]).unwrap();\n             } else {\n                 msg.push_str(\"__ \");\n             }\n@@ -664,7 +669,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         trace!(\n             \"{}({} bytes, alignment {}){}\",\n             msg,\n-            alloc.bytes.len(),\n+            alloc.size.bytes(),\n             alloc.align.bytes(),\n             extra\n         );\n@@ -803,32 +808,8 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         // since we don't want to keep any relocations at the target.\n         // (`get_bytes_with_undef_and_ptr` below checks that there are no\n         // relocations overlapping the edges; those would not be handled correctly).\n-        let relocations = {\n-            let relocations = self.get(src.alloc_id)?.relocations(self, src, size);\n-            if relocations.is_empty() {\n-                // nothing to copy, ignore even the `length` loop\n-                Vec::new()\n-            } else {\n-                let mut new_relocations = Vec::with_capacity(relocations.len() * (length as usize));\n-                for i in 0..length {\n-                    new_relocations.extend(\n-                        relocations\n-                        .iter()\n-                        .map(|&(offset, reloc)| {\n-                            // compute offset for current repetition\n-                            let dest_offset = dest.offset + (i * size);\n-                            (\n-                                // shift offsets from source allocation to destination allocation\n-                                offset + dest_offset - src.offset,\n-                                reloc,\n-                            )\n-                        })\n-                    );\n-                }\n-\n-                new_relocations\n-            }\n-        };\n+        let relocations = self.get(src.alloc_id)?\n+            .prepare_relocation_copy(self, src, size, dest, length);\n \n         let tcx = self.tcx.tcx;\n \n@@ -875,7 +856,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         // copy definedness to the destination\n         self.copy_undef_mask(src, dest, size, length)?;\n         // copy the relocations to the destination\n-        self.get_mut(dest.alloc_id)?.relocations.insert_presorted(relocations);\n+        self.get_mut(dest.alloc_id)?.mark_relocation_range(relocations);\n \n         Ok(())\n     }\n@@ -894,65 +875,13 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         // The bits have to be saved locally before writing to dest in case src and dest overlap.\n         assert_eq!(size.bytes() as usize as u64, size.bytes());\n \n-        let undef_mask = &self.get(src.alloc_id)?.undef_mask;\n-\n-        // Since we are copying `size` bytes from `src` to `dest + i * size` (`for i in 0..repeat`),\n-        // a naive undef mask copying algorithm would repeatedly have to read the undef mask from\n-        // the source and write it to the destination. Even if we optimized the memory accesses,\n-        // we'd be doing all of this `repeat` times.\n-        // Therefor we precompute a compressed version of the undef mask of the source value and\n-        // then write it back `repeat` times without computing any more information from the source.\n-\n-        // a precomputed cache for ranges of defined/undefined bits\n-        // 0000010010001110 will become\n-        // [5, 1, 2, 1, 3, 3, 1]\n-        // where each element toggles the state\n-        let mut ranges = smallvec::SmallVec::<[u64; 1]>::new();\n-        let first = undef_mask.get(src.offset);\n-        let mut cur_len = 1;\n-        let mut cur = first;\n-        for i in 1..size.bytes() {\n-            // FIXME: optimize to bitshift the current undef block's bits and read the top bit\n-            if undef_mask.get(src.offset + Size::from_bytes(i)) == cur {\n-                cur_len += 1;\n-            } else {\n-                ranges.push(cur_len);\n-                cur_len = 1;\n-                cur = !cur;\n-            }\n-        }\n+        let src_alloc = self.get(src.alloc_id)?;\n+        let compressed = src_alloc.compress_undef_range(src, size);\n \n         // now fill in all the data\n         let dest_allocation = self.get_mut(dest.alloc_id)?;\n-        // an optimization where we can just overwrite an entire range of definedness bits if\n-        // they are going to be uniformly `1` or `0`.\n-        if ranges.is_empty() {\n-            dest_allocation.undef_mask.set_range_inbounds(\n-                dest.offset,\n-                dest.offset + size * repeat,\n-                first,\n-            );\n-            return Ok(())\n-        }\n+        dest_allocation.mark_compressed_undef_range(&compressed, dest, size, repeat);\n \n-        // remember to fill in the trailing bits\n-        ranges.push(cur_len);\n-\n-        for mut j in 0..repeat {\n-            j *= size.bytes();\n-            j += dest.offset.bytes();\n-            let mut cur = first;\n-            for range in &ranges {\n-                let old_j = j;\n-                j += range;\n-                dest_allocation.undef_mask.set_range_inbounds(\n-                    Size::from_bytes(old_j),\n-                    Size::from_bytes(j),\n-                    cur,\n-                );\n-                cur = !cur;\n-            }\n-        }\n         Ok(())\n     }\n "}, {"sha": "2cac8bb0c517e49b99a8a20390689f4e61266dd2", "filename": "src/librustc_mir/interpret/snapshot.rs", "status": "modified", "additions": 19, "deletions": 2, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/b50520835f3b14409797139eca23f401a529e711/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b50520835f3b14409797139eca23f401a529e711/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs?ref=b50520835f3b14409797139eca23f401a529e711", "patch": "@@ -15,7 +15,7 @@ use rustc::mir::interpret::{\n };\n \n use rustc::ty::{self, TyCtxt};\n-use rustc::ty::layout::Align;\n+use rustc::ty::layout::{Align, Size};\n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::indexed_vec::IndexVec;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n@@ -276,6 +276,7 @@ struct AllocationSnapshot<'a> {\n     relocations: Relocations<(), AllocIdSnapshot<'a>>,\n     undef_mask: &'a UndefMask,\n     align: &'a Align,\n+    size: &'a Size,\n     mutability: &'a Mutability,\n }\n \n@@ -285,12 +286,28 @@ impl<'a, Ctx> Snapshot<'a, Ctx> for &'a Allocation\n     type Item = AllocationSnapshot<'a>;\n \n     fn snapshot(&self, ctx: &'a Ctx) -> Self::Item {\n-        let Allocation { bytes, relocations, undef_mask, align, mutability, extra: () } = self;\n+        let Allocation {\n+            size,\n+            align,\n+            mutability,\n+            extra: (),\n+            ..\n+        } = self;\n+\n+        let all_bytes = 0..self.len();\n+        // This 'inspect' is okay since following access respects undef and relocations. This does\n+        // influence interpreter exeuction, but only to detect the error of cycles in evalution\n+        // dependencies.\n+        let bytes = self.inspect_with_undef_and_ptr_outside_interpreter(all_bytes);\n+\n+        let undef_mask = self.undef_mask();\n+        let relocations = self.relocations();\n \n         AllocationSnapshot {\n             bytes,\n             undef_mask,\n             align,\n+            size,\n             mutability,\n             relocations: relocations.snapshot(ctx),\n         }"}, {"sha": "1f7efebfda819950f2f54deb3400400e8d212f36", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b50520835f3b14409797139eca23f401a529e711/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b50520835f3b14409797139eca23f401a529e711/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=b50520835f3b14409797139eca23f401a529e711", "patch": "@@ -1218,7 +1218,7 @@ fn collect_miri<'tcx>(tcx: TyCtxt<'tcx>, alloc_id: AllocId, output: &mut Vec<Mon\n         }\n         Some(GlobalAlloc::Memory(alloc)) => {\n             trace!(\"collecting {:?} with {:#?}\", alloc_id, alloc);\n-            for &((), inner) in alloc.relocations.values() {\n+            for &((), inner) in alloc.relocations().values() {\n                 collect_miri(tcx, inner, output);\n             }\n         },\n@@ -1269,7 +1269,7 @@ fn collect_const<'tcx>(\n             collect_miri(tcx, ptr.alloc_id, output),\n         ConstValue::Slice { data: alloc, start: _, end: _ } |\n         ConstValue::ByRef { alloc, .. } => {\n-            for &((), id) in alloc.relocations.values() {\n+            for &((), id) in alloc.relocations().values() {\n                 collect_miri(tcx, id, output);\n             }\n         }"}, {"sha": "cd041e80e7c9ee202cd173667eadc696610d49e6", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b50520835f3b14409797139eca23f401a529e711/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b50520835f3b14409797139eca23f401a529e711/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=b50520835f3b14409797139eca23f401a529e711", "patch": "@@ -1570,7 +1570,7 @@ fn maybe_check_static_with_link_section(tcx: TyCtxt<'_>, id: DefId, span: Span)\n         } else {\n             bug!(\"Matching on non-ByRef static\")\n         };\n-        if alloc.relocations.len() != 0 {\n+        if alloc.relocations().len() != 0 {\n             let msg = \"statics with a custom `#[link_section]` must be a \\\n                        simple list of bytes on the wasm target with no \\\n                        extra levels of indirection such as references\";"}]}