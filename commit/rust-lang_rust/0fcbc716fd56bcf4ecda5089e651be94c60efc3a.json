{"sha": "0fcbc716fd56bcf4ecda5089e651be94c60efc3a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBmY2JjNzE2ZmQ1NmJjZjRlY2RhNTA4OWU2NTFiZTk0YzYwZWZjM2E=", "commit": {"author": {"name": "Jonas Schievink", "email": "jonas.schievink@ferrous-systems.com", "date": "2020-06-30T11:23:42Z"}, "committer": {"name": "Jonas Schievink", "email": "jonas.schievink@ferrous-systems.com", "date": "2020-06-30T11:23:42Z"}, "message": "Split namespace maps in `ItemScope`\n\nReduces memory usage of the CrateDefMap query by ~130 MB on r-a.", "tree": {"sha": "ae068a4be2b44c9b37da7163fa6c96bf5f74d9ef", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ae068a4be2b44c9b37da7163fa6c96bf5f74d9ef"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0fcbc716fd56bcf4ecda5089e651be94c60efc3a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0fcbc716fd56bcf4ecda5089e651be94c60efc3a", "html_url": "https://github.com/rust-lang/rust/commit/0fcbc716fd56bcf4ecda5089e651be94c60efc3a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0fcbc716fd56bcf4ecda5089e651be94c60efc3a/comments", "author": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5a0fb3caff745d20face2d7ab02fa4da63faef9c", "url": "https://api.github.com/repos/rust-lang/rust/commits/5a0fb3caff745d20face2d7ab02fa4da63faef9c", "html_url": "https://github.com/rust-lang/rust/commit/5a0fb3caff745d20face2d7ab02fa4da63faef9c"}], "stats": {"total": 113, "additions": 79, "deletions": 34}, "files": [{"sha": "7fc53d86dfe423cccfc2ec8da0869388eaf65648", "filename": "crates/ra_hir_def/src/item_scope.rs", "status": "modified", "additions": 79, "deletions": 34, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/0fcbc716fd56bcf4ecda5089e651be94c60efc3a/crates%2Fra_hir_def%2Fsrc%2Fitem_scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fcbc716fd56bcf4ecda5089e651be94c60efc3a/crates%2Fra_hir_def%2Fsrc%2Fitem_scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fitem_scope.rs?ref=0fcbc716fd56bcf4ecda5089e651be94c60efc3a", "patch": "@@ -11,6 +11,7 @@ use crate::{\n     db::DefDatabase, per_ns::PerNs, visibility::Visibility, AdtId, BuiltinType, HasModule, ImplId,\n     LocalModuleId, Lookup, MacroDefId, ModuleDefId, TraitId,\n };\n+use std::collections::hash_map::Entry;\n \n #[derive(Copy, Clone)]\n pub(crate) enum ImportType {\n@@ -27,7 +28,11 @@ pub struct PerNsGlobImports {\n \n #[derive(Debug, Default, PartialEq, Eq)]\n pub struct ItemScope {\n-    visible: FxHashMap<Name, PerNs>,\n+    types: FxHashMap<Name, (ModuleDefId, Visibility)>,\n+    values: FxHashMap<Name, (ModuleDefId, Visibility)>,\n+    macros: FxHashMap<Name, (MacroDefId, Visibility)>,\n+    unresolved: FxHashSet<Name>,\n+\n     defs: Vec<ModuleDefId>,\n     impls: Vec<ImplId>,\n     /// Macros visible in current module in legacy textual scope\n@@ -65,14 +70,22 @@ pub(crate) enum BuiltinShadowMode {\n /// Other methods will only resolve values, types and module scoped macros only.\n impl ItemScope {\n     pub fn entries<'a>(&'a self) -> impl Iterator<Item = (&'a Name, PerNs)> + 'a {\n-        //FIXME: shadowing\n-        self.visible.iter().map(|(n, def)| (n, *def))\n+        // FIXME: shadowing\n+        let keys: FxHashSet<_> = self\n+            .types\n+            .keys()\n+            .chain(self.values.keys())\n+            .chain(self.macros.keys())\n+            .chain(self.unresolved.iter())\n+            .collect();\n+\n+        keys.into_iter().map(move |name| (name, self.get(name)))\n     }\n \n     pub fn entries_without_primitives<'a>(\n         &'a self,\n     ) -> impl Iterator<Item = (&'a Name, PerNs)> + 'a {\n-        self.visible.iter().map(|(n, def)| (n, *def))\n+        self.entries()\n     }\n \n     pub fn declarations(&self) -> impl Iterator<Item = ModuleDefId> + '_ {\n@@ -91,7 +104,7 @@ impl ItemScope {\n \n     /// Iterate over all module scoped macros\n     pub(crate) fn macros<'a>(&'a self) -> impl Iterator<Item = (&'a Name, MacroDefId)> + 'a {\n-        self.visible.iter().filter_map(|(name, def)| def.take_macros().map(|macro_| (name, macro_)))\n+        self.entries().filter_map(|(name, def)| def.take_macros().map(|macro_| (name, macro_)))\n     }\n \n     /// Iterate over all legacy textual scoped macros visible at the end of the module\n@@ -101,21 +114,25 @@ impl ItemScope {\n \n     /// Get a name from current module scope, legacy macros are not included\n     pub(crate) fn get(&self, name: &Name) -> PerNs {\n-        self.visible.get(name).copied().unwrap_or_else(PerNs::none)\n+        PerNs {\n+            types: self.types.get(name).copied(),\n+            values: self.values.get(name).copied(),\n+            macros: self.macros.get(name).copied(),\n+        }\n     }\n \n     pub(crate) fn name_of(&self, item: ItemInNs) -> Option<(&Name, Visibility)> {\n-        for (name, per_ns) in &self.visible {\n-            if let Some(vis) = item.match_with(*per_ns) {\n+        for (name, per_ns) in self.entries() {\n+            if let Some(vis) = item.match_with(per_ns) {\n                 return Some((name, vis));\n             }\n         }\n         None\n     }\n \n     pub(crate) fn traits<'a>(&'a self) -> impl Iterator<Item = TraitId> + 'a {\n-        self.visible.values().filter_map(|def| match def.take_types() {\n-            Some(ModuleDefId::TraitId(t)) => Some(t),\n+        self.types.values().filter_map(|(def, _)| match def {\n+            ModuleDefId::TraitId(t) => Some(*t),\n             _ => None,\n         })\n     }\n@@ -138,21 +155,39 @@ impl ItemScope {\n \n     pub(crate) fn push_res(&mut self, name: Name, def: PerNs) -> bool {\n         let mut changed = false;\n-        let existing = self.visible.entry(name).or_default();\n \n-        if existing.types.is_none() && def.types.is_some() {\n-            existing.types = def.types;\n-            changed = true;\n+        if let Some(types) = def.types {\n+            match self.types.entry(name.clone()) {\n+                Entry::Occupied(_) => {}\n+                Entry::Vacant(e) => {\n+                    e.insert(types);\n+                    changed = true;\n+                }\n+            }\n         }\n-\n-        if existing.values.is_none() && def.values.is_some() {\n-            existing.values = def.values;\n-            changed = true;\n+        if let Some(values) = def.values {\n+            match self.values.entry(name.clone()) {\n+                Entry::Occupied(_) => {}\n+                Entry::Vacant(e) => {\n+                    e.insert(values);\n+                    changed = true;\n+                }\n+            }\n+        }\n+        if let Some(macros) = def.macros {\n+            match self.macros.entry(name.clone()) {\n+                Entry::Occupied(_) => {}\n+                Entry::Vacant(e) => {\n+                    e.insert(macros);\n+                    changed = true;\n+                }\n+            }\n         }\n \n-        if existing.macros.is_none() && def.macros.is_some() {\n-            existing.macros = def.macros;\n-            changed = true;\n+        if def.is_none() {\n+            if self.unresolved.insert(name) {\n+                changed = true;\n+            }\n         }\n \n         changed\n@@ -166,17 +201,17 @@ impl ItemScope {\n         def_import_type: ImportType,\n     ) -> bool {\n         let mut changed = false;\n-        let existing = self.visible.entry(lookup.1.clone()).or_default();\n \n         macro_rules! check_changed {\n             (\n                 $changed:ident,\n-                ( $existing:ident / $def:ident ) . $field:ident,\n+                ( $this:ident / $def:ident ) . $field:ident,\n                 $glob_imports:ident [ $lookup:ident ],\n                 $def_import_type:ident\n-            ) => {\n-                match ($existing.$field, $def.$field) {\n-                    (None, Some(_)) => {\n+            ) => {{\n+                let existing = $this.$field.entry($lookup.1.clone());\n+                match (existing, $def.$field) {\n+                    (Entry::Vacant(entry), Some(_)) => {\n                         match $def_import_type {\n                             ImportType::Glob => {\n                                 $glob_imports.$field.insert($lookup.clone());\n@@ -186,32 +221,42 @@ impl ItemScope {\n                             }\n                         }\n \n-                        $existing.$field = $def.$field;\n+                        if let Some(fld) = $def.$field {\n+                            entry.insert(fld);\n+                        }\n                         $changed = true;\n                     }\n-                    (Some(_), Some(_))\n+                    (Entry::Occupied(mut entry), Some(_))\n                         if $glob_imports.$field.contains(&$lookup)\n                             && matches!($def_import_type, ImportType::Named) =>\n                     {\n                         mark::hit!(import_shadowed);\n                         $glob_imports.$field.remove(&$lookup);\n-                        $existing.$field = $def.$field;\n+                        if let Some(fld) = $def.$field {\n+                            entry.insert(fld);\n+                        }\n                         $changed = true;\n                     }\n                     _ => {}\n                 }\n-            };\n+            }};\n         }\n \n-        check_changed!(changed, (existing / def).types, glob_imports[lookup], def_import_type);\n-        check_changed!(changed, (existing / def).values, glob_imports[lookup], def_import_type);\n-        check_changed!(changed, (existing / def).macros, glob_imports[lookup], def_import_type);\n+        check_changed!(changed, (self / def).types, glob_imports[lookup], def_import_type);\n+        check_changed!(changed, (self / def).values, glob_imports[lookup], def_import_type);\n+        check_changed!(changed, (self / def).macros, glob_imports[lookup], def_import_type);\n+\n+        if def.is_none() {\n+            if self.unresolved.insert(lookup.1) {\n+                changed = true;\n+            }\n+        }\n \n         changed\n     }\n \n     pub(crate) fn resolutions<'a>(&'a self) -> impl Iterator<Item = (Name, PerNs)> + 'a {\n-        self.visible.iter().map(|(name, res)| (name.clone(), *res))\n+        self.entries().map(|(name, res)| (name.clone(), res))\n     }\n \n     pub(crate) fn collect_legacy_macros(&self) -> FxHashMap<Name, MacroDefId> {"}]}