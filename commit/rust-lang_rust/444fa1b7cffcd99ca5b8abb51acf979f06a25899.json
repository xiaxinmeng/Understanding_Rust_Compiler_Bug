{"sha": "444fa1b7cffcd99ca5b8abb51acf979f06a25899", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ0NGZhMWI3Y2ZmY2Q5OWNhNWI4YWJiNTFhY2Y5NzlmMDZhMjU4OTk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-12-13T22:57:21Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-12-13T22:57:21Z"}, "message": "auto merge of #19467 : japaric/rust/uc, r=alexcrichton\n\nThis PR moves almost all our current uses of closures, both in public API and internal uses, to the new \"unboxed\" closures system.\r\n\r\nIn most cases, downstream code that *only uses* closures will continue to work as it is. The reason is that the `|| {}` syntax can be inferred either as a boxed or an \"unboxed\" closure according to the context. For example the following code will continue to work:\r\n\r\n``` rust\r\nsome_option.map(|x| x.transform_with(upvar))\r\n```\r\n\r\nAnd will get silently upgraded to an \"unboxed\" closure.\r\n\r\nIn some other cases, it may be necessary to \"annotate\" which `Fn*` trait the closure implements:\r\n\r\n```\r\n// Change this\r\n|x| { /* body */}\r\n// to either of these\r\n|: x| { /* body */}  // closure implements the FnOnce trait\r\n|&mut : x| { /* body */}  // FnMut\r\n|&: x| { /* body */}  // Fn\r\n```\r\n\r\nThis mainly occurs when the closure is assigned to a variable first, and then passed to a function/method.\r\n\r\n``` rust\r\nlet closure = |: x| x.transform_with(upvar);\r\nsome.option.map(closure)\r\n```\r\n\r\n(It's very likely that in the future, an improved inference engine will make this annotation unnecessary)\r\n\r\nOther cases that require annotation are closures that implement some trait via a blanket `impl`, for example:\r\n\r\n- `std::finally::Finally`\r\n- `regex::Replacer`\r\n- `std::str::CharEq`\r\n\r\n``` rust\r\nstring.trim_left_chars(|c: char| c.is_whitespace())\r\n//~^ ERROR: the trait `Fn<(char,), bool>` is not implemented for the type `|char| -> bool`\r\nstring.trim_left_chars(|&: c: char| c.is_whitespace())  // OK\r\n```\r\n\r\nFinally, all implementations of traits that contain boxed closures in the arguments of their methods are now broken. And will need to be updated to use unboxed closures. These are the main affected traits:\r\n\r\n- `serialize::Decoder`\r\n- `serialize::DecoderHelpers`\r\n- `serialize::Encoder`\r\n- `serialize::EncoderHelpers`\r\n- `rustrt::ToCStr`\r\n\r\nFor example, change this:\r\n\r\n``` rust\r\n// libserialize/json.rs\r\nimpl<'a> Encoder<io::IoError> for Encoder<'a> {\r\n    fn emit_enum(&mut self,\r\n                 _name: &str,\r\n                 f: |&mut Encoder<'a>| -> EncodeResult) -> EncodeResult {\r\n        f(self)\r\n    }\r\n}\r\n```\r\n\r\nto:\r\n\r\n``` rust\r\n// libserialize/json.rs\r\nimpl<'a> Encoder<io::IoError> for Encoder<'a> {\r\n    fn emit_enum<F>(&mut self, _name: &str, f: F) -> EncodeResult where\r\n        F: FnOnce(&mut Encoder<'a>) -> EncodeResult\r\n    {\r\n        f(self)\r\n    }\r\n}\r\n```\r\n\r\n[breaking-change]\r\n\r\n---\r\n\r\n### How the `Fn*` bound has been selected\r\n\r\nI've chosen the bounds to make the functions/structs as \"generic as possible\", i.e. to let them allow the maximum amount of input.\r\n\r\n- An `F: FnOnce` bound accepts the three kinds of closures: `|:|`, `|&mut:|` and `|&:|`.\r\n- An `F: FnMut` bound only accepts \"non-consuming\" closures: `|&mut:|` and `|&:|`.\r\n- An `F: Fn` bound only accept the \"immutable environment\" closures: `|&:|`.\r\n\r\nThis means that whenever possible the `FnOnce` bound has been used, if the `FnOnce` bound couldn't be used, then the `FnMut` was used. The `Fn` bound was never used in the whole repository.\r\n\r\nThe `FnMut` bound was the most used, because it resembles the semantics of the current boxed closures: the closure can modify its environment, and the closure may be called several times.\r\n\r\nThe `FnOnce` bound allows new semantics: you can move out the upvars when the closure is called. This can be effectively paired with the `move || {}` syntax to transfer ownership from the environment to the closure caller.\r\n\r\nIn the case of trait methods, is hard to select the \"right\" bound since we can't control how the trait may be implemented by downstream users. In these cases, I have selected the bound based on how we use these traits in the repository. For this reason the selected bounds may not be ideal, and may require tweaking before stabilization.\r\n\r\nr? @aturon", "tree": {"sha": "51a8beea4fd983ce8cb46879a2fdbaf72916c13e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/51a8beea4fd983ce8cb46879a2fdbaf72916c13e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/444fa1b7cffcd99ca5b8abb51acf979f06a25899", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/444fa1b7cffcd99ca5b8abb51acf979f06a25899", "html_url": "https://github.com/rust-lang/rust/commit/444fa1b7cffcd99ca5b8abb51acf979f06a25899", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/444fa1b7cffcd99ca5b8abb51acf979f06a25899/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "567b90ff095076054c98fa2f08d6c552ae60968d", "url": "https://api.github.com/repos/rust-lang/rust/commits/567b90ff095076054c98fa2f08d6c552ae60968d", "html_url": "https://github.com/rust-lang/rust/commit/567b90ff095076054c98fa2f08d6c552ae60968d"}, {"sha": "b8e0b81dd57621af28d7b2b5551a3217f7bd4cec", "url": "https://api.github.com/repos/rust-lang/rust/commits/b8e0b81dd57621af28d7b2b5551a3217f7bd4cec", "html_url": "https://github.com/rust-lang/rust/commit/b8e0b81dd57621af28d7b2b5551a3217f7bd4cec"}], "stats": {"total": 4295, "additions": 2534, "deletions": 1761}, "files": [{"sha": "1f4df1fd0a5a28e1199ac28ca10c0ec90bc39433", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -28,6 +28,7 @@\n        html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n \n #![feature(unsafe_destructor)]\n+#![feature(unboxed_closures)]\n #![allow(missing_docs)]\n \n extern crate alloc;\n@@ -209,7 +210,7 @@ impl Arena {\n     }\n \n     #[inline]\n-    fn alloc_copy<T>(&self, op: || -> T) -> &mut T {\n+    fn alloc_copy<T, F>(&self, op: F) -> &mut T where F: FnOnce() -> T {\n         unsafe {\n             let ptr = self.alloc_copy_inner(mem::size_of::<T>(),\n                                             mem::min_align_of::<T>());\n@@ -263,7 +264,7 @@ impl Arena {\n     }\n \n     #[inline]\n-    fn alloc_noncopy<T>(&self, op: || -> T) -> &mut T {\n+    fn alloc_noncopy<T, F>(&self, op: F) -> &mut T where F: FnOnce() -> T {\n         unsafe {\n             let tydesc = get_tydesc::<T>();\n             let (ty_ptr, ptr) =\n@@ -287,7 +288,7 @@ impl Arena {\n     /// Allocates a new item in the arena, using `op` to initialize the value,\n     /// and returns a reference to it.\n     #[inline]\n-    pub fn alloc<T>(&self, op: || -> T) -> &mut T {\n+    pub fn alloc<T, F>(&self, op: F) -> &mut T where F: FnOnce() -> T {\n         unsafe {\n             if intrinsics::needs_drop::<T>() {\n                 self.alloc_noncopy(op)\n@@ -339,7 +340,7 @@ fn test_arena_destructors_fail() {\n         arena.alloc(|| { [0u8, 1u8, 2u8] });\n     }\n     // Now, panic while allocating\n-    arena.alloc::<Rc<int>>(|| {\n+    arena.alloc::<Rc<int>, _>(|| {\n         panic!();\n     });\n }"}, {"sha": "3346e55158a2a178b3db99b6387de9563333a84d", "filename": "src/libcollections/bench.rs", "status": "modified", "additions": 32, "deletions": 12, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibcollections%2Fbench.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibcollections%2Fbench.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbench.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -13,9 +13,14 @@ use std::rand;\n use std::rand::Rng;\n use test::Bencher;\n \n-pub fn insert_rand_n<M>(n: uint, map: &mut M, b: &mut Bencher,\n-                        insert: |&mut M, uint|,\n-                        remove: |&mut M, uint|) {\n+pub fn insert_rand_n<M, I, R>(n: uint,\n+                              map: &mut M,\n+                              b: &mut Bencher,\n+                              mut insert: I,\n+                              mut remove: R) where\n+    I: FnMut(&mut M, uint),\n+    R: FnMut(&mut M, uint),\n+{\n     // setup\n     let mut rng = rand::weak_rng();\n \n@@ -31,9 +36,14 @@ pub fn insert_rand_n<M>(n: uint, map: &mut M, b: &mut Bencher,\n     })\n }\n \n-pub fn insert_seq_n<M>(n: uint, map: &mut M, b: &mut Bencher,\n-                       insert: |&mut M, uint|,\n-                       remove: |&mut M, uint|) {\n+pub fn insert_seq_n<M, I, R>(n: uint,\n+                             map: &mut M,\n+                             b: &mut Bencher,\n+                             mut insert: I,\n+                             mut remove: R) where\n+    I: FnMut(&mut M, uint),\n+    R: FnMut(&mut M, uint),\n+{\n     // setup\n     for i in range(0u, n) {\n         insert(map, i * 2);\n@@ -48,9 +58,14 @@ pub fn insert_seq_n<M>(n: uint, map: &mut M, b: &mut Bencher,\n     })\n }\n \n-pub fn find_rand_n<M, T>(n: uint, map: &mut M, b: &mut Bencher,\n-                         insert: |&mut M, uint|,\n-                         find: |&M, uint| -> T) {\n+pub fn find_rand_n<M, T, I, F>(n: uint,\n+                               map: &mut M,\n+                               b: &mut Bencher,\n+                               mut insert: I,\n+                               mut find: F) where\n+    I: FnMut(&mut M, uint),\n+    F: FnMut(&M, uint) -> T,\n+{\n     // setup\n     let mut rng = rand::weak_rng();\n     let mut keys = Vec::from_fn(n, |_| rng.gen::<uint>() % n);\n@@ -70,9 +85,14 @@ pub fn find_rand_n<M, T>(n: uint, map: &mut M, b: &mut Bencher,\n     })\n }\n \n-pub fn find_seq_n<M, T>(n: uint, map: &mut M, b: &mut Bencher,\n-                        insert: |&mut M, uint|,\n-                        find: |&M, uint| -> T) {\n+pub fn find_seq_n<M, T, I, F>(n: uint,\n+                              map: &mut M,\n+                              b: &mut Bencher,\n+                              mut insert: I,\n+                              mut find: F) where\n+    I: FnMut(&mut M, uint),\n+    F: FnMut(&M, uint) -> T,\n+{\n     // setup\n     for i in range(0u, n) {\n         insert(map, i);"}, {"sha": "a0c4f6e7ee8c7f68629eabf901facffa3a17e7c6", "filename": "src/libcollections/bit.rs", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibcollections%2Fbit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibcollections%2Fbit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbit.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -174,7 +174,7 @@ impl<'a> Iterator<(uint, u32)> for MaskWords<'a> {\n \n impl Bitv {\n     #[inline]\n-    fn process(&mut self, other: &Bitv, op: |u32, u32| -> u32) -> bool {\n+    fn process<F>(&mut self, other: &Bitv, mut op: F) -> bool where F: FnMut(u32, u32) -> u32 {\n         let len = other.storage.len();\n         assert_eq!(self.storage.len(), len);\n         let mut changed = false;\n@@ -816,7 +816,7 @@ pub fn from_bytes(bytes: &[u8]) -> Bitv {\n /// let bv = from_fn(5, |i| { i % 2 == 0 });\n /// assert!(bv.eq_vec(&[true, false, true, false, true]));\n /// ```\n-pub fn from_fn(len: uint, f: |index: uint| -> bool) -> Bitv {\n+pub fn from_fn<F>(len: uint, mut f: F) -> Bitv where F: FnMut(uint) -> bool {\n     let mut bitv = Bitv::with_capacity(len, false);\n     for i in range(0u, len) {\n         bitv.set(i, f(i));\n@@ -1182,7 +1182,7 @@ impl BitvSet {\n     }\n \n     #[inline]\n-    fn other_op(&mut self, other: &BitvSet, f: |u32, u32| -> u32) {\n+    fn other_op<F>(&mut self, other: &BitvSet, mut f: F) where F: FnMut(u32, u32) -> u32 {\n         // Expand the vector if necessary\n         self.reserve(other.capacity());\n \n@@ -1277,10 +1277,12 @@ impl BitvSet {\n     #[inline]\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn union<'a>(&'a self, other: &'a BitvSet) -> TwoBitPositions<'a> {\n+        fn or(w1: u32, w2: u32) -> u32 { w1 | w2 }\n+\n         TwoBitPositions {\n             set: self,\n             other: other,\n-            merge: |w1, w2| w1 | w2,\n+            merge: or,\n             current_word: 0u32,\n             next_idx: 0u\n         }\n@@ -1306,11 +1308,13 @@ impl BitvSet {\n     #[inline]\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn intersection<'a>(&'a self, other: &'a BitvSet) -> Take<TwoBitPositions<'a>> {\n+        fn bitand(w1: u32, w2: u32) -> u32 { w1 & w2 }\n+\n         let min = cmp::min(self.capacity(), other.capacity());\n         TwoBitPositions {\n             set: self,\n             other: other,\n-            merge: |w1, w2| w1 & w2,\n+            merge: bitand,\n             current_word: 0u32,\n             next_idx: 0\n         }.take(min)\n@@ -1343,10 +1347,12 @@ impl BitvSet {\n     #[inline]\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn difference<'a>(&'a self, other: &'a BitvSet) -> TwoBitPositions<'a> {\n+        fn diff(w1: u32, w2: u32) -> u32 { w1 & !w2 }\n+\n         TwoBitPositions {\n             set: self,\n             other: other,\n-            merge: |w1, w2| w1 & !w2,\n+            merge: diff,\n             current_word: 0u32,\n             next_idx: 0\n         }\n@@ -1373,10 +1379,12 @@ impl BitvSet {\n     #[inline]\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn symmetric_difference<'a>(&'a self, other: &'a BitvSet) -> TwoBitPositions<'a> {\n+        fn bitxor(w1: u32, w2: u32) -> u32 { w1 ^ w2 }\n+\n         TwoBitPositions {\n             set: self,\n             other: other,\n-            merge: |w1, w2| w1 ^ w2,\n+            merge: bitxor,\n             current_word: 0u32,\n             next_idx: 0\n         }\n@@ -1614,7 +1622,7 @@ pub struct BitPositions<'a> {\n pub struct TwoBitPositions<'a> {\n     set: &'a BitvSet,\n     other: &'a BitvSet,\n-    merge: |u32, u32|: 'a -> u32,\n+    merge: fn(u32, u32) -> u32,\n     current_word: u32,\n     next_idx: uint\n }"}, {"sha": "e49a8ddbe5ab8054fed030b8bdb2231374dc4a50", "filename": "src/libcollections/btree/map.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fmap.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -107,10 +107,12 @@ pub struct MoveEntries<K, V> {\n }\n \n /// An iterator over a BTreeMap's keys.\n-pub type Keys<'a, K, V> = iter::Map<'static, (&'a K, &'a V), &'a K, Entries<'a, K, V>>;\n+pub type Keys<'a, K, V> =\n+    iter::Map<(&'a K, &'a V), &'a K, Entries<'a, K, V>, fn((&'a K, &'a V)) -> &'a K>;\n \n /// An iterator over a BTreeMap's values.\n-pub type Values<'a, K, V> = iter::Map<'static, (&'a K, &'a V), &'a V, Entries<'a, K, V>>;\n+pub type Values<'a, K, V> =\n+    iter::Map<(&'a K, &'a V), &'a V, Entries<'a, K, V>, fn((&'a K, &'a V)) -> &'a V>;\n \n /// A view into a single entry in a map, which may either be vacant or occupied.\n pub enum Entry<'a, K:'a, V:'a> {\n@@ -1207,7 +1209,9 @@ impl<K, V> BTreeMap<K, V> {\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn keys<'a>(&'a self) -> Keys<'a, K, V> {\n-        self.iter().map(|(k, _)| k)\n+        fn first<A, B>((a, _): (A, B)) -> A { a }\n+\n+        self.iter().map(first)\n     }\n \n     /// Gets an iterator over the values of the map.\n@@ -1226,7 +1230,9 @@ impl<K, V> BTreeMap<K, V> {\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn values<'a>(&'a self) -> Values<'a, K, V> {\n-        self.iter().map(|(_, v)| v)\n+        fn second<A, B>((_, b): (A, B)) -> B { b }\n+\n+        self.iter().map(second)\n     }\n \n     /// Return the number of elements in the map."}, {"sha": "cd01c008fe1bc3a92654950c7ebc06dc2f4e1a7b", "filename": "src/libcollections/btree/set.rs", "status": "modified", "additions": 23, "deletions": 11, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fset.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -36,7 +36,8 @@ pub struct BTreeSet<T>{\n pub type Items<'a, T> = Keys<'a, T, ()>;\n \n /// An owning iterator over a BTreeSet's items.\n-pub type MoveItems<T> = iter::Map<'static, (T, ()), T, MoveEntries<T, ()>>;\n+pub type MoveItems<T> =\n+    iter::Map<(T, ()), T, MoveEntries<T, ()>, fn((T, ())) -> T>;\n \n /// A lazy iterator producing elements in the set difference (in-order).\n pub struct DifferenceItems<'a, T:'a> {\n@@ -87,7 +88,9 @@ impl<T> BTreeSet<T> {\n     /// Gets an iterator for moving out the BtreeSet's contents.\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn into_iter(self) -> MoveItems<T> {\n-        self.map.into_iter().map(|(k, _)| k)\n+        fn first<A, B>((a, _): (A, B)) -> A { a }\n+\n+        self.map.into_iter().map(first)\n     }\n }\n \n@@ -600,22 +603,31 @@ mod test {\n       assert!(hash::hash(&x) == hash::hash(&y));\n     }\n \n-    fn check(a: &[int],\n-             b: &[int],\n-             expected: &[int],\n-             f: |&BTreeSet<int>, &BTreeSet<int>, f: |&int| -> bool| -> bool) {\n+    struct Counter<'a, 'b> {\n+        i: &'a mut uint,\n+        expected: &'b [int],\n+    }\n+\n+    impl<'a, 'b> FnMut(&int) -> bool for Counter<'a, 'b> {\n+        extern \"rust-call\" fn call_mut(&mut self, (&x,): (&int,)) -> bool {\n+            assert_eq!(x, self.expected[*self.i]);\n+            *self.i += 1;\n+            true\n+        }\n+    }\n+\n+    fn check<F>(a: &[int], b: &[int], expected: &[int], f: F) where\n+        // FIXME Replace Counter with `Box<FnMut(_) -> _>`\n+        F: FnOnce(&BTreeSet<int>, &BTreeSet<int>, Counter) -> bool,\n+    {\n         let mut set_a = BTreeSet::new();\n         let mut set_b = BTreeSet::new();\n \n         for x in a.iter() { assert!(set_a.insert(*x)) }\n         for y in b.iter() { assert!(set_b.insert(*y)) }\n \n         let mut i = 0;\n-        f(&set_a, &set_b, |x| {\n-            assert_eq!(*x, expected[i]);\n-            i += 1;\n-            true\n-        });\n+        f(&set_a, &set_b, Counter { i: &mut i, expected: expected });\n         assert_eq!(i, expected.len());\n     }\n "}, {"sha": "f49a0c037de84372133d35cc23b9caac9fc4fafa", "filename": "src/libcollections/dlist.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibcollections%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibcollections%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fdlist.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -351,18 +351,16 @@ impl<T> DList<T> {\n     ///     println!(\"{}\", e); // prints 2, then 4, then 11, then 7, then 8\n     /// }\n     /// ```\n-    pub fn insert_when(&mut self, elt: T, f: |&T, &T| -> bool) {\n-        {\n-            let mut it = self.iter_mut();\n-            loop {\n-                match it.peek_next() {\n-                    None => break,\n-                    Some(x) => if f(x, &elt) { break }\n-                }\n-                it.next();\n+    pub fn insert_when<F>(&mut self, elt: T, mut f: F) where F: FnMut(&T, &T) -> bool {\n+        let mut it = self.iter_mut();\n+        loop {\n+            match it.peek_next() {\n+                None => break,\n+                Some(x) => if f(x, &elt) { break }\n             }\n-            it.insert_next(elt);\n+            it.next();\n         }\n+        it.insert_next(elt);\n     }\n \n     /// Merges `other` into this `DList`, using the function `f`.\n@@ -371,7 +369,7 @@ impl<T> DList<T> {\n     /// put `a` in the result if `f(a, b)` is true, and otherwise `b`.\n     ///\n     /// This operation should compute in O(max(N, M)) time.\n-    pub fn merge(&mut self, mut other: DList<T>, f: |&T, &T| -> bool) {\n+    pub fn merge<F>(&mut self, mut other: DList<T>, mut f: F) where F: FnMut(&T, &T) -> bool {\n         {\n             let mut it = self.iter_mut();\n             loop {"}, {"sha": "463e28b420d157c6d7bbf6d72aeae439bd1a070b", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -94,6 +94,7 @@ use core::cmp;\n use core::kinds::{Copy, Sized};\n use core::mem::size_of;\n use core::mem;\n+use core::ops::FnMut;\n use core::prelude::{Clone, Greater, Iterator, IteratorExt, Less, None, Option};\n use core::prelude::{Ord, Ordering, RawPtr, Some, range};\n use core::ptr;\n@@ -296,7 +297,7 @@ pub trait CloneSliceAllocPrelude<T> for Sized? {\n \n     /// Partitions the vector into two vectors `(a, b)`, where all\n     /// elements of `a` satisfy `f` and all elements of `b` do not.\n-    fn partitioned(&self, f: |&T| -> bool) -> (Vec<T>, Vec<T>);\n+    fn partitioned<F>(&self, f: F) -> (Vec<T>, Vec<T>) where F: FnMut(&T) -> bool;\n \n     /// Creates an iterator that yields every possible permutation of the\n     /// vector in succession.\n@@ -336,7 +337,7 @@ impl<T: Clone> CloneSliceAllocPrelude<T> for [T] {\n \n \n     #[inline]\n-    fn partitioned(&self, f: |&T| -> bool) -> (Vec<T>, Vec<T>) {\n+    fn partitioned<F>(&self, mut f: F) -> (Vec<T>, Vec<T>) where F: FnMut(&T) -> bool {\n         let mut lefts  = Vec::new();\n         let mut rights = Vec::new();\n \n@@ -361,7 +362,7 @@ impl<T: Clone> CloneSliceAllocPrelude<T> for [T] {\n \n }\n \n-fn insertion_sort<T>(v: &mut [T], compare: |&T, &T| -> Ordering) {\n+fn insertion_sort<T, F>(v: &mut [T], mut compare: F) where F: FnMut(&T, &T) -> Ordering {\n     let len = v.len() as int;\n     let buf_v = v.as_mut_ptr();\n \n@@ -403,7 +404,7 @@ fn insertion_sort<T>(v: &mut [T], compare: |&T, &T| -> Ordering) {\n     }\n }\n \n-fn merge_sort<T>(v: &mut [T], compare: |&T, &T| -> Ordering) {\n+fn merge_sort<T, F>(v: &mut [T], mut compare: F) where F: FnMut(&T, &T) -> Ordering {\n     // warning: this wildly uses unsafe.\n     static BASE_INSERTION: uint = 32;\n     static LARGE_INSERTION: uint = 16;\n@@ -611,7 +612,7 @@ pub trait SliceAllocPrelude<T> for Sized? {\n     /// v.sort_by(|a, b| b.cmp(a));\n     /// assert!(v == [5, 4, 3, 2, 1]);\n     /// ```\n-    fn sort_by(&mut self, compare: |&T, &T| -> Ordering);\n+    fn sort_by<F>(&mut self, compare: F) where F: FnMut(&T, &T) -> Ordering;\n \n     /// Consumes `src` and moves as many elements as it can into `self`\n     /// from the range [start,end).\n@@ -639,7 +640,7 @@ pub trait SliceAllocPrelude<T> for Sized? {\n \n impl<T> SliceAllocPrelude<T> for [T] {\n     #[inline]\n-    fn sort_by(&mut self, compare: |&T, &T| -> Ordering) {\n+    fn sort_by<F>(&mut self, compare: F) where F: FnMut(&T, &T) -> Ordering {\n         merge_sort(self, compare)\n     }\n "}, {"sha": "bf568fd92d5653d50cf3b0fc572564d9da1a7508", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -903,21 +903,21 @@ mod tests {\n     #[test]\n     fn test_find() {\n         assert_eq!(\"hello\".find('l'), Some(2u));\n-        assert_eq!(\"hello\".find(|c:char| c == 'o'), Some(4u));\n+        assert_eq!(\"hello\".find(|&: c:char| c == 'o'), Some(4u));\n         assert!(\"hello\".find('x').is_none());\n-        assert!(\"hello\".find(|c:char| c == 'x').is_none());\n+        assert!(\"hello\".find(|&: c:char| c == 'x').is_none());\n         assert_eq!(\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".find('\u534e'), Some(30u));\n-        assert_eq!(\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".find(|c: char| c == '\u534e'), Some(30u));\n+        assert_eq!(\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".find(|&: c: char| c == '\u534e'), Some(30u));\n     }\n \n     #[test]\n     fn test_rfind() {\n         assert_eq!(\"hello\".rfind('l'), Some(3u));\n-        assert_eq!(\"hello\".rfind(|c:char| c == 'o'), Some(4u));\n+        assert_eq!(\"hello\".rfind(|&: c:char| c == 'o'), Some(4u));\n         assert!(\"hello\".rfind('x').is_none());\n-        assert!(\"hello\".rfind(|c:char| c == 'x').is_none());\n+        assert!(\"hello\".rfind(|&: c:char| c == 'x').is_none());\n         assert_eq!(\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".rfind('\u534e'), Some(30u));\n-        assert_eq!(\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".rfind(|c: char| c == '\u534e'), Some(30u));\n+        assert_eq!(\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".rfind(|&: c: char| c == '\u534e'), Some(30u));\n     }\n \n     #[test]\n@@ -1281,7 +1281,7 @@ mod tests {\n         assert_eq!(\"11foo1bar11\".trim_left_chars('1'), \"foo1bar11\");\n         let chars: &[char] = &['1', '2'];\n         assert_eq!(\"12foo1bar12\".trim_left_chars(chars), \"foo1bar12\");\n-        assert_eq!(\"123foo1bar123\".trim_left_chars(|c: char| c.is_numeric()), \"foo1bar123\");\n+        assert_eq!(\"123foo1bar123\".trim_left_chars(|&: c: char| c.is_numeric()), \"foo1bar123\");\n     }\n \n     #[test]\n@@ -1296,7 +1296,7 @@ mod tests {\n         assert_eq!(\"11foo1bar11\".trim_right_chars('1'), \"11foo1bar\");\n         let chars: &[char] = &['1', '2'];\n         assert_eq!(\"12foo1bar12\".trim_right_chars(chars), \"12foo1bar\");\n-        assert_eq!(\"123foo1bar123\".trim_right_chars(|c: char| c.is_numeric()), \"123foo1bar\");\n+        assert_eq!(\"123foo1bar123\".trim_right_chars(|&: c: char| c.is_numeric()), \"123foo1bar\");\n     }\n \n     #[test]\n@@ -1311,7 +1311,7 @@ mod tests {\n         assert_eq!(\"11foo1bar11\".trim_chars('1'), \"foo1bar\");\n         let chars: &[char] = &['1', '2'];\n         assert_eq!(\"12foo1bar12\".trim_chars(chars), \"foo1bar\");\n-        assert_eq!(\"123foo1bar123\".trim_chars(|c: char| c.is_numeric()), \"foo1bar\");\n+        assert_eq!(\"123foo1bar123\".trim_chars(|&: c: char| c.is_numeric()), \"foo1bar\");\n     }\n \n     #[test]\n@@ -1787,14 +1787,14 @@ mod tests {\n         let split: Vec<&str> = data.splitn(3, ' ').collect();\n         assert_eq!(split, vec![\"\\nM\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little l\u00e4mb\\nLittle l\u00e4mb\\n\"]);\n \n-        let split: Vec<&str> = data.splitn(3, |c: char| c == ' ').collect();\n+        let split: Vec<&str> = data.splitn(3, |&: c: char| c == ' ').collect();\n         assert_eq!(split, vec![\"\\nM\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little l\u00e4mb\\nLittle l\u00e4mb\\n\"]);\n \n         // Unicode\n         let split: Vec<&str> = data.splitn(3, '\u00e4').collect();\n         assert_eq!(split, vec![\"\\nM\", \"ry h\", \"d \", \" little l\u00e4mb\\nLittle l\u00e4mb\\n\"]);\n \n-        let split: Vec<&str> = data.splitn(3, |c: char| c == '\u00e4').collect();\n+        let split: Vec<&str> = data.splitn(3, |&: c: char| c == '\u00e4').collect();\n         assert_eq!(split, vec![\"\\nM\", \"ry h\", \"d \", \" little l\u00e4mb\\nLittle l\u00e4mb\\n\"]);\n     }\n \n@@ -2588,7 +2588,7 @@ mod bench {\n         let s = \"Mary had a little lamb, Little lamb, little-lamb.\";\n         let len = s.split(' ').count();\n \n-        b.iter(|| assert_eq!(s.split(|c: char| c == ' ').count(), len));\n+        b.iter(|| assert_eq!(s.split(|&: c: char| c == ' ').count(), len));\n     }\n \n     #[bench]"}, {"sha": "5c2cf4a81808dd73b4b96c6ce7813d7d73577864", "filename": "src/libcollections/tree/map.rs", "status": "modified", "additions": 24, "deletions": 10, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibcollections%2Ftree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibcollections%2Ftree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftree%2Fmap.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -234,7 +234,9 @@ impl<K: Ord, V> TreeMap<K, V> {\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn keys<'a>(&'a self) -> Keys<'a, K, V> {\n-        self.iter().map(|(k, _v)| k)\n+        fn first<A, B>((a, _): (A, B)) -> A { a }\n+\n+        self.iter().map(first)\n     }\n \n     /// Gets a lazy iterator over the values in the map, in ascending order\n@@ -256,7 +258,9 @@ impl<K: Ord, V> TreeMap<K, V> {\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn values<'a>(&'a self) -> Values<'a, K, V> {\n-        self.iter().map(|(_k, v)| v)\n+        fn second<A, B>((_, b): (A, B)) -> B { b }\n+\n+        self.iter().map(second)\n     }\n \n     /// Gets a lazy iterator over the key-value pairs in the map, in ascending order.\n@@ -612,7 +616,7 @@ impl<K, V> TreeMap<K, V> {\n     /// ```\n     #[inline]\n     #[experimental = \"likely to be renamed, may be removed\"]\n-    pub fn find_with(&self, f:|&K| -> Ordering) -> Option<&V> {\n+    pub fn find_with<F>(&self, f: F) -> Option<&V> where F: FnMut(&K) -> Ordering {\n         tree_find_with(&self.root, f)\n     }\n \n@@ -637,7 +641,9 @@ impl<K, V> TreeMap<K, V> {\n     /// ```\n     #[inline]\n     #[experimental = \"likely to be renamed, may be removed\"]\n-    pub fn find_with_mut<'a>(&'a mut self, f:|&K| -> Ordering) -> Option<&'a mut V> {\n+    pub fn find_with_mut<'a, F>(&'a mut self, f: F) -> Option<&'a mut V> where\n+        F: FnMut(&K) -> Ordering\n+    {\n         tree_find_with_mut(&mut self.root, f)\n     }\n }\n@@ -863,11 +869,11 @@ pub struct RevMutEntries<'a, K:'a, V:'a> {\n \n /// TreeMap keys iterator.\n pub type Keys<'a, K, V> =\n-    iter::Map<'static, (&'a K, &'a V), &'a K, Entries<'a, K, V>>;\n+    iter::Map<(&'a K, &'a V), &'a K, Entries<'a, K, V>, fn((&'a K, &'a V)) -> &'a K>;\n \n /// TreeMap values iterator.\n pub type Values<'a, K, V> =\n-    iter::Map<'static, (&'a K, &'a V), &'a V, Entries<'a, K, V>>;\n+    iter::Map<(&'a K, &'a V), &'a V, Entries<'a, K, V>, fn((&'a K, &'a V)) -> &'a V>;\n \n \n // FIXME #5846 we want to be able to choose between &x and &mut x\n@@ -1125,8 +1131,12 @@ fn split<K: Ord, V>(node: &mut Box<TreeNode<K, V>>) {\n // Next 2 functions have the same convention: comparator gets\n // at input current key and returns search_key cmp cur_key\n // (i.e. search_key.cmp(&cur_key))\n-fn tree_find_with<'r, K, V>(node: &'r Option<Box<TreeNode<K, V>>>,\n-                            f: |&K| -> Ordering) -> Option<&'r V> {\n+fn tree_find_with<'r, K, V, F>(\n+    node: &'r Option<Box<TreeNode<K, V>>>,\n+    mut f: F,\n+) -> Option<&'r V> where\n+    F: FnMut(&K) -> Ordering,\n+{\n     let mut current: &'r Option<Box<TreeNode<K, V>>> = node;\n     loop {\n         match *current {\n@@ -1143,8 +1153,12 @@ fn tree_find_with<'r, K, V>(node: &'r Option<Box<TreeNode<K, V>>>,\n }\n \n // See comments above tree_find_with\n-fn tree_find_with_mut<'r, K, V>(node: &'r mut Option<Box<TreeNode<K, V>>>,\n-                                f: |&K| -> Ordering) -> Option<&'r mut V> {\n+fn tree_find_with_mut<'r, K, V, F>(\n+    node: &'r mut Option<Box<TreeNode<K, V>>>,\n+    mut f: F,\n+) -> Option<&'r mut V> where\n+    F: FnMut(&K) -> Ordering,\n+{\n \n     let mut current = node;\n     loop {"}, {"sha": "bd8bf5c6cb67f54a437beff65bdbea14847b39e9", "filename": "src/libcollections/tree/set.rs", "status": "modified", "additions": 22, "deletions": 11, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibcollections%2Ftree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibcollections%2Ftree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftree%2Fset.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -205,7 +205,9 @@ impl<T: Ord> TreeSet<T> {\n     #[inline]\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn into_iter(self) -> MoveSetItems<T> {\n-        self.map.into_iter().map(|(value, _)| value)\n+        fn first<A, B>((a, _): (A, B)) -> A { a }\n+\n+        self.map.into_iter().map(first)\n     }\n \n     /// Gets a lazy iterator pointing to the first value not less than `v` (greater or equal).\n@@ -560,7 +562,7 @@ pub struct RevSetItems<'a, T:'a> {\n }\n \n /// A lazy forward iterator over a set that consumes the set while iterating.\n-pub type MoveSetItems<T> = iter::Map<'static, (T, ()), T, MoveEntries<T, ()>>;\n+pub type MoveSetItems<T> = iter::Map<(T, ()), T, MoveEntries<T, ()>, fn((T, ())) -> T>;\n \n /// A lazy iterator producing elements in the set difference (in-order).\n pub struct DifferenceItems<'a, T:'a> {\n@@ -934,22 +936,31 @@ mod test {\n       assert!(hash::hash(&x) == hash::hash(&y));\n     }\n \n-    fn check(a: &[int],\n-             b: &[int],\n-             expected: &[int],\n-             f: |&TreeSet<int>, &TreeSet<int>, f: |&int| -> bool| -> bool) {\n+    struct Counter<'a, 'b> {\n+        i: &'a mut uint,\n+        expected: &'b [int],\n+    }\n+\n+    impl<'a, 'b> FnMut(&int) -> bool for Counter<'a, 'b> {\n+        extern \"rust-call\" fn call_mut(&mut self, (&x,): (&int,)) -> bool {\n+            assert_eq!(x, self.expected[*self.i]);\n+            *self.i += 1;\n+            true\n+        }\n+    }\n+\n+    fn check<F>(a: &[int], b: &[int], expected: &[int], f: F) where\n+        // FIXME Replace `Counter` with `Box<FnMut(&int) -> bool>`\n+        F: FnOnce(&TreeSet<int>, &TreeSet<int>, Counter) -> bool,\n+    {\n         let mut set_a = TreeSet::new();\n         let mut set_b = TreeSet::new();\n \n         for x in a.iter() { assert!(set_a.insert(*x)) }\n         for y in b.iter() { assert!(set_b.insert(*y)) }\n \n         let mut i = 0;\n-        f(&set_a, &set_b, |x| {\n-            assert_eq!(*x, expected[i]);\n-            i += 1;\n-            true\n-        });\n+        f(&set_a, &set_b, Counter { i: &mut i, expected: expected });\n         assert_eq!(i, expected.len());\n     }\n "}, {"sha": "a4dee8076487d142fa0172085398e6c2e7561f6f", "filename": "src/libcollections/trie/map.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibcollections%2Ftrie%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibcollections%2Ftrie%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftrie%2Fmap.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -197,14 +197,18 @@ impl<T> TrieMap<T> {\n     /// The iterator's element type is `uint`.\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn keys<'r>(&'r self) -> Keys<'r, T> {\n-        self.iter().map(|(k, _v)| k)\n+        fn first<A, B>((a, _): (A, B)) -> A { a }\n+\n+        self.iter().map(first)\n     }\n \n     /// Gets an iterator visiting all values in ascending order by the keys.\n     /// The iterator's element type is `&'r T`.\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn values<'r>(&'r self) -> Values<'r, T> {\n-        self.iter().map(|(_k, v)| v)\n+        fn second<A, B>((_, b): (A, B)) -> B { b }\n+\n+        self.iter().map(second)\n     }\n \n     /// Gets an iterator over the key-value pairs in the map, ordered by keys.\n@@ -1091,12 +1095,11 @@ pub struct MutEntries<'a, T:'a> {\n }\n \n /// A forward iterator over the keys of a map.\n-pub type Keys<'a, T> =\n-    iter::Map<'static, (uint, &'a T), uint, Entries<'a, T>>;\n+pub type Keys<'a, T> = iter::Map<(uint, &'a T), uint, Entries<'a, T>, fn((uint, &'a T)) -> uint>;\n \n /// A forward iterator over the values of a map.\n pub type Values<'a, T> =\n-    iter::Map<'static, (uint, &'a T), &'a T, Entries<'a, T>>;\n+    iter::Map<(uint, &'a T), &'a T, Entries<'a, T>, fn((uint, &'a T)) -> &'a T>;\n \n // FIXME #5846: see `addr!` above.\n macro_rules! item { ($i:item) => {$i}}"}, {"sha": "5621726dc568291368c42f7945575010f2f8db2c", "filename": "src/libcollections/trie/set.rs", "status": "modified", "additions": 18, "deletions": 9, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibcollections%2Ftrie%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibcollections%2Ftrie%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftrie%2Fset.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -743,22 +743,31 @@ mod test {\n         assert!(a < b && a <= b);\n     }\n \n-    fn check(a: &[uint],\n-             b: &[uint],\n-             expected: &[uint],\n-             f: |&TrieSet, &TrieSet, f: |uint| -> bool| -> bool) {\n+    struct Counter<'a, 'b> {\n+        i: &'a mut uint,\n+        expected: &'b [uint],\n+    }\n+\n+    impl<'a, 'b> FnMut(uint) -> bool for Counter<'a, 'b> {\n+        extern \"rust-call\" fn call_mut(&mut self, (x,): (uint,)) -> bool {\n+            assert_eq!(x, self.expected[*self.i]);\n+            *self.i += 1;\n+            true\n+        }\n+    }\n+\n+    fn check<F>(a: &[uint], b: &[uint], expected: &[uint], f: F) where\n+        // FIXME Replace `Counter` with `Box<FnMut(&uint) -> bool>`\n+        F: FnOnce(&TrieSet, &TrieSet, Counter) -> bool,\n+    {\n         let mut set_a = TrieSet::new();\n         let mut set_b = TrieSet::new();\n \n         for x in a.iter() { assert!(set_a.insert(*x)) }\n         for y in b.iter() { assert!(set_b.insert(*y)) }\n \n         let mut i = 0;\n-        f(&set_a, &set_b, |x| {\n-            assert_eq!(x, expected[i]);\n-            i += 1;\n-            true\n-        });\n+        f(&set_a, &set_b, Counter { i: &mut i, expected: expected });\n         assert_eq!(i, expected.len());\n     }\n "}, {"sha": "2ed8686394c01d4aeebe65edb10d2a8b328ae007", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -206,7 +206,7 @@ impl<T> Vec<T> {\n     #[inline]\n     #[unstable = \"the naming is uncertain as well as this migrating to unboxed \\\n                   closures in the future\"]\n-    pub fn from_fn(length: uint, op: |uint| -> T) -> Vec<T> {\n+    pub fn from_fn<F>(length: uint, mut op: F) -> Vec<T> where F: FnMut(uint) -> T {\n         unsafe {\n             let mut xs = Vec::with_capacity(length);\n             while xs.len < length {\n@@ -289,7 +289,7 @@ impl<T> Vec<T> {\n     /// ```\n     #[inline]\n     #[experimental]\n-    pub fn partition(self, f: |&T| -> bool) -> (Vec<T>, Vec<T>) {\n+    pub fn partition<F>(self, mut f: F) -> (Vec<T>, Vec<T>) where F: FnMut(&T) -> bool {\n         let mut lefts  = Vec::new();\n         let mut rights = Vec::new();\n \n@@ -400,7 +400,7 @@ impl<T: Clone> Vec<T> {\n     /// assert_eq!(odd, vec![1i, 3]);\n     /// ```\n     #[experimental]\n-    pub fn partitioned(&self, f: |&T| -> bool) -> (Vec<T>, Vec<T>) {\n+    pub fn partitioned<F>(&self, mut f: F) -> (Vec<T>, Vec<T>) where F: FnMut(&T) -> bool {\n         let mut lefts = Vec::new();\n         let mut rights = Vec::new();\n \n@@ -991,7 +991,7 @@ impl<T> Vec<T> {\n     /// assert_eq!(vec, vec![2, 4]);\n     /// ```\n     #[unstable = \"the closure argument may become an unboxed closure\"]\n-    pub fn retain(&mut self, f: |&T| -> bool) {\n+    pub fn retain<F>(&mut self, mut f: F) where F: FnMut(&T) -> bool {\n         let len = self.len();\n         let mut del = 0u;\n         {\n@@ -1023,7 +1023,7 @@ impl<T> Vec<T> {\n     /// assert_eq!(vec, vec![0, 1, 0, 1, 2]);\n     /// ```\n     #[unstable = \"this function may be renamed or change to unboxed closures\"]\n-    pub fn grow_fn(&mut self, n: uint, f: |uint| -> T) {\n+    pub fn grow_fn<F>(&mut self, n: uint, mut f: F) where F: FnMut(uint) -> T {\n         self.reserve(n);\n         for i in range(0u, n) {\n             self.push(f(i));\n@@ -1570,7 +1570,7 @@ impl<T> Vec<T> {\n     /// let newtyped_bytes = bytes.map_in_place(|x| Newtype(x));\n     /// assert_eq!(newtyped_bytes.as_slice(), [Newtype(0x11), Newtype(0x22)].as_slice());\n     /// ```\n-    pub fn map_in_place<U>(self, f: |T| -> U) -> Vec<U> {\n+    pub fn map_in_place<U, F>(self, mut f: F) -> Vec<U> where F: FnMut(T) -> U {\n         // FIXME: Assert statically that the types `T` and `U` have the same\n         // size.\n         assert!(mem::size_of::<T>() == mem::size_of::<U>());"}, {"sha": "cc2fd0a66469017fa55ba0fc03c058ac1113a820", "filename": "src/libcollections/vec_map.rs", "status": "modified", "additions": 24, "deletions": 17, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibcollections%2Fvec_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibcollections%2Fvec_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_map.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -20,6 +20,7 @@ use core::fmt;\n use core::iter;\n use core::iter::{Enumerate, FilterMap};\n use core::mem::replace;\n+use core::ops::FnOnce;\n \n use hash::{Hash, Writer};\n use {vec, slice};\n@@ -141,14 +142,18 @@ impl<V> VecMap<V> {\n     /// The iterator's element type is `uint`.\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn keys<'r>(&'r self) -> Keys<'r, V> {\n-        self.iter().map(|(k, _v)| k)\n+        fn first<A, B>((a, _): (A, B)) -> A { a }\n+\n+        self.iter().map(first)\n     }\n \n     /// Returns an iterator visiting all values in ascending order by the keys.\n     /// The iterator's element type is `&'r V`.\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn values<'r>(&'r self) -> Values<'r, V> {\n-        self.iter().map(|(_k, v)| v)\n+        fn second<A, B>((_, b): (A, B)) -> B { b }\n+\n+        self.iter().map(second)\n     }\n \n     /// Returns an iterator visiting all key-value pairs in ascending order by the keys.\n@@ -230,10 +235,12 @@ impl<V> VecMap<V> {\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn into_iter(&mut self) -> MoveItems<V> {\n-        let values = replace(&mut self.v, vec!());\n-        values.into_iter().enumerate().filter_map(|(i, v)| {\n+        fn filter<A>((i, v): (uint, Option<A>)) -> Option<(uint, A)> {\n             v.map(|v| (i, v))\n-        })\n+        }\n+\n+        let values = replace(&mut self.v, vec!());\n+        values.into_iter().enumerate().filter_map(filter)\n     }\n \n     /// Return the number of elements in the map.\n@@ -446,8 +453,8 @@ impl<V:Clone> VecMap<V> {\n     /// assert!(!map.update(1, vec![3i, 4], |mut old, new| { old.extend(new.into_iter()); old }));\n     /// assert_eq!(map[1], vec![1i, 2, 3, 4]);\n     /// ```\n-    pub fn update(&mut self, key: uint, newval: V, ff: |V, V| -> V) -> bool {\n-        self.update_with_key(key, newval, |_k, v, v1| ff(v,v1))\n+    pub fn update<F>(&mut self, key: uint, newval: V, ff: F) -> bool where F: FnOnce(V, V) -> V {\n+        self.update_with_key(key, newval, move |_k, v, v1| ff(v,v1))\n     }\n \n     /// Updates a value in the map. If the key already exists in the map,\n@@ -470,11 +477,9 @@ impl<V:Clone> VecMap<V> {\n     /// assert!(!map.update_with_key(7, 20, |key, old, new| (old + new) % key));\n     /// assert_eq!(map[7], 2);\n     /// ```\n-    pub fn update_with_key(&mut self,\n-                           key: uint,\n-                           val: V,\n-                           ff: |uint, V, V| -> V)\n-                           -> bool {\n+    pub fn update_with_key<F>(&mut self, key: uint, val: V, ff: F) -> bool where\n+        F: FnOnce(uint, V, V) -> V\n+    {\n         let new_val = match self.get(&key) {\n             None => val,\n             Some(orig) => ff(key, (*orig).clone(), val)\n@@ -620,16 +625,18 @@ iterator!(impl MutEntries -> (uint, &'a mut V), as_mut)\n double_ended_iterator!(impl MutEntries -> (uint, &'a mut V), as_mut)\n \n /// Forward iterator over the keys of a map\n-pub type Keys<'a, V> =\n-    iter::Map<'static, (uint, &'a V), uint, Entries<'a, V>>;\n+pub type Keys<'a, V> = iter::Map<(uint, &'a V), uint, Entries<'a, V>, fn((uint, &'a V)) -> uint>;\n \n /// Forward iterator over the values of a map\n pub type Values<'a, V> =\n-    iter::Map<'static, (uint, &'a V), &'a V, Entries<'a, V>>;\n+    iter::Map<(uint, &'a V), &'a V, Entries<'a, V>, fn((uint, &'a V)) -> &'a V>;\n \n /// Iterator over the key-value pairs of a map, the iterator consumes the map\n-pub type MoveItems<V> =\n-    FilterMap<'static, (uint, Option<V>), (uint, V), Enumerate<vec::MoveItems<Option<V>>>>;\n+pub type MoveItems<V> = FilterMap<\n+    (uint, Option<V>),\n+    (uint, V),\n+    Enumerate<vec::MoveItems<Option<V>>>,\n+    fn((uint, Option<V>)) -> Option<(uint, V)>>;\n \n #[cfg(test)]\n mod test_map {"}, {"sha": "75f7991df027b51fc8df78d4feea4433b107dd7a", "filename": "src/libcore/char.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibcore%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibcore%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -16,6 +16,7 @@\n #![doc(primitive = \"char\")]\n \n use mem::transmute;\n+use ops::FnMut;\n use option::Option;\n use option::Option::{None, Some};\n use iter::{range_step, Iterator, RangeStep};\n@@ -165,7 +166,7 @@ pub fn from_digit(num: uint, radix: uint) -> Option<char> {\n /// - chars above 0x10000 get 8-digit escapes: `\\\\u{{NNN}NNNNN}`\n ///\n #[deprecated = \"use the Char::escape_unicode method\"]\n-pub fn escape_unicode(c: char, f: |char|) {\n+pub fn escape_unicode<F>(c: char, mut f: F) where F: FnMut(char) {\n     for char in c.escape_unicode() {\n         f(char);\n     }\n@@ -184,7 +185,7 @@ pub fn escape_unicode(c: char, f: |char|) {\n /// - Any other chars are given hex Unicode escapes; see `escape_unicode`.\n ///\n #[deprecated = \"use the Char::escape_default method\"]\n-pub fn escape_default(c: char, f: |char|) {\n+pub fn escape_default<F>(c: char, mut f: F) where F: FnMut(char) {\n     for c in c.escape_default() {\n         f(c);\n     }"}, {"sha": "2b48b2bf81afbd25563ac6b1a07697ebbb239784", "filename": "src/libcore/finally.rs", "status": "modified", "additions": 17, "deletions": 24, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibcore%2Ffinally.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibcore%2Ffinally.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffinally.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -19,40 +19,34 @@\n //! # Example\n //!\n //! ```\n+//! # #![feature(unboxed_closures)]\n+//!\n //! use std::finally::Finally;\n //!\n-//! (|| {\n+//! # fn main() {\n+//! (|&mut:| {\n //!     // ...\n //! }).finally(|| {\n //!     // this code is always run\n //! })\n+//! # }\n //! ```\n \n #![experimental]\n \n-use ops::Drop;\n+use ops::{Drop, FnMut, FnOnce};\n \n /// A trait for executing a destructor unconditionally after a block of code,\n /// regardless of whether the blocked fails.\n pub trait Finally<T> {\n     /// Executes this object, unconditionally running `dtor` after this block of\n     /// code has run.\n-    fn finally(&mut self, dtor: ||) -> T;\n-}\n-\n-impl<'a,T> Finally<T> for ||: 'a -> T {\n-    fn finally(&mut self, dtor: ||) -> T {\n-        try_finally(&mut (), self,\n-                    |_, f| (*f)(),\n-                    |_| dtor())\n-    }\n+    fn finally<F>(&mut self, dtor: F) -> T where F: FnMut();\n }\n \n-impl<T> Finally<T> for fn() -> T {\n-    fn finally(&mut self, dtor: ||) -> T {\n-        try_finally(&mut (), (),\n-                    |_, _| (*self)(),\n-                    |_| dtor())\n+impl<T, F> Finally<T> for F where F: FnMut() -> T {\n+    fn finally<G>(&mut self, mut dtor: G) -> T where G: FnMut() {\n+        try_finally(&mut (), self, |_, f| (*f)(), |_| dtor())\n     }\n }\n \n@@ -86,25 +80,24 @@ impl<T> Finally<T> for fn() -> T {\n ///         // use state.buffer, state.len to cleanup\n ///     })\n /// ```\n-pub fn try_finally<T,U,R>(mutate: &mut T,\n-                          drop: U,\n-                          try_fn: |&mut T, U| -> R,\n-                          finally_fn: |&mut T|)\n-                          -> R {\n+pub fn try_finally<T, U, R, F, G>(mutate: &mut T, drop: U, try_fn: F, finally_fn: G) -> R where\n+    F: FnOnce(&mut T, U) -> R,\n+    G: FnMut(&mut T),\n+{\n     let f = Finallyalizer {\n         mutate: mutate,\n         dtor: finally_fn,\n     };\n     try_fn(&mut *f.mutate, drop)\n }\n \n-struct Finallyalizer<'a,A:'a> {\n+struct Finallyalizer<'a, A:'a, F> where F: FnMut(&mut A) {\n     mutate: &'a mut A,\n-    dtor: |&mut A|: 'a\n+    dtor: F,\n }\n \n #[unsafe_destructor]\n-impl<'a,A> Drop for Finallyalizer<'a,A> {\n+impl<'a, A, F> Drop for Finallyalizer<'a, A, F> where F: FnMut(&mut A) {\n     #[inline]\n     fn drop(&mut self) {\n         (self.dtor)(self.mutate);"}, {"sha": "fb4d91e912a3b65c75706dd0d394f1d34d064c58", "filename": "src/libcore/fmt/float.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibcore%2Ffmt%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibcore%2Ffmt%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Ffloat.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -20,6 +20,7 @@ use fmt;\n use iter::{range, DoubleEndedIteratorExt};\n use num::{Float, FPNaN, FPInfinite, ToPrimitive};\n use num::cast;\n+use ops::FnOnce;\n use result::Result::Ok;\n use slice::{mod, SlicePrelude};\n use str::StrPrelude;\n@@ -84,16 +85,18 @@ static DIGIT_E_RADIX: uint = ('e' as uint) - ('a' as uint) + 11u;\n ///   between digit and exponent sign `'e'`.\n /// - Panics if `radix` > 25 and `exp_format` is `ExpBin` due to conflict\n ///   between digit and exponent sign `'p'`.\n-pub fn float_to_str_bytes_common<T: Float, U>(\n+pub fn float_to_str_bytes_common<T: Float, U, F>(\n     num: T,\n     radix: uint,\n     negative_zero: bool,\n     sign: SignFormat,\n     digits: SignificantDigits,\n     exp_format: ExponentFormat,\n     exp_upper: bool,\n-    f: |&[u8]| -> U\n-) -> U {\n+    f: F\n+) -> U where\n+    F: FnOnce(&[u8]) -> U,\n+{\n     assert!(2 <= radix && radix <= 36);\n     match exp_format {\n         ExpDec if radix >= DIGIT_E_RADIX       // decimal exponent 'e'"}, {"sha": "37a1d4d564d843836b1cd45faffece81fd1a85ca", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -19,7 +19,7 @@ use kinds::{Copy, Sized};\n use mem;\n use option::Option;\n use option::Option::{Some, None};\n-use ops::Deref;\n+use ops::{Deref, FnOnce};\n use result::Result::{Ok, Err};\n use result;\n use slice::SlicePrelude;\n@@ -491,10 +491,9 @@ impl<'a> Formatter<'a> {\n \n     /// Runs a callback, emitting the correct padding either before or\n     /// afterwards depending on whether right or left alignment is requested.\n-    fn with_padding(&mut self,\n-                    padding: uint,\n-                    default: rt::Alignment,\n-                    f: |&mut Formatter| -> Result) -> Result {\n+    fn with_padding<F>(&mut self, padding: uint, default: rt::Alignment, f: F) -> Result where\n+        F: FnOnce(&mut Formatter) -> Result,\n+    {\n         use char::Char;\n         let align = match self.align {\n             rt::AlignUnknown => default,"}, {"sha": "8ee2a8874bb0368812675da1994e3a3ebca0d9af", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 121, "deletions": 79, "changes": 200, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -62,7 +62,7 @@ use cmp::Ord;\n use kinds::Copy;\n use mem;\n use num::{ToPrimitive, Int};\n-use ops::{Add, Deref};\n+use ops::{Add, Deref, FnMut};\n use option::Option;\n use option::Option::{Some, None};\n use uint;\n@@ -165,7 +165,7 @@ pub trait IteratorExt<A>: Iterator<A> {\n     /// ```\n     #[inline]\n     #[unstable = \"waiting for unboxed closures\"]\n-    fn map<'r, B>(self, f: |A|: 'r -> B) -> Map<'r, A, B, Self> {\n+    fn map<B, F: FnMut(A) -> B>(self, f: F) -> Map<A, B, Self, F> {\n         Map{iter: self, f: f}\n     }\n \n@@ -183,7 +183,7 @@ pub trait IteratorExt<A>: Iterator<A> {\n     /// ```\n     #[inline]\n     #[unstable = \"waiting for unboxed closures\"]\n-    fn filter<'r>(self, predicate: |&A|: 'r -> bool) -> Filter<'r, A, Self> {\n+    fn filter<P>(self, predicate: P) -> Filter<A, Self, P> where P: FnMut(&A) -> bool {\n         Filter{iter: self, predicate: predicate}\n     }\n \n@@ -201,7 +201,7 @@ pub trait IteratorExt<A>: Iterator<A> {\n     /// ```\n     #[inline]\n     #[unstable = \"waiting for unboxed closures\"]\n-    fn filter_map<'r, B>(self, f: |A|: 'r -> Option<B>) -> FilterMap<'r, A, B, Self> {\n+    fn filter_map<B, F>(self, f: F) -> FilterMap<A, B, Self, F> where F: FnMut(A) -> Option<B> {\n         FilterMap { iter: self, f: f }\n     }\n \n@@ -264,7 +264,7 @@ pub trait IteratorExt<A>: Iterator<A> {\n     /// ```\n     #[inline]\n     #[unstable = \"waiting for unboxed closures\"]\n-    fn skip_while<'r>(self, predicate: |&A|: 'r -> bool) -> SkipWhile<'r, A, Self> {\n+    fn skip_while<P>(self, predicate: P) -> SkipWhile<A, Self, P> where P: FnMut(&A) -> bool {\n         SkipWhile{iter: self, flag: false, predicate: predicate}\n     }\n \n@@ -283,7 +283,7 @@ pub trait IteratorExt<A>: Iterator<A> {\n     /// ```\n     #[inline]\n     #[unstable = \"waiting for unboxed closures, may want to require peek\"]\n-    fn take_while<'r>(self, predicate: |&A|: 'r -> bool) -> TakeWhile<'r, A, Self> {\n+    fn take_while<P>(self, predicate: P) -> TakeWhile<A, Self, P> where P: FnMut(&A) -> bool {\n         TakeWhile{iter: self, flag: false, predicate: predicate}\n     }\n \n@@ -346,8 +346,9 @@ pub trait IteratorExt<A>: Iterator<A> {\n     /// ```\n     #[inline]\n     #[unstable = \"waiting for unboxed closures\"]\n-    fn scan<'r, St, B>(self, initial_state: St, f: |&mut St, A|: 'r -> Option<B>)\n-        -> Scan<'r, A, B, Self, St> {\n+    fn scan<St, B, F>(self, initial_state: St, f: F) -> Scan<A, B, Self, St, F> where\n+        F: FnMut(&mut St, A) -> Option<B>,\n+    {\n         Scan{iter: self, f: f, state: initial_state}\n     }\n \n@@ -371,8 +372,10 @@ pub trait IteratorExt<A>: Iterator<A> {\n     /// ```\n     #[inline]\n     #[unstable = \"waiting for unboxed closures\"]\n-    fn flat_map<'r, B, U: Iterator<B>>(self, f: |A|: 'r -> U)\n-        -> FlatMap<'r, A, Self, U> {\n+    fn flat_map<B, U, F>(self, f: F) -> FlatMap<A, B, Self, U, F> where\n+        U: Iterator<B>,\n+        F: FnMut(A) -> U,\n+    {\n         FlatMap{iter: self, f: f, frontiter: None, backiter: None }\n     }\n \n@@ -429,7 +432,7 @@ pub trait IteratorExt<A>: Iterator<A> {\n     /// ```\n     #[inline]\n     #[unstable = \"waiting for unboxed closures\"]\n-    fn inspect<'r>(self, f: |&A|: 'r) -> Inspect<'r, A, Self> {\n+    fn inspect<F>(self, f: F) -> Inspect<A, Self, F> where F: FnMut(&A) {\n         Inspect{iter: self, f: f}\n     }\n \n@@ -518,7 +521,7 @@ pub trait IteratorExt<A>: Iterator<A> {\n     /// ```\n     #[inline]\n     #[unstable = \"waiting for unboxed closures, just changed to take self by value\"]\n-    fn fold<B>(mut self, init: B, f: |B, A| -> B) -> B {\n+    fn fold<B, F>(mut self, init: B, mut f: F) -> B where F: FnMut(B, A) -> B {\n         let mut accum = init;\n         for x in self {\n             accum = f(accum, x);\n@@ -552,7 +555,7 @@ pub trait IteratorExt<A>: Iterator<A> {\n     /// ```\n     #[inline]\n     #[unstable = \"waiting for unboxed closures, just changed to take self by value\"]\n-    fn all(mut self, f: |A| -> bool) -> bool {\n+    fn all<F>(mut self, mut f: F) -> bool where F: FnMut(A) -> bool {\n         for x in self { if !f(x) { return false; } }\n         true\n     }\n@@ -570,7 +573,7 @@ pub trait IteratorExt<A>: Iterator<A> {\n     /// ```\n     #[inline]\n     #[unstable = \"waiting for unboxed closures\"]\n-    fn any(&mut self, f: |A| -> bool) -> bool {\n+    fn any<F>(&mut self, mut f: F) -> bool where F: FnMut(A) -> bool {\n         for x in *self { if f(x) { return true; } }\n         false\n     }\n@@ -580,7 +583,7 @@ pub trait IteratorExt<A>: Iterator<A> {\n     /// Does not consume the iterator past the first found element.\n     #[inline]\n     #[unstable = \"waiting for unboxed closures\"]\n-    fn find(&mut self, predicate: |&A| -> bool) -> Option<A> {\n+    fn find<P>(&mut self, mut predicate: P) -> Option<A> where P: FnMut(&A) -> bool {\n         for x in *self {\n             if predicate(&x) { return Some(x) }\n         }\n@@ -590,7 +593,7 @@ pub trait IteratorExt<A>: Iterator<A> {\n     /// Return the index of the first element satisfying the specified predicate\n     #[inline]\n     #[unstable = \"waiting for unboxed closures\"]\n-    fn position(&mut self, predicate: |A| -> bool) -> Option<uint> {\n+    fn position<P>(&mut self, mut predicate: P) -> Option<uint> where P: FnMut(A) -> bool {\n         let mut i = 0;\n         for x in *self {\n             if predicate(x) {\n@@ -614,7 +617,7 @@ pub trait IteratorExt<A>: Iterator<A> {\n     /// ```\n     #[inline]\n     #[unstable = \"waiting for unboxed closures, just changed to take self by value\"]\n-    fn max_by<B: Ord>(self, f: |&A| -> B) -> Option<A> {\n+    fn max_by<B: Ord, F>(self, mut f: F) -> Option<A> where F: FnMut(&A) -> B {\n         self.fold(None, |max: Option<(A, B)>, x| {\n             let x_val = f(&x);\n             match max {\n@@ -641,7 +644,7 @@ pub trait IteratorExt<A>: Iterator<A> {\n     /// ```\n     #[inline]\n     #[unstable = \"waiting for unboxed closures, just changed to take self by value\"]\n-    fn min_by<B: Ord>(self, f: |&A| -> B) -> Option<A> {\n+    fn min_by<B: Ord, F>(self, mut f: F) -> Option<A> where F: FnMut(&A) -> B {\n         self.fold(None, |min: Option<(A, B)>, x| {\n             let x_val = f(&x);\n             match min {\n@@ -746,7 +749,7 @@ pub trait ExactSizeIterator<A> : DoubleEndedIterator<A> {\n     ///\n     /// If no element matches, None is returned.\n     #[inline]\n-    fn rposition(&mut self, predicate: |A| -> bool) -> Option<uint> {\n+    fn rposition<P>(&mut self, mut predicate: P) -> Option<uint> where P: FnMut(A) -> bool {\n         let len = self.len();\n         for i in range(0, len).rev() {\n             if predicate(self.next_back().expect(\"rposition: incorrect ExactSizeIterator\")) {\n@@ -774,11 +777,17 @@ pub trait ExactSizeIterator<A> : DoubleEndedIterator<A> {\n #[unstable = \"trait is unstable\"]\n impl<A, T: ExactSizeIterator<A>> ExactSizeIterator<(uint, A)> for Enumerate<T> {}\n #[unstable = \"trait is unstable\"]\n-impl<'a, A, T: ExactSizeIterator<A>> ExactSizeIterator<A> for Inspect<'a, A, T> {}\n+impl<A, I, F> ExactSizeIterator<A> for Inspect<A, I, F> where\n+    I: ExactSizeIterator<A>,\n+    F: FnMut(&A),\n+{}\n #[unstable = \"trait is unstable\"]\n impl<A, T: ExactSizeIterator<A>> ExactSizeIterator<A> for Rev<T> {}\n #[unstable = \"trait is unstable\"]\n-impl<'a, A, B, T: ExactSizeIterator<A>> ExactSizeIterator<B> for Map<'a, A, B, T> {}\n+impl<A, B, I, F> ExactSizeIterator<B> for Map<A, B, I, F> where\n+    I: ExactSizeIterator<A>,\n+    F: FnMut(A) -> B,\n+{}\n #[unstable = \"trait is unstable\"]\n impl<A, B, T, U> ExactSizeIterator<(A, B)> for Zip<T, U>\n     where T: ExactSizeIterator<A>, U: ExactSizeIterator<B> {}\n@@ -1374,12 +1383,12 @@ RandomAccessIterator<(A, B)> for Zip<T, U> {\n /// An iterator which maps the values of `iter` with `f`\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n #[stable]\n-pub struct Map<'a, A, B, T> {\n-    iter: T,\n-    f: |A|: 'a -> B\n+pub struct Map<A, B, I: Iterator<A>, F: FnMut(A) -> B> {\n+    iter: I,\n+    f: F,\n }\n \n-impl<'a, A, B, T> Map<'a, A, B, T> {\n+impl<A, B, I, F> Map<A, B, I, F> where I: Iterator<A>, F: FnMut(A) -> B {\n     #[inline]\n     fn do_map(&mut self, elt: Option<A>) -> Option<B> {\n         match elt {\n@@ -1390,7 +1399,7 @@ impl<'a, A, B, T> Map<'a, A, B, T> {\n }\n \n #[unstable = \"trait is unstable\"]\n-impl<'a, A, B, T: Iterator<A>> Iterator<B> for Map<'a, A, B, T> {\n+impl<A, B, I, F> Iterator<B> for Map<A, B, I, F> where I: Iterator<A>, F: FnMut(A) -> B {\n     #[inline]\n     fn next(&mut self) -> Option<B> {\n         let next = self.iter.next();\n@@ -1404,7 +1413,10 @@ impl<'a, A, B, T: Iterator<A>> Iterator<B> for Map<'a, A, B, T> {\n }\n \n #[unstable = \"trait is unstable\"]\n-impl<'a, A, B, T: DoubleEndedIterator<A>> DoubleEndedIterator<B> for Map<'a, A, B, T> {\n+impl<A, B, I, F> DoubleEndedIterator<B> for Map<A, B, I, F> where\n+    I: DoubleEndedIterator<A>,\n+    F: FnMut(A) -> B,\n+{\n     #[inline]\n     fn next_back(&mut self) -> Option<B> {\n         let next = self.iter.next_back();\n@@ -1413,7 +1425,10 @@ impl<'a, A, B, T: DoubleEndedIterator<A>> DoubleEndedIterator<B> for Map<'a, A,\n }\n \n #[experimental = \"trait is experimental\"]\n-impl<'a, A, B, T: RandomAccessIterator<A>> RandomAccessIterator<B> for Map<'a, A, B, T> {\n+impl<A, B, I, F> RandomAccessIterator<B> for Map<A, B, I, F> where\n+    I: RandomAccessIterator<A>,\n+    F: FnMut(A) -> B,\n+{\n     #[inline]\n     fn indexable(&self) -> uint {\n         self.iter.indexable()\n@@ -1429,13 +1444,13 @@ impl<'a, A, B, T: RandomAccessIterator<A>> RandomAccessIterator<B> for Map<'a, A\n /// An iterator which filters the elements of `iter` with `predicate`\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n #[stable]\n-pub struct Filter<'a, A, T> {\n-    iter: T,\n-    predicate: |&A|: 'a -> bool\n+pub struct Filter<A, I, P> where I: Iterator<A>, P: FnMut(&A) -> bool {\n+    iter: I,\n+    predicate: P,\n }\n \n #[unstable = \"trait is unstable\"]\n-impl<'a, A, T: Iterator<A>> Iterator<A> for Filter<'a, A, T> {\n+impl<A, I, P> Iterator<A> for Filter<A, I, P> where I: Iterator<A>, P: FnMut(&A) -> bool {\n     #[inline]\n     fn next(&mut self) -> Option<A> {\n         for x in self.iter {\n@@ -1456,7 +1471,10 @@ impl<'a, A, T: Iterator<A>> Iterator<A> for Filter<'a, A, T> {\n }\n \n #[unstable = \"trait is unstable\"]\n-impl<'a, A, T: DoubleEndedIterator<A>> DoubleEndedIterator<A> for Filter<'a, A, T> {\n+impl<A, I, P> DoubleEndedIterator<A> for Filter<A, I, P> where\n+    I: DoubleEndedIterator<A>,\n+    P: FnMut(&A) -> bool,\n+{\n     #[inline]\n     fn next_back(&mut self) -> Option<A> {\n         for x in self.iter.by_ref().rev() {\n@@ -1471,13 +1489,16 @@ impl<'a, A, T: DoubleEndedIterator<A>> DoubleEndedIterator<A> for Filter<'a, A,\n /// An iterator which uses `f` to both filter and map elements from `iter`\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n #[stable]\n-pub struct FilterMap<'a, A, B, T> {\n-    iter: T,\n-    f: |A|: 'a -> Option<B>\n+pub struct FilterMap<A, B, I, F> where I: Iterator<A>, F: FnMut(A) -> Option<B> {\n+    iter: I,\n+    f: F,\n }\n \n #[unstable = \"trait is unstable\"]\n-impl<'a, A, B, T: Iterator<A>> Iterator<B> for FilterMap<'a, A, B, T> {\n+impl<A, B, I, F> Iterator<B> for FilterMap<A, B, I, F> where\n+    I: Iterator<A>,\n+    F: FnMut(A) -> Option<B>,\n+{\n     #[inline]\n     fn next(&mut self) -> Option<B> {\n         for x in self.iter {\n@@ -1497,8 +1518,10 @@ impl<'a, A, B, T: Iterator<A>> Iterator<B> for FilterMap<'a, A, B, T> {\n }\n \n #[unstable = \"trait is unstable\"]\n-impl<'a, A, B, T: DoubleEndedIterator<A>> DoubleEndedIterator<B>\n-for FilterMap<'a, A, B, T> {\n+impl<A, B, I, F> DoubleEndedIterator<B> for FilterMap<A, B, I, F> where\n+    I: DoubleEndedIterator<A>,\n+    F: FnMut(A) -> Option<B>,\n+{\n     #[inline]\n     fn next_back(&mut self) -> Option<B> {\n         for x in self.iter.by_ref().rev() {\n@@ -1628,14 +1651,14 @@ impl<'a, A, T: Iterator<A>> Peekable<A, T> {\n /// An iterator which rejects elements while `predicate` is true\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n #[stable]\n-pub struct SkipWhile<'a, A, T> {\n-    iter: T,\n+pub struct SkipWhile<A, I, P> where I: Iterator<A>, P: FnMut(&A) -> bool {\n+    iter: I,\n     flag: bool,\n-    predicate: |&A|: 'a -> bool\n+    predicate: P,\n }\n \n #[unstable = \"trait is unstable\"]\n-impl<'a, A, T: Iterator<A>> Iterator<A> for SkipWhile<'a, A, T> {\n+impl<A, I, P> Iterator<A> for SkipWhile<A, I, P> where I: Iterator<A>, P: FnMut(&A) -> bool {\n     #[inline]\n     fn next(&mut self) -> Option<A> {\n         for x in self.iter {\n@@ -1657,14 +1680,14 @@ impl<'a, A, T: Iterator<A>> Iterator<A> for SkipWhile<'a, A, T> {\n /// An iterator which only accepts elements while `predicate` is true\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n #[stable]\n-pub struct TakeWhile<'a, A, T> {\n-    iter: T,\n+pub struct TakeWhile<A, I, P> where I: Iterator<A>, P: FnMut(&A) -> bool {\n+    iter: I,\n     flag: bool,\n-    predicate: |&A|: 'a -> bool\n+    predicate: P,\n }\n \n #[unstable = \"trait is unstable\"]\n-impl<'a, A, T: Iterator<A>> Iterator<A> for TakeWhile<'a, A, T> {\n+impl<A, I, P> Iterator<A> for TakeWhile<A, I, P> where I: Iterator<A>, P: FnMut(&A) -> bool {\n     #[inline]\n     fn next(&mut self) -> Option<A> {\n         if self.flag {\n@@ -1816,16 +1839,19 @@ impl<A, T: RandomAccessIterator<A>> RandomAccessIterator<A> for Take<T> {\n /// An iterator to maintain state while iterating another iterator\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n #[unstable = \"waiting for unboxed closures\"]\n-pub struct Scan<'a, A, B, T, St> {\n-    iter: T,\n-    f: |&mut St, A|: 'a -> Option<B>,\n+pub struct Scan<A, B, I, St, F> where I: Iterator<A>, F: FnMut(&mut St, A) -> Option<B> {\n+    iter: I,\n+    f: F,\n \n     /// The current internal state to be passed to the closure next.\n     pub state: St,\n }\n \n #[unstable = \"trait is unstable\"]\n-impl<'a, A, B, T: Iterator<A>, St> Iterator<B> for Scan<'a, A, B, T, St> {\n+impl<A, B, I, St, F> Iterator<B> for Scan<A, B, I, St, F> where\n+    I: Iterator<A>,\n+    F: FnMut(&mut St, A) -> Option<B>,\n+{\n     #[inline]\n     fn next(&mut self) -> Option<B> {\n         self.iter.next().and_then(|a| (self.f)(&mut self.state, a))\n@@ -1843,15 +1869,19 @@ impl<'a, A, B, T: Iterator<A>, St> Iterator<B> for Scan<'a, A, B, T, St> {\n ///\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n #[unstable = \"waiting for unboxed closures\"]\n-pub struct FlatMap<'a, A, T, U> {\n-    iter: T,\n-    f: |A|: 'a -> U,\n+pub struct FlatMap<A, B, I, U, F> where I: Iterator<A>, U: Iterator<B>, F: FnMut(A) -> U {\n+    iter: I,\n+    f: F,\n     frontiter: Option<U>,\n     backiter: Option<U>,\n }\n \n #[unstable = \"trait is unstable\"]\n-impl<'a, A, T: Iterator<A>, B, U: Iterator<B>> Iterator<B> for FlatMap<'a, A, T, U> {\n+impl<A, B, I, U, F> Iterator<B> for FlatMap<A, B, I, U, F> where\n+    I: Iterator<A>,\n+    U: Iterator<B>,\n+    F: FnMut(A) -> U,\n+{\n     #[inline]\n     fn next(&mut self) -> Option<B> {\n         loop {\n@@ -1880,10 +1910,11 @@ impl<'a, A, T: Iterator<A>, B, U: Iterator<B>> Iterator<B> for FlatMap<'a, A, T,\n }\n \n #[unstable = \"trait is unstable\"]\n-impl<'a,\n-     A, T: DoubleEndedIterator<A>,\n-     B, U: DoubleEndedIterator<B>> DoubleEndedIterator<B>\n-     for FlatMap<'a, A, T, U> {\n+impl<A, B, I, U, F> DoubleEndedIterator<B> for FlatMap<A, B, I, U, F> where\n+    I: DoubleEndedIterator<A>,\n+    U: DoubleEndedIterator<B>,\n+    F: FnMut(A) -> U,\n+{\n     #[inline]\n     fn next_back(&mut self) -> Option<B> {\n         loop {\n@@ -1984,12 +2015,12 @@ impl<T> Fuse<T> {\n /// element before yielding it.\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n #[unstable = \"waiting for unboxed closures\"]\n-pub struct Inspect<'a, A, T> {\n-    iter: T,\n-    f: |&A|: 'a\n+pub struct Inspect<A, I, F> where I: Iterator<A>, F: FnMut(&A) {\n+    iter: I,\n+    f: F,\n }\n \n-impl<'a, A, T> Inspect<'a, A, T> {\n+impl<A, I, F> Inspect<A, I, F> where I: Iterator<A>, F: FnMut(&A) {\n     #[inline]\n     fn do_inspect(&mut self, elt: Option<A>) -> Option<A> {\n         match elt {\n@@ -2002,7 +2033,7 @@ impl<'a, A, T> Inspect<'a, A, T> {\n }\n \n #[unstable = \"trait is unstable\"]\n-impl<'a, A, T: Iterator<A>> Iterator<A> for Inspect<'a, A, T> {\n+impl<A, I, F> Iterator<A> for Inspect<A, I, F> where I: Iterator<A>, F: FnMut(&A) {\n     #[inline]\n     fn next(&mut self) -> Option<A> {\n         let next = self.iter.next();\n@@ -2016,8 +2047,10 @@ impl<'a, A, T: Iterator<A>> Iterator<A> for Inspect<'a, A, T> {\n }\n \n #[unstable = \"trait is unstable\"]\n-impl<'a, A, T: DoubleEndedIterator<A>> DoubleEndedIterator<A>\n-for Inspect<'a, A, T> {\n+impl<A, I, F> DoubleEndedIterator<A> for Inspect<A, I, F> where\n+    I: DoubleEndedIterator<A>,\n+    F: FnMut(&A),\n+{\n     #[inline]\n     fn next_back(&mut self) -> Option<A> {\n         let next = self.iter.next_back();\n@@ -2026,8 +2059,10 @@ for Inspect<'a, A, T> {\n }\n \n #[experimental = \"trait is experimental\"]\n-impl<'a, A, T: RandomAccessIterator<A>> RandomAccessIterator<A>\n-for Inspect<'a, A, T> {\n+impl<A, I, F> RandomAccessIterator<A> for Inspect<A, I, F> where\n+    I: RandomAccessIterator<A>,\n+    F: FnMut(&A),\n+{\n     #[inline]\n     fn indexable(&self) -> uint {\n         self.iter.indexable()\n@@ -2073,19 +2108,18 @@ for Inspect<'a, A, T> {\n /// }\n /// ```\n #[experimental]\n-pub struct Unfold<'a, A, St> {\n-    f: |&mut St|: 'a -> Option<A>,\n+pub struct Unfold<A, St, F> where F: FnMut(&mut St) -> Option<A> {\n+    f: F,\n     /// Internal state that will be passed to the closure on the next iteration\n     pub state: St,\n }\n \n #[experimental]\n-impl<'a, A, St> Unfold<'a, A, St> {\n+impl<A, St, F> Unfold<A, St, F> where F: FnMut(&mut St) -> Option<A> {\n     /// Creates a new iterator with the specified closure as the \"iterator\n     /// function\" and an initial state to eventually pass to the closure\n     #[inline]\n-    pub fn new<'a>(initial_state: St, f: |&mut St|: 'a -> Option<A>)\n-               -> Unfold<'a, A, St> {\n+    pub fn new(initial_state: St, f: F) -> Unfold<A, St, F> {\n         Unfold {\n             f: f,\n             state: initial_state\n@@ -2094,7 +2128,7 @@ impl<'a, A, St> Unfold<'a, A, St> {\n }\n \n #[experimental]\n-impl<'a, A, St> Iterator<A> for Unfold<'a, A, St> {\n+impl<A, St, F> Iterator<A> for Unfold<A, St, F> where F: FnMut(&mut St) -> Option<A> {\n     #[inline]\n     fn next(&mut self) -> Option<A> {\n         (self.f)(&mut self.state)\n@@ -2421,18 +2455,24 @@ impl<A: Clone> RandomAccessIterator<A> for Repeat<A> {\n     fn idx(&mut self, _: uint) -> Option<A> { Some(self.element.clone()) }\n }\n \n-type IterateState<'a, T> = (|T|: 'a -> T, Option<T>, bool);\n+type IterateState<T, F> = (F, Option<T>, bool);\n \n /// An iterator that repeatedly applies a given function, starting\n /// from a given seed value.\n #[experimental]\n-pub type Iterate<'a, T> = Unfold<'a, T, IterateState<'a, T>>;\n+pub type Iterate<T, F> = Unfold<T, IterateState<T, F>, fn(&mut IterateState<T, F>) -> Option<T>>;\n \n /// Create a new iterator that produces an infinite sequence of\n /// repeated applications of the given function `f`.\n #[experimental]\n-pub fn iterate<'a, T: Clone>(seed: T, f: |T|: 'a -> T) -> Iterate<'a, T> {\n-    Unfold::new((f, Some(seed), true), |st| {\n+pub fn iterate<T, F>(seed: T, f: F) -> Iterate<T, F> where\n+    T: Clone,\n+    F: FnMut(T) -> T,\n+{\n+    fn next<T, F>(st: &mut IterateState<T, F>) -> Option<T> where\n+        T: Clone,\n+        F: FnMut(T) -> T,\n+    {\n         let &(ref mut f, ref mut val, ref mut first) = st;\n         if *first {\n             *first = false;\n@@ -2445,7 +2485,9 @@ pub fn iterate<'a, T: Clone>(seed: T, f: |T|: 'a -> T) -> Iterate<'a, T> {\n             }\n         }\n         val.clone()\n-    })\n+    }\n+\n+    Unfold::new((f, Some(seed), true), next)\n }\n \n /// Create a new iterator that endlessly repeats the element `elt`."}, {"sha": "7be47f73e9ee7feef36c4ffee572de7a7fd9cc9b", "filename": "src/libcore/option.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -156,7 +156,7 @@ use result::Result::{Ok, Err};\n use slice;\n use slice::AsSlice;\n use clone::Clone;\n-use ops::Deref;\n+use ops::{Deref, FnOnce};\n \n // Note that this is not a lang item per se, but it has a hidden dependency on\n // `Iterator`, which is one. The compiler assumes that the `next` method of\n@@ -389,7 +389,7 @@ impl<T> Option<T> {\n     /// ```\n     #[inline]\n     #[unstable = \"waiting for conventions\"]\n-    pub fn unwrap_or_else(self, f: || -> T) -> T {\n+    pub fn unwrap_or_else<F: FnOnce() -> T>(self, f: F) -> T {\n         match self {\n             Some(x) => x,\n             None => f()\n@@ -413,7 +413,7 @@ impl<T> Option<T> {\n     /// ```\n     #[inline]\n     #[unstable = \"waiting for unboxed closures\"]\n-    pub fn map<U>(self, f: |T| -> U) -> Option<U> {\n+    pub fn map<U, F: FnOnce(T) -> U>(self, f: F) -> Option<U> {\n         match self {\n             Some(x) => Some(f(x)),\n             None => None\n@@ -433,7 +433,7 @@ impl<T> Option<T> {\n     /// ```\n     #[inline]\n     #[unstable = \"waiting for unboxed closures\"]\n-    pub fn map_or<U>(self, def: U, f: |T| -> U) -> U {\n+    pub fn map_or<U, F: FnOnce(T) -> U>(self, def: U, f: F) -> U {\n         match self {\n             Some(t) => f(t),\n             None => def\n@@ -455,7 +455,7 @@ impl<T> Option<T> {\n     /// ```\n     #[inline]\n     #[unstable = \"waiting for unboxed closures\"]\n-    pub fn map_or_else<U>(self, def: || -> U, f: |T| -> U) -> U {\n+    pub fn map_or_else<U, D: FnOnce() -> U, F: FnOnce(T) -> U>(self, def: D, f: F) -> U {\n         match self {\n             Some(t) => f(t),\n             None => def()\n@@ -497,7 +497,7 @@ impl<T> Option<T> {\n     /// ```\n     #[inline]\n     #[experimental]\n-    pub fn ok_or_else<E>(self, err: || -> E) -> Result<T, E> {\n+    pub fn ok_or_else<E, F: FnOnce() -> E>(self, err: F) -> Result<T, E> {\n         match self {\n             Some(v) => Ok(v),\n             None => Err(err()),\n@@ -615,7 +615,7 @@ impl<T> Option<T> {\n     /// ```\n     #[inline]\n     #[unstable = \"waiting for unboxed closures\"]\n-    pub fn and_then<U>(self, f: |T| -> Option<U>) -> Option<U> {\n+    pub fn and_then<U, F: FnOnce(T) -> Option<U>>(self, f: F) -> Option<U> {\n         match self {\n             Some(x) => f(x),\n             None => None,\n@@ -667,7 +667,7 @@ impl<T> Option<T> {\n     /// ```\n     #[inline]\n     #[unstable = \"waiting for unboxed closures\"]\n-    pub fn or_else(self, f: || -> Option<T>) -> Option<T> {\n+    pub fn or_else<F: FnOnce() -> Option<T>>(self, f: F) -> Option<T> {\n         match self {\n             Some(_) => self,\n             None => f()"}, {"sha": "88d33a59b38bd1852b05024619f83687e285f923", "filename": "src/libcore/result.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -239,6 +239,7 @@ use slice::AsSlice;\n use iter::{Iterator, IteratorExt, DoubleEndedIterator, FromIterator, ExactSizeIterator};\n use option::Option;\n use option::Option::{None, Some};\n+use ops::{FnMut, FnOnce};\n \n /// `Result` is a type that represents either success (`Ok`) or failure (`Err`).\n ///\n@@ -466,7 +467,7 @@ impl<T, E> Result<T, E> {\n     /// ```\n     #[inline]\n     #[unstable = \"waiting for unboxed closures\"]\n-    pub fn map<U>(self, op: |T| -> U) -> Result<U,E> {\n+    pub fn map<U, F: FnOnce(T) -> U>(self, op: F) -> Result<U,E> {\n         match self {\n           Ok(t) => Ok(op(t)),\n           Err(e) => Err(e)\n@@ -492,7 +493,7 @@ impl<T, E> Result<T, E> {\n     /// ```\n     #[inline]\n     #[unstable = \"waiting for unboxed closures\"]\n-    pub fn map_err<F>(self, op: |E| -> F) -> Result<T,F> {\n+    pub fn map_err<F, O: FnOnce(E) -> F>(self, op: O) -> Result<T,F> {\n         match self {\n           Ok(t) => Ok(t),\n           Err(e) => Err(op(e))\n@@ -612,7 +613,7 @@ impl<T, E> Result<T, E> {\n     /// ```\n     #[inline]\n     #[unstable = \"waiting for unboxed closures\"]\n-    pub fn and_then<U>(self, op: |T| -> Result<U, E>) -> Result<U, E> {\n+    pub fn and_then<U, F: FnOnce(T) -> Result<U, E>>(self, op: F) -> Result<U, E> {\n         match self {\n             Ok(t) => op(t),\n             Err(e) => Err(e),\n@@ -666,7 +667,7 @@ impl<T, E> Result<T, E> {\n     /// ```\n     #[inline]\n     #[unstable = \"waiting for unboxed closures\"]\n-    pub fn or_else<F>(self, op: |E| -> Result<T, F>) -> Result<T, F> {\n+    pub fn or_else<F, O: FnOnce(E) -> Result<T, F>>(self, op: O) -> Result<T, F> {\n         match self {\n             Ok(t) => Ok(t),\n             Err(e) => op(e),\n@@ -708,7 +709,7 @@ impl<T, E> Result<T, E> {\n     /// ```\n     #[inline]\n     #[unstable = \"waiting for conventions\"]\n-    pub fn unwrap_or_else(self, op: |E| -> T) -> T {\n+    pub fn unwrap_or_else<F: FnOnce(E) -> T>(self, op: F) -> T {\n         match self {\n             Ok(t) => t,\n             Err(e) => op(e)\n@@ -904,10 +905,11 @@ impl<A, E, V: FromIterator<A>> FromIterator<Result<A, E>> for Result<V, E> {\n pub fn fold<T,\n             V,\n             E,\n+            F: FnMut(V, T) -> V,\n             Iter: Iterator<Result<T, E>>>(\n             mut iterator: Iter,\n             mut init: V,\n-            f: |V, T| -> V)\n+            mut f: F)\n             -> Result<V, E> {\n     for t in iterator {\n         match t {"}, {"sha": "27a4328ba8017fe82e370a0d92c1162e64b36532", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 48, "deletions": 33, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -43,7 +43,7 @@ use default::Default;\n use iter::*;\n use kinds::Copy;\n use num::Int;\n-use ops;\n+use ops::{FnMut, mod};\n use option::Option;\n use option::Option::{None, Some};\n use ptr;\n@@ -105,20 +105,23 @@ pub trait SlicePrelude<T> for Sized? {\n     /// Returns an iterator over subslices separated by elements that match\n     /// `pred`.  The matched element is not contained in the subslices.\n     #[unstable = \"iterator type may change, waiting on unboxed closures\"]\n-    fn split<'a>(&'a self, pred: |&T|: 'a -> bool) -> Splits<'a, T>;\n+    fn split<'a, P>(&'a self, pred: P) -> Splits<'a, T, P> where\n+        P: FnMut(&T) -> bool;\n \n     /// Returns an iterator over subslices separated by elements that match\n     /// `pred`, limited to splitting at most `n` times.  The matched element is\n     /// not contained in the subslices.\n     #[unstable = \"iterator type may change\"]\n-    fn splitn<'a>(&'a self, n: uint, pred: |&T|: 'a -> bool) -> SplitsN<Splits<'a, T>>;\n+    fn splitn<'a, P>(&'a self, n: uint, pred: P) -> SplitsN<Splits<'a, T, P>> where\n+        P: FnMut(&T) -> bool;\n \n     /// Returns an iterator over subslices separated by elements that match\n     /// `pred` limited to splitting at most `n` times. This starts at the end of\n     /// the slice and works backwards.  The matched element is not contained in\n     /// the subslices.\n     #[unstable = \"iterator type may change\"]\n-    fn rsplitn<'a>(&'a self,  n: uint, pred: |&T|: 'a -> bool) -> SplitsN<Splits<'a, T>>;\n+    fn rsplitn<'a, P>(&'a self,  n: uint, pred: P) -> SplitsN<Splits<'a, T, P>> where\n+        P: FnMut(&T) -> bool;\n \n     /// Returns an iterator over all contiguous windows of length\n     /// `size`. The windows overlap. If the slice is shorter than\n@@ -235,7 +238,7 @@ pub trait SlicePrelude<T> for Sized? {\n     /// assert!(match r { Found(1...4) => true, _ => false, });\n     /// ```\n     #[unstable = \"waiting on unboxed closures\"]\n-    fn binary_search(&self, f: |&T| -> Ordering) -> BinarySearchResult;\n+    fn binary_search<F>(&self, f: F) -> BinarySearchResult where F: FnMut(&T) -> Ordering;\n \n     /// Return the number of elements in the slice\n     ///\n@@ -316,20 +319,23 @@ pub trait SlicePrelude<T> for Sized? {\n     /// Returns an iterator over mutable subslices separated by elements that\n     /// match `pred`.  The matched element is not contained in the subslices.\n     #[unstable = \"waiting on unboxed closures, iterator type name conventions\"]\n-    fn split_mut<'a>(&'a mut self, pred: |&T|: 'a -> bool) -> MutSplits<'a, T>;\n+    fn split_mut<'a, P>(&'a mut self, pred: P) -> MutSplits<'a, T, P> where\n+        P: FnMut(&T) -> bool;\n \n     /// Returns an iterator over subslices separated by elements that match\n     /// `pred`, limited to splitting at most `n` times.  The matched element is\n     /// not contained in the subslices.\n     #[unstable = \"waiting on unboxed closures, iterator type name conventions\"]\n-    fn splitn_mut<'a>(&'a mut self, n: uint, pred: |&T|: 'a -> bool) -> SplitsN<MutSplits<'a, T>>;\n+    fn splitn_mut<'a, P>(&'a mut self, n: uint, pred: P) -> SplitsN<MutSplits<'a, T, P>> where\n+        P: FnMut(&T) -> bool;\n \n     /// Returns an iterator over subslices separated by elements that match\n     /// `pred` limited to splitting at most `n` times. This starts at the end of\n     /// the slice and works backwards.  The matched element is not contained in\n     /// the subslices.\n     #[unstable = \"waiting on unboxed closures, iterator type name conventions\"]\n-    fn rsplitn_mut<'a>(&'a mut self,  n: uint, pred: |&T|: 'a -> bool) -> SplitsN<MutSplits<'a, T>>;\n+    fn rsplitn_mut<'a, P>(&'a mut self,  n: uint, pred: P) -> SplitsN<MutSplits<'a, T, P>> where\n+        P: FnMut(&T) -> bool;\n \n     /// Returns an iterator over `chunk_size` elements of the slice at a time.\n     /// The chunks are mutable and do not overlap. If `chunk_size` does\n@@ -470,7 +476,7 @@ impl<T> SlicePrelude<T> for [T] {\n     }\n \n     #[inline]\n-    fn split<'a>(&'a self, pred: |&T|: 'a -> bool) -> Splits<'a, T> {\n+    fn split<'a, P>(&'a self, pred: P) -> Splits<'a, T, P> where P: FnMut(&T) -> bool {\n         Splits {\n             v: self,\n             pred: pred,\n@@ -479,7 +485,9 @@ impl<T> SlicePrelude<T> for [T] {\n     }\n \n     #[inline]\n-    fn splitn<'a>(&'a self, n: uint, pred: |&T|: 'a -> bool) -> SplitsN<Splits<'a, T>> {\n+    fn splitn<'a, P>(&'a self, n: uint, pred: P) -> SplitsN<Splits<'a, T, P>> where\n+        P: FnMut(&T) -> bool,\n+    {\n         SplitsN {\n             iter: self.split(pred),\n             count: n,\n@@ -488,7 +496,9 @@ impl<T> SlicePrelude<T> for [T] {\n     }\n \n     #[inline]\n-    fn rsplitn<'a>(&'a self, n: uint, pred: |&T|: 'a -> bool) -> SplitsN<Splits<'a, T>> {\n+    fn rsplitn<'a, P>(&'a self, n: uint, pred: P) -> SplitsN<Splits<'a, T, P>> where\n+        P: FnMut(&T) -> bool,\n+    {\n         SplitsN {\n             iter: self.split(pred),\n             count: n,\n@@ -542,7 +552,7 @@ impl<T> SlicePrelude<T> for [T] {\n     }\n \n     #[unstable]\n-    fn binary_search(&self, f: |&T| -> Ordering) -> BinarySearchResult {\n+    fn binary_search<F>(&self, mut f: F) -> BinarySearchResult where F: FnMut(&T) -> Ordering {\n         let mut base : uint = 0;\n         let mut lim : uint = self.len();\n \n@@ -637,12 +647,14 @@ impl<T> SlicePrelude<T> for [T] {\n     }\n \n     #[inline]\n-    fn split_mut<'a>(&'a mut self, pred: |&T|: 'a -> bool) -> MutSplits<'a, T> {\n+    fn split_mut<'a, P>(&'a mut self, pred: P) -> MutSplits<'a, T, P> where P: FnMut(&T) -> bool {\n         MutSplits { v: self, pred: pred, finished: false }\n     }\n \n     #[inline]\n-    fn splitn_mut<'a>(&'a mut self, n: uint, pred: |&T|: 'a -> bool) -> SplitsN<MutSplits<'a, T>> {\n+    fn splitn_mut<'a, P>(&'a mut self, n: uint, pred: P) -> SplitsN<MutSplits<'a, T, P>> where\n+        P: FnMut(&T) -> bool\n+    {\n         SplitsN {\n             iter: self.split_mut(pred),\n             count: n,\n@@ -651,7 +663,9 @@ impl<T> SlicePrelude<T> for [T] {\n     }\n \n     #[inline]\n-    fn rsplitn_mut<'a>(&'a mut self, n: uint, pred: |&T|: 'a -> bool) -> SplitsN<MutSplits<'a, T>> {\n+    fn rsplitn_mut<'a, P>(&'a mut self, n: uint, pred: P) -> SplitsN<MutSplits<'a, T, P>> where\n+        P: FnMut(&T) -> bool,\n+    {\n         SplitsN {\n             iter: self.split_mut(pred),\n             count: n,\n@@ -1271,14 +1285,14 @@ trait SplitsIter<E>: DoubleEndedIterator<E> {\n /// An iterator over subslices separated by elements that match a predicate\n /// function.\n #[experimental = \"needs review\"]\n-pub struct Splits<'a, T:'a> {\n+pub struct Splits<'a, T:'a, P> where P: FnMut(&T) -> bool {\n     v: &'a [T],\n-    pred: |t: &T|: 'a -> bool,\n+    pred: P,\n     finished: bool\n }\n \n #[experimental = \"needs review\"]\n-impl<'a, T> Iterator<&'a [T]> for Splits<'a, T> {\n+impl<'a, T, P> Iterator<&'a [T]> for Splits<'a, T, P> where P: FnMut(&T) -> bool {\n     #[inline]\n     fn next(&mut self) -> Option<&'a [T]> {\n         if self.finished { return None; }\n@@ -1304,7 +1318,7 @@ impl<'a, T> Iterator<&'a [T]> for Splits<'a, T> {\n }\n \n #[experimental = \"needs review\"]\n-impl<'a, T> DoubleEndedIterator<&'a [T]> for Splits<'a, T> {\n+impl<'a, T, P> DoubleEndedIterator<&'a [T]> for Splits<'a, T, P> where P: FnMut(&T) -> bool {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a [T]> {\n         if self.finished { return None; }\n@@ -1320,7 +1334,7 @@ impl<'a, T> DoubleEndedIterator<&'a [T]> for Splits<'a, T> {\n     }\n }\n \n-impl<'a, T> SplitsIter<&'a [T]> for Splits<'a, T> {\n+impl<'a, T, P> SplitsIter<&'a [T]> for Splits<'a, T, P> where P: FnMut(&T) -> bool {\n     #[inline]\n     fn finish(&mut self) -> Option<&'a [T]> {\n         if self.finished { None } else { self.finished = true; Some(self.v) }\n@@ -1330,13 +1344,13 @@ impl<'a, T> SplitsIter<&'a [T]> for Splits<'a, T> {\n /// An iterator over the subslices of the vector which are separated\n /// by elements that match `pred`.\n #[experimental = \"needs review\"]\n-pub struct MutSplits<'a, T:'a> {\n+pub struct MutSplits<'a, T:'a, P> where P: FnMut(&T) -> bool {\n     v: &'a mut [T],\n-    pred: |t: &T|: 'a -> bool,\n+    pred: P,\n     finished: bool\n }\n \n-impl<'a, T> SplitsIter<&'a mut [T]> for MutSplits<'a, T> {\n+impl<'a, T, P> SplitsIter<&'a mut [T]> for MutSplits<'a, T, P> where P: FnMut(&T) -> bool {\n     #[inline]\n     fn finish(&mut self) -> Option<&'a mut [T]> {\n         if self.finished {\n@@ -1349,7 +1363,7 @@ impl<'a, T> SplitsIter<&'a mut [T]> for MutSplits<'a, T> {\n }\n \n #[experimental = \"needs review\"]\n-impl<'a, T> Iterator<&'a mut [T]> for MutSplits<'a, T> {\n+impl<'a, T, P> Iterator<&'a mut [T]> for MutSplits<'a, T, P> where P: FnMut(&T) -> bool {\n     #[inline]\n     fn next(&mut self) -> Option<&'a mut [T]> {\n         if self.finished { return None; }\n@@ -1382,7 +1396,9 @@ impl<'a, T> Iterator<&'a mut [T]> for MutSplits<'a, T> {\n }\n \n #[experimental = \"needs review\"]\n-impl<'a, T> DoubleEndedIterator<&'a mut [T]> for MutSplits<'a, T> {\n+impl<'a, T, P> DoubleEndedIterator<&'a mut [T]> for MutSplits<'a, T, P> where\n+    P: FnMut(&T) -> bool,\n+{\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a mut [T]> {\n         if self.finished { return None; }\n@@ -1709,15 +1725,17 @@ pub mod raw {\n     use mem::transmute;\n     use ptr::RawPtr;\n     use raw::Slice;\n+    use ops::FnOnce;\n     use option::Option;\n     use option::Option::{None, Some};\n \n     /// Form a slice from a pointer and length (as a number of units,\n     /// not bytes).\n     #[inline]\n     #[deprecated = \"renamed to slice::from_raw_buf\"]\n-    pub unsafe fn buf_as_slice<T,U>(p: *const T, len: uint, f: |v: &[T]| -> U)\n-                               -> U {\n+    pub unsafe fn buf_as_slice<T, U, F>(p: *const T, len: uint, f: F) -> U where\n+        F: FnOnce(&[T]) -> U,\n+    {\n         f(transmute(Slice {\n             data: p,\n             len: len\n@@ -1728,12 +1746,9 @@ pub mod raw {\n     /// not bytes).\n     #[inline]\n     #[deprecated = \"renamed to slice::from_raw_mut_buf\"]\n-    pub unsafe fn mut_buf_as_slice<T,\n-                                   U>(\n-                                   p: *mut T,\n-                                   len: uint,\n-                                   f: |v: &mut [T]| -> U)\n-                                   -> U {\n+    pub unsafe fn mut_buf_as_slice<T, U, F>(p: *mut T, len: uint, f: F) -> U where\n+        F: FnOnce(&mut [T]) -> U,\n+    {\n         f(transmute(Slice {\n             data: p as *const T,\n             len: len"}, {"sha": "92f82bd97711489367ac099f4203e65765a070b0", "filename": "src/libcore/str.rs", "status": "modified", "additions": 60, "deletions": 29, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -31,6 +31,7 @@ use mem;\n use num::Int;\n use option::Option;\n use option::Option::{None, Some};\n+use ops::FnMut;\n use ptr::RawPtr;\n use raw::{Repr, Slice};\n use slice::{mod, SlicePrelude};\n@@ -136,15 +137,7 @@ impl CharEq for char {\n     fn only_ascii(&self) -> bool { (*self as uint) < 128 }\n }\n \n-impl<'a> CharEq for |char|: 'a -> bool {\n-    #[inline]\n-    fn matches(&mut self, c: char) -> bool { (*self)(c) }\n-\n-    #[inline]\n-    fn only_ascii(&self) -> bool { false }\n-}\n-\n-impl CharEq for extern \"Rust\" fn(char) -> bool {\n+impl<F> CharEq for F where F: FnMut(char) -> bool {\n     #[inline]\n     fn matches(&mut self, c: char) -> bool { (*self)(c) }\n \n@@ -323,8 +316,7 @@ impl<'a> DoubleEndedIterator<(uint, char)> for CharOffsets<'a> {\n \n /// External iterator for a string's bytes.\n /// Use with the `std::iter` module.\n-pub type Bytes<'a> =\n-    Map<'a, &'a u8, u8, slice::Items<'a, u8>>;\n+pub type Bytes<'a> = Map<&'a u8, u8, slice::Items<'a, u8>, fn(&u8) -> u8>;\n \n /// An iterator over the substrings of a string, separated by `sep`.\n #[deriving(Clone)]\n@@ -349,8 +341,7 @@ pub struct CharSplitsN<'a, Sep> {\n }\n \n /// An iterator over the lines of a string, separated by either `\\n` or (`\\r\\n`).\n-pub type AnyLines<'a> =\n-    Map<'a, &'a str, &'a str, CharSplits<'a, char>>;\n+pub type AnyLines<'a> = Map<&'a str, &'a str, CharSplits<'a, char>, fn(&str) -> &str>;\n \n impl<'a, Sep> CharSplits<'a, Sep> {\n     #[inline]\n@@ -1361,17 +1352,21 @@ pub trait StrPrelude for Sized? {\n     /// # Example\n     ///\n     /// ```rust\n+    /// # #![feature(unboxed_closures)]\n+    ///\n+    /// # fn main() {\n     /// let v: Vec<&str> = \"Mary had a little lamb\".split(' ').collect();\n     /// assert_eq!(v, vec![\"Mary\", \"had\", \"a\", \"little\", \"lamb\"]);\n     ///\n-    /// let v: Vec<&str> = \"abc1def2ghi\".split(|c: char| c.is_numeric()).collect();\n+    /// let v: Vec<&str> = \"abc1def2ghi\".split(|&: c: char| c.is_numeric()).collect();\n     /// assert_eq!(v, vec![\"abc\", \"def\", \"ghi\"]);\n     ///\n     /// let v: Vec<&str> = \"lionXXtigerXleopard\".split('X').collect();\n     /// assert_eq!(v, vec![\"lion\", \"\", \"tiger\", \"leopard\"]);\n     ///\n     /// let v: Vec<&str> = \"\".split('X').collect();\n     /// assert_eq!(v, vec![\"\"]);\n+    /// # }\n     /// ```\n     fn split<'a, Sep: CharEq>(&'a self, sep: Sep) -> CharSplits<'a, Sep>;\n \n@@ -1382,10 +1377,13 @@ pub trait StrPrelude for Sized? {\n     /// # Example\n     ///\n     /// ```rust\n+    /// # #![feature(unboxed_closures)]\n+    ///\n+    /// # fn main() {\n     /// let v: Vec<&str> = \"Mary had a little lambda\".splitn(2, ' ').collect();\n     /// assert_eq!(v, vec![\"Mary\", \"had\", \"a little lambda\"]);\n     ///\n-    /// let v: Vec<&str> = \"abc1def2ghi\".splitn(1, |c: char| c.is_numeric()).collect();\n+    /// let v: Vec<&str> = \"abc1def2ghi\".splitn(1, |&: c: char| c.is_numeric()).collect();\n     /// assert_eq!(v, vec![\"abc\", \"def2ghi\"]);\n     ///\n     /// let v: Vec<&str> = \"lionXXtigerXleopard\".splitn(2, 'X').collect();\n@@ -1396,6 +1394,7 @@ pub trait StrPrelude for Sized? {\n     ///\n     /// let v: Vec<&str> = \"\".splitn(1, 'X').collect();\n     /// assert_eq!(v, vec![\"\"]);\n+    /// # }\n     /// ```\n     fn splitn<'a, Sep: CharEq>(&'a self, count: uint, sep: Sep) -> CharSplitsN<'a, Sep>;\n \n@@ -1408,6 +1407,9 @@ pub trait StrPrelude for Sized? {\n     /// # Example\n     ///\n     /// ```rust\n+    /// # #![feature(unboxed_closures)]\n+    ///\n+    /// # fn main() {\n     /// let v: Vec<&str> = \"A.B.\".split_terminator('.').collect();\n     /// assert_eq!(v, vec![\"A\", \"B\"]);\n     ///\n@@ -1417,11 +1419,12 @@ pub trait StrPrelude for Sized? {\n     /// let v: Vec<&str> = \"Mary had a little lamb\".split(' ').rev().collect();\n     /// assert_eq!(v, vec![\"lamb\", \"little\", \"a\", \"had\", \"Mary\"]);\n     ///\n-    /// let v: Vec<&str> = \"abc1def2ghi\".split(|c: char| c.is_numeric()).rev().collect();\n+    /// let v: Vec<&str> = \"abc1def2ghi\".split(|&: c: char| c.is_numeric()).rev().collect();\n     /// assert_eq!(v, vec![\"ghi\", \"def\", \"abc\"]);\n     ///\n     /// let v: Vec<&str> = \"lionXXtigerXleopard\".split('X').rev().collect();\n     /// assert_eq!(v, vec![\"leopard\", \"tiger\", \"\", \"lion\"]);\n+    /// # }\n     /// ```\n     fn split_terminator<'a, Sep: CharEq>(&'a self, sep: Sep) -> CharSplits<'a, Sep>;\n \n@@ -1432,14 +1435,18 @@ pub trait StrPrelude for Sized? {\n     /// # Example\n     ///\n     /// ```rust\n+    /// # #![feature(unboxed_closures)]\n+    ///\n+    /// # fn main() {\n     /// let v: Vec<&str> = \"Mary had a little lamb\".rsplitn(2, ' ').collect();\n     /// assert_eq!(v, vec![\"lamb\", \"little\", \"Mary had a\"]);\n     ///\n-    /// let v: Vec<&str> = \"abc1def2ghi\".rsplitn(1, |c: char| c.is_numeric()).collect();\n+    /// let v: Vec<&str> = \"abc1def2ghi\".rsplitn(1, |&: c: char| c.is_numeric()).collect();\n     /// assert_eq!(v, vec![\"ghi\", \"abc1def\"]);\n     ///\n     /// let v: Vec<&str> = \"lionXXtigerXleopard\".rsplitn(2, 'X').collect();\n     /// assert_eq!(v, vec![\"leopard\", \"tiger\", \"lionX\"]);\n+    /// # }\n     /// ```\n     fn rsplitn<'a, Sep: CharEq>(&'a self, count: uint, sep: Sep) -> CharSplitsN<'a, Sep>;\n \n@@ -1650,10 +1657,14 @@ pub trait StrPrelude for Sized? {\n     /// # Example\n     ///\n     /// ```rust\n+    /// # #![feature(unboxed_closures)]\n+    ///\n+    /// # fn main() {\n     /// assert_eq!(\"11foo1bar11\".trim_chars('1'), \"foo1bar\")\n     /// let x: &[_] = &['1', '2'];\n     /// assert_eq!(\"12foo1bar12\".trim_chars(x), \"foo1bar\")\n-    /// assert_eq!(\"123foo1bar123\".trim_chars(|c: char| c.is_numeric()), \"foo1bar\")\n+    /// assert_eq!(\"123foo1bar123\".trim_chars(|&: c: char| c.is_numeric()), \"foo1bar\")\n+    /// # }\n     /// ```\n     fn trim_chars<'a, C: CharEq>(&'a self, to_trim: C) -> &'a str;\n \n@@ -1666,10 +1677,14 @@ pub trait StrPrelude for Sized? {\n     /// # Example\n     ///\n     /// ```rust\n+    /// # #![feature(unboxed_closures)]\n+    ///\n+    /// # fn main() {\n     /// assert_eq!(\"11foo1bar11\".trim_left_chars('1'), \"foo1bar11\")\n     /// let x: &[_] = &['1', '2'];\n     /// assert_eq!(\"12foo1bar12\".trim_left_chars(x), \"foo1bar12\")\n-    /// assert_eq!(\"123foo1bar123\".trim_left_chars(|c: char| c.is_numeric()), \"foo1bar123\")\n+    /// assert_eq!(\"123foo1bar123\".trim_left_chars(|&: c: char| c.is_numeric()), \"foo1bar123\")\n+    /// # }\n     /// ```\n     fn trim_left_chars<'a, C: CharEq>(&'a self, to_trim: C) -> &'a str;\n \n@@ -1682,10 +1697,14 @@ pub trait StrPrelude for Sized? {\n     /// # Example\n     ///\n     /// ```rust\n+    /// # #![feature(unboxed_closures)]\n+    ///\n+    /// # fn main() {\n     /// assert_eq!(\"11foo1bar11\".trim_right_chars('1'), \"11foo1bar\")\n     /// let x: &[_] = &['1', '2'];\n     /// assert_eq!(\"12foo1bar12\".trim_right_chars(x), \"12foo1bar\")\n-    /// assert_eq!(\"123foo1bar123\".trim_right_chars(|c: char| c.is_numeric()), \"123foo1bar\")\n+    /// assert_eq!(\"123foo1bar123\".trim_right_chars(|&: c: char| c.is_numeric()), \"123foo1bar\")\n+    /// # }\n     /// ```\n     fn trim_right_chars<'a, C: CharEq>(&'a self, to_trim: C) -> &'a str;\n \n@@ -1826,17 +1845,21 @@ pub trait StrPrelude for Sized? {\n     /// # Example\n     ///\n     /// ```rust\n+    /// # #![feature(unboxed_closures)]\n+    ///\n+    /// # fn main() {\n     /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n     ///\n     /// assert_eq!(s.find('L'), Some(0));\n     /// assert_eq!(s.find('\u00e9'), Some(14));\n     ///\n     /// // the first space\n-    /// assert_eq!(s.find(|c: char| c.is_whitespace()), Some(5));\n+    /// assert_eq!(s.find(|&: c: char| c.is_whitespace()), Some(5));\n     ///\n     /// // neither are found\n     /// let x: &[_] = &['1', '2'];\n     /// assert_eq!(s.find(x), None);\n+    /// # }\n     /// ```\n     fn find<C: CharEq>(&self, search: C) -> Option<uint>;\n \n@@ -1851,17 +1874,21 @@ pub trait StrPrelude for Sized? {\n     /// # Example\n     ///\n     /// ```rust\n+    /// # #![feature(unboxed_closures)]\n+    ///\n+    /// # fn main() {\n     /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n     ///\n     /// assert_eq!(s.rfind('L'), Some(13));\n     /// assert_eq!(s.rfind('\u00e9'), Some(14));\n     ///\n     /// // the second space\n-    /// assert_eq!(s.rfind(|c: char| c.is_whitespace()), Some(12));\n+    /// assert_eq!(s.rfind(|&: c: char| c.is_whitespace()), Some(12));\n     ///\n     /// // searches for an occurrence of either `1` or `2`, but neither are found\n     /// let x: &[_] = &['1', '2'];\n     /// assert_eq!(s.rfind(x), None);\n+    /// # }\n     /// ```\n     fn rfind<C: CharEq>(&self, search: C) -> Option<uint>;\n \n@@ -1980,7 +2007,9 @@ impl StrPrelude for str {\n \n     #[inline]\n     fn bytes(&self) -> Bytes {\n-        self.as_bytes().iter().map(|&b| b)\n+        fn deref(&x: &u8) -> u8 { x }\n+\n+        self.as_bytes().iter().map(deref)\n     }\n \n     #[inline]\n@@ -2053,11 +2082,13 @@ impl StrPrelude for str {\n     }\n \n     fn lines_any(&self) -> AnyLines {\n-        self.lines().map(|line| {\n+        fn f(line: &str) -> &str {\n             let l = line.len();\n             if l > 0 && line.as_bytes()[l - 1] == b'\\r' { line.slice(0, l - 1) }\n             else { line }\n-        })\n+        }\n+\n+        self.lines().map(f)\n     }\n \n     #[inline]\n@@ -2140,11 +2171,11 @@ impl StrPrelude for str {\n \n     #[inline]\n     fn trim_chars<C: CharEq>(&self, mut to_trim: C) -> &str {\n-        let cur = match self.find(|c: char| !to_trim.matches(c)) {\n+        let cur = match self.find(|&mut: c: char| !to_trim.matches(c)) {\n             None => \"\",\n             Some(i) => unsafe { self.slice_unchecked(i, self.len()) }\n         };\n-        match cur.rfind(|c: char| !to_trim.matches(c)) {\n+        match cur.rfind(|&mut: c: char| !to_trim.matches(c)) {\n             None => \"\",\n             Some(i) => {\n                 let right = cur.char_range_at(i).next;\n@@ -2155,15 +2186,15 @@ impl StrPrelude for str {\n \n     #[inline]\n     fn trim_left_chars<C: CharEq>(&self, mut to_trim: C) -> &str {\n-        match self.find(|c: char| !to_trim.matches(c)) {\n+        match self.find(|&mut: c: char| !to_trim.matches(c)) {\n             None => \"\",\n             Some(first) => unsafe { self.slice_unchecked(first, self.len()) }\n         }\n     }\n \n     #[inline]\n     fn trim_right_chars<C: CharEq>(&self, mut to_trim: C) -> &str {\n-        match self.rfind(|c: char| !to_trim.matches(c)) {\n+        match self.rfind(|&mut: c: char| !to_trim.matches(c)) {\n             None => \"\",\n             Some(last) => {\n                 let next = self.char_range_at(last).next;"}, {"sha": "2d77c1bc0978c14248bfe4732fdadb7e9696b7a7", "filename": "src/libcoretest/finally.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibcoretest%2Ffinally.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibcoretest%2Ffinally.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Ffinally.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -45,7 +45,7 @@ fn test_fail() {\n \n #[test]\n fn test_retval() {\n-    let mut closure: || -> int = || 10;\n+    let mut closure = |&mut:| 10i;\n     let i = closure.finally(|| { });\n     assert_eq!(i, 10);\n }"}, {"sha": "acc2eab60e7785488c3edbb023913ac4760b94e4", "filename": "src/libcoretest/iter.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibcoretest%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibcoretest%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fiter.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -221,7 +221,7 @@ fn test_iterator_flat_map() {\n #[test]\n fn test_inspect() {\n     let xs = [1u, 2, 3, 4];\n-    let mut n = 0;\n+    let mut n = 0u;\n \n     let ys = xs.iter()\n                .map(|&x| x)"}, {"sha": "089a2cc880eb624a79a26714d5f1406c2e3da62a", "filename": "src/libcoretest/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibcoretest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibcoretest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Flib.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n #![feature(globs, unsafe_destructor, macro_rules, slicing_syntax)]\n+#![feature(unboxed_closures)]\n \n extern crate core;\n extern crate test;"}, {"sha": "763fcccdbfdc8cbdc7d2b568368d7ebfd9fc9da7", "filename": "src/libcoretest/str.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibcoretest%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibcoretest%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fstr.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -54,7 +54,7 @@ fn test_rsplitn_char_iterator() {\n     split.reverse();\n     assert_eq!(split, vec![\"\\nM\u00e4ry h\u00e4d \u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n \n-    let mut split: Vec<&str> = data.rsplitn(3, |c: char| c == ' ').collect();\n+    let mut split: Vec<&str> = data.rsplitn(3, |&: c: char| c == ' ').collect();\n     split.reverse();\n     assert_eq!(split, vec![\"\\nM\u00e4ry h\u00e4d \u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n \n@@ -63,7 +63,7 @@ fn test_rsplitn_char_iterator() {\n     split.reverse();\n     assert_eq!(split, vec![\"\\nM\u00e4ry h\u00e4d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n \n-    let mut split: Vec<&str> = data.rsplitn(3, |c: char| c == '\u00e4').collect();\n+    let mut split: Vec<&str> = data.rsplitn(3, |&: c: char| c == '\u00e4').collect();\n     split.reverse();\n     assert_eq!(split, vec![\"\\nM\u00e4ry h\u00e4d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n }\n@@ -79,10 +79,10 @@ fn test_split_char_iterator() {\n     rsplit.reverse();\n     assert_eq!(rsplit, vec![\"\\nM\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n \n-    let split: Vec<&str> = data.split(|c: char| c == ' ').collect();\n+    let split: Vec<&str> = data.split(|&: c: char| c == ' ').collect();\n     assert_eq!( split, vec![\"\\nM\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n \n-    let mut rsplit: Vec<&str> = data.split(|c: char| c == ' ').rev().collect();\n+    let mut rsplit: Vec<&str> = data.split(|&: c: char| c == ' ').rev().collect();\n     rsplit.reverse();\n     assert_eq!(rsplit, vec![\"\\nM\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n \n@@ -94,10 +94,10 @@ fn test_split_char_iterator() {\n     rsplit.reverse();\n     assert_eq!(rsplit, vec![\"\\nM\", \"ry h\", \"d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n \n-    let split: Vec<&str> = data.split(|c: char| c == '\u00e4').collect();\n+    let split: Vec<&str> = data.split(|&: c: char| c == '\u00e4').collect();\n     assert_eq!( split, vec![\"\\nM\", \"ry h\", \"d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n \n-    let mut rsplit: Vec<&str> = data.split(|c: char| c == '\u00e4').rev().collect();\n+    let mut rsplit: Vec<&str> = data.split(|&: c: char| c == '\u00e4').rev().collect();\n     rsplit.reverse();\n     assert_eq!(rsplit, vec![\"\\nM\", \"ry h\", \"d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n }"}, {"sha": "79c435f01e4e6b71b5053a64d943bb550570fc23", "filename": "src/libgetopts/lib.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibgetopts%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibgetopts%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgetopts%2Flib.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -87,6 +87,7 @@\n        html_playground_url = \"http://play.rust-lang.org/\")]\n #![feature(globs, phase)]\n #![feature(import_shadowing)]\n+#![feature(unboxed_closures)]\n #![deny(missing_docs)]\n \n #[cfg(test)] #[phase(plugin, link)] extern crate log;\n@@ -867,8 +868,9 @@ impl Copy for LengthLimit {}\n ///\n /// Panics during iteration if the string contains a non-whitespace\n /// sequence longer than the limit.\n-fn each_split_within<'a>(ss: &'a str, lim: uint, it: |&'a str| -> bool)\n-                     -> bool {\n+fn each_split_within<F>(ss: &str, lim: uint, mut it: F) -> bool where\n+    F: FnMut(&str) -> bool\n+{\n     // Just for fun, let's write this as a state machine:\n \n     let mut slice_start = 0;"}, {"sha": "8ebb3ae365c079aecbac79f10b2d116395be8d7a", "filename": "src/libgraphviz/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibgraphviz%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibgraphviz%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Flib.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -269,6 +269,7 @@\n        html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n        html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n #![feature(globs, slicing_syntax)]\n+#![feature(unboxed_closures)]\n \n pub use self::LabelText::*;\n \n@@ -420,7 +421,7 @@ pub trait Labeller<'a,N,E> {\n }\n \n impl<'a> LabelText<'a> {\n-    fn escape_char(c: char, f: |char|) {\n+    fn escape_char<F>(c: char, mut f: F) where F: FnMut(char) {\n         match c {\n             // not escaping \\\\, since Graphviz escString needs to\n             // interpret backslashes; see EscStr above."}, {"sha": "7ebf9b633520809d9b249a3fcf1d4d59b4fea0ba", "filename": "src/libgraphviz/maybe_owned_vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibgraphviz%2Fmaybe_owned_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibgraphviz%2Fmaybe_owned_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Fmaybe_owned_vec.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -142,7 +142,7 @@ impl<'a,T:Clone> CloneSliceAllocPrelude<T> for MaybeOwnedVector<'a,T> {\n         self.as_slice().to_vec()\n     }\n \n-    fn partitioned(&self, f: |&T| -> bool) -> (Vec<T>, Vec<T>) {\n+    fn partitioned<F>(&self, f: F) -> (Vec<T>, Vec<T>) where F: FnMut(&T) -> bool {\n         self.as_slice().partitioned(f)\n     }\n "}, {"sha": "a44197c98590c74e720e45b71a19e3c9b13ebeb2", "filename": "src/librand/distributions/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrand%2Fdistributions%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrand%2Fdistributions%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Fmod.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -208,14 +208,14 @@ mod ziggurat_tables;\n // the perf improvement (25-50%) is definitely worth the extra code\n // size from force-inlining.\n #[inline(always)]\n-fn ziggurat<R:Rng>(\n+fn ziggurat<R: Rng, P, Z>(\n             rng: &mut R,\n             symmetric: bool,\n             x_tab: ziggurat_tables::ZigTable,\n             f_tab: ziggurat_tables::ZigTable,\n-            pdf: |f64|: 'static -> f64,\n-            zero_case: |&mut R, f64|: 'static -> f64)\n-            -> f64 {\n+            mut pdf: P,\n+            mut zero_case: Z)\n+            -> f64 where P: FnMut(f64) -> f64, Z: FnMut(&mut R, f64) -> f64 {\n     static SCALE: f64 = (1u64 << 53) as f64;\n     loop {\n         // reimplement the f64 generation as an optimisation suggested"}, {"sha": "4fba3707703a5f6d7ed68e3639431d61acaec32f", "filename": "src/librand/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrand%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrand%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Flib.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -24,6 +24,7 @@\n        html_playground_url = \"http://play.rust-lang.org/\")]\n \n #![feature(macro_rules, phase, globs)]\n+#![feature(unboxed_closures)]\n #![no_std]\n #![experimental]\n "}, {"sha": "28d5e1812f0902485b91062b30d7d7f61e0f435e", "filename": "src/librbml/lib.rs", "status": "modified", "additions": 151, "deletions": 131, "changes": 282, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrbml%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrbml%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrbml%2Flib.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -25,6 +25,7 @@\n        html_playground_url = \"http://play.rust-lang.org/\")]\n #![allow(unknown_features)]\n #![feature(macro_rules, phase, slicing_syntax, globs)]\n+#![feature(unboxed_closures)]\n #![allow(missing_docs)]\n \n extern crate serialize;\n@@ -259,7 +260,9 @@ pub mod reader {\n         }\n     }\n \n-    pub fn docs<'a>(d: Doc<'a>, it: |uint, Doc<'a>| -> bool) -> bool {\n+    pub fn docs<F>(d: Doc, mut it: F) -> bool where\n+        F: FnMut(uint, Doc) -> bool,\n+    {\n         let mut pos = d.start;\n         while pos < d.end {\n             let elt_tag = try_or!(vuint_at(d.data, pos), false);\n@@ -273,7 +276,9 @@ pub mod reader {\n         return true;\n     }\n \n-    pub fn tagged_docs<'a>(d: Doc<'a>, tg: uint, it: |Doc<'a>| -> bool) -> bool {\n+    pub fn tagged_docs<F>(d: Doc, tg: uint, mut it: F) -> bool where\n+        F: FnMut(Doc) -> bool,\n+    {\n         let mut pos = d.start;\n         while pos < d.end {\n             let elt_tag = try_or!(vuint_at(d.data, pos), false);\n@@ -290,7 +295,9 @@ pub mod reader {\n         return true;\n     }\n \n-    pub fn with_doc_data<'a, T>(d: Doc<'a>, f: |x: &'a [u8]| -> T) -> T {\n+    pub fn with_doc_data<T, F>(d: Doc, f: F) -> T where\n+        F: FnOnce(&[u8]) -> T,\n+    {\n         f(d.data[d.start..d.end])\n     }\n \n@@ -378,8 +385,9 @@ pub mod reader {\n             Ok(r_doc)\n         }\n \n-        fn push_doc<T>(&mut self, exp_tag: EbmlEncoderTag,\n-                       f: |&mut Decoder<'doc>| -> DecodeResult<T>) -> DecodeResult<T> {\n+        fn push_doc<T, F>(&mut self, exp_tag: EbmlEncoderTag, f: F) -> DecodeResult<T> where\n+            F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>,\n+        {\n             let d = try!(self.next_doc(exp_tag));\n             let old_parent = self.parent;\n             let old_pos = self.pos;\n@@ -397,8 +405,9 @@ pub mod reader {\n             Ok(r as uint)\n         }\n \n-        pub fn read_opaque<R>(&mut self,\n-                              op: |&mut Decoder<'doc>, Doc| -> DecodeResult<R>) -> DecodeResult<R> {\n+        pub fn read_opaque<R, F>(&mut self, op: F) -> DecodeResult<R> where\n+            F: FnOnce(&mut Decoder, Doc) -> DecodeResult<R>,\n+        {\n             let doc = try!(self.next_doc(EsOpaque));\n \n             let (old_parent, old_pos) = (self.parent, self.pos);\n@@ -471,9 +480,9 @@ pub mod reader {\n         }\n \n         // Compound types:\n-        fn read_enum<T>(&mut self,\n-                        name: &str,\n-                        f: |&mut Decoder<'doc>| -> DecodeResult<T>) -> DecodeResult<T> {\n+        fn read_enum<T, F>(&mut self, name: &str, f: F) -> DecodeResult<T> where\n+            F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>,\n+        {\n             debug!(\"read_enum({})\", name);\n             try!(self._check_label(name));\n \n@@ -490,10 +499,9 @@ pub mod reader {\n             Ok(result)\n         }\n \n-        fn read_enum_variant<T>(&mut self,\n-                                _: &[&str],\n-                                f: |&mut Decoder<'doc>, uint| -> DecodeResult<T>)\n-                                -> DecodeResult<T> {\n+        fn read_enum_variant<T, F>(&mut self, _: &[&str], f: F) -> DecodeResult<T> where\n+            F: FnOnce(&mut Decoder<'doc>, uint) -> DecodeResult<T>,\n+        {\n             debug!(\"read_enum_variant()\");\n             let idx = try!(self._next_uint(EsEnumVid));\n             debug!(\"  idx={}\", idx);\n@@ -511,17 +519,16 @@ pub mod reader {\n             Ok(result)\n         }\n \n-        fn read_enum_variant_arg<T>(&mut self,\n-                                    idx: uint,\n-                                    f: |&mut Decoder<'doc>| -> DecodeResult<T>) -> DecodeResult<T> {\n+        fn read_enum_variant_arg<T, F>(&mut self, idx: uint, f: F) -> DecodeResult<T> where\n+            F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>,\n+        {\n             debug!(\"read_enum_variant_arg(idx={})\", idx);\n             f(self)\n         }\n \n-        fn read_enum_struct_variant<T>(&mut self,\n-                                       _: &[&str],\n-                                       f: |&mut Decoder<'doc>, uint| -> DecodeResult<T>)\n-                                       -> DecodeResult<T> {\n+        fn read_enum_struct_variant<T, F>(&mut self, _: &[&str], f: F) -> DecodeResult<T> where\n+            F: FnOnce(&mut Decoder<'doc>, uint) -> DecodeResult<T>,\n+        {\n             debug!(\"read_enum_struct_variant()\");\n             let idx = try!(self._next_uint(EsEnumVid));\n             debug!(\"  idx={}\", idx);\n@@ -539,39 +546,37 @@ pub mod reader {\n             Ok(result)\n         }\n \n-        fn read_enum_struct_variant_field<T>(&mut self,\n-                                             name: &str,\n-                                             idx: uint,\n-                                             f: |&mut Decoder<'doc>| -> DecodeResult<T>)\n-                                             -> DecodeResult<T> {\n-            debug!(\"read_enum_struct_variant_arg(name={}, idx={})\", name, idx);\n+        fn read_enum_struct_variant_field<T, F>(&mut self,\n+                                                name: &str,\n+                                                idx: uint,\n+                                                f: F)\n+                                                -> DecodeResult<T> where\n+            F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>,\n+        {\n+                debug!(\"read_enum_struct_variant_arg(name={}, idx={})\", name, idx);\n             f(self)\n         }\n \n-        fn read_struct<T>(&mut self,\n-                          name: &str,\n-                          _: uint,\n-                          f: |&mut Decoder<'doc>| -> DecodeResult<T>)\n-                          -> DecodeResult<T> {\n+        fn read_struct<T, F>(&mut self, name: &str, _: uint, f: F) -> DecodeResult<T> where\n+            F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>,\n+        {\n             debug!(\"read_struct(name={})\", name);\n             f(self)\n         }\n \n-        fn read_struct_field<T>(&mut self,\n-                                name: &str,\n-                                idx: uint,\n-                                f: |&mut Decoder<'doc>| -> DecodeResult<T>)\n-                                -> DecodeResult<T> {\n+        fn read_struct_field<T, F>(&mut self, name: &str, idx: uint, f: F) -> DecodeResult<T> where\n+            F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>,\n+        {\n             debug!(\"read_struct_field(name={}, idx={})\", name, idx);\n             try!(self._check_label(name));\n             f(self)\n         }\n \n-        fn read_tuple<T>(&mut self,\n-                         tuple_len: uint,\n-                         f: |&mut Decoder<'doc>| -> DecodeResult<T>) -> DecodeResult<T> {\n+        fn read_tuple<T, F>(&mut self, tuple_len: uint, f: F) -> DecodeResult<T> where\n+            F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>,\n+        {\n             debug!(\"read_tuple()\");\n-            self.read_seq(|d, len| {\n+            self.read_seq(move |d, len| {\n                 if len == tuple_len {\n                     f(d)\n                 } else {\n@@ -581,34 +586,36 @@ pub mod reader {\n             })\n         }\n \n-        fn read_tuple_arg<T>(&mut self, idx: uint, f: |&mut Decoder<'doc>| -> DecodeResult<T>)\n-                             -> DecodeResult<T> {\n+        fn read_tuple_arg<T, F>(&mut self, idx: uint, f: F) -> DecodeResult<T> where\n+            F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>,\n+        {\n             debug!(\"read_tuple_arg(idx={})\", idx);\n             self.read_seq_elt(idx, f)\n         }\n \n-        fn read_tuple_struct<T>(&mut self,\n-                                name: &str,\n-                                len: uint,\n-                                f: |&mut Decoder<'doc>| -> DecodeResult<T>)\n-                                -> DecodeResult<T> {\n+        fn read_tuple_struct<T, F>(&mut self, name: &str, len: uint, f: F) -> DecodeResult<T> where\n+            F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>,\n+        {\n             debug!(\"read_tuple_struct(name={})\", name);\n             self.read_tuple(len, f)\n         }\n \n-        fn read_tuple_struct_arg<T>(&mut self,\n-                                    idx: uint,\n-                                    f: |&mut Decoder<'doc>| -> DecodeResult<T>)\n-                                    -> DecodeResult<T> {\n+        fn read_tuple_struct_arg<T, F>(&mut self,\n+                                       idx: uint,\n+                                       f: F)\n+                                       -> DecodeResult<T> where\n+            F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>,\n+        {\n             debug!(\"read_tuple_struct_arg(idx={})\", idx);\n             self.read_tuple_arg(idx, f)\n         }\n \n-        fn read_option<T>(&mut self,\n-                          f: |&mut Decoder<'doc>, bool| -> DecodeResult<T>) -> DecodeResult<T> {\n+        fn read_option<T, F>(&mut self, f: F) -> DecodeResult<T> where\n+            F: FnOnce(&mut Decoder<'doc>, bool) -> DecodeResult<T>,\n+        {\n             debug!(\"read_option()\");\n-            self.read_enum(\"Option\", |this| {\n-                this.read_enum_variant(&[\"None\", \"Some\"], |this, idx| {\n+            self.read_enum(\"Option\", move |this| {\n+                this.read_enum_variant(&[\"None\", \"Some\"], move |this, idx| {\n                     match idx {\n                         0 => f(this, false),\n                         1 => f(this, true),\n@@ -620,40 +627,45 @@ pub mod reader {\n             })\n         }\n \n-        fn read_seq<T>(&mut self,\n-                       f: |&mut Decoder<'doc>, uint| -> DecodeResult<T>) -> DecodeResult<T> {\n+        fn read_seq<T, F>(&mut self, f: F) -> DecodeResult<T> where\n+            F: FnOnce(&mut Decoder<'doc>, uint) -> DecodeResult<T>,\n+        {\n             debug!(\"read_seq()\");\n-            self.push_doc(EsVec, |d| {\n+            self.push_doc(EsVec, move |d| {\n                 let len = try!(d._next_uint(EsVecLen));\n                 debug!(\"  len={}\", len);\n                 f(d, len)\n             })\n         }\n \n-        fn read_seq_elt<T>(&mut self, idx: uint, f: |&mut Decoder<'doc>| -> DecodeResult<T>)\n-                           -> DecodeResult<T> {\n+        fn read_seq_elt<T, F>(&mut self, idx: uint, f: F) -> DecodeResult<T> where\n+            F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>,\n+        {\n             debug!(\"read_seq_elt(idx={})\", idx);\n             self.push_doc(EsVecElt, f)\n         }\n \n-        fn read_map<T>(&mut self,\n-                       f: |&mut Decoder<'doc>, uint| -> DecodeResult<T>) -> DecodeResult<T> {\n+        fn read_map<T, F>(&mut self, f: F) -> DecodeResult<T> where\n+            F: FnOnce(&mut Decoder<'doc>, uint) -> DecodeResult<T>,\n+        {\n             debug!(\"read_map()\");\n-            self.push_doc(EsMap, |d| {\n+            self.push_doc(EsMap, move |d| {\n                 let len = try!(d._next_uint(EsMapLen));\n                 debug!(\"  len={}\", len);\n                 f(d, len)\n             })\n         }\n \n-        fn read_map_elt_key<T>(&mut self, idx: uint, f: |&mut Decoder<'doc>| -> DecodeResult<T>)\n-                               -> DecodeResult<T> {\n+        fn read_map_elt_key<T, F>(&mut self, idx: uint, f: F) -> DecodeResult<T> where\n+            F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>,\n+        {\n             debug!(\"read_map_elt_key(idx={})\", idx);\n             self.push_doc(EsMapKey, f)\n         }\n \n-        fn read_map_elt_val<T>(&mut self, idx: uint, f: |&mut Decoder<'doc>| -> DecodeResult<T>)\n-                               -> DecodeResult<T> {\n+        fn read_map_elt_val<T, F>(&mut self, idx: uint, f: F) -> DecodeResult<T> where\n+            F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>,\n+        {\n             debug!(\"read_map_elt_val(idx={})\", idx);\n             self.push_doc(EsMapVal, f)\n         }\n@@ -756,7 +768,9 @@ pub mod writer {\n             Ok(r)\n         }\n \n-        pub fn wr_tag(&mut self, tag_id: uint, blk: || -> EncodeResult) -> EncodeResult {\n+        pub fn wr_tag<F>(&mut self, tag_id: uint, blk: F) -> EncodeResult where\n+            F: FnOnce() -> EncodeResult,\n+        {\n             try!(self.start_tag(tag_id));\n             try!(blk());\n             self.end_tag()\n@@ -852,7 +866,9 @@ pub mod writer {\n             else { Ok(()) }\n         }\n \n-        pub fn emit_opaque(&mut self, f: |&mut Encoder<W>| -> EncodeResult) -> EncodeResult {\n+        pub fn emit_opaque<F>(&mut self, f: F) -> EncodeResult where\n+            F: FnOnce(&mut Encoder<W>) -> EncodeResult,\n+        {\n             try!(self.start_tag(EsOpaque as uint));\n             try!(f(self));\n             self.end_tag()\n@@ -916,140 +932,144 @@ pub mod writer {\n             self.wr_tagged_str(EsStr as uint, v)\n         }\n \n-        fn emit_enum(&mut self,\n-                     name: &str,\n-                     f: |&mut Encoder<'a, W>| -> EncodeResult) -> EncodeResult {\n+        fn emit_enum<F>(&mut self, name: &str, f: F) -> EncodeResult where\n+            F: FnOnce(&mut Encoder<'a, W>) -> EncodeResult,\n+        {\n             try!(self._emit_label(name));\n             try!(self.start_tag(EsEnum as uint));\n             try!(f(self));\n             self.end_tag()\n         }\n \n-        fn emit_enum_variant(&mut self,\n-                             _: &str,\n-                             v_id: uint,\n-                             _: uint,\n-                             f: |&mut Encoder<'a, W>| -> EncodeResult) -> EncodeResult {\n+        fn emit_enum_variant<F>(&mut self,\n+                                _: &str,\n+                                v_id: uint,\n+                                _: uint,\n+                                f: F) -> EncodeResult where\n+            F: FnOnce(&mut Encoder<'a, W>) -> EncodeResult,\n+        {\n             try!(self._emit_tagged_uint(EsEnumVid, v_id));\n             try!(self.start_tag(EsEnumBody as uint));\n             try!(f(self));\n             self.end_tag()\n         }\n \n-        fn emit_enum_variant_arg(&mut self,\n-                                 _: uint,\n-                                 f: |&mut Encoder<'a, W>| -> EncodeResult) -> EncodeResult {\n+        fn emit_enum_variant_arg<F>(&mut self, _: uint, f: F) -> EncodeResult where\n+            F: FnOnce(&mut Encoder<'a, W>) -> EncodeResult,\n+        {\n             f(self)\n         }\n \n-        fn emit_enum_struct_variant(&mut self,\n-                                    v_name: &str,\n-                                    v_id: uint,\n-                                    cnt: uint,\n-                                    f: |&mut Encoder<'a, W>| -> EncodeResult) -> EncodeResult {\n+        fn emit_enum_struct_variant<F>(&mut self,\n+                                       v_name: &str,\n+                                       v_id: uint,\n+                                       cnt: uint,\n+                                       f: F) -> EncodeResult where\n+            F: FnOnce(&mut Encoder<'a, W>) -> EncodeResult,\n+        {\n             self.emit_enum_variant(v_name, v_id, cnt, f)\n         }\n \n-        fn emit_enum_struct_variant_field(&mut self,\n-                                          _: &str,\n-                                          idx: uint,\n-                                          f: |&mut Encoder<'a, W>| -> EncodeResult)\n-            -> EncodeResult {\n+        fn emit_enum_struct_variant_field<F>(&mut self,\n+                                             _: &str,\n+                                             idx: uint,\n+                                             f: F) -> EncodeResult where\n+            F: FnOnce(&mut Encoder<'a, W>) -> EncodeResult,\n+        {\n             self.emit_enum_variant_arg(idx, f)\n         }\n \n-        fn emit_struct(&mut self,\n-                       _: &str,\n-                       _len: uint,\n-                       f: |&mut Encoder<'a, W>| -> EncodeResult) -> EncodeResult {\n+        fn emit_struct<F>(&mut self, _: &str, _len: uint, f: F) -> EncodeResult where\n+            F: FnOnce(&mut Encoder<'a, W>) -> EncodeResult,\n+        {\n             f(self)\n         }\n \n-        fn emit_struct_field(&mut self,\n-                             name: &str,\n-                             _: uint,\n-                             f: |&mut Encoder<'a, W>| -> EncodeResult) -> EncodeResult {\n+        fn emit_struct_field<F>(&mut self, name: &str, _: uint, f: F) -> EncodeResult where\n+            F: FnOnce(&mut Encoder<'a, W>) -> EncodeResult,\n+        {\n             try!(self._emit_label(name));\n             f(self)\n         }\n \n-        fn emit_tuple(&mut self,\n-                      len: uint,\n-                      f: |&mut Encoder<'a, W>| -> EncodeResult) -> EncodeResult {\n+        fn emit_tuple<F>(&mut self, len: uint, f: F) -> EncodeResult where\n+            F: FnOnce(&mut Encoder<'a, W>) -> EncodeResult,\n+        {\n             self.emit_seq(len, f)\n         }\n-        fn emit_tuple_arg(&mut self,\n-                          idx: uint,\n-                          f: |&mut Encoder<'a, W>| -> EncodeResult) -> EncodeResult {\n+        fn emit_tuple_arg<F>(&mut self, idx: uint, f: F) -> EncodeResult where\n+            F: FnOnce(&mut Encoder<'a, W>) -> EncodeResult,\n+        {\n             self.emit_seq_elt(idx, f)\n         }\n \n-        fn emit_tuple_struct(&mut self,\n-                             _: &str,\n-                             len: uint,\n-                             f: |&mut Encoder<'a, W>| -> EncodeResult) -> EncodeResult {\n+        fn emit_tuple_struct<F>(&mut self, _: &str, len: uint, f: F) -> EncodeResult where\n+            F: FnOnce(&mut Encoder<'a, W>) -> EncodeResult,\n+        {\n             self.emit_seq(len, f)\n         }\n-        fn emit_tuple_struct_arg(&mut self,\n-                                 idx: uint,\n-                                 f: |&mut Encoder<'a, W>| -> EncodeResult) -> EncodeResult {\n+        fn emit_tuple_struct_arg<F>(&mut self, idx: uint, f: F) -> EncodeResult where\n+            F: FnOnce(&mut Encoder<'a, W>) -> EncodeResult,\n+        {\n             self.emit_seq_elt(idx, f)\n         }\n \n-        fn emit_option(&mut self,\n-                       f: |&mut Encoder<'a, W>| -> EncodeResult) -> EncodeResult {\n+        fn emit_option<F>(&mut self, f: F) -> EncodeResult where\n+            F: FnOnce(&mut Encoder<'a, W>) -> EncodeResult,\n+        {\n             self.emit_enum(\"Option\", f)\n         }\n         fn emit_option_none(&mut self) -> EncodeResult {\n             self.emit_enum_variant(\"None\", 0, 0, |_| Ok(()))\n         }\n-        fn emit_option_some(&mut self,\n-                            f: |&mut Encoder<'a, W>| -> EncodeResult) -> EncodeResult {\n+        fn emit_option_some<F>(&mut self, f: F) -> EncodeResult where\n+            F: FnOnce(&mut Encoder<'a, W>) -> EncodeResult,\n+        {\n \n             self.emit_enum_variant(\"Some\", 1, 1, f)\n         }\n \n-        fn emit_seq(&mut self,\n-                    len: uint,\n-                    f: |&mut Encoder<'a, W>| -> EncodeResult) -> EncodeResult {\n+        fn emit_seq<F>(&mut self, len: uint, f: F) -> EncodeResult where\n+            F: FnOnce(&mut Encoder<'a, W>) -> EncodeResult,\n+        {\n \n             try!(self.start_tag(EsVec as uint));\n             try!(self._emit_tagged_uint(EsVecLen, len));\n             try!(f(self));\n             self.end_tag()\n         }\n \n-        fn emit_seq_elt(&mut self,\n-                        _idx: uint,\n-                        f: |&mut Encoder<'a, W>| -> EncodeResult) -> EncodeResult {\n+        fn emit_seq_elt<F>(&mut self, _idx: uint, f: F) -> EncodeResult where\n+            F: FnOnce(&mut Encoder<'a, W>) -> EncodeResult,\n+        {\n \n             try!(self.start_tag(EsVecElt as uint));\n             try!(f(self));\n             self.end_tag()\n         }\n \n-        fn emit_map(&mut self,\n-                    len: uint,\n-                    f: |&mut Encoder<'a, W>| -> EncodeResult) -> EncodeResult {\n+        fn emit_map<F>(&mut self, len: uint, f: F) -> EncodeResult where\n+            F: FnOnce(&mut Encoder<'a, W>) -> EncodeResult,\n+        {\n \n             try!(self.start_tag(EsMap as uint));\n             try!(self._emit_tagged_uint(EsMapLen, len));\n             try!(f(self));\n             self.end_tag()\n         }\n \n-        fn emit_map_elt_key(&mut self,\n-                            _idx: uint,\n-                            f: |&mut Encoder<'a, W>| -> EncodeResult) -> EncodeResult {\n+        fn emit_map_elt_key<F>(&mut self, _idx: uint, mut f: F) -> EncodeResult where\n+            F: FnMut(&mut Encoder<'a, W>) -> EncodeResult,\n+        {\n \n             try!(self.start_tag(EsMapKey as uint));\n             try!(f(self));\n             self.end_tag()\n         }\n \n-        fn emit_map_elt_val(&mut self,\n-                            _idx: uint,\n-                            f: |&mut Encoder<'a, W>| -> EncodeResult) -> EncodeResult {\n+        fn emit_map_elt_val<F>(&mut self, _idx: uint, f: F) -> EncodeResult where\n+            F: FnOnce(&mut Encoder<'a, W>) -> EncodeResult,\n+        {\n             try!(self.start_tag(EsMapVal as uint));\n             try!(f(self));\n             self.end_tag()"}, {"sha": "05f853a851ea7aa226358eb4d7743dbb4c4fc8b7", "filename": "src/libregex/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibregex%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibregex%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Flib.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -370,6 +370,7 @@\n \n #![allow(unknown_features)]\n #![feature(macro_rules, phase, slicing_syntax, globs)]\n+#![feature(unboxed_closures)]\n #![deny(missing_docs)]\n \n #[cfg(test)]"}, {"sha": "ccbd53c4f2a889f56faa154a5462938b734ceb4c", "filename": "src/libregex/parse.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibregex%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibregex%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fparse.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -838,8 +838,9 @@ impl<'a> Parser<'a> {\n     // Otherwise, an error will be returned.\n     // Generally, `allow_start` is only true when you're *not* expecting an\n     // opening parenthesis.\n-    fn pos_last(&self, allow_start: bool, pred: |&BuildAst| -> bool)\n-               -> Result<uint, Error> {\n+    fn pos_last<P>(&self, allow_start: bool, pred: P) -> Result<uint, Error> where\n+        P: FnMut(&BuildAst) -> bool,\n+   {\n         let from = match self.stack.iter().rev().position(pred) {\n             Some(i) => i,\n             None => {\n@@ -887,8 +888,9 @@ impl<'a> Parser<'a> {\n     // build_from combines all AST elements starting at 'from' in the\n     // parser's stack using 'mk' to combine them. If any such element is not an\n     // AST then it is popped off the stack and ignored.\n-    fn build_from(&mut self, from: uint, mk: |Ast, Ast| -> Ast)\n-                 -> Result<Ast, Error> {\n+    fn build_from<F>(&mut self, from: uint, mut mk: F) -> Result<Ast, Error> where\n+        F: FnMut(Ast, Ast) -> Ast,\n+    {\n         if from >= self.stack.len() {\n             return self.err(\"Empty group or alternate not allowed.\")\n         }"}, {"sha": "1504e1919852d8e0058eb0eeec5ee7daeb6a6783", "filename": "src/libregex/re.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibregex%2Fre.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibregex%2Fre.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fre.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -429,10 +429,11 @@ impl Regex {\n     ///\n     /// ```rust\n     /// # #![feature(phase)]\n+    /// # #![feature(unboxed_closures)]\n     /// # extern crate regex; #[phase(plugin)] extern crate regex_macros;\n     /// # use regex::Captures; fn main() {\n     /// let re = regex!(r\"([^,\\s]+),\\s+(\\S+)\");\n-    /// let result = re.replace(\"Springsteen, Bruce\", |caps: &Captures| {\n+    /// let result = re.replace(\"Springsteen, Bruce\", |&: caps: &Captures| {\n     ///     format!(\"{} {}\", caps.at(2), caps.at(1))\n     /// });\n     /// assert_eq!(result.as_slice(), \"Bruce Springsteen\");\n@@ -585,7 +586,7 @@ impl<'t> Replacer for &'t str {\n     }\n }\n \n-impl<'t> Replacer for |&Captures|: 't -> String {\n+impl<F> Replacer for F where F: FnMut(&Captures) -> String {\n     fn reg_replace<'a>(&'a mut self, caps: &Captures) -> CowString<'a> {\n         (*self)(caps).into_cow()\n     }\n@@ -767,7 +768,7 @@ impl<'t> Captures<'t> {\n         // How evil can you get?\n         // FIXME: Don't use regexes for this. It's completely unnecessary.\n         let re = Regex::new(r\"(^|[^$]|\\b)\\$(\\w+)\").unwrap();\n-        let text = re.replace_all(text, |refs: &Captures| -> String {\n+        let text = re.replace_all(text, |&mut: refs: &Captures| -> String {\n             let (pre, name) = (refs.at(1), refs.at(2));\n             format!(\"{}{}\", pre,\n                     match from_str::<uint>(name.as_slice()) {"}, {"sha": "c1e8677fa8f3d99ccdf2baba0279bdcf6fe289b4", "filename": "src/libregex_macros/lib.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibregex_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibregex_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex_macros%2Flib.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -19,6 +19,7 @@\n        html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n \n #![feature(plugin_registrar, quote)]\n+#![feature(unboxed_closures)]\n \n extern crate regex;\n extern crate syntax;\n@@ -601,9 +602,10 @@ fn exec<'t>(which: ::regex::native::MatchKind, input: &'t str,\n \n     // Converts `xs` to a `[x1, x2, .., xN]` expression by calling `to_expr`\n     // on each element in `xs`.\n-    fn vec_expr<T, It: Iterator<T>>(&self, xs: It,\n-                                    to_expr: |&ExtCtxt, T| -> P<ast::Expr>)\n-                  -> P<ast::Expr> {\n+    fn vec_expr<T, It, F>(&self, xs: It, mut to_expr: F) -> P<ast::Expr> where\n+        It: Iterator<T>,\n+        F: FnMut(&ExtCtxt, T) -> P<ast::Expr>,\n+    {\n         let exprs = xs.map(|x| to_expr(self.cx, x)).collect();\n         self.cx.expr_vec(self.sp, exprs)\n     }"}, {"sha": "404c7edeb88d6ddfad3dadabcc64dfd668688c49", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -25,6 +25,7 @@\n #![feature(default_type_params, globs, import_shadowing, macro_rules, phase, quote)]\n #![feature(slicing_syntax, unsafe_destructor)]\n #![feature(rustc_diagnostic_macros)]\n+#![feature(unboxed_closures)]\n \n extern crate arena;\n extern crate flate;"}, {"sha": "9f9e266c6c74b2ea0602799a4dea007398d758c5", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -464,9 +464,11 @@ impl<'a, 'tcx> Context<'a, 'tcx> {\n     /// Merge the lints specified by any lint attributes into the\n     /// current lint context, call the provided function, then reset the\n     /// lints in effect to their previous state.\n-    fn with_lint_attrs(&mut self,\n-                       attrs: &[ast::Attribute],\n-                       f: |&mut Context|) {\n+    fn with_lint_attrs<F>(&mut self,\n+                          attrs: &[ast::Attribute],\n+                          f: F) where\n+        F: FnOnce(&mut Context),\n+    {\n         // Parse all of the lint attributes, and then add them all to the\n         // current dictionary of lint information. Along the way, keep a history\n         // of what we changed so we can roll everything back after invoking the\n@@ -528,7 +530,9 @@ impl<'a, 'tcx> Context<'a, 'tcx> {\n         }\n     }\n \n-    fn visit_ids(&mut self, f: |&mut ast_util::IdVisitor<Context>|) {\n+    fn visit_ids<F>(&mut self, f: F) where\n+        F: FnOnce(&mut ast_util::IdVisitor<Context>)\n+    {\n         let mut v = ast_util::IdVisitor {\n             operation: self,\n             pass_through_items: false,"}, {"sha": "4cbb1babf9a2cbf8e9b5bc01790a8b14e78f440d", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 36, "deletions": 26, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -47,20 +47,22 @@ pub fn get_symbol(cstore: &cstore::CStore, def: ast::DefId) -> String {\n }\n \n /// Iterates over all the language items in the given crate.\n-pub fn each_lang_item(cstore: &cstore::CStore,\n-                      cnum: ast::CrateNum,\n-                      f: |ast::NodeId, uint| -> bool)\n-                      -> bool {\n+pub fn each_lang_item<F>(cstore: &cstore::CStore,\n+                         cnum: ast::CrateNum,\n+                         f: F)\n+                         -> bool where\n+    F: FnMut(ast::NodeId, uint) -> bool,\n+{\n     let crate_data = cstore.get_crate_data(cnum);\n     decoder::each_lang_item(&*crate_data, f)\n }\n \n /// Iterates over each child of the given item.\n-pub fn each_child_of_item(cstore: &cstore::CStore,\n-                          def_id: ast::DefId,\n-                          callback: |decoder::DefLike,\n-                                     ast::Name,\n-                                     ast::Visibility|) {\n+pub fn each_child_of_item<F>(cstore: &cstore::CStore,\n+                             def_id: ast::DefId,\n+                             callback: F) where\n+    F: FnMut(decoder::DefLike, ast::Name, ast::Visibility),\n+{\n     let crate_data = cstore.get_crate_data(def_id.krate);\n     let get_crate_data: decoder::GetCrateDataCb = |cnum| {\n         cstore.get_crate_data(cnum)\n@@ -73,11 +75,11 @@ pub fn each_child_of_item(cstore: &cstore::CStore,\n }\n \n /// Iterates over each top-level crate item.\n-pub fn each_top_level_item_of_crate(cstore: &cstore::CStore,\n-                                    cnum: ast::CrateNum,\n-                                    callback: |decoder::DefLike,\n-                                               ast::Name,\n-                                               ast::Visibility|) {\n+pub fn each_top_level_item_of_crate<F>(cstore: &cstore::CStore,\n+                                       cnum: ast::CrateNum,\n+                                       callback: F) where\n+    F: FnMut(decoder::DefLike, ast::Name, ast::Visibility),\n+{\n     let crate_data = cstore.get_crate_data(cnum);\n     let get_crate_data: decoder::GetCrateDataCb = |cnum| {\n         cstore.get_crate_data(cnum)\n@@ -195,9 +197,11 @@ pub fn get_methods_if_impl(cstore: &cstore::CStore,\n     decoder::get_methods_if_impl(cstore.intr.clone(), &*cdata, def.node)\n }\n \n-pub fn get_item_attrs(cstore: &cstore::CStore,\n-                      def_id: ast::DefId,\n-                      f: |Vec<ast::Attribute>|) {\n+pub fn get_item_attrs<F>(cstore: &cstore::CStore,\n+                         def_id: ast::DefId,\n+                         f: F) where\n+    F: FnOnce(Vec<ast::Attribute>),\n+{\n     let cdata = cstore.get_crate_data(def_id.krate);\n     decoder::get_item_attrs(&*cdata, def_id.node, f)\n }\n@@ -279,23 +283,29 @@ pub fn get_native_libraries(cstore: &cstore::CStore, crate_num: ast::CrateNum)\n     decoder::get_native_libraries(&*cdata)\n }\n \n-pub fn each_impl(cstore: &cstore::CStore,\n-                 crate_num: ast::CrateNum,\n-                 callback: |ast::DefId|) {\n+pub fn each_impl<F>(cstore: &cstore::CStore,\n+                    crate_num: ast::CrateNum,\n+                    callback: F) where\n+    F: FnMut(ast::DefId),\n+{\n     let cdata = cstore.get_crate_data(crate_num);\n     decoder::each_impl(&*cdata, callback)\n }\n \n-pub fn each_implementation_for_type(cstore: &cstore::CStore,\n-                                    def_id: ast::DefId,\n-                                    callback: |ast::DefId|) {\n+pub fn each_implementation_for_type<F>(cstore: &cstore::CStore,\n+                                       def_id: ast::DefId,\n+                                       callback: F) where\n+    F: FnMut(ast::DefId),\n+{\n     let cdata = cstore.get_crate_data(def_id.krate);\n     decoder::each_implementation_for_type(&*cdata, def_id.node, callback)\n }\n \n-pub fn each_implementation_for_trait(cstore: &cstore::CStore,\n-                                     def_id: ast::DefId,\n-                                     callback: |ast::DefId|) {\n+pub fn each_implementation_for_trait<F>(cstore: &cstore::CStore,\n+                                        def_id: ast::DefId,\n+                                        callback: F) where\n+    F: FnMut(ast::DefId),\n+{\n     let cdata = cstore.get_crate_data(def_id.krate);\n     decoder::each_implementation_for_trait(&*cdata, def_id.node, callback)\n }"}, {"sha": "c0642f29abc90fe534c55f6d76d9ea168345df2c", "filename": "src/librustc/metadata/cstore.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcstore.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -113,16 +113,18 @@ impl CStore {\n         self.metas.borrow_mut().insert(cnum, data);\n     }\n \n-    pub fn iter_crate_data(&self, i: |ast::CrateNum, &crate_metadata|) {\n+    pub fn iter_crate_data<I>(&self, mut i: I) where\n+        I: FnMut(ast::CrateNum, &crate_metadata),\n+    {\n         for (&k, v) in self.metas.borrow().iter() {\n             i(k, &**v);\n         }\n     }\n \n     /// Like `iter_crate_data`, but passes source paths (if available) as well.\n-    pub fn iter_crate_data_origins(&self, i: |ast::CrateNum,\n-                                              &crate_metadata,\n-                                              Option<CrateSource>|) {\n+    pub fn iter_crate_data_origins<I>(&self, mut i: I) where\n+        I: FnMut(ast::CrateNum, &crate_metadata, Option<CrateSource>),\n+    {\n         for (&k, v) in self.metas.borrow().iter() {\n             let origin = self.get_used_crate_source(k);\n             origin.as_ref().map(|cs| { assert!(k == cs.cnum); });"}, {"sha": "4e892f53186bc2d9808584fd587f3fad52858fdf", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 46, "deletions": 31, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -60,8 +60,9 @@ pub type Cmd<'a> = &'a crate_metadata;\n // what crate that's in and give us a def_id that makes sense for the current\n // build.\n \n-fn lookup_hash<'a>(d: rbml::Doc<'a>, eq_fn: |&[u8]| -> bool,\n-                   hash: u64) -> Option<rbml::Doc<'a>> {\n+fn lookup_hash<'a, F>(d: rbml::Doc<'a>, mut eq_fn: F, hash: u64) -> Option<rbml::Doc<'a>> where\n+    F: FnMut(&[u8]) -> bool,\n+{\n     let index = reader::get_doc(d, tag_index);\n     let table = reader::get_doc(index, tag_index_table);\n     let hash_pos = table.start + (hash % 256 * 4) as uint;\n@@ -212,7 +213,9 @@ fn get_provided_source(d: rbml::Doc, cdata: Cmd) -> Option<ast::DefId> {\n     })\n }\n \n-fn each_reexport(d: rbml::Doc, f: |rbml::Doc| -> bool) -> bool {\n+fn each_reexport<F>(d: rbml::Doc, f: F) -> bool where\n+    F: FnMut(rbml::Doc) -> bool,\n+{\n     reader::tagged_docs(d, tag_items_data_item_reexport, f)\n }\n \n@@ -446,7 +449,9 @@ pub enum DefLike {\n impl Copy for DefLike {}\n \n /// Iterates over the language items in the given crate.\n-pub fn each_lang_item(cdata: Cmd, f: |ast::NodeId, uint| -> bool) -> bool {\n+pub fn each_lang_item<F>(cdata: Cmd, mut f: F) -> bool where\n+    F: FnMut(ast::NodeId, uint) -> bool,\n+{\n     let root = rbml::Doc::new(cdata.data());\n     let lang_items = reader::get_doc(root, tag_lang_items);\n     reader::tagged_docs(lang_items, tag_lang_items_item, |item_doc| {\n@@ -462,13 +467,13 @@ pub fn each_lang_item(cdata: Cmd, f: |ast::NodeId, uint| -> bool) -> bool {\n \n pub type GetCrateDataCb<'a> = |ast::CrateNum|: 'a -> Rc<crate_metadata>;\n \n-fn each_child_of_item_or_crate(intr: Rc<IdentInterner>,\n-                               cdata: Cmd,\n-                               item_doc: rbml::Doc,\n-                               get_crate_data: GetCrateDataCb,\n-                               callback: |DefLike,\n-                                          ast::Name,\n-                                          ast::Visibility|) {\n+fn each_child_of_item_or_crate<F>(intr: Rc<IdentInterner>,\n+                                  cdata: Cmd,\n+                                  item_doc: rbml::Doc,\n+                                  get_crate_data: GetCrateDataCb,\n+                                  mut callback: F) where\n+    F: FnMut(DefLike, ast::Name, ast::Visibility),\n+{\n     // Iterate over all children.\n     let _ = reader::tagged_docs(item_doc, tag_mod_child, |child_info_doc| {\n         let child_def_id = reader::with_doc_data(child_info_doc,\n@@ -581,11 +586,13 @@ fn each_child_of_item_or_crate(intr: Rc<IdentInterner>,\n }\n \n /// Iterates over each child of the given item.\n-pub fn each_child_of_item(intr: Rc<IdentInterner>,\n-                          cdata: Cmd,\n-                          id: ast::NodeId,\n-                          get_crate_data: GetCrateDataCb,\n-                          callback: |DefLike, ast::Name, ast::Visibility|) {\n+pub fn each_child_of_item<F>(intr: Rc<IdentInterner>,\n+                             cdata: Cmd,\n+                             id: ast::NodeId,\n+                             get_crate_data: GetCrateDataCb,\n+                             callback: F) where\n+    F: FnMut(DefLike, ast::Name, ast::Visibility),\n+{\n     // Find the item.\n     let root_doc = rbml::Doc::new(cdata.data());\n     let items = reader::get_doc(root_doc, tag_items);\n@@ -602,12 +609,12 @@ pub fn each_child_of_item(intr: Rc<IdentInterner>,\n }\n \n /// Iterates over all the top-level crate items.\n-pub fn each_top_level_item_of_crate(intr: Rc<IdentInterner>,\n-                                    cdata: Cmd,\n-                                    get_crate_data: GetCrateDataCb,\n-                                    callback: |DefLike,\n-                                               ast::Name,\n-                                               ast::Visibility|) {\n+pub fn each_top_level_item_of_crate<F>(intr: Rc<IdentInterner>,\n+                                       cdata: Cmd,\n+                                       get_crate_data: GetCrateDataCb,\n+                                       callback: F) where\n+    F: FnMut(DefLike, ast::Name, ast::Visibility),\n+{\n     let root_doc = rbml::Doc::new(cdata.data());\n     let misc_info_doc = reader::get_doc(root_doc, tag_misc_info);\n     let crate_items_doc = reader::get_doc(misc_info_doc,\n@@ -980,9 +987,11 @@ pub fn get_tuple_struct_definition_if_ctor(cdata: Cmd,\n     ret\n }\n \n-pub fn get_item_attrs(cdata: Cmd,\n-                      orig_node_id: ast::NodeId,\n-                      f: |Vec<ast::Attribute>|) {\n+pub fn get_item_attrs<F>(cdata: Cmd,\n+                         orig_node_id: ast::NodeId,\n+                         f: F) where\n+    F: FnOnce(Vec<ast::Attribute>),\n+{\n     // The attributes for a tuple struct are attached to the definition, not the ctor;\n     // we assume that someone passing in a tuple struct ctor is actually wanting to\n     // look at the definition\n@@ -1222,17 +1231,21 @@ pub fn translate_def_id(cdata: Cmd, did: ast::DefId) -> ast::DefId {\n     }\n }\n \n-pub fn each_impl(cdata: Cmd, callback: |ast::DefId|) {\n+pub fn each_impl<F>(cdata: Cmd, mut callback: F) where\n+    F: FnMut(ast::DefId),\n+{\n     let impls_doc = reader::get_doc(rbml::Doc::new(cdata.data()), tag_impls);\n     let _ = reader::tagged_docs(impls_doc, tag_impls_impl, |impl_doc| {\n         callback(item_def_id(impl_doc, cdata));\n         true\n     });\n }\n \n-pub fn each_implementation_for_type(cdata: Cmd,\n+pub fn each_implementation_for_type<F>(cdata: Cmd,\n                                     id: ast::NodeId,\n-                                    callback: |ast::DefId|) {\n+                                    mut callback: F) where\n+    F: FnMut(ast::DefId),\n+{\n     let item_doc = lookup_item(id, cdata.data());\n     reader::tagged_docs(item_doc,\n                         tag_items_data_item_inherent_impl,\n@@ -1243,9 +1256,11 @@ pub fn each_implementation_for_type(cdata: Cmd,\n     });\n }\n \n-pub fn each_implementation_for_trait(cdata: Cmd,\n-                                     id: ast::NodeId,\n-                                     callback: |ast::DefId|) {\n+pub fn each_implementation_for_trait<F>(cdata: Cmd,\n+                                        id: ast::NodeId,\n+                                        mut callback: F) where\n+    F: FnMut(ast::DefId),\n+{\n     let item_doc = lookup_item(id, cdata.data());\n \n     let _ = reader::tagged_docs(item_doc,"}, {"sha": "9804e3c20aa35c764c90043f51e2784c01157871", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -493,7 +493,9 @@ fn encode_reexported_static_methods(ecx: &EncodeContext,\n /// top-level items that are sub-items of the given item. Specifically:\n ///\n /// * For newtype structs, iterates through the node ID of the constructor.\n-fn each_auxiliary_node_id(item: &ast::Item, callback: |NodeId| -> bool) -> bool {\n+fn each_auxiliary_node_id<F>(item: &ast::Item, callback: F) -> bool where\n+    F: FnOnce(NodeId) -> bool,\n+{\n     let mut continue_ = true;\n     match item.node {\n         ast::ItemStruct(ref struct_def, _) => {\n@@ -1579,8 +1581,10 @@ fn encode_info_for_items(ecx: &EncodeContext,\n \n // Path and definition ID indexing\n \n-fn encode_index<T: Hash>(rbml_w: &mut Encoder, index: Vec<entry<T>>,\n-                         write_fn: |&mut SeekableMemWriter, &T|) {\n+fn encode_index<T, F>(rbml_w: &mut Encoder, index: Vec<entry<T>>, mut write_fn: F) where\n+    F: FnMut(&mut SeekableMemWriter, &T),\n+    T: Hash,\n+{\n     let mut buckets: Vec<Vec<entry<T>>> = Vec::from_fn(256, |_| Vec::new());\n     for elt in index.into_iter() {\n         let h = hash::hash(&elt.val) as uint;"}, {"sha": "507fb751303f9fcff5161db02295d18b1f66e604", "filename": "src/librustc/metadata/filesearch.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -42,7 +42,9 @@ pub struct FileSearch<'a> {\n }\n \n impl<'a> FileSearch<'a> {\n-    pub fn for_each_lib_search_path(&self, f: |&Path| -> FileMatch) {\n+    pub fn for_each_lib_search_path<F>(&self, mut f: F) where\n+        F: FnMut(&Path) -> FileMatch,\n+    {\n         let mut visited_dirs = HashSet::new();\n         let mut found = false;\n "}, {"sha": "7358b3bc9c969d3fab3ae284dea734523b0ba5ad", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -89,7 +89,10 @@ fn next_byte(st: &mut PState) -> u8 {\n     return b;\n }\n \n-fn scan<R>(st: &mut PState, is_last: |char| -> bool, op: |&[u8]| -> R) -> R {\n+fn scan<R, F, G>(st: &mut PState, mut is_last: F, op: G) -> R where\n+    F: FnMut(char) -> bool,\n+    G: FnOnce(&[u8]) -> R,\n+{\n     let start_pos = st.pos;\n     debug!(\"scan: '{}' (start)\", st.data[st.pos] as char);\n     while !is_last(st.data[st.pos] as char) {\n@@ -110,7 +113,9 @@ pub fn parse_name(st: &mut PState, last: char) -> ast::Name {\n     parse_name_(st, |a| is_last(last, a) )\n }\n \n-fn parse_name_(st: &mut PState, is_last: |char| -> bool) -> ast::Name {\n+fn parse_name_<F>(st: &mut PState, is_last: F) -> ast::Name where\n+    F: FnMut(char) -> bool,\n+{\n     scan(st, is_last, |bytes| {\n         token::intern(str::from_utf8(bytes).unwrap())\n     })\n@@ -234,9 +239,10 @@ fn parse_trait_store(st: &mut PState, conv: conv_did) -> ty::TraitStore {\n     }\n }\n \n-fn parse_vec_per_param_space<'a, 'tcx, T>(st: &mut PState<'a, 'tcx>,\n-                                          f: |&mut PState<'a, 'tcx>| -> T)\n-                                          -> VecPerParamSpace<T>\n+fn parse_vec_per_param_space<'a, 'tcx, T, F>(st: &mut PState<'a, 'tcx>,\n+                                             mut f: F)\n+                                             -> VecPerParamSpace<T> where\n+    F: FnMut(&mut PState<'a, 'tcx>) -> T,\n {\n     let mut r = VecPerParamSpace::empty();\n     for &space in subst::ParamSpace::all().iter() {\n@@ -350,8 +356,9 @@ fn parse_scope(st: &mut PState) -> region::CodeExtent {\n     }\n }\n \n-fn parse_opt<'a, 'tcx, T>(st: &mut PState<'a, 'tcx>, f: |&mut PState<'a, 'tcx>| -> T)\n-                          -> Option<T> {\n+fn parse_opt<'a, 'tcx, T, F>(st: &mut PState<'a, 'tcx>, f: F) -> Option<T> where\n+    F: FnOnce(&mut PState<'a, 'tcx>) -> T,\n+{\n     match next(st) {\n       'n' => None,\n       's' => Some(f(st)),"}, {"sha": "54376cd7b9078e6d651ee4abf80370650c93c205", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -86,7 +86,9 @@ fn enc_mt<'a, 'tcx>(w: &mut SeekableMemWriter, cx: &ctxt<'a, 'tcx>,\n     enc_ty(w, cx, mt.ty);\n }\n \n-fn enc_opt<T>(w: &mut SeekableMemWriter, t: Option<T>, enc_f: |&mut SeekableMemWriter, T|) {\n+fn enc_opt<T, F>(w: &mut SeekableMemWriter, t: Option<T>, enc_f: F) where\n+    F: FnOnce(&mut SeekableMemWriter, T),\n+{\n     match t {\n         None => mywrite!(w, \"n\"),\n         Some(v) => {\n@@ -96,10 +98,12 @@ fn enc_opt<T>(w: &mut SeekableMemWriter, t: Option<T>, enc_f: |&mut SeekableMemW\n     }\n }\n \n-fn enc_vec_per_param_space<'a, 'tcx, T>(w: &mut SeekableMemWriter,\n-                                        cx: &ctxt<'a, 'tcx>,\n-                                        v: &VecPerParamSpace<T>,\n-                                        op: |&mut SeekableMemWriter, &ctxt<'a, 'tcx>, &T|) {\n+fn enc_vec_per_param_space<'a, 'tcx, T, F>(w: &mut SeekableMemWriter,\n+                                           cx: &ctxt<'a, 'tcx>,\n+                                           v: &VecPerParamSpace<T>,\n+                                           mut op: F) where\n+    F: FnMut(&mut SeekableMemWriter, &ctxt<'a, 'tcx>, &T),\n+{\n     for &space in subst::ParamSpace::all().iter() {\n         mywrite!(w, \"[\");\n         for t in v.get_slice(space).iter() {"}, {"sha": "26d70502a5b1677cb01b3970f850d70b849f3de8", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -680,9 +680,8 @@ pub fn encode_unboxed_closure_kind(ebml_w: &mut Encoder,\n }\n \n pub trait vtable_decoder_helpers<'tcx> {\n-    fn read_vec_per_param_space<T>(&mut self,\n-                                   f: |&mut Self| -> T)\n-                                   -> VecPerParamSpace<T>;\n+    fn read_vec_per_param_space<T, F>(&mut self, f: F) -> VecPerParamSpace<T> where\n+        F: FnMut(&mut Self) -> T;\n     fn read_vtable_res_with_key(&mut self,\n                                 tcx: &ty::ctxt<'tcx>,\n                                 cdata: &cstore::crate_metadata)\n@@ -699,9 +698,8 @@ pub trait vtable_decoder_helpers<'tcx> {\n }\n \n impl<'tcx, 'a> vtable_decoder_helpers<'tcx> for reader::Decoder<'a> {\n-    fn read_vec_per_param_space<T>(&mut self,\n-                                   f: |&mut reader::Decoder<'a>| -> T)\n-                                   -> VecPerParamSpace<T>\n+    fn read_vec_per_param_space<T, F>(&mut self, mut f: F) -> VecPerParamSpace<T> where\n+        F: FnMut(&mut reader::Decoder<'a>) -> T,\n     {\n         let types = self.read_to_vec(|this| Ok(f(this))).unwrap();\n         let selfs = self.read_to_vec(|this| Ok(f(this))).unwrap();\n@@ -793,9 +791,11 @@ impl<'tcx, 'a> vtable_decoder_helpers<'tcx> for reader::Decoder<'a> {\n // ___________________________________________________________________________\n //\n \n-fn encode_vec_per_param_space<T>(rbml_w: &mut Encoder,\n-                                 v: &subst::VecPerParamSpace<T>,\n-                                 f: |&mut Encoder, &T|) {\n+fn encode_vec_per_param_space<T, F>(rbml_w: &mut Encoder,\n+                                    v: &subst::VecPerParamSpace<T>,\n+                                    mut f: F) where\n+    F: FnMut(&mut Encoder, &T),\n+{\n     for &space in subst::ParamSpace::all().iter() {\n         rbml_w.emit_from_vec(v.get_slice(space),\n                              |rbml_w, n| Ok(f(rbml_w, n))).unwrap();\n@@ -1124,14 +1124,16 @@ impl<'a, 'tcx> rbml_writer_helpers<'tcx> for Encoder<'a> {\n }\n \n trait write_tag_and_id {\n-    fn tag(&mut self, tag_id: c::astencode_tag, f: |&mut Self|);\n+    fn tag<F>(&mut self, tag_id: c::astencode_tag, f: F) where F: FnOnce(&mut Self);\n     fn id(&mut self, id: ast::NodeId);\n }\n \n impl<'a> write_tag_and_id for Encoder<'a> {\n-    fn tag(&mut self,\n-           tag_id: c::astencode_tag,\n-           f: |&mut Encoder<'a>|) {\n+    fn tag<F>(&mut self,\n+              tag_id: c::astencode_tag,\n+              f: F) where\n+        F: FnOnce(&mut Encoder<'a>),\n+    {\n         self.start_tag(tag_id as uint);\n         f(self);\n         self.end_tag();"}, {"sha": "a91ea8bfef8c77d93bd793ea0376c4b3fc054456", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -24,16 +24,22 @@ struct CheckCrateVisitor<'a, 'tcx: 'a> {\n }\n \n impl<'a, 'tcx> CheckCrateVisitor<'a, 'tcx> {\n-    fn with_const(&mut self, in_const: bool, f: |&mut CheckCrateVisitor<'a, 'tcx>|) {\n+    fn with_const<F>(&mut self, in_const: bool, f: F) where\n+        F: FnOnce(&mut CheckCrateVisitor<'a, 'tcx>),\n+    {\n         let was_const = self.in_const;\n         self.in_const = in_const;\n         f(self);\n         self.in_const = was_const;\n     }\n-    fn inside_const(&mut self, f: |&mut CheckCrateVisitor<'a, 'tcx>|) {\n+    fn inside_const<F>(&mut self, f: F) where\n+        F: FnOnce(&mut CheckCrateVisitor<'a, 'tcx>),\n+    {\n         self.with_const(true, f);\n     }\n-    fn outside_const(&mut self, f: |&mut CheckCrateVisitor<'a, 'tcx>|) {\n+    fn outside_const<F>(&mut self, f: F) where\n+        F: FnOnce(&mut CheckCrateVisitor<'a, 'tcx>),\n+    {\n         self.with_const(false, f);\n     }\n }"}, {"sha": "fee2d810fcb3dace18ad10917f3ddee04d83809d", "filename": "src/librustc/middle/check_loop.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -64,7 +64,9 @@ impl<'a, 'v> Visitor<'v> for CheckLoopVisitor<'a> {\n }\n \n impl<'a> CheckLoopVisitor<'a> {\n-    fn with_context(&mut self, cx: Context, f: |&mut CheckLoopVisitor<'a>|) {\n+    fn with_context<F>(&mut self, cx: Context, f: F) where\n+        F: FnOnce(&mut CheckLoopVisitor<'a>),\n+    {\n         let old_cx = self.cx;\n         self.cx = cx;\n         f(self);"}, {"sha": "ea3ef2af7390612b46020116e5f4d6020b0a959e", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -980,7 +980,9 @@ fn check_fn(cx: &mut MatchCheckCtxt,\n     }\n }\n \n-fn is_refutable<A>(cx: &MatchCheckCtxt, pat: &Pat, refutable: |&Pat| -> A) -> Option<A> {\n+fn is_refutable<A, F>(cx: &MatchCheckCtxt, pat: &Pat, refutable: F) -> Option<A> where\n+    F: FnOnce(&Pat) -> A,\n+{\n     let pats = Matrix(vec!(vec!(pat)));\n     match is_useful(cx, &pats, &[DUMMY_WILD_PAT], ConstructWitness) {\n         UsefulWithWitness(pats) => {"}, {"sha": "65412ff8effc96c5547f9213e409a51da80113de", "filename": "src/librustc/middle/check_static.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustc%2Fmiddle%2Fcheck_static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustc%2Fmiddle%2Fcheck_static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_static.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -85,7 +85,9 @@ pub fn check_crate(tcx: &ty::ctxt) {\n }\n \n impl<'a, 'tcx> CheckStaticVisitor<'a, 'tcx> {\n-    fn with_mode(&mut self, mode: Mode, f: |&mut CheckStaticVisitor<'a, 'tcx>|) {\n+    fn with_mode<F>(&mut self, mode: Mode, f: F) where\n+        F: FnOnce(&mut CheckStaticVisitor<'a, 'tcx>),\n+    {\n         let old = self.mode;\n         self.mode = mode;\n         f(self);"}, {"sha": "9373a5704b2b0b6401a9a2cf5c7725b0064d9732", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -280,10 +280,9 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n     }\n \n \n-    pub fn each_bit_on_entry(&self,\n-                             id: ast::NodeId,\n-                             f: |uint| -> bool)\n-                             -> bool {\n+    pub fn each_bit_on_entry<F>(&self, id: ast::NodeId, f: F) -> bool where\n+        F: FnMut(uint) -> bool,\n+    {\n         //! Iterates through each bit that is set on entry to `id`.\n         //! Only useful after `propagate()` has been called.\n         if !self.has_bitset_for_nodeid(id) {\n@@ -293,11 +292,9 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n         self.each_bit_for_node(Entry, cfgidx, f)\n     }\n \n-    pub fn each_bit_for_node(&self,\n-                             e: EntryOrExit,\n-                             cfgidx: CFGIndex,\n-                             f: |uint| -> bool)\n-                             -> bool {\n+    pub fn each_bit_for_node<F>(&self, e: EntryOrExit, cfgidx: CFGIndex, f: F) -> bool where\n+        F: FnMut(uint) -> bool,\n+    {\n         //! Iterates through each bit that is set on entry/exit to `cfgidx`.\n         //! Only useful after `propagate()` has been called.\n \n@@ -324,8 +321,9 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n         self.each_bit(slice, f)\n     }\n \n-    pub fn each_gen_bit(&self, id: ast::NodeId, f: |uint| -> bool)\n-                        -> bool {\n+    pub fn each_gen_bit<F>(&self, id: ast::NodeId, f: F) -> bool where\n+        F: FnMut(uint) -> bool,\n+    {\n         //! Iterates through each bit in the gen set for `id`.\n         if !self.has_bitset_for_nodeid(id) {\n             return true;\n@@ -345,7 +343,9 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n         self.each_bit(gens, f)\n     }\n \n-    fn each_bit(&self, words: &[uint], f: |uint| -> bool) -> bool {\n+    fn each_bit<F>(&self, words: &[uint], mut f: F) -> bool where\n+        F: FnMut(uint) -> bool,\n+    {\n         //! Helper for iterating over the bits in a bit set.\n         //! Returns false on the first call to `f` that returns false;\n         //! if all calls to `f` return true, then returns true."}, {"sha": "ca60ac45e266a8bafe98148a80e281fb01ff52eb", "filename": "src/librustc/middle/def.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustc%2Fmiddle%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustc%2Fmiddle%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdef.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -61,7 +61,9 @@ pub enum MethodProvenance {\n }\n \n impl MethodProvenance {\n-    pub fn map(self, f: |ast::DefId| -> ast::DefId) -> MethodProvenance {\n+    pub fn map<F>(self, f: F) -> MethodProvenance where\n+        F: FnOnce(ast::DefId) -> ast::DefId,\n+    {\n         match self {\n             FromTrait(did) => FromTrait(f(did)),\n             FromImpl(did) => FromImpl(f(did))"}, {"sha": "4c03ed2a480efd501949706acfdb706ee2884756", "filename": "src/librustc/middle/graph.rs", "status": "modified", "additions": 25, "deletions": 21, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustc%2Fmiddle%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustc%2Fmiddle%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fgraph.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -221,39 +221,43 @@ impl<N,E> Graph<N,E> {\n     ///////////////////////////////////////////////////////////////////////////\n     // Iterating over nodes, edges\n \n-    pub fn each_node<'a>(&'a self, f: |NodeIndex, &'a Node<N>| -> bool) -> bool {\n+    pub fn each_node<'a, F>(&'a self, mut f: F) -> bool where\n+        F: FnMut(NodeIndex, &'a Node<N>) -> bool,\n+    {\n         //! Iterates over all edges defined in the graph.\n         self.nodes.iter().enumerate().all(|(i, node)| f(NodeIndex(i), node))\n     }\n \n-    pub fn each_edge<'a>(&'a self, f: |EdgeIndex, &'a Edge<E>| -> bool) -> bool {\n+    pub fn each_edge<'a, F>(&'a self, mut f: F) -> bool where\n+        F: FnMut(EdgeIndex, &'a Edge<E>) -> bool,\n+    {\n         //! Iterates over all edges defined in the graph\n         self.edges.iter().enumerate().all(|(i, edge)| f(EdgeIndex(i), edge))\n     }\n \n-    pub fn each_outgoing_edge<'a>(&'a self,\n-                                  source: NodeIndex,\n-                                  f: |EdgeIndex, &'a Edge<E>| -> bool)\n-                                  -> bool {\n+    pub fn each_outgoing_edge<'a, F>(&'a self, source: NodeIndex, f: F) -> bool where\n+        F: FnMut(EdgeIndex, &'a Edge<E>) -> bool,\n+    {\n         //! Iterates over all outgoing edges from the node `from`\n \n         self.each_adjacent_edge(source, Outgoing, f)\n     }\n \n-    pub fn each_incoming_edge<'a>(&'a self,\n-                                  target: NodeIndex,\n-                                  f: |EdgeIndex, &'a Edge<E>| -> bool)\n-                                  -> bool {\n+    pub fn each_incoming_edge<'a, F>(&'a self, target: NodeIndex, f: F) -> bool where\n+        F: FnMut(EdgeIndex, &'a Edge<E>) -> bool,\n+    {\n         //! Iterates over all incoming edges to the node `target`\n \n         self.each_adjacent_edge(target, Incoming, f)\n     }\n \n-    pub fn each_adjacent_edge<'a>(&'a self,\n-                                  node: NodeIndex,\n-                                  dir: Direction,\n-                                  f: |EdgeIndex, &'a Edge<E>| -> bool)\n-                                  -> bool {\n+    pub fn each_adjacent_edge<'a, F>(&'a self,\n+                                     node: NodeIndex,\n+                                     dir: Direction,\n+                                     mut f: F)\n+                                     -> bool where\n+        F: FnMut(EdgeIndex, &'a Edge<E>) -> bool,\n+    {\n         //! Iterates over all edges adjacent to the node `node`\n         //! in the direction `dir` (either `Outgoing` or `Incoming)\n \n@@ -277,11 +281,9 @@ impl<N,E> Graph<N,E> {\n     // variables or other bitsets. This method facilitates such a\n     // computation.\n \n-    pub fn iterate_until_fixed_point<'a>(&'a self,\n-                                         op: |iter_index: uint,\n-                                              edge_index: EdgeIndex,\n-                                              edge: &'a Edge<E>|\n-                                              -> bool) {\n+    pub fn iterate_until_fixed_point<'a, F>(&'a self, mut op: F) where\n+        F: FnMut(uint, EdgeIndex, &'a Edge<E>) -> bool,\n+    {\n         let mut iteration = 0;\n         let mut changed = true;\n         while changed {\n@@ -294,7 +296,9 @@ impl<N,E> Graph<N,E> {\n     }\n }\n \n-pub fn each_edge_index(max_edge_index: EdgeIndex, f: |EdgeIndex| -> bool) {\n+pub fn each_edge_index<F>(max_edge_index: EdgeIndex, mut f: F) where\n+    F: FnMut(EdgeIndex) -> bool,\n+{\n     let mut i = 0;\n     let n = max_edge_index.get();\n     while i < n {"}, {"sha": "c6422b36e384d43a18cdf4de85cd418d665d47f8", "filename": "src/librustc/middle/infer/coercion.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustc%2Fmiddle%2Finfer%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustc%2Fmiddle%2Finfer%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fcoercion.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -194,8 +194,9 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         }\n     }\n \n-    pub fn unpack_actual_value<T>(&self, a: Ty<'tcx>, f: |&ty::sty<'tcx>| -> T)\n-                                  -> T {\n+    pub fn unpack_actual_value<T, F>(&self, a: Ty<'tcx>, f: F) -> T where\n+        F: FnOnce(&ty::sty<'tcx>) -> T,\n+    {\n         match resolve_type(self.get_ref().infcx, None,\n                            a, try_resolve_tvar_shallow) {\n             Ok(t) => {\n@@ -458,13 +459,15 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                            || AutoUnsafe(b_mutbl, None))\n     }\n \n-    fn coerce_object(&self,\n-                     a: Ty<'tcx>,\n-                     sty_a: &ty::sty<'tcx>,\n-                     b: Ty<'tcx>,\n-                     b_mutbl: ast::Mutability,\n-                     mk_ty: |Ty<'tcx>| -> Ty<'tcx>,\n-                     mk_adjust: || -> ty::AutoRef<'tcx>) -> CoerceResult<'tcx>\n+    fn coerce_object<F, G>(&self,\n+                           a: Ty<'tcx>,\n+                           sty_a: &ty::sty<'tcx>,\n+                           b: Ty<'tcx>,\n+                           b_mutbl: ast::Mutability,\n+                           mk_ty: F,\n+                           mk_adjust: G) -> CoerceResult<'tcx> where\n+        F: FnOnce(Ty<'tcx>) -> Ty<'tcx>,\n+        G: FnOnce() -> ty::AutoRef<'tcx>,\n     {\n         let tcx = self.get_ref().infcx.tcx;\n "}, {"sha": "be053afcca43660574a93cf6e75ae7ea13c416a4", "filename": "src/librustc/middle/infer/higher_ranked/mod.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -426,11 +426,9 @@ fn is_var_in_set(new_vars: &[ty::RegionVid], r: ty::Region) -> bool {\n     }\n }\n \n-fn fold_regions_in<'tcx, T>(tcx: &ty::ctxt<'tcx>,\n-                            value: &T,\n-                            fldr: |ty::Region, ty::DebruijnIndex| -> ty::Region)\n-                            -> T\n-    where T: HigherRankedFoldable<'tcx>\n+fn fold_regions_in<'tcx, T, F>(tcx: &ty::ctxt<'tcx>, value: &T, mut fldr: F) -> T where\n+    T: HigherRankedFoldable<'tcx>,\n+    F: FnMut(ty::Region, ty::DebruijnIndex) -> ty::Region,\n {\n     value.fold_contents(&mut ty_fold::RegionFolder::new(tcx, |region, current_depth| {\n         // we should only be encountering \"escaping\" late-bound regions here,"}, {"sha": "4c3b7589d76cbb59cc4c65e1005ea6954458f419", "filename": "src/librustc/middle/infer/mod.rs", "status": "modified", "additions": 52, "deletions": 32, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -477,14 +477,17 @@ pub fn resolve_region(cx: &InferCtxt, r: ty::Region, modes: uint)\n }\n \n trait then<'tcx> {\n-    fn then<T:Clone>(&self, f: || -> Result<T,ty::type_err<'tcx>>)\n-        -> Result<T,ty::type_err<'tcx>>;\n+    fn then<T, F>(&self, f: F) -> Result<T, ty::type_err<'tcx>> where\n+        T: Clone,\n+        F: FnOnce() -> Result<T, ty::type_err<'tcx>>;\n }\n \n impl<'tcx> then<'tcx> for ures<'tcx> {\n-    fn then<T:Clone>(&self, f: || -> Result<T,ty::type_err<'tcx>>)\n-        -> Result<T,ty::type_err<'tcx>> {\n-        self.and_then(|_i| f())\n+    fn then<T, F>(&self, f: F) -> Result<T, ty::type_err<'tcx>> where\n+        T: Clone,\n+        F: FnOnce() -> Result<T, ty::type_err<'tcx>>,\n+    {\n+        self.and_then(move |_| f())\n     }\n }\n \n@@ -502,12 +505,15 @@ impl<'tcx, T> ToUres<'tcx> for cres<'tcx, T> {\n }\n \n trait CresCompare<'tcx, T> {\n-    fn compare(&self, t: T, f: || -> ty::type_err<'tcx>) -> cres<'tcx, T>;\n+    fn compare<F>(&self, t: T, f: F) -> cres<'tcx, T> where\n+        F: FnOnce() -> ty::type_err<'tcx>;\n }\n \n impl<'tcx, T:Clone + PartialEq> CresCompare<'tcx, T> for cres<'tcx, T> {\n-    fn compare(&self, t: T, f: || -> ty::type_err<'tcx>) -> cres<'tcx, T> {\n-        (*self).clone().and_then(|s| {\n+    fn compare<F>(&self, t: T, f: F) -> cres<'tcx, T> where\n+        F: FnOnce() -> ty::type_err<'tcx>,\n+    {\n+        (*self).clone().and_then(move |s| {\n             if s == t {\n                 (*self).clone()\n             } else {\n@@ -616,7 +622,9 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     }\n \n     /// Execute `f` and commit the bindings\n-    pub fn commit_unconditionally<R>(&self, f: || -> R) -> R {\n+    pub fn commit_unconditionally<R, F>(&self, f: F) -> R where\n+        F: FnOnce() -> R,\n+    {\n         debug!(\"commit()\");\n         let snapshot = self.start_snapshot();\n         let r = f();\n@@ -625,12 +633,16 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     }\n \n     /// Execute `f` and commit the bindings if successful\n-    pub fn commit_if_ok<T,E>(&self, f: || -> Result<T,E>) -> Result<T,E> {\n-        self.commit_unconditionally(|| self.try(|| f()))\n+    pub fn commit_if_ok<T, E, F>(&self, f: F) -> Result<T, E> where\n+        F: FnOnce() -> Result<T, E>\n+    {\n+        self.commit_unconditionally(move || self.try(move || f()))\n     }\n \n     /// Execute `f`, unroll bindings on panic\n-    pub fn try<T,E>(&self, f: || -> Result<T,E>) -> Result<T,E> {\n+    pub fn try<T, E, F>(&self, f: F) -> Result<T, E> where\n+        F: FnOnce() -> Result<T, E>\n+    {\n         debug!(\"try()\");\n         let snapshot = self.start_snapshot();\n         let r = f();\n@@ -647,7 +659,9 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     }\n \n     /// Execute `f` then unroll any bindings it creates\n-    pub fn probe<R>(&self, f: || -> R) -> R {\n+    pub fn probe<R, F>(&self, f: F) -> R where\n+        F: FnOnce() -> R,\n+    {\n         debug!(\"probe()\");\n         let snapshot = self.start_snapshot();\n         let r = f();\n@@ -902,22 +916,24 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     // in this case. The typechecker should only ever report type errors involving mismatched\n     // types using one of these four methods, and should not call span_err directly for such\n     // errors.\n-    pub fn type_error_message_str(&self,\n-                                  sp: Span,\n-                                  mk_msg: |Option<String>, String| -> String,\n-                                  actual_ty: String,\n-                                  err: Option<&ty::type_err<'tcx>>) {\n+    pub fn type_error_message_str<M>(&self,\n+                                     sp: Span,\n+                                     mk_msg: M,\n+                                     actual_ty: String,\n+                                     err: Option<&ty::type_err<'tcx>>) where\n+        M: FnOnce(Option<String>, String) -> String,\n+    {\n         self.type_error_message_str_with_expected(sp, mk_msg, None, actual_ty, err)\n     }\n \n-    pub fn type_error_message_str_with_expected(&self,\n-                                                sp: Span,\n-                                                mk_msg: |Option<String>,\n-                                                         String|\n-                                                         -> String,\n-                                                expected_ty: Option<Ty<'tcx>>,\n-                                                actual_ty: String,\n-                                                err: Option<&ty::type_err<'tcx>>) {\n+    pub fn type_error_message_str_with_expected<M>(&self,\n+                                                   sp: Span,\n+                                                   mk_msg: M,\n+                                                   expected_ty: Option<Ty<'tcx>>,\n+                                                   actual_ty: String,\n+                                                   err: Option<&ty::type_err<'tcx>>) where\n+        M: FnOnce(Option<String>, String) -> String,\n+    {\n         debug!(\"hi! expected_ty = {}, actual_ty = {}\", expected_ty, actual_ty);\n \n         let resolved_expected = expected_ty.map(|e_ty| {\n@@ -942,19 +958,23 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         }\n     }\n \n-    pub fn type_error_message(&self,\n-                              sp: Span,\n-                              mk_msg: |String| -> String,\n-                              actual_ty: Ty<'tcx>,\n-                              err: Option<&ty::type_err<'tcx>>) {\n+    pub fn type_error_message<M>(&self,\n+                                 sp: Span,\n+                                 mk_msg: M,\n+                                 actual_ty: Ty<'tcx>,\n+                                 err: Option<&ty::type_err<'tcx>>) where\n+        M: FnOnce(String) -> String,\n+    {\n         let actual_ty = self.resolve_type_vars_if_possible(actual_ty);\n \n         // Don't report an error if actual type is ty_err.\n         if ty::type_is_error(actual_ty) {\n             return;\n         }\n \n-        self.type_error_message_str(sp, |_e, a| { mk_msg(a) }, self.ty_to_string(actual_ty), err);\n+        self.type_error_message_str(sp,\n+            move |_e, a| { mk_msg(a) },\n+            self.ty_to_string(actual_ty), err);\n     }\n \n     pub fn report_mismatched_types(&self,"}, {"sha": "98f69f66b27fc4536b91d96947e1db8dff1442c0", "filename": "src/librustc/middle/infer/region_inference/mod.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -569,15 +569,15 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         }\n     }\n \n-    pub fn combine_vars(&self,\n-                        t: CombineMapType,\n-                        a: Region,\n-                        b: Region,\n-                        origin: SubregionOrigin<'tcx>,\n-                        relate: |this: &RegionVarBindings<'a, 'tcx>,\n-                                 old_r: Region,\n-                                 new_r: Region|)\n-                        -> Region {\n+    pub fn combine_vars<F>(&self,\n+                           t: CombineMapType,\n+                           a: Region,\n+                           b: Region,\n+                           origin: SubregionOrigin<'tcx>,\n+                           mut relate: F)\n+                           -> Region where\n+        F: FnMut(&RegionVarBindings<'a, 'tcx>, Region, Region),\n+    {\n         let vars = TwoRegions { a: a, b: b };\n         match self.combine_map(t).borrow().get(&vars) {\n             Some(&c) => {\n@@ -1539,9 +1539,9 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         }\n     }\n \n-    fn iterate_until_fixed_point(&self,\n-                                 tag: &str,\n-                                 body: |constraint: &Constraint| -> bool) {\n+    fn iterate_until_fixed_point<F>(&self, tag: &str, mut body: F) where\n+        F: FnMut(&Constraint) -> bool,\n+    {\n         let mut iteration = 0u;\n         let mut changed = true;\n         while changed {"}, {"sha": "705b0ae730d498070c5b1374ee4ef068c9f9c6d5", "filename": "src/librustc/middle/infer/skolemize.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustc%2Fmiddle%2Finfer%2Fskolemize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustc%2Fmiddle%2Finfer%2Fskolemize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fskolemize.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -54,11 +54,12 @@ impl<'a, 'tcx> TypeSkolemizer<'a, 'tcx> {\n         }\n     }\n \n-    fn skolemize(&mut self,\n-                 opt_ty: Option<Ty<'tcx>>,\n-                 key: ty::InferTy,\n-                 skolemizer: |uint| -> ty::InferTy)\n-                 -> Ty<'tcx>\n+    fn skolemize<F>(&mut self,\n+                    opt_ty: Option<Ty<'tcx>>,\n+                    key: ty::InferTy,\n+                    skolemizer: F)\n+                    -> Ty<'tcx> where\n+        F: FnOnce(uint) -> ty::InferTy,\n     {\n         match opt_ty {\n             Some(ty) => { return ty.fold_with(self); }"}, {"sha": "271e903bbdf1761feff735b8715788f8e106faa5", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 24, "deletions": 20, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -616,19 +616,19 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         self.ir.variable(node_id, span)\n     }\n \n-    fn pat_bindings(&mut self,\n-                    pat: &ast::Pat,\n-                    f: |&mut Liveness<'a, 'tcx>, LiveNode, Variable, Span, NodeId|) {\n+    fn pat_bindings<F>(&mut self, pat: &ast::Pat, mut f: F) where\n+        F: FnMut(&mut Liveness<'a, 'tcx>, LiveNode, Variable, Span, NodeId),\n+    {\n         pat_util::pat_bindings(&self.ir.tcx.def_map, pat, |_bm, p_id, sp, _n| {\n             let ln = self.live_node(p_id, sp);\n             let var = self.variable(p_id, sp);\n             f(self, ln, var, sp, p_id);\n         })\n     }\n \n-    fn arm_pats_bindings(&mut self,\n-                         pat: Option<&ast::Pat>,\n-                         f: |&mut Liveness<'a, 'tcx>, LiveNode, Variable, Span, NodeId|) {\n+    fn arm_pats_bindings<F>(&mut self, pat: Option<&ast::Pat>, f: F) where\n+        F: FnMut(&mut Liveness<'a, 'tcx>, LiveNode, Variable, Span, NodeId),\n+    {\n         match pat {\n             Some(pat) => {\n                 self.pat_bindings(pat, f);\n@@ -691,21 +691,23 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         self.assigned_on_entry(successor, var)\n     }\n \n-    fn indices2(&mut self,\n-                ln: LiveNode,\n-                succ_ln: LiveNode,\n-                op: |&mut Liveness<'a, 'tcx>, uint, uint|) {\n+    fn indices2<F>(&mut self, ln: LiveNode, succ_ln: LiveNode, mut op: F) where\n+        F: FnMut(&mut Liveness<'a, 'tcx>, uint, uint),\n+    {\n         let node_base_idx = self.idx(ln, Variable(0u));\n         let succ_base_idx = self.idx(succ_ln, Variable(0u));\n         for var_idx in range(0u, self.ir.num_vars) {\n             op(self, node_base_idx + var_idx, succ_base_idx + var_idx);\n         }\n     }\n \n-    fn write_vars(&self,\n-                  wr: &mut io::Writer,\n-                  ln: LiveNode,\n-                  test: |uint| -> LiveNode) -> io::IoResult<()> {\n+    fn write_vars<F>(&self,\n+                     wr: &mut io::Writer,\n+                     ln: LiveNode,\n+                     mut test: F)\n+                     -> io::IoResult<()> where\n+        F: FnMut(uint) -> LiveNode,\n+    {\n         let node_base_idx = self.idx(ln, Variable(0));\n         for var_idx in range(0u, self.ir.num_vars) {\n             let idx = node_base_idx + var_idx;\n@@ -1408,12 +1410,14 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         cond_ln\n     }\n \n-    fn with_loop_nodes<R>(&mut self,\n-                          loop_node_id: NodeId,\n-                          break_ln: LiveNode,\n-                          cont_ln: LiveNode,\n-                          f: |&mut Liveness<'a, 'tcx>| -> R)\n-                          -> R {\n+    fn with_loop_nodes<R, F>(&mut self,\n+                             loop_node_id: NodeId,\n+                             break_ln: LiveNode,\n+                             cont_ln: LiveNode,\n+                             f: F)\n+                             -> R where\n+        F: FnOnce(&mut Liveness<'a, 'tcx>) -> R,\n+    {\n         debug!(\"with_loop_nodes: {} {}\", loop_node_id, break_ln.get());\n         self.loop_scope.push(loop_node_id);\n         self.break_ln.insert(loop_node_id, break_ln);"}, {"sha": "d96cf4495bdde95b0ab624606776aef7f0832531", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -1142,12 +1142,11 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n         })\n     }\n \n+    // FIXME(#19596) unbox `op`\n     pub fn cat_pattern(&self,\n                        cmt: cmt<'tcx>,\n                        pat: &ast::Pat,\n-                       op: |&MemCategorizationContext<'t,TYPER>,\n-                            cmt<'tcx>,\n-                            &ast::Pat|)\n+                       op: |&MemCategorizationContext<'t, TYPER>, cmt<'tcx>, &ast::Pat|)\n                        -> McResult<()> {\n         // Here, `cmt` is the categorization for the value being\n         // matched and pat is the pattern it is being matched against."}, {"sha": "8ef8e091c94858aeda905d049380ae50944c6c66", "filename": "src/librustc/middle/pat_util.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fpat_util.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -91,9 +91,9 @@ pub fn pat_is_binding_or_wild(dm: &resolve::DefMap, pat: &ast::Pat) -> bool {\n \n /// Call `it` on every \"binding\" in a pattern, e.g., on `a` in\n /// `match foo() { Some(a) => (), None => () }`\n-pub fn pat_bindings(dm: &resolve::DefMap,\n-                    pat: &ast::Pat,\n-                    it: |ast::BindingMode, ast::NodeId, Span, &ast::SpannedIdent|) {\n+pub fn pat_bindings<I>(dm: &resolve::DefMap, pat: &ast::Pat, mut it: I) where\n+    I: FnMut(ast::BindingMode, ast::NodeId, Span, &ast::SpannedIdent),\n+{\n     walk_pat(pat, |p| {\n         match p.node {\n           ast::PatIdent(binding_mode, ref pth, _) if pat_is_binding(dm, p) => {"}, {"sha": "390729df0125d1ba7a5241354e5a5114f7dd5e9a", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -62,7 +62,9 @@ impl CodeExtent {\n \n     /// Maps this scope to a potentially new one according to the\n     /// NodeId transformer `f_id`.\n-    pub fn map_id(&self, f_id: |ast::NodeId| -> ast::NodeId) -> CodeExtent {\n+    pub fn map_id<F>(&self, f_id: F) -> CodeExtent where\n+        F: FnOnce(ast::NodeId) -> ast::NodeId,\n+    {\n         match *self {\n             CodeExtent::Misc(node_id) => CodeExtent::Misc(f_id(node_id)),\n         }"}, {"sha": "85e0c9294a6baeb87294dc5f26a3252945dad165", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 29, "deletions": 15, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -1837,10 +1837,12 @@ impl<'a> Resolver<'a> {\n     }\n \n     /// Constructs the reduced graph for one foreign item.\n-    fn build_reduced_graph_for_foreign_item(&mut self,\n-                                            foreign_item: &ForeignItem,\n-                                            parent: ReducedGraphParent,\n-                                            f: |&mut Resolver|) {\n+    fn build_reduced_graph_for_foreign_item<F>(&mut self,\n+                                               foreign_item: &ForeignItem,\n+                                               parent: ReducedGraphParent,\n+                                               f: F) where\n+        F: FnOnce(&mut Resolver),\n+    {\n         let name = foreign_item.ident.name;\n         let is_public = foreign_item.vis == ast::Public;\n         let modifiers = if is_public { PUBLIC } else { DefModifiers::empty() } | IMPORTABLE;\n@@ -3970,7 +3972,9 @@ impl<'a> Resolver<'a> {\n     // generate a fake \"implementation scope\" containing all the\n     // implementations thus found, for compatibility with old resolve pass.\n \n-    fn with_scope(&mut self, name: Option<Name>, f: |&mut Resolver|) {\n+    fn with_scope<F>(&mut self, name: Option<Name>, f: F) where\n+        F: FnOnce(&mut Resolver),\n+    {\n         let orig_module = self.current_module.clone();\n \n         // Move down in the graph.\n@@ -4373,9 +4377,9 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n-    fn with_type_parameter_rib(&mut self,\n-                               type_parameters: TypeParameters,\n-                               f: |&mut Resolver|) {\n+    fn with_type_parameter_rib<F>(&mut self, type_parameters: TypeParameters, f: F) where\n+        F: FnOnce(&mut Resolver),\n+    {\n         match type_parameters {\n             HasTypeParameters(generics, space, node_id, rib_kind) => {\n                 let mut function_type_rib = Rib::new(rib_kind);\n@@ -4422,13 +4426,17 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n-    fn with_label_rib(&mut self, f: |&mut Resolver|) {\n+    fn with_label_rib<F>(&mut self, f: F) where\n+        F: FnOnce(&mut Resolver),\n+    {\n         self.label_ribs.push(Rib::new(NormalRibKind));\n         f(self);\n         self.label_ribs.pop();\n     }\n \n-    fn with_constant_rib(&mut self, f: |&mut Resolver|) {\n+    fn with_constant_rib<F>(&mut self, f: F) where\n+        F: FnOnce(&mut Resolver),\n+    {\n         self.value_ribs.push(Rib::new(ConstantItemRibKind));\n         self.type_ribs.push(Rib::new(ConstantItemRibKind));\n         f(self);\n@@ -4676,17 +4684,21 @@ impl<'a> Resolver<'a> {\n                               method.pe_body());\n     }\n \n-    fn with_current_self_type<T>(&mut self, self_type: &Ty, f: |&mut Resolver| -> T) -> T {\n+    fn with_current_self_type<T, F>(&mut self, self_type: &Ty, f: F) -> T where\n+        F: FnOnce(&mut Resolver) -> T,\n+    {\n         // Handle nested impls (inside fn bodies)\n         let previous_value = replace(&mut self.current_self_type, Some(self_type.clone()));\n         let result = f(self);\n         self.current_self_type = previous_value;\n         result\n     }\n \n-    fn with_optional_trait_ref<T>(&mut self, id: NodeId,\n-                                  opt_trait_ref: &Option<TraitRef>,\n-                                  f: |&mut Resolver| -> T) -> T {\n+    fn with_optional_trait_ref<T, F>(&mut self, id: NodeId,\n+                                     opt_trait_ref: &Option<TraitRef>,\n+                                     f: F) -> T where\n+        F: FnOnce(&mut Resolver) -> T,\n+    {\n         let new_val = match *opt_trait_ref {\n             Some(ref trait_ref) => {\n                 self.resolve_trait_reference(id, trait_ref, TraitImplementation);\n@@ -5620,7 +5632,9 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n-    fn with_no_errors<T>(&mut self, f: |&mut Resolver| -> T) -> T {\n+    fn with_no_errors<T, F>(&mut self, f: F) -> T where\n+        F: FnOnce(&mut Resolver) -> T,\n+    {\n         self.emit_errors = false;\n         let rs = f(self);\n         self.emit_errors = true;"}, {"sha": "83332d275ce99ab19a1e27cea656c268dbbce739", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -247,7 +247,9 @@ impl<'a, 'v> Visitor<'v> for LifetimeContext<'a> {\n }\n \n impl<'a> LifetimeContext<'a> {\n-    fn with(&mut self, wrap_scope: ScopeChain, f: |&mut LifetimeContext|) {\n+    fn with<F>(&mut self, wrap_scope: ScopeChain, f: F) where\n+        F: FnOnce(&mut LifetimeContext),\n+    {\n         let LifetimeContext {sess, ref mut named_region_map, ..} = *self;\n         let mut this = LifetimeContext {\n             sess: sess,\n@@ -278,10 +280,12 @@ impl<'a> LifetimeContext<'a> {\n     /// already in scope (for a fn item, that will be 0, but for a method it might not be). Late\n     /// bound lifetimes are resolved by name and associated with a binder id (`binder_id`), so the\n     /// ordering is not important there.\n-    fn visit_early_late(&mut self,\n-                        early_space: subst::ParamSpace,\n-                        generics: &ast::Generics,\n-                        walk: |&mut LifetimeContext|) {\n+    fn visit_early_late<F>(&mut self,\n+                           early_space: subst::ParamSpace,\n+                           generics: &ast::Generics,\n+                           walk: F) where\n+        F: FnOnce(&mut LifetimeContext),\n+    {\n         let referenced_idents = early_bound_lifetime_names(generics);\n \n         debug!(\"visit_early_late: referenced_idents={}\",\n@@ -290,8 +294,8 @@ impl<'a> LifetimeContext<'a> {\n         let (early, late) = generics.lifetimes.clone().partition(\n             |l| referenced_idents.iter().any(|&i| i == l.lifetime.name));\n \n-        self.with(EarlyScope(early_space, &early, self.scope), |this| {\n-            this.with(LateScope(&late, this.scope), |this| {\n+        self.with(EarlyScope(early_space, &early, self.scope), move |this| {\n+            this.with(LateScope(&late, this.scope), move |this| {\n                 this.check_lifetime_defs(&generics.lifetimes);\n                 walk(this);\n             });"}, {"sha": "ca8029fdfca3b418babf952d150a6c8c9d97343b", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -43,7 +43,9 @@ struct Annotator {\n impl Annotator {\n     // Determine the stability for a node based on its attributes and inherited\n     // stability. The stability is recorded in the index and used as the parent.\n-    fn annotate(&mut self, id: NodeId, attrs: &Vec<Attribute>, f: |&mut Annotator|) {\n+    fn annotate<F>(&mut self, id: NodeId, attrs: &Vec<Attribute>, f: F) where\n+        F: FnOnce(&mut Annotator),\n+    {\n         match attr::find_stability(attrs.as_slice()) {\n             Some(stab) => {\n                 self.index.local.insert(id, stab.clone());"}, {"sha": "2098aa3db533af673ae4f31110b4c1ca0f766e15", "filename": "src/librustc/middle/subst.rs", "status": "modified", "additions": 15, "deletions": 10, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsubst.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -167,10 +167,9 @@ impl<'tcx> Substs<'tcx> {\n }\n \n impl RegionSubsts {\n-    fn map<A>(self,\n-              a: A,\n-              op: |VecPerParamSpace<ty::Region>, A| -> VecPerParamSpace<ty::Region>)\n-              -> RegionSubsts {\n+    fn map<A, F>(self, a: A, op: F) -> RegionSubsts where\n+        F: FnOnce(VecPerParamSpace<ty::Region>, A) -> VecPerParamSpace<ty::Region>,\n+    {\n         match self {\n             ErasedRegions => ErasedRegions,\n             NonerasedRegions(r) => NonerasedRegions(op(r, a))\n@@ -415,40 +414,46 @@ impl<T> VecPerParamSpace<T> {\n         self.content.as_slice()\n     }\n \n-    pub fn all_vecs(&self, pred: |&[T]| -> bool) -> bool {\n+    pub fn all_vecs<P>(&self, mut pred: P) -> bool where\n+        P: FnMut(&[T]) -> bool,\n+    {\n         let spaces = [TypeSpace, SelfSpace, FnSpace];\n         spaces.iter().all(|&space| { pred(self.get_slice(space)) })\n     }\n \n-    pub fn all(&self, pred: |&T| -> bool) -> bool {\n+    pub fn all<P>(&self, pred: P) -> bool where P: FnMut(&T) -> bool {\n         self.iter().all(pred)\n     }\n \n-    pub fn any(&self, pred: |&T| -> bool) -> bool {\n+    pub fn any<P>(&self, pred: P) -> bool where P: FnMut(&T) -> bool {\n         self.iter().any(pred)\n     }\n \n     pub fn is_empty(&self) -> bool {\n         self.all_vecs(|v| v.is_empty())\n     }\n \n-    pub fn map<U>(&self, pred: |&T| -> U) -> VecPerParamSpace<U> {\n+    pub fn map<U, P>(&self, pred: P) -> VecPerParamSpace<U> where P: FnMut(&T) -> U {\n         let result = self.iter().map(pred).collect();\n         VecPerParamSpace::new_internal(result,\n                                        self.type_limit,\n                                        self.self_limit,\n                                        self.assoc_limit)\n     }\n \n-    pub fn map_enumerated<U>(&self, pred: |(ParamSpace, uint, &T)| -> U) -> VecPerParamSpace<U> {\n+    pub fn map_enumerated<U, P>(&self, pred: P) -> VecPerParamSpace<U> where\n+        P: FnMut((ParamSpace, uint, &T)) -> U,\n+    {\n         let result = self.iter_enumerated().map(pred).collect();\n         VecPerParamSpace::new_internal(result,\n                                        self.type_limit,\n                                        self.self_limit,\n                                        self.assoc_limit)\n     }\n \n-    pub fn map_move<U>(self, pred: |T| -> U) -> VecPerParamSpace<U> {\n+    pub fn map_move<U, F>(self, mut pred: F) -> VecPerParamSpace<U> where\n+        F: FnMut(T) -> U,\n+    {\n         let SeparateVecsPerParamSpace {\n             types: t,\n             selfs: s,"}, {"sha": "936304c5eb483d980ad1b0c3d5ee6c2047c05167", "filename": "src/librustc/middle/traits/mod.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -312,7 +312,7 @@ impl<'tcx, N> Vtable<'tcx, N> {\n         }\n     }\n \n-    pub fn map_nested<M>(&self, op: |&N| -> M) -> Vtable<'tcx, M> {\n+    pub fn map_nested<M, F>(&self, op: F) -> Vtable<'tcx, M> where F: FnMut(&N) -> M {\n         match *self {\n             VtableImpl(ref i) => VtableImpl(i.map_nested(op)),\n             VtableFnPointer(ref sig) => VtableFnPointer((*sig).clone()),\n@@ -322,7 +322,9 @@ impl<'tcx, N> Vtable<'tcx, N> {\n         }\n     }\n \n-    pub fn map_move_nested<M>(self, op: |N| -> M) -> Vtable<'tcx, M> {\n+    pub fn map_move_nested<M, F>(self, op: F) -> Vtable<'tcx, M> where\n+        F: FnMut(N) -> M,\n+    {\n         match self {\n             VtableImpl(i) => VtableImpl(i.map_move_nested(op)),\n             VtableFnPointer(sig) => VtableFnPointer(sig),\n@@ -338,9 +340,8 @@ impl<'tcx, N> VtableImplData<'tcx, N> {\n         self.nested.iter()\n     }\n \n-    pub fn map_nested<M>(&self,\n-                         op: |&N| -> M)\n-                         -> VtableImplData<'tcx, M>\n+    pub fn map_nested<M, F>(&self, op: F) -> VtableImplData<'tcx, M> where\n+        F: FnMut(&N) -> M,\n     {\n         VtableImplData {\n             impl_def_id: self.impl_def_id,\n@@ -349,8 +350,9 @@ impl<'tcx, N> VtableImplData<'tcx, N> {\n         }\n     }\n \n-    pub fn map_move_nested<M>(self, op: |N| -> M)\n-                              -> VtableImplData<'tcx, M> {\n+    pub fn map_move_nested<M, F>(self, op: F) -> VtableImplData<'tcx, M> where\n+        F: FnMut(N) -> M,\n+    {\n         let VtableImplData { impl_def_id, substs, nested } = self;\n         VtableImplData {\n             impl_def_id: impl_def_id,\n@@ -365,16 +367,15 @@ impl<N> VtableBuiltinData<N> {\n         self.nested.iter()\n     }\n \n-    pub fn map_nested<M>(&self,\n-                         op: |&N| -> M)\n-                         -> VtableBuiltinData<M>\n-    {\n+    pub fn map_nested<M, F>(&self, op: F) -> VtableBuiltinData<M> where F: FnMut(&N) -> M {\n         VtableBuiltinData {\n             nested: self.nested.map(op)\n         }\n     }\n \n-    pub fn map_move_nested<M>(self, op: |N| -> M) -> VtableBuiltinData<M> {\n+    pub fn map_move_nested<M, F>(self, op: F) -> VtableBuiltinData<M> where\n+        F: FnMut(N) -> M,\n+    {\n         VtableBuiltinData {\n             nested: self.nested.map_move(op)\n         }"}, {"sha": "d8956246d326fd41e989bf3c9dafbc8c6b8283ee", "filename": "src/librustc/middle/traits/util.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -306,10 +306,11 @@ pub fn predicate_for_builtin_bound<'tcx>(\n /// of caller obligations), search through the trait and supertraits to find one where `test(d)` is\n /// true, where `d` is the def-id of the trait/supertrait. If any is found, return `Some(p)` where\n /// `p` is the path to that trait/supertrait. Else `None`.\n-pub fn search_trait_and_supertraits_from_bound<'tcx>(tcx: &ty::ctxt<'tcx>,\n-                                                     caller_bound: Rc<ty::TraitRef<'tcx>>,\n-                                                     test: |ast::DefId| -> bool)\n-                                                     -> Option<VtableParamData<'tcx>>\n+pub fn search_trait_and_supertraits_from_bound<'tcx, F>(tcx: &ty::ctxt<'tcx>,\n+                                                        caller_bound: Rc<ty::TraitRef<'tcx>>,\n+                                                        mut test: F)\n+                                                        -> Option<VtableParamData<'tcx>> where\n+    F: FnMut(ast::DefId) -> bool,\n {\n     for bound in transitive_bounds(tcx, &[caller_bound]) {\n         if test(bound.def_id) {"}, {"sha": "8e99045cffb5831f57978fa9123054ece46ec870", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 53, "deletions": 33, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -2420,10 +2420,13 @@ pub fn mk_param_from_def<'tcx>(cx: &ctxt<'tcx>, def: &TypeParameterDef) -> Ty<'t\n \n pub fn mk_open<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> Ty<'tcx> { mk_t(cx, ty_open(ty)) }\n \n-pub fn walk_ty<'tcx>(ty: Ty<'tcx>, f: |Ty<'tcx>|) {\n+pub fn walk_ty<'tcx, F>(ty: Ty<'tcx>, mut f: F) where\n+    F: FnMut(Ty<'tcx>),\n+{\n     maybe_walk_ty(ty, |ty| { f(ty); true });\n }\n \n+// FIXME(#19596) unbox `f`\n pub fn maybe_walk_ty<'tcx>(ty: Ty<'tcx>, f: |Ty<'tcx>| -> bool) {\n     if !f(ty) {\n         return;\n@@ -2464,9 +2467,11 @@ pub fn maybe_walk_ty<'tcx>(ty: Ty<'tcx>, f: |Ty<'tcx>| -> bool) {\n }\n \n // Folds types from the bottom up.\n-pub fn fold_ty<'tcx>(cx: &ctxt<'tcx>, t0: Ty<'tcx>,\n-                     fldop: |Ty<'tcx>| -> Ty<'tcx>)\n-                     -> Ty<'tcx> {\n+pub fn fold_ty<'tcx, F>(cx: &ctxt<'tcx>, t0: Ty<'tcx>,\n+                        fldop: F)\n+                        -> Ty<'tcx> where\n+    F: FnMut(Ty<'tcx>) -> Ty<'tcx>,\n+{\n     let mut f = ty_fold::BottomUpFolder {tcx: cx, fldop: fldop};\n     f.fold_ty(t0)\n }\n@@ -2843,7 +2848,9 @@ impl TypeContents {\n         *self & TC::ReachesAll\n     }\n \n-    pub fn union<T>(v: &[T], f: |&T| -> TypeContents) -> TypeContents {\n+    pub fn union<T, F>(v: &[T], mut f: F) -> TypeContents where\n+        F: FnMut(&T) -> TypeContents,\n+    {\n         v.iter().fold(TC::None, |tc, ty| tc | f(ty))\n     }\n \n@@ -3162,10 +3169,12 @@ pub fn type_contents<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> TypeContents {\n \n         // Iterates over all builtin bounds on the type parameter def, including\n         // those inherited from traits with builtin-kind-supertraits.\n-        fn each_inherited_builtin_bound<'tcx>(cx: &ctxt<'tcx>,\n-                                              bounds: BuiltinBounds,\n-                                              traits: &[Rc<TraitRef<'tcx>>],\n-                                              f: |BuiltinBound|) {\n+        fn each_inherited_builtin_bound<'tcx, F>(cx: &ctxt<'tcx>,\n+                                                 bounds: BuiltinBounds,\n+                                                 traits: &[Rc<TraitRef<'tcx>>],\n+                                                 mut f: F) where\n+            F: FnMut(BuiltinBound),\n+        {\n             for bound in bounds.iter() {\n                 f(bound);\n             }\n@@ -3959,14 +3968,15 @@ pub fn local_var_name_str(cx: &ctxt, id: NodeId) -> InternedString {\n }\n \n /// See `expr_ty_adjusted`\n-pub fn adjust_ty<'tcx>(cx: &ctxt<'tcx>,\n-                       span: Span,\n-                       expr_id: ast::NodeId,\n-                       unadjusted_ty: Ty<'tcx>,\n-                       adjustment: Option<&AutoAdjustment<'tcx>>,\n-                       method_type: |MethodCall| -> Option<Ty<'tcx>>)\n-                       -> Ty<'tcx> {\n-\n+pub fn adjust_ty<'tcx, F>(cx: &ctxt<'tcx>,\n+                          span: Span,\n+                          expr_id: ast::NodeId,\n+                          unadjusted_ty: Ty<'tcx>,\n+                          adjustment: Option<&AutoAdjustment<'tcx>>,\n+                          mut method_type: F)\n+                          -> Ty<'tcx> where\n+    F: FnMut(MethodCall) -> Option<Ty<'tcx>>,\n+{\n     if let ty_err = unadjusted_ty.sty {\n         return unadjusted_ty;\n     }\n@@ -4604,11 +4614,13 @@ pub fn provided_trait_methods<'tcx>(cx: &ctxt<'tcx>, id: ast::DefId)\n /// id is local, it should have been loaded into the map by the `typeck::collect` phase.  If the\n /// def-id is external, then we have to go consult the crate loading code (and cache the result for\n /// the future).\n-fn lookup_locally_or_in_crate_store<V:Clone>(\n-                                    descr: &str,\n-                                    def_id: ast::DefId,\n-                                    map: &mut DefIdMap<V>,\n-                                    load_external: || -> V) -> V {\n+fn lookup_locally_or_in_crate_store<V, F>(descr: &str,\n+                                          def_id: ast::DefId,\n+                                          map: &mut DefIdMap<V>,\n+                                          load_external: F) -> V where\n+    V: Clone,\n+    F: FnOnce() -> V,\n+{\n     match map.get(&def_id).cloned() {\n         Some(v) => { return v; }\n         None => { }\n@@ -4916,7 +4928,9 @@ pub fn has_dtor(cx: &ctxt, struct_id: DefId) -> bool {\n     cx.destructor_for_type.borrow().contains_key(&struct_id)\n }\n \n-pub fn with_path<T>(cx: &ctxt, id: ast::DefId, f: |ast_map::PathElems| -> T) -> T {\n+pub fn with_path<T, F>(cx: &ctxt, id: ast::DefId, f: F) -> T where\n+    F: FnOnce(ast_map::PathElems) -> T,\n+{\n     if id.krate == ast::LOCAL_CRATE {\n         cx.map.with_path(id.node, f)\n     } else {\n@@ -5162,7 +5176,9 @@ pub fn predicates<'tcx>(\n /// Iterate over attributes of a definition.\n // (This should really be an iterator, but that would require csearch and\n // decoder to use iterators instead of higher-order functions.)\n-pub fn each_attr(tcx: &ctxt, did: DefId, f: |&ast::Attribute| -> bool) -> bool {\n+pub fn each_attr<F>(tcx: &ctxt, did: DefId, mut f: F) -> bool where\n+    F: FnMut(&ast::Attribute) -> bool,\n+{\n     if is_local(did) {\n         let item = tcx.map.expect_item(did.node);\n         item.attrs.iter().all(|attr| f(attr))\n@@ -5501,10 +5517,11 @@ pub fn eval_repeat_count(tcx: &ctxt, count_expr: &ast::Expr) -> uint {\n // Here, the supertraits are the transitive closure of the supertrait\n // relation on the supertraits from each bounded trait's constraint\n // list.\n-pub fn each_bound_trait_and_supertraits<'tcx>(tcx: &ctxt<'tcx>,\n-                                              bounds: &[Rc<TraitRef<'tcx>>],\n-                                              f: |Rc<TraitRef<'tcx>>| -> bool)\n-                                              -> bool\n+pub fn each_bound_trait_and_supertraits<'tcx, F>(tcx: &ctxt<'tcx>,\n+                                                 bounds: &[Rc<TraitRef<'tcx>>],\n+                                                 mut f: F)\n+                                                 -> bool where\n+    F: FnMut(Rc<TraitRef<'tcx>>) -> bool,\n {\n     for bound_trait_ref in traits::transitive_bounds(tcx, bounds) {\n         if !f(bound_trait_ref) {\n@@ -6192,7 +6209,9 @@ pub type FreevarMap = NodeMap<Vec<Freevar>>;\n \n pub type CaptureModeMap = NodeMap<ast::CaptureClause>;\n \n-pub fn with_freevars<T>(tcx: &ty::ctxt, fid: ast::NodeId, f: |&[Freevar]| -> T) -> T {\n+pub fn with_freevars<T, F>(tcx: &ty::ctxt, fid: ast::NodeId, f: F) -> T where\n+    F: FnOnce(&[Freevar]) -> T,\n+{\n     match tcx.freevars.borrow().get(&fid) {\n         None => f(&[]),\n         Some(d) => f(d.as_slice())\n@@ -6240,12 +6259,13 @@ pub fn erase_late_bound_regions<'tcx, HR>(\n }\n \n /// Replaces the late-bound-regions in `value` that are bound by `value`.\n-pub fn replace_late_bound_regions<'tcx, HR>(\n+pub fn replace_late_bound_regions<'tcx, HR, F>(\n     tcx: &ty::ctxt<'tcx>,\n     value: &HR,\n-    mapf: |BoundRegion, DebruijnIndex| -> ty::Region)\n-    -> (HR, FnvHashMap<ty::BoundRegion,ty::Region>)\n-    where HR : HigherRankedFoldable<'tcx>\n+    mut mapf: F)\n+-> (HR, FnvHashMap<ty::BoundRegion, ty::Region>) where\n+    HR : HigherRankedFoldable<'tcx>,\n+    F: FnMut(BoundRegion, DebruijnIndex) -> ty::Region,\n {\n     debug!(\"replace_late_bound_regions({})\", value.repr(tcx));\n "}, {"sha": "63ee71dc6a51a26510611f7579eba2035b823e6b", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -743,12 +743,14 @@ impl<'tcx, T:HigherRankedFoldable<'tcx>> HigherRankedFoldable<'tcx> for Rc<T> {\n ///////////////////////////////////////////////////////////////////////////\n // Some sample folders\n \n-pub struct BottomUpFolder<'a, 'tcx: 'a> {\n+pub struct BottomUpFolder<'a, 'tcx: 'a, F> where F: FnMut(Ty<'tcx>) -> Ty<'tcx> {\n     pub tcx: &'a ty::ctxt<'tcx>,\n-    pub fldop: |Ty<'tcx>|: 'a -> Ty<'tcx>,\n+    pub fldop: F,\n }\n \n-impl<'a, 'tcx> TypeFolder<'tcx> for BottomUpFolder<'a, 'tcx> {\n+impl<'a, 'tcx, F> TypeFolder<'tcx> for BottomUpFolder<'a, 'tcx, F> where\n+    F: FnMut(Ty<'tcx>) -> Ty<'tcx>,\n+{\n     fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx> { self.tcx }\n \n     fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n@@ -772,15 +774,14 @@ impl<'a, 'tcx> TypeFolder<'tcx> for BottomUpFolder<'a, 'tcx> {\n /// (The distinction between \"free\" and \"bound\" is represented by\n /// keeping track of each `FnSig` in the lexical context of the\n /// current position of the fold.)\n-pub struct RegionFolder<'a, 'tcx: 'a> {\n+pub struct RegionFolder<'a, 'tcx: 'a, F> where F: FnMut(ty::Region, uint) -> ty::Region {\n     tcx: &'a ty::ctxt<'tcx>,\n     current_depth: uint,\n-    fld_r: |ty::Region, uint|: 'a -> ty::Region,\n+    fld_r: F,\n }\n \n-impl<'a, 'tcx> RegionFolder<'a, 'tcx> {\n-    pub fn new(tcx: &'a ty::ctxt<'tcx>, fld_r: |ty::Region, uint|: 'a -> ty::Region)\n-               -> RegionFolder<'a, 'tcx> {\n+impl<'a, 'tcx, F> RegionFolder<'a, 'tcx, F> where F: FnMut(ty::Region, uint) -> ty::Region {\n+    pub fn new(tcx: &'a ty::ctxt<'tcx>, fld_r: F) -> RegionFolder<'a, 'tcx, F> {\n         RegionFolder {\n             tcx: tcx,\n             current_depth: 1,\n@@ -789,7 +790,9 @@ impl<'a, 'tcx> RegionFolder<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> TypeFolder<'tcx> for RegionFolder<'a, 'tcx> {\n+impl<'a, 'tcx, F> TypeFolder<'tcx> for RegionFolder<'a, 'tcx, F> where\n+    F: FnMut(ty::Region, uint) -> ty::Region,\n+{\n     fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx> { self.tcx }\n \n     fn enter_region_binder(&mut self) {"}, {"sha": "8516ece202c7598edd331e8ef3334879c891177f", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -288,7 +288,9 @@ pub fn build_session_(sopts: config::Options,\n }\n \n // Seems out of place, but it uses session, so I'm putting it here\n-pub fn expect<T>(sess: &Session, opt: Option<T>, msg: || -> String) -> T {\n+pub fn expect<T, M>(sess: &Session, opt: Option<T>, msg: M) -> T where\n+    M: FnOnce() -> String,\n+{\n     diagnostic::expect(sess.diagnostic(), opt, msg)\n }\n "}, {"sha": "51e18c80d0584dbd94508d8d5cfdcd5f8e91a184", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 28, "deletions": 18, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -27,7 +27,9 @@ pub struct ErrorReported;\n \n impl Copy for ErrorReported {}\n \n-pub fn time<T, U>(do_it: bool, what: &str, u: U, f: |U| -> T) -> T {\n+pub fn time<T, U, F>(do_it: bool, what: &str, u: U, f: F) -> T where\n+    F: FnOnce(U) -> T,\n+{\n     thread_local!(static DEPTH: Cell<uint> = Cell::new(0));\n     if !do_it { return f(u); }\n \n@@ -39,9 +41,13 @@ pub fn time<T, U>(do_it: bool, what: &str, u: U, f: |U| -> T) -> T {\n \n     let mut u = Some(u);\n     let mut rv = None;\n-    let dur = Duration::span(|| {\n-        rv = Some(f(u.take().unwrap()))\n-    });\n+    let dur = {\n+        let ref mut rvp = rv;\n+\n+        Duration::span(move || {\n+            *rvp = Some(f(u.take().unwrap()))\n+        })\n+    };\n     let rv = rv.unwrap();\n \n     println!(\"{}time: {}.{:03} \\t{}\", \"  \".repeat(old),\n@@ -51,7 +57,10 @@ pub fn time<T, U>(do_it: bool, what: &str, u: U, f: |U| -> T) -> T {\n     rv\n }\n \n-pub fn indent<R: Show>(op: || -> R) -> R {\n+pub fn indent<R, F>(op: F) -> R where\n+    R: Show,\n+    F: FnOnce() -> R,\n+{\n     // Use in conjunction with the log post-processor like `src/etc/indenter`\n     // to make debug output more readable.\n     debug!(\">>\");\n@@ -73,12 +82,12 @@ pub fn indenter() -> Indenter {\n     Indenter { _cannot_construct_outside_of_this_module: () }\n }\n \n-struct LoopQueryVisitor<'a> {\n-    p: |&ast::Expr_|: 'a -> bool,\n+struct LoopQueryVisitor<P> where P: FnMut(&ast::Expr_) -> bool {\n+    p: P,\n     flag: bool,\n }\n \n-impl<'a, 'v> Visitor<'v> for LoopQueryVisitor<'a> {\n+impl<'v, P> Visitor<'v> for LoopQueryVisitor<P> where P: FnMut(&ast::Expr_) -> bool {\n     fn visit_expr(&mut self, e: &ast::Expr) {\n         self.flag |= (self.p)(&e.node);\n         match e.node {\n@@ -92,7 +101,7 @@ impl<'a, 'v> Visitor<'v> for LoopQueryVisitor<'a> {\n \n // Takes a predicate p, returns true iff p is true for any subexpressions\n // of b -- skipping any inner loops (loop, while, loop_body)\n-pub fn loop_query(b: &ast::Block, p: |&ast::Expr_| -> bool) -> bool {\n+pub fn loop_query<P>(b: &ast::Block, p: P) -> bool where P: FnMut(&ast::Expr_) -> bool {\n     let mut v = LoopQueryVisitor {\n         p: p,\n         flag: false,\n@@ -101,12 +110,12 @@ pub fn loop_query(b: &ast::Block, p: |&ast::Expr_| -> bool) -> bool {\n     return v.flag;\n }\n \n-struct BlockQueryVisitor<'a> {\n-    p: |&ast::Expr|: 'a -> bool,\n+struct BlockQueryVisitor<P> where P: FnMut(&ast::Expr) -> bool {\n+    p: P,\n     flag: bool,\n }\n \n-impl<'a, 'v> Visitor<'v> for BlockQueryVisitor<'a> {\n+impl<'v, P> Visitor<'v> for BlockQueryVisitor<P> where P: FnMut(&ast::Expr) -> bool {\n     fn visit_expr(&mut self, e: &ast::Expr) {\n         self.flag |= (self.p)(e);\n         visit::walk_expr(self, e)\n@@ -115,7 +124,7 @@ impl<'a, 'v> Visitor<'v> for BlockQueryVisitor<'a> {\n \n // Takes a predicate p, returns true iff p is true for any subexpressions\n // of b -- skipping any inner loops (loop, while, loop_body)\n-pub fn block_query(b: &ast::Block, p: |&ast::Expr| -> bool) -> bool {\n+pub fn block_query<P>(b: &ast::Block, p: P) -> bool where P: FnMut(&ast::Expr) -> bool {\n     let mut v = BlockQueryVisitor {\n         p: p,\n         flag: false,\n@@ -194,11 +203,12 @@ pub fn can_reach<S,H:Hasher<S>,T:Eq+Clone+Hash<S>>(\n /// }\n /// ```\n #[inline(always)]\n-pub fn memoized<T: Clone + Hash<S> + Eq, U: Clone, S, H: Hasher<S>>(\n-    cache: &RefCell<HashMap<T, U, H>>,\n-    arg: T,\n-    f: |T| -> U\n-) -> U {\n+pub fn memoized<T, U, S, H, F>(cache: &RefCell<HashMap<T, U, H>>, arg: T, f: F) -> U where\n+    T: Clone + Hash<S> + Eq,\n+    U: Clone,\n+    H: Hasher<S>,\n+    F: FnOnce(T) -> U,\n+{\n     let key = arg.clone();\n     let result = cache.borrow().get(&key).map(|result| result.clone());\n     match result {"}, {"sha": "5dbf3208595ed9434f64a625918b29165c58cc75", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -241,7 +241,9 @@ pub fn trait_store_to_string(cx: &ctxt, s: ty::TraitStore) -> String {\n     }\n }\n \n-pub fn vec_map_to_string<T>(ts: &[T], f: |t: &T| -> String) -> String {\n+pub fn vec_map_to_string<T, F>(ts: &[T], f: F) -> String where\n+    F: FnMut(&T) -> String,\n+{\n     let tstrs = ts.iter().map(f).collect::<Vec<String>>();\n     format!(\"[{}]\", tstrs.connect(\", \"))\n }"}, {"sha": "3a4510703166c84a835b983ceaf0746b86c5ee95", "filename": "src/librustc_back/archive.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustc_back%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustc_back%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Farchive.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -279,8 +279,9 @@ impl<'a> ArchiveBuilder<'a> {\n         self.archive\n     }\n \n-    fn add_archive(&mut self, archive: &Path, name: &str,\n-                   skip: |&str| -> bool) -> io::IoResult<()> {\n+    fn add_archive<F>(&mut self, archive: &Path, name: &str, mut skip: F) -> io::IoResult<()> where\n+        F: FnMut(&str) -> bool,\n+    {\n         let loc = TempDir::new(\"rsar\").unwrap();\n \n         // First, extract the contents of the archive to a temporary directory."}, {"sha": "cb547df7d9cd83a9cc8a710eb586730431d2e899", "filename": "src/librustc_back/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustc_back%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustc_back%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Flib.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -31,6 +31,7 @@\n \n #![allow(unknown_features)]\n #![feature(globs, phase, macro_rules, slicing_syntax)]\n+#![feature(unboxed_closures)]\n \n #[phase(plugin, link)]\n extern crate log;"}, {"sha": "1f8549098d949f044c4768d295b5baa3eb5eaeb4", "filename": "src/librustc_back/rpath.rs", "status": "modified", "additions": 27, "deletions": 12, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustc_back%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustc_back%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Frpath.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -14,17 +14,22 @@ use std::os;\n use std::io::IoError;\n use syntax::ast;\n \n-pub struct RPathConfig<'a> {\n+pub struct RPathConfig<F, G> where\n+    F: FnOnce() -> Path,\n+    G: FnMut(&Path) -> Result<Path, IoError>,\n+{\n     pub used_crates: Vec<(ast::CrateNum, Option<Path>)>,\n     pub out_filename: Path,\n     pub is_like_osx: bool,\n     pub has_rpath: bool,\n-    pub get_install_prefix_lib_path: ||:'a -> Path,\n-    pub realpath: |&Path|:'a -> Result<Path, IoError>\n+    pub get_install_prefix_lib_path: F,\n+    pub realpath: G,\n }\n \n-pub fn get_rpath_flags(config: RPathConfig) -> Vec<String> {\n-\n+pub fn get_rpath_flags<F, G>(config: RPathConfig<F, G>) -> Vec<String> where\n+    F: FnOnce() -> Path,\n+    G: FnMut(&Path) -> Result<Path, IoError>,\n+{\n     // No rpath on windows\n     if !config.has_rpath {\n         return Vec::new();\n@@ -52,8 +57,10 @@ fn rpaths_to_flags(rpaths: &[String]) -> Vec<String> {\n     return ret;\n }\n \n-fn get_rpaths(mut config: RPathConfig,\n-              libs: &[Path]) -> Vec<String> {\n+fn get_rpaths<F, G>(mut config: RPathConfig<F, G>, libs: &[Path]) -> Vec<String> where\n+    F: FnOnce() -> Path,\n+    G: FnMut(&Path) -> Result<Path, IoError>,\n+{\n     debug!(\"output: {}\", config.out_filename.display());\n     debug!(\"libs:\");\n     for libpath in libs.iter() {\n@@ -86,13 +93,18 @@ fn get_rpaths(mut config: RPathConfig,\n     return rpaths;\n }\n \n-fn get_rpaths_relative_to_output(config: &mut RPathConfig,\n-                                 libs: &[Path]) -> Vec<String> {\n+fn get_rpaths_relative_to_output<F, G>(config: &mut RPathConfig<F, G>,\n+                                       libs: &[Path]) -> Vec<String> where\n+    F: FnOnce() -> Path,\n+    G: FnMut(&Path) -> Result<Path, IoError>,\n+{\n     libs.iter().map(|a| get_rpath_relative_to_output(config, a)).collect()\n }\n \n-fn get_rpath_relative_to_output(config: &mut RPathConfig,\n-                                lib: &Path) -> String {\n+fn get_rpath_relative_to_output<F, G>(config: &mut RPathConfig<F, G>, lib: &Path) -> String where\n+    F: FnOnce() -> Path,\n+    G: FnMut(&Path) -> Result<Path, IoError>,\n+{\n     use std::os;\n \n     // Mac doesn't appear to support $ORIGIN\n@@ -114,7 +126,10 @@ fn get_rpath_relative_to_output(config: &mut RPathConfig,\n             relative.as_str().expect(\"non-utf8 component in path\"))\n }\n \n-fn get_install_prefix_rpath(config: RPathConfig) -> String {\n+fn get_install_prefix_rpath<F, G>(config: RPathConfig<F, G>) -> String where\n+    F: FnOnce() -> Path,\n+    G: FnMut(&Path) -> Result<Path, IoError>,\n+{\n     let path = (config.get_install_prefix_lib_path)();\n     let path = os::make_absolute(&path).unwrap();\n     // FIXME (#9639): This needs to handle non-utf8 paths"}, {"sha": "1587104ca49d16443664352c8fc3c5677d76e4ab", "filename": "src/librustc_back/sha2.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustc_back%2Fsha2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustc_back%2Fsha2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fsha2.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -82,7 +82,8 @@ fn add_bytes_to_bits<T: Int + ToBits>(bits: T, bytes: T) -> T {\n trait FixedBuffer {\n     /// Input a vector of bytes. If the buffer becomes full, process it with the provided\n     /// function and then clear the buffer.\n-    fn input(&mut self, input: &[u8], func: |&[u8]|);\n+    fn input<F>(&mut self, input: &[u8], func: F) where\n+        F: FnMut(&[u8]);\n \n     /// Reset the buffer.\n     fn reset(&mut self);\n@@ -125,7 +126,9 @@ impl FixedBuffer64 {\n }\n \n impl FixedBuffer for FixedBuffer64 {\n-    fn input(&mut self, input: &[u8], func: |&[u8]|) {\n+    fn input<F>(&mut self, input: &[u8], mut func: F) where\n+        F: FnMut(&[u8]),\n+    {\n         let mut i = 0;\n \n         let size = self.size();\n@@ -201,11 +204,11 @@ trait StandardPadding {\n     /// guaranteed to have exactly rem remaining bytes when it returns. If there are not at least\n     /// rem bytes available, the buffer will be zero padded, processed, cleared, and then filled\n     /// with zeros again until only rem bytes are remaining.\n-    fn standard_padding(&mut self, rem: uint, func: |&[u8]|);\n+    fn standard_padding<F>(&mut self, rem: uint, func: F) where F: FnMut(&[u8]);\n }\n \n impl <T: FixedBuffer> StandardPadding for T {\n-    fn standard_padding(&mut self, rem: uint, func: |&[u8]|) {\n+    fn standard_padding<F>(&mut self, rem: uint, mut func: F) where F: FnMut(&[u8]) {\n         let size = self.size();\n \n         self.next(1)[0] = 128;"}, {"sha": "3bf817b42b06de19ec85ea76fd4a6dad36365bcf", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -232,8 +232,9 @@ fn compatible_borrow_kinds(borrow_kind1: ty::BorrowKind,\n impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n     pub fn tcx(&self) -> &'a ty::ctxt<'tcx> { self.bccx.tcx }\n \n-    pub fn each_issued_loan(&self, scope: region::CodeExtent, op: |&Loan<'tcx>| -> bool)\n-                            -> bool {\n+    pub fn each_issued_loan<F>(&self, scope: region::CodeExtent, mut op: F) -> bool where\n+        F: FnMut(&Loan<'tcx>) -> bool,\n+    {\n         //! Iterates over each loan that has been issued\n         //! on entrance to `scope`, regardless of whether it is\n         //! actually *in scope* at that point.  Sometimes loans\n@@ -246,10 +247,9 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n         })\n     }\n \n-    pub fn each_in_scope_loan(&self,\n-                              scope: region::CodeExtent,\n-                              op: |&Loan<'tcx>| -> bool)\n-                              -> bool {\n+    pub fn each_in_scope_loan<F>(&self, scope: region::CodeExtent, mut op: F) -> bool where\n+        F: FnMut(&Loan<'tcx>) -> bool,\n+    {\n         //! Like `each_issued_loan()`, but only considers loans that are\n         //! currently in scope.\n \n@@ -263,11 +263,13 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n         })\n     }\n \n-    fn each_in_scope_loan_affecting_path(&self,\n-                                         scope: region::CodeExtent,\n-                                         loan_path: &LoanPath<'tcx>,\n-                                         op: |&Loan<'tcx>| -> bool)\n-                                         -> bool {\n+    fn each_in_scope_loan_affecting_path<F>(&self,\n+                                            scope: region::CodeExtent,\n+                                            loan_path: &LoanPath<'tcx>,\n+                                            mut op: F)\n+                                            -> bool where\n+        F: FnMut(&Loan<'tcx>) -> bool,\n+    {\n         //! Iterates through all of the in-scope loans affecting `loan_path`,\n         //! calling `op`, and ceasing iteration if `false` is returned.\n "}, {"sha": "00b1377af73040793dfa803a227bd45ad65ed47d", "filename": "src/librustc_borrowck/borrowck/move_data.rs", "status": "modified", "additions": 22, "deletions": 20, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -523,8 +523,9 @@ impl<'tcx> MoveData<'tcx> {\n         }\n     }\n \n-    fn each_base_path(&self, index: MovePathIndex, f: |MovePathIndex| -> bool)\n-                      -> bool {\n+    fn each_base_path<F>(&self, index: MovePathIndex, mut f: F) -> bool where\n+        F: FnMut(MovePathIndex) -> bool,\n+    {\n         let mut p = index;\n         while p != InvalidMovePathIndex {\n             if !f(p) {\n@@ -535,10 +536,8 @@ impl<'tcx> MoveData<'tcx> {\n         return true;\n     }\n \n-    fn each_extending_path(&self,\n-                           index: MovePathIndex,\n-                           f: |MovePathIndex| -> bool)\n-                           -> bool {\n+    // FIXME(#19596) unbox `f`\n+    fn each_extending_path(&self, index: MovePathIndex, f: |MovePathIndex| -> bool) -> bool {\n         if !f(index) {\n             return false;\n         }\n@@ -554,10 +553,9 @@ impl<'tcx> MoveData<'tcx> {\n         return true;\n     }\n \n-    fn each_applicable_move(&self,\n-                            index0: MovePathIndex,\n-                            f: |MoveIndex| -> bool)\n-                            -> bool {\n+    fn each_applicable_move<F>(&self, index0: MovePathIndex, mut f: F) -> bool where\n+        F: FnMut(MoveIndex) -> bool,\n+    {\n         let mut ret = true;\n         self.each_extending_path(index0, |index| {\n             let mut p = self.path_first_move(index);\n@@ -660,11 +658,13 @@ impl<'a, 'tcx> FlowedMoveData<'a, 'tcx> {\n     /// Iterates through each move of `loan_path` (or some base path of `loan_path`) that *may*\n     /// have occurred on entry to `id` without an intervening assignment. In other words, any moves\n     /// that would invalidate a reference to `loan_path` at location `id`.\n-    pub fn each_move_of(&self,\n-                        id: ast::NodeId,\n-                        loan_path: &Rc<LoanPath<'tcx>>,\n-                        f: |&Move, &LoanPath<'tcx>| -> bool)\n-                        -> bool {\n+    pub fn each_move_of<F>(&self,\n+                           id: ast::NodeId,\n+                           loan_path: &Rc<LoanPath<'tcx>>,\n+                           mut f: F)\n+                           -> bool where\n+        F: FnMut(&Move, &LoanPath<'tcx>) -> bool,\n+    {\n         // Bad scenarios:\n         //\n         // 1. Move of `a.b.c`, use of `a.b.c`\n@@ -715,11 +715,13 @@ impl<'a, 'tcx> FlowedMoveData<'a, 'tcx> {\n \n     /// Iterates through every assignment to `loan_path` that may have occurred on entry to `id`.\n     /// `loan_path` must be a single variable.\n-    pub fn each_assignment_of(&self,\n-                              id: ast::NodeId,\n-                              loan_path: &Rc<LoanPath<'tcx>>,\n-                              f: |&Assignment| -> bool)\n-                              -> bool {\n+    pub fn each_assignment_of<F>(&self,\n+                                 id: ast::NodeId,\n+                                 loan_path: &Rc<LoanPath<'tcx>>,\n+                                 mut f: F)\n+                                 -> bool where\n+        F: FnMut(&Assignment) -> bool,\n+    {\n         let loan_path_index = {\n             match self.move_data.existing_move_path(loan_path) {\n                 Some(i) => i,"}, {"sha": "e09ec79166997db26327b351cd191649ca01763b", "filename": "src/librustc_borrowck/graphviz.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustc_borrowck%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustc_borrowck%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fgraphviz.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -75,11 +75,13 @@ impl<'a, 'tcx> DataflowLabeller<'a, 'tcx> {\n         }\n     }\n \n-    fn build_set<O:DataFlowOperator>(&self,\n-                                     e: EntryOrExit,\n-                                     cfgidx: CFGIndex,\n-                                     dfcx: &DataFlowContext<'a, 'tcx, O>,\n-                                     to_lp: |uint| -> Rc<LoanPath<'tcx>>) -> String {\n+    fn build_set<O:DataFlowOperator, F>(&self,\n+                                        e: EntryOrExit,\n+                                        cfgidx: CFGIndex,\n+                                        dfcx: &DataFlowContext<'a, 'tcx, O>,\n+                                        mut to_lp: F) -> String where\n+        F: FnMut(uint) -> Rc<LoanPath<'tcx>>,\n+    {\n         let mut saw_some = false;\n         let mut set = \"{\".to_string();\n         dfcx.each_bit_for_node(e, cfgidx, |index| {\n@@ -98,7 +100,7 @@ impl<'a, 'tcx> DataflowLabeller<'a, 'tcx> {\n \n     fn dataflow_loans_for(&self, e: EntryOrExit, cfgidx: CFGIndex) -> String {\n         let dfcx = &self.analysis_data.loans;\n-        let loan_index_to_path = |loan_index| {\n+        let loan_index_to_path = |&mut: loan_index| {\n             let all_loans = &self.analysis_data.all_loans;\n             all_loans[loan_index].loan_path()\n         };\n@@ -107,7 +109,7 @@ impl<'a, 'tcx> DataflowLabeller<'a, 'tcx> {\n \n     fn dataflow_moves_for(&self, e: EntryOrExit, cfgidx: CFGIndex) -> String {\n         let dfcx = &self.analysis_data.move_data.dfcx_moves;\n-        let move_index_to_path = |move_index| {\n+        let move_index_to_path = |&mut: move_index| {\n             let move_data = &self.analysis_data.move_data.move_data;\n             let moves = move_data.moves.borrow();\n             let the_move = &(*moves)[move_index];\n@@ -118,7 +120,7 @@ impl<'a, 'tcx> DataflowLabeller<'a, 'tcx> {\n \n     fn dataflow_assigns_for(&self, e: EntryOrExit, cfgidx: CFGIndex) -> String {\n         let dfcx = &self.analysis_data.move_data.dfcx_assign;\n-        let assign_index_to_path = |assign_index| {\n+        let assign_index_to_path = |&mut: assign_index| {\n             let move_data = &self.analysis_data.move_data.move_data;\n             let assignments = move_data.var_assignments.borrow();\n             let assignment = &(*assignments)[assign_index];"}, {"sha": "db19a09deba3a066188e644fa34e9bbc579b6ef9", "filename": "src/librustc_borrowck/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustc_borrowck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustc_borrowck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Flib.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -19,6 +19,7 @@\n #![feature(default_type_params, globs, if_let, import_shadowing, macro_rules, phase, quote)]\n #![feature(slicing_syntax, tuple_indexing, unsafe_destructor)]\n #![feature(rustc_diagnostic_macros)]\n+#![feature(unboxed_closures)]\n #![allow(non_camel_case_types)]\n \n #[phase(plugin, link)] extern crate log;"}, {"sha": "d655b704053096fe7aad68e03756e2304bf35a26", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -25,6 +25,7 @@\n #![feature(default_type_params, globs, import_shadowing, macro_rules, phase, quote)]\n #![feature(slicing_syntax, unsafe_destructor)]\n #![feature(rustc_diagnostic_macros)]\n+#![feature(unboxed_closures)]\n \n extern crate arena;\n extern crate flate;"}, {"sha": "7ec05b6a0306e3c331732067c587e069fb801c50", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -78,7 +78,7 @@ pub fn parse_pretty(sess: &Session, name: &str) -> (PpMode, Option<UserIdentifie\n                  or `expanded,identified`; got {}\", name).as_slice());\n         }\n     };\n-    let opt_second = opt_second.and_then::<UserIdentifiedItem>(from_str);\n+    let opt_second = opt_second.and_then::<UserIdentifiedItem, _>(from_str);\n     (first, opt_second)\n }\n \n@@ -99,13 +99,15 @@ pub fn parse_pretty(sess: &Session, name: &str) -> (PpMode, Option<UserIdentifie\n \n impl PpSourceMode {\n     /// Constructs a `PrinterSupport` object and passes it to `f`.\n-    fn call_with_pp_support<'tcx, A, B>(&self,\n-                                        sess: Session,\n-                                        ast_map: Option<ast_map::Map<'tcx>>,\n-                                        type_arena: &'tcx TypedArena<ty::TyS<'tcx>>,\n-                                        id: String,\n-                                        payload: B,\n-                                        f: |&PrinterSupport, B| -> A) -> A {\n+    fn call_with_pp_support<'tcx, A, B, F>(&self,\n+                                           sess: Session,\n+                                           ast_map: Option<ast_map::Map<'tcx>>,\n+                                           type_arena: &'tcx TypedArena<ty::TyS<'tcx>>,\n+                                           id: String,\n+                                           payload: B,\n+                                           f: F) -> A where\n+        F: FnOnce(&PrinterSupport, B) -> A,\n+    {\n         match *self {\n             PpmNormal | PpmExpanded => {\n                 let annotation = NoAnn { sess: sess, ast_map: ast_map };\n@@ -313,14 +315,12 @@ pub enum UserIdentifiedItem {\n \n impl FromStr for UserIdentifiedItem {\n     fn from_str(s: &str) -> Option<UserIdentifiedItem> {\n-        let extract_path_parts = || {\n+        from_str(s).map(ItemViaNode).or_else(|| {\n             let v : Vec<_> = s.split_str(\"::\")\n                 .map(|x|x.to_string())\n                 .collect();\n             Some(ItemViaPath(v))\n-        };\n-\n-        from_str(s).map(ItemViaNode).or_else(extract_path_parts)\n+        })\n     }\n }\n "}, {"sha": "dda3754cf7371cbeab9ef33d462aed0056ca0a9f", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -93,9 +93,11 @@ fn errors(msgs: &[&str]) -> (Box<Emitter+Send>, uint) {\n     (box ExpectErrorEmitter { messages: v } as Box<Emitter+Send>, msgs.len())\n }\n \n-fn test_env(source_string: &str,\n-            (emitter, expected_err_count): (Box<Emitter+Send>, uint),\n-            body: |Env|) {\n+fn test_env<F>(source_string: &str,\n+               (emitter, expected_err_count): (Box<Emitter+Send>, uint),\n+               body: F) where\n+    F: FnOnce(Env),\n+{\n     let mut options =\n         config::basic_options();\n     options.debugging_opts |= config::VERBOSE;"}, {"sha": "7d8338ba976dd7091d75e0887fcdb80c158695a3", "filename": "src/librustc_llvm/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustc_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustc_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Flib.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -23,6 +23,7 @@\n \n #![feature(globs)]\n #![feature(link_args)]\n+#![feature(unboxed_closures)]\n \n extern crate libc;\n \n@@ -2206,7 +2207,7 @@ pub unsafe extern \"C\" fn rust_llvm_string_write_impl(sr: RustStringRef,\n     (*sr).borrow_mut().push_all(slice);\n }\n \n-pub fn build_string(f: |RustStringRef|) -> Option<String> {\n+pub fn build_string<F>(f: F) -> Option<String> where F: FnOnce(RustStringRef){\n     let mut buf = RefCell::new(Vec::new());\n     f(&mut buf as RustStringRepr as RustStringRef);\n     String::from_utf8(buf.into_inner()).ok()"}, {"sha": "5617110bfecf774f5c89b5a767a91b6d51ca18bf", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -1002,7 +1002,7 @@ fn link_args(cmd: &mut Command,\n     if sess.opts.cg.rpath {\n         let sysroot = sess.sysroot();\n         let target_triple = sess.opts.target_triple.as_slice();\n-        let get_install_prefix_lib_path = || {\n+        let get_install_prefix_lib_path = |:| {\n             let install_prefix = option_env!(\"CFG_PREFIX\").expect(\"CFG_PREFIX\");\n             let tlib = filesearch::relative_target_lib_path(sysroot, target_triple);\n             let mut path = Path::new(install_prefix);"}, {"sha": "fb4d6de5f282c20728bca4e3925a175386e2fa13", "filename": "src/librustc_trans/back/lto.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustc_trans%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustc_trans%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flto.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -81,8 +81,9 @@ pub fn run(sess: &session::Session, llmod: ModuleRef,\n                     break;\n                 },\n             };\n-            let bc_extractor = if is_versioned_bytecode_format(bc_encoded) {\n-                |_| {\n+\n+            let bc_decoded = if is_versioned_bytecode_format(bc_encoded) {\n+                time(sess.time_passes(), format!(\"decode {}.{}.bc\", file, i).as_slice(), (), |_| {\n                     // Read the version\n                     let version = extract_bytecode_format_version(bc_encoded);\n \n@@ -104,26 +105,21 @@ pub fn run(sess: &session::Session, llmod: ModuleRef,\n                         sess.fatal(format!(\"Unsupported bytecode format version {}\",\n                                            version).as_slice())\n                     }\n-                }\n+                })\n             } else {\n+                time(sess.time_passes(), format!(\"decode {}.{}.bc\", file, i).as_slice(), (), |_| {\n                 // the object must be in the old, pre-versioning format, so simply\n                 // inflate everything and let LLVM decide if it can make sense of it\n-                |_| {\n                     match flate::inflate_bytes(bc_encoded) {\n                         Some(bc) => bc,\n                         None => {\n                             sess.fatal(format!(\"failed to decompress bc of `{}`\",\n                                                name).as_slice())\n                         }\n                     }\n-                }\n+                })\n             };\n \n-            let bc_decoded = time(sess.time_passes(),\n-                                  format!(\"decode {}.{}.bc\", file, i).as_slice(),\n-                                  (),\n-                                  bc_extractor);\n-\n             let ptr = bc_decoded.as_slice().as_ptr();\n             debug!(\"linking {}, part {}\", name, i);\n             time(sess.time_passes(),"}, {"sha": "c52f31532dcd0c63c74ab4dfe8367ab41f854194", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -488,8 +488,12 @@ unsafe fn optimize_and_codegen(cgcx: &CodegenContext,\n     // pass manager passed to the closure should be ensured to not\n     // escape the closure itself, and the manager should only be\n     // used once.\n-    unsafe fn with_codegen(tm: TargetMachineRef, llmod: ModuleRef,\n-                    no_builtins: bool, f: |PassManagerRef|) {\n+    unsafe fn with_codegen<F>(tm: TargetMachineRef,\n+                              llmod: ModuleRef,\n+                              no_builtins: bool,\n+                              f: F) where\n+        F: FnOnce(PassManagerRef),\n+    {\n         let cpm = llvm::LLVMCreatePassManager();\n         llvm::LLVMRustAddAnalysisPasses(tm, cpm, llmod);\n         llvm::LLVMRustAddLibraryInfo(cpm, llmod, no_builtins);"}, {"sha": "05b1a86b72b05171a3f88ce1b2408ca3a3c220a8", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -25,6 +25,7 @@\n #![feature(default_type_params, globs, import_shadowing, macro_rules, phase, quote)]\n #![feature(slicing_syntax, unsafe_destructor)]\n #![feature(rustc_diagnostic_macros)]\n+#![feature(unboxed_closures)]\n \n extern crate arena;\n extern crate flate;"}, {"sha": "329241b24e6520f0fa3d5daa4db8a60a674371d8", "filename": "src/librustc_trans/save/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fmod.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -79,7 +79,9 @@ struct DxrVisitor<'l, 'tcx: 'l> {\n }\n \n impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n-    fn nest(&mut self, scope_id: NodeId, f: |&mut DxrVisitor<'l, 'tcx>|) {\n+    fn nest<F>(&mut self, scope_id: NodeId, f: F) where\n+        F: FnOnce(&mut DxrVisitor<'l, 'tcx>),\n+    {\n         let parent_scope = self.cur_scope;\n         self.cur_scope = scope_id;\n         f(self);"}, {"sha": "b051292571980fe47987f7cdf79ed9c75a00d0d0", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -771,7 +771,7 @@ fn pick_column_to_specialize(def_map: &DefMap, m: &[Match]) -> Option<uint> {\n         }\n     };\n \n-    let column_contains_any_nonwild_patterns: |&uint| -> bool = |&col| {\n+    let column_contains_any_nonwild_patterns = |&: &col: &uint| -> bool {\n         m.iter().any(|row| match row.pats[col].node {\n             ast::PatWild(_) => false,\n             _ => true\n@@ -1578,14 +1578,15 @@ pub fn store_for_loop_binding<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     bind_irrefutable_pat(bcx, pat, llvalue, body_scope)\n }\n \n-fn mk_binding_alloca<'blk, 'tcx, A>(bcx: Block<'blk, 'tcx>,\n-                                    p_id: ast::NodeId,\n-                                    ident: &ast::Ident,\n-                                    cleanup_scope: cleanup::ScopeId,\n-                                    arg: A,\n-                                    populate: |A, Block<'blk, 'tcx>, ValueRef, Ty<'tcx>|\n-                                              -> Block<'blk, 'tcx>)\n-                                    -> Block<'blk, 'tcx> {\n+fn mk_binding_alloca<'blk, 'tcx, A, F>(bcx: Block<'blk, 'tcx>,\n+                                       p_id: ast::NodeId,\n+                                       ident: &ast::Ident,\n+                                       cleanup_scope: cleanup::ScopeId,\n+                                       arg: A,\n+                                       populate: F)\n+                                       -> Block<'blk, 'tcx> where\n+    F: FnOnce(A, Block<'blk, 'tcx>, ValueRef, Ty<'tcx>) -> Block<'blk, 'tcx>,\n+{\n     let var_ty = node_id_type(bcx, p_id);\n \n     // Allocate memory on stack for the binding."}, {"sha": "991333d8f07ddb9a9b4d97b27058641783a2952a", "filename": "src/librustc_trans/trans/adt.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fadt.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -858,10 +858,13 @@ pub fn struct_field_ptr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, st: &Struct<'tcx>, v\n     GEPi(bcx, val, &[0, ix])\n }\n \n-pub fn fold_variants<'blk, 'tcx>(\n-        bcx: Block<'blk, 'tcx>, r: &Repr<'tcx>, value: ValueRef,\n-        f: |Block<'blk, 'tcx>, &Struct<'tcx>, ValueRef| -> Block<'blk, 'tcx>)\n-        -> Block<'blk, 'tcx> {\n+pub fn fold_variants<'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n+                                    r: &Repr<'tcx>,\n+                                    value: ValueRef,\n+                                    mut f: F)\n+                                    -> Block<'blk, 'tcx> where\n+    F: FnMut(Block<'blk, 'tcx>, &Struct<'tcx>, ValueRef) -> Block<'blk, 'tcx>,\n+{\n     let fcx = bcx.fcx;\n     match *r {\n         Univariant(ref st, _) => {"}, {"sha": "5170746404e01d0a440c57aa6258e5bc53031f7a", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 20, "deletions": 13, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -107,9 +107,11 @@ thread_local!(static TASK_LOCAL_INSN_KEY: RefCell<Option<Vec<&'static str>>> = {\n     RefCell::new(None)\n })\n \n-pub fn with_insn_ctxt(blk: |&[&'static str]|) {\n-    TASK_LOCAL_INSN_KEY.with(|slot| {\n-        slot.borrow().as_ref().map(|s| blk(s.as_slice()));\n+pub fn with_insn_ctxt<F>(blk: F) where\n+    F: FnOnce(&[&'static str]),\n+{\n+    TASK_LOCAL_INSN_KEY.with(move |slot| {\n+        slot.borrow().as_ref().map(move |s| blk(s.as_slice()));\n     })\n }\n \n@@ -841,12 +843,15 @@ pub fn cast_shift_const_rhs(op: ast::BinOp,\n                    |a, b| unsafe { llvm::LLVMConstZExt(a, b.to_ref()) })\n }\n \n-pub fn cast_shift_rhs(op: ast::BinOp,\n-                      lhs: ValueRef,\n-                      rhs: ValueRef,\n-                      trunc: |ValueRef, Type| -> ValueRef,\n-                      zext: |ValueRef, Type| -> ValueRef)\n-                      -> ValueRef {\n+pub fn cast_shift_rhs<F, G>(op: ast::BinOp,\n+                            lhs: ValueRef,\n+                            rhs: ValueRef,\n+                            trunc: F,\n+                            zext: G)\n+                            -> ValueRef where\n+    F: FnOnce(ValueRef, Type) -> ValueRef,\n+    G: FnOnce(ValueRef, Type) -> ValueRef,\n+{\n     // Shifts may have any size int on the rhs\n     unsafe {\n         if ast_util::is_shift_binop(op) {\n@@ -1101,10 +1106,12 @@ pub fn raw_block<'blk, 'tcx>(fcx: &'blk FunctionContext<'blk, 'tcx>,\n     common::BlockS::new(llbb, is_lpad, None, fcx)\n }\n \n-pub fn with_cond<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                             val: ValueRef,\n-                             f: |Block<'blk, 'tcx>| -> Block<'blk, 'tcx>)\n-                             -> Block<'blk, 'tcx> {\n+pub fn with_cond<'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n+                                val: ValueRef,\n+                                f: F)\n+                                -> Block<'blk, 'tcx> where\n+    F: FnOnce(Block<'blk, 'tcx>) -> Block<'blk, 'tcx>,\n+{\n     let _icx = push_ctxt(\"with_cond\");\n     let fcx = bcx.fcx;\n     let next_cx = fcx.new_temp_block(\"next\");"}, {"sha": "dca106a3897fb3fc68eeb52a254b4f2254dce8e2", "filename": "src/librustc_trans/trans/basic_block.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustc_trans%2Ftrans%2Fbasic_block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustc_trans%2Ftrans%2Fbasic_block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbasic_block.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -17,7 +17,12 @@ pub struct BasicBlock(pub BasicBlockRef);\n \n impl Copy for BasicBlock {}\n \n-pub type Preds<'a> = Map<'a, Value, BasicBlock, Filter<'a, Value, Users>>;\n+pub type Preds = Map<\n+    Value,\n+    BasicBlock,\n+    Filter<Value, Users, fn(&Value) -> bool>,\n+    fn(Value) -> BasicBlock,\n+>;\n \n /// Wrapper for LLVM BasicBlockRef\n impl BasicBlock {\n@@ -31,10 +36,13 @@ impl BasicBlock {\n         }\n     }\n \n-    pub fn pred_iter(self) -> Preds<'static> {\n+    pub fn pred_iter(self) -> Preds {\n+        fn is_a_terminator_inst(user: &Value) -> bool { user.is_a_terminator_inst() }\n+        fn get_parent(user: Value) -> BasicBlock { user.get_parent().unwrap() }\n+\n         self.as_value().user_iter()\n-            .filter(|user| user.is_a_terminator_inst())\n-            .map(|user| user.get_parent().unwrap())\n+            .filter(is_a_terminator_inst)\n+            .map(get_parent)\n     }\n \n     pub fn get_single_predecessor(self) -> Option<BasicBlock> {"}, {"sha": "4a6bc58051c57aa9b4132d56b332c0d9c2d2c690", "filename": "src/librustc_trans/trans/cabi_x86_64.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86_64.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -342,11 +342,13 @@ pub fn compute_abi_info(ccx: &CrateContext,\n                         atys: &[Type],\n                         rty: Type,\n                         ret_def: bool) -> FnType {\n-    fn x86_64_ty(ccx: &CrateContext,\n-                 ty: Type,\n-                 is_mem_cls: |cls: &[RegClass]| -> bool,\n-                 ind_attr: Attribute)\n-                 -> ArgType {\n+    fn x86_64_ty<F>(ccx: &CrateContext,\n+                    ty: Type,\n+                    is_mem_cls: F,\n+                    ind_attr: Attribute)\n+                    -> ArgType where\n+        F: FnOnce(&[RegClass]) -> bool,\n+    {\n         if !ty.is_reg_ty() {\n             let cls = classify_ty(ty);\n             if is_mem_cls(cls.as_slice()) {"}, {"sha": "b8b2395dde17229225bbe45ec1dc4a77f24d45a1", "filename": "src/librustc_trans/trans/callee.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -781,15 +781,15 @@ pub fn trans_lang_call<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n ///\n /// For non-lang items, `dest` is always Some, and hence the result is written into memory\n /// somewhere. Nonetheless we return the actual return value of the function.\n-pub fn trans_call_inner<'a, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                        call_info: Option<NodeInfo>,\n-                                        callee_ty: Ty<'tcx>,\n-                                        get_callee: |bcx: Block<'blk, 'tcx>,\n-                                                     arg_cleanup_scope: cleanup::ScopeId|\n-                                                     -> Callee<'blk, 'tcx>,\n-                                        args: CallArgs<'a, 'tcx>,\n-                                        dest: Option<expr::Dest>)\n-                                        -> Result<'blk, 'tcx> {\n+pub fn trans_call_inner<'a, 'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n+                                           call_info: Option<NodeInfo>,\n+                                           callee_ty: Ty<'tcx>,\n+                                           get_callee: F,\n+                                           args: CallArgs<'a, 'tcx>,\n+                                           dest: Option<expr::Dest>)\n+                                           -> Result<'blk, 'tcx> where\n+    F: FnOnce(Block<'blk, 'tcx>, cleanup::ScopeId) -> Callee<'blk, 'tcx>,\n+{\n     // Introduce a temporary cleanup scope that will contain cleanups\n     // for the arguments while they are being evaluated. The purpose\n     // this cleanup is to ensure that, should a panic occur while"}, {"sha": "2fd6551409e90e734f288039805cd98862820da0", "filename": "src/librustc_trans/trans/cleanup.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -527,7 +527,7 @@ impl<'blk, 'tcx> CleanupHelperMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx\n         self.scopes.borrow_mut().pop().unwrap()\n     }\n \n-    fn top_scope<R>(&self, f: |&CleanupScope<'blk, 'tcx>| -> R) -> R {\n+    fn top_scope<R, F>(&self, f: F) -> R where F: FnOnce(&CleanupScope<'blk, 'tcx>) -> R {\n         f(self.scopes.borrow().last().unwrap())\n     }\n \n@@ -1145,5 +1145,5 @@ trait CleanupHelperMethods<'blk, 'tcx> {\n     fn scopes_len(&self) -> uint;\n     fn push_scope(&self, scope: CleanupScope<'blk, 'tcx>);\n     fn pop_scope(&self) -> CleanupScope<'blk, 'tcx>;\n-    fn top_scope<R>(&self, f: |&CleanupScope<'blk, 'tcx>| -> R) -> R;\n+    fn top_scope<R, F>(&self, f: F) -> R where F: FnOnce(&CleanupScope<'blk, 'tcx>) -> R;\n }"}, {"sha": "531b22c8fb5f2d221c0757c8d2ad1fe7ea8c3f53", "filename": "src/librustc_trans/trans/datum.rs", "status": "modified", "additions": 19, "deletions": 16, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -113,15 +113,16 @@ pub fn immediate_rvalue_bcx<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n /// it. The memory will be dropped upon exit from `scope`. The callback `populate` should\n /// initialize the memory. If `zero` is true, the space will be zeroed when it is allocated; this\n /// is not necessary unless `bcx` does not dominate the end of `scope`.\n-pub fn lvalue_scratch_datum<'blk, 'tcx, A>(bcx: Block<'blk, 'tcx>,\n-                                           ty: Ty<'tcx>,\n-                                           name: &str,\n-                                           zero: bool,\n-                                           scope: cleanup::ScopeId,\n-                                           arg: A,\n-                                           populate: |A, Block<'blk, 'tcx>, ValueRef|\n-                                                      -> Block<'blk, 'tcx>)\n-                                          -> DatumBlock<'blk, 'tcx, Lvalue> {\n+pub fn lvalue_scratch_datum<'blk, 'tcx, A, F>(bcx: Block<'blk, 'tcx>,\n+                                              ty: Ty<'tcx>,\n+                                              name: &str,\n+                                              zero: bool,\n+                                              scope: cleanup::ScopeId,\n+                                              arg: A,\n+                                              populate: F)\n+                                              -> DatumBlock<'blk, 'tcx, Lvalue> where\n+    F: FnOnce(A, Block<'blk, 'tcx>, ValueRef) -> Block<'blk, 'tcx>,\n+{\n     let scratch = if zero {\n         alloca_zeroed(bcx, ty, name)\n     } else {\n@@ -339,10 +340,10 @@ impl<'tcx> Datum<'tcx, Rvalue> {\n /// here since we can `match self.kind` rather than having to implement\n /// generic methods in `KindOps`.)\n impl<'tcx> Datum<'tcx, Expr> {\n-    fn match_kind<R>(self,\n-                     if_lvalue: |Datum<'tcx, Lvalue>| -> R,\n-                     if_rvalue: |Datum<'tcx, Rvalue>| -> R)\n-                     -> R {\n+    fn match_kind<R, F, G>(self, if_lvalue: F, if_rvalue: G) -> R where\n+        F: FnOnce(Datum<'tcx, Lvalue>) -> R,\n+        G: FnOnce(Datum<'tcx, Rvalue>) -> R,\n+    {\n         let Datum { val, ty, kind } = self;\n         match kind {\n             LvalueExpr => if_lvalue(Datum::new(val, ty, Lvalue)),\n@@ -455,9 +456,11 @@ impl<'tcx> Datum<'tcx, Lvalue> {\n     // datum may also be unsized _without the size information_. It is the\n     // callers responsibility to package the result in some way to make a valid\n     // datum in that case (e.g., by making a fat pointer or opened pair).\n-    pub fn get_element<'blk>(&self, bcx: Block<'blk, 'tcx>, ty: Ty<'tcx>,\n-                             gep: |ValueRef| -> ValueRef)\n-                             -> Datum<'tcx, Lvalue> {\n+    pub fn get_element<'blk, F>(&self, bcx: Block<'blk, 'tcx>, ty: Ty<'tcx>,\n+                                gep: F)\n+                                -> Datum<'tcx, Lvalue> where\n+        F: FnOnce(ValueRef) -> ValueRef,\n+    {\n         let val = match self.ty.sty {\n             _ if ty::type_is_sized(bcx.tcx(), self.ty) => gep(self.val),\n             ty::ty_open(_) => {"}, {"sha": "de169fc9d62a6f2f67e92beac98b4e73b94e137c", "filename": "src/librustc_trans/trans/debuginfo.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -3212,13 +3212,13 @@ fn populate_scope_map(cx: &CrateContext,\n     });\n \n     // local helper functions for walking the AST.\n-    fn with_new_scope(cx: &CrateContext,\n-                      scope_span: Span,\n-                      scope_stack: &mut Vec<ScopeStackEntry> ,\n-                      scope_map: &mut NodeMap<DIScope>,\n-                      inner_walk: |&CrateContext,\n-                                   &mut Vec<ScopeStackEntry> ,\n-                                   &mut NodeMap<DIScope>|) {\n+    fn with_new_scope<F>(cx: &CrateContext,\n+                         scope_span: Span,\n+                         scope_stack: &mut Vec<ScopeStackEntry> ,\n+                         scope_map: &mut NodeMap<DIScope>,\n+                         inner_walk: F) where\n+        F: FnOnce(&CrateContext, &mut Vec<ScopeStackEntry>, &mut NodeMap<DIScope>),\n+    {\n         // Create a new lexical scope and push it onto the stack\n         let loc = cx.sess().codemap().lookup_char_pos(scope_span.lo);\n         let file_metadata = file_metadata(cx, loc.file.name.as_slice());"}, {"sha": "e1769001942d586950358355618d518603289fed", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 51, "deletions": 40, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -295,6 +295,7 @@ fn apply_adjustments<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     // into a type to be destructed. If we want to end up with a Box pointer,\n     // then mk_ty should make a Box pointer (T -> Box<T>), if we want a\n     // borrowed reference then it should be T -> &T.\n+    // FIXME(#19596) unbox `mk_ty`\n     fn unsized_info<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                 kind: &ty::UnsizeKind<'tcx>,\n                                 id: ast::NodeId,\n@@ -341,27 +342,30 @@ fn apply_adjustments<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         debug!(\"dest_ty={}\", unsized_ty.repr(bcx.tcx()));\n         // Closures for extracting and manipulating the data and payload parts of\n         // the fat pointer.\n-        let base = match k {\n-            &ty::UnsizeStruct(..) =>\n-                |bcx, val| PointerCast(bcx,\n-                                       val,\n-                                       type_of::type_of(bcx.ccx(), unsized_ty).ptr_to()),\n-            &ty::UnsizeLength(..) =>\n-                |bcx, val| GEPi(bcx, val, &[0u, 0u]),\n-            &ty::UnsizeVtable(..) =>\n-                |_bcx, val| PointerCast(bcx, val, Type::i8p(bcx.ccx()))\n-        };\n-        let info = |bcx, _val| unsized_info(bcx,\n-                                            k,\n-                                            expr.id,\n-                                            datum_ty,\n-                                            |t| ty::mk_rptr(tcx,\n-                                                            ty::ReStatic,\n-                                                            ty::mt{\n-                                                                ty: t,\n-                                                                mutbl: ast::MutImmutable\n-                                                            }));\n-        into_fat_ptr(bcx, expr, datum, dest_ty, base, info)\n+        let info = |: bcx, _val| unsized_info(bcx,\n+                                              k,\n+                                              expr.id,\n+                                              datum_ty,\n+                                              |t| ty::mk_rptr(tcx,\n+                                                              ty::ReStatic,\n+                                                              ty::mt{\n+                                                                  ty: t,\n+                                                                  mutbl: ast::MutImmutable\n+                                                              }));\n+        match *k {\n+            ty::UnsizeStruct(..) =>\n+                into_fat_ptr(bcx, expr, datum, dest_ty, |bcx, val| {\n+                    PointerCast(bcx, val, type_of::type_of(bcx.ccx(), unsized_ty).ptr_to())\n+                }, info),\n+            ty::UnsizeLength(..) =>\n+                into_fat_ptr(bcx, expr, datum, dest_ty, |bcx, val| {\n+                    GEPi(bcx, val, &[0u, 0u])\n+                }, info),\n+            ty::UnsizeVtable(..) =>\n+                into_fat_ptr(bcx, expr, datum, dest_ty, |_bcx, val| {\n+                    PointerCast(bcx, val, Type::i8p(bcx.ccx()))\n+                }, info),\n+        }\n     }\n \n     fn ref_fat_ptr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n@@ -370,18 +374,21 @@ fn apply_adjustments<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                -> DatumBlock<'blk, 'tcx, Expr> {\n         let tcx = bcx.tcx();\n         let dest_ty = ty::close_type(tcx, datum.ty);\n-        let base = |bcx, val| Load(bcx, get_dataptr(bcx, val));\n-        let len = |bcx, val| Load(bcx, get_len(bcx, val));\n+        let base = |: bcx, val| Load(bcx, get_dataptr(bcx, val));\n+        let len = |: bcx, val| Load(bcx, get_len(bcx, val));\n         into_fat_ptr(bcx, expr, datum, dest_ty, base, len)\n     }\n \n-    fn into_fat_ptr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                expr: &ast::Expr,\n-                                datum: Datum<'tcx, Expr>,\n-                                dest_ty: Ty<'tcx>,\n-                                base: |Block<'blk, 'tcx>, ValueRef| -> ValueRef,\n-                                info: |Block<'blk, 'tcx>, ValueRef| -> ValueRef)\n-                                -> DatumBlock<'blk, 'tcx, Expr> {\n+    fn into_fat_ptr<'blk, 'tcx, F, G>(bcx: Block<'blk, 'tcx>,\n+                                      expr: &ast::Expr,\n+                                      datum: Datum<'tcx, Expr>,\n+                                      dest_ty: Ty<'tcx>,\n+                                      base: F,\n+                                      info: G)\n+                                      -> DatumBlock<'blk, 'tcx, Expr> where\n+        F: FnOnce(Block<'blk, 'tcx>, ValueRef) -> ValueRef,\n+        G: FnOnce(Block<'blk, 'tcx>, ValueRef) -> ValueRef,\n+    {\n         let mut bcx = bcx;\n \n         // Arrange cleanup\n@@ -659,17 +666,19 @@ fn trans_datum_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     }\n }\n \n-fn trans_field<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                           base: &ast::Expr,\n-                           get_idx: |&'blk ty::ctxt<'tcx>, &[ty::field<'tcx>]| -> uint)\n-                           -> DatumBlock<'blk, 'tcx, Expr> {\n+fn trans_field<'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n+                              base: &ast::Expr,\n+                              get_idx: F)\n+                              -> DatumBlock<'blk, 'tcx, Expr> where\n+    F: FnOnce(&'blk ty::ctxt<'tcx>, &[ty::field<'tcx>]) -> uint,\n+{\n     let mut bcx = bcx;\n     let _icx = push_ctxt(\"trans_rec_field\");\n \n     let base_datum = unpack_datum!(bcx, trans_to_lvalue(bcx, base, \"field\"));\n     let bare_ty = ty::unopen_type(base_datum.ty);\n     let repr = adt::represent_type(bcx.ccx(), bare_ty);\n-    with_field_tys(bcx.tcx(), bare_ty, None, |discr, field_tys| {\n+    with_field_tys(bcx.tcx(), bare_ty, None, move |discr, field_tys| {\n         let ix = get_idx(bcx.tcx(), field_tys);\n         let d = base_datum.get_element(\n             bcx,\n@@ -1254,11 +1263,13 @@ pub fn trans_local_var<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n /// Helper for enumerating the field types of structs, enums, or records. The optional node ID here\n /// is the node ID of the path identifying the enum variant in use. If none, this cannot possibly\n /// an enum variant (so, if it is and `node_id_opt` is none, this function panics).\n-pub fn with_field_tys<'tcx, R>(tcx: &ty::ctxt<'tcx>,\n-                               ty: Ty<'tcx>,\n-                               node_id_opt: Option<ast::NodeId>,\n-                               op: |ty::Disr, (&[ty::field<'tcx>])| -> R)\n-                               -> R {\n+pub fn with_field_tys<'tcx, R, F>(tcx: &ty::ctxt<'tcx>,\n+                                  ty: Ty<'tcx>,\n+                                  node_id_opt: Option<ast::NodeId>,\n+                                  op: F)\n+                                  -> R where\n+    F: FnOnce(ty::Disr, &[ty::field<'tcx>]) -> R,\n+{\n     match ty.sty {\n         ty::ty_struct(did, ref substs) => {\n             op(0, struct_fields(tcx, did, substs).as_slice())"}, {"sha": "980097eaead997648819ae2d6a529115a2bf650c", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -28,12 +28,14 @@ pub fn suptype<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>, sp: Span,\n         |sp, e, a, s| { fcx.report_mismatched_types(sp, e, a, s) })\n }\n \n-pub fn suptype_with_fn<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n-                                 sp: Span,\n-                                 b_is_expected: bool,\n-                                 ty_a: Ty<'tcx>,\n-                                 ty_b: Ty<'tcx>,\n-                                 handle_err: |Span, Ty<'tcx>, Ty<'tcx>, &ty::type_err<'tcx>|) {\n+pub fn suptype_with_fn<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n+                                    sp: Span,\n+                                    b_is_expected: bool,\n+                                    ty_a: Ty<'tcx>,\n+                                    ty_b: Ty<'tcx>,\n+                                    handle_err: F) where\n+    F: FnOnce(Span, Ty<'tcx>, Ty<'tcx>, &ty::type_err<'tcx>),\n+{\n     // n.b.: order of actual, expected is reversed\n     match infer::mk_subty(fcx.infcx(), b_is_expected, infer::Misc(sp),\n                           ty_b, ty_a) {"}, {"sha": "3c7cecc96a320d0f18254c3cab648ad298baffe2", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -286,11 +286,8 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n         }\n     }\n \n-    fn extract_trait_ref<R>(&mut self,\n-                            self_ty: Ty<'tcx>,\n-                            closure: |&mut ConfirmContext<'a,'tcx>,\n-                                      Ty<'tcx>, &ty::TyTrait<'tcx>| -> R)\n-                            -> R\n+    fn extract_trait_ref<R, F>(&mut self, self_ty: Ty<'tcx>, mut closure: F) -> R where\n+        F: FnMut(&mut ConfirmContext<'a, 'tcx>, Ty<'tcx>, &ty::TyTrait<'tcx>) -> R,\n     {\n         // If we specified that this is an object method, then the\n         // self-type ought to be something that can be dereferenced to\n@@ -665,9 +662,11 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n     }\n }\n \n-fn wrap_autoref<'tcx>(mut deref: ty::AutoDerefRef<'tcx>,\n-                      base_fn: |Option<Box<ty::AutoRef<'tcx>>>| -> ty::AutoRef<'tcx>)\n-                      -> ty::AutoDerefRef<'tcx> {\n+fn wrap_autoref<'tcx, F>(mut deref: ty::AutoDerefRef<'tcx>,\n+                         base_fn: F)\n+                         -> ty::AutoDerefRef<'tcx> where\n+    F: FnOnce(Option<Box<ty::AutoRef<'tcx>>>) -> ty::AutoRef<'tcx>,\n+{\n     let autoref = mem::replace(&mut deref.autoref, None);\n     let autoref = autoref.map(|r| box r);\n     deref.autoref = Some(base_fn(autoref));"}, {"sha": "adcfc491dcc4fecf7a0cd057e6211cc217508355", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -710,10 +710,12 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n                                                mutbl: m }))\n     }\n \n-    fn search_mutabilities(&mut self,\n-                           mk_adjustment: |ast::Mutability| -> PickAdjustment,\n-                           mk_autoref_ty: |ast::Mutability, ty::Region| -> Ty<'tcx>)\n-                           -> Option<PickResult<'tcx>>\n+    fn search_mutabilities<F, G>(&mut self,\n+                                 mut mk_adjustment: F,\n+                                 mut mk_autoref_ty: G)\n+                                 -> Option<PickResult<'tcx>> where\n+        F: FnMut(ast::Mutability) -> PickAdjustment,\n+        G: FnMut(ast::Mutability, ty::Region) -> Ty<'tcx>,\n     {\n         // In general, during probing we erase regions. See\n         // `impl_self_ty()` for an explanation."}, {"sha": "18a773fb949fcec1ec1c3b4e728d9b57031f557d", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 48, "deletions": 40, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -1885,9 +1885,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self.inh.item_substs.borrow()\n     }\n \n-    pub fn opt_node_ty_substs(&self,\n-                              id: ast::NodeId,\n-                              f: |&ty::ItemSubsts<'tcx>|) {\n+    pub fn opt_node_ty_substs<F>(&self,\n+                                 id: ast::NodeId,\n+                                 f: F) where\n+        F: FnOnce(&ty::ItemSubsts<'tcx>),\n+    {\n         match self.inh.item_substs.borrow().get(&id) {\n             Some(s) => { f(s) }\n             None => { }\n@@ -1938,11 +1940,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         infer::mk_subr(self.infcx(), origin, sub, sup)\n     }\n \n-    pub fn type_error_message(&self,\n-                              sp: Span,\n-                              mk_msg: |String| -> String,\n-                              actual_ty: Ty<'tcx>,\n-                              err: Option<&ty::type_err<'tcx>>) {\n+    pub fn type_error_message<M>(&self,\n+                                 sp: Span,\n+                                 mk_msg: M,\n+                                 actual_ty: Ty<'tcx>,\n+                                 err: Option<&ty::type_err<'tcx>>) where\n+        M: FnOnce(String) -> String,\n+    {\n         self.infcx().type_error_message(sp, mk_msg, actual_ty, err);\n     }\n \n@@ -2025,12 +2029,14 @@ impl Copy for LvaluePreference {}\n ///\n /// Note: this method does not modify the adjustments table. The caller is responsible for\n /// inserting an AutoAdjustment record into the `fcx` using one of the suitable methods.\n-pub fn autoderef<'a, 'tcx, T>(fcx: &FnCtxt<'a, 'tcx>, sp: Span,\n-                              base_ty: Ty<'tcx>,\n-                              expr_id: Option<ast::NodeId>,\n-                              mut lvalue_pref: LvaluePreference,\n-                              should_stop: |Ty<'tcx>, uint| -> Option<T>)\n-                              -> (Ty<'tcx>, uint, Option<T>) {\n+pub fn autoderef<'a, 'tcx, T, F>(fcx: &FnCtxt<'a, 'tcx>, sp: Span,\n+                                 base_ty: Ty<'tcx>,\n+                                 expr_id: Option<ast::NodeId>,\n+                                 mut lvalue_pref: LvaluePreference,\n+                                 mut should_stop: F)\n+                                 -> (Ty<'tcx>, uint, Option<T>) where\n+    F: FnMut(Ty<'tcx>, uint) -> Option<T>,\n+{\n     let mut t = base_ty;\n     for autoderefs in range(0, fcx.tcx().sess.recursion_limit.get()) {\n         let resolved_t = structurally_resolved_type(fcx, sp, t);\n@@ -2192,12 +2198,13 @@ fn make_overloaded_lvalue_return_type<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     }\n }\n \n-fn autoderef_for_index<'a, 'tcx, T>(fcx: &FnCtxt<'a, 'tcx>,\n-                                    base_expr: &ast::Expr,\n-                                    base_ty: Ty<'tcx>,\n-                                    lvalue_pref: LvaluePreference,\n-                                    step: |Ty<'tcx>, ty::AutoDerefRef<'tcx>| -> Option<T>)\n-                                    -> Option<T>\n+fn autoderef_for_index<'a, 'tcx, T, F>(fcx: &FnCtxt<'a, 'tcx>,\n+                                       base_expr: &ast::Expr,\n+                                       base_ty: Ty<'tcx>,\n+                                       lvalue_pref: LvaluePreference,\n+                                       mut step: F)\n+                                       -> Option<T> where\n+    F: FnMut(Ty<'tcx>, ty::AutoDerefRef<'tcx>) -> Option<T>,\n {\n     // FIXME(#18741) -- this is almost but not quite the same as the\n     // autoderef that normal method probing does. They could likely be\n@@ -2936,11 +2943,12 @@ enum TupleArgumentsFlag {\n /// Note that inspecting a type's structure *directly* may expose the fact\n /// that there are actually multiple representations for `ty_err`, so avoid\n /// that when err needs to be handled differently.\n-fn check_expr_with_unifier<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n-                                     expr: &ast::Expr,\n-                                     expected: Expectation<'tcx>,\n-                                     lvalue_pref: LvaluePreference,\n-                                     unifier: ||)\n+fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n+                                        expr: &ast::Expr,\n+                                        expected: Expectation<'tcx>,\n+                                        lvalue_pref: LvaluePreference,\n+                                        unifier: F) where\n+    F: FnOnce(),\n {\n     debug!(\">> typechecking: expr={} expected={}\",\n            expr.repr(fcx.tcx()), expected.repr(fcx.tcx()));\n@@ -3115,14 +3123,16 @@ fn check_expr_with_unifier<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         fcx.write_ty(id, if_ty);\n     }\n \n-    fn lookup_op_method<'a, 'tcx>(fcx: &'a FnCtxt<'a, 'tcx>,\n-                                  op_ex: &ast::Expr,\n-                                  lhs_ty: Ty<'tcx>,\n-                                  opname: ast::Name,\n-                                  trait_did: Option<ast::DefId>,\n-                                  lhs: &'a ast::Expr,\n-                                  rhs: Option<&P<ast::Expr>>,\n-                                  unbound_method: ||) -> Ty<'tcx> {\n+    fn lookup_op_method<'a, 'tcx, F>(fcx: &'a FnCtxt<'a, 'tcx>,\n+                                     op_ex: &ast::Expr,\n+                                     lhs_ty: Ty<'tcx>,\n+                                     opname: ast::Name,\n+                                     trait_did: Option<ast::DefId>,\n+                                     lhs: &'a ast::Expr,\n+                                     rhs: Option<&P<ast::Expr>>,\n+                                     unbound_method: F) -> Ty<'tcx> where\n+        F: FnOnce(),\n+    {\n         let method = match trait_did {\n             Some(trait_did) => {\n                 // We do eager coercions to make using operators\n@@ -4374,19 +4384,17 @@ impl<'tcx> Expectation<'tcx> {\n         }\n     }\n \n-    fn map<'a>(self, fcx: &FnCtxt<'a, 'tcx>,\n-               unpack: |&ty::sty<'tcx>| -> Expectation<'tcx>)\n-               -> Expectation<'tcx> {\n+    fn map<'a, F>(self, fcx: &FnCtxt<'a, 'tcx>, unpack: F) -> Expectation<'tcx> where\n+        F: FnOnce(&ty::sty<'tcx>) -> Expectation<'tcx>\n+    {\n         match self.resolve(fcx) {\n             NoExpectation => NoExpectation,\n             ExpectCastableToType(t) | ExpectHasType(t) => unpack(&t.sty),\n         }\n     }\n \n-    fn map_to_option<'a, O>(self,\n-                            fcx: &FnCtxt<'a, 'tcx>,\n-                            unpack: |&ty::sty<'tcx>| -> Option<O>)\n-                            -> Option<O>\n+    fn map_to_option<'a, O, F>(self, fcx: &FnCtxt<'a, 'tcx>, unpack: F) -> Option<O> where\n+        F: FnOnce(&ty::sty<'tcx>) -> Option<O>,\n     {\n         match self.resolve(fcx) {\n             NoExpectation => None,"}, {"sha": "32c732c2467167aab02e7e31b911a59af52bdf71", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -74,6 +74,7 @@ This API is completely unstable and subject to change.\n #![feature(default_type_params, globs, import_shadowing, macro_rules, phase, quote)]\n #![feature(slicing_syntax, unsafe_destructor)]\n #![feature(rustc_diagnostic_macros)]\n+#![feature(unboxed_closures)]\n #![allow(non_camel_case_types)]\n \n #[phase(plugin, link)] extern crate log;\n@@ -169,14 +170,16 @@ fn no_params<'tcx>(t: Ty<'tcx>) -> ty::Polytype<'tcx> {\n     }\n }\n \n-fn require_same_types<'a, 'tcx>(tcx: &ty::ctxt<'tcx>,\n-                                    maybe_infcx: Option<&infer::InferCtxt<'a, 'tcx>>,\n-                                    t1_is_expected: bool,\n-                                    span: Span,\n-                                    t1: Ty<'tcx>,\n-                                    t2: Ty<'tcx>,\n-                                    msg: || -> String)\n-                                    -> bool {\n+fn require_same_types<'a, 'tcx, M>(tcx: &ty::ctxt<'tcx>,\n+                                   maybe_infcx: Option<&infer::InferCtxt<'a, 'tcx>>,\n+                                   t1_is_expected: bool,\n+                                   span: Span,\n+                                   t1: Ty<'tcx>,\n+                                   t2: Ty<'tcx>,\n+                                   msg: M)\n+                                   -> bool where\n+    M: FnOnce() -> String,\n+{\n     let result = match maybe_infcx {\n         None => {\n             let infcx = infer::new_infer_ctxt(tcx);"}, {"sha": "5623c0f0e535fb880b704cde3d6aeb8c91b9e12a", "filename": "src/librustdoc/fold.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustdoc%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustdoc%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ffold.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -79,8 +79,7 @@ pub trait DocFolder {\n                     StructVariant(mut j) => {\n                         let mut foo = Vec::new(); swap(&mut foo, &mut j.fields);\n                         let num_fields = foo.len();\n-                        let c = |x| self.fold_item(x);\n-                        j.fields.extend(foo.into_iter().filter_map(c));\n+                        j.fields.extend(foo.into_iter().filter_map(|x| self.fold_item(x)));\n                         j.fields_stripped |= num_fields != j.fields.len();\n                         VariantItem(Variant {kind: StructVariant(j), ..i2})\n                     },"}, {"sha": "051e8a3568fb64306c3094963807aa4ab2bd4d5c", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -218,10 +218,14 @@ fn resolved_path(w: &mut fmt::Formatter, did: ast::DefId, p: &clean::Path,\n         })\n }\n \n-fn path(w: &mut fmt::Formatter, path: &clean::Path, print_all: bool,\n-        root: |&render::Cache, &[String]| -> Option<String>,\n-        info: |&render::Cache| -> Option<(Vec<String> , ItemType)>)\n-    -> fmt::Result\n+fn path<F, G>(w: &mut fmt::Formatter,\n+              path: &clean::Path,\n+              print_all: bool,\n+              root: F,\n+              info: G)\n+              -> fmt::Result where\n+    F: FnOnce(&render::Cache, &[String]) -> Option<String>,\n+    G: FnOnce(&render::Cache) -> Option<(Vec<String>, ItemType)>,\n {\n     // The generics will get written to both the title and link\n     let mut generics = String::new();"}, {"sha": "cba58db7c7f733516f2db8ec161bbc8c1fe55fd1", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -393,7 +393,7 @@ impl LangString {\n         let mut seen_other_tags = false;\n         let mut data = LangString::all_false();\n \n-        let mut tokens = string.split(|c: char|\n+        let mut tokens = string.split(|&: c: char|\n             !(c == '_' || c == '-' || c.is_alphanumeric())\n         );\n "}, {"sha": "63b1f5ca0497daf28e6b8f8adf1590c4b8b23b16", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -646,7 +646,9 @@ fn shortty(item: &clean::Item) -> ItemType {\n /// static HTML tree.\n // FIXME (#9639): The closure should deal with &[u8] instead of &str\n // FIXME (#9639): This is too conservative, rejecting non-UTF-8 paths\n-fn clean_srcpath(src_root: &Path, src: &[u8], f: |&str|) {\n+fn clean_srcpath<F>(src_root: &Path, src: &[u8], mut f: F) where\n+    F: FnMut(&str),\n+{\n     let p = Path::new(src);\n \n     // make it relative, if possible\n@@ -1051,7 +1053,9 @@ impl<'a> Cache {\n impl Context {\n     /// Recurse in the directory structure and change the \"root path\" to make\n     /// sure it always points to the top (relatively)\n-    fn recurse<T>(&mut self, s: String, f: |&mut Context| -> T) -> T {\n+    fn recurse<T, F>(&mut self, s: String, f: F) -> T where\n+        F: FnOnce(&mut Context) -> T,\n+    {\n         if s.len() == 0 {\n             panic!(\"Unexpected empty destination: {}\", self.current);\n         }\n@@ -1131,8 +1135,9 @@ impl Context {\n     /// all sub-items which need to be rendered.\n     ///\n     /// The rendering driver uses this closure to queue up more work.\n-    fn item(&mut self, item: clean::Item,\n-            f: |&mut Context, clean::Item|) -> io::IoResult<()> {\n+    fn item<F>(&mut self, item: clean::Item, mut f: F) -> io::IoResult<()> where\n+        F: FnMut(&mut Context, clean::Item),\n+    {\n         fn render(w: io::File, cx: &Context, it: &clean::Item,\n                   pushname: bool) -> io::IoResult<()> {\n             info!(\"Rendering an item to {}\", w.path().display());"}, {"sha": "6da7ec40f3472380ce99209a29051388cc75610e", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -19,6 +19,7 @@\n \n #![allow(unknown_features)]\n #![feature(globs, macro_rules, phase, slicing_syntax)]\n+#![feature(unboxed_closures)]\n \n extern crate arena;\n extern crate getopts;"}, {"sha": "c1b48e989a1c142ff85bc32bbc677fe4ff31877d", "filename": "src/librustrt/args.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustrt%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustrt%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Fargs.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -89,7 +89,7 @@ mod imp {\n         })\n     }\n \n-    fn with_lock<T>(f: || -> T) -> T {\n+    fn with_lock<T, F>(f: F) -> T where F: FnOnce() -> T {\n         unsafe {\n             let _guard = LOCK.lock();\n             f()\n@@ -128,7 +128,7 @@ mod imp {\n             assert!(take() == Some(expected.clone()));\n             assert!(take() == None);\n \n-            (|| {\n+            (|&mut:| {\n             }).finally(|| {\n                 // Restore the actual global state.\n                 match saved_value {"}, {"sha": "865c1af1d14272e6c8f85970c43b8a45dcb710cb", "filename": "src/librustrt/c_str.rs", "status": "modified", "additions": 41, "deletions": 16, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustrt%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustrt%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Fc_str.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -72,6 +72,7 @@ use collections::hash;\n use core::fmt;\n use core::kinds::{Sized, marker};\n use core::mem;\n+use core::ops::{FnMut, FnOnce};\n use core::prelude::{Clone, Drop, Eq, Iterator};\n use core::prelude::{SlicePrelude, None, Option, Ordering, PartialEq};\n use core::prelude::{PartialOrd, RawPtr, Some, StrPrelude, range};\n@@ -319,14 +320,18 @@ pub trait ToCStr for Sized? {\n     ///\n     /// Panics the task if the receiver has an interior null.\n     #[inline]\n-    fn with_c_str<T>(&self, f: |*const libc::c_char| -> T) -> T {\n+    fn with_c_str<T, F>(&self, f: F) -> T where\n+        F: FnOnce(*const libc::c_char) -> T,\n+    {\n         let c_str = self.to_c_str();\n         f(c_str.as_ptr())\n     }\n \n     /// Unsafe variant of `with_c_str()` that doesn't check for nulls.\n     #[inline]\n-    unsafe fn with_c_str_unchecked<T>(&self, f: |*const libc::c_char| -> T) -> T {\n+    unsafe fn with_c_str_unchecked<T, F>(&self, f: F) -> T where\n+        F: FnOnce(*const libc::c_char) -> T,\n+    {\n         let c_str = self.to_c_str_unchecked();\n         f(c_str.as_ptr())\n     }\n@@ -344,12 +349,16 @@ impl ToCStr for str {\n     }\n \n     #[inline]\n-    fn with_c_str<T>(&self, f: |*const libc::c_char| -> T) -> T {\n+    fn with_c_str<T, F>(&self, f: F) -> T where\n+        F: FnOnce(*const libc::c_char) -> T,\n+    {\n         self.as_bytes().with_c_str(f)\n     }\n \n     #[inline]\n-    unsafe fn with_c_str_unchecked<T>(&self, f: |*const libc::c_char| -> T) -> T {\n+    unsafe fn with_c_str_unchecked<T, F>(&self, f: F) -> T where\n+        F: FnOnce(*const libc::c_char) -> T,\n+    {\n         self.as_bytes().with_c_str_unchecked(f)\n     }\n }\n@@ -366,12 +375,16 @@ impl ToCStr for String {\n     }\n \n     #[inline]\n-    fn with_c_str<T>(&self, f: |*const libc::c_char| -> T) -> T {\n+    fn with_c_str<T, F>(&self, f: F) -> T where\n+        F: FnOnce(*const libc::c_char) -> T,\n+    {\n         self.as_bytes().with_c_str(f)\n     }\n \n     #[inline]\n-    unsafe fn with_c_str_unchecked<T>(&self, f: |*const libc::c_char| -> T) -> T {\n+    unsafe fn with_c_str_unchecked<T, F>(&self, f: F) -> T where\n+        F: FnOnce(*const libc::c_char) -> T,\n+    {\n         self.as_bytes().with_c_str_unchecked(f)\n     }\n }\n@@ -397,11 +410,15 @@ impl ToCStr for [u8] {\n         CString::new(buf as *const libc::c_char, true)\n     }\n \n-    fn with_c_str<T>(&self, f: |*const libc::c_char| -> T) -> T {\n+    fn with_c_str<T, F>(&self, f: F) -> T where\n+        F: FnOnce(*const libc::c_char) -> T,\n+    {\n         unsafe { with_c_str(self, true, f) }\n     }\n \n-    unsafe fn with_c_str_unchecked<T>(&self, f: |*const libc::c_char| -> T) -> T {\n+    unsafe fn with_c_str_unchecked<T, F>(&self, f: F) -> T where\n+        F: FnOnce(*const libc::c_char) -> T,\n+    {\n         with_c_str(self, false, f)\n     }\n }\n@@ -418,19 +435,24 @@ impl<'a, Sized? T: ToCStr> ToCStr for &'a T {\n     }\n \n     #[inline]\n-    fn with_c_str<T>(&self, f: |*const libc::c_char| -> T) -> T {\n+    fn with_c_str<T, F>(&self, f: F) -> T where\n+        F: FnOnce(*const libc::c_char) -> T,\n+    {\n         (**self).with_c_str(f)\n     }\n \n     #[inline]\n-    unsafe fn with_c_str_unchecked<T>(&self, f: |*const libc::c_char| -> T) -> T {\n+    unsafe fn with_c_str_unchecked<T, F>(&self, f: F) -> T where\n+        F: FnOnce(*const libc::c_char) -> T,\n+    {\n         (**self).with_c_str_unchecked(f)\n     }\n }\n \n // Unsafe function that handles possibly copying the &[u8] into a stack array.\n-unsafe fn with_c_str<T>(v: &[u8], checked: bool,\n-                        f: |*const libc::c_char| -> T) -> T {\n+unsafe fn with_c_str<T, F>(v: &[u8], checked: bool, f: F) -> T where\n+    F: FnOnce(*const libc::c_char) -> T,\n+{\n     let c_str = if v.len() < BUF_LEN {\n         let mut buf: [u8, .. BUF_LEN] = mem::uninitialized();\n         slice::bytes::copy_memory(&mut buf, v);\n@@ -489,9 +511,12 @@ impl<'a> Iterator<libc::c_char> for CChars<'a> {\n ///\n /// The specified closure is invoked with each string that\n /// is found, and the number of strings found is returned.\n-pub unsafe fn from_c_multistring(buf: *const libc::c_char,\n-                                 count: Option<uint>,\n-                                 f: |&CString|) -> uint {\n+pub unsafe fn from_c_multistring<F>(buf: *const libc::c_char,\n+                                    count: Option<uint>,\n+                                    mut f: F)\n+                                    -> uint where\n+    F: FnMut(&CString),\n+{\n \n     let mut curr_ptr: uint = buf as uint;\n     let mut ctr = 0;\n@@ -678,7 +703,7 @@ mod tests {\n \n     #[test]\n     fn test_clone_noleak() {\n-        fn foo(f: |c: &CString|) {\n+        fn foo<F>(f: F) where F: FnOnce(&CString) {\n             let s = \"test\".to_string();\n             let c = s.to_c_str();\n             // give the closure a non-owned CString"}, {"sha": "c2ee91d6acca281943ef94b31aa28805558bdda6", "filename": "src/librustrt/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustrt%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustrt%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Flib.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -19,6 +19,7 @@\n #![feature(macro_rules, phase, globs, thread_local, asm)]\n #![feature(linkage, lang_items, unsafe_destructor, default_type_params)]\n #![feature(import_shadowing, slicing_syntax)]\n+#![feature(unboxed_closures)]\n #![no_std]\n #![experimental]\n "}, {"sha": "7e657d3aef39197c27a0a0da77218026d7c70497", "filename": "src/librustrt/task.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustrt%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibrustrt%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Ftask.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -22,6 +22,7 @@ use core::atomic::{AtomicUint, SeqCst};\n use core::iter::{IteratorExt, Take};\n use core::kinds::marker;\n use core::mem;\n+use core::ops::FnMut;\n use core::prelude::{Clone, Drop, Err, Iterator, None, Ok, Option, Send, Some};\n use core::prelude::{drop};\n \n@@ -297,9 +298,9 @@ impl Task {\n     // `awoken` field which indicates whether we were actually woken up via some\n     // invocation of `reawaken`. This flag is only ever accessed inside the\n     // lock, so there's no need to make it atomic.\n-    pub fn deschedule(mut self: Box<Task>,\n-                      times: uint,\n-                      f: |BlockedTask| -> ::core::result::Result<(), BlockedTask>) {\n+    pub fn deschedule<F>(mut self: Box<Task>, times: uint, mut f: F) where\n+        F: FnMut(BlockedTask) -> ::core::result::Result<(), BlockedTask>,\n+    {\n         unsafe {\n             let me = &mut *self as *mut Task;\n             let task = BlockedTask::block(self);"}, {"sha": "d34828ccee328e58822e2a6262963d9ce4393b06", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 197, "deletions": 162, "changes": 359, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -458,17 +458,19 @@ impl<'a> ::Encoder<io::IoError> for Encoder<'a> {\n         escape_str(self.writer, v)\n     }\n \n-    fn emit_enum(&mut self,\n-                 _name: &str,\n-                 f: |&mut Encoder<'a>| -> EncodeResult) -> EncodeResult {\n+    fn emit_enum<F>(&mut self, _name: &str, f: F) -> EncodeResult where\n+        F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n+    {\n         f(self)\n     }\n \n-    fn emit_enum_variant(&mut self,\n-                         name: &str,\n-                         _id: uint,\n-                         cnt: uint,\n-                         f: |&mut Encoder<'a>| -> EncodeResult) -> EncodeResult {\n+    fn emit_enum_variant<F>(&mut self,\n+                            name: &str,\n+                            _id: uint,\n+                            cnt: uint,\n+                            f: F) -> EncodeResult where\n+        F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n+    {\n         // enums are encoded as strings or objects\n         // Bunny => \"Bunny\"\n         // Kangaroo(34,\"William\") => {\"variant\": \"Kangaroo\", \"fields\": [34,\"William\"]}\n@@ -483,100 +485,113 @@ impl<'a> ::Encoder<io::IoError> for Encoder<'a> {\n         }\n     }\n \n-    fn emit_enum_variant_arg(&mut self,\n-                             idx: uint,\n-                             f: |&mut Encoder<'a>| -> EncodeResult) -> EncodeResult {\n+    fn emit_enum_variant_arg<F>(&mut self, idx: uint, f: F) -> EncodeResult where\n+        F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n+    {\n         if idx != 0 {\n             try!(write!(self.writer, \",\"));\n         }\n         f(self)\n     }\n \n-    fn emit_enum_struct_variant(&mut self,\n-                                name: &str,\n-                                id: uint,\n-                                cnt: uint,\n-                                f: |&mut Encoder<'a>| -> EncodeResult) -> EncodeResult {\n+    fn emit_enum_struct_variant<F>(&mut self,\n+                                   name: &str,\n+                                   id: uint,\n+                                   cnt: uint,\n+                                   f: F) -> EncodeResult where\n+        F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n+    {\n         self.emit_enum_variant(name, id, cnt, f)\n     }\n \n-    fn emit_enum_struct_variant_field(&mut self,\n-                                      _: &str,\n-                                      idx: uint,\n-                                      f: |&mut Encoder<'a>| -> EncodeResult) -> EncodeResult {\n+    fn emit_enum_struct_variant_field<F>(&mut self,\n+                                         _: &str,\n+                                         idx: uint,\n+                                         f: F) -> EncodeResult where\n+        F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n+    {\n         self.emit_enum_variant_arg(idx, f)\n     }\n \n-    fn emit_struct(&mut self,\n-                   _: &str,\n-                   _: uint,\n-                   f: |&mut Encoder<'a>| -> EncodeResult) -> EncodeResult {\n+    fn emit_struct<F>(&mut self, _: &str, _: uint, f: F) -> EncodeResult where\n+        F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n+    {\n         try!(write!(self.writer, \"{{\"));\n         try!(f(self));\n         write!(self.writer, \"}}\")\n     }\n \n-    fn emit_struct_field(&mut self,\n-                         name: &str,\n-                         idx: uint,\n-                         f: |&mut Encoder<'a>| -> EncodeResult) -> EncodeResult {\n+    fn emit_struct_field<F>(&mut self, name: &str, idx: uint, f: F) -> EncodeResult where\n+        F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n+    {\n         if idx != 0 { try!(write!(self.writer, \",\")); }\n         try!(escape_str(self.writer, name));\n         try!(write!(self.writer, \":\"));\n         f(self)\n     }\n \n-    fn emit_tuple(&mut self, len: uint, f: |&mut Encoder<'a>| -> EncodeResult) -> EncodeResult {\n+    fn emit_tuple<F>(&mut self, len: uint, f: F) -> EncodeResult where\n+        F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n+    {\n         self.emit_seq(len, f)\n     }\n-    fn emit_tuple_arg(&mut self,\n-                      idx: uint,\n-                      f: |&mut Encoder<'a>| -> EncodeResult) -> EncodeResult {\n+    fn emit_tuple_arg<F>(&mut self, idx: uint, f: F) -> EncodeResult where\n+        F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n+    {\n         self.emit_seq_elt(idx, f)\n     }\n \n-    fn emit_tuple_struct(&mut self,\n-                         _name: &str,\n-                         len: uint,\n-                         f: |&mut Encoder<'a>| -> EncodeResult) -> EncodeResult {\n+    fn emit_tuple_struct<F>(&mut self, _name: &str, len: uint, f: F) -> EncodeResult where\n+        F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n+    {\n         self.emit_seq(len, f)\n     }\n-    fn emit_tuple_struct_arg(&mut self,\n-                             idx: uint,\n-                             f: |&mut Encoder<'a>| -> EncodeResult) -> EncodeResult {\n+    fn emit_tuple_struct_arg<F>(&mut self, idx: uint, f: F) -> EncodeResult where\n+        F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n+    {\n         self.emit_seq_elt(idx, f)\n     }\n \n-    fn emit_option(&mut self, f: |&mut Encoder<'a>| -> EncodeResult) -> EncodeResult {\n+    fn emit_option<F>(&mut self, f: F) -> EncodeResult where\n+        F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n+    {\n         f(self)\n     }\n     fn emit_option_none(&mut self) -> EncodeResult { self.emit_nil() }\n-    fn emit_option_some(&mut self, f: |&mut Encoder<'a>| -> EncodeResult) -> EncodeResult {\n+    fn emit_option_some<F>(&mut self, f: F) -> EncodeResult where\n+        F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n+    {\n         f(self)\n     }\n \n-    fn emit_seq(&mut self, _len: uint, f: |&mut Encoder<'a>| -> EncodeResult) -> EncodeResult {\n+    fn emit_seq<F>(&mut self, _len: uint, f: F) -> EncodeResult where\n+        F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n+    {\n         try!(write!(self.writer, \"[\"));\n         try!(f(self));\n         write!(self.writer, \"]\")\n     }\n \n-    fn emit_seq_elt(&mut self, idx: uint, f: |&mut Encoder<'a>| -> EncodeResult) -> EncodeResult {\n+    fn emit_seq_elt<F>(&mut self, idx: uint, f: F) -> EncodeResult where\n+        F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n+    {\n         if idx != 0 {\n             try!(write!(self.writer, \",\"));\n         }\n         f(self)\n     }\n \n-    fn emit_map(&mut self, _len: uint, f: |&mut Encoder<'a>| -> EncodeResult) -> EncodeResult {\n+    fn emit_map<F>(&mut self, _len: uint, f: F) -> EncodeResult where\n+        F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n+    {\n         try!(write!(self.writer, \"{{\"));\n         try!(f(self));\n         write!(self.writer, \"}}\")\n     }\n \n-    fn emit_map_elt_key(&mut self,\n-                        idx: uint,\n-                        f: |&mut Encoder<'a>| -> EncodeResult) -> EncodeResult {\n+    fn emit_map_elt_key<F>(&mut self, idx: uint, mut f: F) -> EncodeResult where\n+        F: FnMut(&mut Encoder<'a>) -> EncodeResult,\n+    {\n         if idx != 0 { try!(write!(self.writer, \",\")) }\n         // ref #12967, make sure to wrap a key in double quotes,\n         // in the event that its of a type that omits them (eg numbers)\n@@ -594,9 +609,9 @@ impl<'a> ::Encoder<io::IoError> for Encoder<'a> {\n         Ok(())\n     }\n \n-    fn emit_map_elt_val(&mut self,\n-                        _idx: uint,\n-                        f: |&mut Encoder<'a>| -> EncodeResult) -> EncodeResult {\n+    fn emit_map_elt_val<F>(&mut self, _idx: uint, f: F) -> EncodeResult where\n+        F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n+    {\n         try!(write!(self.writer, \":\"));\n         f(self)\n     }\n@@ -663,17 +678,20 @@ impl<'a> ::Encoder<io::IoError> for PrettyEncoder<'a> {\n         escape_str(self.writer, v)\n     }\n \n-    fn emit_enum(&mut self,\n-                 _name: &str,\n-                 f: |&mut PrettyEncoder<'a>| -> EncodeResult) -> EncodeResult {\n+    fn emit_enum<F>(&mut self, _name: &str, f: F) -> EncodeResult where\n+        F: FnOnce(&mut PrettyEncoder<'a>) -> EncodeResult,\n+    {\n         f(self)\n     }\n \n-    fn emit_enum_variant(&mut self,\n-                         name: &str,\n-                         _id: uint,\n-                         cnt: uint,\n-                         f: |&mut PrettyEncoder<'a>| -> EncodeResult) -> EncodeResult {\n+    fn emit_enum_variant<F>(&mut self,\n+                            name: &str,\n+                            _id: uint,\n+                            cnt: uint,\n+                            f: F)\n+                            -> EncodeResult where\n+        F: FnOnce(&mut PrettyEncoder<'a>) -> EncodeResult,\n+    {\n         if cnt == 0 {\n             escape_str(self.writer, name)\n         } else {\n@@ -697,36 +715,39 @@ impl<'a> ::Encoder<io::IoError> for PrettyEncoder<'a> {\n         }\n     }\n \n-    fn emit_enum_variant_arg(&mut self,\n-                             idx: uint,\n-                             f: |&mut PrettyEncoder<'a>| -> EncodeResult) -> EncodeResult {\n+    fn emit_enum_variant_arg<F>(&mut self, idx: uint, f: F) -> EncodeResult where\n+        F: FnOnce(&mut PrettyEncoder<'a>) -> EncodeResult,\n+    {\n         if idx != 0 {\n             try!(write!(self.writer, \",\\n\"));\n         }\n         try!(spaces(self.writer, self.curr_indent));\n         f(self)\n     }\n \n-    fn emit_enum_struct_variant(&mut self,\n-                                name: &str,\n-                                id: uint,\n-                                cnt: uint,\n-                                f: |&mut PrettyEncoder<'a>| -> EncodeResult) -> EncodeResult {\n+    fn emit_enum_struct_variant<F>(&mut self,\n+                                   name: &str,\n+                                   id: uint,\n+                                   cnt: uint,\n+                                   f: F) -> EncodeResult where\n+        F: FnOnce(&mut PrettyEncoder<'a>) -> EncodeResult,\n+    {\n         self.emit_enum_variant(name, id, cnt, f)\n     }\n \n-    fn emit_enum_struct_variant_field(&mut self,\n-                                      _: &str,\n-                                      idx: uint,\n-                                      f: |&mut PrettyEncoder<'a>| -> EncodeResult) -> EncodeResult {\n+    fn emit_enum_struct_variant_field<F>(&mut self,\n+                                         _: &str,\n+                                         idx: uint,\n+                                         f: F) -> EncodeResult where\n+        F: FnOnce(&mut PrettyEncoder<'a>) -> EncodeResult,\n+    {\n         self.emit_enum_variant_arg(idx, f)\n     }\n \n \n-    fn emit_struct(&mut self,\n-                   _: &str,\n-                   len: uint,\n-                   f: |&mut PrettyEncoder<'a>| -> EncodeResult) -> EncodeResult {\n+    fn emit_struct<F>(&mut self, _: &str, len: uint, f: F) -> EncodeResult where\n+        F: FnOnce(&mut PrettyEncoder<'a>) -> EncodeResult,\n+    {\n         if len == 0 {\n             write!(self.writer, \"{{}}\")\n         } else {\n@@ -740,10 +761,9 @@ impl<'a> ::Encoder<io::IoError> for PrettyEncoder<'a> {\n         }\n     }\n \n-    fn emit_struct_field(&mut self,\n-                         name: &str,\n-                         idx: uint,\n-                         f: |&mut PrettyEncoder<'a>| -> EncodeResult) -> EncodeResult {\n+    fn emit_struct_field<F>(&mut self, name: &str, idx: uint, f: F) -> EncodeResult where\n+        F: FnOnce(&mut PrettyEncoder<'a>) -> EncodeResult,\n+    {\n         if idx == 0 {\n             try!(write!(self.writer, \"\\n\"));\n         } else {\n@@ -755,40 +775,43 @@ impl<'a> ::Encoder<io::IoError> for PrettyEncoder<'a> {\n         f(self)\n     }\n \n-    fn emit_tuple(&mut self,\n-                  len: uint,\n-                  f: |&mut PrettyEncoder<'a>| -> EncodeResult) -> EncodeResult {\n+    fn emit_tuple<F>(&mut self, len: uint, f: F) -> EncodeResult where\n+        F: FnOnce(&mut PrettyEncoder<'a>) -> EncodeResult,\n+    {\n         self.emit_seq(len, f)\n     }\n-    fn emit_tuple_arg(&mut self,\n-                      idx: uint,\n-                      f: |&mut PrettyEncoder<'a>| -> EncodeResult) -> EncodeResult {\n+    fn emit_tuple_arg<F>(&mut self, idx: uint, f: F) -> EncodeResult where\n+        F: FnOnce(&mut PrettyEncoder<'a>) -> EncodeResult,\n+    {\n         self.emit_seq_elt(idx, f)\n     }\n \n-    fn emit_tuple_struct(&mut self,\n-                         _: &str,\n-                         len: uint,\n-                         f: |&mut PrettyEncoder<'a>| -> EncodeResult) -> EncodeResult {\n+    fn emit_tuple_struct<F>(&mut self, _: &str, len: uint, f: F) -> EncodeResult where\n+        F: FnOnce(&mut PrettyEncoder<'a>) -> EncodeResult,\n+    {\n         self.emit_seq(len, f)\n     }\n-    fn emit_tuple_struct_arg(&mut self,\n-                             idx: uint,\n-                             f: |&mut PrettyEncoder<'a>| -> EncodeResult) -> EncodeResult {\n+    fn emit_tuple_struct_arg<F>(&mut self, idx: uint, f: F) -> EncodeResult where\n+        F: FnOnce(&mut PrettyEncoder<'a>) -> EncodeResult,\n+    {\n         self.emit_seq_elt(idx, f)\n     }\n \n-    fn emit_option(&mut self, f: |&mut PrettyEncoder<'a>| -> EncodeResult) -> EncodeResult {\n+    fn emit_option<F>(&mut self, f: F) -> EncodeResult where\n+        F: FnOnce(&mut PrettyEncoder<'a>) -> EncodeResult,\n+    {\n         f(self)\n     }\n     fn emit_option_none(&mut self) -> EncodeResult { self.emit_nil() }\n-    fn emit_option_some(&mut self, f: |&mut PrettyEncoder<'a>| -> EncodeResult) -> EncodeResult {\n+    fn emit_option_some<F>(&mut self, f: F) -> EncodeResult where\n+        F: FnOnce(&mut PrettyEncoder<'a>) -> EncodeResult,\n+    {\n         f(self)\n     }\n \n-    fn emit_seq(&mut self,\n-                len: uint,\n-                f: |&mut PrettyEncoder<'a>| -> EncodeResult) -> EncodeResult {\n+    fn emit_seq<F>(&mut self, len: uint, f: F) -> EncodeResult where\n+        F: FnOnce(&mut PrettyEncoder<'a>) -> EncodeResult,\n+    {\n         if len == 0 {\n             write!(self.writer, \"[]\")\n         } else {\n@@ -802,9 +825,9 @@ impl<'a> ::Encoder<io::IoError> for PrettyEncoder<'a> {\n         }\n     }\n \n-    fn emit_seq_elt(&mut self,\n-                    idx: uint,\n-                    f: |&mut PrettyEncoder<'a>| -> EncodeResult) -> EncodeResult {\n+    fn emit_seq_elt<F>(&mut self, idx: uint, f: F) -> EncodeResult where\n+        F: FnOnce(&mut PrettyEncoder<'a>) -> EncodeResult,\n+    {\n         if idx == 0 {\n             try!(write!(self.writer, \"\\n\"));\n         } else {\n@@ -814,9 +837,9 @@ impl<'a> ::Encoder<io::IoError> for PrettyEncoder<'a> {\n         f(self)\n     }\n \n-    fn emit_map(&mut self,\n-                len: uint,\n-                f: |&mut PrettyEncoder<'a>| -> EncodeResult) -> EncodeResult {\n+    fn emit_map<F>(&mut self, len: uint, f: F) -> EncodeResult where\n+        F: FnOnce(&mut PrettyEncoder<'a>) -> EncodeResult,\n+    {\n         if len == 0 {\n             write!(self.writer, \"{{}}\")\n         } else {\n@@ -830,9 +853,9 @@ impl<'a> ::Encoder<io::IoError> for PrettyEncoder<'a> {\n         }\n     }\n \n-    fn emit_map_elt_key(&mut self,\n-                        idx: uint,\n-                        f: |&mut PrettyEncoder<'a>| -> EncodeResult) -> EncodeResult {\n+    fn emit_map_elt_key<F>(&mut self, idx: uint, mut f: F) -> EncodeResult where\n+        F: FnMut(&mut PrettyEncoder<'a>) -> EncodeResult,\n+    {\n         if idx == 0 {\n             try!(write!(self.writer, \"\\n\"));\n         } else {\n@@ -855,9 +878,9 @@ impl<'a> ::Encoder<io::IoError> for PrettyEncoder<'a> {\n         Ok(())\n     }\n \n-    fn emit_map_elt_val(&mut self,\n-                        _idx: uint,\n-                        f: |&mut PrettyEncoder<'a>| -> EncodeResult) -> EncodeResult {\n+    fn emit_map_elt_val<F>(&mut self, _idx: uint, f: F) -> EncodeResult where\n+        F: FnOnce(&mut PrettyEncoder<'a>) -> EncodeResult,\n+    {\n         try!(write!(self.writer, \": \"));\n         f(self)\n     }\n@@ -2052,17 +2075,16 @@ impl ::Decoder<DecoderError> for Decoder {\n         expect!(self.pop(), String)\n     }\n \n-    fn read_enum<T>(&mut self,\n-                    name: &str,\n-                    f: |&mut Decoder| -> DecodeResult<T>) -> DecodeResult<T> {\n+    fn read_enum<T, F>(&mut self, name: &str, f: F) -> DecodeResult<T> where\n+        F: FnOnce(&mut Decoder) -> DecodeResult<T>,\n+    {\n         debug!(\"read_enum({})\", name);\n         f(self)\n     }\n \n-    fn read_enum_variant<T>(&mut self,\n-                            names: &[&str],\n-                            f: |&mut Decoder, uint| -> DecodeResult<T>)\n-                            -> DecodeResult<T> {\n+    fn read_enum_variant<T, F>(&mut self, names: &[&str], f: F) -> DecodeResult<T> where\n+        F: FnOnce(&mut Decoder, uint) -> DecodeResult<T>,\n+    {\n         debug!(\"read_enum_variant(names={})\", names);\n         let name = match self.pop() {\n             Json::String(s) => s,\n@@ -2103,46 +2125,48 @@ impl ::Decoder<DecoderError> for Decoder {\n         f(self, idx)\n     }\n \n-    fn read_enum_variant_arg<T>(&mut self, idx: uint, f: |&mut Decoder| -> DecodeResult<T>)\n-                                -> DecodeResult<T> {\n+    fn read_enum_variant_arg<T, F>(&mut self, idx: uint, f: F) -> DecodeResult<T> where\n+        F: FnOnce(&mut Decoder) -> DecodeResult<T>,\n+    {\n         debug!(\"read_enum_variant_arg(idx={})\", idx);\n         f(self)\n     }\n \n-    fn read_enum_struct_variant<T>(&mut self,\n-                                   names: &[&str],\n-                                   f: |&mut Decoder, uint| -> DecodeResult<T>)\n-                                   -> DecodeResult<T> {\n+    fn read_enum_struct_variant<T, F>(&mut self, names: &[&str], f: F) -> DecodeResult<T> where\n+        F: FnOnce(&mut Decoder, uint) -> DecodeResult<T>,\n+    {\n         debug!(\"read_enum_struct_variant(names={})\", names);\n         self.read_enum_variant(names, f)\n     }\n \n \n-    fn read_enum_struct_variant_field<T>(&mut self,\n+    fn read_enum_struct_variant_field<T, F>(&mut self,\n                                          name: &str,\n                                          idx: uint,\n-                                         f: |&mut Decoder| -> DecodeResult<T>)\n-                                         -> DecodeResult<T> {\n+                                         f: F)\n+                                         -> DecodeResult<T> where\n+        F: FnOnce(&mut Decoder) -> DecodeResult<T>,\n+    {\n         debug!(\"read_enum_struct_variant_field(name={}, idx={})\", name, idx);\n         self.read_enum_variant_arg(idx, f)\n     }\n \n-    fn read_struct<T>(&mut self,\n-                      name: &str,\n-                      len: uint,\n-                      f: |&mut Decoder| -> DecodeResult<T>)\n-                      -> DecodeResult<T> {\n+    fn read_struct<T, F>(&mut self, name: &str, len: uint, f: F) -> DecodeResult<T> where\n+        F: FnOnce(&mut Decoder) -> DecodeResult<T>,\n+    {\n         debug!(\"read_struct(name={}, len={})\", name, len);\n         let value = try!(f(self));\n         self.pop();\n         Ok(value)\n     }\n \n-    fn read_struct_field<T>(&mut self,\n-                            name: &str,\n-                            idx: uint,\n-                            f: |&mut Decoder| -> DecodeResult<T>)\n-                            -> DecodeResult<T> {\n+    fn read_struct_field<T, F>(&mut self,\n+                               name: &str,\n+                               idx: uint,\n+                               f: F)\n+                               -> DecodeResult<T> where\n+        F: FnOnce(&mut Decoder) -> DecodeResult<T>,\n+    {\n         debug!(\"read_struct_field(name={}, idx={})\", name, idx);\n         let mut obj = try!(expect!(self.pop(), Object));\n \n@@ -2165,12 +2189,11 @@ impl ::Decoder<DecoderError> for Decoder {\n         Ok(value)\n     }\n \n-    fn read_tuple<T>(&mut self,\n-                     tuple_len: uint,\n-                     f: |&mut Decoder| -> DecodeResult<T>)\n-                     -> DecodeResult<T> {\n+    fn read_tuple<T, F>(&mut self, tuple_len: uint, f: F) -> DecodeResult<T> where\n+        F: FnOnce(&mut Decoder) -> DecodeResult<T>,\n+    {\n         debug!(\"read_tuple()\");\n-        self.read_seq(|d, len| {\n+        self.read_seq(move |d, len| {\n             if len == tuple_len {\n                 f(d)\n             } else {\n@@ -2179,39 +2202,47 @@ impl ::Decoder<DecoderError> for Decoder {\n         })\n     }\n \n-    fn read_tuple_arg<T>(&mut self,\n-                         idx: uint,\n-                         f: |&mut Decoder| -> DecodeResult<T>) -> DecodeResult<T> {\n+    fn read_tuple_arg<T, F>(&mut self, idx: uint, f: F) -> DecodeResult<T> where\n+        F: FnOnce(&mut Decoder) -> DecodeResult<T>,\n+    {\n         debug!(\"read_tuple_arg(idx={})\", idx);\n         self.read_seq_elt(idx, f)\n     }\n \n-    fn read_tuple_struct<T>(&mut self,\n-                            name: &str,\n-                            len: uint,\n-                            f: |&mut Decoder| -> DecodeResult<T>)\n-                            -> DecodeResult<T> {\n+    fn read_tuple_struct<T, F>(&mut self,\n+                               name: &str,\n+                               len: uint,\n+                               f: F)\n+                               -> DecodeResult<T> where\n+        F: FnOnce(&mut Decoder) -> DecodeResult<T>,\n+    {\n         debug!(\"read_tuple_struct(name={})\", name);\n         self.read_tuple(len, f)\n     }\n \n-    fn read_tuple_struct_arg<T>(&mut self,\n-                                idx: uint,\n-                                f: |&mut Decoder| -> DecodeResult<T>)\n-                                -> DecodeResult<T> {\n+    fn read_tuple_struct_arg<T, F>(&mut self,\n+                                   idx: uint,\n+                                   f: F)\n+                                   -> DecodeResult<T> where\n+        F: FnOnce(&mut Decoder) -> DecodeResult<T>,\n+    {\n         debug!(\"read_tuple_struct_arg(idx={})\", idx);\n         self.read_tuple_arg(idx, f)\n     }\n \n-    fn read_option<T>(&mut self, f: |&mut Decoder, bool| -> DecodeResult<T>) -> DecodeResult<T> {\n+    fn read_option<T, F>(&mut self, f: F) -> DecodeResult<T> where\n+        F: FnOnce(&mut Decoder, bool) -> DecodeResult<T>,\n+    {\n         debug!(\"read_option()\");\n         match self.pop() {\n             Json::Null => f(self, false),\n             value => { self.stack.push(value); f(self, true) }\n         }\n     }\n \n-    fn read_seq<T>(&mut self, f: |&mut Decoder, uint| -> DecodeResult<T>) -> DecodeResult<T> {\n+    fn read_seq<T, F>(&mut self, f: F) -> DecodeResult<T> where\n+        F: FnOnce(&mut Decoder, uint) -> DecodeResult<T>,\n+    {\n         debug!(\"read_seq()\");\n         let array = try!(expect!(self.pop(), Array));\n         let len = array.len();\n@@ -2221,14 +2252,16 @@ impl ::Decoder<DecoderError> for Decoder {\n         f(self, len)\n     }\n \n-    fn read_seq_elt<T>(&mut self,\n-                       idx: uint,\n-                       f: |&mut Decoder| -> DecodeResult<T>) -> DecodeResult<T> {\n+    fn read_seq_elt<T, F>(&mut self, idx: uint, f: F) -> DecodeResult<T> where\n+        F: FnOnce(&mut Decoder) -> DecodeResult<T>,\n+    {\n         debug!(\"read_seq_elt(idx={})\", idx);\n         f(self)\n     }\n \n-    fn read_map<T>(&mut self, f: |&mut Decoder, uint| -> DecodeResult<T>) -> DecodeResult<T> {\n+    fn read_map<T, F>(&mut self, f: F) -> DecodeResult<T> where\n+        F: FnOnce(&mut Decoder, uint) -> DecodeResult<T>,\n+    {\n         debug!(\"read_map()\");\n         let obj = try!(expect!(self.pop(), Object));\n         let len = obj.len();\n@@ -2239,14 +2272,16 @@ impl ::Decoder<DecoderError> for Decoder {\n         f(self, len)\n     }\n \n-    fn read_map_elt_key<T>(&mut self, idx: uint, f: |&mut Decoder| -> DecodeResult<T>)\n-                           -> DecodeResult<T> {\n+    fn read_map_elt_key<T, F>(&mut self, idx: uint, f: F) -> DecodeResult<T> where\n+       F: FnOnce(&mut Decoder) -> DecodeResult<T>,\n+    {\n         debug!(\"read_map_elt_key(idx={})\", idx);\n         f(self)\n     }\n \n-    fn read_map_elt_val<T>(&mut self, idx: uint, f: |&mut Decoder| -> DecodeResult<T>)\n-                           -> DecodeResult<T> {\n+    fn read_map_elt_val<T, F>(&mut self, idx: uint, f: F) -> DecodeResult<T> where\n+       F: FnOnce(&mut Decoder) -> DecodeResult<T>,\n+    {\n         debug!(\"read_map_elt_val(idx={})\", idx);\n         f(self)\n     }\n@@ -2645,7 +2680,7 @@ mod tests {\n                    from_str(a.to_pretty_str().as_slice()).unwrap());\n     }\n \n-    fn with_str_writer(f: |&mut io::Writer|) -> string::String {\n+    fn with_str_writer<F>(f: F) -> string::String where F: FnOnce(&mut io::Writer){\n         use std::str;\n \n         let mut m = Vec::new();"}, {"sha": "390b3976562ffacbb00d3a127e76f7f8ae20a9f1", "filename": "src/libserialize/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibserialize%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibserialize%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Flib.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -24,6 +24,7 @@ Core encoding and decoding interfaces.\n        html_playground_url = \"http://play.rust-lang.org/\")]\n #![allow(unknown_features)]\n #![feature(macro_rules, default_type_params, phase, slicing_syntax, globs)]\n+#![feature(unboxed_closures)]\n \n // test harness access\n #[cfg(test)]"}, {"sha": "98bd2f6bc930f68ff09a4724486a35fb8dd69333", "filename": "src/libserialize/serialize.rs", "status": "modified", "additions": 107, "deletions": 100, "changes": 207, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibserialize%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibserialize%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fserialize.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -39,58 +39,61 @@ pub trait Encoder<E> {\n     fn emit_str(&mut self, v: &str) -> Result<(), E>;\n \n     // Compound types:\n-    fn emit_enum(&mut self, name: &str, f: |&mut Self| -> Result<(), E>) -> Result<(), E>;\n-\n-    fn emit_enum_variant(&mut self,\n-                         v_name: &str,\n-                         v_id: uint,\n-                         len: uint,\n-                         f: |&mut Self| -> Result<(), E>) -> Result<(), E>;\n-    fn emit_enum_variant_arg(&mut self,\n-                             a_idx: uint,\n-                             f: |&mut Self| -> Result<(), E>) -> Result<(), E>;\n-\n-    fn emit_enum_struct_variant(&mut self,\n-                                v_name: &str,\n-                                v_id: uint,\n-                                len: uint,\n-                                f: |&mut Self| -> Result<(), E>) -> Result<(), E>;\n-    fn emit_enum_struct_variant_field(&mut self,\n-                                      f_name: &str,\n-                                      f_idx: uint,\n-                                      f: |&mut Self| -> Result<(), E>) -> Result<(), E>;\n-\n-    fn emit_struct(&mut self,\n-                   name: &str,\n-                   len: uint,\n-                   f: |&mut Self| -> Result<(), E>) -> Result<(), E>;\n-    fn emit_struct_field(&mut self,\n-                         f_name: &str,\n-                         f_idx: uint,\n-                         f: |&mut Self| -> Result<(), E>) -> Result<(), E>;\n-\n-    fn emit_tuple(&mut self, len: uint, f: |&mut Self| -> Result<(), E>) -> Result<(), E>;\n-    fn emit_tuple_arg(&mut self, idx: uint, f: |&mut Self| -> Result<(), E>) -> Result<(), E>;\n-\n-    fn emit_tuple_struct(&mut self,\n-                         name: &str,\n-                         len: uint,\n-                         f: |&mut Self| -> Result<(), E>) -> Result<(), E>;\n-    fn emit_tuple_struct_arg(&mut self,\n-                             f_idx: uint,\n-                             f: |&mut Self| -> Result<(), E>) -> Result<(), E>;\n+    fn emit_enum<F>(&mut self, name: &str, f: F) -> Result<(), E> where\n+        F: FnOnce(&mut Self) -> Result<(), E>;\n+\n+    fn emit_enum_variant<F>(&mut self, v_name: &str,\n+                            v_id: uint,\n+                            len: uint,\n+                            f: F) -> Result<(), E> where\n+        F: FnOnce(&mut Self) -> Result<(), E>;\n+    fn emit_enum_variant_arg<F>(&mut self, a_idx: uint, f: F) -> Result<(), E> where\n+        F: FnOnce(&mut Self) -> Result<(), E>;\n+\n+    fn emit_enum_struct_variant<F>(&mut self, v_name: &str,\n+                                   v_id: uint,\n+                                   len: uint,\n+                                   f: F) -> Result<(), E> where\n+        F: FnOnce(&mut Self) -> Result<(), E>;\n+    fn emit_enum_struct_variant_field<F>(&mut self,\n+                                         f_name: &str,\n+                                         f_idx: uint,\n+                                         f: F) -> Result<(), E> where\n+        F: FnOnce(&mut Self) -> Result<(), E>;\n+\n+    fn emit_struct<F>(&mut self, name: &str, len: uint, f: F) -> Result<(), E> where\n+        F: FnOnce(&mut Self) -> Result<(), E>;\n+    fn emit_struct_field<F>(&mut self, f_name: &str, f_idx: uint, f: F) -> Result<(), E> where\n+        F: FnOnce(&mut Self) -> Result<(), E>;\n+\n+    fn emit_tuple<F>(&mut self, len: uint, f: F) -> Result<(), E> where\n+        F: FnOnce(&mut Self) -> Result<(), E>;\n+    fn emit_tuple_arg<F>(&mut self, idx: uint, f: F) -> Result<(), E> where\n+        F: FnOnce(&mut Self) -> Result<(), E>;\n+\n+    fn emit_tuple_struct<F>(&mut self, name: &str, len: uint, f: F) -> Result<(), E> where\n+        F: FnOnce(&mut Self) -> Result<(), E>;\n+    fn emit_tuple_struct_arg<F>(&mut self, f_idx: uint, f: F) -> Result<(), E> where\n+        F: FnOnce(&mut Self) -> Result<(), E>;\n \n     // Specialized types:\n-    fn emit_option(&mut self, f: |&mut Self| -> Result<(), E>) -> Result<(), E>;\n+    fn emit_option<F>(&mut self, f: F) -> Result<(), E> where\n+        F: FnOnce(&mut Self) -> Result<(), E>;\n     fn emit_option_none(&mut self) -> Result<(), E>;\n-    fn emit_option_some(&mut self, f: |&mut Self| -> Result<(), E>) -> Result<(), E>;\n+    fn emit_option_some<F>(&mut self, f: F) -> Result<(), E> where\n+        F: FnOnce(&mut Self) -> Result<(), E>;\n \n-    fn emit_seq(&mut self, len: uint, f: |this: &mut Self| -> Result<(), E>) -> Result<(), E>;\n-    fn emit_seq_elt(&mut self, idx: uint, f: |this: &mut Self| -> Result<(), E>) -> Result<(), E>;\n+    fn emit_seq<F>(&mut self, len: uint, f: F) -> Result<(), E> where\n+        F: FnOnce(&mut Self) -> Result<(), E>;\n+    fn emit_seq_elt<F>(&mut self, idx: uint, f: F) -> Result<(), E> where\n+        F: FnOnce(&mut Self) -> Result<(), E>;\n \n-    fn emit_map(&mut self, len: uint, f: |&mut Self| -> Result<(), E>) -> Result<(), E>;\n-    fn emit_map_elt_key(&mut self, idx: uint, f: |&mut Self| -> Result<(), E>) -> Result<(), E>;\n-    fn emit_map_elt_val(&mut self, idx: uint, f: |&mut Self| -> Result<(), E>) -> Result<(), E>;\n+    fn emit_map<F>(&mut self, len: uint, f: F) -> Result<(), E> where\n+        F: FnOnce(&mut Self) -> Result<(), E>;\n+    fn emit_map_elt_key<F>(&mut self, idx: uint, f: F) -> Result<(), E> where\n+        F: FnMut(&mut Self) -> Result<(), E>;\n+    fn emit_map_elt_val<F>(&mut self, idx: uint, f: F) -> Result<(), E> where\n+        F: FnOnce(&mut Self) -> Result<(), E>;\n }\n \n pub trait Decoder<E> {\n@@ -113,57 +116,57 @@ pub trait Decoder<E> {\n     fn read_str(&mut self) -> Result<String, E>;\n \n     // Compound types:\n-    fn read_enum<T>(&mut self, name: &str, f: |&mut Self| -> Result<T, E>) -> Result<T, E>;\n-\n-    fn read_enum_variant<T>(&mut self,\n-                            names: &[&str],\n-                            f: |&mut Self, uint| -> Result<T, E>)\n-                            -> Result<T, E>;\n-    fn read_enum_variant_arg<T>(&mut self,\n-                                a_idx: uint,\n-                                f: |&mut Self| -> Result<T, E>)\n-                                -> Result<T, E>;\n-\n-    fn read_enum_struct_variant<T>(&mut self,\n-                                   names: &[&str],\n-                                   f: |&mut Self, uint| -> Result<T, E>)\n-                                   -> Result<T, E>;\n-    fn read_enum_struct_variant_field<T>(&mut self,\n-                                         &f_name: &str,\n-                                         f_idx: uint,\n-                                         f: |&mut Self| -> Result<T, E>)\n-                                         -> Result<T, E>;\n-\n-    fn read_struct<T>(&mut self, s_name: &str, len: uint, f: |&mut Self| -> Result<T, E>)\n-                      -> Result<T, E>;\n-    fn read_struct_field<T>(&mut self,\n-                            f_name: &str,\n-                            f_idx: uint,\n-                            f: |&mut Self| -> Result<T, E>)\n-                            -> Result<T, E>;\n-\n-    fn read_tuple<T>(&mut self, len: uint, f: |&mut Self| -> Result<T, E>) -> Result<T, E>;\n-    fn read_tuple_arg<T>(&mut self, a_idx: uint, f: |&mut Self| -> Result<T, E>) -> Result<T, E>;\n-\n-    fn read_tuple_struct<T>(&mut self,\n-                            s_name: &str,\n-                            len: uint,\n-                            f: |&mut Self| -> Result<T, E>)\n-                            -> Result<T, E>;\n-    fn read_tuple_struct_arg<T>(&mut self,\n-                                a_idx: uint,\n-                                f: |&mut Self| -> Result<T, E>)\n-                                -> Result<T, E>;\n+    fn read_enum<T, F>(&mut self, name: &str, f: F) -> Result<T, E> where\n+        F: FnOnce(&mut Self) -> Result<T, E>;\n+\n+    fn read_enum_variant<T, F>(&mut self, names: &[&str], f: F) -> Result<T, E> where\n+        F: FnOnce(&mut Self, uint) -> Result<T, E>;\n+    fn read_enum_variant_arg<T, F>(&mut self, a_idx: uint, f: F) -> Result<T, E> where\n+        F: FnOnce(&mut Self) -> Result<T, E>;\n+\n+    fn read_enum_struct_variant<T, F>(&mut self, names: &[&str], f: F) -> Result<T, E> where\n+        F: FnOnce(&mut Self, uint) -> Result<T, E>;\n+    fn read_enum_struct_variant_field<T, F>(&mut self,\n+                                            &f_name: &str,\n+                                            f_idx: uint,\n+                                            f: F)\n+                                            -> Result<T, E> where\n+        F: FnOnce(&mut Self) -> Result<T, E>;\n+\n+    fn read_struct<T, F>(&mut self, s_name: &str, len: uint, f: F) -> Result<T, E> where\n+        F: FnOnce(&mut Self) -> Result<T, E>;\n+    fn read_struct_field<T, F>(&mut self,\n+                               f_name: &str,\n+                               f_idx: uint,\n+                               f: F)\n+                               -> Result<T, E> where\n+        F: FnOnce(&mut Self) -> Result<T, E>;\n+\n+    fn read_tuple<T, F>(&mut self, len: uint, f: F) -> Result<T, E> where\n+        F: FnOnce(&mut Self) -> Result<T, E>;\n+    fn read_tuple_arg<T, F>(&mut self, a_idx: uint, f: F) -> Result<T, E> where\n+        F: FnOnce(&mut Self) -> Result<T, E>;\n+\n+    fn read_tuple_struct<T, F>(&mut self, s_name: &str, len: uint, f: F) -> Result<T, E> where\n+        F: FnOnce(&mut Self) -> Result<T, E>;\n+    fn read_tuple_struct_arg<T, F>(&mut self, a_idx: uint, f: F) -> Result<T, E> where\n+        F: FnOnce(&mut Self) -> Result<T, E>;\n \n     // Specialized types:\n-    fn read_option<T>(&mut self, f: |&mut Self, bool| -> Result<T, E>) -> Result<T, E>;\n+    fn read_option<T, F>(&mut self, f: F) -> Result<T, E> where\n+        F: FnOnce(&mut Self, bool) -> Result<T, E>;\n \n-    fn read_seq<T>(&mut self, f: |&mut Self, uint| -> Result<T, E>) -> Result<T, E>;\n-    fn read_seq_elt<T>(&mut self, idx: uint, f: |&mut Self| -> Result<T, E>) -> Result<T, E>;\n+    fn read_seq<T, F>(&mut self, f: F) -> Result<T, E> where\n+        F: FnOnce(&mut Self, uint) -> Result<T, E>;\n+    fn read_seq_elt<T, F>(&mut self, idx: uint, f: F) -> Result<T, E> where\n+        F: FnOnce(&mut Self) -> Result<T, E>;\n \n-    fn read_map<T>(&mut self, f: |&mut Self, uint| -> Result<T, E>) -> Result<T, E>;\n-    fn read_map_elt_key<T>(&mut self, idx: uint, f: |&mut Self| -> Result<T, E>) -> Result<T, E>;\n-    fn read_map_elt_val<T>(&mut self, idx: uint, f: |&mut Self| -> Result<T, E>) -> Result<T, E>;\n+    fn read_map<T, F>(&mut self, f: F) -> Result<T, E> where\n+        F: FnOnce(&mut Self, uint) -> Result<T, E>;\n+    fn read_map_elt_key<T, F>(&mut self, idx: uint, f: F) -> Result<T, E> where\n+        F: FnOnce(&mut Self) -> Result<T, E>;\n+    fn read_map_elt_val<T, F>(&mut self, idx: uint, f: F) -> Result<T, E> where\n+        F: FnOnce(&mut Self) -> Result<T, E>;\n \n     // Failure\n     fn error(&mut self, err: &str) -> E;\n@@ -585,13 +588,14 @@ impl<E, D:Decoder<E>,T:Decodable<D, E>+Send+Sync> Decodable<D, E> for Arc<T> {\n // Helper routines\n \n pub trait EncoderHelpers<E> {\n-    fn emit_from_vec<T>(&mut self,\n-                        v: &[T],\n-                        f: |&mut Self, v: &T| -> Result<(), E>) -> Result<(), E>;\n+    fn emit_from_vec<T, F>(&mut self, v: &[T], f: F) -> Result<(), E> where\n+        F: FnMut(&mut Self, &T) -> Result<(), E>;\n }\n \n impl<E, S:Encoder<E>> EncoderHelpers<E> for S {\n-    fn emit_from_vec<T>(&mut self, v: &[T], f: |&mut S, &T| -> Result<(), E>) -> Result<(), E> {\n+    fn emit_from_vec<T, F>(&mut self, v: &[T], mut f: F) -> Result<(), E> where\n+        F: FnMut(&mut S, &T) -> Result<(), E>,\n+    {\n         self.emit_seq(v.len(), |this| {\n             for (i, e) in v.iter().enumerate() {\n                 try!(this.emit_seq_elt(i, |this| {\n@@ -604,11 +608,14 @@ impl<E, S:Encoder<E>> EncoderHelpers<E> for S {\n }\n \n pub trait DecoderHelpers<E> {\n-    fn read_to_vec<T>(&mut self, f: |&mut Self| -> Result<T, E>) -> Result<Vec<T>, E>;\n+    fn read_to_vec<T, F>(&mut self, f: F) -> Result<Vec<T>, E> where\n+        F: FnMut(&mut Self) -> Result<T, E>;\n }\n \n impl<E, D:Decoder<E>> DecoderHelpers<E> for D {\n-    fn read_to_vec<T>(&mut self, f: |&mut D| -> Result<T, E>) -> Result<Vec<T>, E> {\n+    fn read_to_vec<T, F>(&mut self, mut f: F) -> Result<Vec<T>, E> where F:\n+        FnMut(&mut D) -> Result<T, E>,\n+    {\n         self.read_seq(|this, len| {\n             let mut v = Vec::with_capacity(len);\n             for i in range(0, len) {"}, {"sha": "ad2167214a7d413c8e688fb70f78e47954b46250", "filename": "src/libstd/ascii.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibstd%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibstd%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fascii.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -20,6 +20,7 @@ use fmt;\n use iter::IteratorExt;\n use kinds::Copy;\n use mem;\n+use ops::FnMut;\n use option::Option;\n use option::Option::{Some, None};\n use slice::{SlicePrelude, AsSlice};\n@@ -527,7 +528,9 @@ impl OwnedAsciiExt for Vec<u8> {\n /// - Any other chars are given hex escapes.\n /// - Unicode escapes are never generated by this function.\n #[unstable = \"needs to be updated to use an iterator\"]\n-pub fn escape_default(c: u8, f: |u8|) {\n+pub fn escape_default<F>(c: u8, mut f: F) where\n+    F: FnMut(u8),\n+{\n     match c {\n         b'\\t' => { f(b'\\\\'); f(b't'); }\n         b'\\r' => { f(b'\\\\'); f(b'r'); }"}, {"sha": "2a8d97eed05bced13bee11796db34d89d8677858", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 33, "deletions": 17, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -24,7 +24,7 @@ use iter::{mod, Iterator, IteratorExt, FromIterator, Extend};\n use kinds::Sized;\n use mem::{mod, replace};\n use num::{Int, UnsignedInt};\n-use ops::{Deref, Index, IndexMut};\n+use ops::{Deref, FnMut, Index, IndexMut};\n use option::Option;\n use option::Option::{Some, None};\n use result::Result;\n@@ -296,10 +296,13 @@ pub struct HashMap<K, V, H = RandomSipHasher> {\n }\n \n /// Search for a pre-hashed key.\n-fn search_hashed<K, V, M: Deref<RawTable<K, V>>>(table: M,\n-                                                 hash: &SafeHash,\n-                                                 is_match: |&K| -> bool)\n-                                                 -> SearchResult<K, V, M> {\n+fn search_hashed<K, V, M, F>(table: M,\n+                             hash: &SafeHash,\n+                             mut is_match: F)\n+                             -> SearchResult<K, V, M> where\n+    M: Deref<RawTable<K, V>>,\n+    F: FnMut(&K) -> bool,\n+{\n     let size = table.size();\n     let mut probe = Bucket::new(table, hash);\n     let ib = probe.index();\n@@ -749,12 +752,14 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n         self.insert_or_replace_with(hash, k, v, |_, _, _| ())\n     }\n \n-    fn insert_or_replace_with<'a>(&'a mut self,\n-                                  hash: SafeHash,\n-                                  k: K,\n-                                  v: V,\n-                                  found_existing: |&mut K, &mut V, V|)\n-                                  -> &'a mut V {\n+    fn insert_or_replace_with<'a, F>(&'a mut self,\n+                                     hash: SafeHash,\n+                                     k: K,\n+                                     v: V,\n+                                     mut found_existing: F)\n+                                     -> &'a mut V where\n+        F: FnMut(&mut K, &mut V, V),\n+    {\n         // Worst case, we'll find one empty bucket among `size + 1` buckets.\n         let size = self.table.size();\n         let mut probe = Bucket::new(&mut self.table, &hash);\n@@ -852,7 +857,9 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn keys(&self) -> Keys<K, V> {\n-        self.iter().map(|(k, _v)| k)\n+        fn first<A, B>((a, _): (A, B)) -> A { a }\n+\n+        self.iter().map(first)\n     }\n \n     /// An iterator visiting all values in arbitrary order.\n@@ -874,7 +881,9 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn values(&self) -> Values<K, V> {\n-        self.iter().map(|(_k, v)| v)\n+        fn second<A, B>((_, b): (A, B)) -> B { b }\n+\n+        self.iter().map(second)\n     }\n \n     /// An iterator visiting all key-value pairs in arbitrary order.\n@@ -946,8 +955,10 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn into_iter(self) -> MoveEntries<K, V> {\n+        fn last_two<A, B, C>((_, b, c): (A, B, C)) -> (B, C) { (b, c) }\n+\n         MoveEntries {\n-            inner: self.table.into_iter().map(|(_, k, v)| (k, v))\n+            inner: self.table.into_iter().map(last_two)\n         }\n     }\n \n@@ -1316,7 +1327,12 @@ pub struct MutEntries<'a, K: 'a, V: 'a> {\n \n /// HashMap move iterator\n pub struct MoveEntries<K, V> {\n-    inner: iter::Map<'static, (SafeHash, K, V), (K, V), table::MoveEntries<K, V>>\n+    inner: iter::Map<\n+        (SafeHash, K, V),\n+        (K, V),\n+        table::MoveEntries<K, V>,\n+        fn((SafeHash, K, V)) -> (K, V),\n+    >\n }\n \n /// A view into a single occupied location in a HashMap\n@@ -1434,11 +1450,11 @@ impl<'a, K, V> VacantEntry<'a, K, V> {\n \n /// HashMap keys iterator\n pub type Keys<'a, K, V> =\n-    iter::Map<'static, (&'a K, &'a V), &'a K, Entries<'a, K, V>>;\n+    iter::Map<(&'a K, &'a V), &'a K, Entries<'a, K, V>, fn((&'a K, &'a V)) -> &'a K>;\n \n /// HashMap values iterator\n pub type Values<'a, K, V> =\n-    iter::Map<'static, (&'a K, &'a V), &'a V, Entries<'a, K, V>>;\n+    iter::Map<(&'a K, &'a V), &'a V, Entries<'a, K, V>, fn((&'a K, &'a V)) -> &'a V>;\n \n impl<K: Eq + Hash<S>, V, S, H: Hasher<S> + Default> FromIterator<(K, V)> for HashMap<K, V, H> {\n     fn from_iter<T: Iterator<(K, V)>>(iter: T) -> HashMap<K, V, H> {"}, {"sha": "745a8298ee8a5890bd0b0ae68a778772174d738f", "filename": "src/libstd/collections/hash/set.rs", "status": "modified", "additions": 27, "deletions": 18, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -19,7 +19,7 @@ use fmt;\n use hash::{Hash, Hasher, RandomSipHasher};\n use iter::{Iterator, IteratorExt, FromIterator, FilterMap, Chain, Repeat, Zip, Extend, repeat};\n use iter;\n-use option::Option::{Some, None};\n+use option::Option::{Some, None, mod};\n use result::Result::{Ok, Err};\n \n use super::map::{HashMap, Entries, MoveEntries, INITIAL_CAPACITY};\n@@ -277,7 +277,9 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn into_iter(self) -> SetMoveItems<T> {\n-        self.map.into_iter().map(|(k, _)| k)\n+        fn first<A, B>((a, _): (A, B)) -> A { a }\n+\n+        self.map.into_iter().map(first)\n     }\n \n     /// Visit the values representing the difference.\n@@ -304,10 +306,13 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn difference<'a>(&'a self, other: &'a HashSet<T, H>) -> SetAlgebraItems<'a, T, H> {\n-        repeat(other).zip(self.iter())\n-            .filter_map(|(other, elt)| {\n-                if !other.contains(elt) { Some(elt) } else { None }\n-            })\n+        fn filter<'a, T, S, H>((other, elt): (&HashSet<T, H>, &'a T)) -> Option<&'a T> where\n+            T: Eq + Hash<S>, H: Hasher<S>\n+        {\n+            if !other.contains(elt) { Some(elt) } else { None }\n+        }\n+\n+        repeat(other).zip(self.iter()).filter_map(filter)\n     }\n \n     /// Visit the values representing the symmetric difference.\n@@ -354,12 +359,14 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     /// assert_eq!(diff, [2i, 3].iter().map(|&x| x).collect());\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn intersection<'a>(&'a self, other: &'a HashSet<T, H>)\n-        -> SetAlgebraItems<'a, T, H> {\n-        repeat(other).zip(self.iter())\n-            .filter_map(|(other, elt)| {\n-                if other.contains(elt) { Some(elt) } else { None }\n-            })\n+    pub fn intersection<'a>(&'a self, other: &'a HashSet<T, H>) -> SetAlgebraItems<'a, T, H> {\n+        fn filter<'a, T, S, H>((other, elt): (&HashSet<T, H>, &'a T)) -> Option<&'a T> where\n+            T: Eq + Hash<S>, H: Hasher<S>\n+        {\n+            if other.contains(elt) { Some(elt) } else { None }\n+        }\n+\n+        repeat(other).zip(self.iter()).filter_map(filter)\n     }\n \n     /// Visit the values representing the union.\n@@ -611,18 +618,20 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S> + Default> Default for HashSet<T, H> {\n \n /// HashSet iterator\n pub type SetItems<'a, K> =\n-    iter::Map<'static, (&'a K, &'a ()), &'a K, Entries<'a, K, ()>>;\n+    iter::Map<(&'a K, &'a ()), &'a K, Entries<'a, K, ()>, fn((&'a K, &'a ())) -> &'a K>;\n \n /// HashSet move iterator\n-pub type SetMoveItems<K> =\n-    iter::Map<'static, (K, ()), K, MoveEntries<K, ()>>;\n+pub type SetMoveItems<K> = iter::Map<(K, ()), K, MoveEntries<K, ()>, fn((K, ())) -> K>;\n \n // `Repeat` is used to feed the filter closure an explicit capture\n // of a reference to the other set\n /// Set operations iterator\n-pub type SetAlgebraItems<'a, T, H> =\n-    FilterMap<'static, (&'a HashSet<T, H>, &'a T), &'a T,\n-              Zip<Repeat<&'a HashSet<T, H>>, SetItems<'a, T>>>;\n+pub type SetAlgebraItems<'a, T, H> = FilterMap<\n+    (&'a HashSet<T, H>, &'a T),\n+    &'a T,\n+    Zip<Repeat<&'a HashSet<T, H>>, SetItems<'a, T>>,\n+    for<'b> fn((&HashSet<T, H>, &'b T)) -> Option<&'b T>,\n+>;\n \n #[cfg(test)]\n mod test_set {"}, {"sha": "059ad7537193f72d39e27b4f333f72940829681f", "filename": "src/libstd/dynamic_lib.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibstd%2Fdynamic_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibstd%2Fdynamic_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdynamic_lib.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -216,6 +216,7 @@ pub mod dl {\n     use c_str::{CString, ToCStr};\n     use libc;\n     use kinds::Copy;\n+    use ops::FnOnce;\n     use ptr;\n     use result::*;\n     use result::Result::{Err, Ok};\n@@ -231,7 +232,9 @@ pub mod dl {\n         dlopen(ptr::null(), Lazy as libc::c_int) as *mut u8\n     }\n \n-    pub fn check_for_errors_in<T>(f: || -> T) -> Result<T, String> {\n+    pub fn check_for_errors_in<T, F>(f: F) -> Result<T, String> where\n+        F: FnOnce() -> T,\n+    {\n         use sync::{StaticMutex, MUTEX_INIT};\n         static LOCK: StaticMutex = MUTEX_INIT;\n         unsafe {\n@@ -287,6 +290,7 @@ pub mod dl {\n     use c_str::ToCStr;\n     use iter::IteratorExt;\n     use libc;\n+    use ops::FnOnce;\n     use os;\n     use ptr;\n     use result::Result;\n@@ -312,7 +316,9 @@ pub mod dl {\n         handle as *mut u8\n     }\n \n-    pub fn check_for_errors_in<T>(f: || -> T) -> Result<T, String> {\n+    pub fn check_for_errors_in<T, F>(f: F) -> Result<T, String> where\n+        F: FnOnce() -> T,\n+    {\n         unsafe {\n             SetLastError(0);\n "}, {"sha": "69712e39d910851830a5507596f1e7663e5c3950", "filename": "src/libstd/io/extensions.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibstd%2Fio%2Fextensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibstd%2Fio%2Fextensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fextensions.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -19,6 +19,7 @@ use io::{IoError, IoResult, Reader};\n use io;\n use iter::Iterator;\n use num::Int;\n+use ops::FnOnce;\n use option::Option;\n use option::Option::{Some, None};\n use ptr::RawPtr;\n@@ -76,7 +77,9 @@ impl<'r, R: Reader> Iterator<IoResult<u8>> for Bytes<'r, R> {\n /// * `f`: A callback that receives the value.\n ///\n /// This function returns the value returned by the callback, for convenience.\n-pub fn u64_to_le_bytes<T>(n: u64, size: uint, f: |v: &[u8]| -> T) -> T {\n+pub fn u64_to_le_bytes<T, F>(n: u64, size: uint, f: F) -> T where\n+    F: FnOnce(&[u8]) -> T,\n+{\n     use mem::transmute;\n \n     // LLVM fails to properly optimize this when using shifts instead of the to_le* intrinsics\n@@ -115,7 +118,9 @@ pub fn u64_to_le_bytes<T>(n: u64, size: uint, f: |v: &[u8]| -> T) -> T {\n /// * `f`: A callback that receives the value.\n ///\n /// This function returns the value returned by the callback, for convenience.\n-pub fn u64_to_be_bytes<T>(n: u64, size: uint, f: |v: &[u8]| -> T) -> T {\n+pub fn u64_to_be_bytes<T, F>(n: u64, size: uint, f: F) -> T where\n+    F: FnOnce(&[u8]) -> T,\n+{\n     use mem::transmute;\n \n     // LLVM fails to properly optimize this when using shifts instead of the to_be* intrinsics"}, {"sha": "bad86258bb85db44d2702a13716a30b7f7582f91", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -233,7 +233,7 @@ use int;\n use iter::{Iterator, IteratorExt};\n use kinds::Copy;\n use mem::transmute;\n-use ops::{BitOr, BitXor, BitAnd, Sub, Not};\n+use ops::{BitOr, BitXor, BitAnd, Sub, Not, FnOnce};\n use option::Option;\n use option::Option::{Some, None};\n use os;\n@@ -426,27 +426,33 @@ impl Copy for IoErrorKind {}\n /// A trait that lets you add a `detail` to an IoError easily\n trait UpdateIoError<T> {\n     /// Returns an IoError with updated description and detail\n-    fn update_err(self, desc: &'static str, detail: |&IoError| -> String) -> Self;\n+    fn update_err<D>(self, desc: &'static str, detail: D) -> Self where\n+        D: FnOnce(&IoError) -> String;\n \n     /// Returns an IoError with updated detail\n-    fn update_detail(self, detail: |&IoError| -> String) -> Self;\n+    fn update_detail<D>(self, detail: D) -> Self where\n+        D: FnOnce(&IoError) -> String;\n \n     /// Returns an IoError with update description\n     fn update_desc(self, desc: &'static str) -> Self;\n }\n \n impl<T> UpdateIoError<T> for IoResult<T> {\n-    fn update_err(self, desc: &'static str, detail: |&IoError| -> String) -> IoResult<T> {\n-        self.map_err(|mut e| {\n+    fn update_err<D>(self, desc: &'static str, detail: D) -> IoResult<T> where\n+        D: FnOnce(&IoError) -> String,\n+    {\n+        self.map_err(move |mut e| {\n             let detail = detail(&e);\n             e.desc = desc;\n             e.detail = Some(detail);\n             e\n         })\n     }\n \n-    fn update_detail(self, detail: |&IoError| -> String) -> IoResult<T> {\n-        self.map_err(|mut e| { e.detail = Some(detail(&e)); e })\n+    fn update_detail<D>(self, detail: D) -> IoResult<T> where\n+        D: FnOnce(&IoError) -> String,\n+    {\n+        self.map_err(move |mut e| { e.detail = Some(detail(&e)); e })\n     }\n \n     fn update_desc(self, desc: &'static str) -> IoResult<T> {"}, {"sha": "62965c48a2680cffa18ac51025ef516b0af72944", "filename": "src/libstd/io/net/ip.rs", "status": "modified", "additions": 26, "deletions": 22, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibstd%2Fio%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibstd%2Fio%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fip.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -22,6 +22,7 @@ use kinds::Copy;\n use io::{mod, IoResult, IoError};\n use io::net;\n use iter::{Iterator, IteratorExt};\n+use ops::FnOnce;\n use option::Option;\n use option::Option::{None, Some};\n use result::Result::{Ok, Err};\n@@ -100,8 +101,9 @@ impl<'a> Parser<'a> {\n     }\n \n     // Commit only if parser returns Some\n-    fn read_atomically<T>(&mut self, cb: |&mut Parser| -> Option<T>)\n-                       -> Option<T> {\n+    fn read_atomically<T, F>(&mut self, cb: F) -> Option<T> where\n+        F: FnOnce(&mut Parser) -> Option<T>,\n+    {\n         let pos = self.pos;\n         let r = cb(self);\n         if r.is_none() {\n@@ -111,9 +113,10 @@ impl<'a> Parser<'a> {\n     }\n \n     // Commit only if parser read till EOF\n-    fn read_till_eof<T>(&mut self, cb: |&mut Parser| -> Option<T>)\n-                     -> Option<T> {\n-        self.read_atomically(|p| {\n+    fn read_till_eof<T, F>(&mut self, cb: F) -> Option<T> where\n+        F: FnOnce(&mut Parser) -> Option<T>,\n+    {\n+        self.read_atomically(move |p| {\n             match cb(p) {\n                 Some(x) => if p.is_eof() {Some(x)} else {None},\n                 None => None,\n@@ -134,15 +137,16 @@ impl<'a> Parser<'a> {\n     }\n \n     // Apply 3 parsers sequentially\n-    fn read_seq_3<A,\n-                  B,\n-                  C>(\n-                  &mut self,\n-                  pa: |&mut Parser| -> Option<A>,\n-                  pb: |&mut Parser| -> Option<B>,\n-                  pc: |&mut Parser| -> Option<C>)\n-                  -> Option<(A, B, C)> {\n-        self.read_atomically(|p| {\n+    fn read_seq_3<A, B, C, PA, PB, PC>(&mut self,\n+                                       pa: PA,\n+                                       pb: PB,\n+                                       pc: PC)\n+                                       -> Option<(A, B, C)> where\n+        PA: FnOnce(&mut Parser) -> Option<A>,\n+        PB: FnOnce(&mut Parser) -> Option<B>,\n+        PC: FnOnce(&mut Parser) -> Option<C>,\n+    {\n+        self.read_atomically(move |p| {\n             let a = pa(p);\n             let b = if a.is_some() { pb(p) } else { None };\n             let c = if b.is_some() { pc(p) } else { None };\n@@ -327,22 +331,22 @@ impl<'a> Parser<'a> {\n     }\n \n     fn read_socket_addr(&mut self) -> Option<SocketAddr> {\n-        let ip_addr = |p: &mut Parser| {\n+        let ip_addr = |&: p: &mut Parser| {\n             let ipv4_p = |p: &mut Parser| p.read_ip_addr();\n             let ipv6_p = |p: &mut Parser| {\n-                let open_br = |p: &mut Parser| p.read_given_char('[');\n-                let ip_addr = |p: &mut Parser| p.read_ipv6_addr();\n-                let clos_br = |p: &mut Parser| p.read_given_char(']');\n-                p.read_seq_3::<char, IpAddr, char>(open_br, ip_addr, clos_br)\n+                let open_br = |&: p: &mut Parser| p.read_given_char('[');\n+                let ip_addr = |&: p: &mut Parser| p.read_ipv6_addr();\n+                let clos_br = |&: p: &mut Parser| p.read_given_char(']');\n+                p.read_seq_3::<char, IpAddr, char, _, _, _>(open_br, ip_addr, clos_br)\n                         .map(|t| match t { (_, ip, _) => ip })\n             };\n             p.read_or(&mut [ipv4_p, ipv6_p])\n         };\n-        let colon = |p: &mut Parser| p.read_given_char(':');\n-        let port  = |p: &mut Parser| p.read_number(10, 5, 0x10000).map(|n| n as u16);\n+        let colon = |&: p: &mut Parser| p.read_given_char(':');\n+        let port  = |&: p: &mut Parser| p.read_number(10, 5, 0x10000).map(|n| n as u16);\n \n         // host, colon, port\n-        self.read_seq_3::<IpAddr, char, u16>(ip_addr, colon, port)\n+        self.read_seq_3::<IpAddr, char, u16, _, _, _>(ip_addr, colon, port)\n                 .map(|t| match t { (ip, _, port) => SocketAddr { ip: ip, port: port } })\n     }\n }"}, {"sha": "2056933e6df6f1ba01a9881898b379b9e481d497", "filename": "src/libstd/io/net/mod.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibstd%2Fio%2Fnet%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibstd%2Fio%2Fnet%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fmod.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -11,6 +11,7 @@\n //! Networking I/O\n \n use io::{IoError, IoResult, InvalidInput};\n+use ops::FnMut;\n use option::Option::None;\n use result::Result::{Ok, Err};\n use self::ip::{SocketAddr, ToSocketAddr};\n@@ -23,8 +24,10 @@ pub mod udp;\n pub mod ip;\n pub mod pipe;\n \n-fn with_addresses<A: ToSocketAddr, T>(addr: A, action: |SocketAddr| -> IoResult<T>)\n-    -> IoResult<T> {\n+fn with_addresses<A, T, F>(addr: A, mut action: F) -> IoResult<T> where\n+    A: ToSocketAddr,\n+    F: FnMut(SocketAddr) -> IoResult<T>,\n+{\n     const DEFAULT_ERROR: IoError = IoError {\n         kind: InvalidInput,\n         desc: \"no addresses found for hostname\","}, {"sha": "b23921ba3594d7382a86e801a1ea545af918de6d", "filename": "src/libstd/io/net/udp.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibstd%2Fio%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibstd%2Fio%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fudp.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -18,6 +18,7 @@\n use clone::Clone;\n use io::net::ip::{SocketAddr, IpAddr, ToSocketAddr};\n use io::{Reader, Writer, IoResult};\n+use ops::FnOnce;\n use option::Option;\n use result::Result::{Ok, Err};\n use sys::udp::UdpSocket as UdpSocketImp;\n@@ -210,7 +211,9 @@ impl UdpStream {\n     /// Allows access to the underlying UDP socket owned by this stream. This\n     /// is useful to, for example, use the socket to send data to hosts other\n     /// than the one that this stream is connected to.\n-    pub fn as_socket<T>(&mut self, f: |&mut UdpSocket| -> T) -> T {\n+    pub fn as_socket<T, F>(&mut self, f: F) -> T where\n+        F: FnOnce(&mut UdpSocket) -> T,\n+    {\n         f(&mut self.socket)\n     }\n "}, {"sha": "8438c9fb441ed7476f5ac701a9a0a6062bc4274d", "filename": "src/libstd/io/stdio.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibstd%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibstd%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fstdio.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -39,7 +39,7 @@ use libc;\n use mem;\n use option::Option;\n use option::Option::{Some, None};\n-use ops::{Deref, DerefMut};\n+use ops::{Deref, DerefMut, FnOnce};\n use result::Result::{Ok, Err};\n use rustrt;\n use rustrt::local::Local;\n@@ -85,7 +85,9 @@ enum StdSource {\n     File(fs::FileDesc),\n }\n \n-fn src<T>(fd: libc::c_int, _readable: bool, f: |StdSource| -> T) -> T {\n+fn src<T, F>(fd: libc::c_int, _readable: bool, f: F) -> T where\n+    F: FnOnce(StdSource) -> T,\n+{\n     match tty::TTY::new(fd) {\n         Ok(tty) => f(TTY(tty)),\n         Err(_) => f(File(fs::FileDesc::new(fd, false))),\n@@ -318,7 +320,9 @@ pub fn set_stderr(stderr: Box<Writer + Send>) -> Option<Box<Writer + Send>> {\n //          // io1 aliases io2\n //      })\n //  })\n-fn with_task_stdout(f: |&mut Writer| -> IoResult<()>) {\n+fn with_task_stdout<F>(f: F) where\n+    F: FnOnce(&mut Writer) -> IoResult<()>,\n+{\n     let result = if Local::exists(None::<Task>) {\n         let mut my_stdout = LOCAL_STDOUT.with(|slot| {\n             slot.borrow_mut().take()"}, {"sha": "c2363c9946a96a5842e071e41b139513e1157725", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -107,6 +107,7 @@\n #![feature(macro_rules, globs, linkage)]\n #![feature(default_type_params, phase, lang_items, unsafe_destructor)]\n #![feature(import_shadowing, slicing_syntax)]\n+#![feature(unboxed_closures)]\n \n // Don't link to std. We are std.\n #![no_std]"}, {"sha": "d5c27c7fbf82af8f7a6ff5dfa9247f6e2e827476", "filename": "src/libstd/num/strconv.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibstd%2Fnum%2Fstrconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibstd%2Fnum%2Fstrconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fstrconv.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -21,6 +21,7 @@ use char::Char;\n use kinds::Copy;\n use num;\n use num::{Int, Float, FPNaN, FPInfinite, ToPrimitive};\n+use ops::FnMut;\n use slice::{SlicePrelude, CloneSliceAllocPrelude};\n use str::StrPrelude;\n use string::String;\n@@ -93,7 +94,10 @@ impl Copy for SignFormat {}\n /// # Panics\n ///\n /// - Panics if `radix` < 2 or `radix` > 36.\n-fn int_to_str_bytes_common<T: Int>(num: T, radix: uint, sign: SignFormat, f: |u8|) {\n+fn int_to_str_bytes_common<T, F>(num: T, radix: uint, sign: SignFormat, mut f: F) where\n+    T: Int,\n+    F: FnMut(u8),\n+{\n     assert!(2 <= radix && radix <= 36);\n \n     let _0: T = Int::zero();"}, {"sha": "6d9b177574afc1d8ee49e94fba290f14d3ca956d", "filename": "src/libstd/num/u16.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibstd%2Fnum%2Fu16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibstd%2Fnum%2Fu16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fu16.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -15,4 +15,6 @@\n \n pub use core::u16::{BITS, BYTES, MIN, MAX};\n \n+use ops::FnOnce;\n+\n uint_module!(u16)"}, {"sha": "0d6d17fa007bf5eb46a02c419ce4b704720520df", "filename": "src/libstd/num/u32.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibstd%2Fnum%2Fu32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibstd%2Fnum%2Fu32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fu32.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -15,4 +15,6 @@\n \n pub use core::u32::{BITS, BYTES, MIN, MAX};\n \n+use ops::FnOnce;\n+\n uint_module!(u32)"}, {"sha": "ebb5d2946c5314dfc09e410d8fe229705e11c460", "filename": "src/libstd/num/u64.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibstd%2Fnum%2Fu64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibstd%2Fnum%2Fu64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fu64.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -15,4 +15,6 @@\n \n pub use core::u64::{BITS, BYTES, MIN, MAX};\n \n+use ops::FnOnce;\n+\n uint_module!(u64)"}, {"sha": "59aea214aae0ccdad679ecfba6da6d81b56892e4", "filename": "src/libstd/num/u8.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibstd%2Fnum%2Fu8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibstd%2Fnum%2Fu8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fu8.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -15,4 +15,6 @@\n \n pub use core::u8::{BITS, BYTES, MIN, MAX};\n \n+use ops::FnOnce;\n+\n uint_module!(u8)"}, {"sha": "484d28dfed05813089edd7a66c15896744d5a66b", "filename": "src/libstd/num/uint.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibstd%2Fnum%2Fuint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibstd%2Fnum%2Fuint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fuint.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -15,4 +15,6 @@\n \n pub use core::uint::{BITS, BYTES, MIN, MAX};\n \n+use ops::FnOnce;\n+\n uint_module!(uint)"}, {"sha": "bd6f3d4bb286bff2b8058985ba673b9a4cda7450", "filename": "src/libstd/num/uint_macros.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibstd%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibstd%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fuint_macros.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -32,7 +32,9 @@ macro_rules! uint_module (($T:ty) => (\n /// ```\n #[inline]\n #[deprecated = \"just use .to_string(), or a BufWriter with write! if you mustn't allocate\"]\n-pub fn to_str_bytes<U>(n: $T, radix: uint, f: |v: &[u8]| -> U) -> U {\n+pub fn to_str_bytes<U, F>(n: $T, radix: uint, f: F) -> U where\n+    F: FnOnce(&[u8]) -> U,\n+{\n     use io::{Writer, Seek};\n     // The radix can be as low as 2, so we need at least 64 characters for a\n     // base 2 number, and then we need another for a possible '-' character."}, {"sha": "a3ecfb49acee090e0da261424596d2d24df0109c", "filename": "src/libstd/os.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -40,7 +40,7 @@ use kinds::Copy;\n use libc::{c_void, c_int};\n use libc;\n use boxed::Box;\n-use ops::Drop;\n+use ops::{Drop, FnOnce};\n use option::Option;\n use option::Option::{Some, None};\n use os;\n@@ -163,6 +163,7 @@ pub fn getcwd() -> IoResult<Path> {\n pub mod windoze {\n     use libc::types::os::arch::extra::DWORD;\n     use libc;\n+    use ops::FnMut;\n     use option::Option;\n     use option::Option::None;\n     use option;\n@@ -172,8 +173,9 @@ pub mod windoze {\n     use str::StrPrelude;\n     use vec::Vec;\n \n-    pub fn fill_utf16_buf_and_decode(f: |*mut u16, DWORD| -> DWORD)\n-        -> Option<String> {\n+    pub fn fill_utf16_buf_and_decode<F>(mut f: F) -> Option<String> where\n+        F: FnMut(*mut u16, DWORD) -> DWORD,\n+    {\n \n         unsafe {\n             let mut n = TMPBUF_SZ as DWORD;\n@@ -212,7 +214,9 @@ pub mod windoze {\n Accessing environment variables is not generally threadsafe.\n Serialize access through a global lock.\n */\n-fn with_env_lock<T>(f: || -> T) -> T {\n+fn with_env_lock<T, F>(f: F) -> T where\n+    F: FnOnce() -> T,\n+{\n     use sync::{StaticMutex, MUTEX_INIT};\n \n     static LOCK: StaticMutex = MUTEX_INIT;"}, {"sha": "3daba53cd866eb3b823853b85d6ce61597f53d4c", "filename": "src/libstd/path/posix.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibstd%2Fpath%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibstd%2Fpath%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fposix.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -29,11 +29,11 @@ use vec::Vec;\n use super::{BytesContainer, GenericPath, GenericPathUnsafe};\n \n /// Iterator that yields successive components of a Path as &[u8]\n-pub type Components<'a> = Splits<'a, u8>;\n+pub type Components<'a> = Splits<'a, u8, fn(&u8) -> bool>;\n \n /// Iterator that yields successive components of a Path as Option<&str>\n-pub type StrComponents<'a> = Map<'a, &'a [u8], Option<&'a str>,\n-                                       Components<'a>>;\n+pub type StrComponents<'a> =\n+    Map<&'a [u8], Option<&'a str>, Components<'a>, fn(&[u8]) -> Option<&str>>;\n \n /// Represents a POSIX file path\n #[deriving(Clone)]"}, {"sha": "e1b0d9b139542e39dc4fa775f713c58abc924323", "filename": "src/libstd/path/windows.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibstd%2Fpath%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibstd%2Fpath%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fwindows.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -38,12 +38,12 @@ use super::{contains_nul, BytesContainer, GenericPath, GenericPathUnsafe};\n ///\n /// Each component is yielded as Option<&str> for compatibility with PosixPath, but\n /// every component in WindowsPath is guaranteed to be Some.\n-pub type StrComponents<'a> = Map<'a, &'a str, Option<&'a str>,\n-                                       CharSplits<'a, char>>;\n+pub type StrComponents<'a> =\n+    Map<&'a str, Option<&'a str>, CharSplits<'a, char>, fn(&'a str) -> Option<&'a str>>;\n \n /// Iterator that yields successive components of a Path as &[u8]\n-pub type Components<'a> = Map<'a, Option<&'a str>, &'a [u8],\n-                                    StrComponents<'a>>;\n+pub type Components<'a> =\n+    Map<Option<&'a str>, &'a [u8], StrComponents<'a>, fn(Option<&str>) -> &[u8]>;\n \n /// Represents a Windows path\n // Notes for Windows path impl:\n@@ -1038,9 +1038,8 @@ fn parse_prefix<'a>(mut path: &'a str) -> Option<PathPrefix> {\n     }\n     return None;\n \n-    fn parse_two_comps<'a>(mut path: &'a str, f: |char| -> bool)\n-                       -> Option<(uint, uint)> {\n-        let idx_a = match path.find(|x| f(x)) {\n+    fn parse_two_comps(mut path: &str, f: fn(char) -> bool) -> Option<(uint, uint)> {\n+        let idx_a = match path.find(f) {\n             None => return None,\n             Some(x) => x\n         };"}, {"sha": "1bcdc760fc6803ccd8869a7986f6c7fde59455e9", "filename": "src/libstd/sync/once.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibstd%2Fsync%2Fonce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibstd%2Fsync%2Fonce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fonce.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -15,6 +15,7 @@\n \n use int;\n use mem::drop;\n+use ops::FnOnce;\n use sync::atomic;\n use sync::{StaticMutex, MUTEX_INIT};\n \n@@ -57,7 +58,7 @@ impl Once {\n     ///\n     /// When this function returns, it is guaranteed that some initialization\n     /// has run and completed (it may not be the closure specified).\n-    pub fn doit(&'static self, f: ||) {\n+    pub fn doit<F>(&'static self, f: F) where F: FnOnce() {\n         // Optimize common path: load is much cheaper than fetch_add.\n         if self.cnt.load(atomic::SeqCst) < 0 {\n             return"}, {"sha": "6c5fc3005edd27b38ecad8b9e5dd387925512279", "filename": "src/libstd/sys/common/helper_thread.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibstd%2Fsys%2Fcommon%2Fhelper_thread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibstd%2Fsys%2Fcommon%2Fhelper_thread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fhelper_thread.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -70,9 +70,10 @@ impl<M: Send> Helper<M> {\n     /// passed to the helper thread in a separate task.\n     ///\n     /// This function is safe to be called many times.\n-    pub fn boot<T: Send>(&'static self,\n-                         f: || -> T,\n-                         helper: fn(helper_signal::signal, Receiver<M>, T)) {\n+    pub fn boot<T, F>(&'static self, f: F, helper: fn(helper_signal::signal, Receiver<M>, T)) where\n+        T: Send,\n+        F: FnOnce() -> T,\n+    {\n         unsafe {\n             let _guard = self.lock.lock();\n             if !*self.initialized.get() {"}, {"sha": "73e1c7bd9e5e0e596505dad79445ef2ca3fee9f9", "filename": "src/libstd/sys/common/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibstd%2Fsys%2Fcommon%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibstd%2Fsys%2Fcommon%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fmod.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -69,7 +69,9 @@ pub fn mkerr_libc<T: Int>(ret: T) -> IoResult<()> {\n     }\n }\n \n-pub fn keep_going(data: &[u8], f: |*const u8, uint| -> i64) -> i64 {\n+pub fn keep_going<F>(data: &[u8], mut f: F) -> i64 where\n+    F: FnMut(*const u8, uint) -> i64,\n+{\n     let origamt = data.len();\n     let mut data = data.as_ptr();\n     let mut amt = origamt;"}, {"sha": "73da200e1623828eec709345afb7bd4b48dfce80", "filename": "src/libstd/sys/common/net.rs", "status": "modified", "additions": 20, "deletions": 17, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibstd%2Fsys%2Fcommon%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibstd%2Fsys%2Fcommon%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fnet.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -344,10 +344,10 @@ pub fn get_host_addresses(host: Option<&str>, servname: Option<&str>,\n // [1] http://twistedmatrix.com/pipermail/twisted-commits/2012-April/034692.html\n // [2] http://stackoverflow.com/questions/19819198/does-send-msg-dontwait\n \n-pub fn read<T>(fd: sock_t,\n-               deadline: u64,\n-               lock: || -> T,\n-               read: |bool| -> libc::c_int) -> IoResult<uint> {\n+pub fn read<T, L, R>(fd: sock_t, deadline: u64, mut lock: L, mut read: R) -> IoResult<uint> where\n+    L: FnMut() -> T,\n+    R: FnMut(bool) -> libc::c_int,\n+{\n     let mut ret = -1;\n     if deadline == 0 {\n         ret = retry(|| read(false));\n@@ -386,12 +386,15 @@ pub fn read<T>(fd: sock_t,\n     }\n }\n \n-pub fn write<T>(fd: sock_t,\n-                deadline: u64,\n-                buf: &[u8],\n-                write_everything: bool,\n-                lock: || -> T,\n-                write: |bool, *const u8, uint| -> i64) -> IoResult<uint> {\n+pub fn write<T, L, W>(fd: sock_t,\n+                      deadline: u64,\n+                      buf: &[u8],\n+                      write_everything: bool,\n+                      mut lock: L,\n+                      mut write: W) -> IoResult<uint> where\n+    L: FnMut() -> T,\n+    W: FnMut(bool, *const u8, uint) -> i64,\n+{\n     let mut ret = -1;\n     let mut written = 0;\n     if deadline == 0 {\n@@ -674,8 +677,8 @@ impl TcpStream {\n \n     pub fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n         let fd = self.fd();\n-        let dolock = || self.lock_nonblocking();\n-        let doread = |nb| unsafe {\n+        let dolock = |&:| self.lock_nonblocking();\n+        let doread = |&mut: nb| unsafe {\n             let flags = if nb {c::MSG_DONTWAIT} else {0};\n             libc::recv(fd,\n                        buf.as_mut_ptr() as *mut libc::c_void,\n@@ -687,8 +690,8 @@ impl TcpStream {\n \n     pub fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n         let fd = self.fd();\n-        let dolock = || self.lock_nonblocking();\n-        let dowrite = |nb: bool, buf: *const u8, len: uint| unsafe {\n+        let dolock = |&:| self.lock_nonblocking();\n+        let dowrite = |&: nb: bool, buf: *const u8, len: uint| unsafe {\n             let flags = if nb {c::MSG_DONTWAIT} else {0};\n             libc::send(fd,\n                        buf as *const _,\n@@ -822,7 +825,7 @@ impl UdpSocket {\n         let mut addrlen: libc::socklen_t =\n                 mem::size_of::<libc::sockaddr_storage>() as libc::socklen_t;\n \n-        let dolock = || self.lock_nonblocking();\n+        let dolock = |&:| self.lock_nonblocking();\n         let n = try!(read(fd, self.read_deadline, dolock, |nb| unsafe {\n             let flags = if nb {c::MSG_DONTWAIT} else {0};\n             libc::recvfrom(fd,\n@@ -843,8 +846,8 @@ impl UdpSocket {\n         let dstp = &storage as *const _ as *const libc::sockaddr;\n \n         let fd = self.fd();\n-        let dolock = || self.lock_nonblocking();\n-        let dowrite = |nb, buf: *const u8, len: uint| unsafe {\n+        let dolock = |&: | self.lock_nonblocking();\n+        let dowrite = |&mut: nb, buf: *const u8, len: uint| unsafe {\n             let flags = if nb {c::MSG_DONTWAIT} else {0};\n             libc::sendto(fd,\n                          buf as *const libc::c_void,"}, {"sha": "107263c31a7665585c69a399595fec295858ec82", "filename": "src/libstd/sys/unix/mod.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fmod.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -125,7 +125,10 @@ pub fn decode_error_detailed(errno: i32) -> IoError {\n }\n \n #[inline]\n-pub fn retry<T: SignedInt> (f: || -> T) -> T {\n+pub fn retry<T, F> (mut f: F) -> T where\n+    T: SignedInt,\n+    F: FnMut() -> T,\n+{\n     let one: T = Int::one();\n     loop {\n         let n = f();"}, {"sha": "26fd410a7a9b61c19bb41426230d1e1bbbb12913", "filename": "src/libstd/sys/unix/pipe.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibstd%2Fsys%2Funix%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibstd%2Fsys%2Funix%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fpipe.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -149,8 +149,8 @@ impl UnixStream {\n \n     pub fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n         let fd = self.fd();\n-        let dolock = || self.lock_nonblocking();\n-        let doread = |nb| unsafe {\n+        let dolock = |&:| self.lock_nonblocking();\n+        let doread = |&mut: nb| unsafe {\n             let flags = if nb {c::MSG_DONTWAIT} else {0};\n             libc::recv(fd,\n                        buf.as_mut_ptr() as *mut libc::c_void,\n@@ -162,8 +162,8 @@ impl UnixStream {\n \n     pub fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n         let fd = self.fd();\n-        let dolock = || self.lock_nonblocking();\n-        let dowrite = |nb: bool, buf: *const u8, len: uint| unsafe {\n+        let dolock = |&: | self.lock_nonblocking();\n+        let dowrite = |&: nb: bool, buf: *const u8, len: uint| unsafe {\n             let flags = if nb {c::MSG_DONTWAIT} else {0};\n             libc::send(fd,\n                        buf as *const _,"}, {"sha": "41361a0cde695a5b9cf887125865a18ef69af3d5", "filename": "src/libstd/sys/windows/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -138,7 +138,7 @@ pub fn decode_error_detailed(errno: i32) -> IoError {\n }\n \n #[inline]\n-pub fn retry<I> (f: || -> I) -> I { f() } // PR rust-lang/rust/#17020\n+pub fn retry<I, F>(f: F) -> I where F: FnOnce() -> I { f() } // PR rust-lang/rust/#17020\n \n pub fn ms_to_timeval(ms: u64) -> libc::timeval {\n     libc::timeval {"}, {"sha": "356d6f02565ede63f635d54b0f9f2e42c39ba831", "filename": "src/libstd/sys/windows/process.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -418,9 +418,8 @@ fn make_command_line(prog: &CString, args: &[CString]) -> String {\n     }\n }\n \n-fn with_envp<K, V, T>(env: Option<&collections::HashMap<K, V>>,\n-                      cb: |*mut c_void| -> T) -> T\n-    where K: BytesContainer + Eq + Hash, V: BytesContainer\n+fn with_envp<K, V, T, F>(env: Option<&collections::HashMap<K, V>>, cb: F) -> T where\n+    K: BytesContainer + Eq + Hash, V: BytesContainer, F: FnOnce(*mut c_void) -> T,\n {\n     // On Windows we pass an \"environment block\" which is not a char**, but\n     // rather a concatenation of null-terminated k=v\\0 sequences, with a final\n@@ -445,7 +444,9 @@ fn with_envp<K, V, T>(env: Option<&collections::HashMap<K, V>>,\n     }\n }\n \n-fn with_dirp<T>(d: Option<&CString>, cb: |*const u16| -> T) -> T {\n+fn with_dirp<T, F>(d: Option<&CString>, cb: F) -> T where\n+    F: FnOnce(*const u16) -> T,\n+{\n     match d {\n       Some(dir) => {\n           let dir_str = dir.as_str()"}, {"sha": "5a1a5b4fb7a107ff7d55d96b706e384eb48f216d", "filename": "src/libstd/task.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibstd%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibstd%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -381,7 +381,9 @@ mod test {\n         rx.recv();\n     }\n \n-    fn avoid_copying_the_body(spawnfn: |v: proc():Send|) {\n+    fn avoid_copying_the_body<F>(spawnfn: F) where\n+        F: FnOnce(proc():Send),\n+    {\n         let (tx, rx) = channel::<uint>();\n \n         let x = box 1;"}, {"sha": "b85b6eccb771821f09410be45ec26c42bbed2abe", "filename": "src/libstd/thread_local/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibstd%2Fthread_local%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibstd%2Fthread_local%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread_local%2Fmod.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -218,7 +218,9 @@ impl<T: 'static> Key<T> {\n     /// This function will `panic!()` if the key currently has its\n     /// destructor running, and it **may** panic if the destructor has\n     /// previously been run for this thread.\n-    pub fn with<R>(&'static self, f: |&T| -> R) -> R {\n+    pub fn with<R, F>(&'static self, f: F) -> R where\n+        F: FnOnce(&T) -> R,\n+    {\n         let slot = (self.inner)();\n         unsafe {\n             let slot = slot.get().expect(\"cannot access a TLS value during or \\"}, {"sha": "ee742ab83751d94cd025e12acbe85dbd7f271462", "filename": "src/libstd/thread_local/scoped.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibstd%2Fthread_local%2Fscoped.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibstd%2Fthread_local%2Fscoped.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread_local%2Fscoped.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -135,7 +135,9 @@ impl<T> Key<T> {\n     ///     assert_eq!(val, 100);\n     /// });\n     /// ```\n-    pub fn set<R>(&'static self, t: &T, cb: || -> R) -> R {\n+    pub fn set<R, F>(&'static self, t: &T, cb: F) -> R where\n+        F: FnOnce() -> R,\n+    {\n         struct Reset<'a, T: 'a> {\n             key: &'a KeyInner<T>,\n             val: *mut T,\n@@ -175,7 +177,9 @@ impl<T> Key<T> {\n     ///     // work with `slot`\n     /// });\n     /// ```\n-    pub fn with<R>(&'static self, cb: |&T| -> R) -> R {\n+    pub fn with<R, F>(&'static self, cb: F) -> R where\n+        F: FnOnce(&T) -> R\n+    {\n         unsafe {\n             let ptr = self.inner.get();\n             assert!(!ptr.is_null(), \"cannot access a scoped thread local \\"}, {"sha": "34a3d6aa2753645b2fcd39d69765c5fe480b5c68", "filename": "src/libstd/time/duration.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibstd%2Ftime%2Fduration.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibstd%2Ftime%2Fduration.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime%2Fduration.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -14,7 +14,7 @@\n \n use {fmt, i64};\n use kinds::Copy;\n-use ops::{Add, Sub, Mul, Div, Neg};\n+use ops::{Add, Sub, Mul, Div, Neg, FnOnce};\n use option::Option;\n use option::Option::{Some, None};\n use num::Int;\n@@ -141,7 +141,7 @@ impl Duration {\n \n     /// Runs a closure, returning the duration of time it took to run the\n     /// closure.\n-    pub fn span(f: ||) -> Duration {\n+    pub fn span<F>(f: F) -> Duration where F: FnOnce() {\n         let before = super::precise_time_ns();\n         f();\n         Duration::nanoseconds((super::precise_time_ns() - before) as i64)"}, {"sha": "75f69f2f6d062a093134fbee3322749bc781bfc3", "filename": "src/libsyntax/ast_map/blocks.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibsyntax%2Fast_map%2Fblocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibsyntax%2Fast_map%2Fblocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map%2Fblocks.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -181,22 +181,23 @@ impl<'a> FnLikeNode<'a> {\n     }\n \n     pub fn kind(self) -> visit::FnKind<'a> {\n-        let item = |p: ItemFnParts<'a>| -> visit::FnKind<'a> {\n+        let item = |: p: ItemFnParts<'a>| -> visit::FnKind<'a> {\n             visit::FkItemFn(p.ident, p.generics, p.style, p.abi)\n         };\n-        let closure = |_: ClosureParts| {\n+        let closure = |: _: ClosureParts| {\n             visit::FkFnBlock\n         };\n-        let method = |m: &'a ast::Method| {\n+        let method = |: m: &'a ast::Method| {\n             visit::FkMethod(m.pe_ident(), m.pe_generics(), m)\n         };\n         self.handle(item, method, closure)\n     }\n \n-    fn handle<A>(self,\n-                 item_fn: |ItemFnParts<'a>| -> A,\n-                 method: |&'a ast::Method| -> A,\n-                 closure: |ClosureParts<'a>| -> A) -> A {\n+    fn handle<A, I, M, C>(self, item_fn: I, method: M, closure: C) -> A where\n+        I: FnOnce(ItemFnParts<'a>) -> A,\n+        M: FnOnce(&'a ast::Method) -> A,\n+        C: FnOnce(ClosureParts<'a>) -> A,\n+    {\n         match self.node {\n             ast_map::NodeItem(i) => match i.node {\n                 ast::ItemFn(ref decl, style, abi, ref generics, ref block) =>"}, {"sha": "907ac6b19fc0dced1053f4383fdda45b7d0c4f3c", "filename": "src/libsyntax/ast_map/mod.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibsyntax%2Fast_map%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibsyntax%2Fast_map%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map%2Fmod.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -424,7 +424,9 @@ impl<'ast> Map<'ast> {\n         }\n     }\n \n-    pub fn with_path<T>(&self, id: NodeId, f: |PathElems| -> T) -> T {\n+    pub fn with_path<T, F>(&self, id: NodeId, f: F) -> T where\n+        F: FnOnce(PathElems) -> T,\n+    {\n         self.with_path_next(id, None, f)\n     }\n \n@@ -438,7 +440,9 @@ impl<'ast> Map<'ast> {\n         })\n     }\n \n-    fn with_path_next<T>(&self, id: NodeId, next: LinkedPath, f: |PathElems| -> T) -> T {\n+    fn with_path_next<T, F>(&self, id: NodeId, next: LinkedPath, f: F) -> T where\n+        F: FnOnce(PathElems) -> T,\n+    {\n         let parent = self.get_parent(id);\n         let parent = match self.find_entry(id) {\n             Some(EntryForeignItem(..)) | Some(EntryVariant(..)) => {\n@@ -470,7 +474,9 @@ impl<'ast> Map<'ast> {\n \n     /// Given a node ID and a closure, apply the closure to the array\n     /// of attributes associated with the AST corresponding to the Node ID\n-    pub fn with_attrs<T>(&self, id: NodeId, f: |Option<&[Attribute]>| -> T) -> T {\n+    pub fn with_attrs<T, F>(&self, id: NodeId, f: F) -> T where\n+        F: FnOnce(Option<&[Attribute]>) -> T,\n+    {\n         let attrs = match self.get(id) {\n             NodeItem(i) => Some(i.attrs.as_slice()),\n             NodeForeignItem(fi) => Some(fi.attrs.as_slice()),"}, {"sha": "7579972c6d84337a164e17683d39bbf28fd4a7b3", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -602,6 +602,7 @@ pub fn compute_id_range_for_fn_body(fk: visit::FnKind,\n     id_visitor.operation.result\n }\n \n+// FIXME(#19596) unbox `it`\n pub fn walk_pat(pat: &Pat, it: |&Pat| -> bool) -> bool {\n     if !it(pat) {\n         return false;\n@@ -632,21 +633,21 @@ pub fn walk_pat(pat: &Pat, it: |&Pat| -> bool) -> bool {\n }\n \n pub trait EachViewItem {\n-    fn each_view_item(&self, f: |&ast::ViewItem| -> bool) -> bool;\n+    fn each_view_item<F>(&self, f: F) -> bool where F: FnMut(&ast::ViewItem) -> bool;\n }\n \n-struct EachViewItemData<'a> {\n-    callback: |&ast::ViewItem|: 'a -> bool,\n+struct EachViewItemData<F> where F: FnMut(&ast::ViewItem) -> bool {\n+    callback: F,\n }\n \n-impl<'a, 'v> Visitor<'v> for EachViewItemData<'a> {\n+impl<'v, F> Visitor<'v> for EachViewItemData<F> where F: FnMut(&ast::ViewItem) -> bool {\n     fn visit_view_item(&mut self, view_item: &ast::ViewItem) {\n         let _ = (self.callback)(view_item);\n     }\n }\n \n impl EachViewItem for ast::Crate {\n-    fn each_view_item(&self, f: |&ast::ViewItem| -> bool) -> bool {\n+    fn each_view_item<F>(&self, f: F) -> bool where F: FnMut(&ast::ViewItem) -> bool {\n         let mut visit = EachViewItemData {\n             callback: f,\n         };"}, {"sha": "8248eae4b8cdd4cb4b1d225a7d20dcadf93d4125", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -115,7 +115,8 @@ impl AttrMetaMethods for P<MetaItem> {\n \n pub trait AttributeMethods {\n     fn meta<'a>(&'a self) -> &'a MetaItem;\n-    fn with_desugared_doc<T>(&self, f: |&Attribute| -> T) -> T;\n+    fn with_desugared_doc<T, F>(&self, f: F) -> T where\n+        F: FnOnce(&Attribute) -> T;\n }\n \n impl AttributeMethods for Attribute {\n@@ -127,7 +128,9 @@ impl AttributeMethods for Attribute {\n     /// Convert self to a normal #[doc=\"foo\"] comment, if it is a\n     /// comment like `///` or `/** */`. (Returns self unchanged for\n     /// non-sugared doc attributes.)\n-    fn with_desugared_doc<T>(&self, f: |&Attribute| -> T) -> T {\n+    fn with_desugared_doc<T, F>(&self, f: F) -> T where\n+        F: FnOnce(&Attribute) -> T,\n+    {\n         if self.node.is_sugared_doc {\n             let comment = self.value_str().unwrap();\n             let meta = mk_name_value_item_str("}, {"sha": "d2fe667339c848b932daa7860c73f928b9193d5f", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -568,7 +568,9 @@ impl CodeMap {\n         ExpnId(expansions.len().to_u32().expect(\"too many ExpnInfo's!\") - 1)\n     }\n \n-    pub fn with_expn_info<T>(&self, id: ExpnId, f: |Option<&ExpnInfo>| -> T) -> T {\n+    pub fn with_expn_info<T, F>(&self, id: ExpnId, f: F) -> T where\n+        F: FnOnce(Option<&ExpnInfo>) -> T,\n+    {\n         match id {\n             NO_EXPANSION => f(None),\n             ExpnId(i) => f(Some(&(*self.expansions.borrow())[i as uint]))"}, {"sha": "87426dce918177e34671eaf3d91a639f38fcfcc7", "filename": "src/libsyntax/config.rs", "status": "modified", "additions": 59, "deletions": 23, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibsyntax%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibsyntax%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fconfig.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -19,8 +19,8 @@ use util::small_vector::SmallVector;\n \n /// A folder that strips out items that do not belong in the current\n /// configuration.\n-struct Context<'a> {\n-    in_cfg: |attrs: &[ast::Attribute]|: 'a -> bool,\n+struct Context<F> where F: FnMut(&[ast::Attribute]) -> bool {\n+    in_cfg: F,\n }\n \n // Support conditional compilation by transforming the AST, stripping out\n@@ -30,7 +30,7 @@ pub fn strip_unconfigured_items(diagnostic: &SpanHandler, krate: ast::Crate) ->\n     strip_items(krate, |attrs| in_cfg(diagnostic, config.as_slice(), attrs))\n }\n \n-impl<'a> fold::Folder for Context<'a> {\n+impl<F> fold::Folder for Context<F> where F: FnMut(&[ast::Attribute]) -> bool {\n     fn fold_mod(&mut self, module: ast::Mod) -> ast::Mod {\n         fold_mod(self, module)\n     }\n@@ -54,24 +54,32 @@ impl<'a> fold::Folder for Context<'a> {\n     }\n }\n \n-pub fn strip_items(krate: ast::Crate,\n-                   in_cfg: |attrs: &[ast::Attribute]| -> bool)\n-                   -> ast::Crate {\n+pub fn strip_items<F>(krate: ast::Crate, in_cfg: F) -> ast::Crate where\n+    F: FnMut(&[ast::Attribute]) -> bool,\n+{\n     let mut ctxt = Context {\n         in_cfg: in_cfg,\n     };\n     ctxt.fold_crate(krate)\n }\n \n-fn filter_view_item(cx: &mut Context, view_item: ast::ViewItem) -> Option<ast::ViewItem> {\n+fn filter_view_item<F>(cx: &mut Context<F>,\n+                       view_item: ast::ViewItem)\n+                       -> Option<ast::ViewItem> where\n+    F: FnMut(&[ast::Attribute]) -> bool\n+{\n     if view_item_in_cfg(cx, &view_item) {\n         Some(view_item)\n     } else {\n         None\n     }\n }\n \n-fn fold_mod(cx: &mut Context, ast::Mod {inner, view_items, items}: ast::Mod) -> ast::Mod {\n+fn fold_mod<F>(cx: &mut Context<F>,\n+               ast::Mod {inner,\n+               view_items, items}: ast::Mod) -> ast::Mod where\n+    F: FnMut(&[ast::Attribute]) -> bool\n+{\n     ast::Mod {\n         inner: inner,\n         view_items: view_items.into_iter().filter_map(|a| {\n@@ -83,17 +91,23 @@ fn fold_mod(cx: &mut Context, ast::Mod {inner, view_items, items}: ast::Mod) ->\n     }\n }\n \n-fn filter_foreign_item(cx: &mut Context, item: P<ast::ForeignItem>)\n-                       -> Option<P<ast::ForeignItem>> {\n+fn filter_foreign_item<F>(cx: &mut Context<F>,\n+                          item: P<ast::ForeignItem>)\n+                          -> Option<P<ast::ForeignItem>> where\n+    F: FnMut(&[ast::Attribute]) -> bool\n+{\n     if foreign_item_in_cfg(cx, &*item) {\n         Some(item)\n     } else {\n         None\n     }\n }\n \n-fn fold_foreign_mod(cx: &mut Context, ast::ForeignMod {abi, view_items, items}: ast::ForeignMod)\n-                    -> ast::ForeignMod {\n+fn fold_foreign_mod<F>(cx: &mut Context<F>,\n+                       ast::ForeignMod {abi, view_items, items}: ast::ForeignMod)\n+                       -> ast::ForeignMod where\n+    F: FnMut(&[ast::Attribute]) -> bool\n+{\n     ast::ForeignMod {\n         abi: abi,\n         view_items: view_items.into_iter().filter_map(|a| {\n@@ -105,15 +119,19 @@ fn fold_foreign_mod(cx: &mut Context, ast::ForeignMod {abi, view_items, items}:\n     }\n }\n \n-fn fold_item(cx: &mut Context, item: P<ast::Item>) -> SmallVector<P<ast::Item>> {\n+fn fold_item<F>(cx: &mut Context<F>, item: P<ast::Item>) -> SmallVector<P<ast::Item>> where\n+    F: FnMut(&[ast::Attribute]) -> bool\n+{\n     if item_in_cfg(cx, &*item) {\n         SmallVector::one(item.map(|i| cx.fold_item_simple(i)))\n     } else {\n         SmallVector::zero()\n     }\n }\n \n-fn fold_item_underscore(cx: &mut Context, item: ast::Item_) -> ast::Item_ {\n+fn fold_item_underscore<F>(cx: &mut Context<F>, item: ast::Item_) -> ast::Item_ where\n+    F: FnMut(&[ast::Attribute]) -> bool\n+{\n     let item = match item {\n         ast::ItemImpl(a, b, c, impl_items) => {\n             let impl_items = impl_items.into_iter()\n@@ -166,7 +184,9 @@ fn fold_item_underscore(cx: &mut Context, item: ast::Item_) -> ast::Item_ {\n     fold::noop_fold_item_underscore(item, cx)\n }\n \n-fn fold_struct(cx: &mut Context, def: P<ast::StructDef>) -> P<ast::StructDef> {\n+fn fold_struct<F>(cx: &mut Context<F>, def: P<ast::StructDef>) -> P<ast::StructDef> where\n+    F: FnMut(&[ast::Attribute]) -> bool\n+{\n     def.map(|ast::StructDef { fields, ctor_id }| {\n         ast::StructDef {\n             fields: fields.into_iter().filter(|m| {\n@@ -177,7 +197,9 @@ fn fold_struct(cx: &mut Context, def: P<ast::StructDef>) -> P<ast::StructDef> {\n     })\n }\n \n-fn retain_stmt(cx: &mut Context, stmt: &ast::Stmt) -> bool {\n+fn retain_stmt<F>(cx: &mut Context<F>, stmt: &ast::Stmt) -> bool where\n+    F: FnMut(&[ast::Attribute]) -> bool\n+{\n     match stmt.node {\n         ast::StmtDecl(ref decl, _) => {\n             match decl.node {\n@@ -191,7 +213,9 @@ fn retain_stmt(cx: &mut Context, stmt: &ast::Stmt) -> bool {\n     }\n }\n \n-fn fold_block(cx: &mut Context, b: P<ast::Block>) -> P<ast::Block> {\n+fn fold_block<F>(cx: &mut Context<F>, b: P<ast::Block>) -> P<ast::Block> where\n+    F: FnMut(&[ast::Attribute]) -> bool\n+{\n     b.map(|ast::Block {id, view_items, stmts, expr, rules, span}| {\n         let resulting_stmts: Vec<P<ast::Stmt>> =\n             stmts.into_iter().filter(|a| retain_stmt(cx, &**a)).collect();\n@@ -212,7 +236,9 @@ fn fold_block(cx: &mut Context, b: P<ast::Block>) -> P<ast::Block> {\n     })\n }\n \n-fn fold_expr(cx: &mut Context, expr: P<ast::Expr>) -> P<ast::Expr> {\n+fn fold_expr<F>(cx: &mut Context<F>, expr: P<ast::Expr>) -> P<ast::Expr> where\n+    F: FnMut(&[ast::Attribute]) -> bool\n+{\n     expr.map(|ast::Expr {id, span, node}| {\n         fold::noop_fold_expr(ast::Expr {\n             id: id,\n@@ -229,27 +255,37 @@ fn fold_expr(cx: &mut Context, expr: P<ast::Expr>) -> P<ast::Expr> {\n     })\n }\n \n-fn item_in_cfg(cx: &mut Context, item: &ast::Item) -> bool {\n+fn item_in_cfg<F>(cx: &mut Context<F>, item: &ast::Item) -> bool where\n+    F: FnMut(&[ast::Attribute]) -> bool\n+{\n     return (cx.in_cfg)(item.attrs.as_slice());\n }\n \n-fn foreign_item_in_cfg(cx: &mut Context, item: &ast::ForeignItem) -> bool {\n+fn foreign_item_in_cfg<F>(cx: &mut Context<F>, item: &ast::ForeignItem) -> bool where\n+    F: FnMut(&[ast::Attribute]) -> bool\n+{\n     return (cx.in_cfg)(item.attrs.as_slice());\n }\n \n-fn view_item_in_cfg(cx: &mut Context, item: &ast::ViewItem) -> bool {\n+fn view_item_in_cfg<F>(cx: &mut Context<F>, item: &ast::ViewItem) -> bool where\n+    F: FnMut(&[ast::Attribute]) -> bool\n+{\n     return (cx.in_cfg)(item.attrs.as_slice());\n }\n \n-fn trait_method_in_cfg(cx: &mut Context, meth: &ast::TraitItem) -> bool {\n+fn trait_method_in_cfg<F>(cx: &mut Context<F>, meth: &ast::TraitItem) -> bool where\n+    F: FnMut(&[ast::Attribute]) -> bool\n+{\n     match *meth {\n         ast::RequiredMethod(ref meth) => (cx.in_cfg)(meth.attrs.as_slice()),\n         ast::ProvidedMethod(ref meth) => (cx.in_cfg)(meth.attrs.as_slice()),\n         ast::TypeTraitItem(ref typ) => (cx.in_cfg)(typ.attrs.as_slice()),\n     }\n }\n \n-fn impl_item_in_cfg(cx: &mut Context, impl_item: &ast::ImplItem) -> bool {\n+fn impl_item_in_cfg<F>(cx: &mut Context<F>, impl_item: &ast::ImplItem) -> bool where\n+    F: FnMut(&[ast::Attribute]) -> bool\n+{\n     match *impl_item {\n         ast::MethodImplItem(ref meth) => (cx.in_cfg)(meth.attrs.as_slice()),\n         ast::TypeImplItem(ref typ) => (cx.in_cfg)(typ.attrs.as_slice()),"}, {"sha": "3a816987922641631edef4ea0a8629a479a517f2", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -581,7 +581,9 @@ fn print_macro_backtrace(w: &mut EmitterWriter,\n     cs.map_or(Ok(()), |call_site| print_macro_backtrace(w, cm, call_site))\n }\n \n-pub fn expect<T>(diag: &SpanHandler, opt: Option<T>, msg: || -> String) -> T {\n+pub fn expect<T, M>(diag: &SpanHandler, opt: Option<T>, msg: M) -> T where\n+    M: FnOnce() -> String,\n+{\n     match opt {\n         Some(t) => t,\n         None => diag.handler().bug(msg().as_slice()),"}, {"sha": "cb2a1f8acd8bf3630068e08ba6f6a1187e57d786", "filename": "src/libsyntax/diagnostics/plugin.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -25,14 +25,18 @@ thread_local!(static USED_DIAGNOSTICS: RefCell<HashMap<Name, Span>> = {\n     RefCell::new(HashMap::new())\n })\n \n-fn with_registered_diagnostics<T>(f: |&mut HashMap<Name, Option<Name>>| -> T) -> T {\n-    REGISTERED_DIAGNOSTICS.with(|slot| {\n+fn with_registered_diagnostics<T, F>(f: F) -> T where\n+    F: FnOnce(&mut HashMap<Name, Option<Name>>) -> T,\n+{\n+    REGISTERED_DIAGNOSTICS.with(move |slot| {\n         f(&mut *slot.borrow_mut())\n     })\n }\n \n-fn with_used_diagnostics<T>(f: |&mut HashMap<Name, Span>| -> T) -> T {\n-    USED_DIAGNOSTICS.with(|slot| {\n+fn with_used_diagnostics<T, F>(f: F) -> T where\n+    F: FnOnce(&mut HashMap<Name, Span>) -> T,\n+{\n+    USED_DIAGNOSTICS.with(move |slot| {\n         f(&mut *slot.borrow_mut())\n     })\n }"}, {"sha": "3145b3bb1a4fe2da4ebbc9b77361a8b96abddfb3", "filename": "src/libsyntax/ext/deriving/bounds.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibsyntax%2Fext%2Fderiving%2Fbounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibsyntax%2Fext%2Fderiving%2Fbounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fbounds.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -15,12 +15,13 @@ use ext::deriving::generic::*;\n use ext::deriving::generic::ty::*;\n use ptr::P;\n \n-pub fn expand_deriving_bound(cx: &mut ExtCtxt,\n-                             span: Span,\n-                             mitem: &MetaItem,\n-                             item: &Item,\n-                             push: |P<Item>|) {\n-\n+pub fn expand_deriving_bound<F>(cx: &mut ExtCtxt,\n+                                span: Span,\n+                                mitem: &MetaItem,\n+                                item: &Item,\n+                                push: F) where\n+    F: FnOnce(P<Item>),\n+{\n     let name = match mitem.node {\n         MetaWord(ref tname) => {\n             match tname.get() {"}, {"sha": "a34764221b3b60704212365fe0b15b9f10ba69b2", "filename": "src/libsyntax/ext/deriving/clone.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -17,11 +17,13 @@ use ext::deriving::generic::ty::*;\n use parse::token::InternedString;\n use ptr::P;\n \n-pub fn expand_deriving_clone(cx: &mut ExtCtxt,\n-                             span: Span,\n-                             mitem: &MetaItem,\n-                             item: &Item,\n-                             push: |P<Item>|) {\n+pub fn expand_deriving_clone<F>(cx: &mut ExtCtxt,\n+                                span: Span,\n+                                mitem: &MetaItem,\n+                                item: &Item,\n+                                push: F) where\n+    F: FnOnce(P<Item>),\n+{\n     let inline = cx.meta_word(span, InternedString::new(\"inline\"));\n     let attrs = vec!(cx.attribute(span, inline));\n     let trait_def = TraitDef {\n@@ -60,7 +62,7 @@ fn cs_clone(\n         cx.ident_of(\"Clone\"),\n         cx.ident_of(\"clone\"),\n     ];\n-    let subcall = |field: &FieldInfo| {\n+    let subcall = |&: field: &FieldInfo| {\n         let args = vec![cx.expr_addr_of(field.span, field.self_.clone())];\n \n         cx.expr_call_global(field.span, fn_path.clone(), args)"}, {"sha": "c8bf5ec326cd9178cfea5acdc57d15c419c44bd3", "filename": "src/libsyntax/ext/deriving/cmp/eq.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Feq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Feq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Feq.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -17,11 +17,13 @@ use ext::deriving::generic::ty::*;\n use parse::token::InternedString;\n use ptr::P;\n \n-pub fn expand_deriving_eq(cx: &mut ExtCtxt,\n-                          span: Span,\n-                          mitem: &MetaItem,\n-                          item: &Item,\n-                          push: |P<Item>|) {\n+pub fn expand_deriving_eq<F>(cx: &mut ExtCtxt,\n+                             span: Span,\n+                             mitem: &MetaItem,\n+                             item: &Item,\n+                             push: F) where\n+    F: FnOnce(P<Item>),\n+{\n     // structures are equal if all fields are equal, and non equal, if\n     // any fields are not equal or if the enum variants are different\n     fn cs_eq(cx: &mut ExtCtxt, span: Span, substr: &Substructure) -> P<Expr> {"}, {"sha": "bd1962de56ed903d9a0f0a8d9353de8bf8cd45d5", "filename": "src/libsyntax/ext/deriving/cmp/ord.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -20,11 +20,13 @@ use ext::deriving::generic::ty::*;\n use parse::token::InternedString;\n use ptr::P;\n \n-pub fn expand_deriving_ord(cx: &mut ExtCtxt,\n-                           span: Span,\n-                           mitem: &MetaItem,\n-                           item: &Item,\n-                           push: |P<Item>|) {\n+pub fn expand_deriving_ord<F>(cx: &mut ExtCtxt,\n+                              span: Span,\n+                              mitem: &MetaItem,\n+                              item: &Item,\n+                              push: F) where\n+    F: FnOnce(P<Item>),\n+{\n     macro_rules! md (\n         ($name:expr, $op:expr, $equal:expr) => { {\n             let inline = cx.meta_word(span, InternedString::new(\"inline\"));"}, {"sha": "2b986bea1221eb67b7ed25898d48183b50bf9b29", "filename": "src/libsyntax/ext/deriving/cmp/totaleq.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotaleq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotaleq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotaleq.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -17,11 +17,13 @@ use ext::deriving::generic::ty::*;\n use parse::token::InternedString;\n use ptr::P;\n \n-pub fn expand_deriving_totaleq(cx: &mut ExtCtxt,\n-                               span: Span,\n-                               mitem: &MetaItem,\n-                               item: &Item,\n-                               push: |P<Item>|) {\n+pub fn expand_deriving_totaleq<F>(cx: &mut ExtCtxt,\n+                                  span: Span,\n+                                  mitem: &MetaItem,\n+                                  item: &Item,\n+                                  push: F) where\n+    F: FnOnce(P<Item>),\n+{\n     fn cs_total_eq_assert(cx: &mut ExtCtxt, span: Span, substr: &Substructure) -> P<Expr> {\n         cs_same_method(|cx, span, exprs| {\n             // create `a.<method>(); b.<method>(); c.<method>(); ...`"}, {"sha": "a2bf46f41fc961a146a05f0d8a14a5b76d6f7ae3", "filename": "src/libsyntax/ext/deriving/cmp/totalord.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotalord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotalord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotalord.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -18,11 +18,13 @@ use ext::deriving::generic::ty::*;\n use parse::token::InternedString;\n use ptr::P;\n \n-pub fn expand_deriving_totalord(cx: &mut ExtCtxt,\n-                                span: Span,\n-                                mitem: &MetaItem,\n-                                item: &Item,\n-                                push: |P<Item>|) {\n+pub fn expand_deriving_totalord<F>(cx: &mut ExtCtxt,\n+                                   span: Span,\n+                                   mitem: &MetaItem,\n+                                   item: &Item,\n+                                   push: F) where\n+    F: FnOnce(P<Item>),\n+{\n     let inline = cx.meta_word(span, InternedString::new(\"inline\"));\n     let attrs = vec!(cx.attribute(span, inline));\n     let trait_def = TraitDef {"}, {"sha": "0a8d59da8967724cb5a171b2e71876ca053b689b", "filename": "src/libsyntax/ext/deriving/decodable.rs", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -21,11 +21,13 @@ use parse::token::InternedString;\n use parse::token;\n use ptr::P;\n \n-pub fn expand_deriving_decodable(cx: &mut ExtCtxt,\n-                                 span: Span,\n-                                 mitem: &MetaItem,\n-                                 item: &Item,\n-                                 push: |P<Item>|) {\n+pub fn expand_deriving_decodable<F>(cx: &mut ExtCtxt,\n+                                    span: Span,\n+                                    mitem: &MetaItem,\n+                                    item: &Item,\n+                                    push: F) where\n+    F: FnOnce(P<Item>),\n+{\n     let trait_def = TraitDef {\n         span: span,\n         attributes: Vec::new(),\n@@ -155,12 +157,14 @@ fn decodable_substructure(cx: &mut ExtCtxt, trait_span: Span,\n /// Create a decoder for a single enum variant/struct:\n /// - `outer_pat_path` is the path to this enum variant/struct\n /// - `getarg` should retrieve the `uint`-th field with name `@str`.\n-fn decode_static_fields(cx: &mut ExtCtxt,\n-                        trait_span: Span,\n-                        outer_pat_path: ast::Path,\n-                        fields: &StaticFields,\n-                        getarg: |&mut ExtCtxt, Span, InternedString, uint| -> P<Expr>)\n-                        -> P<Expr> {\n+fn decode_static_fields<F>(cx: &mut ExtCtxt,\n+                           trait_span: Span,\n+                           outer_pat_path: ast::Path,\n+                           fields: &StaticFields,\n+                           mut getarg: F)\n+                           -> P<Expr> where\n+    F: FnMut(&mut ExtCtxt, Span, InternedString, uint) -> P<Expr>,\n+{\n     match *fields {\n         Unnamed(ref fields) => {\n             let path_expr = cx.expr_path(outer_pat_path);"}, {"sha": "b3621490ce3bf6191e38415282e6d91ab1f5f1e7", "filename": "src/libsyntax/ext/deriving/default.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibsyntax%2Fext%2Fderiving%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibsyntax%2Fext%2Fderiving%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fdefault.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -17,11 +17,13 @@ use ext::deriving::generic::ty::*;\n use parse::token::InternedString;\n use ptr::P;\n \n-pub fn expand_deriving_default(cx: &mut ExtCtxt,\n-                            span: Span,\n-                            mitem: &MetaItem,\n-                            item: &Item,\n-                            push: |P<Item>|) {\n+pub fn expand_deriving_default<F>(cx: &mut ExtCtxt,\n+                                  span: Span,\n+                                  mitem: &MetaItem,\n+                                  item: &Item,\n+                                  push: F) where\n+    F: FnOnce(P<Item>),\n+{\n     let inline = cx.meta_word(span, InternedString::new(\"inline\"));\n     let attrs = vec!(cx.attribute(span, inline));\n     let trait_def = TraitDef {"}, {"sha": "30851ebeaaef3562b70554f7fad0904d88d3fba4", "filename": "src/libsyntax/ext/deriving/encodable.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -97,11 +97,13 @@ use ext::deriving::generic::ty::*;\n use parse::token;\n use ptr::P;\n \n-pub fn expand_deriving_encodable(cx: &mut ExtCtxt,\n-                                 span: Span,\n-                                 mitem: &MetaItem,\n-                                 item: &Item,\n-                                 push: |P<Item>|) {\n+pub fn expand_deriving_encodable<F>(cx: &mut ExtCtxt,\n+                                    span: Span,\n+                                    mitem: &MetaItem,\n+                                    item: &Item,\n+                                    push: F) where\n+    F: FnOnce(P<Item>),\n+{\n     let trait_def = TraitDef {\n         span: span,\n         attributes: Vec::new(),"}, {"sha": "a75be40604ea6b9fc50c36ed655a0b1276425b9b", "filename": "src/libsyntax/ext/deriving/generic/mod.rs", "status": "modified", "additions": 35, "deletions": 27, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -333,11 +333,13 @@ pub fn combine_substructure<'a>(f: CombineSubstructureFunc<'a>)\n \n \n impl<'a> TraitDef<'a> {\n-    pub fn expand(&self,\n-                  cx: &mut ExtCtxt,\n-                  mitem: &ast::MetaItem,\n-                  item: &ast::Item,\n-                  push: |P<ast::Item>|) {\n+    pub fn expand<F>(&self,\n+                     cx: &mut ExtCtxt,\n+                     mitem: &ast::MetaItem,\n+                     item: &ast::Item,\n+                     push: F) where\n+        F: FnOnce(P<ast::Item>),\n+    {\n         let newitem = match item.node {\n             ast::ItemStruct(ref struct_def, ref generics) => {\n                 self.expand_struct_def(cx,\n@@ -1309,14 +1311,16 @@ impl<'a> TraitDef<'a> {\n \n /// Fold the fields. `use_foldl` controls whether this is done\n /// left-to-right (`true`) or right-to-left (`false`).\n-pub fn cs_fold(use_foldl: bool,\n-               f: |&mut ExtCtxt, Span, P<Expr>, P<Expr>, &[P<Expr>]| -> P<Expr>,\n-               base: P<Expr>,\n-               enum_nonmatch_f: EnumNonMatchCollapsedFunc,\n-               cx: &mut ExtCtxt,\n-               trait_span: Span,\n-               substructure: &Substructure)\n-               -> P<Expr> {\n+pub fn cs_fold<F>(use_foldl: bool,\n+                  mut f: F,\n+                  base: P<Expr>,\n+                  enum_nonmatch_f: EnumNonMatchCollapsedFunc,\n+                  cx: &mut ExtCtxt,\n+                  trait_span: Span,\n+                  substructure: &Substructure)\n+                  -> P<Expr> where\n+    F: FnMut(&mut ExtCtxt, Span, P<Expr>, P<Expr>, &[P<Expr>]) -> P<Expr>,\n+{\n     match *substructure.fields {\n         EnumMatching(_, _, ref all_fields) | Struct(ref all_fields) => {\n             if use_foldl {\n@@ -1355,12 +1359,14 @@ pub fn cs_fold(use_foldl: bool,\n ///              self_2.method(__arg_1_2, __arg_2_2)])\n /// ```\n #[inline]\n-pub fn cs_same_method(f: |&mut ExtCtxt, Span, Vec<P<Expr>>| -> P<Expr>,\n-                      enum_nonmatch_f: EnumNonMatchCollapsedFunc,\n-                      cx: &mut ExtCtxt,\n-                      trait_span: Span,\n-                      substructure: &Substructure)\n-                      -> P<Expr> {\n+pub fn cs_same_method<F>(f: F,\n+                         enum_nonmatch_f: EnumNonMatchCollapsedFunc,\n+                         cx: &mut ExtCtxt,\n+                         trait_span: Span,\n+                         substructure: &Substructure)\n+                         -> P<Expr> where\n+    F: FnOnce(&mut ExtCtxt, Span, Vec<P<Expr>>) -> P<Expr>,\n+{\n     match *substructure.fields {\n         EnumMatching(_, _, ref all_fields) | Struct(ref all_fields) => {\n             // call self_n.method(other_1_n, other_2_n, ...)\n@@ -1388,14 +1394,16 @@ pub fn cs_same_method(f: |&mut ExtCtxt, Span, Vec<P<Expr>>| -> P<Expr>,\n /// fields. `use_foldl` controls whether this is done left-to-right\n /// (`true`) or right-to-left (`false`).\n #[inline]\n-pub fn cs_same_method_fold(use_foldl: bool,\n-                           f: |&mut ExtCtxt, Span, P<Expr>, P<Expr>| -> P<Expr>,\n-                           base: P<Expr>,\n-                           enum_nonmatch_f: EnumNonMatchCollapsedFunc,\n-                           cx: &mut ExtCtxt,\n-                           trait_span: Span,\n-                           substructure: &Substructure)\n-                           -> P<Expr> {\n+pub fn cs_same_method_fold<F>(use_foldl: bool,\n+                              mut f: F,\n+                              base: P<Expr>,\n+                              enum_nonmatch_f: EnumNonMatchCollapsedFunc,\n+                              cx: &mut ExtCtxt,\n+                              trait_span: Span,\n+                              substructure: &Substructure)\n+                              -> P<Expr> where\n+    F: FnMut(&mut ExtCtxt, Span, P<Expr>, P<Expr>) -> P<Expr>,\n+{\n     cs_same_method(\n         |cx, span, vals| {\n             if use_foldl {"}, {"sha": "4e59124a1294f042a966dd0f90c0064b67260cf5", "filename": "src/libsyntax/ext/deriving/hash.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibsyntax%2Fext%2Fderiving%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibsyntax%2Fext%2Fderiving%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fhash.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -17,11 +17,13 @@ use ext::deriving::generic::ty::*;\n use parse::token::InternedString;\n use ptr::P;\n \n-pub fn expand_deriving_hash(cx: &mut ExtCtxt,\n-                            span: Span,\n-                            mitem: &MetaItem,\n-                            item: &Item,\n-                            push: |P<Item>|) {\n+pub fn expand_deriving_hash<F>(cx: &mut ExtCtxt,\n+                               span: Span,\n+                               mitem: &MetaItem,\n+                               item: &Item,\n+                               push: F) where\n+    F: FnOnce(P<Item>),\n+{\n \n     let (path, generics, args) = if cx.ecfg.deriving_hash_type_parameter {\n         (Path::new_(vec!(\"std\", \"hash\", \"Hash\"), None,"}, {"sha": "8abd846373ae10264802cbb3a8880f64d644cb37", "filename": "src/libsyntax/ext/deriving/primitive.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibsyntax%2Fext%2Fderiving%2Fprimitive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibsyntax%2Fext%2Fderiving%2Fprimitive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fprimitive.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -18,11 +18,13 @@ use ext::deriving::generic::ty::*;\n use parse::token::InternedString;\n use ptr::P;\n \n-pub fn expand_deriving_from_primitive(cx: &mut ExtCtxt,\n-                                      span: Span,\n-                                      mitem: &MetaItem,\n-                                      item: &Item,\n-                                      push: |P<Item>|) {\n+pub fn expand_deriving_from_primitive<F>(cx: &mut ExtCtxt,\n+                                         span: Span,\n+                                         mitem: &MetaItem,\n+                                         item: &Item,\n+                                         push: F) where\n+    F: FnOnce(P<Item>),\n+{\n     let inline = cx.meta_word(span, InternedString::new(\"inline\"));\n     let attrs = vec!(cx.attribute(span, inline));\n     let trait_def = TraitDef {"}, {"sha": "4f6e4d1fb3c106484353c1e61e748e70485aaa1f", "filename": "src/libsyntax/ext/deriving/rand.rs", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -17,11 +17,13 @@ use ext::deriving::generic::*;\n use ext::deriving::generic::ty::*;\n use ptr::P;\n \n-pub fn expand_deriving_rand(cx: &mut ExtCtxt,\n-                            span: Span,\n-                            mitem: &MetaItem,\n-                            item: &Item,\n-                            push: |P<Item>|) {\n+pub fn expand_deriving_rand<F>(cx: &mut ExtCtxt,\n+                               span: Span,\n+                               mitem: &MetaItem,\n+                               item: &Item,\n+                               push: F) where\n+    F: FnOnce(P<Item>),\n+{\n     let trait_def = TraitDef {\n         span: span,\n         attributes: Vec::new(),\n@@ -64,7 +66,7 @@ fn rand_substructure(cx: &mut ExtCtxt, trait_span: Span, substr: &Substructure)\n         cx.ident_of(\"Rand\"),\n         cx.ident_of(\"rand\")\n     );\n-    let rand_call = |cx: &mut ExtCtxt, span| {\n+    let mut rand_call = |&mut: cx: &mut ExtCtxt, span| {\n         cx.expr_call_global(span,\n                             rand_ident.clone(),\n                             vec!(rng.clone()))\n@@ -133,12 +135,14 @@ fn rand_substructure(cx: &mut ExtCtxt, trait_span: Span, substr: &Substructure)\n         _ => cx.bug(\"Non-static method in `deriving(Rand)`\")\n     };\n \n-    fn rand_thing(cx: &mut ExtCtxt,\n-                  trait_span: Span,\n-                  ctor_path: ast::Path,\n-                  summary: &StaticFields,\n-                  rand_call: |&mut ExtCtxt, Span| -> P<Expr>)\n-                  -> P<Expr> {\n+    fn rand_thing<F>(cx: &mut ExtCtxt,\n+                     trait_span: Span,\n+                     ctor_path: ast::Path,\n+                     summary: &StaticFields,\n+                     mut rand_call: F)\n+                     -> P<Expr> where\n+        F: FnMut(&mut ExtCtxt, Span) -> P<Expr>,\n+    {\n         let path = cx.expr_path(ctor_path.clone());\n         match *summary {\n             Unnamed(ref fields) => {"}, {"sha": "a68b521bbc9a2ea2465a56a41d18ac6c82fb7d70", "filename": "src/libsyntax/ext/deriving/show.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -21,11 +21,13 @@ use ptr::P;\n \n use std::collections::HashMap;\n \n-pub fn expand_deriving_show(cx: &mut ExtCtxt,\n-                            span: Span,\n-                            mitem: &MetaItem,\n-                            item: &Item,\n-                            push: |P<Item>|) {\n+pub fn expand_deriving_show<F>(cx: &mut ExtCtxt,\n+                               span: Span,\n+                               mitem: &MetaItem,\n+                               item: &Item,\n+                               push: F) where\n+    F: FnOnce(P<Item>),\n+{\n     // &mut ::std::fmt::Formatter\n     let fmtr = Ptr(box Literal(Path::new(vec!(\"std\", \"fmt\", \"Formatter\"))),\n                    Borrowed(None, ast::MutMutable));"}, {"sha": "ea32549cad266f21893b082bcfc13f5e68505aeb", "filename": "src/libsyntax/ext/deriving/zero.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibsyntax%2Fext%2Fderiving%2Fzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibsyntax%2Fext%2Fderiving%2Fzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fzero.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -17,11 +17,13 @@ use ext::deriving::generic::ty::*;\n use parse::token::InternedString;\n use ptr::P;\n \n-pub fn expand_deriving_zero(cx: &mut ExtCtxt,\n-                            span: Span,\n-                            mitem: &MetaItem,\n-                            item: &Item,\n-                            push: |P<Item>|) {\n+pub fn expand_deriving_zero<F>(cx: &mut ExtCtxt,\n+                               span: Span,\n+                               mitem: &MetaItem,\n+                               item: &Item,\n+                               push: F) where\n+    F: FnOnce(P<Item>),\n+{\n     let inline = cx.meta_word(span, InternedString::new(\"inline\"));\n     let attrs = vec!(cx.attribute(span, inline));\n     let trait_def = TraitDef {"}, {"sha": "9c4e85f16ff8570c42527480c3610507dab21ac6", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -238,11 +238,13 @@ pub fn expand_expr(e: P<ast::Expr>, fld: &mut MacroExpander) -> P<ast::Expr> {\n /// of expansion and the mark which must be applied to the result.\n /// Our current interface doesn't allow us to apply the mark to the\n /// result until after calling make_expr, make_items, etc.\n-fn expand_mac_invoc<T>(mac: ast::Mac, span: codemap::Span,\n-                       parse_thunk: |Box<MacResult>|->Option<T>,\n-                       mark_thunk: |T,Mrk|->T,\n-                       fld: &mut MacroExpander)\n-                       -> Option<T>\n+fn expand_mac_invoc<T, F, G>(mac: ast::Mac, span: codemap::Span,\n+                             parse_thunk: F,\n+                             mark_thunk: G,\n+                             fld: &mut MacroExpander)\n+                             -> Option<T> where\n+    F: FnOnce(Box<MacResult>) -> Option<T>,\n+    G: FnOnce(T, Mrk) -> T,\n {\n     match mac.node {\n         // it would almost certainly be cleaner to pass the whole"}, {"sha": "a4e06aeaf63b9aa0d1b06a968254dca4b0cd1cc2", "filename": "src/libsyntax/ext/mtwt.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibsyntax%2Fext%2Fmtwt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibsyntax%2Fext%2Fmtwt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fmtwt.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -105,9 +105,11 @@ pub fn apply_renames(renames: &RenameList, ctxt: SyntaxContext) -> SyntaxContext\n }\n \n /// Fetch the SCTable from TLS, create one if it doesn't yet exist.\n-pub fn with_sctable<T>(op: |&SCTable| -> T) -> T {\n+pub fn with_sctable<T, F>(op: F) -> T where\n+    F: FnOnce(&SCTable) -> T,\n+{\n     thread_local!(static SCTABLE_KEY: SCTable = new_sctable_internal())\n-    SCTABLE_KEY.with(|slot| op(slot))\n+    SCTABLE_KEY.with(move |slot| op(slot))\n }\n \n // Make a fresh syntax context table with EmptyCtxt in slot zero\n@@ -167,12 +169,14 @@ type ResolveTable = HashMap<(Name,SyntaxContext),Name>;\n \n // okay, I admit, putting this in TLS is not so nice:\n // fetch the SCTable from TLS, create one if it doesn't yet exist.\n-fn with_resolve_table_mut<T>(op: |&mut ResolveTable| -> T) -> T {\n+fn with_resolve_table_mut<T, F>(op: F) -> T where\n+    F: FnOnce(&mut ResolveTable) -> T,\n+{\n     thread_local!(static RESOLVE_TABLE_KEY: RefCell<ResolveTable> = {\n         RefCell::new(HashMap::new())\n     })\n \n-    RESOLVE_TABLE_KEY.with(|slot| op(&mut *slot.borrow_mut()))\n+    RESOLVE_TABLE_KEY.with(move |slot| op(&mut *slot.borrow_mut()))\n }\n \n /// Resolve a syntax object to a name, per MTWT."}, {"sha": "0318dd5b0cd2d218e3091233cc6cc55384a57496", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -32,11 +32,11 @@ use std::rc::Rc;\n \n // This could have a better place to live.\n pub trait MoveMap<T> {\n-    fn move_map(self, f: |T| -> T) -> Self;\n+    fn move_map<F>(self, f: F) -> Self where F: FnMut(T) -> T;\n }\n \n impl<T> MoveMap<T> for Vec<T> {\n-    fn move_map(mut self, f: |T| -> T) -> Vec<T> {\n+    fn move_map<F>(mut self, mut f: F) -> Vec<T> where F: FnMut(T) -> T {\n         for p in self.iter_mut() {\n             unsafe {\n                 // FIXME(#5016) this shouldn't need to zero to be safe.\n@@ -48,7 +48,7 @@ impl<T> MoveMap<T> for Vec<T> {\n }\n \n impl<T> MoveMap<T> for OwnedSlice<T> {\n-    fn move_map(self, f: |T| -> T) -> OwnedSlice<T> {\n+    fn move_map<F>(self, f: F) -> OwnedSlice<T> where F: FnMut(T) -> T {\n         OwnedSlice::from_vec(self.into_vec().move_map(f))\n     }\n }"}, {"sha": "5d5b56d444f8ec2deb3a054f34e3cdf7f82f908d", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -25,6 +25,7 @@\n #![allow(unknown_features)]\n #![feature(macro_rules, globs, default_type_params, phase, slicing_syntax)]\n #![feature(quote, unsafe_destructor, import_shadowing)]\n+#![feature(unboxed_closures)]\n \n extern crate arena;\n extern crate fmt_macros;"}, {"sha": "8e418e46921ffb1b264c7a924f3cfb164eecf85c", "filename": "src/libsyntax/owned_slice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibsyntax%2Fowned_slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibsyntax%2Fowned_slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fowned_slice.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -49,7 +49,7 @@ impl<T> OwnedSlice<T> {\n         self.into_vec().into_iter()\n     }\n \n-    pub fn map<U>(&self, f: |&T| -> U) -> OwnedSlice<U> {\n+    pub fn map<U, F: FnMut(&T) -> U>(&self, f: F) -> OwnedSlice<U> {\n         self.iter().map(f).collect()\n     }\n }"}, {"sha": "50c7258fe1c7b75b3e8209c83861a4b311866d58", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -244,7 +244,9 @@ impl<'a> StringReader<'a> {\n     /// Calls `f` with a string slice of the source text spanning from `start`\n     /// up to but excluding `self.last_pos`, meaning the slice does not include\n     /// the character `self.curr`.\n-    pub fn with_str_from<T>(&self, start: BytePos, f: |s: &str| -> T) -> T {\n+    pub fn with_str_from<T, F>(&self, start: BytePos, f: F) -> T where\n+        F: FnOnce(&str) -> T,\n+    {\n         self.with_str_from_to(start, self.last_pos, f)\n     }\n \n@@ -264,7 +266,9 @@ impl<'a> StringReader<'a> {\n \n     /// Calls `f` with a string slice of the source text spanning from `start`\n     /// up to but excluding `end`.\n-    fn with_str_from_to<T>(&self, start: BytePos, end: BytePos, f: |s: &str| -> T) -> T {\n+    fn with_str_from_to<T, F>(&self, start: BytePos, end: BytePos, f: F) -> T where\n+        F: FnOnce(&str) -> T,\n+    {\n         f(self.filemap.src.slice(\n                 self.byte_offset(start).to_uint(),\n                 self.byte_offset(end).to_uint()))"}, {"sha": "8c44f9fdf26b7ea8f09cc8fd77fc610e7546488e", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 74, "deletions": 58, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -718,11 +718,12 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parse a sequence bracketed by `|` and `|`, stopping before the `|`.\n-    fn parse_seq_to_before_or<T>(\n-                              &mut self,\n-                              sep: &token::Token,\n-                              f: |&mut Parser| -> T)\n-                              -> Vec<T> {\n+    fn parse_seq_to_before_or<T, F>(&mut self,\n+                                    sep: &token::Token,\n+                                    mut f: F)\n+                                    -> Vec<T> where\n+        F: FnMut(&mut Parser) -> T,\n+    {\n         let mut first = true;\n         let mut vector = Vec::new();\n         while self.token != token::BinOp(token::Or) &&\n@@ -769,10 +770,12 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    pub fn parse_seq_to_before_gt_or_return<T>(&mut self,\n-                                               sep: Option<token::Token>,\n-                                               f: |&mut Parser| -> Option<T>)\n-                                               -> (OwnedSlice<T>, bool) {\n+    pub fn parse_seq_to_before_gt_or_return<T, F>(&mut self,\n+                                                  sep: Option<token::Token>,\n+                                                  mut f: F)\n+                                                  -> (OwnedSlice<T>, bool) where\n+        F: FnMut(&mut Parser) -> Option<T>,\n+    {\n         let mut v = Vec::new();\n         // This loop works by alternating back and forth between parsing types\n         // and commas.  For example, given a string `A, B,>`, the parser would\n@@ -802,28 +805,34 @@ impl<'a> Parser<'a> {\n \n     /// Parse a sequence bracketed by '<' and '>', stopping\n     /// before the '>'.\n-    pub fn parse_seq_to_before_gt<T>(&mut self,\n-                                     sep: Option<token::Token>,\n-                                     f: |&mut Parser| -> T)\n-                                     -> OwnedSlice<T> {\n+    pub fn parse_seq_to_before_gt<T, F>(&mut self,\n+                                        sep: Option<token::Token>,\n+                                        mut f: F)\n+                                        -> OwnedSlice<T> where\n+        F: FnMut(&mut Parser) -> T,\n+    {\n         let (result, returned) = self.parse_seq_to_before_gt_or_return(sep, |p| Some(f(p)));\n         assert!(!returned);\n         return result;\n     }\n \n-    pub fn parse_seq_to_gt<T>(&mut self,\n-                              sep: Option<token::Token>,\n-                              f: |&mut Parser| -> T)\n-                              -> OwnedSlice<T> {\n+    pub fn parse_seq_to_gt<T, F>(&mut self,\n+                                 sep: Option<token::Token>,\n+                                 f: F)\n+                                 -> OwnedSlice<T> where\n+        F: FnMut(&mut Parser) -> T,\n+    {\n         let v = self.parse_seq_to_before_gt(sep, f);\n         self.expect_gt();\n         return v;\n     }\n \n-    pub fn parse_seq_to_gt_or_return<T>(&mut self,\n-                                        sep: Option<token::Token>,\n-                                        f: |&mut Parser| -> Option<T>)\n-                                        -> (OwnedSlice<T>, bool) {\n+    pub fn parse_seq_to_gt_or_return<T, F>(&mut self,\n+                                           sep: Option<token::Token>,\n+                                           f: F)\n+                                           -> (OwnedSlice<T>, bool) where\n+        F: FnMut(&mut Parser) -> Option<T>,\n+    {\n         let (v, returned) = self.parse_seq_to_before_gt_or_return(sep, f);\n         if !returned {\n             self.expect_gt();\n@@ -834,12 +843,13 @@ impl<'a> Parser<'a> {\n     /// Parse a sequence, including the closing delimiter. The function\n     /// f must consume tokens until reaching the next separator or\n     /// closing bracket.\n-    pub fn parse_seq_to_end<T>(\n-                            &mut self,\n-                            ket: &token::Token,\n-                            sep: SeqSep,\n-                            f: |&mut Parser| -> T)\n-                            -> Vec<T> {\n+    pub fn parse_seq_to_end<T, F>(&mut self,\n+                                  ket: &token::Token,\n+                                  sep: SeqSep,\n+                                  f: F)\n+                                  -> Vec<T> where\n+        F: FnMut(&mut Parser) -> T,\n+    {\n         let val = self.parse_seq_to_before_end(ket, sep, f);\n         self.bump();\n         val\n@@ -848,12 +858,13 @@ impl<'a> Parser<'a> {\n     /// Parse a sequence, not including the closing delimiter. The function\n     /// f must consume tokens until reaching the next separator or\n     /// closing bracket.\n-    pub fn parse_seq_to_before_end<T>(\n-                                   &mut self,\n-                                   ket: &token::Token,\n-                                   sep: SeqSep,\n-                                   f: |&mut Parser| -> T)\n-                                   -> Vec<T> {\n+    pub fn parse_seq_to_before_end<T, F>(&mut self,\n+                                         ket: &token::Token,\n+                                         sep: SeqSep,\n+                                         mut f: F)\n+                                         -> Vec<T> where\n+        F: FnMut(&mut Parser) -> T,\n+    {\n         let mut first: bool = true;\n         let mut v = vec!();\n         while self.token != *ket {\n@@ -873,13 +884,14 @@ impl<'a> Parser<'a> {\n     /// Parse a sequence, including the closing delimiter. The function\n     /// f must consume tokens until reaching the next separator or\n     /// closing bracket.\n-    pub fn parse_unspanned_seq<T>(\n-                               &mut self,\n-                               bra: &token::Token,\n-                               ket: &token::Token,\n-                               sep: SeqSep,\n-                               f: |&mut Parser| -> T)\n-                               -> Vec<T> {\n+    pub fn parse_unspanned_seq<T, F>(&mut self,\n+                                     bra: &token::Token,\n+                                     ket: &token::Token,\n+                                     sep: SeqSep,\n+                                     f: F)\n+                                     -> Vec<T> where\n+        F: FnMut(&mut Parser) -> T,\n+    {\n         self.expect(bra);\n         let result = self.parse_seq_to_before_end(ket, sep, f);\n         self.bump();\n@@ -888,13 +900,14 @@ impl<'a> Parser<'a> {\n \n     /// Parse a sequence parameter of enum variant. For consistency purposes,\n     /// these should not be empty.\n-    pub fn parse_enum_variant_seq<T>(\n-                               &mut self,\n-                               bra: &token::Token,\n-                               ket: &token::Token,\n-                               sep: SeqSep,\n-                               f: |&mut Parser| -> T)\n-                               -> Vec<T> {\n+    pub fn parse_enum_variant_seq<T, F>(&mut self,\n+                                        bra: &token::Token,\n+                                        ket: &token::Token,\n+                                        sep: SeqSep,\n+                                        f: F)\n+                                        -> Vec<T> where\n+        F: FnMut(&mut Parser) -> T,\n+    {\n         let result = self.parse_unspanned_seq(bra, ket, sep, f);\n         if result.is_empty() {\n             let last_span = self.last_span;\n@@ -906,13 +919,14 @@ impl<'a> Parser<'a> {\n \n     // NB: Do not use this function unless you actually plan to place the\n     // spanned list in the AST.\n-    pub fn parse_seq<T>(\n-                     &mut self,\n-                     bra: &token::Token,\n-                     ket: &token::Token,\n-                     sep: SeqSep,\n-                     f: |&mut Parser| -> T)\n-                     -> Spanned<Vec<T> > {\n+    pub fn parse_seq<T, F>(&mut self,\n+                           bra: &token::Token,\n+                           ket: &token::Token,\n+                           sep: SeqSep,\n+                           f: F)\n+                           -> Spanned<Vec<T>> where\n+        F: FnMut(&mut Parser) -> T,\n+    {\n         let lo = self.span.lo;\n         self.expect(bra);\n         let result = self.parse_seq_to_before_end(ket, sep, f);\n@@ -972,8 +986,9 @@ impl<'a> Parser<'a> {\n         }\n         return (4 - self.buffer_start) + self.buffer_end;\n     }\n-    pub fn look_ahead<R>(&mut self, distance: uint, f: |&token::Token| -> R)\n-                      -> R {\n+    pub fn look_ahead<R, F>(&mut self, distance: uint, f: F) -> R where\n+        F: FnOnce(&token::Token) -> R,\n+    {\n         let dist = distance as int;\n         while self.buffer_length() < dist {\n             self.buffer[self.buffer_end as uint] = self.reader.real_token();\n@@ -4285,8 +4300,9 @@ impl<'a> Parser<'a> {\n \n     /// Parse the argument list and result type of a function\n     /// that may have a self type.\n-    fn parse_fn_decl_with_self(&mut self, parse_arg_fn: |&mut Parser| -> Arg)\n-                               -> (ExplicitSelf, P<FnDecl>) {\n+    fn parse_fn_decl_with_self<F>(&mut self, parse_arg_fn: F) -> (ExplicitSelf, P<FnDecl>) where\n+        F: FnMut(&mut Parser) -> Arg,\n+    {\n         fn maybe_parse_borrowed_explicit_self(this: &mut Parser)\n                                               -> ast::ExplicitSelf_ {\n             // The following things are possible to see here:"}, {"sha": "6d8b8dcb8ba5d0e442f07233e50af5e07a9f5b12", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 18, "deletions": 12, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -165,7 +165,9 @@ impl<'a> State<'a> {\n     }\n }\n \n-pub fn to_string(f: |&mut State| -> IoResult<()>) -> String {\n+pub fn to_string<F>(f: F) -> String where\n+    F: FnOnce(&mut State) -> IoResult<()>,\n+{\n     use std::raw::TraitObject;\n     let mut s = rust_printer(box Vec::new());\n     f(&mut s).unwrap();\n@@ -426,8 +428,10 @@ pub mod with_hygiene {\n \n     // This function is the trick that all the rest of the routines\n     // hang on.\n-    pub fn to_string_hyg(f: |&mut super::State| -> IoResult<()>) -> String {\n-        super::to_string(|s| {\n+    pub fn to_string_hyg<F>(f: F) -> String where\n+        F: FnOnce(&mut super::State) -> IoResult<()>,\n+    {\n+        super::to_string(move |s| {\n             s.encode_idents_with_hygiene = true;\n             f(s)\n         })\n@@ -580,9 +584,9 @@ impl<'a> State<'a> {\n         word(&mut self.s, \"*/\")\n     }\n \n-    pub fn commasep<T>(&mut self, b: Breaks, elts: &[T],\n-                       op: |&mut State, &T| -> IoResult<()>)\n-        -> IoResult<()> {\n+    pub fn commasep<T, F>(&mut self, b: Breaks, elts: &[T], mut op: F) -> IoResult<()> where\n+        F: FnMut(&mut State, &T) -> IoResult<()>,\n+    {\n         try!(self.rbox(0u, b));\n         let mut first = true;\n         for elt in elts.iter() {\n@@ -593,12 +597,14 @@ impl<'a> State<'a> {\n     }\n \n \n-    pub fn commasep_cmnt<T>(\n-                         &mut self,\n-                         b: Breaks,\n-                         elts: &[T],\n-                         op: |&mut State, &T| -> IoResult<()>,\n-                         get_span: |&T| -> codemap::Span) -> IoResult<()> {\n+    pub fn commasep_cmnt<T, F, G>(&mut self,\n+                                  b: Breaks,\n+                                  elts: &[T],\n+                                  mut op: F,\n+                                  mut get_span: G) -> IoResult<()> where\n+        F: FnMut(&mut State, &T) -> IoResult<()>,\n+        G: FnMut(&T) -> codemap::Span,\n+    {\n         try!(self.rbox(0u, b));\n         let len = elts.len();\n         let mut i = 0u;"}, {"sha": "1b3ebde2461e693fe47d1a1a93ec8798f08e952e", "filename": "src/libsyntax/ptr.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibsyntax%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibsyntax%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fptr.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -56,12 +56,16 @@ pub fn P<T: 'static>(value: T) -> P<T> {\n impl<T: 'static> P<T> {\n     /// Move out of the pointer.\n     /// Intended for chaining transformations not covered by `map`.\n-    pub fn and_then<U>(self, f: |T| -> U) -> U {\n+    pub fn and_then<U, F>(self, f: F) -> U where\n+        F: FnOnce(T) -> U,\n+    {\n         f(*self.ptr)\n     }\n \n     /// Transform the inner value, consuming `self` and producing a new `P<T>`.\n-    pub fn map(mut self, f: |T| -> T) -> P<T> {\n+    pub fn map<F>(mut self, f: F) -> P<T> where\n+        F: FnOnce(T) -> T,\n+    {\n         unsafe {\n             let p = &mut *self.ptr;\n             // FIXME(#5016) this shouldn't need to zero to be safe."}, {"sha": "83bbff8473d046121b1486aa20c083bbb75b0524", "filename": "src/libsyntax/util/parser_testing.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibsyntax%2Futil%2Fparser_testing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibsyntax%2Futil%2Fparser_testing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fparser_testing.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -31,7 +31,9 @@ pub fn string_to_parser<'a>(ps: &'a ParseSess, source_str: String) -> Parser<'a>\n                                source_str)\n }\n \n-fn with_error_checking_parse<T>(s: String, f: |&mut Parser| -> T) -> T {\n+fn with_error_checking_parse<T, F>(s: String, f: F) -> T where\n+    F: FnOnce(&mut Parser) -> T,\n+{\n     let ps = new_parse_sess();\n     let mut p = string_to_parser(&ps, s);\n     let x = f(&mut p);"}, {"sha": "8d050e34abf4c846431f9e592440b95bd6ce2060", "filename": "src/libsyntax/util/small_vector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibsyntax%2Futil%2Fsmall_vector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibsyntax%2Futil%2Fsmall_vector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fsmall_vector.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -171,7 +171,7 @@ impl<T> Iterator<T> for MoveItems<T> {\n }\n \n impl<T> MoveMap<T> for SmallVector<T> {\n-    fn move_map(self, f: |T| -> T) -> SmallVector<T> {\n+    fn move_map<F>(self, mut f: F) -> SmallVector<T> where F: FnMut(T) -> T {\n         let repr = match self.repr {\n             Zero => Zero,\n             One(v) => One(f(v)),"}, {"sha": "7436a8af30765d17ad1d47132cb9ab566a72608d", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -32,6 +32,7 @@\n        html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n \n #![feature(asm, macro_rules, phase, globs, slicing_syntax)]\n+#![feature(unboxed_closures)]\n \n extern crate getopts;\n extern crate regex;\n@@ -978,9 +979,11 @@ enum TestEvent {\n \n pub type MonitorMsg = (TestDesc, TestResult, Vec<u8> );\n \n-fn run_tests(opts: &TestOpts,\n-             tests: Vec<TestDescAndFn> ,\n-             callback: |e: TestEvent| -> io::IoResult<()>) -> io::IoResult<()> {\n+fn run_tests<F>(opts: &TestOpts,\n+                tests: Vec<TestDescAndFn> ,\n+                mut callback: F) -> io::IoResult<()> where\n+    F: FnMut(TestEvent) -> io::IoResult<()>,\n+{\n     let filtered_tests = filter_tests(opts, tests);\n     let filtered_descs = filtered_tests.iter()\n                                        .map(|t| t.desc.clone())\n@@ -1339,7 +1342,7 @@ pub fn black_box<T>(dummy: T) {\n \n impl Bencher {\n     /// Callback for benchmark functions to run in their body.\n-    pub fn iter<T>(&mut self, inner: || -> T) {\n+    pub fn iter<T, F>(&mut self, mut inner: F) where F: FnMut() -> T {\n         self.dur = Duration::span(|| {\n             let k = self.iterations;\n             for _ in range(0u64, k) {\n@@ -1360,14 +1363,13 @@ impl Bencher {\n         }\n     }\n \n-    pub fn bench_n(&mut self, n: u64, f: |&mut Bencher|) {\n+    pub fn bench_n<F>(&mut self, n: u64, f: F) where F: FnOnce(&mut Bencher) {\n         self.iterations = n;\n         f(self);\n     }\n \n     // This is a more statistics-driven benchmark algorithm\n-    pub fn auto_bench(&mut self, f: |&mut Bencher|) -> stats::Summary<f64> {\n-\n+    pub fn auto_bench<F>(&mut self, mut f: F) -> stats::Summary<f64> where F: FnMut(&mut Bencher) {\n         // Initial bench run to get ballpark figure.\n         let mut n = 1_u64;\n         self.bench_n(n, |x| f(x));\n@@ -1437,7 +1439,7 @@ pub mod bench {\n     use std::time::Duration;\n     use super::{Bencher, BenchSamples};\n \n-    pub fn benchmark(f: |&mut Bencher|) -> BenchSamples {\n+    pub fn benchmark<F>(f: F) -> BenchSamples where F: FnMut(&mut Bencher) {\n         let mut bs = Bencher {\n             iterations: 0,\n             dur: Duration::nanoseconds(0),"}, {"sha": "1f75daa7bdecdd4c97326a25f7b6001adfe033ab", "filename": "src/libunicode/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibunicode%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibunicode%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunicode%2Flib.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -29,6 +29,7 @@\n        html_playground_url = \"http://play.rust-lang.org/\")]\n #![no_std]\n #![feature(globs)]\n+#![feature(unboxed_closures)]\n \n extern crate core;\n "}, {"sha": "80311137b0165ed69bf1138cc7a094a71882beba", "filename": "src/libunicode/u_str.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibunicode%2Fu_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Flibunicode%2Fu_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunicode%2Fu_str.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -29,8 +29,7 @@ use tables::grapheme::GraphemeCat;\n \n /// An iterator over the words of a string, separated by a sequence of whitespace\n /// FIXME: This should be opaque\n-pub type Words<'a> =\n-    Filter<'a, &'a str, CharSplits<'a, |char|:'a -> bool>>;\n+pub type Words<'a> = Filter<&'a str, CharSplits<'a, fn(char) -> bool>, fn(&&str) -> bool>;\n \n /// Methods for Unicode string slices\n pub trait UnicodeStrPrelude for Sized? {\n@@ -143,8 +142,10 @@ impl UnicodeStrPrelude for str {\n \n     #[inline]\n     fn words(&self) -> Words {\n-        let f = |c: char| c.is_whitespace();\n-        self.split(f).filter(|s| !s.is_empty())\n+        fn is_not_empty(s: &&str) -> bool { !s.is_empty() }\n+        fn is_whitespace(c: char) -> bool { c.is_whitespace() }\n+\n+        self.split(is_whitespace).filter(is_not_empty)\n     }\n \n     #[inline]\n@@ -165,12 +166,12 @@ impl UnicodeStrPrelude for str {\n \n     #[inline]\n     fn trim_left(&self) -> &str {\n-        self.trim_left_chars(|c: char| c.is_whitespace())\n+        self.trim_left_chars(|&: c: char| c.is_whitespace())\n     }\n \n     #[inline]\n     fn trim_right(&self) -> &str {\n-        self.trim_right_chars(|c: char| c.is_whitespace())\n+        self.trim_right_chars(|&: c: char| c.is_whitespace())\n     }\n }\n "}, {"sha": "112d4fd0912d4e3e2aa1f8b478d270e6a05e6fe9", "filename": "src/test/bench/core-map.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Ftest%2Fbench%2Fcore-map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Ftest%2Fbench%2Fcore-map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-map.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -8,13 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![feature(unboxed_closures)]\n+\n use std::collections::{TrieMap, TreeMap, HashMap, HashSet};\n use std::os;\n use std::rand::{Rng, IsaacRng, SeedableRng};\n use std::time::Duration;\n use std::uint;\n \n-fn timed(label: &str, f: ||) {\n+fn timed<F>(label: &str, f: F) where F: FnMut() {\n     println!(\"  {}: {}\", label, Duration::span(f));\n }\n "}, {"sha": "6ba642cc47b7563d809dbc07a543474183d2b33b", "filename": "src/test/bench/core-set.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Ftest%2Fbench%2Fcore-set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Ftest%2Fbench%2Fcore-set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-set.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -10,6 +10,8 @@\n \n // ignore-pretty very bad with line comments\n \n+#![feature(unboxed_closures)]\n+\n extern crate collections;\n extern crate rand;\n \n@@ -31,7 +33,7 @@ struct Results {\n     delete_strings: Duration,\n }\n \n-fn timed(result: &mut Duration, op: ||) {\n+fn timed<F>(result: &mut Duration, op: F) where F: FnOnce() {\n     *result = Duration::span(op);\n }\n "}, {"sha": "6e2cd508291e0305f25c3c53fafbd89ac3650ac7", "filename": "src/test/bench/core-std.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Ftest%2Fbench%2Fcore-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Ftest%2Fbench%2Fcore-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-std.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -12,6 +12,7 @@\n // Microbenchmarks for various functions in std and extra\n \n #![feature(macro_rules)]\n+#![feature(unboxed_closures)]\n \n use std::io::File;\n use std::mem::swap;\n@@ -41,7 +42,7 @@ fn main() {\n     bench!(is_utf8_multibyte);\n }\n \n-fn maybe_run_test(argv: &[String], name: String, test: ||) {\n+fn maybe_run_test<F>(argv: &[String], name: String, test: F) where F: FnOnce() {\n     let mut run_test = false;\n \n     if os::getenv(\"RUST_BENCH\").is_some() {"}, {"sha": "fe7635f065cdc5ee969fe64c792b991de8fe45a6", "filename": "src/test/compile-fail/coerce-unsafe-to-closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Ftest%2Fcompile-fail%2Fcoerce-unsafe-to-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Ftest%2Fcompile-fail%2Fcoerce-unsafe-to-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoerce-unsafe-to-closure.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -10,5 +10,5 @@\n \n fn main() {\n     let x: Option<&[u8]> = Some(\"foo\").map(std::mem::transmute);\n-    //~^ ERROR: mismatched types\n+    //~^ ERROR: is not implemented for the type\n }"}, {"sha": "f623b7911ce6d3c49673629ae9ed6c23a9f70892", "filename": "src/test/run-pass/assignability-trait.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Ftest%2Frun-pass%2Fassignability-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Ftest%2Frun-pass%2Fassignability-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassignability-trait.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -12,19 +12,20 @@\n // making method calls, but only if there aren't any matches without\n // it.\n \n+#![feature(unboxed_closures)]\n \n trait iterable<A> {\n-    fn iterate(&self, blk: |x: &A| -> bool) -> bool;\n+    fn iterate<F>(&self, blk: F) -> bool where F: FnMut(&A) -> bool;\n }\n \n impl<'a,A> iterable<A> for &'a [A] {\n-    fn iterate(&self, f: |x: &A| -> bool) -> bool {\n+    fn iterate<F>(&self, f: F) -> bool where F: FnMut(&A) -> bool {\n         self.iter().all(f)\n     }\n }\n \n impl<A> iterable<A> for Vec<A> {\n-    fn iterate(&self, f: |x: &A| -> bool) -> bool {\n+    fn iterate<F>(&self, f: F) -> bool where F: FnMut(&A) -> bool {\n         self.iter().all(f)\n     }\n }"}, {"sha": "da5fa19f816f753771008632a3794a3ae882bf6e", "filename": "src/test/run-pass/backtrace.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Ftest%2Frun-pass%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444fa1b7cffcd99ca5b8abb51acf979f06a25899/src%2Ftest%2Frun-pass%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbacktrace.rs?ref=444fa1b7cffcd99ca5b8abb51acf979f06a25899", "patch": "@@ -10,6 +10,9 @@\n \n // no-pretty-expanded FIXME #15189\n // ignore-windows FIXME #13259\n+\n+#![feature(unboxed_closures)]\n+\n use std::os;\n use std::io::process::Command;\n use std::finally::Finally;\n@@ -25,7 +28,7 @@ fn foo() {\n \n #[inline(never)]\n fn double() {\n-    (|| {\n+    (|&mut:| {\n         panic!(\"once\");\n     }).finally(|| {\n         panic!(\"twice\");"}]}