{"sha": "7d7bd9b6c24a89ebafd4400a710a868fb3e70242", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdkN2JkOWI2YzI0YTg5ZWJhZmQ0NDAwYTcxMGE4NjhmYjNlNzAyNDI=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-10-31T17:44:00Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-11-05T08:17:48Z"}, "message": "reduce the amount of traversal/projection code that the visitor has to implement itself", "tree": {"sha": "2d9f76095690b54b90872c4acce0711eef0e2dc4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2d9f76095690b54b90872c4acce0711eef0e2dc4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7d7bd9b6c24a89ebafd4400a710a868fb3e70242", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7d7bd9b6c24a89ebafd4400a710a868fb3e70242", "html_url": "https://github.com/rust-lang/rust/commit/7d7bd9b6c24a89ebafd4400a710a868fb3e70242", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7d7bd9b6c24a89ebafd4400a710a868fb3e70242/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5b5e076b473eb31736381f3c2cd73a169a66cbf5", "url": "https://api.github.com/repos/rust-lang/rust/commits/5b5e076b473eb31736381f3c2cd73a169a66cbf5", "html_url": "https://github.com/rust-lang/rust/commit/5b5e076b473eb31736381f3c2cd73a169a66cbf5"}], "stats": {"total": 397, "additions": 237, "deletions": 160}, "files": [{"sha": "7caf81788dd2314783e45276731423915b5319ff", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 118, "deletions": 131, "changes": 249, "blob_url": "https://github.com/rust-lang/rust/blob/7d7bd9b6c24a89ebafd4400a710a868fb3e70242/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d7bd9b6c24a89ebafd4400a710a868fb3e70242/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=7d7bd9b6c24a89ebafd4400a710a868fb3e70242", "patch": "@@ -78,6 +78,7 @@ pub enum PathElem {\n     TupleElem(usize),\n     Deref,\n     Tag,\n+    DynDowncast,\n }\n \n /// State for tracking recursive validation of references\n@@ -97,75 +98,30 @@ impl<'tcx, Tag: Copy+Eq+Hash> RefTracking<'tcx, Tag> {\n     }\n }\n \n-// Adding a Deref and making a copy of the path to be put into the queue\n-// always go together.  This one does it with only new allocation.\n-fn path_clone_and_deref(path: &Vec<PathElem>) -> Vec<PathElem> {\n-    let mut new_path = Vec::with_capacity(path.len()+1);\n-    new_path.clone_from(path);\n-    new_path.push(PathElem::Deref);\n-    new_path\n-}\n-\n /// Format a path\n fn path_format(path: &Vec<PathElem>) -> String {\n     use self::PathElem::*;\n \n     let mut out = String::new();\n     for elem in path.iter() {\n         match elem {\n-            Field(name) => write!(out, \".{}\", name).unwrap(),\n-            ClosureVar(name) => write!(out, \".<closure-var({})>\", name).unwrap(),\n-            TupleElem(idx) => write!(out, \".{}\", idx).unwrap(),\n-            ArrayElem(idx) => write!(out, \"[{}]\", idx).unwrap(),\n+            Field(name) => write!(out, \".{}\", name),\n+            ClosureVar(name) => write!(out, \".<closure-var({})>\", name),\n+            TupleElem(idx) => write!(out, \".{}\", idx),\n+            ArrayElem(idx) => write!(out, \"[{}]\", idx),\n             Deref =>\n                 // This does not match Rust syntax, but it is more readable for long paths -- and\n                 // some of the other items here also are not Rust syntax.  Actually we can't\n                 // even use the usual syntax because we are just showing the projections,\n                 // not the root.\n-                write!(out, \".<deref>\").unwrap(),\n-            Tag => write!(out, \".<enum-tag>\").unwrap(),\n-        }\n+                write!(out, \".<deref>\"),\n+            Tag => write!(out, \".<enum-tag>\"),\n+            DynDowncast => write!(out, \".<dyn-downcast>\"),\n+        }.unwrap()\n     }\n     out\n }\n \n-fn aggregate_field_path_elem<'a, 'tcx>(\n-    layout: TyLayout<'tcx>,\n-    field: usize,\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-) -> PathElem {\n-    match layout.ty.sty {\n-        // generators and closures.\n-        ty::Closure(def_id, _) | ty::Generator(def_id, _, _) => {\n-            if let Some(upvar) = tcx.optimized_mir(def_id).upvar_decls.get(field) {\n-                PathElem::ClosureVar(upvar.debug_name)\n-            } else {\n-                // Sometimes the index is beyond the number of freevars (seen\n-                // for a generator).\n-                PathElem::ClosureVar(Symbol::intern(&field.to_string()))\n-            }\n-        }\n-\n-        // tuples\n-        ty::Tuple(_) => PathElem::TupleElem(field),\n-\n-        // enums\n-        ty::Adt(def, ..) if def.is_enum() => {\n-            let variant = match layout.variants {\n-                layout::Variants::Single { index } => &def.variants[index],\n-                _ => bug!(\"aggregate_field_path_elem: got enum but not in a specific variant\"),\n-            };\n-            PathElem::Field(variant.fields[field].ident.name)\n-        }\n-\n-        // other ADTs\n-        ty::Adt(def, _) => PathElem::Field(def.non_enum_variant().fields[field].ident.name),\n-\n-        // nothing else has an aggregate layout\n-        _ => bug!(\"aggregate_field_path_elem: got non-aggregate type {:?}\", layout.ty),\n-    }\n-}\n-\n fn scalar_format<Tag>(value: ScalarMaybeUndef<Tag>) -> String {\n     match value {\n         ScalarMaybeUndef::Undef =>\n@@ -177,28 +133,97 @@ fn scalar_format<Tag>(value: ScalarMaybeUndef<Tag>) -> String {\n     }\n }\n \n-struct ValidityVisitor<'rt, 'tcx, Tag> {\n+struct ValidityVisitor<'rt, 'a, 'tcx, Tag> {\n     op: OpTy<'tcx, Tag>,\n     /// The `path` may be pushed to, but the part that is present when a function\n     /// starts must not be changed!  `visit_fields` and `visit_array` rely on\n     /// this stack discipline.\n     path: Vec<PathElem>,\n     ref_tracking: Option<&'rt mut RefTracking<'tcx, Tag>>,\n     const_mode: bool,\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n }\n \n-impl<Tag: fmt::Debug> fmt::Debug for ValidityVisitor<'_, '_, Tag> {\n+impl<Tag: fmt::Debug> fmt::Debug for ValidityVisitor<'_, '_, '_, Tag> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"{:?} ({:?})\", *self.op, self.op.layout.ty)\n+        write!(f, \"{:?}, {:?}\", *self.op, self.op.layout.ty)\n+    }\n+}\n+\n+impl<'rt, 'a, 'tcx, Tag> ValidityVisitor<'rt, 'a, 'tcx, Tag> {\n+    fn push_aggregate_field_path_elem(\n+        &mut self,\n+        layout: TyLayout<'tcx>,\n+        field: usize,\n+    ) {\n+        let elem = match layout.ty.sty {\n+            // generators and closures.\n+            ty::Closure(def_id, _) | ty::Generator(def_id, _, _) => {\n+                if let Some(upvar) = self.tcx.optimized_mir(def_id).upvar_decls.get(field) {\n+                    PathElem::ClosureVar(upvar.debug_name)\n+                } else {\n+                    // Sometimes the index is beyond the number of freevars (seen\n+                    // for a generator).\n+                    PathElem::ClosureVar(Symbol::intern(&field.to_string()))\n+                }\n+            }\n+\n+            // tuples\n+            ty::Tuple(_) => PathElem::TupleElem(field),\n+\n+            // enums\n+            ty::Adt(def, ..) if def.is_enum() => {\n+                let variant = match layout.variants {\n+                    layout::Variants::Single { index } => &def.variants[index],\n+                    _ => bug!(\"aggregate_field_path_elem: got enum but not in a specific variant\"),\n+                };\n+                PathElem::Field(variant.fields[field].ident.name)\n+            }\n+\n+            // other ADTs\n+            ty::Adt(def, _) => PathElem::Field(def.non_enum_variant().fields[field].ident.name),\n+\n+            // arrays/slices\n+            ty::Array(..) | ty::Slice(..) => PathElem::ArrayElem(field),\n+\n+            // dyn traits\n+            ty::Dynamic(..) => PathElem::DynDowncast,\n+\n+            // nothing else has an aggregate layout\n+            _ => bug!(\"aggregate_field_path_elem: got non-aggregate type {:?}\", layout.ty),\n+        };\n+        self.path.push(elem);\n     }\n }\n \n impl<'rt, 'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>>\n-    ValueVisitor<'a, 'mir, 'tcx, M> for ValidityVisitor<'rt, 'tcx, M::PointerTag>\n+    ValueVisitor<'a, 'mir, 'tcx, M> for ValidityVisitor<'rt, 'a, 'tcx, M::PointerTag>\n {\n+    type V = OpTy<'tcx, M::PointerTag>;\n+\n     #[inline(always)]\n-    fn layout(&self) -> TyLayout<'tcx> {\n-        self.op.layout\n+    fn value(&self) -> &OpTy<'tcx, M::PointerTag> {\n+        &self.op\n+    }\n+\n+    #[inline]\n+    fn with_field(\n+        &mut self,\n+        val: Self::V,\n+        field: usize,\n+        f: impl FnOnce(&mut Self) -> EvalResult<'tcx>,\n+    ) -> EvalResult<'tcx> {\n+        // Remember the old state\n+        let path_len = self.path.len();\n+        let op = self.op;\n+        // Perform operation\n+        self.push_aggregate_field_path_elem(op.layout, field);\n+        self.op = val;\n+        f(self)?;\n+        // Undo changes\n+        self.path.truncate(path_len);\n+        self.op = op;\n+        Ok(())\n     }\n \n     fn downcast_enum(&mut self, ectx: &EvalContext<'a, 'mir, 'tcx, M>)\n@@ -227,15 +252,6 @@ impl<'rt, 'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>>\n         Ok(())\n     }\n \n-    fn downcast_dyn_trait(&mut self, ectx: &EvalContext<'a, 'mir, 'tcx, M>)\n-        -> EvalResult<'tcx>\n-    {\n-        // FIXME: Should we reflect this in `self.path`?\n-        let dest = self.op.to_mem_place(); // immediate trait objects are not a thing\n-        self.op = ectx.unpack_dyn_trait(dest)?.1.into();\n-        Ok(())\n-    }\n-\n     fn visit_primitive(&mut self, ectx: &mut EvalContext<'a, 'mir, 'tcx, M>)\n         -> EvalResult<'tcx>\n     {\n@@ -365,7 +381,13 @@ impl<'rt, 'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>>\n                     let op = place.into();\n                     if ref_tracking.seen.insert(op) {\n                         trace!(\"Recursing below ptr {:#?}\", *op);\n-                        ref_tracking.todo.push((op, path_clone_and_deref(&self.path)));\n+                        // We need to clone the path anyway, make sure it gets created\n+                        // with enough space for the additional `Deref`.\n+                        let mut new_path = Vec::with_capacity(self.path.len()+1);\n+                        new_path.clone_from(&self.path);\n+                        new_path.push(PathElem::Deref);\n+                        // Remember to come back to this later.\n+                        ref_tracking.todo.push((op, new_path));\n                     }\n                 }\n             }\n@@ -378,12 +400,17 @@ impl<'rt, 'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>>\n                 // FIXME: Check if the signature matches\n             }\n             // This should be all the primitive types\n-            ty::Never => bug!(\"Uninhabited type should have been caught earlier\"),\n             _ => bug!(\"Unexpected primitive type {}\", value.layout.ty)\n         }\n         Ok(())\n     }\n \n+    fn visit_uninhabited(&mut self, _ectx: &mut EvalContext<'a, 'mir, 'tcx, M>)\n+        -> EvalResult<'tcx>\n+    {\n+        validation_failure!(\"a value of an uninhabited type\", self.path)\n+    }\n+\n     fn visit_scalar(&mut self, ectx: &mut EvalContext<'a, 'mir, 'tcx, M>, layout: &layout::Scalar)\n         -> EvalResult<'tcx>\n     {\n@@ -468,47 +495,16 @@ impl<'rt, 'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>>\n         }\n     }\n \n-    fn visit_fields(&mut self, ectx: &mut EvalContext<'a, 'mir, 'tcx, M>, num_fields: usize)\n-        -> EvalResult<'tcx>\n-    {\n-        // Remember some stuff that will change for the recursive calls\n-        let op = self.op;\n-        let path_len = self.path.len();\n-        // Go look at all the fields\n-        for i in 0..num_fields {\n-            // Adapt our state\n-            self.op = ectx.operand_field(op, i as u64)?;\n-            self.path.push(aggregate_field_path_elem(op.layout, i, *ectx.tcx));\n-            // Recursive visit\n-            ectx.visit_value(self)?;\n-            // Restore original state\n-            self.op = op;\n-            self.path.truncate(path_len);\n-        }\n-        Ok(())\n-    }\n-\n-    fn visit_str(&mut self, ectx: &mut EvalContext<'a, 'mir, 'tcx, M>)\n-        -> EvalResult<'tcx>\n-    {\n-        let mplace = self.op.to_mem_place(); // strings are never immediate\n-        try_validation!(ectx.read_str(mplace),\n-            \"uninitialized or non-UTF-8 data in str\", self.path);\n-        Ok(())\n-    }\n-\n-    fn visit_array(&mut self, ectx: &mut EvalContext<'a, 'mir, 'tcx, M>) -> EvalResult<'tcx>\n+    fn handle_array(&mut self, ectx: &EvalContext<'a, 'mir, 'tcx, M>)\n+        -> EvalResult<'tcx, bool>\n     {\n-        let mplace = if self.op.layout.is_zst() {\n-            // it's a ZST, the memory content cannot matter\n-            MPlaceTy::dangling(self.op.layout, ectx)\n-        } else {\n-            // non-ZST array/slice/str cannot be immediate\n-            self.op.to_mem_place()\n-        };\n-        match self.op.layout.ty.sty {\n-            ty::Str => bug!(\"Strings should be handled separately\"),\n-            // Special handling for arrays/slices of builtin integer types\n+        Ok(match self.op.layout.ty.sty {\n+            ty::Str => {\n+                let mplace = self.op.to_mem_place(); // strings are never immediate\n+                try_validation!(ectx.read_str(mplace),\n+                    \"uninitialized or non-UTF-8 data in str\", self.path);\n+                true\n+            }\n             ty::Array(tys, ..) | ty::Slice(tys) if {\n                 // This optimization applies only for integer and floating point types\n                 // (i.e., types that can hold arbitrary bytes).\n@@ -517,6 +513,13 @@ impl<'rt, 'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>>\n                     _ => false,\n                 }\n             } => {\n+                let mplace = if self.op.layout.is_zst() {\n+                    // it's a ZST, the memory content cannot matter\n+                    MPlaceTy::dangling(self.op.layout, ectx)\n+                } else {\n+                    // non-ZST array/slice/str cannot be immediate\n+                    self.op.to_mem_place()\n+                };\n                 // This is the length of the array/slice.\n                 let len = mplace.len(ectx)?;\n                 // This is the element type size.\n@@ -539,7 +542,7 @@ impl<'rt, 'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>>\n                     /*allow_ptr_and_undef*/!self.const_mode,\n                 ) {\n                     // In the happy case, we needn't check anything else.\n-                    Ok(()) => {},\n+                    Ok(()) => true, // handled these arrays\n                     // Some error happened, try to provide a more detailed description.\n                     Err(err) => {\n                         // For some errors we might be able to provide extra information\n@@ -560,26 +563,9 @@ impl<'rt, 'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>>\n                         }\n                     }\n                 }\n-            },\n-            _ => {\n-                // Remember some stuff that will change for the recursive calls\n-                let op = self.op;\n-                let path_len = self.path.len();\n-                // This handles the unsized case correctly as well, as well as\n-                // SIMD and all sorts of other array-like types.\n-                for (i, field) in ectx.mplace_array_fields(mplace)?.enumerate() {\n-                    // Adapt our state\n-                    self.op = field?.into();\n-                    self.path.push(PathElem::ArrayElem(i));\n-                    // Recursive visit\n-                    ectx.visit_value(self)?;\n-                    // Restore original state\n-                    self.op = op;\n-                    self.path.truncate(path_len);\n-                }\n             }\n-        }\n-        Ok(())\n+            _ => false, // not handled\n+        })\n     }\n }\n \n@@ -605,7 +591,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n             op,\n             path,\n             ref_tracking,\n-            const_mode\n+            const_mode,\n+            tcx: *self.tcx,\n         };\n \n         // Run it"}, {"sha": "7d6029d6424f718c68febbf520c72ec0e80c62aa", "filename": "src/librustc_mir/interpret/visitor.rs", "status": "modified", "additions": 117, "deletions": 27, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/7d7bd9b6c24a89ebafd4400a710a868fb3e70242/src%2Flibrustc_mir%2Finterpret%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d7bd9b6c24a89ebafd4400a710a868fb3e70242/src%2Flibrustc_mir%2Finterpret%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvisitor.rs?ref=7d7bd9b6c24a89ebafd4400a710a868fb3e70242", "patch": "@@ -10,42 +10,114 @@ use rustc::mir::interpret::{\n };\n \n use super::{\n-    Machine, EvalContext,\n+    Machine, EvalContext, MPlaceTy, OpTy,\n };\n \n-// How to traverse a value and what to do when we are at the leaves.\n-// In the future, we might want to turn this into two traits, but so far the\n-// only implementations we have couldn't share any code anyway.\n-pub trait ValueVisitor<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>>: fmt::Debug {\n+// A thing that we can project into, and that has a layout.\n+// This wouldn't have to depend on `Machine` but with the current type inference,\n+// that's just more convenient to work with (avoids repeading all the `Machine` bounds).\n+pub trait Value<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>>: Copy\n+{\n     // Get this value's layout.\n     fn layout(&self) -> TyLayout<'tcx>;\n \n-    // Downcast functions.  These change the value as a side-effect.\n+    // Get the underlying `MPlaceTy`, or panic if there is no such thing.\n+    fn to_mem_place(self) -> MPlaceTy<'tcx, M::PointerTag>;\n+\n+    // Create this from an `MPlaceTy`\n+    fn from_mem_place(MPlaceTy<'tcx, M::PointerTag>) -> Self;\n+\n+    // Project to the n-th field\n+    fn project_field(\n+        self,\n+        ectx: &mut EvalContext<'a, 'mir, 'tcx, M>,\n+        field: u64,\n+    ) -> EvalResult<'tcx, Self>;\n+}\n+\n+// Operands and places are both values\n+impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Value<'a, 'mir, 'tcx, M>\n+    for OpTy<'tcx, M::PointerTag>\n+{\n+    #[inline(always)]\n+    fn layout(&self) -> TyLayout<'tcx> {\n+        self.layout\n+    }\n+\n+    #[inline(always)]\n+    fn to_mem_place(self) -> MPlaceTy<'tcx, M::PointerTag> {\n+        self.to_mem_place()\n+    }\n+\n+    #[inline(always)]\n+    fn from_mem_place(mplace: MPlaceTy<'tcx, M::PointerTag>) -> Self {\n+        mplace.into()\n+    }\n+\n+    #[inline(always)]\n+    fn project_field(\n+        self,\n+        ectx: &mut EvalContext<'a, 'mir, 'tcx, M>,\n+        field: u64,\n+    ) -> EvalResult<'tcx, Self> {\n+        ectx.operand_field(self, field)\n+    }\n+}\n+\n+// How to traverse a value and what to do when we are at the leaves.\n+pub trait ValueVisitor<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>>: fmt::Debug {\n+    type V: Value<'a, 'mir, 'tcx, M>;\n+\n+    // There's a value in here.\n+    fn value(&self) -> &Self::V;\n+\n+    // The value's layout (not meant to be overwritten).\n+    #[inline(always)]\n+    fn layout(&self) -> TyLayout<'tcx> {\n+        self.value().layout()\n+    }\n+\n+    // Replace the value by `val`, which must be the `field`th field of `self`,\n+    // then call `f` and then un-do everything that might have happened to the visitor state.\n+    // The point of this is that some visitors keep a stack of fields that we projected below,\n+    // and this lets us avoid copying that stack; instead they will pop the stack after\n+    // executing `f`.\n+    fn with_field(\n+        &mut self,\n+        val: Self::V,\n+        field: usize,\n+        f: impl FnOnce(&mut Self) -> EvalResult<'tcx>,\n+    ) -> EvalResult<'tcx>;\n+\n+    // This is an enum, downcast it to whatever the current variant is.\n+    // (We do this here and not in `Value` to keep error handling\n+    // under control of th visitor.)\n     fn downcast_enum(&mut self, ectx: &EvalContext<'a, 'mir, 'tcx, M>)\n         -> EvalResult<'tcx>;\n-    fn downcast_dyn_trait(&mut self, ectx: &EvalContext<'a, 'mir, 'tcx, M>)\n-        -> EvalResult<'tcx>;\n \n-    // Visit all fields of a compound.\n-    // Just call `visit_value` if you want to go on recursively.\n-    fn visit_fields(&mut self, ectx: &mut EvalContext<'a, 'mir, 'tcx, M>, num_fields: usize)\n-        -> EvalResult<'tcx>;\n-    // Optimized handling for arrays -- avoid computing the layout for every field.\n-    // Also it is the value's responsibility to figure out the length.\n-    fn visit_array(&mut self, ectx: &mut EvalContext<'a, 'mir, 'tcx, M>) -> EvalResult<'tcx>;\n-    // Special handling for strings.\n-    fn visit_str(&mut self, ectx: &mut EvalContext<'a, 'mir, 'tcx, M>)\n-        -> EvalResult<'tcx>;\n+    // A chance for the visitor to do special (different or more efficient) handling for some\n+    // array types.  Return `true` if the value was handled and we should return.\n+    #[inline]\n+    fn handle_array(&mut self, _ectx: &EvalContext<'a, 'mir, 'tcx, M>)\n+        -> EvalResult<'tcx, bool>\n+    {\n+        Ok(false)\n+    }\n \n     // Actions on the leaves.\n+    fn visit_uninhabited(&mut self, ectx: &mut EvalContext<'a, 'mir, 'tcx, M>)\n+        -> EvalResult<'tcx>;\n     fn visit_scalar(&mut self, ectx: &mut EvalContext<'a, 'mir, 'tcx, M>, layout: &layout::Scalar)\n         -> EvalResult<'tcx>;\n     fn visit_primitive(&mut self, ectx: &mut EvalContext<'a, 'mir, 'tcx, M>)\n         -> EvalResult<'tcx>;\n }\n \n impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n-    pub fn visit_value<V: ValueVisitor<'a, 'mir, 'tcx, M>>(&mut self, v: &mut V) -> EvalResult<'tcx> {\n+    pub fn visit_value<V: ValueVisitor<'a, 'mir, 'tcx, M>>(\n+        &mut self,\n+        v: &mut V,\n+    ) -> EvalResult<'tcx> {\n         trace!(\"visit_value: {:?}\", v);\n \n         // If this is a multi-variant layout, we have find the right one and proceed with that.\n@@ -63,7 +135,10 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n         // If it is a trait object, switch to the actual type that was used to create it.\n         match v.layout().ty.sty {\n             ty::Dynamic(..) => {\n-                v.downcast_dyn_trait(self)?;\n+                let dest = v.value().to_mem_place(); // immediate trait objects are not a thing\n+                let inner = self.unpack_dyn_trait(dest)?.1;\n+                // recurse with the inner type\n+                return v.with_field(Value::from_mem_place(inner), 0, |v| self.visit_value(v));\n             },\n             _ => {},\n         };\n@@ -76,6 +151,9 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n         // scalars, we do the same check on every \"level\" (e.g. first we check\n         // MyNewtype and then the scalar in there).\n         match v.layout().abi {\n+            layout::Abi::Uninhabited => {\n+                v.visit_uninhabited(self)?;\n+            }\n             layout::Abi::Scalar(ref layout) => {\n                 v.visit_scalar(self, layout)?;\n             }\n@@ -107,19 +185,31 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n                 // We can't traverse unions, their bits are allowed to be anything.\n                 // The fields don't need to correspond to any bit pattern of the union's fields.\n                 // See https://github.com/rust-lang/rust/issues/32836#issuecomment-406875389\n-                Ok(())\n             },\n             layout::FieldPlacement::Arbitrary { ref offsets, .. } => {\n-                v.visit_fields(self, offsets.len())\n+                for i in 0..offsets.len() {\n+                    let val = v.value().project_field(self, i as u64)?;\n+                    v.with_field(val, i, |v| self.visit_value(v))?;\n+                }\n             },\n             layout::FieldPlacement::Array { .. } => {\n-                match v.layout().ty.sty {\n-                    // Strings have properties that cannot be expressed pointwise.\n-                    ty::Str => v.visit_str(self),\n-                    // General case -- might also be SIMD vector or so\n-                    _ => v.visit_array(self),\n+                if !v.handle_array(self)? {\n+                    // We still have to work!\n+                    // Let's get an mplace first.\n+                    let mplace = if v.layout().is_zst() {\n+                        // it's a ZST, the memory content cannot matter\n+                        MPlaceTy::dangling(v.layout(), self)\n+                    } else {\n+                        // non-ZST array/slice/str cannot be immediate\n+                        v.value().to_mem_place()\n+                    };\n+                    // Now iterate over it.\n+                    for (i, field) in self.mplace_array_fields(mplace)?.enumerate() {\n+                        v.with_field(Value::from_mem_place(field?), i, |v| self.visit_value(v))?;\n+                    }\n                 }\n             }\n         }\n+        Ok(())\n     }\n }"}, {"sha": "947af20b8891fd64e20127b2d5f4b219a8eae2b1", "filename": "src/test/ui/consts/const-eval/ub-upvars.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d7bd9b6c24a89ebafd4400a710a868fb3e70242/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-upvars.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7d7bd9b6c24a89ebafd4400a710a868fb3e70242/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-upvars.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-upvars.stderr?ref=7d7bd9b6c24a89ebafd4400a710a868fb3e70242", "patch": "@@ -6,7 +6,7 @@ LL | |     let bad_ref: &'static u16 = unsafe { mem::transmute(0usize) };\n LL | |     let another_var = 13;\n LL | |     move || { let _ = bad_ref; let _ = another_var; }\n LL | | };\n-   | |__^ type validation failed: encountered 0 at .<deref>.<closure-var(bad_ref)>, but expected something greater or equal to 1\n+   | |__^ type validation failed: encountered 0 at .<deref>.<dyn-downcast>.<closure-var(bad_ref)>, but expected something greater or equal to 1\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n "}, {"sha": "13683ead0d5c5074fc033c3d0776491624f7026c", "filename": "src/test/ui/consts/const-eval/union-ub-fat-ptr.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d7bd9b6c24a89ebafd4400a710a868fb3e70242/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Funion-ub-fat-ptr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7d7bd9b6c24a89ebafd4400a710a868fb3e70242/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Funion-ub-fat-ptr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Funion-ub-fat-ptr.stderr?ref=7d7bd9b6c24a89ebafd4400a710a868fb3e70242", "patch": "@@ -66,7 +66,7 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/union-ub-fat-ptr.rs:116:1\n    |\n LL | const G: &Trait = &unsafe { BoolTransmute { val: 3 }.bl };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 3 at .<deref>, but expected something in the range 0..=1\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 3 at .<deref>.<dyn-downcast>, but expected something in the range 0..=1\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n "}]}