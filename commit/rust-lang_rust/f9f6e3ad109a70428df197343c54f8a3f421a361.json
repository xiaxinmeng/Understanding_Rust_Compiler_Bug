{"sha": "f9f6e3ad109a70428df197343c54f8a3f421a361", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY5ZjZlM2FkMTA5YTcwNDI4ZGYxOTczNDNjNTRmOGEzZjQyMWEzNjE=", "commit": {"author": {"name": "Simonas Kazlauskas", "email": "git@kazlauskas.me", "date": "2016-01-15T22:36:32Z"}, "committer": {"name": "Simonas Kazlauskas", "email": "git@kazlauskas.me", "date": "2016-01-19T20:53:34Z"}, "message": "[MIR] Reintroduce the unit temporary\n\nAn attempt to make loop body destination be optional, author implemented a pretty self contained\nchange and deemed it to be (much) uglier than the alternative of just keeping the unit temporary.\nHaving the temporary created lazily also has a nice property of not figuring in the MIR of\nfunctions which do not use loops of any sort.", "tree": {"sha": "f3b01331368ea1e7df519f80fbaa83d6cfd264be", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f3b01331368ea1e7df519f80fbaa83d6cfd264be"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f9f6e3ad109a70428df197343c54f8a3f421a361", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f9f6e3ad109a70428df197343c54f8a3f421a361", "html_url": "https://github.com/rust-lang/rust/commit/f9f6e3ad109a70428df197343c54f8a3f421a361", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f9f6e3ad109a70428df197343c54f8a3f421a361/comments", "author": {"login": "nagisa", "id": 679122, "node_id": "MDQ6VXNlcjY3OTEyMg==", "avatar_url": "https://avatars.githubusercontent.com/u/679122?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nagisa", "html_url": "https://github.com/nagisa", "followers_url": "https://api.github.com/users/nagisa/followers", "following_url": "https://api.github.com/users/nagisa/following{/other_user}", "gists_url": "https://api.github.com/users/nagisa/gists{/gist_id}", "starred_url": "https://api.github.com/users/nagisa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nagisa/subscriptions", "organizations_url": "https://api.github.com/users/nagisa/orgs", "repos_url": "https://api.github.com/users/nagisa/repos", "events_url": "https://api.github.com/users/nagisa/events{/privacy}", "received_events_url": "https://api.github.com/users/nagisa/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nagisa", "id": 679122, "node_id": "MDQ6VXNlcjY3OTEyMg==", "avatar_url": "https://avatars.githubusercontent.com/u/679122?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nagisa", "html_url": "https://github.com/nagisa", "followers_url": "https://api.github.com/users/nagisa/followers", "following_url": "https://api.github.com/users/nagisa/following{/other_user}", "gists_url": "https://api.github.com/users/nagisa/gists{/gist_id}", "starred_url": "https://api.github.com/users/nagisa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nagisa/subscriptions", "organizations_url": "https://api.github.com/users/nagisa/orgs", "repos_url": "https://api.github.com/users/nagisa/repos", "events_url": "https://api.github.com/users/nagisa/events{/privacy}", "received_events_url": "https://api.github.com/users/nagisa/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1f4e317e45349eb2d3c853e96bfd24dd574b36d1", "url": "https://api.github.com/repos/rust-lang/rust/commits/1f4e317e45349eb2d3c853e96bfd24dd574b36d1", "html_url": "https://github.com/rust-lang/rust/commit/1f4e317e45349eb2d3c853e96bfd24dd574b36d1"}], "stats": {"total": 152, "additions": 90, "deletions": 62}, "files": [{"sha": "4261efe8215a8190f478c42d4779727e6c1592d3", "filename": "src/librustc_mir/build/expr/into.rs", "status": "modified", "additions": 29, "deletions": 21, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/f9f6e3ad109a70428df197343c54f8a3f421a361/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9f6e3ad109a70428df197343c54f8a3f421a361/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs?ref=f9f6e3ad109a70428df197343c54f8a3f421a361", "patch": "@@ -146,11 +146,13 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                 // start the loop\n                 this.cfg.terminate(block, Terminator::Goto { target: loop_block });\n \n-                this.in_loop_scope(loop_block, exit_block, |this| {\n+                let might_break = this.in_loop_scope(loop_block, exit_block, move |this| {\n                     // conduct the test, if necessary\n                     let body_block;\n-                    let opt_cond_expr = opt_cond_expr; // FIXME rustc bug\n                     if let Some(cond_expr) = opt_cond_expr {\n+                        // This loop has a condition, ergo its exit_block is reachable.\n+                        this.find_loop_scope(expr_span, None).might_break = true;\n+\n                         let loop_block_end;\n                         let cond = unpack!(loop_block_end = this.as_operand(loop_block, cond_expr));\n                         body_block = this.cfg.start_new_block();\n@@ -163,21 +165,22 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                         body_block = loop_block;\n                     }\n \n-                    // execute the body, branching back to the test\n-                    // We write body\u2019s \u201creturn value\u201d into the destination of loop. This is fine,\n-                    // because:\n-                    //\n-                    // * In Rust both loop expression and its body are required to have `()`\n-                    //   as the \u201creturn value\u201d;\n-                    // * The destination will be considered uninitialised (given it was\n-                    //   uninitialised before the loop) during the first iteration, thus\n-                    //   disallowing its use inside the body. Alternatively, if it was already\n-                    //   initialised, the `destination` can only possibly have a value of `()`,\n-                    //   therefore, \u201cmutating\u201d the destination during iteration is fine.\n-                    let body_block_end = unpack!(this.into(destination, body_block, body));\n+                    // The \u201creturn\u201d value of the loop body must always be an unit, but we cannot\n+                    // reuse that as a \u201creturn\u201d value of the whole loop expressions, because some\n+                    // loops are diverging (e.g. `loop {}`). Thus, we introduce a unit temporary as\n+                    // the destination for the loop body and assign the loop\u2019s own \u201creturn\u201d value\n+                    // immediately after the iteration is finished.\n+                    let tmp = this.get_unit_temp();\n+                    // Execute the body, branching back to the test.\n+                    let body_block_end = unpack!(this.into(&tmp, body_block, body));\n                     this.cfg.terminate(body_block_end, Terminator::Goto { target: loop_block });\n-                    exit_block.unit()\n-                })\n+                });\n+                // If the loop may reach its exit_block, we assign an empty tuple to the\n+                // destination to keep the MIR well-formed.\n+                if might_break {\n+                    this.cfg.push_assign_unit(exit_block, expr_span, destination);\n+                }\n+                exit_block.unit()\n             }\n             ExprKind::Assign { lhs, rhs } => {\n                 // Note: we evaluate assignments right-to-left. This\n@@ -217,7 +220,10 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                                        |loop_scope| loop_scope.continue_block)\n             }\n             ExprKind::Break { label } => {\n-                this.break_or_continue(expr_span, label, block, |loop_scope| loop_scope.break_block)\n+                this.break_or_continue(expr_span, label, block, |loop_scope| {\n+                    loop_scope.might_break = true;\n+                    loop_scope.break_block\n+                })\n             }\n             ExprKind::Return { value } => {\n                 block = match value {\n@@ -303,11 +309,13 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                             block: BasicBlock,\n                             exit_selector: F)\n                             -> BlockAnd<()>\n-        where F: FnOnce(&LoopScope) -> BasicBlock\n+        where F: FnOnce(&mut LoopScope) -> BasicBlock\n     {\n-        let loop_scope = self.find_loop_scope(span, label);\n-        let exit_block = exit_selector(&loop_scope);\n-        self.exit_scope(span, loop_scope.extent, block, exit_block);\n+        let (exit_block, extent) = {\n+            let loop_scope = self.find_loop_scope(span, label);\n+            (exit_selector(loop_scope), loop_scope.extent)\n+        };\n+        self.exit_scope(span, extent, block, exit_block);\n         self.cfg.start_new_block().unit()\n     }\n }"}, {"sha": "a7459d62368e9cfa6e5f72b694f3deace3b93854", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f9f6e3ad109a70428df197343c54f8a3f421a361/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9f6e3ad109a70428df197343c54f8a3f421a361/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=f9f6e3ad109a70428df197343c54f8a3f421a361", "patch": "@@ -26,6 +26,7 @@ pub struct Builder<'a, 'tcx: 'a> {\n     var_decls: Vec<VarDecl<'tcx>>,\n     var_indices: FnvHashMap<ast::NodeId, u32>,\n     temp_decls: Vec<TempDecl<'tcx>>,\n+    unit_temp: Option<Lvalue<'tcx>>,\n }\n \n struct CFG<'tcx> {\n@@ -96,6 +97,7 @@ pub fn construct<'a,'tcx>(hir: Cx<'a,'tcx>,\n         temp_decls: vec![],\n         var_decls: vec![],\n         var_indices: FnvHashMap(),\n+        unit_temp: None\n     };\n \n     assert_eq!(builder.cfg.start_new_block(), START_BLOCK);\n@@ -156,6 +158,18 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n             block.and(arg_decls)\n         })\n     }\n+\n+    fn get_unit_temp(&mut self) -> Lvalue<'tcx> {\n+        match self.unit_temp {\n+            Some(ref tmp) => tmp.clone(),\n+            None => {\n+                let ty = self.hir.unit_ty();\n+                let tmp = self.temp(ty);\n+                self.unit_temp = Some(tmp.clone());\n+                tmp\n+            }\n+        }\n+    }\n }\n \n ///////////////////////////////////////////////////////////////////////////"}, {"sha": "dae525c84d033f53f4018d4dcb7bca201df50f0c", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 43, "deletions": 41, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/f9f6e3ad109a70428df197343c54f8a3f421a361/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9f6e3ad109a70428df197343c54f8a3f421a361/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=f9f6e3ad109a70428df197343c54f8a3f421a361", "patch": "@@ -103,31 +103,41 @@ pub struct Scope<'tcx> {\n \n #[derive(Clone, Debug)]\n pub struct LoopScope {\n-    pub extent: CodeExtent, // extent of the loop\n-    pub continue_block: BasicBlock, // where to go on a `loop`\n+    /// Extent of the loop\n+    pub extent: CodeExtent,\n+    /// Where the body of the loop begins\n+    pub continue_block: BasicBlock,\n+    /// Block to branch into when the loop terminates (either by being `break`-en out from, or by\n+    /// having its condition to become false)\n     pub break_block: BasicBlock, // where to go on a `break\n+    /// Indicates the reachability of the break_block for this loop\n+    pub might_break: bool\n }\n \n impl<'a,'tcx> Builder<'a,'tcx> {\n     /// Start a loop scope, which tracks where `continue` and `break`\n     /// should branch to. See module comment for more details.\n-    pub fn in_loop_scope<F, R>(&mut self,\n+    ///\n+    /// Returns the might_break attribute of the LoopScope used.\n+    pub fn in_loop_scope<F>(&mut self,\n                                loop_block: BasicBlock,\n                                break_block: BasicBlock,\n                                f: F)\n-                               -> BlockAnd<R>\n-        where F: FnOnce(&mut Builder<'a, 'tcx>) -> BlockAnd<R>\n+                               -> bool\n+        where F: FnOnce(&mut Builder<'a, 'tcx>)\n     {\n         let extent = self.extent_of_innermost_scope();\n         let loop_scope = LoopScope {\n             extent: extent.clone(),\n             continue_block: loop_block,\n             break_block: break_block,\n+            might_break: false\n         };\n         self.loop_scopes.push(loop_scope);\n-        let r = f(self);\n-        assert!(self.loop_scopes.pop().unwrap().extent == extent);\n-        r\n+        f(self);\n+        let loop_scope = self.loop_scopes.pop().unwrap();\n+        assert!(loop_scope.extent == extent);\n+        loop_scope.might_break\n     }\n \n     /// Convenience wrapper that pushes a scope and then executes `f`\n@@ -181,28 +191,21 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n     pub fn find_loop_scope(&mut self,\n                            span: Span,\n                            label: Option<CodeExtent>)\n-                           -> LoopScope {\n-        let loop_scope =\n-            match label {\n-                None => {\n-                    // no label? return the innermost loop scope\n-                    self.loop_scopes.iter()\n-                                    .rev()\n-                                    .next()\n-                }\n-                Some(label) => {\n-                    // otherwise, find the loop-scope with the correct id\n-                    self.loop_scopes.iter()\n-                                    .rev()\n-                                    .filter(|loop_scope| loop_scope.extent == label)\n-                                    .next()\n-                }\n-            };\n-\n-        match loop_scope {\n-            Some(loop_scope) => loop_scope.clone(),\n-            None => self.hir.span_bug(span, \"no enclosing loop scope found?\"),\n-        }\n+                           -> &mut LoopScope {\n+        let Builder { ref mut loop_scopes, ref mut hir, .. } = *self;\n+        match label {\n+            None => {\n+                // no label? return the innermost loop scope\n+                loop_scopes.iter_mut().rev().next()\n+            }\n+            Some(label) => {\n+                // otherwise, find the loop-scope with the correct id\n+                loop_scopes.iter_mut()\n+                           .rev()\n+                           .filter(|loop_scope| loop_scope.extent == label)\n+                           .next()\n+            }\n+        }.unwrap_or_else(|| hir.span_bug(span, \"no enclosing loop scope found?\"))\n     }\n \n     /// Branch out of `block` to `target`, exiting all scopes up to\n@@ -214,20 +217,19 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                       extent: CodeExtent,\n                       block: BasicBlock,\n                       target: BasicBlock) {\n-        let popped_scopes =\n-            match self.scopes.iter().rev().position(|scope| scope.extent == extent) {\n-                Some(p) => p + 1,\n-                None => self.hir.span_bug(span, &format!(\"extent {:?} does not enclose\",\n-                                                              extent)),\n-            };\n-\n-        for scope in self.scopes.iter_mut().rev().take(popped_scopes) {\n+        let Builder { ref mut scopes, ref mut cfg, ref mut hir, .. } = *self;\n+\n+        let scope_count = 1 + scopes.iter().rev().position(|scope| scope.extent == extent)\n+                                                 .unwrap_or_else(||{\n+            hir.span_bug(span, &format!(\"extent {:?} does not enclose\", extent))\n+        });\n+\n+        for scope in scopes.iter_mut().rev().take(scope_count) {\n             for &(kind, drop_span, ref lvalue) in &scope.drops {\n-                self.cfg.push_drop(block, drop_span, kind, lvalue);\n+                cfg.push_drop(block, drop_span, kind, lvalue);\n             }\n         }\n-\n-        self.cfg.terminate(block, Terminator::Goto { target: target });\n+        cfg.terminate(block, Terminator::Goto { target: target });\n     }\n \n     /// Creates a path that performs all required cleanup for unwinding."}, {"sha": "7019b40bb252117b73efa8e8ce4c5168b42474dd", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f9f6e3ad109a70428df197343c54f8a3f421a361/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9f6e3ad109a70428df197343c54f8a3f421a361/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=f9f6e3ad109a70428df197343c54f8a3f421a361", "patch": "@@ -58,6 +58,10 @@ impl<'a,'tcx:'a> Cx<'a, 'tcx> {\n         self.tcx.types.bool\n     }\n \n+    pub fn unit_ty(&mut self) -> Ty<'tcx> {\n+        self.tcx.mk_nil()\n+    }\n+\n     pub fn str_literal(&mut self, value: token::InternedString) -> Literal<'tcx> {\n         Literal::Value { value: ConstVal::Str(value) }\n     }"}]}