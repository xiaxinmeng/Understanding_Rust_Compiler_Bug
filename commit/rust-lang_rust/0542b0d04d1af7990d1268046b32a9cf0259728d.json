{"sha": "0542b0d04d1af7990d1268046b32a9cf0259728d", "node_id": "C_kwDOAAsO6NoAKDA1NDJiMGQwNGQxYWY3OTkwZDEyNjgwNDZiMzJhOWNmMDI1OTcyOGQ", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2023-03-27T21:16:46Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2023-03-29T16:22:17Z"}, "message": "Freshen normalizes-to hack goal RHS in the evaluate loop", "tree": {"sha": "f0b713edc646a2592a48d665ab14a04177245378", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f0b713edc646a2592a48d665ab14a04177245378"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0542b0d04d1af7990d1268046b32a9cf0259728d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0542b0d04d1af7990d1268046b32a9cf0259728d", "html_url": "https://github.com/rust-lang/rust/commit/0542b0d04d1af7990d1268046b32a9cf0259728d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0542b0d04d1af7990d1268046b32a9cf0259728d/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cf32b9de1e8f66526c36ad2927458558d2e81093", "url": "https://api.github.com/repos/rust-lang/rust/commits/cf32b9de1e8f66526c36ad2927458558d2e81093", "html_url": "https://github.com/rust-lang/rust/commit/cf32b9de1e8f66526c36ad2927458558d2e81093"}], "stats": {"total": 113, "additions": 70, "deletions": 43}, "files": [{"sha": "e86427224764699c3e74f9804863cf401c440976", "filename": "compiler/rustc_trait_selection/src/solve/eval_ctxt.rs", "status": "modified", "additions": 69, "deletions": 33, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/0542b0d04d1af7990d1268046b32a9cf0259728d/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0542b0d04d1af7990d1268046b32a9cf0259728d/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt.rs?ref=0542b0d04d1af7990d1268046b32a9cf0259728d", "patch": "@@ -48,7 +48,20 @@ pub(super) enum IsNormalizesToHack {\n \n #[derive(Debug, Clone)]\n pub(super) struct NestedGoals<'tcx> {\n+    /// This normalizes-to goal that is treated specially during the evaluation\n+    /// loop. In each iteration we take the RHS of the projection, replace it with\n+    /// a fresh inference variable, and only after evaluating that goal do we\n+    /// equate the fresh inference variable with the actual RHS of the predicate.\n+    ///\n+    /// This is both to improve caching, and to avoid using the RHS of the\n+    /// projection predicate to influence the normalizes-to candidate we select.\n+    ///\n+    /// This is not a 'real' nested goal. We must not forget to replace the RHS\n+    /// with a fresh inference variable when we evaluate this goal. That can result\n+    /// in a trait solver cycle. This would currently result in overflow but can be\n+    /// can be unsound with more powerful coinduction in the future.\n     pub(super) normalizes_to_hack_goal: Option<Goal<'tcx, ty::ProjectionPredicate<'tcx>>>,\n+    /// The rest of the goals which have not yet processed or remain ambiguous.\n     pub(super) goals: Vec<Goal<'tcx, ty::Predicate<'tcx>>>,\n }\n \n@@ -163,6 +176,10 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n             canonical_response,\n         )?;\n \n+        if !has_changed && !nested_goals.is_empty() {\n+            bug!(\"an unchanged goal shouldn't have any side-effects on instantiation\");\n+        }\n+\n         // Check that rerunning this query with its inference constraints applied\n         // doesn't result in new inference constraints and has the same result.\n         //\n@@ -180,9 +197,17 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n             let canonical_response =\n                 EvalCtxt::evaluate_canonical_goal(self.tcx(), self.search_graph, canonical_goal)?;\n             if !canonical_response.value.var_values.is_identity() {\n-                bug!(\"unstable result: {goal:?} {canonical_goal:?} {canonical_response:?}\");\n+                bug!(\n+                    \"unstable result: re-canonicalized goal={canonical_goal:#?} \\\n+                     response={canonical_response:#?}\"\n+                );\n+            }\n+            if certainty != canonical_response.value.certainty {\n+                bug!(\n+                    \"unstable certainty: {certainty:#?} re-canonicalized goal={canonical_goal:#?} \\\n+                     response={canonical_response:#?}\"\n+                );\n             }\n-            assert_eq!(certainty, canonical_response.value.certainty);\n         }\n \n         Ok((has_changed, certainty, nested_goals))\n@@ -262,15 +287,44 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n                 let mut has_changed = Err(Certainty::Yes);\n \n                 if let Some(goal) = goals.normalizes_to_hack_goal.take() {\n-                    let (_, certainty, nested_goals) = match this.evaluate_goal(\n-                        IsNormalizesToHack::Yes,\n-                        goal.with(this.tcx(), ty::Binder::dummy(goal.predicate)),\n+                    // Replace the goal with an unconstrained infer var, so the\n+                    // RHS does not affect projection candidate assembly.\n+                    let unconstrained_rhs = this.next_term_infer_of_kind(goal.predicate.term);\n+                    let unconstrained_goal = goal.with(\n+                        this.tcx(),\n+                        ty::Binder::dummy(ty::ProjectionPredicate {\n+                            projection_ty: goal.predicate.projection_ty,\n+                            term: unconstrained_rhs,\n+                        }),\n+                    );\n+\n+                    let (_, certainty, instantiate_goals) =\n+                        match this.evaluate_goal(IsNormalizesToHack::Yes, unconstrained_goal) {\n+                            Ok(r) => r,\n+                            Err(NoSolution) => return Some(Err(NoSolution)),\n+                        };\n+                    new_goals.goals.extend(instantiate_goals);\n+\n+                    // Finally, equate the goal's RHS with the unconstrained var.\n+                    // We put the nested goals from this into goals instead of\n+                    // next_goals to avoid needing to process the loop one extra\n+                    // time if this goal returns something -- I don't think this\n+                    // matters in practice, though.\n+                    match this.eq_and_get_goals(\n+                        goal.param_env,\n+                        goal.predicate.term,\n+                        unconstrained_rhs,\n                     ) {\n-                        Ok(r) => r,\n+                        Ok(eq_goals) => {\n+                            goals.goals.extend(eq_goals);\n+                        }\n                         Err(NoSolution) => return Some(Err(NoSolution)),\n                     };\n-                    new_goals.goals.extend(nested_goals);\n \n+                    // We only look at the `projection_ty` part here rather than\n+                    // looking at the \"has changed\" return from evaluate_goal,\n+                    // because we expect the `unconstrained_rhs` part of the predicate\n+                    // to have changed -- that means we actually normalized successfully!\n                     if goal.predicate.projection_ty\n                         != this.resolve_vars_if_possible(goal.predicate.projection_ty)\n                     {\n@@ -280,40 +334,22 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n                     match certainty {\n                         Certainty::Yes => {}\n                         Certainty::Maybe(_) => {\n-                            let goal = this.resolve_vars_if_possible(goal);\n-\n-                            // The rhs of this `normalizes-to` must always be an unconstrained infer var as it is\n-                            // the hack used by `normalizes-to` to ensure that every `normalizes-to` behaves the same\n-                            // regardless of the rhs.\n-                            //\n-                            // However it is important not to unconditionally replace the rhs with a new infer var\n-                            // as otherwise we may replace the original unconstrained infer var with a new infer var\n-                            // and never propagate any constraints on the new var back to the original var.\n-                            let term = this\n-                                .term_is_fully_unconstrained(goal)\n-                                .then_some(goal.predicate.term)\n-                                .unwrap_or_else(|| {\n-                                    this.next_term_infer_of_kind(goal.predicate.term)\n-                                });\n-                            let projection_pred = ty::ProjectionPredicate {\n-                                term,\n-                                projection_ty: goal.predicate.projection_ty,\n-                            };\n+                            // We need to resolve vars here so that we correctly\n+                            // deal with `has_changed` in the next iteration.\n                             new_goals.normalizes_to_hack_goal =\n-                                Some(goal.with(this.tcx(), projection_pred));\n-\n+                                Some(this.resolve_vars_if_possible(goal));\n                             has_changed = has_changed.map_err(|c| c.unify_and(certainty));\n                         }\n                     }\n                 }\n \n-                for nested_goal in goals.goals.drain(..) {\n-                    let (changed, certainty, nested_goals) =\n-                        match this.evaluate_goal(IsNormalizesToHack::No, nested_goal) {\n+                for goal in goals.goals.drain(..) {\n+                    let (changed, certainty, instantiate_goals) =\n+                        match this.evaluate_goal(IsNormalizesToHack::No, goal) {\n                             Ok(result) => result,\n                             Err(NoSolution) => return Some(Err(NoSolution)),\n                         };\n-                    new_goals.goals.extend(nested_goals);\n+                    new_goals.goals.extend(instantiate_goals);\n \n                     if changed {\n                         has_changed = Ok(());\n@@ -322,7 +358,7 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n                     match certainty {\n                         Certainty::Yes => {}\n                         Certainty::Maybe(_) => {\n-                            new_goals.goals.push(nested_goal);\n+                            new_goals.goals.push(goal);\n                             has_changed = has_changed.map_err(|c| c.unify_and(certainty));\n                         }\n                     }"}, {"sha": "32f0db742ad0d1297c1a2ba2a92d097d0b6ec1ff", "filename": "compiler/rustc_trait_selection/src/solve/project_goals.rs", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0542b0d04d1af7990d1268046b32a9cf0259728d/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0542b0d04d1af7990d1268046b32a9cf0259728d/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs?ref=0542b0d04d1af7990d1268046b32a9cf0259728d", "patch": "@@ -35,16 +35,7 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n             let candidates = self.assemble_and_evaluate_candidates(goal);\n             self.merge_candidates(candidates)\n         } else {\n-            let predicate = goal.predicate;\n-            let unconstrained_rhs = self.next_term_infer_of_kind(predicate.term);\n-            let unconstrained_predicate = ProjectionPredicate {\n-                projection_ty: goal.predicate.projection_ty,\n-                term: unconstrained_rhs,\n-            };\n-\n-            self.set_normalizes_to_hack_goal(goal.with(self.tcx(), unconstrained_predicate));\n-            self.try_evaluate_added_goals()?;\n-            self.eq(goal.param_env, unconstrained_rhs, predicate.term)?;\n+            self.set_normalizes_to_hack_goal(goal);\n             self.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n         }\n     }"}]}