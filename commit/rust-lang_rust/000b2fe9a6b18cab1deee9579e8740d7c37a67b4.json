{"sha": "000b2fe9a6b18cab1deee9579e8740d7c37a67b4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAwMGIyZmU5YTZiMThjYWIxZGVlZTk1NzllODc0MGQ3YzM3YTY3YjQ=", "commit": {"author": {"name": "Matt Brubeck", "email": "mbrubeck@limpet.net", "date": "2011-10-28T05:01:30Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-10-28T21:44:39Z"}, "message": "Use IEEE 754 semantics for NaN (Issue #1084)", "tree": {"sha": "513f8248a6998825fa45b5c7ff6540e8d1a0a63b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/513f8248a6998825fa45b5c7ff6540e8d1a0a63b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/000b2fe9a6b18cab1deee9579e8740d7c37a67b4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/000b2fe9a6b18cab1deee9579e8740d7c37a67b4", "html_url": "https://github.com/rust-lang/rust/commit/000b2fe9a6b18cab1deee9579e8740d7c37a67b4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/000b2fe9a6b18cab1deee9579e8740d7c37a67b4/comments", "author": {"login": "mbrubeck", "id": 5920, "node_id": "MDQ6VXNlcjU5MjA=", "avatar_url": "https://avatars.githubusercontent.com/u/5920?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mbrubeck", "html_url": "https://github.com/mbrubeck", "followers_url": "https://api.github.com/users/mbrubeck/followers", "following_url": "https://api.github.com/users/mbrubeck/following{/other_user}", "gists_url": "https://api.github.com/users/mbrubeck/gists{/gist_id}", "starred_url": "https://api.github.com/users/mbrubeck/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mbrubeck/subscriptions", "organizations_url": "https://api.github.com/users/mbrubeck/orgs", "repos_url": "https://api.github.com/users/mbrubeck/repos", "events_url": "https://api.github.com/users/mbrubeck/events{/privacy}", "received_events_url": "https://api.github.com/users/mbrubeck/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7e064deacfc9eab6e79737bb1f5070a19e2e1dc1", "url": "https://api.github.com/repos/rust-lang/rust/commits/7e064deacfc9eab6e79737bb1f5070a19e2e1dc1", "html_url": "https://github.com/rust-lang/rust/commit/7e064deacfc9eab6e79737bb1f5070a19e2e1dc1"}], "stats": {"total": 208, "additions": 149, "deletions": 59}, "files": [{"sha": "8b2f57baf60d55aafd45ce26c0a2b9b235a204b7", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 47, "deletions": 58, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/000b2fe9a6b18cab1deee9579e8740d7c37a67b4/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/000b2fe9a6b18cab1deee9579e8740d7c37a67b4/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=000b2fe9a6b18cab1deee9579e8740d7c37a67b4", "patch": "@@ -1492,26 +1492,26 @@ tag scalar_type { nil_type; signed_int; unsigned_int; floating_point; }\n \n \n fn compare_scalar_types(cx: @block_ctxt, lhs: ValueRef, rhs: ValueRef,\n-                        t: ty::t, llop: ValueRef) -> result {\n-    let f = bind compare_scalar_values(cx, lhs, rhs, _, llop);\n+                        t: ty::t, op: ast::binop) -> result {\n+    let f = bind compare_scalar_values(cx, lhs, rhs, _, op);\n \n     alt ty::struct(bcx_tcx(cx), t) {\n-      ty::ty_nil. { ret f(nil_type); }\n+      ty::ty_nil. { ret rslt(cx, f(nil_type)); }\n       ty::ty_bool. | ty::ty_uint. | ty::ty_ptr(_) | ty::ty_char. {\n-        ret f(unsigned_int);\n+        ret rslt(cx, f(unsigned_int));\n       }\n-      ty::ty_int. { ret f(signed_int); }\n-      ty::ty_float. { ret f(floating_point); }\n+      ty::ty_int. { ret rslt(cx, f(signed_int)); }\n+      ty::ty_float. { ret rslt(cx, f(floating_point)); }\n       ty::ty_machine(_) {\n         if ty::type_is_fp(bcx_tcx(cx), t) {\n             // Floating point machine types\n-            ret f(floating_point);\n+            ret rslt(cx, f(floating_point));\n         } else if ty::type_is_signed(bcx_tcx(cx), t) {\n             // Signed, integral machine types\n-            ret f(signed_int);\n+            ret rslt(cx, f(signed_int));\n         } else {\n             // Unsigned, integral machine types\n-            ret f(unsigned_int);\n+            ret rslt(cx, f(unsigned_int));\n         }\n       }\n       ty::ty_type. {\n@@ -1535,34 +1535,47 @@ fn compare_scalar_types(cx: @block_ctxt, lhs: ValueRef, rhs: ValueRef,\n \n // A helper function to do the actual comparison of scalar values.\n fn compare_scalar_values(cx: @block_ctxt, lhs: ValueRef, rhs: ValueRef,\n-                         nt: scalar_type, llop: ValueRef) -> result {\n-    let eq_cmp;\n-    let lt_cmp;\n-    let le_cmp;\n-    alt nt {\n+                         nt: scalar_type, op: ast::binop) -> ValueRef {\n+    let cmp = alt nt {\n       nil_type. {\n         // We don't need to do actual comparisons for nil.\n         // () == () holds but () < () does not.\n-        eq_cmp = 1u;\n-        lt_cmp = 0u;\n-        le_cmp = 1u;\n+        alt op {\n+          ast::eq. | ast::le. | ast::ge. { 1u }\n+          ast::ne. | ast::lt. | ast::gt. { 0u }\n+        }\n       }\n       floating_point. {\n-        eq_cmp = lib::llvm::LLVMRealUEQ;\n-        lt_cmp = lib::llvm::LLVMRealULT;\n-        le_cmp = lib::llvm::LLVMRealULE;\n+        alt op {\n+          ast::eq. { lib::llvm::LLVMRealOEQ }\n+          ast::ne. { lib::llvm::LLVMRealUNE }\n+          ast::lt. { lib::llvm::LLVMRealOLT }\n+          ast::le. { lib::llvm::LLVMRealOLE }\n+          ast::gt. { lib::llvm::LLVMRealOGT }\n+          ast::ge. { lib::llvm::LLVMRealOGE }\n+        }\n       }\n       signed_int. {\n-        eq_cmp = lib::llvm::LLVMIntEQ;\n-        lt_cmp = lib::llvm::LLVMIntSLT;\n-        le_cmp = lib::llvm::LLVMIntSLE;\n+        alt op {\n+          ast::eq. { lib::llvm::LLVMIntEQ }\n+          ast::ne. { lib::llvm::LLVMIntNE }\n+          ast::lt. { lib::llvm::LLVMIntSLT }\n+          ast::le. { lib::llvm::LLVMIntSLE }\n+          ast::gt. { lib::llvm::LLVMIntSGT }\n+          ast::ge. { lib::llvm::LLVMIntSGE }\n+        }\n       }\n       unsigned_int. {\n-        eq_cmp = lib::llvm::LLVMIntEQ;\n-        lt_cmp = lib::llvm::LLVMIntULT;\n-        le_cmp = lib::llvm::LLVMIntULE;\n+        alt op {\n+          ast::eq. { lib::llvm::LLVMIntEQ }\n+          ast::ne. { lib::llvm::LLVMIntNE }\n+          ast::lt. { lib::llvm::LLVMIntULT }\n+          ast::le. { lib::llvm::LLVMIntULE }\n+          ast::gt. { lib::llvm::LLVMIntUGT }\n+          ast::ge. { lib::llvm::LLVMIntUGE }\n+        }\n       }\n-    }\n+    };\n     // FIXME: This wouldn't be necessary if we could bind methods off of\n     // objects and therefore abstract over FCmp and ICmp (issue #435).  Then\n     // we could just write, e.g., \"cmp_fn = bind FCmp(cx, _, _, _);\" in\n@@ -1579,26 +1592,7 @@ fn compare_scalar_values(cx: @block_ctxt, lhs: ValueRef, rhs: ValueRef,\n         } else { r = ICmp(cx, op, lhs, rhs); }\n         ret r;\n     }\n-    let last_cx = new_sub_block_ctxt(cx, \"last\");\n-    let eq_cx = new_sub_block_ctxt(cx, \"eq\");\n-    let eq_result = generic_cmp(eq_cx, nt, eq_cmp, lhs, rhs);\n-    Br(eq_cx, last_cx.llbb);\n-    let lt_cx = new_sub_block_ctxt(cx, \"lt\");\n-    let lt_result = generic_cmp(lt_cx, nt, lt_cmp, lhs, rhs);\n-    Br(lt_cx, last_cx.llbb);\n-    let le_cx = new_sub_block_ctxt(cx, \"le\");\n-    let le_result = generic_cmp(le_cx, nt, le_cmp, lhs, rhs);\n-    Br(le_cx, last_cx.llbb);\n-    let unreach_cx = new_sub_block_ctxt(cx, \"unreach\");\n-    Unreachable(unreach_cx);\n-    let llswitch = Switch(cx, llop, unreach_cx.llbb, 3u);\n-    AddCase(llswitch, C_u8(abi::cmp_glue_op_eq), eq_cx.llbb);\n-    AddCase(llswitch, C_u8(abi::cmp_glue_op_lt), lt_cx.llbb);\n-    AddCase(llswitch, C_u8(abi::cmp_glue_op_le), le_cx.llbb);\n-    let last_result =\n-        Phi(last_cx, T_i1(), [eq_result, lt_result, le_result],\n-            [eq_cx.llbb, lt_cx.llbb, le_cx.llbb]);\n-    ret rslt(last_cx, last_result);\n+    ret generic_cmp(cx, nt, cmp, lhs, rhs);\n }\n \n type val_pair_fn = fn(@block_ctxt, ValueRef, ValueRef) -> @block_ctxt;\n@@ -1912,16 +1906,6 @@ fn call_cmp_glue(cx: @block_ctxt, lhs: ValueRef, rhs: ValueRef, t: ty::t,\n     ret rslt(bcx, Load(bcx, llcmpresultptr));\n }\n \n-// Compares two values. Performs the simple scalar comparison if the types are\n-// scalar and calls to comparison glue otherwise.\n-fn compare(cx: @block_ctxt, lhs: ValueRef, rhs: ValueRef, t: ty::t,\n-           llop: ValueRef) -> result {\n-    if ty::type_is_scalar(bcx_tcx(cx), t) {\n-        ret compare_scalar_types(cx, lhs, rhs, t, llop);\n-    }\n-    ret call_cmp_glue(cx, lhs, rhs, t, llop);\n-}\n-\n fn take_ty(cx: @block_ctxt, v: ValueRef, t: ty::t) -> @block_ctxt {\n     if ty::type_has_pointers(bcx_tcx(cx), t) {\n         ret call_tydesc_glue(cx, v, t, abi::tydesc_field_take_glue);\n@@ -2262,6 +2246,11 @@ fn trans_expr_fn(bcx: @block_ctxt, f: ast::_fn, sp: span,\n \n fn trans_compare(cx: @block_ctxt, op: ast::binop, lhs: ValueRef,\n                  _lhs_t: ty::t, rhs: ValueRef, rhs_t: ty::t) -> result {\n+    if ty::type_is_scalar(bcx_tcx(cx), rhs_t) {\n+      let rs = compare_scalar_types(cx, lhs, rhs, rhs_t, op);\n+      ret rslt(rs.bcx, rs.val);\n+    }\n+\n     // Determine the operation we need.\n     let llop;\n     alt op {\n@@ -2270,7 +2259,7 @@ fn trans_compare(cx: @block_ctxt, op: ast::binop, lhs: ValueRef,\n       ast::le. | ast::gt. { llop = C_u8(abi::cmp_glue_op_le); }\n     }\n \n-    let rs = compare(cx, lhs, rhs, rhs_t, llop);\n+    let rs = call_cmp_glue(cx, lhs, rhs, rhs_t, llop);\n \n     // Invert the result if necessary.\n     alt op {"}, {"sha": "1b101eaf859be8580048ce704c1621737e8d8527", "filename": "src/lib/float.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/000b2fe9a6b18cab1deee9579e8740d7c37a67b4/src%2Flib%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/000b2fe9a6b18cab1deee9579e8740d7c37a67b4/src%2Flib%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Ffloat.rs?ref=000b2fe9a6b18cab1deee9579e8740d7c37a67b4", "patch": "@@ -213,6 +213,9 @@ fn NaN() -> float {\n    ret 0./0.;\n }\n \n+/* Predicate: isNaN */\n+pure fn isNaN(f: float) -> bool { f != f }\n+\n /* Function: infinity */\n pure fn infinity() -> float {\n    ret 1./0.;"}, {"sha": "61ef4373a8c2ac4547a26b646b28e5315dbed493", "filename": "src/test/run-pass/float-nan.rs", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/000b2fe9a6b18cab1deee9579e8740d7c37a67b4/src%2Ftest%2Frun-pass%2Ffloat-nan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/000b2fe9a6b18cab1deee9579e8740d7c37a67b4/src%2Ftest%2Frun-pass%2Ffloat-nan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffloat-nan.rs?ref=000b2fe9a6b18cab1deee9579e8740d7c37a67b4", "patch": "@@ -0,0 +1,74 @@\n+use std;\n+import std::float;\n+\n+fn main() {\n+  let nan = float::NaN();\n+  assert(float::isNaN(nan));\n+\n+  let inf = float::infinity();\n+  assert(-inf == float::neg_infinity());\n+\n+  assert( nan !=  nan);\n+  assert( nan != -nan);\n+  assert(-nan != -nan);\n+  assert(-nan !=  nan);\n+\n+  assert( nan !=   1.);\n+  assert( nan !=   0.);\n+  assert( nan !=  inf);\n+  assert( nan != -inf);\n+\n+  assert(  1. !=  nan);\n+  assert(  0. !=  nan);\n+  assert( inf !=  nan);\n+  assert(-inf !=  nan);\n+\n+  assert(!( nan ==  nan));\n+  assert(!( nan == -nan));\n+  assert(!( nan ==   1.));\n+  assert(!( nan ==   0.));\n+  assert(!( nan ==  inf));\n+  assert(!( nan == -inf));\n+  assert(!(  1. ==  nan));\n+  assert(!(  0. ==  nan));\n+  assert(!( inf ==  nan));\n+  assert(!(-inf ==  nan));\n+  assert(!(-nan ==  nan));\n+  assert(!(-nan == -nan));\n+\n+  assert(!( nan >  nan));\n+  assert(!( nan > -nan));\n+  assert(!( nan >   0.));\n+  assert(!( nan >  inf));\n+  assert(!( nan > -inf));\n+  assert(!(  0. >  nan));\n+  assert(!( inf >  nan));\n+  assert(!(-inf >  nan));\n+  assert(!(-nan >  nan));\n+\n+  assert(!(nan <   0.));\n+  assert(!(nan <   1.));\n+  assert(!(nan <  -1.));\n+  assert(!(nan <  inf));\n+  assert(!(nan < -inf));\n+  assert(!(nan <  nan));\n+  assert(!(nan < -nan));\n+\n+  assert(!(  0. < nan));\n+  assert(!(  1. < nan));\n+  assert(!( -1. < nan));\n+  assert(!( inf < nan));\n+  assert(!(-inf < nan));\n+  assert(!(-nan < nan));\n+\n+  assert(float::isNaN(nan + inf));\n+  assert(float::isNaN(nan + -inf));\n+  assert(float::isNaN(nan + 0.));\n+  assert(float::isNaN(nan + 1.));\n+  assert(float::isNaN(nan * 1.));\n+  assert(float::isNaN(nan / 1.));\n+  assert(float::isNaN(nan / 0.));\n+  assert(float::isNaN(0. / 0.));\n+  assert(float::isNaN(-inf + inf));\n+  assert(float::isNaN(inf - inf));\n+}"}, {"sha": "302d6b1679e01b5617e72f9b71eeb41a80a9df76", "filename": "src/test/stdtest/float.rs", "status": "modified", "additions": 25, "deletions": 1, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/000b2fe9a6b18cab1deee9579e8740d7c37a67b4/src%2Ftest%2Fstdtest%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/000b2fe9a6b18cab1deee9579e8740d7c37a67b4/src%2Ftest%2Fstdtest%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Ffloat.rs?ref=000b2fe9a6b18cab1deee9579e8740d7c37a67b4", "patch": "@@ -10,7 +10,7 @@ fn test_from_str() {\n    assert ( float::from_str(\"2.5e10\") == 25000000000. );\n    assert ( float::from_str(\"25000000000.E-10\") == 2.5 );\n    assert ( float::from_str(\"\") == 0. );\n-   assert ( float::from_str(\"   \") == 0. );\n+   assert ( float::isNaN(float::from_str(\"   \")) );\n    assert ( float::from_str(\".\") == 0. );\n    assert ( float::from_str(\"5.\") == 5. );\n    assert ( float::from_str(\".5\") == 0.5 );\n@@ -25,6 +25,7 @@ fn test_positive() {\n   assert(!float::positive(-1.));\n   assert(!float::positive(float::neg_infinity()));\n   assert(!float::positive(1./float::neg_infinity()));\n+  assert(!float::positive(float::NaN()));\n }\n \n #[test]\n@@ -35,4 +36,27 @@ fn test_negative() {\n   assert(float::negative(-1.));\n   assert(float::negative(float::neg_infinity()));\n   assert(float::negative(1./float::neg_infinity()));\n+  assert(!float::negative(float::NaN()));\n+}\n+\n+#[test]\n+fn test_nonpositive() {\n+  assert(!float::nonpositive(float::infinity()));\n+  assert(!float::nonpositive(1.));\n+  assert(!float::nonpositive(0.));\n+  assert(float::nonpositive(-1.));\n+  assert(float::nonpositive(float::neg_infinity()));\n+  assert(float::nonpositive(1./float::neg_infinity()));\n+  // TODO: assert(!float::nonpositive(float::NaN()));\n+}\n+\n+#[test]\n+fn test_nonnegative() {\n+  assert(float::nonnegative(float::infinity()));\n+  assert(float::nonnegative(1.));\n+  assert(float::nonnegative(0.));\n+  assert(!float::nonnegative(-1.));\n+  assert(!float::nonnegative(float::neg_infinity()));\n+  assert(!float::nonnegative(1./float::neg_infinity()));\n+  // TODO: assert(!float::nonnegative(float::NaN()));\n }"}]}