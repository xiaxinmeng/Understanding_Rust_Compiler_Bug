{"sha": "35e7966ebeee70ca2c15b5139b5c1918d9ef4086", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM1ZTc5NjZlYmVlZTcwY2EyYzE1YjUxMzliNWMxOTE4ZDllZjQwODY=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-07-30T12:06:04Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-07-30T12:06:39Z"}, "message": "Add comma list to use tree", "tree": {"sha": "884d3e034699c6d6bd389fa05bb4999fefcbcf73", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/884d3e034699c6d6bd389fa05bb4999fefcbcf73"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/35e7966ebeee70ca2c15b5139b5c1918d9ef4086", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/35e7966ebeee70ca2c15b5139b5c1918d9ef4086", "html_url": "https://github.com/rust-lang/rust/commit/35e7966ebeee70ca2c15b5139b5c1918d9ef4086", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/35e7966ebeee70ca2c15b5139b5c1918d9ef4086/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "be803efb7c7ba257716fcc97c57ecfd07e278b07", "url": "https://api.github.com/repos/rust-lang/rust/commits/be803efb7c7ba257716fcc97c57ecfd07e278b07", "html_url": "https://github.com/rust-lang/rust/commit/be803efb7c7ba257716fcc97c57ecfd07e278b07"}], "stats": {"total": 215, "additions": 126, "deletions": 89}, "files": [{"sha": "9d8127a3d417b3e6216f3d21694f9ab5a3ca9934", "filename": "crates/ra_syntax/src/ast/generated/nodes.rs", "status": "modified", "additions": 78, "deletions": 77, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/35e7966ebeee70ca2c15b5139b5c1918d9ef4086/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35e7966ebeee70ca2c15b5139b5c1918d9ef4086/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs?ref=35e7966ebeee70ca2c15b5139b5c1918d9ef4086", "patch": "@@ -268,6 +268,36 @@ pub struct Rename {\n impl ast::NameOwner for Rename {}\n impl Rename {\n     pub fn as_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![as]) }\n+    pub fn underscore_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![_]) }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct UseTree {\n+    pub(crate) syntax: SyntaxNode,\n+}\n+impl UseTree {\n+    pub fn path(&self) -> Option<Path> { support::child(&self.syntax) }\n+    pub fn coloncolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![::]) }\n+    pub fn star_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![*]) }\n+    pub fn use_tree_list(&self) -> Option<UseTreeList> { support::child(&self.syntax) }\n+    pub fn rename(&self) -> Option<Rename> { support::child(&self.syntax) }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct Path {\n+    pub(crate) syntax: SyntaxNode,\n+}\n+impl Path {\n+    pub fn qualifier(&self) -> Option<Path> { support::child(&self.syntax) }\n+    pub fn coloncolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![::]) }\n+    pub fn segment(&self) -> Option<PathSegment> { support::child(&self.syntax) }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct UseTreeList {\n+    pub(crate) syntax: SyntaxNode,\n+}\n+impl UseTreeList {\n+    pub fn l_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['{']) }\n+    pub fn use_trees(&self) -> AstChildren<UseTree> { support::children(&self.syntax) }\n+    pub fn r_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['}']) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct Abi {\n@@ -433,15 +463,6 @@ impl PathType {\n     pub fn path(&self) -> Option<Path> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct Path {\n-    pub(crate) syntax: SyntaxNode,\n-}\n-impl Path {\n-    pub fn qualifier(&self) -> Option<Path> { support::child(&self.syntax) }\n-    pub fn coloncolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![::]) }\n-    pub fn segment(&self) -> Option<PathSegment> { support::child(&self.syntax) }\n-}\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct PointerType {\n     pub(crate) syntax: SyntaxNode,\n }\n@@ -1178,26 +1199,6 @@ impl Param {\n     pub fn dotdotdot_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![...]) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct UseTree {\n-    pub(crate) syntax: SyntaxNode,\n-}\n-impl UseTree {\n-    pub fn path(&self) -> Option<Path> { support::child(&self.syntax) }\n-    pub fn coloncolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![::]) }\n-    pub fn star_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![*]) }\n-    pub fn use_tree_list(&self) -> Option<UseTreeList> { support::child(&self.syntax) }\n-    pub fn rename(&self) -> Option<Rename> { support::child(&self.syntax) }\n-}\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct UseTreeList {\n-    pub(crate) syntax: SyntaxNode,\n-}\n-impl UseTreeList {\n-    pub fn l_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['{']) }\n-    pub fn use_trees(&self) -> AstChildren<UseTree> { support::children(&self.syntax) }\n-    pub fn r_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['}']) }\n-}\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct PathSegment {\n     pub(crate) syntax: SyntaxNode,\n }\n@@ -1627,6 +1628,39 @@ impl AstNode for Rename {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n+impl AstNode for UseTree {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == USE_TREE }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxNode { &self.syntax }\n+}\n+impl AstNode for Path {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == PATH }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxNode { &self.syntax }\n+}\n+impl AstNode for UseTreeList {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == USE_TREE_LIST }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxNode { &self.syntax }\n+}\n impl AstNode for Abi {\n     fn can_cast(kind: SyntaxKind) -> bool { kind == ABI }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n@@ -1825,17 +1859,6 @@ impl AstNode for PathType {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for Path {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == PATH }\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        if Self::can_cast(syntax.kind()) {\n-            Some(Self { syntax })\n-        } else {\n-            None\n-        }\n-    }\n-    fn syntax(&self) -> &SyntaxNode { &self.syntax }\n-}\n impl AstNode for PointerType {\n     fn can_cast(kind: SyntaxKind) -> bool { kind == POINTER_TYPE }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n@@ -2672,28 +2695,6 @@ impl AstNode for Param {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for UseTree {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == USE_TREE }\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        if Self::can_cast(syntax.kind()) {\n-            Some(Self { syntax })\n-        } else {\n-            None\n-        }\n-    }\n-    fn syntax(&self) -> &SyntaxNode { &self.syntax }\n-}\n-impl AstNode for UseTreeList {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == USE_TREE_LIST }\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        if Self::can_cast(syntax.kind()) {\n-            Some(Self { syntax })\n-        } else {\n-            None\n-        }\n-    }\n-    fn syntax(&self) -> &SyntaxNode { &self.syntax }\n-}\n impl AstNode for PathSegment {\n     fn can_cast(kind: SyntaxKind) -> bool { kind == PATH_SEGMENT }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n@@ -3560,6 +3561,21 @@ impl std::fmt::Display for Rename {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n+impl std::fmt::Display for UseTree {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        std::fmt::Display::fmt(self.syntax(), f)\n+    }\n+}\n+impl std::fmt::Display for Path {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        std::fmt::Display::fmt(self.syntax(), f)\n+    }\n+}\n+impl std::fmt::Display for UseTreeList {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        std::fmt::Display::fmt(self.syntax(), f)\n+    }\n+}\n impl std::fmt::Display for Abi {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n@@ -3650,11 +3666,6 @@ impl std::fmt::Display for PathType {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for Path {\n-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n-        std::fmt::Display::fmt(self.syntax(), f)\n-    }\n-}\n impl std::fmt::Display for PointerType {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n@@ -4035,16 +4046,6 @@ impl std::fmt::Display for Param {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for UseTree {\n-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n-        std::fmt::Display::fmt(self.syntax(), f)\n-    }\n-}\n-impl std::fmt::Display for UseTreeList {\n-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n-        std::fmt::Display::fmt(self.syntax(), f)\n-    }\n-}\n impl std::fmt::Display for PathSegment {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)"}, {"sha": "c77fc8a8d09e04f3eb781c331e359f1f850cb956", "filename": "xtask/src/codegen/gen_syntax.rs", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/35e7966ebeee70ca2c15b5139b5c1918d9ef4086/xtask%2Fsrc%2Fcodegen%2Fgen_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35e7966ebeee70ca2c15b5139b5c1918d9ef4086/xtask%2Fsrc%2Fcodegen%2Fgen_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Fcodegen%2Fgen_syntax.rs?ref=35e7966ebeee70ca2c15b5139b5c1918d9ef4086", "patch": "@@ -543,6 +543,10 @@ fn lower_enum(grammar: &Grammar, rule: &Rule) -> Option<Vec<String>> {\n }\n \n fn lower_rule(acc: &mut Vec<Field>, grammar: &Grammar, rule: &Rule) {\n+    if lower_comma_list(acc, grammar, rule) {\n+        return;\n+    }\n+\n     match rule {\n         Rule::Node(node) => {\n             let field = Field::Node { name: grammar[*node].name.clone(), src: FieldSrc::Shorthand };\n@@ -595,6 +599,37 @@ fn lower_rule(acc: &mut Vec<Field>, grammar: &Grammar, rule: &Rule) {\n     }\n }\n \n+// (T (',' T)* ','?)?\n+fn lower_comma_list(acc: &mut Vec<Field>, grammar: &Grammar, rule: &Rule) -> bool {\n+    let rule = match rule {\n+        Rule::Opt(it) => it,\n+        _ => return false,\n+    };\n+    let rule = match &**rule {\n+        Rule::Seq(it) => it,\n+        _ => return false,\n+    };\n+    let (node, repeat, trailing_comma) = match rule.as_slice() {\n+        [Rule::Node(node), Rule::Rep(repeat), Rule::Opt(trailing_comma)] => {\n+            (node, repeat, trailing_comma)\n+        }\n+        _ => return false,\n+    };\n+    let repeat = match &**repeat {\n+        Rule::Seq(it) => it,\n+        _ => return false,\n+    };\n+    match repeat.as_slice() {\n+        [comma, Rule::Node(n)] if comma == &**trailing_comma && n == node => (),\n+        _ => return false,\n+    }\n+    let name = grammar[*node].name.clone();\n+    let label = pluralize(&to_lower_snake_case(&name));\n+    let field = Field::Node { name: label.clone(), src: FieldSrc::Many(name) };\n+    acc.push(field);\n+    true\n+}\n+\n fn deduplicate_fields(ast: &mut AstSrc) {\n     for node in &mut ast.nodes {\n         let mut i = 0;"}, {"sha": "2ba68457fd86c6c5f7408f7269090ce40c33259d", "filename": "xtask/src/codegen/rust.ungram", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/35e7966ebeee70ca2c15b5139b5c1918d9ef4086/xtask%2Fsrc%2Fcodegen%2Frust.ungram", "raw_url": "https://github.com/rust-lang/rust/raw/35e7966ebeee70ca2c15b5139b5c1918d9ef4086/xtask%2Fsrc%2Fcodegen%2Frust.ungram", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Fcodegen%2Frust.ungram?ref=35e7966ebeee70ca2c15b5139b5c1918d9ef4086", "patch": "@@ -29,6 +29,19 @@ ItemList =\n ExternCrate =\n   Attr* Visibility? 'extern' 'crate' (NameRef | 'self') Rename? ';'\n \n+Rename =\n+  'as' (Name | '_')\n+\n+UseItem =\n+  Attr* Visibility? 'use' UseTree ';'\n+\n+UseTree =\n+  (Path? '::')? ('*' | UseTreeList )\n+| Path Rename?\n+\n+UseTreeList =\n+  '{' (UseTree (',' UseTree)* ','?)? '}'\n+\n FnDef =\n  Attr* Visibility? Abi? 'const' 'default' 'async' 'unsafe' 'fn' Name TypeParamList?\n  ParamList RetType?\n@@ -395,18 +408,6 @@ Param =\n   Attr* Pat (':' ascribed_type:TypeRef)\n | '...'\n \n-UseItem =\n-  Attr* Visibility? 'use' UseTree ';'\n-\n-UseTree =\n-  Path ('::' ('*' | UseTreeList))  Rename?\n-\n-UseTreeList =\n-  '{' UseTree* '}'\n-\n-Rename =\n-  'as' Name\n-\n Path =\n   (qualifier:Path '::')? segment:PathSegment\n "}]}