{"sha": "3ed2a10d173d6c2e0232776af338ca7d080b1cd4", "node_id": "C_kwDOAAsO6NoAKDNlZDJhMTBkMTczZDZjMmUwMjMyNzc2YWYzMzhjYTdkMDgwYjFjZDQ", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-06-14T08:26:22Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-06-14T08:26:22Z"}, "message": "Auto merge of #110662 - bryangarza:safe-transmute-reference-types, r=compiler-errors\n\nSafe Transmute: Enable handling references\n\nThis patch enables support for references in Safe Transmute, by generating nested obligations during trait selection. Specifically, when we call `confirm_transmutability_candidate(...)`, we now recursively traverse the `rustc_transmute::Answer` tree and create obligations for all the `Answer` variants, some of which include multiple nested `Answer`s.", "tree": {"sha": "91c79ae2593fa4cdeb38755a057feefa2594856d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/91c79ae2593fa4cdeb38755a057feefa2594856d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3ed2a10d173d6c2e0232776af338ca7d080b1cd4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3ed2a10d173d6c2e0232776af338ca7d080b1cd4", "html_url": "https://github.com/rust-lang/rust/commit/3ed2a10d173d6c2e0232776af338ca7d080b1cd4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3ed2a10d173d6c2e0232776af338ca7d080b1cd4/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "57c215b08e18054c64428e00a291b45dc690d9de", "url": "https://api.github.com/repos/rust-lang/rust/commits/57c215b08e18054c64428e00a291b45dc690d9de", "html_url": "https://github.com/rust-lang/rust/commit/57c215b08e18054c64428e00a291b45dc690d9de"}, {"sha": "f4cf8f65a5e8e110c8c36469d31f16e8571e2c1a", "url": "https://api.github.com/repos/rust-lang/rust/commits/f4cf8f65a5e8e110c8c36469d31f16e8571e2c1a", "html_url": "https://github.com/rust-lang/rust/commit/f4cf8f65a5e8e110c8c36469d31f16e8571e2c1a"}], "stats": {"total": 995, "additions": 789, "deletions": 206}, "files": [{"sha": "a8a0e1ebfb42cf4be2086b14d94127e16399243c", "filename": "compiler/rustc_trait_selection/src/solve/eval_ctxt.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3ed2a10d173d6c2e0232776af338ca7d080b1cd4/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ed2a10d173d6c2e0232776af338ca7d080b1cd4/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt.rs?ref=3ed2a10d173d6c2e0232776af338ca7d080b1cd4", "patch": "@@ -709,18 +709,16 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         scope: Ty<'tcx>,\n         assume: rustc_transmute::Assume,\n     ) -> Result<Certainty, NoSolution> {\n+        use rustc_transmute::Answer;\n         // FIXME(transmutability): This really should be returning nested goals for `Answer::If*`\n         match rustc_transmute::TransmuteTypeEnv::new(self.infcx).is_transmutable(\n             ObligationCause::dummy(),\n             src_and_dst,\n             scope,\n             assume,\n         ) {\n-            rustc_transmute::Answer::Yes => Ok(Certainty::Yes),\n-            rustc_transmute::Answer::No(_)\n-            | rustc_transmute::Answer::IfTransmutable { .. }\n-            | rustc_transmute::Answer::IfAll(_)\n-            | rustc_transmute::Answer::IfAny(_) => Err(NoSolution),\n+            Answer::Yes => Ok(Certainty::Yes),\n+            Answer::No(_) | Answer::If(_) => Err(NoSolution),\n         }\n     }\n "}, {"sha": "1bc4599377aac91b60ff8467198762021dafda96", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 45, "deletions": 11, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/3ed2a10d173d6c2e0232776af338ca7d080b1cd4/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ed2a10d173d6c2e0232776af338ca7d080b1cd4/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=3ed2a10d173d6c2e0232776af338ca7d080b1cd4", "patch": "@@ -66,6 +66,11 @@ pub struct ImplCandidate<'tcx> {\n     pub similarity: CandidateSimilarity,\n }\n \n+enum GetSafeTransmuteErrorAndReason {\n+    Silent,\n+    Error { err_msg: String, safe_transmute_explanation: String },\n+}\n+\n pub trait InferCtxtExt<'tcx> {\n     /// Given some node representing a fn-like thing in the HIR map,\n     /// returns a span and `ArgKind` information that describes the\n@@ -739,11 +744,17 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                             == self.tcx.lang_items().transmute_trait()\n                         {\n                             // Recompute the safe transmute reason and use that for the error reporting\n-                            self.get_safe_transmute_error_and_reason(\n+                            match self.get_safe_transmute_error_and_reason(\n                                 obligation.clone(),\n                                 trait_ref,\n                                 span,\n-                            )\n+                            ) {\n+                                GetSafeTransmuteErrorAndReason::Silent => return,\n+                                GetSafeTransmuteErrorAndReason::Error {\n+                                    err_msg,\n+                                    safe_transmute_explanation,\n+                                } => (err_msg, Some(safe_transmute_explanation)),\n+                            }\n                         } else {\n                             (err_msg, None)\n                         };\n@@ -1403,7 +1414,7 @@ trait InferCtxtPrivExt<'tcx> {\n         obligation: PredicateObligation<'tcx>,\n         trait_ref: ty::PolyTraitRef<'tcx>,\n         span: Span,\n-    ) -> (String, Option<String>);\n+    ) -> GetSafeTransmuteErrorAndReason;\n \n     fn add_tuple_trait_message(\n         &self,\n@@ -2850,7 +2861,9 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n         obligation: PredicateObligation<'tcx>,\n         trait_ref: ty::PolyTraitRef<'tcx>,\n         span: Span,\n-    ) -> (String, Option<String>) {\n+    ) -> GetSafeTransmuteErrorAndReason {\n+        use rustc_transmute::Answer;\n+\n         // Erase regions because layout code doesn't particularly care about regions.\n         let trait_ref = self.tcx.erase_regions(self.tcx.erase_late_bound_regions(trait_ref));\n \n@@ -2863,19 +2876,20 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n             rustc_transmute::Assume::from_const(self.infcx.tcx, obligation.param_env, trait_ref.substs.const_at(3)) else {\n                 span_bug!(span, \"Unable to construct rustc_transmute::Assume where it was previously possible\");\n             };\n+\n         match rustc_transmute::TransmuteTypeEnv::new(self.infcx).is_transmutable(\n             obligation.cause,\n             src_and_dst,\n             scope,\n             assume,\n         ) {\n-            rustc_transmute::Answer::No(reason) => {\n+            Answer::No(reason) => {\n                 let dst = trait_ref.substs.type_at(0);\n                 let src = trait_ref.substs.type_at(1);\n-                let custom_err_msg = format!(\n+                let err_msg = format!(\n                     \"`{src}` cannot be safely transmuted into `{dst}` in the defining scope of `{scope}`\"\n                 );\n-                let reason_msg = match reason {\n+                let safe_transmute_explanation = match reason {\n                     rustc_transmute::Reason::SrcIsUnspecified => {\n                         format!(\"`{src}` does not have a well-specified layout\")\n                     }\n@@ -2891,19 +2905,39 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                     rustc_transmute::Reason::DstIsPrivate => format!(\n                         \"`{dst}` is or contains a type or field that is not visible in that scope\"\n                     ),\n-                    // FIXME(bryangarza): Include the number of bytes of src and dst\n                     rustc_transmute::Reason::DstIsTooBig => {\n                         format!(\"The size of `{src}` is smaller than the size of `{dst}`\")\n                     }\n+                    rustc_transmute::Reason::DstHasStricterAlignment {\n+                        src_min_align,\n+                        dst_min_align,\n+                    } => {\n+                        format!(\n+                            \"The minimum alignment of `{src}` ({src_min_align}) should be greater than that of `{dst}` ({dst_min_align})\"\n+                        )\n+                    }\n+                    rustc_transmute::Reason::DstIsMoreUnique => {\n+                        format!(\"`{src}` is a shared reference, but `{dst}` is a unique reference\")\n+                    }\n+                    // Already reported by rustc\n+                    rustc_transmute::Reason::TypeError => {\n+                        return GetSafeTransmuteErrorAndReason::Silent;\n+                    }\n+                    rustc_transmute::Reason::SrcLayoutUnknown => {\n+                        format!(\"`{src}` has an unknown layout\")\n+                    }\n+                    rustc_transmute::Reason::DstLayoutUnknown => {\n+                        format!(\"`{dst}` has an unknown layout\")\n+                    }\n                 };\n-                (custom_err_msg, Some(reason_msg))\n+                GetSafeTransmuteErrorAndReason::Error { err_msg, safe_transmute_explanation }\n             }\n             // Should never get a Yes at this point! We already ran it before, and did not get a Yes.\n-            rustc_transmute::Answer::Yes => span_bug!(\n+            Answer::Yes => span_bug!(\n                 span,\n                 \"Inconsistent rustc_transmute::is_transmutable(...) result, got Yes\",\n             ),\n-            _ => span_bug!(span, \"Unsupported rustc_transmute::Reason variant\"),\n+            other => span_bug!(span, \"Unsupported rustc_transmute::Answer variant: `{other:?}`\"),\n         }\n     }\n "}, {"sha": "7853af959ad5d9e55b6fc783d9a7d7f80a7fa113", "filename": "compiler/rustc_trait_selection/src/traits/select/confirmation.rs", "status": "modified", "additions": 64, "deletions": 10, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/3ed2a10d173d6c2e0232776af338ca7d080b1cd4/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ed2a10d173d6c2e0232776af338ca7d080b1cd4/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs?ref=3ed2a10d173d6c2e0232776af338ca7d080b1cd4", "patch": "@@ -6,14 +6,15 @@\n //!\n //! [rustc dev guide]:\n //! https://rustc-dev-guide.rust-lang.org/traits/resolution.html#confirmation\n+use rustc_ast::Mutability;\n use rustc_data_structures::stack::ensure_sufficient_stack;\n use rustc_hir::lang_items::LangItem;\n use rustc_infer::infer::LateBoundRegionConversionTime::HigherRankedType;\n use rustc_infer::infer::{DefineOpaqueTypes, InferOk};\n use rustc_middle::traits::SelectionOutputTypeParameterMismatch;\n use rustc_middle::ty::{\n     self, Binder, GenericParamDefKind, InternalSubsts, SubstsRef, ToPolyTraitRef, ToPredicate,\n-    TraitRef, Ty, TyCtxt, TypeVisitableExt,\n+    TraitPredicate, TraitRef, Ty, TyCtxt, TypeVisitableExt,\n };\n use rustc_session::config::TraitSolver;\n use rustc_span::def_id::DefId;\n@@ -279,11 +280,60 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         ImplSourceBuiltinData { nested: obligations }\n     }\n \n+    #[instrument(level = \"debug\", skip(self))]\n     fn confirm_transmutability_candidate(\n         &mut self,\n         obligation: &TraitObligation<'tcx>,\n     ) -> Result<ImplSourceBuiltinData<PredicateObligation<'tcx>>, SelectionError<'tcx>> {\n-        debug!(?obligation, \"confirm_transmutability_candidate\");\n+        use rustc_transmute::{Answer, Condition};\n+        #[instrument(level = \"debug\", skip(tcx, obligation, predicate))]\n+        fn flatten_answer_tree<'tcx>(\n+            tcx: TyCtxt<'tcx>,\n+            obligation: &TraitObligation<'tcx>,\n+            predicate: TraitPredicate<'tcx>,\n+            cond: Condition<rustc_transmute::layout::rustc::Ref<'tcx>>,\n+        ) -> Vec<PredicateObligation<'tcx>> {\n+            match cond {\n+                // FIXME(bryangarza): Add separate `IfAny` case, instead of treating as `IfAll`\n+                // Not possible until the trait solver supports disjunctions of obligations\n+                Condition::IfAll(conds) | Condition::IfAny(conds) => conds\n+                    .into_iter()\n+                    .flat_map(|cond| flatten_answer_tree(tcx, obligation, predicate, cond))\n+                    .collect(),\n+                Condition::IfTransmutable { src, dst } => {\n+                    let trait_def_id = obligation.predicate.def_id();\n+                    let scope = predicate.trait_ref.substs.type_at(2);\n+                    let assume_const = predicate.trait_ref.substs.const_at(3);\n+                    let make_obl = |from_ty, to_ty| {\n+                        let trait_ref1 = ty::TraitRef::new(\n+                            tcx,\n+                            trait_def_id,\n+                            [\n+                                ty::GenericArg::from(to_ty),\n+                                ty::GenericArg::from(from_ty),\n+                                ty::GenericArg::from(scope),\n+                                ty::GenericArg::from(assume_const),\n+                            ],\n+                        );\n+                        Obligation::with_depth(\n+                            tcx,\n+                            obligation.cause.clone(),\n+                            obligation.recursion_depth + 1,\n+                            obligation.param_env,\n+                            trait_ref1,\n+                        )\n+                    };\n+\n+                    // If Dst is mutable, check bidirectionally.\n+                    // For example, transmuting bool -> u8 is OK as long as you can't update that u8\n+                    // to be > 1, because you could later transmute the u8 back to a bool and get UB.\n+                    match dst.mutability {\n+                        Mutability::Not => vec![make_obl(src.ty, dst.ty)],\n+                        Mutability::Mut => vec![make_obl(src.ty, dst.ty), make_obl(dst.ty, src.ty)],\n+                    }\n+                }\n+            }\n+        }\n \n         // We erase regions here because transmutability calls layout queries,\n         // which does not handle inference regions and doesn't particularly\n@@ -301,21 +351,25 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             return Err(Unimplemented);\n         };\n \n+        let dst = predicate.trait_ref.substs.type_at(0);\n+        let src = predicate.trait_ref.substs.type_at(1);\n+        debug!(?src, ?dst);\n         let mut transmute_env = rustc_transmute::TransmuteTypeEnv::new(self.infcx);\n         let maybe_transmutable = transmute_env.is_transmutable(\n             obligation.cause.clone(),\n-            rustc_transmute::Types {\n-                dst: predicate.trait_ref.substs.type_at(0),\n-                src: predicate.trait_ref.substs.type_at(1),\n-            },\n+            rustc_transmute::Types { dst, src },\n             predicate.trait_ref.substs.type_at(2),\n             assume,\n         );\n \n-        match maybe_transmutable {\n-            rustc_transmute::Answer::Yes => Ok(ImplSourceBuiltinData { nested: vec![] }),\n-            _ => Err(Unimplemented),\n-        }\n+        let fully_flattened = match maybe_transmutable {\n+            Answer::No(_) => Err(Unimplemented)?,\n+            Answer::If(cond) => flatten_answer_tree(self.tcx(), obligation, predicate, cond),\n+            Answer::Yes => vec![],\n+        };\n+\n+        debug!(?fully_flattened);\n+        Ok(ImplSourceBuiltinData { nested: fully_flattened })\n     }\n \n     /// This handles the case where an `auto trait Foo` impl is being used."}, {"sha": "76d97e0e6e7a62f4c4462e1299e4a30a64d06b50", "filename": "compiler/rustc_transmute/src/layout/mod.rs", "status": "modified", "additions": 29, "deletions": 13, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/3ed2a10d173d6c2e0232776af338ca7d080b1cd4/compiler%2Frustc_transmute%2Fsrc%2Flayout%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ed2a10d173d6c2e0232776af338ca7d080b1cd4/compiler%2Frustc_transmute%2Fsrc%2Flayout%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_transmute%2Fsrc%2Flayout%2Fmod.rs?ref=3ed2a10d173d6c2e0232776af338ca7d080b1cd4", "patch": "@@ -30,33 +30,49 @@ impl fmt::Debug for Byte {\n }\n \n pub(crate) trait Def: Debug + Hash + Eq + PartialEq + Copy + Clone {}\n-pub trait Ref: Debug + Hash + Eq + PartialEq + Copy + Clone {}\n+pub trait Ref: Debug + Hash + Eq + PartialEq + Copy + Clone {\n+    fn min_align(&self) -> usize;\n+\n+    fn is_mutable(&self) -> bool;\n+}\n \n impl Def for ! {}\n-impl Ref for ! {}\n+impl Ref for ! {\n+    fn min_align(&self) -> usize {\n+        unreachable!()\n+    }\n+    fn is_mutable(&self) -> bool {\n+        unreachable!()\n+    }\n+}\n \n #[cfg(feature = \"rustc\")]\n-pub(crate) mod rustc {\n+pub mod rustc {\n     use rustc_middle::mir::Mutability;\n-    use rustc_middle::ty;\n-    use rustc_middle::ty::Region;\n-    use rustc_middle::ty::Ty;\n+    use rustc_middle::ty::{self, Ty};\n \n     /// A reference in the layout.\n     #[derive(Debug, Hash, Eq, PartialEq, PartialOrd, Ord, Clone, Copy)]\n     pub struct Ref<'tcx> {\n-        lifetime: Region<'tcx>,\n-        ty: Ty<'tcx>,\n-        mutability: Mutability,\n+        pub lifetime: ty::Region<'tcx>,\n+        pub ty: Ty<'tcx>,\n+        pub mutability: Mutability,\n+        pub align: usize,\n     }\n \n-    impl<'tcx> super::Ref for Ref<'tcx> {}\n+    impl<'tcx> super::Ref for Ref<'tcx> {\n+        fn min_align(&self) -> usize {\n+            self.align\n+        }\n \n-    impl<'tcx> Ref<'tcx> {\n-        pub fn min_align(&self) -> usize {\n-            todo!()\n+        fn is_mutable(&self) -> bool {\n+            match self.mutability {\n+                Mutability::Mut => true,\n+                Mutability::Not => false,\n+            }\n         }\n     }\n+    impl<'tcx> Ref<'tcx> {}\n \n     /// A visibility node in the layout.\n     #[derive(Debug, Hash, Eq, PartialEq, Clone, Copy)]"}, {"sha": "6b718be7b1564c4cee1bcc5687db70757e310960", "filename": "compiler/rustc_transmute/src/layout/tree.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/3ed2a10d173d6c2e0232776af338ca7d080b1cd4/compiler%2Frustc_transmute%2Fsrc%2Flayout%2Ftree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ed2a10d173d6c2e0232776af338ca7d080b1cd4/compiler%2Frustc_transmute%2Fsrc%2Flayout%2Ftree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_transmute%2Fsrc%2Flayout%2Ftree.rs?ref=3ed2a10d173d6c2e0232776af338ca7d080b1cd4", "patch": "@@ -188,14 +188,14 @@ pub(crate) mod rustc {\n         /// The layout of the type is unspecified.\n         Unspecified,\n         /// This error will be surfaced elsewhere by rustc, so don't surface it.\n-        Unknown,\n+        UnknownLayout,\n         TypeError(ErrorGuaranteed),\n     }\n \n     impl<'tcx> From<LayoutError<'tcx>> for Err {\n         fn from(err: LayoutError<'tcx>) -> Self {\n             match err {\n-                LayoutError::Unknown(..) => Self::Unknown,\n+                LayoutError::Unknown(..) => Self::UnknownLayout,\n                 err => unimplemented!(\"{:?}\", err),\n             }\n         }\n@@ -365,6 +365,17 @@ pub(crate) mod rustc {\n                         }\n                     }))\n                 }\n+\n+                ty::Ref(lifetime, ty, mutability) => {\n+                    let align = layout_of(tcx, *ty)?.align();\n+                    Ok(Tree::Ref(Ref {\n+                        lifetime: *lifetime,\n+                        ty: *ty,\n+                        mutability: *mutability,\n+                        align,\n+                    }))\n+                }\n+\n                 _ => Err(Err::Unspecified),\n             }\n         }"}, {"sha": "34ad6bd8c6923a822183ab163e387614303ad97f", "filename": "compiler/rustc_transmute/src/lib.rs", "status": "modified", "additions": 23, "deletions": 13, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/3ed2a10d173d6c2e0232776af338ca7d080b1cd4/compiler%2Frustc_transmute%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ed2a10d173d6c2e0232776af338ca7d080b1cd4/compiler%2Frustc_transmute%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_transmute%2Fsrc%2Flib.rs?ref=3ed2a10d173d6c2e0232776af338ca7d080b1cd4", "patch": "@@ -8,7 +8,7 @@ extern crate tracing;\n \n pub(crate) use rustc_data_structures::fx::{FxIndexMap as Map, FxIndexSet as Set};\n \n-pub(crate) mod layout;\n+pub mod layout;\n pub(crate) mod maybe_transmutable;\n \n #[derive(Default)]\n@@ -19,29 +19,29 @@ pub struct Assume {\n     pub validity: bool,\n }\n \n-/// The type encodes answers to the question: \"Are these types transmutable?\"\n-#[derive(Debug, Hash, Eq, PartialEq, PartialOrd, Ord, Clone)]\n-pub enum Answer<R>\n-where\n-    R: layout::Ref,\n-{\n-    /// `Src` is transmutable into `Dst`.\n+/// Either we have an error, transmutation is allowed, or we have an optional\n+/// Condition that must hold.\n+#[derive(Debug, Hash, Eq, PartialEq, Clone)]\n+pub enum Answer<R> {\n     Yes,\n-\n-    /// `Src` is NOT transmutable into `Dst`.\n     No(Reason),\n+    If(Condition<R>),\n+}\n \n+/// A condition which must hold for safe transmutation to be possible.\n+#[derive(Debug, Hash, Eq, PartialEq, Clone)]\n+pub enum Condition<R> {\n     /// `Src` is transmutable into `Dst`, if `src` is transmutable into `dst`.\n     IfTransmutable { src: R, dst: R },\n \n     /// `Src` is transmutable into `Dst`, if all of the enclosed requirements are met.\n-    IfAll(Vec<Answer<R>>),\n+    IfAll(Vec<Condition<R>>),\n \n     /// `Src` is transmutable into `Dst` if any of the enclosed requirements are met.\n-    IfAny(Vec<Answer<R>>),\n+    IfAny(Vec<Condition<R>>),\n }\n \n-/// Answers: Why wasn't the source type transmutable into the destination type?\n+/// Answers \"why wasn't the source type transmutable into the destination type?\"\n #[derive(Debug, Hash, Eq, PartialEq, PartialOrd, Ord, Clone)]\n pub enum Reason {\n     /// The layout of the source type is unspecified.\n@@ -54,6 +54,16 @@ pub enum Reason {\n     DstIsPrivate,\n     /// `Dst` is larger than `Src`, and the excess bytes were not exclusively uninitialized.\n     DstIsTooBig,\n+    /// Src should have a stricter alignment than Dst, but it does not.\n+    DstHasStricterAlignment { src_min_align: usize, dst_min_align: usize },\n+    /// Can't go from shared pointer to unique pointer\n+    DstIsMoreUnique,\n+    /// Encountered a type error\n+    TypeError,\n+    /// The layout of src is unknown\n+    SrcLayoutUnknown,\n+    /// The layout of dst is unknown\n+    DstLayoutUnknown,\n }\n \n #[cfg(feature = \"rustc\")]"}, {"sha": "b223a90f7514b24132a72fb193a7296b7f8221f4", "filename": "compiler/rustc_transmute/src/maybe_transmutable/mod.rs", "status": "modified", "additions": 222, "deletions": 108, "changes": 330, "blob_url": "https://github.com/rust-lang/rust/blob/3ed2a10d173d6c2e0232776af338ca7d080b1cd4/compiler%2Frustc_transmute%2Fsrc%2Fmaybe_transmutable%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ed2a10d173d6c2e0232776af338ca7d080b1cd4/compiler%2Frustc_transmute%2Fsrc%2Fmaybe_transmutable%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_transmute%2Fsrc%2Fmaybe_transmutable%2Fmod.rs?ref=3ed2a10d173d6c2e0232776af338ca7d080b1cd4", "patch": "@@ -1,13 +1,13 @@\n-use crate::Map;\n-use crate::{Answer, Reason};\n-\n+pub(crate) mod query_context;\n #[cfg(test)]\n mod tests;\n \n-mod query_context;\n-use query_context::QueryContext;\n+use crate::{\n+    layout::{self, dfa, Byte, Dfa, Nfa, Ref, Tree, Uninhabited},\n+    maybe_transmutable::query_context::QueryContext,\n+    Answer, Condition, Map, Reason,\n+};\n \n-use crate::layout::{self, dfa, Byte, Dfa, Nfa, Tree, Uninhabited};\n pub(crate) struct MaybeTransmutableQuery<L, C>\n where\n     C: QueryContext,\n@@ -33,6 +33,7 @@ where\n         Self { src, dst, scope, assume, context }\n     }\n \n+    // FIXME(bryangarza): Delete this when all usages are removed\n     pub(crate) fn map_layouts<F, M>(\n         self,\n         f: F,\n@@ -53,6 +54,7 @@ where\n     }\n }\n \n+// FIXME: Nix this cfg, so we can write unit tests independently of rustc\n #[cfg(feature = \"rustc\")]\n mod rustc {\n     use super::*;\n@@ -66,30 +68,26 @@ mod rustc {\n         /// then computes an answer using those trees.\n         #[instrument(level = \"debug\", skip(self), fields(src = ?self.src, dst = ?self.dst))]\n         pub fn answer(self) -> Answer<<TyCtxt<'tcx> as QueryContext>::Ref> {\n-            let query_or_answer = self.map_layouts(|src, dst, scope, &context| {\n-                // Convert `src` and `dst` from their rustc representations, to `Tree`-based\n-                // representations. If these conversions fail, conclude that the transmutation is\n-                // unacceptable; the layouts of both the source and destination types must be\n-                // well-defined.\n-                let src = Tree::from_ty(src, context);\n-                let dst = Tree::from_ty(dst, context);\n-\n-                match (src, dst) {\n-                    // Answer `Yes` here, because 'unknown layout' and type errors will already\n-                    // be reported by rustc. No need to spam the user with more errors.\n-                    (Err(Err::TypeError(_)), _) => Err(Answer::Yes),\n-                    (_, Err(Err::TypeError(_))) => Err(Answer::Yes),\n-                    (Err(Err::Unknown), _) => Err(Answer::Yes),\n-                    (_, Err(Err::Unknown)) => Err(Answer::Yes),\n-                    (Err(Err::Unspecified), _) => Err(Answer::No(Reason::SrcIsUnspecified)),\n-                    (_, Err(Err::Unspecified)) => Err(Answer::No(Reason::DstIsUnspecified)),\n-                    (Ok(src), Ok(dst)) => Ok((src, dst)),\n-                }\n-            });\n+            let Self { src, dst, scope, assume, context } = self;\n+\n+            // Convert `src` and `dst` from their rustc representations, to `Tree`-based\n+            // representations. If these conversions fail, conclude that the transmutation is\n+            // unacceptable; the layouts of both the source and destination types must be\n+            // well-defined.\n+            let src = Tree::from_ty(src, context);\n+            let dst = Tree::from_ty(dst, context);\n \n-            match query_or_answer {\n-                Ok(query) => query.answer(),\n-                Err(answer) => answer,\n+            match (src, dst) {\n+                (Err(Err::TypeError(_)), _) | (_, Err(Err::TypeError(_))) => {\n+                    Answer::No(Reason::TypeError)\n+                }\n+                (Err(Err::UnknownLayout), _) => Answer::No(Reason::SrcLayoutUnknown),\n+                (_, Err(Err::UnknownLayout)) => Answer::No(Reason::DstLayoutUnknown),\n+                (Err(Err::Unspecified), _) => Answer::No(Reason::SrcIsUnspecified),\n+                (_, Err(Err::Unspecified)) => Answer::No(Reason::DstIsUnspecified),\n+                (Ok(src), Ok(dst)) => {\n+                    MaybeTransmutableQuery { src, dst, scope, assume, context }.answer()\n+                }\n             }\n         }\n     }\n@@ -107,6 +105,7 @@ where\n     #[instrument(level = \"debug\", skip(self), fields(src = ?self.src, dst = ?self.dst))]\n     pub(crate) fn answer(self) -> Answer<<C as QueryContext>::Ref> {\n         let assume_visibility = self.assume.safety;\n+        // FIXME(bryangarza): Refactor this code to get rid of `map_layouts`\n         let query_or_answer = self.map_layouts(|src, dst, scope, context| {\n             // Remove all `Def` nodes from `src`, without checking their visibility.\n             let src = src.prune(&|def| true);\n@@ -155,6 +154,7 @@ where\n     #[inline(always)]\n     #[instrument(level = \"debug\", skip(self), fields(src = ?self.src, dst = ?self.dst))]\n     pub(crate) fn answer(self) -> Answer<<C as QueryContext>::Ref> {\n+        // FIXME(bryangarza): Refactor this code to get rid of `map_layouts`\n         let query_or_answer = self\n             .map_layouts(|src, dst, scope, context| Ok((Dfa::from_nfa(src), Dfa::from_nfa(dst))));\n \n@@ -203,8 +203,29 @@ where\n         if let Some(answer) = cache.get(&(src_state, dst_state)) {\n             answer.clone()\n         } else {\n+            debug!(?src_state, ?dst_state);\n+            debug!(src = ?self.src);\n+            debug!(dst = ?self.dst);\n+            debug!(\n+                src_transitions_len = self.src.transitions.len(),\n+                dst_transitions_len = self.dst.transitions.len()\n+            );\n             let answer = if dst_state == self.dst.accepting {\n                 // truncation: `size_of(Src) >= size_of(Dst)`\n+                //\n+                // Why is truncation OK to do? Because even though the Src is bigger, all we care about\n+                // is whether we have enough data for the Dst to be valid in accordance with what its\n+                // type dictates.\n+                // For example, in a u8 to `()` transmutation, we have enough data available from the u8\n+                // to transmute it to a `()` (though in this case does `()` really need any data to\n+                // begin with? It doesn't). Same thing with u8 to fieldless struct.\n+                // Now then, why is something like u8 to bool not allowed? That is not because the bool\n+                // is smaller in size, but rather because those 2 bits that we are re-interpreting from\n+                // the u8 could introduce invalid states for the bool type.\n+                //\n+                // So, if it's possible to transmute to a smaller Dst by truncating, and we can guarantee\n+                // that none of the actually-used data can introduce an invalid state for Dst's type, we\n+                // are able to safely transmute, even with truncation.\n                 Answer::Yes\n             } else if src_state == self.src.accepting {\n                 // extension: `size_of(Src) >= size_of(Dst)`\n@@ -214,108 +235,201 @@ where\n                     Answer::No(Reason::DstIsTooBig)\n                 }\n             } else {\n-                let src_quantification = if self.assume.validity {\n+                let src_quantifier = if self.assume.validity {\n                     // if the compiler may assume that the programmer is doing additional validity checks,\n                     // (e.g.: that `src != 3u8` when the destination type is `bool`)\n                     // then there must exist at least one transition out of `src_state` such that the transmute is viable...\n-                    there_exists\n+                    Quantifier::ThereExists\n                 } else {\n                     // if the compiler cannot assume that the programmer is doing additional validity checks,\n                     // then for all transitions out of `src_state`, such that the transmute is viable...\n-                    // then there must exist at least one transition out of `src_state` such that the transmute is viable...\n-                    for_all\n+                    // then there must exist at least one transition out of `dst_state` such that the transmute is viable...\n+                    Quantifier::ForAll\n+                };\n+\n+                let bytes_answer = src_quantifier.apply(\n+                    // for each of the byte transitions out of the `src_state`...\n+                    self.src.bytes_from(src_state).unwrap_or(&Map::default()).into_iter().map(\n+                        |(&src_validity, &src_state_prime)| {\n+                            // ...try to find a matching transition out of `dst_state`.\n+                            if let Some(dst_state_prime) =\n+                                self.dst.byte_from(dst_state, src_validity)\n+                            {\n+                                self.answer_memo(cache, src_state_prime, dst_state_prime)\n+                            } else if let Some(dst_state_prime) =\n+                                // otherwise, see if `dst_state` has any outgoing `Uninit` transitions\n+                                // (any init byte is a valid uninit byte)\n+                                self.dst.byte_from(dst_state, Byte::Uninit)\n+                            {\n+                                self.answer_memo(cache, src_state_prime, dst_state_prime)\n+                            } else {\n+                                // otherwise, we've exhausted our options.\n+                                // the DFAs, from this point onwards, are bit-incompatible.\n+                                Answer::No(Reason::DstIsBitIncompatible)\n+                            }\n+                        },\n+                    ),\n+                );\n+\n+                // The below early returns reflect how this code would behave:\n+                //   if self.assume.validity {\n+                //       or(bytes_answer, refs_answer)\n+                //   } else {\n+                //       and(bytes_answer, refs_answer)\n+                //   }\n+                // ...if `refs_answer` was computed lazily. The below early\n+                // returns can be deleted without impacting the correctness of\n+                // the algoritm; only its performance.\n+                debug!(?bytes_answer);\n+                match bytes_answer {\n+                    Answer::No(_) if !self.assume.validity => return bytes_answer,\n+                    Answer::Yes if self.assume.validity => return bytes_answer,\n+                    _ => {}\n                 };\n \n-                src_quantification(\n-                    self.src.bytes_from(src_state).unwrap_or(&Map::default()),\n-                    |(&src_validity, &src_state_prime)| {\n-                        if let Some(dst_state_prime) = self.dst.byte_from(dst_state, src_validity) {\n-                            self.answer_memo(cache, src_state_prime, dst_state_prime)\n-                        } else if let Some(dst_state_prime) =\n-                            self.dst.byte_from(dst_state, Byte::Uninit)\n-                        {\n-                            self.answer_memo(cache, src_state_prime, dst_state_prime)\n-                        } else {\n-                            Answer::No(Reason::DstIsBitIncompatible)\n-                        }\n-                    },\n-                )\n+                let refs_answer = src_quantifier.apply(\n+                    // for each reference transition out of `src_state`...\n+                    self.src.refs_from(src_state).unwrap_or(&Map::default()).into_iter().map(\n+                        |(&src_ref, &src_state_prime)| {\n+                            // ...there exists a reference transition out of `dst_state`...\n+                            Quantifier::ThereExists.apply(\n+                                self.dst\n+                                    .refs_from(dst_state)\n+                                    .unwrap_or(&Map::default())\n+                                    .into_iter()\n+                                    .map(|(&dst_ref, &dst_state_prime)| {\n+                                        if !src_ref.is_mutable() && dst_ref.is_mutable() {\n+                                            Answer::No(Reason::DstIsMoreUnique)\n+                                        } else if !self.assume.alignment\n+                                            && src_ref.min_align() < dst_ref.min_align()\n+                                        {\n+                                            Answer::No(Reason::DstHasStricterAlignment {\n+                                                src_min_align: src_ref.min_align(),\n+                                                dst_min_align: dst_ref.min_align(),\n+                                            })\n+                                        } else {\n+                                            // ...such that `src` is transmutable into `dst`, if\n+                                            // `src_ref` is transmutability into `dst_ref`.\n+                                            and(\n+                                                Answer::If(Condition::IfTransmutable {\n+                                                    src: src_ref,\n+                                                    dst: dst_ref,\n+                                                }),\n+                                                self.answer_memo(\n+                                                    cache,\n+                                                    src_state_prime,\n+                                                    dst_state_prime,\n+                                                ),\n+                                            )\n+                                        }\n+                                    }),\n+                            )\n+                        },\n+                    ),\n+                );\n+\n+                if self.assume.validity {\n+                    or(bytes_answer, refs_answer)\n+                } else {\n+                    and(bytes_answer, refs_answer)\n+                }\n             };\n-            cache.insert((src_state, dst_state), answer.clone());\n+            if let Some(..) = cache.insert((src_state, dst_state), answer.clone()) {\n+                panic!(\"failed to correctly cache transmutability\")\n+            }\n             answer\n         }\n     }\n }\n \n-impl<R> Answer<R>\n+fn and<R>(lhs: Answer<R>, rhs: Answer<R>) -> Answer<R>\n where\n-    R: layout::Ref,\n+    R: PartialEq,\n {\n-    pub(crate) fn and(self, rhs: Self) -> Self {\n-        match (self, rhs) {\n-            (Self::No(reason), _) | (_, Self::No(reason)) => Self::No(reason),\n-            (Self::Yes, Self::Yes) => Self::Yes,\n-            (Self::IfAll(mut lhs), Self::IfAll(ref mut rhs)) => {\n-                lhs.append(rhs);\n-                Self::IfAll(lhs)\n-            }\n-            (constraint, Self::IfAll(mut constraints))\n-            | (Self::IfAll(mut constraints), constraint) => {\n-                constraints.push(constraint);\n-                Self::IfAll(constraints)\n-            }\n-            (lhs, rhs) => Self::IfAll(vec![lhs, rhs]),\n+    match (lhs, rhs) {\n+        // If both are errors, then we should return the more specific one\n+        (Answer::No(Reason::DstIsBitIncompatible), Answer::No(reason))\n+        | (Answer::No(reason), Answer::No(_))\n+        // If either is an error, return it\n+        | (Answer::No(reason), _) | (_, Answer::No(reason)) => Answer::No(reason),\n+        // If only one side has a condition, pass it along\n+        | (Answer::Yes, other) | (other, Answer::Yes) => other,\n+        // If both sides have IfAll conditions, merge them\n+        (Answer::If(Condition::IfAll(mut lhs)), Answer::If(Condition::IfAll(ref mut rhs))) => {\n+            lhs.append(rhs);\n+            Answer::If(Condition::IfAll(lhs))\n         }\n-    }\n-\n-    pub(crate) fn or(self, rhs: Self) -> Self {\n-        match (self, rhs) {\n-            (Self::Yes, _) | (_, Self::Yes) => Self::Yes,\n-            (Self::No(lhr), Self::No(rhr)) => Self::No(lhr),\n-            (Self::IfAny(mut lhs), Self::IfAny(ref mut rhs)) => {\n-                lhs.append(rhs);\n-                Self::IfAny(lhs)\n-            }\n-            (constraint, Self::IfAny(mut constraints))\n-            | (Self::IfAny(mut constraints), constraint) => {\n-                constraints.push(constraint);\n-                Self::IfAny(constraints)\n-            }\n-            (lhs, rhs) => Self::IfAny(vec![lhs, rhs]),\n+        // If only one side is an IfAll, add the other Condition to it\n+        (Answer::If(cond), Answer::If(Condition::IfAll(mut conds)))\n+        | (Answer::If(Condition::IfAll(mut conds)), Answer::If(cond)) => {\n+            conds.push(cond);\n+            Answer::If(Condition::IfAll(conds))\n         }\n+        // Otherwise, both lhs and rhs conditions can be combined in a parent IfAll\n+        (Answer::If(lhs), Answer::If(rhs)) => Answer::If(Condition::IfAll(vec![lhs, rhs])),\n     }\n }\n \n-pub fn for_all<R, I, F>(iter: I, f: F) -> Answer<R>\n+fn or<R>(lhs: Answer<R>, rhs: Answer<R>) -> Answer<R>\n where\n-    R: layout::Ref,\n-    I: IntoIterator,\n-    F: FnMut(<I as IntoIterator>::Item) -> Answer<R>,\n+    R: PartialEq,\n {\n-    use std::ops::ControlFlow::{Break, Continue};\n-    let (Continue(result) | Break(result)) =\n-        iter.into_iter().map(f).try_fold(Answer::Yes, |constraints, constraint| {\n-            match constraint.and(constraints) {\n-                Answer::No(reason) => Break(Answer::No(reason)),\n-                maybe => Continue(maybe),\n-            }\n-        });\n-    result\n+    match (lhs, rhs) {\n+        // If both are errors, then we should return the more specific one\n+        (Answer::No(Reason::DstIsBitIncompatible), Answer::No(reason))\n+        | (Answer::No(reason), Answer::No(_)) => Answer::No(reason),\n+        // Otherwise, errors can be ignored for the rest of the pattern matching\n+        (Answer::No(_), other) | (other, Answer::No(_)) => or(other, Answer::Yes),\n+        // If only one side has a condition, pass it along\n+        (Answer::Yes, other) | (other, Answer::Yes) => other,\n+        // If both sides have IfAny conditions, merge them\n+        (Answer::If(Condition::IfAny(mut lhs)), Answer::If(Condition::IfAny(ref mut rhs))) => {\n+            lhs.append(rhs);\n+            Answer::If(Condition::IfAny(lhs))\n+        }\n+        // If only one side is an IfAny, add the other Condition to it\n+        (Answer::If(cond), Answer::If(Condition::IfAny(mut conds)))\n+        | (Answer::If(Condition::IfAny(mut conds)), Answer::If(cond)) => {\n+            conds.push(cond);\n+            Answer::If(Condition::IfAny(conds))\n+        }\n+        // Otherwise, both lhs and rhs conditions can be combined in a parent IfAny\n+        (Answer::If(lhs), Answer::If(rhs)) => Answer::If(Condition::IfAny(vec![lhs, rhs])),\n+    }\n }\n \n-pub fn there_exists<R, I, F>(iter: I, f: F) -> Answer<R>\n-where\n-    R: layout::Ref,\n-    I: IntoIterator,\n-    F: FnMut(<I as IntoIterator>::Item) -> Answer<R>,\n-{\n-    use std::ops::ControlFlow::{Break, Continue};\n-    let (Continue(result) | Break(result)) = iter.into_iter().map(f).try_fold(\n-        Answer::No(Reason::DstIsBitIncompatible),\n-        |constraints, constraint| match constraint.or(constraints) {\n-            Answer::Yes => Break(Answer::Yes),\n-            maybe => Continue(maybe),\n-        },\n-    );\n-    result\n+pub enum Quantifier {\n+    ThereExists,\n+    ForAll,\n+}\n+\n+impl Quantifier {\n+    pub fn apply<R, I>(&self, iter: I) -> Answer<R>\n+    where\n+        R: layout::Ref,\n+        I: IntoIterator<Item = Answer<R>>,\n+    {\n+        use std::ops::ControlFlow::{Break, Continue};\n+\n+        let (init, try_fold_f): (_, fn(_, _) -> _) = match self {\n+            Self::ThereExists => {\n+                (Answer::No(Reason::DstIsBitIncompatible), |accum: Answer<R>, next| {\n+                    match or(accum, next) {\n+                        Answer::Yes => Break(Answer::Yes),\n+                        maybe => Continue(maybe),\n+                    }\n+                })\n+            }\n+            Self::ForAll => (Answer::Yes, |accum: Answer<R>, next| {\n+                let answer = and(accum, next);\n+                match answer {\n+                    Answer::No(_) => Break(answer),\n+                    maybe => Continue(maybe),\n+                }\n+            }),\n+        };\n+\n+        let (Continue(result) | Break(result)) = iter.into_iter().try_fold(init, try_fold_f);\n+        result\n+    }\n }"}, {"sha": "e49bebf571deae4cd028a44178114088058a1014", "filename": "compiler/rustc_transmute/src/maybe_transmutable/tests.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3ed2a10d173d6c2e0232776af338ca7d080b1cd4/compiler%2Frustc_transmute%2Fsrc%2Fmaybe_transmutable%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ed2a10d173d6c2e0232776af338ca7d080b1cd4/compiler%2Frustc_transmute%2Fsrc%2Fmaybe_transmutable%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_transmute%2Fsrc%2Fmaybe_transmutable%2Ftests.rs?ref=3ed2a10d173d6c2e0232776af338ca7d080b1cd4", "patch": "@@ -1,9 +1,11 @@\n use super::query_context::test::{Def, UltraMinimal};\n use crate::maybe_transmutable::MaybeTransmutableQuery;\n-use crate::{layout, Answer, Reason};\n+use crate::{layout, Reason};\n use itertools::Itertools;\n \n mod bool {\n+    use crate::Answer;\n+\n     use super::*;\n \n     #[test]"}, {"sha": "7f6090a6e4db567b5dd6250aa9829e5716379ef4", "filename": "tests/ui/transmutability/alignment/align-fail.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/3ed2a10d173d6c2e0232776af338ca7d080b1cd4/tests%2Fui%2Ftransmutability%2Falignment%2Falign-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ed2a10d173d6c2e0232776af338ca7d080b1cd4/tests%2Fui%2Ftransmutability%2Falignment%2Falign-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftransmutability%2Falignment%2Falign-fail.rs?ref=3ed2a10d173d6c2e0232776af338ca7d080b1cd4", "patch": "@@ -0,0 +1,23 @@\n+// check-fail\n+#![feature(transmutability)]\n+\n+mod assert {\n+    use std::mem::{Assume, BikeshedIntrinsicFrom};\n+    pub struct Context;\n+\n+    pub fn is_maybe_transmutable<Src, Dst>()\n+    where\n+        Dst: BikeshedIntrinsicFrom<Src, Context, {\n+            Assume {\n+                alignment: false,\n+                lifetimes: true,\n+                safety: true,\n+                validity: true,\n+            }\n+        }>\n+    {}\n+}\n+\n+fn main() {\n+    assert::is_maybe_transmutable::<&'static [u8; 0], &'static [u16; 0]>(); //~ ERROR `&[u8; 0]` cannot be safely transmuted into `&[u16; 0]`\n+}"}, {"sha": "59246fb1b0371fe6ea1c49fee219fee026642260", "filename": "tests/ui/transmutability/alignment/align-fail.stderr", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/3ed2a10d173d6c2e0232776af338ca7d080b1cd4/tests%2Fui%2Ftransmutability%2Falignment%2Falign-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3ed2a10d173d6c2e0232776af338ca7d080b1cd4/tests%2Fui%2Ftransmutability%2Falignment%2Falign-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftransmutability%2Falignment%2Falign-fail.stderr?ref=3ed2a10d173d6c2e0232776af338ca7d080b1cd4", "patch": "@@ -0,0 +1,30 @@\n+error[E0277]: `&[u8; 0]` cannot be safely transmuted into `&[u16; 0]` in the defining scope of `assert::Context`\n+  --> $DIR/align-fail.rs:22:55\n+   |\n+LL | ...tatic [u8; 0], &'static [u16; 0]>();\n+   |                   ^^^^^^^^^^^^^^^^^ The minimum alignment of `&[u8; 0]` (1) should be greater than that of `&[u16; 0]` (2)\n+   |\n+note: required by a bound in `is_maybe_transmutable`\n+  --> $DIR/align-fail.rs:10:14\n+   |\n+LL |       pub fn is_maybe_transmutable<Src, Dst>()\n+   |              --------------------- required by a bound in this function\n+LL |       where\n+LL |           Dst: BikeshedIntrinsicFrom<Src, Context, {\n+   |  ______________^\n+LL | |             Assume {\n+LL | |                 alignment: false,\n+LL | |                 lifetimes: true,\n+...  |\n+LL | |             }\n+LL | |         }>\n+   | |__________^ required by this bound in `is_maybe_transmutable`\n+help: consider removing the leading `&`-reference\n+   |\n+LL -     assert::is_maybe_transmutable::<&'static [u8; 0], &'static [u16; 0]>();\n+LL +     assert::is_maybe_transmutable::<&'static [u8; 0], [u16; 0]>();\n+   |\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "62dc672eacb9b1893807709931487576691bea36", "filename": "tests/ui/transmutability/alignment/align-pass.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/3ed2a10d173d6c2e0232776af338ca7d080b1cd4/tests%2Fui%2Ftransmutability%2Falignment%2Falign-pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ed2a10d173d6c2e0232776af338ca7d080b1cd4/tests%2Fui%2Ftransmutability%2Falignment%2Falign-pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftransmutability%2Falignment%2Falign-pass.rs?ref=3ed2a10d173d6c2e0232776af338ca7d080b1cd4", "patch": "@@ -0,0 +1,23 @@\n+// check-pass\n+#![feature(transmutability)]\n+\n+mod assert {\n+    use std::mem::{Assume, BikeshedIntrinsicFrom};\n+    pub struct Context;\n+\n+    pub fn is_maybe_transmutable<Src, Dst>()\n+    where\n+        Dst: BikeshedIntrinsicFrom<Src, Context, {\n+            Assume {\n+                alignment: false,\n+                lifetimes: false,\n+                safety: true,\n+                validity: false,\n+            }\n+        }>\n+    {}\n+}\n+\n+fn main() {\n+    assert::is_maybe_transmutable::<&'static [u16; 0], &'static [u8; 0]>();\n+}"}, {"sha": "46cdaa925630ac119fb5bf752b34a8cc060b0a6e", "filename": "tests/ui/transmutability/enums/repr/primitive_reprs_should_have_correct_length.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3ed2a10d173d6c2e0232776af338ca7d080b1cd4/tests%2Fui%2Ftransmutability%2Fenums%2Frepr%2Fprimitive_reprs_should_have_correct_length.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3ed2a10d173d6c2e0232776af338ca7d080b1cd4/tests%2Fui%2Ftransmutability%2Fenums%2Frepr%2Fprimitive_reprs_should_have_correct_length.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftransmutability%2Fenums%2Frepr%2Fprimitive_reprs_should_have_correct_length.stderr?ref=3ed2a10d173d6c2e0232776af338ca7d080b1cd4", "patch": "@@ -90,7 +90,7 @@ error[E0277]: `u8` cannot be safely transmuted into `V0i16` in the defining scop\n   --> $DIR/primitive_reprs_should_have_correct_length.rs:72:44\n    |\n LL |         assert::is_transmutable::<Smaller, Current, Context>();\n-   |                                            ^^^^^^^ At least one value of `u8` isn't a bit-valid value of `V0i16`\n+   |                                            ^^^^^^^ The size of `u8` is smaller than the size of `V0i16`\n    |\n note: required by a bound in `is_transmutable`\n   --> $DIR/primitive_reprs_should_have_correct_length.rs:12:14\n@@ -134,7 +134,7 @@ error[E0277]: `u8` cannot be safely transmuted into `V0u16` in the defining scop\n   --> $DIR/primitive_reprs_should_have_correct_length.rs:80:44\n    |\n LL |         assert::is_transmutable::<Smaller, Current, Context>();\n-   |                                            ^^^^^^^ At least one value of `u8` isn't a bit-valid value of `V0u16`\n+   |                                            ^^^^^^^ The size of `u8` is smaller than the size of `V0u16`\n    |\n note: required by a bound in `is_transmutable`\n   --> $DIR/primitive_reprs_should_have_correct_length.rs:12:14\n@@ -178,7 +178,7 @@ error[E0277]: `u16` cannot be safely transmuted into `V0i32` in the defining sco\n   --> $DIR/primitive_reprs_should_have_correct_length.rs:96:44\n    |\n LL |         assert::is_transmutable::<Smaller, Current, Context>();\n-   |                                            ^^^^^^^ At least one value of `u16` isn't a bit-valid value of `V0i32`\n+   |                                            ^^^^^^^ The size of `u16` is smaller than the size of `V0i32`\n    |\n note: required by a bound in `is_transmutable`\n   --> $DIR/primitive_reprs_should_have_correct_length.rs:12:14\n@@ -222,7 +222,7 @@ error[E0277]: `u16` cannot be safely transmuted into `V0u32` in the defining sco\n   --> $DIR/primitive_reprs_should_have_correct_length.rs:104:44\n    |\n LL |         assert::is_transmutable::<Smaller, Current, Context>();\n-   |                                            ^^^^^^^ At least one value of `u16` isn't a bit-valid value of `V0u32`\n+   |                                            ^^^^^^^ The size of `u16` is smaller than the size of `V0u32`\n    |\n note: required by a bound in `is_transmutable`\n   --> $DIR/primitive_reprs_should_have_correct_length.rs:12:14\n@@ -266,7 +266,7 @@ error[E0277]: `u32` cannot be safely transmuted into `V0i64` in the defining sco\n   --> $DIR/primitive_reprs_should_have_correct_length.rs:120:44\n    |\n LL |         assert::is_transmutable::<Smaller, Current, Context>();\n-   |                                            ^^^^^^^ At least one value of `u32` isn't a bit-valid value of `V0i64`\n+   |                                            ^^^^^^^ The size of `u32` is smaller than the size of `V0i64`\n    |\n note: required by a bound in `is_transmutable`\n   --> $DIR/primitive_reprs_should_have_correct_length.rs:12:14\n@@ -310,7 +310,7 @@ error[E0277]: `u32` cannot be safely transmuted into `V0u64` in the defining sco\n   --> $DIR/primitive_reprs_should_have_correct_length.rs:128:44\n    |\n LL |         assert::is_transmutable::<Smaller, Current, Context>();\n-   |                                            ^^^^^^^ At least one value of `u32` isn't a bit-valid value of `V0u64`\n+   |                                            ^^^^^^^ The size of `u32` is smaller than the size of `V0u64`\n    |\n note: required by a bound in `is_transmutable`\n   --> $DIR/primitive_reprs_should_have_correct_length.rs:12:14\n@@ -354,7 +354,7 @@ error[E0277]: `u8` cannot be safely transmuted into `V0isize` in the defining sc\n   --> $DIR/primitive_reprs_should_have_correct_length.rs:144:44\n    |\n LL |         assert::is_transmutable::<Smaller, Current, Context>();\n-   |                                            ^^^^^^^ At least one value of `u8` isn't a bit-valid value of `V0isize`\n+   |                                            ^^^^^^^ The size of `u8` is smaller than the size of `V0isize`\n    |\n note: required by a bound in `is_transmutable`\n   --> $DIR/primitive_reprs_should_have_correct_length.rs:12:14\n@@ -398,7 +398,7 @@ error[E0277]: `u8` cannot be safely transmuted into `V0usize` in the defining sc\n   --> $DIR/primitive_reprs_should_have_correct_length.rs:152:44\n    |\n LL |         assert::is_transmutable::<Smaller, Current, Context>();\n-   |                                            ^^^^^^^ At least one value of `u8` isn't a bit-valid value of `V0usize`\n+   |                                            ^^^^^^^ The size of `u8` is smaller than the size of `V0usize`\n    |\n note: required by a bound in `is_transmutable`\n   --> $DIR/primitive_reprs_should_have_correct_length.rs:12:14"}, {"sha": "8d19cabc0f9f022602b11a2a58aad58f2242a0f9", "filename": "tests/ui/transmutability/malformed-program-gracefulness/unknown_src_field.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3ed2a10d173d6c2e0232776af338ca7d080b1cd4/tests%2Fui%2Ftransmutability%2Fmalformed-program-gracefulness%2Funknown_src_field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ed2a10d173d6c2e0232776af338ca7d080b1cd4/tests%2Fui%2Ftransmutability%2Fmalformed-program-gracefulness%2Funknown_src_field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftransmutability%2Fmalformed-program-gracefulness%2Funknown_src_field.rs?ref=3ed2a10d173d6c2e0232776af338ca7d080b1cd4", "patch": "@@ -18,5 +18,5 @@ fn should_gracefully_handle_unknown_dst_field() {\n     struct Context;\n     #[repr(C)] struct Src;\n     #[repr(C)] struct Dst(Missing); //~ cannot find type\n-    assert::is_transmutable::<Src, Dst, Context>();\n+    assert::is_transmutable::<Src, Dst, Context>(); //~ ERROR cannot be safely transmuted\n }"}, {"sha": "c2df398b8ff91ee488e4fce987a8f4d3a22654fc", "filename": "tests/ui/transmutability/malformed-program-gracefulness/unknown_src_field.stderr", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3ed2a10d173d6c2e0232776af338ca7d080b1cd4/tests%2Fui%2Ftransmutability%2Fmalformed-program-gracefulness%2Funknown_src_field.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3ed2a10d173d6c2e0232776af338ca7d080b1cd4/tests%2Fui%2Ftransmutability%2Fmalformed-program-gracefulness%2Funknown_src_field.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftransmutability%2Fmalformed-program-gracefulness%2Funknown_src_field.stderr?ref=3ed2a10d173d6c2e0232776af338ca7d080b1cd4", "patch": "@@ -4,6 +4,22 @@ error[E0412]: cannot find type `Missing` in this scope\n LL |     #[repr(C)] struct Dst(Missing);\n    |                           ^^^^^^^ not found in this scope\n \n-error: aborting due to previous error\n+error[E0277]: `Src` cannot be safely transmuted into `Dst` in the defining scope of `should_gracefully_handle_unknown_dst_field::Context`\n+  --> $DIR/unknown_src_field.rs:21:36\n+   |\n+LL |     assert::is_transmutable::<Src, Dst, Context>();\n+   |                                    ^^^ `Dst` has an unknown layout\n+   |\n+note: required by a bound in `is_transmutable`\n+  --> $DIR/unknown_src_field.rs:13:14\n+   |\n+LL |     pub fn is_transmutable<Src, Dst, Context>()\n+   |            --------------- required by a bound in this function\n+LL |     where\n+LL |         Dst: BikeshedIntrinsicFrom<Src, Context>\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `is_transmutable`\n+\n+error: aborting due to 2 previous errors\n \n-For more information about this error, try `rustc --explain E0412`.\n+Some errors have detailed explanations: E0277, E0412.\n+For more information about an error, try `rustc --explain E0277`."}, {"sha": "49dbe90e4b8b3b960c2e992e5b177da97e31c870", "filename": "tests/ui/transmutability/primitives/bool-mut.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/3ed2a10d173d6c2e0232776af338ca7d080b1cd4/tests%2Fui%2Ftransmutability%2Fprimitives%2Fbool-mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ed2a10d173d6c2e0232776af338ca7d080b1cd4/tests%2Fui%2Ftransmutability%2Fprimitives%2Fbool-mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftransmutability%2Fprimitives%2Fbool-mut.rs?ref=3ed2a10d173d6c2e0232776af338ca7d080b1cd4", "patch": "@@ -0,0 +1,17 @@\n+// check-fail\n+//[next] compile-flags: -Ztrait-solver=next\n+\n+#![feature(transmutability)]\n+mod assert {\n+    use std::mem::{Assume, BikeshedIntrinsicFrom};\n+    pub struct Context;\n+\n+    pub fn is_transmutable<Src, Dst>()\n+    where\n+        Dst: BikeshedIntrinsicFrom<Src, Context, { Assume::SAFETY }>\n+    {}\n+}\n+\n+fn main() {\n+    assert::is_transmutable::<&'static mut bool, &'static mut u8>() //~ ERROR cannot be safely transmuted\n+}"}, {"sha": "b36991e1c01c65cd470e4cbcd7a62910be2eff80", "filename": "tests/ui/transmutability/primitives/bool-mut.stderr", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3ed2a10d173d6c2e0232776af338ca7d080b1cd4/tests%2Fui%2Ftransmutability%2Fprimitives%2Fbool-mut.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3ed2a10d173d6c2e0232776af338ca7d080b1cd4/tests%2Fui%2Ftransmutability%2Fprimitives%2Fbool-mut.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftransmutability%2Fprimitives%2Fbool-mut.stderr?ref=3ed2a10d173d6c2e0232776af338ca7d080b1cd4", "patch": "@@ -0,0 +1,18 @@\n+error[E0277]: `u8` cannot be safely transmuted into `bool` in the defining scope of `assert::Context`\n+  --> $DIR/bool-mut.rs:16:50\n+   |\n+LL |     assert::is_transmutable::<&'static mut bool, &'static mut u8>()\n+   |                                                  ^^^^^^^^^^^^^^^ At least one value of `u8` isn't a bit-valid value of `bool`\n+   |\n+note: required by a bound in `is_transmutable`\n+  --> $DIR/bool-mut.rs:11:14\n+   |\n+LL |     pub fn is_transmutable<Src, Dst>()\n+   |            --------------- required by a bound in this function\n+LL |     where\n+LL |         Dst: BikeshedIntrinsicFrom<Src, Context, { Assume::SAFETY }>\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `is_transmutable`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "4b3eb6c517d91fb7ce96d5f7b9e4c6b6e43e67ff", "filename": "tests/ui/transmutability/primitives/bool.current.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3ed2a10d173d6c2e0232776af338ca7d080b1cd4/tests%2Fui%2Ftransmutability%2Fprimitives%2Fbool.current.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3ed2a10d173d6c2e0232776af338ca7d080b1cd4/tests%2Fui%2Ftransmutability%2Fprimitives%2Fbool.current.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftransmutability%2Fprimitives%2Fbool.current.stderr?ref=3ed2a10d173d6c2e0232776af338ca7d080b1cd4", "patch": "@@ -1,11 +1,11 @@\n error[E0277]: `u8` cannot be safely transmuted into `bool` in the defining scope of `assert::Context`\n-  --> $DIR/bool.rs:24:35\n+  --> $DIR/bool.rs:21:35\n    |\n LL |     assert::is_transmutable::<u8, bool>();\n    |                                   ^^^^ At least one value of `u8` isn't a bit-valid value of `bool`\n    |\n note: required by a bound in `is_transmutable`\n-  --> $DIR/bool.rs:14:14\n+  --> $DIR/bool.rs:11:14\n    |\n LL |     pub fn is_transmutable<Src, Dst>()\n    |            --------------- required by a bound in this function"}, {"sha": "4b3eb6c517d91fb7ce96d5f7b9e4c6b6e43e67ff", "filename": "tests/ui/transmutability/primitives/bool.next.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3ed2a10d173d6c2e0232776af338ca7d080b1cd4/tests%2Fui%2Ftransmutability%2Fprimitives%2Fbool.next.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3ed2a10d173d6c2e0232776af338ca7d080b1cd4/tests%2Fui%2Ftransmutability%2Fprimitives%2Fbool.next.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftransmutability%2Fprimitives%2Fbool.next.stderr?ref=3ed2a10d173d6c2e0232776af338ca7d080b1cd4", "patch": "@@ -1,11 +1,11 @@\n error[E0277]: `u8` cannot be safely transmuted into `bool` in the defining scope of `assert::Context`\n-  --> $DIR/bool.rs:24:35\n+  --> $DIR/bool.rs:21:35\n    |\n LL |     assert::is_transmutable::<u8, bool>();\n    |                                   ^^^^ At least one value of `u8` isn't a bit-valid value of `bool`\n    |\n note: required by a bound in `is_transmutable`\n-  --> $DIR/bool.rs:14:14\n+  --> $DIR/bool.rs:11:14\n    |\n LL |     pub fn is_transmutable<Src, Dst>()\n    |            --------------- required by a bound in this function"}, {"sha": "654e7b47edecc40a53bbb62fbcf2af175ce54a0c", "filename": "tests/ui/transmutability/primitives/bool.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3ed2a10d173d6c2e0232776af338ca7d080b1cd4/tests%2Fui%2Ftransmutability%2Fprimitives%2Fbool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ed2a10d173d6c2e0232776af338ca7d080b1cd4/tests%2Fui%2Ftransmutability%2Fprimitives%2Fbool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftransmutability%2Fprimitives%2Fbool.rs?ref=3ed2a10d173d6c2e0232776af338ca7d080b1cd4", "patch": "@@ -1,10 +1,7 @@\n // revisions: current next\n //[next] compile-flags: -Ztrait-solver=next\n \n-#![crate_type = \"lib\"]\n #![feature(transmutability)]\n-#![allow(dead_code)]\n-#![allow(incomplete_features)]\n mod assert {\n     use std::mem::{Assume, BikeshedIntrinsicFrom};\n     pub struct Context;\n@@ -20,7 +17,7 @@ mod assert {\n     {}\n }\n \n-fn contrast_with_u8() {\n+fn main() {\n     assert::is_transmutable::<u8, bool>(); //~ ERROR cannot be safely transmuted\n     assert::is_maybe_transmutable::<u8, bool>();\n     assert::is_transmutable::<bool, u8>();"}, {"sha": "a6e2889d3f23d580b0e40cdb63a7d54510192f93", "filename": "tests/ui/transmutability/references/recursive-wrapper-types-bit-compatible-mut.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/3ed2a10d173d6c2e0232776af338ca7d080b1cd4/tests%2Fui%2Ftransmutability%2Freferences%2Frecursive-wrapper-types-bit-compatible-mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ed2a10d173d6c2e0232776af338ca7d080b1cd4/tests%2Fui%2Ftransmutability%2Freferences%2Frecursive-wrapper-types-bit-compatible-mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftransmutability%2Freferences%2Frecursive-wrapper-types-bit-compatible-mut.rs?ref=3ed2a10d173d6c2e0232776af338ca7d080b1cd4", "patch": "@@ -0,0 +1,25 @@\n+// check-fail\n+#![feature(transmutability)]\n+\n+mod assert {\n+    use std::mem::{Assume, BikeshedIntrinsicFrom};\n+    pub struct Context;\n+\n+    pub fn is_maybe_transmutable<Src, Dst>()\n+    where\n+        Dst: BikeshedIntrinsicFrom<Src, Context, {\n+            Assume {\n+                alignment: true,\n+                lifetimes: false,\n+                safety: true,\n+                validity: false,\n+            }\n+        }>\n+    {}\n+}\n+\n+fn main() {\n+    #[repr(C)] struct A(bool, &'static A);\n+    #[repr(C)] struct B(u8, &'static B);\n+    assert::is_maybe_transmutable::<&'static A, &'static mut B>(); //~ ERROR cannot be safely transmuted\n+}"}, {"sha": "4b4d6ad0298ee41a5a59480d2d2c721bb29d9844", "filename": "tests/ui/transmutability/references/recursive-wrapper-types-bit-compatible-mut.stderr", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/3ed2a10d173d6c2e0232776af338ca7d080b1cd4/tests%2Fui%2Ftransmutability%2Freferences%2Frecursive-wrapper-types-bit-compatible-mut.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3ed2a10d173d6c2e0232776af338ca7d080b1cd4/tests%2Fui%2Ftransmutability%2Freferences%2Frecursive-wrapper-types-bit-compatible-mut.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftransmutability%2Freferences%2Frecursive-wrapper-types-bit-compatible-mut.stderr?ref=3ed2a10d173d6c2e0232776af338ca7d080b1cd4", "patch": "@@ -0,0 +1,25 @@\n+error[E0277]: `&A` cannot be safely transmuted into `&mut B` in the defining scope of `assert::Context`\n+  --> $DIR/recursive-wrapper-types-bit-compatible-mut.rs:24:49\n+   |\n+LL |     assert::is_maybe_transmutable::<&'static A, &'static mut B>();\n+   |                                                 ^^^^^^^^^^^^^^ `&A` is a shared reference, but `&mut B` is a unique reference\n+   |\n+note: required by a bound in `is_maybe_transmutable`\n+  --> $DIR/recursive-wrapper-types-bit-compatible-mut.rs:10:14\n+   |\n+LL |       pub fn is_maybe_transmutable<Src, Dst>()\n+   |              --------------------- required by a bound in this function\n+LL |       where\n+LL |           Dst: BikeshedIntrinsicFrom<Src, Context, {\n+   |  ______________^\n+LL | |             Assume {\n+LL | |                 alignment: true,\n+LL | |                 lifetimes: false,\n+...  |\n+LL | |             }\n+LL | |         }>\n+   | |__________^ required by this bound in `is_maybe_transmutable`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "3ea80173afaa985772e73108356469c763ea09c8", "filename": "tests/ui/transmutability/references/recursive-wrapper-types-bit-compatible.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/3ed2a10d173d6c2e0232776af338ca7d080b1cd4/tests%2Fui%2Ftransmutability%2Freferences%2Frecursive-wrapper-types-bit-compatible.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ed2a10d173d6c2e0232776af338ca7d080b1cd4/tests%2Fui%2Ftransmutability%2Freferences%2Frecursive-wrapper-types-bit-compatible.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftransmutability%2Freferences%2Frecursive-wrapper-types-bit-compatible.rs?ref=3ed2a10d173d6c2e0232776af338ca7d080b1cd4", "patch": "@@ -0,0 +1,26 @@\n+// check-fail\n+// FIXME(bryangarza): Change to check-pass when coinduction is supported for BikeshedIntrinsicFrom\n+#![feature(transmutability)]\n+\n+mod assert {\n+    use std::mem::{Assume, BikeshedIntrinsicFrom};\n+    pub struct Context;\n+\n+    pub fn is_maybe_transmutable<Src, Dst>()\n+    where\n+        Dst: BikeshedIntrinsicFrom<Src, Context, {\n+            Assume {\n+                alignment: true,\n+                lifetimes: false,\n+                safety: true,\n+                validity: false,\n+            }\n+        }>\n+    {}\n+}\n+\n+fn main() {\n+    #[repr(C)] struct A(bool, &'static A);\n+    #[repr(C)] struct B(u8, &'static B);\n+    assert::is_maybe_transmutable::<&'static A, &'static B>(); //~ ERROR overflow evaluating the requirement\n+}"}, {"sha": "fae332e6af93265e1ba27f02905a8bcb99544f0d", "filename": "tests/ui/transmutability/references/recursive-wrapper-types-bit-compatible.stderr", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/3ed2a10d173d6c2e0232776af338ca7d080b1cd4/tests%2Fui%2Ftransmutability%2Freferences%2Frecursive-wrapper-types-bit-compatible.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3ed2a10d173d6c2e0232776af338ca7d080b1cd4/tests%2Fui%2Ftransmutability%2Freferences%2Frecursive-wrapper-types-bit-compatible.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftransmutability%2Freferences%2Frecursive-wrapper-types-bit-compatible.stderr?ref=3ed2a10d173d6c2e0232776af338ca7d080b1cd4", "patch": "@@ -0,0 +1,25 @@\n+error[E0275]: overflow evaluating the requirement `B: BikeshedIntrinsicFrom<A, assert::Context, Assume { alignment: true, lifetimes: false, safety: true, validity: false }>`\n+  --> $DIR/recursive-wrapper-types-bit-compatible.rs:25:5\n+   |\n+LL |     assert::is_maybe_transmutable::<&'static A, &'static B>();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: required by a bound in `is_maybe_transmutable`\n+  --> $DIR/recursive-wrapper-types-bit-compatible.rs:11:14\n+   |\n+LL |       pub fn is_maybe_transmutable<Src, Dst>()\n+   |              --------------------- required by a bound in this function\n+LL |       where\n+LL |           Dst: BikeshedIntrinsicFrom<Src, Context, {\n+   |  ______________^\n+LL | |             Assume {\n+LL | |                 alignment: true,\n+LL | |                 lifetimes: false,\n+...  |\n+LL | |             }\n+LL | |         }>\n+   | |__________^ required by this bound in `is_maybe_transmutable`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0275`."}, {"sha": "e8582d2fd021279a11f446a2b337adc3b85180d8", "filename": "tests/ui/transmutability/references/recursive-wrapper-types-bit-incompatible.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/3ed2a10d173d6c2e0232776af338ca7d080b1cd4/tests%2Fui%2Ftransmutability%2Freferences%2Frecursive-wrapper-types-bit-incompatible.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ed2a10d173d6c2e0232776af338ca7d080b1cd4/tests%2Fui%2Ftransmutability%2Freferences%2Frecursive-wrapper-types-bit-incompatible.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftransmutability%2Freferences%2Frecursive-wrapper-types-bit-incompatible.rs?ref=3ed2a10d173d6c2e0232776af338ca7d080b1cd4", "patch": "@@ -0,0 +1,25 @@\n+// check-fail\n+#![feature(transmutability)]\n+\n+mod assert {\n+    use std::mem::{Assume, BikeshedIntrinsicFrom};\n+    pub struct Context;\n+\n+    pub fn is_maybe_transmutable<Src, Dst>()\n+    where\n+        Dst: BikeshedIntrinsicFrom<Src, Context, {\n+            Assume {\n+                alignment: true,\n+                lifetimes: false,\n+                safety: true,\n+                validity: false,\n+            }\n+        }>\n+    {}\n+}\n+\n+fn main() {\n+    #[repr(C)] struct A(bool, &'static A);\n+    #[repr(C)] struct B(u8, &'static B);\n+    assert::is_maybe_transmutable::<&'static B, &'static A>(); //~ ERROR cannot be safely transmuted\n+}"}, {"sha": "ecfe4865962f72d84a1b9fbd1134c7b07a3adced", "filename": "tests/ui/transmutability/references/recursive-wrapper-types-bit-incompatible.stderr", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/3ed2a10d173d6c2e0232776af338ca7d080b1cd4/tests%2Fui%2Ftransmutability%2Freferences%2Frecursive-wrapper-types-bit-incompatible.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3ed2a10d173d6c2e0232776af338ca7d080b1cd4/tests%2Fui%2Ftransmutability%2Freferences%2Frecursive-wrapper-types-bit-incompatible.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftransmutability%2Freferences%2Frecursive-wrapper-types-bit-incompatible.stderr?ref=3ed2a10d173d6c2e0232776af338ca7d080b1cd4", "patch": "@@ -0,0 +1,25 @@\n+error[E0277]: `B` cannot be safely transmuted into `A` in the defining scope of `assert::Context`\n+  --> $DIR/recursive-wrapper-types-bit-incompatible.rs:24:49\n+   |\n+LL |     assert::is_maybe_transmutable::<&'static B, &'static A>();\n+   |                                                 ^^^^^^^^^^ At least one value of `B` isn't a bit-valid value of `A`\n+   |\n+note: required by a bound in `is_maybe_transmutable`\n+  --> $DIR/recursive-wrapper-types-bit-incompatible.rs:10:14\n+   |\n+LL |       pub fn is_maybe_transmutable<Src, Dst>()\n+   |              --------------------- required by a bound in this function\n+LL |       where\n+LL |           Dst: BikeshedIntrinsicFrom<Src, Context, {\n+   |  ______________^\n+LL | |             Assume {\n+LL | |                 alignment: true,\n+LL | |                 lifetimes: false,\n+...  |\n+LL | |             }\n+LL | |         }>\n+   | |__________^ required by this bound in `is_maybe_transmutable`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "59d1ad84a5d4c16e7780fe3aa940ea433c459bf2", "filename": "tests/ui/transmutability/references/recursive-wrapper-types.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/3ed2a10d173d6c2e0232776af338ca7d080b1cd4/tests%2Fui%2Ftransmutability%2Freferences%2Frecursive-wrapper-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ed2a10d173d6c2e0232776af338ca7d080b1cd4/tests%2Fui%2Ftransmutability%2Freferences%2Frecursive-wrapper-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftransmutability%2Freferences%2Frecursive-wrapper-types.rs?ref=3ed2a10d173d6c2e0232776af338ca7d080b1cd4", "patch": "@@ -0,0 +1,27 @@\n+// check-fail\n+// FIXME(bryangarza): Change to check-pass when coinduction is supported for BikeshedIntrinsicFrom\n+#![feature(transmutability)]\n+\n+mod assert {\n+    use std::mem::{Assume, BikeshedIntrinsicFrom};\n+    pub struct Context;\n+\n+    pub fn is_maybe_transmutable<Src, Dst>()\n+    where\n+        Dst: BikeshedIntrinsicFrom<Src, Context, {\n+            Assume {\n+                alignment: true,\n+                lifetimes: false,\n+                safety: true,\n+                validity: false,\n+            }\n+        }>\n+    {}\n+}\n+\n+fn main() {\n+    #[repr(C)] struct A(&'static B);\n+    #[repr(C)] struct B(&'static A);\n+    assert::is_maybe_transmutable::<&'static A, &'static B>(); //~ overflow evaluating the requirement\n+    assert::is_maybe_transmutable::<&'static B, &'static A>();\n+}"}, {"sha": "35a60c226437aafb18a2811e741a5c3328877b47", "filename": "tests/ui/transmutability/references/recursive-wrapper-types.stderr", "status": "renamed", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3ed2a10d173d6c2e0232776af338ca7d080b1cd4/tests%2Fui%2Ftransmutability%2Freferences%2Frecursive-wrapper-types.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3ed2a10d173d6c2e0232776af338ca7d080b1cd4/tests%2Fui%2Ftransmutability%2Freferences%2Frecursive-wrapper-types.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftransmutability%2Freferences%2Frecursive-wrapper-types.stderr?ref=3ed2a10d173d6c2e0232776af338ca7d080b1cd4", "patch": "@@ -1,11 +1,11 @@\n-error[E0277]: `&Unit` cannot be safely transmuted into `&Unit` in the defining scope of `assert::Context`\n-  --> $DIR/references.rs:29:52\n+error[E0275]: overflow evaluating the requirement `A: BikeshedIntrinsicFrom<B, assert::Context, Assume { alignment: true, lifetimes: false, safety: true, validity: false }>`\n+  --> $DIR/recursive-wrapper-types.rs:25:5\n    |\n-LL |     assert::is_maybe_transmutable::<&'static Unit, &'static Unit>();\n-   |                                                    ^^^^^^^^^^^^^ `&Unit` does not have a well-specified layout\n+LL |     assert::is_maybe_transmutable::<&'static A, &'static B>();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n note: required by a bound in `is_maybe_transmutable`\n-  --> $DIR/references.rs:16:14\n+  --> $DIR/recursive-wrapper-types.rs:11:14\n    |\n LL |       pub fn is_maybe_transmutable<Src, Dst>()\n    |              --------------------- required by a bound in this function\n@@ -14,12 +14,12 @@ LL |           Dst: BikeshedIntrinsicFrom<Src, Context, {\n    |  ______________^\n LL | |             Assume {\n LL | |                 alignment: true,\n-LL | |                 lifetimes: true,\n+LL | |                 lifetimes: false,\n ...  |\n LL | |             }\n LL | |         }>\n    | |__________^ required by this bound in `is_maybe_transmutable`\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0277`.\n+For more information about this error, try `rustc --explain E0275`.", "previous_filename": "tests/ui/transmutability/references.next.stderr"}, {"sha": "8b37492bd6b1cc3d0123c413c6910c40993a9b3f", "filename": "tests/ui/transmutability/references/u8-to-unit.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/3ed2a10d173d6c2e0232776af338ca7d080b1cd4/tests%2Fui%2Ftransmutability%2Freferences%2Fu8-to-unit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ed2a10d173d6c2e0232776af338ca7d080b1cd4/tests%2Fui%2Ftransmutability%2Freferences%2Fu8-to-unit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftransmutability%2Freferences%2Fu8-to-unit.rs?ref=3ed2a10d173d6c2e0232776af338ca7d080b1cd4", "patch": "@@ -0,0 +1,24 @@\n+// check-pass\n+#![feature(transmutability)]\n+\n+mod assert {\n+    use std::mem::{Assume, BikeshedIntrinsicFrom};\n+    pub struct Context;\n+\n+    pub fn is_maybe_transmutable<Src, Dst>()\n+    where\n+        Dst: BikeshedIntrinsicFrom<Src, Context, {\n+            Assume {\n+                alignment: false,\n+                lifetimes: true,\n+                safety: true,\n+                validity: false,\n+            }\n+        }>\n+    {}\n+}\n+\n+fn main() {\n+    #[repr(C)] struct Unit;\n+    assert::is_maybe_transmutable::<&'static u8, &'static Unit>();\n+}"}, {"sha": "04a7e16d7cccc2b74bdb62b70ec842853d53c0c3", "filename": "tests/ui/transmutability/references/unit-to-itself.rs", "status": "renamed", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3ed2a10d173d6c2e0232776af338ca7d080b1cd4/tests%2Fui%2Ftransmutability%2Freferences%2Funit-to-itself.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ed2a10d173d6c2e0232776af338ca7d080b1cd4/tests%2Fui%2Ftransmutability%2Freferences%2Funit-to-itself.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftransmutability%2Freferences%2Funit-to-itself.rs?ref=3ed2a10d173d6c2e0232776af338ca7d080b1cd4", "patch": "@@ -1,11 +1,5 @@\n-// revisions: current next\n-//[next] compile-flags: -Ztrait-solver=next\n-\n-//! Transmutations involving references are not yet supported.\n-\n-#![crate_type = \"lib\"]\n+// check-pass\n #![feature(transmutability)]\n-#![allow(dead_code, incomplete_features, non_camel_case_types)]\n \n mod assert {\n     use std::mem::{Assume, BikeshedIntrinsicFrom};\n@@ -16,15 +10,15 @@ mod assert {\n         Dst: BikeshedIntrinsicFrom<Src, Context, {\n             Assume {\n                 alignment: true,\n-                lifetimes: true,\n+                lifetimes: false,\n                 safety: true,\n-                validity: true,\n+                validity: false,\n             }\n         }>\n     {}\n }\n \n-fn not_yet_implemented() {\n+fn main() {\n     #[repr(C)] struct Unit;\n-    assert::is_maybe_transmutable::<&'static Unit, &'static Unit>(); //~ ERROR cannot be safely transmuted\n+    assert::is_maybe_transmutable::<&'static Unit, &'static Unit>();\n }", "previous_filename": "tests/ui/transmutability/references.rs"}, {"sha": "eff516e9a9691c1dbc5ebb1a1019b3f7913b053b", "filename": "tests/ui/transmutability/references/unit-to-u8.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/3ed2a10d173d6c2e0232776af338ca7d080b1cd4/tests%2Fui%2Ftransmutability%2Freferences%2Funit-to-u8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ed2a10d173d6c2e0232776af338ca7d080b1cd4/tests%2Fui%2Ftransmutability%2Freferences%2Funit-to-u8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftransmutability%2Freferences%2Funit-to-u8.rs?ref=3ed2a10d173d6c2e0232776af338ca7d080b1cd4", "patch": "@@ -0,0 +1,24 @@\n+// check-fail\n+#![feature(transmutability)]\n+\n+mod assert {\n+    use std::mem::{Assume, BikeshedIntrinsicFrom};\n+    pub struct Context;\n+\n+    pub fn is_maybe_transmutable<Src, Dst>()\n+    where\n+        Dst: BikeshedIntrinsicFrom<Src, Context, {\n+            Assume {\n+                alignment: true,\n+                lifetimes: true,\n+                safety: true,\n+                validity: false,\n+            }\n+        }>\n+    {}\n+}\n+\n+fn main() {\n+    #[repr(C)] struct Unit;\n+    assert::is_maybe_transmutable::<&'static Unit, &'static u8>(); //~ ERROR cannot be safely transmuted\n+}"}, {"sha": "f2b72357f792b7ced043a4eb7a4ec0bf7d83df50", "filename": "tests/ui/transmutability/references/unit-to-u8.stderr", "status": "renamed", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3ed2a10d173d6c2e0232776af338ca7d080b1cd4/tests%2Fui%2Ftransmutability%2Freferences%2Funit-to-u8.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3ed2a10d173d6c2e0232776af338ca7d080b1cd4/tests%2Fui%2Ftransmutability%2Freferences%2Funit-to-u8.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftransmutability%2Freferences%2Funit-to-u8.stderr?ref=3ed2a10d173d6c2e0232776af338ca7d080b1cd4", "patch": "@@ -1,11 +1,11 @@\n-error[E0277]: `&Unit` cannot be safely transmuted into `&Unit` in the defining scope of `assert::Context`\n-  --> $DIR/references.rs:29:52\n+error[E0277]: `Unit` cannot be safely transmuted into `u8` in the defining scope of `assert::Context`\n+  --> $DIR/unit-to-u8.rs:23:52\n    |\n-LL |     assert::is_maybe_transmutable::<&'static Unit, &'static Unit>();\n-   |                                                    ^^^^^^^^^^^^^ `&Unit` does not have a well-specified layout\n+LL |     assert::is_maybe_transmutable::<&'static Unit, &'static u8>();\n+   |                                                    ^^^^^^^^^^^ The size of `Unit` is smaller than the size of `u8`\n    |\n note: required by a bound in `is_maybe_transmutable`\n-  --> $DIR/references.rs:16:14\n+  --> $DIR/unit-to-u8.rs:10:14\n    |\n LL |       pub fn is_maybe_transmutable<Src, Dst>()\n    |              --------------------- required by a bound in this function", "previous_filename": "tests/ui/transmutability/references.current.stderr"}, {"sha": "307d0dfe50d2258a990ad1daf2f9283e7ea0a568", "filename": "tests/ui/transmutability/region-infer.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3ed2a10d173d6c2e0232776af338ca7d080b1cd4/tests%2Fui%2Ftransmutability%2Fregion-infer.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3ed2a10d173d6c2e0232776af338ca7d080b1cd4/tests%2Fui%2Ftransmutability%2Fregion-infer.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftransmutability%2Fregion-infer.stderr?ref=3ed2a10d173d6c2e0232776af338ca7d080b1cd4", "patch": "@@ -2,7 +2,7 @@ error[E0277]: `()` cannot be safely transmuted into `W<'_>` in the defining scop\n   --> $DIR/region-infer.rs:20:5\n    |\n LL |     test();\n-   |     ^^^^ `W<'_>` does not have a well-specified layout\n+   |     ^^^^ The size of `()` is smaller than the size of `W<'_>`\n    |\n note: required by a bound in `test`\n   --> $DIR/region-infer.rs:11:12"}]}