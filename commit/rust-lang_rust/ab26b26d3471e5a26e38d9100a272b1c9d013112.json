{"sha": "ab26b26d3471e5a26e38d9100a272b1c9d013112", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFiMjZiMjZkMzQ3MWU1YTI2ZTM4ZDkxMDBhMjcyYjFjOWQwMTMxMTI=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2019-01-14T20:07:38Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2019-03-15T11:25:10Z"}, "message": "rustc: introduce a ty::print::PrettyPrinter helper for printing \"<...>\".", "tree": {"sha": "0dd100bf263729199aac119dedd1242053840e03", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0dd100bf263729199aac119dedd1242053840e03"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ab26b26d3471e5a26e38d9100a272b1c9d013112", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ab26b26d3471e5a26e38d9100a272b1c9d013112", "html_url": "https://github.com/rust-lang/rust/commit/ab26b26d3471e5a26e38d9100a272b1c9d013112", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ab26b26d3471e5a26e38d9100a272b1c9d013112/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "35e5123f5168102eed3b3c8e1d7ab36e6f90d53b", "url": "https://api.github.com/repos/rust-lang/rust/commits/35e5123f5168102eed3b3c8e1d7ab36e6f90d53b", "html_url": "https://github.com/rust-lang/rust/commit/35e5123f5168102eed3b3c8e1d7ab36e6f90d53b"}], "stats": {"total": 249, "additions": 132, "deletions": 117}, "files": [{"sha": "447f02f42d24d86cb82f79d1a60679b2064a6dfc", "filename": "src/librustc/ty/print.rs", "status": "modified", "additions": 109, "deletions": 72, "changes": 181, "blob_url": "https://github.com/rust-lang/rust/blob/ab26b26d3471e5a26e38d9100a272b1c9d013112/src%2Flibrustc%2Fty%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab26b26d3471e5a26e38d9100a272b1c9d013112/src%2Flibrustc%2Fty%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint.rs?ref=ab26b26d3471e5a26e38d9100a272b1c9d013112", "patch": "@@ -336,7 +336,7 @@ pub trait PrettyPrinter:\n     /// nested components in some larger context.\n     fn nest<'a, 'gcx, 'tcx, E>(\n         self: PrintCx<'a, 'gcx, 'tcx, Self>,\n-        f: impl for<'b> FnOnce(PrintCx<'b, 'gcx, 'tcx, Self>) -> Result<Self, E>,\n+        f: impl FnOnce(PrintCx<'_, 'gcx, 'tcx, Self>) -> Result<Self, E>,\n     ) -> Result<PrintCx<'a, 'gcx, 'tcx, Self>, E> {\n         let printer = f(PrintCx {\n             tcx: self.tcx,\n@@ -350,6 +350,17 @@ pub trait PrettyPrinter:\n         })\n     }\n \n+    /// Print `<...>` around what `f` prints.\n+    fn generic_delimiters<'gcx, 'tcx>(\n+        mut self: PrintCx<'_, 'gcx, 'tcx, Self>,\n+        f: impl FnOnce(PrintCx<'_, 'gcx, 'tcx, Self>) -> Result<Self, Self::Error>,\n+    ) -> Result<Self, Self::Error> {\n+        write!(self.printer, \"<\")?;\n+        let mut printer = f(self)?;\n+        write!(printer, \">\")?;\n+        Ok(printer)\n+    }\n+\n     /// Return `true` if the region should be printed in path generic args\n     /// even when it's `'_`, such as in e.g. `Foo<'_, '_, '_>`.\n     fn always_print_region_in_paths(\n@@ -746,7 +757,7 @@ impl<'gcx, 'tcx, P: PrettyPrinter> PrintCx<'_, 'gcx, 'tcx, P> {\n     }\n \n     pub fn pretty_path_qualified(\n-        mut self,\n+        self,\n         self_ty: Ty<'tcx>,\n         trait_ref: Option<ty::TraitRef<'tcx>>,\n         ns: Namespace,\n@@ -772,20 +783,19 @@ impl<'gcx, 'tcx, P: PrettyPrinter> PrintCx<'_, 'gcx, 'tcx, P> {\n             }\n         }\n \n-        write!(self.printer, \"<\")?;\n-        nest!(self, |cx| self_ty.print_display(cx));\n-        if let Some(trait_ref) = trait_ref {\n-            write!(self.printer, \" as \")?;\n-            nest!(self, |cx| cx.print_def_path(\n-                trait_ref.def_id,\n-                Some(trait_ref.substs),\n-                Namespace::TypeNS,\n-                iter::empty(),\n-            ));\n-        }\n-        write!(self.printer, \">\")?;\n-\n-        Ok(self.printer)\n+        self.generic_delimiters(|mut cx| {\n+            nest!(cx, |cx| self_ty.print_display(cx));\n+            if let Some(trait_ref) = trait_ref {\n+                write!(cx.printer, \" as \")?;\n+                nest!(cx, |cx| cx.print_def_path(\n+                    trait_ref.def_id,\n+                    Some(trait_ref.substs),\n+                    Namespace::TypeNS,\n+                    iter::empty(),\n+                ));\n+            }\n+            Ok(cx.printer)\n+        })\n     }\n \n     pub fn pretty_path_append_impl(\n@@ -796,17 +806,18 @@ impl<'gcx, 'tcx, P: PrettyPrinter> PrintCx<'_, 'gcx, 'tcx, P> {\n         self_ty: Ty<'tcx>,\n         trait_ref: Option<ty::TraitRef<'tcx>>,\n     ) -> Result<P::Path, P::Error> {\n-        // HACK(eddyb) going through `path_append` means symbol name\n-        // computation gets to handle its equivalent of `::` correctly.\n-        nest!(self, |cx| cx.path_append(print_prefix, \"<impl \"));\n-        if let Some(trait_ref) = trait_ref {\n-            nest!(self, |cx| trait_ref.print_display(cx));\n-            write!(self.printer, \" for \")?;\n-        }\n-        nest!(self, |cx| self_ty.print_display(cx));\n-        write!(self.printer, \">\")?;\n+        nest!(self, print_prefix);\n \n-        Ok(self.printer)\n+        self.generic_delimiters(|mut cx| {\n+            write!(cx.printer, \"impl \")?;\n+            if let Some(trait_ref) = trait_ref {\n+                nest!(cx, |cx| trait_ref.print_display(cx));\n+                write!(cx.printer, \" for \")?;\n+            }\n+            nest!(cx, |cx| self_ty.print_display(cx));\n+\n+            Ok(cx.printer)\n+        })\n     }\n \n     pub fn pretty_path_generic_args(\n@@ -821,18 +832,6 @@ impl<'gcx, 'tcx, P: PrettyPrinter> PrintCx<'_, 'gcx, 'tcx, P> {\n     ) -> Result<P::Path, P::Error> {\n         nest!(self, |cx| print_prefix(cx));\n \n-        let mut empty = true;\n-        let mut start_or_continue = |cx: &mut Self, start: &str, cont: &str| {\n-            write!(cx.printer, \"{}\", if empty {\n-                empty = false;\n-                start\n-            } else {\n-                cont\n-            })\n-        };\n-\n-        let start = if ns == Namespace::ValueNS { \"::<\" } else { \"<\" };\n-\n         // Don't print `'_` if there's no printed region.\n         let print_regions = params.iter().any(|param| {\n             match substs[param.index as usize].unpack() {\n@@ -861,45 +860,75 @@ impl<'gcx, 'tcx, P: PrettyPrinter> PrintCx<'_, 'gcx, 'tcx, P> {\n             }).count()\n         };\n \n-        for param in &params[..params.len() - num_supplied_defaults] {\n-            match substs[param.index as usize].unpack() {\n-                UnpackedKind::Lifetime(region) => {\n-                    if !print_regions {\n-                        continue;\n+        let params = &params[..params.len() - num_supplied_defaults];\n+        let mut args = params.iter().map(|param| {\n+            substs[param.index as usize].unpack()\n+        }).filter(|arg| {\n+            match arg {\n+                UnpackedKind::Lifetime(_) => print_regions,\n+                _ => true,\n+            }\n+        });\n+        let arg0 = args.next();\n+\n+        let mut projections = projections;\n+        let projection0 = projections.next();\n+\n+        if arg0.is_none() && projection0.is_none() {\n+            return Ok(self.printer);\n+        }\n+\n+        // FIXME(eddyb) move this into `generic_delimiters`.\n+        if ns == Namespace::ValueNS {\n+            write!(self.printer, \"::\")?;\n+        }\n+\n+        self.generic_delimiters(|mut cx| {\n+            let mut empty = true;\n+            let mut maybe_comma = |cx: &mut Self| {\n+                if empty {\n+                    empty = false;\n+                    Ok(())\n+                } else {\n+                    write!(cx.printer, \", \")\n+                }\n+            };\n+\n+            for arg in arg0.into_iter().chain(args) {\n+                maybe_comma(&mut cx)?;\n+\n+                match arg {\n+                    UnpackedKind::Lifetime(region) => {\n+                        if !cx.print_region_outputs_anything(region) {\n+                            // This happens when the value of the region\n+                            // parameter is not easily serialized. This may be\n+                            // because the user omitted it in the first place,\n+                            // or because it refers to some block in the code,\n+                            // etc. I'm not sure how best to serialize this.\n+                            write!(cx.printer, \"'_\")?;\n+                        } else {\n+                            nest!(cx, |cx| region.print_display(cx));\n+                        }\n                     }\n-                    start_or_continue(&mut self, start, \", \")?;\n-                    if !self.print_region_outputs_anything(region) {\n-                        // This happens when the value of the region\n-                        // parameter is not easily serialized. This may be\n-                        // because the user omitted it in the first place,\n-                        // or because it refers to some block in the code,\n-                        // etc. I'm not sure how best to serialize this.\n-                        write!(self.printer, \"'_\")?;\n-                    } else {\n-                        nest!(self, |cx| region.print_display(cx));\n+                    UnpackedKind::Type(ty) => {\n+                        nest!(cx, |cx| ty.print_display(cx));\n+                    }\n+                    UnpackedKind::Const(ct) => {\n+                        nest!(cx, |cx| ct.print_display(cx));\n                     }\n-                }\n-                UnpackedKind::Type(ty) => {\n-                    start_or_continue(&mut self, start, \", \")?;\n-                    nest!(self, |cx| ty.print_display(cx));\n-                }\n-                UnpackedKind::Const(ct) => {\n-                    start_or_continue(&mut self, start, \", \")?;\n-                    nest!(self, |cx| ct.print_display(cx));\n                 }\n             }\n-        }\n \n-        for projection in projections {\n-            start_or_continue(&mut self, start, \", \")?;\n-            write!(self.printer, \"{}=\",\n-                   self.tcx.associated_item(projection.item_def_id).ident)?;\n-            nest!(self, |cx| projection.ty.print_display(cx));\n-        }\n+            for projection in projection0.into_iter().chain(projections) {\n+                maybe_comma(&mut cx)?;\n \n-        start_or_continue(&mut self, \"\", \">\")?;\n+                write!(cx.printer, \"{}=\",\n+                    cx.tcx.associated_item(projection.item_def_id).ident)?;\n+                nest!(cx, |cx| projection.ty.print_display(cx));\n+            }\n \n-        Ok(self.printer)\n+            Ok(cx.printer)\n+        })\n     }\n }\n \n@@ -1087,7 +1116,15 @@ impl<F: fmt::Write> Printer for FmtPrinter<F> {\n         self_ty: Ty<'tcx>,\n         trait_ref: Option<ty::TraitRef<'tcx>>,\n     ) -> Result<Self::Path, Self::Error> {\n-        self.pretty_path_append_impl(print_prefix, self_ty, trait_ref)\n+        self.pretty_path_append_impl(|cx| {\n+            let mut printer = print_prefix(cx)?;\n+\n+            if !printer.empty {\n+                write!(printer, \"::\")?;\n+            }\n+\n+            Ok(printer)\n+        }, self_ty, trait_ref)\n     }\n     fn path_append<'gcx, 'tcx>(\n         self: PrintCx<'_, 'gcx, 'tcx, Self>,\n@@ -1126,7 +1163,7 @@ impl<F: fmt::Write> Printer for FmtPrinter<F> {\n impl<F: fmt::Write> PrettyPrinter for FmtPrinter<F> {\n     fn nest<'a, 'gcx, 'tcx, E>(\n         mut self: PrintCx<'a, 'gcx, 'tcx, Self>,\n-        f: impl for<'b> FnOnce(PrintCx<'b, 'gcx, 'tcx, Self>) -> Result<Self, E>,\n+        f: impl FnOnce(PrintCx<'_, 'gcx, 'tcx, Self>) -> Result<Self, E>,\n     ) -> Result<PrintCx<'a, 'gcx, 'tcx, Self>, E> {\n         let was_empty = std::mem::replace(&mut self.printer.empty, true);\n         let mut printer = f(PrintCx {"}, {"sha": "40dc22309664a1a90d06379ae5f3d90fde1073fa", "filename": "src/librustc_codegen_utils/symbol_names.rs", "status": "modified", "additions": 23, "deletions": 45, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/ab26b26d3471e5a26e38d9100a272b1c9d013112/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab26b26d3471e5a26e38d9100a272b1c9d013112/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs?ref=ab26b26d3471e5a26e38d9100a272b1c9d013112", "patch": "@@ -434,28 +434,12 @@ impl Printer for SymbolPath {\n         Ok(self.printer)\n     }\n     fn path_qualified(\n-        mut self: PrintCx<'_, '_, 'tcx, Self>,\n+        self: PrintCx<'_, '_, 'tcx, Self>,\n         self_ty: Ty<'tcx>,\n         trait_ref: Option<ty::TraitRef<'tcx>>,\n         ns: Namespace,\n     ) -> Result<Self::Path, Self::Error> {\n-        // HACK(eddyb) avoid `keep_within_component` for the cases\n-        // that print without `<...>` around `self_ty`.\n-        match self_ty.sty {\n-            ty::Adt(..) | ty::Foreign(_) |\n-            ty::Bool | ty::Char | ty::Str |\n-            ty::Int(_) | ty::Uint(_) | ty::Float(_)\n-                if trait_ref.is_none() =>\n-            {\n-                return self.pretty_path_qualified(self_ty, trait_ref, ns);\n-            }\n-            _ => {}\n-        }\n-\n-        let kept_within_component = mem::replace(&mut self.printer.keep_within_component, true);\n-        let mut path = self.pretty_path_qualified(self_ty, trait_ref, ns)?;\n-        path.keep_within_component = kept_within_component;\n-        Ok(path)\n+        self.pretty_path_qualified(self_ty, trait_ref, ns)\n     }\n \n     fn path_append_impl<'gcx, 'tcx>(\n@@ -466,18 +450,11 @@ impl Printer for SymbolPath {\n         self_ty: Ty<'tcx>,\n         trait_ref: Option<ty::TraitRef<'tcx>>,\n     ) -> Result<Self::Path, Self::Error> {\n-        let kept_within_component = self.printer.keep_within_component;\n-        let mut path = self.pretty_path_append_impl(\n-            |cx| {\n-                let mut path = print_prefix(cx)?;\n-                path.keep_within_component = true;\n-                Ok(path)\n-            },\n+        self.pretty_path_append_impl(\n+            |cx| cx.path_append(print_prefix, \"\"),\n             self_ty,\n             trait_ref,\n-        )?;\n-        path.keep_within_component = kept_within_component;\n-        Ok(path)\n+        )\n     }\n     fn path_append<'gcx, 'tcx>(\n         self: PrintCx<'_, 'gcx, 'tcx, Self>,\n@@ -486,11 +463,9 @@ impl Printer for SymbolPath {\n         ) -> Result<Self::Path, Self::Error>,\n         text: &str,\n     ) -> Result<Self::Path, Self::Error> {\n-        let keep_within_component = self.printer.keep_within_component;\n-\n         let mut path = print_prefix(self)?;\n \n-        if keep_within_component {\n+        if path.keep_within_component {\n             // HACK(eddyb) print the path similarly to how `FmtPrinter` prints it.\n             path.write_str(\"::\")?;\n         } else {\n@@ -510,20 +485,7 @@ impl Printer for SymbolPath {\n         ns: Namespace,\n         projections: impl Iterator<Item = ty::ExistentialProjection<'tcx>>,\n     )  -> Result<Self::Path, Self::Error> {\n-        let kept_within_component = self.printer.keep_within_component;\n-        let mut path = self.pretty_path_generic_args(\n-            |cx| {\n-                let mut path = print_prefix(cx)?;\n-                path.keep_within_component = true;\n-                Ok(path)\n-            },\n-            params,\n-            substs,\n-            ns,\n-            projections,\n-        )?;\n-        path.keep_within_component = kept_within_component;\n-        Ok(path)\n+        self.pretty_path_generic_args(print_prefix, params, substs, ns, projections)\n     }\n }\n \n@@ -534,6 +496,22 @@ impl PrettyPrinter for SymbolPath {\n     ) -> bool {\n         false\n     }\n+\n+    fn generic_delimiters<'gcx, 'tcx>(\n+        mut self: PrintCx<'_, 'gcx, 'tcx, Self>,\n+        f: impl FnOnce(PrintCx<'_, 'gcx, 'tcx, Self>) -> Result<Self, Self::Error>,\n+    ) -> Result<Self, Self::Error> {\n+        write!(self.printer, \"<\")?;\n+\n+        let kept_within_component =\n+            mem::replace(&mut self.printer.keep_within_component, true);\n+        let mut path = f(self)?;\n+        path.keep_within_component = kept_within_component;\n+\n+        write!(path, \">\")?;\n+\n+        Ok(path)\n+    }\n }\n \n impl fmt::Write for SymbolPath {"}]}