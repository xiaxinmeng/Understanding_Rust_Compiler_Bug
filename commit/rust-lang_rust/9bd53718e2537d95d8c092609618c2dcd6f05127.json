{"sha": "9bd53718e2537d95d8c092609618c2dcd6f05127", "node_id": "C_kwDOAAsO6NoAKDliZDUzNzE4ZTI1MzdkOTVkOGMwOTI2MDk2MThjMmRjZDZmMDUxMjc", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-03-20T13:48:23Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-03-20T13:48:23Z"}, "message": "Auto merge of #95071 - RalfJung:arbitrary-self-dyn, r=oli-obk\n\nMiri: implement arbitrary-self dyn receivers\n\nRoughly follows the [codegen logic](https://github.com/rust-lang/rust/blob/851fcc7a54262748b1aa9e16de91453998d896f3/compiler/rustc_codegen_ssa/src/mir/block.rs#L809).\n\nFixes https://github.com/rust-lang/miri/issues/1038\nr? `@oli-obk` Cc `@eddyb`", "tree": {"sha": "d2d0f21ef4c3baa836cf9737d810a18107f3aa17", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d2d0f21ef4c3baa836cf9737d810a18107f3aa17"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9bd53718e2537d95d8c092609618c2dcd6f05127", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9bd53718e2537d95d8c092609618c2dcd6f05127", "html_url": "https://github.com/rust-lang/rust/commit/9bd53718e2537d95d8c092609618c2dcd6f05127", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9bd53718e2537d95d8c092609618c2dcd6f05127/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c7ce69faf2a7ea16c15d922985ca27ba70da30ee", "url": "https://api.github.com/repos/rust-lang/rust/commits/c7ce69faf2a7ea16c15d922985ca27ba70da30ee", "html_url": "https://github.com/rust-lang/rust/commit/c7ce69faf2a7ea16c15d922985ca27ba70da30ee"}, {"sha": "fa5fa72fe1c7c29f3a52f9be14a2ed0acb03b5ce", "url": "https://api.github.com/repos/rust-lang/rust/commits/fa5fa72fe1c7c29f3a52f9be14a2ed0acb03b5ce", "html_url": "https://github.com/rust-lang/rust/commit/fa5fa72fe1c7c29f3a52f9be14a2ed0acb03b5ce"}], "stats": {"total": 55, "additions": 40, "deletions": 15}, "files": [{"sha": "57a93ed4d55f8efa20ef0e52b0c09d15a81b9f6e", "filename": "compiler/rustc_const_eval/src/interpret/terminator.rs", "status": "modified", "additions": 40, "deletions": 15, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/9bd53718e2537d95d8c092609618c2dcd6f05127/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bd53718e2537d95d8c092609618c2dcd6f05127/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs?ref=9bd53718e2537d95d8c092609618c2dcd6f05127", "patch": "@@ -476,22 +476,47 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             // cannot use the shim here, because that will only result in infinite recursion\n             ty::InstanceDef::Virtual(_, idx) => {\n                 let mut args = args.to_vec();\n-                // We have to implement all \"object safe receivers\".  Currently we\n-                // support built-in pointers `(&, &mut, Box)` as well as unsized-self.  We do\n-                // not yet support custom self types.\n-                // Also see `compiler/rustc_codegen_llvm/src/abi.rs` and `compiler/rustc_codegen_ssa/src/mir/block.rs`.\n-                let receiver_place = match args[0].layout.ty.builtin_deref(true) {\n-                    Some(_) => {\n-                        // Built-in pointer.\n-                        self.deref_operand(&args[0])?\n-                    }\n-                    None => {\n-                        // Unsized self.\n-                        args[0].assert_mem_place()\n+                // We have to implement all \"object safe receivers\". So we have to go search for a\n+                // pointer or `dyn Trait` type, but it could be wrapped in newtypes. So recursively\n+                // unwrap those newtypes until we are there.\n+                let mut receiver = args[0];\n+                let receiver_place = loop {\n+                    match receiver.layout.ty.kind() {\n+                        ty::Ref(..) | ty::RawPtr(..) => break self.deref_operand(&receiver)?,\n+                        ty::Dynamic(..) => break receiver.assert_mem_place(),\n+                        _ => {\n+                            // Not there yet, search for the only non-ZST field.\n+                            let mut non_zst_field = None;\n+                            for i in 0..receiver.layout.fields.count() {\n+                                let field = self.operand_field(&receiver, i)?;\n+                                if !field.layout.is_zst() {\n+                                    assert!(\n+                                        non_zst_field.is_none(),\n+                                        \"multiple non-ZST fields in dyn receiver type {}\",\n+                                        receiver.layout.ty\n+                                    );\n+                                    non_zst_field = Some(field);\n+                                }\n+                            }\n+                            receiver = non_zst_field.unwrap_or_else(|| {\n+                                panic!(\n+                                    \"no non-ZST fields in dyn receiver type {}\",\n+                                    receiver.layout.ty\n+                                )\n+                            });\n+                        }\n                     }\n                 };\n-                // Find and consult vtable\n-                let vtable = self.scalar_to_ptr(receiver_place.vtable());\n+                // Find and consult vtable. The type now could be something like RcBox<dyn Trait>,\n+                // i.e., it is still not necessarily `ty::Dynamic` (so we cannot use\n+                // `place.vtable()`), but it should have a `dyn Trait` tail.\n+                assert!(matches!(\n+                    self.tcx\n+                        .struct_tail_erasing_lifetimes(receiver_place.layout.ty, self.param_env)\n+                        .kind(),\n+                    ty::Dynamic(..)\n+                ));\n+                let vtable = self.scalar_to_ptr(receiver_place.meta.unwrap_meta());\n                 let fn_val = self.get_vtable_slot(vtable, u64::try_from(idx).unwrap())?;\n \n                 // `*mut receiver_place.layout.ty` is almost the layout that we\n@@ -505,7 +530,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     Scalar::from_maybe_pointer(receiver_place.ptr, self).into(),\n                     this_receiver_ptr,\n                 ));\n-                trace!(\"Patched self operand to {:#?}\", args[0]);\n+                trace!(\"Patched receiver operand to {:#?}\", args[0]);\n                 // recurse with concrete function\n                 self.eval_fn_call(\n                     fn_val,"}]}