{"sha": "a3d705ef3094968c457cf0408cc6bbe241e627b5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEzZDcwNWVmMzA5NDk2OGM0NTdjZjA0MDhjYzZiYmUyNDFlNjI3YjU=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-05-21T00:19:00Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-05-21T23:01:02Z"}, "message": "Refactor away `expand_item_mac`", "tree": {"sha": "a17dcd78c64882036c2a6fc1af55e5330de2b9a4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a17dcd78c64882036c2a6fc1af55e5330de2b9a4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a3d705ef3094968c457cf0408cc6bbe241e627b5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a3d705ef3094968c457cf0408cc6bbe241e627b5", "html_url": "https://github.com/rust-lang/rust/commit/a3d705ef3094968c457cf0408cc6bbe241e627b5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a3d705ef3094968c457cf0408cc6bbe241e627b5/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3192adbf87138b2a7276719f32764db79cb2a883", "url": "https://api.github.com/repos/rust-lang/rust/commits/3192adbf87138b2a7276719f32764db79cb2a883", "html_url": "https://github.com/rust-lang/rust/commit/3192adbf87138b2a7276719f32764db79cb2a883"}], "stats": {"total": 244, "additions": 85, "deletions": 159}, "files": [{"sha": "c8272316c3c7661f9f370e9fdc844a9760565447", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 85, "deletions": 159, "changes": 244, "blob_url": "https://github.com/rust-lang/rust/blob/a3d705ef3094968c457cf0408cc6bbe241e627b5/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3d705ef3094968c457cf0408cc6bbe241e627b5/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=a3d705ef3094968c457cf0408cc6bbe241e627b5", "patch": "@@ -86,7 +86,7 @@ pub fn expand_expr(e: P<ast::Expr>, fld: &mut MacroExpander) -> P<ast::Expr> {\n         // expr_mac should really be expr_ext or something; it's the\n         // entry-point for all syntax extensions.\n         ast::ExprKind::Mac(mac) => {\n-            expand_mac_invoc(mac, attrs.into_attr_vec(), span, fld)\n+            expand_mac_invoc(mac, None, attrs.into_attr_vec(), span, fld)\n         }\n \n         ast::ExprKind::InPlace(placer, value_expr) => {\n@@ -196,21 +196,17 @@ pub fn expand_expr(e: P<ast::Expr>, fld: &mut MacroExpander) -> P<ast::Expr> {\n     });\n }\n \n-/// Expand a (not-ident-style) macro invocation. Returns the result of expansion.\n-fn expand_mac_invoc<T>(mac: ast::Mac, attrs: Vec<ast::Attribute>, span: Span,\n+/// Expand a macro invocation. Returns the result of expansion.\n+fn expand_mac_invoc<T>(mac: ast::Mac, ident: Option<Ident>, attrs: Vec<ast::Attribute>, span: Span,\n                        fld: &mut MacroExpander) -> T\n     where T: MacroGenerable,\n {\n-    // it would almost certainly be cleaner to pass the whole\n-    // macro invocation in, rather than pulling it apart and\n-    // marking the tts and the ctxt separately. This also goes\n-    // for the other three macro invocation chunks of code\n-    // in this file.\n-\n+    // It would almost certainly be cleaner to pass the whole macro invocation in,\n+    // rather than pulling it apart and marking the tts and the ctxt separately.\n     let Mac_ { path, tts, .. } = mac.node;\n     let mark = fresh_mark();\n \n-    fn mac_result<'a>(path: &ast::Path, tts: Vec<TokenTree>, mark: Mrk,\n+    fn mac_result<'a>(path: &ast::Path, ident: Option<Ident>, tts: Vec<TokenTree>, mark: Mrk,\n                       attrs: Vec<ast::Attribute>, call_site: Span, fld: &'a mut MacroExpander)\n                       -> Option<Box<MacResult + 'a>> {\n         check_attributes(&attrs, fld);\n@@ -231,8 +227,16 @@ fn expand_mac_invoc<T>(mac: ast::Mac, attrs: Vec<ast::Attribute>, span: Span,\n             return None;\n         };\n \n+        let ident = ident.unwrap_or(Ident::with_empty_ctxt(keywords::Invalid.name()));\n         match *extension {\n             NormalTT(ref expandfun, exp_span, allow_internal_unstable) => {\n+                if ident.name != keywords::Invalid.name() {\n+                    let msg =\n+                        format!(\"macro {}! expects no ident argument, given '{}'\", extname, ident);\n+                    fld.cx.span_err(path.span, &msg);\n+                    return None;\n+                }\n+\n                 fld.cx.bt_push(ExpnInfo {\n                     call_site: call_site,\n                     callee: NameAndSpan {\n@@ -251,15 +255,72 @@ fn expand_mac_invoc<T>(mac: ast::Mac, attrs: Vec<ast::Attribute>, span: Span,\n                 let marked_tts = mark_tts(&tts[..], mark);\n                 Some(expandfun.expand(fld.cx, mac_span, &marked_tts))\n             }\n-            _ => {\n+\n+            IdentTT(ref expander, tt_span, allow_internal_unstable) => {\n+                if ident.name == keywords::Invalid.name() {\n+                    fld.cx.span_err(path.span,\n+                                    &format!(\"macro {}! expects an ident argument\", extname));\n+                    return None;\n+                };\n+\n+                fld.cx.bt_push(ExpnInfo {\n+                    call_site: call_site,\n+                    callee: NameAndSpan {\n+                        format: MacroBang(extname),\n+                        span: tt_span,\n+                        allow_internal_unstable: allow_internal_unstable,\n+                    }\n+                });\n+\n+                let marked_tts = mark_tts(&tts, mark);\n+                Some(expander.expand(fld.cx, call_site, ident, marked_tts))\n+            }\n+\n+            MacroRulesTT => {\n+                if ident.name == keywords::Invalid.name() {\n+                    fld.cx.span_err(path.span,\n+                                    &format!(\"macro {}! expects an ident argument\", extname));\n+                    return None;\n+                };\n+\n+                fld.cx.bt_push(ExpnInfo {\n+                    call_site: call_site,\n+                    callee: NameAndSpan {\n+                        format: MacroBang(extname),\n+                        span: None,\n+                        // `macro_rules!` doesn't directly allow unstable\n+                        // (this is orthogonal to whether the macro it creates allows it)\n+                        allow_internal_unstable: false,\n+                    }\n+                });\n+\n+                // DON'T mark before expansion.\n+                fld.cx.insert_macro(ast::MacroDef {\n+                    ident: ident,\n+                    id: ast::DUMMY_NODE_ID,\n+                    span: call_site,\n+                    imported_from: None,\n+                    use_locally: true,\n+                    body: tts,\n+                    export: attr::contains_name(&attrs, \"macro_export\"),\n+                    allow_internal_unstable: attr::contains_name(&attrs, \"allow_internal_unstable\"),\n+                    attrs: attrs,\n+                });\n+\n+                // macro_rules! has a side effect but expands to nothing.\n+                fld.cx.bt_pop();\n+                None\n+            }\n+\n+            MultiDecorator(..) | MultiModifier(..) => {\n                 fld.cx.span_err(path.span,\n-                                &format!(\"'{}' is not a tt-style macro\", extname));\n+                                &format!(\"`{}` can only be used in attributes\", extname));\n                 None\n             }\n         }\n     }\n \n-    let opt_expanded = T::make_with(match mac_result(&path, tts, mark, attrs, span, fld) {\n+    let opt_expanded = T::make_with(match mac_result(&path, ident, tts, mark, attrs, span, fld) {\n         Some(result) => result,\n         None => return T::dummy(span),\n     });\n@@ -375,141 +436,6 @@ fn contains_macro_use(fld: &mut MacroExpander, attrs: &[ast::Attribute]) -> bool\n     false\n }\n \n-// Support for item-position macro invocations, exactly the same\n-// logic as for expression-position macro invocations.\n-pub fn expand_item_mac(it: P<ast::Item>,\n-                       fld: &mut MacroExpander) -> SmallVector<P<ast::Item>> {\n-    let (extname, path_span, tts, span, attrs, ident) = it.and_then(|it| match it.node {\n-        ItemKind::Mac(codemap::Spanned { node: Mac_ { path, tts, .. }, .. }) =>\n-            (path.segments[0].identifier.name, path.span, tts, it.span, it.attrs, it.ident),\n-        _ => fld.cx.span_bug(it.span, \"invalid item macro invocation\")\n-    });\n-\n-    check_attributes(&attrs, fld);\n-\n-    let fm = fresh_mark();\n-    let items = {\n-        let expanded = match fld.cx.syntax_env.find(extname) {\n-            None => {\n-                fld.cx.span_err(path_span,\n-                                &format!(\"macro undefined: '{}!'\",\n-                                        extname));\n-                // let compilation continue\n-                return SmallVector::zero();\n-            }\n-\n-            Some(rc) => match *rc {\n-                NormalTT(ref expander, tt_span, allow_internal_unstable) => {\n-                    if ident.name != keywords::Invalid.name() {\n-                        fld.cx\n-                            .span_err(path_span,\n-                                      &format!(\"macro {}! expects no ident argument, given '{}'\",\n-                                               extname,\n-                                               ident));\n-                        return SmallVector::zero();\n-                    }\n-                    fld.cx.bt_push(ExpnInfo {\n-                        call_site: span,\n-                        callee: NameAndSpan {\n-                            format: MacroBang(extname),\n-                            span: tt_span,\n-                            allow_internal_unstable: allow_internal_unstable,\n-                        }\n-                    });\n-                    // mark before expansion:\n-                    let marked_before = mark_tts(&tts[..], fm);\n-                    expander.expand(fld.cx, span, &marked_before[..])\n-                }\n-                IdentTT(ref expander, tt_span, allow_internal_unstable) => {\n-                    if ident.name == keywords::Invalid.name() {\n-                        fld.cx.span_err(path_span,\n-                                        &format!(\"macro {}! expects an ident argument\",\n-                                                extname));\n-                        return SmallVector::zero();\n-                    }\n-                    fld.cx.bt_push(ExpnInfo {\n-                        call_site: span,\n-                        callee: NameAndSpan {\n-                            format: MacroBang(extname),\n-                            span: tt_span,\n-                            allow_internal_unstable: allow_internal_unstable,\n-                        }\n-                    });\n-                    // mark before expansion:\n-                    let marked_tts = mark_tts(&tts[..], fm);\n-                    expander.expand(fld.cx, span, ident, marked_tts)\n-                }\n-                MacroRulesTT => {\n-                    if ident.name == keywords::Invalid.name() {\n-                        fld.cx.span_err(path_span, \"macro_rules! expects an ident argument\");\n-                        return SmallVector::zero();\n-                    }\n-\n-                    fld.cx.bt_push(ExpnInfo {\n-                        call_site: span,\n-                        callee: NameAndSpan {\n-                            format: MacroBang(extname),\n-                            span: None,\n-                            // `macro_rules!` doesn't directly allow\n-                            // unstable (this is orthogonal to whether\n-                            // the macro it creates allows it)\n-                            allow_internal_unstable: false,\n-                        }\n-                    });\n-                    // DON'T mark before expansion.\n-\n-                    let allow_internal_unstable = attr::contains_name(&attrs,\n-                                                                      \"allow_internal_unstable\");\n-\n-                    let export = attr::contains_name(&attrs, \"macro_export\");\n-                    let def = ast::MacroDef {\n-                        ident: ident,\n-                        attrs: attrs,\n-                        id: ast::DUMMY_NODE_ID,\n-                        span: span,\n-                        imported_from: None,\n-                        export: export,\n-                        use_locally: true,\n-                        allow_internal_unstable: allow_internal_unstable,\n-                        body: tts,\n-                    };\n-                    fld.cx.insert_macro(def);\n-\n-                    // macro_rules! has a side effect but expands to nothing.\n-                    fld.cx.bt_pop();\n-                    return SmallVector::zero();\n-                }\n-                _ => {\n-                    fld.cx.span_err(span,\n-                                    &format!(\"{}! is not legal in item position\",\n-                                            extname));\n-                    return SmallVector::zero();\n-                }\n-            }\n-        };\n-\n-        expanded.make_items()\n-    };\n-\n-    let items = match items {\n-        Some(items) => {\n-            items.into_iter()\n-                .map(|i| mark_item(i, fm))\n-                .flat_map(|i| fld.fold_item(i).into_iter())\n-                .collect()\n-        }\n-        None => {\n-            fld.cx.span_err(path_span,\n-                            &format!(\"non-item macro in item position: {}\",\n-                                    extname));\n-            return SmallVector::zero();\n-        }\n-    };\n-\n-    fld.cx.bt_pop();\n-    items\n-}\n-\n /// Expand a stmt\n fn expand_stmt(stmt: Stmt, fld: &mut MacroExpander) -> SmallVector<Stmt> {\n     // perform all pending renames\n@@ -525,7 +451,7 @@ fn expand_stmt(stmt: Stmt, fld: &mut MacroExpander) -> SmallVector<Stmt> {\n     };\n \n     let mut fully_expanded: SmallVector<ast::Stmt> =\n-        expand_mac_invoc(mac.unwrap(), attrs.into_attr_vec(), stmt.span, fld);\n+        expand_mac_invoc(mac.unwrap(), None, attrs.into_attr_vec(), stmt.span, fld);\n \n     // If this is a macro invocation with a semicolon, then apply that\n     // semicolon to the final statement produced by expansion.\n@@ -742,7 +668,7 @@ fn expand_pat(p: P<ast::Pat>, fld: &mut MacroExpander) -> P<ast::Pat> {\n     }\n     p.and_then(|ast::Pat {node, span, ..}| {\n         match node {\n-            PatKind::Mac(mac) => expand_mac_invoc(mac, Vec::new(), span, fld),\n+            PatKind::Mac(mac) => expand_mac_invoc(mac, None, Vec::new(), span, fld),\n             _ => unreachable!()\n         }\n     })\n@@ -813,7 +739,13 @@ fn expand_annotatable(a: Annotatable,\n     let mut new_items: SmallVector<Annotatable> = match a {\n         Annotatable::Item(it) => match it.node {\n             ast::ItemKind::Mac(..) => {\n-                expand_item_mac(it, fld).into_iter().map(|i| Annotatable::Item(i)).collect()\n+                let new_items: SmallVector<P<ast::Item>> = it.and_then(|it| match it.node {\n+                    ItemKind::Mac(mac) =>\n+                        expand_mac_invoc(mac, Some(it.ident), it.attrs, it.span, fld),\n+                    _ => unreachable!(),\n+                });\n+\n+                new_items.into_iter().map(|i| Annotatable::Item(i)).collect()\n             }\n             ast::ItemKind::Mod(_) | ast::ItemKind::ForeignMod(_) => {\n                 let valid_ident =\n@@ -997,7 +929,7 @@ fn expand_impl_item(ii: ast::ImplItem, fld: &mut MacroExpander)\n             span: fld.new_span(ii.span)\n         }),\n         ast::ImplItemKind::Macro(mac) => {\n-            expand_mac_invoc(mac, ii.attrs, ii.span, fld)\n+            expand_mac_invoc(mac, None, ii.attrs, ii.span, fld)\n         }\n         _ => fold::noop_fold_impl_item(ii, fld)\n     }\n@@ -1041,7 +973,7 @@ pub fn expand_type(t: P<ast::Ty>, fld: &mut MacroExpander) -> P<ast::Ty> {\n     let t = match t.node.clone() {\n         ast::TyKind::Mac(mac) => {\n             if fld.cx.ecfg.features.unwrap().type_macros {\n-                expand_mac_invoc(mac, Vec::new(), t.span, fld)\n+                expand_mac_invoc(mac, None, Vec::new(), t.span, fld)\n             } else {\n                 feature_gate::emit_feature_err(\n                     &fld.cx.parse_sess.span_diagnostic,\n@@ -1310,12 +1242,6 @@ fn mark_tts(tts: &[TokenTree], m: Mrk) -> Vec<TokenTree> {\n     noop_fold_tts(tts, &mut Marker{mark:m})\n }\n \n-// apply a given mark to the given item. Used following the expansion of a macro.\n-fn mark_item(expr: P<ast::Item>, m: Mrk) -> P<ast::Item> {\n-    Marker{mark:m}.fold_item(expr)\n-        .expect_one(\"marking an item didn't return exactly one item\")\n-}\n-\n /// Check that there are no macro invocations left in the AST:\n pub fn check_for_macros(sess: &parse::ParseSess, krate: &ast::Crate) {\n     visit::walk_crate(&mut MacroExterminator{sess:sess}, krate);"}]}