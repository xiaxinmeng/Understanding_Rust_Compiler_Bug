{"sha": "61bb0cfbbe326c95dcc241df830e57e2be25b33c", "node_id": "C_kwDOAAsO6NoAKDYxYmIwY2ZiYmUzMjZjOTVkY2MyNDFkZjgzMGU1N2UyYmUyNWIzM2M", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-09-23T17:56:55Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-09-23T17:56:55Z"}, "message": "Merge #10320\n\n10320: feat: Hover/GotoDef works in macro invocations and on doc attribute strings r=Veykril a=Veykril\n\n![image](https://user-images.githubusercontent.com/3757771/134554781-b903d33d-674f-4ed4-8acb-71ff5913f1cb.png)\r\ncc https://github.com/rust-analyzer/rust-analyzer/issues/10271 \r\n\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>", "tree": {"sha": "f9f66fdc764f87bed01067405f5fe9122260eaac", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f9f66fdc764f87bed01067405f5fe9122260eaac"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/61bb0cfbbe326c95dcc241df830e57e2be25b33c", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhTL/nCRBK7hj4Ov3rIwAARWUIAHybm4DfpCC/E9qbyJ77Qp8g\nFY+LMAezzbPKwLg6ubGBxbzhP+wsW6/AyuJRanscd5yuSvTAOFZ3SclQ6Vhsz0au\n8y4mvD45HwDyr+mTwt3oVJlUnPbHPUytpVvFvGtkkrRuKdP7p4Ohbj76CrNhIkR1\nE8dXE12ddicWv27vaR/IcH6nHF6ZRYrRIoOtlUhW1CDSmY5GEKGgM3CjcTRrouh3\n2r43dEQf0GCQMx14zDh9g3wC/dhQhn9WKSWRuD08YZDO8IUBmnbJgPXHzmktKS7t\nNybhpVY9/OtvXMBSkbeKebY6coQAvUT1T/SFNAqC1nIPq258yBgVdOm5SrPncTE=\n=kdPl\n-----END PGP SIGNATURE-----\n", "payload": "tree f9f66fdc764f87bed01067405f5fe9122260eaac\nparent eb727c72229275ceff23232299844499abb8623b\nparent 22c6f0a8a584304534ee75dc8ed7f7564eee8ae6\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1632419815 +0000\ncommitter GitHub <noreply@github.com> 1632419815 +0000\n\nMerge #10320\n\n10320: feat: Hover/GotoDef works in macro invocations and on doc attribute strings r=Veykril a=Veykril\n\n![image](https://user-images.githubusercontent.com/3757771/134554781-b903d33d-674f-4ed4-8acb-71ff5913f1cb.png)\r\ncc https://github.com/rust-analyzer/rust-analyzer/issues/10271 \r\n\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/61bb0cfbbe326c95dcc241df830e57e2be25b33c", "html_url": "https://github.com/rust-lang/rust/commit/61bb0cfbbe326c95dcc241df830e57e2be25b33c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/61bb0cfbbe326c95dcc241df830e57e2be25b33c/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eb727c72229275ceff23232299844499abb8623b", "url": "https://api.github.com/repos/rust-lang/rust/commits/eb727c72229275ceff23232299844499abb8623b", "html_url": "https://github.com/rust-lang/rust/commit/eb727c72229275ceff23232299844499abb8623b"}, {"sha": "22c6f0a8a584304534ee75dc8ed7f7564eee8ae6", "url": "https://api.github.com/repos/rust-lang/rust/commits/22c6f0a8a584304534ee75dc8ed7f7564eee8ae6", "html_url": "https://github.com/rust-lang/rust/commit/22c6f0a8a584304534ee75dc8ed7f7564eee8ae6"}], "stats": {"total": 232, "additions": 177, "deletions": 55}, "files": [{"sha": "70fa249a5b08584beb1bf8496446e510f68ee579", "filename": "crates/hir_def/src/attr.rs", "status": "modified", "additions": 27, "deletions": 3, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/61bb0cfbbe326c95dcc241df830e57e2be25b33c/crates%2Fhir_def%2Fsrc%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61bb0cfbbe326c95dcc241df830e57e2be25b33c/crates%2Fhir_def%2Fsrc%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fattr.rs?ref=61bb0cfbbe326c95dcc241df830e57e2be25b33c", "patch": "@@ -17,7 +17,7 @@ use la_arena::ArenaMap;\n use mbe::{syntax_node_to_token_tree, DelimiterKind};\n use smallvec::{smallvec, SmallVec};\n use syntax::{\n-    ast::{self, AstNode, AttrsOwner},\n+    ast::{self, AstNode, AttrsOwner, IsString},\n     match_ast, AstPtr, AstToken, SmolStr, SyntaxNode, TextRange, TextSize,\n };\n use tt::Subtree;\n@@ -610,6 +610,7 @@ pub struct DocsRangeMap {\n }\n \n impl DocsRangeMap {\n+    /// Maps a [`TextRange`] relative to the documentation string back to its AST range\n     pub fn map(&self, range: TextRange) -> Option<InFile<TextRange>> {\n         let found = self.mapping.binary_search_by(|(probe, ..)| probe.ordering(range)).ok()?;\n         let (line_docs_range, idx, original_line_src_range) = self.mapping[found];\n@@ -621,8 +622,15 @@ impl DocsRangeMap {\n \n         let InFile { file_id, value: source } = self.source_map.source_of_id(idx);\n         match source {\n-            Either::Left(_) => None, // FIXME, figure out a nice way to handle doc attributes here\n-            // as well as for whats done in syntax highlight doc injection\n+            Either::Left(attr) => {\n+                let string = get_doc_string_in_attr(&attr)?;\n+                let text_range = string.open_quote_text_range()?;\n+                let range = TextRange::at(\n+                    text_range.end() + original_line_src_range.start() + relative_range.start(),\n+                    string.syntax().text_range().len().min(range.len()),\n+                );\n+                Some(InFile { file_id, value: range })\n+            }\n             Either::Right(comment) => {\n                 let text_range = comment.syntax().text_range();\n                 let range = TextRange::at(\n@@ -638,6 +646,22 @@ impl DocsRangeMap {\n     }\n }\n \n+fn get_doc_string_in_attr(it: &ast::Attr) -> Option<ast::String> {\n+    match it.expr() {\n+        // #[doc = lit]\n+        Some(ast::Expr::Literal(lit)) => match lit.kind() {\n+            ast::LiteralKind::String(it) => Some(it),\n+            _ => None,\n+        },\n+        // #[cfg_attr(..., doc = \"\", ...)]\n+        None => {\n+            // FIXME: See highlight injection for what to do here\n+            None\n+        }\n+        _ => None,\n+    }\n+}\n+\n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub(crate) struct AttrId {\n     is_doc_comment: bool,"}, {"sha": "adaaece719fee269928088dabff31b4866cfd626", "filename": "crates/ide/src/doc_links.rs", "status": "modified", "additions": 66, "deletions": 1, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/61bb0cfbbe326c95dcc241df830e57e2be25b33c/crates%2Fide%2Fsrc%2Fdoc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61bb0cfbbe326c95dcc241df830e57e2be25b33c/crates%2Fide%2Fsrc%2Fdoc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fdoc_links.rs?ref=61bb0cfbbe326c95dcc241df830e57e2be25b33c", "patch": "@@ -19,7 +19,12 @@ use ide_db::{\n     helpers::pick_best_token,\n     RootDatabase,\n };\n-use syntax::{ast, match_ast, AstNode, SyntaxKind::*, SyntaxNode, TextRange, T};\n+use syntax::{\n+    ast::{self, IsString},\n+    match_ast, AstNode, AstToken,\n+    SyntaxKind::*,\n+    SyntaxNode, SyntaxToken, TextRange, TextSize, T,\n+};\n \n use crate::{\n     doc_links::intra_doc_links::{parse_intra_doc_link, strip_prefixes_suffixes},\n@@ -220,6 +225,66 @@ pub(crate) fn doc_attributes(\n     }\n }\n \n+pub(crate) struct DocCommentToken {\n+    doc_token: SyntaxToken,\n+    prefix_len: TextSize,\n+}\n+\n+pub(crate) fn token_as_doc_comment(doc_token: &SyntaxToken) -> Option<DocCommentToken> {\n+    (match_ast! {\n+        match doc_token {\n+            ast::Comment(comment) => TextSize::try_from(comment.prefix().len()).ok(),\n+            ast::String(string) => doc_token.ancestors().find_map(ast::Attr::cast)\n+                .filter(|attr| attr.simple_name().as_deref() == Some(\"doc\")).and_then(|_| string.open_quote_text_range().map(|it| it.len())),\n+            _ => None,\n+        }\n+    }).map(|prefix_len| DocCommentToken { prefix_len, doc_token: doc_token.clone() })\n+}\n+\n+impl DocCommentToken {\n+    pub(crate) fn get_definition_with_descend_at<T>(\n+        self,\n+        sema: &Semantics<RootDatabase>,\n+        offset: TextSize,\n+        // Definition, CommentOwner, range of intra doc link in original file\n+        mut cb: impl FnMut(Definition, SyntaxNode, TextRange) -> Option<T>,\n+    ) -> Option<T> {\n+        let DocCommentToken { prefix_len, doc_token } = self;\n+        // offset relative to the comments contents\n+        let original_start = doc_token.text_range().start();\n+        let relative_comment_offset = offset - original_start - prefix_len;\n+\n+        sema.descend_into_macros_many(doc_token.clone()).into_iter().find_map(|t| {\n+            let (node, descended_prefix_len) = match_ast! {\n+                match t {\n+                    ast::Comment(comment) => (t.parent()?, TextSize::try_from(comment.prefix().len()).ok()?),\n+                    ast::String(string) => (t.ancestors().skip_while(|n| n.kind() != ATTR).nth(1)?, string.open_quote_text_range()?.len()),\n+                    _ => return None,\n+                }\n+            };\n+            let token_start = t.text_range().start();\n+            let abs_in_expansion_offset = token_start + relative_comment_offset + descended_prefix_len;\n+\n+            let (attributes, def) = doc_attributes(sema, &node)?;\n+            let (docs, doc_mapping) = attributes.docs_with_rangemap(sema.db)?;\n+            let (in_expansion_range, link, ns) =\n+                extract_definitions_from_docs(&docs).into_iter().find_map(|(range, link, ns)| {\n+                    let mapped = doc_mapping.map(range)?;\n+                    (mapped.value.contains(abs_in_expansion_offset)).then(|| (mapped.value, link, ns))\n+                })?;\n+            // get the relative range to the doc/attribute in the expansion\n+            let in_expansion_relative_range = in_expansion_range - descended_prefix_len - token_start;\n+            // Apply relative range to the original input comment\n+            let absolute_range = in_expansion_relative_range + original_start + prefix_len;\n+            let def = match resolve_doc_path_for_def(sema.db, def, &link, ns)? {\n+                Either::Left(it) => Definition::ModuleDef(it),\n+                Either::Right(it) => Definition::Macro(it),\n+            };\n+            cb(def, node, absolute_range)\n+        })\n+    }\n+}\n+\n fn broken_link_clone_cb<'a, 'b>(link: BrokenLink<'a>) -> Option<(CowStr<'b>, CowStr<'b>)> {\n     // These allocations are actually unnecessary but the lifetimes on BrokenLinkCallback are wrong\n     // this is fixed in the repo but not on the crates.io release yet"}, {"sha": "911998d69b5b4e321c76bc51198960cbbf87afbb", "filename": "crates/ide/src/goto_definition.rs", "status": "modified", "additions": 8, "deletions": 17, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/61bb0cfbbe326c95dcc241df830e57e2be25b33c/crates%2Fide%2Fsrc%2Fgoto_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61bb0cfbbe326c95dcc241df830e57e2be25b33c/crates%2Fide%2Fsrc%2Fgoto_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fgoto_definition.rs?ref=61bb0cfbbe326c95dcc241df830e57e2be25b33c", "patch": "@@ -1,11 +1,9 @@\n use std::convert::TryInto;\n \n use crate::{\n-    display::TryToNav,\n-    doc_links::{doc_attributes, extract_definitions_from_docs, resolve_doc_path_for_def},\n-    FilePosition, NavigationTarget, RangeInfo,\n+    display::TryToNav, doc_links::token_as_doc_comment, FilePosition, NavigationTarget, RangeInfo,\n };\n-use hir::{AsAssocItem, InFile, ModuleDef, Semantics};\n+use hir::{AsAssocItem, ModuleDef, Semantics};\n use ide_db::{\n     base_db::{AnchoredPath, FileId, FileLoader},\n     defs::Definition,\n@@ -30,26 +28,19 @@ pub(crate) fn goto_definition(\n     db: &RootDatabase,\n     position: FilePosition,\n ) -> Option<RangeInfo<Vec<NavigationTarget>>> {\n-    let sema = Semantics::new(db);\n+    let sema = &Semantics::new(db);\n     let file = sema.parse(position.file_id).syntax().clone();\n     let original_token =\n         pick_best_token(file.token_at_offset(position.offset), |kind| match kind {\n             IDENT | INT_NUMBER | LIFETIME_IDENT | T![self] | T![super] | T![crate] | COMMENT => 2,\n             kind if kind.is_trivia() => 0,\n             _ => 1,\n         })?;\n-    if let Some(_) = ast::Comment::cast(original_token.clone()) {\n-        let parent = original_token.parent()?;\n-        let (attributes, def) = doc_attributes(&sema, &parent)?;\n-        let (docs, doc_mapping) = attributes.docs_with_rangemap(db)?;\n-        let (_, link, ns) =\n-            extract_definitions_from_docs(&docs).into_iter().find(|&(range, ..)| {\n-                doc_mapping.map(range).map_or(false, |InFile { file_id, value: range }| {\n-                    file_id == position.file_id.into() && range.contains(position.offset)\n-                })\n-            })?;\n-        let nav = resolve_doc_path_for_def(db, def, &link, ns)?.try_to_nav(db)?;\n-        return Some(RangeInfo::new(original_token.text_range(), vec![nav]));\n+    if let Some(doc_comment) = token_as_doc_comment(&original_token) {\n+        return doc_comment.get_definition_with_descend_at(sema, position.offset, |def, _, _| {\n+            let nav = def.try_to_nav(db)?;\n+            Some(RangeInfo::new(original_token.text_range(), vec![nav]))\n+        });\n     }\n     let navs = sema\n         .descend_into_macros_many(original_token.clone())"}, {"sha": "4b7043bd9b7ab2bbd37f3f26225cbe962bb5624d", "filename": "crates/ide/src/hover.rs", "status": "modified", "additions": 64, "deletions": 33, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/61bb0cfbbe326c95dcc241df830e57e2be25b33c/crates%2Fide%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61bb0cfbbe326c95dcc241df830e57e2be25b33c/crates%2Fide%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhover.rs?ref=61bb0cfbbe326c95dcc241df830e57e2be25b33c", "patch": "@@ -20,10 +20,7 @@ use syntax::{\n \n use crate::{\n     display::{macro_label, TryToNav},\n-    doc_links::{\n-        doc_attributes, extract_definitions_from_docs, remove_links, resolve_doc_path_for_def,\n-        rewrite_links,\n-    },\n+    doc_links::{remove_links, rewrite_links, token_as_doc_comment},\n     markdown_remove::remove_markdown,\n     markup::Markup,\n     runnables::{runnable_fn, runnable_mod},\n@@ -114,40 +111,15 @@ pub(crate) fn hover(\n         _ => 1,\n     })?;\n \n-    let descended = sema.descend_into_macros_many(original_token.clone());\n-\n-    // FIXME handle doc attributes? TokenMap currently doesn't work with comments\n-    if original_token.kind() == COMMENT {\n-        let relative_comment_offset = offset - original_token.text_range().start();\n-        // intra-doc links\n+    if let Some(doc_comment) = token_as_doc_comment(&original_token) {\n         cov_mark::hit!(no_highlight_on_comment_hover);\n-        return descended.iter().find_map(|t| {\n-            match t.kind() {\n-                COMMENT => (),\n-                TOKEN_TREE => {}\n-                _ => return None,\n-            }\n-            let node = t.parent()?;\n-            let absolute_comment_offset = t.text_range().start() + relative_comment_offset;\n-            let (attributes, def) = doc_attributes(sema, &node)?;\n-            let (docs, doc_mapping) = attributes.docs_with_rangemap(sema.db)?;\n-            let (idl_range, link, ns) = extract_definitions_from_docs(&docs).into_iter().find_map(\n-                |(range, link, ns)| {\n-                    let mapped = doc_mapping.map(range)?;\n-                    (mapped.file_id == file_id.into()\n-                        && mapped.value.contains(absolute_comment_offset))\n-                    .then(|| (mapped.value, link, ns))\n-                },\n-            )?;\n-            let def = match resolve_doc_path_for_def(sema.db, def, &link, ns)? {\n-                Either::Left(it) => Definition::ModuleDef(it),\n-                Either::Right(it) => Definition::Macro(it),\n-            };\n+        return doc_comment.get_definition_with_descend_at(sema, offset, |def, node, range| {\n             let res = hover_for_definition(sema, file_id, def, &node, config)?;\n-            Some(RangeInfo::new(idl_range, res))\n+            Some(RangeInfo::new(range, res))\n         });\n     }\n \n+    let descended = sema.descend_into_macros_many(original_token.clone());\n     // attributes, require special machinery as they are mere ident tokens\n \n     // FIXME: Definition should include known lints and the like instead of having this special case here\n@@ -4941,4 +4913,63 @@ fn foo() {\n             \"#]],\n         );\n     }\n+\n+    #[test]\n+    fn hover_intra_in_macro() {\n+        check(\n+            r#\"\n+macro_rules! foo_macro {\n+    ($(#[$attr:meta])* $name:ident) => {\n+        $(#[$attr])*\n+        pub struct $name;\n+    }\n+}\n+\n+foo_macro!(\n+    /// Doc comment for [`Foo$0`]\n+    Foo\n+);\n+\"#,\n+            expect![[r#\"\n+                *[`Foo`]*\n+\n+                ```rust\n+                test\n+                ```\n+\n+                ```rust\n+                pub struct Foo\n+                ```\n+\n+                ---\n+\n+                Doc comment for [`Foo`](https://docs.rs/test/*/test/struct.Foo.html)\n+            \"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn hover_intra_in_attr() {\n+        check(\n+            r#\"\n+#[doc = \"Doc comment for [`Foo$0`]\"]\n+pub struct Foo;\n+\"#,\n+            expect![[r#\"\n+                *[`Foo`]*\n+\n+                ```rust\n+                test\n+                ```\n+\n+                ```rust\n+                pub struct Foo\n+                ```\n+\n+                ---\n+\n+                Doc comment for [`Foo`](https://docs.rs/test/*/test/struct.Foo.html)\n+            \"#]],\n+        );\n+    }\n }"}, {"sha": "7f68543310994c60bb6fc98818dd3f2d9ef77175", "filename": "crates/mbe/src/syntax_bridge.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/61bb0cfbbe326c95dcc241df830e57e2be25b33c/crates%2Fmbe%2Fsrc%2Fsyntax_bridge.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61bb0cfbbe326c95dcc241df830e57e2be25b33c/crates%2Fmbe%2Fsrc%2Fsyntax_bridge.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Fsyntax_bridge.rs?ref=61bb0cfbbe326c95dcc241df830e57e2be25b33c", "patch": "@@ -149,7 +149,18 @@ fn convert_tokens<C: TokenConvertor>(conv: &mut C) -> tt::Subtree {\n         let k: SyntaxKind = token.kind();\n         if k == COMMENT {\n             if let Some(tokens) = conv.convert_doc_comment(&token) {\n-                result.extend(tokens);\n+                // FIXME: There has to be a better way to do this\n+                // Add the comments token id to the converted doc string\n+                let id = conv.id_alloc().alloc(range);\n+                result.extend(tokens.into_iter().map(|mut tt| {\n+                    if let tt::TokenTree::Subtree(sub) = &mut tt {\n+                        if let tt::TokenTree::Leaf(tt::Leaf::Literal(lit)) = &mut sub.token_trees[2]\n+                        {\n+                            lit.id = id\n+                        }\n+                    }\n+                    tt\n+                }));\n             }\n             continue;\n         }"}]}