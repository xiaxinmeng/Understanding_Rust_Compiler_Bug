{"sha": "178e29df7d2927641ddbadaaa92e1f1c17fa5c92", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE3OGUyOWRmN2QyOTI3NjQxZGRiYWRhYWE5MmUxZjFjMTdmYTVjOTI=", "commit": {"author": {"name": "arthurprs", "email": "arthurprs@gmail.com", "date": "2016-11-26T23:57:09Z"}, "committer": {"name": "arthurprs", "email": "arthurprs@gmail.com", "date": "2016-11-27T20:38:46Z"}, "message": "Use displacement instead of initial bucket in HashMap code", "tree": {"sha": "3ce2f24dd05674cab258402606487acbe8d55809", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3ce2f24dd05674cab258402606487acbe8d55809"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/178e29df7d2927641ddbadaaa92e1f1c17fa5c92", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/178e29df7d2927641ddbadaaa92e1f1c17fa5c92", "html_url": "https://github.com/rust-lang/rust/commit/178e29df7d2927641ddbadaaa92e1f1c17fa5c92", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/178e29df7d2927641ddbadaaa92e1f1c17fa5c92/comments", "author": {"login": "arthurprs", "id": 715958, "node_id": "MDQ6VXNlcjcxNTk1OA==", "avatar_url": "https://avatars.githubusercontent.com/u/715958?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arthurprs", "html_url": "https://github.com/arthurprs", "followers_url": "https://api.github.com/users/arthurprs/followers", "following_url": "https://api.github.com/users/arthurprs/following{/other_user}", "gists_url": "https://api.github.com/users/arthurprs/gists{/gist_id}", "starred_url": "https://api.github.com/users/arthurprs/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arthurprs/subscriptions", "organizations_url": "https://api.github.com/users/arthurprs/orgs", "repos_url": "https://api.github.com/users/arthurprs/repos", "events_url": "https://api.github.com/users/arthurprs/events{/privacy}", "received_events_url": "https://api.github.com/users/arthurprs/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arthurprs", "id": 715958, "node_id": "MDQ6VXNlcjcxNTk1OA==", "avatar_url": "https://avatars.githubusercontent.com/u/715958?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arthurprs", "html_url": "https://github.com/arthurprs", "followers_url": "https://api.github.com/users/arthurprs/followers", "following_url": "https://api.github.com/users/arthurprs/following{/other_user}", "gists_url": "https://api.github.com/users/arthurprs/gists{/gist_id}", "starred_url": "https://api.github.com/users/arthurprs/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arthurprs/subscriptions", "organizations_url": "https://api.github.com/users/arthurprs/orgs", "repos_url": "https://api.github.com/users/arthurprs/repos", "events_url": "https://api.github.com/users/arthurprs/events{/privacy}", "received_events_url": "https://api.github.com/users/arthurprs/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "73e98a0210f0afdec28b4f5bc0f7327d6a5a8555", "url": "https://api.github.com/repos/rust-lang/rust/commits/73e98a0210f0afdec28b4f5bc0f7327d6a5a8555", "html_url": "https://github.com/rust-lang/rust/commit/73e98a0210f0afdec28b4f5bc0f7327d6a5a8555"}], "stats": {"total": 39, "additions": 21, "deletions": 18}, "files": [{"sha": "f102a1bf6307bff2080338b5bac48f6a3306763f", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 21, "deletions": 18, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/178e29df7d2927641ddbadaaa92e1f1c17fa5c92/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/178e29df7d2927641ddbadaaa92e1f1c17fa5c92/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=178e29df7d2927641ddbadaaa92e1f1c17fa5c92", "patch": "@@ -371,9 +371,9 @@ fn search_hashed<K, V, M, F>(table: M, hash: SafeHash, mut is_match: F) -> Inter\n         return InternalEntry::TableIsEmpty;\n     }\n \n-    let size = table.size() as isize;\n+    let size = table.size();\n     let mut probe = Bucket::new(table, hash);\n-    let ib = probe.index() as isize;\n+    let mut displacement = 0;\n \n     loop {\n         let full = match probe.peek() {\n@@ -387,15 +387,15 @@ fn search_hashed<K, V, M, F>(table: M, hash: SafeHash, mut is_match: F) -> Inter\n             Full(bucket) => bucket,\n         };\n \n-        let robin_ib = full.index() as isize - full.displacement() as isize;\n+        let probe_displacement = full.displacement();\n \n-        if ib < robin_ib {\n+        if probe_displacement < displacement {\n             // Found a luckier bucket than me.\n             // We can finish the search early if we hit any bucket\n             // with a lower distance to initial bucket than we've probed.\n             return InternalEntry::Vacant {\n                 hash: hash,\n-                elem: NeqElem(full, robin_ib as usize),\n+                elem: NeqElem(full, probe_displacement),\n             };\n         }\n \n@@ -406,9 +406,9 @@ fn search_hashed<K, V, M, F>(table: M, hash: SafeHash, mut is_match: F) -> Inter\n                 return InternalEntry::Occupied { elem: full };\n             }\n         }\n-\n+        displacement += 1;\n         probe = full.next();\n-        debug_assert!(probe.index() as isize != ib + size + 1);\n+        debug_assert!(displacement <= size);\n     }\n }\n \n@@ -431,12 +431,11 @@ fn pop_internal<K, V>(starting_bucket: FullBucketMut<K, V>) -> (K, V) {\n }\n \n /// Perform robin hood bucket stealing at the given `bucket`. You must\n-/// also pass the position of that bucket's initial bucket so we don't have\n-/// to recalculate it.\n+/// also pass that bucket's displacement so we don't have to recalculate it.\n ///\n /// `hash`, `k`, and `v` are the elements to \"robin hood\" into the hashtable.\n fn robin_hood<'a, K: 'a, V: 'a>(bucket: FullBucketMut<'a, K, V>,\n-                                mut ib: usize,\n+                                mut displacement: usize,\n                                 mut hash: SafeHash,\n                                 mut key: K,\n                                 mut val: V)\n@@ -457,6 +456,7 @@ fn robin_hood<'a, K: 'a, V: 'a>(bucket: FullBucketMut<'a, K, V>,\n         val = old_val;\n \n         loop {\n+            displacement += 1;\n             let probe = bucket.next();\n             debug_assert!(probe.index() != idx_end);\n \n@@ -476,13 +476,13 @@ fn robin_hood<'a, K: 'a, V: 'a>(bucket: FullBucketMut<'a, K, V>,\n                 Full(bucket) => bucket,\n             };\n \n-            let probe_ib = full_bucket.index() - full_bucket.displacement();\n+            let probe_displacement = full_bucket.displacement();\n \n             bucket = full_bucket;\n \n             // Robin hood! Steal the spot.\n-            if ib < probe_ib {\n-                ib = probe_ib;\n+            if probe_displacement < displacement {\n+                displacement = probe_displacement;\n                 break;\n             }\n         }\n@@ -520,13 +520,16 @@ impl<K, V, S> HashMap<K, V, S>\n         search_hashed(&mut self.table, hash, |k| q.eq(k.borrow()))\n     }\n \n-    // The caller should ensure that invariants by Robin Hood Hashing hold.\n+    // The caller should ensure that invariants by Robin Hood Hashing hold\n+    // and that there's space in the underlying table.\n     fn insert_hashed_ordered(&mut self, hash: SafeHash, k: K, v: V) {\n         let raw_cap = self.raw_capacity();\n         let mut buckets = Bucket::new(&mut self.table, hash);\n-        let ib = buckets.index();\n+        // note that buckets.index() keeps increasing\n+        // even if the pointer wraps back to the first bucket.\n+        let limit_bucket = buckets.index() + raw_cap;\n \n-        while buckets.index() != ib + raw_cap {\n+        loop {\n             // We don't need to compare hashes for value swap.\n             // Not even DIBs for Robin Hood.\n             buckets = match buckets.peek() {\n@@ -537,8 +540,8 @@ impl<K, V, S> HashMap<K, V, S>\n                 Full(b) => b.into_bucket(),\n             };\n             buckets.next();\n+            debug_assert!(buckets.index() < limit_bucket);\n         }\n-        panic!(\"Internal HashMap error: Out of space.\");\n     }\n }\n \n@@ -1959,7 +1962,7 @@ impl<'a, K: 'a, V: 'a> VacantEntry<'a, K, V> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn insert(self, value: V) -> &'a mut V {\n         match self.elem {\n-            NeqElem(bucket, ib) => robin_hood(bucket, ib, self.hash, self.key, value),\n+            NeqElem(bucket, disp) => robin_hood(bucket, disp, self.hash, self.key, value),\n             NoElem(bucket) => bucket.put(self.hash, self.key, value).into_mut_refs().1,\n         }\n     }"}]}