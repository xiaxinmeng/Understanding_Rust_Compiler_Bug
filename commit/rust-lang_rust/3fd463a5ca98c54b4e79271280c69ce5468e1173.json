{"sha": "3fd463a5ca98c54b4e79271280c69ce5468e1173", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNmZDQ2M2E1Y2E5OGM1NGI0ZTc5MjcxMjgwYzY5Y2U1NDY4ZTExNzM=", "commit": {"author": {"name": "Amanieu d'Antras", "email": "amanieu@gmail.com", "date": "2021-07-29T11:43:26Z"}, "committer": {"name": "Amanieu d'Antras", "email": "amanieu@gmail.com", "date": "2021-08-12T11:43:11Z"}, "message": "Add support for clobber_abi to asm!", "tree": {"sha": "a89ee858ba88f4d0866b4e11093fd3dc850dacb5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a89ee858ba88f4d0866b4e11093fd3dc850dacb5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3fd463a5ca98c54b4e79271280c69ce5468e1173", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3fd463a5ca98c54b4e79271280c69ce5468e1173", "html_url": "https://github.com/rust-lang/rust/commit/3fd463a5ca98c54b4e79271280c69ce5468e1173", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3fd463a5ca98c54b4e79271280c69ce5468e1173/comments", "author": {"login": "Amanieu", "id": 278509, "node_id": "MDQ6VXNlcjI3ODUwOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/278509?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Amanieu", "html_url": "https://github.com/Amanieu", "followers_url": "https://api.github.com/users/Amanieu/followers", "following_url": "https://api.github.com/users/Amanieu/following{/other_user}", "gists_url": "https://api.github.com/users/Amanieu/gists{/gist_id}", "starred_url": "https://api.github.com/users/Amanieu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Amanieu/subscriptions", "organizations_url": "https://api.github.com/users/Amanieu/orgs", "repos_url": "https://api.github.com/users/Amanieu/repos", "events_url": "https://api.github.com/users/Amanieu/events{/privacy}", "received_events_url": "https://api.github.com/users/Amanieu/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Amanieu", "id": 278509, "node_id": "MDQ6VXNlcjI3ODUwOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/278509?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Amanieu", "html_url": "https://github.com/Amanieu", "followers_url": "https://api.github.com/users/Amanieu/followers", "following_url": "https://api.github.com/users/Amanieu/following{/other_user}", "gists_url": "https://api.github.com/users/Amanieu/gists{/gist_id}", "starred_url": "https://api.github.com/users/Amanieu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Amanieu/subscriptions", "organizations_url": "https://api.github.com/users/Amanieu/orgs", "repos_url": "https://api.github.com/users/Amanieu/repos", "events_url": "https://api.github.com/users/Amanieu/events{/privacy}", "received_events_url": "https://api.github.com/users/Amanieu/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2f4612260d35ef162c088b6b1a87f1e75717acb6", "url": "https://api.github.com/repos/rust-lang/rust/commits/2f4612260d35ef162c088b6b1a87f1e75717acb6", "html_url": "https://github.com/rust-lang/rust/commit/2f4612260d35ef162c088b6b1a87f1e75717acb6"}], "stats": {"total": 731, "additions": 652, "deletions": 79}, "files": [{"sha": "bd6e4c30fc34c6e4b07832fd6b6cca6ef6bf2f30", "filename": "compiler/rustc_ast/src/ast.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3fd463a5ca98c54b4e79271280c69ce5468e1173/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fd463a5ca98c54b4e79271280c69ce5468e1173/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast.rs?ref=3fd463a5ca98c54b4e79271280c69ce5468e1173", "patch": "@@ -2027,6 +2027,7 @@ pub enum InlineAsmOperand {\n pub struct InlineAsm {\n     pub template: Vec<InlineAsmTemplatePiece>,\n     pub operands: Vec<(InlineAsmOperand, Span)>,\n+    pub clobber_abi: Option<(Symbol, Span)>,\n     pub options: InlineAsmOptions,\n     pub line_spans: Vec<Span>,\n }"}, {"sha": "d94fb48d7cb883513e8798c55cc41a800c1dd164", "filename": "compiler/rustc_ast_lowering/src/asm.rs", "status": "modified", "additions": 55, "deletions": 1, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/3fd463a5ca98c54b4e79271280c69ce5468e1173/compiler%2Frustc_ast_lowering%2Fsrc%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fd463a5ca98c54b4e79271280c69ce5468e1173/compiler%2Frustc_ast_lowering%2Fsrc%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fasm.rs?ref=3fd463a5ca98c54b4e79271280c69ce5468e1173", "patch": "@@ -27,11 +27,41 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 .emit();\n         }\n \n+        let mut clobber_abi = None;\n+        if let Some(asm_arch) = asm_arch {\n+            if let Some((abi_name, abi_span)) = asm.clobber_abi {\n+                match asm::InlineAsmClobberAbi::parse(asm_arch, &self.sess.target, abi_name) {\n+                    Ok(abi) => clobber_abi = Some((abi, abi_span)),\n+                    Err(&[]) => {\n+                        self.sess\n+                            .struct_span_err(\n+                                abi_span,\n+                                \"`clobber_abi` is not supported on this target\",\n+                            )\n+                            .emit();\n+                    }\n+                    Err(supported_abis) => {\n+                        let mut err =\n+                            self.sess.struct_span_err(abi_span, \"invalid ABI for `clobber_abi`\");\n+                        let mut abis = format!(\"`{}`\", supported_abis[0]);\n+                        for m in &supported_abis[1..] {\n+                            let _ = write!(abis, \", `{}`\", m);\n+                        }\n+                        err.note(&format!(\n+                            \"the following ABIs are supported on this target: {}\",\n+                            abis\n+                        ));\n+                        err.emit();\n+                    }\n+                }\n+            }\n+        }\n+\n         // Lower operands to HIR. We use dummy register classes if an error\n         // occurs during lowering because we still need to be able to produce a\n         // valid HIR.\n         let sess = self.sess;\n-        let operands: Vec<_> = asm\n+        let mut operands: Vec<_> = asm\n             .operands\n             .iter()\n             .map(|(op, op_sp)| {\n@@ -336,6 +366,30 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             }\n         }\n \n+        // If a clobber_abi is specified, add the necessary clobbers to the\n+        // operands list.\n+        if let Some((abi, abi_span)) = clobber_abi {\n+            for &clobber in abi.clobbered_regs() {\n+                let mut output_used = false;\n+                clobber.overlapping_regs(|reg| {\n+                    if used_output_regs.contains_key(&reg) {\n+                        output_used = true;\n+                    }\n+                });\n+\n+                if !output_used {\n+                    operands.push((\n+                        hir::InlineAsmOperand::Out {\n+                            reg: asm::InlineAsmRegOrRegClass::Reg(clobber),\n+                            late: true,\n+                            expr: None,\n+                        },\n+                        abi_span,\n+                    ));\n+                }\n+            }\n+        }\n+\n         let operands = self.arena.alloc_from_iter(operands);\n         let template = self.arena.alloc_from_iter(asm.template.iter().cloned());\n         let line_spans = self.arena.alloc_slice(&asm.line_spans[..]);"}, {"sha": "763c1b12bf883f358bd18498e5780cbd39ad3e50", "filename": "compiler/rustc_ast_pretty/src/pprust/state.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3fd463a5ca98c54b4e79271280c69ce5468e1173/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fd463a5ca98c54b4e79271280c69ce5468e1173/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs?ref=3fd463a5ca98c54b4e79271280c69ce5468e1173", "patch": "@@ -2186,11 +2186,15 @@ impl<'a> State<'a> {\n         enum AsmArg<'a> {\n             Template(String),\n             Operand(&'a InlineAsmOperand),\n+            ClobberAbi(Symbol),\n             Options(InlineAsmOptions),\n         }\n \n         let mut args = vec![AsmArg::Template(InlineAsmTemplatePiece::to_string(&asm.template))];\n         args.extend(asm.operands.iter().map(|(o, _)| AsmArg::Operand(o)));\n+        if let Some((abi, _)) = asm.clobber_abi {\n+            args.push(AsmArg::ClobberAbi(abi));\n+        }\n         if !asm.options.is_empty() {\n             args.push(AsmArg::Options(asm.options));\n         }\n@@ -2257,6 +2261,12 @@ impl<'a> State<'a> {\n                     }\n                 }\n             }\n+            AsmArg::ClobberAbi(abi) => {\n+                s.word(\"clobber_abi\");\n+                s.popen();\n+                s.print_symbol(*abi, ast::StrStyle::Cooked);\n+                s.pclose();\n+            }\n             AsmArg::Options(opts) => {\n                 s.word(\"options\");\n                 s.popen();"}, {"sha": "3eaa629448a03a09de96fb9fb8cd5d54a1ddd2f3", "filename": "compiler/rustc_builtin_macros/src/asm.rs", "status": "modified", "additions": 100, "deletions": 7, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/3fd463a5ca98c54b4e79271280c69ce5468e1173/compiler%2Frustc_builtin_macros%2Fsrc%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fd463a5ca98c54b4e79271280c69ce5468e1173/compiler%2Frustc_builtin_macros%2Fsrc%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fasm.rs?ref=3fd463a5ca98c54b4e79271280c69ce5468e1173", "patch": "@@ -19,6 +19,7 @@ struct AsmArgs {\n     operands: Vec<(ast::InlineAsmOperand, Span)>,\n     named_args: FxHashMap<Symbol, usize>,\n     reg_args: FxHashSet<usize>,\n+    clobber_abi: Option<(Symbol, Span)>,\n     options: ast::InlineAsmOptions,\n     options_spans: Vec<Span>,\n }\n@@ -63,6 +64,7 @@ fn parse_args<'a>(\n         operands: vec![],\n         named_args: FxHashMap::default(),\n         reg_args: FxHashSet::default(),\n+        clobber_abi: None,\n         options: ast::InlineAsmOptions::empty(),\n         options_spans: vec![],\n     };\n@@ -85,6 +87,13 @@ fn parse_args<'a>(\n             break;\n         } // accept trailing commas\n \n+        // Parse clobber_abi\n+        if p.eat_keyword(sym::clobber_abi) {\n+            parse_clobber_abi(&mut p, &mut args)?;\n+            allow_templates = false;\n+            continue;\n+        }\n+\n         // Parse options\n         if p.eat_keyword(sym::options) {\n             parse_options(&mut p, &mut args, is_global_asm)?;\n@@ -160,7 +169,11 @@ fn parse_args<'a>(\n                 ast::ExprKind::Lit(ast::Lit { kind: ast::LitKind::Str(..), .. }) => {}\n                 ast::ExprKind::MacCall(..) => {}\n                 _ => {\n-                    let errstr = \"expected operand, options, or additional template string\";\n+                    let errstr = if is_global_asm {\n+                        \"expected operand, options, or additional template string\"\n+                    } else {\n+                        \"expected operand, clobber_abi, options, or additional template string\"\n+                    };\n                     let mut err = ecx.struct_span_err(template.span, errstr);\n                     err.span_label(template.span, errstr);\n                     return Err(err);\n@@ -177,13 +190,19 @@ fn parse_args<'a>(\n         let slot = args.operands.len();\n         args.operands.push((op, span));\n \n-        // Validate the order of named, positional & explicit register operands and options. We do\n-        // this at the end once we have the full span of the argument available.\n+        // Validate the order of named, positional & explicit register operands and\n+        // clobber_abi/options. We do this at the end once we have the full span\n+        // of the argument available.\n         if !args.options_spans.is_empty() {\n             ecx.struct_span_err(span, \"arguments are not allowed after options\")\n                 .span_labels(args.options_spans.clone(), \"previous options\")\n                 .span_label(span, \"argument\")\n                 .emit();\n+        } else if let Some((_, abi_span)) = args.clobber_abi {\n+            ecx.struct_span_err(span, \"arguments are not allowed after clobber_abi\")\n+                .span_label(abi_span, \"clobber_abi\")\n+                .span_label(span, \"argument\")\n+                .emit();\n         }\n         if explicit_reg {\n             if name.is_some() {\n@@ -256,16 +275,23 @@ fn parse_args<'a>(\n \n     let mut have_real_output = false;\n     let mut outputs_sp = vec![];\n+    let mut regclass_outputs = vec![];\n     for (op, op_sp) in &args.operands {\n         match op {\n-            ast::InlineAsmOperand::Out { expr, .. }\n-            | ast::InlineAsmOperand::SplitInOut { out_expr: expr, .. } => {\n+            ast::InlineAsmOperand::Out { reg, expr, .. }\n+            | ast::InlineAsmOperand::SplitInOut { reg, out_expr: expr, .. } => {\n                 outputs_sp.push(*op_sp);\n                 have_real_output |= expr.is_some();\n+                if let ast::InlineAsmRegOrRegClass::RegClass(_) = reg {\n+                    regclass_outputs.push(*op_sp);\n+                }\n             }\n-            ast::InlineAsmOperand::InOut { .. } => {\n+            ast::InlineAsmOperand::InOut { reg, .. } => {\n                 outputs_sp.push(*op_sp);\n                 have_real_output = true;\n+                if let ast::InlineAsmRegOrRegClass::RegClass(_) = reg {\n+                    regclass_outputs.push(*op_sp);\n+                }\n             }\n             _ => {}\n         }\n@@ -284,6 +310,24 @@ fn parse_args<'a>(\n         // Bail out now since this is likely to confuse MIR\n         return Err(err);\n     }\n+    if let Some((_, abi_span)) = args.clobber_abi {\n+        if is_global_asm {\n+            let err =\n+                ecx.struct_span_err(abi_span, \"`clobber_abi` cannot be used with `global_asm!`\");\n+\n+            // Bail out now since this is likely to confuse later stages\n+            return Err(err);\n+        }\n+        if !regclass_outputs.is_empty() {\n+            ecx.struct_span_err(\n+                regclass_outputs.clone(),\n+                \"asm with `clobber_abi` must specify explicit registers for outputs\",\n+            )\n+            .span_label(abi_span, \"clobber_abi\")\n+            .span_labels(regclass_outputs, \"generic outputs\")\n+            .emit();\n+        }\n+    }\n \n     Ok(args)\n }\n@@ -375,6 +419,49 @@ fn parse_options<'a>(\n     Ok(())\n }\n \n+fn parse_clobber_abi<'a>(\n+    p: &mut Parser<'a>,\n+    args: &mut AsmArgs,\n+) -> Result<(), DiagnosticBuilder<'a>> {\n+    let span_start = p.prev_token.span;\n+\n+    p.expect(&token::OpenDelim(token::DelimToken::Paren))?;\n+\n+    let clobber_abi = match p.parse_str_lit() {\n+        Ok(str_lit) => str_lit.symbol_unescaped,\n+        Err(opt_lit) => {\n+            let span = opt_lit.map_or(p.token.span, |lit| lit.span);\n+            let mut err = p.sess.span_diagnostic.struct_span_err(span, \"expected string literal\");\n+            err.span_label(span, \"not a string literal\");\n+            return Err(err);\n+        }\n+    };\n+\n+    p.expect(&token::CloseDelim(token::DelimToken::Paren))?;\n+\n+    let new_span = span_start.to(p.prev_token.span);\n+\n+    if let Some((_, prev_span)) = args.clobber_abi {\n+        let mut err = p\n+            .sess\n+            .span_diagnostic\n+            .struct_span_err(new_span, \"clobber_abi specified multiple times\");\n+        err.span_label(prev_span, \"clobber_abi previously specified here\");\n+        return Err(err);\n+    } else if !args.options_spans.is_empty() {\n+        let mut err = p\n+            .sess\n+            .span_diagnostic\n+            .struct_span_err(new_span, \"clobber_abi is not allowed after options\");\n+        err.span_labels(args.options_spans.clone(), \"options\");\n+        return Err(err);\n+    }\n+\n+    args.clobber_abi = Some((clobber_abi, new_span));\n+\n+    Ok(())\n+}\n+\n fn parse_reg<'a>(\n     p: &mut Parser<'a>,\n     explicit_reg: &mut bool,\n@@ -660,7 +747,13 @@ fn expand_preparsed_asm(ecx: &mut ExtCtxt<'_>, args: AsmArgs) -> Option<ast::Inl\n         }\n     }\n \n-    Some(ast::InlineAsm { template, operands: args.operands, options: args.options, line_spans })\n+    Some(ast::InlineAsm {\n+        template,\n+        operands: args.operands,\n+        clobber_abi: args.clobber_abi,\n+        options: args.options,\n+        line_spans,\n+    })\n }\n \n pub fn expand_asm<'cx>("}, {"sha": "e4e7139ce73706d8fc61ac301c2f74409c7befb2", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3fd463a5ca98c54b4e79271280c69ce5468e1173/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fd463a5ca98c54b4e79271280c69ce5468e1173/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=3fd463a5ca98c54b4e79271280c69ce5468e1173", "patch": "@@ -377,6 +377,7 @@ symbols! {\n         char,\n         client,\n         clippy,\n+        clobber_abi,\n         clone,\n         clone_closures,\n         clone_from,"}, {"sha": "9ebf8235e209883e8434647f1a42223ccfa8e79f", "filename": "compiler/rustc_target/src/asm/mod.rs", "status": "modified", "additions": 182, "deletions": 0, "changes": 182, "blob_url": "https://github.com/rust-lang/rust/blob/3fd463a5ca98c54b4e79271280c69ce5468e1173/compiler%2Frustc_target%2Fsrc%2Fasm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fd463a5ca98c54b4e79271280c69ce5468e1173/compiler%2Frustc_target%2Fsrc%2Fasm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fasm%2Fmod.rs?ref=3fd463a5ca98c54b4e79271280c69ce5468e1173", "patch": "@@ -712,3 +712,185 @@ pub fn allocatable_registers(\n         }\n     }\n }\n+\n+#[derive(\n+    Copy,\n+    Clone,\n+    Encodable,\n+    Decodable,\n+    Debug,\n+    Eq,\n+    PartialEq,\n+    PartialOrd,\n+    Hash,\n+    HashStable_Generic\n+)]\n+pub enum InlineAsmClobberAbi {\n+    X86,\n+    X86_64Win,\n+    X86_64SysV,\n+    Arm,\n+    AArch64,\n+    RiscV,\n+}\n+\n+impl InlineAsmClobberAbi {\n+    /// Parses a clobber ABI for the given target, or returns a list of supported\n+    /// clobber ABIs for the target.\n+    pub fn parse(\n+        arch: InlineAsmArch,\n+        target: &Target,\n+        name: Symbol,\n+    ) -> Result<Self, &'static [&'static str]> {\n+        let name = &*name.as_str();\n+        match arch {\n+            InlineAsmArch::X86 => match name {\n+                \"C\" | \"system\" | \"efiapi\" | \"cdecl\" | \"stdcall\" | \"fastcall\" => {\n+                    Ok(InlineAsmClobberAbi::X86)\n+                }\n+                _ => Err(&[\"C\", \"system\", \"efiapi\", \"cdecl\", \"stdcall\", \"fastcall\"]),\n+            },\n+            InlineAsmArch::X86_64 => match name {\n+                \"C\" | \"system\" if !target.is_like_windows => Ok(InlineAsmClobberAbi::X86_64SysV),\n+                \"C\" | \"system\" if target.is_like_windows => Ok(InlineAsmClobberAbi::X86_64Win),\n+                \"win64\" | \"efiapi\" => Ok(InlineAsmClobberAbi::X86_64Win),\n+                \"sysv64\" => Ok(InlineAsmClobberAbi::X86_64SysV),\n+                _ => Err(&[\"C\", \"system\", \"efiapi\", \"win64\", \"sysv64\"]),\n+            },\n+            InlineAsmArch::Arm => match name {\n+                \"C\" | \"system\" | \"efiapi\" | \"aapcs\" => Ok(InlineAsmClobberAbi::Arm),\n+                _ => Err(&[\"C\", \"system\", \"efiapi\", \"aapcs\"]),\n+            },\n+            InlineAsmArch::AArch64 => match name {\n+                \"C\" | \"system\" | \"efiapi\" => Ok(InlineAsmClobberAbi::AArch64),\n+                _ => Err(&[\"C\", \"system\", \"efiapi\"]),\n+            },\n+            InlineAsmArch::RiscV32 | InlineAsmArch::RiscV64 => match name {\n+                \"C\" | \"system\" | \"efiapi\" => Ok(InlineAsmClobberAbi::RiscV),\n+                _ => Err(&[\"C\", \"system\", \"efiapi\"]),\n+            },\n+            _ => Err(&[]),\n+        }\n+    }\n+\n+    /// Returns the set of registers which are clobbered by this ABI.\n+    pub fn clobbered_regs(self) -> &'static [InlineAsmReg] {\n+        macro_rules! clobbered_regs {\n+            ($arch:ident $arch_reg:ident {\n+                $(\n+                    $reg:ident,\n+                )*\n+            }) => {\n+                &[\n+                    $(InlineAsmReg::$arch($arch_reg::$reg),)*\n+                ]\n+            };\n+        }\n+        match self {\n+            InlineAsmClobberAbi::X86 => clobbered_regs! {\n+                X86 X86InlineAsmReg {\n+                    ax, cx, dx,\n+\n+                    xmm0, xmm1, xmm2, xmm3, xmm4, xmm5, xmm6, xmm7,\n+\n+                    k1, k2, k3, k4, k5, k6, k7,\n+\n+                    mm0, mm1, mm2, mm3, mm4, mm5, mm6, mm7,\n+                    st0, st1, st2, st3, st4, st5, st6, st7,\n+                }\n+            },\n+            InlineAsmClobberAbi::X86_64SysV => clobbered_regs! {\n+                X86 X86InlineAsmReg {\n+                    ax, cx, dx, si, di, r8, r9, r10, r11,\n+\n+                    xmm0, xmm1, xmm2, xmm3, xmm4, xmm5, xmm6, xmm7,\n+                    xmm8, xmm9, xmm10, xmm11, xmm12, xmm13, xmm14, xmm15,\n+                    zmm16, zmm17, zmm18, zmm19, zmm20, zmm21, zmm22, zmm23,\n+                    zmm24, zmm25, zmm26, zmm27, zmm28, zmm29, zmm30, zmm31,\n+\n+                    k1, k2, k3, k4, k5, k6, k7,\n+\n+                    mm0, mm1, mm2, mm3, mm4, mm5, mm6, mm7,\n+                    st0, st1, st2, st3, st4, st5, st6, st7,\n+                }\n+            },\n+            InlineAsmClobberAbi::X86_64Win => clobbered_regs! {\n+                X86 X86InlineAsmReg {\n+                    // rdi and rsi are callee-saved on windows\n+                    ax, cx, dx, r8, r9, r10, r11,\n+\n+                    // xmm6-xmm15 are callee-saved on windows, but we need to\n+                    // mark them as clobbered anyways because the upper portions\n+                    // of ymm6-ymm15 are volatile.\n+                    xmm0, xmm1, xmm2, xmm3, xmm4, xmm5, xmm6, xmm7,\n+                    xmm8, xmm9, xmm10, xmm11, xmm12, xmm13, xmm14, xmm15,\n+                    zmm16, zmm17, zmm18, zmm19, zmm20, zmm21, zmm22, zmm23,\n+                    zmm24, zmm25, zmm26, zmm27, zmm28, zmm29, zmm30, zmm31,\n+\n+                    k1, k2, k3, k4, k5, k6, k7,\n+\n+                    mm0, mm1, mm2, mm3, mm4, mm5, mm6, mm7,\n+                    st0, st1, st2, st3, st4, st5, st6, st7,\n+                }\n+            },\n+            InlineAsmClobberAbi::AArch64 => clobbered_regs! {\n+                AArch64 AArch64InlineAsmReg {\n+                    x0, x1, x2, x3, x4, x5, x6, x7,\n+                    x8, x9, x10, x11, x12, x13, x14, x15,\n+                    // x18 is platform-reserved or temporary, but we exclude it\n+                    // here since it is a reserved register.\n+                    x16, x17, x30,\n+\n+                    // Technically the low 64 bits of v8-v15 are preserved, but\n+                    // we have no way of expressing this using clobbers.\n+                    v0, v1, v2, v3, v4, v5, v6, v7,\n+                    v8, v9, v10, v11, v12, v13, v14, v15,\n+                    v16, v17, v18, v19, v20, v21, v22, v23,\n+                    v24, v25, v26, v27, v28, v29, v30, v31,\n+\n+                    p0, p1, p2, p3, p4, p5, p6, p7,\n+                    p8, p9, p10, p11, p12, p13, p14, p15,\n+                    ffr,\n+\n+                }\n+            },\n+            InlineAsmClobberAbi::Arm => clobbered_regs! {\n+                Arm ArmInlineAsmReg {\n+                    // r9 is platform-reserved and is treated as callee-saved.\n+                    r0, r1, r2, r3, r12, r14,\n+\n+                    // The finest-grained register variant is used here so that\n+                    // partial uses of larger registers are properly handled.\n+                    s0, s1, s2, s3, s4, s5, s6, s7,\n+                    s8, s9, s10, s11, s12, s13, s14, s15,\n+                    // s16-s31 are callee-saved\n+                    d16, d17, d18, d19, d20, d21, d22, d23,\n+                    d24, d25, d26, d27, d28, d29, d30, d31,\n+                }\n+            },\n+            InlineAsmClobberAbi::RiscV => clobbered_regs! {\n+                RiscV RiscVInlineAsmReg {\n+                    // ra\n+                    x1,\n+                    // t0-t2\n+                    x5, x6, x7,\n+                    // a0-a7\n+                    x10, x11, x12, x13, x14, x15, x16, x17,\n+                    // t3-t6\n+                    x28, x29, x30, x31,\n+                    // ft0-ft7\n+                    f0, f1, f2, f3, f4, f5, f6, f7,\n+                    // fa0-fa7\n+                    f10, f11, f12, f13, f14, f15, f16, f17,\n+                    // ft8-ft11\n+                    f28, f29, f30, f31,\n+\n+                    v0, v1, v2, v3, v4, v5, v6, v7,\n+                    v8, v9, v10, v11, v12, v13, v14, v15,\n+                    v16, v17, v18, v19, v20, v21, v22, v23,\n+                    v24, v25, v26, v27, v28, v29, v30, v31,\n+                }\n+            },\n+        }\n+    }\n+}"}, {"sha": "220b74ca6e6e1b438c26383fc3ce0ac9b33c50b7", "filename": "src/doc/unstable-book/src/library-features/asm.md", "status": "modified", "additions": 49, "deletions": 21, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/3fd463a5ca98c54b4e79271280c69ce5468e1173/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fasm.md", "raw_url": "https://github.com/rust-lang/rust/raw/3fd463a5ca98c54b4e79271280c69ce5468e1173/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fasm.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fasm.md?ref=3fd463a5ca98c54b4e79271280c69ce5468e1173", "patch": "@@ -290,45 +290,42 @@ unsafe {\n assert_eq!(x, 4 * 6);\n ```\n \n-## Symbol operands\n+## Symbol operands and ABI clobbers\n \n A special operand type, `sym`, allows you to use the symbol name of a `fn` or `static` in inline assembly code.\n This allows you to call a function or access a global variable without needing to keep its address in a register.\n \n ```rust,allow_fail\n #![feature(asm)]\n-extern \"C\" fn foo(arg: i32) {\n+extern \"C\" fn foo(arg: i32) -> i32 {\n     println!(\"arg = {}\", arg);\n+    arg * 2\n }\n \n-fn call_foo(arg: i32) {\n+fn call_foo(arg: i32) -> i32 {\n     unsafe {\n+        let result;\n         asm!(\n             \"call {}\",\n             sym foo,\n-            // 1st argument in rdi, which is caller-saved\n-            inout(\"rdi\") arg => _,\n-            // All caller-saved registers must be marked as clobbered\n-            out(\"rax\") _, out(\"rcx\") _, out(\"rdx\") _, out(\"rsi\") _,\n-            out(\"r8\") _, out(\"r9\") _, out(\"r10\") _, out(\"r11\") _,\n-            out(\"xmm0\") _, out(\"xmm1\") _, out(\"xmm2\") _, out(\"xmm3\") _,\n-            out(\"xmm4\") _, out(\"xmm5\") _, out(\"xmm6\") _, out(\"xmm7\") _,\n-            out(\"xmm8\") _, out(\"xmm9\") _, out(\"xmm10\") _, out(\"xmm11\") _,\n-            out(\"xmm12\") _, out(\"xmm13\") _, out(\"xmm14\") _, out(\"xmm15\") _,\n-            // Also mark AVX-512 registers as clobbered. This is accepted by the\n-            // compiler even if AVX-512 is not enabled on the current target.\n-            out(\"xmm16\") _, out(\"xmm17\") _, out(\"xmm18\") _, out(\"xmm19\") _,\n-            out(\"xmm20\") _, out(\"xmm21\") _, out(\"xmm22\") _, out(\"xmm23\") _,\n-            out(\"xmm24\") _, out(\"xmm25\") _, out(\"xmm26\") _, out(\"xmm27\") _,\n-            out(\"xmm28\") _, out(\"xmm29\") _, out(\"xmm30\") _, out(\"xmm31\") _,\n-        )\n+            // 1st argument in rdi\n+            in(\"rdi\") arg,\n+            // Return value in rax\n+            out(\"rax\") result,\n+            // Mark all registers which are not preserved by the \"C\" calling\n+            // convention as clobbered.\n+            clobber_abi(\"C\"),\n+        );\n+        result\n     }\n }\n ```\n \n Note that the `fn` or `static` item does not need to be public or `#[no_mangle]`:\n the compiler will automatically insert the appropriate mangled symbol name into the assembly code.\n \n+By default, `asm!` assumes that any register not specified as an output will have its contents preserved by the assembly code. The [`clobber_abi`](#abi-clobbers) argument to `asm!` tells the compiler to automatically insert the necessary clobber operands according to the given calling convention ABI: any register which is not fully preserved in that ABI will be treated as clobbered.\n+\n ## Register template modifiers\n \n In some cases, fine control is needed over the way a register name is formatted when inserted into the template string. This is needed when an architecture's assembly language has several names for the same register, each typically being a \"view\" over a subset of the register (e.g. the low 32 bits of a 64-bit register).\n@@ -456,12 +453,25 @@ reg_spec := <register class> / \"<explicit register>\"\n operand_expr := expr / \"_\" / expr \"=>\" expr / expr \"=>\" \"_\"\n reg_operand := dir_spec \"(\" reg_spec \")\" operand_expr\n operand := reg_operand / \"const\" const_expr / \"sym\" path\n+clobber_abi := \"clobber_abi(\" <abi> \")\"\n option := \"pure\" / \"nomem\" / \"readonly\" / \"preserves_flags\" / \"noreturn\" / \"nostack\" / \"att_syntax\" / \"raw\"\n options := \"options(\" option *[\",\" option] [\",\"] \")\"\n-asm := \"asm!(\" format_string *(\",\" format_string) *(\",\" [ident \"=\"] operand) [\",\" options] [\",\"] \")\"\n+asm := \"asm!(\" format_string *(\",\" format_string) *(\",\" [ident \"=\"] operand) [\",\" clobber_abi]  [\",\" options] [\",\"] \")\"\n ```\n \n-The macro will initially be supported only on ARM, AArch64, Hexagon, PowerPC, x86, x86-64 and RISC-V targets. Support for more targets may be added in the future. The compiler will emit an error if `asm!` is used on an unsupported target.\n+Inline assembly is currently supported on the following architectures:\n+- x86 and x86-64\n+- ARM\n+- AArch64\n+- RISC-V\n+- NVPTX\n+- PowerPC\n+- Hexagon\n+- MIPS32r2 and MIPS64r2\n+- wasm32\n+- BPF\n+\n+Support for more targets may be added in the future. The compiler will emit an error if `asm!` is used on an unsupported target.\n \n [format-syntax]: https://doc.rust-lang.org/std/fmt/#syntax\n \n@@ -780,6 +790,24 @@ As stated in the previous section, passing an input value smaller than the regis\n \n [llvm-argmod]: http://llvm.org/docs/LangRef.html#asm-template-argument-modifiers\n \n+## ABI clobbers\n+\n+The `clobber_abi` keyword can be used to apply a default set of clobbers to an `asm` block. This will automatically insert the necessary clobber constraints as needed for calling a function with a particular calling convention: if the calling convention does not fully preserve the value of a register across a call then a `lateout(\"reg\") _` is implicitly added to the operands list.\n+\n+Generic register class outputs are disallowed by the compiler when `clobber_abi` is used: all outputs must specify an explicit register. Explicit register outputs have precedence over the implicit clobbers inserted by `clobber_abi`: a clobber will only be inserted for a register if that register is not used as an output.\n+The following ABIs can be used with `clobber_abi`:\n+\n+| Architecture | ABI name | Clobbered registers |\n+| ------------ | -------- | ------------------- |\n+| x86-32 | `\"C\"`, `\"system\"`, `\"efiapi\"`, `\"cdecl\"`, `\"stdcall\"`, `\"fastcall\"` | `ax`, `cx`, `dx`, `xmm[0-7]`, `mm[0-7]`, `st([0-7])` |\n+| x86-64 | `\"C\"`, `\"system\"` (on Windows), `\"efiapi\"`, `\"win64\"` | `ax`, `cx`, `dx`, `r[8-11]`, `xmm[0-31]`, `mm[0-7]`, `st([0-7])` |\n+| x86-64 | `\"C\"`, `\"system\"` (on non-Windows), `\"sysv64\"` | `ax`, `cx`, `dx`, `si`, `di`, `r[8-11]`, `xmm[0-31]`, `mm[0-7]`, `st([0-7])` |\n+| AArch64 | `\"C\"`, `\"system\"`, `\"efiapi\"` | `x[0-17]`, `x30`, `v[0-31]`, `p[0-15]`, `ffr` |\n+| ARM | `\"C\"`, `\"system\"`, `\"efiapi\"`, `\"aapcs\"` | `r[0-3]`, `r12`, `r14`, `s[0-15]`, `d[0-7]`, `d[16-31]` |\n+| RISC-V | `\"C\"`, `\"system\"`, `\"efiapi\"` | `x1`, `x[5-7]`, `x[10-17]`, `x[28-31]`, `f[0-7]`, `f[10-17]`, `f[28-31]`, `v[0-31]` |\n+\n+The list of clobbered registers for each ABI is updated in rustc as architectures gain new registers: this ensures that `asm` clobbers will continue to be correct when LLVM starts using these new registers in its generated code.\n+\n ## Options\n \n Flags are used to further influence the behavior of the inline assembly block."}, {"sha": "d589a7c668825fe3f29ce421abe21ce6ebbade12", "filename": "src/test/codegen/asm-clobber_abi.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/3fd463a5ca98c54b4e79271280c69ce5468e1173/src%2Ftest%2Fcodegen%2Fasm-clobber_abi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fd463a5ca98c54b4e79271280c69ce5468e1173/src%2Ftest%2Fcodegen%2Fasm-clobber_abi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fasm-clobber_abi.rs?ref=3fd463a5ca98c54b4e79271280c69ce5468e1173", "patch": "@@ -0,0 +1,35 @@\n+// compile-flags: -O\n+// only-x86_64\n+\n+#![crate_type = \"rlib\"]\n+#![feature(asm)]\n+\n+// CHECK-LABEL: @clobber_sysv64\n+// CHECK: ={ax},={cx},={dx},={si},={di},={r8},={r9},={r10},={r11},={xmm0},={xmm1},={xmm2},={xmm3},={xmm4},={xmm5},={xmm6},={xmm7},={xmm8},={xmm9},={xmm10},={xmm11},={xmm12},={xmm13},={xmm14},={xmm15},~{xmm16},~{xmm17},~{xmm18},~{xmm19},~{xmm20},~{xmm21},~{xmm22},~{xmm23},~{xmm24},~{xmm25},~{xmm26},~{xmm27},~{xmm28},~{xmm29},~{xmm30},~{xmm31},~{k1},~{k2},~{k3},~{k4},~{k5},~{k6},~{k7},~{st},~{st(1)},~{st(2)},~{st(3)},~{st(4)},~{st(5)},~{st(6)},~{st(7)},~{dirflag},~{fpsr},~{flags},~{memory}\n+#[no_mangle]\n+pub unsafe fn clobber_sysv64() {\n+    asm!(\"\", clobber_abi(\"sysv64\"));\n+}\n+\n+// CHECK-LABEL: @clobber_win64\n+// CHECK: ={ax},={cx},={dx},={r8},={r9},={r10},={r11},={xmm0},={xmm1},={xmm2},={xmm3},={xmm4},={xmm5},={xmm6},={xmm7},={xmm8},={xmm9},={xmm10},={xmm11},={xmm12},={xmm13},={xmm14},={xmm15},~{xmm16},~{xmm17},~{xmm18},~{xmm19},~{xmm20},~{xmm21},~{xmm22},~{xmm23},~{xmm24},~{xmm25},~{xmm26},~{xmm27},~{xmm28},~{xmm29},~{xmm30},~{xmm31},~{k1},~{k2},~{k3},~{k4},~{k5},~{k6},~{k7},~{st},~{st(1)},~{st(2)},~{st(3)},~{st(4)},~{st(5)},~{st(6)},~{st(7)},~{dirflag},~{fpsr},~{flags},~{memory}\n+#[no_mangle]\n+pub unsafe fn clobber_win64() {\n+    asm!(\"\", clobber_abi(\"win64\"));\n+}\n+\n+// CHECK-LABEL: @clobber_sysv64\n+// CHECK: =&{dx},={ax},={cx},={si},={di},={r8},={r9},={r10},={r11},={xmm0},={xmm1},={xmm2},={xmm3},={xmm4},={xmm5},={xmm6},={xmm7},={xmm8},={xmm9},={xmm10},={xmm11},={xmm12},={xmm13},={xmm14},={xmm15},~{xmm16},~{xmm17},~{xmm18},~{xmm19},~{xmm20},~{xmm21},~{xmm22},~{xmm23},~{xmm24},~{xmm25},~{xmm26},~{xmm27},~{xmm28},~{xmm29},~{xmm30},~{xmm31},~{k1},~{k2},~{k3},~{k4},~{k5},~{k6},~{k7},~{st},~{st(1)},~{st(2)},~{st(3)},~{st(4)},~{st(5)},~{st(6)},~{st(7)},~{dirflag},~{fpsr},~{flags},~{memory}\n+#[no_mangle]\n+pub unsafe fn clobber_sysv64_edx() {\n+    let foo: i32;\n+    asm!(\"\", out(\"edx\") foo, clobber_abi(\"sysv64\"));\n+}\n+\n+// CHECK-LABEL: @clobber_win64\n+// CHECK: =&{dx},={ax},={cx},={r8},={r9},={r10},={r11},={xmm0},={xmm1},={xmm2},={xmm3},={xmm4},={xmm5},={xmm6},={xmm7},={xmm8},={xmm9},={xmm10},={xmm11},={xmm12},={xmm13},={xmm14},={xmm15},~{xmm16},~{xmm17},~{xmm18},~{xmm19},~{xmm20},~{xmm21},~{xmm22},~{xmm23},~{xmm24},~{xmm25},~{xmm26},~{xmm27},~{xmm28},~{xmm29},~{xmm30},~{xmm31},~{k1},~{k2},~{k3},~{k4},~{k5},~{k6},~{k7},~{st},~{st(1)},~{st(2)},~{st(3)},~{st(4)},~{st(5)},~{st(6)},~{st(7)},~{dirflag},~{fpsr},~{flags},~{memory}\n+#[no_mangle]\n+pub unsafe fn clobber_win64_edx() {\n+    let foo: i32;\n+    asm!(\"\", out(\"edx\") foo, clobber_abi(\"win64\"));\n+}"}, {"sha": "dc61d1612e8d64ea640eb889495afb05e90dd011", "filename": "src/test/ui/asm/bad-options.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3fd463a5ca98c54b4e79271280c69ce5468e1173/src%2Ftest%2Fui%2Fasm%2Fbad-options.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fd463a5ca98c54b4e79271280c69ce5468e1173/src%2Ftest%2Fui%2Fasm%2Fbad-options.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasm%2Fbad-options.rs?ref=3fd463a5ca98c54b4e79271280c69ce5468e1173", "patch": "@@ -15,6 +15,14 @@ fn main() {\n         asm!(\"{}\", out(reg) foo, options(noreturn));\n         //~^ ERROR asm outputs are not allowed with the `noreturn` option\n     }\n+\n+    unsafe {\n+        asm!(\"\", clobber_abi(\"foo\"));\n+        //~^ ERROR invalid ABI for `clobber_abi`\n+        asm!(\"{}\", out(reg) foo, clobber_abi(\"C\"));\n+        //~^ ERROR asm with `clobber_abi` must specify explicit registers for outputs\n+        asm!(\"\", out(\"eax\") foo, clobber_abi(\"C\"));\n+    }\n }\n \n global_asm!(\"\", options(nomem));"}, {"sha": "8cfd450ab02a551becd9331c59eaa81f5e29d278", "filename": "src/test/ui/asm/bad-options.stderr", "status": "modified", "additions": 23, "deletions": 7, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/3fd463a5ca98c54b4e79271280c69ce5468e1173/src%2Ftest%2Fui%2Fasm%2Fbad-options.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3fd463a5ca98c54b4e79271280c69ce5468e1173/src%2Ftest%2Fui%2Fasm%2Fbad-options.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasm%2Fbad-options.stderr?ref=3fd463a5ca98c54b4e79271280c69ce5468e1173", "patch": "@@ -28,41 +28,57 @@ error: asm outputs are not allowed with the `noreturn` option\n LL |         asm!(\"{}\", out(reg) foo, options(noreturn));\n    |                    ^^^^^^^^^^^^\n \n+error: asm with `clobber_abi` must specify explicit registers for outputs\n+  --> $DIR/bad-options.rs:22:20\n+   |\n+LL |         asm!(\"{}\", out(reg) foo, clobber_abi(\"C\"));\n+   |                    ^^^^^^^^^^^^  ---------------- clobber_abi\n+   |                    |\n+   |                    generic outputs\n+\n error: expected one of `)`, `att_syntax`, or `raw`, found `nomem`\n-  --> $DIR/bad-options.rs:20:25\n+  --> $DIR/bad-options.rs:28:25\n    |\n LL | global_asm!(\"\", options(nomem));\n    |                         ^^^^^ expected one of `)`, `att_syntax`, or `raw`\n \n error: expected one of `)`, `att_syntax`, or `raw`, found `readonly`\n-  --> $DIR/bad-options.rs:22:25\n+  --> $DIR/bad-options.rs:30:25\n    |\n LL | global_asm!(\"\", options(readonly));\n    |                         ^^^^^^^^ expected one of `)`, `att_syntax`, or `raw`\n \n error: expected one of `)`, `att_syntax`, or `raw`, found `noreturn`\n-  --> $DIR/bad-options.rs:24:25\n+  --> $DIR/bad-options.rs:32:25\n    |\n LL | global_asm!(\"\", options(noreturn));\n    |                         ^^^^^^^^ expected one of `)`, `att_syntax`, or `raw`\n \n error: expected one of `)`, `att_syntax`, or `raw`, found `pure`\n-  --> $DIR/bad-options.rs:26:25\n+  --> $DIR/bad-options.rs:34:25\n    |\n LL | global_asm!(\"\", options(pure));\n    |                         ^^^^ expected one of `)`, `att_syntax`, or `raw`\n \n error: expected one of `)`, `att_syntax`, or `raw`, found `nostack`\n-  --> $DIR/bad-options.rs:28:25\n+  --> $DIR/bad-options.rs:36:25\n    |\n LL | global_asm!(\"\", options(nostack));\n    |                         ^^^^^^^ expected one of `)`, `att_syntax`, or `raw`\n \n error: expected one of `)`, `att_syntax`, or `raw`, found `preserves_flags`\n-  --> $DIR/bad-options.rs:30:25\n+  --> $DIR/bad-options.rs:38:25\n    |\n LL | global_asm!(\"\", options(preserves_flags));\n    |                         ^^^^^^^^^^^^^^^ expected one of `)`, `att_syntax`, or `raw`\n \n-error: aborting due to 11 previous errors\n+error: invalid ABI for `clobber_abi`\n+  --> $DIR/bad-options.rs:20:18\n+   |\n+LL |         asm!(\"\", clobber_abi(\"foo\"));\n+   |                  ^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: the following ABIs are supported on this target: `C`, `system`, `efiapi`, `win64`, `sysv64`\n+\n+error: aborting due to 13 previous errors\n "}, {"sha": "3ec3c72d38d72c53277581d6267fdaf353e898db", "filename": "src/test/ui/asm/parse-error.rs", "status": "modified", "additions": 31, "deletions": 1, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/3fd463a5ca98c54b4e79271280c69ce5468e1173/src%2Ftest%2Fui%2Fasm%2Fparse-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fd463a5ca98c54b4e79271280c69ce5468e1173/src%2Ftest%2Fui%2Fasm%2Fparse-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasm%2Fparse-error.rs?ref=3fd463a5ca98c54b4e79271280c69ce5468e1173", "patch": "@@ -13,7 +13,7 @@ fn main() {\n         asm!(\"{}\" foo);\n         //~^ ERROR expected token: `,`\n         asm!(\"{}\", foo);\n-        //~^ ERROR expected operand, options, or additional template string\n+        //~^ ERROR expected operand, clobber_abi, options, or additional template string\n         asm!(\"{}\", in foo);\n         //~^ ERROR expected `(`, found `foo`\n         asm!(\"{}\", in(reg foo));\n@@ -37,6 +37,21 @@ fn main() {\n         asm!(\"{}\", options(), const foo);\n         //~^ ERROR arguments are not allowed after options\n         //~^^ ERROR attempt to use a non-constant value in a constant\n+        asm!(\"\", clobber_abi(foo));\n+        //~^ ERROR expected string literal\n+        asm!(\"\", clobber_abi(\"C\" foo));\n+        //~^ ERROR expected `)`, found `foo`\n+        asm!(\"\", clobber_abi(\"C\", foo));\n+        //~^ ERROR expected `)`, found `,`\n+        asm!(\"{}\", clobber_abi(\"C\"), const foo);\n+        //~^ ERROR arguments are not allowed after clobber_abi\n+        //~^^ ERROR attempt to use a non-constant value in a constant\n+        asm!(\"\", options(), clobber_abi(\"C\"));\n+        //~^ ERROR clobber_abi is not allowed after options\n+        asm!(\"{}\", options(), clobber_abi(\"C\"), const foo);\n+        //~^ ERROR clobber_abi is not allowed after options\n+        asm!(\"\", clobber_abi(\"C\"), clobber_abi(\"C\"));\n+        //~^ ERROR clobber_abi specified multiple times\n         asm!(\"{a}\", a = const foo, a = const bar);\n         //~^ ERROR duplicate argument named `a`\n         //~^^ ERROR argument never used\n@@ -86,6 +101,21 @@ global_asm!(\"\", options(nomem, FOO));\n //~^ ERROR expected one of\n global_asm!(\"{}\", options(), const FOO);\n //~^ ERROR arguments are not allowed after options\n+global_asm!(\"\", clobber_abi(FOO));\n+//~^ ERROR expected string literal\n+global_asm!(\"\", clobber_abi(\"C\" FOO));\n+//~^ ERROR expected `)`, found `FOO`\n+global_asm!(\"\", clobber_abi(\"C\", FOO));\n+//~^ ERROR expected `)`, found `,`\n+global_asm!(\"{}\", clobber_abi(\"C\"), const FOO);\n+//~^ ERROR arguments are not allowed after clobber_abi\n+//~^^ ERROR `clobber_abi` cannot be used with `global_asm!`\n+global_asm!(\"\", options(), clobber_abi(\"C\"));\n+//~^ ERROR clobber_abi is not allowed after options\n+global_asm!(\"{}\", options(), clobber_abi(\"C\"), const FOO);\n+//~^ ERROR clobber_abi is not allowed after options\n+global_asm!(\"\", clobber_abi(\"C\"), clobber_abi(\"C\"));\n+//~^ ERROR clobber_abi specified multiple times\n global_asm!(\"{a}\", a = const FOO, a = const BAR);\n //~^ ERROR duplicate argument named `a`\n //~^^ ERROR argument never used"}, {"sha": "423003c99d42c93fd4fe759a85312e059c040965", "filename": "src/test/ui/asm/parse-error.stderr", "status": "modified", "additions": 157, "deletions": 42, "changes": 199, "blob_url": "https://github.com/rust-lang/rust/blob/3fd463a5ca98c54b4e79271280c69ce5468e1173/src%2Ftest%2Fui%2Fasm%2Fparse-error.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3fd463a5ca98c54b4e79271280c69ce5468e1173/src%2Ftest%2Fui%2Fasm%2Fparse-error.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasm%2Fparse-error.stderr?ref=3fd463a5ca98c54b4e79271280c69ce5468e1173", "patch": "@@ -16,11 +16,11 @@ error: expected token: `,`\n LL |         asm!(\"{}\" foo);\n    |                   ^^^ expected `,`\n \n-error: expected operand, options, or additional template string\n+error: expected operand, clobber_abi, options, or additional template string\n   --> $DIR/parse-error.rs:15:20\n    |\n LL |         asm!(\"{}\", foo);\n-   |                    ^^^ expected operand, options, or additional template string\n+   |                    ^^^ expected operand, clobber_abi, options, or additional template string\n \n error: expected `(`, found `foo`\n   --> $DIR/parse-error.rs:17:23\n@@ -90,180 +90,286 @@ LL |         asm!(\"{}\", options(), const foo);\n    |                    |\n    |                    previous options\n \n+error: expected string literal\n+  --> $DIR/parse-error.rs:40:30\n+   |\n+LL |         asm!(\"\", clobber_abi(foo));\n+   |                              ^^^ not a string literal\n+\n+error: expected `)`, found `foo`\n+  --> $DIR/parse-error.rs:42:34\n+   |\n+LL |         asm!(\"\", clobber_abi(\"C\" foo));\n+   |                                  ^^^ expected `)`\n+\n+error: expected `)`, found `,`\n+  --> $DIR/parse-error.rs:44:33\n+   |\n+LL |         asm!(\"\", clobber_abi(\"C\", foo));\n+   |                                 ^ expected `)`\n+\n+error: arguments are not allowed after clobber_abi\n+  --> $DIR/parse-error.rs:46:38\n+   |\n+LL |         asm!(\"{}\", clobber_abi(\"C\"), const foo);\n+   |                    ----------------  ^^^^^^^^^ argument\n+   |                    |\n+   |                    clobber_abi\n+\n+error: clobber_abi is not allowed after options\n+  --> $DIR/parse-error.rs:49:29\n+   |\n+LL |         asm!(\"\", options(), clobber_abi(\"C\"));\n+   |                  ---------  ^^^^^^^^^^^^^^^^\n+   |                  |\n+   |                  options\n+\n+error: clobber_abi is not allowed after options\n+  --> $DIR/parse-error.rs:51:31\n+   |\n+LL |         asm!(\"{}\", options(), clobber_abi(\"C\"), const foo);\n+   |                    ---------  ^^^^^^^^^^^^^^^^\n+   |                    |\n+   |                    options\n+\n+error: clobber_abi specified multiple times\n+  --> $DIR/parse-error.rs:53:36\n+   |\n+LL |         asm!(\"\", clobber_abi(\"C\"), clobber_abi(\"C\"));\n+   |                  ----------------  ^^^^^^^^^^^^^^^^\n+   |                  |\n+   |                  clobber_abi previously specified here\n+\n error: duplicate argument named `a`\n-  --> $DIR/parse-error.rs:40:36\n+  --> $DIR/parse-error.rs:55:36\n    |\n LL |         asm!(\"{a}\", a = const foo, a = const bar);\n    |                     -------------  ^^^^^^^^^^^^^ duplicate argument\n    |                     |\n    |                     previously here\n \n error: argument never used\n-  --> $DIR/parse-error.rs:40:36\n+  --> $DIR/parse-error.rs:55:36\n    |\n LL |         asm!(\"{a}\", a = const foo, a = const bar);\n    |                                    ^^^^^^^^^^^^^ argument never used\n    |\n    = help: if this argument is intentionally unused, consider using it in an asm comment: `\"/* {1} */\"`\n \n error: explicit register arguments cannot have names\n-  --> $DIR/parse-error.rs:45:18\n+  --> $DIR/parse-error.rs:60:18\n    |\n LL |         asm!(\"\", a = in(\"eax\") foo);\n    |                  ^^^^^^^^^^^^^^^^^\n \n error: named arguments cannot follow explicit register arguments\n-  --> $DIR/parse-error.rs:47:36\n+  --> $DIR/parse-error.rs:62:36\n    |\n LL |         asm!(\"{a}\", in(\"eax\") foo, a = const bar);\n    |                     -------------  ^^^^^^^^^^^^^ named argument\n    |                     |\n    |                     explicit register argument\n \n error: named arguments cannot follow explicit register arguments\n-  --> $DIR/parse-error.rs:50:36\n+  --> $DIR/parse-error.rs:65:36\n    |\n LL |         asm!(\"{a}\", in(\"eax\") foo, a = const bar);\n    |                     -------------  ^^^^^^^^^^^^^ named argument\n    |                     |\n    |                     explicit register argument\n \n error: positional arguments cannot follow named arguments or explicit register arguments\n-  --> $DIR/parse-error.rs:53:36\n+  --> $DIR/parse-error.rs:68:36\n    |\n LL |         asm!(\"{1}\", in(\"eax\") foo, const bar);\n    |                     -------------  ^^^^^^^^^ positional argument\n    |                     |\n    |                     explicit register argument\n \n-error: expected one of `const`, `in`, `inlateout`, `inout`, `lateout`, `options`, `out`, or `sym`, found `\"\"`\n-  --> $DIR/parse-error.rs:56:29\n+error: expected one of `clobber_abi`, `const`, `in`, `inlateout`, `inout`, `lateout`, `options`, `out`, or `sym`, found `\"\"`\n+  --> $DIR/parse-error.rs:71:29\n    |\n LL |         asm!(\"\", options(), \"\");\n-   |                             ^^ expected one of 8 possible tokens\n+   |                             ^^ expected one of 9 possible tokens\n \n-error: expected one of `const`, `in`, `inlateout`, `inout`, `lateout`, `options`, `out`, or `sym`, found `\"{}\"`\n-  --> $DIR/parse-error.rs:58:33\n+error: expected one of `clobber_abi`, `const`, `in`, `inlateout`, `inout`, `lateout`, `options`, `out`, or `sym`, found `\"{}\"`\n+  --> $DIR/parse-error.rs:73:33\n    |\n LL |         asm!(\"{}\", in(reg) foo, \"{}\", out(reg) foo);\n-   |                                 ^^^^ expected one of 8 possible tokens\n+   |                                 ^^^^ expected one of 9 possible tokens\n \n error: asm template must be a string literal\n-  --> $DIR/parse-error.rs:60:14\n+  --> $DIR/parse-error.rs:75:14\n    |\n LL |         asm!(format!(\"{{{}}}\", 0), in(reg) foo);\n    |              ^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: asm template must be a string literal\n-  --> $DIR/parse-error.rs:62:21\n+  --> $DIR/parse-error.rs:77:21\n    |\n LL |         asm!(\"{1}\", format!(\"{{{}}}\", 0), in(reg) foo, out(reg) bar);\n    |                     ^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: requires at least a template string argument\n-  --> $DIR/parse-error.rs:69:1\n+  --> $DIR/parse-error.rs:84:1\n    |\n LL | global_asm!();\n    | ^^^^^^^^^^^^^^\n \n error: asm template must be a string literal\n-  --> $DIR/parse-error.rs:71:13\n+  --> $DIR/parse-error.rs:86:13\n    |\n LL | global_asm!(FOO);\n    |             ^^^\n \n error: expected token: `,`\n-  --> $DIR/parse-error.rs:73:18\n+  --> $DIR/parse-error.rs:88:18\n    |\n LL | global_asm!(\"{}\" FOO);\n    |                  ^^^ expected `,`\n \n error: expected operand, options, or additional template string\n-  --> $DIR/parse-error.rs:75:19\n+  --> $DIR/parse-error.rs:90:19\n    |\n LL | global_asm!(\"{}\", FOO);\n    |                   ^^^ expected operand, options, or additional template string\n \n error: expected expression, found end of macro arguments\n-  --> $DIR/parse-error.rs:77:24\n+  --> $DIR/parse-error.rs:92:24\n    |\n LL | global_asm!(\"{}\", const);\n    |                        ^ expected expression\n \n error: expected one of `,`, `.`, `?`, or an operator, found `FOO`\n-  --> $DIR/parse-error.rs:79:30\n+  --> $DIR/parse-error.rs:94:30\n    |\n LL | global_asm!(\"{}\", const(reg) FOO);\n    |                              ^^^ expected one of `,`, `.`, `?`, or an operator\n \n error: expected one of `)`, `att_syntax`, or `raw`, found `FOO`\n-  --> $DIR/parse-error.rs:81:25\n+  --> $DIR/parse-error.rs:96:25\n    |\n LL | global_asm!(\"\", options(FOO));\n    |                         ^^^ expected one of `)`, `att_syntax`, or `raw`\n \n error: expected one of `)`, `att_syntax`, or `raw`, found `nomem`\n-  --> $DIR/parse-error.rs:83:25\n+  --> $DIR/parse-error.rs:98:25\n    |\n LL | global_asm!(\"\", options(nomem FOO));\n    |                         ^^^^^ expected one of `)`, `att_syntax`, or `raw`\n \n error: expected one of `)`, `att_syntax`, or `raw`, found `nomem`\n-  --> $DIR/parse-error.rs:85:25\n+  --> $DIR/parse-error.rs:100:25\n    |\n LL | global_asm!(\"\", options(nomem, FOO));\n    |                         ^^^^^ expected one of `)`, `att_syntax`, or `raw`\n \n error: arguments are not allowed after options\n-  --> $DIR/parse-error.rs:87:30\n+  --> $DIR/parse-error.rs:102:30\n    |\n LL | global_asm!(\"{}\", options(), const FOO);\n    |                   ---------  ^^^^^^^^^ argument\n    |                   |\n    |                   previous options\n \n+error: expected string literal\n+  --> $DIR/parse-error.rs:104:29\n+   |\n+LL | global_asm!(\"\", clobber_abi(FOO));\n+   |                             ^^^ not a string literal\n+\n+error: expected `)`, found `FOO`\n+  --> $DIR/parse-error.rs:106:33\n+   |\n+LL | global_asm!(\"\", clobber_abi(\"C\" FOO));\n+   |                                 ^^^ expected `)`\n+\n+error: expected `)`, found `,`\n+  --> $DIR/parse-error.rs:108:32\n+   |\n+LL | global_asm!(\"\", clobber_abi(\"C\", FOO));\n+   |                                ^ expected `)`\n+\n+error: arguments are not allowed after clobber_abi\n+  --> $DIR/parse-error.rs:110:37\n+   |\n+LL | global_asm!(\"{}\", clobber_abi(\"C\"), const FOO);\n+   |                   ----------------  ^^^^^^^^^ argument\n+   |                   |\n+   |                   clobber_abi\n+\n+error: `clobber_abi` cannot be used with `global_asm!`\n+  --> $DIR/parse-error.rs:110:19\n+   |\n+LL | global_asm!(\"{}\", clobber_abi(\"C\"), const FOO);\n+   |                   ^^^^^^^^^^^^^^^^\n+\n+error: clobber_abi is not allowed after options\n+  --> $DIR/parse-error.rs:113:28\n+   |\n+LL | global_asm!(\"\", options(), clobber_abi(\"C\"));\n+   |                 ---------  ^^^^^^^^^^^^^^^^\n+   |                 |\n+   |                 options\n+\n+error: clobber_abi is not allowed after options\n+  --> $DIR/parse-error.rs:115:30\n+   |\n+LL | global_asm!(\"{}\", options(), clobber_abi(\"C\"), const FOO);\n+   |                   ---------  ^^^^^^^^^^^^^^^^\n+   |                   |\n+   |                   options\n+\n+error: clobber_abi specified multiple times\n+  --> $DIR/parse-error.rs:117:35\n+   |\n+LL | global_asm!(\"\", clobber_abi(\"C\"), clobber_abi(\"C\"));\n+   |                 ----------------  ^^^^^^^^^^^^^^^^\n+   |                 |\n+   |                 clobber_abi previously specified here\n+\n error: duplicate argument named `a`\n-  --> $DIR/parse-error.rs:89:35\n+  --> $DIR/parse-error.rs:119:35\n    |\n LL | global_asm!(\"{a}\", a = const FOO, a = const BAR);\n    |                    -------------  ^^^^^^^^^^^^^ duplicate argument\n    |                    |\n    |                    previously here\n \n error: argument never used\n-  --> $DIR/parse-error.rs:89:35\n+  --> $DIR/parse-error.rs:119:35\n    |\n LL | global_asm!(\"{a}\", a = const FOO, a = const BAR);\n    |                                   ^^^^^^^^^^^^^ argument never used\n    |\n    = help: if this argument is intentionally unused, consider using it in an asm comment: `\"/* {1} */\"`\n \n-error: expected one of `const` or `options`, found `\"\"`\n-  --> $DIR/parse-error.rs:92:28\n+error: expected one of `clobber_abi`, `const`, or `options`, found `\"\"`\n+  --> $DIR/parse-error.rs:122:28\n    |\n LL | global_asm!(\"\", options(), \"\");\n-   |                            ^^ expected one of `const` or `options`\n+   |                            ^^ expected one of `clobber_abi`, `const`, or `options`\n \n-error: expected one of `const` or `options`, found `\"{}\"`\n-  --> $DIR/parse-error.rs:94:30\n+error: expected one of `clobber_abi`, `const`, or `options`, found `\"{}\"`\n+  --> $DIR/parse-error.rs:124:30\n    |\n LL | global_asm!(\"{}\", const FOO, \"{}\", const FOO);\n-   |                              ^^^^ expected one of `const` or `options`\n+   |                              ^^^^ expected one of `clobber_abi`, `const`, or `options`\n \n error: asm template must be a string literal\n-  --> $DIR/parse-error.rs:96:13\n+  --> $DIR/parse-error.rs:126:13\n    |\n LL | global_asm!(format!(\"{{{}}}\", 0), const FOO);\n    |             ^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: asm template must be a string literal\n-  --> $DIR/parse-error.rs:98:20\n+  --> $DIR/parse-error.rs:128:20\n    |\n LL | global_asm!(\"{1}\", format!(\"{{{}}}\", 0), const FOO, const BAR);\n    |                    ^^^^^^^^^^^^^^^^^^^^\n@@ -280,7 +386,16 @@ LL |         asm!(\"{}\", options(), const foo);\n    |                                     ^^^ non-constant value\n \n error[E0435]: attempt to use a non-constant value in a constant\n-  --> $DIR/parse-error.rs:40:31\n+  --> $DIR/parse-error.rs:46:44\n+   |\n+LL |     let mut foo = 0;\n+   |      ---------- help: consider using `const` instead of `let`: `const foo`\n+...\n+LL |         asm!(\"{}\", clobber_abi(\"C\"), const foo);\n+   |                                            ^^^ non-constant value\n+\n+error[E0435]: attempt to use a non-constant value in a constant\n+  --> $DIR/parse-error.rs:55:31\n    |\n LL |     let mut foo = 0;\n    |      ---------- help: consider using `const` instead of `let`: `const foo`\n@@ -289,7 +404,7 @@ LL |         asm!(\"{a}\", a = const foo, a = const bar);\n    |                               ^^^ non-constant value\n \n error[E0435]: attempt to use a non-constant value in a constant\n-  --> $DIR/parse-error.rs:40:46\n+  --> $DIR/parse-error.rs:55:46\n    |\n LL |     let mut bar = 0;\n    |      ---------- help: consider using `const` instead of `let`: `const bar`\n@@ -298,7 +413,7 @@ LL |         asm!(\"{a}\", a = const foo, a = const bar);\n    |                                              ^^^ non-constant value\n \n error[E0435]: attempt to use a non-constant value in a constant\n-  --> $DIR/parse-error.rs:47:46\n+  --> $DIR/parse-error.rs:62:46\n    |\n LL |     let mut bar = 0;\n    |      ---------- help: consider using `const` instead of `let`: `const bar`\n@@ -307,7 +422,7 @@ LL |         asm!(\"{a}\", in(\"eax\") foo, a = const bar);\n    |                                              ^^^ non-constant value\n \n error[E0435]: attempt to use a non-constant value in a constant\n-  --> $DIR/parse-error.rs:50:46\n+  --> $DIR/parse-error.rs:65:46\n    |\n LL |     let mut bar = 0;\n    |      ---------- help: consider using `const` instead of `let`: `const bar`\n@@ -316,14 +431,14 @@ LL |         asm!(\"{a}\", in(\"eax\") foo, a = const bar);\n    |                                              ^^^ non-constant value\n \n error[E0435]: attempt to use a non-constant value in a constant\n-  --> $DIR/parse-error.rs:53:42\n+  --> $DIR/parse-error.rs:68:42\n    |\n LL |     let mut bar = 0;\n    |      ---------- help: consider using `const` instead of `let`: `const bar`\n ...\n LL |         asm!(\"{1}\", in(\"eax\") foo, const bar);\n    |                                          ^^^ non-constant value\n \n-error: aborting due to 47 previous errors\n+error: aborting due to 63 previous errors\n \n For more information about this error, try `rustc --explain E0435`."}]}