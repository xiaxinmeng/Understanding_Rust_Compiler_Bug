{"sha": "35e92d942093fad264ff010957d2eecb13a68315", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM1ZTkyZDk0MjA5M2ZhZDI2NGZmMDEwOTU3ZDJlZWNiMTNhNjgzMTU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-11-20T19:16:40Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-11-20T19:16:40Z"}, "message": "Auto merge of #1065 - Aaron1011:fix/start-return, r=RalfJung\n\nPropagate the return code from the `start` lang item\n\nFixes #1064\n\nThis ensures that we set the error code properly when a panic unwinds\npast `main`.\n\nI'm not sure what the best way to write a test for this is", "tree": {"sha": "3897b4f8f33871ad5f5c0593453d4a3d140ffd6e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3897b4f8f33871ad5f5c0593453d4a3d140ffd6e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/35e92d942093fad264ff010957d2eecb13a68315", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/35e92d942093fad264ff010957d2eecb13a68315", "html_url": "https://github.com/rust-lang/rust/commit/35e92d942093fad264ff010957d2eecb13a68315", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/35e92d942093fad264ff010957d2eecb13a68315/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "613879466a18c7b704dc1587869780d1f40ce00d", "url": "https://api.github.com/repos/rust-lang/rust/commits/613879466a18c7b704dc1587869780d1f40ce00d", "html_url": "https://github.com/rust-lang/rust/commit/613879466a18c7b704dc1587869780d1f40ce00d"}, {"sha": "2176bf6cf04bea76d9a1c85a8418fb9b91d17dfa", "url": "https://api.github.com/repos/rust-lang/rust/commits/2176bf6cf04bea76d9a1c85a8418fb9b91d17dfa", "html_url": "https://github.com/rust-lang/rust/commit/2176bf6cf04bea76d9a1c85a8418fb9b91d17dfa"}], "stats": {"total": 43, "additions": 31, "deletions": 12}, "files": [{"sha": "9e95e4b0a466a6113fd6c04edb258741d7824a5b", "filename": "src/bin/miri.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/35e92d942093fad264ff010957d2eecb13a68315/src%2Fbin%2Fmiri.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35e92d942093fad264ff010957d2eecb13a68315/src%2Fbin%2Fmiri.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Fmiri.rs?ref=35e92d942093fad264ff010957d2eecb13a68315", "patch": "@@ -15,6 +15,7 @@ extern crate rustc_interface;\n extern crate syntax;\n \n use std::str::FromStr;\n+use std::convert::TryFrom;\n use std::env;\n \n use hex::FromHexError;\n@@ -39,7 +40,9 @@ impl rustc_driver::Callbacks for MiriCompilerCalls {\n             // Add filename to `miri` arguments.\n             config.args.insert(0, compiler.input().filestem().to_string());\n \n-            miri::eval_main(tcx, entry_def_id, config);\n+            if let Some(return_code) = miri::eval_main(tcx, entry_def_id, config) {\n+                std::process::exit(i32::try_from(return_code).expect(\"Return value was too large!\"));\n+            }\n         });\n \n         compiler.session().abort_if_errors();"}, {"sha": "237ef99d1fe66e7ea1b3eaf9ce9f607c7c409689", "filename": "src/eval.rs", "status": "modified", "additions": 27, "deletions": 11, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/35e92d942093fad264ff010957d2eecb13a68315/src%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35e92d942093fad264ff010957d2eecb13a68315/src%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feval.rs?ref=35e92d942093fad264ff010957d2eecb13a68315", "patch": "@@ -11,7 +11,7 @@ use syntax::source_map::DUMMY_SP;\n use crate::{\n     EnvVars, Evaluator, FnVal, HelpersEvalContextExt, InterpCx, InterpError,\n     InterpResult, MemoryExtra, MiriMemoryKind, Pointer, Scalar, StackPopCleanup, Tag,\n-    TlsEvalContextExt,\n+    TlsEvalContextExt, MPlaceTy\n };\n \n /// Configuration needed to spawn a Miri instance.\n@@ -29,12 +29,15 @@ pub struct MiriConfig {\n     pub seed: Option<u64>,\n }\n \n-// Used by priroda.\n+/// Returns a freshly created `InterpCx`, along with an `MPlaceTy` representing\n+/// the location where the return value of the `start` lang item will be\n+/// written to.\n+/// Public because this is also used by `priroda`.\n pub fn create_ecx<'mir, 'tcx: 'mir>(\n     tcx: TyCtxt<'tcx>,\n     main_id: DefId,\n     config: MiriConfig,\n-) -> InterpResult<'tcx, InterpCx<'mir, 'tcx, Evaluator<'tcx>>> {\n+) -> InterpResult<'tcx, (InterpCx<'mir, 'tcx, Evaluator<'tcx>>, MPlaceTy<'tcx, Tag>)> {\n     let mut ecx = InterpCx::new(\n         tcx.at(syntax::source_map::DUMMY_SP),\n         ty::ParamEnv::reveal_all(),\n@@ -170,40 +173,51 @@ pub fn create_ecx<'mir, 'tcx: 'mir>(\n     ecx.write_scalar(Scalar::from_u32(0), errno_place.into())?;\n     ecx.machine.last_error = Some(errno_place);\n \n-    Ok(ecx)\n+    Ok((ecx, ret_ptr))\n }\n \n-pub fn eval_main<'tcx>(tcx: TyCtxt<'tcx>, main_id: DefId, config: MiriConfig) {\n-    let mut ecx = match create_ecx(tcx, main_id, config) {\n-        Ok(ecx) => ecx,\n+/// Evaluates the main function specified by `main_id`.\n+/// Returns `Some(return_code)` if program executed completed.\n+/// Returns `None` if an evaluation error occured.\n+pub fn eval_main<'tcx>(tcx: TyCtxt<'tcx>, main_id: DefId, config: MiriConfig) -> Option<i64> {\n+    let (mut ecx, ret_ptr) = match create_ecx(tcx, main_id, config) {\n+        Ok(v) => v,\n         Err(mut err) => {\n             err.print_backtrace();\n             panic!(\"Miri initialziation error: {}\", err.kind)\n         }\n     };\n \n     // Perform the main execution.\n-    let res: InterpResult<'_> = (|| {\n+    let res: InterpResult<'_, i64> = (|| {\n         ecx.run()?;\n-        ecx.run_tls_dtors()\n+        // Read the return code pointer *before* we run TLS destructors, to assert\n+        // that it was written to by the time that `start` lang item returned.\n+        let return_code = ecx.read_scalar(ret_ptr.into())?.not_undef()?.to_machine_isize(&ecx)?;\n+        ecx.run_tls_dtors()?;\n+        Ok(return_code)\n     })();\n \n     // Process the result.\n     match res {\n-        Ok(()) => {\n+        Ok(return_code) => {\n             let leaks = ecx.memory.leak_report();\n             // Disable the leak test on some platforms where we do not\n             // correctly implement TLS destructors.\n             let target_os = ecx.tcx.tcx.sess.target.target.target_os.to_lowercase();\n             let ignore_leaks = target_os == \"windows\" || target_os == \"macos\";\n             if !ignore_leaks && leaks != 0 {\n                 tcx.sess.err(\"the evaluated program leaked memory\");\n+                // Ignore the provided return code - let the reported error\n+                // determine the return code.\n+                return None;\n             }\n+            return Some(return_code)\n         }\n         Err(mut e) => {\n             // Special treatment for some error kinds\n             let msg = match e.kind {\n-                InterpError::Exit(code) => std::process::exit(code),\n+                InterpError::Exit(code) => return Some(code.into()),\n                 err_unsup!(NoMirFor(..)) =>\n                     format!(\"{}. Did you set `MIRI_SYSROOT` to a Miri-enabled sysroot? You can prepare one with `cargo miri setup`.\", e),\n                 _ => e.to_string()\n@@ -246,6 +260,8 @@ pub fn eval_main<'tcx>(tcx: TyCtxt<'tcx>, main_id: DefId, config: MiriConfig) {\n                     trace!(\"    local {}: {:?}\", i, local.value);\n                 }\n             }\n+            // Let the reported error determine the return code.\n+            return None;\n         }\n     }\n }"}]}