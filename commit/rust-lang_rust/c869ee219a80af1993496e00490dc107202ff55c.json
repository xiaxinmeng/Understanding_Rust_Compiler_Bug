{"sha": "c869ee219a80af1993496e00490dc107202ff55c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM4NjllZTIxOWE4MGFmMTk5MzQ5NmUwMDQ5MGRjMTA3MjAyZmY1NWM=", "commit": {"author": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-01-26T08:47:56Z"}, "committer": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-01-26T08:47:56Z"}, "message": "Merge #665\n\n665: Pr 556 r=matklad a=matklad\n\nRebased #556 \r\n\r\nThanks @vemoo, now I can change branches without reopening VS Code!\n\nCo-authored-by: Bernardo <berublan@gmail.com>", "tree": {"sha": "5717d124c71de13412f61a8584b119da378828ae", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5717d124c71de13412f61a8584b119da378828ae"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c869ee219a80af1993496e00490dc107202ff55c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c869ee219a80af1993496e00490dc107202ff55c", "html_url": "https://github.com/rust-lang/rust/commit/c869ee219a80af1993496e00490dc107202ff55c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c869ee219a80af1993496e00490dc107202ff55c/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "ac757e114e9dcbc70600803dd4adc4f99ecde78e", "url": "https://api.github.com/repos/rust-lang/rust/commits/ac757e114e9dcbc70600803dd4adc4f99ecde78e", "html_url": "https://github.com/rust-lang/rust/commit/ac757e114e9dcbc70600803dd4adc4f99ecde78e"}, {"sha": "410a3ae6e847b59f9930ce4d6bf9f3c5f1d72167", "url": "https://api.github.com/repos/rust-lang/rust/commits/410a3ae6e847b59f9930ce4d6bf9f3c5f1d72167", "html_url": "https://github.com/rust-lang/rust/commit/410a3ae6e847b59f9930ce4d6bf9f3c5f1d72167"}], "stats": {"total": 1116, "additions": 903, "deletions": 213}, "files": [{"sha": "db09967ba7b900147afa92c36b909bf8a74d78b8", "filename": "Cargo.lock", "status": "modified", "additions": 256, "deletions": 10, "changes": 266, "blob_url": "https://github.com/rust-lang/rust/blob/c869ee219a80af1993496e00490dc107202ff55c/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/c869ee219a80af1993496e00490dc107202ff55c/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=c869ee219a80af1993496e00490dc107202ff55c", "patch": "@@ -85,6 +85,11 @@ name = \"bit-vec\"\n version = \"0.5.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n+[[package]]\n+name = \"bitflags\"\n+version = \"0.7.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n [[package]]\n name = \"bitflags\"\n version = \"1.0.4\"\n@@ -109,6 +114,15 @@ name = \"byteorder\"\n version = \"1.3.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n+[[package]]\n+name = \"bytes\"\n+version = \"0.4.11\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"byteorder 1.3.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"iovec 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"cargo_metadata\"\n version = \"0.7.1\"\n@@ -335,6 +349,16 @@ name = \"fake-simd\"\n version = \"0.1.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n+[[package]]\n+name = \"filetime\"\n+version = \"0.2.4\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"cfg-if 0.1.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.48 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"redox_syscall 0.1.51 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"flexi_logger\"\n version = \"0.10.5\"\n@@ -351,6 +375,24 @@ name = \"fnv\"\n version = \"1.0.6\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n+[[package]]\n+name = \"fsevent\"\n+version = \"0.2.17\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"bitflags 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"fsevent-sys 0.1.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.48 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"fsevent-sys\"\n+version = \"0.1.6\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"libc 0.2.48 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"fst\"\n version = \"0.3.3\"\n@@ -374,6 +416,11 @@ name = \"fuchsia-zircon-sys\"\n version = \"0.3.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n+[[package]]\n+name = \"futures\"\n+version = \"0.1.25\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n [[package]]\n name = \"gen_lsp_server\"\n version = \"0.1.0\"\n@@ -436,6 +483,28 @@ name = \"indexmap\"\n version = \"1.0.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n+[[package]]\n+name = \"inotify\"\n+version = \"0.6.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"bitflags 1.0.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"futures 0.1.25 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"inotify-sys 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.48 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"mio 0.6.16 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"tokio-io 0.1.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"tokio-reactor 0.1.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"inotify-sys\"\n+version = \"0.1.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"libc 0.2.48 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"insta\"\n version = \"0.5.2\"\n@@ -455,6 +524,15 @@ dependencies = [\n  \"serde_yaml 0.8.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n+[[package]]\n+name = \"iovec\"\n+version = \"0.1.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"libc 0.2.48 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"itertools\"\n version = \"0.8.0\"\n@@ -473,11 +551,25 @@ name = \"join_to_string\"\n version = \"0.1.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n+[[package]]\n+name = \"kernel32-sys\"\n+version = \"0.2.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"winapi-build 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"lazy_static\"\n version = \"1.2.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n+[[package]]\n+name = \"lazycell\"\n+version = \"1.2.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n [[package]]\n name = \"libc\"\n version = \"0.2.48\"\n@@ -511,7 +603,7 @@ version = \"0.55.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"bitflags 1.0.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"num-derive 0.2.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"num-derive 0.2.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"num-traits 0.2.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde 1.0.85 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde_derive 1.0.85 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -553,17 +645,84 @@ name = \"memoffset\"\n version = \"0.2.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n+[[package]]\n+name = \"mio\"\n+version = \"0.6.16\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"fuchsia-zircon 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"fuchsia-zircon-sys 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"iovec 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"lazycell 1.2.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.48 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"log 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"miow 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"net2 0.2.33 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"slab 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"mio-extras\"\n+version = \"2.0.5\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"lazycell 1.2.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"log 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"mio 0.6.16 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"slab 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"miow\"\n+version = \"0.2.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"net2 0.2.33 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"ws2_32-sys 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"net2\"\n+version = \"0.2.33\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"cfg-if 0.1.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.48 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"winapi 0.3.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"nodrop\"\n version = \"0.1.13\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n+[[package]]\n+name = \"notify\"\n+version = \"4.0.7\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"bitflags 1.0.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"filetime 0.2.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"fsevent 0.2.17 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"fsevent-sys 0.1.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"inotify 0.6.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.48 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"mio 0.6.16 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"mio-extras 2.0.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"walkdir 2.2.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"winapi 0.3.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"num-derive\"\n-version = \"0.2.3\"\n+version = \"0.2.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"num-traits 0.2.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"proc-macro2 0.4.26 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"quote 0.6.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"syn 0.15.26 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -726,7 +885,7 @@ dependencies = [\n  \"ra_syntax 0.1.0\",\n  \"relative-path 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-hash 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"salsa 0.10.0-alpha4 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"salsa 0.10.0-alpha5 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"test_utils 0.1.0\",\n ]\n \n@@ -849,7 +1008,11 @@ name = \"ra_vfs\"\n version = \"0.1.0\"\n dependencies = [\n  \"crossbeam-channel 0.3.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"drop_bomb 0.1.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"flexi_logger 0.10.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"notify 4.0.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"parking_lot 0.7.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"ra_arena 0.1.0\",\n  \"relative-path 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-hash 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1097,7 +1260,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"salsa\"\n-version = \"0.10.0-alpha4\"\n+version = \"0.10.0-alpha5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"derive-new 0.5.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1106,13 +1269,13 @@ dependencies = [\n  \"log 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"parking_lot 0.7.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-hash 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"salsa-macros 0.10.0-alpha4 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"salsa-macros 0.10.0-alpha5 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"smallvec 0.6.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"salsa-macros\"\n-version = \"0.10.0-alpha4\"\n+version = \"0.10.0-alpha5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"heck 0.3.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1198,6 +1361,11 @@ dependencies = [\n  \"fake-simd 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n+[[package]]\n+name = \"slab\"\n+version = \"0.4.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n [[package]]\n name = \"slug\"\n version = \"0.1.4\"\n@@ -1381,6 +1549,42 @@ dependencies = [\n  \"winapi 0.3.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n+[[package]]\n+name = \"tokio-executor\"\n+version = \"0.1.6\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"crossbeam-utils 0.6.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"futures 0.1.25 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"tokio-io\"\n+version = \"0.1.11\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"bytes 0.4.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"futures 0.1.25 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"log 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"tokio-reactor\"\n+version = \"0.1.8\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"crossbeam-utils 0.6.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"futures 0.1.25 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"lazy_static 1.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"log 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"mio 0.6.16 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"num_cpus 1.9.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"parking_lot 0.7.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"slab 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"tokio-executor 0.1.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"tokio-io 0.1.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"tools\"\n version = \"0.1.0\"\n@@ -1555,6 +1759,11 @@ dependencies = [\n  \"winapi-util 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n+[[package]]\n+name = \"winapi\"\n+version = \"0.2.8\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n [[package]]\n name = \"winapi\"\n version = \"0.3.6\"\n@@ -1564,6 +1773,11 @@ dependencies = [\n  \"winapi-x86_64-pc-windows-gnu 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n+[[package]]\n+name = \"winapi-build\"\n+version = \"0.1.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n [[package]]\n name = \"winapi-i686-pc-windows-gnu\"\n version = \"0.4.0\"\n@@ -1582,6 +1796,15 @@ name = \"winapi-x86_64-pc-windows-gnu\"\n version = \"0.4.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n+[[package]]\n+name = \"ws2_32-sys\"\n+version = \"0.2.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"winapi-build 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"yaml-rust\"\n version = \"0.4.2\"\n@@ -1602,10 +1825,12 @@ dependencies = [\n \"checksum base64 0.10.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0b25d992356d2eb0ed82172f5248873db5560c4721f564b13cb5193bda5e668e\"\n \"checksum bit-set 0.5.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"6f1efcc46c18245a69c38fcc5cc650f16d3a59d034f3106e9ed63748f695730a\"\n \"checksum bit-vec 0.5.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"4440d5cb623bb7390ae27fec0bb6c61111969860f8e3ae198bfa0663645e67cf\"\n+\"checksum bitflags 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"aad18937a628ec6abcd26d1489012cc0e18c21798210f491af69ded9b881106d\"\n \"checksum bitflags 1.0.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"228047a76f468627ca71776ecdebd732a3423081fcf5125585bcd7c49886ce12\"\n \"checksum block-buffer 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a076c298b9ecdb530ed9d967e74a6027d6a7478924520acddcddc24c1c8ab3ab\"\n \"checksum byte-tools 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"560c32574a12a89ecd91f5e742165893f86e3ab98d21f8ea548658eb9eef5f40\"\n \"checksum byteorder 1.3.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a019b10a2a7cdeb292db131fc8113e57ea2a908f6e7894b0c3c671893b65dbeb\"\n+\"checksum bytes 0.4.11 (registry+https://github.com/rust-lang/crates.io-index)\" = \"40ade3d27603c2cb345eb0912aec461a6dec7e06a4ae48589904e808335c7afa\"\n \"checksum cargo_metadata 0.7.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"585784cac9b05c93a53b17a0b24a5cdd1dfdda5256f030e089b549d2390cc720\"\n \"checksum cc 1.0.28 (registry+https://github.com/rust-lang/crates.io-index)\" = \"bb4a8b715cb4597106ea87c7c84b2f1d452c7492033765df7f32651e66fcf749\"\n \"checksum cfg-if 0.1.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"082bb9b28e00d3c9d39cc03e64ce4cea0f1bb9b3fde493f0cbc008472d22bdf4\"\n@@ -1633,23 +1858,32 @@ dependencies = [\n \"checksum failure 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"795bd83d3abeb9220f257e597aa0080a508b27533824adf336529648f6abf7e2\"\n \"checksum failure_derive 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ea1063915fd7ef4309e222a5a07cf9c319fb9c7836b1f89b85458672dbb127e1\"\n \"checksum fake-simd 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e88a8acf291dafb59c2d96e8f59828f3838bb1a70398823ade51a84de6a6deed\"\n+\"checksum filetime 0.2.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a2df5c1a8c4be27e7707789dc42ae65976e60b394afd293d1419ab915833e646\"\n \"checksum flexi_logger 0.10.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"bbd731387787f54fa333fa426e173fe42ea3d1123636b2b27ad802025fc5d182\"\n \"checksum fnv 1.0.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"2fad85553e09a6f881f739c29f0b00b0f01357c743266d478b68951ce23285f3\"\n+\"checksum fsevent 0.2.17 (registry+https://github.com/rust-lang/crates.io-index)\" = \"c4bbbf71584aeed076100b5665ac14e3d85eeb31fdbb45fbd41ef9a682b5ec05\"\n+\"checksum fsevent-sys 0.1.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"1a772d36c338d07a032d5375a36f15f9a7043bf0cb8ce7cee658e037c6032874\"\n \"checksum fst 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"db72126ca7dff566cdbbdd54af44668c544897d9d3862b198141f176f1238bdf\"\n \"checksum fuchsia-zircon 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"2e9763c69ebaae630ba35f74888db465e49e259ba1bc0eda7d06f4a067615d82\"\n \"checksum fuchsia-zircon-sys 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3dcaa9ae7725d12cdb85b3ad99a434db70b468c09ded17e012d86b5c1010f7a7\"\n+\"checksum futures 0.1.25 (registry+https://github.com/rust-lang/crates.io-index)\" = \"49e7653e374fe0d0c12de4250f0bdb60680b8c80eed558c5c7538eec9c89e21b\"\n \"checksum generic-array 0.9.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ef25c5683767570c2bbd7deba372926a55eaae9982d7726ee2a1050239d45b9d\"\n \"checksum glob 0.2.11 (registry+https://github.com/rust-lang/crates.io-index)\" = \"8be18de09a56b60ed0edf84bc9df007e30040691af7acd1c41874faac5895bfb\"\n \"checksum heck 0.3.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"20564e78d53d2bb135c343b3f47714a56af2061f1c928fdb541dc7b9fdd94205\"\n \"checksum humansize 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"b6cab2627acfc432780848602f3f558f7e9dd427352224b0d9324025796d2a5e\"\n \"checksum idna 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"38f09e0f0b1fb55fdee1f17470ad800da77af5186a1a76c026b679358b7e844e\"\n \"checksum im 12.3.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0627d417829c1d763d602687634869f254fc79f7e22dea6c824dab993db857e4\"\n \"checksum indexmap 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7e81a7c05f79578dbc15793d8b619db9ba32b4577003ef3af1a91c416798c58d\"\n+\"checksum inotify 0.6.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"40b54539f3910d6f84fbf9a643efd6e3aa6e4f001426c0329576128255994718\"\n+\"checksum inotify-sys 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e74a1aa87c59aeff6ef2cc2fa62d41bc43f54952f55652656b18a02fd5e356c0\"\n \"checksum insta 0.5.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"6ff57d9cbc4664b54a972c321155c7703794bc0f5c9944f29c36f40d10d626f3\"\n+\"checksum iovec 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"dbe6e417e7d0975db6512b90796e8ce223145ac4e33c377e4a42882a0e88bb08\"\n \"checksum itertools 0.8.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"5b8467d9c1cebe26feb08c640139247fac215782d35371ade9a2136ed6085358\"\n \"checksum itoa 0.4.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"1306f3464951f30e30d12373d31c79fbd52d236e5e896fd92f96ec7babbbe60b\"\n \"checksum join_to_string 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"4dc7a5290e8c2606ce2be49f456d50f69173cb96d1541e4f66e34ac8b331a98f\"\n+\"checksum kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7507624b29483431c0ba2d82aece8ca6cdba9382bff4ddd0f7490560c056098d\"\n \"checksum lazy_static 1.2.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a374c89b9db55895453a74c1e38861d9deec0b01b405a82516e9d5de4820dea1\"\n+\"checksum lazycell 1.2.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"b294d6fa9ee409a054354afc4352b0b9ef7ca222c69b8812cbea9e7d2bf3783f\"\n \"checksum libc 0.2.48 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e962c7641008ac010fa60a7dfdc1712449f29c44ef2d4702394aea943ee75047\"\n \"checksum linked-hash-map 0.5.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"70fb39025bc7cdd76305867c4eccf2f2dcf6e9a57f5b21a93e1c2d86cd03ec9e\"\n \"checksum lock_api 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"62ebf1391f6acad60e5c8b43706dde4582df75c06698ab44511d15016bc2442c\"\n@@ -1660,8 +1894,13 @@ dependencies = [\n \"checksum memchr 2.1.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e1dd4eaac298c32ce07eb6ed9242eda7d82955b9170b7d6db59b2e02cc63fcb8\"\n \"checksum memmap 0.6.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e2ffa2c986de11a9df78620c01eeaaf27d94d3ff02bf81bfcca953102dd0c6ff\"\n \"checksum memoffset 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0f9dc261e2b62d7a622bf416ea3c5245cdd5d9a7fcc428c0d06804dfce1775b3\"\n+\"checksum mio 0.6.16 (registry+https://github.com/rust-lang/crates.io-index)\" = \"71646331f2619b1026cc302f87a2b8b648d5c6dd6937846a16cc8ce0f347f432\"\n+\"checksum mio-extras 2.0.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"46e73a04c2fa6250b8d802134d56d554a9ec2922bf977777c805ea5def61ce40\"\n+\"checksum miow 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"8c1f2f3b1cf331de6896aabf6e9d55dca90356cc9960cca7eaaf408a355ae919\"\n+\"checksum net2 0.2.33 (registry+https://github.com/rust-lang/crates.io-index)\" = \"42550d9fb7b6684a6d404d9fa7250c2eb2646df731d1c06afc06dcee9e1bcf88\"\n \"checksum nodrop 0.1.13 (registry+https://github.com/rust-lang/crates.io-index)\" = \"2f9667ddcc6cc8a43afc9b7917599d7216aa09c463919ea32c59ed6cac8bc945\"\n-\"checksum num-derive 0.2.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"8af1847c907c2f04d7bfd572fb25bbb4385c637fe5be163cf2f8c5d778fe1e7d\"\n+\"checksum notify 4.0.7 (registry+https://github.com/rust-lang/crates.io-index)\" = \"c968cf37cf949114b00d51b0b23536d1c3a4a3963767cf4c969c65a6af78dc7d\"\n+\"checksum num-derive 0.2.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d9fe8fcafd1b86a37ce8a1cfa15ae504817e0c8c2e7ad42767371461ac1d316d\"\n \"checksum num-integer 0.1.39 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e83d528d2677f0518c570baf2b7abdcf0cd2d248860b68507bdcb3e91d4c0cea\"\n \"checksum num-traits 0.2.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0b3a5d7cc97d6d30d8b9bc8fa19bf45349ffe46241e8816f50f62f6d6aaabee1\"\n \"checksum num_cpus 1.9.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"5a69d464bdc213aaaff628444e99578ede64e9c854025aa43b9796530afa9238\"\n@@ -1704,8 +1943,8 @@ dependencies = [\n \"checksum rustc_version 0.2.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"138e3e0acb6c9fb258b19b67cb8abd63c00679d2851805ea151465464fe9030a\"\n \"checksum rusty-fork 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"9591f190d2852720b679c21f66ad929f9f1d7bb09d1193c26167586029d8489c\"\n \"checksum ryu 0.2.7 (registry+https://github.com/rust-lang/crates.io-index)\" = \"eb9e9b8cde282a9fe6a42dd4681319bfb63f121b8a8ee9439c6f4107e58a46f7\"\n-\"checksum salsa 0.10.0-alpha4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3f442595eae948da8fbb2aa1e13940d9d2d70031753a27a5d1434f91b706ff12\"\n-\"checksum salsa-macros 0.10.0-alpha4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"2e6c1a1bee4eb44881438e80c1a26db1c3b957b6cc51765615d429019babdec2\"\n+\"checksum salsa 0.10.0-alpha5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"8b5e2535d707dc5ced81106d3b71d806cfeef8a6e8a567472fde7ffd56b770dd\"\n+\"checksum salsa-macros 0.10.0-alpha5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e7c5da4c649f6d4fc1864fcd9a379b1f7c6d570b278559c84a6e15981c949cc6\"\n \"checksum same-file 1.0.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"8f20c4be53a8a1ff4c1f1b2bd14570d2f634628709752f0702ecdd2b3f9a5267\"\n \"checksum scopeguard 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"94258f53601af11e6a49f722422f6e3425c52b06245a5cf9bc09908b174f5e27\"\n \"checksum semver 0.9.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"1d7eb9ef2c18661902cc47e535f9bc51b78acd254da71d375c2f6720d9a40403\"\n@@ -1715,6 +1954,7 @@ dependencies = [\n \"checksum serde_json 1.0.37 (registry+https://github.com/rust-lang/crates.io-index)\" = \"4b90a9fbe1211e57d3e1c15670f1cb00802988fb23a1a4aad7a2b63544f1920e\"\n \"checksum serde_yaml 0.8.8 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0887a8e097a69559b56aa2526bf7aff7c3048cf627dff781f0b56a6001534593\"\n \"checksum sha-1 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"51b9d1f3b5de8a167ab06834a7c883bd197f2191e1dda1a22d9ccfeedbf9aded\"\n+\"checksum slab 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"c111b5bd5695e56cffe5129854aa230b39c93a305372fdbb2668ca2394eea9f8\"\n \"checksum slug 0.1.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"b3bc762e6a4b6c6fcaade73e77f9ebc6991b676f88bb2358bddb56560f073373\"\n \"checksum smallvec 0.6.8 (registry+https://github.com/rust-lang/crates.io-index)\" = \"88aea073965ab29f6edb5493faf96ad662fb18aa9eeb186a3b7057951605ed15\"\n \"checksum smol_str 0.1.9 (registry+https://github.com/rust-lang/crates.io-index)\" = \"9af1035bc5d742ab6b7ab16713e41cc2ffe78cb474f6f43cd696b2d16052007e\"\n@@ -1733,6 +1973,9 @@ dependencies = [\n \"checksum thread_local 0.3.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"c6b53e329000edc2b34dbe8545fd20e55a333362d0a321909685a19bd28c3f1b\"\n \"checksum threadpool 1.7.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e2f0c90a5f3459330ac8bc0d2f879c693bb7a2f59689c1083fc4ef83834da865\"\n \"checksum time 0.1.42 (registry+https://github.com/rust-lang/crates.io-index)\" = \"db8dcfca086c1143c9270ac42a2bbd8a7ee477b78ac8e45b19abfb0cbede4b6f\"\n+\"checksum tokio-executor 0.1.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"30c6dbf2d1ad1de300b393910e8a3aa272b724a400b6531da03eed99e329fbf0\"\n+\"checksum tokio-io 0.1.11 (registry+https://github.com/rust-lang/crates.io-index)\" = \"b53aeb9d3f5ccf2ebb29e19788f96987fa1355f8fe45ea193928eaaaf3ae820f\"\n+\"checksum tokio-reactor 0.1.8 (registry+https://github.com/rust-lang/crates.io-index)\" = \"afbcdb0f0d2a1e4c440af82d7bbf0bf91a8a8c0575bcd20c05d15be7e9d3a02f\"\n \"checksum typenum 1.10.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"612d636f949607bdf9b123b4a6f6d966dedf3ff669f7f045890d3a4a73948169\"\n \"checksum ucd-trie 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"71a9c5b1fe77426cf144cc30e49e955270f5086e31a6441dfa8b32efc09b9d77\"\n \"checksum ucd-util 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"535c204ee4d8434478593480b8f86ab45ec9aae0e83c568ca81abf0fd0e88f86\"\n@@ -1757,8 +2000,11 @@ dependencies = [\n \"checksum void 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"6a02e4885ed3bc0f2de90ea6dd45ebcbb66dacffe03547fadbb0eeae2770887d\"\n \"checksum wait-timeout 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"b9f3bf741a801531993db6478b95682117471f76916f5e690dd8d45395b09349\"\n \"checksum walkdir 2.2.7 (registry+https://github.com/rust-lang/crates.io-index)\" = \"9d9d7ed3431229a144296213105a390676cc49c9b6a72bd19f3176c98e129fa1\"\n+\"checksum winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\" = \"167dc9d6949a9b857f3451275e911c3f44255842c1f7a76f33c55103a909087a\"\n \"checksum winapi 0.3.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"92c1eb33641e276cfa214a0522acad57be5c56b10cb348b3c5117db75f3ac4b0\"\n+\"checksum winapi-build 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"2d315eee3b34aca4797b2da6b13ed88266e6d612562a0c46390af8299fc699bc\"\n \"checksum winapi-i686-pc-windows-gnu 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ac3b87c63620426dd9b991e5ce0329eff545bccbbb34f3be09ff6fb6ab51b7b6\"\n \"checksum winapi-util 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"afc5508759c5bf4285e61feb862b6083c8480aec864fa17a81fdec6f69b461ab\"\n \"checksum winapi-x86_64-pc-windows-gnu 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"712e227841d057c1ee1cd2fb22fa7e5a5461ae8e48fa2ca79ec42cfc1931183f\"\n+\"checksum ws2_32-sys 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d59cefebd0c892fa2dd6de581e937301d8552cb44489cdff035c6187cb63fa5e\"\n \"checksum yaml-rust 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"95acf0db5515d07da9965ec0e0ba6cc2d825e2caeb7303b66ca441729801254e\""}, {"sha": "383381d2a957cd4d921e9f553bff9dd33b2e9591", "filename": "crates/ra_vfs/Cargo.toml", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c869ee219a80af1993496e00490dc107202ff55c/crates%2Fra_vfs%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/c869ee219a80af1993496e00490dc107202ff55c/crates%2Fra_vfs%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_vfs%2FCargo.toml?ref=c869ee219a80af1993496e00490dc107202ff55c", "patch": "@@ -10,9 +10,13 @@ relative-path = \"0.4.0\"\n rustc-hash = \"1.0\"\n crossbeam-channel = \"0.3.5\"\n log = \"0.4.6\"\n+notify = \"4.0.7\"\n+drop_bomb = \"0.1.0\"\n+parking_lot = \"0.7.0\"\n \n thread_worker = { path = \"../thread_worker\" }\n ra_arena = { path = \"../ra_arena\" }\n \n [dev-dependencies]\n tempfile = \"3\"\n+flexi_logger = \"0.10.0\""}, {"sha": "7ca1e983586b5ecfacca281fe1e8ade8b328c25b", "filename": "crates/ra_vfs/src/io.rs", "status": "modified", "additions": 91, "deletions": 40, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/c869ee219a80af1993496e00490dc107202ff55c/crates%2Fra_vfs%2Fsrc%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c869ee219a80af1993496e00490dc107202ff55c/crates%2Fra_vfs%2Fsrc%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_vfs%2Fsrc%2Fio.rs?ref=c869ee219a80af1993496e00490dc107202ff55c", "patch": "@@ -1,55 +1,109 @@\n-use std::{\n-    fmt,\n-    fs,\n-    path::{Path, PathBuf},\n-};\n+use std::{fs, sync::Arc, thread};\n \n-use walkdir::{DirEntry, WalkDir};\n-use thread_worker::{WorkerHandle};\n+use crossbeam_channel::{Receiver, Sender};\n use relative_path::RelativePathBuf;\n+use thread_worker::WorkerHandle;\n+use walkdir::WalkDir;\n \n-use crate::{VfsRoot, has_rs_extension};\n+mod watcher;\n+use watcher::Watcher;\n \n-pub(crate) struct Task {\n-    pub(crate) root: VfsRoot,\n-    pub(crate) path: PathBuf,\n-    pub(crate) filter: Box<Fn(&DirEntry) -> bool + Send>,\n+use crate::{RootFilter, Roots, VfsRoot};\n+\n+pub(crate) enum Task {\n+    AddRoot {\n+        root: VfsRoot,\n+        filter: Arc<RootFilter>,\n+    },\n }\n \n-pub struct TaskResult {\n-    pub(crate) root: VfsRoot,\n-    pub(crate) files: Vec<(RelativePathBuf, String)>,\n+#[derive(Debug)]\n+pub enum TaskResult {\n+    BulkLoadRoot {\n+        root: VfsRoot,\n+        files: Vec<(RelativePathBuf, String)>,\n+    },\n+    AddSingleFile {\n+        root: VfsRoot,\n+        path: RelativePathBuf,\n+        text: String,\n+    },\n+    ChangeSingleFile {\n+        root: VfsRoot,\n+        path: RelativePathBuf,\n+        text: String,\n+    },\n+    RemoveSingleFile {\n+        root: VfsRoot,\n+        path: RelativePathBuf,\n+    },\n }\n \n-impl fmt::Debug for TaskResult {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.write_str(\"TaskResult { ... }\")\n-    }\n+pub(crate) struct Worker {\n+    worker: thread_worker::Worker<Task, TaskResult>,\n+    worker_handle: WorkerHandle,\n }\n \n-pub(crate) type Worker = thread_worker::Worker<Task, TaskResult>;\n+impl Worker {\n+    pub(crate) fn start(roots: Arc<Roots>) -> Worker {\n+        let (worker, worker_handle) =\n+            thread_worker::spawn(\"vfs\", 128, move |input_receiver, output_sender| {\n+                let mut watcher = match Watcher::start(roots, output_sender.clone()) {\n+                    Ok(w) => Some(w),\n+                    Err(e) => {\n+                        log::error!(\"could not start watcher: {}\", e);\n+                        None\n+                    }\n+                };\n+                let res = input_receiver\n+                    .into_iter()\n+                    .filter_map(|t| handle_task(t, &mut watcher))\n+                    .try_for_each(|it| output_sender.send(it));\n+                if let Some(watcher) = watcher {\n+                    let _ = watcher.shutdown();\n+                }\n+                res.unwrap()\n+            });\n+        Worker {\n+            worker,\n+            worker_handle,\n+        }\n+    }\n+\n+    pub(crate) fn sender(&self) -> &Sender<Task> {\n+        &self.worker.inp\n+    }\n+\n+    pub(crate) fn receiver(&self) -> &Receiver<TaskResult> {\n+        &self.worker.out\n+    }\n \n-pub(crate) fn start() -> (Worker, WorkerHandle) {\n-    thread_worker::spawn(\"vfs\", 128, |input_receiver, output_sender| {\n-        input_receiver\n-            .into_iter()\n-            .map(handle_task)\n-            .try_for_each(|it| output_sender.send(it))\n-            .unwrap()\n-    })\n+    pub(crate) fn shutdown(self) -> thread::Result<()> {\n+        let _ = self.worker.shutdown();\n+        self.worker_handle.shutdown()\n+    }\n }\n \n-fn handle_task(task: Task) -> TaskResult {\n-    let Task { root, path, filter } = task;\n-    log::debug!(\"loading {} ...\", path.as_path().display());\n-    let files = load_root(path.as_path(), &*filter);\n-    log::debug!(\"... loaded {}\", path.as_path().display());\n-    TaskResult { root, files }\n+fn handle_task(task: Task, watcher: &mut Option<Watcher>) -> Option<TaskResult> {\n+    match task {\n+        Task::AddRoot { root, filter } => {\n+            if let Some(watcher) = watcher {\n+                watcher.watch_root(&filter)\n+            }\n+            log::debug!(\"loading {} ...\", filter.root.as_path().display());\n+            let files = load_root(filter.as_ref());\n+            log::debug!(\"... loaded {}\", filter.root.as_path().display());\n+            Some(TaskResult::BulkLoadRoot { root, files })\n+        }\n+    }\n }\n \n-fn load_root(root: &Path, filter: &dyn Fn(&DirEntry) -> bool) -> Vec<(RelativePathBuf, String)> {\n+fn load_root(filter: &RootFilter) -> Vec<(RelativePathBuf, String)> {\n     let mut res = Vec::new();\n-    for entry in WalkDir::new(root).into_iter().filter_entry(filter) {\n+    for entry in WalkDir::new(&filter.root)\n+        .into_iter()\n+        .filter_entry(filter.entry_filter())\n+    {\n         let entry = match entry {\n             Ok(entry) => entry,\n             Err(e) => {\n@@ -61,17 +115,14 @@ fn load_root(root: &Path, filter: &dyn Fn(&DirEntry) -> bool) -> Vec<(RelativePa\n             continue;\n         }\n         let path = entry.path();\n-        if !has_rs_extension(path) {\n-            continue;\n-        }\n         let text = match fs::read_to_string(path) {\n             Ok(text) => text,\n             Err(e) => {\n                 log::warn!(\"watcher error: {}\", e);\n                 continue;\n             }\n         };\n-        let path = RelativePathBuf::from_path(path.strip_prefix(root).unwrap()).unwrap();\n+        let path = RelativePathBuf::from_path(path.strip_prefix(&filter.root).unwrap()).unwrap();\n         res.push((path.to_owned(), text))\n     }\n     res"}, {"sha": "ff6775f59402cf13c65bebf496d78109aed917f8", "filename": "crates/ra_vfs/src/io/watcher.rs", "status": "added", "additions": 200, "deletions": 0, "changes": 200, "blob_url": "https://github.com/rust-lang/rust/blob/c869ee219a80af1993496e00490dc107202ff55c/crates%2Fra_vfs%2Fsrc%2Fio%2Fwatcher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c869ee219a80af1993496e00490dc107202ff55c/crates%2Fra_vfs%2Fsrc%2Fio%2Fwatcher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_vfs%2Fsrc%2Fio%2Fwatcher.rs?ref=c869ee219a80af1993496e00490dc107202ff55c", "patch": "@@ -0,0 +1,200 @@\n+use crate::{io, RootFilter, Roots, VfsRoot};\n+use crossbeam_channel::Sender;\n+use drop_bomb::DropBomb;\n+use notify::{DebouncedEvent, RecommendedWatcher, RecursiveMode, Watcher as NotifyWatcher};\n+use parking_lot::Mutex;\n+use std::{\n+    fs,\n+    path::{Path, PathBuf},\n+    sync::{mpsc, Arc},\n+    thread,\n+    time::Duration,\n+};\n+use walkdir::WalkDir;\n+\n+#[derive(Debug)]\n+enum ChangeKind {\n+    Create,\n+    Write,\n+    Remove,\n+}\n+\n+const WATCHER_DELAY: Duration = Duration::from_millis(250);\n+\n+pub(crate) struct Watcher {\n+    thread: thread::JoinHandle<()>,\n+    bomb: DropBomb,\n+    watcher: Arc<Mutex<Option<RecommendedWatcher>>>,\n+}\n+\n+impl Watcher {\n+    pub(crate) fn start(\n+        roots: Arc<Roots>,\n+        output_sender: Sender<io::TaskResult>,\n+    ) -> Result<Watcher, Box<std::error::Error>> {\n+        let (input_sender, input_receiver) = mpsc::channel();\n+        let watcher = Arc::new(Mutex::new(Some(notify::watcher(\n+            input_sender,\n+            WATCHER_DELAY,\n+        )?)));\n+        let sender = output_sender.clone();\n+        let watcher_clone = watcher.clone();\n+        let thread = thread::spawn(move || {\n+            let worker = WatcherWorker {\n+                roots,\n+                watcher: watcher_clone,\n+                sender,\n+            };\n+            input_receiver\n+                .into_iter()\n+                // forward relevant events only\n+                .try_for_each(|change| worker.handle_debounced_event(change))\n+                .unwrap()\n+        });\n+        Ok(Watcher {\n+            thread,\n+            watcher,\n+            bomb: DropBomb::new(format!(\"Watcher was not shutdown\")),\n+        })\n+    }\n+\n+    pub fn watch_root(&mut self, filter: &RootFilter) {\n+        for res in WalkDir::new(&filter.root)\n+            .into_iter()\n+            .filter_entry(filter.entry_filter())\n+        {\n+            match res {\n+                Ok(entry) => {\n+                    if entry.file_type().is_dir() {\n+                        watch_one(self.watcher.as_ref(), entry.path());\n+                    }\n+                }\n+                Err(e) => log::warn!(\"watcher error: {}\", e),\n+            }\n+        }\n+    }\n+\n+    pub fn shutdown(mut self) -> thread::Result<()> {\n+        self.bomb.defuse();\n+        drop(self.watcher.lock().take());\n+        let res = self.thread.join();\n+        match &res {\n+            Ok(()) => log::info!(\"... Watcher terminated with ok\"),\n+            Err(_) => log::error!(\"... Watcher terminated with err\"),\n+        }\n+        res\n+    }\n+}\n+\n+struct WatcherWorker {\n+    watcher: Arc<Mutex<Option<RecommendedWatcher>>>,\n+    roots: Arc<Roots>,\n+    sender: Sender<io::TaskResult>,\n+}\n+\n+impl WatcherWorker {\n+    fn handle_debounced_event(&self, ev: DebouncedEvent) -> Result<(), Box<std::error::Error>> {\n+        match ev {\n+            DebouncedEvent::NoticeWrite(_)\n+            | DebouncedEvent::NoticeRemove(_)\n+            | DebouncedEvent::Chmod(_) => {\n+                // ignore\n+            }\n+            DebouncedEvent::Rescan => {\n+                // TODO rescan all roots\n+            }\n+            DebouncedEvent::Create(path) => {\n+                self.handle_change(path, ChangeKind::Create);\n+            }\n+            DebouncedEvent::Write(path) => {\n+                self.handle_change(path, ChangeKind::Write);\n+            }\n+            DebouncedEvent::Remove(path) => {\n+                self.handle_change(path, ChangeKind::Remove);\n+            }\n+            DebouncedEvent::Rename(src, dst) => {\n+                self.handle_change(src, ChangeKind::Remove);\n+                self.handle_change(dst, ChangeKind::Create);\n+            }\n+            DebouncedEvent::Error(err, path) => {\n+                // TODO should we reload the file contents?\n+                log::warn!(\"watcher error \\\"{}\\\", {:?}\", err, path);\n+            }\n+        }\n+        Ok(())\n+    }\n+\n+    fn handle_change(&self, path: PathBuf, kind: ChangeKind) {\n+        if let Err(e) = self.try_handle_change(path, kind) {\n+            log::warn!(\"watcher error: {}\", e)\n+        }\n+    }\n+\n+    fn try_handle_change(\n+        &self,\n+        path: PathBuf,\n+        kind: ChangeKind,\n+    ) -> Result<(), Box<std::error::Error>> {\n+        let (root, rel_path) = match self.roots.find(&path) {\n+            Some(x) => x,\n+            None => return Ok(()),\n+        };\n+        match kind {\n+            ChangeKind::Create => {\n+                if path.is_dir() {\n+                    self.watch_recursive(&path, root);\n+                } else {\n+                    let text = fs::read_to_string(&path)?;\n+                    self.sender.send(io::TaskResult::AddSingleFile {\n+                        root,\n+                        path: rel_path,\n+                        text,\n+                    })?\n+                }\n+            }\n+            ChangeKind::Write => {\n+                let text = fs::read_to_string(&path)?;\n+                self.sender.send(io::TaskResult::ChangeSingleFile {\n+                    root,\n+                    path: rel_path,\n+                    text,\n+                })?\n+            }\n+            ChangeKind::Remove => self.sender.send(io::TaskResult::RemoveSingleFile {\n+                root,\n+                path: rel_path,\n+            })?,\n+        }\n+        Ok(())\n+    }\n+\n+    fn watch_recursive(&self, dir: &Path, root: VfsRoot) {\n+        let filter = &self.roots[root];\n+        for res in WalkDir::new(dir)\n+            .into_iter()\n+            .filter_entry(filter.entry_filter())\n+        {\n+            match res {\n+                Ok(entry) => {\n+                    if entry.file_type().is_dir() {\n+                        watch_one(self.watcher.as_ref(), entry.path());\n+                    } else {\n+                        // emit only for files otherwise we will cause watch_recursive to be called again with a dir that we are already watching\n+                        // emit as create because we haven't seen it yet\n+                        self.handle_change(entry.path().to_path_buf(), ChangeKind::Create);\n+                    }\n+                }\n+                Err(e) => log::warn!(\"watcher error: {}\", e),\n+            }\n+        }\n+    }\n+}\n+\n+fn watch_one(watcher: &Mutex<Option<RecommendedWatcher>>, dir: &Path) {\n+    if let Some(watcher) = watcher.lock().as_mut() {\n+        match watcher.watch(dir, RecursiveMode::NonRecursive) {\n+            Ok(()) => log::debug!(\"watching \\\"{}\\\"\", dir.display()),\n+            Err(e) => log::warn!(\"could not watch \\\"{}\\\": {}\", dir.display(), e),\n+        }\n+    }\n+}"}, {"sha": "d1b0222e79f64420767bb1ce48b85ced2966071a", "filename": "crates/ra_vfs/src/lib.rs", "status": "modified", "additions": 235, "deletions": 124, "changes": 359, "blob_url": "https://github.com/rust-lang/rust/blob/c869ee219a80af1993496e00490dc107202ff55c/crates%2Fra_vfs%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c869ee219a80af1993496e00490dc107202ff55c/crates%2Fra_vfs%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_vfs%2Fsrc%2Flib.rs?ref=c869ee219a80af1993496e00490dc107202ff55c", "patch": "@@ -16,52 +16,77 @@\n mod io;\n \n use std::{\n-    fmt,\n-    mem,\n-    thread,\n     cmp::Reverse,\n+    fmt, fs, mem,\n+    ops::{Deref, DerefMut},\n     path::{Path, PathBuf},\n-    ffi::OsStr,\n     sync::Arc,\n-    fs,\n+    thread,\n };\n \n-use rustc_hash::{FxHashMap, FxHashSet};\n-use relative_path::RelativePathBuf;\n use crossbeam_channel::Receiver;\n+use ra_arena::{impl_arena_id, Arena, RawId};\n+use relative_path::{Component, RelativePath, RelativePathBuf};\n+use rustc_hash::{FxHashMap, FxHashSet};\n use walkdir::DirEntry;\n-use thread_worker::WorkerHandle;\n-use ra_arena::{Arena, RawId, impl_arena_id};\n \n pub use crate::io::TaskResult as VfsTask;\n+use io::{TaskResult, Worker};\n \n /// `RootFilter` is a predicate that checks if a file can belong to a root. If\n /// several filters match a file (nested dirs), the most nested one wins.\n-struct RootFilter {\n+pub(crate) struct RootFilter {\n     root: PathBuf,\n-    file_filter: fn(&Path) -> bool,\n+    filter: fn(&Path, &RelativePath) -> bool,\n+    excluded_dirs: Vec<PathBuf>,\n }\n \n impl RootFilter {\n-    fn new(root: PathBuf) -> RootFilter {\n+    fn new(root: PathBuf, excluded_dirs: Vec<PathBuf>) -> RootFilter {\n         RootFilter {\n             root,\n-            file_filter: has_rs_extension,\n+            filter: default_filter,\n+            excluded_dirs,\n         }\n     }\n     /// Check if this root can contain `path`. NB: even if this returns\n     /// true, the `path` might actually be conained in some nested root.\n-    fn can_contain(&self, path: &Path) -> Option<RelativePathBuf> {\n-        if !(self.file_filter)(path) {\n+    pub(crate) fn can_contain(&self, path: &Path) -> Option<RelativePathBuf> {\n+        let rel_path = path.strip_prefix(&self.root).ok()?;\n+        let rel_path = RelativePathBuf::from_path(rel_path).ok()?;\n+        if !(self.filter)(path, rel_path.as_relative_path()) {\n             return None;\n         }\n-        let path = path.strip_prefix(&self.root).ok()?;\n-        RelativePathBuf::from_path(path).ok()\n+        Some(rel_path)\n+    }\n+\n+    pub(crate) fn entry_filter<'a>(&'a self) -> impl FnMut(&DirEntry) -> bool + 'a {\n+        move |entry: &DirEntry| {\n+            if entry.file_type().is_dir() && self.excluded_dirs.iter().any(|it| it == entry.path())\n+            {\n+                // do not walk nested roots\n+                false\n+            } else {\n+                self.can_contain(entry.path()).is_some()\n+            }\n+        }\n     }\n }\n \n-fn has_rs_extension(p: &Path) -> bool {\n-    p.extension() == Some(OsStr::new(\"rs\"))\n+pub(crate) fn default_filter(path: &Path, rel_path: &RelativePath) -> bool {\n+    if path.is_dir() {\n+        for (i, c) in rel_path.components().enumerate() {\n+            if let Component::Normal(c) = c {\n+                // TODO hardcoded for now\n+                if (i == 0 && c == \"target\") || c == \".git\" || c == \"node_modules\" {\n+                    return false;\n+                }\n+            }\n+        }\n+        true\n+    } else {\n+        rel_path.extension() == Some(\"rs\")\n+    }\n }\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n@@ -75,16 +100,58 @@ impl_arena_id!(VfsFile);\n struct VfsFileData {\n     root: VfsRoot,\n     path: RelativePathBuf,\n+    is_overlayed: bool,\n     text: Arc<String>,\n }\n \n+pub(crate) struct Roots {\n+    roots: Arena<VfsRoot, Arc<RootFilter>>,\n+}\n+\n+impl Roots {\n+    pub(crate) fn new(mut paths: Vec<PathBuf>) -> Roots {\n+        let mut roots = Arena::default();\n+        // A hack to make nesting work.\n+        paths.sort_by_key(|it| Reverse(it.as_os_str().len()));\n+        for (i, path) in paths.iter().enumerate() {\n+            let nested_roots = paths[..i]\n+                .iter()\n+                .filter(|it| it.starts_with(path))\n+                .map(|it| it.clone())\n+                .collect::<Vec<_>>();\n+\n+            let root_filter = Arc::new(RootFilter::new(path.clone(), nested_roots));\n+\n+            roots.alloc(root_filter.clone());\n+        }\n+        Roots { roots }\n+    }\n+    pub(crate) fn find(&self, path: &Path) -> Option<(VfsRoot, RelativePathBuf)> {\n+        self.roots\n+            .iter()\n+            .find_map(|(root, data)| data.can_contain(path).map(|it| (root, it)))\n+    }\n+}\n+\n+impl Deref for Roots {\n+    type Target = Arena<VfsRoot, Arc<RootFilter>>;\n+    fn deref(&self) -> &Self::Target {\n+        &self.roots\n+    }\n+}\n+\n+impl DerefMut for Roots {\n+    fn deref_mut(&mut self) -> &mut Self::Target {\n+        &mut self.roots\n+    }\n+}\n+\n pub struct Vfs {\n-    roots: Arena<VfsRoot, RootFilter>,\n+    roots: Arc<Roots>,\n     files: Arena<VfsFile, VfsFileData>,\n     root2files: FxHashMap<VfsRoot, FxHashSet<VfsFile>>,\n     pending_changes: Vec<VfsChange>,\n-    worker: io::Worker,\n-    worker_handle: WorkerHandle,\n+    worker: Worker,\n }\n \n impl fmt::Debug for Vfs {\n@@ -94,44 +161,30 @@ impl fmt::Debug for Vfs {\n }\n \n impl Vfs {\n-    pub fn new(mut roots: Vec<PathBuf>) -> (Vfs, Vec<VfsRoot>) {\n-        let (worker, worker_handle) = io::start();\n-\n-        let mut res = Vfs {\n-            roots: Arena::default(),\n+    pub fn new(roots: Vec<PathBuf>) -> (Vfs, Vec<VfsRoot>) {\n+        let roots = Arc::new(Roots::new(roots));\n+        let worker = io::Worker::start(roots.clone());\n+        let mut root2files = FxHashMap::default();\n+\n+        for (root, filter) in roots.iter() {\n+            root2files.insert(root, Default::default());\n+            worker\n+                .sender()\n+                .send(io::Task::AddRoot {\n+                    root,\n+                    filter: filter.clone(),\n+                })\n+                .unwrap();\n+        }\n+        let res = Vfs {\n+            roots,\n             files: Arena::default(),\n-            root2files: FxHashMap::default(),\n+            root2files,\n             worker,\n-            worker_handle,\n             pending_changes: Vec::new(),\n         };\n-\n-        // A hack to make nesting work.\n-        roots.sort_by_key(|it| Reverse(it.as_os_str().len()));\n-        for (i, path) in roots.iter().enumerate() {\n-            let root = res.roots.alloc(RootFilter::new(path.clone()));\n-            res.root2files.insert(root, Default::default());\n-            let nested = roots[..i]\n-                .iter()\n-                .filter(|it| it.starts_with(path))\n-                .map(|it| it.clone())\n-                .collect::<Vec<_>>();\n-            let filter = move |entry: &DirEntry| {\n-                if entry.file_type().is_file() {\n-                    has_rs_extension(entry.path())\n-                } else {\n-                    nested.iter().all(|it| it != entry.path())\n-                }\n-            };\n-            let task = io::Task {\n-                root,\n-                path: path.clone(),\n-                filter: Box::new(filter),\n-            };\n-            res.worker.inp.send(task).unwrap();\n-        }\n-        let roots = res.roots.iter().map(|(id, _)| id).collect();\n-        (res, roots)\n+        let vfs_roots = res.roots.iter().map(|(id, _)| id).collect();\n+        (res, vfs_roots)\n     }\n \n     pub fn root2path(&self, root: VfsRoot) -> PathBuf {\n@@ -165,7 +218,7 @@ impl Vfs {\n             } else {\n                 let text = fs::read_to_string(path).unwrap_or_default();\n                 let text = Arc::new(text);\n-                let file = self.add_file(root, rel_path.clone(), Arc::clone(&text));\n+                let file = self.add_file(root, rel_path.clone(), Arc::clone(&text), false);\n                 let change = VfsChange::AddFile {\n                     file,\n                     text,\n@@ -180,85 +233,130 @@ impl Vfs {\n     }\n \n     pub fn task_receiver(&self) -> &Receiver<io::TaskResult> {\n-        &self.worker.out\n+        self.worker.receiver()\n     }\n \n     pub fn handle_task(&mut self, task: io::TaskResult) {\n-        let mut files = Vec::new();\n-        // While we were scanning the root in the backgound, a file might have\n-        // been open in the editor, so we need to account for that.\n-        let exising = self.root2files[&task.root]\n-            .iter()\n-            .map(|&file| (self.files[file].path.clone(), file))\n-            .collect::<FxHashMap<_, _>>();\n-        for (path, text) in task.files {\n-            if let Some(&file) = exising.get(&path) {\n-                let text = Arc::clone(&self.files[file].text);\n-                files.push((file, path, text));\n-                continue;\n+        match task {\n+            TaskResult::BulkLoadRoot { root, files } => {\n+                let mut cur_files = Vec::new();\n+                // While we were scanning the root in the backgound, a file might have\n+                // been open in the editor, so we need to account for that.\n+                let exising = self.root2files[&root]\n+                    .iter()\n+                    .map(|&file| (self.files[file].path.clone(), file))\n+                    .collect::<FxHashMap<_, _>>();\n+                for (path, text) in files {\n+                    if let Some(&file) = exising.get(&path) {\n+                        let text = Arc::clone(&self.files[file].text);\n+                        cur_files.push((file, path, text));\n+                        continue;\n+                    }\n+                    let text = Arc::new(text);\n+                    let file = self.add_file(root, path.clone(), Arc::clone(&text), false);\n+                    cur_files.push((file, path, text));\n+                }\n+\n+                let change = VfsChange::AddRoot {\n+                    root,\n+                    files: cur_files,\n+                };\n+                self.pending_changes.push(change);\n+            }\n+            TaskResult::AddSingleFile { root, path, text } => {\n+                self.do_add_file(root, path, text, false);\n+            }\n+            TaskResult::ChangeSingleFile { root, path, text } => {\n+                if let Some(file) = self.find_file(root, &path) {\n+                    self.do_change_file(file, text, false);\n+                } else {\n+                    self.do_add_file(root, path, text, false);\n+                }\n+            }\n+            TaskResult::RemoveSingleFile { root, path } => {\n+                if let Some(file) = self.find_file(root, &path) {\n+                    self.do_remove_file(root, path, file, false);\n+                }\n             }\n-            let text = Arc::new(text);\n-            let file = self.add_file(task.root, path.clone(), Arc::clone(&text));\n-            files.push((file, path, text));\n         }\n+    }\n \n-        let change = VfsChange::AddRoot {\n-            root: task.root,\n-            files,\n-        };\n-        self.pending_changes.push(change);\n+    fn do_add_file(\n+        &mut self,\n+        root: VfsRoot,\n+        path: RelativePathBuf,\n+        text: String,\n+        is_overlay: bool,\n+    ) -> Option<VfsFile> {\n+        let text = Arc::new(text);\n+        let file = self.add_file(root, path.clone(), text.clone(), is_overlay);\n+        self.pending_changes.push(VfsChange::AddFile {\n+            file,\n+            root,\n+            path,\n+            text,\n+        });\n+        Some(file)\n+    }\n+\n+    fn do_change_file(&mut self, file: VfsFile, text: String, is_overlay: bool) {\n+        if !is_overlay && self.files[file].is_overlayed {\n+            return;\n+        }\n+        let text = Arc::new(text);\n+        self.change_file(file, text.clone(), is_overlay);\n+        self.pending_changes\n+            .push(VfsChange::ChangeFile { file, text });\n+    }\n+\n+    fn do_remove_file(\n+        &mut self,\n+        root: VfsRoot,\n+        path: RelativePathBuf,\n+        file: VfsFile,\n+        is_overlay: bool,\n+    ) {\n+        if !is_overlay && self.files[file].is_overlayed {\n+            return;\n+        }\n+        self.remove_file(file);\n+        self.pending_changes\n+            .push(VfsChange::RemoveFile { root, path, file });\n     }\n \n     pub fn add_file_overlay(&mut self, path: &Path, text: String) -> Option<VfsFile> {\n-        let mut res = None;\n-        if let Some((root, path, file)) = self.find_root(path) {\n-            let text = Arc::new(text);\n-            let change = if let Some(file) = file {\n-                res = Some(file);\n-                self.change_file(file, Arc::clone(&text));\n-                VfsChange::ChangeFile { file, text }\n+        if let Some((root, rel_path, file)) = self.find_root(path) {\n+            if let Some(file) = file {\n+                self.do_change_file(file, text, true);\n+                Some(file)\n             } else {\n-                let file = self.add_file(root, path.clone(), Arc::clone(&text));\n-                res = Some(file);\n-                VfsChange::AddFile {\n-                    file,\n-                    text,\n-                    root,\n-                    path,\n-                }\n-            };\n-            self.pending_changes.push(change);\n+                self.do_add_file(root, rel_path, text, true)\n+            }\n+        } else {\n+            None\n         }\n-        res\n     }\n \n     pub fn change_file_overlay(&mut self, path: &Path, new_text: String) {\n         if let Some((_root, _path, file)) = self.find_root(path) {\n             let file = file.expect(\"can't change a file which wasn't added\");\n-            let text = Arc::new(new_text);\n-            self.change_file(file, Arc::clone(&text));\n-            let change = VfsChange::ChangeFile { file, text };\n-            self.pending_changes.push(change);\n+            self.do_change_file(file, new_text, true);\n         }\n     }\n \n     pub fn remove_file_overlay(&mut self, path: &Path) -> Option<VfsFile> {\n-        let mut res = None;\n         if let Some((root, path, file)) = self.find_root(path) {\n             let file = file.expect(\"can't remove a file which wasn't added\");\n-            res = Some(file);\n             let full_path = path.to_path(&self.roots[root].root);\n-            let change = if let Ok(text) = fs::read_to_string(&full_path) {\n-                let text = Arc::new(text);\n-                self.change_file(file, Arc::clone(&text));\n-                VfsChange::ChangeFile { file, text }\n+            if let Ok(text) = fs::read_to_string(&full_path) {\n+                self.do_change_file(file, text, true);\n             } else {\n-                self.remove_file(file);\n-                VfsChange::RemoveFile { root, file, path }\n-            };\n-            self.pending_changes.push(change);\n+                self.do_remove_file(root, path, file, true);\n+            }\n+            Some(file)\n+        } else {\n+            None\n         }\n-        res\n     }\n \n     pub fn commit_changes(&mut self) -> Vec<VfsChange> {\n@@ -267,19 +365,31 @@ impl Vfs {\n \n     /// Sutdown the VFS and terminate the background watching thread.\n     pub fn shutdown(self) -> thread::Result<()> {\n-        let _ = self.worker.shutdown();\n-        self.worker_handle.shutdown()\n+        self.worker.shutdown()\n     }\n \n-    fn add_file(&mut self, root: VfsRoot, path: RelativePathBuf, text: Arc<String>) -> VfsFile {\n-        let data = VfsFileData { root, path, text };\n+    fn add_file(\n+        &mut self,\n+        root: VfsRoot,\n+        path: RelativePathBuf,\n+        text: Arc<String>,\n+        is_overlayed: bool,\n+    ) -> VfsFile {\n+        let data = VfsFileData {\n+            root,\n+            path,\n+            text,\n+            is_overlayed,\n+        };\n         let file = self.files.alloc(data);\n         self.root2files.get_mut(&root).unwrap().insert(file);\n         file\n     }\n \n-    fn change_file(&mut self, file: VfsFile, new_text: Arc<String>) {\n-        self.files[file].text = new_text;\n+    fn change_file(&mut self, file: VfsFile, new_text: Arc<String>, is_overlayed: bool) {\n+        let mut file_data = &mut self.files[file];\n+        file_data.text = new_text;\n+        file_data.is_overlayed = is_overlayed;\n     }\n \n     fn remove_file(&mut self, file: VfsFile) {\n@@ -292,15 +402,16 @@ impl Vfs {\n     }\n \n     fn find_root(&self, path: &Path) -> Option<(VfsRoot, RelativePathBuf, Option<VfsFile>)> {\n-        let (root, path) = self\n-            .roots\n-            .iter()\n-            .find_map(|(root, data)| data.can_contain(path).map(|it| (root, it)))?;\n-        let file = self.root2files[&root]\n+        let (root, path) = self.roots.find(&path)?;\n+        let file = self.find_file(root, &path);\n+        Some((root, path, file))\n+    }\n+\n+    fn find_file(&self, root: VfsRoot, path: &RelativePath) -> Option<VfsFile> {\n+        self.root2files[&root]\n             .iter()\n             .map(|&it| it)\n-            .find(|&file| self.files[file].path == path);\n-        Some((root, path, file))\n+            .find(|&file| self.files[file].path == path)\n     }\n }\n "}, {"sha": "357e1c775e2614ec09c3a264ecc32a62239d90ab", "filename": "crates/ra_vfs/tests/vfs.rs", "status": "modified", "additions": 117, "deletions": 39, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/c869ee219a80af1993496e00490dc107202ff55c/crates%2Fra_vfs%2Ftests%2Fvfs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c869ee219a80af1993496e00490dc107202ff55c/crates%2Fra_vfs%2Ftests%2Fvfs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_vfs%2Ftests%2Fvfs.rs?ref=c869ee219a80af1993496e00490dc107202ff55c", "patch": "@@ -1,35 +1,55 @@\n-use std::{\n-    fs,\n-    collections::HashSet,\n-};\n+use std::{collections::HashSet, fs, time::Duration};\n \n+// use flexi_logger::Logger;\n+use crossbeam_channel::RecvTimeoutError;\n+use ra_vfs::{Vfs, VfsChange};\n use tempfile::tempdir;\n \n-use ra_vfs::{Vfs, VfsChange};\n+fn process_tasks(vfs: &mut Vfs, num_tasks: u32) {\n+    for _ in 0..num_tasks {\n+        let task = vfs\n+            .task_receiver()\n+            .recv_timeout(Duration::from_secs(3))\n+            .unwrap();\n+        log::debug!(\"{:?}\", task);\n+        vfs.handle_task(task);\n+    }\n+}\n+\n+macro_rules! assert_match {\n+    ($x:expr, $pat:pat) => {\n+        assert_match!($x, $pat, ())\n+    };\n+    ($x:expr, $pat:pat, $assert:expr) => {\n+        match $x {\n+            $pat => $assert,\n+            x => assert!(false, \"Expected {}, got {:?}\", stringify!($pat), x),\n+        };\n+    };\n+}\n \n #[test]\n fn test_vfs_works() -> std::io::Result<()> {\n+    // Logger::with_str(\"vfs=debug,ra_vfs=debug\").start().unwrap();\n+\n     let files = [\n         (\"a/foo.rs\", \"hello\"),\n         (\"a/bar.rs\", \"world\"),\n         (\"a/b/baz.rs\", \"nested hello\"),\n     ];\n \n-    let dir = tempdir()?;\n+    let dir = tempdir().unwrap();\n     for (path, text) in files.iter() {\n         let file_path = dir.path().join(path);\n-        fs::create_dir_all(file_path.parent().unwrap())?;\n+        fs::create_dir_all(file_path.parent().unwrap()).unwrap();\n         fs::write(file_path, text)?\n     }\n \n     let a_root = dir.path().join(\"a\");\n     let b_root = dir.path().join(\"a/b\");\n \n     let (mut vfs, _) = Vfs::new(vec![a_root, b_root]);\n-    for _ in 0..2 {\n-        let task = vfs.task_receiver().recv().unwrap();\n-        vfs.handle_task(task);\n-    }\n+    process_tasks(&mut vfs, 2);\n     {\n         let files = vfs\n             .commit_changes()\n@@ -58,43 +78,101 @@ fn test_vfs_works() -> std::io::Result<()> {\n         assert_eq!(files, expected_files);\n     }\n \n-    vfs.add_file_overlay(&dir.path().join(\"a/b/baz.rs\"), \"quux\".to_string());\n-    let change = vfs.commit_changes().pop().unwrap();\n-    match change {\n-        VfsChange::ChangeFile { text, .. } => assert_eq!(&*text, \"quux\"),\n-        _ => panic!(\"unexpected change\"),\n-    }\n+    fs::write(&dir.path().join(\"a/b/baz.rs\"), \"quux\").unwrap();\n+    process_tasks(&mut vfs, 1);\n+    assert_match!(\n+        vfs.commit_changes().as_slice(),\n+        [VfsChange::ChangeFile { text, .. }],\n+        assert_eq!(text.as_str(), \"quux\")\n+    );\n \n-    vfs.change_file_overlay(&dir.path().join(\"a/b/baz.rs\"), \"m\".to_string());\n-    let change = vfs.commit_changes().pop().unwrap();\n-    match change {\n-        VfsChange::ChangeFile { text, .. } => assert_eq!(&*text, \"m\"),\n-        _ => panic!(\"unexpected change\"),\n-    }\n+    vfs.add_file_overlay(&dir.path().join(\"a/b/baz.rs\"), \"m\".to_string());\n+    assert_match!(\n+        vfs.commit_changes().as_slice(),\n+        [VfsChange::ChangeFile { text, .. }],\n+        assert_eq!(text.as_str(), \"m\")\n+    );\n \n+    // changing file on disk while overlayed doesn't generate a VfsChange\n+    fs::write(&dir.path().join(\"a/b/baz.rs\"), \"corge\").unwrap();\n+    process_tasks(&mut vfs, 1);\n+    assert_match!(vfs.commit_changes().as_slice(), []);\n+\n+    // removing overlay restores data on disk\n     vfs.remove_file_overlay(&dir.path().join(\"a/b/baz.rs\"));\n-    let change = vfs.commit_changes().pop().unwrap();\n-    match change {\n-        VfsChange::ChangeFile { text, .. } => assert_eq!(&*text, \"nested hello\"),\n-        _ => panic!(\"unexpected change\"),\n-    }\n+    assert_match!(\n+        vfs.commit_changes().as_slice(),\n+        [VfsChange::ChangeFile { text, .. }],\n+        assert_eq!(text.as_str(), \"corge\")\n+    );\n \n     vfs.add_file_overlay(&dir.path().join(\"a/b/spam.rs\"), \"spam\".to_string());\n-    let change = vfs.commit_changes().pop().unwrap();\n-    match change {\n-        VfsChange::AddFile { text, path, .. } => {\n-            assert_eq!(&*text, \"spam\");\n+    assert_match!(\n+        vfs.commit_changes().as_slice(),\n+        [VfsChange::AddFile { text, path, .. }],\n+        {\n+            assert_eq!(text.as_str(), \"spam\");\n             assert_eq!(path, \"spam.rs\");\n         }\n-        _ => panic!(\"unexpected change\"),\n-    }\n+    );\n \n     vfs.remove_file_overlay(&dir.path().join(\"a/b/spam.rs\"));\n-    let change = vfs.commit_changes().pop().unwrap();\n-    match change {\n-        VfsChange::RemoveFile { .. } => (),\n-        _ => panic!(\"unexpected change\"),\n-    }\n+    assert_match!(\n+        vfs.commit_changes().as_slice(),\n+        [VfsChange::RemoveFile { path, .. }],\n+        assert_eq!(path, \"spam.rs\")\n+    );\n+\n+    fs::create_dir_all(dir.path().join(\"a/sub1/sub2\")).unwrap();\n+    fs::write(dir.path().join(\"a/sub1/sub2/new.rs\"), \"new hello\").unwrap();\n+    process_tasks(&mut vfs, 1);\n+    assert_match!(\n+        vfs.commit_changes().as_slice(),\n+        [VfsChange::AddFile { text, path, .. }],\n+        {\n+            assert_eq!(text.as_str(), \"new hello\");\n+            assert_eq!(path, \"sub1/sub2/new.rs\");\n+        }\n+    );\n+\n+    fs::rename(\n+        &dir.path().join(\"a/sub1/sub2/new.rs\"),\n+        &dir.path().join(\"a/sub1/sub2/new1.rs\"),\n+    )\n+    .unwrap();\n+    process_tasks(&mut vfs, 2);\n+    assert_match!(\n+        vfs.commit_changes().as_slice(),\n+        [VfsChange::RemoveFile {\n+            path: removed_path, ..\n+        }, VfsChange::AddFile {\n+            text,\n+            path: added_path,\n+            ..\n+        }],\n+        {\n+            assert_eq!(removed_path, \"sub1/sub2/new.rs\");\n+            assert_eq!(added_path, \"sub1/sub2/new1.rs\");\n+            assert_eq!(text.as_str(), \"new hello\");\n+        }\n+    );\n+\n+    fs::remove_file(&dir.path().join(\"a/sub1/sub2/new1.rs\")).unwrap();\n+    process_tasks(&mut vfs, 1);\n+    assert_match!(\n+        vfs.commit_changes().as_slice(),\n+        [VfsChange::RemoveFile { path, .. }],\n+        assert_eq!(path, \"sub1/sub2/new1.rs\")\n+    );\n+\n+    // should be ignored\n+    fs::create_dir_all(dir.path().join(\"a/target\")).unwrap();\n+    fs::write(&dir.path().join(\"a/target/new.rs\"), \"ignore me\").unwrap();\n+\n+    assert_match!(\n+        vfs.task_receiver().recv_timeout(Duration::from_millis(300)), // slightly more than watcher debounce delay\n+        Err(RecvTimeoutError::Timeout)\n+    );\n \n     vfs.shutdown().unwrap();\n     Ok(())"}]}