{"sha": "3699c2497bc6ff74126ae8c56a06905f49d0300c", "node_id": "C_kwDOAAsO6NoAKDM2OTljMjQ5N2JjNmZmNzQxMjZhZThjNTZhMDY5MDVmNDlkMDMwMGM", "commit": {"author": {"name": "mejrs", "email": "", "date": "2022-09-12T20:17:06Z"}, "committer": {"name": "mejrs", "email": "", "date": "2022-09-18T00:44:44Z"}, "message": "Address feedback", "tree": {"sha": "8de0525d5bd6d61a50977ad608e2d61cc8cbc8e7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8de0525d5bd6d61a50977ad608e2d61cc8cbc8e7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3699c2497bc6ff74126ae8c56a06905f49d0300c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3699c2497bc6ff74126ae8c56a06905f49d0300c", "html_url": "https://github.com/rust-lang/rust/commit/3699c2497bc6ff74126ae8c56a06905f49d0300c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3699c2497bc6ff74126ae8c56a06905f49d0300c/comments", "author": {}, "committer": {}, "parents": [{"sha": "8477b9b707db74aa97a8390ff562f0e20b5d4d86", "url": "https://api.github.com/repos/rust-lang/rust/commits/8477b9b707db74aa97a8390ff562f0e20b5d4d86", "html_url": "https://github.com/rust-lang/rust/commit/8477b9b707db74aa97a8390ff562f0e20b5d4d86"}], "stats": {"total": 272, "additions": 223, "deletions": 49}, "files": [{"sha": "d4e8e267babe9b8361a3bd175f045f0511ebbb75", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 140, "deletions": 31, "changes": 171, "blob_url": "https://github.com/rust-lang/rust/blob/3699c2497bc6ff74126ae8c56a06905f49d0300c/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3699c2497bc6ff74126ae8c56a06905f49d0300c/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=3699c2497bc6ff74126ae8c56a06905f49d0300c", "patch": "@@ -1654,47 +1654,156 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 ),\n                 Mismatch::Fixed(s) => (s.into(), s.into(), None),\n             };\n-            let looks_similar = |e: ExpectedFound<Ty<'_>>| {\n-                // We're only interested in adts\n-                if let (Some(e), Some(f)) = (e.expected.ty_adt_def(), e.found.ty_adt_def()) {\n-                    // Only compare the last parts of the path.\n-                    // `whatever::Foo` is pretty similar to `blah::Foo`\n-                    let e_path = self.tcx.def_path(e.did()).data;\n-                    let f_path = self.tcx.def_path(f.did()).data;\n-                    if let (Some(e), Some(f)) = (e_path.last(), f_path.last()) {\n-                        return e.data == f.data;\n+\n+            enum Similar<'tcx> {\n+                Adts(ty::AdtDef<'tcx>, ty::AdtDef<'tcx>),\n+                PrimitiveFound(Ty<'tcx>, ty::AdtDef<'tcx>),\n+                PrimitiveExpected(ty::AdtDef<'tcx>, Ty<'tcx>),\n+            }\n+\n+            let primitive_sym = |kind: &_| match kind {\n+                ty::Bool => Some(sym::bool),\n+                ty::Char => Some(sym::char),\n+                ty::Float(f) => match f {\n+                    ty::FloatTy::F32 => Some(sym::f32),\n+                    ty::FloatTy::F64 => Some(sym::f64),\n+                },\n+                ty::Int(f) => match f {\n+                    ty::IntTy::Isize => Some(sym::isize),\n+                    ty::IntTy::I8 => Some(sym::i8),\n+                    ty::IntTy::I16 => Some(sym::i16),\n+                    ty::IntTy::I32 => Some(sym::i32),\n+                    ty::IntTy::I64 => Some(sym::i64),\n+                    ty::IntTy::I128 => Some(sym::i128),\n+                },\n+                ty::Uint(f) => match f {\n+                    ty::UintTy::Usize => Some(sym::usize),\n+                    ty::UintTy::U8 => Some(sym::u8),\n+                    ty::UintTy::U16 => Some(sym::u16),\n+                    ty::UintTy::U32 => Some(sym::u32),\n+                    ty::UintTy::U64 => Some(sym::u64),\n+                    ty::UintTy::U128 => Some(sym::u128),\n+                },\n+                _ => None,\n+            };\n+\n+            let similarity = |e: ExpectedFound<Ty<'tcx>>| {\n+                let (fk, ek) = (e.found.kind(), e.expected.kind());\n+                match (fk, ek) {\n+                    (\n+                        ty::Adt(adt, _),\n+                        ty::Bool | ty::Char | ty::Int(_) | ty::Uint(_) | ty::Float(_),\n+                    ) => {\n+                        let path = self.tcx.def_path(adt.did()).data;\n+                        let name = path.last().unwrap().data.get_opt_name();\n+                        let prim_sym = primitive_sym(ek);\n+\n+                        if name == prim_sym {\n+                            return Some(Similar::PrimitiveExpected(*adt, e.expected));\n+                        }\n+                        None\n+                    }\n+                    (\n+                        ty::Bool | ty::Char | ty::Int(_) | ty::Uint(_) | ty::Float(_),\n+                        ty::Adt(adt, _),\n+                    ) => {\n+                        let path = self.tcx.def_path(adt.did()).data;\n+                        let name = path.last().unwrap().data.get_opt_name();\n+                        let prim_sym = primitive_sym(fk);\n+\n+                        if name == prim_sym {\n+                            return Some(Similar::PrimitiveFound(e.expected, *adt));\n+                        }\n+                        None\n+                    }\n+                    (ty::Adt(f, _), ty::Adt(e, _)) => {\n+                        if !f.did().is_local() && f.did().krate == e.did().krate {\n+                            // Most likely types from different versions of the same crate\n+                            // are in play, in which case this message isn't so helpful.\n+                            // A \"perhaps two different versions...\" error is already emitted for that.\n+                            return None;\n+                        }\n+                        let e_path = self.tcx.def_path(e.did()).data;\n+                        let f_path = self.tcx.def_path(f.did()).data;\n+                        if let (Some(e_last), Some(f_last)) = (e_path.last(), f_path.last()) && e_last ==  f_last {\n+                            return Some(Similar::Adts(*f, *e));\n+                        }\n+                        None\n                     }\n+                    _ => None,\n                 }\n-                false\n             };\n \n             match terr {\n                 // If two types mismatch but have similar names, mention that specifically.\n-                TypeError::Sorts(values) if looks_similar(values) => {\n-                    let found_adt = values.found.ty_adt_def().unwrap();\n-                    let expected_adt = values.expected.ty_adt_def().unwrap();\n-\n-                    let found_name = values.found.sort_string(self.tcx);\n-                    let expected_name = values.expected.sort_string(self.tcx);\n+                TypeError::Sorts(values) if let Some(s) = similarity(values) => {\n+                    let diagnose_primitive =\n+                        |prim: Ty<'tcx>,\n+                         shadow: Ty<'tcx>,\n+                         defid: DefId,\n+                         diagnostic: &mut Diagnostic| {\n+                            let name = shadow.sort_string(self.tcx);\n+                            diagnostic.note(format!(\n+                            \"{prim} and {name} have similar names, but are actually distinct types\"\n+                        ));\n+                            diagnostic\n+                                .note(format!(\"{prim} is a primitive defined by the language\"));\n+                            let def_span = self.tcx.def_span(defid);\n+                            let msg = if defid.is_local() {\n+                                format!(\"{name} is defined in the current crate\")\n+                            } else {\n+                                let crate_name = self.tcx.crate_name(defid.krate);\n+                                format!(\"{name} is defined in crate `{crate_name}\")\n+                            };\n+                            diagnostic.span_note(def_span, msg);\n+                        };\n \n-                    diag.note(format!(\"{found_name} and {expected_name} have similar names, but are actually distinct types\"));\n+                    let diagnose_adts =\n+                        |found_adt: ty::AdtDef<'tcx>,\n+                         expected_adt: ty::AdtDef<'tcx>,\n+                         diagnostic: &mut Diagnostic| {\n+                            let found_name = values.found.sort_string(self.tcx);\n+                            let expected_name = values.expected.sort_string(self.tcx);\n \n-                    for (adt, name) in [(found_adt, found_name), (expected_adt, expected_name)] {\n-                        let defid = adt.did();\n-                        let def_span = self.tcx.def_span(defid);\n+                            let found_defid = found_adt.did();\n+                            let expected_defid = expected_adt.did();\n \n-                        let msg = if defid.is_local() {\n-                            format!(\"{name} is defined in the current crate.\")\n-                        } else if self.tcx.all_diagnostic_items(()).id_to_name.get(&defid).is_some()\n-                        {\n-                            // if it's a diagnostic item, it's definitely defined in std/core/alloc\n-                            // otherwise might be, might not be.\n-                            format!(\"{name} is defined in the standard library.\")\n-                        } else {\n-                            let crate_name = self.tcx.crate_name(defid.krate);\n-                            format!(\"{name} is defined in crate `{crate_name}`.\")\n+                            diagnostic.note(format!(\"{found_name} and {expected_name} have similar names, but are actually distinct types\"));\n+                            for (defid, name) in\n+                                [(found_defid, found_name), (expected_defid, expected_name)]\n+                            {\n+                                let def_span = self.tcx.def_span(defid);\n+\n+                                let msg = if found_defid.is_local() && expected_defid.is_local() {\n+                                    let module = self\n+                                        .tcx\n+                                        .parent_module_from_def_id(defid.expect_local())\n+                                        .to_def_id();\n+                                    let module_name =\n+                                        self.tcx.def_path(module).to_string_no_crate_verbose();\n+                                    format!(\n+                                        \"{name} is defined in module {module_name} of the current crate\"\n+                                    )\n+                                } else if defid.is_local() {\n+                                    format!(\"{name} is defined in the current crate\")\n+                                } else {\n+                                    let crate_name = self.tcx.crate_name(defid.krate);\n+                                    format!(\"{name} is defined in crate `{crate_name}`\")\n+                                };\n+                                diagnostic.span_note(def_span, msg);\n+                            }\n                         };\n-                        diag.span_note(def_span, msg);\n+\n+                    match s {\n+                        Similar::Adts(found_adt, expected_adt) => {\n+                            diagnose_adts(found_adt, expected_adt, diag)\n+                        }\n+                        Similar::PrimitiveFound(prim, e) => {\n+                            diagnose_primitive(prim, values.expected, e.did(), diag)\n+                        }\n+                        Similar::PrimitiveExpected(f, prim) => {\n+                            diagnose_primitive(prim, values.found, f.did(), diag)\n+                        }\n                     }\n                 }\n                 TypeError::Sorts(values) => {"}, {"sha": "5b14e5bdb78cf16aa3c5548d1888042f88d01bec", "filename": "compiler/rustc_infer/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3699c2497bc6ff74126ae8c56a06905f49d0300c/compiler%2Frustc_infer%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3699c2497bc6ff74126ae8c56a06905f49d0300c/compiler%2Frustc_infer%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Flib.rs?ref=3699c2497bc6ff74126ae8c56a06905f49d0300c", "patch": "@@ -20,6 +20,8 @@\n #![cfg_attr(bootstrap, feature(label_break_value))]\n #![feature(let_chains)]\n #![cfg_attr(bootstrap, feature(let_else))]\n+#![feature(let_else)]\n+#![feature(if_let_guard)]\n #![feature(min_specialization)]\n #![feature(never_type)]\n #![feature(try_blocks)]"}, {"sha": "94c34cf9d04faef82fadc5c123fe307c6ab6934f", "filename": "src/test/ui/fully-qualified-type/fully-qualified-type-name2.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3699c2497bc6ff74126ae8c56a06905f49d0300c/src%2Ftest%2Fui%2Ffully-qualified-type%2Ffully-qualified-type-name2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3699c2497bc6ff74126ae8c56a06905f49d0300c/src%2Ftest%2Fui%2Ffully-qualified-type%2Ffully-qualified-type-name2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffully-qualified-type%2Ffully-qualified-type-name2.stderr?ref=3699c2497bc6ff74126ae8c56a06905f49d0300c", "patch": "@@ -7,12 +7,12 @@ LL |     return x;\n    |            ^ expected enum `y::Foo`, found enum `x::Foo`\n    |\n    = note: enum `x::Foo` and enum `y::Foo` have similar names, but are actually distinct types\n-note: enum `x::Foo` is defined in the current crate.\n+note: enum `x::Foo` is defined in module ::x of the current crate\n   --> $DIR/fully-qualified-type-name2.rs:4:5\n    |\n LL |     pub enum Foo { }\n    |     ^^^^^^^^^^^^\n-note: enum `y::Foo` is defined in the current crate.\n+note: enum `y::Foo` is defined in module ::y of the current crate\n   --> $DIR/fully-qualified-type-name2.rs:8:5\n    |\n LL |     pub enum Foo { }"}, {"sha": "74ed5ec0fb6f161ba399c44cbfe131192c114aaf", "filename": "src/test/ui/issues/issue-56943.stderr", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3699c2497bc6ff74126ae8c56a06905f49d0300c/src%2Ftest%2Fui%2Fissues%2Fissue-56943.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3699c2497bc6ff74126ae8c56a06905f49d0300c/src%2Ftest%2Fui%2Fissues%2Fissue-56943.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-56943.stderr?ref=3699c2497bc6ff74126ae8c56a06905f49d0300c", "patch": "@@ -5,18 +5,6 @@ LL |     let _: issue_56943::S = issue_56943::S2;\n    |            --------------   ^^^^^^^^^^^^^^^ expected struct `S`, found struct `S2`\n    |            |\n    |            expected due to this\n-   |\n-   = note: struct `S2` and struct `S` have similar names, but are actually distinct types\n-note: struct `S2` is defined in crate `issue_56943`.\n-  --> $DIR/auxiliary/issue-56943.rs:2:9\n-   |\n-LL | mod m { pub struct S; }\n-   |         ^^^^^^^^^^^^\n-note: struct `S` is defined in crate `issue_56943`.\n-  --> $DIR/auxiliary/issue-56943.rs:1:1\n-   |\n-LL | pub struct S;\n-   | ^^^^^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "97d45b377bcfbb4d27d1f676354f655cfc746cc8", "filename": "src/test/ui/mismatched_types/show_module.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3699c2497bc6ff74126ae8c56a06905f49d0300c/src%2Ftest%2Fui%2Fmismatched_types%2Fshow_module.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3699c2497bc6ff74126ae8c56a06905f49d0300c/src%2Ftest%2Fui%2Fmismatched_types%2Fshow_module.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fshow_module.rs?ref=3699c2497bc6ff74126ae8c56a06905f49d0300c", "patch": "@@ -0,0 +1,18 @@\n+pub mod blah{\n+    pub mod baz{\n+        pub struct Foo;\n+    }\n+}\n+\n+pub mod meh{\n+    pub struct Foo;\n+}\n+\n+pub type Foo = blah::baz::Foo;\n+\n+fn foo() -> Foo {\n+    meh::Foo\n+    //~^ ERROR mismatched types [E0308]\n+}\n+\n+fn main(){}"}, {"sha": "6d8986d1cad2cfe0d5879920701830e03e886fd9", "filename": "src/test/ui/mismatched_types/show_module.stderr", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/3699c2497bc6ff74126ae8c56a06905f49d0300c/src%2Ftest%2Fui%2Fmismatched_types%2Fshow_module.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3699c2497bc6ff74126ae8c56a06905f49d0300c/src%2Ftest%2Fui%2Fmismatched_types%2Fshow_module.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fshow_module.stderr?ref=3699c2497bc6ff74126ae8c56a06905f49d0300c", "patch": "@@ -0,0 +1,23 @@\n+error[E0308]: mismatched types\n+  --> $DIR/show_module.rs:14:5\n+   |\n+LL | fn foo() -> Foo {\n+   |             --- expected `baz::Foo` because of return type\n+LL |     meh::Foo\n+   |     ^^^^^^^^ expected struct `baz::Foo`, found struct `meh::Foo`\n+   |\n+   = note: struct `meh::Foo` and struct `baz::Foo` have similar names, but are actually distinct types\n+note: struct `meh::Foo` is defined in module ::meh of the current crate\n+  --> $DIR/show_module.rs:8:5\n+   |\n+LL |     pub struct Foo;\n+   |     ^^^^^^^^^^^^^^\n+note: struct `baz::Foo` is defined in module ::blah::baz of the current crate\n+  --> $DIR/show_module.rs:3:9\n+   |\n+LL |         pub struct Foo;\n+   |         ^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "16f33e55fea03e017b4d1cbe6db10822fc75263e", "filename": "src/test/ui/mismatched_types/similar_paths.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3699c2497bc6ff74126ae8c56a06905f49d0300c/src%2Ftest%2Fui%2Fmismatched_types%2Fsimilar_paths.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3699c2497bc6ff74126ae8c56a06905f49d0300c/src%2Ftest%2Fui%2Fmismatched_types%2Fsimilar_paths.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fsimilar_paths.stderr?ref=3699c2497bc6ff74126ae8c56a06905f49d0300c", "patch": "@@ -7,12 +7,12 @@ LL |     Some(42_u8)\n    |     ^^^^^^^^^^^ expected enum `Option`, found enum `std::option::Option`\n    |\n    = note: enum `std::option::Option` and enum `Option` have similar names, but are actually distinct types\n-note: enum `std::option::Option` is defined in the standard library.\n+note: enum `std::option::Option` is defined in crate `core`\n   --> $SRC_DIR/core/src/option.rs:LL:COL\n    |\n LL | pub enum Option<T> {\n    | ^^^^^^^^^^^^^^^^^^\n-note: enum `Option` is defined in the current crate.\n+note: enum `Option` is defined in the current crate\n   --> $DIR/similar_paths.rs:1:1\n    |\n LL | enum Option<T>{"}, {"sha": "8f5b7cce46908abcdb36141f672126a73e01862d", "filename": "src/test/ui/mismatched_types/similar_paths_primitive.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3699c2497bc6ff74126ae8c56a06905f49d0300c/src%2Ftest%2Fui%2Fmismatched_types%2Fsimilar_paths_primitive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3699c2497bc6ff74126ae8c56a06905f49d0300c/src%2Ftest%2Fui%2Fmismatched_types%2Fsimilar_paths_primitive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fsimilar_paths_primitive.rs?ref=3699c2497bc6ff74126ae8c56a06905f49d0300c", "patch": "@@ -0,0 +1,10 @@\n+#![allow(non_camel_case_types)]\n+\n+struct bool;\n+\n+fn foo(_: bool) {}\n+\n+fn main() {\n+    foo(true);\n+    //~^ ERROR mismatched types [E0308]\n+}"}, {"sha": "8a2f73945e84184d0d00e9e1e478279b15631966", "filename": "src/test/ui/mismatched_types/similar_paths_primitive.stderr", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/3699c2497bc6ff74126ae8c56a06905f49d0300c/src%2Ftest%2Fui%2Fmismatched_types%2Fsimilar_paths_primitive.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3699c2497bc6ff74126ae8c56a06905f49d0300c/src%2Ftest%2Fui%2Fmismatched_types%2Fsimilar_paths_primitive.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fsimilar_paths_primitive.stderr?ref=3699c2497bc6ff74126ae8c56a06905f49d0300c", "patch": "@@ -0,0 +1,24 @@\n+error[E0308]: mismatched types\n+  --> $DIR/similar_paths_primitive.rs:8:9\n+   |\n+LL |     foo(true);\n+   |     --- ^^^^ expected struct `bool`, found `bool`\n+   |     |\n+   |     arguments to this function are incorrect\n+   |\n+   = note: bool and struct `bool` have similar names, but are actually distinct types\n+   = note: bool is a primitive defined by the language\n+note: struct `bool` is defined in the current crate\n+  --> $DIR/similar_paths_primitive.rs:3:1\n+   |\n+LL | struct bool;\n+   | ^^^^^^^^^^^\n+note: function defined here\n+  --> $DIR/similar_paths_primitive.rs:5:4\n+   |\n+LL | fn foo(_: bool) {}\n+   |    ^^^ -------\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "fcafd315ebf5450e5f0ea68e6281a6d52969bf46", "filename": "src/test/ui/type/type-mismatch-same-crate-name.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3699c2497bc6ff74126ae8c56a06905f49d0300c/src%2Ftest%2Fui%2Ftype%2Ftype-mismatch-same-crate-name.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3699c2497bc6ff74126ae8c56a06905f49d0300c/src%2Ftest%2Fui%2Ftype%2Ftype-mismatch-same-crate-name.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Ftype-mismatch-same-crate-name.stderr?ref=3699c2497bc6ff74126ae8c56a06905f49d0300c", "patch": "@@ -7,12 +7,12 @@ LL |         a::try_foo(foo2);\n    |         arguments to this function are incorrect\n    |\n    = note: struct `main::a::Foo` and struct `main::a::Foo` have similar names, but are actually distinct types\n-note: struct `main::a::Foo` is defined in crate `crate_a2`.\n+note: struct `main::a::Foo` is defined in crate `crate_a2`\n   --> $DIR/auxiliary/crate_a2.rs:1:1\n    |\n LL | pub struct Foo;\n    | ^^^^^^^^^^^^^^\n-note: struct `main::a::Foo` is defined in crate `crate_a1`.\n+note: struct `main::a::Foo` is defined in crate `crate_a1`\n   --> $DIR/auxiliary/crate_a1.rs:1:1\n    |\n LL | pub struct Foo;"}]}