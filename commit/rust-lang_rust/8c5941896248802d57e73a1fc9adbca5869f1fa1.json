{"sha": "8c5941896248802d57e73a1fc9adbca5869f1fa1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhjNTk0MTg5NjI0ODgwMmQ1N2U3M2ExZmM5YWRiY2E1ODY5ZjFmYTE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-12-31T16:38:10Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-12-31T16:38:10Z"}, "message": "Auto merge of #46713 - Manishearth:memchr, r=bluss\n\nUse memchr to speed up [u8]::contains 3x\n\nNone", "tree": {"sha": "dd9cbcbdcaf84e0bde5801fdb5b09b0a03d02041", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dd9cbcbdcaf84e0bde5801fdb5b09b0a03d02041"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8c5941896248802d57e73a1fc9adbca5869f1fa1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8c5941896248802d57e73a1fc9adbca5869f1fa1", "html_url": "https://github.com/rust-lang/rust/commit/8c5941896248802d57e73a1fc9adbca5869f1fa1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8c5941896248802d57e73a1fc9adbca5869f1fa1/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "885011ef1fd8fbe8c5be50a0713c03c980772be3", "url": "https://api.github.com/repos/rust-lang/rust/commits/885011ef1fd8fbe8c5be50a0713c03c980772be3", "html_url": "https://github.com/rust-lang/rust/commit/885011ef1fd8fbe8c5be50a0713c03c980772be3"}, {"sha": "4ef6847d4df609054caca328b69b4ee5335426ae", "url": "https://api.github.com/repos/rust-lang/rust/commits/4ef6847d4df609054caca328b69b4ee5335426ae", "html_url": "https://github.com/rust-lang/rust/commit/4ef6847d4df609054caca328b69b4ee5335426ae"}], "stats": {"total": 498, "additions": 265, "deletions": 233}, "files": [{"sha": "00183be97e7514873636375ce4c561cfd72aec65", "filename": "src/libcore/slice/memchr.rs", "status": "added", "additions": 230, "deletions": 0, "changes": 230, "blob_url": "https://github.com/rust-lang/rust/blob/8c5941896248802d57e73a1fc9adbca5869f1fa1/src%2Flibcore%2Fslice%2Fmemchr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c5941896248802d57e73a1fc9adbca5869f1fa1/src%2Flibcore%2Fslice%2Fmemchr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmemchr.rs?ref=8c5941896248802d57e73a1fc9adbca5869f1fa1", "patch": "@@ -0,0 +1,230 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+//\n+// Original implementation taken from rust-memchr\n+// Copyright 2015 Andrew Gallant, bluss and Nicolas Koch\n+\n+use cmp;\n+use mem;\n+\n+const LO_U64: u64 = 0x0101010101010101;\n+const HI_U64: u64 = 0x8080808080808080;\n+\n+// use truncation\n+const LO_USIZE: usize = LO_U64 as usize;\n+const HI_USIZE: usize = HI_U64 as usize;\n+\n+/// Return `true` if `x` contains any zero byte.\n+///\n+/// From *Matters Computational*, J. Arndt\n+///\n+/// \"The idea is to subtract one from each of the bytes and then look for\n+/// bytes where the borrow propagated all the way to the most significant\n+/// bit.\"\n+#[inline]\n+fn contains_zero_byte(x: usize) -> bool {\n+    x.wrapping_sub(LO_USIZE) & !x & HI_USIZE != 0\n+}\n+\n+#[cfg(target_pointer_width = \"16\")]\n+#[inline]\n+fn repeat_byte(b: u8) -> usize {\n+    (b as usize) << 8 | b as usize\n+}\n+\n+#[cfg(target_pointer_width = \"32\")]\n+#[inline]\n+fn repeat_byte(b: u8) -> usize {\n+    let mut rep = (b as usize) << 8 | b as usize;\n+    rep = rep << 16 | rep;\n+    rep\n+}\n+\n+#[cfg(target_pointer_width = \"64\")]\n+#[inline]\n+fn repeat_byte(b: u8) -> usize {\n+    let mut rep = (b as usize) << 8 | b as usize;\n+    rep = rep << 16 | rep;\n+    rep = rep << 32 | rep;\n+    rep\n+}\n+\n+/// Return the first index matching the byte `a` in `text`.\n+pub fn memchr(x: u8, text: &[u8]) -> Option<usize> {\n+    // Scan for a single byte value by reading two `usize` words at a time.\n+    //\n+    // Split `text` in three parts\n+    // - unaligned initial part, before the first word aligned address in text\n+    // - body, scan by 2 words at a time\n+    // - the last remaining part, < 2 word size\n+    let len = text.len();\n+    let ptr = text.as_ptr();\n+    let usize_bytes = mem::size_of::<usize>();\n+\n+    // search up to an aligned boundary\n+    let mut offset = ptr.align_offset(usize_bytes);\n+    if offset > 0 {\n+        offset = cmp::min(offset, len);\n+        if let Some(index) = text[..offset].iter().position(|elt| *elt == x) {\n+            return Some(index);\n+        }\n+    }\n+\n+    // search the body of the text\n+    let repeated_x = repeat_byte(x);\n+\n+    if len >= 2 * usize_bytes {\n+        while offset <= len - 2 * usize_bytes {\n+            unsafe {\n+                let u = *(ptr.offset(offset as isize) as *const usize);\n+                let v = *(ptr.offset((offset + usize_bytes) as isize) as *const usize);\n+\n+                // break if there is a matching byte\n+                let zu = contains_zero_byte(u ^ repeated_x);\n+                let zv = contains_zero_byte(v ^ repeated_x);\n+                if zu || zv {\n+                    break;\n+                }\n+            }\n+            offset += usize_bytes * 2;\n+        }\n+    }\n+\n+    // find the byte after the point the body loop stopped\n+    text[offset..].iter().position(|elt| *elt == x).map(|i| offset + i)\n+}\n+\n+/// Return the last index matching the byte `a` in `text`.\n+pub fn memrchr(x: u8, text: &[u8]) -> Option<usize> {\n+    // Scan for a single byte value by reading two `usize` words at a time.\n+    //\n+    // Split `text` in three parts\n+    // - unaligned tail, after the last word aligned address in text\n+    // - body, scan by 2 words at a time\n+    // - the first remaining bytes, < 2 word size\n+    let len = text.len();\n+    let ptr = text.as_ptr();\n+    let usize_bytes = mem::size_of::<usize>();\n+\n+    // search to an aligned boundary\n+    let end_align = (ptr as usize + len) & (usize_bytes - 1);\n+    let mut offset;\n+    if end_align > 0 {\n+        offset = if end_align >= len { 0 } else { len - end_align };\n+        if let Some(index) = text[offset..].iter().rposition(|elt| *elt == x) {\n+            return Some(offset + index);\n+        }\n+    } else {\n+        offset = len;\n+    }\n+\n+    // search the body of the text\n+    let repeated_x = repeat_byte(x);\n+\n+    while offset >= 2 * usize_bytes {\n+        unsafe {\n+            let u = *(ptr.offset(offset as isize - 2 * usize_bytes as isize) as *const usize);\n+            let v = *(ptr.offset(offset as isize - usize_bytes as isize) as *const usize);\n+\n+            // break if there is a matching byte\n+            let zu = contains_zero_byte(u ^ repeated_x);\n+            let zv = contains_zero_byte(v ^ repeated_x);\n+            if zu || zv {\n+                break;\n+            }\n+        }\n+        offset -= 2 * usize_bytes;\n+    }\n+\n+    // find the byte before the point the body loop stopped\n+    text[..offset].iter().rposition(|elt| *elt == x)\n+}\n+\n+// test fallback implementations on all platforms\n+#[test]\n+fn matches_one() {\n+    assert_eq!(Some(0), memchr(b'a', b\"a\"));\n+}\n+\n+#[test]\n+fn matches_begin() {\n+    assert_eq!(Some(0), memchr(b'a', b\"aaaa\"));\n+}\n+\n+#[test]\n+fn matches_end() {\n+    assert_eq!(Some(4), memchr(b'z', b\"aaaaz\"));\n+}\n+\n+#[test]\n+fn matches_nul() {\n+    assert_eq!(Some(4), memchr(b'\\x00', b\"aaaa\\x00\"));\n+}\n+\n+#[test]\n+fn matches_past_nul() {\n+    assert_eq!(Some(5), memchr(b'z', b\"aaaa\\x00z\"));\n+}\n+\n+#[test]\n+fn no_match_empty() {\n+    assert_eq!(None, memchr(b'a', b\"\"));\n+}\n+\n+#[test]\n+fn no_match() {\n+    assert_eq!(None, memchr(b'a', b\"xyz\"));\n+}\n+\n+#[test]\n+fn matches_one_reversed() {\n+    assert_eq!(Some(0), memrchr(b'a', b\"a\"));\n+}\n+\n+#[test]\n+fn matches_begin_reversed() {\n+    assert_eq!(Some(3), memrchr(b'a', b\"aaaa\"));\n+}\n+\n+#[test]\n+fn matches_end_reversed() {\n+    assert_eq!(Some(0), memrchr(b'z', b\"zaaaa\"));\n+}\n+\n+#[test]\n+fn matches_nul_reversed() {\n+    assert_eq!(Some(4), memrchr(b'\\x00', b\"aaaa\\x00\"));\n+}\n+\n+#[test]\n+fn matches_past_nul_reversed() {\n+    assert_eq!(Some(0), memrchr(b'z', b\"z\\x00aaaa\"));\n+}\n+\n+#[test]\n+fn no_match_empty_reversed() {\n+    assert_eq!(None, memrchr(b'a', b\"\"));\n+}\n+\n+#[test]\n+fn no_match_reversed() {\n+    assert_eq!(None, memrchr(b'a', b\"xyz\"));\n+}\n+\n+#[test]\n+fn each_alignment_reversed() {\n+    let mut data = [1u8; 64];\n+    let needle = 2;\n+    let pos = 40;\n+    data[pos] = needle;\n+    for start in 0..16 {\n+        assert_eq!(Some(pos - start), memrchr(needle, &data[start..]));\n+    }\n+}"}, {"sha": "20d586a40217055e1159a4bbe847ef6d2aaaddde", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 30, "deletions": 1, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/8c5941896248802d57e73a1fc9adbca5869f1fa1/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c5941896248802d57e73a1fc9adbca5869f1fa1/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=8c5941896248802d57e73a1fc9adbca5869f1fa1", "patch": "@@ -50,6 +50,11 @@ use mem;\n use marker::{Copy, Send, Sync, Sized, self};\n use iter_private::TrustedRandomAccess;\n \n+#[unstable(feature = \"slice_internals\", issue = \"0\",\n+           reason = \"exposed from core to be reused in std; use the memchr crate\")]\n+/// Pure rust memchr implementation, taken from rust-memchr\n+pub mod memchr;\n+\n mod rotate;\n mod sort;\n \n@@ -619,7 +624,7 @@ impl<T> SliceExt for [T] {\n \n     #[inline]\n     fn contains(&self, x: &T) -> bool where T: PartialEq {\n-        self.iter().any(|elt| *x == *elt)\n+        x.slice_contains(self)\n     }\n \n     #[inline]\n@@ -2614,3 +2619,27 @@ unsafe impl<'a, T> TrustedRandomAccess for IterMut<'a, T> {\n     }\n     fn may_have_side_effect() -> bool { false }\n }\n+\n+trait SliceContains: Sized {\n+    fn slice_contains(&self, x: &[Self]) -> bool;\n+}\n+\n+impl<T> SliceContains for T where T: PartialEq {\n+    default fn slice_contains(&self, x: &[Self]) -> bool {\n+        x.iter().any(|y| *y == *self)\n+    }\n+}\n+\n+impl SliceContains for u8 {\n+    fn slice_contains(&self, x: &[Self]) -> bool {\n+        memchr::memchr(*self, x).is_some()\n+    }\n+}\n+\n+impl SliceContains for i8 {\n+    fn slice_contains(&self, x: &[Self]) -> bool {\n+        let byte = *self as u8;\n+        let bytes: &[u8] = unsafe { from_raw_parts(x.as_ptr() as *const u8, x.len()) };\n+        memchr::memchr(byte, bytes).is_some()\n+    }\n+}"}, {"sha": "29ea87aaf786ac168b05397f8382b6d028113d03", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8c5941896248802d57e73a1fc9adbca5869f1fa1/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c5941896248802d57e73a1fc9adbca5869f1fa1/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=8c5941896248802d57e73a1fc9adbca5869f1fa1", "patch": "@@ -302,6 +302,7 @@\n #![feature(sip_hash_13)]\n #![feature(slice_bytes)]\n #![feature(slice_concat_ext)]\n+#![feature(slice_internals)]\n #![feature(slice_patterns)]\n #![feature(staged_api)]\n #![feature(stmt_expr_attributes)]"}, {"sha": "873b33535025bef22f6196761b1129737e75fe3c", "filename": "src/libstd/sys/redox/memchr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c5941896248802d57e73a1fc9adbca5869f1fa1/src%2Flibstd%2Fsys%2Fredox%2Fmemchr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c5941896248802d57e73a1fc9adbca5869f1fa1/src%2Flibstd%2Fsys%2Fredox%2Fmemchr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fmemchr.rs?ref=8c5941896248802d57e73a1fc9adbca5869f1fa1", "patch": "@@ -11,4 +11,4 @@\n // Original implementation taken from rust-memchr\n // Copyright 2015 Andrew Gallant, bluss and Nicolas Koch\n \n-pub use sys_common::memchr::fallback::{memchr, memrchr};\n+pub use core::slice::memchr::{memchr, memrchr};"}, {"sha": "f49adc24163ca4c75bd6568468155fe0a355aa6b", "filename": "src/libstd/sys/unix/memchr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c5941896248802d57e73a1fc9adbca5869f1fa1/src%2Flibstd%2Fsys%2Funix%2Fmemchr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c5941896248802d57e73a1fc9adbca5869f1fa1/src%2Flibstd%2Fsys%2Funix%2Fmemchr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fmemchr.rs?ref=8c5941896248802d57e73a1fc9adbca5869f1fa1", "patch": "@@ -50,7 +50,7 @@ pub fn memrchr(needle: u8, haystack: &[u8]) -> Option<usize> {\n \n     #[cfg(not(target_os = \"linux\"))]\n     fn memrchr_specific(needle: u8, haystack: &[u8]) -> Option<usize> {\n-        ::sys_common::memchr::fallback::memrchr(needle, haystack)\n+        ::core::slice::memchr::memrchr(needle, haystack)\n     }\n \n     memrchr_specific(needle, haystack)"}, {"sha": "964e35994139bfe6354b72a3922b1433743b3c1a", "filename": "src/libstd/sys/wasm/memchr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c5941896248802d57e73a1fc9adbca5869f1fa1/src%2Flibstd%2Fsys%2Fwasm%2Fmemchr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c5941896248802d57e73a1fc9adbca5869f1fa1/src%2Flibstd%2Fsys%2Fwasm%2Fmemchr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasm%2Fmemchr.rs?ref=8c5941896248802d57e73a1fc9adbca5869f1fa1", "patch": "@@ -8,4 +8,4 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-pub use sys_common::memchr::fallback::{memchr, memrchr};\n+pub use core::slice::memchr::{memchr, memrchr};"}, {"sha": "fa7c816fd02eadc3b8fd0d1613d3fc8cca59f186", "filename": "src/libstd/sys/windows/memchr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c5941896248802d57e73a1fc9adbca5869f1fa1/src%2Flibstd%2Fsys%2Fwindows%2Fmemchr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c5941896248802d57e73a1fc9adbca5869f1fa1/src%2Flibstd%2Fsys%2Fwindows%2Fmemchr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fmemchr.rs?ref=8c5941896248802d57e73a1fc9adbca5869f1fa1", "patch": "@@ -12,4 +12,4 @@\n // Copyright 2015 Andrew Gallant, bluss and Nicolas Koch\n \n // Fallback memchr is fastest on windows\n-pub use sys_common::memchr::fallback::{memchr, memrchr};\n+pub use core::slice::memchr::{memchr, memrchr};"}, {"sha": "50f998eb4867dc087476835f2feef4bd25f6056e", "filename": "src/libstd/sys_common/memchr.rs", "status": "removed", "additions": 0, "deletions": 227, "changes": 227, "blob_url": "https://github.com/rust-lang/rust/blob/885011ef1fd8fbe8c5be50a0713c03c980772be3/src%2Flibstd%2Fsys_common%2Fmemchr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/885011ef1fd8fbe8c5be50a0713c03c980772be3/src%2Flibstd%2Fsys_common%2Fmemchr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fmemchr.rs?ref=885011ef1fd8fbe8c5be50a0713c03c980772be3", "patch": "@@ -1,227 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-//\n-// Original implementation taken from rust-memchr\n-// Copyright 2015 Andrew Gallant, bluss and Nicolas Koch\n-\n-#[allow(dead_code)]\n-pub mod fallback {\n-    use cmp;\n-    use mem;\n-\n-    const LO_U64: u64 = 0x0101010101010101;\n-    const HI_U64: u64 = 0x8080808080808080;\n-\n-    // use truncation\n-    const LO_USIZE: usize = LO_U64 as usize;\n-    const HI_USIZE: usize = HI_U64 as usize;\n-\n-    /// Return `true` if `x` contains any zero byte.\n-    ///\n-    /// From *Matters Computational*, J. Arndt\n-    ///\n-    /// \"The idea is to subtract one from each of the bytes and then look for\n-    /// bytes where the borrow propagated all the way to the most significant\n-    /// bit.\"\n-    #[inline]\n-    fn contains_zero_byte(x: usize) -> bool {\n-        x.wrapping_sub(LO_USIZE) & !x & HI_USIZE != 0\n-    }\n-\n-    #[cfg(target_pointer_width = \"32\")]\n-    #[inline]\n-    fn repeat_byte(b: u8) -> usize {\n-        let mut rep = (b as usize) << 8 | b as usize;\n-        rep = rep << 16 | rep;\n-        rep\n-    }\n-\n-    #[cfg(target_pointer_width = \"64\")]\n-    #[inline]\n-    fn repeat_byte(b: u8) -> usize {\n-        let mut rep = (b as usize) << 8 | b as usize;\n-        rep = rep << 16 | rep;\n-        rep = rep << 32 | rep;\n-        rep\n-    }\n-\n-    /// Return the first index matching the byte `a` in `text`.\n-    pub fn memchr(x: u8, text: &[u8]) -> Option<usize> {\n-        // Scan for a single byte value by reading two `usize` words at a time.\n-        //\n-        // Split `text` in three parts\n-        // - unaligned initial part, before the first word aligned address in text\n-        // - body, scan by 2 words at a time\n-        // - the last remaining part, < 2 word size\n-        let len = text.len();\n-        let ptr = text.as_ptr();\n-        let usize_bytes = mem::size_of::<usize>();\n-\n-        // search up to an aligned boundary\n-        let mut offset = ptr.align_offset(usize_bytes);\n-        if offset > 0 {\n-            offset = cmp::min(offset, len);\n-            if let Some(index) = text[..offset].iter().position(|elt| *elt == x) {\n-                return Some(index);\n-            }\n-        }\n-\n-        // search the body of the text\n-        let repeated_x = repeat_byte(x);\n-\n-        if len >= 2 * usize_bytes {\n-            while offset <= len - 2 * usize_bytes {\n-                unsafe {\n-                    let u = *(ptr.offset(offset as isize) as *const usize);\n-                    let v = *(ptr.offset((offset + usize_bytes) as isize) as *const usize);\n-\n-                    // break if there is a matching byte\n-                    let zu = contains_zero_byte(u ^ repeated_x);\n-                    let zv = contains_zero_byte(v ^ repeated_x);\n-                    if zu || zv {\n-                        break;\n-                    }\n-                }\n-                offset += usize_bytes * 2;\n-            }\n-        }\n-\n-        // find the byte after the point the body loop stopped\n-        text[offset..].iter().position(|elt| *elt == x).map(|i| offset + i)\n-    }\n-\n-    /// Return the last index matching the byte `a` in `text`.\n-    pub fn memrchr(x: u8, text: &[u8]) -> Option<usize> {\n-        // Scan for a single byte value by reading two `usize` words at a time.\n-        //\n-        // Split `text` in three parts\n-        // - unaligned tail, after the last word aligned address in text\n-        // - body, scan by 2 words at a time\n-        // - the first remaining bytes, < 2 word size\n-        let len = text.len();\n-        let ptr = text.as_ptr();\n-        let usize_bytes = mem::size_of::<usize>();\n-\n-        // search to an aligned boundary\n-        let end_align = (ptr as usize + len) & (usize_bytes - 1);\n-        let mut offset;\n-        if end_align > 0 {\n-            offset = if end_align >= len { 0 } else { len - end_align };\n-            if let Some(index) = text[offset..].iter().rposition(|elt| *elt == x) {\n-                return Some(offset + index);\n-            }\n-        } else {\n-            offset = len;\n-        }\n-\n-        // search the body of the text\n-        let repeated_x = repeat_byte(x);\n-\n-        while offset >= 2 * usize_bytes {\n-            unsafe {\n-                let u = *(ptr.offset(offset as isize - 2 * usize_bytes as isize) as *const usize);\n-                let v = *(ptr.offset(offset as isize - usize_bytes as isize) as *const usize);\n-\n-                // break if there is a matching byte\n-                let zu = contains_zero_byte(u ^ repeated_x);\n-                let zv = contains_zero_byte(v ^ repeated_x);\n-                if zu || zv {\n-                    break;\n-                }\n-            }\n-            offset -= 2 * usize_bytes;\n-        }\n-\n-        // find the byte before the point the body loop stopped\n-        text[..offset].iter().rposition(|elt| *elt == x)\n-    }\n-\n-    // test fallback implementations on all platforms\n-    #[test]\n-    fn matches_one() {\n-        assert_eq!(Some(0), memchr(b'a', b\"a\"));\n-    }\n-\n-    #[test]\n-    fn matches_begin() {\n-        assert_eq!(Some(0), memchr(b'a', b\"aaaa\"));\n-    }\n-\n-    #[test]\n-    fn matches_end() {\n-        assert_eq!(Some(4), memchr(b'z', b\"aaaaz\"));\n-    }\n-\n-    #[test]\n-    fn matches_nul() {\n-        assert_eq!(Some(4), memchr(b'\\x00', b\"aaaa\\x00\"));\n-    }\n-\n-    #[test]\n-    fn matches_past_nul() {\n-        assert_eq!(Some(5), memchr(b'z', b\"aaaa\\x00z\"));\n-    }\n-\n-    #[test]\n-    fn no_match_empty() {\n-        assert_eq!(None, memchr(b'a', b\"\"));\n-    }\n-\n-    #[test]\n-    fn no_match() {\n-        assert_eq!(None, memchr(b'a', b\"xyz\"));\n-    }\n-\n-    #[test]\n-    fn matches_one_reversed() {\n-        assert_eq!(Some(0), memrchr(b'a', b\"a\"));\n-    }\n-\n-    #[test]\n-    fn matches_begin_reversed() {\n-        assert_eq!(Some(3), memrchr(b'a', b\"aaaa\"));\n-    }\n-\n-    #[test]\n-    fn matches_end_reversed() {\n-        assert_eq!(Some(0), memrchr(b'z', b\"zaaaa\"));\n-    }\n-\n-    #[test]\n-    fn matches_nul_reversed() {\n-        assert_eq!(Some(4), memrchr(b'\\x00', b\"aaaa\\x00\"));\n-    }\n-\n-    #[test]\n-    fn matches_past_nul_reversed() {\n-        assert_eq!(Some(0), memrchr(b'z', b\"z\\x00aaaa\"));\n-    }\n-\n-    #[test]\n-    fn no_match_empty_reversed() {\n-        assert_eq!(None, memrchr(b'a', b\"\"));\n-    }\n-\n-    #[test]\n-    fn no_match_reversed() {\n-        assert_eq!(None, memrchr(b'a', b\"xyz\"));\n-    }\n-\n-    #[test]\n-    fn each_alignment_reversed() {\n-        let mut data = [1u8; 64];\n-        let needle = 2;\n-        let pos = 40;\n-        data[pos] = needle;\n-        for start in 0..16 {\n-            assert_eq!(Some(pos - start), memrchr(needle, &data[start..]));\n-        }\n-    }\n-}"}, {"sha": "938e8656808068b7dd6e9b7e9857769acd05fa4e", "filename": "src/libstd/sys_common/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8c5941896248802d57e73a1fc9adbca5869f1fa1/src%2Flibstd%2Fsys_common%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c5941896248802d57e73a1fc9adbca5869f1fa1/src%2Flibstd%2Fsys_common%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fmod.rs?ref=8c5941896248802d57e73a1fc9adbca5869f1fa1", "patch": "@@ -33,7 +33,6 @@ pub mod at_exit_imp;\n pub mod backtrace;\n pub mod condvar;\n pub mod io;\n-pub mod memchr;\n pub mod mutex;\n pub mod poison;\n pub mod remutex;"}]}