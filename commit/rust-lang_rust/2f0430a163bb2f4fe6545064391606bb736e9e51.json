{"sha": "2f0430a163bb2f4fe6545064391606bb736e9e51", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJmMDQzMGExNjNiYjJmNGZlNjU0NTA2NDM5MTYwNmJiNzM2ZTllNTE=", "commit": {"author": {"name": "jumbatm", "email": "jumbatm@gmail.com", "date": "2020-02-02T09:41:14Z"}, "committer": {"name": "jumbatm", "email": "jumbatm@gmail.com", "date": "2020-02-11T09:49:01Z"}, "message": "Make cx.span_lint methods lazy\n\n- Make report_unsafe take decorate function\n- Remove span_lint, replacing calls with struct_span_lint, as caller is\nnow responsible for emitting.\n- Remove lookup_and_emit, replacing with just lookup which takes a\ndecorate function.\n- Remove span_lint_note, span_lint_help.  These methods aren't easily\nmade lazy as standalone methods, private, and unused. If this\nfunctionality is needed, to be lazy, they can easily be made into\nFn(&mut DiagnosticBuilder) that are meant to be called _within_ the\ndecorate function.\n- Rename lookup_and_emit_with_diagnostics to lookup_with_diagnostics to\nbetter reflect the fact that it doesn't emit for you.", "tree": {"sha": "f31051b5d0d597131a62d983abfa00348ccb14e7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f31051b5d0d597131a62d983abfa00348ccb14e7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2f0430a163bb2f4fe6545064391606bb736e9e51", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2f0430a163bb2f4fe6545064391606bb736e9e51", "html_url": "https://github.com/rust-lang/rust/commit/2f0430a163bb2f4fe6545064391606bb736e9e51", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2f0430a163bb2f4fe6545064391606bb736e9e51/comments", "author": {"login": "jumbatm", "id": 30644300, "node_id": "MDQ6VXNlcjMwNjQ0MzAw", "avatar_url": "https://avatars.githubusercontent.com/u/30644300?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jumbatm", "html_url": "https://github.com/jumbatm", "followers_url": "https://api.github.com/users/jumbatm/followers", "following_url": "https://api.github.com/users/jumbatm/following{/other_user}", "gists_url": "https://api.github.com/users/jumbatm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jumbatm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jumbatm/subscriptions", "organizations_url": "https://api.github.com/users/jumbatm/orgs", "repos_url": "https://api.github.com/users/jumbatm/repos", "events_url": "https://api.github.com/users/jumbatm/events{/privacy}", "received_events_url": "https://api.github.com/users/jumbatm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jumbatm", "id": 30644300, "node_id": "MDQ6VXNlcjMwNjQ0MzAw", "avatar_url": "https://avatars.githubusercontent.com/u/30644300?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jumbatm", "html_url": "https://github.com/jumbatm", "followers_url": "https://api.github.com/users/jumbatm/followers", "following_url": "https://api.github.com/users/jumbatm/following{/other_user}", "gists_url": "https://api.github.com/users/jumbatm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jumbatm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jumbatm/subscriptions", "organizations_url": "https://api.github.com/users/jumbatm/orgs", "repos_url": "https://api.github.com/users/jumbatm/repos", "events_url": "https://api.github.com/users/jumbatm/events{/privacy}", "received_events_url": "https://api.github.com/users/jumbatm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b2e78faa15263011dad1e9579fc59610d5b75579", "url": "https://api.github.com/repos/rust-lang/rust/commits/b2e78faa15263011dad1e9579fc59610d5b75579", "html_url": "https://github.com/rust-lang/rust/commit/b2e78faa15263011dad1e9579fc59610d5b75579"}], "stats": {"total": 199, "additions": 85, "deletions": 114}, "files": [{"sha": "7ebedd29cc420fa6ab45134cc0567a061ac2000d", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/2f0430a163bb2f4fe6545064391606bb736e9e51/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f0430a163bb2f4fe6545064391606bb736e9e51/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=2f0430a163bb2f4fe6545064391606bb736e9e51", "patch": "@@ -28,6 +28,7 @@ use rustc::ty::{self, layout::VariantIdx, Ty, TyCtxt};\n use rustc_ast_pretty::pprust::{self, expr_to_string};\n use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::{Applicability, DiagnosticBuilder};\n+use rustc::lint::LintDiagnosticBuilder;\n use rustc_feature::Stability;\n use rustc_feature::{deprecated_attributes, AttributeGate, AttributeTemplate, AttributeType};\n use rustc_hir as hir;\n@@ -106,8 +107,7 @@ impl BoxPointers {\n     fn check_heap_type(&self, cx: &LateContext<'_, '_>, span: Span, ty: Ty<'_>) {\n         for leaf_ty in ty.walk() {\n             if leaf_ty.is_box() {\n-                let m = format!(\"type uses owned (Box type) pointers: {}\", ty);\n-                cx.span_lint(BOX_POINTERS, span, &m);\n+                cx.struct_span_lint(BOX_POINTERS, span, |lint| lint.build(&format!(\"type uses owned (Box type) pointers: {}\", ty)).emit());\n             }\n         }\n     }\n@@ -214,13 +214,13 @@ declare_lint! {\n declare_lint_pass!(UnsafeCode => [UNSAFE_CODE]);\n \n impl UnsafeCode {\n-    fn report_unsafe(&self, cx: &EarlyContext<'_>, span: Span, desc: &'static str) {\n+    fn report_unsafe(&self, cx: &EarlyContext<'_>, span: Span, decorate: impl for<'a> FnOnce(LintDiagnosticBuilder<'a>)) {\n         // This comes from a macro that has `#[allow_internal_unsafe]`.\n         if span.allows_unsafe() {\n             return;\n         }\n \n-        cx.span_lint(UNSAFE_CODE, span, desc);\n+        cx.struct_span_lint(UNSAFE_CODE, span, decorate);\n     }\n }\n \n@@ -230,9 +230,9 @@ impl EarlyLintPass for UnsafeCode {\n             self.report_unsafe(\n                 cx,\n                 attr.span,\n-                \"`allow_internal_unsafe` allows defining \\\n+                |lint| lint.build(\"`allow_internal_unsafe` allows defining \\\n                                                macros using unsafe without triggering \\\n-                                               the `unsafe_code` lint at their call site\",\n+                                               the `unsafe_code` lint at their call site\").emit(),\n             );\n         }\n     }\n@@ -241,19 +241,19 @@ impl EarlyLintPass for UnsafeCode {\n         if let ast::ExprKind::Block(ref blk, _) = e.kind {\n             // Don't warn about generated blocks; that'll just pollute the output.\n             if blk.rules == ast::BlockCheckMode::Unsafe(ast::UserProvided) {\n-                self.report_unsafe(cx, blk.span, \"usage of an `unsafe` block\");\n+                self.report_unsafe(cx, blk.span, |lint| lint.build(\"usage of an `unsafe` block\").emit());\n             }\n         }\n     }\n \n     fn check_item(&mut self, cx: &EarlyContext<'_>, it: &ast::Item) {\n         match it.kind {\n             ast::ItemKind::Trait(_, ast::Unsafety::Unsafe, ..) => {\n-                self.report_unsafe(cx, it.span, \"declaration of an `unsafe` trait\")\n+                self.report_unsafe(cx, it.span, |lint| lint.build(\"declaration of an `unsafe` trait\").emit())\n             }\n \n             ast::ItemKind::Impl { unsafety: ast::Unsafety::Unsafe, .. } => {\n-                self.report_unsafe(cx, it.span, \"implementation of an `unsafe` trait\")\n+                self.report_unsafe(cx, it.span, |lint| lint.build(\"implementation of an `unsafe` trait\").emit())\n             }\n \n             _ => return,\n@@ -275,7 +275,7 @@ impl EarlyLintPass for UnsafeCode {\n                 FnCtxt::Assoc(_) if body.is_none() => \"declaration of an `unsafe` method\",\n                 FnCtxt::Assoc(_) => \"implementation of an `unsafe` method\",\n             };\n-            self.report_unsafe(cx, span, msg);\n+            self.report_unsafe(cx, span, |lint| lint.build(msg).emit());\n         }\n     }\n }\n@@ -360,10 +360,10 @@ impl MissingDoc {\n \n         let has_doc = attrs.iter().any(|a| has_doc(a));\n         if !has_doc {\n-            cx.span_lint(\n+            cx.struct_span_lint(\n                 MISSING_DOCS,\n                 cx.tcx.sess.source_map().def_span(sp),\n-                &format!(\"missing documentation for {}\", desc),\n+                |lint| lint.build(&format!(\"missing documentation for {}\", desc)).emit(),\n             );\n         }\n     }\n@@ -392,10 +392,10 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDoc {\n         for macro_def in krate.exported_macros {\n             let has_doc = macro_def.attrs.iter().any(|a| has_doc(a));\n             if !has_doc {\n-                cx.span_lint(\n+                cx.struct_span_lint(\n                     MISSING_DOCS,\n                     cx.tcx.sess.source_map().def_span(macro_def.span),\n-                    \"missing documentation for macro\",\n+                    |lint| lint.build(\"missing documentation for macro\").emit(),\n                 );\n             }\n         }\n@@ -543,11 +543,11 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingCopyImplementations {\n             return;\n         }\n         if can_type_implement_copy(cx.tcx, param_env, ty).is_ok() {\n-            cx.span_lint(\n+            cx.struct_span_lint(\n                 MISSING_COPY_IMPLEMENTATIONS,\n                 item.span,\n-                \"type could implement `Copy`; consider adding `impl \\\n-                          Copy`\",\n+                |lint| lint.build(\"type could implement `Copy`; consider adding `impl \\\n+                          Copy`\").emit(),\n             )\n         }\n     }\n@@ -597,14 +597,14 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDebugImplementations {\n         }\n \n         if !self.impling_types.as_ref().unwrap().contains(&item.hir_id) {\n-            cx.span_lint(\n+            cx.struct_span_lint(\n                 MISSING_DEBUG_IMPLEMENTATIONS,\n                 item.span,\n-                &format!(\n+                |lint| lint.build(&format!(\n                     \"type does not implement `{}`; consider adding `#[derive(Debug)]` \\\n                      or a manual implementation\",\n                     cx.tcx.def_path_str(debug)\n-                ),\n+                )).emit(),\n             );\n         }\n     }\n@@ -903,7 +903,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MutableTransmutes {\n         match get_transmute_from_to(cx, expr).map(|(ty1, ty2)| (&ty1.kind, &ty2.kind)) {\n             Some((&ty::Ref(_, _, from_mt), &ty::Ref(_, _, to_mt))) => {\n                 if to_mt == hir::Mutability::Mut && from_mt == hir::Mutability::Not {\n-                    cx.span_lint(MUTABLE_TRANSMUTES, expr.span, msg);\n+                    cx.struct_span_lint(MUTABLE_TRANSMUTES, expr.span, |lint| lint.build(msg).emit());\n                 }\n             }\n             _ => (),\n@@ -953,7 +953,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnstableFeatures {\n         if attr.check_name(sym::feature) {\n             if let Some(items) = attr.meta_item_list() {\n                 for item in items {\n-                    ctx.span_lint(UNSTABLE_FEATURES, item.span(), \"unstable feature\");\n+                    ctx.struct_span_lint(UNSTABLE_FEATURES, item.span(), |lint| lint.build(\"unstable feature\").emit());\n                 }\n             }\n         }\n@@ -1235,14 +1235,14 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TrivialConstraints {\n                     ConstEvaluatable(..) => continue,\n                 };\n                 if predicate.is_global() {\n-                    cx.span_lint(\n+                    cx.struct_span_lint(\n                         TRIVIAL_BOUNDS,\n                         span,\n-                        &format!(\n+                        |lint| lint.build(&format!(\n                             \"{} bound {} does not depend on any type \\\n                                 or lifetime parameters\",\n                             predicate_kind_name, predicate\n-                        ),\n+                        )).emit(),\n                     );\n                 }\n             }"}, {"sha": "232b56c88f2b0b3c9700d2adf38d04534cb40d25", "filename": "src/librustc_lint/context.rs", "status": "modified", "additions": 10, "deletions": 47, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/2f0430a163bb2f4fe6545064391606bb736e9e51/src%2Flibrustc_lint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f0430a163bb2f4fe6545064391606bb736e9e51/src%2Flibrustc_lint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fcontext.rs?ref=2f0430a163bb2f4fe6545064391606bb736e9e51", "patch": "@@ -474,19 +474,18 @@ pub trait LintContext: Sized {\n     fn sess(&self) -> &Session;\n     fn lints(&self) -> &LintStore;\n \n-    fn lookup_and_emit<S: Into<MultiSpan>>(&self, lint: &'static Lint, span: Option<S>, msg: &str) {\n-        self.lookup(lint, span, |lint| lint.build(msg).emit());\n-    }\n-\n-    fn lookup_and_emit_with_diagnostics<S: Into<MultiSpan>>(\n+    fn lookup_with_diagnostics<S: Into<MultiSpan>>(\n         &self,\n         lint: &'static Lint,\n         span: Option<S>,\n-        msg: &str,\n+        decorate: impl for<'a> FnOnce(LintDiagnosticBuilder<'a>),\n         diagnostic: BuiltinLintDiagnostics,\n     ) {\n         self.lookup(lint, span, |lint| {\n-            let mut db = lint.build(msg);\n+            // We first generate a blank diagnostic.\n+            let mut db = lint.build(\"\");\n+\n+            // Now, set up surrounding context.\n             let sess = self.sess();\n             match diagnostic {\n                 BuiltinLintDiagnostics::Normal => (),\n@@ -567,8 +566,8 @@ pub trait LintContext: Sized {\n                     stability::deprecation_suggestion(&mut db, suggestion, span)\n                 }\n             }\n-\n-            db.emit();\n+            // Rewrap `db`, and pass control to the user.\n+            decorate(LintDiagnosticBuilder::new(db));\n         });\n     }\n \n@@ -579,11 +578,6 @@ pub trait LintContext: Sized {\n         decorate: impl for<'a> FnOnce(LintDiagnosticBuilder<'a>),\n     );\n \n-    /// Emit a lint at the appropriate level, for a particular span.\n-    fn span_lint<S: Into<MultiSpan>>(&self, lint: &'static Lint, span: S, msg: &str) {\n-        self.lookup_and_emit(lint, Some(span), msg);\n-    }\n-\n     fn struct_span_lint<S: Into<MultiSpan>>(\n         &self,\n         lint: &'static Lint,\n@@ -592,40 +586,9 @@ pub trait LintContext: Sized {\n     ) {\n         self.lookup(lint, Some(span), decorate);\n     }\n-\n-    /// Emit a lint and note at the appropriate level, for a particular span.\n-    fn span_lint_note(\n-        &self,\n-        lint: &'static Lint,\n-        span: Span,\n-        msg: &str,\n-        note_span: Span,\n-        note: &str,\n-    ) {\n-        self.lookup(lint, Some(span), |lint| {\n-            let mut err = lint.build(msg);\n-            if note_span == span {\n-                err.note(note);\n-            } else {\n-                err.span_note(note_span, note);\n-            }\n-            err.emit();\n-        });\n-    }\n-\n-    /// Emit a lint and help at the appropriate level, for a particular span.\n-    fn span_lint_help(&self, lint: &'static Lint, span: Span, msg: &str, help: &str) {\n-        self.lookup(lint, Some(span), |err| {\n-            let mut err = err.build(msg);\n-            self.span_lint(lint, span, msg);\n-            err.span_help(span, help);\n-            err.emit();\n-        });\n-    }\n-\n     /// Emit a lint at the appropriate level, with no associated span.\n-    fn lint(&self, lint: &'static Lint, msg: &str) {\n-        self.lookup_and_emit(lint, None as Option<Span>, msg);\n+    fn lint(&self, lint: &'static Lint, decorate: impl for<'a> FnOnce(LintDiagnosticBuilder<'a>)) {\n+        self.lookup(lint, None as Option<Span>, decorate);\n     }\n }\n "}, {"sha": "4f337cd18aaa0b6651f19a2f4abb305bdda005d5", "filename": "src/librustc_lint/early.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2f0430a163bb2f4fe6545064391606bb736e9e51/src%2Flibrustc_lint%2Fearly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f0430a163bb2f4fe6545064391606bb736e9e51/src%2Flibrustc_lint%2Fearly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fearly.rs?ref=2f0430a163bb2f4fe6545064391606bb736e9e51", "patch": "@@ -37,11 +37,12 @@ struct EarlyContextAndPass<'a, T: EarlyLintPass> {\n impl<'a, T: EarlyLintPass> EarlyContextAndPass<'a, T> {\n     fn check_id(&mut self, id: ast::NodeId) {\n         for early_lint in self.context.buffered.take(id) {\n-            self.context.lookup_and_emit_with_diagnostics(\n+            let rustc_session::lint::BufferedEarlyLint { span, msg, node_id: _, lint_id: _, diagnostic } = early_lint;\n+            self.context.lookup_with_diagnostics(\n                 early_lint.lint_id.lint,\n-                Some(early_lint.span.clone()),\n-                &early_lint.msg,\n-                early_lint.diagnostic,\n+                Some(span),\n+                |lint| lint.build(&msg).emit(),\n+                diagnostic,\n             );\n         }\n     }"}, {"sha": "f6404fb63d4090dca23dbb3952f62900862562e3", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/2f0430a163bb2f4fe6545064391606bb736e9e51/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f0430a163bb2f4fe6545064391606bb736e9e51/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=2f0430a163bb2f4fe6545064391606bb736e9e51", "patch": "@@ -266,10 +266,10 @@ fn lint_int_literal<'a, 'tcx>(\n             }\n         }\n \n-        cx.span_lint(\n+        cx.struct_span_lint(\n             OVERFLOWING_LITERALS,\n             e.span,\n-            &format!(\"literal out of range for `{}`\", t.name_str()),\n+            |lint| lint.build(&format!(\"literal out of range for `{}`\", t.name_str())).emit(),\n         );\n     }\n }\n@@ -321,10 +321,10 @@ fn lint_uint_literal<'a, 'tcx>(\n             report_bin_hex_error(cx, e, attr::IntType::UnsignedInt(t), repr_str, lit_val, false);\n             return;\n         }\n-        cx.span_lint(\n+        cx.struct_span_lint(\n             OVERFLOWING_LITERALS,\n             e.span,\n-            &format!(\"literal out of range for `{}`\", t.name_str()),\n+            |lint| lint.build(&format!(\"literal out of range for `{}`\", t.name_str())).emit(),\n         );\n     }\n }\n@@ -355,10 +355,10 @@ fn lint_literal<'a, 'tcx>(\n                 _ => bug!(),\n             };\n             if is_infinite == Ok(true) {\n-                cx.span_lint(\n+                cx.struct_span_lint(\n                     OVERFLOWING_LITERALS,\n                     e.span,\n-                    &format!(\"literal out of range for `{}`\", t.name_str()),\n+                    |lint| lint.build(&format!(\"literal out of range for `{}`\", t.name_str())).emit(),\n                 );\n             }\n         }\n@@ -377,10 +377,10 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n             }\n             hir::ExprKind::Binary(binop, ref l, ref r) => {\n                 if is_comparison(binop) && !check_limits(cx, binop, &l, &r) {\n-                    cx.span_lint(\n+                    cx.struct_span_lint(\n                         UNUSED_COMPARISONS,\n                         e.span,\n-                        \"comparison is useless due to type limits\",\n+                        |lint| lint.build(\"comparison is useless due to type limits\").emit(),\n                     );\n                 }\n             }\n@@ -1055,14 +1055,14 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for VariantSizeDifferences {\n             // We only warn if the largest variant is at least thrice as large as\n             // the second-largest.\n             if largest > slargest * 3 && slargest > 0 {\n-                cx.span_lint(\n+                cx.struct_span_lint(\n                     VARIANT_SIZE_DIFFERENCES,\n                     enum_definition.variants[largest_index].span,\n-                    &format!(\n+                    |lint| lint.build(&format!(\n                         \"enum variant is more than three times \\\n                                           larger ({} bytes) than the next largest\",\n                         largest\n-                    ),\n+                    )).emit(),\n                 );\n             }\n         }"}, {"sha": "faa0b019311eb9546b270f09ec6633c5288c955f", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 29, "deletions": 24, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/2f0430a163bb2f4fe6545064391606bb736e9e51/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f0430a163bb2f4fe6545064391606bb736e9e51/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=2f0430a163bb2f4fe6545064391606bb736e9e51", "patch": "@@ -104,16 +104,16 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedResults {\n         };\n \n         if let Some(must_use_op) = must_use_op {\n-            cx.span_lint(\n+            cx.struct_span_lint(\n                 UNUSED_MUST_USE,\n                 expr.span,\n-                &format!(\"unused {} that must be used\", must_use_op),\n+                |lint| lint.build(&format!(\"unused {} that must be used\", must_use_op)).emit(),\n             );\n             op_warned = true;\n         }\n \n         if !(type_permits_lack_of_use || fn_warned || op_warned) {\n-            cx.span_lint(UNUSED_RESULTS, s.span, \"unused result\");\n+            cx.struct_span_lint(UNUSED_RESULTS, s.span, |lint| lint.build(\"unused result\").emit());\n         }\n \n         // Returns whether an error has been emitted (and thus another does not need to be later).\n@@ -247,7 +247,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for PathStatements {\n     fn check_stmt(&mut self, cx: &LateContext<'_, '_>, s: &hir::Stmt<'_>) {\n         if let hir::StmtKind::Semi(ref expr) = s.kind {\n             if let hir::ExprKind::Path(_) = expr.kind {\n-                cx.span_lint(PATH_STATEMENTS, s.span, \"path statement with no effect\");\n+                cx.struct_span_lint(PATH_STATEMENTS, s.span, |lint| lint.build(\"path statement with no effect\").emit());\n             }\n         }\n     }\n@@ -288,17 +288,19 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedAttributes {\n \n         if !attr::is_used(attr) {\n             debug!(\"emitting warning for: {:?}\", attr);\n-            cx.span_lint(UNUSED_ATTRIBUTES, attr.span, \"unused attribute\");\n+            cx.struct_span_lint(UNUSED_ATTRIBUTES, attr.span, |lint| lint.build(\"unused attribute\").emit());\n             // Is it a builtin attribute that must be used at the crate level?\n             if attr_info.map_or(false, |(_, ty, ..)| ty == &AttributeType::CrateLevel) {\n-                let msg = match attr.style {\n-                    ast::AttrStyle::Outer => {\n-                        \"crate-level attribute should be an inner attribute: add an exclamation \\\n-                         mark: `#![foo]`\"\n-                    }\n-                    ast::AttrStyle::Inner => \"crate-level attribute should be in the root module\",\n-                };\n-                cx.span_lint(UNUSED_ATTRIBUTES, attr.span, msg);\n+                cx.struct_span_lint(UNUSED_ATTRIBUTES, attr.span, |lint| {\n+                    let msg = match attr.style {\n+                        ast::AttrStyle::Outer => {\n+                            \"crate-level attribute should be an inner attribute: add an exclamation \\\n+                             mark: `#![foo]`\"\n+                        }\n+                        ast::AttrStyle::Inner => \"crate-level attribute should be in the root module\",\n+                    };\n+                    lint.build(msg).emit()\n+                });\n             }\n         } else {\n             debug!(\"Attr was used: {:?}\", attr);\n@@ -635,8 +637,9 @@ impl UnusedImportBraces {\n                 ast::UseTreeKind::Nested(_) => return,\n             };\n \n-            let msg = format!(\"braces around {} is unnecessary\", node_name);\n-            cx.span_lint(UNUSED_IMPORT_BRACES, item.span, &msg);\n+            cx.struct_span_lint(UNUSED_IMPORT_BRACES, item.span, |lint|\n+            lint.build(&format!(\"braces around {} is unnecessary\", node_name)).emit()\n+            );\n         }\n     }\n }\n@@ -666,15 +669,17 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedAllocation {\n \n         for adj in cx.tables.expr_adjustments(e) {\n             if let adjustment::Adjust::Borrow(adjustment::AutoBorrow::Ref(_, m)) = adj.kind {\n-                let msg = match m {\n-                    adjustment::AutoBorrowMutability::Not => {\n-                        \"unnecessary allocation, use `&` instead\"\n-                    }\n-                    adjustment::AutoBorrowMutability::Mut { .. } => {\n-                        \"unnecessary allocation, use `&mut` instead\"\n-                    }\n-                };\n-                cx.span_lint(UNUSED_ALLOCATION, e.span, msg);\n+                cx.struct_span_lint(UNUSED_ALLOCATION, e.span, |lint| {\n+                    let msg = match m {\n+                        adjustment::AutoBorrowMutability::Not => {\n+                            \"unnecessary allocation, use `&` instead\"\n+                        }\n+                        adjustment::AutoBorrowMutability::Mut { .. } => {\n+                            \"unnecessary allocation, use `&mut` instead\"\n+                        }\n+                    };\n+                    lint.build(msg).emit()\n+                });\n             }\n         }\n     }"}, {"sha": "b661006d1ddd08e0b27624dcbf32f4a89a671ebe", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2f0430a163bb2f4fe6545064391606bb736e9e51/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f0430a163bb2f4fe6545064391606bb736e9e51/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=2f0430a163bb2f4fe6545064391606bb736e9e51", "patch": "@@ -2959,10 +2959,12 @@ fn codegen_fn_attrs(tcx: TyCtxt<'_>, id: DefId) -> CodegenFnAttrs {\n                     lint::builtin::INLINE_NO_SANITIZE,\n                     hir_id,\n                     no_sanitize_span,\n-                    \"`no_sanitize` will have no effect after inlining\",\n+                    |lint| {\n+                        lint.build(\"`no_sanitize` will have no effect after inlining\")\n+                            .span_note(inline_span, \"inlining requested here\")\n+                            .emit();\n+                    },\n                 )\n-                .span_note(inline_span, \"inlining requested here\")\n-                .emit();\n             }\n         }\n     }"}]}