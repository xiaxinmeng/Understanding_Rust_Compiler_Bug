{"sha": "b5aa3b389e93d77cb769bf417555489e999c401e", "node_id": "C_kwDOAAsO6NoAKGI1YWEzYjM4OWU5M2Q3N2NiNzY5YmY0MTc1NTU0ODllOTk5YzQwMWU", "commit": {"author": {"name": "harpsword", "email": "harpswordyyl@gmail.com", "date": "2022-05-01T09:08:09Z"}, "committer": {"name": "harpsword", "email": "harpswordyyl@gmail.com", "date": "2022-07-18T00:36:10Z"}, "message": "fix: \u201cGenerate constant\u201d ignores the path prefix of the identifier", "tree": {"sha": "6aaeeaf45c2d7f6f9786981f110a49c37ff35b9a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6aaeeaf45c2d7f6f9786981f110a49c37ff35b9a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b5aa3b389e93d77cb769bf417555489e999c401e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b5aa3b389e93d77cb769bf417555489e999c401e", "html_url": "https://github.com/rust-lang/rust/commit/b5aa3b389e93d77cb769bf417555489e999c401e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b5aa3b389e93d77cb769bf417555489e999c401e/comments", "author": {"login": "harpsword", "id": 10148927, "node_id": "MDQ6VXNlcjEwMTQ4OTI3", "avatar_url": "https://avatars.githubusercontent.com/u/10148927?v=4", "gravatar_id": "", "url": "https://api.github.com/users/harpsword", "html_url": "https://github.com/harpsword", "followers_url": "https://api.github.com/users/harpsword/followers", "following_url": "https://api.github.com/users/harpsword/following{/other_user}", "gists_url": "https://api.github.com/users/harpsword/gists{/gist_id}", "starred_url": "https://api.github.com/users/harpsword/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/harpsword/subscriptions", "organizations_url": "https://api.github.com/users/harpsword/orgs", "repos_url": "https://api.github.com/users/harpsword/repos", "events_url": "https://api.github.com/users/harpsword/events{/privacy}", "received_events_url": "https://api.github.com/users/harpsword/received_events", "type": "User", "site_admin": false}, "committer": {"login": "harpsword", "id": 10148927, "node_id": "MDQ6VXNlcjEwMTQ4OTI3", "avatar_url": "https://avatars.githubusercontent.com/u/10148927?v=4", "gravatar_id": "", "url": "https://api.github.com/users/harpsword", "html_url": "https://github.com/harpsword", "followers_url": "https://api.github.com/users/harpsword/followers", "following_url": "https://api.github.com/users/harpsword/following{/other_user}", "gists_url": "https://api.github.com/users/harpsword/gists{/gist_id}", "starred_url": "https://api.github.com/users/harpsword/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/harpsword/subscriptions", "organizations_url": "https://api.github.com/users/harpsword/orgs", "repos_url": "https://api.github.com/users/harpsword/repos", "events_url": "https://api.github.com/users/harpsword/events{/privacy}", "received_events_url": "https://api.github.com/users/harpsword/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "897a7ec4b826f85ec1626870e734490701138097", "url": "https://api.github.com/repos/rust-lang/rust/commits/897a7ec4b826f85ec1626870e734490701138097", "html_url": "https://github.com/rust-lang/rust/commit/897a7ec4b826f85ec1626870e734490701138097"}], "stats": {"total": 166, "additions": 151, "deletions": 15}, "files": [{"sha": "8932a91ebe6601f8917aa384a32a617f0d3d3146", "filename": "crates/ide-assists/src/handlers/generate_constant.rs", "status": "modified", "additions": 151, "deletions": 15, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/b5aa3b389e93d77cb769bf417555489e999c401e/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_constant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5aa3b389e93d77cb769bf417555489e999c401e/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_constant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_constant.rs?ref=b5aa3b389e93d77cb769bf417555489e999c401e", "patch": "@@ -1,12 +1,13 @@\n use crate::assist_context::{AssistContext, Assists};\n-use hir::HirDisplay;\n+use hir::{HasVisibility, HirDisplay, Module};\n use ide_db::{\n     assists::{AssistId, AssistKind},\n-    defs::NameRefClass,\n+    base_db::{FileId, Upcast},\n+    defs::{Definition, NameRefClass},\n };\n use syntax::{\n-    ast::{self, edit::IndentLevel},\n-    AstNode,\n+    ast::{self, edit::IndentLevel, NameRef},\n+    AstNode, Direction, SyntaxKind, TextSize,\n };\n \n // Assist: generate_constant\n@@ -32,13 +33,6 @@ use syntax::{\n \n pub(crate) fn generate_constant(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let constant_token = ctx.find_node_at_offset::<ast::NameRef>()?;\n-    let expr = constant_token.syntax().ancestors().find_map(ast::Expr::cast)?;\n-    let statement = expr.syntax().ancestors().find_map(ast::Stmt::cast)?;\n-    let ty = ctx.sema.type_of_expr(&expr)?;\n-    let scope = ctx.sema.scope(statement.syntax())?;\n-    let module = scope.module();\n-    let type_name = ty.original().display_source_code(ctx.db(), module.into()).ok()?;\n-    let indent = IndentLevel::from_node(statement.syntax());\n     if constant_token.to_string().chars().any(|it| !(it.is_uppercase() || it == '_')) {\n         cov_mark::hit!(not_constant_name);\n         return None;\n@@ -47,20 +41,106 @@ pub(crate) fn generate_constant(acc: &mut Assists, ctx: &AssistContext) -> Optio\n         cov_mark::hit!(already_defined);\n         return None;\n     }\n+    let expr = constant_token.syntax().ancestors().find_map(ast::Expr::cast)?;\n+    let statement = expr.syntax().ancestors().find_map(ast::Stmt::cast)?;\n+    let ty = ctx.sema.type_of_expr(&expr)?;\n+    let scope = ctx.sema.scope(statement.syntax())?;\n+    let constant_module = scope.module();\n+    let type_name = ty.original().display_source_code(ctx.db(), constant_module.into()).ok()?;\n     let target = statement.syntax().parent()?.text_range();\n+    let path = constant_token.syntax().ancestors().find_map(ast::Path::cast)?;\n+\n+    let name_refs = path.segments().map(|s| s.name_ref());\n+    let mut outer_exists = false;\n+    let mut not_exist_name_ref = Vec::new();\n+    let mut current_module = constant_module;\n+    for name_ref in name_refs {\n+        let name_ref_value = name_ref?;\n+        let name_ref_class = NameRefClass::classify(&ctx.sema, &name_ref_value);\n+        match name_ref_class {\n+            Some(NameRefClass::Definition(Definition::Module(m))) => {\n+                if !m.visibility(ctx.sema.db).is_visible_from(ctx.sema.db, constant_module.into()) {\n+                    return None;\n+                }\n+                outer_exists = true;\n+                current_module = m;\n+            }\n+            Some(_) => {\n+                return None;\n+            }\n+            None => {\n+                not_exist_name_ref.push(name_ref_value);\n+            }\n+        }\n+    }\n+    let (offset, indent, file_id, post_string) =\n+        target_data_for_generate_constant(ctx, current_module, constant_module).unwrap_or_else(\n+            || {\n+                let indent = IndentLevel::from_node(statement.syntax());\n+                (statement.syntax().text_range().start(), indent, None, format!(\"\\n{}\", indent))\n+            },\n+        );\n+\n+    let text = get_text_for_generate_constant(not_exist_name_ref, indent, outer_exists, type_name)?;\n     acc.add(\n         AssistId(\"generate_constant\", AssistKind::QuickFix),\n         \"Generate constant\",\n         target,\n         |builder| {\n-            builder.insert(\n-                statement.syntax().text_range().start(),\n-                format!(\"const {}: {} = $0;\\n{}\", constant_token, type_name, indent),\n-            );\n+            if let Some(file_id) = file_id {\n+                builder.edit_file(file_id);\n+            }\n+            builder.insert(offset, format!(\"{}{}\", text, post_string));\n         },\n     )\n }\n \n+fn get_text_for_generate_constant(\n+    mut not_exist_name_ref: Vec<NameRef>,\n+    indent: IndentLevel,\n+    outer_exists: bool,\n+    type_name: String,\n+) -> Option<String> {\n+    let constant_token = not_exist_name_ref.pop()?;\n+    let vis = if not_exist_name_ref.len() == 0 && !outer_exists { \"\" } else { \"\\npub \" };\n+    let mut text = format!(\"{}const {}: {} = $0;\", vis, constant_token, type_name);\n+    while let Some(name_ref) = not_exist_name_ref.pop() {\n+        let vis = if not_exist_name_ref.len() == 0 && !outer_exists { \"\" } else { \"\\npub \" };\n+        text = text.replace(\"\\n\", \"\\n    \");\n+        text = format!(\"{}mod {} {{{}\\n}}\", vis, name_ref.to_string(), text);\n+    }\n+    Some(text.replace(\"\\n\", &format!(\"\\n{}\", indent)))\n+}\n+\n+fn target_data_for_generate_constant(\n+    ctx: &AssistContext,\n+    current_module: Module,\n+    constant_module: Module,\n+) -> Option<(TextSize, IndentLevel, Option<FileId>, String)> {\n+    if current_module == constant_module {\n+        // insert in current file\n+        return None;\n+    }\n+    let in_file_source = current_module.definition_source(ctx.sema.db);\n+    let file_id = in_file_source.file_id.original_file(ctx.sema.db.upcast());\n+    match in_file_source.value {\n+        hir::ModuleSource::Module(module_node) => {\n+            let indent = IndentLevel::from_node(module_node.syntax());\n+            let l_curly_token = module_node.item_list()?.l_curly_token()?;\n+            let offset = l_curly_token.text_range().end();\n+\n+            let siblings_has_newline = l_curly_token\n+                .siblings_with_tokens(Direction::Next)\n+                .find(|it| it.kind() == SyntaxKind::WHITESPACE && it.to_string().contains(\"\\n\"))\n+                .is_some();\n+            let post_string =\n+                if siblings_has_newline { format!(\"{}\", indent) } else { format!(\"\\n{}\", indent) };\n+            Some((offset, indent + 1, Some(file_id), post_string))\n+        }\n+        _ => Some((TextSize::from(0), 0.into(), Some(file_id), \"\\n\".into())),\n+    }\n+}\n+\n #[cfg(test)]\n mod tests {\n     use super::*;\n@@ -113,6 +193,62 @@ impl S {\n }\n fn main() {\n     let v = S::new(capa$0city);\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_constant_with_path() {\n+        check_assist(\n+            generate_constant,\n+            r#\"mod foo {}\n+fn bar() -> i32 {\n+    foo::A_CON$0STANT\n+}\"#,\n+            r#\"mod foo {\n+    pub const A_CONSTANT: i32 = $0;\n+}\n+fn bar() -> i32 {\n+    foo::A_CONSTANT\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_constant_with_longer_path() {\n+        check_assist(\n+            generate_constant,\n+            r#\"mod foo {\n+    pub mod goo {}\n+}\n+fn bar() -> i32 {\n+    foo::goo::A_CON$0STANT\n+}\"#,\n+            r#\"mod foo {\n+    pub mod goo {\n+        pub const A_CONSTANT: i32 = $0;\n+    }\n+}\n+fn bar() -> i32 {\n+    foo::goo::A_CONSTANT\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_constant_with_not_exist_longer_path() {\n+        check_assist(\n+            generate_constant,\n+            r#\"fn bar() -> i32 {\n+    foo::goo::A_CON$0STANT\n+}\"#,\n+            r#\"mod foo {\n+    pub mod goo {\n+        pub const A_CONSTANT: i32 = $0;\n+    }\n+}\n+fn bar() -> i32 {\n+    foo::goo::A_CONSTANT\n }\"#,\n         );\n     }"}]}