{"sha": "0bc108a13be32d498e6aa3066a15748e2ce1febf", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBiYzEwOGExM2JlMzJkNDk4ZTZhYTMwNjZhMTU3NDhlMmNlMWZlYmY=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-03-22T16:48:11Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-03-25T14:53:52Z"}, "message": "make Size::from* methods generic in the integer type they accept", "tree": {"sha": "46d5f2697348d29e5f9ee339950c23334fb47019", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/46d5f2697348d29e5f9ee339950c23334fb47019"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0bc108a13be32d498e6aa3066a15748e2ce1febf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0bc108a13be32d498e6aa3066a15748e2ce1febf", "html_url": "https://github.com/rust-lang/rust/commit/0bc108a13be32d498e6aa3066a15748e2ce1febf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0bc108a13be32d498e6aa3066a15748e2ce1febf/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f16b4910150f841d57c92aed6fa089f387da0d92", "url": "https://api.github.com/repos/rust-lang/rust/commits/f16b4910150f841d57c92aed6fa089f387da0d92", "html_url": "https://github.com/rust-lang/rust/commit/f16b4910150f841d57c92aed6fa089f387da0d92"}], "stats": {"total": 48, "additions": 22, "deletions": 26}, "files": [{"sha": "5440aef6fe6c939b11133d3e6e51372905ffd8d2", "filename": "src/librustc/mir/interpret/allocation.rs", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0bc108a13be32d498e6aa3066a15748e2ce1febf/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bc108a13be32d498e6aa3066a15748e2ce1febf/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs?ref=0bc108a13be32d498e6aa3066a15748e2ce1febf", "patch": "@@ -92,7 +92,7 @@ impl<Tag> Allocation<Tag> {\n     /// Creates a read-only allocation initialized by the given bytes\n     pub fn from_bytes<'a>(slice: impl Into<Cow<'a, [u8]>>, align: Align) -> Self {\n         let bytes = slice.into().into_owned();\n-        let size = Size::from_bytes(u64::try_from(bytes.len()).unwrap());\n+        let size = Size::from_bytes(bytes.len());\n         Self {\n             bytes,\n             relocations: Relocations::new(),\n@@ -293,8 +293,7 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n         let offset = usize::try_from(ptr.offset.bytes()).unwrap();\n         Ok(match self.bytes[offset..].iter().position(|&c| c == 0) {\n             Some(size) => {\n-                let size_with_null =\n-                    Size::from_bytes(u64::try_from(size.checked_add(1).unwrap()).unwrap());\n+                let size_with_null = Size::from_bytes(size.checked_add(1).unwrap());\n                 // Go through `get_bytes` for checks and AllocationExtra hooks.\n                 // We read the null, so we include it in the request, but we want it removed\n                 // from the result, so we do subslicing.\n@@ -339,7 +338,7 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n         let (lower, upper) = src.size_hint();\n         let len = upper.expect(\"can only write bounded iterators\");\n         assert_eq!(lower, len, \"can only write iterators with a precise length\");\n-        let bytes = self.get_bytes_mut(cx, ptr, Size::from_bytes(u64::try_from(len).unwrap()))?;\n+        let bytes = self.get_bytes_mut(cx, ptr, Size::from_bytes(len))?;\n         // `zip` would stop when the first iterator ends; we want to definitely\n         // cover all of `bytes`.\n         for dest in bytes {\n@@ -382,11 +381,7 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n         } else {\n             match self.relocations.get(&ptr.offset) {\n                 Some(&(tag, alloc_id)) => {\n-                    let ptr = Pointer::new_with_tag(\n-                        alloc_id,\n-                        Size::from_bytes(u64::try_from(bits).unwrap()),\n-                        tag,\n-                    );\n+                    let ptr = Pointer::new_with_tag(alloc_id, Size::from_bytes(bits), tag);\n                     return Ok(ScalarMaybeUndef::Scalar(ptr.into()));\n                 }\n                 None => {}"}, {"sha": "f00952e3725eb862b22dca16bf96e97945e039d4", "filename": "src/librustc/mir/interpret/value.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0bc108a13be32d498e6aa3066a15748e2ce1febf/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bc108a13be32d498e6aa3066a15748e2ce1febf/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs?ref=0bc108a13be32d498e6aa3066a15748e2ce1febf", "patch": "@@ -686,8 +686,8 @@ pub fn get_slice_bytes<'tcx>(cx: &impl HasDataLayout, val: ConstValue<'tcx>) ->\n         data.get_bytes(\n             cx,\n             // invent a pointer, only the offset is relevant anyway\n-            Pointer::new(AllocId(0), Size::from_bytes(u64::try_from(start).unwrap())),\n-            Size::from_bytes(u64::try_from(len).unwrap()),\n+            Pointer::new(AllocId(0), Size::from_bytes(start)),\n+            Size::from_bytes(len),\n         )\n         .unwrap_or_else(|err| bug!(\"const slice is invalid: {:?}\", err))\n     } else {"}, {"sha": "b1626d95eb3e88bd25fa3ced6e717bc5e19ec08b", "filename": "src/librustc/ty/print/pretty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0bc108a13be32d498e6aa3066a15748e2ce1febf/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bc108a13be32d498e6aa3066a15748e2ce1febf/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs?ref=0bc108a13be32d498e6aa3066a15748e2ce1febf", "patch": "@@ -981,7 +981,7 @@ pub trait PrettyPrinter<'tcx>:\n                     .alloc_map\n                     .lock()\n                     .unwrap_memory(ptr.alloc_id)\n-                    .get_bytes(&self.tcx(), ptr, Size::from_bytes(*data as u64))\n+                    .get_bytes(&self.tcx(), ptr, Size::from_bytes(*data))\n                     .unwrap();\n                 p!(pretty_print_byte_str(byte_str));\n             }\n@@ -1169,7 +1169,7 @@ pub trait PrettyPrinter<'tcx>:\n             (ConstValue::ByRef { alloc, offset }, ty::Array(t, n)) if *t == u8_type => {\n                 let n = n.val.try_to_bits(self.tcx().data_layout.pointer_size).unwrap();\n                 // cast is ok because we already checked for pointer size (32 or 64 bit) above\n-                let n = Size::from_bytes(n as u64);\n+                let n = Size::from_bytes(n);\n                 let ptr = Pointer::new(AllocId(0), offset);\n \n                 let byte_str = alloc.get_bytes(&self.tcx(), ptr, n).unwrap();"}, {"sha": "5bb30d03d9f8d6997682daddb126c74aa2ba41fc", "filename": "src/librustc_codegen_ssa/mir/operand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0bc108a13be32d498e6aa3066a15748e2ce1febf/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bc108a13be32d498e6aa3066a15748e2ce1febf/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs?ref=0bc108a13be32d498e6aa3066a15748e2ce1febf", "patch": "@@ -91,7 +91,7 @@ impl<'a, 'tcx, V: CodegenObject> OperandRef<'tcx, V> {\n                 };\n                 let a = Scalar::from(Pointer::new(\n                     bx.tcx().alloc_map.lock().create_memory_alloc(data),\n-                    Size::from_bytes(start as u64),\n+                    Size::from_bytes(start),\n                 ));\n                 let a_llval = bx.scalar_to_backend(\n                     a,"}, {"sha": "62bb4c8d5563498fff2a237cd6164139e99fd9eb", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0bc108a13be32d498e6aa3066a15748e2ce1febf/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bc108a13be32d498e6aa3066a15748e2ce1febf/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=0bc108a13be32d498e6aa3066a15748e2ce1febf", "patch": "@@ -836,7 +836,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         src: impl IntoIterator<Item = u8>,\n     ) -> InterpResult<'tcx> {\n         let src = src.into_iter();\n-        let size = Size::from_bytes(src.size_hint().0 as u64);\n+        let size = Size::from_bytes(src.size_hint().0);\n         // `write_bytes` checks that this lower bound `size` matches the upper bound and reality.\n         let ptr = match self.check_ptr_access(ptr, size, Align::from_bytes(1).unwrap())? {\n             Some(ptr) => ptr,"}, {"sha": "409c958ac39fd67dc645768d7ec311b3e2b90829", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0bc108a13be32d498e6aa3066a15748e2ce1febf/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bc108a13be32d498e6aa3066a15748e2ce1febf/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=0bc108a13be32d498e6aa3066a15748e2ce1febf", "patch": "@@ -1,7 +1,7 @@\n //! Functions concerning immediate values and operands, and reading from operands.\n //! All high-level functions to read from memory work on operands as sources.\n \n-use std::convert::{TryFrom, TryInto};\n+use std::convert::TryFrom;\n \n use super::{InterpCx, MPlaceTy, Machine, MemPlace, Place, PlaceTy};\n pub use rustc::mir::interpret::ScalarMaybeUndef;\n@@ -570,7 +570,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 // where none should happen.\n                 let ptr = Pointer::new(\n                     self.tcx.alloc_map.lock().create_memory_alloc(data),\n-                    Size::from_bytes(start.try_into().unwrap()), // offset: `start`\n+                    Size::from_bytes(start), // offset: `start`\n                 );\n                 Operand::Immediate(Immediate::new_slice(\n                     self.tag_global_base_pointer(ptr).into(),"}, {"sha": "ef3471725558110759c0bad38f4baa2b31bfdf83", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0bc108a13be32d498e6aa3066a15748e2ce1febf/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bc108a13be32d498e6aa3066a15748e2ce1febf/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=0bc108a13be32d498e6aa3066a15748e2ce1febf", "patch": "@@ -739,7 +739,7 @@ where\n                 ),\n                 Immediate::Scalar(ScalarMaybeUndef::Scalar(Scalar::Raw { size, .. })) => {\n                     assert_eq!(\n-                        Size::from_bytes(size.into()),\n+                        Size::from_bytes(size),\n                         dest.layout.size,\n                         \"Size mismatch when writing bits\"\n                     )"}, {"sha": "76fcbf326fa788803ac06893ca838ad8b97e7377", "filename": "src/librustc_mir_build/hair/pattern/_match.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0bc108a13be32d498e6aa3066a15748e2ce1febf/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bc108a13be32d498e6aa3066a15748e2ce1febf/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2F_match.rs?ref=0bc108a13be32d498e6aa3066a15748e2ce1febf", "patch": "@@ -1920,8 +1920,8 @@ fn slice_pat_covered_by_const<'tcx>(\n         }\n         (ConstValue::Slice { data, start, end }, ty::Slice(t)) => {\n             assert_eq!(*t, tcx.types.u8);\n-            let ptr = Pointer::new(AllocId(0), Size::from_bytes(start as u64));\n-            data.get_bytes(&tcx, ptr, Size::from_bytes((end - start) as u64)).unwrap()\n+            let ptr = Pointer::new(AllocId(0), Size::from_bytes(start));\n+            data.get_bytes(&tcx, ptr, Size::from_bytes(end - start)).unwrap()\n         }\n         // FIXME(oli-obk): create a way to extract fat pointers from ByRef\n         (_, ty::Slice(_)) => return Ok(false),\n@@ -2375,7 +2375,7 @@ fn specialize_one_pattern<'p, 'tcx>(\n                 ty::Slice(t) => {\n                     match value.val {\n                         ty::ConstKind::Value(ConstValue::Slice { data, start, end }) => {\n-                            let offset = Size::from_bytes(start as u64);\n+                            let offset = Size::from_bytes(start);\n                             let n = (end - start) as u64;\n                             (Cow::Borrowed(data), offset, n, t)\n                         }"}, {"sha": "ffd6c8da1dc2fb1a58d9a2f451479a9f4769327f", "filename": "src/librustc_target/abi/mod.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0bc108a13be32d498e6aa3066a15748e2ce1febf/src%2Flibrustc_target%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bc108a13be32d498e6aa3066a15748e2ce1febf/src%2Flibrustc_target%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fmod.rs?ref=0bc108a13be32d498e6aa3066a15748e2ce1febf", "patch": "@@ -3,7 +3,7 @@ pub use Primitive::*;\n \n use crate::spec::Target;\n \n-use std::convert::TryFrom;\n+use std::convert::{TryFrom, TryInto};\n use std::ops::{Add, AddAssign, Deref, Mul, Range, RangeInclusive, Sub};\n \n use rustc_index::vec::{Idx, IndexVec};\n@@ -241,17 +241,18 @@ pub struct Size {\n }\n \n impl Size {\n-    pub const ZERO: Size = Self::from_bytes(0);\n+    pub const ZERO: Size = Size { raw: 0 };\n \n     #[inline]\n-    pub fn from_bits(bits: u64) -> Size {\n+    pub fn from_bits(bits: impl TryInto<u64>) -> Size {\n+        let bits = bits.try_into().ok().unwrap();\n         // Avoid potential overflow from `bits + 7`.\n         Size::from_bytes(bits / 8 + ((bits % 8) + 7) / 8)\n     }\n \n     #[inline]\n-    pub const fn from_bytes(bytes: u64) -> Size {\n-        Size { raw: bytes }\n+    pub fn from_bytes(bytes: impl TryInto<u64>) -> Size {\n+        Size { raw: bytes.try_into().ok().unwrap() }\n     }\n \n     #[inline]"}]}