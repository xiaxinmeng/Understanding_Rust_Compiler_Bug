{"sha": "eb5c0a6b6895990e5a69bf3a143ccc6d07df3aac", "node_id": "MDY6Q29tbWl0NzI0NzEyOmViNWMwYTZiNjg5NTk5MGU1YTY5YmYzYTE0M2NjYzZkMDdkZjNhYWM=", "commit": {"author": {"name": "Ms2ger", "email": "Ms2ger@gmail.com", "date": "2015-10-31T10:31:52Z"}, "committer": {"name": "Ms2ger", "email": "Ms2ger@gmail.com", "date": "2015-10-31T10:31:52Z"}, "message": "Rustfmt region_inference.", "tree": {"sha": "0f8929027c78a75d3d84961f10cbd0a94a534cdf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0f8929027c78a75d3d84961f10cbd0a94a534cdf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/eb5c0a6b6895990e5a69bf3a143ccc6d07df3aac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/eb5c0a6b6895990e5a69bf3a143ccc6d07df3aac", "html_url": "https://github.com/rust-lang/rust/commit/eb5c0a6b6895990e5a69bf3a143ccc6d07df3aac", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/eb5c0a6b6895990e5a69bf3a143ccc6d07df3aac/comments", "author": {"login": "Ms2ger", "id": 111161, "node_id": "MDQ6VXNlcjExMTE2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/111161?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Ms2ger", "html_url": "https://github.com/Ms2ger", "followers_url": "https://api.github.com/users/Ms2ger/followers", "following_url": "https://api.github.com/users/Ms2ger/following{/other_user}", "gists_url": "https://api.github.com/users/Ms2ger/gists{/gist_id}", "starred_url": "https://api.github.com/users/Ms2ger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Ms2ger/subscriptions", "organizations_url": "https://api.github.com/users/Ms2ger/orgs", "repos_url": "https://api.github.com/users/Ms2ger/repos", "events_url": "https://api.github.com/users/Ms2ger/events{/privacy}", "received_events_url": "https://api.github.com/users/Ms2ger/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Ms2ger", "id": 111161, "node_id": "MDQ6VXNlcjExMTE2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/111161?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Ms2ger", "html_url": "https://github.com/Ms2ger", "followers_url": "https://api.github.com/users/Ms2ger/followers", "following_url": "https://api.github.com/users/Ms2ger/following{/other_user}", "gists_url": "https://api.github.com/users/Ms2ger/gists{/gist_id}", "starred_url": "https://api.github.com/users/Ms2ger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Ms2ger/subscriptions", "organizations_url": "https://api.github.com/users/Ms2ger/orgs", "repos_url": "https://api.github.com/users/Ms2ger/repos", "events_url": "https://api.github.com/users/Ms2ger/events{/privacy}", "received_events_url": "https://api.github.com/users/Ms2ger/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fa7a3c210d7bd7c16c1f1201afaae8df76804687", "url": "https://api.github.com/repos/rust-lang/rust/commits/fa7a3c210d7bd7c16c1f1201afaae8df76804687", "html_url": "https://github.com/rust-lang/rust/commit/fa7a3c210d7bd7c16c1f1201afaae8df76804687"}], "stats": {"total": 683, "additions": 326, "deletions": 357}, "files": [{"sha": "439274cd476968718e0b4a2818bfe05f8656a1a4", "filename": "src/librustc/middle/infer/region_inference/graphviz.rs", "status": "modified", "additions": 31, "deletions": 29, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/eb5c0a6b6895990e5a69bf3a143ccc6d07df3aac/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb5c0a6b6895990e5a69bf3a143ccc6d07df3aac/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fgraphviz.rs?ref=eb5c0a6b6895990e5a69bf3a143ccc6d07df3aac", "patch": "@@ -61,16 +61,18 @@ pub fn maybe_print_constraints_for<'a, 'tcx>(region_vars: &RegionVarBindings<'a,\n         return;\n     }\n \n-    let requested_node : Option<ast::NodeId> =\n-        env::var(\"RUST_REGION_GRAPH_NODE\").ok().and_then(|s| s.parse().ok());\n+    let requested_node: Option<ast::NodeId> = env::var(\"RUST_REGION_GRAPH_NODE\")\n+                                                  .ok()\n+                                                  .and_then(|s| s.parse().ok());\n \n     if requested_node.is_some() && requested_node != Some(subject_node) {\n         return;\n     }\n \n     let requested_output = env::var(\"RUST_REGION_GRAPH\");\n     debug!(\"requested_output: {:?} requested_node: {:?}\",\n-           requested_output, requested_node);\n+           requested_output,\n+           requested_node);\n \n     let output_path = {\n         let output_template = match requested_output {\n@@ -139,7 +141,8 @@ enum Edge {\n impl<'a, 'tcx> ConstraintGraph<'a, 'tcx> {\n     fn new(tcx: &'a ty::ctxt<'tcx>,\n            name: String,\n-           map: &'a ConstraintMap<'tcx>) -> ConstraintGraph<'a, 'tcx> {\n+           map: &'a ConstraintMap<'tcx>)\n+           -> ConstraintGraph<'a, 'tcx> {\n         let mut i = 0;\n         let mut node_ids = FnvHashMap();\n         {\n@@ -150,7 +153,7 @@ impl<'a, 'tcx> ConstraintGraph<'a, 'tcx> {\n                 }\n             };\n \n-            for (n1, n2) in map.keys().map(|c|constraint_to_nodes(c)) {\n+            for (n1, n2) in map.keys().map(|c| constraint_to_nodes(c)) {\n                 add_node(n1);\n                 add_node(n2);\n             }\n@@ -161,10 +164,12 @@ impl<'a, 'tcx> ConstraintGraph<'a, 'tcx> {\n             });\n         }\n \n-        ConstraintGraph { tcx: tcx,\n-                          graph_name: name,\n-                          map: map,\n-                          node_ids: node_ids }\n+        ConstraintGraph {\n+            tcx: tcx,\n+            graph_name: name,\n+            map: map,\n+            node_ids: node_ids,\n+        }\n     }\n }\n \n@@ -187,38 +192,34 @@ impl<'a, 'tcx> dot::Labeller<'a, Node, Edge> for ConstraintGraph<'a, 'tcx> {\n     }\n     fn node_label(&self, n: &Node) -> dot::LabelText {\n         match *n {\n-            Node::RegionVid(n_vid) =>\n-                dot::LabelText::label(format!(\"{:?}\", n_vid)),\n-            Node::Region(n_rgn) =>\n-                dot::LabelText::label(format!(\"{:?}\", n_rgn)),\n+            Node::RegionVid(n_vid) => dot::LabelText::label(format!(\"{:?}\", n_vid)),\n+            Node::Region(n_rgn) => dot::LabelText::label(format!(\"{:?}\", n_rgn)),\n         }\n     }\n     fn edge_label(&self, e: &Edge) -> dot::LabelText {\n         match *e {\n             Edge::Constraint(ref c) =>\n                 dot::LabelText::label(format!(\"{:?}\", self.map.get(c).unwrap())),\n-            Edge::EnclScope(..) =>\n-                dot::LabelText::label(format!(\"(enclosed)\")),\n+            Edge::EnclScope(..) => dot::LabelText::label(format!(\"(enclosed)\")),\n         }\n     }\n }\n \n fn constraint_to_nodes(c: &Constraint) -> (Node, Node) {\n     match *c {\n-        Constraint::ConstrainVarSubVar(rv_1, rv_2) => (Node::RegionVid(rv_1),\n-                                                       Node::RegionVid(rv_2)),\n-        Constraint::ConstrainRegSubVar(r_1, rv_2) => (Node::Region(r_1),\n-                                                      Node::RegionVid(rv_2)),\n-        Constraint::ConstrainVarSubReg(rv_1, r_2) => (Node::RegionVid(rv_1),\n-                                                      Node::Region(r_2)),\n+        Constraint::ConstrainVarSubVar(rv_1, rv_2) =>\n+            (Node::RegionVid(rv_1), Node::RegionVid(rv_2)),\n+        Constraint::ConstrainRegSubVar(r_1, rv_2) => (Node::Region(r_1), Node::RegionVid(rv_2)),\n+        Constraint::ConstrainVarSubReg(rv_1, r_2) => (Node::RegionVid(rv_1), Node::Region(r_2)),\n     }\n }\n \n fn edge_to_nodes(e: &Edge) -> (Node, Node) {\n     match *e {\n         Edge::Constraint(ref c) => constraint_to_nodes(c),\n         Edge::EnclScope(sub, sup) => {\n-            (Node::Region(ty::ReScope(sub)), Node::Region(ty::ReScope(sup)))\n+            (Node::Region(ty::ReScope(sub)),\n+             Node::Region(ty::ReScope(sup)))\n         }\n     }\n }\n@@ -234,10 +235,8 @@ impl<'a, 'tcx> dot::GraphWalk<'a, Node, Edge> for ConstraintGraph<'a, 'tcx> {\n     }\n     fn edges(&self) -> dot::Edges<Edge> {\n         debug!(\"constraint graph has {} edges\", self.map.len());\n-        let mut v : Vec<_> = self.map.keys().map(|e| Edge::Constraint(*e)).collect();\n-        self.tcx.region_maps.each_encl_scope(|sub, sup| {\n-            v.push(Edge::EnclScope(*sub, *sup))\n-        });\n+        let mut v: Vec<_> = self.map.keys().map(|e| Edge::Constraint(*e)).collect();\n+        self.tcx.region_maps.each_encl_scope(|sub, sup| v.push(Edge::EnclScope(*sub, *sup)));\n         debug!(\"region graph has {} edges\", v.len());\n         Cow::Owned(v)\n     }\n@@ -255,10 +254,13 @@ impl<'a, 'tcx> dot::GraphWalk<'a, Node, Edge> for ConstraintGraph<'a, 'tcx> {\n \n pub type ConstraintMap<'tcx> = FnvHashMap<Constraint, SubregionOrigin<'tcx>>;\n \n-fn dump_region_constraints_to<'a, 'tcx:'a >(tcx: &'a ty::ctxt<'tcx>,\n+fn dump_region_constraints_to<'a, 'tcx: 'a>(tcx: &'a ty::ctxt<'tcx>,\n                                             map: &ConstraintMap<'tcx>,\n-                                            path: &str) -> io::Result<()> {\n-    debug!(\"dump_region_constraints map (len: {}) path: {}\", map.len(), path);\n+                                            path: &str)\n+                                            -> io::Result<()> {\n+    debug!(\"dump_region_constraints map (len: {}) path: {}\",\n+           map.len(),\n+           path);\n     let g = ConstraintGraph::new(tcx, format!(\"region_constraints\"), map);\n     debug!(\"dump_region_constraints calling render\");\n     let mut v = Vec::new();"}, {"sha": "dd95fc4cc0d89745f92bc1303a9fd0a437f375a3", "filename": "src/librustc/middle/infer/region_inference/mod.rs", "status": "modified", "additions": 295, "deletions": 328, "changes": 623, "blob_url": "https://github.com/rust-lang/rust/blob/eb5c0a6b6895990e5a69bf3a143ccc6d07df3aac/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb5c0a6b6895990e5a69bf3a143ccc6d07df3aac/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs?ref=eb5c0a6b6895990e5a69bf3a143ccc6d07df3aac", "patch": "@@ -113,12 +113,13 @@ pub enum UndoLogEntry {\n     AddConstraint(Constraint),\n     AddVerify(usize),\n     AddGiven(ty::FreeRegion, ty::RegionVid),\n-    AddCombination(CombineMapType, TwoRegions)\n+    AddCombination(CombineMapType, TwoRegions),\n }\n \n #[derive(Copy, Clone, PartialEq)]\n pub enum CombineMapType {\n-    Lub, Glb\n+    Lub,\n+    Glb,\n }\n \n #[derive(Clone, Debug)]\n@@ -140,8 +141,10 @@ pub enum RegionResolutionError<'tcx> {\n     /// `sub_origin`) but `v <= sup_r` (due to `sup_origin`) and\n     /// `sub_r <= sup_r` does not hold.\n     SubSupConflict(RegionVariableOrigin,\n-                   SubregionOrigin<'tcx>, Region,\n-                   SubregionOrigin<'tcx>, Region),\n+                   SubregionOrigin<'tcx>,\n+                   Region,\n+                   SubregionOrigin<'tcx>,\n+                   Region),\n \n     /// For subsets of `ConcreteFailure` and `SubSupConflict`, we can derive\n     /// more specific errors message by suggesting to the user where they\n@@ -166,7 +169,7 @@ pub enum RegionResolutionError<'tcx> {\n #[derive(Clone, Debug)]\n pub struct SameRegions {\n     pub scope_id: ast::NodeId,\n-    pub regions: Vec<BoundRegion>\n+    pub regions: Vec<BoundRegion>,\n }\n \n impl SameRegions {\n@@ -256,7 +259,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n             glbs: RefCell::new(FnvHashMap()),\n             skolemization_count: Cell::new(0),\n             bound_count: Cell::new(0),\n-            undo_log: RefCell::new(Vec::new())\n+            undo_log: RefCell::new(Vec::new()),\n         }\n     }\n \n@@ -268,7 +271,10 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         let length = self.undo_log.borrow().len();\n         debug!(\"RegionVarBindings: start_snapshot({})\", length);\n         self.undo_log.borrow_mut().push(OpenSnapshot);\n-        RegionSnapshot { length: length, skolemization_count: self.skolemization_count.get() }\n+        RegionSnapshot {\n+            length: length,\n+            skolemization_count: self.skolemization_count.get(),\n+        }\n     }\n \n     pub fn commit(&self, snapshot: RegionSnapshot) {\n@@ -295,7 +301,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                 OpenSnapshot => {\n                     panic!(\"Failure to observe stack discipline\");\n                 }\n-                CommitedSnapshot => { }\n+                CommitedSnapshot => {}\n                 AddVar(vid) => {\n                     let mut var_origins = self.var_origins.borrow_mut();\n                     var_origins.pop().unwrap();\n@@ -339,7 +345,8 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n             self.undo_log.borrow_mut().push(AddVar(vid));\n         }\n         debug!(\"created new region variable {:?} with origin {:?}\",\n-               vid, origin);\n+               vid,\n+               origin);\n         return vid;\n     }\n \n@@ -400,14 +407,11 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         self.values.borrow().is_none()\n     }\n \n-    fn add_constraint(&self,\n-                      constraint: Constraint,\n-                      origin: SubregionOrigin<'tcx>) {\n+    fn add_constraint(&self, constraint: Constraint, origin: SubregionOrigin<'tcx>) {\n         // cannot add constraints once regions are resolved\n         assert!(self.values_are_none());\n \n-        debug!(\"RegionVarBindings: add_constraint({:?})\",\n-               constraint);\n+        debug!(\"RegionVarBindings: add_constraint({:?})\", constraint);\n \n         if self.constraints.borrow_mut().insert(constraint, origin).is_none() {\n             if self.in_snapshot() {\n@@ -416,20 +420,18 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         }\n     }\n \n-    fn add_verify(&self,\n-                  verify: Verify<'tcx>) {\n+    fn add_verify(&self, verify: Verify<'tcx>) {\n         // cannot add verifys once regions are resolved\n         assert!(self.values_are_none());\n \n-        debug!(\"RegionVarBindings: add_verify({:?})\",\n-               verify);\n+        debug!(\"RegionVarBindings: add_verify({:?})\", verify);\n \n         // skip no-op cases known to be satisfied\n         match verify {\n             VerifyGenericBound(_, _, _, VerifyBound::AllBounds(ref bs)) if bs.len() == 0 => {\n                 return;\n             }\n-            _ => { }\n+            _ => {}\n         }\n \n         let mut verifys = self.verifys.borrow_mut();\n@@ -440,26 +442,19 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         }\n     }\n \n-    pub fn add_given(&self,\n-                     sub: ty::FreeRegion,\n-                     sup: ty::RegionVid) {\n+    pub fn add_given(&self, sub: ty::FreeRegion, sup: ty::RegionVid) {\n         // cannot add givens once regions are resolved\n         assert!(self.values_are_none());\n \n         let mut givens = self.givens.borrow_mut();\n         if givens.insert((sub, sup)) {\n-            debug!(\"add_given({:?} <= {:?})\",\n-                   sub,\n-                   sup);\n+            debug!(\"add_given({:?} <= {:?})\", sub, sup);\n \n             self.undo_log.borrow_mut().push(AddGiven(sub, sup));\n         }\n     }\n \n-    pub fn make_eqregion(&self,\n-                         origin: SubregionOrigin<'tcx>,\n-                         sub: Region,\n-                         sup: Region) {\n+    pub fn make_eqregion(&self, origin: SubregionOrigin<'tcx>, sub: Region, sup: Region) {\n         if sub != sup {\n             // Eventually, it would be nice to add direct support for\n             // equating regions.\n@@ -468,10 +463,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         }\n     }\n \n-    pub fn make_subregion(&self,\n-                          origin: SubregionOrigin<'tcx>,\n-                          sub: Region,\n-                          sup: Region) {\n+    pub fn make_subregion(&self, origin: SubregionOrigin<'tcx>, sub: Region, sup: Region) {\n         // cannot add constraints once regions are resolved\n         assert!(self.values_are_none());\n \n@@ -481,38 +473,37 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                origin);\n \n         match (sub, sup) {\n-          (ReEarlyBound(..), ReEarlyBound(..)) => {\n-            // This case is used only to make sure that explicitly-specified\n-            // `Self` types match the real self type in implementations.\n-            //\n-            // FIXME(NDM) -- we really shouldn't be comparing bound things\n-            self.add_verify(VerifyRegSubReg(origin, sub, sup));\n-          }\n-          (ReEarlyBound(..), _) |\n-          (ReLateBound(..), _) |\n-          (_, ReEarlyBound(..)) |\n-          (_, ReLateBound(..)) => {\n-            self.tcx.sess.span_bug(\n-                origin.span(),\n-                &format!(\"cannot relate bound region: {:?} <= {:?}\",\n-                        sub,\n-                        sup));\n-          }\n-          (_, ReStatic) => {\n-            // all regions are subregions of static, so we can ignore this\n-          }\n-          (ReVar(sub_id), ReVar(sup_id)) => {\n-            self.add_constraint(ConstrainVarSubVar(sub_id, sup_id), origin);\n-          }\n-          (r, ReVar(sup_id)) => {\n-            self.add_constraint(ConstrainRegSubVar(r, sup_id), origin);\n-          }\n-          (ReVar(sub_id), r) => {\n-            self.add_constraint(ConstrainVarSubReg(sub_id, r), origin);\n-          }\n-          _ => {\n-            self.add_verify(VerifyRegSubReg(origin, sub, sup));\n-          }\n+            (ReEarlyBound(..), ReEarlyBound(..)) => {\n+                // This case is used only to make sure that explicitly-specified\n+                // `Self` types match the real self type in implementations.\n+                //\n+                // FIXME(NDM) -- we really shouldn't be comparing bound things\n+                self.add_verify(VerifyRegSubReg(origin, sub, sup));\n+            }\n+            (ReEarlyBound(..), _) |\n+            (ReLateBound(..), _) |\n+            (_, ReEarlyBound(..)) |\n+            (_, ReLateBound(..)) => {\n+                self.tcx.sess.span_bug(origin.span(),\n+                                       &format!(\"cannot relate bound region: {:?} <= {:?}\",\n+                                                sub,\n+                                                sup));\n+            }\n+            (_, ReStatic) => {\n+                // all regions are subregions of static, so we can ignore this\n+            }\n+            (ReVar(sub_id), ReVar(sup_id)) => {\n+                self.add_constraint(ConstrainVarSubVar(sub_id, sup_id), origin);\n+            }\n+            (r, ReVar(sup_id)) => {\n+                self.add_constraint(ConstrainRegSubVar(r, sup_id), origin);\n+            }\n+            (ReVar(sub_id), r) => {\n+                self.add_constraint(ConstrainVarSubReg(sub_id, r), origin);\n+            }\n+            _ => {\n+                self.add_verify(VerifyRegSubReg(origin, sub, sup));\n+            }\n         }\n     }\n \n@@ -525,64 +516,49 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         self.add_verify(VerifyGenericBound(kind, origin, sub, bound));\n     }\n \n-    pub fn lub_regions(&self,\n-                       origin: SubregionOrigin<'tcx>,\n-                       a: Region,\n-                       b: Region)\n-                       -> Region {\n+    pub fn lub_regions(&self, origin: SubregionOrigin<'tcx>, a: Region, b: Region) -> Region {\n         // cannot add constraints once regions are resolved\n         assert!(self.values_are_none());\n \n-        debug!(\"RegionVarBindings: lub_regions({:?}, {:?})\",\n-               a,\n-               b);\n+        debug!(\"RegionVarBindings: lub_regions({:?}, {:?})\", a, b);\n         match (a, b) {\n             (ReStatic, _) | (_, ReStatic) => {\n                 ReStatic // nothing lives longer than static\n             }\n \n             _ => {\n-                self.combine_vars(\n-                    Lub, a, b, origin.clone(),\n-                    |this, old_r, new_r|\n-                    this.make_subregion(origin.clone(), old_r, new_r))\n+                self.combine_vars(Lub, a, b, origin.clone(), |this, old_r, new_r| {\n+                    this.make_subregion(origin.clone(), old_r, new_r)\n+                })\n             }\n         }\n     }\n \n-    pub fn glb_regions(&self,\n-                       origin: SubregionOrigin<'tcx>,\n-                       a: Region,\n-                       b: Region)\n-                       -> Region {\n+    pub fn glb_regions(&self, origin: SubregionOrigin<'tcx>, a: Region, b: Region) -> Region {\n         // cannot add constraints once regions are resolved\n         assert!(self.values_are_none());\n \n-        debug!(\"RegionVarBindings: glb_regions({:?}, {:?})\",\n-               a,\n-               b);\n+        debug!(\"RegionVarBindings: glb_regions({:?}, {:?})\", a, b);\n         match (a, b) {\n             (ReStatic, r) | (r, ReStatic) => {\n                 // static lives longer than everything else\n                 r\n             }\n \n             _ => {\n-                self.combine_vars(\n-                    Glb, a, b, origin.clone(),\n-                    |this, old_r, new_r|\n-                    this.make_subregion(origin.clone(), new_r, old_r))\n+                self.combine_vars(Glb, a, b, origin.clone(), |this, old_r, new_r| {\n+                    this.make_subregion(origin.clone(), new_r, old_r)\n+                })\n             }\n         }\n     }\n \n     pub fn resolve_var(&self, rid: RegionVid) -> ty::Region {\n         match *self.values.borrow() {\n             None => {\n-                self.tcx.sess.span_bug(\n-                    (*self.var_origins.borrow())[rid.index as usize].span(),\n-                    \"attempt to resolve region variable before values have \\\n-                     been computed!\")\n+                self.tcx.sess.span_bug((*self.var_origins.borrow())[rid.index as usize].span(),\n+                                       \"attempt to resolve region variable before values have \\\n+                                        been computed!\")\n             }\n             Some(ref values) => {\n                 let r = lookup(values, rid);\n@@ -592,8 +568,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         }\n     }\n \n-    fn combine_map(&self, t: CombineMapType)\n-                   -> &RefCell<CombineMap> {\n+    fn combine_map(&self, t: CombineMapType) -> &RefCell<CombineMap> {\n         match t {\n             Glb => &self.glbs,\n             Lub => &self.lubs,\n@@ -606,8 +581,8 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                            b: Region,\n                            origin: SubregionOrigin<'tcx>,\n                            mut relate: F)\n-                           -> Region where\n-        F: FnMut(&RegionVarBindings<'a, 'tcx>, Region, Region),\n+                           -> Region\n+        where F: FnMut(&RegionVarBindings<'a, 'tcx>, Region, Region)\n     {\n         let vars = TwoRegions { a: a, b: b };\n         match self.combine_map(t).borrow().get(&vars) {\n@@ -627,14 +602,14 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         ReVar(c)\n     }\n \n-    pub fn vars_created_since_snapshot(&self, mark: &RegionSnapshot)\n-                                       -> Vec<RegionVid>\n-    {\n+    pub fn vars_created_since_snapshot(&self, mark: &RegionSnapshot) -> Vec<RegionVid> {\n         self.undo_log.borrow()[mark.length..]\n             .iter()\n-            .filter_map(|&elt| match elt {\n-                AddVar(vid) => Some(vid),\n-                _ => None\n+            .filter_map(|&elt| {\n+                match elt {\n+                    AddVar(vid) => Some(vid),\n+                    _ => None,\n+                }\n             })\n             .collect()\n     }\n@@ -649,57 +624,46 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         // `result_set` acts as a worklist: we explore all outgoing\n         // edges and add any new regions we find to result_set.  This\n         // is not a terribly efficient implementation.\n-        let mut result_set = vec!(r0);\n+        let mut result_set = vec![r0];\n         let mut result_index = 0;\n         while result_index < result_set.len() {\n             // nb: can't use usize::range() here because result_set grows\n             let r = result_set[result_index];\n             debug!(\"result_index={}, r={:?}\", result_index, r);\n \n-            for undo_entry in\n-                self.undo_log.borrow()[mark.length..].iter()\n-            {\n+            for undo_entry in self.undo_log.borrow()[mark.length..].iter() {\n                 match undo_entry {\n                     &AddConstraint(ConstrainVarSubVar(a, b)) => {\n-                        consider_adding_bidirectional_edges(\n-                            &mut result_set, r,\n-                            ReVar(a), ReVar(b));\n+                        consider_adding_bidirectional_edges(&mut result_set, r, ReVar(a), ReVar(b));\n                     }\n                     &AddConstraint(ConstrainRegSubVar(a, b)) => {\n-                        consider_adding_bidirectional_edges(\n-                            &mut result_set, r,\n-                            a, ReVar(b));\n+                        consider_adding_bidirectional_edges(&mut result_set, r, a, ReVar(b));\n                     }\n                     &AddConstraint(ConstrainVarSubReg(a, b)) => {\n-                        consider_adding_bidirectional_edges(\n-                            &mut result_set, r,\n-                            ReVar(a), b);\n+                        consider_adding_bidirectional_edges(&mut result_set, r, ReVar(a), b);\n                     }\n                     &AddGiven(a, b) => {\n-                        consider_adding_bidirectional_edges(\n-                            &mut result_set, r,\n-                            ReFree(a), ReVar(b));\n+                        consider_adding_bidirectional_edges(&mut result_set,\n+                                                            r,\n+                                                            ReFree(a),\n+                                                            ReVar(b));\n                     }\n                     &AddVerify(i) => {\n                         match (*self.verifys.borrow())[i] {\n                             VerifyRegSubReg(_, a, b) => {\n-                                consider_adding_bidirectional_edges(\n-                                    &mut result_set, r,\n-                                    a, b);\n+                                consider_adding_bidirectional_edges(&mut result_set, r, a, b);\n                             }\n                             VerifyGenericBound(_, _, a, ref bound) => {\n                                 bound.for_each_region(&mut |b| {\n-                                    consider_adding_bidirectional_edges(&mut result_set, r,\n-                                                                        a, b)\n+                                    consider_adding_bidirectional_edges(&mut result_set, r, a, b)\n                                 });\n                             }\n                         }\n                     }\n                     &AddCombination(..) |\n                     &AddVar(..) |\n                     &OpenSnapshot |\n-                    &CommitedSnapshot => {\n-                    }\n+                    &CommitedSnapshot => {}\n                 }\n             }\n \n@@ -737,89 +701,91 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n     pub fn resolve_regions(&self,\n                            free_regions: &FreeRegionMap,\n                            subject_node: ast::NodeId)\n-                           -> Vec<RegionResolutionError<'tcx>>\n-    {\n+                           -> Vec<RegionResolutionError<'tcx>> {\n         debug!(\"RegionVarBindings: resolve_regions()\");\n-        let mut errors = vec!();\n+        let mut errors = vec![];\n         let v = self.infer_variable_values(free_regions, &mut errors, subject_node);\n         *self.values.borrow_mut() = Some(v);\n         errors\n     }\n \n     fn lub_concrete_regions(&self, free_regions: &FreeRegionMap, a: Region, b: Region) -> Region {\n         match (a, b) {\n-          (ReLateBound(..), _) |\n-          (_, ReLateBound(..)) |\n-          (ReEarlyBound(..), _) |\n-          (_, ReEarlyBound(..)) => {\n-            self.tcx.sess.bug(\n-                &format!(\"cannot relate bound region: LUB({:?}, {:?})\",\n-                        a,\n-                        b));\n-          }\n-\n-          (ReStatic, _) | (_, ReStatic) => {\n-            ReStatic // nothing lives longer than static\n-          }\n-\n-          (ReEmpty, r) | (r, ReEmpty) => {\n-            r // everything lives longer than empty\n-          }\n-\n-          (ReVar(v_id), _) | (_, ReVar(v_id)) => {\n-            self.tcx.sess.span_bug(\n-                (*self.var_origins.borrow())[v_id.index as usize].span(),\n-                &format!(\"lub_concrete_regions invoked with \\\n-                         non-concrete regions: {:?}, {:?}\",\n-                        a,\n-                        b));\n-          }\n-\n-          (ReFree(ref fr), ReScope(s_id)) |\n-          (ReScope(s_id), ReFree(ref fr)) => {\n-            let f = ReFree(*fr);\n-            // A \"free\" region can be interpreted as \"some region\n-            // at least as big as the block fr.scope_id\".  So, we can\n-            // reasonably compare free regions and scopes:\n-            let r_id = self.tcx.region_maps.nearest_common_ancestor(fr.scope, s_id);\n-\n-            if r_id == fr.scope {\n-              // if the free region's scope `fr.scope_id` is bigger than\n-              // the scope region `s_id`, then the LUB is the free\n-              // region itself:\n-              f\n-            } else {\n-              // otherwise, we don't know what the free region is,\n-              // so we must conservatively say the LUB is static:\n-              ReStatic\n+            (ReLateBound(..), _) |\n+            (_, ReLateBound(..)) |\n+            (ReEarlyBound(..), _) |\n+            (_, ReEarlyBound(..)) => {\n+                self.tcx.sess.bug(&format!(\"cannot relate bound region: LUB({:?}, {:?})\", a, b));\n+            }\n+\n+            (ReStatic, _) | (_, ReStatic) => {\n+                ReStatic // nothing lives longer than static\n+            }\n+\n+            (ReEmpty, r) | (r, ReEmpty) => {\n+                r // everything lives longer than empty\n+            }\n+\n+            (ReVar(v_id), _) | (_, ReVar(v_id)) => {\n+                self.tcx.sess.span_bug((*self.var_origins.borrow())[v_id.index as usize].span(),\n+                                       &format!(\"lub_concrete_regions invoked with non-concrete \\\n+                                                 regions: {:?}, {:?}\",\n+                                                a,\n+                                                b));\n+            }\n+\n+            (ReFree(ref fr), ReScope(s_id)) |\n+            (ReScope(s_id), ReFree(ref fr)) => {\n+                let f = ReFree(*fr);\n+                // A \"free\" region can be interpreted as \"some region\n+                // at least as big as the block fr.scope_id\".  So, we can\n+                // reasonably compare free regions and scopes:\n+                let r_id = self.tcx.region_maps.nearest_common_ancestor(fr.scope, s_id);\n+\n+                if r_id == fr.scope {\n+                    // if the free region's scope `fr.scope_id` is bigger than\n+                    // the scope region `s_id`, then the LUB is the free\n+                    // region itself:\n+                    f\n+                } else {\n+                    // otherwise, we don't know what the free region is,\n+                    // so we must conservatively say the LUB is static:\n+                    ReStatic\n+                }\n+            }\n+\n+            (ReScope(a_id), ReScope(b_id)) => {\n+                // The region corresponding to an outer block is a\n+                // subtype of the region corresponding to an inner\n+                // block.\n+                ReScope(self.tcx.region_maps.nearest_common_ancestor(a_id, b_id))\n+            }\n+\n+            (ReFree(a_fr), ReFree(b_fr)) => {\n+                free_regions.lub_free_regions(a_fr, b_fr)\n+            }\n+\n+            // For these types, we cannot define any additional\n+            // relationship:\n+            (ReSkolemized(..), _) |\n+            (_, ReSkolemized(..)) => {\n+                if a == b {\n+                    a\n+                } else {\n+                    ReStatic\n+                }\n             }\n-          }\n-\n-          (ReScope(a_id), ReScope(b_id)) => {\n-            // The region corresponding to an outer block is a\n-            // subtype of the region corresponding to an inner\n-            // block.\n-            ReScope(self.tcx.region_maps.nearest_common_ancestor(a_id, b_id))\n-          }\n-\n-          (ReFree(a_fr), ReFree(b_fr)) => {\n-            free_regions.lub_free_regions(a_fr, b_fr)\n-          }\n-\n-          // For these types, we cannot define any additional\n-          // relationship:\n-          (ReSkolemized(..), _) |\n-          (_, ReSkolemized(..)) => {\n-            if a == b {a} else {ReStatic}\n-          }\n         }\n     }\n }\n \n // ______________________________________________________________________\n \n #[derive(Copy, Clone, Debug)]\n-pub enum VarValue { Value(Region), ErrorValue }\n+pub enum VarValue {\n+    Value(Region),\n+    ErrorValue,\n+}\n \n struct VarData {\n     value: VarValue,\n@@ -836,39 +802,38 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n     fn infer_variable_values(&self,\n                              free_regions: &FreeRegionMap,\n                              errors: &mut Vec<RegionResolutionError<'tcx>>,\n-                             subject: ast::NodeId) -> Vec<VarValue>\n-    {\n+                             subject: ast::NodeId)\n+                             -> Vec<VarValue> {\n         let mut var_data = self.construct_var_data();\n \n         // Dorky hack to cause `dump_constraints` to only get called\n         // if debug mode is enabled:\n         debug!(\"----() End constraint listing (subject={}) {:?}---\",\n-               subject, self.dump_constraints(subject));\n+               subject,\n+               self.dump_constraints(subject));\n         graphviz::maybe_print_constraints_for(self, subject);\n \n         let graph = self.construct_graph();\n         self.expand_givens(&graph);\n         self.expansion(free_regions, &mut var_data);\n         self.contraction(free_regions, &mut var_data);\n-        let values =\n-            self.extract_values_and_collect_conflicts(free_regions,\n-                                                      &var_data,\n-                                                      &graph,\n-                                                      errors);\n+        let values = self.extract_values_and_collect_conflicts(free_regions,\n+                                                               &var_data,\n+                                                               &graph,\n+                                                               errors);\n         self.collect_concrete_region_errors(free_regions, &values, errors);\n         values\n     }\n \n     fn construct_var_data(&self) -> Vec<VarData> {\n-        (0..self.num_vars() as usize).map(|_| {\n-            VarData {\n-                value: Value(ty::ReEmpty),\n-            }\n-        }).collect()\n+        (0..self.num_vars() as usize)\n+            .map(|_| VarData { value: Value(ty::ReEmpty) })\n+            .collect()\n     }\n \n     fn dump_constraints(&self, subject: ast::NodeId) {\n-        debug!(\"----() Start constraint listing (subject={}) ()----\", subject);\n+        debug!(\"----() Start constraint listing (subject={}) ()----\",\n+               subject);\n         for (idx, (constraint, _)) in self.constraints.borrow().iter().enumerate() {\n             debug!(\"Constraint {} => {:?}\", idx, constraint);\n         }\n@@ -903,28 +868,28 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         self.iterate_until_fixed_point(\"Expansion\", |constraint| {\n             debug!(\"expansion: constraint={:?} origin={:?}\",\n                    constraint,\n-                   self.constraints.borrow()\n-                                   .get(constraint)\n-                                   .unwrap()\n-                                   );\n+                   self.constraints\n+                       .borrow()\n+                       .get(constraint)\n+                       .unwrap());\n             match *constraint {\n-              ConstrainRegSubVar(a_region, b_vid) => {\n-                let b_data = &mut var_data[b_vid.index as usize];\n-                self.expand_node(free_regions, a_region, b_vid, b_data)\n-              }\n-              ConstrainVarSubVar(a_vid, b_vid) => {\n-                match var_data[a_vid.index as usize].value {\n-                    ErrorValue => false,\n-                    Value(a_region) => {\n-                        let b_node = &mut var_data[b_vid.index as usize];\n-                        self.expand_node(free_regions, a_region, b_vid, b_node)\n+                ConstrainRegSubVar(a_region, b_vid) => {\n+                    let b_data = &mut var_data[b_vid.index as usize];\n+                    self.expand_node(free_regions, a_region, b_vid, b_data)\n+                }\n+                ConstrainVarSubVar(a_vid, b_vid) => {\n+                    match var_data[a_vid.index as usize].value {\n+                        ErrorValue => false,\n+                        Value(a_region) => {\n+                            let b_node = &mut var_data[b_vid.index as usize];\n+                            self.expand_node(free_regions, a_region, b_vid, b_node)\n+                        }\n                     }\n                 }\n-              }\n-              ConstrainVarSubReg(..) => {\n-                // This is a contraction constraint.  Ignore it.\n-                false\n-              }\n+                ConstrainVarSubReg(..) => {\n+                    // This is a contraction constraint.  Ignore it.\n+                    false\n+                }\n             }\n         })\n     }\n@@ -934,8 +899,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                    a_region: Region,\n                    b_vid: RegionVid,\n                    b_data: &mut VarData)\n-                   -> bool\n-    {\n+                   -> bool {\n         debug!(\"expand_node({:?}, {:?} == {:?})\",\n                a_region,\n                b_vid,\n@@ -949,50 +913,51 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                     return false;\n                 }\n             }\n-            _ => { }\n+            _ => {}\n         }\n \n         match b_data.value {\n-          Value(cur_region) => {\n-            let lub = self.lub_concrete_regions(free_regions, a_region, cur_region);\n-            if lub == cur_region {\n-                return false;\n-            }\n+            Value(cur_region) => {\n+                let lub = self.lub_concrete_regions(free_regions, a_region, cur_region);\n+                if lub == cur_region {\n+                    return false;\n+                }\n \n-            debug!(\"Expanding value of {:?} from {:?} to {:?}\",\n-                   b_vid,\n-                   cur_region,\n-                   lub);\n+                debug!(\"Expanding value of {:?} from {:?} to {:?}\",\n+                       b_vid,\n+                       cur_region,\n+                       lub);\n \n-            b_data.value = Value(lub);\n-            return true;\n-          }\n+                b_data.value = Value(lub);\n+                return true;\n+            }\n \n-          ErrorValue => {\n-            return false;\n-          }\n+            ErrorValue => {\n+                return false;\n+            }\n         }\n     }\n \n     // FIXME(#29436) -- this fn would just go away if we removed ConstrainVarSubReg\n-    fn contraction(&self,\n-                   free_regions: &FreeRegionMap,\n-                   var_data: &mut [VarData]) {\n+    fn contraction(&self, free_regions: &FreeRegionMap, var_data: &mut [VarData]) {\n         self.iterate_until_fixed_point(\"Contraction\", |constraint| {\n             debug!(\"contraction: constraint={:?} origin={:?}\",\n                    constraint,\n-                   self.constraints.borrow()\n-                                   .get(constraint)\n-                                   .unwrap()\n-                                   );\n+                   self.constraints\n+                       .borrow()\n+                       .get(constraint)\n+                       .unwrap());\n             match *constraint {\n                 ConstrainRegSubVar(..) |\n                 ConstrainVarSubVar(..) => {\n                     // Expansion will ensure that these constraints hold. Ignore.\n                 }\n                 ConstrainVarSubReg(a_vid, b_region) => {\n                     let a_data = &mut var_data[a_vid.index as usize];\n-                    debug!(\"contraction: {:?} == {:?}, {:?}\", a_vid, a_data.value, b_region);\n+                    debug!(\"contraction: {:?} == {:?}, {:?}\",\n+                           a_vid,\n+                           a_data.value,\n+                           b_region);\n \n                     let a_region = match a_data.value {\n                         ErrorValue => return false,\n@@ -1001,9 +966,9 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n \n                     if !free_regions.is_subregion_of(self.tcx, a_region, b_region) {\n                         debug!(\"Setting {:?} to ErrorValue: {:?} not subregion of {:?}\",\n-                            a_vid,\n-                            a_region,\n-                            b_region);\n+                               a_vid,\n+                               a_region,\n+                               b_region);\n                         a_data.value = ErrorValue;\n                     }\n                 }\n@@ -1016,8 +981,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n     fn collect_concrete_region_errors(&self,\n                                       free_regions: &FreeRegionMap,\n                                       values: &Vec<VarValue>,\n-                                      errors: &mut Vec<RegionResolutionError<'tcx>>)\n-    {\n+                                      errors: &mut Vec<RegionResolutionError<'tcx>>) {\n         let mut reg_reg_dups = FnvHashSet();\n         for verify in self.verifys.borrow().iter() {\n             match *verify {\n@@ -1031,7 +995,9 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                     }\n \n                     debug!(\"region inference error at {:?}: {:?} <= {:?} is not true\",\n-                           origin, sub, sup);\n+                           origin,\n+                           sub,\n+                           sup);\n \n                     errors.push(ConcreteFailure((*origin).clone(), sub, sup));\n                 }\n@@ -1043,22 +1009,22 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                     }\n \n                     debug!(\"region inference error at {:?}: verifying {:?} <= {:?}\",\n-                           origin, sub, bound);\n+                           origin,\n+                           sub,\n+                           bound);\n \n                     errors.push(GenericBoundFailure((*origin).clone(), kind.clone(), sub));\n                 }\n             }\n         }\n     }\n \n-    fn extract_values_and_collect_conflicts(\n-        &self,\n-        free_regions: &FreeRegionMap,\n-        var_data: &[VarData],\n-        graph: &RegionGraph,\n-        errors: &mut Vec<RegionResolutionError<'tcx>>)\n-        -> Vec<VarValue>\n-    {\n+    fn extract_values_and_collect_conflicts(&self,\n+                                            free_regions: &FreeRegionMap,\n+                                            var_data: &[VarData],\n+                                            graph: &RegionGraph,\n+                                            errors: &mut Vec<RegionResolutionError<'tcx>>)\n+                                            -> Vec<VarValue> {\n         debug!(\"extract_values_and_collect_conflicts()\");\n \n         // This is the best way that I have found to suppress\n@@ -1104,8 +1070,11 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                        this portion of the code and think hard about it. =) */\n \n                     let node_vid = RegionVid { index: idx as u32 };\n-                    self.collect_error_for_expanding_node(\n-                        free_regions, graph, &mut dup_vec, node_vid, errors);\n+                    self.collect_error_for_expanding_node(free_regions,\n+                                                          graph,\n+                                                          &mut dup_vec,\n+                                                          node_vid,\n+                                                          errors);\n                 }\n             }\n         }\n@@ -1133,14 +1102,10 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                                    *constraint);\n                 }\n                 ConstrainRegSubVar(_, b_id) => {\n-                    graph.add_edge(dummy_idx,\n-                                   NodeIndex(b_id.index as usize),\n-                                   *constraint);\n+                    graph.add_edge(dummy_idx, NodeIndex(b_id.index as usize), *constraint);\n                 }\n                 ConstrainVarSubReg(a_id, _) => {\n-                    graph.add_edge(NodeIndex(a_id.index as usize),\n-                                   dummy_idx,\n-                                   *constraint);\n+                    graph.add_edge(NodeIndex(a_id.index as usize), dummy_idx, *constraint);\n                 }\n             }\n         }\n@@ -1153,14 +1118,17 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                                         graph: &RegionGraph,\n                                         dup_vec: &mut [u32],\n                                         node_idx: RegionVid,\n-                                        errors: &mut Vec<RegionResolutionError<'tcx>>)\n-    {\n+                                        errors: &mut Vec<RegionResolutionError<'tcx>>) {\n         // Errors in expanding nodes result from a lower-bound that is\n         // not contained by an upper-bound.\n-        let (mut lower_bounds, lower_dup) =\n-            self.collect_concrete_regions(graph, node_idx, graph::INCOMING, dup_vec);\n-        let (mut upper_bounds, upper_dup) =\n-            self.collect_concrete_regions(graph, node_idx, graph::OUTGOING, dup_vec);\n+        let (mut lower_bounds, lower_dup) = self.collect_concrete_regions(graph,\n+                                                                          node_idx,\n+                                                                          graph::INCOMING,\n+                                                                          dup_vec);\n+        let (mut upper_bounds, upper_dup) = self.collect_concrete_regions(graph,\n+                                                                          node_idx,\n+                                                                          graph::OUTGOING,\n+                                                                          dup_vec);\n \n         if lower_dup || upper_dup {\n             return;\n@@ -1169,46 +1137,44 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         // We place free regions first because we are special casing\n         // SubSupConflict(ReFree, ReFree) when reporting error, and so\n         // the user will more likely get a specific suggestion.\n-        fn free_regions_first(a: &RegionAndOrigin,\n-                              b: &RegionAndOrigin)\n-                              -> Ordering {\n+        fn free_regions_first(a: &RegionAndOrigin, b: &RegionAndOrigin) -> Ordering {\n             match (a.region, b.region) {\n                 (ReFree(..), ReFree(..)) => Equal,\n                 (ReFree(..), _) => Less,\n                 (_, ReFree(..)) => Greater,\n                 (_, _) => Equal,\n             }\n         }\n-        lower_bounds.sort_by(|a, b| { free_regions_first(a, b) });\n-        upper_bounds.sort_by(|a, b| { free_regions_first(a, b) });\n+        lower_bounds.sort_by(|a, b| free_regions_first(a, b));\n+        upper_bounds.sort_by(|a, b| free_regions_first(a, b));\n \n         for lower_bound in &lower_bounds {\n             for upper_bound in &upper_bounds {\n-                if !free_regions.is_subregion_of(self.tcx,\n-                                                 lower_bound.region,\n-                                                 upper_bound.region) {\n+                if !free_regions.is_subregion_of(self.tcx, lower_bound.region, upper_bound.region) {\n                     let origin = (*self.var_origins.borrow())[node_idx.index as usize].clone();\n-                    debug!(\"region inference error at {:?} for {:?}: \\\n-                            SubSupConflict sub: {:?} sup: {:?}\",\n-                           origin, node_idx, lower_bound.region, upper_bound.region);\n-                    errors.push(SubSupConflict(\n-                        origin,\n-                        lower_bound.origin.clone(),\n-                        lower_bound.region,\n-                        upper_bound.origin.clone(),\n-                        upper_bound.region));\n+                    debug!(\"region inference error at {:?} for {:?}: SubSupConflict sub: {:?} \\\n+                            sup: {:?}\",\n+                           origin,\n+                           node_idx,\n+                           lower_bound.region,\n+                           upper_bound.region);\n+                    errors.push(SubSupConflict(origin,\n+                                               lower_bound.origin.clone(),\n+                                               lower_bound.region,\n+                                               upper_bound.origin.clone(),\n+                                               upper_bound.region));\n                     return;\n                 }\n             }\n         }\n \n-        self.tcx.sess.span_bug(\n-            (*self.var_origins.borrow())[node_idx.index as usize].span(),\n-            &format!(\"collect_error_for_expanding_node() could not find error \\\n-                    for var {:?}, lower_bounds={:?}, upper_bounds={:?}\",\n-                    node_idx,\n-                    lower_bounds,\n-                    upper_bounds));\n+        self.tcx.sess.span_bug((*self.var_origins.borrow())[node_idx.index as usize].span(),\n+                               &format!(\"collect_error_for_expanding_node() could not find \\\n+                                         error for var {:?}, lower_bounds={:?}, \\\n+                                         upper_bounds={:?}\",\n+                                        node_idx,\n+                                        lower_bounds,\n+                                        upper_bounds));\n     }\n \n     fn collect_concrete_regions(&self,\n@@ -1221,13 +1187,13 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n             set: FnvHashSet<RegionVid>,\n             stack: Vec<RegionVid>,\n             result: Vec<RegionAndOrigin<'tcx>>,\n-            dup_found: bool\n+            dup_found: bool,\n         }\n         let mut state = WalkState {\n             set: FnvHashSet(),\n-            stack: vec!(orig_node_idx),\n+            stack: vec![orig_node_idx],\n             result: Vec::new(),\n-            dup_found: false\n+            dup_found: false,\n         };\n         state.set.insert(orig_node_idx);\n \n@@ -1246,7 +1212,8 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n             }\n \n             debug!(\"collect_concrete_regions(orig_node_idx={:?}, node_idx={:?})\",\n-                   orig_node_idx, node_idx);\n+                   orig_node_idx,\n+                   node_idx);\n \n             // figure out the direction from which this node takes its\n             // values, and search for concrete regions etc in that direction\n@@ -1268,8 +1235,11 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n             for (_, edge) in graph.adjacent_edges(source_node_index, dir) {\n                 match edge.data {\n                     ConstrainVarSubVar(from_vid, to_vid) => {\n-                        let opp_vid =\n-                            if from_vid == source_vid {to_vid} else {from_vid};\n+                        let opp_vid = if from_vid == source_vid {\n+                            to_vid\n+                        } else {\n+                            from_vid\n+                        };\n                         if state.set.insert(opp_vid) {\n                             state.stack.push(opp_vid);\n                         }\n@@ -1279,16 +1249,16 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                     ConstrainVarSubReg(_, region) => {\n                         state.result.push(RegionAndOrigin {\n                             region: region,\n-                            origin: this.constraints.borrow().get(&edge.data).unwrap().clone()\n+                            origin: this.constraints.borrow().get(&edge.data).unwrap().clone(),\n                         });\n                     }\n                 }\n             }\n         }\n     }\n \n-    fn iterate_until_fixed_point<F>(&self, tag: &str, mut body: F) where\n-        F: FnMut(&Constraint) -> bool,\n+    fn iterate_until_fixed_point<F>(&self, tag: &str, mut body: F)\n+        where F: FnMut(&Constraint) -> bool\n     {\n         let mut iteration = 0;\n         let mut changed = true;\n@@ -1299,8 +1269,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n             for (constraint, _) in self.constraints.borrow().iter() {\n                 let edge_changed = body(constraint);\n                 if edge_changed {\n-                    debug!(\"Updated due to constraint {:?}\",\n-                           constraint);\n+                    debug!(\"Updated due to constraint {:?}\", constraint);\n                     changed = true;\n                 }\n             }\n@@ -1326,7 +1295,7 @@ impl<'tcx> fmt::Debug for Verify<'tcx> {\n fn normalize(values: &Vec<VarValue>, r: ty::Region) -> ty::Region {\n     match r {\n         ty::ReVar(rid) => lookup(values, rid),\n-        _ => r\n+        _ => r,\n     }\n }\n \n@@ -1339,9 +1308,7 @@ fn lookup(values: &Vec<VarValue>, rid: ty::RegionVid) -> ty::Region {\n \n impl<'tcx> fmt::Debug for RegionAndOrigin<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"RegionAndOrigin({:?},{:?})\",\n-               self.region,\n-               self.origin)\n+        write!(f, \"RegionAndOrigin({:?},{:?})\", self.region, self.origin)\n     }\n }\n \n@@ -1366,10 +1333,8 @@ impl<'tcx> fmt::Display for GenericKind<'tcx> {\n impl<'tcx> GenericKind<'tcx> {\n     pub fn to_ty(&self, tcx: &ty::ctxt<'tcx>) -> Ty<'tcx> {\n         match *self {\n-            GenericKind::Param(ref p) =>\n-                p.to_ty(tcx),\n-            GenericKind::Projection(ref p) =>\n-                tcx.mk_projection(p.trait_ref.clone(), p.item_name),\n+            GenericKind::Param(ref p) => p.to_ty(tcx),\n+            GenericKind::Projection(ref p) => tcx.mk_projection(p.trait_ref.clone(), p.item_name),\n         }\n     }\n }\n@@ -1378,12 +1343,14 @@ impl VerifyBound {\n     fn for_each_region(&self, f: &mut FnMut(ty::Region)) {\n         match self {\n             &VerifyBound::AnyRegion(ref rs) |\n-            &VerifyBound::AllRegions(ref rs) =>\n-                for &r in rs { f(r); },\n+            &VerifyBound::AllRegions(ref rs) => for &r in rs {\n+                f(r);\n+            },\n \n             &VerifyBound::AnyBound(ref bs) |\n-            &VerifyBound::AllBounds(ref bs) =>\n-                for b in bs { b.for_each_region(f); },\n+            &VerifyBound::AllBounds(ref bs) => for b in bs {\n+                b.for_each_region(f);\n+            },\n         }\n     }\n "}]}