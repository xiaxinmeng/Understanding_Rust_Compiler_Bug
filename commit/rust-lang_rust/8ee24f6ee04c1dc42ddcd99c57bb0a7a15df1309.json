{"sha": "8ee24f6ee04c1dc42ddcd99c57bb0a7a15df1309", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhlZTI0ZjZlZTA0YzFkYzQyZGRjZDk5YzU3YmIwYTdhMTVkZjEzMDk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-10-10T04:07:02Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-10-10T04:07:02Z"}, "message": "Auto merge of #65077 - estebank:mut-trait-expected, r=nikomatsakis\n\nNote when a mutable trait object is needed\n\nFix https://github.com/rust-lang/rust/issues/63619, fix https://github.com/rust-lang/rust/issues/37914. CC https://github.com/rust-lang/rust/issues/64068.", "tree": {"sha": "db085b0cb6f6fde4e6f9eba60e7bc1aa2645b089", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/db085b0cb6f6fde4e6f9eba60e7bc1aa2645b089"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8ee24f6ee04c1dc42ddcd99c57bb0a7a15df1309", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8ee24f6ee04c1dc42ddcd99c57bb0a7a15df1309", "html_url": "https://github.com/rust-lang/rust/commit/8ee24f6ee04c1dc42ddcd99c57bb0a7a15df1309", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8ee24f6ee04c1dc42ddcd99c57bb0a7a15df1309/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "aa45e032d96f1785581d336170e6dc35d5f1cb65", "url": "https://api.github.com/repos/rust-lang/rust/commits/aa45e032d96f1785581d336170e6dc35d5f1cb65", "html_url": "https://github.com/rust-lang/rust/commit/aa45e032d96f1785581d336170e6dc35d5f1cb65"}, {"sha": "faf8a2af7aab765c832c9045f08421e42ddb0b35", "url": "https://api.github.com/repos/rust-lang/rust/commits/faf8a2af7aab765c832c9045f08421e42ddb0b35", "html_url": "https://github.com/rust-lang/rust/commit/faf8a2af7aab765c832c9045f08421e42ddb0b35"}], "stats": {"total": 354, "additions": 297, "deletions": 57}, "files": [{"sha": "e72f46682cee599d714c71c130addefb6c5c4082", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8ee24f6ee04c1dc42ddcd99c57bb0a7a15df1309/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ee24f6ee04c1dc42ddcd99c57bb0a7a15df1309/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=8ee24f6ee04c1dc42ddcd99c57bb0a7a15df1309", "patch": "@@ -1053,6 +1053,13 @@ impl Mutability {\n             MutImmutable => MutImmutable,\n         }\n     }\n+\n+    pub fn invert(self) -> Self {\n+        match self {\n+            MutMutable => MutImmutable,\n+            MutImmutable => MutMutable,\n+        }\n+    }\n }\n \n #[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, Hash, HashStable)]"}, {"sha": "9eb91569ed5c4f6ded2018545d83e7814038ece9", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 99, "deletions": 21, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/8ee24f6ee04c1dc42ddcd99c57bb0a7a15df1309/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ee24f6ee04c1dc42ddcd99c57bb0a7a15df1309/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=8ee24f6ee04c1dc42ddcd99c57bb0a7a15df1309", "patch": "@@ -453,21 +453,17 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn find_similar_impl_candidates(&self,\n-                                    trait_ref: ty::PolyTraitRef<'tcx>)\n-                                    -> Vec<ty::TraitRef<'tcx>>\n-    {\n-        let simp = fast_reject::simplify_type(self.tcx,\n-                                              trait_ref.skip_binder().self_ty(),\n-                                              true);\n+    fn find_similar_impl_candidates(\n+        &self,\n+        trait_ref: ty::PolyTraitRef<'tcx>,\n+    ) -> Vec<ty::TraitRef<'tcx>> {\n+        let simp = fast_reject::simplify_type(self.tcx, trait_ref.skip_binder().self_ty(), true);\n         let all_impls = self.tcx.all_impls(trait_ref.def_id());\n \n         match simp {\n             Some(simp) => all_impls.iter().filter_map(|&def_id| {\n                 let imp = self.tcx.impl_trait_ref(def_id).unwrap();\n-                let imp_simp = fast_reject::simplify_type(self.tcx,\n-                                                          imp.self_ty(),\n-                                                          true);\n+                let imp_simp = fast_reject::simplify_type(self.tcx, imp.self_ty(), true);\n                 if let Some(imp_simp) = imp_simp {\n                     if simp != imp_simp {\n                         return None\n@@ -482,10 +478,11 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn report_similar_impl_candidates(&self,\n-                                      impl_candidates: Vec<ty::TraitRef<'tcx>>,\n-                                      err: &mut DiagnosticBuilder<'_>)\n-    {\n+    fn report_similar_impl_candidates(\n+        &self,\n+        impl_candidates: Vec<ty::TraitRef<'tcx>>,\n+        err: &mut DiagnosticBuilder<'_>,\n+    ) {\n         if impl_candidates.is_empty() {\n             return;\n         }\n@@ -720,10 +717,18 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                             // which is somewhat confusing.\n                             err.help(&format!(\"consider adding a `where {}` bound\",\n                                               trait_ref.to_predicate()));\n-                        } else if !have_alt_message {\n-                            // Can't show anything else useful, try to find similar impls.\n-                            let impl_candidates = self.find_similar_impl_candidates(trait_ref);\n-                            self.report_similar_impl_candidates(impl_candidates, &mut err);\n+                        } else {\n+                            if !have_alt_message {\n+                                // Can't show anything else useful, try to find similar impls.\n+                                let impl_candidates = self.find_similar_impl_candidates(trait_ref);\n+                                self.report_similar_impl_candidates(impl_candidates, &mut err);\n+                            }\n+                            self.suggest_change_mut(\n+                                &obligation,\n+                                &mut err,\n+                                &trait_ref,\n+                                points_at_arg,\n+                            );\n                         }\n \n                         // If this error is due to `!: Trait` not implemented but `(): Trait` is\n@@ -1081,9 +1086,11 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n                     let substs = self.tcx.mk_substs_trait(trait_type, &[]);\n                     let new_trait_ref = ty::TraitRef::new(trait_ref.def_id, substs);\n-                    let new_obligation = Obligation::new(ObligationCause::dummy(),\n-                                                         obligation.param_env,\n-                                                         new_trait_ref.to_predicate());\n+                    let new_obligation = Obligation::new(\n+                        ObligationCause::dummy(),\n+                        obligation.param_env,\n+                        new_trait_ref.to_predicate(),\n+                    );\n \n                     if self.predicate_may_hold(&new_obligation) {\n                         let sp = self.tcx.sess.source_map()\n@@ -1105,6 +1112,77 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         }\n     }\n \n+    /// Check if the trait bound is implemented for a different mutability and note it in the\n+    /// final error.\n+    fn suggest_change_mut(\n+        &self,\n+        obligation: &PredicateObligation<'tcx>,\n+        err: &mut DiagnosticBuilder<'tcx>,\n+        trait_ref: &ty::Binder<ty::TraitRef<'tcx>>,\n+        points_at_arg: bool,\n+    ) {\n+        let span = obligation.cause.span;\n+        if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(span) {\n+            let refs_number = snippet.chars()\n+                .filter(|c| !c.is_whitespace())\n+                .take_while(|c| *c == '&')\n+                .count();\n+            if let Some('\\'') = snippet.chars()\n+                .filter(|c| !c.is_whitespace())\n+                .skip(refs_number)\n+                .next()\n+            { // Do not suggest removal of borrow from type arguments.\n+                return;\n+            }\n+            let trait_ref = self.resolve_vars_if_possible(trait_ref);\n+            if trait_ref.has_infer_types() {\n+                // Do not ICE while trying to find if a reborrow would succeed on a trait with\n+                // unresolved bindings.\n+                return;\n+            }\n+\n+            if let ty::Ref(region, t_type, mutability) = trait_ref.skip_binder().self_ty().kind {\n+                let trait_type = match mutability {\n+                    hir::Mutability::MutMutable => self.tcx.mk_imm_ref(region, t_type),\n+                    hir::Mutability::MutImmutable => self.tcx.mk_mut_ref(region, t_type),\n+                };\n+\n+                let substs = self.tcx.mk_substs_trait(&trait_type, &[]);\n+                let new_trait_ref = ty::TraitRef::new(trait_ref.skip_binder().def_id, substs);\n+                let new_obligation = Obligation::new(\n+                    ObligationCause::dummy(),\n+                    obligation.param_env,\n+                    new_trait_ref.to_predicate(),\n+                );\n+\n+                if self.evaluate_obligation_no_overflow(\n+                    &new_obligation,\n+                ).must_apply_modulo_regions() {\n+                    let sp = self.tcx.sess.source_map()\n+                        .span_take_while(span, |c| c.is_whitespace() || *c == '&');\n+                    if points_at_arg &&\n+                        mutability == hir::Mutability::MutImmutable &&\n+                        refs_number > 0\n+                    {\n+                        err.span_suggestion(\n+                            sp,\n+                            \"consider changing this borrow's mutability\",\n+                            \"&mut \".to_string(),\n+                            Applicability::MachineApplicable,\n+                        );\n+                    } else {\n+                        err.note(&format!(\n+                            \"`{}` is implemented for `{:?}`, but not for `{:?}`\",\n+                            trait_ref,\n+                            trait_type,\n+                            trait_ref.skip_binder().self_ty(),\n+                        ));\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n     fn suggest_semicolon_removal(\n         &self,\n         obligation: &PredicateObligation<'tcx>,"}, {"sha": "0d426cab9b751381f3106051b92e97ca269acdc2", "filename": "src/librustc/traits/query/evaluate_obligation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ee24f6ee04c1dc42ddcd99c57bb0a7a15df1309/src%2Flibrustc%2Ftraits%2Fquery%2Fevaluate_obligation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ee24f6ee04c1dc42ddcd99c57bb0a7a15df1309/src%2Flibrustc%2Ftraits%2Fquery%2Fevaluate_obligation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fevaluate_obligation.rs?ref=8ee24f6ee04c1dc42ddcd99c57bb0a7a15df1309", "patch": "@@ -56,7 +56,7 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n     // Helper function that canonicalizes and runs the query. If an\n     // overflow results, we re-run it in the local context so we can\n     // report a nice error.\n-    fn evaluate_obligation_no_overflow(\n+    crate fn evaluate_obligation_no_overflow(\n         &self,\n         obligation: &PredicateObligation<'tcx>,\n     ) -> EvaluationResult {"}, {"sha": "434ead50e0423817e0e7bf1b8eadcc99587d6620", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 40, "deletions": 24, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/8ee24f6ee04c1dc42ddcd99c57bb0a7a15df1309/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ee24f6ee04c1dc42ddcd99c57bb0a7a15df1309/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=8ee24f6ee04c1dc42ddcd99c57bb0a7a15df1309", "patch": "@@ -58,7 +58,7 @@ pub enum MethodError<'tcx> {\n \n     // Found a `Self: Sized` bound where `Self` is a trait object, also the caller may have\n     // forgotten to import a trait.\n-    IllegalSizedBound(Vec<DefId>),\n+    IllegalSizedBound(Vec<DefId>, bool),\n \n     // Found a match, but the return type is wrong\n     BadReturnType,\n@@ -213,33 +213,49 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             segment,\n         );\n \n+        let mut needs_mut = false;\n+        if let ty::Ref(region, t_type, mutability) = self_ty.kind {\n+            let trait_type = self.tcx.mk_ref(region, ty::TypeAndMut {\n+                ty: t_type,\n+                mutbl: mutability.invert(),\n+            });\n+            match self.lookup_probe(\n+                span,\n+                segment.ident,\n+                trait_type,\n+                call_expr,\n+                ProbeScope::TraitsInScope\n+            ) {\n+                Ok(ref new_pick) if *new_pick != pick => {\n+                    needs_mut = true;\n+                }\n+                _ => {}\n+            }\n+        }\n+\n         if result.illegal_sized_bound {\n             // We probe again, taking all traits into account (not only those in scope).\n-            let candidates =\n-                match self.lookup_probe(span,\n-                                        segment.ident,\n-                                        self_ty,\n-                                        call_expr,\n-                                        ProbeScope::AllTraits) {\n-\n-                    // If we find a different result the caller probably forgot to import a trait.\n-                    Ok(ref new_pick) if *new_pick != pick => vec![new_pick.item.container.id()],\n-                    Err(Ambiguity(ref sources)) => {\n-                        sources.iter()\n-                               .filter_map(|source| {\n-                                   match *source {\n-                                       // Note: this cannot come from an inherent impl,\n-                                       // because the first probing succeeded.\n-                                       ImplSource(def) => self.tcx.trait_id_of_impl(def),\n-                                       TraitSource(_) => None,\n-                                   }\n-                               })\n-                               .collect()\n+            let candidates = match self.lookup_probe(\n+                span,\n+                segment.ident,\n+                self_ty,\n+                call_expr,\n+                ProbeScope::AllTraits,\n+            ) {\n+                // If we find a different result the caller probably forgot to import a trait.\n+                Ok(ref new_pick) if *new_pick != pick => vec![new_pick.item.container.id()],\n+                Err(Ambiguity(ref sources)) => sources.iter().filter_map(|source| {\n+                    match *source {\n+                        // Note: this cannot come from an inherent impl,\n+                        // because the first probing succeeded.\n+                        ImplSource(def) => self.tcx.trait_id_of_impl(def),\n+                        TraitSource(_) => None,\n                     }\n-                    _ => Vec::new(),\n-                };\n+                }).collect(),\n+                _ => Vec::new(),\n+            };\n \n-            return Err(IllegalSizedBound(candidates));\n+            return Err(IllegalSizedBound(candidates, needs_mut));\n         }\n \n         Ok(result.callee)"}, {"sha": "ebeb9ba25c6cb523a504d2da243b2cf373a0aa87", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 22, "deletions": 11, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/8ee24f6ee04c1dc42ddcd99c57bb0a7a15df1309/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ee24f6ee04c1dc42ddcd99c57bb0a7a15df1309/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=8ee24f6ee04c1dc42ddcd99c57bb0a7a15df1309", "patch": "@@ -593,22 +593,33 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 err.emit();\n             }\n \n-            MethodError::IllegalSizedBound(candidates) => {\n+            MethodError::IllegalSizedBound(candidates, needs_mut) => {\n                 let msg = format!(\"the `{}` method cannot be invoked on a trait object\", item_name);\n                 let mut err = self.sess().struct_span_err(span, &msg);\n                 if !candidates.is_empty() {\n-                    let help = format!(\"{an}other candidate{s} {were} found in the following \\\n-                                        trait{s}, perhaps add a `use` for {one_of_them}:\",\n-                                    an = if candidates.len() == 1 {\"an\" } else { \"\" },\n-                                    s = pluralise!(candidates.len()),\n-                                    were = if candidates.len() == 1 { \"was\" } else { \"were\" },\n-                                    one_of_them = if candidates.len() == 1 {\n-                                        \"it\"\n-                                    } else {\n-                                        \"one_of_them\"\n-                                    });\n+                    let help = format!(\n+                        \"{an}other candidate{s} {were} found in the following trait{s}, perhaps \\\n+                         add a `use` for {one_of_them}:\",\n+                        an = if candidates.len() == 1 {\"an\" } else { \"\" },\n+                        s = pluralise!(candidates.len()),\n+                        were = if candidates.len() == 1 { \"was\" } else { \"were\" },\n+                        one_of_them = if candidates.len() == 1 {\n+                            \"it\"\n+                        } else {\n+                            \"one_of_them\"\n+                        },\n+                    );\n                     self.suggest_use_candidates(&mut err, help, candidates);\n                 }\n+                if let ty::Ref(region, t_type, mutability) = rcvr_ty.kind {\n+                    if needs_mut {\n+                        let trait_type = self.tcx.mk_ref(region, ty::TypeAndMut {\n+                            ty: t_type,\n+                            mutbl: mutability.invert(),\n+                        });\n+                        err.note(&format!(\"you need `{}` instead of `{}`\", trait_type, rcvr_ty));\n+                    }\n+                }\n                 err.emit();\n             }\n "}, {"sha": "2362ccd32de994d0239ba0ce9ac3a336273d7a09", "filename": "src/test/ui/not-panic/not-panic-safe.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8ee24f6ee04c1dc42ddcd99c57bb0a7a15df1309/src%2Ftest%2Fui%2Fnot-panic%2Fnot-panic-safe.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8ee24f6ee04c1dc42ddcd99c57bb0a7a15df1309/src%2Ftest%2Fui%2Fnot-panic%2Fnot-panic-safe.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnot-panic%2Fnot-panic-safe.stderr?ref=8ee24f6ee04c1dc42ddcd99c57bb0a7a15df1309", "patch": "@@ -8,6 +8,7 @@ LL |     assert::<&mut i32>();\n    |     ^^^^^^^^^^^^^^^^^^ `&mut i32` may not be safely transferred across an unwind boundary\n    |\n    = help: the trait `std::panic::UnwindSafe` is not implemented for `&mut i32`\n+   = note: `std::panic::UnwindSafe` is implemented for `&i32`, but not for `&mut i32`\n \n error: aborting due to previous error\n "}, {"sha": "22ca6dde45eee1eac39177ce95cffd5fc5081389", "filename": "src/test/ui/suggestions/imm-ref-trait-object-literal.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8ee24f6ee04c1dc42ddcd99c57bb0a7a15df1309/src%2Ftest%2Fui%2Fsuggestions%2Fimm-ref-trait-object-literal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ee24f6ee04c1dc42ddcd99c57bb0a7a15df1309/src%2Ftest%2Fui%2Fsuggestions%2Fimm-ref-trait-object-literal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fimm-ref-trait-object-literal.rs?ref=8ee24f6ee04c1dc42ddcd99c57bb0a7a15df1309", "patch": "@@ -0,0 +1,14 @@\n+trait Trait {}\n+\n+struct S;\n+\n+impl<'a> Trait for &'a mut S {}\n+\n+fn foo<X: Trait>(_: X) {}\n+\n+\n+fn main() {\n+  let s = S;\n+  foo(&s); //~ ERROR the trait bound `&S: Trait` is not satisfied\n+  foo(s); //~ ERROR the trait bound `S: Trait` is not satisfied\n+}"}, {"sha": "ccaceefacd739649761db3181773aac6c8c199c3", "filename": "src/test/ui/suggestions/imm-ref-trait-object-literal.stderr", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/8ee24f6ee04c1dc42ddcd99c57bb0a7a15df1309/src%2Ftest%2Fui%2Fsuggestions%2Fimm-ref-trait-object-literal.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8ee24f6ee04c1dc42ddcd99c57bb0a7a15df1309/src%2Ftest%2Fui%2Fsuggestions%2Fimm-ref-trait-object-literal.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fimm-ref-trait-object-literal.stderr?ref=8ee24f6ee04c1dc42ddcd99c57bb0a7a15df1309", "patch": "@@ -0,0 +1,30 @@\n+error[E0277]: the trait bound `&S: Trait` is not satisfied\n+  --> $DIR/imm-ref-trait-object-literal.rs:12:7\n+   |\n+LL | fn foo<X: Trait>(_: X) {}\n+   |    ---    ----- required by this bound in `foo`\n+...\n+LL |   foo(&s);\n+   |       -^\n+   |       |\n+   |       the trait `Trait` is not implemented for `&S`\n+   |       help: consider changing this borrow's mutability: `&mut`\n+   |\n+   = help: the following implementations were found:\n+             <&'a mut S as Trait>\n+\n+error[E0277]: the trait bound `S: Trait` is not satisfied\n+  --> $DIR/imm-ref-trait-object-literal.rs:13:7\n+   |\n+LL | fn foo<X: Trait>(_: X) {}\n+   |    ---    ----- required by this bound in `foo`\n+...\n+LL |   foo(s);\n+   |       ^ the trait `Trait` is not implemented for `S`\n+   |\n+   = help: the following implementations were found:\n+             <&'a mut S as Trait>\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "288d6c699f59a03a38335fea9aef48938e33288b", "filename": "src/test/ui/suggestions/imm-ref-trait-object.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8ee24f6ee04c1dc42ddcd99c57bb0a7a15df1309/src%2Ftest%2Fui%2Fsuggestions%2Fimm-ref-trait-object.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ee24f6ee04c1dc42ddcd99c57bb0a7a15df1309/src%2Ftest%2Fui%2Fsuggestions%2Fimm-ref-trait-object.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fimm-ref-trait-object.rs?ref=8ee24f6ee04c1dc42ddcd99c57bb0a7a15df1309", "patch": "@@ -0,0 +1,8 @@\n+fn test(t: &dyn Iterator<Item=&u64>) -> u64 {\n+     t.min().unwrap() //~ ERROR the `min` method cannot be invoked on a trait object\n+}\n+\n+fn main() {\n+     let array = [0u64];\n+     test(&mut array.iter());\n+}"}, {"sha": "9185eaa65c06d02a7f186b5a6604108614248105", "filename": "src/test/ui/suggestions/imm-ref-trait-object.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8ee24f6ee04c1dc42ddcd99c57bb0a7a15df1309/src%2Ftest%2Fui%2Fsuggestions%2Fimm-ref-trait-object.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8ee24f6ee04c1dc42ddcd99c57bb0a7a15df1309/src%2Ftest%2Fui%2Fsuggestions%2Fimm-ref-trait-object.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fimm-ref-trait-object.stderr?ref=8ee24f6ee04c1dc42ddcd99c57bb0a7a15df1309", "patch": "@@ -0,0 +1,10 @@\n+error: the `min` method cannot be invoked on a trait object\n+  --> $DIR/imm-ref-trait-object.rs:2:8\n+   |\n+LL |      t.min().unwrap()\n+   |        ^^^\n+   |\n+   = note: you need `&mut dyn std::iter::Iterator<Item = &u64>` instead of `&dyn std::iter::Iterator<Item = &u64>`\n+\n+error: aborting due to previous error\n+"}, {"sha": "a1e1f4d13572a703736c33b7dbf8cdb5d53bfff4", "filename": "src/test/ui/suggestions/into-str.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8ee24f6ee04c1dc42ddcd99c57bb0a7a15df1309/src%2Ftest%2Fui%2Fsuggestions%2Finto-str.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8ee24f6ee04c1dc42ddcd99c57bb0a7a15df1309/src%2Ftest%2Fui%2Fsuggestions%2Finto-str.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Finto-str.stderr?ref=8ee24f6ee04c1dc42ddcd99c57bb0a7a15df1309", "patch": "@@ -8,6 +8,7 @@ LL |     foo(String::new());\n    |     ^^^ the trait `std::convert::From<std::string::String>` is not implemented for `&str`\n    |\n    = note: to coerce a `std::string::String` into a `&str`, use `&*` as a prefix\n+   = note: `std::convert::From<std::string::String>` is implemented for `&mut str`, but not for `&str`\n    = note: required because of the requirements on the impl of `std::convert::Into<&str>` for `std::string::String`\n \n error: aborting due to previous error"}, {"sha": "dcef2ada63beac30a15d76f58ef2f085acf908b2", "filename": "src/test/ui/suggestions/mut-borrow-needed-by-trait.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/8ee24f6ee04c1dc42ddcd99c57bb0a7a15df1309/src%2Ftest%2Fui%2Fsuggestions%2Fmut-borrow-needed-by-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ee24f6ee04c1dc42ddcd99c57bb0a7a15df1309/src%2Ftest%2Fui%2Fsuggestions%2Fmut-borrow-needed-by-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fmut-borrow-needed-by-trait.rs?ref=8ee24f6ee04c1dc42ddcd99c57bb0a7a15df1309", "patch": "@@ -0,0 +1,23 @@\n+use std::env::args;\n+use std::fs::File;\n+use std::io::{stdout, Write, BufWriter};\n+\n+fn main() {\n+    let mut args = args();\n+    let _ = args.next();\n+    let dest = args.next();\n+\n+    let h1; let h2; let h3;\n+\n+    let fp: &dyn Write = match dest {\n+        Some(path) => { h1 = File::create(path).unwrap(); &h1 },\n+        None => { h2 = stdout(); h3 = h2.lock(); &h3 }\n+    };\n+\n+    let fp = BufWriter::new(fp);\n+    //~^ ERROR the trait bound `&dyn std::io::Write: std::io::Write` is not satisfied\n+    //~| ERROR the trait bound `&dyn std::io::Write: std::io::Write` is not satisfied\n+    //~| ERROR the trait bound `&dyn std::io::Write: std::io::Write` is not satisfied\n+\n+    writeln!(fp, \"hello world\").unwrap(); //~ ERROR no method named `write_fmt` found for type\n+}"}, {"sha": "daa8e1162d197a54187ab4c548351cff66f93928", "filename": "src/test/ui/suggestions/mut-borrow-needed-by-trait.stderr", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/8ee24f6ee04c1dc42ddcd99c57bb0a7a15df1309/src%2Ftest%2Fui%2Fsuggestions%2Fmut-borrow-needed-by-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8ee24f6ee04c1dc42ddcd99c57bb0a7a15df1309/src%2Ftest%2Fui%2Fsuggestions%2Fmut-borrow-needed-by-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fmut-borrow-needed-by-trait.stderr?ref=8ee24f6ee04c1dc42ddcd99c57bb0a7a15df1309", "patch": "@@ -0,0 +1,41 @@\n+error[E0277]: the trait bound `&dyn std::io::Write: std::io::Write` is not satisfied\n+  --> $DIR/mut-borrow-needed-by-trait.rs:17:29\n+   |\n+LL |     let fp = BufWriter::new(fp);\n+   |                             ^^ the trait `std::io::Write` is not implemented for `&dyn std::io::Write`\n+   |\n+   = note: `std::io::Write` is implemented for `&mut dyn std::io::Write`, but not for `&dyn std::io::Write`\n+   = note: required by `std::io::BufWriter::<W>::new`\n+\n+error[E0277]: the trait bound `&dyn std::io::Write: std::io::Write` is not satisfied\n+  --> $DIR/mut-borrow-needed-by-trait.rs:17:14\n+   |\n+LL |     let fp = BufWriter::new(fp);\n+   |              ^^^^^^^^^^^^^^ the trait `std::io::Write` is not implemented for `&dyn std::io::Write`\n+   |\n+   = note: `std::io::Write` is implemented for `&mut dyn std::io::Write`, but not for `&dyn std::io::Write`\n+   = note: required by `std::io::BufWriter`\n+\n+error[E0277]: the trait bound `&dyn std::io::Write: std::io::Write` is not satisfied\n+  --> $DIR/mut-borrow-needed-by-trait.rs:17:14\n+   |\n+LL |     let fp = BufWriter::new(fp);\n+   |              ^^^^^^^^^^^^^^^^^^ the trait `std::io::Write` is not implemented for `&dyn std::io::Write`\n+   |\n+   = note: `std::io::Write` is implemented for `&mut dyn std::io::Write`, but not for `&dyn std::io::Write`\n+   = note: required by `std::io::BufWriter`\n+\n+error[E0599]: no method named `write_fmt` found for type `std::io::BufWriter<&dyn std::io::Write>` in the current scope\n+  --> $DIR/mut-borrow-needed-by-trait.rs:22:5\n+   |\n+LL |     writeln!(fp, \"hello world\").unwrap();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ method not found in `std::io::BufWriter<&dyn std::io::Write>`\n+   |\n+   = note: the method `write_fmt` exists but the following trait bounds were not satisfied:\n+           `std::io::BufWriter<&dyn std::io::Write> : std::io::Write`\n+   = note: this error originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n+\n+error: aborting due to 4 previous errors\n+\n+Some errors have detailed explanations: E0277, E0599.\n+For more information about an error, try `rustc --explain E0277`."}]}