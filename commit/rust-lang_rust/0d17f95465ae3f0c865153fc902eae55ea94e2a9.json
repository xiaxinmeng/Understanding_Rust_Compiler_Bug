{"sha": "0d17f95465ae3f0c865153fc902eae55ea94e2a9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBkMTdmOTU0NjVhZTNmMGM4NjUxNTNmYzkwMmVhZTU1ZWE5NGUyYTk=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-03-07T19:08:21Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-03-13T15:22:08Z"}, "message": "short-circuit work when instantiating query responses\n\nAlso, perform substitution in smaller parts.", "tree": {"sha": "5741ea7547ee1f1a4abeef577aab1d72686e8e23", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5741ea7547ee1f1a4abeef577aab1d72686e8e23"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0d17f95465ae3f0c865153fc902eae55ea94e2a9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0d17f95465ae3f0c865153fc902eae55ea94e2a9", "html_url": "https://github.com/rust-lang/rust/commit/0d17f95465ae3f0c865153fc902eae55ea94e2a9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0d17f95465ae3f0c865153fc902eae55ea94e2a9/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "03c5428be37eedd09f1f3b627c03c3de1beb0674", "url": "https://api.github.com/repos/rust-lang/rust/commits/03c5428be37eedd09f1f3b627c03c3de1beb0674", "html_url": "https://github.com/rust-lang/rust/commit/03c5428be37eedd09f1f3b627c03c3de1beb0674"}], "stats": {"total": 108, "additions": 84, "deletions": 24}, "files": [{"sha": "83194b5e504e5f878b91b4709dcc8dc739095ae9", "filename": "src/librustc/infer/canonical.rs", "status": "modified", "additions": 84, "deletions": 24, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/0d17f95465ae3f0c865153fc902eae55ea94e2a9/src%2Flibrustc%2Finfer%2Fcanonical.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d17f95465ae3f0c865153fc902eae55ea94e2a9/src%2Flibrustc%2Finfer%2Fcanonical.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical.rs?ref=0d17f95465ae3f0c865153fc902eae55ea94e2a9", "patch": "@@ -29,6 +29,7 @@\n use infer::{InferCtxt, InferOk, InferResult, RegionVariableOrigin, TypeVariableOrigin};\n use rustc_data_structures::indexed_vec::Idx;\n use std::fmt::Debug;\n+use std::ops::Index;\n use syntax::codemap::Span;\n use traits::{Obligation, ObligationCause, PredicateObligation};\n use ty::{self, CanonicalVar, Lift, Region, Slice, Ty, TyCtxt, TypeFlags};\n@@ -395,28 +396,27 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n                 .collect(),\n         };\n \n-        // Apply the result substitution to the query.\n-        let QueryResult {\n-            var_values: query_values,\n-            region_constraints: query_region_constraints,\n-            certainty: _,\n-            value: user_result,\n-        } = query_result.substitute(self.tcx, result_subst);\n-\n         // Unify the original values for the canonical variables in\n         // the input with the value found in the query\n         // post-substitution. Often, but not always, this is a no-op,\n         // because we already found the mapping in the first step.\n+        let substituted_values = |index: CanonicalVar| -> Kind<'tcx> {\n+            query_result.substitute_projected(self.tcx, result_subst, |v| &v.var_values[index])\n+        };\n         let mut obligations =\n-            self.unify_canonical_vars(cause, param_env, original_values, &query_values)?\n+            self.unify_canonical_vars(cause, param_env, original_values, substituted_values)?\n                 .into_obligations();\n \n         obligations.extend(self.query_region_constraints_into_obligations(\n             cause,\n             param_env,\n-            query_region_constraints,\n+            &query_result.value.region_constraints,\n+            result_subst,\n         ));\n \n+        let user_result: R =\n+            query_result.substitute_projected(self.tcx, result_subst, |q_r| &q_r.value);\n+\n         Ok(InferOk {\n             value: user_result,\n             obligations,\n@@ -426,25 +426,30 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n     /// Converts the region constraints resulting from a query into an\n     /// iterator of obligations.\n     fn query_region_constraints_into_obligations<'a>(\n-        &self,\n+        &'a self,\n         cause: &'a ObligationCause<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n-        query_region_constraints: QueryRegionConstraints<'tcx>,\n+        unsubstituted_region_constraints: &'a QueryRegionConstraints<'tcx>,\n+        result_subst: &'a CanonicalVarValues<'tcx>,\n     ) -> impl Iterator<Item = PredicateObligation<'tcx>> + 'a {\n         let QueryRegionConstraints {\n             region_outlives,\n             ty_outlives,\n-        } = query_region_constraints;\n+        } = unsubstituted_region_constraints;\n \n-        let region_obligations = region_outlives.into_iter().map(move |(r1, r2)| {\n+        let region_obligations = region_outlives.iter().map(move |(r1, r2)| {\n+            let r1 = substitute_value(self.tcx, result_subst, r1);\n+            let r2 = substitute_value(self.tcx, result_subst, r2);\n             Obligation::new(\n                 cause.clone(),\n                 param_env,\n                 ty::Predicate::RegionOutlives(ty::Binder(ty::OutlivesPredicate(r1, r2))),\n             )\n         });\n \n-        let ty_obligations = ty_outlives.into_iter().map(move |(t1, r2)| {\n+        let ty_obligations = ty_outlives.iter().map(move |(t1, r2)| {\n+            let t1 = substitute_value(self.tcx, result_subst, t1);\n+            let r2 = substitute_value(self.tcx, result_subst, r2);\n             Obligation::new(\n                 cause.clone(),\n                 param_env,\n@@ -456,17 +461,19 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n     }\n \n     /// Given two sets of values for the same set of canonical variables, unify them.\n-    pub fn unify_canonical_vars(\n+    /// The second set is produced lazilly by supplying indices from the first set.\n+    fn unify_canonical_vars(\n         &self,\n         cause: &ObligationCause<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n         variables1: &CanonicalVarValues<'tcx>,\n-        variables2: &CanonicalVarValues<'tcx>,\n+        variables2: impl Fn(CanonicalVar) -> Kind<'tcx>,\n     ) -> InferResult<'tcx, ()> {\n-        assert_eq!(variables1.var_values.len(), variables2.var_values.len());\n         self.commit_if_ok(|_| {\n             let mut obligations = vec![];\n-            for (value1, value2) in variables1.var_values.iter().zip(&variables2.var_values) {\n+            for (index, value1) in variables1.var_values.iter_enumerated() {\n+                let value2 = variables2(index);\n+\n                 match (value1.unpack(), value2.unpack()) {\n                     (UnpackedKind::Type(v1), UnpackedKind::Type(v2)) => {\n                         obligations\n@@ -724,7 +731,9 @@ impl<'cx, 'gcx, 'tcx> Canonicalizer<'cx, 'gcx, 'tcx> {\n                     value: out_value,\n                 },\n             );\n-            let values = CanonicalVarValues { var_values: IndexVec::default() };\n+            let values = CanonicalVarValues {\n+                var_values: IndexVec::default(),\n+            };\n             return (canon_value, values);\n         }\n \n@@ -810,13 +819,50 @@ impl<'cx, 'gcx, 'tcx> Canonicalizer<'cx, 'gcx, 'tcx> {\n impl<'tcx, V> Canonical<'tcx, V> {\n     /// Instantiate the wrapped value, replacing each canonical value\n     /// with the value given in `var_values`.\n-    pub fn substitute(&self, tcx: TyCtxt<'_, '_, 'tcx>, var_values: &CanonicalVarValues<'tcx>) -> V\n+    fn substitute(&self, tcx: TyCtxt<'_, '_, 'tcx>, var_values: &CanonicalVarValues<'tcx>) -> V\n     where\n         V: TypeFoldable<'tcx>,\n+    {\n+        self.substitute_projected(tcx, var_values, |value| value)\n+    }\n+\n+    /// Invoke `projection_fn` with `self.value` to get a value V that\n+    /// is expressed in terms of the same canonical variables bound in\n+    /// `self`. Apply the substitution `var_values` to this value V,\n+    /// replacing each of the canonical variables.\n+    fn substitute_projected<T>(\n+        &self,\n+        tcx: TyCtxt<'_, '_, 'tcx>,\n+        var_values: &CanonicalVarValues<'tcx>,\n+        projection_fn: impl FnOnce(&V) -> &T,\n+    ) -> T\n+    where\n+        T: TypeFoldable<'tcx>,\n     {\n         assert_eq!(self.variables.len(), var_values.var_values.len());\n-        self.value\n-            .fold_with(&mut CanonicalVarValuesSubst { tcx, var_values })\n+        let value = projection_fn(&self.value);\n+        substitute_value(tcx, var_values, value)\n+    }\n+}\n+\n+/// Substitute the values from `var_values` into `value`. `var_values`\n+/// must be values for the set of cnaonical variables that appear in\n+/// `value`.\n+fn substitute_value<'a, 'tcx, T>(\n+    tcx: TyCtxt<'_, '_, 'tcx>,\n+    var_values: &CanonicalVarValues<'tcx>,\n+    value: &'a T,\n+) -> T\n+where\n+    T: TypeFoldable<'tcx>,\n+{\n+    if var_values.var_values.is_empty() {\n+        debug_assert!(!value.has_type_flags(TypeFlags::HAS_CANONICAL_VARS));\n+        value.clone()\n+    } else if !value.has_type_flags(TypeFlags::HAS_CANONICAL_VARS) {\n+        value.clone()\n+    } else {\n+        value.fold_with(&mut CanonicalVarValuesSubst { tcx, var_values })\n     }\n }\n \n@@ -838,7 +884,13 @@ impl<'cx, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for CanonicalVarValuesSubst<'cx, 'g\n                     r => bug!(\"{:?} is a type but value is {:?}\", c, r),\n                 }\n             }\n-            _ => t.super_fold_with(self),\n+            _ => {\n+                if !t.has_type_flags(TypeFlags::HAS_CANONICAL_VARS) {\n+                    t\n+                } else {\n+                    t.super_fold_with(self)\n+                }\n+            }\n         }\n     }\n \n@@ -926,3 +978,11 @@ BraceStructLiftImpl! {\n         var_values, region_constraints, certainty, value\n     } where R: Lift<'tcx>\n }\n+\n+impl<'tcx> Index<CanonicalVar> for CanonicalVarValues<'tcx> {\n+    type Output = Kind<'tcx>;\n+\n+    fn index(&self, value: CanonicalVar) -> &Kind<'tcx> {\n+        &self.var_values[value]\n+    }\n+}"}]}