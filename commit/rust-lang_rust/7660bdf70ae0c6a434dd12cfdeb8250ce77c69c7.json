{"sha": "7660bdf70ae0c6a434dd12cfdeb8250ce77c69c7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc2NjBiZGY3MGFlMGM2YTQzNGRkMTJjZmRlYjgyNTBjZTc3YzY5Yzc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-09-30T03:25:45Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-09-30T03:25:45Z"}, "message": "Auto merge of #36557 - sfackler:fix-hashdos-docs, r=alexcrichton\n\nClean up hasher discussion on HashMap\n\n* We never want to make guarantees about protecting against attacks.\n* \"True randomness\" is not the right terminology to be using in this\n    context.\n* There is significantly more nuance to the performance of SipHash than\n    \"somewhat slow\".\n\nr? @steveklabnik\n\nFollow up to discussion on #35371", "tree": {"sha": "725f98bad1bc54447a28f5a1172f6e042dba8eef", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/725f98bad1bc54447a28f5a1172f6e042dba8eef"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7660bdf70ae0c6a434dd12cfdeb8250ce77c69c7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7660bdf70ae0c6a434dd12cfdeb8250ce77c69c7", "html_url": "https://github.com/rust-lang/rust/commit/7660bdf70ae0c6a434dd12cfdeb8250ce77c69c7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7660bdf70ae0c6a434dd12cfdeb8250ce77c69c7/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c717cfa7c1640a65ea9198e52265a3bc12449b88", "url": "https://api.github.com/repos/rust-lang/rust/commits/c717cfa7c1640a65ea9198e52265a3bc12449b88", "html_url": "https://github.com/rust-lang/rust/commit/c717cfa7c1640a65ea9198e52265a3bc12449b88"}, {"sha": "aaf32aa4fe97d3050a63c231d2cb2df14360a281", "url": "https://api.github.com/repos/rust-lang/rust/commits/aaf32aa4fe97d3050a63c231d2cb2df14360a281", "html_url": "https://github.com/rust-lang/rust/commit/aaf32aa4fe97d3050a63c231d2cb2df14360a281"}], "stats": {"total": 30, "additions": 22, "deletions": 8}, "files": [{"sha": "2ea0320d1f13f8d54fe676fff0f927f51a43c3fc", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 22, "deletions": 8, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/7660bdf70ae0c6a434dd12cfdeb8250ce77c69c7/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7660bdf70ae0c6a434dd12cfdeb8250ce77c69c7/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=7660bdf70ae0c6a434dd12cfdeb8250ce77c69c7", "patch": "@@ -196,15 +196,29 @@ fn test_resize_policy() {\n //\n // FIXME(Gankro, pczarn): review the proof and put it all in a separate README.md\n \n-/// A hash map implementation which uses linear probing with Robin\n-/// Hood bucket stealing.\n+/// A hash map implementation which uses linear probing with Robin Hood bucket\n+/// stealing.\n ///\n-/// By default, HashMap uses a somewhat slow hashing algorithm which can provide resistance\n-/// to DoS attacks. Rust makes a best attempt at acquiring random numbers without IO\n-/// blocking from your system. Because of this HashMap is not guaranteed to provide\n-/// DoS resistance since the numbers generated might not be truly random. If you do\n-/// require this behavior you can create your own hashing function using\n-/// [BuildHasherDefault](../hash/struct.BuildHasherDefault.html).\n+/// By default, `HashMap` uses a hashing algorithm selected to provide\n+/// resistance against HashDoS attacks. The algorithm is randomly seeded, and a\n+/// reasonable best-effort is made to generate this seed from a high quality,\n+/// secure source of randomness provided by the host without blocking the\n+/// program. Because of this, the randomness of the seed is dependant on the\n+/// quality of the system's random number generator at the time it is created.\n+/// In particular, seeds generated when the system's entropy pool is abnormally\n+/// low such as during system boot may be of a lower quality.\n+///\n+/// The default hashing algorithm is currently SipHash 1-3, though this is\n+/// subject to change at any point in the future. While its performance is very\n+/// competitive for medium sized keys, other hashing algorithms will outperform\n+/// it for small keys such as integers as well as large keys such as long\n+/// strings, though those algorithms will typically *not* protect against\n+/// attacks such as HashDoS.\n+///\n+/// The hashing algorithm can be replaced on a per-`HashMap` basis using the\n+/// `HashMap::default`, `HashMap::with_hasher`, and\n+/// `HashMap::with_capacity_and_hasher` methods. Many alternative algorithms\n+/// are available on crates.io, such as the `fnv` crate.\n ///\n /// It is required that the keys implement the [`Eq`] and [`Hash`] traits, although\n /// this can frequently be achieved by using `#[derive(PartialEq, Eq, Hash)]`."}]}