{"sha": "31f282636bb1b1d701d41f7c7fedb11a5511cabd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMxZjI4MjYzNmJiMWIxZDcwMWQ0MWY3YzdmZWRiMTFhNTUxMWNhYmQ=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-06-02T14:30:26Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-06-02T14:30:47Z"}, "message": "Minor", "tree": {"sha": "0c9581f425b6bf38b79a7f0adfb090adef716461", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0c9581f425b6bf38b79a7f0adfb090adef716461"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/31f282636bb1b1d701d41f7c7fedb11a5511cabd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/31f282636bb1b1d701d41f7c7fedb11a5511cabd", "html_url": "https://github.com/rust-lang/rust/commit/31f282636bb1b1d701d41f7c7fedb11a5511cabd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/31f282636bb1b1d701d41f7c7fedb11a5511cabd/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "61e8f392191037acefddc5793e814f93d01b114a", "url": "https://api.github.com/repos/rust-lang/rust/commits/61e8f392191037acefddc5793e814f93d01b114a", "html_url": "https://github.com/rust-lang/rust/commit/61e8f392191037acefddc5793e814f93d01b114a"}], "stats": {"total": 249, "additions": 125, "deletions": 124}, "files": [{"sha": "008518a089ffde0b43e6c13ad7b4d14f862280ba", "filename": "crates/rust-analyzer/src/cargo_target_spec.rs", "status": "modified", "additions": 80, "deletions": 5, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/31f282636bb1b1d701d41f7c7fedb11a5511cabd/crates%2Frust-analyzer%2Fsrc%2Fcargo_target_spec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31f282636bb1b1d701d41f7c7fedb11a5511cabd/crates%2Frust-analyzer%2Fsrc%2Fcargo_target_spec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fcargo_target_spec.rs?ref=31f282636bb1b1d701d41f7c7fedb11a5511cabd", "patch": "@@ -1,10 +1,10 @@\n //! See `CargoTargetSpec`\n \n+use ra_cfg::CfgExpr;\n use ra_ide::{FileId, RunnableKind, TestId};\n use ra_project_model::{self, ProjectWorkspace, TargetKind};\n \n use crate::{world::WorldSnapshot, Result};\n-use ra_syntax::SmolStr;\n \n /// Abstract representation of Cargo target.\n ///\n@@ -21,7 +21,7 @@ impl CargoTargetSpec {\n     pub(crate) fn runnable_args(\n         spec: Option<CargoTargetSpec>,\n         kind: &RunnableKind,\n-        features_needed: &Vec<SmolStr>,\n+        cfgs: &[CfgExpr],\n     ) -> Result<(Vec<String>, Vec<String>)> {\n         let mut args = Vec::new();\n         let mut extra_args = Vec::new();\n@@ -76,10 +76,14 @@ impl CargoTargetSpec {\n             }\n         }\n \n-        features_needed.iter().for_each(|feature| {\n+        let mut features = Vec::new();\n+        for cfg in cfgs {\n+            required_features(cfg, &mut features);\n+        }\n+        for feature in features {\n             args.push(\"--features\".to_string());\n-            args.push(feature.to_string());\n-        });\n+            args.push(feature);\n+        }\n \n         Ok((args, extra_args))\n     }\n@@ -140,3 +144,74 @@ impl CargoTargetSpec {\n         }\n     }\n }\n+\n+/// Fill minimal features needed\n+fn required_features(cfg_expr: &CfgExpr, features: &mut Vec<String>) {\n+    match cfg_expr {\n+        CfgExpr::KeyValue { key, value } if key == \"feature\" => features.push(value.to_string()),\n+        CfgExpr::All(preds) => {\n+            preds.iter().for_each(|cfg| required_features(cfg, features));\n+        }\n+        CfgExpr::Any(preds) => {\n+            for cfg in preds {\n+                let len_features = features.len();\n+                required_features(cfg, features);\n+                if len_features != features.len() {\n+                    break;\n+                }\n+            }\n+        }\n+        _ => {}\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+\n+    use mbe::{ast_to_token_tree, TokenMap};\n+    use ra_cfg::parse_cfg;\n+    use ra_syntax::{\n+        ast::{self, AstNode},\n+        SmolStr,\n+    };\n+\n+    fn get_token_tree_generated(input: &str) -> (tt::Subtree, TokenMap) {\n+        let source_file = ast::SourceFile::parse(input).ok().unwrap();\n+        let tt = source_file.syntax().descendants().find_map(ast::TokenTree::cast).unwrap();\n+        ast_to_token_tree(&tt).unwrap()\n+    }\n+\n+    #[test]\n+    fn test_cfg_expr_minimal_features_needed() {\n+        let (subtree, _) = get_token_tree_generated(r#\"#![cfg(feature = \"baz\")]\"#);\n+        let cfg_expr = parse_cfg(&subtree);\n+        let mut min_features = vec![];\n+        required_features(&cfg_expr, &mut min_features);\n+\n+        assert_eq!(min_features, vec![SmolStr::new(\"baz\")]);\n+\n+        let (subtree, _) =\n+            get_token_tree_generated(r#\"#![cfg(all(feature = \"baz\", feature = \"foo\"))]\"#);\n+        let cfg_expr = parse_cfg(&subtree);\n+\n+        let mut min_features = vec![];\n+        required_features(&cfg_expr, &mut min_features);\n+        assert_eq!(min_features, vec![SmolStr::new(\"baz\"), SmolStr::new(\"foo\")]);\n+\n+        let (subtree, _) =\n+            get_token_tree_generated(r#\"#![cfg(any(feature = \"baz\", feature = \"foo\", unix))]\"#);\n+        let cfg_expr = parse_cfg(&subtree);\n+\n+        let mut min_features = vec![];\n+        required_features(&cfg_expr, &mut min_features);\n+        assert_eq!(min_features, vec![SmolStr::new(\"baz\")]);\n+\n+        let (subtree, _) = get_token_tree_generated(r#\"#![cfg(foo)]\"#);\n+        let cfg_expr = parse_cfg(&subtree);\n+\n+        let mut min_features = vec![];\n+        required_features(&cfg_expr, &mut min_features);\n+        assert!(min_features.is_empty());\n+    }\n+}"}, {"sha": "410c654abeba5f7624cab24c3be871fabdfa7381", "filename": "crates/rust-analyzer/src/main_loop/handlers.rs", "status": "modified", "additions": 4, "deletions": 116, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/31f282636bb1b1d701d41f7c7fedb11a5511cabd/crates%2Frust-analyzer%2Fsrc%2Fmain_loop%2Fhandlers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31f282636bb1b1d701d41f7c7fedb11a5511cabd/crates%2Frust-analyzer%2Fsrc%2Fmain_loop%2Fhandlers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fmain_loop%2Fhandlers.rs?ref=31f282636bb1b1d701d41f7c7fedb11a5511cabd", "patch": "@@ -17,14 +17,12 @@ use lsp_types::{\n     SemanticTokensParams, SemanticTokensRangeParams, SemanticTokensRangeResult,\n     SemanticTokensResult, SymbolInformation, TextDocumentIdentifier, Url, WorkspaceEdit,\n };\n-use ra_cfg::CfgExpr;\n use ra_ide::{\n-    FileId, FilePosition, FileRange, Query, RangeInfo, Runnable, RunnableKind, SearchScope,\n-    TextEdit,\n+    FileId, FilePosition, FileRange, Query, RangeInfo, RunnableKind, SearchScope, TextEdit,\n };\n use ra_prof::profile;\n use ra_project_model::TargetKind;\n-use ra_syntax::{AstNode, SmolStr, SyntaxKind, TextRange, TextSize};\n+use ra_syntax::{AstNode, SyntaxKind, TextRange, TextSize};\n use rustc_hash::FxHashMap;\n use serde::{Deserialize, Serialize};\n use serde_json::to_value;\n@@ -416,7 +414,7 @@ pub fn handle_runnables(\n                 }\n             }\n         }\n-        res.push(to_lsp_runnable(&world, file_id, runnable)?);\n+        res.push(to_proto::runnable(&world, file_id, runnable)?);\n     }\n \n     // Add `cargo check` and `cargo test` for the whole package\n@@ -784,7 +782,7 @@ pub fn handle_code_lens(\n                 }\n             };\n \n-            let mut r = to_lsp_runnable(&world, file_id, runnable)?;\n+            let mut r = to_proto::runnable(&world, file_id, runnable)?;\n             if world.config.lens.run {\n                 let lens = CodeLens {\n                     range: r.range,\n@@ -959,65 +957,6 @@ pub fn publish_diagnostics(world: &WorldSnapshot, file_id: FileId) -> Result<Dia\n     Ok(DiagnosticTask::SetNative(file_id, diagnostics))\n }\n \n-fn to_lsp_runnable(\n-    world: &WorldSnapshot,\n-    file_id: FileId,\n-    runnable: Runnable,\n-) -> Result<lsp_ext::Runnable> {\n-    let spec = CargoTargetSpec::for_file(world, file_id)?;\n-    let target = spec.as_ref().map(|s| s.target.clone());\n-    let mut features_needed = vec![];\n-    for cfg_expr in &runnable.cfg_exprs {\n-        collect_minimal_features_needed(cfg_expr, &mut features_needed);\n-    }\n-    let (args, extra_args) =\n-        CargoTargetSpec::runnable_args(spec, &runnable.kind, &features_needed)?;\n-    let line_index = world.analysis().file_line_index(file_id)?;\n-    let label = match &runnable.kind {\n-        RunnableKind::Test { test_id, .. } => format!(\"test {}\", test_id),\n-        RunnableKind::TestMod { path } => format!(\"test-mod {}\", path),\n-        RunnableKind::Bench { test_id } => format!(\"bench {}\", test_id),\n-        RunnableKind::DocTest { test_id, .. } => format!(\"doctest {}\", test_id),\n-        RunnableKind::Bin => {\n-            target.map_or_else(|| \"run binary\".to_string(), |t| format!(\"run {}\", t))\n-        }\n-    };\n-\n-    Ok(lsp_ext::Runnable {\n-        range: to_proto::range(&line_index, runnable.range),\n-        label,\n-        kind: lsp_ext::RunnableKind::Cargo,\n-        args,\n-        extra_args,\n-        env: {\n-            let mut m = FxHashMap::default();\n-            m.insert(\"RUST_BACKTRACE\".to_string(), \"short\".to_string());\n-            m\n-        },\n-        cwd: world.workspace_root_for(file_id).map(|root| root.to_owned()),\n-    })\n-}\n-\n-/// Fill minimal features needed\n-fn collect_minimal_features_needed(cfg_expr: &CfgExpr, features: &mut Vec<SmolStr>) {\n-    match cfg_expr {\n-        CfgExpr::KeyValue { key, value } if key == \"feature\" => features.push(value.clone()),\n-        CfgExpr::All(preds) => {\n-            preds.iter().for_each(|cfg| collect_minimal_features_needed(cfg, features));\n-        }\n-        CfgExpr::Any(preds) => {\n-            for cfg in preds {\n-                let len_features = features.len();\n-                collect_minimal_features_needed(cfg, features);\n-                if len_features != features.len() {\n-                    break;\n-                }\n-            }\n-        }\n-        _ => {}\n-    }\n-}\n-\n pub fn handle_inlay_hints(\n     world: WorldSnapshot,\n     params: InlayHintsParams,\n@@ -1154,54 +1093,3 @@ pub fn handle_semantic_tokens_range(\n     let semantic_tokens = to_proto::semantic_tokens(&text, &line_index, highlights);\n     Ok(Some(semantic_tokens.into()))\n }\n-\n-#[cfg(test)]\n-mod tests {\n-    use super::*;\n-\n-    use mbe::{ast_to_token_tree, TokenMap};\n-    use ra_cfg::parse_cfg;\n-    use ra_syntax::{\n-        ast::{self, AstNode},\n-        SmolStr,\n-    };\n-\n-    fn get_token_tree_generated(input: &str) -> (tt::Subtree, TokenMap) {\n-        let source_file = ast::SourceFile::parse(input).ok().unwrap();\n-        let tt = source_file.syntax().descendants().find_map(ast::TokenTree::cast).unwrap();\n-        ast_to_token_tree(&tt).unwrap()\n-    }\n-\n-    #[test]\n-    fn test_cfg_expr_minimal_features_needed() {\n-        let (subtree, _) = get_token_tree_generated(r#\"#![cfg(feature = \"baz\")]\"#);\n-        let cfg_expr = parse_cfg(&subtree);\n-        let mut min_features = vec![];\n-        collect_minimal_features_needed(&cfg_expr, &mut min_features);\n-\n-        assert_eq!(min_features, vec![SmolStr::new(\"baz\")]);\n-\n-        let (subtree, _) =\n-            get_token_tree_generated(r#\"#![cfg(all(feature = \"baz\", feature = \"foo\"))]\"#);\n-        let cfg_expr = parse_cfg(&subtree);\n-\n-        let mut min_features = vec![];\n-        collect_minimal_features_needed(&cfg_expr, &mut min_features);\n-        assert_eq!(min_features, vec![SmolStr::new(\"baz\"), SmolStr::new(\"foo\")]);\n-\n-        let (subtree, _) =\n-            get_token_tree_generated(r#\"#![cfg(any(feature = \"baz\", feature = \"foo\", unix))]\"#);\n-        let cfg_expr = parse_cfg(&subtree);\n-\n-        let mut min_features = vec![];\n-        collect_minimal_features_needed(&cfg_expr, &mut min_features);\n-        assert_eq!(min_features, vec![SmolStr::new(\"baz\")]);\n-\n-        let (subtree, _) = get_token_tree_generated(r#\"#![cfg(foo)]\"#);\n-        let cfg_expr = parse_cfg(&subtree);\n-\n-        let mut min_features = vec![];\n-        collect_minimal_features_needed(&cfg_expr, &mut min_features);\n-        assert!(min_features.is_empty());\n-    }\n-}"}, {"sha": "66144fe2411438de3feba12ec32093b5ebd1b967", "filename": "crates/rust-analyzer/src/to_proto.rs", "status": "modified", "additions": 41, "deletions": 3, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/31f282636bb1b1d701d41f7c7fedb11a5511cabd/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31f282636bb1b1d701d41f7c7fedb11a5511cabd/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs?ref=31f282636bb1b1d701d41f7c7fedb11a5511cabd", "patch": "@@ -3,13 +3,16 @@ use ra_db::{FileId, FileRange};\n use ra_ide::{\n     Assist, CompletionItem, CompletionItemKind, Documentation, FileSystemEdit, Fold, FoldKind,\n     FunctionSignature, Highlight, HighlightModifier, HighlightTag, HighlightedRange, Indel,\n-    InlayHint, InlayKind, InsertTextFormat, LineIndex, NavigationTarget, ReferenceAccess, Severity,\n-    SourceChange, SourceFileEdit, TextEdit,\n+    InlayHint, InlayKind, InsertTextFormat, LineIndex, NavigationTarget, ReferenceAccess, Runnable,\n+    RunnableKind, Severity, SourceChange, SourceFileEdit, TextEdit,\n };\n use ra_syntax::{SyntaxKind, TextRange, TextSize};\n use ra_vfs::LineEndings;\n+use rustc_hash::FxHashMap;\n \n-use crate::{lsp_ext, semantic_tokens, world::WorldSnapshot, Result};\n+use crate::{\n+    cargo_target_spec::CargoTargetSpec, lsp_ext, semantic_tokens, world::WorldSnapshot, Result,\n+};\n \n pub(crate) fn position(line_index: &LineIndex, offset: TextSize) -> lsp_types::Position {\n     let line_col = line_index.line_col(offset);\n@@ -627,3 +630,38 @@ pub(crate) fn code_action(world: &WorldSnapshot, assist: Assist) -> Result<lsp_e\n     };\n     Ok(res)\n }\n+\n+pub(crate) fn runnable(\n+    world: &WorldSnapshot,\n+    file_id: FileId,\n+    runnable: Runnable,\n+) -> Result<lsp_ext::Runnable> {\n+    let spec = CargoTargetSpec::for_file(world, file_id)?;\n+    let target = spec.as_ref().map(|s| s.target.clone());\n+    let (args, extra_args) =\n+        CargoTargetSpec::runnable_args(spec, &runnable.kind, &runnable.cfg_exprs)?;\n+    let line_index = world.analysis().file_line_index(file_id)?;\n+    let label = match &runnable.kind {\n+        RunnableKind::Test { test_id, .. } => format!(\"test {}\", test_id),\n+        RunnableKind::TestMod { path } => format!(\"test-mod {}\", path),\n+        RunnableKind::Bench { test_id } => format!(\"bench {}\", test_id),\n+        RunnableKind::DocTest { test_id, .. } => format!(\"doctest {}\", test_id),\n+        RunnableKind::Bin => {\n+            target.map_or_else(|| \"run binary\".to_string(), |t| format!(\"run {}\", t))\n+        }\n+    };\n+\n+    Ok(lsp_ext::Runnable {\n+        range: range(&line_index, runnable.range),\n+        label,\n+        kind: lsp_ext::RunnableKind::Cargo,\n+        args,\n+        extra_args,\n+        env: {\n+            let mut m = FxHashMap::default();\n+            m.insert(\"RUST_BACKTRACE\".to_string(), \"short\".to_string());\n+            m\n+        },\n+        cwd: world.workspace_root_for(file_id).map(|root| root.to_owned()),\n+    })\n+}"}]}