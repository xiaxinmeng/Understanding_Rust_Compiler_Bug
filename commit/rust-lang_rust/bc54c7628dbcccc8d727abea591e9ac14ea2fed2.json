{"sha": "bc54c7628dbcccc8d727abea591e9ac14ea2fed2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJjNTRjNzYyOGRiY2NjYzhkNzI3YWJlYTU5MWU5YWMxNGVhMmZlZDI=", "commit": {"author": {"name": "David Cook", "email": "divergentdave@gmail.com", "date": "2020-04-05T21:03:44Z"}, "committer": {"name": "David Cook", "email": "divergentdave@gmail.com", "date": "2020-04-05T21:03:44Z"}, "message": "Eagerly compute i32 and u32 layouts", "tree": {"sha": "4c451ad1dd1043ffe3befd021f446432bb2e01b1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4c451ad1dd1043ffe3befd021f446432bb2e01b1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bc54c7628dbcccc8d727abea591e9ac14ea2fed2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bc54c7628dbcccc8d727abea591e9ac14ea2fed2", "html_url": "https://github.com/rust-lang/rust/commit/bc54c7628dbcccc8d727abea591e9ac14ea2fed2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bc54c7628dbcccc8d727abea591e9ac14ea2fed2/comments", "author": {"login": "divergentdave", "id": 181772, "node_id": "MDQ6VXNlcjE4MTc3Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/181772?v=4", "gravatar_id": "", "url": "https://api.github.com/users/divergentdave", "html_url": "https://github.com/divergentdave", "followers_url": "https://api.github.com/users/divergentdave/followers", "following_url": "https://api.github.com/users/divergentdave/following{/other_user}", "gists_url": "https://api.github.com/users/divergentdave/gists{/gist_id}", "starred_url": "https://api.github.com/users/divergentdave/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/divergentdave/subscriptions", "organizations_url": "https://api.github.com/users/divergentdave/orgs", "repos_url": "https://api.github.com/users/divergentdave/repos", "events_url": "https://api.github.com/users/divergentdave/events{/privacy}", "received_events_url": "https://api.github.com/users/divergentdave/received_events", "type": "User", "site_admin": false}, "committer": {"login": "divergentdave", "id": 181772, "node_id": "MDQ6VXNlcjE4MTc3Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/181772?v=4", "gravatar_id": "", "url": "https://api.github.com/users/divergentdave", "html_url": "https://github.com/divergentdave", "followers_url": "https://api.github.com/users/divergentdave/followers", "following_url": "https://api.github.com/users/divergentdave/following{/other_user}", "gists_url": "https://api.github.com/users/divergentdave/gists{/gist_id}", "starred_url": "https://api.github.com/users/divergentdave/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/divergentdave/subscriptions", "organizations_url": "https://api.github.com/users/divergentdave/orgs", "repos_url": "https://api.github.com/users/divergentdave/repos", "events_url": "https://api.github.com/users/divergentdave/events{/privacy}", "received_events_url": "https://api.github.com/users/divergentdave/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "134d6a2faab1801e9b3d23b6ee11ba1643eae0fe", "url": "https://api.github.com/repos/rust-lang/rust/commits/134d6a2faab1801e9b3d23b6ee11ba1643eae0fe", "html_url": "https://github.com/rust-lang/rust/commit/134d6a2faab1801e9b3d23b6ee11ba1643eae0fe"}], "stats": {"total": 157, "additions": 83, "deletions": 74}, "files": [{"sha": "c3510188e3cb225e7c92ad0fc38a97413451c326", "filename": "src/eval.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/bc54c7628dbcccc8d727abea591e9ac14ea2fed2/src%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc54c7628dbcccc8d727abea591e9ac14ea2fed2/src%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feval.rs?ref=bc54c7628dbcccc8d727abea591e9ac14ea2fed2", "patch": "@@ -1,14 +1,14 @@\n //! Main evaluator loop and setting up the initial stack frame.\n \n-use std::ffi::OsStr;\n use std::convert::TryFrom;\n+use std::ffi::OsStr;\n \n use rand::rngs::StdRng;\n use rand::SeedableRng;\n \n-use rustc_target::abi::LayoutOf;\n-use rustc_middle::ty::{self, TyCtxt};\n use rustc_hir::def_id::DefId;\n+use rustc_middle::ty::{self, layout::LayoutCx, TyCtxt};\n+use rustc_target::abi::LayoutOf;\n \n use crate::*;\n \n@@ -60,10 +60,13 @@ pub fn create_ecx<'mir, 'tcx: 'mir>(\n     main_id: DefId,\n     config: MiriConfig,\n ) -> InterpResult<'tcx, (InterpCx<'mir, 'tcx, Evaluator<'tcx>>, MPlaceTy<'tcx, Tag>)> {\n+    let tcx_at = tcx.at(rustc_span::source_map::DUMMY_SP);\n+    let param_env = ty::ParamEnv::reveal_all();\n+    let layout_cx = LayoutCx { tcx, param_env };\n     let mut ecx = InterpCx::new(\n-        tcx.at(rustc_span::source_map::DUMMY_SP),\n-        ty::ParamEnv::reveal_all(),\n-        Evaluator::new(config.communicate, config.validate),\n+        tcx_at,\n+        param_env,\n+        Evaluator::new(config.communicate, config.validate, layout_cx),\n         MemoryExtra::new(\n             StdRng::seed_from_u64(config.seed.unwrap_or(0)),\n             config.stacked_borrows,"}, {"sha": "2f381b4a34546f7868ed5dd82cff3175820814a3", "filename": "src/lib.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bc54c7628dbcccc8d727abea591e9ac14ea2fed2/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc54c7628dbcccc8d727abea591e9ac14ea2fed2/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=bc54c7628dbcccc8d727abea591e9ac14ea2fed2", "patch": "@@ -51,9 +51,8 @@ pub use crate::diagnostics::{\n pub use crate::eval::{create_ecx, eval_main, MiriConfig};\n pub use crate::helpers::EvalContextExt as HelpersEvalContextExt;\n pub use crate::machine::{\n-    AllocExtra, EvalContextExt as MachineEvalContextExt, Evaluator, FrameData, MemoryExtra,\n-    MiriEvalContext, MiriEvalContextExt, MiriMemoryKind, NUM_CPUS, PAGE_SIZE, STACK_ADDR,\n-    STACK_SIZE,\n+    AllocExtra, Evaluator, FrameData, MemoryExtra, MiriEvalContext, MiriEvalContextExt,\n+    MiriMemoryKind, NUM_CPUS, PAGE_SIZE, STACK_ADDR, STACK_SIZE,\n };\n pub use crate::mono_hash_map::MonoHashMap;\n pub use crate::operator::EvalContextExt as OperatorEvalContextExt;"}, {"sha": "26ff23511f73375f3d095aa29891113eef982c23", "filename": "src/machine.rs", "status": "modified", "additions": 30, "deletions": 49, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/bc54c7628dbcccc8d727abea591e9ac14ea2fed2/src%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc54c7628dbcccc8d727abea591e9ac14ea2fed2/src%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmachine.rs?ref=bc54c7628dbcccc8d727abea591e9ac14ea2fed2", "patch": "@@ -10,11 +10,18 @@ use std::time::Instant;\n use log::trace;\n use rand::rngs::StdRng;\n \n-use rustc_data_structures::fx::FxHashMap;\n-use rustc_middle::{mir, ty::{self, layout::TyAndLayout}};\n-use rustc_target::abi::{LayoutOf, Size};\n use rustc_ast::attr;\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_middle::{\n+    mir,\n+    ty::{\n+        self,\n+        layout::{LayoutCx, LayoutError, TyAndLayout},\n+        TyCtxt,\n+    },\n+};\n use rustc_span::symbol::{sym, Symbol};\n+use rustc_target::abi::{LayoutOf, Size};\n \n use crate::*;\n \n@@ -146,36 +153,18 @@ impl MemoryExtra {\n     }\n }\n \n-/// Cached layouts of primitive types\n-#[derive(Default)]\n-struct PrimitiveLayouts<'tcx> {\n-    i32: RefCell<Option<TyAndLayout<'tcx>>>,\n-    u32: RefCell<Option<TyAndLayout<'tcx>>>,\n+/// Precomputed layouts of primitive types\n+pub(crate) struct PrimitiveLayouts<'tcx> {\n+    pub(crate) i32: TyAndLayout<'tcx>,\n+    pub(crate) u32: TyAndLayout<'tcx>,\n }\n \n impl<'mir, 'tcx: 'mir> PrimitiveLayouts<'tcx> {\n-    fn i32(&self, ecx: &MiriEvalContext<'mir, 'tcx>) -> InterpResult<'tcx, TyAndLayout<'tcx>> {\n-        {\n-            let layout_ref = self.i32.borrow();\n-            if layout_ref.is_some() {\n-                return Ok(layout_ref.unwrap());\n-            }\n-        }\n-        let layout = ecx.layout_of(ecx.tcx.types.i32)?;\n-        *self.i32.borrow_mut() = Some(layout);\n-        Ok(layout)\n-    }\n-\n-    fn u32(&self, ecx: &MiriEvalContext<'mir, 'tcx>) -> InterpResult<'tcx, TyAndLayout<'tcx>> {\n-        {\n-            let layout_ref = self.u32.borrow();\n-            if layout_ref.is_some() {\n-                return Ok(layout_ref.unwrap());\n-            }\n-        }\n-        let layout = ecx.layout_of(ecx.tcx.types.u32)?;\n-        *self.u32.borrow_mut() = Some(layout);\n-        Ok(layout)\n+    fn new(layout_cx: LayoutCx<'tcx, TyCtxt<'tcx>>) -> Result<Self, LayoutError<'tcx>> {\n+        Ok(Self {\n+            i32: layout_cx.layout_of(layout_cx.tcx.types.i32)?,\n+            u32: layout_cx.layout_of(layout_cx.tcx.types.u32)?,\n+        })\n     }\n }\n \n@@ -216,14 +205,20 @@ pub struct Evaluator<'tcx> {\n     /// The \"time anchor\" for this machine's monotone clock (for `Instant` simulation).\n     pub(crate) time_anchor: Instant,\n \n-    /// Cached `TyLayout`s for primitive data types that are commonly used inside Miri.\n+    /// Precomputed `TyLayout`s for primitive data types that are commonly used inside Miri.\n     /// FIXME: Search through the rest of the codebase for more layout_of() calls that\n-    /// could be cached here.\n-    primitive_layouts: PrimitiveLayouts<'tcx>,\n+    /// could be stored here.\n+    pub(crate) layouts: PrimitiveLayouts<'tcx>,\n }\n \n impl<'tcx> Evaluator<'tcx> {\n-    pub(crate) fn new(communicate: bool, validate: bool) -> Self {\n+    pub(crate) fn new(\n+        communicate: bool,\n+        validate: bool,\n+        layout_cx: LayoutCx<'tcx, TyCtxt<'tcx>>,\n+    ) -> Self {\n+        let layouts = PrimitiveLayouts::new(layout_cx)\n+            .expect(\"Couldn't get layouts of primitive types\");\n         Evaluator {\n             // `env_vars` could be initialized properly here if `Memory` were available before\n             // calling this method.\n@@ -239,7 +234,7 @@ impl<'tcx> Evaluator<'tcx> {\n             dir_handler: Default::default(),\n             panic_payload: None,\n             time_anchor: Instant::now(),\n-            primitive_layouts: PrimitiveLayouts::default(),\n+            layouts,\n         }\n     }\n }\n@@ -263,20 +258,6 @@ impl<'mir, 'tcx> MiriEvalContextExt<'mir, 'tcx> for MiriEvalContext<'mir, 'tcx>\n     }\n }\n \n-impl<'mir, 'tcx> EvalContextExt<'mir, 'tcx> for MiriEvalContext<'mir, 'tcx> {}\n-/// Provides convenience methods for use elsewhere\n-pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n-    fn i32_layout(&self) -> InterpResult<'tcx, TyAndLayout<'tcx>> {\n-        let this = self.eval_context_ref();\n-        this.machine.primitive_layouts.i32(this)\n-    }\n-\n-    fn u32_layout(&self) -> InterpResult<'tcx, TyAndLayout<'tcx>> {\n-        let this = self.eval_context_ref();\n-        this.machine.primitive_layouts.u32(this)\n-    }\n-}\n-\n /// Machine hook implementations.\n impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'tcx> {\n     type MemoryKind = MiriMemoryKind;"}, {"sha": "b03dcbfd8969a2bc310fe08a8f8803eba6b9485a", "filename": "src/shims/sync.rs", "status": "modified", "additions": 42, "deletions": 16, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/bc54c7628dbcccc8d727abea591e9ac14ea2fed2/src%2Fshims%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc54c7628dbcccc8d727abea591e9ac14ea2fed2/src%2Fshims%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fsync.rs?ref=bc54c7628dbcccc8d727abea591e9ac14ea2fed2", "patch": "@@ -31,7 +31,8 @@ fn mutexattr_get_kind<'mir, 'tcx: 'mir>(\n     // Ensure that the following read at an offset to the attr pointer is within bounds\n     assert_ptr_target_min_size(ecx, attr_op, 4)?;\n     let attr_place = ecx.deref_operand(attr_op)?;\n-    let kind_place = attr_place.offset(Size::ZERO, MemPlaceMeta::None, ecx.i32_layout()?, ecx)?;\n+    let kind_place =\n+        attr_place.offset(Size::ZERO, MemPlaceMeta::None, ecx.machine.layouts.i32, ecx)?;\n     ecx.read_scalar(kind_place.into())\n }\n \n@@ -43,7 +44,8 @@ fn mutexattr_set_kind<'mir, 'tcx: 'mir>(\n     // Ensure that the following write at an offset to the attr pointer is within bounds\n     assert_ptr_target_min_size(ecx, attr_op, 4)?;\n     let attr_place = ecx.deref_operand(attr_op)?;\n-    let kind_place = attr_place.offset(Size::ZERO, MemPlaceMeta::None, ecx.i32_layout()?, ecx)?;\n+    let kind_place =\n+        attr_place.offset(Size::ZERO, MemPlaceMeta::None, ecx.machine.layouts.i32, ecx)?;\n     ecx.write_scalar(kind.into(), kind_place.into())\n }\n \n@@ -63,8 +65,12 @@ fn mutex_get_locked_count<'mir, 'tcx: 'mir>(\n     // Ensure that the following read at an offset to the mutex pointer is within bounds\n     assert_ptr_target_min_size(ecx, mutex_op, 20)?;\n     let mutex_place = ecx.deref_operand(mutex_op)?;\n-    let locked_count_place =\n-        mutex_place.offset(Size::from_bytes(4), MemPlaceMeta::None, ecx.u32_layout()?, ecx)?;\n+    let locked_count_place = mutex_place.offset(\n+        Size::from_bytes(4),\n+        MemPlaceMeta::None,\n+        ecx.machine.layouts.u32,\n+        ecx,\n+    )?;\n     ecx.read_scalar(locked_count_place.into())\n }\n \n@@ -76,8 +82,12 @@ fn mutex_set_locked_count<'mir, 'tcx: 'mir>(\n     // Ensure that the following write at an offset to the mutex pointer is within bounds\n     assert_ptr_target_min_size(ecx, mutex_op, 20)?;\n     let mutex_place = ecx.deref_operand(mutex_op)?;\n-    let locked_count_place =\n-        mutex_place.offset(Size::from_bytes(4), MemPlaceMeta::None, ecx.u32_layout()?, ecx)?;\n+    let locked_count_place = mutex_place.offset(\n+        Size::from_bytes(4),\n+        MemPlaceMeta::None,\n+        ecx.machine.layouts.u32,\n+        ecx,\n+    )?;\n     ecx.write_scalar(locked_count.into(), locked_count_place.into())\n }\n \n@@ -92,7 +102,7 @@ fn mutex_get_kind<'mir, 'tcx: 'mir>(\n     let kind_place = mutex_place.offset(\n         Size::from_bytes(kind_offset),\n         MemPlaceMeta::None,\n-        ecx.i32_layout()?,\n+        ecx.machine.layouts.i32,\n         ecx,\n     )?;\n     ecx.read_scalar(kind_place.into())\n@@ -110,7 +120,7 @@ fn mutex_set_kind<'mir, 'tcx: 'mir>(\n     let kind_place = mutex_place.offset(\n         Size::from_bytes(kind_offset),\n         MemPlaceMeta::None,\n-        ecx.i32_layout()?,\n+        ecx.machine.layouts.i32,\n         ecx,\n     )?;\n     ecx.write_scalar(kind.into(), kind_place.into())\n@@ -131,8 +141,12 @@ fn rwlock_get_readers<'mir, 'tcx: 'mir>(\n     // Ensure that the following read at an offset to the rwlock pointer is within bounds\n     assert_ptr_target_min_size(ecx, rwlock_op, 12)?;\n     let rwlock_place = ecx.deref_operand(rwlock_op)?;\n-    let readers_place =\n-        rwlock_place.offset(Size::from_bytes(4), MemPlaceMeta::None, ecx.u32_layout()?, ecx)?;\n+    let readers_place = rwlock_place.offset(\n+        Size::from_bytes(4),\n+        MemPlaceMeta::None,\n+        ecx.machine.layouts.u32,\n+        ecx,\n+    )?;\n     ecx.read_scalar(readers_place.into())\n }\n \n@@ -144,8 +158,12 @@ fn rwlock_set_readers<'mir, 'tcx: 'mir>(\n     // Ensure that the following write at an offset to the rwlock pointer is within bounds\n     assert_ptr_target_min_size(ecx, rwlock_op, 12)?;\n     let rwlock_place = ecx.deref_operand(rwlock_op)?;\n-    let readers_place =\n-        rwlock_place.offset(Size::from_bytes(4), MemPlaceMeta::None, ecx.u32_layout()?, ecx)?;\n+    let readers_place = rwlock_place.offset(\n+        Size::from_bytes(4),\n+        MemPlaceMeta::None,\n+        ecx.machine.layouts.u32,\n+        ecx,\n+    )?;\n     ecx.write_scalar(readers.into(), readers_place.into())\n }\n \n@@ -156,8 +174,12 @@ fn rwlock_get_writers<'mir, 'tcx: 'mir>(\n     // Ensure that the following read at an offset to the rwlock pointer is within bounds\n     assert_ptr_target_min_size(ecx, rwlock_op, 12)?;\n     let rwlock_place = ecx.deref_operand(rwlock_op)?;\n-    let writers_place =\n-        rwlock_place.offset(Size::from_bytes(8), MemPlaceMeta::None, ecx.u32_layout()?, ecx)?;\n+    let writers_place = rwlock_place.offset(\n+        Size::from_bytes(8),\n+        MemPlaceMeta::None,\n+        ecx.machine.layouts.u32,\n+        ecx,\n+    )?;\n     ecx.read_scalar(writers_place.into())\n }\n \n@@ -169,8 +191,12 @@ fn rwlock_set_writers<'mir, 'tcx: 'mir>(\n     // Ensure that the following write at an offset to the rwlock pointer is within bounds\n     assert_ptr_target_min_size(ecx, rwlock_op, 12)?;\n     let rwlock_place = ecx.deref_operand(rwlock_op)?;\n-    let writers_place =\n-        rwlock_place.offset(Size::from_bytes(8), MemPlaceMeta::None, ecx.u32_layout()?, ecx)?;\n+    let writers_place = rwlock_place.offset(\n+        Size::from_bytes(8),\n+        MemPlaceMeta::None,\n+        ecx.machine.layouts.u32,\n+        ecx,\n+    )?;\n     ecx.write_scalar(writers.into(), writers_place.into())\n }\n "}]}