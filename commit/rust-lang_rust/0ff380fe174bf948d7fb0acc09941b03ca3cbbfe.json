{"sha": "0ff380fe174bf948d7fb0acc09941b03ca3cbbfe", "node_id": "C_kwDOAAsO6NoAKDBmZjM4MGZlMTc0YmY5NDhkN2ZiMGFjYzA5OTQxYjAzY2EzY2JiZmU", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-11-16T20:26:34Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-11-16T20:26:34Z"}, "message": "Simplify", "tree": {"sha": "f86571aa09027b5670a0169de45c49718b44a47d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f86571aa09027b5670a0169de45c49718b44a47d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0ff380fe174bf948d7fb0acc09941b03ca3cbbfe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0ff380fe174bf948d7fb0acc09941b03ca3cbbfe", "html_url": "https://github.com/rust-lang/rust/commit/0ff380fe174bf948d7fb0acc09941b03ca3cbbfe", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0ff380fe174bf948d7fb0acc09941b03ca3cbbfe/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b57289c4cb21ba7b94009cffc4210eafe901ea71", "url": "https://api.github.com/repos/rust-lang/rust/commits/b57289c4cb21ba7b94009cffc4210eafe901ea71", "html_url": "https://github.com/rust-lang/rust/commit/b57289c4cb21ba7b94009cffc4210eafe901ea71"}], "stats": {"total": 250, "additions": 107, "deletions": 143}, "files": [{"sha": "7d4d52ff50ebf5527d4161b9af16ada6b1764935", "filename": "crates/ide/src/highlight_related.rs", "status": "modified", "additions": 17, "deletions": 52, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/0ff380fe174bf948d7fb0acc09941b03ca3cbbfe/crates%2Fide%2Fsrc%2Fhighlight_related.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ff380fe174bf948d7fb0acc09941b03ca3cbbfe/crates%2Fide%2Fsrc%2Fhighlight_related.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhighlight_related.rs?ref=0ff380fe174bf948d7fb0acc09941b03ca3cbbfe", "patch": "@@ -1,7 +1,7 @@\n use hir::Semantics;\n use ide_db::{\n-    base_db::FilePosition,\n-    defs::{Definition, NameClass, NameRefClass},\n+    base_db::{FileId, FilePosition},\n+    defs::Definition,\n     helpers::{for_each_break_expr, for_each_tail_expr, node_ext::walk_expr, pick_best_token},\n     search::{FileReference, ReferenceCategory, SearchScope},\n     RootDatabase,\n@@ -11,7 +11,7 @@ use syntax::{\n     ast::{self, HasLoopBody},\n     match_ast, AstNode,\n     SyntaxKind::IDENT,\n-    SyntaxNode, SyntaxToken, TextRange, TextSize, T,\n+    SyntaxNode, SyntaxToken, TextRange, T,\n };\n \n use crate::{display::TryToNav, references, NavigationTarget};\n@@ -45,12 +45,12 @@ pub struct HighlightRelatedConfig {\n pub(crate) fn highlight_related(\n     sema: &Semantics<RootDatabase>,\n     config: HighlightRelatedConfig,\n-    position: FilePosition,\n+    FilePosition { offset, file_id }: FilePosition,\n ) -> Option<Vec<HighlightedRange>> {\n     let _p = profile::span(\"highlight_related\");\n-    let syntax = sema.parse(position.file_id).syntax().clone();\n+    let syntax = sema.parse(file_id).syntax().clone();\n \n-    let token = pick_best_token(syntax.token_at_offset(position.offset), |kind| match kind {\n+    let token = pick_best_token(syntax.token_at_offset(offset), |kind| match kind {\n         T![?] => 4, // prefer `?` when the cursor is sandwiched like in `await$0?`\n         T![->] => 3,\n         kind if kind.is_keyword() => 2,\n@@ -68,17 +68,18 @@ pub(crate) fn highlight_related(\n             highlight_break_points(token)\n         }\n         T![break] | T![loop] | T![while] if config.break_points => highlight_break_points(token),\n-        _ if config.references => highlight_references(sema, &syntax, position),\n+        _ if config.references => highlight_references(sema, &syntax, token, file_id),\n         _ => None,\n     }\n }\n \n fn highlight_references(\n     sema: &Semantics<RootDatabase>,\n-    syntax: &SyntaxNode,\n-    FilePosition { offset, file_id }: FilePosition,\n+    node: &SyntaxNode,\n+    token: SyntaxToken,\n+    file_id: FileId,\n ) -> Option<Vec<HighlightedRange>> {\n-    let defs = find_defs(sema, syntax, offset);\n+    let defs = find_defs(sema, token.clone());\n     let usages = defs\n         .iter()\n         .filter_map(|&d| {\n@@ -105,11 +106,8 @@ fn highlight_references(\n         .filter(|decl| decl.file_id == file_id)\n         .and_then(|decl| {\n             let range = decl.focus_range?;\n-            let category = if references::decl_mutability(&def, syntax, range) {\n-                Some(ReferenceCategory::Write)\n-            } else {\n-                None\n-            };\n+            let category =\n+                references::decl_mutability(&def, node, range).then(|| ReferenceCategory::Write);\n             Some(HighlightedRange { range, category })\n         })\n     });\n@@ -293,43 +291,10 @@ fn cover_range(r0: Option<TextRange>, r1: Option<TextRange>) -> Option<TextRange\n     }\n }\n \n-fn find_defs(\n-    sema: &Semantics<RootDatabase>,\n-    syntax: &SyntaxNode,\n-    offset: TextSize,\n-) -> FxHashSet<Definition> {\n-    sema.find_nodes_at_offset_with_descend(syntax, offset)\n-        .flat_map(|name_like| {\n-            Some(match name_like {\n-                ast::NameLike::NameRef(name_ref) => {\n-                    match NameRefClass::classify(sema, &name_ref)? {\n-                        NameRefClass::Definition(def) => vec![def],\n-                        NameRefClass::FieldShorthand { local_ref, field_ref } => {\n-                            vec![Definition::Local(local_ref), Definition::Field(field_ref)]\n-                        }\n-                    }\n-                }\n-                ast::NameLike::Name(name) => match NameClass::classify(sema, &name)? {\n-                    NameClass::Definition(it) | NameClass::ConstReference(it) => vec![it],\n-                    NameClass::PatFieldShorthand { local_def, field_ref } => {\n-                        vec![Definition::Local(local_def), Definition::Field(field_ref)]\n-                    }\n-                },\n-                ast::NameLike::Lifetime(lifetime) => {\n-                    NameRefClass::classify_lifetime(sema, &lifetime)\n-                        .and_then(|class| match class {\n-                            NameRefClass::Definition(it) => Some(it),\n-                            _ => None,\n-                        })\n-                        .or_else(|| {\n-                            NameClass::classify_lifetime(sema, &lifetime)\n-                                .and_then(NameClass::defined)\n-                        })\n-                        .map(|it| vec![it])?\n-                }\n-            })\n-        })\n-        .flatten()\n+fn find_defs(sema: &Semantics<RootDatabase>, token: SyntaxToken) -> FxHashSet<Definition> {\n+    sema.descend_into_macros(token)\n+        .into_iter()\n+        .flat_map(|token| Definition::from_token(sema, &token))\n         .collect()\n }\n "}, {"sha": "8c3e380b76d8815c60353b9e5a3062da07bc1245", "filename": "crates/ide/src/references.rs", "status": "modified", "additions": 49, "deletions": 53, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/0ff380fe174bf948d7fb0acc09941b03ca3cbbfe/crates%2Fide%2Fsrc%2Freferences.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ff380fe174bf948d7fb0acc09941b03ca3cbbfe/crates%2Fide%2Fsrc%2Freferences.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Freferences.rs?ref=0ff380fe174bf948d7fb0acc09941b03ca3cbbfe", "patch": "@@ -9,9 +9,6 @@\n //! at the index that the match starts at and its tree parent is\n //! resolved to the search element definition, we get a reference.\n \n-use std::iter;\n-\n-use either::Either;\n use hir::{PathResolution, Semantics};\n use ide_db::{\n     base_db::FileId,\n@@ -58,69 +55,67 @@ pub(crate) fn find_all_refs(\n ) -> Option<Vec<ReferenceSearchResult>> {\n     let _p = profile::span(\"find_all_refs\");\n     let syntax = sema.parse(position.file_id).syntax().clone();\n+    let make_searcher = |literal_search: bool| {\n+        move |def: Definition| {\n+            let mut usages =\n+                def.usages(sema).set_scope(search_scope.clone()).include_self_refs().all();\n+            let declaration = match def {\n+                Definition::Module(module) => {\n+                    Some(NavigationTarget::from_module_to_decl(sema.db, module))\n+                }\n+                def => def.try_to_nav(sema.db),\n+            }\n+            .map(|nav| {\n+                let decl_range = nav.focus_or_full_range();\n+                Declaration {\n+                    is_mut: decl_mutability(&def, sema.parse(nav.file_id).syntax(), decl_range),\n+                    nav,\n+                }\n+            });\n+            if literal_search {\n+                retain_adt_literal_usages(&mut usages, def, sema);\n+            }\n+\n+            let references = usages\n+                .into_iter()\n+                .map(|(file_id, refs)| {\n+                    (\n+                        file_id,\n+                        refs.into_iter()\n+                            .map(|file_ref| (file_ref.range, file_ref.category))\n+                            .collect(),\n+                    )\n+                })\n+                .collect();\n+\n+            ReferenceSearchResult { declaration, references }\n+        }\n+    };\n \n-    let mut is_literal_search = false;\n-    let defs = match name_for_constructor_search(&syntax, position) {\n+    match name_for_constructor_search(&syntax, position) {\n         Some(name) => {\n-            is_literal_search = true;\n             let def = match NameClass::classify(sema, &name)? {\n                 NameClass::Definition(it) | NameClass::ConstReference(it) => it,\n                 NameClass::PatFieldShorthand { local_def: _, field_ref } => {\n                     Definition::Field(field_ref)\n                 }\n             };\n-            Either::Left(iter::once(def))\n+            Some(vec![make_searcher(true)(def)])\n         }\n-        None => Either::Right(find_defs(sema, &syntax, position.offset)),\n-    };\n-\n-    Some(\n-        defs.into_iter()\n-            .map(|def| {\n-                let mut usages =\n-                    def.usages(sema).set_scope(search_scope.clone()).include_self_refs().all();\n-                let declaration = match def {\n-                    Definition::Module(module) => {\n-                        Some(NavigationTarget::from_module_to_decl(sema.db, module))\n-                    }\n-                    def => def.try_to_nav(sema.db),\n-                }\n-                .map(|nav| {\n-                    let decl_range = nav.focus_or_full_range();\n-                    Declaration {\n-                        is_mut: decl_mutability(&def, sema.parse(nav.file_id).syntax(), decl_range),\n-                        nav,\n-                    }\n-                });\n-                if is_literal_search {\n-                    retain_adt_literal_usages(&mut usages, def, sema);\n-                }\n+        None => {\n+            let search = make_searcher(false);\n+            Some(find_defs(sema, &syntax, position.offset).into_iter().map(search).collect())\n+        }\n+    }\n+}\n \n-                let references = usages\n-                    .into_iter()\n-                    .map(|(file_id, refs)| {\n-                        (\n-                            file_id,\n-                            refs.into_iter()\n-                                .map(|file_ref| (file_ref.range, file_ref.category))\n-                                .collect(),\n-                        )\n-                    })\n-                    .collect();\n-\n-                ReferenceSearchResult { declaration, references }\n-            })\n-            .collect(),\n-    )\n-}\n-\n-pub(crate) fn find_defs<'a>(\n+fn find_defs<'a>(\n     sema: &'a Semantics<RootDatabase>,\n     syntax: &SyntaxNode,\n     offset: TextSize,\n ) -> impl Iterator<Item = Definition> + 'a {\n-    sema.find_nodes_at_offset_with_descend(syntax, offset).filter_map(move |node| {\n-        Some(match node {\n+    sema.find_nodes_at_offset_with_descend(syntax, offset).filter_map(move |name_like| {\n+        let def = match name_like {\n             ast::NameLike::NameRef(name_ref) => match NameRefClass::classify(sema, &name_ref)? {\n                 NameRefClass::Definition(def) => def,\n                 NameRefClass::FieldShorthand { local_ref, field_ref: _ } => {\n@@ -141,7 +136,8 @@ pub(crate) fn find_defs<'a>(\n                 .or_else(|| {\n                     NameClass::classify_lifetime(sema, &lifetime).and_then(NameClass::defined)\n                 })?,\n-        })\n+        };\n+        Some(def)\n     })\n }\n "}, {"sha": "f03bc1427cbebee048eb0c2c7caa8ad90a251a51", "filename": "crates/ide/src/runnables.rs", "status": "modified", "additions": 41, "deletions": 38, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/0ff380fe174bf948d7fb0acc09941b03ca3cbbfe/crates%2Fide%2Fsrc%2Frunnables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ff380fe174bf948d7fb0acc09941b03ca3cbbfe/crates%2Fide%2Fsrc%2Frunnables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Frunnables.rs?ref=0ff380fe174bf948d7fb0acc09941b03ca3cbbfe", "patch": "@@ -209,7 +209,7 @@ pub(crate) fn related_tests(\n \n     find_related_tests(&sema, position, search_scope, &mut res);\n \n-    res.into_iter().collect_vec()\n+    res.into_iter().collect()\n }\n \n fn find_related_tests(\n@@ -218,56 +218,59 @@ fn find_related_tests(\n     search_scope: Option<SearchScope>,\n     tests: &mut FxHashSet<Runnable>,\n ) {\n-    if let Some(refs) = references::find_all_refs(sema, position, search_scope) {\n-        for (file_id, refs) in refs.into_iter().flat_map(|refs| refs.references) {\n-            let file = sema.parse(file_id);\n-            let file = file.syntax();\n-\n-            // create flattened vec of tokens\n-            let tokens = refs.iter().flat_map(|(range, _)| {\n-                match file.token_at_offset(range.start()).next() {\n-                    Some(token) => sema.descend_into_macros(token),\n-                    None => Default::default(),\n-                }\n+    let refs = match references::find_all_refs(sema, position, search_scope) {\n+        Some(it) => it,\n+        _ => return,\n+    };\n+    for (file_id, refs) in refs.into_iter().flat_map(|refs| refs.references) {\n+        let file = sema.parse(file_id);\n+        let file = file.syntax();\n+\n+        // create flattened vec of tokens\n+        let tokens =\n+            refs.iter().flat_map(|(range, _)| match file.token_at_offset(range.start()).next() {\n+                Some(token) => sema.descend_into_macros(token),\n+                None => Default::default(),\n             });\n \n-            // find first suitable ancestor\n-            let functions = tokens\n-                .filter_map(|token| token.ancestors().find_map(ast::Fn::cast))\n-                .map(|f| hir::InFile::new(sema.hir_file_for(f.syntax()), f));\n-\n-            for fn_def in functions {\n-                let InFile { value: fn_def, .. } = &fn_def;\n-                if let Some(runnable) = as_test_runnable(sema, fn_def) {\n-                    // direct test\n-                    tests.insert(runnable);\n-                } else if let Some(module) = parent_test_module(sema, fn_def) {\n-                    // indirect test\n-                    find_related_tests_in_module(sema, fn_def, &module, tests);\n-                }\n+        // find first suitable ancestor\n+        let functions = tokens\n+            .filter_map(|token| token.ancestors().find_map(ast::Fn::cast))\n+            .map(|f| hir::InFile::new(sema.hir_file_for(f.syntax()), f));\n+\n+        for InFile { value: fn_def, .. } in functions {\n+            if let Some(runnable) = as_test_runnable(sema, &fn_def) {\n+                // direct test\n+                tests.insert(runnable);\n+            } else if let Some(module) = parent_test_module(sema, &fn_def) {\n+                // indirect test\n+                find_related_tests_in_module(sema, &fn_def, &module, tests);\n             }\n         }\n     }\n }\n+\n fn find_related_tests_in_module(\n     sema: &Semantics<RootDatabase>,\n     fn_def: &ast::Fn,\n     parent_module: &hir::Module,\n     tests: &mut FxHashSet<Runnable>,\n ) {\n-    if let Some(fn_name) = fn_def.name() {\n-        let mod_source = parent_module.definition_source(sema.db);\n-        let range = match mod_source.value {\n-            hir::ModuleSource::Module(m) => m.syntax().text_range(),\n-            hir::ModuleSource::BlockExpr(b) => b.syntax().text_range(),\n-            hir::ModuleSource::SourceFile(f) => f.syntax().text_range(),\n-        };\n+    let fn_name = match fn_def.name() {\n+        Some(it) => it,\n+        _ => return,\n+    };\n+    let mod_source = parent_module.definition_source(sema.db);\n+    let range = match &mod_source.value {\n+        hir::ModuleSource::Module(m) => m.syntax().text_range(),\n+        hir::ModuleSource::BlockExpr(b) => b.syntax().text_range(),\n+        hir::ModuleSource::SourceFile(f) => f.syntax().text_range(),\n+    };\n \n-        let file_id = mod_source.file_id.original_file(sema.db);\n-        let mod_scope = SearchScope::file_range(FileRange { file_id, range });\n-        let fn_pos = FilePosition { file_id, offset: fn_name.syntax().text_range().start() };\n-        find_related_tests(sema, fn_pos, Some(mod_scope), tests)\n-    }\n+    let file_id = mod_source.file_id.original_file(sema.db);\n+    let mod_scope = SearchScope::file_range(FileRange { file_id, range });\n+    let fn_pos = FilePosition { file_id, offset: fn_name.syntax().text_range().start() };\n+    find_related_tests(sema, fn_pos, Some(mod_scope), tests)\n }\n \n fn as_test_runnable(sema: &Semantics<RootDatabase>, fn_def: &ast::Fn) -> Option<Runnable> {"}]}