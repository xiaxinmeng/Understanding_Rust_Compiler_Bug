{"sha": "29a946203aeebdd0d8466968705694fea9ca866f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI5YTk0NjIwM2FlZWJkZDBkODQ2Njk2ODcwNTY5NGZlYTljYTg2NmY=", "commit": {"author": {"name": "Tyler Mandry", "email": "tmandry@gmail.com", "date": "2020-08-15T03:07:16Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-08-15T03:07:16Z"}, "message": "Rollup merge of #75545 - eddyb:instant-sub-branchless, r=sfackler\n\nstd/sys/unix/time: make it easier for LLVM to optimize `Instant` subtraction.\n\nThis PR is the minimal change necessary to get LLVM to optimize `if self.t.tv_nsec >= other.t.tv_nsec` to branchless instructions (at least on x86_64), inspired by @m-ou-se's own attempts at optimizing `Instant` subtraction.\n\nI stumbled over this by looking at the total number of instructions executed by `rustc -Z self-profile`, and found that after disabling ASLR, the largest source of non-determinism remaining was from this `if` taking one branch or the other, depending on the values involved.\n\nThe reason this code is even called so many times to make a difference, is that `measureme` (the `-Z self-profile` implementation) currently uses `Instant::elapsed` for its event timestamps (of which there can be millions).\n\nI doubt it's critical to land this, although perhaps it could slightly improve some forms of benchmarking.", "tree": {"sha": "aa173050fa295a736d6ab1e5a1a23529262e1b9b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aa173050fa295a736d6ab1e5a1a23529262e1b9b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/29a946203aeebdd0d8466968705694fea9ca866f", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfN1FkCRBK7hj4Ov3rIwAAdHIIAItrOmWrevL3pCrdGixYIonE\nda6snwBpjh4W3+MiTsnvRSu6cbBTWWIUwcNFVYA/TNEptzISj9Vbs7xYlewsvUp7\nl/kZVtpYZql2NAyiBTlkzPcmdApuII4hYaaEKNKPRhzeq1AEbm75yexNl7wCCmJF\n0eebQR5Zc6UPDSGSOvdCg+EWUV9/knrsqCCGPy1zWTN1Qtg08yZdZ4IQfR/KIAnX\nYeuRDPxn8O96Stj6WbdBCC9cxPWQSI8AwFy7umU9oA/Yn4J0ZbGnrb2l7MKaOcpb\nxiVR3tv1rxdI8kchgLMCRiJvi77cvkYMyppkAuka7HgtRwD1qy9Fm+b0NYvA4Wk=\n=atIO\n-----END PGP SIGNATURE-----\n", "payload": "tree aa173050fa295a736d6ab1e5a1a23529262e1b9b\nparent e38eaf22d247644e5554d0c200e6df756e469b0a\nparent a7ad899f9dbce1b4a0beb56650bc72732f204d24\nauthor Tyler Mandry <tmandry@gmail.com> 1597460836 -0700\ncommitter GitHub <noreply@github.com> 1597460836 -0700\n\nRollup merge of #75545 - eddyb:instant-sub-branchless, r=sfackler\n\nstd/sys/unix/time: make it easier for LLVM to optimize `Instant` subtraction.\n\nThis PR is the minimal change necessary to get LLVM to optimize `if self.t.tv_nsec >= other.t.tv_nsec` to branchless instructions (at least on x86_64), inspired by @m-ou-se's own attempts at optimizing `Instant` subtraction.\n\nI stumbled over this by looking at the total number of instructions executed by `rustc -Z self-profile`, and found that after disabling ASLR, the largest source of non-determinism remaining was from this `if` taking one branch or the other, depending on the values involved.\n\nThe reason this code is even called so many times to make a difference, is that `measureme` (the `-Z self-profile` implementation) currently uses `Instant::elapsed` for its event timestamps (of which there can be millions).\n\nI doubt it's critical to land this, although perhaps it could slightly improve some forms of benchmarking.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/29a946203aeebdd0d8466968705694fea9ca866f", "html_url": "https://github.com/rust-lang/rust/commit/29a946203aeebdd0d8466968705694fea9ca866f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/29a946203aeebdd0d8466968705694fea9ca866f/comments", "author": {"login": "tmandry", "id": 2280544, "node_id": "MDQ6VXNlcjIyODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/2280544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmandry", "html_url": "https://github.com/tmandry", "followers_url": "https://api.github.com/users/tmandry/followers", "following_url": "https://api.github.com/users/tmandry/following{/other_user}", "gists_url": "https://api.github.com/users/tmandry/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmandry/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmandry/subscriptions", "organizations_url": "https://api.github.com/users/tmandry/orgs", "repos_url": "https://api.github.com/users/tmandry/repos", "events_url": "https://api.github.com/users/tmandry/events{/privacy}", "received_events_url": "https://api.github.com/users/tmandry/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e38eaf22d247644e5554d0c200e6df756e469b0a", "url": "https://api.github.com/repos/rust-lang/rust/commits/e38eaf22d247644e5554d0c200e6df756e469b0a", "html_url": "https://github.com/rust-lang/rust/commit/e38eaf22d247644e5554d0c200e6df756e469b0a"}, {"sha": "a7ad899f9dbce1b4a0beb56650bc72732f204d24", "url": "https://api.github.com/repos/rust-lang/rust/commits/a7ad899f9dbce1b4a0beb56650bc72732f204d24", "html_url": "https://github.com/rust-lang/rust/commit/a7ad899f9dbce1b4a0beb56650bc72732f204d24"}], "stats": {"total": 28, "additions": 20, "deletions": 8}, "files": [{"sha": "f2a9cb5a0e8795a4126aed38ebc0224b723b8cd9", "filename": "library/std/src/sys/unix/time.rs", "status": "modified", "additions": 20, "deletions": 8, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/29a946203aeebdd0d8466968705694fea9ca866f/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29a946203aeebdd0d8466968705694fea9ca866f/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ftime.rs?ref=29a946203aeebdd0d8466968705694fea9ca866f", "patch": "@@ -20,17 +20,29 @@ impl Timespec {\n \n     fn sub_timespec(&self, other: &Timespec) -> Result<Duration, Duration> {\n         if self >= other {\n-            Ok(if self.t.tv_nsec >= other.t.tv_nsec {\n-                Duration::new(\n-                    (self.t.tv_sec - other.t.tv_sec) as u64,\n-                    (self.t.tv_nsec - other.t.tv_nsec) as u32,\n-                )\n+            // NOTE(eddyb) two aspects of this `if`-`else` are required for LLVM\n+            // to optimize it into a branchless form (see also #75545):\n+            //\n+            // 1. `self.t.tv_sec - other.t.tv_sec` shows up as a common expression\n+            //    in both branches, i.e. the `else` must have its `- 1`\n+            //    subtraction after the common one, not interleaved with it\n+            //    (it used to be `self.t.tv_sec - 1 - other.t.tv_sec`)\n+            //\n+            // 2. the `Duration::new` call (or any other additional complexity)\n+            //    is outside of the `if`-`else`, not duplicated in both branches\n+            //\n+            // Ideally this code could be rearranged such that it more\n+            // directly expresses the lower-cost behavior we want from it.\n+            let (secs, nsec) = if self.t.tv_nsec >= other.t.tv_nsec {\n+                ((self.t.tv_sec - other.t.tv_sec) as u64, (self.t.tv_nsec - other.t.tv_nsec) as u32)\n             } else {\n-                Duration::new(\n-                    (self.t.tv_sec - 1 - other.t.tv_sec) as u64,\n+                (\n+                    (self.t.tv_sec - other.t.tv_sec - 1) as u64,\n                     self.t.tv_nsec as u32 + (NSEC_PER_SEC as u32) - other.t.tv_nsec as u32,\n                 )\n-            })\n+            };\n+\n+            Ok(Duration::new(secs, nsec))\n         } else {\n             match other.sub_timespec(self) {\n                 Ok(d) => Err(d),"}]}