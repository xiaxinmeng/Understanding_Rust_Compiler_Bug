{"sha": "2b9fea1300b515e0f8929bb3a09d4fb6fef3f0ea", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJiOWZlYTEzMDBiNTE1ZTBmODkyOWJiM2EwOWQ0ZmI2ZmVmM2YwZWE=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2017-03-09T18:10:05Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2017-03-18T00:53:07Z"}, "message": "move the drop expansion code to rustc_mir", "tree": {"sha": "7a9d037e3cef30a34171c4a0f01489b01b28f7c9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7a9d037e3cef30a34171c4a0f01489b01b28f7c9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2b9fea1300b515e0f8929bb3a09d4fb6fef3f0ea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2b9fea1300b515e0f8929bb3a09d4fb6fef3f0ea", "html_url": "https://github.com/rust-lang/rust/commit/2b9fea1300b515e0f8929bb3a09d4fb6fef3f0ea", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2b9fea1300b515e0f8929bb3a09d4fb6fef3f0ea/comments", "author": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e1f3c67cb4e2eb1595040888e897e48c64afb4be", "url": "https://api.github.com/repos/rust-lang/rust/commits/e1f3c67cb4e2eb1595040888e897e48c64afb4be", "html_url": "https://github.com/rust-lang/rust/commit/e1f3c67cb4e2eb1595040888e897e48c64afb4be"}], "stats": {"total": 1349, "additions": 728, "deletions": 621}, "files": [{"sha": "7f95f07f48d4ab3d6f062abb33a4aff6046ba779", "filename": "src/librustc_borrowck/borrowck/mir/dataflow/graphviz.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2b9fea1300b515e0f8929bb3a09d4fb6fef3f0ea/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b9fea1300b515e0f8929bb3a09d4fb6fef3f0ea/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fgraphviz.rs?ref=2b9fea1300b515e0f8929bb3a09d4fb6fef3f0ea", "patch": "@@ -15,6 +15,7 @@ use rustc::mir::{BasicBlock, Mir};\n use rustc_data_structures::bitslice::bits_to_string;\n use rustc_data_structures::indexed_set::{IdxSet};\n use rustc_data_structures::indexed_vec::Idx;\n+use rustc_mir::util as mir_util;\n \n use dot;\n use dot::IntoCow;\n@@ -219,7 +220,7 @@ impl<'a, 'tcx, MWF, P> dot::Labeller<'a> for Graph<'a, 'tcx, MWF, P>\n             }\n             Ok(())\n         }\n-        ::rustc_mir::graphviz::write_node_label(\n+        mir_util::write_graphviz_node_label(\n             *n, self.mbcx.mir(), &mut v, 4,\n             |w| {\n                 let flow = self.mbcx.flow_state();"}, {"sha": "da8aa231ccf157219d590059189e279d4e3605a8", "filename": "src/librustc_borrowck/borrowck/mir/dataflow/impls.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2b9fea1300b515e0f8929bb3a09d4fb6fef3f0ea/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fimpls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b9fea1300b515e0f8929bb3a09d4fb6fef3f0ea/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fimpls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fimpls.rs?ref=2b9fea1300b515e0f8929bb3a09d4fb6fef3f0ea", "patch": "@@ -14,10 +14,10 @@ use rustc_data_structures::bitslice::BitSlice; // adds set_bit/get_bit to &[usiz\n use rustc_data_structures::bitslice::{BitwiseOperator};\n use rustc_data_structures::indexed_set::{IdxSet};\n use rustc_data_structures::indexed_vec::Idx;\n+use rustc_mir::util::elaborate_drops::DropFlagState;\n \n use super::super::gather_moves::{HasMoveData, MoveData, MoveOutIndex, MovePathIndex};\n use super::super::MoveDataParamEnv;\n-use super::super::DropFlagState;\n use super::super::drop_flag_effects_for_function_entry;\n use super::super::drop_flag_effects_for_location;\n use super::super::on_lookup_result_bits;"}, {"sha": "88ec86cc95d614dfe461a30620d73dc6c5c9a064", "filename": "src/librustc_borrowck/borrowck/mir/elaborate_drops.rs", "status": "modified", "additions": 135, "deletions": 592, "changes": 727, "blob_url": "https://github.com/rust-lang/rust/blob/2b9fea1300b515e0f8929bb3a09d4fb6fef3f0ea/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b9fea1300b515e0f8929bb3a09d4fb6fef3f0ea/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs?ref=2b9fea1300b515e0f8929bb3a09d4fb6fef3f0ea", "patch": "@@ -13,22 +13,20 @@ use super::dataflow::{MaybeInitializedLvals, MaybeUninitializedLvals};\n use super::dataflow::{DataflowResults};\n use super::{drop_flag_effects_for_location, on_all_children_bits};\n use super::on_lookup_result_bits;\n-use super::{DropFlagState, MoveDataParamEnv};\n-use super::patch::MirPatch;\n-use rustc::ty::{self, Ty, TyCtxt};\n-use rustc::ty::subst::{Kind, Subst, Substs};\n-use rustc::ty::util::IntTypeExt;\n+use super::MoveDataParamEnv;\n+use rustc::ty::{self, TyCtxt};\n use rustc::mir::*;\n use rustc::mir::transform::{Pass, MirPass, MirSource};\n use rustc::middle::const_val::ConstVal;\n-use rustc::middle::lang_items;\n use rustc::util::nodemap::FxHashMap;\n use rustc_data_structures::indexed_set::IdxSetBuf;\n use rustc_data_structures::indexed_vec::Idx;\n+use rustc_mir::util::patch::MirPatch;\n+use rustc_mir::util::elaborate_drops::{DropFlagState, elaborate_drop};\n+use rustc_mir::util::elaborate_drops::{DropElaborator, DropStyle, DropFlagMode};\n use syntax_pos::Span;\n \n use std::fmt;\n-use std::iter;\n use std::u32;\n \n pub struct ElaborateDrops;\n@@ -109,12 +107,116 @@ impl InitializationData {\n     }\n }\n \n-impl fmt::Debug for InitializationData {\n+struct Elaborator<'a, 'b: 'a, 'tcx: 'b> {\n+    init_data: &'a InitializationData,\n+    ctxt: &'a mut ElaborateDropsCtxt<'b, 'tcx>,\n+}\n+\n+impl<'a, 'b, 'tcx> fmt::Debug for Elaborator<'a, 'b, 'tcx> {\n     fn fmt(&self, _f: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n         Ok(())\n     }\n }\n \n+impl<'a, 'b, 'tcx> DropElaborator<'a, 'tcx> for Elaborator<'a, 'b, 'tcx> {\n+    type Path = MovePathIndex;\n+\n+    fn patch(&mut self) -> &mut MirPatch<'tcx> {\n+        &mut self.ctxt.patch\n+    }\n+\n+    fn mir(&self) -> &'a Mir<'tcx> {\n+        self.ctxt.mir\n+    }\n+\n+    fn tcx(&self) -> ty::TyCtxt<'a, 'tcx, 'tcx> {\n+        self.ctxt.tcx\n+    }\n+\n+    fn param_env(&self) -> &'a ty::ParameterEnvironment<'tcx> {\n+        self.ctxt.param_env()\n+    }\n+\n+    fn drop_style(&self, path: Self::Path, mode: DropFlagMode) -> DropStyle {\n+        let ((maybe_live, maybe_dead), multipart) = match mode {\n+            DropFlagMode::Shallow => (self.init_data.state(path), false),\n+            DropFlagMode::Deep => {\n+                let mut some_live = false;\n+                let mut some_dead = false;\n+                let mut children_count = 0;\n+                on_all_children_bits(\n+                    self.tcx(), self.mir(), self.ctxt.move_data(),\n+                    path, |child| {\n+                        if self.ctxt.path_needs_drop(child) {\n+                            let (live, dead) = self.init_data.state(child);\n+                            debug!(\"elaborate_drop: state({:?}) = {:?}\",\n+                                   child, (live, dead));\n+                            some_live |= live;\n+                            some_dead |= dead;\n+                            children_count += 1;\n+                        }\n+                    });\n+                ((some_live, some_dead), children_count != 1)\n+            }\n+        };\n+        match (maybe_live, maybe_dead, multipart) {\n+            (false, _, _) => DropStyle::Dead,\n+            (true, false, _) => DropStyle::Static,\n+            (true, true, false) => DropStyle::Conditional,\n+            (true, true, true) => DropStyle::Open,\n+        }\n+    }\n+\n+    fn clear_drop_flag(&mut self, loc: Location, path: Self::Path, mode: DropFlagMode) {\n+        match mode {\n+            DropFlagMode::Shallow => {\n+                self.ctxt.set_drop_flag(loc, path, DropFlagState::Absent);\n+            }\n+            DropFlagMode::Deep => {\n+                on_all_children_bits(\n+                    self.tcx(), self.mir(), self.ctxt.move_data(), path,\n+                    |child| self.ctxt.set_drop_flag(loc, child, DropFlagState::Absent)\n+                 );\n+            }\n+        }\n+    }\n+\n+    fn field_subpath(&self, path: Self::Path, field: Field) -> Option<Self::Path> {\n+        super::move_path_children_matching(self.ctxt.move_data(), path, |p| {\n+            match p {\n+                &Projection {\n+                    elem: ProjectionElem::Field(idx, _), ..\n+                } => idx == field,\n+                _ => false\n+            }\n+        })\n+    }\n+\n+    fn deref_subpath(&self, path: Self::Path) -> Option<Self::Path> {\n+        super::move_path_children_matching(self.ctxt.move_data(), path, |p| {\n+            match p {\n+                &Projection { elem: ProjectionElem::Deref, .. } => true,\n+                _ => false\n+            }\n+        })\n+    }\n+\n+    fn downcast_subpath(&self, path: Self::Path, variant: usize) -> Option<Self::Path> {\n+        super::move_path_children_matching(self.ctxt.move_data(), path, |p| {\n+            match p {\n+                &Projection {\n+                    elem: ProjectionElem::Downcast(_, idx), ..\n+                } => idx == variant,\n+                _ => false\n+            }\n+        })\n+    }\n+\n+    fn get_drop_flag(&mut self, path: Self::Path) -> Option<Operand<'tcx>> {\n+        self.ctxt.drop_flag(path).map(Operand::Consume)\n+    }\n+}\n+\n struct ElaborateDropsCtxt<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     mir: &'a Mir<'tcx>,\n@@ -125,19 +227,6 @@ struct ElaborateDropsCtxt<'a, 'tcx: 'a> {\n     patch: MirPatch<'tcx>,\n }\n \n-#[derive(Copy, Clone, Debug)]\n-struct DropCtxt<'a, 'tcx: 'a> {\n-    source_info: SourceInfo,\n-    is_cleanup: bool,\n-\n-    init_data: &'a InitializationData,\n-\n-    lvalue: &'a Lvalue<'tcx>,\n-    path: MovePathIndex,\n-    succ: BasicBlock,\n-    unwind: Option<BasicBlock>\n-}\n-\n impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n     fn move_data(&self) -> &'b MoveData<'tcx> { &self.env.move_data }\n     fn param_env(&self) -> &'b ty::ParameterEnvironment<'tcx> {\n@@ -254,19 +343,22 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n                     let init_data = self.initialization_data_at(loc);\n                     match self.move_data().rev_lookup.find(location) {\n                         LookupResult::Exact(path) => {\n-                            self.elaborate_drop(&DropCtxt {\n-                                source_info: terminator.source_info,\n-                                is_cleanup: data.is_cleanup,\n-                                init_data: &init_data,\n-                                lvalue: location,\n-                                path: path,\n-                                succ: target,\n-                                unwind: if data.is_cleanup {\n+                            elaborate_drop(\n+                                &mut Elaborator {\n+                                    init_data: &init_data,\n+                                    ctxt: self\n+                                },\n+                                terminator.source_info,\n+                                data.is_cleanup,\n+                                location,\n+                                path,\n+                                target,\n+                                if data.is_cleanup {\n                                     None\n                                 } else {\n                                     Some(Option::unwrap_or(unwind, resume_block))\n-                                }\n-                            }, bb);\n+                                },\n+                                bb)\n                         }\n                         LookupResult::Parent(..) => {\n                             span_bug!(terminator.source_info.span,\n@@ -343,15 +435,18 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n                 debug!(\"elaborate_drop_and_replace({:?}) - tracked {:?}\", terminator, path);\n                 let init_data = self.initialization_data_at(loc);\n \n-                self.elaborate_drop(&DropCtxt {\n-                    source_info: terminator.source_info,\n-                    is_cleanup: data.is_cleanup,\n-                    init_data: &init_data,\n-                    lvalue: location,\n-                    path: path,\n-                    succ: target,\n-                    unwind: Some(unwind)\n-                }, bb);\n+                elaborate_drop(\n+                    &mut Elaborator {\n+                        init_data: &init_data,\n+                        ctxt: self\n+                    },\n+                    terminator.source_info,\n+                    data.is_cleanup,\n+                    location,\n+                    path,\n+                    target,\n+                    Some(unwind),\n+                    bb);\n                 on_all_children_bits(self.tcx, self.mir, self.move_data(), path, |child| {\n                     self.set_drop_flag(Location { block: target, statement_index: 0 },\n                                        child, DropFlagState::Present);\n@@ -372,547 +467,6 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n         }\n     }\n \n-    /// This elaborates a single drop instruction, located at `bb`, and\n-    /// patches over it.\n-    ///\n-    /// The elaborated drop checks the drop flags to only drop what\n-    /// is initialized.\n-    ///\n-    /// In addition, the relevant drop flags also need to be cleared\n-    /// to avoid double-drops. However, in the middle of a complex\n-    /// drop, one must avoid clearing some of the flags before they\n-    /// are read, as that would cause a memory leak.\n-    ///\n-    /// In particular, when dropping an ADT, multiple fields may be\n-    /// joined together under the `rest` subpath. They are all controlled\n-    /// by the primary drop flag, but only the last rest-field dropped\n-    /// should clear it (and it must also not clear anything else).\n-    ///\n-    /// FIXME: I think we should just control the flags externally\n-    /// and then we do not need this machinery.\n-    fn elaborate_drop<'a>(&mut self, c: &DropCtxt<'a, 'tcx>, bb: BasicBlock) {\n-        debug!(\"elaborate_drop({:?})\", c);\n-\n-        let mut some_live = false;\n-        let mut some_dead = false;\n-        let mut children_count = 0;\n-        on_all_children_bits(\n-            self.tcx, self.mir, self.move_data(),\n-            c.path, |child| {\n-                if self.path_needs_drop(child) {\n-                    let (live, dead) = c.init_data.state(child);\n-                    debug!(\"elaborate_drop: state({:?}) = {:?}\",\n-                           child, (live, dead));\n-                    some_live |= live;\n-                    some_dead |= dead;\n-                    children_count += 1;\n-                }\n-            });\n-\n-        debug!(\"elaborate_drop({:?}): live - {:?}\", c,\n-               (some_live, some_dead));\n-        match (some_live, some_dead) {\n-            (false, false) | (false, true) => {\n-                // dead drop - patch it out\n-                self.patch.patch_terminator(bb, TerminatorKind::Goto {\n-                    target: c.succ\n-                });\n-            }\n-            (true, false) => {\n-                // static drop - just set the flag\n-                self.patch.patch_terminator(bb, TerminatorKind::Drop {\n-                    location: c.lvalue.clone(),\n-                    target: c.succ,\n-                    unwind: c.unwind\n-                });\n-                self.drop_flags_for_drop(c, bb);\n-            }\n-            (true, true) => {\n-                // dynamic drop\n-                let drop_bb = if children_count == 1 || self.must_complete_drop(c) {\n-                    self.conditional_drop(c)\n-                } else {\n-                    self.open_drop(c)\n-                };\n-                self.patch.patch_terminator(bb, TerminatorKind::Goto {\n-                    target: drop_bb\n-                });\n-            }\n-        }\n-    }\n-\n-    /// Return the lvalue and move path for each field of `variant`,\n-    /// (the move path is `None` if the field is a rest field).\n-    fn move_paths_for_fields(&self,\n-                             base_lv: &Lvalue<'tcx>,\n-                             variant_path: MovePathIndex,\n-                             variant: &'tcx ty::VariantDef,\n-                             substs: &'tcx Substs<'tcx>)\n-                             -> Vec<(Lvalue<'tcx>, Option<MovePathIndex>)>\n-    {\n-        variant.fields.iter().enumerate().map(|(i, f)| {\n-            let subpath =\n-                super::move_path_children_matching(self.move_data(), variant_path, |p| {\n-                    match p {\n-                        &Projection {\n-                            elem: ProjectionElem::Field(idx, _), ..\n-                        } => idx.index() == i,\n-                        _ => false\n-                    }\n-                });\n-\n-            let field_ty =\n-                self.tcx.normalize_associated_type_in_env(\n-                    &f.ty(self.tcx, substs),\n-                    self.param_env()\n-                );\n-            (base_lv.clone().field(Field::new(i), field_ty), subpath)\n-        }).collect()\n-    }\n-\n-    /// Create one-half of the drop ladder for a list of fields, and return\n-    /// the list of steps in it in reverse order.\n-    ///\n-    /// `unwind_ladder` is such a list of steps in reverse order,\n-    /// which is called instead of the next step if the drop unwinds\n-    /// (the first field is never reached). If it is `None`, all\n-    /// unwind targets are left blank.\n-    fn drop_halfladder<'a>(&mut self,\n-                           c: &DropCtxt<'a, 'tcx>,\n-                           unwind_ladder: Option<Vec<BasicBlock>>,\n-                           succ: BasicBlock,\n-                           fields: &[(Lvalue<'tcx>, Option<MovePathIndex>)],\n-                           is_cleanup: bool)\n-                           -> Vec<BasicBlock>\n-    {\n-        let mut unwind_succ = if is_cleanup {\n-            None\n-        } else {\n-            c.unwind\n-        };\n-\n-        let mut succ = self.new_block(\n-            c, c.is_cleanup, TerminatorKind::Goto { target: succ }\n-        );\n-\n-        // Always clear the \"master\" drop flag at the bottom of the\n-        // ladder. This is needed because the \"master\" drop flag\n-        // protects the ADT's discriminant, which is invalidated\n-        // after the ADT is dropped.\n-        self.set_drop_flag(\n-            Location { block: succ, statement_index: 0 },\n-            c.path,\n-            DropFlagState::Absent\n-        );\n-\n-        fields.iter().rev().enumerate().map(|(i, &(ref lv, path))| {\n-            succ = if let Some(path) = path {\n-                debug!(\"drop_ladder: for std field {} ({:?})\", i, lv);\n-\n-                self.elaborated_drop_block(&DropCtxt {\n-                    source_info: c.source_info,\n-                    is_cleanup: is_cleanup,\n-                    init_data: c.init_data,\n-                    lvalue: lv,\n-                    path: path,\n-                    succ: succ,\n-                    unwind: unwind_succ,\n-                })\n-            } else {\n-                debug!(\"drop_ladder: for rest field {} ({:?})\", i, lv);\n-\n-                self.complete_drop(&DropCtxt {\n-                    source_info: c.source_info,\n-                    is_cleanup: is_cleanup,\n-                    init_data: c.init_data,\n-                    lvalue: lv,\n-                    path: c.path,\n-                    succ: succ,\n-                    unwind: unwind_succ,\n-                }, false)\n-            };\n-\n-            unwind_succ = unwind_ladder.as_ref().map(|p| p[i]);\n-            succ\n-        }).collect()\n-    }\n-\n-    /// Create a full drop ladder, consisting of 2 connected half-drop-ladders\n-    ///\n-    /// For example, with 3 fields, the drop ladder is\n-    ///\n-    /// .d0:\n-    ///     ELAB(drop location.0 [target=.d1, unwind=.c1])\n-    /// .d1:\n-    ///     ELAB(drop location.1 [target=.d2, unwind=.c2])\n-    /// .d2:\n-    ///     ELAB(drop location.2 [target=`c.succ`, unwind=`c.unwind`])\n-    /// .c1:\n-    ///     ELAB(drop location.1 [target=.c2])\n-    /// .c2:\n-    ///     ELAB(drop location.2 [target=`c.unwind])\n-    fn drop_ladder<'a>(&mut self,\n-                       c: &DropCtxt<'a, 'tcx>,\n-                       fields: Vec<(Lvalue<'tcx>, Option<MovePathIndex>)>)\n-                       -> BasicBlock\n-    {\n-        debug!(\"drop_ladder({:?}, {:?})\", c, fields);\n-\n-        let mut fields = fields;\n-        fields.retain(|&(ref lvalue, _)| {\n-            let ty = lvalue.ty(self.mir, self.tcx).to_ty(self.tcx);\n-            self.tcx.type_needs_drop_given_env(ty, self.param_env())\n-        });\n-\n-        debug!(\"drop_ladder - fields needing drop: {:?}\", fields);\n-\n-        let unwind_ladder = if c.is_cleanup {\n-            None\n-        } else {\n-            Some(self.drop_halfladder(c, None, c.unwind.unwrap(), &fields, true))\n-        };\n-\n-        self.drop_halfladder(c, unwind_ladder, c.succ, &fields, c.is_cleanup)\n-            .last().cloned().unwrap_or(c.succ)\n-    }\n-\n-    fn open_drop_for_tuple<'a>(&mut self, c: &DropCtxt<'a, 'tcx>, tys: &[Ty<'tcx>])\n-                               -> BasicBlock\n-    {\n-        debug!(\"open_drop_for_tuple({:?}, {:?})\", c, tys);\n-\n-        let fields = tys.iter().enumerate().map(|(i, &ty)| {\n-            (c.lvalue.clone().field(Field::new(i), ty),\n-             super::move_path_children_matching(\n-                 self.move_data(), c.path, |proj| match proj {\n-                     &Projection {\n-                         elem: ProjectionElem::Field(f, _), ..\n-                     } => f.index() == i,\n-                     _ => false\n-                 }\n-            ))\n-        }).collect();\n-\n-        self.drop_ladder(c, fields)\n-    }\n-\n-    fn open_drop_for_box<'a>(&mut self, c: &DropCtxt<'a, 'tcx>, ty: Ty<'tcx>)\n-                             -> BasicBlock\n-    {\n-        debug!(\"open_drop_for_box({:?}, {:?})\", c, ty);\n-\n-        let interior_path = super::move_path_children_matching(\n-            self.move_data(), c.path, |proj| match proj {\n-                &Projection { elem: ProjectionElem::Deref, .. } => true,\n-                _ => false\n-            }).unwrap();\n-\n-        let interior = c.lvalue.clone().deref();\n-        let inner_c = DropCtxt {\n-            lvalue: &interior,\n-            unwind: c.unwind.map(|u| {\n-                self.box_free_block(c, ty, u, true)\n-            }),\n-            succ: self.box_free_block(c, ty, c.succ, c.is_cleanup),\n-            path: interior_path,\n-            ..*c\n-        };\n-\n-        self.elaborated_drop_block(&inner_c)\n-    }\n-\n-    fn open_drop_for_adt<'a>(&mut self, c: &DropCtxt<'a, 'tcx>,\n-                             adt: &'tcx ty::AdtDef, substs: &'tcx Substs<'tcx>)\n-                             -> BasicBlock {\n-        debug!(\"open_drop_for_adt({:?}, {:?}, {:?})\", c, adt, substs);\n-\n-        match adt.variants.len() {\n-            1 => {\n-                let fields = self.move_paths_for_fields(\n-                    c.lvalue,\n-                    c.path,\n-                    &adt.variants[0],\n-                    substs\n-                );\n-                self.drop_ladder(c, fields)\n-            }\n-            _ => {\n-                let mut values = Vec::with_capacity(adt.variants.len());\n-                let mut blocks = Vec::with_capacity(adt.variants.len());\n-                let mut otherwise = None;\n-                for (variant_index, discr) in adt.discriminants(self.tcx).enumerate() {\n-                    let subpath = super::move_path_children_matching(\n-                        self.move_data(), c.path, |proj| match proj {\n-                            &Projection {\n-                                elem: ProjectionElem::Downcast(_, idx), ..\n-                            } => idx == variant_index,\n-                            _ => false\n-                        });\n-                    if let Some(variant_path) = subpath {\n-                        let base_lv = c.lvalue.clone().elem(\n-                            ProjectionElem::Downcast(adt, variant_index)\n-                        );\n-                        let fields = self.move_paths_for_fields(\n-                            &base_lv,\n-                            variant_path,\n-                            &adt.variants[variant_index],\n-                            substs);\n-                        values.push(discr);\n-                        blocks.push(self.drop_ladder(c, fields));\n-                    } else {\n-                        // variant not found - drop the entire enum\n-                        if let None = otherwise {\n-                            otherwise = Some(self.complete_drop(c, true));\n-                        }\n-                    }\n-                }\n-                if let Some(block) = otherwise {\n-                    blocks.push(block);\n-                } else {\n-                    values.pop();\n-                }\n-                // If there are multiple variants, then if something\n-                // is present within the enum the discriminant, tracked\n-                // by the rest path, must be initialized.\n-                //\n-                // Additionally, we do not want to switch on the\n-                // discriminant after it is free-ed, because that\n-                // way lies only trouble.\n-                let discr_ty = adt.repr.discr_type().to_ty(self.tcx);\n-                let discr = Lvalue::Local(self.patch.new_temp(discr_ty));\n-                let switch_block = self.patch.new_block(BasicBlockData {\n-                    statements: vec![\n-                        Statement {\n-                            source_info: c.source_info,\n-                            kind: StatementKind::Assign(discr.clone(),\n-                                                        Rvalue::Discriminant(c.lvalue.clone()))\n-                        }\n-                    ],\n-                    terminator: Some(Terminator {\n-                        source_info: c.source_info,\n-                        kind: TerminatorKind::SwitchInt {\n-                            discr: Operand::Consume(discr),\n-                            switch_ty: discr_ty,\n-                            values: From::from(values),\n-                            targets: blocks,\n-                        }\n-                    }),\n-                    is_cleanup: c.is_cleanup,\n-                });\n-                self.drop_flag_test_block(c, switch_block)\n-            }\n-        }\n-    }\n-\n-    /// The slow-path - create an \"open\", elaborated drop for a type\n-    /// which is moved-out-of only partially, and patch `bb` to a jump\n-    /// to it. This must not be called on ADTs with a destructor,\n-    /// as these can't be moved-out-of, except for `Box<T>`, which is\n-    /// special-cased.\n-    ///\n-    /// This creates a \"drop ladder\" that drops the needed fields of the\n-    /// ADT, both in the success case or if one of the destructors fail.\n-    fn open_drop<'a>(&mut self, c: &DropCtxt<'a, 'tcx>) -> BasicBlock {\n-        let ty = c.lvalue.ty(self.mir, self.tcx).to_ty(self.tcx);\n-        match ty.sty {\n-            ty::TyClosure(def_id, substs) => {\n-                let tys : Vec<_> = substs.upvar_tys(def_id, self.tcx).collect();\n-                self.open_drop_for_tuple(c, &tys)\n-            }\n-            ty::TyTuple(tys, _) => {\n-                self.open_drop_for_tuple(c, tys)\n-            }\n-            ty::TyAdt(def, _) if def.is_box() => {\n-                self.open_drop_for_box(c, ty.boxed_ty())\n-            }\n-            ty::TyAdt(def, substs) => {\n-                self.open_drop_for_adt(c, def, substs)\n-            }\n-            _ => bug!(\"open drop from non-ADT `{:?}`\", ty)\n-        }\n-    }\n-\n-    /// Return a basic block that drop an lvalue using the context\n-    /// and path in `c`. If `update_drop_flag` is true, also\n-    /// clear `c`.\n-    ///\n-    /// if FLAG(c.path)\n-    ///     if(update_drop_flag) FLAG(c.path) = false\n-    ///     drop(c.lv)\n-    fn complete_drop<'a>(\n-        &mut self,\n-        c: &DropCtxt<'a, 'tcx>,\n-        update_drop_flag: bool)\n-        -> BasicBlock\n-    {\n-        debug!(\"complete_drop({:?},{:?})\", c, update_drop_flag);\n-\n-        let drop_block = self.drop_block(c);\n-        if update_drop_flag {\n-            self.set_drop_flag(\n-                Location { block: drop_block, statement_index: 0 },\n-                c.path,\n-                DropFlagState::Absent\n-            );\n-        }\n-\n-        self.drop_flag_test_block(c, drop_block)\n-    }\n-\n-    /// Create a simple conditional drop.\n-    ///\n-    /// if FLAG(c.lv)\n-    ///     FLAGS(c.lv) = false\n-    ///     drop(c.lv)\n-    fn conditional_drop<'a>(&mut self, c: &DropCtxt<'a, 'tcx>)\n-                            -> BasicBlock\n-    {\n-        debug!(\"conditional_drop({:?})\", c);\n-        let drop_bb = self.drop_block(c);\n-        self.drop_flags_for_drop(c, drop_bb);\n-\n-        self.drop_flag_test_block(c, drop_bb)\n-    }\n-\n-    fn new_block<'a>(&mut self,\n-                     c: &DropCtxt<'a, 'tcx>,\n-                     is_cleanup: bool,\n-                     k: TerminatorKind<'tcx>)\n-                     -> BasicBlock\n-    {\n-        self.patch.new_block(BasicBlockData {\n-            statements: vec![],\n-            terminator: Some(Terminator {\n-                source_info: c.source_info, kind: k\n-            }),\n-            is_cleanup: is_cleanup\n-        })\n-    }\n-\n-    fn elaborated_drop_block<'a>(&mut self, c: &DropCtxt<'a, 'tcx>) -> BasicBlock {\n-        debug!(\"elaborated_drop_block({:?})\", c);\n-        let blk = self.drop_block(c);\n-        self.elaborate_drop(c, blk);\n-        blk\n-    }\n-\n-    fn drop_flag_test_block<'a>(&mut self,\n-                                c: &DropCtxt<'a, 'tcx>,\n-                                on_set: BasicBlock)\n-                                -> BasicBlock {\n-        self.drop_flag_test_block_with_succ(c, c.is_cleanup, on_set, c.succ)\n-    }\n-\n-    fn drop_flag_test_block_with_succ<'a>(&mut self,\n-                                          c: &DropCtxt<'a, 'tcx>,\n-                                          is_cleanup: bool,\n-                                          on_set: BasicBlock,\n-                                          on_unset: BasicBlock)\n-                                          -> BasicBlock\n-    {\n-        let (maybe_live, maybe_dead) = c.init_data.state(c.path);\n-        debug!(\"drop_flag_test_block({:?},{:?},{:?}) - {:?}\",\n-               c, is_cleanup, on_set, (maybe_live, maybe_dead));\n-\n-        match (maybe_live, maybe_dead) {\n-            (false, _) => on_unset,\n-            (true, false) => on_set,\n-            (true, true) => {\n-                let flag = self.drop_flag(c.path).unwrap();\n-                let term = TerminatorKind::if_(self.tcx, Operand::Consume(flag), on_set, on_unset);\n-                self.new_block(c, is_cleanup, term)\n-            }\n-        }\n-    }\n-\n-    fn drop_block<'a>(&mut self, c: &DropCtxt<'a, 'tcx>) -> BasicBlock {\n-        self.new_block(c, c.is_cleanup, TerminatorKind::Drop {\n-            location: c.lvalue.clone(),\n-            target: c.succ,\n-            unwind: c.unwind\n-        })\n-    }\n-\n-    fn box_free_block<'a>(\n-        &mut self,\n-        c: &DropCtxt<'a, 'tcx>,\n-        ty: Ty<'tcx>,\n-        target: BasicBlock,\n-        is_cleanup: bool\n-    ) -> BasicBlock {\n-        let block = self.unelaborated_free_block(c, ty, target, is_cleanup);\n-        self.drop_flag_test_block_with_succ(c, is_cleanup, block, target)\n-    }\n-\n-    fn unelaborated_free_block<'a>(\n-        &mut self,\n-        c: &DropCtxt<'a, 'tcx>,\n-        ty: Ty<'tcx>,\n-        target: BasicBlock,\n-        is_cleanup: bool\n-    ) -> BasicBlock {\n-        let mut statements = vec![];\n-        if let Some(&flag) = self.drop_flags.get(&c.path) {\n-            statements.push(Statement {\n-                source_info: c.source_info,\n-                kind: StatementKind::Assign(\n-                    Lvalue::Local(flag),\n-                    self.constant_bool(c.source_info.span, false)\n-                )\n-            });\n-        }\n-\n-        let tcx = self.tcx;\n-        let unit_temp = Lvalue::Local(self.patch.new_temp(tcx.mk_nil()));\n-        let free_func = tcx.require_lang_item(lang_items::BoxFreeFnLangItem);\n-        let substs = tcx.mk_substs(iter::once(Kind::from(ty)));\n-        let fty = tcx.item_type(free_func).subst(tcx, substs);\n-\n-        self.patch.new_block(BasicBlockData {\n-            statements: statements,\n-            terminator: Some(Terminator {\n-                source_info: c.source_info, kind: TerminatorKind::Call {\n-                    func: Operand::Constant(Constant {\n-                        span: c.source_info.span,\n-                        ty: fty,\n-                        literal: Literal::Item {\n-                            def_id: free_func,\n-                            substs: substs\n-                        }\n-                    }),\n-                    args: vec![Operand::Consume(c.lvalue.clone())],\n-                    destination: Some((unit_temp, target)),\n-                    cleanup: None\n-                }\n-            }),\n-            is_cleanup: is_cleanup\n-        })\n-    }\n-\n-    fn must_complete_drop<'a>(&self, c: &DropCtxt<'a, 'tcx>) -> bool {\n-        // if we have a destuctor, we must *not* split the drop.\n-\n-        // dataflow can create unneeded children in some cases\n-        // - be sure to ignore them.\n-\n-        let ty = c.lvalue.ty(self.mir, self.tcx).to_ty(self.tcx);\n-\n-        match ty.sty {\n-            ty::TyAdt(def, _) => {\n-                if def.has_dtor(self.tcx) && !def.is_box() {\n-                    self.tcx.sess.span_warn(\n-                        c.source_info.span,\n-                        &format!(\"dataflow bug??? moving out of type with dtor {:?}\",\n-                                 c));\n-                    true\n-                } else {\n-                    false\n-                }\n-            }\n-            _ => false\n-        }\n-    }\n-\n     fn constant_bool(&self, span: Span, val: bool) -> Rvalue<'tcx> {\n         Rvalue::Use(Operand::Constant(Constant {\n             span: span,\n@@ -1023,15 +577,4 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n             }\n         }\n     }\n-\n-    fn drop_flags_for_drop<'a>(&mut self,\n-                               c: &DropCtxt<'a, 'tcx>,\n-                               bb: BasicBlock)\n-    {\n-        let loc = self.patch.terminator_loc(self.mir, bb);\n-        on_all_children_bits(\n-            self.tcx, self.mir, self.move_data(), c.path,\n-            |child| self.set_drop_flag(loc, child, DropFlagState::Absent)\n-        );\n-    }\n }"}, {"sha": "9237bb31f6bd7f62c267550d29723c46d69bcf13", "filename": "src/librustc_borrowck/borrowck/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 16, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/2b9fea1300b515e0f8929bb3a09d4fb6fef3f0ea/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b9fea1300b515e0f8929bb3a09d4fb6fef3f0ea/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs?ref=2b9fea1300b515e0f8929bb3a09d4fb6fef3f0ea", "patch": "@@ -16,12 +16,12 @@ use syntax_pos::DUMMY_SP;\n use rustc::mir::{self, BasicBlock, BasicBlockData, Mir, Statement, Terminator, Location};\n use rustc::session::Session;\n use rustc::ty::{self, TyCtxt};\n+use rustc_mir::util::elaborate_drops::DropFlagState;\n \n mod abs_domain;\n pub mod elaborate_drops;\n mod dataflow;\n mod gather_moves;\n-mod patch;\n // mod graphviz;\n \n use self::dataflow::{BitDenotation};\n@@ -183,21 +183,6 @@ impl<'b, 'a: 'b, 'tcx: 'a> MirBorrowckCtxt<'b, 'a, 'tcx> {\n     }\n }\n \n-#[derive(Debug, PartialEq, Eq, Copy, Clone)]\n-enum DropFlagState {\n-    Present, // i.e. initialized\n-    Absent, // i.e. deinitialized or \"moved\"\n-}\n-\n-impl DropFlagState {\n-    fn value(self) -> bool {\n-        match self {\n-            DropFlagState::Present => true,\n-            DropFlagState::Absent => false\n-        }\n-    }\n-}\n-\n fn move_path_children_matching<'tcx, F>(move_data: &MoveData<'tcx>,\n                                         path: MovePathIndex,\n                                         mut cond: F)"}, {"sha": "6cd97e9559885048ac4f6905ecc257b5bf45e545", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2b9fea1300b515e0f8929bb3a09d4fb6fef3f0ea/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b9fea1300b515e0f8929bb3a09d4fb6fef3f0ea/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=2b9fea1300b515e0f8929bb3a09d4fb6fef3f0ea", "patch": "@@ -26,8 +26,7 @@ use rustc::session::config::Input;\n use rustc_borrowck as borrowck;\n use rustc_borrowck::graphviz as borrowck_dot;\n \n-use rustc_mir::pretty::write_mir_pretty;\n-use rustc_mir::graphviz::write_mir_graphviz;\n+use rustc_mir::util::{write_mir_pretty, write_mir_graphviz};\n \n use syntax::ast::{self, BlockCheckMode};\n use syntax::fold::{self, Folder};"}, {"sha": "590c6a430b98a2862970c58db9c28c8282bc50d5", "filename": "src/librustc_mir/lib.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2b9fea1300b515e0f8929bb3a09d4fb6fef3f0ea/src%2Flibrustc_mir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b9fea1300b515e0f8929bb3a09d4fb6fef3f0ea/src%2Flibrustc_mir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flib.rs?ref=2b9fea1300b515e0f8929bb3a09d4fb6fef3f0ea", "patch": "@@ -49,13 +49,11 @@ pub mod diagnostics;\n \n pub mod build;\n pub mod callgraph;\n-pub mod def_use;\n-pub mod graphviz;\n mod hair;\n mod shim;\n pub mod mir_map;\n-pub mod pretty;\n pub mod transform;\n+pub mod util;\n \n use rustc::ty::maps::Providers;\n "}, {"sha": "8c138d779c10687f274897e635476808e1227de5", "filename": "src/librustc_mir/mir_map.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2b9fea1300b515e0f8929bb3a09d4fb6fef3f0ea/src%2Flibrustc_mir%2Fmir_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b9fea1300b515e0f8929bb3a09d4fb6fef3f0ea/src%2Flibrustc_mir%2Fmir_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmir_map.rs?ref=2b9fea1300b515e0f8929bb3a09d4fb6fef3f0ea", "patch": "@@ -23,8 +23,8 @@ use rustc::mir::Mir;\n use rustc::mir::transform::MirSource;\n use rustc::mir::visit::MutVisitor;\n use shim;\n-use pretty;\n use hair::cx::Cx;\n+use util as mir_util;\n \n use rustc::traits::Reveal;\n use rustc::ty::{self, Ty, TyCtxt};\n@@ -175,7 +175,7 @@ fn build_mir<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n             mem::transmute::<Mir, Mir<'tcx>>(mir)\n         };\n \n-        pretty::dump_mir(tcx, \"mir_map\", &0, src, &mir);\n+        mir_util::dump_mir(tcx, \"mir_map\", &0, src, &mir);\n \n         tcx.alloc_mir(mir)\n     })\n@@ -234,7 +234,7 @@ fn create_constructor_shim<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 mem::transmute::<Mir, Mir<'tcx>>(mir)\n             };\n \n-            pretty::dump_mir(tcx, \"mir_map\", &0, src, &mir);\n+            mir_util::dump_mir(tcx, \"mir_map\", &0, src, &mir);\n \n             tcx.alloc_mir(mir)\n         })"}, {"sha": "5d127a5aed4618d0c5c76e8380f2eb744e346120", "filename": "src/librustc_mir/transform/copy_prop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2b9fea1300b515e0f8929bb3a09d4fb6fef3f0ea/src%2Flibrustc_mir%2Ftransform%2Fcopy_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b9fea1300b515e0f8929bb3a09d4fb6fef3f0ea/src%2Flibrustc_mir%2Ftransform%2Fcopy_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcopy_prop.rs?ref=2b9fea1300b515e0f8929bb3a09d4fb6fef3f0ea", "patch": "@@ -29,11 +29,11 @@\n //! (non-mutating) use of `SRC`. These restrictions are conservative and may be relaxed in the\n //! future.\n \n-use def_use::DefUseAnalysis;\n use rustc::mir::{Constant, Local, LocalKind, Location, Lvalue, Mir, Operand, Rvalue, StatementKind};\n use rustc::mir::transform::{MirPass, MirSource, Pass};\n use rustc::mir::visit::MutVisitor;\n use rustc::ty::TyCtxt;\n+use util::def_use::DefUseAnalysis;\n use transform::qualify_consts;\n \n pub struct CopyPropagation;"}, {"sha": "f22a71636a98e883028c090f294e964be3dea271", "filename": "src/librustc_mir/transform/dump_mir.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2b9fea1300b515e0f8929bb3a09d4fb6fef3f0ea/src%2Flibrustc_mir%2Ftransform%2Fdump_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b9fea1300b515e0f8929bb3a09d4fb6fef3f0ea/src%2Flibrustc_mir%2Ftransform%2Fdump_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fdump_mir.rs?ref=2b9fea1300b515e0f8929bb3a09d4fb6fef3f0ea", "patch": "@@ -15,7 +15,7 @@ use std::fmt;\n use rustc::ty::TyCtxt;\n use rustc::mir::*;\n use rustc::mir::transform::{Pass, MirPass, MirPassHook, MirSource};\n-use pretty;\n+use util as mir_util;\n \n pub struct Marker<'a>(pub &'a str);\n \n@@ -56,7 +56,7 @@ impl<'tcx> MirPassHook<'tcx> for DumpMir {\n         pass: &Pass,\n         is_after: bool)\n     {\n-        pretty::dump_mir(\n+        mir_util::dump_mir(\n             tcx,\n             &*pass.name(),\n             &Disambiguator {"}, {"sha": "d20d50c561140a3f6cf526c13a554c7737f5e48c", "filename": "src/librustc_mir/util/def_use.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/2b9fea1300b515e0f8929bb3a09d4fb6fef3f0ea/src%2Flibrustc_mir%2Futil%2Fdef_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b9fea1300b515e0f8929bb3a09d4fb6fef3f0ea/src%2Flibrustc_mir%2Futil%2Fdef_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fdef_use.rs?ref=2b9fea1300b515e0f8929bb3a09d4fb6fef3f0ea", "previous_filename": "src/librustc_mir/def_use.rs"}, {"sha": "ce6debab9a4b865feaebea9cb5c821777e0ace4d", "filename": "src/librustc_mir/util/elaborate_drops.rs", "status": "added", "additions": 561, "deletions": 0, "changes": 561, "blob_url": "https://github.com/rust-lang/rust/blob/2b9fea1300b515e0f8929bb3a09d4fb6fef3f0ea/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b9fea1300b515e0f8929bb3a09d4fb6fef3f0ea/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs?ref=2b9fea1300b515e0f8929bb3a09d4fb6fef3f0ea", "patch": "@@ -0,0 +1,561 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::fmt;\n+use rustc::mir::*;\n+use rustc::middle::lang_items;\n+use rustc::ty::{self, Ty};\n+use rustc::ty::subst::{Kind, Subst, Substs};\n+use rustc::ty::util::IntTypeExt;\n+use rustc_data_structures::indexed_vec::Idx;\n+use util::patch::MirPatch;\n+\n+use std::iter;\n+\n+#[derive(Debug, PartialEq, Eq, Copy, Clone)]\n+pub enum DropFlagState {\n+    Present, // i.e. initialized\n+    Absent, // i.e. deinitialized or \"moved\"\n+}\n+\n+impl DropFlagState {\n+    pub fn value(self) -> bool {\n+        match self {\n+            DropFlagState::Present => true,\n+            DropFlagState::Absent => false\n+        }\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub enum DropStyle {\n+    Dead,\n+    Static,\n+    Conditional,\n+    Open,\n+}\n+\n+#[derive(Debug)]\n+pub enum DropFlagMode {\n+    Shallow,\n+    Deep\n+}\n+\n+pub trait DropElaborator<'a, 'tcx: 'a> : fmt::Debug {\n+    type Path : Copy + fmt::Debug;\n+\n+    fn patch(&mut self) -> &mut MirPatch<'tcx>;\n+    fn mir(&self) -> &'a Mir<'tcx>;\n+    fn tcx(&self) -> ty::TyCtxt<'a, 'tcx, 'tcx>;\n+    fn param_env(&self) -> &'a ty::ParameterEnvironment<'tcx>;\n+\n+    fn drop_style(&self, path: Self::Path, mode: DropFlagMode) -> DropStyle;\n+    fn get_drop_flag(&mut self, path: Self::Path) -> Option<Operand<'tcx>>;\n+    fn clear_drop_flag(&mut self, location: Location, path: Self::Path, mode: DropFlagMode);\n+\n+\n+    fn field_subpath(&self, path: Self::Path, field: Field) -> Option<Self::Path>;\n+    fn deref_subpath(&self, path: Self::Path) -> Option<Self::Path>;\n+    fn downcast_subpath(&self, path: Self::Path, variant: usize) -> Option<Self::Path>;\n+}\n+\n+#[derive(Debug)]\n+struct DropCtxt<'l, 'b: 'l, 'tcx: 'b, D>\n+    where D : DropElaborator<'b, 'tcx> + 'l\n+{\n+    elaborator: &'l mut D,\n+\n+    source_info: SourceInfo,\n+    is_cleanup: bool,\n+\n+    lvalue: &'l Lvalue<'tcx>,\n+    path: D::Path,\n+    succ: BasicBlock,\n+    unwind: Option<BasicBlock>,\n+}\n+\n+pub fn elaborate_drop<'b, 'tcx, D>(\n+    elaborator: &mut D,\n+    source_info: SourceInfo,\n+    is_cleanup: bool,\n+    lvalue: &Lvalue<'tcx>,\n+    path: D::Path,\n+    succ: BasicBlock,\n+    unwind: Option<BasicBlock>,\n+    bb: BasicBlock)\n+    where D: DropElaborator<'b, 'tcx>\n+{\n+    DropCtxt {\n+        elaborator, source_info, is_cleanup, lvalue, path, succ, unwind\n+    }.elaborate_drop(bb)\n+}\n+\n+impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n+    where D: DropElaborator<'b, 'tcx>\n+{\n+    fn lvalue_ty(&self, lvalue: &Lvalue<'tcx>) -> Ty<'tcx> {\n+        lvalue.ty(self.elaborator.mir(), self.tcx()).to_ty(self.tcx())\n+    }\n+\n+    fn tcx(&self) -> ty::TyCtxt<'b, 'tcx, 'tcx> {\n+        self.elaborator.tcx()\n+    }\n+\n+    /// This elaborates a single drop instruction, located at `bb`, and\n+    /// patches over it.\n+    ///\n+    /// The elaborated drop checks the drop flags to only drop what\n+    /// is initialized.\n+    ///\n+    /// In addition, the relevant drop flags also need to be cleared\n+    /// to avoid double-drops. However, in the middle of a complex\n+    /// drop, one must avoid clearing some of the flags before they\n+    /// are read, as that would cause a memory leak.\n+    ///\n+    /// In particular, when dropping an ADT, multiple fields may be\n+    /// joined together under the `rest` subpath. They are all controlled\n+    /// by the primary drop flag, but only the last rest-field dropped\n+    /// should clear it (and it must also not clear anything else).\n+    ///\n+    /// FIXME: I think we should just control the flags externally\n+    /// and then we do not need this machinery.\n+    pub fn elaborate_drop<'a>(&mut self, bb: BasicBlock) {\n+        debug!(\"elaborate_drop({:?})\", self);\n+        let style = self.elaborator.drop_style(self.path, DropFlagMode::Deep);\n+        debug!(\"elaborate_drop({:?}): live - {:?}\", self, style);\n+        match style {\n+            DropStyle::Dead => {\n+                self.elaborator.patch().patch_terminator(bb, TerminatorKind::Goto {\n+                    target: self.succ\n+                });\n+            }\n+            DropStyle::Static => {\n+                let loc = self.terminator_loc(bb);\n+                self.elaborator.clear_drop_flag(loc, self.path, DropFlagMode::Deep);\n+                self.elaborator.patch().patch_terminator(bb, TerminatorKind::Drop {\n+                    location: self.lvalue.clone(),\n+                    target: self.succ,\n+                    unwind: self.unwind\n+                });\n+            }\n+            DropStyle::Conditional => {\n+                let drop_bb = self.complete_drop(Some(DropFlagMode::Deep));\n+                self.elaborator.patch().patch_terminator(bb, TerminatorKind::Goto {\n+                    target: drop_bb\n+                });\n+            }\n+            DropStyle::Open => {\n+                let drop_bb = self.open_drop();\n+                self.elaborator.patch().patch_terminator(bb, TerminatorKind::Goto {\n+                    target: drop_bb\n+                });\n+            }\n+        }\n+    }\n+\n+    /// Return the lvalue and move path for each field of `variant`,\n+    /// (the move path is `None` if the field is a rest field).\n+    fn move_paths_for_fields(&self,\n+                             base_lv: &Lvalue<'tcx>,\n+                             variant_path: D::Path,\n+                             variant: &'tcx ty::VariantDef,\n+                             substs: &'tcx Substs<'tcx>)\n+                             -> Vec<(Lvalue<'tcx>, Option<D::Path>)>\n+    {\n+        variant.fields.iter().enumerate().map(|(i, f)| {\n+            let field = Field::new(i);\n+            let subpath = self.elaborator.field_subpath(variant_path, field);\n+\n+            let field_ty =\n+                self.tcx().normalize_associated_type_in_env(\n+                    &f.ty(self.tcx(), substs),\n+                    self.elaborator.param_env()\n+                );\n+            (base_lv.clone().field(field, field_ty), subpath)\n+        }).collect()\n+    }\n+\n+    fn drop_subpath(&mut self,\n+                    is_cleanup: bool,\n+                    lvalue: &Lvalue<'tcx>,\n+                    path: Option<D::Path>,\n+                    succ: BasicBlock,\n+                    unwind: Option<BasicBlock>)\n+                    -> BasicBlock\n+    {\n+        if let Some(path) = path {\n+            debug!(\"drop_subpath: for std field {:?}\", lvalue);\n+\n+            DropCtxt {\n+                elaborator: self.elaborator,\n+                source_info: self.source_info,\n+                path, lvalue, succ, unwind, is_cleanup\n+            }.elaborated_drop_block()\n+        } else {\n+            debug!(\"drop_subpath: for rest field {:?}\", lvalue);\n+\n+            DropCtxt {\n+                elaborator: self.elaborator,\n+                source_info: self.source_info,\n+                lvalue, succ, unwind, is_cleanup,\n+                // Using `self.path` here to condition the drop on\n+                // our own drop flag.\n+                path: self.path\n+            }.complete_drop(None)\n+        }\n+    }\n+\n+    /// Create one-half of the drop ladder for a list of fields, and return\n+    /// the list of steps in it in reverse order.\n+    ///\n+    /// `unwind_ladder` is such a list of steps in reverse order,\n+    /// which is called instead of the next step if the drop unwinds\n+    /// (the first field is never reached). If it is `None`, all\n+    /// unwind targets are left blank.\n+    fn drop_halfladder<'a>(&mut self,\n+                           unwind_ladder: Option<Vec<BasicBlock>>,\n+                           succ: BasicBlock,\n+                           fields: &[(Lvalue<'tcx>, Option<D::Path>)],\n+                           is_cleanup: bool)\n+                           -> Vec<BasicBlock>\n+    {\n+        let mut unwind_succ = if is_cleanup {\n+            None\n+        } else {\n+            self.unwind\n+        };\n+\n+        let goto = TerminatorKind::Goto { target: succ };\n+        let mut succ = self.new_block(is_cleanup, goto);\n+\n+        // Always clear the \"master\" drop flag at the bottom of the\n+        // ladder. This is needed because the \"master\" drop flag\n+        // protects the ADT's discriminant, which is invalidated\n+        // after the ADT is dropped.\n+        let succ_loc = Location { block: succ, statement_index: 0 };\n+        self.elaborator.clear_drop_flag(succ_loc, self.path, DropFlagMode::Shallow);\n+\n+        fields.iter().rev().enumerate().map(|(i, &(ref lv, path))| {\n+            succ = self.drop_subpath(is_cleanup, lv, path, succ, unwind_succ);\n+            unwind_succ = unwind_ladder.as_ref().map(|p| p[i]);\n+            succ\n+        }).collect()\n+    }\n+\n+    /// Create a full drop ladder, consisting of 2 connected half-drop-ladders\n+    ///\n+    /// For example, with 3 fields, the drop ladder is\n+    ///\n+    /// .d0:\n+    ///     ELAB(drop location.0 [target=.d1, unwind=.c1])\n+    /// .d1:\n+    ///     ELAB(drop location.1 [target=.d2, unwind=.c2])\n+    /// .d2:\n+    ///     ELAB(drop location.2 [target=`self.succ`, unwind=`self.unwind`])\n+    /// .c1:\n+    ///     ELAB(drop location.1 [target=.c2])\n+    /// .c2:\n+    ///     ELAB(drop location.2 [target=`self.unwind])\n+    fn drop_ladder<'a>(&mut self,\n+                       fields: Vec<(Lvalue<'tcx>, Option<D::Path>)>)\n+                       -> BasicBlock\n+    {\n+        debug!(\"drop_ladder({:?}, {:?})\", self, fields);\n+\n+        let mut fields = fields;\n+        fields.retain(|&(ref lvalue, _)| {\n+            self.tcx().type_needs_drop_given_env(\n+                self.lvalue_ty(lvalue), self.elaborator.param_env())\n+        });\n+\n+        debug!(\"drop_ladder - fields needing drop: {:?}\", fields);\n+\n+        let unwind_ladder = if self.is_cleanup {\n+            None\n+        } else {\n+            let unwind = self.unwind.unwrap(); // FIXME(#6393)\n+            Some(self.drop_halfladder(None, unwind, &fields, true))\n+        };\n+\n+        let succ = self.succ; // FIXME(#6393)\n+        let is_cleanup = self.is_cleanup;\n+        self.drop_halfladder(unwind_ladder, succ, &fields, is_cleanup)\n+            .last().cloned().unwrap_or(succ)\n+    }\n+\n+    fn open_drop_for_tuple<'a>(&mut self, tys: &[Ty<'tcx>])\n+                               -> BasicBlock\n+    {\n+        debug!(\"open_drop_for_tuple({:?}, {:?})\", self, tys);\n+\n+        let fields = tys.iter().enumerate().map(|(i, &ty)| {\n+            (self.lvalue.clone().field(Field::new(i), ty),\n+             self.elaborator.field_subpath(self.path, Field::new(i)))\n+        }).collect();\n+\n+        self.drop_ladder(fields)\n+    }\n+\n+    fn open_drop_for_box<'a>(&mut self, ty: Ty<'tcx>) -> BasicBlock\n+    {\n+        debug!(\"open_drop_for_box({:?}, {:?})\", self, ty);\n+\n+        let interior = self.lvalue.clone().deref();\n+        let interior_path = self.elaborator.deref_subpath(self.path);\n+\n+        let succ = self.succ; // FIXME(#6393)\n+        let is_cleanup = self.is_cleanup;\n+        let succ = self.box_free_block(ty, succ, is_cleanup);\n+        let unwind_succ = self.unwind.map(|u| {\n+            self.box_free_block(ty, u, true)\n+        });\n+\n+        self.drop_subpath(is_cleanup, &interior, interior_path, succ, unwind_succ)\n+    }\n+\n+    fn open_drop_for_adt<'a>(&mut self, adt: &'tcx ty::AdtDef, substs: &'tcx Substs<'tcx>)\n+                             -> BasicBlock {\n+        debug!(\"open_drop_for_adt({:?}, {:?}, {:?})\", self, adt, substs);\n+\n+        match adt.variants.len() {\n+            1 => {\n+                let fields = self.move_paths_for_fields(\n+                    self.lvalue,\n+                    self.path,\n+                    &adt.variants[0],\n+                    substs\n+                );\n+                self.drop_ladder(fields)\n+            }\n+            _ => {\n+                let mut values = Vec::with_capacity(adt.variants.len());\n+                let mut blocks = Vec::with_capacity(adt.variants.len());\n+                let mut otherwise = None;\n+                for (variant_index, discr) in adt.discriminants(self.tcx()).enumerate() {\n+                    let subpath = self.elaborator.downcast_subpath(\n+                        self.path, variant_index);\n+                    if let Some(variant_path) = subpath {\n+                        let base_lv = self.lvalue.clone().elem(\n+                            ProjectionElem::Downcast(adt, variant_index)\n+                        );\n+                        let fields = self.move_paths_for_fields(\n+                            &base_lv,\n+                            variant_path,\n+                            &adt.variants[variant_index],\n+                            substs);\n+                        values.push(discr);\n+                        blocks.push(self.drop_ladder(fields));\n+                    } else {\n+                        // variant not found - drop the entire enum\n+                        if let None = otherwise {\n+                            otherwise =\n+                                Some(self.complete_drop(Some(DropFlagMode::Shallow)));\n+                        }\n+                    }\n+                }\n+                if let Some(block) = otherwise {\n+                    blocks.push(block);\n+                } else {\n+                    values.pop();\n+                }\n+                // If there are multiple variants, then if something\n+                // is present within the enum the discriminant, tracked\n+                // by the rest path, must be initialized.\n+                //\n+                // Additionally, we do not want to switch on the\n+                // discriminant after it is free-ed, because that\n+                // way lies only trouble.\n+                let discr_ty = adt.repr.discr_type().to_ty(self.tcx());\n+                let discr = Lvalue::Local(self.new_temp(discr_ty));\n+                let discr_rv = Rvalue::Discriminant(self.lvalue.clone());\n+                let switch_block = self.elaborator.patch().new_block(BasicBlockData {\n+                    statements: vec![\n+                        Statement {\n+                            source_info: self.source_info,\n+                            kind: StatementKind::Assign(discr.clone(), discr_rv),\n+                        }\n+                    ],\n+                    terminator: Some(Terminator {\n+                        source_info: self.source_info,\n+                        kind: TerminatorKind::SwitchInt {\n+                            discr: Operand::Consume(discr),\n+                            switch_ty: discr_ty,\n+                            values: From::from(values),\n+                            targets: blocks,\n+                        }\n+                    }),\n+                    is_cleanup: self.is_cleanup,\n+                });\n+                self.drop_flag_test_block(switch_block)\n+            }\n+        }\n+    }\n+\n+    /// The slow-path - create an \"open\", elaborated drop for a type\n+    /// which is moved-out-of only partially, and patch `bb` to a jump\n+    /// to it. This must not be called on ADTs with a destructor,\n+    /// as these can't be moved-out-of, except for `Box<T>`, which is\n+    /// special-cased.\n+    ///\n+    /// This creates a \"drop ladder\" that drops the needed fields of the\n+    /// ADT, both in the success case or if one of the destructors fail.\n+    fn open_drop<'a>(&mut self) -> BasicBlock {\n+        let ty = self.lvalue_ty(self.lvalue);\n+        match ty.sty {\n+            ty::TyClosure(def_id, substs) => {\n+                let tys : Vec<_> = substs.upvar_tys(def_id, self.tcx()).collect();\n+                self.open_drop_for_tuple(&tys)\n+            }\n+            ty::TyTuple(tys, _) => {\n+                self.open_drop_for_tuple(tys)\n+            }\n+            ty::TyAdt(def, _) if def.is_box() => {\n+                self.open_drop_for_box(ty.boxed_ty())\n+            }\n+            ty::TyAdt(def, substs) => {\n+                self.open_drop_for_adt(def, substs)\n+            }\n+            _ => bug!(\"open drop from non-ADT `{:?}`\", ty)\n+        }\n+    }\n+\n+    /// Return a basic block that drop an lvalue using the context\n+    /// and path in `c`. If `mode` is something, also clear `c`\n+    /// according to it.\n+    ///\n+    /// if FLAG(self.path)\n+    ///     if let Some(mode) = mode: FLAG(self.path)[mode] = false\n+    ///     drop(self.lv)\n+    fn complete_drop<'a>(&mut self, drop_mode: Option<DropFlagMode>) -> BasicBlock\n+    {\n+        debug!(\"complete_drop({:?},{:?})\", self, drop_mode);\n+\n+        let drop_block = self.drop_block();\n+        if let Some(mode) = drop_mode {\n+            let block_start = Location { block: drop_block, statement_index: 0 };\n+            self.elaborator.clear_drop_flag(block_start, self.path, mode);\n+        }\n+\n+        self.drop_flag_test_block(drop_block)\n+    }\n+\n+    fn elaborated_drop_block<'a>(&mut self) -> BasicBlock {\n+        debug!(\"elaborated_drop_block({:?})\", self);\n+        let blk = self.drop_block();\n+        self.elaborate_drop(blk);\n+        blk\n+    }\n+\n+    fn box_free_block<'a>(\n+        &mut self,\n+        ty: Ty<'tcx>,\n+        target: BasicBlock,\n+        is_cleanup: bool\n+    ) -> BasicBlock {\n+        let block = self.unelaborated_free_block(ty, target, is_cleanup);\n+        self.drop_flag_test_block_with_succ(is_cleanup, block, target)\n+    }\n+\n+    fn unelaborated_free_block<'a>(\n+        &mut self,\n+        ty: Ty<'tcx>,\n+        target: BasicBlock,\n+        is_cleanup: bool\n+    ) -> BasicBlock {\n+        let tcx = self.tcx();\n+        let unit_temp = Lvalue::Local(self.new_temp(tcx.mk_nil()));\n+        let free_func = tcx.require_lang_item(lang_items::BoxFreeFnLangItem);\n+        let substs = tcx.mk_substs(iter::once(Kind::from(ty)));\n+        let fty = tcx.item_type(free_func).subst(tcx, substs);\n+\n+        let free_block = self.elaborator.patch().new_block(BasicBlockData {\n+            statements: vec![],\n+            terminator: Some(Terminator {\n+                source_info: self.source_info, kind: TerminatorKind::Call {\n+                    func: Operand::Constant(Constant {\n+                        span: self.source_info.span,\n+                        ty: fty,\n+                        literal: Literal::Item {\n+                            def_id: free_func,\n+                            substs: substs\n+                        }\n+                    }),\n+                    args: vec![Operand::Consume(self.lvalue.clone())],\n+                    destination: Some((unit_temp, target)),\n+                    cleanup: None\n+                }\n+            }),\n+            is_cleanup: is_cleanup\n+        });\n+        let block_start = Location { block: free_block, statement_index: 0 };\n+        self.elaborator.clear_drop_flag(block_start, self.path, DropFlagMode::Shallow);\n+        free_block\n+    }\n+\n+    fn drop_block<'a>(&mut self) -> BasicBlock {\n+        let block = TerminatorKind::Drop {\n+            location: self.lvalue.clone(),\n+            target: self.succ,\n+            unwind: self.unwind\n+        };\n+        let is_cleanup = self.is_cleanup; // FIXME(#6393)\n+        self.new_block(is_cleanup, block)\n+    }\n+\n+    fn drop_flag_test_block<'a>(&mut self, on_set: BasicBlock) -> BasicBlock {\n+        let is_cleanup = self.is_cleanup;\n+        let succ = self.succ; // FIXME(#6393)\n+        self.drop_flag_test_block_with_succ(is_cleanup, on_set, succ)\n+    }\n+\n+    fn drop_flag_test_block_with_succ<'a>(&mut self,\n+                                          is_cleanup: bool,\n+                                          on_set: BasicBlock,\n+                                          on_unset: BasicBlock)\n+                                          -> BasicBlock\n+    {\n+        let style = self.elaborator.drop_style(self.path, DropFlagMode::Shallow);\n+        debug!(\"drop_flag_test_block({:?},{:?},{:?}) - {:?}\",\n+               self, is_cleanup, on_set, style);\n+\n+        match style {\n+            DropStyle::Dead => on_unset,\n+            DropStyle::Static => on_set,\n+            DropStyle::Conditional | DropStyle::Open => {\n+                let flag = self.elaborator.get_drop_flag(self.path).unwrap();\n+                let term = TerminatorKind::if_(self.tcx(), flag, on_set, on_unset);\n+                self.new_block(is_cleanup, term)\n+            }\n+        }\n+    }\n+\n+    fn new_block<'a>(&mut self,\n+                     is_cleanup: bool,\n+                     k: TerminatorKind<'tcx>)\n+                     -> BasicBlock\n+    {\n+        self.elaborator.patch().new_block(BasicBlockData {\n+            statements: vec![],\n+            terminator: Some(Terminator {\n+                source_info: self.source_info, kind: k\n+            }),\n+            is_cleanup: is_cleanup\n+        })\n+    }\n+\n+    fn new_temp(&mut self, ty: Ty<'tcx>) -> Local {\n+        self.elaborator.patch().new_temp(ty)\n+    }\n+\n+    fn terminator_loc(&mut self, bb: BasicBlock) -> Location {\n+        let mir = self.elaborator.mir();\n+        self.elaborator.patch().terminator_loc(mir, bb)\n+    }\n+}"}, {"sha": "91600b947c6106b96fce3887c8a99cee6f96371b", "filename": "src/librustc_mir/util/graphviz.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/2b9fea1300b515e0f8929bb3a09d4fb6fef3f0ea/src%2Flibrustc_mir%2Futil%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b9fea1300b515e0f8929bb3a09d4fb6fef3f0ea/src%2Flibrustc_mir%2Futil%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fgraphviz.rs?ref=2b9fea1300b515e0f8929bb3a09d4fb6fef3f0ea", "previous_filename": "src/librustc_mir/graphviz.rs"}, {"sha": "cafc5bca76acd8eeb2e638eee83cfef33fc35f90", "filename": "src/librustc_mir/util/mod.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/2b9fea1300b515e0f8929bb3a09d4fb6fef3f0ea/src%2Flibrustc_mir%2Futil%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b9fea1300b515e0f8929bb3a09d4fb6fef3f0ea/src%2Flibrustc_mir%2Futil%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fmod.rs?ref=2b9fea1300b515e0f8929bb3a09d4fb6fef3f0ea", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub mod elaborate_drops;\n+pub mod def_use;\n+pub mod patch;\n+\n+mod graphviz;\n+mod pretty;\n+\n+pub use self::pretty::{dump_mir, write_mir_pretty};\n+pub use self::graphviz::{write_mir_graphviz};\n+pub use self::graphviz::write_node_label as write_graphviz_node_label;"}, {"sha": "19f240da73059d498b543a087c967581cc98b695", "filename": "src/librustc_mir/util/patch.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/2b9fea1300b515e0f8929bb3a09d4fb6fef3f0ea/src%2Flibrustc_mir%2Futil%2Fpatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b9fea1300b515e0f8929bb3a09d4fb6fef3f0ea/src%2Flibrustc_mir%2Futil%2Fpatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fpatch.rs?ref=2b9fea1300b515e0f8929bb3a09d4fb6fef3f0ea", "previous_filename": "src/librustc_borrowck/borrowck/mir/patch.rs"}, {"sha": "35734dcce2beb631c2dd58cc319dffd7c7a7a816", "filename": "src/librustc_mir/util/pretty.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/2b9fea1300b515e0f8929bb3a09d4fb6fef3f0ea/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b9fea1300b515e0f8929bb3a09d4fb6fef3f0ea/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fpretty.rs?ref=2b9fea1300b515e0f8929bb3a09d4fb6fef3f0ea", "previous_filename": "src/librustc_mir/pretty.rs"}]}