{"sha": "69f4839b926d6435df83cd80945d9f843cf60e27", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY5ZjQ4MzliOTI2ZDY0MzVkZjgzY2Q4MDk0NWQ5Zjg0M2NmNjBlMjc=", "commit": {"author": {"name": "Cameron Zwarich", "email": "zwarich@mozilla.com", "date": "2014-06-16T22:40:20Z"}, "committer": {"name": "Cameron Zwarich", "email": "zwarich@mozilla.com", "date": "2014-06-16T22:40:20Z"}, "message": "Always check assigned loan paths to the top of the path\n\nCurrently, check_for_assignment_to_restricted_or_frozen_location bails\nout early when looking for loaned base paths when it hits an McDeclared\nor McImmutable extension. With the current type system, this is actually\nirrelevant, since mutation can only occur given a unique mutable access\npath, forcing the same requirement on each base path.", "tree": {"sha": "ce96a1c16deaaf42d5b9be26caf7147b838de840", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ce96a1c16deaaf42d5b9be26caf7147b838de840"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/69f4839b926d6435df83cd80945d9f843cf60e27", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/69f4839b926d6435df83cd80945d9f843cf60e27", "html_url": "https://github.com/rust-lang/rust/commit/69f4839b926d6435df83cd80945d9f843cf60e27", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/69f4839b926d6435df83cd80945d9f843cf60e27/comments", "author": null, "committer": null, "parents": [{"sha": "178c4fbccbc59fc7c554cb3cda33413d7d455366", "url": "https://api.github.com/repos/rust-lang/rust/commits/178c4fbccbc59fc7c554cb3cda33413d7d455366", "html_url": "https://github.com/rust-lang/rust/commit/178c4fbccbc59fc7c554cb3cda33413d7d455366"}], "stats": {"total": 24, "additions": 3, "deletions": 21}, "files": [{"sha": "d36eb6751b16a1e7a95dbfebd8a9c4d17c42a231", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 3, "deletions": 21, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/69f4839b926d6435df83cd80945d9f843cf60e27/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69f4839b926d6435df83cd80945d9f843cf60e27/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=69f4839b926d6435df83cd80945d9f843cf60e27", "patch": "@@ -870,34 +870,16 @@ impl<'a> CheckLoanCtxt<'a> {\n             // here is to `v[*]`, and the existing restrictions were issued\n             // for `v`, not `v[*]`.\n             //\n-            // So in this loop, we walk back up the loan path so long\n-            // as the mutability of the path is dependent on a super\n-            // path, and check that the super path was not borrowed.\n-            //\n-            // Mutability of a path can be dependent on the super path\n-            // in two ways. First, it might be inherited mutability.\n-            // Second, the pointee of an `&mut` pointer can only be\n-            // mutated if it is found in an unaliased location, so we\n-            // have to check that the owner location is not borrowed.\n+            // So in this loop, we walk back up the path and look for\n+            // loans, not restrictions.\n \n             let full_loan_path = loan_path.clone();\n             let mut loan_path = loan_path;\n             loop {\n                 loan_path = match *loan_path {\n-                    // Peel back one layer if, for `loan_path` to be\n-                    // mutable, `lp_base` must be mutable. This occurs\n-                    // with inherited mutability, owned pointers and\n-                    // `&mut` pointers.\n-                    LpExtend(ref lp_base, mc::McInherited, _) |\n-                    LpExtend(ref lp_base, _, LpDeref(mc::OwnedPtr)) |\n-                    LpExtend(ref lp_base, _, LpDeref(mc::GcPtr)) |\n-                    LpExtend(ref lp_base, _, LpDeref(mc::BorrowedPtr(ty::MutBorrow, _))) => {\n+                    LpExtend(ref lp_base, _, _) => {\n                         lp_base.clone()\n                     }\n-\n-                    // Otherwise stop iterating\n-                    LpExtend(_, mc::McDeclared, _) |\n-                    LpExtend(_, mc::McImmutable, _) |\n                     LpVar(_) => {\n                         return;\n                     }"}]}