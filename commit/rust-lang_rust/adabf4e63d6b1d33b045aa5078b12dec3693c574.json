{"sha": "adabf4e63d6b1d33b045aa5078b12dec3693c574", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFkYWJmNGU2M2Q2YjFkMzNiMDQ1YWE1MDc4YjEyZGVjMzY5M2M1NzQ=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2014-12-23T11:30:36Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2014-12-23T11:30:36Z"}, "message": "rustc_typeck: don't expect rvalues to have unsized types.", "tree": {"sha": "2fcd0f78e60710cfb702886d4dada174e8979cba", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2fcd0f78e60710cfb702886d4dada174e8979cba"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/adabf4e63d6b1d33b045aa5078b12dec3693c574", "comment_count": 7, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/adabf4e63d6b1d33b045aa5078b12dec3693c574", "html_url": "https://github.com/rust-lang/rust/commit/adabf4e63d6b1d33b045aa5078b12dec3693c574", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/adabf4e63d6b1d33b045aa5078b12dec3693c574/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "url": "https://api.github.com/repos/rust-lang/rust/commits/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91", "html_url": "https://github.com/rust-lang/rust/commit/62fb41c32bd97c4e9bc286a1db5d7126a06b8b91"}], "stats": {"total": 155, "additions": 113, "deletions": 42}, "files": [{"sha": "b2cc52ab0a87bd80d6d187c45f2c351495e9fbdd", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/adabf4e63d6b1d33b045aa5078b12dec3693c574/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adabf4e63d6b1d33b045aa5078b12dec3693c574/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=adabf4e63d6b1d33b045aa5078b12dec3693c574", "patch": "@@ -4212,10 +4212,14 @@ pub fn expr_kind(tcx: &ctxt, expr: &ast::Expr) -> ExprKind {\n                 }\n \n                 def::DefStruct(_) => {\n-                    match expr_ty(tcx, expr).sty {\n-                        ty_bare_fn(..) => RvalueDatumExpr,\n-                        _ => RvalueDpsExpr\n-                    }\n+                    match tcx.node_types.borrow().get(&expr.id) {\n+                        Some(ty) => match ty.sty {\n+                            ty_bare_fn(..) => RvalueDatumExpr,\n+                            _ => RvalueDpsExpr\n+                        },\n+                        // See ExprCast below for why types might be missing.\n+                        None => RvalueDatumExpr\n+                     }\n                 }\n \n                 // Special case: A unit like struct's constructor must be called without () at the"}, {"sha": "e25543ea99241c651141e656d4503811169c6a79", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 7, "deletions": 21, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/adabf4e63d6b1d33b045aa5078b12dec3693c574/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adabf4e63d6b1d33b045aa5078b12dec3693c574/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=adabf4e63d6b1d33b045aa5078b12dec3693c574", "patch": "@@ -10,9 +10,7 @@\n \n //! Code for type-checking closure expressions.\n \n-use super::check_fn;\n-use super::{Expectation, ExpectCastableToType, ExpectHasType, NoExpectation};\n-use super::FnCtxt;\n+use super::{check_fn, Expectation, FnCtxt};\n \n use astconv;\n use middle::infer;\n@@ -34,13 +32,17 @@ pub fn check_expr_closure<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n            expr.repr(fcx.tcx()),\n            expected.repr(fcx.tcx()));\n \n+    let expected_sig_and_kind = expected.map_to_option(fcx, |ty| {\n+        deduce_unboxed_closure_expectations_from_expected_type(fcx, ty)\n+    });\n+\n     match opt_kind {\n         None => {\n             // If users didn't specify what sort of closure they want,\n             // examine the expected type. For now, if we see explicit\n             // evidence than an unboxed closure is desired, we'll use\n             // that, otherwise we'll fall back to boxed closures.\n-            match deduce_unboxed_closure_expectations_from_expectation(fcx, expected) {\n+            match expected_sig_and_kind {\n                 None => { // doesn't look like an unboxed closure\n                     let region = astconv::opt_ast_region_to_region(fcx,\n                                                                    fcx.infcx(),\n@@ -66,10 +68,7 @@ pub fn check_expr_closure<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n                 ast::FnOnceUnboxedClosureKind => ty::FnOnceUnboxedClosureKind,\n             };\n \n-            let expected_sig =\n-                deduce_unboxed_closure_expectations_from_expectation(fcx, expected)\n-                .map(|t| t.0);\n-\n+            let expected_sig = expected_sig_and_kind.map(|t| t.0);\n             check_unboxed_closure(fcx, expr, kind, decl, body, expected_sig);\n         }\n     }\n@@ -147,19 +146,6 @@ fn check_unboxed_closure<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n         .insert(expr_def_id, unboxed_closure);\n }\n \n-fn deduce_unboxed_closure_expectations_from_expectation<'a,'tcx>(\n-    fcx: &FnCtxt<'a,'tcx>,\n-    expected: Expectation<'tcx>)\n-    -> Option<(ty::FnSig<'tcx>,ty::UnboxedClosureKind)>\n-{\n-    match expected.resolve(fcx) {\n-        NoExpectation => None,\n-        ExpectCastableToType(t) | ExpectHasType(t) => {\n-            deduce_unboxed_closure_expectations_from_expected_type(fcx, t)\n-        }\n-    }\n-}\n-\n fn deduce_unboxed_closure_expectations_from_expected_type<'a,'tcx>(\n     fcx: &FnCtxt<'a,'tcx>,\n     expected_ty: Ty<'tcx>)"}, {"sha": "fbd40ef6fed0ebbd223a4e6a914c919f46e04fca", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 68, "deletions": 17, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/adabf4e63d6b1d33b045aa5078b12dec3693c574/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adabf4e63d6b1d33b045aa5078b12dec3693c574/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=adabf4e63d6b1d33b045aa5078b12dec3693c574", "patch": "@@ -176,6 +176,10 @@ enum Expectation<'tcx> {\n \n     /// This expression will be cast to the `Ty`\n     ExpectCastableToType(Ty<'tcx>),\n+\n+    /// This rvalue expression will be wrapped in `&` or `Box` and coerced\n+    /// to `&Ty` or `Box<Ty>`, respectively. `Ty` is `[A]` or `Trait`.\n+    ExpectRvalueLikeUnsized(Ty<'tcx>),\n }\n \n impl<'tcx> Expectation<'tcx> {\n@@ -196,7 +200,7 @@ impl<'tcx> Expectation<'tcx> {\n     // when checking the 'then' block which are incompatible with the\n     // 'else' branch.\n     fn adjust_for_branches<'a>(&self, fcx: &FnCtxt<'a, 'tcx>) -> Expectation<'tcx> {\n-        match self.only_has_type() {\n+        match *self {\n             ExpectHasType(ety) => {\n                 let ety = fcx.infcx().shallow_resolve(ety);\n                 if !ty::type_is_ty_var(ety) {\n@@ -205,6 +209,9 @@ impl<'tcx> Expectation<'tcx> {\n                     NoExpectation\n                 }\n             }\n+            ExpectRvalueLikeUnsized(ety) => {\n+                ExpectRvalueLikeUnsized(ety)\n+            }\n             _ => NoExpectation\n         }\n     }\n@@ -3678,7 +3685,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n             match unop {\n                 ast::UnUniq => match ty.sty {\n                     ty::ty_uniq(ty) => {\n-                        ExpectHasType(ty)\n+                        Expectation::rvalue_hint(ty)\n                     }\n                     _ => {\n                         NoExpectation\n@@ -3767,7 +3774,16 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         let expected = expected.only_has_type();\n         let hint = expected.map(fcx, |ty| {\n             match ty.sty {\n-                ty::ty_rptr(_, ref mt) | ty::ty_ptr(ref mt) => ExpectHasType(mt.ty),\n+                ty::ty_rptr(_, ref mt) | ty::ty_ptr(ref mt) => {\n+                    if ty::expr_is_lval(fcx.tcx(), &**oprnd) {\n+                        // Lvalues may legitimately have unsized types.\n+                        // For example, dereferences of a fat pointer and\n+                        // the last field of a struct can be unsized.\n+                        ExpectHasType(mt.ty)\n+                    } else {\n+                        Expectation::rvalue_hint(mt.ty)\n+                    }\n+                }\n                 _ => NoExpectation\n             }\n         });\n@@ -3985,15 +4001,12 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         check_cast(fcx, expr, &**e, &**t);\n       }\n       ast::ExprVec(ref args) => {\n-        let uty = match expected {\n-            ExpectHasType(uty) => {\n-                match uty.sty {\n-                        ty::ty_vec(ty, _) => Some(ty),\n-                        _ => None\n-                }\n+        let uty = expected.map_to_option(fcx, |uty| {\n+            match uty.sty {\n+                ty::ty_vec(ty, _) => Some(ty),\n+                _ => None\n             }\n-            _ => None\n-        };\n+        });\n \n         let typ = match uty {\n             Some(uty) => {\n@@ -4020,8 +4033,8 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         let uty = match expected {\n             ExpectHasType(uty) => {\n                 match uty.sty {\n-                        ty::ty_vec(ty, _) => Some(ty),\n-                        _ => None\n+                    ty::ty_vec(ty, _) => Some(ty),\n+                    _ => None\n                 }\n             }\n             _ => None\n@@ -4298,10 +4311,38 @@ fn constrain_path_type_parameters(fcx: &FnCtxt,\n }\n \n impl<'tcx> Expectation<'tcx> {\n+    /// Provide an expectation for an rvalue expression given an *optional*\n+    /// hint, which is not required for type safety (the resulting type might\n+    /// be checked higher up, as is the case with `&expr` and `box expr`), but\n+    /// is useful in determining the concrete type.\n+    ///\n+    /// The primary use case is where the expected type is a fat pointer,\n+    /// like `&[int]`. For example, consider the following statement:\n+    ///\n+    ///    let x: &[int] = &[1, 2, 3];\n+    ///\n+    /// In this case, the expected type for the `&[1, 2, 3]` expression is\n+    /// `&[int]`. If however we were to say that `[1, 2, 3]` has the\n+    /// expectation `ExpectHasType([int])`, that would be too strong --\n+    /// `[1, 2, 3]` does not have the type `[int]` but rather `[int, ..3]`.\n+    /// It is only the `&[1, 2, 3]` expression as a whole that can be coerced\n+    /// to the type `&[int]`. Therefore, we propagate this more limited hint,\n+    /// which still is useful, because it informs integer literals and the like.\n+    /// See the test case `test/run-pass/coerce-expect-unsized.rs` and #20169\n+    /// for examples of where this comes up,.\n+    fn rvalue_hint(ty: Ty<'tcx>) -> Expectation<'tcx> {\n+        match ty.sty {\n+            ty::ty_vec(_, None) | ty::ty_trait(..) => {\n+                ExpectRvalueLikeUnsized(ty)\n+            }\n+            _ => ExpectHasType(ty)\n+        }\n+    }\n+\n     fn only_has_type(self) -> Expectation<'tcx> {\n         match self {\n-            NoExpectation | ExpectCastableToType(..) => NoExpectation,\n-            ExpectHasType(t) => ExpectHasType(t)\n+            ExpectHasType(t) => ExpectHasType(t),\n+            _ => NoExpectation\n         }\n     }\n \n@@ -4321,6 +4362,10 @@ impl<'tcx> Expectation<'tcx> {\n                 ExpectHasType(\n                     fcx.infcx().resolve_type_vars_if_possible(&t))\n             }\n+            ExpectRvalueLikeUnsized(t) => {\n+                ExpectRvalueLikeUnsized(\n+                    fcx.infcx().resolve_type_vars_if_possible(&t))\n+            }\n         }\n     }\n \n@@ -4329,7 +4374,9 @@ impl<'tcx> Expectation<'tcx> {\n     {\n         match self.resolve(fcx) {\n             NoExpectation => NoExpectation,\n-            ExpectCastableToType(ty) | ExpectHasType(ty) => unpack(ty),\n+            ExpectCastableToType(ty) |\n+            ExpectHasType(ty) |\n+            ExpectRvalueLikeUnsized(ty) => unpack(ty),\n         }\n     }\n \n@@ -4338,7 +4385,9 @@ impl<'tcx> Expectation<'tcx> {\n     {\n         match self.resolve(fcx) {\n             NoExpectation => None,\n-            ExpectCastableToType(ty) | ExpectHasType(ty) => unpack(ty),\n+            ExpectCastableToType(ty) |\n+            ExpectHasType(ty) |\n+            ExpectRvalueLikeUnsized(ty) => unpack(ty),\n         }\n     }\n }\n@@ -4351,6 +4400,8 @@ impl<'tcx> Repr<'tcx> for Expectation<'tcx> {\n                                         t.repr(tcx)),\n             ExpectCastableToType(t) => format!(\"ExpectCastableToType({})\",\n                                                t.repr(tcx)),\n+            ExpectRvalueLikeUnsized(t) => format!(\"ExpectRvalueLikeUnsized({})\",\n+                                                  t.repr(tcx)),\n         }\n     }\n }"}, {"sha": "09f230792a9b7a1af22ccf83427dfefcaf5be732", "filename": "src/test/run-pass/coerce-expect-unsized.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/adabf4e63d6b1d33b045aa5078b12dec3693c574/src%2Ftest%2Frun-pass%2Fcoerce-expect-unsized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adabf4e63d6b1d33b045aa5078b12dec3693c574/src%2Ftest%2Frun-pass%2Fcoerce-expect-unsized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcoerce-expect-unsized.rs?ref=adabf4e63d6b1d33b045aa5078b12dec3693c574", "patch": "@@ -0,0 +1,30 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::fmt::Show;\n+\n+// Check that coercions apply at the pointer level and don't cause\n+// rvalue expressions to be unsized. See #20169 for more information.\n+\n+pub fn main() {\n+    let _: Box<[int]> = box { [1, 2, 3] };\n+    let _: Box<[int]> = box if true { [1, 2, 3] } else { [1, 3, 4] };\n+    let _: Box<[int]> = box match true { true => [1, 2, 3], false => [1, 3, 4] };\n+    let _: Box<Fn(int) -> _> = box { |x| (x as u8) };\n+    let _: Box<Show> = box if true { false } else { true };\n+    let _: Box<Show> = box match true { true => 'a', false => 'b' };\n+\n+    let _: &[int] = &{ [1, 2, 3] };\n+    let _: &[int] = &if true { [1, 2, 3] } else { [1, 3, 4] };\n+    let _: &[int] = &match true { true => [1, 2, 3], false => [1, 3, 4] };\n+    let _: &Fn(int) -> _ = &{ |x| (x as u8) };\n+    let _: &Show = &if true { false } else { true };\n+    let _: &Show = &match true { true => 'a', false => 'b' };\n+}"}]}