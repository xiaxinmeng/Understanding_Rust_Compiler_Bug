{"sha": "66363b288141ed2af4b95fb4205a56dce6248363", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY2MzYzYjI4ODE0MWVkMmFmNGI5NWZiNDIwNWE1NmRjZTYyNDgzNjM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-04-28T21:19:33Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-04-28T21:19:33Z"}, "message": "Auto merge of #50240 - nnethercote:LazyBTreeMap, r=cramertj\n\nImplement LazyBTreeMap and use it in a few places.\n\nThis is a thin wrapper around BTreeMap that avoids allocating upon creation.\n\nI would prefer to change BTreeMap directly to make it lazy (like I did with HashSet in #36734) and I initially attempted that by making BTreeMap::root an Option<>. But then I also had to change Iter and Range to handle trees with no root, and those types have stability markers on them and I wasn't sure if that was acceptable. Also, BTreeMap has a lot of complex code and changing it all was challenging, and I didn't have high confidence about my general approach.\n\nSo I prototyped this wrapper instead and used it in the hottest locations to get some measurements about the effect. The measurements are pretty good!\n\n- Doing a debug build of serde, it reduces the total number of heap allocations from 17,728,709 to 13,359,384, a 25% reduction. The number of bytes allocated drops from 7,474,672,966 to 5,482,308,388, a 27% reduction.\n\n- It gives speedups of up to 3.6% on some rustc-perf benchmark jobs. crates.io, futures, and serde benefit most.\n```\nfutures-check\n        avg: -1.9%      min: -3.6%      max: -0.5%\nserde-check\n        avg: -2.1%      min: -3.5%      max: -0.7%\ncrates.io-check\n        avg: -1.7%      min: -3.5%      max: -0.3%\nserde\n        avg: -2.0%      min: -3.0%      max: -0.9%\nserde-opt\n        avg: -1.8%      min: -2.9%      max: -0.3%\nfutures\n        avg: -1.5%      min: -2.8%      max: -0.4%\ntokio-webpush-simple-check\n        avg: -1.1%      min: -2.2%      max: -0.1%\nfutures-opt\n        avg: -1.2%      min: -2.1%      max: -0.4%\npiston-image-check\n        avg: -0.8%      min: -1.1%      max: -0.3%\ncrates.io\n        avg: -0.6%      min: -1.0%      max: -0.3%\n```\n@Gankro, how do you think I should proceed here? Is leaving this as a wrapper reasonable? Or should I try to make BTreeMap itself lazy? If so, can I change the representation of Iter and Range?\n\nThanks!", "tree": {"sha": "239fe445fea81d9503d68c9b0e10f76fc24b5f58", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/239fe445fea81d9503d68c9b0e10f76fc24b5f58"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/66363b288141ed2af4b95fb4205a56dce6248363", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/66363b288141ed2af4b95fb4205a56dce6248363", "html_url": "https://github.com/rust-lang/rust/commit/66363b288141ed2af4b95fb4205a56dce6248363", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/66363b288141ed2af4b95fb4205a56dce6248363/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "68a09fc5398a54538559bd46c38a5372d0ed6091", "url": "https://api.github.com/repos/rust-lang/rust/commits/68a09fc5398a54538559bd46c38a5372d0ed6091", "html_url": "https://github.com/rust-lang/rust/commit/68a09fc5398a54538559bd46c38a5372d0ed6091"}, {"sha": "259ae181391933040389e7e4206e792ad66b1487", "url": "https://api.github.com/repos/rust-lang/rust/commits/259ae181391933040389e7e4206e792ad66b1487", "html_url": "https://github.com/rust-lang/rust/commit/259ae181391933040389e7e4206e792ad66b1487"}], "stats": {"total": 135, "additions": 123, "deletions": 12}, "files": [{"sha": "c35cdf91fe7bfecb7d8f10d8e6d0b14c97849e6e", "filename": "src/librustc/infer/higher_ranked/mod.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/66363b288141ed2af4b95fb4205a56dce6248363/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66363b288141ed2af4b95fb4205a56dce6248363/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=66363b288141ed2af4b95fb4205a56dce6248363", "patch": "@@ -19,7 +19,7 @@ use super::{CombinedSnapshot,\n use super::combine::CombineFields;\n use super::region_constraints::{TaintDirections};\n \n-use std::collections::BTreeMap;\n+use rustc_data_structures::lazy_btree_map::LazyBTreeMap;\n use ty::{self, TyCtxt, Binder, TypeFoldable};\n use ty::error::TypeError;\n use ty::relate::{Relate, RelateResult, TypeRelation};\n@@ -247,7 +247,8 @@ impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n                                              snapshot: &CombinedSnapshot<'a, 'tcx>,\n                                              debruijn: ty::DebruijnIndex,\n                                              new_vars: &[ty::RegionVid],\n-                                             a_map: &BTreeMap<ty::BoundRegion, ty::Region<'tcx>>,\n+                                             a_map: &LazyBTreeMap<ty::BoundRegion,\n+                                                                  ty::Region<'tcx>>,\n                                              r0: ty::Region<'tcx>)\n                                              -> ty::Region<'tcx> {\n             // Regions that pre-dated the LUB computation stay as they are.\n@@ -343,7 +344,8 @@ impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n                                              snapshot: &CombinedSnapshot<'a, 'tcx>,\n                                              debruijn: ty::DebruijnIndex,\n                                              new_vars: &[ty::RegionVid],\n-                                             a_map: &BTreeMap<ty::BoundRegion, ty::Region<'tcx>>,\n+                                             a_map: &LazyBTreeMap<ty::BoundRegion,\n+                                                                  ty::Region<'tcx>>,\n                                              a_vars: &[ty::RegionVid],\n                                              b_vars: &[ty::RegionVid],\n                                              r0: ty::Region<'tcx>)\n@@ -412,7 +414,7 @@ impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n \n         fn rev_lookup<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n                                       span: Span,\n-                                      a_map: &BTreeMap<ty::BoundRegion, ty::Region<'tcx>>,\n+                                      a_map: &LazyBTreeMap<ty::BoundRegion, ty::Region<'tcx>>,\n                                       r: ty::Region<'tcx>) -> ty::Region<'tcx>\n         {\n             for (a_br, a_r) in a_map {\n@@ -435,7 +437,7 @@ impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n }\n \n fn var_ids<'a, 'gcx, 'tcx>(fields: &CombineFields<'a, 'gcx, 'tcx>,\n-                           map: &BTreeMap<ty::BoundRegion, ty::Region<'tcx>>)\n+                           map: &LazyBTreeMap<ty::BoundRegion, ty::Region<'tcx>>)\n                            -> Vec<ty::RegionVid> {\n     map.iter()\n        .map(|(_, &r)| match *r {"}, {"sha": "553926dba8f98e1cdcc7e50a0b763671026cc359", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/66363b288141ed2af4b95fb4205a56dce6248363/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66363b288141ed2af4b95fb4205a56dce6248363/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=66363b288141ed2af4b95fb4205a56dce6248363", "patch": "@@ -28,9 +28,9 @@ use ty::error::{ExpectedFound, TypeError, UnconstrainedNumeric};\n use ty::fold::TypeFoldable;\n use ty::relate::RelateResult;\n use traits::{self, ObligationCause, PredicateObligations};\n+use rustc_data_structures::lazy_btree_map::LazyBTreeMap;\n use rustc_data_structures::unify as ut;\n use std::cell::{Cell, RefCell, Ref, RefMut};\n-use std::collections::BTreeMap;\n use std::fmt;\n use syntax::ast;\n use errors::DiagnosticBuilder;\n@@ -187,7 +187,7 @@ pub struct InferCtxt<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n \n /// A map returned by `skolemize_late_bound_regions()` indicating the skolemized\n /// region that each late-bound region was replaced with.\n-pub type SkolemizationMap<'tcx> = BTreeMap<ty::BoundRegion, ty::Region<'tcx>>;\n+pub type SkolemizationMap<'tcx> = LazyBTreeMap<ty::BoundRegion, ty::Region<'tcx>>;\n \n /// See `error_reporting` module for more details\n #[derive(Clone, Debug)]\n@@ -1216,7 +1216,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         span: Span,\n         lbrct: LateBoundRegionConversionTime,\n         value: &ty::Binder<T>)\n-        -> (T, BTreeMap<ty::BoundRegion, ty::Region<'tcx>>)\n+        -> (T, LazyBTreeMap<ty::BoundRegion, ty::Region<'tcx>>)\n         where T : TypeFoldable<'tcx>\n     {\n         self.tcx.replace_late_bound_regions("}, {"sha": "650ac4e6f6db6faf1fb037a6e66a3b1e0cc28415", "filename": "src/librustc/ty/fold.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/66363b288141ed2af4b95fb4205a56dce6248363/src%2Flibrustc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66363b288141ed2af4b95fb4205a56dce6248363/src%2Flibrustc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffold.rs?ref=66363b288141ed2af4b95fb4205a56dce6248363", "patch": "@@ -43,8 +43,8 @@ use middle::const_val::ConstVal;\n use hir::def_id::DefId;\n use ty::{self, Binder, Ty, TyCtxt, TypeFlags};\n \n+use rustc_data_structures::lazy_btree_map::LazyBTreeMap;\n use std::fmt;\n-use std::collections::BTreeMap;\n use util::nodemap::FxHashSet;\n \n /// The TypeFoldable trait is implemented for every type that can be folded.\n@@ -334,7 +334,7 @@ struct RegionReplacer<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     current_depth: u32,\n     fld_r: &'a mut (dyn FnMut(ty::BoundRegion) -> ty::Region<'tcx> + 'a),\n-    map: BTreeMap<ty::BoundRegion, ty::Region<'tcx>>\n+    map: LazyBTreeMap<ty::BoundRegion, ty::Region<'tcx>>\n }\n \n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n@@ -349,7 +349,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn replace_late_bound_regions<T,F>(self,\n         value: &Binder<T>,\n         mut f: F)\n-        -> (T, BTreeMap<ty::BoundRegion, ty::Region<'tcx>>)\n+        -> (T, LazyBTreeMap<ty::BoundRegion, ty::Region<'tcx>>)\n         where F : FnMut(ty::BoundRegion) -> ty::Region<'tcx>,\n               T : TypeFoldable<'tcx>,\n     {\n@@ -462,7 +462,7 @@ impl<'a, 'gcx, 'tcx> RegionReplacer<'a, 'gcx, 'tcx> {\n             tcx,\n             current_depth: 1,\n             fld_r,\n-            map: BTreeMap::default()\n+            map: LazyBTreeMap::default()\n         }\n     }\n }"}, {"sha": "74f91af10fe637888342d6a7c39407a3e239cd3e", "filename": "src/librustc_data_structures/lazy_btree_map.rs", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/66363b288141ed2af4b95fb4205a56dce6248363/src%2Flibrustc_data_structures%2Flazy_btree_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66363b288141ed2af4b95fb4205a56dce6248363/src%2Flibrustc_data_structures%2Flazy_btree_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Flazy_btree_map.rs?ref=66363b288141ed2af4b95fb4205a56dce6248363", "patch": "@@ -0,0 +1,108 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::collections::btree_map;\n+use std::collections::BTreeMap;\n+\n+/// A thin wrapper around BTreeMap that avoids allocating upon creation.\n+///\n+/// Vec, HashSet and HashMap all have the nice feature that they don't do any\n+/// heap allocation when creating a new structure of the default size. In\n+/// contrast, BTreeMap *does* allocate in that situation. The compiler uses\n+/// B-Tree maps in some places such that many maps are created but few are\n+/// inserted into, so having a BTreeMap alternative that avoids allocating on\n+/// creation is a performance win.\n+///\n+/// Only a fraction of BTreeMap's functionality is currently supported.\n+/// Additional functionality should be added on demand.\n+#[derive(Debug)]\n+pub struct LazyBTreeMap<K, V>(Option<BTreeMap<K, V>>);\n+\n+impl<K, V> LazyBTreeMap<K, V> {\n+    pub fn new() -> LazyBTreeMap<K, V> {\n+        LazyBTreeMap(None)\n+    }\n+\n+    pub fn iter(&self) -> Iter<K, V> {\n+        Iter(self.0.as_ref().map(|btm| btm.iter()))\n+    }\n+\n+    pub fn is_empty(&self) -> bool {\n+        self.0.as_ref().map_or(true, |btm| btm.is_empty())\n+    }\n+}\n+\n+impl<K: Ord, V> LazyBTreeMap<K, V> {\n+    fn instantiate(&mut self) -> &mut BTreeMap<K, V> {\n+        if let Some(ref mut btm) = self.0 {\n+            btm\n+        } else {\n+            let btm = BTreeMap::new();\n+            self.0 = Some(btm);\n+            self.0.as_mut().unwrap()\n+        }\n+    }\n+\n+    pub fn insert(&mut self, key: K, value: V) -> Option<V> {\n+        self.instantiate().insert(key, value)\n+    }\n+\n+    pub fn entry(&mut self, key: K) -> btree_map::Entry<K, V> {\n+        self.instantiate().entry(key)\n+    }\n+\n+    pub fn values<'a>(&'a self) -> Values<'a, K, V> {\n+        Values(self.0.as_ref().map(|btm| btm.values()))\n+    }\n+}\n+\n+impl<K: Ord, V> Default for LazyBTreeMap<K, V> {\n+    fn default() -> LazyBTreeMap<K, V> {\n+        LazyBTreeMap::new()\n+    }\n+}\n+\n+impl<'a, K: 'a, V: 'a> IntoIterator for &'a LazyBTreeMap<K, V> {\n+    type Item = (&'a K, &'a V);\n+    type IntoIter = Iter<'a, K, V>;\n+\n+    fn into_iter(self) -> Iter<'a, K, V> {\n+        self.iter()\n+    }\n+}\n+\n+pub struct Iter<'a, K: 'a, V: 'a>(Option<btree_map::Iter<'a, K, V>>);\n+\n+impl<'a, K: 'a, V: 'a> Iterator for Iter<'a, K, V> {\n+    type Item = (&'a K, &'a V);\n+\n+    fn next(&mut self) -> Option<(&'a K, &'a V)> {\n+        self.0.as_mut().and_then(|iter| iter.next())\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.0.as_ref().map_or_else(|| (0, Some(0)), |iter| iter.size_hint())\n+    }\n+}\n+\n+pub struct Values<'a, K: 'a, V: 'a>(Option<btree_map::Values<'a, K, V>>);\n+\n+impl<'a, K, V> Iterator for Values<'a, K, V> {\n+    type Item = &'a V;\n+\n+    fn next(&mut self) -> Option<&'a V> {\n+        self.0.as_mut().and_then(|values| values.next())\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.0.as_ref().map_or_else(|| (0, Some(0)), |values| values.size_hint())\n+    }\n+}\n+"}, {"sha": "597d1627ada03da578556f761897937181a063c7", "filename": "src/librustc_data_structures/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/66363b288141ed2af4b95fb4205a56dce6248363/src%2Flibrustc_data_structures%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66363b288141ed2af4b95fb4205a56dce6248363/src%2Flibrustc_data_structures%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Flib.rs?ref=66363b288141ed2af4b95fb4205a56dce6248363", "patch": "@@ -60,6 +60,7 @@ pub mod bitvec;\n pub mod graph;\n pub mod indexed_set;\n pub mod indexed_vec;\n+pub mod lazy_btree_map;\n pub mod obligation_forest;\n pub mod sip128;\n pub mod snapshot_map;"}]}