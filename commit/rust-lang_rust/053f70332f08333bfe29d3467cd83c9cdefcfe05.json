{"sha": "053f70332f08333bfe29d3467cd83c9cdefcfe05", "node_id": "C_kwDOAAsO6NoAKDA1M2Y3MDMzMmYwODMzM2JmZTI5ZDM0NjdjZDgzYzljZGVmY2ZlMDU", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-04-11T10:06:57Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-04-11T10:06:57Z"}, "message": "Rollup merge of #95907 - compiler-errors:diag, r=Dylan-DPC\n\naddress fixme for diagnostic variable name\n\nquick rename", "tree": {"sha": "93f5cb8c389281e1d27ab33750badc5de2806086", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/93f5cb8c389281e1d27ab33750badc5de2806086"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/053f70332f08333bfe29d3467cd83c9cdefcfe05", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiU/3BCRBK7hj4Ov3rIwAAwp8IAGbXIXRD6cwo+EzC7zcyfAUQ\nw2nrIo7YHoFbm5aT43pYfwX4Y3Calt+c7uenuHBvzwFIPTMYbn+J7dfVnprrTFXn\ns84ZzjkTbyzx4i5zkZIXmmtmQ1XL7dXT9TVYO/vEwnu0pwn4T0eOwTZV2Y267rHr\n1gBeCrVaKCXpQFIdqRS1nDq/9urI65Q1eSQLawRa9Og9qdcZKX8JPAkzyqlOochi\nmDRmhMcehLDv6zQQFqG6FF/oENH5V/KBvnR/oHzEH2QuPkNS+P4BQgdNlDnH5iin\nGYKbCQruqNHXLRG7L0VeN8qIe29RkBhMm7zdN6Ix38LWSArCHHFyJ/274dcR4Zo=\n=erd8\n-----END PGP SIGNATURE-----\n", "payload": "tree 93f5cb8c389281e1d27ab33750badc5de2806086\nparent 7ed15fb584a9cbb6888113a837433cc416f7c073\nparent 137c207d2055c5703320c71ea6cdd02932492f06\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1649671617 +0200\ncommitter GitHub <noreply@github.com> 1649671617 +0200\n\nRollup merge of #95907 - compiler-errors:diag, r=Dylan-DPC\n\naddress fixme for diagnostic variable name\n\nquick rename\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/053f70332f08333bfe29d3467cd83c9cdefcfe05", "html_url": "https://github.com/rust-lang/rust/commit/053f70332f08333bfe29d3467cd83c9cdefcfe05", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/053f70332f08333bfe29d3467cd83c9cdefcfe05/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7ed15fb584a9cbb6888113a837433cc416f7c073", "url": "https://api.github.com/repos/rust-lang/rust/commits/7ed15fb584a9cbb6888113a837433cc416f7c073", "html_url": "https://github.com/rust-lang/rust/commit/7ed15fb584a9cbb6888113a837433cc416f7c073"}, {"sha": "137c207d2055c5703320c71ea6cdd02932492f06", "url": "https://api.github.com/repos/rust-lang/rust/commits/137c207d2055c5703320c71ea6cdd02932492f06", "html_url": "https://github.com/rust-lang/rust/commit/137c207d2055c5703320c71ea6cdd02932492f06"}], "stats": {"total": 137, "additions": 69, "deletions": 68}, "files": [{"sha": "07878defa8ccdef1562f5ff78fa7ad7398c11c25", "filename": "compiler/rustc_middle/src/ty/error.rs", "status": "modified", "additions": 63, "deletions": 61, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/053f70332f08333bfe29d3467cd83c9cdefcfe05/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/053f70332f08333bfe29d3467cd83c9cdefcfe05/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs?ref=053f70332f08333bfe29d3467cd83c9cdefcfe05", "patch": "@@ -347,8 +347,7 @@ impl<'tcx> Ty<'tcx> {\n impl<'tcx> TyCtxt<'tcx> {\n     pub fn note_and_explain_type_err(\n         self,\n-        // FIXME(eddyb) rename this since it's no longer a `DiagnosticBuilder`.\n-        db: &mut Diagnostic,\n+        diag: &mut Diagnostic,\n         err: &TypeError<'tcx>,\n         cause: &ObligationCause<'tcx>,\n         sp: Span,\n@@ -360,12 +359,12 @@ impl<'tcx> TyCtxt<'tcx> {\n             ArgumentSorts(values, _) | Sorts(values) => {\n                 match (values.expected.kind(), values.found.kind()) {\n                     (ty::Closure(..), ty::Closure(..)) => {\n-                        db.note(\"no two closures, even if identical, have the same type\");\n-                        db.help(\"consider boxing your closure and/or using it as a trait object\");\n+                        diag.note(\"no two closures, even if identical, have the same type\");\n+                        diag.help(\"consider boxing your closure and/or using it as a trait object\");\n                     }\n                     (ty::Opaque(..), ty::Opaque(..)) => {\n                         // Issue #63167\n-                        db.note(\"distinct uses of `impl Trait` result in different opaque types\");\n+                        diag.note(\"distinct uses of `impl Trait` result in different opaque types\");\n                     }\n                     (ty::Float(_), ty::Infer(ty::IntVar(_)))\n                         if let Ok(\n@@ -374,7 +373,7 @@ impl<'tcx> TyCtxt<'tcx> {\n                         ) = self.sess.source_map().span_to_snippet(sp) =>\n                     {\n                         if snippet.chars().all(|c| c.is_digit(10) || c == '-' || c == '_') {\n-                            db.span_suggestion(\n+                            diag.span_suggestion(\n                                 sp,\n                                 \"use a float literal\",\n                                 format!(\"{}.0\", snippet),\n@@ -386,30 +385,30 @@ impl<'tcx> TyCtxt<'tcx> {\n                         let generics = self.generics_of(body_owner_def_id);\n                         let e_span = self.def_span(generics.type_param(expected, self).def_id);\n                         if !sp.contains(e_span) {\n-                            db.span_label(e_span, \"expected type parameter\");\n+                            diag.span_label(e_span, \"expected type parameter\");\n                         }\n                         let f_span = self.def_span(generics.type_param(found, self).def_id);\n                         if !sp.contains(f_span) {\n-                            db.span_label(f_span, \"found type parameter\");\n+                            diag.span_label(f_span, \"found type parameter\");\n                         }\n-                        db.note(\n+                        diag.note(\n                             \"a type parameter was expected, but a different one was found; \\\n                              you might be missing a type parameter or trait bound\",\n                         );\n-                        db.note(\n+                        diag.note(\n                             \"for more information, visit \\\n                              https://doc.rust-lang.org/book/ch10-02-traits.html\\\n                              #traits-as-parameters\",\n                         );\n                     }\n                     (ty::Projection(_), ty::Projection(_)) => {\n-                        db.note(\"an associated type was expected, but a different one was found\");\n+                        diag.note(\"an associated type was expected, but a different one was found\");\n                     }\n                     (ty::Param(p), ty::Projection(proj)) | (ty::Projection(proj), ty::Param(p)) => {\n                         let generics = self.generics_of(body_owner_def_id);\n                         let p_span = self.def_span(generics.type_param(p, self).def_id);\n                         if !sp.contains(p_span) {\n-                            db.span_label(p_span, \"this type parameter\");\n+                            diag.span_label(p_span, \"this type parameter\");\n                         }\n                         let hir = self.hir();\n                         let mut note = true;\n@@ -444,26 +443,26 @@ impl<'tcx> TyCtxt<'tcx> {\n                             note = !suggest_constraining_type_param(\n                                 self,\n                                 generics,\n-                                db,\n+                                diag,\n                                 &format!(\"{}\", proj.self_ty()),\n                                 &path,\n                                 None,\n                             );\n                         }\n                         if note {\n-                            db.note(\"you might be missing a type parameter or trait bound\");\n+                            diag.note(\"you might be missing a type parameter or trait bound\");\n                         }\n                     }\n                     (ty::Param(p), ty::Dynamic(..) | ty::Opaque(..))\n                     | (ty::Dynamic(..) | ty::Opaque(..), ty::Param(p)) => {\n                         let generics = self.generics_of(body_owner_def_id);\n                         let p_span = self.def_span(generics.type_param(p, self).def_id);\n                         if !sp.contains(p_span) {\n-                            db.span_label(p_span, \"this type parameter\");\n+                            diag.span_label(p_span, \"this type parameter\");\n                         }\n-                        db.help(\"type parameters must be constrained to match other types\");\n-                        if self.sess.teach(&db.get_code().unwrap()) {\n-                            db.help(\n+                        diag.help(\"type parameters must be constrained to match other types\");\n+                        if self.sess.teach(&diag.get_code().unwrap()) {\n+                            diag.help(\n                                 \"given a type parameter `T` and a method `foo`:\n ```\n trait Trait<T> { fn foo(&self) -> T; }\n@@ -489,7 +488,7 @@ impl<T> Trait<T> for X {\n ```\",\n                             );\n                         }\n-                        db.note(\n+                        diag.note(\n                             \"for more information, visit \\\n                              https://doc.rust-lang.org/book/ch10-02-traits.html\\\n                              #traits-as-parameters\",\n@@ -499,9 +498,9 @@ impl<T> Trait<T> for X {\n                         let generics = self.generics_of(body_owner_def_id);\n                         let p_span = self.def_span(generics.type_param(p, self).def_id);\n                         if !sp.contains(p_span) {\n-                            db.span_label(p_span, \"this type parameter\");\n+                            diag.span_label(p_span, \"this type parameter\");\n                         }\n-                        db.help(&format!(\n+                        diag.help(&format!(\n                             \"every closure has a distinct type and so could not always match the \\\n                              caller-chosen type of parameter `{}`\",\n                             p\n@@ -511,12 +510,12 @@ impl<T> Trait<T> for X {\n                         let generics = self.generics_of(body_owner_def_id);\n                         let p_span = self.def_span(generics.type_param(p, self).def_id);\n                         if !sp.contains(p_span) {\n-                            db.span_label(p_span, \"this type parameter\");\n+                            diag.span_label(p_span, \"this type parameter\");\n                         }\n                     }\n                     (ty::Projection(proj_ty), _) => {\n                         self.expected_projection(\n-                            db,\n+                            diag,\n                             proj_ty,\n                             values,\n                             body_owner_def_id,\n@@ -529,19 +528,19 @@ impl<T> Trait<T> for X {\n                             values.found, values.expected,\n                         );\n                         if !(self.suggest_constraining_opaque_associated_type(\n-                            db,\n+                            diag,\n                             &msg,\n                             proj_ty,\n                             values.expected,\n                         ) || self.suggest_constraint(\n-                            db,\n+                            diag,\n                             &msg,\n                             body_owner_def_id,\n                             proj_ty,\n                             values.expected,\n                         )) {\n-                            db.help(&msg);\n-                            db.note(\n+                            diag.help(&msg);\n+                            diag.note(\n                                 \"for more information, visit \\\n                                 https://doc.rust-lang.org/book/ch19-03-advanced-traits.html\",\n                             );\n@@ -560,7 +559,7 @@ impl<T> Trait<T> for X {\n             CyclicTy(ty) => {\n                 // Watch out for various cases of cyclic types and try to explain.\n                 if ty.is_closure() || ty.is_generator() {\n-                    db.note(\n+                    diag.note(\n                         \"closures cannot capture themselves or take themselves as argument;\\n\\\n                          this error may be the result of a recent compiler bug-fix,\\n\\\n                          see issue #46062 <https://github.com/rust-lang/rust/issues/46062>\\n\\\n@@ -574,19 +573,18 @@ impl<T> Trait<T> for X {\n                     .iter()\n                     .filter(|attr| attr.has_name(sym::target_feature))\n                     .map(|attr| attr.span);\n-                db.note(\n+                diag.note(\n                     \"functions with `#[target_feature]` can only be coerced to `unsafe` function pointers\"\n                 );\n-                db.span_labels(target_spans, \"`#[target_feature]` added here\");\n+                diag.span_labels(target_spans, \"`#[target_feature]` added here\");\n             }\n             _ => {}\n         }\n     }\n \n     fn suggest_constraint(\n         self,\n-        // FIXME(eddyb) rename this since it's no longer a `DiagnosticBuilder`.\n-        db: &mut Diagnostic,\n+        diag: &mut Diagnostic,\n         msg: &str,\n         body_owner_def_id: DefId,\n         proj_ty: &ty::ProjectionTy<'tcx>,\n@@ -623,7 +621,7 @@ impl<T> Trait<T> for X {\n                         }\n \n                         if self.constrain_generic_bound_associated_type_structured_suggestion(\n-                            db,\n+                            diag,\n                             &trait_ref,\n                             pred.bounds,\n                             &assoc,\n@@ -642,7 +640,7 @@ impl<T> Trait<T> for X {\n                     {\n                         // This is type param `A` in `<A as T>::Foo`.\n                         return self.constrain_generic_bound_associated_type_structured_suggestion(\n-                            db,\n+                            diag,\n                             &trait_ref,\n                             param.bounds,\n                             &assoc,\n@@ -673,8 +671,7 @@ impl<T> Trait<T> for X {\n     ///    fn that returns the type.\n     fn expected_projection(\n         self,\n-        // FIXME(eddyb) rename this since it's no longer a `DiagnosticBuilder`.\n-        db: &mut Diagnostic,\n+        diag: &mut Diagnostic,\n         proj_ty: &ty::ProjectionTy<'tcx>,\n         values: &ExpectedFound<Ty<'tcx>>,\n         body_owner_def_id: DefId,\n@@ -712,41 +709,44 @@ impl<T> Trait<T> for X {\n             // want the more general suggestion later in this method about \"consider constraining\n             // the associated type or calling a method that returns the associated type\".\n             let point_at_assoc_fn = self.point_at_methods_that_satisfy_associated_type(\n-                db,\n+                diag,\n                 assoc.container.id(),\n                 current_method_ident,\n                 proj_ty.item_def_id,\n                 values.expected,\n             );\n             // Possibly suggest constraining the associated type to conform to the\n             // found type.\n-            if self.suggest_constraint(db, &msg, body_owner_def_id, proj_ty, values.found)\n+            if self.suggest_constraint(diag, &msg, body_owner_def_id, proj_ty, values.found)\n                 || point_at_assoc_fn\n             {\n                 return;\n             }\n         }\n \n-        self.suggest_constraining_opaque_associated_type(db, &msg, proj_ty, values.found);\n+        self.suggest_constraining_opaque_associated_type(diag, &msg, proj_ty, values.found);\n \n-        if self.point_at_associated_type(db, body_owner_def_id, values.found) {\n+        if self.point_at_associated_type(diag, body_owner_def_id, values.found) {\n             return;\n         }\n \n         if !impl_comparison {\n             // Generic suggestion when we can't be more specific.\n             if callable_scope {\n-                db.help(&format!(\"{} or calling a method that returns `{}`\", msg, values.expected));\n+                diag.help(&format!(\n+                    \"{} or calling a method that returns `{}`\",\n+                    msg, values.expected\n+                ));\n             } else {\n-                db.help(&msg);\n+                diag.help(&msg);\n             }\n-            db.note(\n+            diag.note(\n                 \"for more information, visit \\\n                  https://doc.rust-lang.org/book/ch19-03-advanced-traits.html\",\n             );\n         }\n-        if self.sess.teach(&db.get_code().unwrap()) {\n-            db.help(\n+        if self.sess.teach(&diag.get_code().unwrap()) {\n+            diag.help(\n                 \"given an associated type `T` and a method `foo`:\n ```\n trait Trait {\n@@ -769,8 +769,7 @@ fn foo(&self) -> Self::T { String::new() }\n     /// a return type. This can occur when dealing with `TryStream` (#71035).\n     fn suggest_constraining_opaque_associated_type(\n         self,\n-        // FIXME(eddyb) rename this since it's no longer a `DiagnosticBuilder`.\n-        db: &mut Diagnostic,\n+        diag: &mut Diagnostic,\n         msg: &str,\n         proj_ty: &ty::ProjectionTy<'tcx>,\n         ty: Ty<'tcx>,\n@@ -790,7 +789,7 @@ fn foo(&self) -> Self::T { String::new() }\n             let (trait_ref, assoc_substs) = proj_ty.trait_ref_and_own_substs(self);\n \n             self.constrain_generic_bound_associated_type_structured_suggestion(\n-                db,\n+                diag,\n                 &trait_ref,\n                 opaque_hir_ty.bounds,\n                 assoc,\n@@ -806,8 +805,7 @@ fn foo(&self) -> Self::T { String::new() }\n \n     fn point_at_methods_that_satisfy_associated_type(\n         self,\n-        // FIXME(eddyb) rename this since it's no longer a `DiagnosticBuilder`.\n-        db: &mut Diagnostic,\n+        diag: &mut Diagnostic,\n         assoc_container_id: DefId,\n         current_method_ident: Option<Symbol>,\n         proj_ty_item_def_id: DefId,\n@@ -854,16 +852,15 @@ fn foo(&self) -> Self::T { String::new() }\n             for (sp, label) in methods.into_iter() {\n                 span.push_span_label(sp, label);\n             }\n-            db.span_help(span, &msg);\n+            diag.span_help(span, &msg);\n             return true;\n         }\n         false\n     }\n \n     fn point_at_associated_type(\n         self,\n-        // FIXME(eddyb) rename this since it's no longer a `DiagnosticBuilder`.\n-        db: &mut Diagnostic,\n+        diag: &mut Diagnostic,\n         body_owner_def_id: DefId,\n         found: Ty<'tcx>,\n     ) -> bool {\n@@ -887,7 +884,7 @@ fn foo(&self) -> Self::T { String::new() }\n                             if let hir::Defaultness::Default { has_value: true } = item.defaultness\n                             {\n                                 if self.type_of(item.id.def_id) == found {\n-                                    db.span_label(\n+                                    diag.span_label(\n                                         item.span,\n                                         \"associated type defaults can't be assumed inside the \\\n                                             trait defining them\",\n@@ -907,7 +904,7 @@ fn foo(&self) -> Self::T { String::new() }\n                 for item in &items[..] {\n                     if let hir::AssocItemKind::Type = item.kind {\n                         if self.type_of(item.id.def_id) == found {\n-                            db.span_label(item.span, \"expected this associated type\");\n+                            diag.span_label(item.span, \"expected this associated type\");\n                             return true;\n                         }\n                     }\n@@ -927,8 +924,7 @@ fn foo(&self) -> Self::T { String::new() }\n     /// type is defined on a supertrait of the one present in the bounds.\n     fn constrain_generic_bound_associated_type_structured_suggestion(\n         self,\n-        // FIXME(eddyb) rename this since it's no longer a `DiagnosticBuilder`.\n-        db: &mut Diagnostic,\n+        diag: &mut Diagnostic,\n         trait_ref: &ty::TraitRef<'tcx>,\n         bounds: hir::GenericBounds<'_>,\n         assoc: &ty::AssocItem,\n@@ -958,15 +954,21 @@ fn foo(&self) -> Self::T { String::new() }\n             _ => return false,\n         };\n \n-        self.constrain_associated_type_structured_suggestion(db, span, assoc, assoc_substs, ty, msg)\n+        self.constrain_associated_type_structured_suggestion(\n+            diag,\n+            span,\n+            assoc,\n+            assoc_substs,\n+            ty,\n+            msg,\n+        )\n     }\n \n     /// Given a span corresponding to a bound, provide a structured suggestion to set an\n     /// associated type to a given type `ty`.\n     fn constrain_associated_type_structured_suggestion(\n         self,\n-        // FIXME(eddyb) rename this since it's no longer a `DiagnosticBuilder`.\n-        db: &mut Diagnostic,\n+        diag: &mut Diagnostic,\n         span: Span,\n         assoc: &ty::AssocItem,\n         assoc_substs: &[ty::GenericArg<'tcx>],\n@@ -984,7 +986,7 @@ fn foo(&self) -> Self::T { String::new() }\n                 let item_args = self.format_generic_args(assoc_substs);\n                 (span.shrink_to_hi(), format!(\"<{}{} = {}>\", assoc.ident(self), item_args, ty))\n             };\n-            db.span_suggestion_verbose(span, msg, sugg, MaybeIncorrect);\n+            diag.span_suggestion_verbose(span, msg, sugg, MaybeIncorrect);\n             return true;\n         }\n         false"}, {"sha": "3ec63d102fab6bc29031921160ee5c50bc4cc3bc", "filename": "compiler/rustc_resolve/src/late/diagnostics.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/053f70332f08333bfe29d3467cd83c9cdefcfe05/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/053f70332f08333bfe29d3467cd83c9cdefcfe05/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs?ref=053f70332f08333bfe29d3467cd83c9cdefcfe05", "patch": "@@ -1875,8 +1875,7 @@ impl<'tcx> LifetimeContext<'_, 'tcx> {\n     /// Returns whether to add `'static` lifetime to the suggested lifetime list.\n     crate fn report_elision_failure(\n         &mut self,\n-        // FIXME(eddyb) rename this since it's no longer a `DiagnosticBuilder`.\n-        db: &mut Diagnostic,\n+        diag: &mut Diagnostic,\n         params: &[ElisionFailureInfo],\n     ) -> bool {\n         let mut m = String::new();\n@@ -1891,7 +1890,7 @@ impl<'tcx> LifetimeContext<'_, 'tcx> {\n             let ElisionFailureInfo { parent, index, lifetime_count: n, have_bound_regions, span } =\n                 info;\n \n-            db.span_label(span, \"\");\n+            diag.span_label(span, \"\");\n             let help_name = if let Some(ident) =\n                 parent.and_then(|body| self.tcx.hir().body(body).params[index].pat.simple_ident())\n             {\n@@ -1923,27 +1922,27 @@ impl<'tcx> LifetimeContext<'_, 'tcx> {\n         }\n \n         if len == 0 {\n-            db.help(\n+            diag.help(\n                 \"this function's return type contains a borrowed value, \\\n                  but there is no value for it to be borrowed from\",\n             );\n             true\n         } else if elided_len == 0 {\n-            db.help(\n+            diag.help(\n                 \"this function's return type contains a borrowed value with \\\n                  an elided lifetime, but the lifetime cannot be derived from \\\n                  the arguments\",\n             );\n             true\n         } else if elided_len == 1 {\n-            db.help(&format!(\n+            diag.help(&format!(\n                 \"this function's return type contains a borrowed value, \\\n                  but the signature does not say which {} it is borrowed from\",\n                 m\n             ));\n             false\n         } else {\n-            db.help(&format!(\n+            diag.help(&format!(\n                 \"this function's return type contains a borrowed value, \\\n                  but the signature does not say whether it is borrowed from {}\",\n                 m"}]}