{"sha": "2ece157e179e8613e8cfc3654acb3d32b62ed841", "node_id": "C_kwDOAAsO6NoAKDJlY2UxNTdlMTc5ZTg2MTNlOGNmYzM2NTRhY2IzZDMyYjYyZWQ4NDE", "commit": {"author": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-05-12T23:38:02Z"}, "committer": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-05-27T05:58:35Z"}, "message": "Make `Buffer<T>` non-generic.\n\n`u8` is the only type that makes sense for `T`, as demonstrated by the\nfact that several impls and functions are hardwired to `Buffer<u8>`.", "tree": {"sha": "fd342a027a90a3cb014830bbc31e5aa598d71c1b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fd342a027a90a3cb014830bbc31e5aa598d71c1b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2ece157e179e8613e8cfc3654acb3d32b62ed841", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2ece157e179e8613e8cfc3654acb3d32b62ed841", "html_url": "https://github.com/rust-lang/rust/commit/2ece157e179e8613e8cfc3654acb3d32b62ed841", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2ece157e179e8613e8cfc3654acb3d32b62ed841/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e02789c9f88e27e03eb583468286c6f94bc9345e", "url": "https://api.github.com/repos/rust-lang/rust/commits/e02789c9f88e27e03eb583468286c6f94bc9345e", "html_url": "https://github.com/rust-lang/rust/commit/e02789c9f88e27e03eb583468286c6f94bc9345e"}], "stats": {"total": 92, "additions": 46, "deletions": 46}, "files": [{"sha": "fb05a02dc4571e4cf1ba9215fd8cb93a6a5cc0b9", "filename": "library/proc_macro/src/bridge/buffer.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/2ece157e179e8613e8cfc3654acb3d32b62ed841/library%2Fproc_macro%2Fsrc%2Fbridge%2Fbuffer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ece157e179e8613e8cfc3654acb3d32b62ed841/library%2Fproc_macro%2Fsrc%2Fbridge%2Fbuffer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fproc_macro%2Fsrc%2Fbridge%2Fbuffer.rs?ref=2ece157e179e8613e8cfc3654acb3d32b62ed841", "patch": "@@ -6,37 +6,37 @@ use std::ops::{Deref, DerefMut};\n use std::slice;\n \n #[repr(C)]\n-pub struct Buffer<T: Copy> {\n-    data: *mut T,\n+pub struct Buffer {\n+    data: *mut u8,\n     len: usize,\n     capacity: usize,\n-    reserve: extern \"C\" fn(Buffer<T>, usize) -> Buffer<T>,\n-    drop: extern \"C\" fn(Buffer<T>),\n+    reserve: extern \"C\" fn(Buffer, usize) -> Buffer,\n+    drop: extern \"C\" fn(Buffer),\n }\n \n-unsafe impl<T: Copy + Sync> Sync for Buffer<T> {}\n-unsafe impl<T: Copy + Send> Send for Buffer<T> {}\n+unsafe impl Sync for Buffer {}\n+unsafe impl Send for Buffer {}\n \n-impl<T: Copy> Default for Buffer<T> {\n+impl Default for Buffer {\n     fn default() -> Self {\n         Self::from(vec![])\n     }\n }\n \n-impl<T: Copy> Deref for Buffer<T> {\n-    type Target = [T];\n-    fn deref(&self) -> &[T] {\n-        unsafe { slice::from_raw_parts(self.data as *const T, self.len) }\n+impl Deref for Buffer {\n+    type Target = [u8];\n+    fn deref(&self) -> &[u8] {\n+        unsafe { slice::from_raw_parts(self.data as *const u8, self.len) }\n     }\n }\n \n-impl<T: Copy> DerefMut for Buffer<T> {\n-    fn deref_mut(&mut self) -> &mut [T] {\n+impl DerefMut for Buffer {\n+    fn deref_mut(&mut self) -> &mut [u8] {\n         unsafe { slice::from_raw_parts_mut(self.data, self.len) }\n     }\n }\n \n-impl<T: Copy> Buffer<T> {\n+impl Buffer {\n     pub(super) fn new() -> Self {\n         Self::default()\n     }\n@@ -53,7 +53,7 @@ impl<T: Copy> Buffer<T> {\n     // because in the case of small arrays, codegen can be more efficient\n     // (avoiding a memmove call). With extend_from_slice, LLVM at least\n     // currently is not able to make that optimization.\n-    pub(super) fn extend_from_array<const N: usize>(&mut self, xs: &[T; N]) {\n+    pub(super) fn extend_from_array<const N: usize>(&mut self, xs: &[u8; N]) {\n         if xs.len() > (self.capacity - self.len) {\n             let b = self.take();\n             *self = (b.reserve)(b, xs.len());\n@@ -64,7 +64,7 @@ impl<T: Copy> Buffer<T> {\n         }\n     }\n \n-    pub(super) fn extend_from_slice(&mut self, xs: &[T]) {\n+    pub(super) fn extend_from_slice(&mut self, xs: &[u8]) {\n         if xs.len() > (self.capacity - self.len) {\n             let b = self.take();\n             *self = (b.reserve)(b, xs.len());\n@@ -75,7 +75,7 @@ impl<T: Copy> Buffer<T> {\n         }\n     }\n \n-    pub(super) fn push(&mut self, v: T) {\n+    pub(super) fn push(&mut self, v: u8) {\n         // The code here is taken from Vec::push, and we know that reserve()\n         // will panic if we're exceeding isize::MAX bytes and so there's no need\n         // to check for overflow.\n@@ -90,7 +90,7 @@ impl<T: Copy> Buffer<T> {\n     }\n }\n \n-impl Write for Buffer<u8> {\n+impl Write for Buffer {\n     fn write(&mut self, xs: &[u8]) -> io::Result<usize> {\n         self.extend_from_slice(xs);\n         Ok(xs.len())\n@@ -106,35 +106,35 @@ impl Write for Buffer<u8> {\n     }\n }\n \n-impl<T: Copy> Drop for Buffer<T> {\n+impl Drop for Buffer {\n     fn drop(&mut self) {\n         let b = self.take();\n         (b.drop)(b);\n     }\n }\n \n-impl<T: Copy> From<Vec<T>> for Buffer<T> {\n-    fn from(mut v: Vec<T>) -> Self {\n+impl From<Vec<u8>> for Buffer {\n+    fn from(mut v: Vec<u8>) -> Self {\n         let (data, len, capacity) = (v.as_mut_ptr(), v.len(), v.capacity());\n         mem::forget(v);\n \n         // This utility function is nested in here because it can *only*\n         // be safely called on `Buffer`s created by *this* `proc_macro`.\n-        fn to_vec<T: Copy>(b: Buffer<T>) -> Vec<T> {\n+        fn to_vec(b: Buffer) -> Vec<u8> {\n             unsafe {\n                 let Buffer { data, len, capacity, .. } = b;\n                 mem::forget(b);\n                 Vec::from_raw_parts(data, len, capacity)\n             }\n         }\n \n-        extern \"C\" fn reserve<T: Copy>(b: Buffer<T>, additional: usize) -> Buffer<T> {\n+        extern \"C\" fn reserve(b: Buffer, additional: usize) -> Buffer {\n             let mut v = to_vec(b);\n             v.reserve(additional);\n             Buffer::from(v)\n         }\n \n-        extern \"C\" fn drop<T: Copy>(b: Buffer<T>) {\n+        extern \"C\" fn drop(b: Buffer) {\n             mem::drop(to_vec(b));\n         }\n "}, {"sha": "60e6950b393bb9b69234aa1daf167294c4f0d5b0", "filename": "library/proc_macro/src/bridge/client.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2ece157e179e8613e8cfc3654acb3d32b62ed841/library%2Fproc_macro%2Fsrc%2Fbridge%2Fclient.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ece157e179e8613e8cfc3654acb3d32b62ed841/library%2Fproc_macro%2Fsrc%2Fbridge%2Fclient.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fproc_macro%2Fsrc%2Fbridge%2Fclient.rs?ref=2ece157e179e8613e8cfc3654acb3d32b62ed841", "patch": "@@ -367,7 +367,7 @@ pub struct Client<F> {\n     // FIXME(eddyb) use a reference to the `static COUNTERS`, instead of\n     // a wrapper `fn` pointer, once `const fn` can reference `static`s.\n     pub(super) get_handle_counters: extern \"C\" fn() -> &'static HandleCounters,\n-    pub(super) run: extern \"C\" fn(Bridge<'_>, F) -> Buffer<u8>,\n+    pub(super) run: extern \"C\" fn(Bridge<'_>, F) -> Buffer,\n     pub(super) f: F,\n }\n \n@@ -377,7 +377,7 @@ pub struct Client<F> {\n fn run_client<A: for<'a, 's> DecodeMut<'a, 's, ()>, R: Encode<()>>(\n     mut bridge: Bridge<'_>,\n     f: impl FnOnce(A) -> R,\n-) -> Buffer<u8> {\n+) -> Buffer {\n     // The initial `cached_buffer` contains the input.\n     let mut b = bridge.cached_buffer.take();\n \n@@ -420,7 +420,7 @@ impl Client<fn(crate::TokenStream) -> crate::TokenStream> {\n         extern \"C\" fn run(\n             bridge: Bridge<'_>,\n             f: impl FnOnce(crate::TokenStream) -> crate::TokenStream,\n-        ) -> Buffer<u8> {\n+        ) -> Buffer {\n             run_client(bridge, |input| f(crate::TokenStream(input)).0)\n         }\n         Client { get_handle_counters: HandleCounters::get, run, f }\n@@ -434,7 +434,7 @@ impl Client<fn(crate::TokenStream, crate::TokenStream) -> crate::TokenStream> {\n         extern \"C\" fn run(\n             bridge: Bridge<'_>,\n             f: impl FnOnce(crate::TokenStream, crate::TokenStream) -> crate::TokenStream,\n-        ) -> Buffer<u8> {\n+        ) -> Buffer {\n             run_client(bridge, |(input, input2)| {\n                 f(crate::TokenStream(input), crate::TokenStream(input2)).0\n             })"}, {"sha": "c547bb758b06271642a045d16df5788343d58fcd", "filename": "library/proc_macro/src/bridge/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2ece157e179e8613e8cfc3654acb3d32b62ed841/library%2Fproc_macro%2Fsrc%2Fbridge%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ece157e179e8613e8cfc3654acb3d32b62ed841/library%2Fproc_macro%2Fsrc%2Fbridge%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fproc_macro%2Fsrc%2Fbridge%2Fmod.rs?ref=2ece157e179e8613e8cfc3654acb3d32b62ed841", "patch": "@@ -224,10 +224,10 @@ use rpc::{Decode, DecodeMut, Encode, Reader, Writer};\n pub struct Bridge<'a> {\n     /// Reusable buffer (only `clear`-ed, never shrunk), primarily\n     /// used for making requests, but also for passing input to client.\n-    cached_buffer: Buffer<u8>,\n+    cached_buffer: Buffer,\n \n     /// Server-side function that the client uses to make requests.\n-    dispatch: closure::Closure<'a, Buffer<u8>, Buffer<u8>>,\n+    dispatch: closure::Closure<'a, Buffer, Buffer>,\n \n     /// If 'true', always invoke the default panic hook\n     force_show_panics: bool,"}, {"sha": "f79e016400fb1a5d30608084665d26a38eada924", "filename": "library/proc_macro/src/bridge/rpc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ece157e179e8613e8cfc3654acb3d32b62ed841/library%2Fproc_macro%2Fsrc%2Fbridge%2Frpc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ece157e179e8613e8cfc3654acb3d32b62ed841/library%2Fproc_macro%2Fsrc%2Fbridge%2Frpc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fproc_macro%2Fsrc%2Fbridge%2Frpc.rs?ref=2ece157e179e8613e8cfc3654acb3d32b62ed841", "patch": "@@ -7,7 +7,7 @@ use std::num::NonZeroU32;\n use std::ops::Bound;\n use std::str;\n \n-pub(super) type Writer = super::buffer::Buffer<u8>;\n+pub(super) type Writer = super::buffer::Buffer;\n \n pub(super) trait Encode<S>: Sized {\n     fn encode(self, w: &mut Writer, s: &mut S);"}, {"sha": "f916d482b071285d4748173be7efa7c7498c118b", "filename": "library/proc_macro/src/bridge/server.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/2ece157e179e8613e8cfc3654acb3d32b62ed841/library%2Fproc_macro%2Fsrc%2Fbridge%2Fserver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ece157e179e8613e8cfc3654acb3d32b62ed841/library%2Fproc_macro%2Fsrc%2Fbridge%2Fserver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fproc_macro%2Fsrc%2Fbridge%2Fserver.rs?ref=2ece157e179e8613e8cfc3654acb3d32b62ed841", "patch": "@@ -80,12 +80,12 @@ macro_rules! define_dispatcher_impl {\n         pub trait DispatcherTrait {\n             // HACK(eddyb) these are here to allow `Self::$name` to work below.\n             $(type $name;)*\n-            fn dispatch(&mut self, b: Buffer<u8>) -> Buffer<u8>;\n+            fn dispatch(&mut self, b: Buffer) -> Buffer;\n         }\n \n         impl<S: Server> DispatcherTrait for Dispatcher<MarkedTypes<S>> {\n             $(type $name = <MarkedTypes<S> as Types>::$name;)*\n-            fn dispatch(&mut self, mut b: Buffer<u8>) -> Buffer<u8> {\n+            fn dispatch(&mut self, mut b: Buffer) -> Buffer {\n                 let Dispatcher { handle_store, server } = self;\n \n                 let mut reader = &b[..];\n@@ -123,11 +123,11 @@ pub trait ExecutionStrategy {\n     fn run_bridge_and_client<D: Copy + Send + 'static>(\n         &self,\n         dispatcher: &mut impl DispatcherTrait,\n-        input: Buffer<u8>,\n-        run_client: extern \"C\" fn(Bridge<'_>, D) -> Buffer<u8>,\n+        input: Buffer,\n+        run_client: extern \"C\" fn(Bridge<'_>, D) -> Buffer,\n         client_data: D,\n         force_show_panics: bool,\n-    ) -> Buffer<u8>;\n+    ) -> Buffer;\n }\n \n pub struct SameThread;\n@@ -136,11 +136,11 @@ impl ExecutionStrategy for SameThread {\n     fn run_bridge_and_client<D: Copy + Send + 'static>(\n         &self,\n         dispatcher: &mut impl DispatcherTrait,\n-        input: Buffer<u8>,\n-        run_client: extern \"C\" fn(Bridge<'_>, D) -> Buffer<u8>,\n+        input: Buffer,\n+        run_client: extern \"C\" fn(Bridge<'_>, D) -> Buffer,\n         client_data: D,\n         force_show_panics: bool,\n-    ) -> Buffer<u8> {\n+    ) -> Buffer {\n         let mut dispatch = |b| dispatcher.dispatch(b);\n \n         run_client(\n@@ -164,11 +164,11 @@ impl ExecutionStrategy for CrossThread1 {\n     fn run_bridge_and_client<D: Copy + Send + 'static>(\n         &self,\n         dispatcher: &mut impl DispatcherTrait,\n-        input: Buffer<u8>,\n-        run_client: extern \"C\" fn(Bridge<'_>, D) -> Buffer<u8>,\n+        input: Buffer,\n+        run_client: extern \"C\" fn(Bridge<'_>, D) -> Buffer,\n         client_data: D,\n         force_show_panics: bool,\n-    ) -> Buffer<u8> {\n+    ) -> Buffer {\n         use std::sync::mpsc::channel;\n \n         let (req_tx, req_rx) = channel();\n@@ -205,11 +205,11 @@ impl ExecutionStrategy for CrossThread2 {\n     fn run_bridge_and_client<D: Copy + Send + 'static>(\n         &self,\n         dispatcher: &mut impl DispatcherTrait,\n-        input: Buffer<u8>,\n-        run_client: extern \"C\" fn(Bridge<'_>, D) -> Buffer<u8>,\n+        input: Buffer,\n+        run_client: extern \"C\" fn(Bridge<'_>, D) -> Buffer,\n         client_data: D,\n         force_show_panics: bool,\n-    ) -> Buffer<u8> {\n+    ) -> Buffer {\n         use std::sync::{Arc, Mutex};\n \n         enum State<T> {\n@@ -276,7 +276,7 @@ fn run_server<\n     handle_counters: &'static client::HandleCounters,\n     server: S,\n     input: I,\n-    run_client: extern \"C\" fn(Bridge<'_>, D) -> Buffer<u8>,\n+    run_client: extern \"C\" fn(Bridge<'_>, D) -> Buffer,\n     client_data: D,\n     force_show_panics: bool,\n ) -> Result<O, PanicMessage> {"}]}