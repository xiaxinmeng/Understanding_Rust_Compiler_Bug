{"sha": "5047856f00ebdd1accec01e629d23164a1557645", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUwNDc4NTZmMDBlYmRkMWFjY2VjMDFlNjI5ZDIzMTY0YTE1NTc2NDU=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2019-12-27T14:40:44Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2019-12-31T14:56:28Z"}, "message": "Use BTreeSet and BTreeMap instead of SecondaryMap", "tree": {"sha": "3b8acd025948d4feefa006e53c38681f5233a876", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3b8acd025948d4feefa006e53c38681f5233a876"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5047856f00ebdd1accec01e629d23164a1557645", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5047856f00ebdd1accec01e629d23164a1557645", "html_url": "https://github.com/rust-lang/rust/commit/5047856f00ebdd1accec01e629d23164a1557645", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5047856f00ebdd1accec01e629d23164a1557645/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c84b1fee0980493a65880234c96577985fa193e3", "url": "https://api.github.com/repos/rust-lang/rust/commits/c84b1fee0980493a65880234c96577985fa193e3", "html_url": "https://github.com/rust-lang/rust/commit/c84b1fee0980493a65880234c96577985fa193e3"}], "stats": {"total": 125, "additions": 54, "deletions": 71}, "files": [{"sha": "f103ff18081df501eac876432386a39575196f7d", "filename": "src/optimize/stack2reg.rs", "status": "modified", "additions": 54, "deletions": 71, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/5047856f00ebdd1accec01e629d23164a1557645/src%2Foptimize%2Fstack2reg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5047856f00ebdd1accec01e629d23164a1557645/src%2Foptimize%2Fstack2reg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Foptimize%2Fstack2reg.rs?ref=5047856f00ebdd1accec01e629d23164a1557645", "patch": "@@ -1,12 +1,27 @@\n-use std::collections::HashSet;\n+use std::collections::{BTreeMap, BTreeSet, HashSet};\n \n use cranelift_codegen::cursor::{Cursor, FuncCursor};\n use cranelift_codegen::ir::{Opcode, InstructionData, ValueDef};\n use cranelift_codegen::ir::immediates::Offset32;\n-use cranelift_codegen::entity::SecondaryMap;\n \n use crate::prelude::*;\n \n+/// Workaround for `StackSlot` not implementing `Ord`.\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+struct OrdStackSlot(StackSlot);\n+\n+impl PartialOrd for OrdStackSlot {\n+    fn partial_cmp(&self, rhs: &Self) -> Option<std::cmp::Ordering> {\n+        self.0.as_u32().partial_cmp(&rhs.0.as_u32())\n+    }\n+}\n+\n+impl Ord for OrdStackSlot {\n+    fn cmp(&self, rhs: &Self) -> std::cmp::Ordering {\n+        self.0.as_u32().cmp(&rhs.0.as_u32())\n+    }\n+}\n+\n pub(super) fn optimize_function(\n     func: &mut Function,\n     clif_comments: &mut crate::pretty_clif::CommentWriter,\n@@ -16,11 +31,11 @@ pub(super) fn optimize_function(\n \n     // Record all stack_addr, stack_load and stack_store instructions. Also record all stack_addr\n     // and stack_load insts whose result is used.\n-    let mut stack_addr_insts = SecondaryMap::new();\n-    let mut stack_addr_insts_users = SecondaryMap::<Inst, HashSet<Inst>>::new();\n-    let mut stack_load_insts = SecondaryMap::new();\n-    let mut stack_load_insts_users = SecondaryMap::<Inst, HashSet<Inst>>::new();\n-    let mut stack_store_insts = SecondaryMap::new();\n+    let mut stack_addr_insts = BTreeSet::new();\n+    let mut stack_addr_insts_users = BTreeMap::<Inst, HashSet<Inst>>::new();\n+    let mut stack_load_insts = BTreeSet::new();\n+    let mut stack_load_insts_users = BTreeMap::<Inst, HashSet<Inst>>::new();\n+    let mut stack_store_insts = BTreeSet::new();\n \n     let mut cursor = FuncCursor::new(func);\n     while let Some(_ebb) = cursor.next_ebb() {\n@@ -31,22 +46,22 @@ pub(super) fn optimize_function(\n                     stack_slot: _,\n                     offset: _,\n                 } => {\n-                    stack_addr_insts[inst] = true;\n+                    stack_addr_insts.insert(inst);\n                 }\n                 InstructionData::StackLoad {\n                     opcode: Opcode::StackLoad,\n                     stack_slot: _,\n                     offset: _,\n                 } => {\n-                    stack_load_insts[inst] = true;\n+                    stack_load_insts.insert(inst);\n                 }\n                 InstructionData::StackStore {\n                     opcode: Opcode::StackStore,\n                     arg: _,\n                     stack_slot: _,\n                     offset: _,\n                 } => {\n-                    stack_store_insts[inst] = true;\n+                    stack_store_insts.insert(inst);\n                 }\n                 _ => {}\n             }\n@@ -55,10 +70,10 @@ pub(super) fn optimize_function(\n                 if let ValueDef::Result(arg_origin, 0) = cursor.func.dfg.value_def(arg) {\n                     match cursor.func.dfg[arg_origin].opcode() {\n                         Opcode::StackAddr => {\n-                            stack_addr_insts_users[arg_origin].insert(inst);\n+                            stack_addr_insts_users.entry(arg_origin).or_insert_with(HashSet::new).insert(inst);\n                         }\n                         Opcode::StackLoad => {\n-                            stack_load_insts_users[arg_origin].insert(inst);\n+                            stack_load_insts_users.entry(arg_origin).or_insert_with(HashSet::new).insert(inst);\n                         }\n                         _ => {}\n                     }\n@@ -68,84 +83,86 @@ pub(super) fn optimize_function(\n     }\n \n     println!(\n-        \"{}:\\nstack_addr: [{}] ({{{}}} used)\\nstack_load: [{}] ([{{{}}}] used)\\nstack_store: [{}]\",\n+        \"{}:\\nstack_addr: {:?} ({:?} used)\\nstack_load: {:?} ({:?} used)\\nstack_store: {:?}\",\n         name,\n-        bool_secondary_map_to_string(&stack_addr_insts),\n-        usage_secondary_map_to_string(&stack_addr_insts_users),\n-        bool_secondary_map_to_string(&stack_load_insts),\n-        usage_secondary_map_to_string(&stack_load_insts_users),\n-        bool_secondary_map_to_string(&stack_store_insts),\n+        stack_addr_insts,\n+        stack_addr_insts_users,\n+        stack_load_insts,\n+        stack_load_insts_users,\n+        stack_store_insts,\n     );\n \n-    for inst in stack_addr_insts_users.keys().filter(|&inst| !stack_addr_insts_users[inst].is_empty()) {\n-        assert!(stack_addr_insts[inst]);\n+    for inst in stack_addr_insts_users.keys() {\n+        assert!(stack_addr_insts.contains(inst));\n     }\n \n     // Replace all unused stack_addr instructions with nop.\n-    for inst in stack_addr_insts.keys() {\n-        if stack_addr_insts[inst] && stack_addr_insts_users[inst].is_empty() {\n+    // FIXME remove clone\n+    for &inst in stack_addr_insts.clone().iter() {\n+        if stack_addr_insts_users.get(&inst).map(|users| users.is_empty()).unwrap_or(true) {\n             func.dfg.detach_results(inst);\n             func.dfg.replace(inst).nop();\n-            stack_addr_insts[inst] = false;\n+            stack_addr_insts.remove(&inst);\n         }\n     }\n \n-    for inst in stack_load_insts_users.keys().filter(|&inst| !stack_load_insts_users[inst].is_empty()) {\n-        assert!(stack_load_insts[inst]);\n+    for inst in stack_load_insts_users.keys() {\n+        assert!(stack_load_insts.contains(inst));\n     }\n \n     // Replace all unused stack_load instructions with nop.\n-    for inst in stack_load_insts.keys() {\n-        if stack_load_insts[inst] && !stack_addr_insts_users[inst].is_empty() {\n+    // FIXME remove clone\n+    for &inst in stack_load_insts.clone().iter() {\n+        if !stack_addr_insts_users.get(&inst).map(|users| users.is_empty()).unwrap_or(true) {\n             func.dfg.detach_results(inst);\n             func.dfg.replace(inst).nop();\n-            stack_load_insts[inst] = false;\n+            stack_load_insts.remove(&inst);\n         }\n     }\n \n \n     //println!(\"stack_addr (after): [{}]\", bool_secondary_map_to_string(&stack_addr_insts));\n \n-    let mut stack_slot_usage_map: SecondaryMap<StackSlot, HashSet<Inst>> = SecondaryMap::new();\n-    for inst in stack_load_insts.keys().filter(|&inst| stack_load_insts[inst]) {\n+    let mut stack_slot_usage_map: BTreeMap<OrdStackSlot, HashSet<Inst>> = BTreeMap::new();\n+    for &inst in stack_load_insts.iter() {\n         match func.dfg[inst] {\n             InstructionData::StackLoad {\n                 opcode: Opcode::StackLoad,\n                 stack_slot,\n                 offset: _,\n             } => {\n-                stack_slot_usage_map[stack_slot].insert(inst);\n+                stack_slot_usage_map.entry(OrdStackSlot(stack_slot)).or_insert_with(HashSet::new).insert(inst);\n             }\n             ref data => unreachable!(\"{:?}\", data),\n         }\n     }\n-    for inst in stack_store_insts.keys().filter(|&inst| stack_store_insts[inst]) {\n+    for &inst in stack_store_insts.iter() {\n         match func.dfg[inst] {\n             InstructionData::StackStore {\n                 opcode: Opcode::StackStore,\n                 arg: _,\n                 stack_slot,\n                 offset: _,\n             } => {\n-                stack_slot_usage_map[stack_slot].insert(inst);\n+                stack_slot_usage_map.entry(OrdStackSlot(stack_slot)).or_insert_with(HashSet::new).insert(inst);\n             }\n             ref data => unreachable!(\"{:?}\", data),\n         }\n     }\n-    for inst in stack_addr_insts.keys().filter(|&inst| stack_addr_insts[inst]) {\n+    for &inst in stack_addr_insts.iter() {\n         match func.dfg[inst] {\n             InstructionData::StackLoad {\n                 opcode: Opcode::StackAddr,\n                 stack_slot,\n                 offset: _,\n             } => {\n-                stack_slot_usage_map[stack_slot].insert(inst);\n+                stack_slot_usage_map.entry(OrdStackSlot(stack_slot)).or_insert_with(HashSet::new).insert(inst);\n             }\n             ref data => unreachable!(\"{:?}\", data),\n         }\n     }\n \n-    println!(\"stack slot usage: {{{}}}\", usage_secondary_map_to_string(&stack_slot_usage_map));\n+    println!(\"stack slot usage: {:?}\", stack_slot_usage_map);\n \n     for (stack_slot, users) in stack_slot_usage_map.iter_mut() {\n         let mut is_addr_leaked = false;\n@@ -188,7 +205,7 @@ pub(super) fn optimize_function(\n         } else {\n             // Stored value never read; just remove reads.\n             for &user in users.iter() {\n-                println!(\"[{}] Remove dead stack store {} of {}\", name, user, stack_slot);\n+                println!(\"[{}] Remove dead stack store {} of {}\", name, user, stack_slot.0);\n                 func.dfg.replace(user).nop();\n             }\n         }\n@@ -242,37 +259,3 @@ fn try_get_stack_slot_and_offset_for_addr(func: &Function, addr: Value) -> Optio\n     }\n     None\n }\n-\n-fn bool_secondary_map_to_string<E>(map: &SecondaryMap<E, bool>) -> String\n-    where E: cranelift_codegen::entity::EntityRef + std::fmt::Display,\n-{\n-    map\n-        .keys()\n-        .filter_map(|inst| {\n-            // EntitySet::keys returns all possible entities until the last entity inserted.\n-            if map[inst] {\n-                Some(format!(\"{}\", inst))\n-            } else {\n-                None\n-            }\n-        })\n-        .collect::<Vec<String>>()\n-        .join(\", \")\n-}\n-\n-fn usage_secondary_map_to_string<E>(map: &SecondaryMap<E, HashSet<Inst>>) -> String\n-    where E: cranelift_codegen::entity::EntityRef + std::fmt::Display,\n-{\n-    map\n-        .keys()\n-        .filter_map(|inst| {\n-            // EntitySet::keys returns all possible entities until the last entity inserted.\n-            if !map[inst].is_empty() {\n-                Some(format!(\"{}: {:?}\", inst, map[inst]))\n-            } else {\n-                None\n-            }\n-        })\n-        .collect::<Vec<String>>()\n-        .join(\", \")\n-}"}]}