{"sha": "96f09d73cd6ffc4a4e2719819e205b6e5a26718f", "node_id": "C_kwDOAAsO6NoAKDk2ZjA5ZDczY2Q2ZmZjNGE0ZTI3MTk4MTllMjA1YjZlNWEyNjcxOGY", "commit": {"author": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-07-07T01:09:07Z"}, "committer": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-07-11T04:07:33Z"}, "message": "Remove unnecessary `&*` sigil pairs in derived code.\n\nBy producing `&T` expressions for fields instead of `T`. This matches\nwhat the existing comments (e.g. on `FieldInfo`) claim is happening, and\nit's also what most of the trait-specific code needs.\n\nThe exception is `PartialEq`, which needs `T` expressions for lots of\nspecial case error messaging to work. So we now convert the `&T` back to\na `T` for `PartialEq`.", "tree": {"sha": "1038dd27fb5ebb4ab4cf5d61e2bd7dabec4b47f5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1038dd27fb5ebb4ab4cf5d61e2bd7dabec4b47f5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/96f09d73cd6ffc4a4e2719819e205b6e5a26718f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/96f09d73cd6ffc4a4e2719819e205b6e5a26718f", "html_url": "https://github.com/rust-lang/rust/commit/96f09d73cd6ffc4a4e2719819e205b6e5a26718f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/96f09d73cd6ffc4a4e2719819e205b6e5a26718f/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "277bc9641d5585fcb2d94440efc6b1880a74fd64", "url": "https://api.github.com/repos/rust-lang/rust/commits/277bc9641d5585fcb2d94440efc6b1880a74fd64", "html_url": "https://github.com/rust-lang/rust/commit/277bc9641d5585fcb2d94440efc6b1880a74fd64"}], "stats": {"total": 183, "additions": 102, "deletions": 81}, "files": [{"sha": "72aa8e17d01f975b04ecdcd608400da524e461c2", "filename": "compiler/rustc_builtin_macros/src/deriving/clone.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/96f09d73cd6ffc4a4e2719819e205b6e5a26718f/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96f09d73cd6ffc4a4e2719819e205b6e5a26718f/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fclone.rs?ref=96f09d73cd6ffc4a4e2719819e205b6e5a26718f", "patch": "@@ -161,7 +161,7 @@ fn cs_clone(\n     let all_fields;\n     let fn_path = cx.std_path(&[sym::clone, sym::Clone, sym::clone]);\n     let subcall = |cx: &mut ExtCtxt<'_>, field: &FieldInfo| {\n-        let args = vec![cx.expr_addr_of(field.span, field.self_expr.clone())];\n+        let args = vec![field.self_expr.clone()];\n         cx.expr_call_global(field.span, fn_path.clone(), args)\n     };\n "}, {"sha": "aad0ab3f5bb3baee0c1fb398d39bc1321f56f126", "filename": "compiler/rustc_builtin_macros/src/deriving/cmp/ord.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/96f09d73cd6ffc4a4e2719819e205b6e5a26718f/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Ford.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96f09d73cd6ffc4a4e2719819e205b6e5a26718f/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Ford.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Ford.rs?ref=96f09d73cd6ffc4a4e2719819e205b6e5a26718f", "patch": "@@ -63,10 +63,7 @@ pub fn cs_cmp(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>) -> Bl\n                 let [other_expr] = &field.other_selflike_exprs[..] else {\n                         cx.span_bug(field.span, \"not exactly 2 arguments in `derive(Ord)`\");\n                     };\n-                let args = vec![\n-                    cx.expr_addr_of(field.span, field.self_expr.clone()),\n-                    cx.expr_addr_of(field.span, other_expr.clone()),\n-                ];\n+                let args = vec![field.self_expr.clone(), other_expr.clone()];\n                 cx.expr_call_global(field.span, cmp_path.clone(), args)\n             }\n             CsFold::Combine(span, expr1, expr2) => {"}, {"sha": "83534b62b46c71778897977cc321e3f6886710f1", "filename": "compiler/rustc_builtin_macros/src/deriving/cmp/partial_eq.rs", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/96f09d73cd6ffc4a4e2719819e205b6e5a26718f/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96f09d73cd6ffc4a4e2719819e205b6e5a26718f/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_eq.rs?ref=96f09d73cd6ffc4a4e2719819e205b6e5a26718f", "patch": "@@ -2,7 +2,8 @@ use crate::deriving::generic::ty::*;\n use crate::deriving::generic::*;\n use crate::deriving::{path_local, path_std};\n \n-use rustc_ast::{BinOpKind, MetaItem};\n+use rustc_ast::ptr::P;\n+use rustc_ast::{BinOpKind, BorrowKind, Expr, ExprKind, MetaItem, Mutability};\n use rustc_expand::base::{Annotatable, ExtCtxt};\n use rustc_span::symbol::sym;\n use rustc_span::Span;\n@@ -32,7 +33,21 @@ pub fn expand_deriving_partial_eq(\n                     let [other_expr] = &field.other_selflike_exprs[..] else {\n                         cx.span_bug(field.span, \"not exactly 2 arguments in `derive(PartialEq)`\");\n                     };\n-                    cx.expr_binary(field.span, op, field.self_expr.clone(), other_expr.clone())\n+\n+                    // We received `&T` arguments. Convert them to `T` by\n+                    // stripping `&` or adding `*`. This isn't necessary for\n+                    // type checking, but it results in much better error\n+                    // messages if something goes wrong.\n+                    let convert = |expr: &P<Expr>| {\n+                        if let ExprKind::AddrOf(BorrowKind::Ref, Mutability::Not, inner) =\n+                            &expr.kind\n+                        {\n+                            inner.clone()\n+                        } else {\n+                            cx.expr_deref(field.span, expr.clone())\n+                        }\n+                    };\n+                    cx.expr_binary(field.span, op, convert(&field.self_expr), convert(other_expr))\n                 }\n                 CsFold::Combine(span, expr1, expr2) => cx.expr_binary(span, combiner, expr1, expr2),\n                 CsFold::Fieldless => cx.expr_bool(span, base),"}, {"sha": "ce45b0e1965567ccfada86cd5ad5d529008ccde0", "filename": "compiler/rustc_builtin_macros/src/deriving/cmp/partial_ord.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/96f09d73cd6ffc4a4e2719819e205b6e5a26718f/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96f09d73cd6ffc4a4e2719819e205b6e5a26718f/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_ord.rs?ref=96f09d73cd6ffc4a4e2719819e205b6e5a26718f", "patch": "@@ -71,10 +71,7 @@ pub fn cs_partial_cmp(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_\n                 let [other_expr] = &field.other_selflike_exprs[..] else {\n                         cx.span_bug(field.span, \"not exactly 2 arguments in `derive(Ord)`\");\n                     };\n-                let args = vec![\n-                    cx.expr_addr_of(field.span, field.self_expr.clone()),\n-                    cx.expr_addr_of(field.span, other_expr.clone()),\n-                ];\n+                let args = vec![field.self_expr.clone(), other_expr.clone()];\n                 cx.expr_call_global(field.span, partial_cmp_path.clone(), args)\n             }\n             CsFold::Combine(span, expr1, expr2) => {"}, {"sha": "5de205204869255e453bcd662665cae1095f253d", "filename": "compiler/rustc_builtin_macros/src/deriving/debug.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/96f09d73cd6ffc4a4e2719819e205b6e5a26718f/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96f09d73cd6ffc4a4e2719819e205b6e5a26718f/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdebug.rs?ref=96f09d73cd6ffc4a4e2719819e205b6e5a26718f", "patch": "@@ -95,9 +95,8 @@ fn show_substructure(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>\n                 );\n                 args.push(name);\n             }\n-            // Use double indirection to make sure this works for unsized types\n+            // Use an extra indirection to make sure this works for unsized types.\n             let field = cx.expr_addr_of(field.span, field.self_expr.clone());\n-            let field = cx.expr_addr_of(field.span, field);\n             args.push(field);\n         }\n         let expr = cx.expr_call_global(span, fn_path_debug, args);\n@@ -115,9 +114,9 @@ fn show_substructure(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>\n                 ));\n             }\n \n-            // Use double indirection to make sure this works for unsized types\n-            let value_ref = cx.expr_addr_of(field.span, field.self_expr.clone());\n-            value_exprs.push(cx.expr_addr_of(field.span, value_ref));\n+            // Use an extra indirection to make sure this works for unsized types.\n+            let field = cx.expr_addr_of(field.span, field.self_expr.clone());\n+            value_exprs.push(field);\n         }\n \n         // `let names: &'static _ = &[\"field1\", \"field2\"];`"}, {"sha": "a5d5782dbd2d12ffcb8ad520e0035fde76b7a260", "filename": "compiler/rustc_builtin_macros/src/deriving/generic/mod.rs", "status": "modified", "additions": 32, "deletions": 16, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/96f09d73cd6ffc4a4e2719819e205b6e5a26718f/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96f09d73cd6ffc4a4e2719819e205b6e5a26718f/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs?ref=96f09d73cd6ffc4a4e2719819e205b6e5a26718f", "patch": "@@ -1004,7 +1004,7 @@ impl<'a> MethodDef<'a> {\n     /// ```\n     /// #[derive(PartialEq)]\n     /// # struct Dummy;\n-    /// struct A { x: i32, y: i32 }\n+    /// struct A { x: u8, y: u8 }\n     ///\n     /// // equivalent to:\n     /// impl PartialEq for A {\n@@ -1016,9 +1016,9 @@ impl<'a> MethodDef<'a> {\n     /// But if the struct is `repr(packed)`, we can't use something like\n     /// `&self.x` on a packed type (as required for e.g. `Debug` and `Hash`)\n     /// because that might cause an unaligned ref. So we use let-destructuring\n-    /// instead.\n+    /// instead. If the struct impls `Copy`:\n     /// ```\n-    /// # struct A { x: i32, y: i32 }\n+    /// # struct A { x: u8, y: u8 }\n     /// impl PartialEq for A {\n     ///     fn eq(&self, other: &A) -> bool {\n     ///         let Self { x: __self_0_0, y: __self_0_1 } = *self;\n@@ -1027,6 +1027,19 @@ impl<'a> MethodDef<'a> {\n     ///     }\n     /// }\n     /// ```\n+    /// If it doesn't impl `Copy`:\n+    /// ```\n+    /// # struct A { x: u8, y: u8 }\n+    /// impl PartialEq for A {\n+    ///     fn eq(&self, other: &A) -> bool {\n+    ///         let Self { x: ref __self_0_0, y: ref __self_0_1 } = *self;\n+    ///         let Self { x: ref __self_1_0, y: ref __self_1_1 } = *other;\n+    ///         *__self_0_0 == *__self_1_0 && *__self_0_1 == *__self_1_1\n+    ///     }\n+    /// }\n+    /// ```\n+    /// This latter case only works if the fields match the alignment required\n+    /// by the `packed(N)` attribute.\n     fn expand_struct_method_body<'b>(\n         &self,\n         cx: &mut ExtCtxt<'_>,\n@@ -1058,9 +1071,9 @@ impl<'a> MethodDef<'a> {\n         } else {\n             let prefixes: Vec<_> =\n                 (0..selflike_args.len()).map(|i| format!(\"__self_{}\", i)).collect();\n-            let no_deref = always_copy;\n+            let addr_of = always_copy;\n             let selflike_fields =\n-                trait_.create_struct_pattern_fields(cx, struct_def, &prefixes, no_deref);\n+                trait_.create_struct_pattern_fields(cx, struct_def, &prefixes, addr_of);\n             let mut body = mk_body(cx, selflike_fields);\n \n             let struct_path = cx.path(span, vec![Ident::new(kw::SelfUpper, type_ident.span)]);\n@@ -1194,9 +1207,9 @@ impl<'a> MethodDef<'a> {\n                 // A single arm has form (&VariantK, &VariantK, ...) => BodyK\n                 // (see \"Final wrinkle\" note below for why.)\n \n-                let no_deref = false; // because enums can't be repr(packed)\n+                let addr_of = false; // because enums can't be repr(packed)\n                 let fields =\n-                    trait_.create_struct_pattern_fields(cx, &variant.data, &prefixes, no_deref);\n+                    trait_.create_struct_pattern_fields(cx, &variant.data, &prefixes, addr_of);\n \n                 let sp = variant.span.with_ctxt(trait_.span.ctxt());\n                 let variant_path = cx.path(sp, vec![type_ident, variant.ident]);\n@@ -1512,15 +1525,15 @@ impl<'a> TraitDef<'a> {\n         cx: &mut ExtCtxt<'_>,\n         struct_def: &'a VariantData,\n         prefixes: &[String],\n-        no_deref: bool,\n+        addr_of: bool,\n     ) -> Vec<FieldInfo> {\n         self.create_fields(struct_def, |i, _struct_field, sp| {\n             prefixes\n                 .iter()\n                 .map(|prefix| {\n                     let ident = self.mk_pattern_ident(prefix, i);\n                     let expr = cx.expr_path(cx.path_ident(sp, ident));\n-                    if no_deref { expr } else { cx.expr_deref(sp, expr) }\n+                    if addr_of { cx.expr_addr_of(sp, expr) } else { expr }\n                 })\n                 .collect()\n         })\n@@ -1536,17 +1549,20 @@ impl<'a> TraitDef<'a> {\n             selflike_args\n                 .iter()\n                 .map(|selflike_arg| {\n-                    // Note: we must use `struct_field.span` rather than `span` in the\n+                    // Note: we must use `struct_field.span` rather than `sp` in the\n                     // `unwrap_or_else` case otherwise the hygiene is wrong and we get\n                     // \"field `0` of struct `Point` is private\" errors on tuple\n                     // structs.\n-                    cx.expr(\n+                    cx.expr_addr_of(\n                         sp,\n-                        ast::ExprKind::Field(\n-                            selflike_arg.clone(),\n-                            struct_field.ident.unwrap_or_else(|| {\n-                                Ident::from_str_and_span(&i.to_string(), struct_field.span)\n-                            }),\n+                        cx.expr(\n+                            sp,\n+                            ast::ExprKind::Field(\n+                                selflike_arg.clone(),\n+                                struct_field.ident.unwrap_or_else(|| {\n+                                    Ident::from_str_and_span(&i.to_string(), struct_field.span)\n+                                }),\n+                            ),\n                         ),\n                     )\n                 })"}, {"sha": "52239eff5da5714e857c5e514b1395b92295dcb9", "filename": "compiler/rustc_builtin_macros/src/deriving/hash.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/96f09d73cd6ffc4a4e2719819e205b6e5a26718f/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96f09d73cd6ffc4a4e2719819e205b6e5a26718f/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fhash.rs?ref=96f09d73cd6ffc4a4e2719819e205b6e5a26718f", "patch": "@@ -52,26 +52,28 @@ fn hash_substructure(\n     let [state_expr] = substr.nonselflike_args else {\n         cx.span_bug(trait_span, \"incorrect number of arguments in `derive(Hash)`\");\n     };\n-    let call_hash = |span, thing_expr| {\n+    let call_hash = |span, expr| {\n         let hash_path = {\n             let strs = cx.std_path(&[sym::hash, sym::Hash, sym::hash]);\n \n             cx.expr_path(cx.path_global(span, strs))\n         };\n-        let ref_thing = cx.expr_addr_of(span, thing_expr);\n-        let expr = cx.expr_call(span, hash_path, vec![ref_thing, state_expr.clone()]);\n+        let expr = cx.expr_call(span, hash_path, vec![expr, state_expr.clone()]);\n         cx.stmt_expr(expr)\n     };\n     let mut stmts = Vec::new();\n \n     let fields = match substr.fields {\n         Struct(_, fs) | EnumMatching(_, 1, .., fs) => fs,\n         EnumMatching(.., fs) => {\n-            let variant_value = deriving::call_intrinsic(\n-                cx,\n+            let variant_value = cx.expr_addr_of(\n                 trait_span,\n-                sym::discriminant_value,\n-                vec![cx.expr_self(trait_span)],\n+                deriving::call_intrinsic(\n+                    cx,\n+                    trait_span,\n+                    sym::discriminant_value,\n+                    vec![cx.expr_self(trait_span)],\n+                ),\n             );\n \n             stmts.push(call_hash(trait_span, variant_value));"}, {"sha": "0b88d68fce8afb615826a525517c505933625a5d", "filename": "src/test/ui/deriving/deriving-all-codegen.stdout", "status": "modified", "additions": 37, "deletions": 42, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/96f09d73cd6ffc4a4e2719819e205b6e5a26718f/src%2Ftest%2Fui%2Fderiving%2Fderiving-all-codegen.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/96f09d73cd6ffc4a4e2719819e205b6e5a26718f/src%2Ftest%2Fui%2Fderiving%2Fderiving-all-codegen.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderiving%2Fderiving-all-codegen.stdout?ref=96f09d73cd6ffc4a4e2719819e205b6e5a26718f", "patch": "@@ -525,7 +525,7 @@ impl ::core::clone::Clone for PackedNonCopy {\n     #[inline]\n     fn clone(&self) -> PackedNonCopy {\n         let Self(ref __self_0_0) = *self;\n-        PackedNonCopy(::core::clone::Clone::clone(&*__self_0_0))\n+        PackedNonCopy(::core::clone::Clone::clone(__self_0_0))\n     }\n }\n #[automatically_derived]\n@@ -534,7 +534,7 @@ impl ::core::fmt::Debug for PackedNonCopy {\n     fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {\n         let Self(ref __self_0_0) = *self;\n         ::core::fmt::Formatter::debug_tuple_field1_finish(f, \"PackedNonCopy\",\n-            &&*__self_0_0)\n+            &__self_0_0)\n     }\n }\n #[automatically_derived]\n@@ -550,7 +550,7 @@ impl ::core::default::Default for PackedNonCopy {\n impl ::core::hash::Hash for PackedNonCopy {\n     fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {\n         let Self(ref __self_0_0) = *self;\n-        ::core::hash::Hash::hash(&*__self_0_0, state)\n+        ::core::hash::Hash::hash(__self_0_0, state)\n     }\n }\n impl ::core::marker::StructuralPartialEq for PackedNonCopy {}\n@@ -589,7 +589,7 @@ impl ::core::cmp::PartialOrd for PackedNonCopy {\n         -> ::core::option::Option<::core::cmp::Ordering> {\n         let Self(ref __self_0_0) = *self;\n         let Self(ref __self_1_0) = *other;\n-        ::core::cmp::PartialOrd::partial_cmp(&*__self_0_0, &*__self_1_0)\n+        ::core::cmp::PartialOrd::partial_cmp(__self_0_0, __self_1_0)\n     }\n }\n #[automatically_derived]\n@@ -599,7 +599,7 @@ impl ::core::cmp::Ord for PackedNonCopy {\n     fn cmp(&self, other: &PackedNonCopy) -> ::core::cmp::Ordering {\n         let Self(ref __self_0_0) = *self;\n         let Self(ref __self_1_0) = *other;\n-        ::core::cmp::Ord::cmp(&*__self_0_0, &*__self_1_0)\n+        ::core::cmp::Ord::cmp(__self_0_0, __self_1_0)\n     }\n }\n \n@@ -677,7 +677,7 @@ impl ::core::clone::Clone for Enum1 {\n     fn clone(&self) -> Enum1 {\n         match self {\n             Enum1::Single { x: __self_0 } =>\n-                Enum1::Single { x: ::core::clone::Clone::clone(&*__self_0) },\n+                Enum1::Single { x: ::core::clone::Clone::clone(__self_0) },\n         }\n     }\n }\n@@ -688,7 +688,7 @@ impl ::core::fmt::Debug for Enum1 {\n         match self {\n             Enum1::Single { x: __self_0 } =>\n                 ::core::fmt::Formatter::debug_struct_field1_finish(f,\n-                    \"Single\", \"x\", &&*__self_0),\n+                    \"Single\", \"x\", &__self_0),\n         }\n     }\n }\n@@ -698,7 +698,7 @@ impl ::core::hash::Hash for Enum1 {\n     fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {\n         match self {\n             Enum1::Single { x: __self_0 } => {\n-                ::core::hash::Hash::hash(&*__self_0, state)\n+                ::core::hash::Hash::hash(__self_0, state)\n             }\n         }\n     }\n@@ -741,7 +741,7 @@ impl ::core::cmp::PartialOrd for Enum1 {\n         -> ::core::option::Option<::core::cmp::Ordering> {\n         match (self, other) {\n             (Enum1::Single { x: __self_0 }, Enum1::Single { x: __arg_1_0 }) =>\n-                ::core::cmp::PartialOrd::partial_cmp(&*__self_0, &*__arg_1_0),\n+                ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg_1_0),\n         }\n     }\n }\n@@ -752,7 +752,7 @@ impl ::core::cmp::Ord for Enum1 {\n     fn cmp(&self, other: &Enum1) -> ::core::cmp::Ordering {\n         match (self, other) {\n             (Enum1::Single { x: __self_0 }, Enum1::Single { x: __arg_1_0 }) =>\n-                ::core::cmp::Ord::cmp(&*__self_0, &*__arg_1_0),\n+                ::core::cmp::Ord::cmp(__self_0, __arg_1_0),\n         }\n     }\n }\n@@ -963,10 +963,10 @@ impl ::core::fmt::Debug for Mixed {\n             Mixed::Q => ::core::fmt::Formatter::write_str(f, \"Q\"),\n             Mixed::R(__self_0) =>\n                 ::core::fmt::Formatter::debug_tuple_field1_finish(f, \"R\",\n-                    &&*__self_0),\n+                    &__self_0),\n             Mixed::S { d1: __self_0, d2: __self_1 } =>\n                 ::core::fmt::Formatter::debug_struct_field2_finish(f, \"S\",\n-                    \"d1\", &&*__self_0, \"d2\", &&*__self_1),\n+                    \"d1\", &__self_0, \"d2\", &__self_1),\n         }\n     }\n }\n@@ -984,13 +984,13 @@ impl ::core::hash::Hash for Mixed {\n             Mixed::R(__self_0) => {\n                 ::core::hash::Hash::hash(&::core::intrinsics::discriminant_value(self),\n                     state);\n-                ::core::hash::Hash::hash(&*__self_0, state)\n+                ::core::hash::Hash::hash(__self_0, state)\n             }\n             Mixed::S { d1: __self_0, d2: __self_1 } => {\n                 ::core::hash::Hash::hash(&::core::intrinsics::discriminant_value(self),\n                     state);\n-                ::core::hash::Hash::hash(&*__self_0, state);\n-                ::core::hash::Hash::hash(&*__self_1, state)\n+                ::core::hash::Hash::hash(__self_0, state);\n+                ::core::hash::Hash::hash(__self_1, state)\n             }\n             _ => {\n                 ::core::hash::Hash::hash(&::core::intrinsics::discriminant_value(self),\n@@ -1056,16 +1056,14 @@ impl ::core::cmp::PartialOrd for Mixed {\n         if __self_vi == __arg_1_vi {\n                 match (self, other) {\n                     (Mixed::R(__self_0), Mixed::R(__arg_1_0)) =>\n-                        ::core::cmp::PartialOrd::partial_cmp(&*__self_0,\n-                            &*__arg_1_0),\n+                        ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg_1_0),\n                     (Mixed::S { d1: __self_0, d2: __self_1 }, Mixed::S {\n                         d1: __arg_1_0, d2: __arg_1_1 }) =>\n-                        match ::core::cmp::PartialOrd::partial_cmp(&*__self_0,\n-                                &*__arg_1_0) {\n+                        match ::core::cmp::PartialOrd::partial_cmp(__self_0,\n+                                __arg_1_0) {\n                             ::core::option::Option::Some(::core::cmp::Ordering::Equal)\n                                 =>\n-                                ::core::cmp::PartialOrd::partial_cmp(&*__self_1,\n-                                    &*__arg_1_1),\n+                                ::core::cmp::PartialOrd::partial_cmp(__self_1, __arg_1_1),\n                             cmp => cmp,\n                         },\n                     _ =>\n@@ -1086,12 +1084,12 @@ impl ::core::cmp::Ord for Mixed {\n         if __self_vi == __arg_1_vi {\n                 match (self, other) {\n                     (Mixed::R(__self_0), Mixed::R(__arg_1_0)) =>\n-                        ::core::cmp::Ord::cmp(&*__self_0, &*__arg_1_0),\n+                        ::core::cmp::Ord::cmp(__self_0, __arg_1_0),\n                     (Mixed::S { d1: __self_0, d2: __self_1 }, Mixed::S {\n                         d1: __arg_1_0, d2: __arg_1_1 }) =>\n-                        match ::core::cmp::Ord::cmp(&*__self_0, &*__arg_1_0) {\n+                        match ::core::cmp::Ord::cmp(__self_0, __arg_1_0) {\n                             ::core::cmp::Ordering::Equal =>\n-                                ::core::cmp::Ord::cmp(&*__self_1, &*__arg_1_1),\n+                                ::core::cmp::Ord::cmp(__self_1, __arg_1_1),\n                             cmp => cmp,\n                         },\n                     _ => ::core::cmp::Ordering::Equal,\n@@ -1110,11 +1108,11 @@ impl ::core::clone::Clone for Fielded {\n     fn clone(&self) -> Fielded {\n         match self {\n             Fielded::X(__self_0) =>\n-                Fielded::X(::core::clone::Clone::clone(&*__self_0)),\n+                Fielded::X(::core::clone::Clone::clone(__self_0)),\n             Fielded::Y(__self_0) =>\n-                Fielded::Y(::core::clone::Clone::clone(&*__self_0)),\n+                Fielded::Y(::core::clone::Clone::clone(__self_0)),\n             Fielded::Z(__self_0) =>\n-                Fielded::Z(::core::clone::Clone::clone(&*__self_0)),\n+                Fielded::Z(::core::clone::Clone::clone(__self_0)),\n         }\n     }\n }\n@@ -1125,13 +1123,13 @@ impl ::core::fmt::Debug for Fielded {\n         match self {\n             Fielded::X(__self_0) =>\n                 ::core::fmt::Formatter::debug_tuple_field1_finish(f, \"X\",\n-                    &&*__self_0),\n+                    &__self_0),\n             Fielded::Y(__self_0) =>\n                 ::core::fmt::Formatter::debug_tuple_field1_finish(f, \"Y\",\n-                    &&*__self_0),\n+                    &__self_0),\n             Fielded::Z(__self_0) =>\n                 ::core::fmt::Formatter::debug_tuple_field1_finish(f, \"Z\",\n-                    &&*__self_0),\n+                    &__self_0),\n         }\n     }\n }\n@@ -1143,17 +1141,17 @@ impl ::core::hash::Hash for Fielded {\n             Fielded::X(__self_0) => {\n                 ::core::hash::Hash::hash(&::core::intrinsics::discriminant_value(self),\n                     state);\n-                ::core::hash::Hash::hash(&*__self_0, state)\n+                ::core::hash::Hash::hash(__self_0, state)\n             }\n             Fielded::Y(__self_0) => {\n                 ::core::hash::Hash::hash(&::core::intrinsics::discriminant_value(self),\n                     state);\n-                ::core::hash::Hash::hash(&*__self_0, state)\n+                ::core::hash::Hash::hash(__self_0, state)\n             }\n             Fielded::Z(__self_0) => {\n                 ::core::hash::Hash::hash(&::core::intrinsics::discriminant_value(self),\n                     state);\n-                ::core::hash::Hash::hash(&*__self_0, state)\n+                ::core::hash::Hash::hash(__self_0, state)\n             }\n         }\n     }\n@@ -1219,14 +1217,11 @@ impl ::core::cmp::PartialOrd for Fielded {\n         if __self_vi == __arg_1_vi {\n                 match (self, other) {\n                     (Fielded::X(__self_0), Fielded::X(__arg_1_0)) =>\n-                        ::core::cmp::PartialOrd::partial_cmp(&*__self_0,\n-                            &*__arg_1_0),\n+                        ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg_1_0),\n                     (Fielded::Y(__self_0), Fielded::Y(__arg_1_0)) =>\n-                        ::core::cmp::PartialOrd::partial_cmp(&*__self_0,\n-                            &*__arg_1_0),\n+                        ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg_1_0),\n                     (Fielded::Z(__self_0), Fielded::Z(__arg_1_0)) =>\n-                        ::core::cmp::PartialOrd::partial_cmp(&*__self_0,\n-                            &*__arg_1_0),\n+                        ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg_1_0),\n                     _ => unsafe { ::core::intrinsics::unreachable() }\n                 }\n             } else {\n@@ -1244,11 +1239,11 @@ impl ::core::cmp::Ord for Fielded {\n         if __self_vi == __arg_1_vi {\n                 match (self, other) {\n                     (Fielded::X(__self_0), Fielded::X(__arg_1_0)) =>\n-                        ::core::cmp::Ord::cmp(&*__self_0, &*__arg_1_0),\n+                        ::core::cmp::Ord::cmp(__self_0, __arg_1_0),\n                     (Fielded::Y(__self_0), Fielded::Y(__arg_1_0)) =>\n-                        ::core::cmp::Ord::cmp(&*__self_0, &*__arg_1_0),\n+                        ::core::cmp::Ord::cmp(__self_0, __arg_1_0),\n                     (Fielded::Z(__self_0), Fielded::Z(__arg_1_0)) =>\n-                        ::core::cmp::Ord::cmp(&*__self_0, &*__arg_1_0),\n+                        ::core::cmp::Ord::cmp(__self_0, __arg_1_0),\n                     _ => unsafe { ::core::intrinsics::unreachable() }\n                 }\n             } else { ::core::cmp::Ord::cmp(&__self_vi, &__arg_1_vi) }"}]}