{"sha": "7eb444e4f18d50e48868861010b3d87d741d1218", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdlYjQ0NGU0ZjE4ZDUwZTQ4ODY4ODYxMDEwYjNkODdkNzQxZDEyMTg=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2019-01-01T21:53:52Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2019-01-03T23:18:34Z"}, "message": "Revert \"add coherence future-compat warnings for marker-only trait objects\"\n\nThis reverts commit 760639635facb6c9a0926ac9278bcba71880b0b3.", "tree": {"sha": "238ac32eb0f5e7644ca63dd0b957c5f330d71bcc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/238ac32eb0f5e7644ca63dd0b957c5f330d71bcc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7eb444e4f18d50e48868861010b3d87d741d1218", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7eb444e4f18d50e48868861010b3d87d741d1218", "html_url": "https://github.com/rust-lang/rust/commit/7eb444e4f18d50e48868861010b3d87d741d1218", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7eb444e4f18d50e48868861010b3d87d741d1218/comments", "author": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e030aa801583ec7ce250088bb180d65b760eedec", "url": "https://api.github.com/repos/rust-lang/rust/commits/e030aa801583ec7ce250088bb180d65b760eedec", "html_url": "https://github.com/rust-lang/rust/commit/e030aa801583ec7ce250088bb180d65b760eedec"}], "stats": {"total": 308, "additions": 54, "deletions": 254}, "files": [{"sha": "40c11695d51e2f67618544b4a1cd47cd871ef39e", "filename": "src/librustc/infer/combine.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7eb444e4f18d50e48868861010b3d87d741d1218/src%2Flibrustc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7eb444e4f18d50e48868861010b3d87d741d1218/src%2Flibrustc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcombine.rs?ref=7eb444e4f18d50e48868861010b3d87d741d1218", "patch": "@@ -337,10 +337,6 @@ impl<'cx, 'gcx, 'tcx> TypeRelation<'cx, 'gcx, 'tcx> for Generalizer<'cx, 'gcx, '\n         self.infcx.tcx\n     }\n \n-    fn trait_object_mode(&self) -> relate::TraitObjectMode {\n-        self.infcx.trait_object_mode()\n-    }\n-\n     fn tag(&self) -> &'static str {\n         \"Generalizer\"\n     }"}, {"sha": "60a7eb0d54f8bf7a4ed7c4e3bcab3caaf2eadd72", "filename": "src/librustc/infer/equate.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7eb444e4f18d50e48868861010b3d87d741d1218/src%2Flibrustc%2Finfer%2Fequate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7eb444e4f18d50e48868861010b3d87d741d1218/src%2Flibrustc%2Finfer%2Fequate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fequate.rs?ref=7eb444e4f18d50e48868861010b3d87d741d1218", "patch": "@@ -29,10 +29,6 @@ impl<'combine, 'infcx, 'gcx, 'tcx> TypeRelation<'infcx, 'gcx, 'tcx>\n \n     fn tcx(&self) -> TyCtxt<'infcx, 'gcx, 'tcx> { self.fields.tcx() }\n \n-    fn trait_object_mode(&self) -> relate::TraitObjectMode {\n-        self.fields.infcx.trait_object_mode()\n-    }\n-\n     fn a_is_expected(&self) -> bool { self.a_is_expected }\n \n     fn relate_item_substs(&mut self,"}, {"sha": "635a6d00270b7f3ce979c13529122e1159ebff68", "filename": "src/librustc/infer/glb.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7eb444e4f18d50e48868861010b3d87d741d1218/src%2Flibrustc%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7eb444e4f18d50e48868861010b3d87d741d1218/src%2Flibrustc%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fglb.rs?ref=7eb444e4f18d50e48868861010b3d87d741d1218", "patch": "@@ -5,7 +5,7 @@ use super::Subtype;\n \n use traits::ObligationCause;\n use ty::{self, Ty, TyCtxt};\n-use ty::relate::{self, Relate, RelateResult, TypeRelation};\n+use ty::relate::{Relate, RelateResult, TypeRelation};\n \n /// \"Greatest lower bound\" (common subtype)\n pub struct Glb<'combine, 'infcx: 'combine, 'gcx: 'infcx+'tcx, 'tcx: 'infcx> {\n@@ -26,10 +26,6 @@ impl<'combine, 'infcx, 'gcx, 'tcx> TypeRelation<'infcx, 'gcx, 'tcx>\n {\n     fn tag(&self) -> &'static str { \"Glb\" }\n \n-    fn trait_object_mode(&self) -> relate::TraitObjectMode {\n-        self.fields.infcx.trait_object_mode()\n-    }\n-\n     fn tcx(&self) -> TyCtxt<'infcx, 'gcx, 'tcx> { self.fields.tcx() }\n \n     fn a_is_expected(&self) -> bool { self.a_is_expected }"}, {"sha": "0b9839f69fa2ad1d86cbf773b1528f37201d5cd0", "filename": "src/librustc/infer/lub.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7eb444e4f18d50e48868861010b3d87d741d1218/src%2Flibrustc%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7eb444e4f18d50e48868861010b3d87d741d1218/src%2Flibrustc%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flub.rs?ref=7eb444e4f18d50e48868861010b3d87d741d1218", "patch": "@@ -5,7 +5,7 @@ use super::Subtype;\n \n use traits::ObligationCause;\n use ty::{self, Ty, TyCtxt};\n-use ty::relate::{self, Relate, RelateResult, TypeRelation};\n+use ty::relate::{Relate, RelateResult, TypeRelation};\n \n /// \"Least upper bound\" (common supertype)\n pub struct Lub<'combine, 'infcx: 'combine, 'gcx: 'infcx+'tcx, 'tcx: 'infcx> {\n@@ -26,10 +26,6 @@ impl<'combine, 'infcx, 'gcx, 'tcx> TypeRelation<'infcx, 'gcx, 'tcx>\n {\n     fn tag(&self) -> &'static str { \"Lub\" }\n \n-    fn trait_object_mode(&self) -> relate::TraitObjectMode {\n-        self.fields.infcx.trait_object_mode()\n-    }\n-\n     fn tcx(&self) -> TyCtxt<'infcx, 'gcx, 'tcx> { self.fields.tcx() }\n \n     fn a_is_expected(&self) -> bool { self.a_is_expected }"}, {"sha": "958982545750fb3b34abac5d9f74a7c133bbdbb1", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 1, "deletions": 18, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/7eb444e4f18d50e48868861010b3d87d741d1218/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7eb444e4f18d50e48868861010b3d87d741d1218/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=7eb444e4f18d50e48868861010b3d87d741d1218", "patch": "@@ -25,7 +25,7 @@ use syntax_pos::{self, Span};\n use traits::{self, ObligationCause, PredicateObligations, TraitEngine};\n use ty::error::{ExpectedFound, TypeError, UnconstrainedNumeric};\n use ty::fold::TypeFoldable;\n-use ty::relate::{RelateResult, TraitObjectMode};\n+use ty::relate::RelateResult;\n use ty::subst::{Kind, Substs};\n use ty::{self, GenericParamDefKind, Ty, TyCtxt, CtxtInterners};\n use ty::{FloatVid, IntVid, TyVid};\n@@ -171,9 +171,6 @@ pub struct InferCtxt<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     // This flag is true while there is an active snapshot.\n     in_snapshot: Cell<bool>,\n \n-    // The TraitObjectMode used here,\n-    trait_object_mode: TraitObjectMode,\n-\n     // A set of constraints that regionck must validate. Each\n     // constraint has the form `T:'a`, meaning \"some type `T` must\n     // outlive the lifetime 'a\". These constraints derive from\n@@ -465,7 +462,6 @@ pub struct InferCtxtBuilder<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     arena: SyncDroplessArena,\n     interners: Option<CtxtInterners<'tcx>>,\n     fresh_tables: Option<RefCell<ty::TypeckTables<'tcx>>>,\n-    trait_object_mode: TraitObjectMode,\n }\n \n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'gcx> {\n@@ -475,7 +471,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'gcx> {\n             arena: SyncDroplessArena::default(),\n             interners: None,\n             fresh_tables: None,\n-            trait_object_mode: TraitObjectMode::NoSquash,\n         }\n     }\n }\n@@ -488,12 +483,6 @@ impl<'a, 'gcx, 'tcx> InferCtxtBuilder<'a, 'gcx, 'tcx> {\n         self\n     }\n \n-    pub fn with_trait_object_mode(mut self, mode: TraitObjectMode) -> Self {\n-        debug!(\"with_trait_object_mode: setting mode to {:?}\", mode);\n-        self.trait_object_mode = mode;\n-        self\n-    }\n-\n     /// Given a canonical value `C` as a starting point, create an\n     /// inference context that contains each of the bound values\n     /// within instantiated as a fresh variable. The `f` closure is\n@@ -520,7 +509,6 @@ impl<'a, 'gcx, 'tcx> InferCtxtBuilder<'a, 'gcx, 'tcx> {\n     pub fn enter<R>(&'tcx mut self, f: impl for<'b> FnOnce(InferCtxt<'b, 'gcx, 'tcx>) -> R) -> R {\n         let InferCtxtBuilder {\n             global_tcx,\n-            trait_object_mode,\n             ref arena,\n             ref mut interners,\n             ref fresh_tables,\n@@ -532,7 +520,6 @@ impl<'a, 'gcx, 'tcx> InferCtxtBuilder<'a, 'gcx, 'tcx> {\n             f(InferCtxt {\n                 tcx,\n                 in_progress_tables,\n-                trait_object_mode,\n                 projection_cache: Default::default(),\n                 type_variables: RefCell::new(type_variable::TypeVariableTable::new()),\n                 int_unification_table: RefCell::new(ut::UnificationTable::new()),\n@@ -614,10 +601,6 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         self.in_snapshot.get()\n     }\n \n-    pub fn trait_object_mode(&self) -> TraitObjectMode {\n-        self.trait_object_mode\n-    }\n-\n     pub fn freshen<T: TypeFoldable<'tcx>>(&self, t: T) -> T {\n         t.fold_with(&mut self.freshener())\n     }"}, {"sha": "7671a47135702d9ef74cc98eaae9a4cb3ee23059", "filename": "src/librustc/infer/nll_relate/mod.rs", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7eb444e4f18d50e48868861010b3d87d741d1218/src%2Flibrustc%2Finfer%2Fnll_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7eb444e4f18d50e48868861010b3d87d741d1218/src%2Flibrustc%2Finfer%2Fnll_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fnll_relate%2Fmod.rs?ref=7eb444e4f18d50e48868861010b3d87d741d1218", "patch": "@@ -372,13 +372,6 @@ where\n         self.infcx.tcx\n     }\n \n-    fn trait_object_mode(&self) -> relate::TraitObjectMode {\n-        // squashing should only be done in coherence, not NLL\n-        assert_eq!(self.infcx.trait_object_mode(),\n-                   relate::TraitObjectMode::NoSquash);\n-        relate::TraitObjectMode::NoSquash\n-    }\n-\n     fn tag(&self) -> &'static str {\n         \"nll::subtype\"\n     }\n@@ -693,13 +686,6 @@ where\n         self.infcx.tcx\n     }\n \n-    fn trait_object_mode(&self) -> relate::TraitObjectMode {\n-        // squashing should only be done in coherence, not NLL\n-        assert_eq!(self.infcx.trait_object_mode(),\n-                   relate::TraitObjectMode::NoSquash);\n-        relate::TraitObjectMode::NoSquash\n-    }\n-\n     fn tag(&self) -> &'static str {\n         \"nll::generalizer\"\n     }"}, {"sha": "df76d1d3afb34bd1cf39b464b0fe06d4db13c9d8", "filename": "src/librustc/infer/sub.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7eb444e4f18d50e48868861010b3d87d741d1218/src%2Flibrustc%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7eb444e4f18d50e48868861010b3d87d741d1218/src%2Flibrustc%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fsub.rs?ref=7eb444e4f18d50e48868861010b3d87d741d1218", "patch": "@@ -5,7 +5,7 @@ use traits::Obligation;\n use ty::{self, Ty, TyCtxt};\n use ty::TyVar;\n use ty::fold::TypeFoldable;\n-use ty::relate::{self, Cause, Relate, RelateResult, TypeRelation};\n+use ty::relate::{Cause, Relate, RelateResult, TypeRelation};\n use std::mem;\n \n /// Ensures `a` is made a subtype of `b`. Returns `a` on success.\n@@ -33,10 +33,6 @@ impl<'combine, 'infcx, 'gcx, 'tcx> TypeRelation<'infcx, 'gcx, 'tcx>\n     for Sub<'combine, 'infcx, 'gcx, 'tcx>\n {\n     fn tag(&self) -> &'static str { \"Sub\" }\n-    fn trait_object_mode(&self) -> relate::TraitObjectMode {\n-        self.fields.infcx.trait_object_mode()\n-    }\n-\n     fn tcx(&self) -> TyCtxt<'infcx, 'gcx, 'tcx> { self.fields.infcx.tcx }\n     fn a_is_expected(&self) -> bool { self.a_is_expected }\n "}, {"sha": "54687bd76e59dac44b6d65c5c6722f91ed37a837", "filename": "src/librustc/traits/coherence.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7eb444e4f18d50e48868861010b3d87d741d1218/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7eb444e4f18d50e48868861010b3d87d741d1218/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fcoherence.rs?ref=7eb444e4f18d50e48868861010b3d87d741d1218", "patch": "@@ -11,7 +11,6 @@ use traits::{self, Normalized, SelectionContext, Obligation, ObligationCause};\n use traits::IntercrateMode;\n use traits::select::IntercrateAmbiguityCause;\n use ty::{self, Ty, TyCtxt};\n-use ty::relate::TraitObjectMode;\n use ty::fold::TypeFoldable;\n use ty::subst::Subst;\n \n@@ -55,7 +54,6 @@ pub fn overlapping_impls<'gcx, F1, F2, R>(\n     impl1_def_id: DefId,\n     impl2_def_id: DefId,\n     intercrate_mode: IntercrateMode,\n-    trait_object_mode: TraitObjectMode,\n     on_overlap: F1,\n     no_overlap: F2,\n ) -> R\n@@ -66,14 +64,12 @@ where\n     debug!(\"overlapping_impls(\\\n            impl1_def_id={:?}, \\\n            impl2_def_id={:?},\n-           intercrate_mode={:?},\n-           trait_object_mode={:?})\",\n+           intercrate_mode={:?})\",\n            impl1_def_id,\n            impl2_def_id,\n-           intercrate_mode,\n-           trait_object_mode);\n+           intercrate_mode);\n \n-    let overlaps = tcx.infer_ctxt().with_trait_object_mode(trait_object_mode).enter(|infcx| {\n+    let overlaps = tcx.infer_ctxt().enter(|infcx| {\n         let selcx = &mut SelectionContext::intercrate(&infcx, intercrate_mode);\n         overlap(selcx, impl1_def_id, impl2_def_id).is_some()\n     });\n@@ -85,7 +81,7 @@ where\n     // In the case where we detect an error, run the check again, but\n     // this time tracking intercrate ambuiguity causes for better\n     // diagnostics. (These take time and can lead to false errors.)\n-    tcx.infer_ctxt().with_trait_object_mode(trait_object_mode).enter(|infcx| {\n+    tcx.infer_ctxt().enter(|infcx| {\n         let selcx = &mut SelectionContext::intercrate(&infcx, intercrate_mode);\n         selcx.enable_tracking_intercrate_ambiguity_causes();\n         on_overlap(overlap(selcx, impl1_def_id, impl2_def_id).unwrap())"}, {"sha": "741053cc1773709fbea4551a8c2fe18efd3bcfda", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7eb444e4f18d50e48868861010b3d87d741d1218/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7eb444e4f18d50e48868861010b3d87d741d1218/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=7eb444e4f18d50e48868861010b3d87d741d1218", "patch": "@@ -449,7 +449,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     {\n         let simp = fast_reject::simplify_type(self.tcx,\n                                               trait_ref.skip_binder().self_ty(),\n-                                              true,);\n+                                              true);\n         let all_impls = self.tcx.all_impls(trait_ref.def_id());\n \n         match simp {"}, {"sha": "1a9f1ada111bd13e673f54d47c39db0868a245ec", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7eb444e4f18d50e48868861010b3d87d741d1218/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7eb444e4f18d50e48868861010b3d87d741d1218/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=7eb444e4f18d50e48868861010b3d87d741d1218", "patch": "@@ -56,8 +56,6 @@ pub use self::select::{EvaluationCache, SelectionContext, SelectionCache};\n pub use self::select::{EvaluationResult, IntercrateAmbiguityCause, OverflowError};\n pub use self::specialize::{OverlapError, specialization_graph, translate_substs};\n pub use self::specialize::find_associated_item;\n-pub use self::specialize::specialization_graph::FutureCompatOverlapError;\n-pub use self::specialize::specialization_graph::FutureCompatOverlapErrorKind;\n pub use self::engine::{TraitEngine, TraitEngineExt};\n pub use self::util::{elaborate_predicates, elaborate_trait_ref, elaborate_trait_refs};\n pub use self::util::{supertraits, supertrait_def_ids, transitive_bounds,"}, {"sha": "9ad974d8e084a19174f6f1c225734d9b1e737c54", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7eb444e4f18d50e48868861010b3d87d741d1218/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7eb444e4f18d50e48868861010b3d87d741d1218/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=7eb444e4f18d50e48868861010b3d87d741d1218", "patch": "@@ -33,7 +33,7 @@ use infer::{InferCtxt, InferOk, TypeFreshener};\n use middle::lang_items;\n use mir::interpret::GlobalId;\n use ty::fast_reject;\n-use ty::relate::{TypeRelation, TraitObjectMode};\n+use ty::relate::TypeRelation;\n use ty::subst::{Subst, Substs};\n use ty::{self, ToPolyTraitRef, ToPredicate, Ty, TyCtxt, TypeFoldable};\n \n@@ -1416,13 +1416,6 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             return false;\n         }\n \n-        // Same idea as the above, but for alt trait object modes. These\n-        // should only be used in intercrate mode - better safe than sorry.\n-        if self.infcx.trait_object_mode() != TraitObjectMode::NoSquash {\n-            bug!(\"using squashing TraitObjectMode outside of intercrate mode? param_env={:?}\",\n-                 param_env);\n-        }\n-\n         // Otherwise, we can use the global cache.\n         true\n     }\n@@ -3580,8 +3573,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         previous: &ty::PolyTraitRef<'tcx>,\n         current: &ty::PolyTraitRef<'tcx>,\n     ) -> bool {\n-        let mut matcher = ty::_match::Match::new(\n-            self.tcx(), self.infcx.trait_object_mode());\n+        let mut matcher = ty::_match::Match::new(self.tcx());\n         matcher.relate(previous, current).is_ok()\n     }\n "}, {"sha": "5ab54b2c99d42bd5d12b496cb19d709cb3ff8e29", "filename": "src/librustc/traits/specialize/mod.rs", "status": "modified", "additions": 6, "deletions": 14, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7eb444e4f18d50e48868861010b3d87d741d1218/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7eb444e4f18d50e48868861010b3d87d741d1218/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs?ref=7eb444e4f18d50e48868861010b3d87d741d1218", "patch": "@@ -14,11 +14,11 @@ pub mod specialization_graph;\n use hir::def_id::DefId;\n use infer::{InferCtxt, InferOk};\n use lint;\n-use traits::{self, FutureCompatOverlapErrorKind, ObligationCause, TraitEngine};\n use traits::coherence;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::sync::Lrc;\n use syntax_pos::DUMMY_SP;\n+use traits::{self, ObligationCause, TraitEngine};\n use traits::select::IntercrateAmbiguityCause;\n use ty::{self, TyCtxt, TypeFoldable};\n use ty::subst::{Subst, Substs};\n@@ -27,7 +27,6 @@ use super::{SelectionContext, FulfillmentContext};\n use super::util::impl_trait_ref_and_oblig;\n \n /// Information pertinent to an overlapping impl error.\n-#[derive(Debug)]\n pub struct OverlapError {\n     pub with_impl: DefId,\n     pub trait_desc: String,\n@@ -311,9 +310,8 @@ pub(super) fn specialization_graph_provider<'a, 'tcx>(\n             let insert_result = sg.insert(tcx, impl_def_id);\n             // Report error if there was one.\n             let (overlap, used_to_be_allowed) = match insert_result {\n-                Err(overlap) => (Some(overlap), None),\n-                Ok(Some(overlap)) => (Some(overlap.error), Some(overlap.kind)),\n-                Ok(None) => (None, None)\n+                Err(overlap) => (Some(overlap), false),\n+                Ok(opt_overlap) => (opt_overlap, true)\n             };\n \n             if let Some(overlap) = overlap {\n@@ -323,20 +321,14 @@ pub(super) fn specialization_graph_provider<'a, 'tcx>(\n                         String::new(), |ty| {\n                             format!(\" for type `{}`\", ty)\n                         }),\n-                    if used_to_be_allowed.is_some() { \" (E0119)\" } else { \"\" }\n+                    if used_to_be_allowed { \" (E0119)\" } else { \"\" }\n                 );\n                 let impl_span = tcx.sess.source_map().def_span(\n                     tcx.span_of_impl(impl_def_id).unwrap()\n                 );\n-                let mut err = if let Some(kind) = used_to_be_allowed {\n-                    let lint = match kind {\n-                        FutureCompatOverlapErrorKind::Issue43355 =>\n-                            lint::builtin::INCOHERENT_FUNDAMENTAL_IMPLS,\n-                        FutureCompatOverlapErrorKind::Issue33140 =>\n-                            lint::builtin::ORDER_DEPENDENT_TRAIT_OBJECTS,\n-                    };\n+                let mut err = if used_to_be_allowed {\n                     tcx.struct_span_lint_node(\n-                        lint,\n+                        lint::builtin::INCOHERENT_FUNDAMENTAL_IMPLS,\n                         tcx.hir().as_local_node_id(impl_def_id).unwrap(),\n                         impl_span,\n                         &msg)"}, {"sha": "c22adeb55a269d4371a9ea449b681ecefe6891e9", "filename": "src/librustc/traits/specialize/specialization_graph.rs", "status": "modified", "additions": 3, "deletions": 41, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/7eb444e4f18d50e48868861010b3d87d741d1218/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7eb444e4f18d50e48868861010b3d87d741d1218/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs?ref=7eb444e4f18d50e48868861010b3d87d741d1218", "patch": "@@ -7,7 +7,6 @@ use rustc_data_structures::stable_hasher::{HashStable, StableHasher,\n use traits;\n use ty::{self, TyCtxt, TypeFoldable};\n use ty::fast_reject::{self, SimplifiedType};\n-use ty::relate::TraitObjectMode;\n use rustc_data_structures::sync::Lrc;\n use syntax::ast::Ident;\n use util::captures::Captures;\n@@ -59,22 +58,10 @@ struct Children {\n     blanket_impls: Vec<DefId>,\n }\n \n-#[derive(Copy, Clone, Debug)]\n-pub enum FutureCompatOverlapErrorKind {\n-    Issue43355,\n-    Issue33140,\n-}\n-\n-#[derive(Debug)]\n-pub struct FutureCompatOverlapError {\n-    pub error: OverlapError,\n-    pub kind: FutureCompatOverlapErrorKind\n-}\n-\n /// The result of attempting to insert an impl into a group of children.\n enum Inserted {\n     /// The impl was inserted as a new child in this group of children.\n-    BecameNewSibling(Option<FutureCompatOverlapError>),\n+    BecameNewSibling(Option<OverlapError>),\n \n     /// The impl should replace existing impls [X1, ..], because the impl specializes X1, X2, etc.\n     ReplaceChildren(Vec<DefId>),\n@@ -174,7 +161,6 @@ impl<'a, 'gcx, 'tcx> Children {\n                 possible_sibling,\n                 impl_def_id,\n                 traits::IntercrateMode::Issue43355,\n-                TraitObjectMode::NoSquash,\n                 |overlap| {\n                     if tcx.impls_are_allowed_to_overlap(impl_def_id, possible_sibling) {\n                         return Ok((false, false));\n@@ -205,36 +191,12 @@ impl<'a, 'gcx, 'tcx> Children {\n                 replace_children.push(possible_sibling);\n             } else {\n                 if !tcx.impls_are_allowed_to_overlap(impl_def_id, possible_sibling) {\n-                    // do future-compat checks for overlap. Have issue #43355\n-                    // errors overwrite issue #33140 errors when both are present.\n-\n-                    traits::overlapping_impls(\n-                        tcx,\n-                        possible_sibling,\n-                        impl_def_id,\n-                        traits::IntercrateMode::Fixed,\n-                        TraitObjectMode::SquashAutoTraitsIssue33140,\n-                        |overlap| {\n-                            last_lint = Some(FutureCompatOverlapError {\n-                                error: overlap_error(overlap),\n-                                kind: FutureCompatOverlapErrorKind::Issue33140\n-                            });\n-                        },\n-                        || (),\n-                    );\n-\n                     traits::overlapping_impls(\n                         tcx,\n                         possible_sibling,\n                         impl_def_id,\n                         traits::IntercrateMode::Fixed,\n-                        TraitObjectMode::NoSquash,\n-                        |overlap| {\n-                            last_lint = Some(FutureCompatOverlapError {\n-                                error: overlap_error(overlap),\n-                                kind: FutureCompatOverlapErrorKind::Issue43355\n-                            });\n-                        },\n+                        |overlap| last_lint = Some(overlap_error(overlap)),\n                         || (),\n                     );\n                 }\n@@ -301,7 +263,7 @@ impl<'a, 'gcx, 'tcx> Graph {\n     pub fn insert(&mut self,\n                   tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                   impl_def_id: DefId)\n-                  -> Result<Option<FutureCompatOverlapError>, OverlapError> {\n+                  -> Result<Option<OverlapError>, OverlapError> {\n         assert!(impl_def_id.is_local());\n \n         let trait_ref = tcx.impl_trait_ref(impl_def_id).unwrap();"}, {"sha": "34b94d4217d8b0889e459d6259aa1950d0471681", "filename": "src/librustc/ty/_match.rs", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7eb444e4f18d50e48868861010b3d87d741d1218/src%2Flibrustc%2Fty%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7eb444e4f18d50e48868861010b3d87d741d1218/src%2Flibrustc%2Fty%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2F_match.rs?ref=7eb444e4f18d50e48868861010b3d87d741d1218", "patch": "@@ -19,24 +19,17 @@ use ty::relate::{self, Relate, TypeRelation, RelateResult};\n /// important thing about the result is Ok/Err. Also, matching never\n /// affects any type variables or unification state.\n pub struct Match<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-    trait_object_mode: relate::TraitObjectMode\n+    tcx: TyCtxt<'a, 'gcx, 'tcx>\n }\n \n impl<'a, 'gcx, 'tcx> Match<'a, 'gcx, 'tcx> {\n-    pub fn new(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-               trait_object_mode: relate::TraitObjectMode)\n-               -> Match<'a, 'gcx, 'tcx> {\n-        Match { tcx, trait_object_mode }\n+    pub fn new(tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Match<'a, 'gcx, 'tcx> {\n+        Match { tcx }\n     }\n }\n \n impl<'a, 'gcx, 'tcx> TypeRelation<'a, 'gcx, 'tcx> for Match<'a, 'gcx, 'tcx> {\n     fn tag(&self) -> &'static str { \"Match\" }\n-    fn trait_object_mode(&self) -> relate::TraitObjectMode {\n-        self.trait_object_mode\n-    }\n-\n     fn tcx(&self) -> TyCtxt<'a, 'gcx, 'tcx> { self.tcx }\n     fn a_is_expected(&self) -> bool { true } // irrelevant\n "}, {"sha": "43ec90eb95becd85b109f0b3c80549ceddafdc8c", "filename": "src/librustc/ty/relate.rs", "status": "modified", "additions": 4, "deletions": 45, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/7eb444e4f18d50e48868861010b3d87d741d1218/src%2Flibrustc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7eb444e4f18d50e48868861010b3d87d741d1218/src%2Flibrustc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Frelate.rs?ref=7eb444e4f18d50e48868861010b3d87d741d1218", "patch": "@@ -25,20 +25,9 @@ pub enum Cause {\n     ExistentialRegionBound, // relating an existential region bound\n }\n \n-#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n-pub enum TraitObjectMode {\n-    NoSquash,\n-    /// A temporary mode to treat `Send + Sync = Sync + Send`, should be\n-    /// used only in coherence.\n-    SquashAutoTraitsIssue33140\n-}\n-\n pub trait TypeRelation<'a, 'gcx: 'a+'tcx, 'tcx: 'a> : Sized {\n     fn tcx(&self) -> TyCtxt<'a, 'gcx, 'tcx>;\n \n-    /// Return the trait object mode to be used.\n-    fn trait_object_mode(&self) -> TraitObjectMode;\n-\n     /// Returns a static string we can use for printouts.\n     fn tag(&self) -> &'static str;\n \n@@ -597,44 +586,14 @@ impl<'tcx> Relate<'tcx> for &'tcx ty::List<ty::ExistentialPredicate<'tcx>> {\n                            a: &Self,\n                            b: &Self)\n         -> RelateResult<'tcx, Self>\n-        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a {\n-        use ty::ExistentialPredicate::*;\n+            where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a {\n \n-        let tcx = relation.tcx();\n-        let (a_buf, b_buf);\n-        let (a_norm, b_norm): (&[_], &[_]) = match relation.trait_object_mode() {\n-            TraitObjectMode::NoSquash => {\n-                (a, b)\n-            }\n-            TraitObjectMode::SquashAutoTraitsIssue33140 => {\n-                // Treat auto-trait \"principal\" components as equal\n-                // to the non-principal components, to make\n-                // `dyn Send+Sync = dyn Sync+Send`.\n-                let normalize = |d: &[ty::ExistentialPredicate<'tcx>]| {\n-                    let mut result: Vec<_> = d.iter().map(|pi| match pi {\n-                        Trait(ref a) if tcx.trait_is_auto(a.def_id) => {\n-                            AutoTrait(a.def_id)\n-                        },\n-                        other => *other\n-                    }).collect();\n-\n-                    result.sort_by(|a, b| a.stable_cmp(tcx, b));\n-                    result.dedup();\n-                    result\n-                };\n-\n-                a_buf = normalize(a);\n-                b_buf = normalize(b);\n-\n-                (&a_buf, &b_buf)\n-            }\n-        };\n-\n-        if a_norm.len() != b_norm.len() {\n+        if a.len() != b.len() {\n             return Err(TypeError::ExistentialMismatch(expected_found(relation, a, b)));\n         }\n \n-        let v = a_norm.iter().zip(b_norm.iter()).map(|(ep_a, ep_b)| {\n+        let tcx = relation.tcx();\n+        let v = a.iter().zip(b.iter()).map(|(ep_a, ep_b)| {\n             use ty::ExistentialPredicate::*;\n             match (*ep_a, *ep_b) {\n                 (Trait(ref a), Trait(ref b)) => Ok(Trait(relation.relate(a, b)?)),"}, {"sha": "932501cc04fe0dd8c4fa471042023fcb2d0af705", "filename": "src/librustc_traits/chalk_context/resolvent_ops.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7eb444e4f18d50e48868861010b3d87d741d1218/src%2Flibrustc_traits%2Fchalk_context%2Fresolvent_ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7eb444e4f18d50e48868861010b3d87d741d1218/src%2Flibrustc_traits%2Fchalk_context%2Fresolvent_ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk_context%2Fresolvent_ops.rs?ref=7eb444e4f18d50e48868861010b3d87d741d1218", "patch": "@@ -17,7 +17,7 @@ use rustc::traits::{\n };\n use rustc::ty::{self, Ty};\n use rustc::ty::subst::Kind;\n-use rustc::ty::relate::{self, Relate, RelateResult, TypeRelation};\n+use rustc::ty::relate::{Relate, RelateResult, TypeRelation};\n use syntax_pos::DUMMY_SP;\n \n use super::{ChalkInferenceContext, ChalkArenas, ChalkExClause, ConstrainedSubst};\n@@ -157,10 +157,6 @@ impl TypeRelation<'cx, 'gcx, 'tcx> for AnswerSubstitutor<'cx, 'gcx, 'tcx> {\n         self.infcx.tcx\n     }\n \n-    fn trait_object_mode(&self) -> relate::TraitObjectMode {\n-        self.infcx.trait_object_mode()\n-    }\n-\n     fn tag(&self) -> &'static str {\n         \"chalk_context::answer_substitutor\"\n     }"}, {"sha": "52dee29294cb72c35d9f8385fd23c2ab04fbd273", "filename": "src/librustc_typeck/coherence/inherent_impls_overlap.rs", "status": "modified", "additions": 26, "deletions": 63, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/7eb444e4f18d50e48868861010b3d87d741d1218/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7eb444e4f18d50e48868861010b3d87d741d1218/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs?ref=7eb444e4f18d50e48868861010b3d87d741d1218", "patch": "@@ -2,9 +2,8 @@ use namespace::Namespace;\n use rustc::hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n use rustc::hir;\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n-use rustc::traits::{self, IntercrateMode, FutureCompatOverlapErrorKind};\n+use rustc::traits::{self, IntercrateMode};\n use rustc::ty::TyCtxt;\n-use rustc::ty::relate::TraitObjectMode;\n \n use lint;\n \n@@ -20,11 +19,9 @@ struct InherentOverlapChecker<'a, 'tcx: 'a> {\n }\n \n impl<'a, 'tcx> InherentOverlapChecker<'a, 'tcx> {\n-    fn check_for_common_items_in_impls(\n-        &self, impl1: DefId, impl2: DefId,\n-        overlap: traits::OverlapResult,\n-        used_to_be_allowed: Option<FutureCompatOverlapErrorKind>)\n-    {\n+    fn check_for_common_items_in_impls(&self, impl1: DefId, impl2: DefId,\n+                                       overlap: traits::OverlapResult,\n+                                       used_to_be_allowed: bool) {\n \n         let name_and_namespace = |def_id| {\n             let item = self.tcx.associated_item(def_id);\n@@ -40,28 +37,19 @@ impl<'a, 'tcx> InherentOverlapChecker<'a, 'tcx> {\n             for &item2 in &impl_items2[..] {\n                 if (name, namespace) == name_and_namespace(item2) {\n                     let node_id = self.tcx.hir().as_local_node_id(impl1);\n-                    let mut err = match used_to_be_allowed {\n-                        Some(kind) if node_id.is_some() => {\n-                            let lint = match kind {\n-                                FutureCompatOverlapErrorKind::Issue43355 =>\n-                                    lint::builtin::INCOHERENT_FUNDAMENTAL_IMPLS,\n-                                FutureCompatOverlapErrorKind::Issue33140 =>\n-                                    lint::builtin::ORDER_DEPENDENT_TRAIT_OBJECTS,\n-                            };\n-                            self.tcx.struct_span_lint_node(\n-                                lint,\n-                                node_id.unwrap(),\n-                                self.tcx.span_of_impl(item1).unwrap(),\n-                                &format!(\"duplicate definitions with name `{}` (E0592)\", name)\n-                            )\n-                        }\n-                        _ => {\n-                            struct_span_err!(self.tcx.sess,\n-                                             self.tcx.span_of_impl(item1).unwrap(),\n-                                             E0592,\n-                                             \"duplicate definitions with name `{}`\",\n-                                             name)\n-                        }\n+                    let mut err = if used_to_be_allowed && node_id.is_some() {\n+                        self.tcx.struct_span_lint_node(\n+                            lint::builtin::INCOHERENT_FUNDAMENTAL_IMPLS,\n+                            node_id.unwrap(),\n+                            self.tcx.span_of_impl(item1).unwrap(),\n+                            &format!(\"duplicate definitions with name `{}` (E0592)\", name)\n+                        )\n+                    } else {\n+                        struct_span_err!(self.tcx.sess,\n+                                         self.tcx.span_of_impl(item1).unwrap(),\n+                                         E0592,\n+                                         \"duplicate definitions with name `{}`\",\n+                                         name)\n                     };\n \n                     err.span_label(self.tcx.span_of_impl(item1).unwrap(),\n@@ -88,61 +76,36 @@ impl<'a, 'tcx> InherentOverlapChecker<'a, 'tcx> {\n \n         for (i, &impl1_def_id) in impls.iter().enumerate() {\n             for &impl2_def_id in &impls[(i + 1)..] {\n-                let mut used_to_be_allowed = traits::overlapping_impls(\n+                let used_to_be_allowed = traits::overlapping_impls(\n                     self.tcx,\n                     impl1_def_id,\n                     impl2_def_id,\n                     IntercrateMode::Issue43355,\n-                    TraitObjectMode::NoSquash,\n                     |overlap| {\n                         self.check_for_common_items_in_impls(\n                             impl1_def_id,\n                             impl2_def_id,\n                             overlap,\n-                            Some(FutureCompatOverlapErrorKind::Issue43355),\n+                            false,\n                         );\n                         false\n                     },\n                     || true,\n                 );\n \n-                if used_to_be_allowed {\n-                    used_to_be_allowed = traits::overlapping_impls(\n-                        self.tcx,\n-                        impl1_def_id,\n-                        impl2_def_id,\n-                        IntercrateMode::Fixed,\n-                        TraitObjectMode::NoSquash,\n-                        |overlap| {\n-                            self.check_for_common_items_in_impls(\n-                                impl1_def_id,\n-                                impl2_def_id,\n-                                overlap,\n-                                None,\n-                            );\n-                            false\n-                        },\n-                        || true,\n-                    );\n-                }\n-\n                 if used_to_be_allowed {\n                     traits::overlapping_impls(\n                         self.tcx,\n                         impl1_def_id,\n                         impl2_def_id,\n                         IntercrateMode::Fixed,\n-                        TraitObjectMode::SquashAutoTraitsIssue33140,\n-                        |overlap| {\n-                            self.check_for_common_items_in_impls(\n-                                impl1_def_id,\n-                                impl2_def_id,\n-                                overlap,\n-                                Some(FutureCompatOverlapErrorKind::Issue33140),\n-                            );\n-                            false\n-                        },\n-                        || true,\n+                        |overlap| self.check_for_common_items_in_impls(\n+                            impl1_def_id,\n+                            impl2_def_id,\n+                            overlap,\n+                            true,\n+                        ),\n+                        || (),\n                     );\n                 }\n             }"}]}