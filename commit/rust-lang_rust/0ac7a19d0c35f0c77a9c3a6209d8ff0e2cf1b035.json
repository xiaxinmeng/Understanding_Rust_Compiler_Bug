{"sha": "0ac7a19d0c35f0c77a9c3a6209d8ff0e2cf1b035", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBhYzdhMTlkMGMzNWYwYzc3YTljM2E2MjA5ZDhmZjBlMmNmMWIwMzU=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-03-15T12:59:47Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-03-15T12:59:47Z"}, "message": "Merge #8008\n\n8008: Completion context expected type r=matklad a=JoshMcguigan\n\nCurrently there are two ways completions use to determine the expected type. There is the `expected_type` field on the `CompletionContext`, as well as the `expected_name_and_type` method on the `RenderContext`. These two things returned slightly different results, and their results were only valid if you had pre-checked some (undocumented) invariants. A simple combination of the two approaches doesn't work because they are both too willing to go far up the syntax tree to find something that fits what they are looking for.\r\n\r\nThis PR makes the following changes:\r\n\r\n1. Updates the algorithm that sets `expected_type` on `CompletionContext`\r\n2. Adds `expected_name` field to `CompletionContext`\r\n3. Re-writes the `expected_name_and_type` method to simply return the underlying fields from `CompletionContext` (I'd like to save actually removing this method for a follow up PR just to keep the scope of the changes down)\r\n4. Adds unit tests for the `expected_type`/`expected_name` fields\r\n\r\nAll the existing unit tests still pass (unmodified), but this new algorithm certainly has some gaps (although I believe all the `FIXME` introduced in this PR are also flaws in the current code). I wanted to stop here and get some feedback though - is this approach fundamentally sound? \n\nCo-authored-by: Josh Mcguigan <joshmcg88@gmail.com>", "tree": {"sha": "6e383cf36600b19ab2e69e7b7a62d132de4f8ba2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6e383cf36600b19ab2e69e7b7a62d132de4f8ba2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0ac7a19d0c35f0c77a9c3a6209d8ff0e2cf1b035", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgT1pDCRBK7hj4Ov3rIwAAdHIIAH6xY17s6VR2n46SBAkqznp/\n40YNYGWUuYUw4p/nkTkS0ZNsS1eosGuRwqdXgkpyBIlwvx48KgYSpHAtTrv/zsDT\nQqh5CrO29Edc8eyVRF3EivHyEQSslgFPrRWdabyUVg1yIjo+ZsvHSQZubFrF4ryT\n6xEn86KtN18WFHfXRvFG4+NOhwjoohflC1PU3a302X9GT5eJQTPzHSCAuE48e01S\nfLXXUKEr1QxbTdyeivYLiYWapOJ7AO+cGqYMPjbQrt+IX5vLtVrpevEkL5qGJ3RP\nTm2U0U5b0tZSIzVuKHOoHZtqIO7ghubECOWET2zeRJytcNS170fqaEj7BDAovTA=\n=yVWQ\n-----END PGP SIGNATURE-----\n", "payload": "tree 6e383cf36600b19ab2e69e7b7a62d132de4f8ba2\nparent 6139bd764974318814edfd5427e2a2e8220b211b\nparent d91151c3b1af6d4e4c29f5f82df8566b046266e3\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1615813187 +0000\ncommitter GitHub <noreply@github.com> 1615813187 +0000\n\nMerge #8008\n\n8008: Completion context expected type r=matklad a=JoshMcguigan\n\nCurrently there are two ways completions use to determine the expected type. There is the `expected_type` field on the `CompletionContext`, as well as the `expected_name_and_type` method on the `RenderContext`. These two things returned slightly different results, and their results were only valid if you had pre-checked some (undocumented) invariants. A simple combination of the two approaches doesn't work because they are both too willing to go far up the syntax tree to find something that fits what they are looking for.\r\n\r\nThis PR makes the following changes:\r\n\r\n1. Updates the algorithm that sets `expected_type` on `CompletionContext`\r\n2. Adds `expected_name` field to `CompletionContext`\r\n3. Re-writes the `expected_name_and_type` method to simply return the underlying fields from `CompletionContext` (I'd like to save actually removing this method for a follow up PR just to keep the scope of the changes down)\r\n4. Adds unit tests for the `expected_type`/`expected_name` fields\r\n\r\nAll the existing unit tests still pass (unmodified), but this new algorithm certainly has some gaps (although I believe all the `FIXME` introduced in this PR are also flaws in the current code). I wanted to stop here and get some feedback though - is this approach fundamentally sound? \n\nCo-authored-by: Josh Mcguigan <joshmcg88@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0ac7a19d0c35f0c77a9c3a6209d8ff0e2cf1b035", "html_url": "https://github.com/rust-lang/rust/commit/0ac7a19d0c35f0c77a9c3a6209d8ff0e2cf1b035", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0ac7a19d0c35f0c77a9c3a6209d8ff0e2cf1b035/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6139bd764974318814edfd5427e2a2e8220b211b", "url": "https://api.github.com/repos/rust-lang/rust/commits/6139bd764974318814edfd5427e2a2e8220b211b", "html_url": "https://github.com/rust-lang/rust/commit/6139bd764974318814edfd5427e2a2e8220b211b"}, {"sha": "d91151c3b1af6d4e4c29f5f82df8566b046266e3", "url": "https://api.github.com/repos/rust-lang/rust/commits/d91151c3b1af6d4e4c29f5f82df8566b046266e3", "html_url": "https://github.com/rust-lang/rust/commit/d91151c3b1af6d4e4c29f5f82df8566b046266e3"}], "stats": {"total": 312, "additions": 286, "deletions": 26}, "files": [{"sha": "89e9bda7839290a465f92d6b306c1febe4f5c72f", "filename": "crates/ide_completion/src/context.rs", "status": "modified", "additions": 283, "deletions": 14, "changes": 297, "blob_url": "https://github.com/rust-lang/rust/blob/0ac7a19d0c35f0c77a9c3a6209d8ff0e2cf1b035/crates%2Fide_completion%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac7a19d0c35f0c77a9c3a6209d8ff0e2cf1b035/crates%2Fide_completion%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcontext.rs?ref=0ac7a19d0c35f0c77a9c3a6209d8ff0e2cf1b035", "patch": "@@ -35,6 +35,7 @@ pub(crate) struct CompletionContext<'a> {\n     /// The token before the cursor, in the macro-expanded file.\n     pub(super) token: SyntaxToken,\n     pub(super) krate: Option<hir::Crate>,\n+    pub(super) expected_name: Option<String>,\n     pub(super) expected_type: Option<Type>,\n     pub(super) name_ref_syntax: Option<ast::NameRef>,\n     pub(super) function_syntax: Option<ast::Fn>,\n@@ -135,6 +136,7 @@ impl<'a> CompletionContext<'a> {\n             original_token,\n             token,\n             krate,\n+            expected_name: None,\n             expected_type: None,\n             name_ref_syntax: None,\n             function_syntax: None,\n@@ -290,23 +292,96 @@ impl<'a> CompletionContext<'a> {\n         file_with_fake_ident: SyntaxNode,\n         offset: TextSize,\n     ) {\n-        // FIXME: this is wrong in at least two cases:\n-        //  * when there's no token `foo($0)`\n-        //  * when there is a token, but it happens to have type of it's own\n-        self.expected_type = self\n-            .token\n-            .ancestors()\n-            .find_map(|node| {\n-                let ty = match_ast! {\n+        let expected = {\n+            let mut node = self.token.parent();\n+            loop {\n+                let ret = match_ast! {\n                     match node {\n-                        ast::Pat(it) => self.sema.type_of_pat(&it),\n-                        ast::Expr(it) => self.sema.type_of_expr(&it),\n-                        _ => return None,\n+                        ast::LetStmt(it) => {\n+                            cov_mark::hit!(expected_type_let_with_leading_char);\n+                            cov_mark::hit!(expected_type_let_without_leading_char);\n+                            let ty = it.pat()\n+                                .and_then(|pat| self.sema.type_of_pat(&pat));\n+                            let name = if let Some(ast::Pat::IdentPat(ident)) = it.pat() {\n+                                Some(ident.syntax().text().to_string())\n+                            } else {\n+                                None\n+                            };\n+\n+                            (ty, name)\n+                        },\n+                        ast::ArgList(it) => {\n+                            cov_mark::hit!(expected_type_fn_param_with_leading_char);\n+                            cov_mark::hit!(expected_type_fn_param_without_leading_char);\n+                            ActiveParameter::at_token(\n+                                &self.sema,\n+                                self.token.clone(),\n+                            ).map(|ap| (Some(ap.ty), Some(ap.name)))\n+                            .unwrap_or((None, None))\n+                        },\n+                        ast::RecordExprFieldList(it) => {\n+                            cov_mark::hit!(expected_type_struct_field_without_leading_char);\n+                            self.token.prev_sibling_or_token()\n+                                .and_then(|se| se.into_node())\n+                                .and_then(|node| ast::RecordExprField::cast(node))\n+                                .and_then(|rf| self.sema.resolve_record_field(&rf))\n+                                .map(|f|(\n+                                    Some(f.0.signature_ty(self.db)),\n+                                    Some(f.0.name(self.db).to_string()),\n+                                ))\n+                                .unwrap_or((None, None))\n+                        },\n+                        ast::RecordExprField(it) => {\n+                            cov_mark::hit!(expected_type_struct_field_with_leading_char);\n+                            self.sema\n+                                .resolve_record_field(&it)\n+                                .map(|f|(\n+                                    Some(f.0.signature_ty(self.db)),\n+                                    Some(f.0.name(self.db).to_string()),\n+                                ))\n+                                .unwrap_or((None, None))\n+                        },\n+                        ast::MatchExpr(it) => {\n+                            cov_mark::hit!(expected_type_match_arm_without_leading_char);\n+                            let ty = it.expr()\n+                                .and_then(|e| self.sema.type_of_expr(&e));\n+\n+                            (ty, None)\n+                        },\n+                        ast::IdentPat(it) => {\n+                            cov_mark::hit!(expected_type_if_let_with_leading_char);\n+                            cov_mark::hit!(expected_type_if_let_without_leading_char);\n+                            cov_mark::hit!(expected_type_match_arm_with_leading_char);\n+                            let ty = self.sema.type_of_pat(&ast::Pat::from(it));\n+\n+                            (ty, None)\n+                        },\n+                        ast::Fn(it) => {\n+                            cov_mark::hit!(expected_type_fn_ret_with_leading_char);\n+                            cov_mark::hit!(expected_type_fn_ret_without_leading_char);\n+                            let ty = self.token.ancestors()\n+                                .find_map(|ancestor| ast::Expr::cast(ancestor))\n+                                .and_then(|expr| self.sema.type_of_expr(&expr));\n+\n+                            (ty, None)\n+                        },\n+                        _ => {\n+                            match node.parent() {\n+                                Some(n) => {\n+                                    node = n;\n+                                    continue;\n+                                },\n+                                None => (None, None),\n+                            }\n+                        },\n                     }\n                 };\n-                Some(ty)\n-            })\n-            .flatten();\n+\n+                break ret;\n+            }\n+        };\n+        self.expected_type = expected.0;\n+        self.expected_name = expected.1;\n         self.attribute_under_caret = find_node_at_offset(&file_with_fake_ident, offset);\n \n         // First, let's try to complete a reference to some declaration.\n@@ -535,3 +610,197 @@ fn path_or_use_tree_qualifier(path: &ast::Path) -> Option<ast::Path> {\n     let use_tree = use_tree_list.syntax().parent().and_then(ast::UseTree::cast)?;\n     use_tree.path()\n }\n+\n+#[cfg(test)]\n+mod tests {\n+    use expect_test::{expect, Expect};\n+    use hir::HirDisplay;\n+\n+    use crate::test_utils::{position, TEST_CONFIG};\n+\n+    use super::CompletionContext;\n+\n+    fn check_expected_type_and_name(ra_fixture: &str, expect: Expect) {\n+        let (db, pos) = position(ra_fixture);\n+        let completion_context = CompletionContext::new(&db, pos, &TEST_CONFIG).unwrap();\n+\n+        let ty = completion_context\n+            .expected_type\n+            .map(|t| t.display_test(&db).to_string())\n+            .unwrap_or(\"?\".to_owned());\n+\n+        let name = completion_context.expected_name.unwrap_or(\"?\".to_owned());\n+\n+        expect.assert_eq(&format!(\"ty: {}, name: {}\", ty, name));\n+    }\n+\n+    #[test]\n+    fn expected_type_let_without_leading_char() {\n+        cov_mark::check!(expected_type_let_without_leading_char);\n+        check_expected_type_and_name(\n+            r#\"\n+fn foo() {\n+    let x: u32 = $0;\n+}\n+\"#,\n+            expect![[r#\"ty: u32, name: x\"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn expected_type_let_with_leading_char() {\n+        cov_mark::check!(expected_type_let_with_leading_char);\n+        check_expected_type_and_name(\n+            r#\"\n+fn foo() {\n+    let x: u32 = c$0;\n+}\n+\"#,\n+            expect![[r#\"ty: u32, name: x\"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn expected_type_fn_param_without_leading_char() {\n+        cov_mark::check!(expected_type_fn_param_without_leading_char);\n+        check_expected_type_and_name(\n+            r#\"\n+fn foo() {\n+    bar($0);\n+}\n+\n+fn bar(x: u32) {}\n+\"#,\n+            expect![[r#\"ty: u32, name: x\"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn expected_type_fn_param_with_leading_char() {\n+        cov_mark::check!(expected_type_fn_param_with_leading_char);\n+        check_expected_type_and_name(\n+            r#\"\n+fn foo() {\n+    bar(c$0);\n+}\n+\n+fn bar(x: u32) {}\n+\"#,\n+            expect![[r#\"ty: u32, name: x\"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn expected_type_struct_field_without_leading_char() {\n+        cov_mark::check!(expected_type_struct_field_without_leading_char);\n+        check_expected_type_and_name(\n+            r#\"\n+struct Foo { a: u32 }\n+fn foo() {\n+    Foo { a: $0 };\n+}\n+\"#,\n+            expect![[r#\"ty: u32, name: a\"#]],\n+        )\n+    }\n+\n+    #[test]\n+    fn expected_type_struct_field_with_leading_char() {\n+        cov_mark::check!(expected_type_struct_field_with_leading_char);\n+        check_expected_type_and_name(\n+            r#\"\n+struct Foo { a: u32 }\n+fn foo() {\n+    Foo { a: c$0 };\n+}\n+\"#,\n+            expect![[r#\"ty: u32, name: a\"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn expected_type_match_arm_without_leading_char() {\n+        cov_mark::check!(expected_type_match_arm_without_leading_char);\n+        check_expected_type_and_name(\n+            r#\"\n+enum E { X }\n+fn foo() {\n+   match E::X { $0 }\n+}\n+\"#,\n+            expect![[r#\"ty: E, name: ?\"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn expected_type_match_arm_with_leading_char() {\n+        cov_mark::check!(expected_type_match_arm_with_leading_char);\n+        check_expected_type_and_name(\n+            r#\"\n+enum E { X }\n+fn foo() {\n+   match E::X { c$0 }\n+}\n+\"#,\n+            expect![[r#\"ty: E, name: ?\"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn expected_type_if_let_without_leading_char() {\n+        cov_mark::check!(expected_type_if_let_without_leading_char);\n+        check_expected_type_and_name(\n+            r#\"\n+enum Foo { Bar, Baz, Quux }\n+\n+fn foo() {\n+    let f = Foo::Quux;\n+    if let $0 = f { }\n+}\n+\"#,\n+            expect![[r#\"ty: (), name: ?\"#]],\n+        ) // FIXME should be `ty: u32, name: ?`\n+    }\n+\n+    #[test]\n+    fn expected_type_if_let_with_leading_char() {\n+        cov_mark::check!(expected_type_if_let_with_leading_char);\n+        check_expected_type_and_name(\n+            r#\"\n+enum Foo { Bar, Baz, Quux }\n+\n+fn foo() {\n+    let f = Foo::Quux;\n+    if let c$0 = f { }\n+}\n+\"#,\n+            expect![[r#\"ty: Foo, name: ?\"#]],\n+        )\n+    }\n+\n+    #[test]\n+    fn expected_type_fn_ret_without_leading_char() {\n+        cov_mark::check!(expected_type_fn_ret_without_leading_char);\n+        check_expected_type_and_name(\n+            r#\"\n+fn foo() -> u32 {\n+    $0\n+}\n+\"#,\n+            expect![[r#\"ty: (), name: ?\"#]],\n+        ) // FIXME this should be `ty: u32, name: ?`\n+    }\n+\n+    #[test]\n+    fn expected_type_fn_ret_with_leading_char() {\n+        cov_mark::check!(expected_type_fn_ret_with_leading_char);\n+        check_expected_type_and_name(\n+            r#\"\n+fn foo() -> u32 {\n+    c$0\n+}\n+\"#,\n+            expect![[r#\"ty: u32, name: ?\"#]],\n+        )\n+    }\n+}"}, {"sha": "3e1bff4d66673ccaa9dd54092bf8920a8a1c29a7", "filename": "crates/ide_completion/src/render.rs", "status": "modified", "additions": 3, "deletions": 12, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/0ac7a19d0c35f0c77a9c3a6209d8ff0e2cf1b035/crates%2Fide_completion%2Fsrc%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac7a19d0c35f0c77a9c3a6209d8ff0e2cf1b035/crates%2Fide_completion%2Fsrc%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Frender.rs?ref=0ac7a19d0c35f0c77a9c3a6209d8ff0e2cf1b035", "patch": "@@ -119,17 +119,10 @@ impl<'a> RenderContext<'a> {\n         node.docs(self.db())\n     }\n \n+    // FIXME delete this method in favor of directly using the fields\n+    // on CompletionContext\n     fn expected_name_and_type(&self) -> Option<(String, Type)> {\n-        if let Some(record_field) = &self.completion.record_field_syntax {\n-            cov_mark::hit!(record_field_type_match);\n-            let (struct_field, _local) = self.completion.sema.resolve_record_field(record_field)?;\n-            Some((struct_field.name(self.db()).to_string(), struct_field.signature_ty(self.db())))\n-        } else if let Some(active_parameter) = &self.completion.active_parameter {\n-            cov_mark::hit!(active_param_type_match);\n-            Some((active_parameter.name.clone(), active_parameter.ty.clone()))\n-        } else {\n-            None\n-        }\n+        Some((self.completion.expected_name.clone()?, self.completion.expected_type.clone()?))\n     }\n }\n \n@@ -852,7 +845,6 @@ fn foo(xs: Vec<i128>)\n \n     #[test]\n     fn active_param_relevance() {\n-        cov_mark::check!(active_param_type_match);\n         check_relevance(\n             r#\"\n struct S { foo: i64, bar: u32, baz: u32 }\n@@ -869,7 +861,6 @@ fn foo(s: S) { test(s.$0) }\n \n     #[test]\n     fn record_field_relevances() {\n-        cov_mark::check!(record_field_type_match);\n         check_relevance(\n             r#\"\n struct A { foo: i64, bar: u32, baz: u32 }"}]}