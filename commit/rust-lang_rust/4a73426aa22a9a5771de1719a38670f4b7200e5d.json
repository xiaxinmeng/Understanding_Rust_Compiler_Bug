{"sha": "4a73426aa22a9a5771de1719a38670f4b7200e5d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRhNzM0MjZhYTIyYTlhNTc3MWRlMTcxOWEzODY3MGY0YjcyMDBlNWQ=", "commit": {"author": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2013-03-02T21:02:27Z"}, "committer": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2013-03-03T23:25:08Z"}, "message": "libsyntax: add &self to parser methods", "tree": {"sha": "44d72ded75d8ca2a12b79c216aaa32df7f8b3fca", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/44d72ded75d8ca2a12b79c216aaa32df7f8b3fca"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4a73426aa22a9a5771de1719a38670f4b7200e5d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4a73426aa22a9a5771de1719a38670f4b7200e5d", "html_url": "https://github.com/rust-lang/rust/commit/4a73426aa22a9a5771de1719a38670f4b7200e5d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4a73426aa22a9a5771de1719a38670f4b7200e5d/comments", "author": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3c23589b08678221132bce88c741853d1fd841af", "url": "https://api.github.com/repos/rust-lang/rust/commits/3c23589b08678221132bce88c741853d1fd841af", "html_url": "https://github.com/rust-lang/rust/commit/3c23589b08678221132bce88c741853d1fd841af"}], "stats": {"total": 564, "additions": 303, "deletions": 261}, "files": [{"sha": "824a3e6f880535d04ab625a8708258806aa3fa7e", "filename": "src/libsyntax/parse/attr.rs", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/4a73426aa22a9a5771de1719a38670f4b7200e5d/src%2Flibsyntax%2Fparse%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a73426aa22a9a5771de1719a38670f4b7200e5d/src%2Flibsyntax%2Fparse%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fattr.rs?ref=4a73426aa22a9a5771de1719a38670f4b7200e5d", "patch": "@@ -21,21 +21,24 @@ use core::either::{Either, Left, Right};\n \n // a parser that can parse attributes.\n pub trait parser_attr {\n-    fn parse_outer_attributes() -> ~[ast::attribute];\n-    fn parse_attribute(style: ast::attr_style) -> ast::attribute;\n-    fn parse_attribute_naked(style: ast::attr_style, lo: BytePos) ->\n-        ast::attribute;\n-    fn parse_inner_attrs_and_next() ->\n+    fn parse_outer_attributes(&self) -> ~[ast::attribute];\n+    fn parse_attribute(&self, style: ast::attr_style) -> ast::attribute;\n+    fn parse_attribute_naked(\n+        &self,\n+        style: ast::attr_style,\n+        lo: BytePos\n+    ) -> ast::attribute;\n+    fn parse_inner_attrs_and_next(&self) ->\n         (~[ast::attribute], ~[ast::attribute]);\n-    fn parse_meta_item() -> @ast::meta_item;\n-    fn parse_meta_seq() -> ~[@ast::meta_item];\n-    fn parse_optional_meta() -> ~[@ast::meta_item];\n+    fn parse_meta_item(&self) -> @ast::meta_item;\n+    fn parse_meta_seq(&self) -> ~[@ast::meta_item];\n+    fn parse_optional_meta(&self) -> ~[@ast::meta_item];\n }\n \n impl parser_attr for Parser {\n \n     // Parse attributes that appear before an item\n-    fn parse_outer_attributes() -> ~[ast::attribute] {\n+    fn parse_outer_attributes(&self) -> ~[ast::attribute] {\n         let mut attrs: ~[ast::attribute] = ~[];\n         loop {\n             match *self.token {\n@@ -63,13 +66,13 @@ impl parser_attr for Parser {\n         return attrs;\n     }\n \n-    fn parse_attribute(style: ast::attr_style) -> ast::attribute {\n+    fn parse_attribute(&self, style: ast::attr_style) -> ast::attribute {\n         let lo = self.span.lo;\n         self.expect(&token::POUND);\n         return self.parse_attribute_naked(style, lo);\n     }\n \n-    fn parse_attribute_naked(style: ast::attr_style, lo: BytePos) ->\n+    fn parse_attribute_naked(&self, style: ast::attr_style, lo: BytePos) ->\n         ast::attribute {\n         self.expect(&token::LBRACKET);\n         let meta_item = self.parse_meta_item();\n@@ -89,7 +92,7 @@ impl parser_attr for Parser {\n \n     // you can make the 'next' field an Option, but the result is going to be\n     // more useful as a vector.\n-    fn parse_inner_attrs_and_next() ->\n+    fn parse_inner_attrs_and_next(&self) ->\n         (~[ast::attribute], ~[ast::attribute]) {\n         let mut inner_attrs: ~[ast::attribute] = ~[];\n         let mut next_outer_attrs: ~[ast::attribute] = ~[];\n@@ -135,7 +138,7 @@ impl parser_attr for Parser {\n         (inner_attrs, next_outer_attrs)\n     }\n \n-    fn parse_meta_item() -> @ast::meta_item {\n+    fn parse_meta_item(&self) -> @ast::meta_item {\n         let lo = self.span.lo;\n         let name = self.id_to_str(self.parse_ident());\n         match *self.token {\n@@ -157,7 +160,7 @@ impl parser_attr for Parser {\n         }\n     }\n \n-    fn parse_meta_seq() -> ~[@ast::meta_item] {\n+    fn parse_meta_seq(&self) -> ~[@ast::meta_item] {\n         copy self.parse_seq(\n             &token::LPAREN,\n             &token::RPAREN,\n@@ -166,7 +169,7 @@ impl parser_attr for Parser {\n         ).node\n     }\n \n-    fn parse_optional_meta() -> ~[@ast::meta_item] {\n+    fn parse_optional_meta(&self) -> ~[@ast::meta_item] {\n         match *self.token {\n             token::LPAREN => self.parse_meta_seq(),\n             _ => ~[]"}, {"sha": "0abec79ee5dc6efd7e41b16b28317bc981fe37fd", "filename": "src/libsyntax/parse/common.rs", "status": "modified", "additions": 29, "deletions": 23, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/4a73426aa22a9a5771de1719a38670f4b7200e5d/src%2Flibsyntax%2Fparse%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a73426aa22a9a5771de1719a38670f4b7200e5d/src%2Flibsyntax%2Fparse%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcommon.rs?ref=4a73426aa22a9a5771de1719a38670f4b7200e5d", "patch": "@@ -54,7 +54,7 @@ pub fn token_to_str(reader: reader, token: &token::Token) -> ~str {\n }\n \n pub impl Parser {\n-    fn unexpected_last(t: &token::Token) -> ! {\n+    fn unexpected_last(&self, t: &token::Token) -> ! {\n         self.span_fatal(\n             *self.last_span,\n             fmt!(\n@@ -64,7 +64,7 @@ pub impl Parser {\n         );\n     }\n \n-    fn unexpected() -> ! {\n+    fn unexpected(&self) -> ! {\n         self.fatal(\n             fmt!(\n                 \"unexpected token: `%s`\",\n@@ -75,7 +75,7 @@ pub impl Parser {\n \n     // expect and consume the token t. Signal an error if\n     // the next token is not t.\n-    fn expect(t: &token::Token) {\n+    fn expect(&self, t: &token::Token) {\n         if *self.token == *t {\n             self.bump();\n         } else {\n@@ -89,7 +89,7 @@ pub impl Parser {\n         }\n     }\n \n-    fn parse_ident() -> ast::ident {\n+    fn parse_ident(&self) -> ast::ident {\n         self.check_strict_keywords();\n         self.check_reserved_keywords();\n         match *self.token {\n@@ -113,50 +113,50 @@ pub impl Parser {\n         }\n     }\n \n-    fn parse_path_list_ident() -> ast::path_list_ident {\n+    fn parse_path_list_ident(&self) -> ast::path_list_ident {\n         let lo = self.span.lo;\n         let ident = self.parse_ident();\n         let hi = self.span.hi;\n         spanned(lo, hi, ast::path_list_ident_ { name: ident,\n                                                 id: self.get_id() })\n     }\n \n-    fn parse_value_ident() -> ast::ident {\n+    fn parse_value_ident(&self) -> ast::ident {\n         return self.parse_ident();\n     }\n \n     // consume token 'tok' if it exists. Returns true if the given\n     // token was present, false otherwise.\n-    fn eat(tok: &token::Token) -> bool {\n+    fn eat(&self, tok: &token::Token) -> bool {\n         return if *self.token == *tok { self.bump(); true } else { false };\n     }\n \n     // Storing keywords as interned idents instead of strings would be nifty.\n \n     // A sanity check that the word we are asking for is a known keyword\n-    fn require_keyword(word: &~str) {\n+    fn require_keyword(&self, word: &~str) {\n         if !self.keywords.contains_key(word) {\n             self.bug(fmt!(\"unknown keyword: %s\", *word));\n         }\n     }\n \n-    pure fn token_is_word(word: &~str, tok: &token::Token) -> bool {\n+    pure fn token_is_word(&self, word: &~str, tok: &token::Token) -> bool {\n         match *tok {\n             token::IDENT(sid, false) => { *self.id_to_str(sid) == *word }\n              _ => { false }\n         }\n     }\n \n-    fn token_is_keyword(word: &~str, tok: &token::Token) -> bool {\n+    fn token_is_keyword(&self, word: &~str, tok: &token::Token) -> bool {\n         self.require_keyword(word);\n         self.token_is_word(word, tok)\n     }\n \n-    fn is_keyword(word: &~str) -> bool {\n+    fn is_keyword(&self, word: &~str) -> bool {\n         self.token_is_keyword(word, &copy *self.token)\n     }\n \n-    fn is_any_keyword(tok: &token::Token) -> bool {\n+    fn is_any_keyword(&self, tok: &token::Token) -> bool {\n         match *tok {\n           token::IDENT(sid, false) => {\n             self.keywords.contains_key(self.id_to_str(sid))\n@@ -165,7 +165,7 @@ pub impl Parser {\n         }\n     }\n \n-    fn eat_keyword(word: &~str) -> bool {\n+    fn eat_keyword(&self, word: &~str) -> bool {\n         self.require_keyword(word);\n         let is_kw = match *self.token {\n             token::IDENT(sid, false) => *word == *self.id_to_str(sid),\n@@ -175,7 +175,7 @@ pub impl Parser {\n         is_kw\n     }\n \n-    fn expect_keyword(word: &~str) {\n+    fn expect_keyword(&self, word: &~str) {\n         self.require_keyword(word);\n         if !self.eat_keyword(word) {\n             self.fatal(\n@@ -188,11 +188,11 @@ pub impl Parser {\n         }\n     }\n \n-    fn is_strict_keyword(word: &~str) -> bool {\n+    fn is_strict_keyword(&self, word: &~str) -> bool {\n         self.strict_keywords.contains_key(word)\n     }\n \n-    fn check_strict_keywords() {\n+    fn check_strict_keywords(&self) {\n         match *self.token {\n             token::IDENT(_, false) => {\n                 let w = token_to_str(self.reader, &copy *self.token);\n@@ -202,17 +202,17 @@ pub impl Parser {\n         }\n     }\n \n-    fn check_strict_keywords_(w: &~str) {\n+    fn check_strict_keywords_(&self, w: &~str) {\n         if self.is_strict_keyword(w) {\n             self.fatal(fmt!(\"found `%s` in ident position\", *w));\n         }\n     }\n \n-    fn is_reserved_keyword(word: &~str) -> bool {\n+    fn is_reserved_keyword(&self, word: &~str) -> bool {\n         self.reserved_keywords.contains_key(word)\n     }\n \n-    fn check_reserved_keywords() {\n+    fn check_reserved_keywords(&self) {\n         match *self.token {\n             token::IDENT(_, false) => {\n                 let w = token_to_str(self.reader, &copy *self.token);\n@@ -222,15 +222,15 @@ pub impl Parser {\n         }\n     }\n \n-    fn check_reserved_keywords_(w: &~str) {\n+    fn check_reserved_keywords_(&self, w: &~str) {\n         if self.is_reserved_keyword(w) {\n             self.fatal(fmt!(\"`%s` is a reserved keyword\", *w));\n         }\n     }\n \n     // expect and consume a GT. if a >> is seen, replace it\n     // with a single > and continue.\n-    fn expect_gt() {\n+    fn expect_gt(&self) {\n         if *self.token == token::GT {\n             self.bump();\n         } else if *self.token == token::BINOP(token::SHR) {\n@@ -252,6 +252,7 @@ pub impl Parser {\n     // parse a sequence bracketed by '<' and '>', stopping\n     // before the '>'.\n     fn parse_seq_to_before_gt<T: Copy>(\n+        &self,\n         sep: Option<token::Token>,\n         f: fn(&Parser) -> T\n     ) -> OptVec<T> {\n@@ -266,12 +267,13 @@ pub impl Parser {\n               }\n               _ => ()\n             }\n-            v.push(f(&self));\n+            v.push(f(self));\n         }\n         return v;\n     }\n \n     fn parse_seq_to_gt<T: Copy>(\n+        &self,\n         sep: Option<token::Token>,\n         f: fn(&Parser) -> T\n     ) -> OptVec<T> {\n@@ -284,6 +286,7 @@ pub impl Parser {\n     // f must consume tokens until reaching the next separator or\n     // closing bracket.\n     fn parse_seq_to_end<T: Copy>(\n+        &self,\n         ket: &token::Token,\n         sep: SeqSep,\n         f: fn(&Parser) -> T\n@@ -297,6 +300,7 @@ pub impl Parser {\n     // f must consume tokens until reaching the next separator or\n     // closing bracket.\n     fn parse_seq_to_before_end<T: Copy>(\n+        &self,\n         ket: &token::Token,\n         sep: SeqSep,\n         f: fn(&Parser) -> T\n@@ -312,7 +316,7 @@ pub impl Parser {\n               _ => ()\n             }\n             if sep.trailing_sep_allowed && *self.token == *ket { break; }\n-            v.push(f(&self));\n+            v.push(f(self));\n         }\n         return v;\n     }\n@@ -321,6 +325,7 @@ pub impl Parser {\n     // f must consume tokens until reaching the next separator or\n     // closing bracket.\n     fn parse_unspanned_seq<T: Copy>(\n+        &self,\n         bra: &token::Token,\n         ket: &token::Token,\n         sep: SeqSep,\n@@ -335,6 +340,7 @@ pub impl Parser {\n     // NB: Do not use this function unless you actually plan to place the\n     // spanned list in the AST.\n     fn parse_seq<T: Copy>(\n+        &self,\n         bra: &token::Token,\n         ket: &token::Token,\n         sep: SeqSep,"}, {"sha": "4ca7c1ec8884a66a08e0942b59d50fc38e82778e", "filename": "src/libsyntax/parse/obsolete.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4a73426aa22a9a5771de1719a38670f4b7200e5d/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a73426aa22a9a5771de1719a38670f4b7200e5d/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fobsolete.rs?ref=4a73426aa22a9a5771de1719a38670f4b7200e5d", "patch": "@@ -62,7 +62,7 @@ impl to_bytes::IterBytes for ObsoleteSyntax {\n \n pub impl Parser {\n     /// Reports an obsolete syntax non-fatal error.\n-    fn obsolete(sp: span, kind: ObsoleteSyntax) {\n+    fn obsolete(&self, sp: span, kind: ObsoleteSyntax) {\n         let (kind_str, desc) = match kind {\n             ObsoleteLowerCaseKindBounds => (\n                 \"lower-case kind bounds\",\n@@ -154,12 +154,12 @@ pub impl Parser {\n \n     // Reports an obsolete syntax non-fatal error, and returns\n     // a placeholder expression\n-    fn obsolete_expr(sp: span, kind: ObsoleteSyntax) -> @expr {\n+    fn obsolete_expr(&self, sp: span, kind: ObsoleteSyntax) -> @expr {\n         self.obsolete(sp, kind);\n         self.mk_expr(sp.lo, sp.hi, expr_lit(@respan(sp, lit_nil)))\n     }\n \n-    priv fn report(sp: span, kind: ObsoleteSyntax, kind_str: &str,\n+    priv fn report(&self, sp: span, kind: ObsoleteSyntax, kind_str: &str,\n                    desc: &str) {\n         self.span_err(sp, fmt!(\"obsolete syntax: %s\", kind_str));\n \n@@ -169,7 +169,7 @@ pub impl Parser {\n         }\n     }\n \n-    fn token_is_obsolete_ident(ident: &str, token: Token) -> bool {\n+    fn token_is_obsolete_ident(&self, ident: &str, token: Token) -> bool {\n         match token {\n             token::IDENT(copy sid, _) => {\n                 str::eq_slice(*self.id_to_str(sid), ident)\n@@ -178,11 +178,11 @@ pub impl Parser {\n         }\n     }\n \n-    fn is_obsolete_ident(ident: &str) -> bool {\n+    fn is_obsolete_ident(&self, ident: &str) -> bool {\n         self.token_is_obsolete_ident(ident, *self.token)\n     }\n \n-    fn eat_obsolete_ident(ident: &str) -> bool {\n+    fn eat_obsolete_ident(&self, ident: &str) -> bool {\n         if self.is_obsolete_ident(ident) {\n             self.bump();\n             true\n@@ -191,7 +191,7 @@ pub impl Parser {\n         }\n     }\n \n-    fn try_parse_obsolete_struct_ctor() -> bool {\n+    fn try_parse_obsolete_struct_ctor(&self) -> bool {\n         if self.eat_obsolete_ident(\"new\") {\n             self.obsolete(*self.last_span, ObsoleteStructCtor);\n             self.parse_fn_decl(|p| p.parse_arg());\n@@ -202,7 +202,7 @@ pub impl Parser {\n         }\n     }\n \n-    fn try_parse_obsolete_with() -> bool {\n+    fn try_parse_obsolete_with(&self) -> bool {\n         if *self.token == token::COMMA\n             && self.token_is_obsolete_ident(\"with\",\n                                             self.look_ahead(1u)) {\n@@ -217,7 +217,7 @@ pub impl Parser {\n         }\n     }\n \n-    fn try_parse_obsolete_priv_section() -> bool {\n+    fn try_parse_obsolete_priv_section(&self) -> bool {\n         if self.is_keyword(&~\"priv\") && self.look_ahead(1) == token::LBRACE {\n             self.obsolete(copy *self.span, ObsoletePrivSection);\n             self.eat_keyword(&~\"priv\");"}, {"sha": "0d0d23e0cd0a9647fd2bd2c22ea8f45bf2dd24a2", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 243, "deletions": 210, "changes": 453, "blob_url": "https://github.com/rust-lang/rust/blob/4a73426aa22a9a5771de1719a38670f4b7200e5d/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a73426aa22a9a5771de1719a38670f4b7200e5d/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=4a73426aa22a9a5771de1719a38670f4b7200e5d", "patch": "@@ -131,61 +131,70 @@ The important thing is to make sure that lookahead doesn't balk\n at INTERPOLATED tokens */\n macro_rules! maybe_whole_expr (\n     ($p:expr) => (\n-        match *$p.token {\n-            INTERPOLATED(token::nt_expr(e)) => {\n+        match *($p).token {\n+            INTERPOLATED(token::nt_expr(copy e)) => {\n                 $p.bump();\n                 return e;\n             }\n-            INTERPOLATED(token::nt_path(pt)) => {\n+            INTERPOLATED(token::nt_path(copy pt)) => {\n                 $p.bump();\n                 return $p.mk_expr(\n-                    $p.span.lo,\n-                    $p.span.hi,\n+                    ($p).span.lo,\n+                    ($p).span.hi,\n                     expr_path(pt)\n                 );\n             }\n-        _ => ()\n+            _ => ()\n         }\n     )\n )\n \n macro_rules! maybe_whole (\n-    ($p:expr, $constructor:ident) => ( match copy *$p.token {\n-      INTERPOLATED(token::$constructor(x)) => {\n-        $p.bump();\n-        return x;\n-      }\n-      _ => ()\n-    }) ;\n-    (deref $p:expr, $constructor:ident) => ( match copy *$p.token {\n-      INTERPOLATED(token::$constructor(x)) => {\n-        $p.bump();\n-        return copy *x;\n-      }\n-      _ => ()\n-    }) ;\n-    (Some $p:expr, $constructor:ident) => ( match copy *$p.token {\n-      INTERPOLATED(token::$constructor(x)) => {\n-        $p.bump();\n-        return Some(x);\n-      }\n-      _ => ()\n-    }) ;\n-    (iovi $p:expr, $constructor:ident) => ( match *$p.token {\n-      INTERPOLATED(token::$constructor(x)) => {\n-        $p.bump();\n-        return iovi_item(x);\n-      }\n-      _ => ()\n-    }) ;\n-    (pair_empty $p:expr, $constructor:ident) => ( match copy *$p.token {\n-      INTERPOLATED(token::$constructor(x)) => {\n-        $p.bump();\n-        return (~[], x);\n-      }\n-      _ => ()\n-    })\n-\n+    ($p:expr, $constructor:ident) => (\n+        match *($p).token {\n+            INTERPOLATED(token::$constructor(copy x)) => {\n+                $p.bump();\n+                return x;\n+            }\n+            _ => ()\n+       }\n+    );\n+    (deref $p:expr, $constructor:ident) => (\n+        match *($p).token {\n+            INTERPOLATED(token::$constructor(copy x)) => {\n+                $p.bump();\n+                return copy *x;\n+            }\n+            _ => ()\n+        }\n+    );\n+    (Some $p:expr, $constructor:ident) => (\n+        match *($p).token {\n+            INTERPOLATED(token::$constructor(copy x)) => {\n+                $p.bump();\n+                return Some(x);\n+            }\n+            _ => ()\n+        }\n+    );\n+    (iovi $p:expr, $constructor:ident) => (\n+        match *($p).token {\n+            INTERPOLATED(token::$constructor(copy x)) => {\n+                $p.bump();\n+                return iovi_item(x);\n+            }\n+            _ => ()\n+        }\n+    );\n+    (pair_empty $p:expr, $constructor:ident) => (\n+        match *($p).token {\n+            INTERPOLATED(token::$constructor(copy x)) => {\n+                $p.bump();\n+                return (~[], x);\n+            }\n+            _ => ()\n+        }\n+    )\n )\n \n \n@@ -268,7 +277,7 @@ impl Drop for Parser {\n \n pub impl Parser {\n     // advance the parser by one token\n-    fn bump() {\n+    fn bump(&self) {\n         *self.last_span = copy *self.span;\n         let next = if *self.buffer_start == *self.buffer_end {\n             self.reader.next_token()\n@@ -282,57 +291,59 @@ pub impl Parser {\n         *self.tokens_consumed += 1u;\n     }\n     // EFFECT: replace the current token and span with the given one\n-    fn replace_token(+next: token::Token, +lo: BytePos, +hi: BytePos) {\n+    fn replace_token(&self, +next: token::Token, +lo: BytePos, +hi: BytePos) {\n         *self.token = next;\n         *self.span = mk_sp(lo, hi);\n     }\n-    fn buffer_length() -> int {\n+    fn buffer_length(&self) -> int {\n         if *self.buffer_start <= *self.buffer_end {\n             return *self.buffer_end - *self.buffer_start;\n         }\n         return (4 - *self.buffer_start) + *self.buffer_end;\n     }\n-    fn look_ahead(distance: uint) -> token::Token {\n+    fn look_ahead(&self, distance: uint) -> token::Token {\n         let dist = distance as int;\n         while self.buffer_length() < dist {\n             self.buffer[*self.buffer_end] = self.reader.next_token();\n             *self.buffer_end = (*self.buffer_end + 1) & 3;\n         }\n         return copy self.buffer[(*self.buffer_start + dist - 1) & 3].tok;\n     }\n-    fn fatal(m: ~str) -> ! {\n+    fn fatal(&self, m: ~str) -> ! {\n         self.sess.span_diagnostic.span_fatal(*copy self.span, m)\n     }\n-    fn span_fatal(sp: span, m: ~str) -> ! {\n+    fn span_fatal(&self, sp: span, m: ~str) -> ! {\n         self.sess.span_diagnostic.span_fatal(sp, m)\n     }\n-    fn span_note(sp: span, m: ~str) {\n+    fn span_note(&self, sp: span, m: ~str) {\n         self.sess.span_diagnostic.span_note(sp, m)\n     }\n-    fn bug(m: ~str) -> ! {\n+    fn bug(&self, m: ~str) -> ! {\n         self.sess.span_diagnostic.span_bug(*copy self.span, m)\n     }\n-    fn warn(m: ~str) {\n+    fn warn(&self, m: ~str) {\n         self.sess.span_diagnostic.span_warn(*copy self.span, m)\n     }\n-    fn span_err(sp: span, m: ~str) {\n+    fn span_err(&self, sp: span, m: ~str) {\n         self.sess.span_diagnostic.span_err(sp, m)\n     }\n-    fn abort_if_errors() {\n+    fn abort_if_errors(&self) {\n         self.sess.span_diagnostic.handler().abort_if_errors();\n     }\n-    fn get_id() -> node_id { next_node_id(self.sess) }\n+    fn get_id(&self) -> node_id { next_node_id(self.sess) }\n \n-    pure fn id_to_str(id: ident) -> @~str { self.sess.interner.get(id) }\n+    pure fn id_to_str(&self, id: ident) -> @~str {\n+        self.sess.interner.get(id)\n+    }\n \n-    fn token_is_closure_keyword(tok: &token::Token) -> bool {\n+    fn token_is_closure_keyword(&self, tok: &token::Token) -> bool {\n         self.token_is_keyword(&~\"pure\", tok) ||\n             self.token_is_keyword(&~\"unsafe\", tok) ||\n             self.token_is_keyword(&~\"once\", tok) ||\n             self.token_is_keyword(&~\"fn\", tok)\n     }\n \n-    fn parse_ty_bare_fn() -> ty_\n+    fn parse_ty_bare_fn(&self) -> ty_\n     {\n         /*\n \n@@ -357,7 +368,7 @@ pub impl Parser {\n         });\n     }\n \n-    fn parse_ty_closure(pre_sigil: Option<ast::Sigil>,\n+    fn parse_ty_closure(&self, pre_sigil: Option<ast::Sigil>,\n                         pre_region_name: Option<ident>) -> ty_\n     {\n         /*\n@@ -379,7 +390,7 @@ pub impl Parser {\n         // parsed.\n \n         let purity = self.parse_purity();\n-        let onceness = parse_onceness(&self);\n+        let onceness = parse_onceness(self);\n         self.expect_keyword(&~\"fn\");\n \n         let sigil = match pre_sigil { None => BorrowedSigil, Some(p) => p };\n@@ -403,7 +414,7 @@ pub impl Parser {\n         }\n     }\n \n-    fn parse_purity() -> purity {\n+    fn parse_purity(&self) -> purity {\n         if self.eat_keyword(&~\"pure\") {\n             return pure_fn;\n         } else if self.eat_keyword(&~\"unsafe\") {\n@@ -413,7 +424,7 @@ pub impl Parser {\n         }\n     }\n \n-    fn parse_ty_fn_decl() -> fn_decl {\n+    fn parse_ty_fn_decl(&self) -> fn_decl {\n         /*\n \n         (fn) <'lt> (S) -> T\n@@ -438,7 +449,7 @@ pub impl Parser {\n         ast::fn_decl { inputs: inputs, output: ret_ty, cf: ret_style }\n     }\n \n-    fn parse_trait_methods() -> ~[trait_method] {\n+    fn parse_trait_methods(&self) -> ~[trait_method] {\n         do self.parse_unspanned_seq(\n             &token::LBRACE,\n             &token::RBRACE,\n@@ -519,13 +530,13 @@ pub impl Parser {\n     }\n \n \n-    fn parse_mt() -> mt {\n+    fn parse_mt(&self) -> mt {\n         let mutbl = self.parse_mutability();\n         let t = self.parse_ty(false);\n         mt { ty: t, mutbl: mutbl }\n     }\n \n-    fn parse_ty_field() -> ty_field {\n+    fn parse_ty_field(&self) -> ty_field {\n         let lo = self.span.lo;\n         let mutbl = self.parse_mutability();\n         let id = self.parse_ident();\n@@ -541,7 +552,7 @@ pub impl Parser {\n         )\n     }\n \n-    fn parse_ret_ty() -> (ret_style, @Ty) {\n+    fn parse_ret_ty(&self) -> (ret_style, @Ty) {\n         return if self.eat(&token::RARROW) {\n             let lo = self.span.lo;\n             if self.eat(&token::NOT) {\n@@ -569,7 +580,7 @@ pub impl Parser {\n         }\n     }\n \n-    fn region_from_name(s: Option<ident>) -> @region {\n+    fn region_from_name(&self, s: Option<ident>) -> @region {\n         let r = match s {\n             Some(id) if id == special_idents::static => ast::re_static,\n             Some(id) if id == special_idents::self_ => re_self,\n@@ -581,7 +592,7 @@ pub impl Parser {\n     }\n \n     // Parses something like \"&x\"\n-    fn parse_region() -> @region {\n+    fn parse_region(&self) -> @region {\n         self.expect(&token::BINOP(token::AND));\n \n         match *self.token {\n@@ -595,7 +606,7 @@ pub impl Parser {\n         }\n     }\n \n-    fn parse_ty(colons_before_params: bool) -> @Ty {\n+    fn parse_ty(&self, colons_before_params: bool) -> @Ty {\n         maybe_whole!(self, nt_ty);\n \n         let lo = self.span.lo;\n@@ -682,6 +693,7 @@ pub impl Parser {\n     }\n \n     fn parse_box_or_uniq_pointee(\n+        &self,\n         sigil: ast::Sigil,\n         ctor: &fn(+v: mt) -> ty_) -> ty_\n     {\n@@ -719,7 +731,7 @@ pub impl Parser {\n         ctor(mt)\n     }\n \n-    fn parse_borrowed_pointee() -> ty_ {\n+    fn parse_borrowed_pointee(&self) -> ty_ {\n         // look for `&'lt` or `&foo/` and interpret `foo` as the region name:\n         let rname = match *self.token {\n             token::LIFETIME(sid) => {\n@@ -748,7 +760,7 @@ pub impl Parser {\n         return ty_rptr(r, mt);\n     }\n \n-    fn parse_arg_mode() -> mode {\n+    fn parse_arg_mode(&self) -> mode {\n         if self.eat(&token::BINOP(token::MINUS)) {\n             expl(by_copy) // NDM outdated syntax\n         } else if self.eat(&token::ANDAND) {\n@@ -764,7 +776,7 @@ pub impl Parser {\n         }\n     }\n \n-    fn is_named_argument() -> bool {\n+    fn is_named_argument(&self) -> bool {\n         let offset = if *self.token == token::BINOP(token::AND) {\n             1\n         } else if *self.token == token::BINOP(token::MINUS) {\n@@ -789,7 +801,7 @@ pub impl Parser {\n \n     // This version of parse arg doesn't necessarily require\n     // identifier names.\n-    fn parse_arg_general(require_name: bool) -> arg {\n+    fn parse_arg_general(&self, require_name: bool) -> arg {\n         let mut m;\n         let mut is_mutbl = false;\n         let pat = if require_name || self.is_named_argument() {\n@@ -811,11 +823,11 @@ pub impl Parser {\n                   ty: t, pat: pat, id: self.get_id() }\n     }\n \n-    fn parse_arg() -> arg_or_capture_item {\n+    fn parse_arg(&self) -> arg_or_capture_item {\n         either::Left(self.parse_arg_general(true))\n     }\n \n-    fn parse_fn_block_arg() -> arg_or_capture_item {\n+    fn parse_fn_block_arg(&self) -> arg_or_capture_item {\n         let m = self.parse_arg_mode();\n         let is_mutbl = self.eat_keyword(&~\"mut\");\n         let pat = self.parse_pat(false);\n@@ -837,7 +849,7 @@ pub impl Parser {\n         })\n     }\n \n-    fn maybe_parse_fixed_vstore_with_star() -> Option<uint> {\n+    fn maybe_parse_fixed_vstore_with_star(&self) -> Option<uint> {\n         if self.eat(&token::BINOP(token::STAR)) {\n             match *self.token {\n                 token::LIT_INT_UNSUFFIXED(i) if i >= 0i64 => {\n@@ -859,7 +871,7 @@ pub impl Parser {\n         }\n     }\n \n-    fn lit_from_token(tok: &token::Token) -> lit_ {\n+    fn lit_from_token(&self, tok: &token::Token) -> lit_ {\n         match *tok {\n             token::LIT_INT(i, it) => lit_int(i, it),\n             token::LIT_UINT(u, ut) => lit_uint(u, ut),\n@@ -873,7 +885,7 @@ pub impl Parser {\n         }\n     }\n \n-    fn parse_lit() -> lit {\n+    fn parse_lit(&self) -> lit {\n         let lo = self.span.lo;\n         let lit = if self.eat_keyword(&~\"true\") {\n             lit_bool(true)\n@@ -888,15 +900,16 @@ pub impl Parser {\n         codemap::spanned { node: lit, span: mk_sp(lo, self.last_span.hi) }\n     }\n \n-    fn parse_path_without_tps() -> @path {\n+    fn parse_path_without_tps(&self) -> @path {\n         self.parse_path_without_tps_(|p| p.parse_ident(),\n                                      |p| p.parse_ident())\n     }\n \n     fn parse_path_without_tps_(\n+        &self,\n         parse_ident: fn(&Parser) -> ident,\n-        parse_last_ident: fn(&Parser) -> ident) -> @path {\n-\n+        parse_last_ident: fn(&Parser) -> ident\n+    ) -> @path {\n         maybe_whole!(self, nt_path);\n         let lo = self.span.lo;\n         let global = self.eat(&token::MOD_SEP);\n@@ -907,10 +920,10 @@ pub impl Parser {\n                 && self.look_ahead(1u) == token::MOD_SEP;\n \n             if is_not_last {\n-                ids.push(parse_ident(&self));\n+                ids.push(parse_ident(self));\n                 self.expect(&token::MOD_SEP);\n             } else {\n-                ids.push(parse_last_ident(&self));\n+                ids.push(parse_last_ident(self));\n                 break;\n             }\n         }\n@@ -921,12 +934,12 @@ pub impl Parser {\n                      types: ~[] }\n     }\n \n-    fn parse_value_path() -> @path {\n+    fn parse_value_path(&self) -> @path {\n         self.parse_path_without_tps_(|p| p.parse_ident(),\n                                      |p| p.parse_value_ident())\n     }\n \n-    fn parse_path_with_tps(colons: bool) -> @path {\n+    fn parse_path_with_tps(&self, colons: bool) -> @path {\n         debug!(\"parse_path_with_tps(colons=%b)\", colons);\n \n         maybe_whole!(self, nt_path);\n@@ -964,7 +977,7 @@ pub impl Parser {\n                      .. copy *path }\n     }\n \n-    fn parse_opt_lifetime() -> Option<ast::Lifetime> {\n+    fn parse_opt_lifetime(&self) -> Option<ast::Lifetime> {\n         /*!\n          *\n          * Parses 0 or 1 lifetime.\n@@ -980,7 +993,7 @@ pub impl Parser {\n         }\n     }\n \n-    fn parse_lifetime() -> ast::Lifetime {\n+    fn parse_lifetime(&self) -> ast::Lifetime {\n         /*!\n          *\n          * Parses a single lifetime.\n@@ -1001,7 +1014,7 @@ pub impl Parser {\n         }\n     }\n \n-    fn parse_lifetimes() -> OptVec<ast::Lifetime> {\n+    fn parse_lifetimes(&self) -> OptVec<ast::Lifetime> {\n         /*!\n          *\n          * Parses zero or more comma separated lifetimes.\n@@ -1031,7 +1044,7 @@ pub impl Parser {\n         }\n     }\n \n-    fn parse_mutability() -> mutability {\n+    fn parse_mutability(&self) -> mutability {\n         if self.eat_keyword(&~\"mut\") {\n             m_mutbl\n         } else if self.eat_keyword(&~\"const\") {\n@@ -1041,7 +1054,7 @@ pub impl Parser {\n         }\n     }\n \n-    fn parse_field(sep: token::Token) -> field {\n+    fn parse_field(&self, sep: token::Token) -> field {\n         let lo = self.span.lo;\n         let m = self.parse_mutability();\n         let i = self.parse_ident();\n@@ -1050,7 +1063,7 @@ pub impl Parser {\n         spanned(lo, e.span.hi, ast::field_ { mutbl: m, ident: i, expr: e })\n     }\n \n-    fn mk_expr(+lo: BytePos, +hi: BytePos, +node: expr_) -> @expr {\n+    fn mk_expr(&self, +lo: BytePos, +hi: BytePos, +node: expr_) -> @expr {\n         @expr {\n             id: self.get_id(),\n             callee_id: self.get_id(),\n@@ -1059,7 +1072,7 @@ pub impl Parser {\n         }\n     }\n \n-    fn mk_mac_expr(+lo: BytePos, +hi: BytePos, +m: mac_) -> @expr {\n+    fn mk_mac_expr(&self, +lo: BytePos, +hi: BytePos, +m: mac_) -> @expr {\n         @expr {\n             id: self.get_id(),\n             callee_id: self.get_id(),\n@@ -1068,7 +1081,7 @@ pub impl Parser {\n         }\n     }\n \n-    fn mk_lit_u32(i: u32) -> @expr {\n+    fn mk_lit_u32(&self, i: u32) -> @expr {\n         let span = self.span;\n         let lv_lit = @codemap::spanned {\n             node: lit_uint(i as u64, ty_u32),\n@@ -1083,8 +1096,9 @@ pub impl Parser {\n         }\n     }\n \n-    fn parse_bottom_expr() -> @expr {\n+    fn parse_bottom_expr(&self) -> @expr {\n         maybe_whole_expr!(self);\n+\n         let lo = self.span.lo;\n         let mut hi = self.span.hi;\n \n@@ -1215,7 +1229,7 @@ pub impl Parser {\n                 !self.is_keyword(&~\"false\") {\n             let pth = self.parse_path_with_tps(true);\n \n-            /* `!`, as an operator, is prefix, so we know this isn't that */\n+            // `!`, as an operator, is prefix, so we know this isn't that\n             if *self.token == token::NOT {\n                 self.bump();\n                 match *self.token {\n@@ -1279,22 +1293,26 @@ pub impl Parser {\n         return self.mk_expr(lo, hi, ex);\n     }\n \n-    fn parse_block_expr(lo: BytePos, blk_mode: blk_check_mode) -> @expr {\n+    fn parse_block_expr(\n+        &self,\n+        lo: BytePos,\n+        blk_mode: blk_check_mode\n+    ) -> @expr {\n         self.expect(&token::LBRACE);\n         let blk = self.parse_block_tail(lo, blk_mode);\n         return self.mk_expr(blk.span.lo, blk.span.hi, expr_block(blk));\n     }\n \n-    fn parse_dot_or_call_expr() -> @expr {\n+    fn parse_dot_or_call_expr(&self) -> @expr {\n         let b = self.parse_bottom_expr();\n         self.parse_dot_or_call_expr_with(b)\n     }\n \n-    fn permits_call() -> bool {\n+    fn permits_call(&self) -> bool {\n         return *self.restriction != RESTRICT_NO_CALL_EXPRS;\n     }\n \n-    fn parse_dot_or_call_expr_with(e0: @expr) -> @expr {\n+    fn parse_dot_or_call_expr_with(&self, e0: @expr) -> @expr {\n         let mut e = e0;\n         let lo = e.span.lo;\n         let mut hi;\n@@ -1368,7 +1386,7 @@ pub impl Parser {\n \n     // parse an optional separator followed by a kleene-style\n     // repetition token (+ or *).\n-    fn parse_sep_and_zerok() -> (Option<token::Token>, bool) {\n+    fn parse_sep_and_zerok(&self) -> (Option<token::Token>, bool) {\n         if *self.token == token::BINOP(token::STAR)\n             || *self.token == token::BINOP(token::PLUS) {\n             let zerok = *self.token == token::BINOP(token::STAR);\n@@ -1389,7 +1407,7 @@ pub impl Parser {\n     }\n \n     // parse a single token tree from the input.\n-    fn parse_token_tree() -> token_tree {\n+    fn parse_token_tree(&self) -> token_tree {\n         maybe_whole!(deref self, nt_tt);\n \n         fn parse_non_delim_tt_tok(p: &Parser) -> token_tree {\n@@ -1450,32 +1468,32 @@ pub impl Parser {\n                 tt_delim(\n                     vec::append(\n                         // the open delimiter:\n-                        ~[parse_any_tt_tok(&self)],\n+                        ~[parse_any_tt_tok(self)],\n                         vec::append(\n                             self.parse_seq_to_before_end(\n                                 &ket,\n                                 seq_sep_none(),\n                                 |p| p.parse_token_tree()\n                             ),\n                             // the close delimiter:\n-                            ~[parse_any_tt_tok(&self)]\n+                            ~[parse_any_tt_tok(self)]\n                         )\n                     )\n                 )\n             }\n-            _ => parse_non_delim_tt_tok(&self)\n+            _ => parse_non_delim_tt_tok(self)\n         }\n     }\n \n-    fn parse_all_token_trees() -> ~[token_tree] {\n+    fn parse_all_token_trees(&self) -> ~[token_tree] {\n         let mut tts = ~[];\n         while *self.token != token::EOF {\n             tts.push(self.parse_token_tree());\n         }\n         tts\n     }\n \n-    fn parse_matchers() -> ~[matcher] {\n+    fn parse_matchers(&self) -> ~[matcher] {\n         // unification of matchers and token_trees would vastly improve\n         // the interpolation of matchers\n         maybe_whole!(self, nt_matchers);\n@@ -1498,6 +1516,7 @@ pub impl Parser {\n     // Otherwise, `$( ( )` would be a valid matcher, and `$( () )` would be\n     // invalid. It's similar to common::parse_seq.\n     fn parse_matcher_subseq(\n+        &self,\n         name_idx: @mut uint,\n         bra: &token::Token,\n         ket: &token::Token\n@@ -1518,7 +1537,7 @@ pub impl Parser {\n         return ret_val;\n     }\n \n-    fn parse_matcher(name_idx: @mut uint) -> matcher {\n+    fn parse_matcher(&self, name_idx: @mut uint) -> matcher {\n         let lo = self.span.lo;\n \n         let m = if *self.token == token::DOLLAR {\n@@ -1553,7 +1572,7 @@ pub impl Parser {\n     }\n \n \n-    fn parse_prefix_expr() -> @expr {\n+    fn parse_prefix_expr(&self) -> @expr {\n         let lo = self.span.lo;\n         let mut hi;\n \n@@ -1643,12 +1662,12 @@ pub impl Parser {\n     }\n \n     // parse an expression of binops\n-    fn parse_binops() -> @expr {\n+    fn parse_binops(&self) -> @expr {\n         self.parse_more_binops(self.parse_prefix_expr(), 0)\n     }\n \n     // parse an expression of binops of at least min_prec precedence\n-    fn parse_more_binops(lhs: @expr, min_prec: uint) ->\n+    fn parse_more_binops(&self, lhs: @expr, min_prec: uint) ->\n         @expr {\n         if self.expr_is_complete(lhs) { return lhs; }\n         let peeked = copy *self.token;\n@@ -1694,7 +1713,7 @@ pub impl Parser {\n     // parse an assignment expression....\n     // actually, this seems to be the main entry point for\n     // parsing an arbitrary expression.\n-    fn parse_assign_expr() -> @expr {\n+    fn parse_assign_expr(&self) -> @expr {\n         let lo = self.span.lo;\n         let lhs = self.parse_binops();\n         match *self.token {\n@@ -1743,7 +1762,7 @@ pub impl Parser {\n         }\n     }\n \n-    fn parse_if_expr() -> @expr {\n+    fn parse_if_expr(&self) -> @expr {\n         let lo = self.last_span.lo;\n         let cond = self.parse_expr();\n         let thn = self.parse_block();\n@@ -1758,7 +1777,7 @@ pub impl Parser {\n     }\n \n     // `|args| { ... }` like in `do` expressions\n-    fn parse_lambda_block_expr() -> @expr {\n+    fn parse_lambda_block_expr(&self) -> @expr {\n         self.parse_lambda_expr_(\n             || {\n                 match *self.token {\n@@ -1786,13 +1805,16 @@ pub impl Parser {\n     }\n \n     // `|args| expr`\n-    fn parse_lambda_expr() -> @expr {\n+    fn parse_lambda_expr(&self) -> @expr {\n         self.parse_lambda_expr_(|| self.parse_fn_block_decl(),\n                                 || self.parse_expr())\n     }\n \n-    fn parse_lambda_expr_(parse_decl: &fn() -> fn_decl,\n-                          parse_body: &fn() -> @expr) -> @expr {\n+    fn parse_lambda_expr_(\n+        &self,\n+        parse_decl: &fn() -> fn_decl,\n+        parse_body: &fn() -> @expr\n+    ) -> @expr {\n         let lo = self.last_span.lo;\n         let decl = parse_decl();\n         let body = parse_body();\n@@ -1809,7 +1831,7 @@ pub impl Parser {\n                             expr_fn_block(decl, fakeblock));\n     }\n \n-    fn parse_else_expr() -> @expr {\n+    fn parse_else_expr(&self) -> @expr {\n         if self.eat_keyword(&~\"if\") {\n             return self.parse_if_expr();\n         } else {\n@@ -1818,7 +1840,7 @@ pub impl Parser {\n         }\n     }\n \n-    fn parse_sugary_call_expr(keyword: ~str,\n+    fn parse_sugary_call_expr(&self, keyword: ~str,\n                               sugar: CallSugar,\n                               ctor: fn(+v: @expr) -> expr_) -> @expr {\n         let lo = self.last_span;\n@@ -1875,15 +1897,15 @@ pub impl Parser {\n         }\n     }\n \n-    fn parse_while_expr() -> @expr {\n+    fn parse_while_expr(&self) -> @expr {\n         let lo = self.last_span.lo;\n         let cond = self.parse_expr();\n         let body = self.parse_block_no_value();\n         let mut hi = body.span.hi;\n         return self.mk_expr(lo, hi, expr_while(cond, body));\n     }\n \n-    fn parse_loop_expr() -> @expr {\n+    fn parse_loop_expr(&self) -> @expr {\n         // loop headers look like 'loop {' or 'loop unsafe {'\n         let is_loop_header =\n             *self.token == token::LBRACE\n@@ -1923,15 +1945,15 @@ pub impl Parser {\n     }\n \n     // For distingishing between record literals and blocks\n-    fn looking_at_record_literal() -> bool {\n+    fn looking_at_record_literal(&self) -> bool {\n         let lookahead = self.look_ahead(1);\n         *self.token == token::LBRACE &&\n             (self.token_is_keyword(&~\"mut\", &lookahead) ||\n              (is_plain_ident(&lookahead) &&\n               self.look_ahead(2) == token::COLON))\n     }\n \n-    fn parse_record_literal() -> expr_ {\n+    fn parse_record_literal(&self) -> expr_ {\n         self.expect(&token::LBRACE);\n         let mut fields = ~[self.parse_field(token::COLON)];\n         let mut base = None;\n@@ -1959,7 +1981,7 @@ pub impl Parser {\n         return expr_rec(fields, base);\n     }\n \n-    fn parse_match_expr() -> @expr {\n+    fn parse_match_expr(&self) -> @expr {\n         let lo = self.last_span.lo;\n         let discriminant = self.parse_expr();\n         self.expect(&token::LBRACE);\n@@ -2000,20 +2022,20 @@ pub impl Parser {\n     }\n \n     // parse an expression\n-    fn parse_expr() -> @expr {\n+    fn parse_expr(&self) -> @expr {\n         return self.parse_expr_res(UNRESTRICTED);\n     }\n \n     // parse an expression, subject to the given restriction\n-    fn parse_expr_res(r: restriction) -> @expr {\n+    fn parse_expr_res(&self, r: restriction) -> @expr {\n         let old = *self.restriction;\n         *self.restriction = r;\n         let e = self.parse_assign_expr();\n         *self.restriction = old;\n         return e;\n     }\n \n-    fn parse_initializer() -> Option<@expr> {\n+    fn parse_initializer(&self) -> Option<@expr> {\n         match *self.token {\n           token::EQ => {\n             self.bump();\n@@ -2031,7 +2053,7 @@ pub impl Parser {\n         }\n     }\n \n-    fn parse_pats() -> ~[@pat] {\n+    fn parse_pats(&self) -> ~[@pat] {\n         let mut pats = ~[];\n         loop {\n             pats.push(self.parse_pat(true));\n@@ -2040,7 +2062,10 @@ pub impl Parser {\n         };\n     }\n \n-    fn parse_pat_vec_elements(refutable: bool) -> (~[@pat], Option<@pat>) {\n+    fn parse_pat_vec_elements(\n+        &self,\n+        refutable: bool\n+    ) -> (~[@pat], Option<@pat>) {\n         let mut elements = ~[];\n         let mut tail = None;\n         let mut first = true;\n@@ -2073,7 +2098,7 @@ pub impl Parser {\n         return (elements, tail);\n     }\n \n-    fn parse_pat_fields(refutable: bool) -> (~[ast::field_pat], bool) {\n+    fn parse_pat_fields(&self, refutable: bool) -> (~[ast::field_pat], bool) {\n         let mut fields = ~[];\n         let mut etc = false;\n         let mut first = true;\n@@ -2120,7 +2145,7 @@ pub impl Parser {\n         return (fields, etc);\n     }\n \n-    fn parse_pat(refutable: bool) -> @pat {\n+    fn parse_pat(&self, refutable: bool) -> @pat {\n         maybe_whole!(self, nt_pat);\n \n         let lo = self.span.lo;\n@@ -2330,7 +2355,7 @@ pub impl Parser {\n         @ast::pat { id: self.get_id(), node: pat, span: mk_sp(lo, hi) }\n     }\n \n-    fn parse_pat_ident(refutable: bool,\n+    fn parse_pat_ident(&self, refutable: bool,\n                        binding_mode: ast::binding_mode) -> ast::pat_ {\n         if !is_plain_ident(&*self.token) {\n             self.span_fatal(\n@@ -2357,7 +2382,7 @@ pub impl Parser {\n         pat_ident(binding_mode, name, sub)\n     }\n \n-    fn parse_local(is_mutbl: bool,\n+    fn parse_local(&self, is_mutbl: bool,\n                    allow_init: bool) -> @local {\n         let lo = self.span.lo;\n         let pat = self.parse_pat(false);\n@@ -2381,7 +2406,7 @@ pub impl Parser {\n         )\n     }\n \n-    fn parse_let() -> @decl {\n+    fn parse_let(&self) -> @decl {\n         let is_mutbl = self.eat_keyword(&~\"mut\");\n         let lo = self.span.lo;\n         let mut locals = ~[self.parse_local(is_mutbl, true)];\n@@ -2392,7 +2417,7 @@ pub impl Parser {\n     }\n \n     /* assumes \"let\" token has already been consumed */\n-    fn parse_instance_var(pr: visibility) -> @struct_field {\n+    fn parse_instance_var(&self, pr: visibility) -> @struct_field {\n         let mut is_mutbl = struct_immutable;\n         let lo = self.span.lo;\n         if self.eat_keyword(&~\"mut\") {\n@@ -2411,7 +2436,7 @@ pub impl Parser {\n         })\n     }\n \n-    fn parse_stmt(+first_item_attrs: ~[attribute]) -> @stmt {\n+    fn parse_stmt(&self, +first_item_attrs: ~[attribute]) -> @stmt {\n         maybe_whole!(self, nt_stmt);\n \n         fn check_expected_item(p: &Parser, current_attrs: &[attribute]) {\n@@ -2423,15 +2448,15 @@ pub impl Parser {\n \n         let lo = self.span.lo;\n         if self.is_keyword(&~\"let\") {\n-            check_expected_item(&self, first_item_attrs);\n+            check_expected_item(self, first_item_attrs);\n             self.expect_keyword(&~\"let\");\n             let decl = self.parse_let();\n             return @spanned(lo, decl.span.hi, stmt_decl(decl, self.get_id()));\n         } else if is_ident(&*self.token)\n             && !self.is_any_keyword(&copy *self.token)\n             && self.look_ahead(1) == token::NOT {\n \n-            check_expected_item(&self, first_item_attrs);\n+            check_expected_item(self, first_item_attrs);\n \n             // Potential trouble: if we allow macros with paths instead of\n             // idents, we'd need to look ahead past the whole path here...\n@@ -2487,26 +2512,26 @@ pub impl Parser {\n               iovi_none() => { /* fallthrough */ }\n             }\n \n-            check_expected_item(&self, item_attrs);\n+            check_expected_item(self, item_attrs);\n \n             // Remainder are line-expr stmts.\n             let e = self.parse_expr_res(RESTRICT_STMT_EXPR);\n             return @spanned(lo, e.span.hi, stmt_expr(e, self.get_id()));\n         }\n     }\n \n-    fn expr_is_complete(e: @expr) -> bool {\n+    fn expr_is_complete(&self, e: @expr) -> bool {\n         return *self.restriction == RESTRICT_STMT_EXPR &&\n             !classify::expr_requires_semi_to_be_stmt(e);\n     }\n \n-    fn parse_block() -> blk {\n+    fn parse_block(&self) -> blk {\n         let (attrs, blk) = self.parse_inner_attrs_and_block(false);\n         assert vec::is_empty(attrs);\n         return blk;\n     }\n \n-    fn parse_inner_attrs_and_block(parse_attrs: bool)\n+    fn parse_inner_attrs_and_block(&self, parse_attrs: bool)\n         -> (~[attribute], blk) {\n \n         maybe_whole!(pair_empty self, nt_block);\n@@ -2526,12 +2551,12 @@ pub impl Parser {\n         }\n         self.expect(&token::LBRACE);\n         let (inner, next) =\n-            maybe_parse_inner_attrs_and_next(&self, parse_attrs);\n+            maybe_parse_inner_attrs_and_next(self, parse_attrs);\n \n         (inner, self.parse_block_tail_(lo, default_blk, next))\n     }\n \n-    fn parse_block_no_value() -> blk {\n+    fn parse_block_no_value(&self) -> blk {\n         // We parse blocks that cannot have a value the same as any other\n         // block; the type checker will make sure that the tail expression (if\n         // any) has unit type.\n@@ -2542,11 +2567,11 @@ pub impl Parser {\n     // I guess that also means \"already parsed the 'impure'\" if\n     // necessary, and this should take a qualifier.\n     // some blocks start with \"#{\"...\n-    fn parse_block_tail(lo: BytePos, s: blk_check_mode) -> blk {\n+    fn parse_block_tail(&self, lo: BytePos, s: blk_check_mode) -> blk {\n         self.parse_block_tail_(lo, s, ~[])\n     }\n \n-    fn parse_block_tail_(lo: BytePos, s: blk_check_mode,\n+    fn parse_block_tail_(&self, lo: BytePos, s: blk_check_mode,\n                          +first_item_attrs: ~[attribute]) -> blk {\n         let mut stmts = ~[];\n         let mut expr = None;\n@@ -2651,7 +2676,7 @@ pub impl Parser {\n         spanned(lo, hi, bloc)\n     }\n \n-    fn mk_ty_path(i: ident) -> @Ty {\n+    fn mk_ty_path(&self, i: ident) -> @Ty {\n         @Ty {\n             id: self.get_id(),\n             node: ty_path(\n@@ -2661,7 +2686,7 @@ pub impl Parser {\n         }\n     }\n \n-    fn parse_optional_purity() -> ast::purity {\n+    fn parse_optional_purity(&self) -> ast::purity {\n         if self.eat_keyword(&~\"pure\") {\n             ast::pure_fn\n         } else if self.eat_keyword(&~\"unsafe\") {\n@@ -2671,11 +2696,11 @@ pub impl Parser {\n         }\n     }\n \n-    fn parse_optional_onceness() -> ast::Onceness {\n+    fn parse_optional_onceness(&self) -> ast::Onceness {\n         if self.eat_keyword(&~\"once\") { ast::Once } else { ast::Many }\n     }\n \n-    fn parse_optional_ty_param_bounds() -> @OptVec<TyParamBound> {\n+    fn parse_optional_ty_param_bounds(&self) -> @OptVec<TyParamBound> {\n         if !self.eat(&token::COLON) {\n             return @opt_vec::Empty;\n         }\n@@ -2740,13 +2765,13 @@ pub impl Parser {\n         return @result;\n     }\n \n-    fn parse_ty_param() -> TyParam {\n+    fn parse_ty_param(&self) -> TyParam {\n         let ident = self.parse_ident();\n         let bounds = self.parse_optional_ty_param_bounds();\n         ast::TyParam { ident: ident, id: self.get_id(), bounds: bounds }\n     }\n \n-    fn parse_generics() -> ast::Generics {\n+    fn parse_generics(&self) -> ast::Generics {\n         if self.eat(&token::LT) {\n             let lifetimes = self.parse_lifetimes();\n             let ty_params = self.parse_seq_to_gt(\n@@ -2758,23 +2783,23 @@ pub impl Parser {\n         }\n     }\n \n-    fn parse_generic_values() -> ~[@Ty] {\n+    fn parse_generic_values(&self) -> ~[@Ty] {\n         if !self.eat(&token::LT) {\n             ~[]\n         } else {\n             self.parse_generic_values_after_lt()\n         }\n     }\n \n-    fn parse_generic_values_after_lt() -> ~[@Ty] {\n+    fn parse_generic_values_after_lt(&self) -> ~[@Ty] {\n         let _lifetimes = self.parse_lifetimes();\n         let result = self.parse_seq_to_gt(\n             Some(token::COMMA),\n             |p| p.parse_ty(false));\n         opt_vec::take_vec(result)\n     }\n \n-    fn parse_fn_decl(parse_arg_fn: fn(&Parser) -> arg_or_capture_item)\n+    fn parse_fn_decl(&self, parse_arg_fn: fn(&Parser) -> arg_or_capture_item)\n         -> fn_decl\n     {\n         let args_or_capture_items: ~[arg_or_capture_item] =\n@@ -2795,15 +2820,15 @@ pub impl Parser {\n         }\n     }\n \n-    fn is_self_ident() -> bool {\n+    fn is_self_ident(&self) -> bool {\n         match *self.token {\n           token::IDENT(id, false) if id == special_idents::self_\n             => true,\n           _ => false\n         }\n     }\n \n-    fn expect_self_ident() {\n+    fn expect_self_ident(&self) {\n         if !self.is_self_ident() {\n             self.fatal(\n                 fmt!(\n@@ -2816,6 +2841,7 @@ pub impl Parser {\n     }\n \n     fn parse_fn_decl_with_self(\n+        &self,\n         parse_arg_fn:\n         fn(&Parser) -> arg_or_capture_item\n     ) -> (self_ty, fn_decl) {\n@@ -2845,13 +2871,13 @@ pub impl Parser {\n         let lo = self.span.lo;\n         let self_ty = match *self.token {\n           token::BINOP(token::AND) => {\n-            maybe_parse_self_ty(sty_region, &self)\n+            maybe_parse_self_ty(sty_region, self)\n           }\n           token::AT => {\n-            maybe_parse_self_ty(sty_box, &self)\n+            maybe_parse_self_ty(sty_box, self)\n           }\n           token::TILDE => {\n-            maybe_parse_self_ty(sty_uniq, &self)\n+            maybe_parse_self_ty(sty_uniq, self)\n           }\n           token::IDENT(*) if self.is_self_ident() => {\n             self.bump();\n@@ -2912,7 +2938,7 @@ pub impl Parser {\n         (spanned(lo, hi, self_ty), fn_decl)\n     }\n \n-    fn parse_fn_block_decl() -> fn_decl {\n+    fn parse_fn_block_decl(&self) -> fn_decl {\n         let inputs_captures = {\n             if self.eat(&token::OROR) {\n                 ~[]\n@@ -2938,13 +2964,13 @@ pub impl Parser {\n         }\n     }\n \n-    fn parse_fn_header() -> (ident, ast::Generics) {\n+    fn parse_fn_header(&self) -> (ident, ast::Generics) {\n         let id = self.parse_value_ident();\n         let generics = self.parse_generics();\n         (id, generics)\n     }\n \n-    fn mk_item(+lo: BytePos, +hi: BytePos, +ident: ident,\n+    fn mk_item(&self, +lo: BytePos, +hi: BytePos, +ident: ident,\n                +node: item_, vis: visibility,\n                +attrs: ~[attribute]) -> @item {\n         @ast::item { ident: ident,\n@@ -2955,18 +2981,18 @@ pub impl Parser {\n                      span: mk_sp(lo, hi) }\n     }\n \n-    fn parse_item_fn(purity: purity) -> item_info {\n+    fn parse_item_fn(&self, purity: purity) -> item_info {\n         let (ident, generics) = self.parse_fn_header();\n         let decl = self.parse_fn_decl(|p| p.parse_arg());\n         let (inner_attrs, body) = self.parse_inner_attrs_and_block(true);\n         (ident, item_fn(decl, purity, generics, body), Some(inner_attrs))\n     }\n \n-    fn parse_method_name() -> ident {\n+    fn parse_method_name(&self) -> ident {\n         self.parse_value_ident()\n     }\n \n-    fn parse_method() -> @method {\n+    fn parse_method(&self) -> @method {\n         let attrs = self.parse_outer_attributes();\n         let lo = self.span.lo;\n \n@@ -3001,7 +3027,7 @@ pub impl Parser {\n         }\n     }\n \n-    fn parse_item_trait() -> item_info {\n+    fn parse_item_trait(&self) -> item_info {\n         let ident = self.parse_ident();\n         self.parse_region_param();\n         let tps = self.parse_generics();\n@@ -3022,7 +3048,7 @@ pub impl Parser {\n     // Parses two variants (with the region/type params always optional):\n     //    impl<T> Foo { ... }\n     //    impl<T> ToStr for ~[T] { ... }\n-    fn parse_item_impl(visibility: ast::visibility) -> item_info {\n+    fn parse_item_impl(&self, visibility: ast::visibility) -> item_info {\n         fn wrap_path(p: &Parser, pt: @path) -> @Ty {\n             @Ty {\n                 id: p.get_id(),\n@@ -3083,22 +3109,22 @@ pub impl Parser {\n         (ident, item_impl(generics, opt_trait, ty, meths), None)\n     }\n \n-    fn parse_trait_ref() -> @trait_ref {\n+    fn parse_trait_ref(&self) -> @trait_ref {\n         @ast::trait_ref {\n             path: self.parse_path_with_tps(false),\n             ref_id: self.get_id(),\n         }\n     }\n \n-    fn parse_trait_ref_list(ket: &token::Token) -> ~[@trait_ref] {\n+    fn parse_trait_ref_list(&self, ket: &token::Token) -> ~[@trait_ref] {\n         self.parse_seq_to_before_end(\n             ket,\n             seq_sep_none(),\n             |p| p.parse_trait_ref()\n         )\n     }\n \n-    fn parse_item_struct() -> item_info {\n+    fn parse_item_struct(&self) -> item_info {\n         let class_name = self.parse_value_ident();\n         self.parse_region_param();\n         let generics = self.parse_generics();\n@@ -3188,14 +3214,14 @@ pub impl Parser {\n          None)\n     }\n \n-    fn token_is_pound_or_doc_comment(++tok: token::Token) -> bool {\n+    fn token_is_pound_or_doc_comment(&self, ++tok: token::Token) -> bool {\n         match tok {\n             token::POUND | token::DOC_COMMENT(_) => true,\n             _ => false\n         }\n     }\n \n-    fn parse_single_class_item(vis: visibility) -> @struct_field {\n+    fn parse_single_class_item(&self, vis: visibility) -> @struct_field {\n         if self.eat_obsolete_ident(\"let\") {\n             self.obsolete(*self.last_span, ObsoleteLet);\n         }\n@@ -3223,13 +3249,13 @@ pub impl Parser {\n         a_var\n     }\n \n-    fn parse_dtor(+attrs: ~[attribute]) -> class_contents {\n+    fn parse_dtor(&self, +attrs: ~[attribute]) -> class_contents {\n         let lo = self.last_span.lo;\n         let body = self.parse_block();\n         dtor_decl(body, attrs, mk_sp(lo, self.last_span.hi))\n     }\n \n-    fn parse_class_item() -> class_contents {\n+    fn parse_class_item(&self) -> class_contents {\n \n         if self.try_parse_obsolete_priv_section() {\n             return members(~[]);\n@@ -3257,18 +3283,18 @@ pub impl Parser {\n         }\n     }\n \n-    fn parse_visibility() -> visibility {\n+    fn parse_visibility(&self) -> visibility {\n         if self.eat_keyword(&~\"pub\") { public }\n         else if self.eat_keyword(&~\"priv\") { private }\n         else { inherited }\n     }\n-    fn parse_staticness() -> bool {\n+    fn parse_staticness(&self) -> bool {\n         self.eat_keyword(&~\"static\")\n     }\n \n     // given a termination token and a vector of already-parsed\n     // attributes (of length 0 or 1), parse all of the items in a module\n-    fn parse_mod_items(term: token::Token,\n+    fn parse_mod_items(&self, term: token::Token,\n                        +first_item_attrs: ~[attribute]) -> _mod {\n         // parse all of the items up to closing or an attribute.\n         // view items are legal here.\n@@ -3326,7 +3352,7 @@ pub impl Parser {\n         ast::_mod { view_items: view_items, items: items }\n     }\n \n-    fn parse_item_const() -> item_info {\n+    fn parse_item_const(&self) -> item_info {\n         let id = self.parse_value_ident();\n         self.expect(&token::COLON);\n         let ty = self.parse_ty(false);\n@@ -3336,7 +3362,7 @@ pub impl Parser {\n         (id, item_const(ty, e), None)\n     }\n \n-    fn parse_item_mod(outer_attrs: ~[ast::attribute]) -> item_info {\n+    fn parse_item_mod(&self, outer_attrs: ~[ast::attribute]) -> item_info {\n         let id_span = *self.span;\n         let id = self.parse_ident();\n         let info_ = if *self.token == token::SEMI {\n@@ -3387,7 +3413,7 @@ pub impl Parser {\n         }\n     }\n \n-    fn push_mod_path(id: ident, attrs: ~[ast::attribute]) {\n+    fn push_mod_path(&self, id: ident, attrs: ~[ast::attribute]) {\n         let default_path = self.sess.interner.get(id);\n         let file_path = match ::attr::first_attr_value_str_by_name(\n             attrs, ~\"path\") {\n@@ -3398,11 +3424,11 @@ pub impl Parser {\n         self.mod_path_stack.push(file_path)\n     }\n \n-    fn pop_mod_path() {\n+    fn pop_mod_path(&self) {\n         self.mod_path_stack.pop();\n     }\n \n-    fn eval_src_mod(id: ast::ident,\n+    fn eval_src_mod(&self, id: ast::ident,\n                     outer_attrs: ~[ast::attribute],\n                     id_sp: span) -> (ast::item_, ~[ast::attribute]) {\n \n@@ -3427,7 +3453,7 @@ pub impl Parser {\n                                     outer_attrs, id_sp)\n     }\n \n-    fn eval_src_mod_from_path(prefix: Path, +path: Path,\n+    fn eval_src_mod_from_path(&self, prefix: Path, +path: Path,\n                               outer_attrs: ~[ast::attribute],\n                               id_sp: span\n                              ) -> (ast::item_, ~[ast::attribute]) {\n@@ -3458,7 +3484,7 @@ pub impl Parser {\n         }\n     }\n \n-    fn parse_item_foreign_fn( +attrs: ~[attribute]) -> @foreign_item {\n+    fn parse_item_foreign_fn(&self,  +attrs: ~[attribute]) -> @foreign_item {\n         let lo = self.span.lo;\n         let vis = self.parse_visibility();\n         let purity = self.parse_fn_purity();\n@@ -3474,7 +3500,7 @@ pub impl Parser {\n                              vis: vis }\n     }\n \n-    fn parse_item_foreign_const(vis: ast::visibility,\n+    fn parse_item_foreign_const(&self, vis: ast::visibility,\n                                 +attrs: ~[attribute]) -> @foreign_item {\n         let lo = self.span.lo;\n         self.expect_keyword(&~\"const\");\n@@ -3491,7 +3517,7 @@ pub impl Parser {\n                              vis: vis }\n     }\n \n-    fn parse_fn_purity() -> purity {\n+    fn parse_fn_purity(&self) -> purity {\n         if self.eat_keyword(&~\"fn\") { impure_fn }\n         else if self.eat_keyword(&~\"pure\") {\n             self.expect_keyword(&~\"fn\");\n@@ -3503,7 +3529,7 @@ pub impl Parser {\n         else { self.unexpected(); }\n     }\n \n-    fn parse_foreign_item(+attrs: ~[attribute]) -> @foreign_item {\n+    fn parse_foreign_item(&self, +attrs: ~[attribute]) -> @foreign_item {\n         let vis = self.parse_visibility();\n         if self.is_keyword(&~\"const\") {\n             self.parse_item_foreign_const(vis, attrs)\n@@ -3512,7 +3538,7 @@ pub impl Parser {\n         }\n     }\n \n-    fn parse_foreign_mod_items(sort: ast::foreign_mod_sort,\n+    fn parse_foreign_mod_items(&self, sort: ast::foreign_mod_sort,\n                                +abi: ast::ident,\n                                +first_item_attrs: ~[attribute])\n                             -> foreign_mod {\n@@ -3542,7 +3568,7 @@ pub impl Parser {\n         }\n     }\n \n-    fn parse_item_foreign_mod(lo: BytePos,\n+    fn parse_item_foreign_mod(&self, lo: BytePos,\n                               visibility: visibility,\n                               attrs: ~[attribute],\n                               items_allowed: bool)\n@@ -3629,13 +3655,13 @@ pub impl Parser {\n         })\n     }\n \n-    fn parse_type_decl() -> (BytePos, ident) {\n+    fn parse_type_decl(&self) -> (BytePos, ident) {\n         let lo = self.last_span.lo;\n         let id = self.parse_ident();\n         (lo, id)\n     }\n \n-    fn parse_item_type() -> item_info {\n+    fn parse_item_type(&self) -> item_info {\n         let (_, ident) = self.parse_type_decl();\n         self.parse_region_param();\n         let tps = self.parse_generics();\n@@ -3645,13 +3671,13 @@ pub impl Parser {\n         (ident, item_ty(ty, tps), None)\n     }\n \n-    fn parse_region_param() {\n+    fn parse_region_param(&self) {\n         if self.eat(&token::BINOP(token::SLASH)) {\n             self.expect(&token::BINOP(token::AND));\n         }\n     }\n \n-    fn parse_struct_def() -> @struct_def {\n+    fn parse_struct_def(&self) -> @struct_def {\n         let mut the_dtor: Option<(blk, ~[attribute], codemap::span)> = None;\n         let mut fields: ~[@struct_field] = ~[];\n         while *self.token != token::RBRACE {\n@@ -3694,7 +3720,7 @@ pub impl Parser {\n         };\n     }\n \n-    fn parse_enum_def(generics: &ast::Generics) -> enum_def {\n+    fn parse_enum_def(&self, generics: &ast::Generics) -> enum_def {\n         let mut variants = ~[];\n         let mut all_nullary = true, have_disr = false;\n         let mut common_fields = None;\n@@ -3776,7 +3802,7 @@ pub impl Parser {\n         enum_def(ast::enum_def_ { variants: variants, common: common_fields })\n     }\n \n-    fn parse_item_enum() -> item_info {\n+    fn parse_item_enum(&self) -> item_info {\n         let id = self.parse_ident();\n         self.parse_region_param();\n         let generics = self.parse_generics();\n@@ -3812,7 +3838,7 @@ pub impl Parser {\n         (id, item_enum(enum_definition, generics), None)\n     }\n \n-    fn parse_fn_ty_sigil() -> Option<Sigil> {\n+    fn parse_fn_ty_sigil(&self) -> Option<Sigil> {\n         match *self.token {\n             token::AT => {\n                 self.bump();\n@@ -3832,7 +3858,7 @@ pub impl Parser {\n         }\n     }\n \n-    fn fn_expr_lookahead(tok: token::Token) -> bool {\n+    fn fn_expr_lookahead(&self, tok: token::Token) -> bool {\n         match tok {\n           token::LPAREN | token::AT | token::TILDE | token::BINOP(_) => true,\n           _ => false\n@@ -3841,13 +3867,16 @@ pub impl Parser {\n \n     // parse one of the items or view items allowed by the\n     // flags; on failure, return iovi_none.\n-    fn parse_item_or_view_item(+attrs: ~[attribute], items_allowed: bool,\n-                               foreign_items_allowed: bool,\n-                               macros_allowed: bool)\n-                            -> item_or_view_item {\n+    fn parse_item_or_view_item(\n+        &self,\n+        +attrs: ~[attribute],\n+        items_allowed: bool,\n+        foreign_items_allowed: bool,\n+        macros_allowed: bool\n+    ) -> item_or_view_item {\n         assert items_allowed != foreign_items_allowed;\n \n-        maybe_whole!(iovi self,nt_item);\n+        maybe_whole!(iovi self, nt_item);\n         let lo = self.span.lo;\n \n         let visibility;\n@@ -4015,7 +4044,7 @@ pub impl Parser {\n         };\n     }\n \n-    fn parse_item(+attrs: ~[attribute]) -> Option<@ast::item> {\n+    fn parse_item(&self, +attrs: ~[attribute]) -> Option<@ast::item> {\n         match self.parse_item_or_view_item(attrs, true, false, true) {\n             iovi_none =>\n                 None,\n@@ -4028,11 +4057,11 @@ pub impl Parser {\n         }\n     }\n \n-    fn parse_use() -> view_item_ {\n+    fn parse_use(&self) -> view_item_ {\n         return view_item_use(self.parse_view_paths());\n     }\n \n-    fn parse_view_path() -> @view_path {\n+    fn parse_view_path(&self) -> @view_path {\n         let lo = self.span.lo;\n \n         let namespace;\n@@ -4121,7 +4150,7 @@ pub impl Parser {\n                      view_path_simple(last, path, namespace, self.get_id()));\n     }\n \n-    fn parse_view_paths() -> ~[@view_path] {\n+    fn parse_view_paths(&self) -> ~[@view_path] {\n         let mut vp = ~[self.parse_view_path()];\n         while *self.token == token::COMMA {\n             self.bump();\n@@ -4130,7 +4159,7 @@ pub impl Parser {\n         return vp;\n     }\n \n-    fn is_view_item() -> bool {\n+    fn is_view_item(&self) -> bool {\n         let tok, next_tok;\n         if !self.is_keyword(&~\"pub\") && !self.is_keyword(&~\"priv\") {\n             tok = copy *self.token;\n@@ -4145,7 +4174,11 @@ pub impl Parser {\n     }\n \n     // parse a view item.\n-    fn parse_view_item(+attrs: ~[attribute], vis: visibility) -> @view_item {\n+    fn parse_view_item(\n+        &self,\n+        +attrs: ~[attribute],\n+        vis: visibility\n+    ) -> @view_item {\n         let lo = self.span.lo;\n         let node = if self.eat_keyword(&~\"use\") {\n             self.parse_use()\n@@ -4166,7 +4199,7 @@ pub impl Parser {\n \n     // Parses a sequence of items. Stops when it finds program\n     // text that can't be parsed as an item\n-    fn parse_items_and_view_items(+first_item_attrs: ~[attribute],\n+    fn parse_items_and_view_items(&self, +first_item_attrs: ~[attribute],\n                                   mode: view_item_parse_mode,\n                                   macros_allowed: bool)\n                                 -> ParsedItemsAndViewItems {\n@@ -4230,7 +4263,7 @@ pub impl Parser {\n     }\n \n     // Parses a source module as a crate\n-    fn parse_crate_mod(_cfg: crate_cfg) -> @crate {\n+    fn parse_crate_mod(&self, _cfg: crate_cfg) -> @crate {\n         let lo = self.span.lo;\n         // parse the crate's inner attrs, maybe (oops) one\n         // of the attrs of an item:\n@@ -4244,7 +4277,7 @@ pub impl Parser {\n                                config: copy self.cfg })\n     }\n \n-    fn parse_str() -> @~str {\n+    fn parse_str(&self) -> @~str {\n         match *self.token {\n           token::LIT_STR(s) => { self.bump(); self.id_to_str(s) }\n           _ =>  self.fatal(~\"expected string literal\")"}, {"sha": "f86d7c7f13540be646db3d657eb8b060b44cc658", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4a73426aa22a9a5771de1719a38670f4b7200e5d/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a73426aa22a9a5771de1719a38670f4b7200e5d/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=4a73426aa22a9a5771de1719a38670f4b7200e5d", "patch": "@@ -359,16 +359,16 @@ pub struct ident_interner {\n }\n \n pub impl ident_interner {\n-    fn intern(val: @~str) -> ast::ident {\n+    fn intern(&self, val: @~str) -> ast::ident {\n         ast::ident { repr: self.interner.intern(val) }\n     }\n-    fn gensym(val: @~str) -> ast::ident {\n+    fn gensym(&self, val: @~str) -> ast::ident {\n         ast::ident { repr: self.interner.gensym(val) }\n     }\n-    pure fn get(idx: ast::ident) -> @~str {\n+    pure fn get(&self, idx: ast::ident) -> @~str {\n         self.interner.get(idx.repr)\n     }\n-    fn len() -> uint {\n+    fn len(&self) -> uint {\n         self.interner.len()\n     }\n }"}]}