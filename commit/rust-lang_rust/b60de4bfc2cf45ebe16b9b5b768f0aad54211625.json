{"sha": "b60de4bfc2cf45ebe16b9b5b768f0aad54211625", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI2MGRlNGJmYzJjZjQ1ZWJlMTZiOWI1Yjc2OGYwYWFkNTQyMTE2MjU=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-12-12T16:09:24Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-12-15T15:23:48Z"}, "message": "Emit warning when lifetime names are shadowed.\n\nThis is not technically a [breaking-change], but it will be soon, so\nyou should update your code. Typically, shadowing is accidental, and\nthe shadowing lifetime can simply be removed. This frequently occurs\nin constructor patterns:\n\n```rust\n// Old:\nimpl<'a> SomeStruct<'a> { fn new<'a>(..) -> SomeStruct<'a> { ... } }\n\n// Should be:\nimpl<'a> SomeStruct<'a> { fn new(..) -> SomeStruct<'a> { ... } }\n```\n\nOtherwise, you should rename the inner lifetime to something\nelse. Note though that lifetime elision frequently applies:\n\n```rust\n// Old\nimpl<'a> SomeStruct<'a> {\n    fn get<'a>(x: &'a self) -> &'a T { &self.field }\n}\n\n// Should be:\nimpl<'a> SomeStruct<'a> {\n    fn get(x: &self) -> &T { &self.field }\n}\n``", "tree": {"sha": "5fcc550e359758bb9737a905ac91b685b165e6a4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5fcc550e359758bb9737a905ac91b685b165e6a4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b60de4bfc2cf45ebe16b9b5b768f0aad54211625", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b60de4bfc2cf45ebe16b9b5b768f0aad54211625", "html_url": "https://github.com/rust-lang/rust/commit/b60de4bfc2cf45ebe16b9b5b768f0aad54211625", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b60de4bfc2cf45ebe16b9b5b768f0aad54211625/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ef0bc464af110d24d4663fbe51eca3646a897308", "url": "https://api.github.com/repos/rust-lang/rust/commits/ef0bc464af110d24d4663fbe51eca3646a897308", "html_url": "https://github.com/rust-lang/rust/commit/ef0bc464af110d24d4663fbe51eca3646a897308"}], "stats": {"total": 197, "additions": 144, "deletions": 53}, "files": [{"sha": "1923142be9e3fcb9b9de509dc50d7bb85d5ea3a1", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 101, "deletions": 53, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/b60de4bfc2cf45ebe16b9b5b768f0aad54211625/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b60de4bfc2cf45ebe16b9b5b768f0aad54211625/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=b60de4bfc2cf45ebe16b9b5b768f0aad54211625", "patch": "@@ -90,48 +90,51 @@ pub fn krate(sess: &Session, krate: &ast::Crate, def_map: &DefMap) -> NamedRegio\n \n impl<'a, 'v> Visitor<'v> for LifetimeContext<'a> {\n     fn visit_item(&mut self, item: &ast::Item) {\n-        match item.node {\n-            ast::ItemFn(..) => {\n-                // Fn lifetimes get added in visit_fn below:\n-                self.with(RootScope, |this| visit::walk_item(this, item));\n-            }\n-            ast::ItemMod(..) |\n-            ast::ItemMac(..) |\n-            ast::ItemForeignMod(..) |\n-            ast::ItemStatic(..) |\n-            ast::ItemConst(..) => {\n-                // These sorts of items have no lifetime parameters at all.\n-                self.with(RootScope, |this| visit::walk_item(this, item));\n-            }\n-            ast::ItemTy(_, ref generics) |\n-            ast::ItemEnum(_, ref generics) |\n-            ast::ItemStruct(_, ref generics) |\n-            ast::ItemTrait(_, ref generics, _, _, _) => {\n-                // These kinds of items have only early bound lifetime parameters.\n-                let lifetimes = &generics.lifetimes;\n-                self.with(EarlyScope(subst::TypeSpace, lifetimes, &ROOT_SCOPE), |this| {\n-                    this.check_lifetime_defs(lifetimes);\n+        // Items always introduce a new root scope\n+        self.with(RootScope, |_, this| {\n+            match item.node {\n+                ast::ItemFn(..) => {\n+                    // Fn lifetimes get added in visit_fn below:\n                     visit::walk_item(this, item);\n-                });\n-            }\n-            ast::ItemImpl(_, ref generics, _, _, _) => {\n-                // Impls have both early- and late-bound lifetimes.\n-                self.visit_early_late(subst::TypeSpace, generics, |this| {\n-                    this.check_lifetime_defs(&generics.lifetimes);\n+                }\n+                ast::ItemMod(..) |\n+                ast::ItemMac(..) |\n+                ast::ItemForeignMod(..) |\n+                ast::ItemStatic(..) |\n+                ast::ItemConst(..) => {\n+                    // These sorts of items have no lifetime parameters at all.\n                     visit::walk_item(this, item);\n-                })\n+                }\n+                ast::ItemTy(_, ref generics) |\n+                ast::ItemEnum(_, ref generics) |\n+                ast::ItemStruct(_, ref generics) |\n+                ast::ItemTrait(_, ref generics, _, _, _) => {\n+                    // These kinds of items have only early bound lifetime parameters.\n+                    let lifetimes = &generics.lifetimes;\n+                    let early_scope = EarlyScope(subst::TypeSpace, lifetimes, &ROOT_SCOPE);\n+                    this.with(early_scope, |old_scope, this| {\n+                        this.check_lifetime_defs(old_scope, lifetimes);\n+                        visit::walk_item(this, item);\n+                    });\n+                }\n+                ast::ItemImpl(_, ref generics, _, _, _) => {\n+                    // Impls have both early- and late-bound lifetimes.\n+                    this.visit_early_late(subst::TypeSpace, generics, |this| {\n+                        visit::walk_item(this, item);\n+                    })\n+                }\n             }\n-        }\n+        });\n     }\n \n     fn visit_fn(&mut self, fk: visit::FnKind<'v>, fd: &'v ast::FnDecl,\n                 b: &'v ast::Block, s: Span, _: ast::NodeId) {\n         match fk {\n             visit::FkItemFn(_, generics, _, _) |\n             visit::FkMethod(_, generics, _) => {\n-                self.visit_early_late(\n-                    subst::FnSpace, generics,\n-                    |this| visit::walk_fn(this, fk, fd, b, s))\n+                self.visit_early_late(subst::FnSpace, generics, |this| {\n+                    visit::walk_fn(this, fk, fd, b, s)\n+                })\n             }\n             visit::FkFnBlock(..) => {\n                 visit::walk_fn(self, fk, fd, b, s)\n@@ -145,8 +148,8 @@ impl<'a, 'v> Visitor<'v> for LifetimeContext<'a> {\n                 // Careful, the bounds on a closure/proc are *not* within its binder.\n                 visit::walk_ty_param_bounds_helper(self, &c.bounds);\n                 visit::walk_lifetime_decls_helper(self, &c.lifetimes);\n-                self.with(LateScope(&c.lifetimes, self.scope), |this| {\n-                    this.check_lifetime_defs(&c.lifetimes);\n+                self.with(LateScope(&c.lifetimes, self.scope), |old_scope, this| {\n+                    this.check_lifetime_defs(old_scope, &c.lifetimes);\n                     for argument in c.decl.inputs.iter() {\n                         this.visit_ty(&*argument.ty)\n                     }\n@@ -155,10 +158,10 @@ impl<'a, 'v> Visitor<'v> for LifetimeContext<'a> {\n             }\n             ast::TyBareFn(ref c) => {\n                 visit::walk_lifetime_decls_helper(self, &c.lifetimes);\n-                self.with(LateScope(&c.lifetimes, self.scope), |this| {\n+                self.with(LateScope(&c.lifetimes, self.scope), |old_scope, this| {\n                     // a bare fn has no bounds, so everything\n                     // contained within is scoped within its binder.\n-                    this.check_lifetime_defs(&c.lifetimes);\n+                    this.check_lifetime_defs(old_scope, &c.lifetimes);\n                     visit::walk_ty(this, ty);\n                 });\n             }\n@@ -167,7 +170,7 @@ impl<'a, 'v> Visitor<'v> for LifetimeContext<'a> {\n                 // a trait ref, which introduces a binding scope.\n                 match self.def_map.borrow().get(&id) {\n                     Some(&def::DefTrait(..)) => {\n-                        self.with(LateScope(&Vec::new(), self.scope), |this| {\n+                        self.with(LateScope(&Vec::new(), self.scope), |_, this| {\n                             this.visit_path(path, id);\n                         });\n                     }\n@@ -190,7 +193,7 @@ impl<'a, 'v> Visitor<'v> for LifetimeContext<'a> {\n \n     fn visit_block(&mut self, b: &ast::Block) {\n         self.with(BlockScope(region::CodeExtent::from_node_id(b.id), self.scope),\n-                  |this| visit::walk_block(this, b));\n+                  |_, this| visit::walk_block(this, b));\n     }\n \n     fn visit_lifetime_ref(&mut self, lifetime_ref: &ast::Lifetime) {\n@@ -232,8 +235,8 @@ impl<'a, 'v> Visitor<'v> for LifetimeContext<'a> {\n     fn visit_poly_trait_ref(&mut self, trait_ref: &ast::PolyTraitRef) {\n         debug!(\"visit_poly_trait_ref trait_ref={}\", trait_ref);\n \n-        self.with(LateScope(&trait_ref.bound_lifetimes, self.scope), |this| {\n-            this.check_lifetime_defs(&trait_ref.bound_lifetimes);\n+        self.with(LateScope(&trait_ref.bound_lifetimes, self.scope), |old_scope, this| {\n+            this.check_lifetime_defs(old_scope, &trait_ref.bound_lifetimes);\n             for lifetime in trait_ref.bound_lifetimes.iter() {\n                 this.visit_lifetime_def(lifetime);\n             }\n@@ -248,7 +251,7 @@ impl<'a, 'v> Visitor<'v> for LifetimeContext<'a> {\n \n impl<'a> LifetimeContext<'a> {\n     fn with<F>(&mut self, wrap_scope: ScopeChain, f: F) where\n-        F: FnOnce(&mut LifetimeContext),\n+        F: FnOnce(Scope, &mut LifetimeContext),\n     {\n         let LifetimeContext {sess, ref mut named_region_map, ..} = *self;\n         let mut this = LifetimeContext {\n@@ -258,7 +261,7 @@ impl<'a> LifetimeContext<'a> {\n             def_map: self.def_map,\n         };\n         debug!(\"entering scope {}\", this.scope);\n-        f(&mut this);\n+        f(self.scope, &mut this);\n         debug!(\"exiting scope {}\", this.scope);\n     }\n \n@@ -294,9 +297,9 @@ impl<'a> LifetimeContext<'a> {\n         let (early, late) = generics.lifetimes.clone().partition(\n             |l| referenced_idents.iter().any(|&i| i == l.lifetime.name));\n \n-        self.with(EarlyScope(early_space, &early, self.scope), move |this| {\n-            this.with(LateScope(&late, this.scope), move |this| {\n-                this.check_lifetime_defs(&generics.lifetimes);\n+        self.with(EarlyScope(early_space, &early, self.scope), move |old_scope, this| {\n+            this.with(LateScope(&late, this.scope), move |_, this| {\n+                this.check_lifetime_defs(old_scope, &generics.lifetimes);\n                 walk(this);\n             });\n         });\n@@ -323,7 +326,8 @@ impl<'a> LifetimeContext<'a> {\n \n                 EarlyScope(space, lifetimes, s) => {\n                     match search_lifetimes(lifetimes, lifetime_ref) {\n-                        Some((index, decl_id)) => {\n+                        Some((index, lifetime_def)) => {\n+                            let decl_id = lifetime_def.id;\n                             let def = DefEarlyBoundRegion(space, index, decl_id);\n                             self.insert_lifetime(lifetime_ref, def);\n                             return;\n@@ -336,7 +340,8 @@ impl<'a> LifetimeContext<'a> {\n \n                 LateScope(lifetimes, s) => {\n                     match search_lifetimes(lifetimes, lifetime_ref) {\n-                        Some((_index, decl_id)) => {\n+                        Some((_index, lifetime_def)) => {\n+                            let decl_id = lifetime_def.id;\n                             let debruijn = ty::DebruijnIndex::new(late_depth + 1);\n                             let def = DefLateBoundRegion(debruijn, decl_id);\n                             self.insert_lifetime(lifetime_ref, def);\n@@ -388,8 +393,8 @@ impl<'a> LifetimeContext<'a> {\n         }\n \n         match search_result {\n-            Some((_depth, decl_id)) => {\n-                let def = DefFreeRegion(scope_data, decl_id);\n+            Some((_depth, lifetime)) => {\n+                let def = DefFreeRegion(scope_data, lifetime.id);\n                 self.insert_lifetime(lifetime_ref, def);\n             }\n \n@@ -407,7 +412,7 @@ impl<'a> LifetimeContext<'a> {\n                     token::get_name(lifetime_ref.name)).as_slice());\n     }\n \n-    fn check_lifetime_defs(&mut self, lifetimes: &Vec<ast::LifetimeDef>) {\n+    fn check_lifetime_defs(&mut self, old_scope: Scope, lifetimes: &Vec<ast::LifetimeDef>) {\n         for i in range(0, lifetimes.len()) {\n             let lifetime_i = &lifetimes[i];\n \n@@ -422,6 +427,7 @@ impl<'a> LifetimeContext<'a> {\n                 }\n             }\n \n+            // It is a hard error to shadow a lifetime within the same scope.\n             for j in range(i + 1, lifetimes.len()) {\n                 let lifetime_j = &lifetimes[j];\n \n@@ -435,12 +441,54 @@ impl<'a> LifetimeContext<'a> {\n                 }\n             }\n \n+            // It is a soft error to shadow a lifetime within a parent scope.\n+            self.check_lifetime_def_for_shadowing(old_scope, &lifetime_i.lifetime);\n+\n             for bound in lifetime_i.bounds.iter() {\n                 self.resolve_lifetime_ref(bound);\n             }\n         }\n     }\n \n+    fn check_lifetime_def_for_shadowing(&self,\n+                                        mut old_scope: Scope,\n+                                        lifetime: &ast::Lifetime)\n+    {\n+        loop {\n+            match *old_scope {\n+                BlockScope(_, s) => {\n+                    old_scope = s;\n+                }\n+\n+                RootScope => {\n+                    return;\n+                }\n+\n+                EarlyScope(_, lifetimes, s) |\n+                LateScope(lifetimes, s) => {\n+                    if let Some((_, lifetime_def)) = search_lifetimes(lifetimes, lifetime) {\n+                        self.sess.span_warn(\n+                            lifetime.span,\n+                            format!(\"lifetime name `{}` shadows another \\\n+                                    lifetime name that is already in scope\",\n+                                    token::get_name(lifetime.name)).as_slice());\n+                        self.sess.span_help(\n+                            lifetime_def.span,\n+                            format!(\"shadowed lifetime `{}` declared here\",\n+                                    token::get_name(lifetime.name)).as_slice());\n+                        self.sess.span_help(\n+                            lifetime.span,\n+                            \"shadowed lifetimes are deprecated \\\n+                             and will become a hard error before 1.0\");\n+                        return;\n+                    }\n+\n+                    old_scope = s;\n+                }\n+            }\n+        }\n+    }\n+\n     fn insert_lifetime(&mut self,\n                        lifetime_ref: &ast::Lifetime,\n                        def: DefRegion) {\n@@ -458,12 +506,12 @@ impl<'a> LifetimeContext<'a> {\n     }\n }\n \n-fn search_lifetimes(lifetimes: &Vec<ast::LifetimeDef>,\n+fn search_lifetimes<'a>(lifetimes: &'a Vec<ast::LifetimeDef>,\n                     lifetime_ref: &ast::Lifetime)\n-                    -> Option<(uint, ast::NodeId)> {\n+                    -> Option<(uint, &'a ast::Lifetime)> {\n     for (i, lifetime_decl) in lifetimes.iter().enumerate() {\n         if lifetime_decl.lifetime.name == lifetime_ref.name {\n-            return Some((i, lifetime_decl.lifetime.id));\n+            return Some((i, &lifetime_decl.lifetime));\n         }\n     }\n     return None;"}, {"sha": "ff8ce7769d77e434eca3b8a88c2e8f4809e5b4c4", "filename": "src/test/compile-fail/shadowed-lifetime.rs", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/b60de4bfc2cf45ebe16b9b5b768f0aad54211625/src%2Ftest%2Fcompile-fail%2Fshadowed-lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b60de4bfc2cf45ebe16b9b5b768f0aad54211625/src%2Ftest%2Fcompile-fail%2Fshadowed-lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fshadowed-lifetime.rs?ref=b60de4bfc2cf45ebe16b9b5b768f0aad54211625", "patch": "@@ -0,0 +1,43 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that shadowed lifetimes generate an error.\n+\n+struct Foo<'a>(&'a int);\n+\n+impl<'a> Foo<'a> {\n+    //~^ HELP shadowed lifetime `'a` declared here\n+    fn shadow_in_method<'a>(&'a self) -> &'a int {\n+        //~^ WARNING lifetime name `'a` shadows another lifetime name that is already in scope\n+        //~| HELP deprecated\n+        self.0\n+    }\n+\n+    fn shadow_in_type<'b>(&'b self) -> &'b int {\n+        //~^ HELP shadowed lifetime `'b` declared here\n+        let x: for<'b> fn(&'b int) = panic!();\n+        //~^ WARNING lifetime name `'b` shadows another lifetime name that is already in scope\n+        //~| HELP deprecated\n+        self.0\n+    }\n+\n+    fn not_shadow_in_item<'b>(&'b self) {\n+        struct Bar<'a, 'b>(&'a int, &'b int); // not a shadow, separate item\n+        fn foo<'a, 'b>(x: &'a int, y: &'b int) { } // same\n+    }\n+}\n+\n+fn main() {\n+    // intentional error that occurs after `resolve_lifetime` runs,\n+    // just to ensure that this test fails to compile; when shadowed\n+    // lifetimes become either an error or a proper lint, this will\n+    // not be needed.\n+    let x: int = 3u; //~ ERROR mismatched types\n+}"}]}