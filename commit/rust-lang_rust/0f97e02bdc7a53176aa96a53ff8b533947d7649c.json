{"sha": "0f97e02bdc7a53176aa96a53ff8b533947d7649c", "node_id": "C_kwDOAAsO6NoAKDBmOTdlMDJiZGM3YTUzMTc2YWE5NmE1M2ZmOGI1MzM5NDdkNzY0OWM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-08T07:22:33Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-08T07:22:33Z"}, "message": "Auto merge of #99047 - matthiaskrgr:rollup-01vn70s, r=matthiaskrgr\n\nRollup of 6 pull requests\n\nSuccessful merges:\n\n - #95635 (sess: stabilize `--terminal-width` as `--diagnostic-width`)\n - #98718 (Stabilize `into_future`)\n - #98795 (A few cleanups)\n - #98798 (Fix caching bug in `download-rustc = true`)\n - #99019 (Add doc comments in `rustc_middle::mir`)\n - #99026 (Add test for and fix rust-lang/rust-clippy#9131)\n\nFailed merges:\n\n - #98957 ( don't allow ZST in ScalarInt )\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "202b412781a793d655e75b9c24d215aa2034fe39", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/202b412781a793d655e75b9c24d215aa2034fe39"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0f97e02bdc7a53176aa96a53ff8b533947d7649c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0f97e02bdc7a53176aa96a53ff8b533947d7649c", "html_url": "https://github.com/rust-lang/rust/commit/0f97e02bdc7a53176aa96a53ff8b533947d7649c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0f97e02bdc7a53176aa96a53ff8b533947d7649c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eba361ae36be41e42fb8fdf138455307e0ad407c", "url": "https://api.github.com/repos/rust-lang/rust/commits/eba361ae36be41e42fb8fdf138455307e0ad407c", "html_url": "https://github.com/rust-lang/rust/commit/eba361ae36be41e42fb8fdf138455307e0ad407c"}, {"sha": "445702d0cb4c47b1c95c0756c0d189ff539ca7bb", "url": "https://api.github.com/repos/rust-lang/rust/commits/445702d0cb4c47b1c95c0756c0d189ff539ca7bb", "html_url": "https://github.com/rust-lang/rust/commit/445702d0cb4c47b1c95c0756c0d189ff539ca7bb"}], "stats": {"total": 1372, "additions": 707, "deletions": 665}, "files": [{"sha": "ea3602e8a056a52010bf6b269e8c47539a3aa5c6", "filename": "compiler/rustc_borrowck/src/region_infer/mod.rs", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0f97e02bdc7a53176aa96a53ff8b533947d7649c/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f97e02bdc7a53176aa96a53ff8b533947d7649c/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs?ref=0f97e02bdc7a53176aa96a53ff8b533947d7649c", "patch": "@@ -495,8 +495,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                     }\n                 }\n \n-                NllRegionVariableOrigin::RootEmptyRegion\n-                | NllRegionVariableOrigin::Existential { .. } => {\n+                NllRegionVariableOrigin::Existential { .. } => {\n                     // For existential, regions, nothing to do.\n                 }\n             }\n@@ -1410,8 +1409,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                     self.check_bound_universal_region(fr, placeholder, errors_buffer);\n                 }\n \n-                NllRegionVariableOrigin::RootEmptyRegion\n-                | NllRegionVariableOrigin::Existential { .. } => {\n+                NllRegionVariableOrigin::Existential { .. } => {\n                     // nothing to check here\n                 }\n             }\n@@ -1513,8 +1511,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                     self.check_bound_universal_region(fr, placeholder, errors_buffer);\n                 }\n \n-                NllRegionVariableOrigin::RootEmptyRegion\n-                | NllRegionVariableOrigin::Existential { .. } => {\n+                NllRegionVariableOrigin::Existential { .. } => {\n                     // nothing to check here\n                 }\n             }\n@@ -1788,9 +1785,9 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 universe1.cannot_name(placeholder.universe)\n             }\n \n-            NllRegionVariableOrigin::RootEmptyRegion\n-            | NllRegionVariableOrigin::FreeRegion\n-            | NllRegionVariableOrigin::Existential { .. } => false,\n+            NllRegionVariableOrigin::FreeRegion | NllRegionVariableOrigin::Existential { .. } => {\n+                false\n+            }\n         }\n     }\n \n@@ -2152,8 +2149,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         let blame_source = match from_region_origin {\n             NllRegionVariableOrigin::FreeRegion\n             | NllRegionVariableOrigin::Existential { from_forall: false } => true,\n-            NllRegionVariableOrigin::RootEmptyRegion\n-            | NllRegionVariableOrigin::Placeholder(_)\n+            NllRegionVariableOrigin::Placeholder(_)\n             | NllRegionVariableOrigin::Existential { from_forall: true } => false,\n         };\n "}, {"sha": "7c1fa28b8dfcc9c9e731e34b2beda85bcc2897bd", "filename": "compiler/rustc_borrowck/src/region_infer/opaque_types.rs", "status": "modified", "additions": 482, "deletions": 2, "changes": 484, "blob_url": "https://github.com/rust-lang/rust/blob/0f97e02bdc7a53176aa96a53ff8b533947d7649c/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f97e02bdc7a53176aa96a53ff8b533947d7649c/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs?ref=0f97e02bdc7a53176aa96a53ff8b533947d7649c", "patch": "@@ -1,11 +1,20 @@\n+use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::vec_map::VecMap;\n use rustc_hir::def_id::DefId;\n use rustc_hir::OpaqueTyOrigin;\n+use rustc_infer::infer::error_reporting::unexpected_hidden_region_diagnostic;\n use rustc_infer::infer::InferCtxt;\n+use rustc_infer::infer::TyCtxtInferExt as _;\n+use rustc_infer::traits::{Obligation, ObligationCause, TraitEngine};\n+use rustc_middle::ty::fold::{TypeFolder, TypeSuperFoldable};\n+use rustc_middle::ty::subst::{GenericArg, GenericArgKind, InternalSubsts};\n+use rustc_middle::ty::visit::TypeVisitable;\n use rustc_middle::ty::{\n-    self, OpaqueHiddenType, OpaqueTypeKey, TyCtxt, TypeFoldable, TypeVisitable,\n+    self, OpaqueHiddenType, OpaqueTypeKey, ToPredicate, Ty, TyCtxt, TypeFoldable,\n };\n-use rustc_trait_selection::opaque_types::InferCtxtExt;\n+use rustc_span::Span;\n+use rustc_trait_selection::traits::error_reporting::InferCtxtExt as _;\n+use rustc_trait_selection::traits::TraitEngineExt as _;\n \n use super::RegionInferenceContext;\n \n@@ -173,3 +182,474 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         })\n     }\n }\n+\n+pub trait InferCtxtExt<'tcx> {\n+    fn infer_opaque_definition_from_instantiation(\n+        &self,\n+        opaque_type_key: OpaqueTypeKey<'tcx>,\n+        instantiated_ty: OpaqueHiddenType<'tcx>,\n+        origin: OpaqueTyOrigin,\n+    ) -> Ty<'tcx>;\n+}\n+\n+impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n+    /// Given the fully resolved, instantiated type for an opaque\n+    /// type, i.e., the value of an inference variable like C1 or C2\n+    /// (*), computes the \"definition type\" for an opaque type\n+    /// definition -- that is, the inferred value of `Foo1<'x>` or\n+    /// `Foo2<'x>` that we would conceptually use in its definition:\n+    /// ```ignore (illustrative)\n+    /// type Foo1<'x> = impl Bar<'x> = AAA;  // <-- this type AAA\n+    /// type Foo2<'x> = impl Bar<'x> = BBB;  // <-- or this type BBB\n+    /// fn foo<'a, 'b>(..) -> (Foo1<'a>, Foo2<'b>) { .. }\n+    /// ```\n+    /// Note that these values are defined in terms of a distinct set of\n+    /// generic parameters (`'x` instead of `'a`) from C1 or C2. The main\n+    /// purpose of this function is to do that translation.\n+    ///\n+    /// (*) C1 and C2 were introduced in the comments on\n+    /// `register_member_constraints`. Read that comment for more context.\n+    ///\n+    /// # Parameters\n+    ///\n+    /// - `def_id`, the `impl Trait` type\n+    /// - `substs`, the substs  used to instantiate this opaque type\n+    /// - `instantiated_ty`, the inferred type C1 -- fully resolved, lifted version of\n+    ///   `opaque_defn.concrete_ty`\n+    #[instrument(level = \"debug\", skip(self))]\n+    fn infer_opaque_definition_from_instantiation(\n+        &self,\n+        opaque_type_key: OpaqueTypeKey<'tcx>,\n+        instantiated_ty: OpaqueHiddenType<'tcx>,\n+        origin: OpaqueTyOrigin,\n+    ) -> Ty<'tcx> {\n+        if self.is_tainted_by_errors() {\n+            return self.tcx.ty_error();\n+        }\n+\n+        let OpaqueTypeKey { def_id, substs } = opaque_type_key;\n+\n+        // Use substs to build up a reverse map from regions to their\n+        // identity mappings. This is necessary because of `impl\n+        // Trait` lifetimes are computed by replacing existing\n+        // lifetimes with 'static and remapping only those used in the\n+        // `impl Trait` return type, resulting in the parameters\n+        // shifting.\n+        let id_substs = InternalSubsts::identity_for_item(self.tcx, def_id);\n+        debug!(?id_substs);\n+        let map: FxHashMap<GenericArg<'tcx>, GenericArg<'tcx>> =\n+            substs.iter().enumerate().map(|(index, subst)| (subst, id_substs[index])).collect();\n+        debug!(\"map = {:#?}\", map);\n+\n+        // Convert the type from the function into a type valid outside\n+        // the function, by replacing invalid regions with 'static,\n+        // after producing an error for each of them.\n+        let definition_ty = instantiated_ty.ty.fold_with(&mut ReverseMapper::new(\n+            self.tcx,\n+            def_id,\n+            map,\n+            instantiated_ty.ty,\n+            instantiated_ty.span,\n+        ));\n+        debug!(?definition_ty);\n+\n+        if !check_opaque_type_parameter_valid(\n+            self.tcx,\n+            opaque_type_key,\n+            origin,\n+            instantiated_ty.span,\n+        ) {\n+            return self.tcx.ty_error();\n+        }\n+\n+        // Only check this for TAIT. RPIT already supports `src/test/ui/impl-trait/nested-return-type2.rs`\n+        // on stable and we'd break that.\n+        if let OpaqueTyOrigin::TyAlias = origin {\n+            // This logic duplicates most of `check_opaque_meets_bounds`.\n+            // FIXME(oli-obk): Also do region checks here and then consider removing `check_opaque_meets_bounds` entirely.\n+            let param_env = self.tcx.param_env(def_id);\n+            let body_id = self.tcx.local_def_id_to_hir_id(def_id.as_local().unwrap());\n+            self.tcx.infer_ctxt().enter(move |infcx| {\n+                // Require the hidden type to be well-formed with only the generics of the opaque type.\n+                // Defining use functions may have more bounds than the opaque type, which is ok, as long as the\n+                // hidden type is well formed even without those bounds.\n+                let predicate =\n+                    ty::Binder::dummy(ty::PredicateKind::WellFormed(definition_ty.into()))\n+                        .to_predicate(infcx.tcx);\n+                let mut fulfillment_cx = <dyn TraitEngine<'tcx>>::new(infcx.tcx);\n+\n+                // Require that the hidden type actually fulfills all the bounds of the opaque type, even without\n+                // the bounds that the function supplies.\n+                match infcx.register_hidden_type(\n+                    OpaqueTypeKey { def_id, substs: id_substs },\n+                    ObligationCause::misc(instantiated_ty.span, body_id),\n+                    param_env,\n+                    definition_ty,\n+                    origin,\n+                ) {\n+                    Ok(infer_ok) => {\n+                        for obligation in infer_ok.obligations {\n+                            fulfillment_cx.register_predicate_obligation(&infcx, obligation);\n+                        }\n+                    }\n+                    Err(err) => {\n+                        infcx\n+                            .report_mismatched_types(\n+                                &ObligationCause::misc(instantiated_ty.span, body_id),\n+                                self.tcx.mk_opaque(def_id, id_substs),\n+                                definition_ty,\n+                                err,\n+                            )\n+                            .emit();\n+                    }\n+                }\n+\n+                fulfillment_cx.register_predicate_obligation(\n+                    &infcx,\n+                    Obligation::misc(instantiated_ty.span, body_id, param_env, predicate),\n+                );\n+\n+                // Check that all obligations are satisfied by the implementation's\n+                // version.\n+                let errors = fulfillment_cx.select_all_or_error(&infcx);\n+\n+                let _ = infcx.inner.borrow_mut().opaque_type_storage.take_opaque_types();\n+\n+                if errors.is_empty() {\n+                    definition_ty\n+                } else {\n+                    infcx.report_fulfillment_errors(&errors, None, false);\n+                    self.tcx.ty_error()\n+                }\n+            })\n+        } else {\n+            definition_ty\n+        }\n+    }\n+}\n+\n+fn check_opaque_type_parameter_valid(\n+    tcx: TyCtxt<'_>,\n+    opaque_type_key: OpaqueTypeKey<'_>,\n+    origin: OpaqueTyOrigin,\n+    span: Span,\n+) -> bool {\n+    match origin {\n+        // No need to check return position impl trait (RPIT)\n+        // because for type and const parameters they are correct\n+        // by construction: we convert\n+        //\n+        // fn foo<P0..Pn>() -> impl Trait\n+        //\n+        // into\n+        //\n+        // type Foo<P0...Pn>\n+        // fn foo<P0..Pn>() -> Foo<P0...Pn>.\n+        //\n+        // For lifetime parameters we convert\n+        //\n+        // fn foo<'l0..'ln>() -> impl Trait<'l0..'lm>\n+        //\n+        // into\n+        //\n+        // type foo::<'p0..'pn>::Foo<'q0..'qm>\n+        // fn foo<l0..'ln>() -> foo::<'static..'static>::Foo<'l0..'lm>.\n+        //\n+        // which would error here on all of the `'static` args.\n+        OpaqueTyOrigin::FnReturn(..) | OpaqueTyOrigin::AsyncFn(..) => return true,\n+        // Check these\n+        OpaqueTyOrigin::TyAlias => {}\n+    }\n+    let opaque_generics = tcx.generics_of(opaque_type_key.def_id);\n+    let mut seen_params: FxHashMap<_, Vec<_>> = FxHashMap::default();\n+    for (i, arg) in opaque_type_key.substs.iter().enumerate() {\n+        let arg_is_param = match arg.unpack() {\n+            GenericArgKind::Type(ty) => matches!(ty.kind(), ty::Param(_)),\n+            GenericArgKind::Lifetime(lt) if lt.is_static() => {\n+                tcx.sess\n+                    .struct_span_err(span, \"non-defining opaque type use in defining scope\")\n+                    .span_label(\n+                        tcx.def_span(opaque_generics.param_at(i, tcx).def_id),\n+                        \"cannot use static lifetime; use a bound lifetime \\\n+                                    instead or remove the lifetime parameter from the \\\n+                                    opaque type\",\n+                    )\n+                    .emit();\n+                return false;\n+            }\n+            GenericArgKind::Lifetime(lt) => {\n+                matches!(*lt, ty::ReEarlyBound(_) | ty::ReFree(_))\n+            }\n+            GenericArgKind::Const(ct) => matches!(ct.kind(), ty::ConstKind::Param(_)),\n+        };\n+\n+        if arg_is_param {\n+            seen_params.entry(arg).or_default().push(i);\n+        } else {\n+            // Prevent `fn foo() -> Foo<u32>` from being defining.\n+            let opaque_param = opaque_generics.param_at(i, tcx);\n+            tcx.sess\n+                .struct_span_err(span, \"non-defining opaque type use in defining scope\")\n+                .span_note(\n+                    tcx.def_span(opaque_param.def_id),\n+                    &format!(\n+                        \"used non-generic {} `{}` for generic parameter\",\n+                        opaque_param.kind.descr(),\n+                        arg,\n+                    ),\n+                )\n+                .emit();\n+            return false;\n+        }\n+    }\n+\n+    for (_, indices) in seen_params {\n+        if indices.len() > 1 {\n+            let descr = opaque_generics.param_at(indices[0], tcx).kind.descr();\n+            let spans: Vec<_> = indices\n+                .into_iter()\n+                .map(|i| tcx.def_span(opaque_generics.param_at(i, tcx).def_id))\n+                .collect();\n+            tcx.sess\n+                .struct_span_err(span, \"non-defining opaque type use in defining scope\")\n+                .span_note(spans, &format!(\"{} used multiple times\", descr))\n+                .emit();\n+            return false;\n+        }\n+    }\n+    true\n+}\n+\n+struct ReverseMapper<'tcx> {\n+    tcx: TyCtxt<'tcx>,\n+\n+    opaque_type_def_id: DefId,\n+    map: FxHashMap<GenericArg<'tcx>, GenericArg<'tcx>>,\n+    map_missing_regions_to_empty: bool,\n+\n+    /// initially `Some`, set to `None` once error has been reported\n+    hidden_ty: Option<Ty<'tcx>>,\n+\n+    /// Span of function being checked.\n+    span: Span,\n+}\n+\n+impl<'tcx> ReverseMapper<'tcx> {\n+    fn new(\n+        tcx: TyCtxt<'tcx>,\n+        opaque_type_def_id: DefId,\n+        map: FxHashMap<GenericArg<'tcx>, GenericArg<'tcx>>,\n+        hidden_ty: Ty<'tcx>,\n+        span: Span,\n+    ) -> Self {\n+        Self {\n+            tcx,\n+            opaque_type_def_id,\n+            map,\n+            map_missing_regions_to_empty: false,\n+            hidden_ty: Some(hidden_ty),\n+            span,\n+        }\n+    }\n+\n+    fn fold_kind_mapping_missing_regions_to_empty(\n+        &mut self,\n+        kind: GenericArg<'tcx>,\n+    ) -> GenericArg<'tcx> {\n+        assert!(!self.map_missing_regions_to_empty);\n+        self.map_missing_regions_to_empty = true;\n+        let kind = kind.fold_with(self);\n+        self.map_missing_regions_to_empty = false;\n+        kind\n+    }\n+\n+    fn fold_kind_normally(&mut self, kind: GenericArg<'tcx>) -> GenericArg<'tcx> {\n+        assert!(!self.map_missing_regions_to_empty);\n+        kind.fold_with(self)\n+    }\n+}\n+\n+impl<'tcx> TypeFolder<'tcx> for ReverseMapper<'tcx> {\n+    fn tcx(&self) -> TyCtxt<'tcx> {\n+        self.tcx\n+    }\n+\n+    #[instrument(skip(self), level = \"debug\")]\n+    fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n+        match *r {\n+            // Ignore bound regions and `'static` regions that appear in the\n+            // type, we only need to remap regions that reference lifetimes\n+            // from the function declaration.\n+            // This would ignore `'r` in a type like `for<'r> fn(&'r u32)`.\n+            ty::ReLateBound(..) | ty::ReStatic => return r,\n+\n+            // If regions have been erased (by writeback), don't try to unerase\n+            // them.\n+            ty::ReErased => return r,\n+\n+            // The regions that we expect from borrow checking.\n+            ty::ReEarlyBound(_) | ty::ReFree(_) | ty::ReEmpty(ty::UniverseIndex::ROOT) => {}\n+\n+            ty::ReEmpty(_) | ty::RePlaceholder(_) | ty::ReVar(_) => {\n+                // All of the regions in the type should either have been\n+                // erased by writeback, or mapped back to named regions by\n+                // borrow checking.\n+                bug!(\"unexpected region kind in opaque type: {:?}\", r);\n+            }\n+        }\n+\n+        let generics = self.tcx().generics_of(self.opaque_type_def_id);\n+        match self.map.get(&r.into()).map(|k| k.unpack()) {\n+            Some(GenericArgKind::Lifetime(r1)) => r1,\n+            Some(u) => panic!(\"region mapped to unexpected kind: {:?}\", u),\n+            None if self.map_missing_regions_to_empty => self.tcx.lifetimes.re_root_empty,\n+            None if generics.parent.is_some() => {\n+                if let Some(hidden_ty) = self.hidden_ty.take() {\n+                    unexpected_hidden_region_diagnostic(\n+                        self.tcx,\n+                        self.tcx.def_span(self.opaque_type_def_id),\n+                        hidden_ty,\n+                        r,\n+                    )\n+                    .emit();\n+                }\n+                self.tcx.lifetimes.re_root_empty\n+            }\n+            None => {\n+                self.tcx\n+                    .sess\n+                    .struct_span_err(self.span, \"non-defining opaque type use in defining scope\")\n+                    .span_label(\n+                        self.span,\n+                        format!(\n+                            \"lifetime `{}` is part of concrete type but not used in \\\n+                                 parameter list of the `impl Trait` type alias\",\n+                            r\n+                        ),\n+                    )\n+                    .emit();\n+\n+                self.tcx().lifetimes.re_static\n+            }\n+        }\n+    }\n+\n+    fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n+        match *ty.kind() {\n+            ty::Closure(def_id, substs) => {\n+                // I am a horrible monster and I pray for death. When\n+                // we encounter a closure here, it is always a closure\n+                // from within the function that we are currently\n+                // type-checking -- one that is now being encapsulated\n+                // in an opaque type. Ideally, we would\n+                // go through the types/lifetimes that it references\n+                // and treat them just like we would any other type,\n+                // which means we would error out if we find any\n+                // reference to a type/region that is not in the\n+                // \"reverse map\".\n+                //\n+                // **However,** in the case of closures, there is a\n+                // somewhat subtle (read: hacky) consideration. The\n+                // problem is that our closure types currently include\n+                // all the lifetime parameters declared on the\n+                // enclosing function, even if they are unused by the\n+                // closure itself. We can't readily filter them out,\n+                // so here we replace those values with `'empty`. This\n+                // can't really make a difference to the rest of the\n+                // compiler; those regions are ignored for the\n+                // outlives relation, and hence don't affect trait\n+                // selection or auto traits, and they are erased\n+                // during codegen.\n+\n+                let generics = self.tcx.generics_of(def_id);\n+                let substs = self.tcx.mk_substs(substs.iter().enumerate().map(|(index, kind)| {\n+                    if index < generics.parent_count {\n+                        // Accommodate missing regions in the parent kinds...\n+                        self.fold_kind_mapping_missing_regions_to_empty(kind)\n+                    } else {\n+                        // ...but not elsewhere.\n+                        self.fold_kind_normally(kind)\n+                    }\n+                }));\n+\n+                self.tcx.mk_closure(def_id, substs)\n+            }\n+\n+            ty::Generator(def_id, substs, movability) => {\n+                let generics = self.tcx.generics_of(def_id);\n+                let substs = self.tcx.mk_substs(substs.iter().enumerate().map(|(index, kind)| {\n+                    if index < generics.parent_count {\n+                        // Accommodate missing regions in the parent kinds...\n+                        self.fold_kind_mapping_missing_regions_to_empty(kind)\n+                    } else {\n+                        // ...but not elsewhere.\n+                        self.fold_kind_normally(kind)\n+                    }\n+                }));\n+\n+                self.tcx.mk_generator(def_id, substs, movability)\n+            }\n+\n+            ty::Param(param) => {\n+                // Look it up in the substitution list.\n+                match self.map.get(&ty.into()).map(|k| k.unpack()) {\n+                    // Found it in the substitution list; replace with the parameter from the\n+                    // opaque type.\n+                    Some(GenericArgKind::Type(t1)) => t1,\n+                    Some(u) => panic!(\"type mapped to unexpected kind: {:?}\", u),\n+                    None => {\n+                        debug!(?param, ?self.map);\n+                        self.tcx\n+                            .sess\n+                            .struct_span_err(\n+                                self.span,\n+                                &format!(\n+                                    \"type parameter `{}` is part of concrete type but not \\\n+                                          used in parameter list for the `impl Trait` type alias\",\n+                                    ty\n+                                ),\n+                            )\n+                            .emit();\n+\n+                        self.tcx().ty_error()\n+                    }\n+                }\n+            }\n+\n+            _ => ty.super_fold_with(self),\n+        }\n+    }\n+\n+    fn fold_const(&mut self, ct: ty::Const<'tcx>) -> ty::Const<'tcx> {\n+        trace!(\"checking const {:?}\", ct);\n+        // Find a const parameter\n+        match ct.kind() {\n+            ty::ConstKind::Param(..) => {\n+                // Look it up in the substitution list.\n+                match self.map.get(&ct.into()).map(|k| k.unpack()) {\n+                    // Found it in the substitution list, replace with the parameter from the\n+                    // opaque type.\n+                    Some(GenericArgKind::Const(c1)) => c1,\n+                    Some(u) => panic!(\"const mapped to unexpected kind: {:?}\", u),\n+                    None => {\n+                        self.tcx\n+                            .sess\n+                            .struct_span_err(\n+                                self.span,\n+                                &format!(\n+                                    \"const parameter `{}` is part of concrete type but not \\\n+                                          used in parameter list for the `impl Trait` type alias\",\n+                                    ct\n+                                ),\n+                            )\n+                            .emit();\n+\n+                        self.tcx().const_error(ct.ty())\n+                    }\n+                }\n+            }\n+\n+            _ => ct,\n+        }\n+    }\n+}"}, {"sha": "2a7713bc4df3b6d1e8be939ef07799a5c412f820", "filename": "compiler/rustc_borrowck/src/universal_regions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f97e02bdc7a53176aa96a53ff8b533947d7649c/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f97e02bdc7a53176aa96a53ff8b533947d7649c/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs?ref=0f97e02bdc7a53176aa96a53ff8b533947d7649c", "patch": "@@ -503,7 +503,7 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n \n         let root_empty = self\n             .infcx\n-            .next_nll_region_var(NllRegionVariableOrigin::RootEmptyRegion)\n+            .next_nll_region_var(NllRegionVariableOrigin::Existential { from_forall: true })\n             .to_region_vid();\n \n         UniversalRegions {"}, {"sha": "85ea8eb3937822708c0c8206286a3ca4eb0ac18d", "filename": "compiler/rustc_errors/src/emitter.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0f97e02bdc7a53176aa96a53ff8b533947d7649c/compiler%2Frustc_errors%2Fsrc%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f97e02bdc7a53176aa96a53ff8b533947d7649c/compiler%2Frustc_errors%2Fsrc%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Femitter.rs?ref=0f97e02bdc7a53176aa96a53ff8b533947d7649c", "patch": "@@ -63,7 +63,7 @@ impl HumanReadableErrorType {\n         bundle: Option<Lrc<FluentBundle>>,\n         fallback_bundle: LazyFallbackBundle,\n         teach: bool,\n-        terminal_width: Option<usize>,\n+        diagnostic_width: Option<usize>,\n         macro_backtrace: bool,\n     ) -> EmitterWriter {\n         let (short, color_config) = self.unzip();\n@@ -76,7 +76,7 @@ impl HumanReadableErrorType {\n             short,\n             teach,\n             color,\n-            terminal_width,\n+            diagnostic_width,\n             macro_backtrace,\n         )\n     }\n@@ -710,7 +710,7 @@ pub struct EmitterWriter {\n     short_message: bool,\n     teach: bool,\n     ui_testing: bool,\n-    terminal_width: Option<usize>,\n+    diagnostic_width: Option<usize>,\n \n     macro_backtrace: bool,\n }\n@@ -730,7 +730,7 @@ impl EmitterWriter {\n         fallback_bundle: LazyFallbackBundle,\n         short_message: bool,\n         teach: bool,\n-        terminal_width: Option<usize>,\n+        diagnostic_width: Option<usize>,\n         macro_backtrace: bool,\n     ) -> EmitterWriter {\n         let dst = Destination::from_stderr(color_config);\n@@ -742,7 +742,7 @@ impl EmitterWriter {\n             short_message,\n             teach,\n             ui_testing: false,\n-            terminal_width,\n+            diagnostic_width,\n             macro_backtrace,\n         }\n     }\n@@ -755,7 +755,7 @@ impl EmitterWriter {\n         short_message: bool,\n         teach: bool,\n         colored: bool,\n-        terminal_width: Option<usize>,\n+        diagnostic_width: Option<usize>,\n         macro_backtrace: bool,\n     ) -> EmitterWriter {\n         EmitterWriter {\n@@ -766,7 +766,7 @@ impl EmitterWriter {\n             short_message,\n             teach,\n             ui_testing: false,\n-            terminal_width,\n+            diagnostic_width,\n             macro_backtrace,\n         }\n     }\n@@ -1615,7 +1615,7 @@ impl EmitterWriter {\n                     width_offset + annotated_file.multiline_depth + 1\n                 };\n \n-                let column_width = if let Some(width) = self.terminal_width {\n+                let column_width = if let Some(width) = self.diagnostic_width {\n                     width.saturating_sub(code_offset)\n                 } else if self.ui_testing {\n                     DEFAULT_COLUMN_WIDTH"}, {"sha": "b8cd334b4c6c6af6844526f60dc7316ff5a0ab7d", "filename": "compiler/rustc_errors/src/json.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0f97e02bdc7a53176aa96a53ff8b533947d7649c/compiler%2Frustc_errors%2Fsrc%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f97e02bdc7a53176aa96a53ff8b533947d7649c/compiler%2Frustc_errors%2Fsrc%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fjson.rs?ref=0f97e02bdc7a53176aa96a53ff8b533947d7649c", "patch": "@@ -42,7 +42,7 @@ pub struct JsonEmitter {\n     pretty: bool,\n     ui_testing: bool,\n     json_rendered: HumanReadableErrorType,\n-    terminal_width: Option<usize>,\n+    diagnostic_width: Option<usize>,\n     macro_backtrace: bool,\n }\n \n@@ -54,7 +54,7 @@ impl JsonEmitter {\n         fallback_bundle: LazyFallbackBundle,\n         pretty: bool,\n         json_rendered: HumanReadableErrorType,\n-        terminal_width: Option<usize>,\n+        diagnostic_width: Option<usize>,\n         macro_backtrace: bool,\n     ) -> JsonEmitter {\n         JsonEmitter {\n@@ -66,7 +66,7 @@ impl JsonEmitter {\n             pretty,\n             ui_testing: false,\n             json_rendered,\n-            terminal_width,\n+            diagnostic_width,\n             macro_backtrace,\n         }\n     }\n@@ -76,7 +76,7 @@ impl JsonEmitter {\n         json_rendered: HumanReadableErrorType,\n         fluent_bundle: Option<Lrc<FluentBundle>>,\n         fallback_bundle: LazyFallbackBundle,\n-        terminal_width: Option<usize>,\n+        diagnostic_width: Option<usize>,\n         macro_backtrace: bool,\n     ) -> JsonEmitter {\n         let file_path_mapping = FilePathMapping::empty();\n@@ -87,7 +87,7 @@ impl JsonEmitter {\n             fallback_bundle,\n             pretty,\n             json_rendered,\n-            terminal_width,\n+            diagnostic_width,\n             macro_backtrace,\n         )\n     }\n@@ -100,7 +100,7 @@ impl JsonEmitter {\n         fallback_bundle: LazyFallbackBundle,\n         pretty: bool,\n         json_rendered: HumanReadableErrorType,\n-        terminal_width: Option<usize>,\n+        diagnostic_width: Option<usize>,\n         macro_backtrace: bool,\n     ) -> JsonEmitter {\n         JsonEmitter {\n@@ -112,7 +112,7 @@ impl JsonEmitter {\n             pretty,\n             ui_testing: false,\n             json_rendered,\n-            terminal_width,\n+            diagnostic_width,\n             macro_backtrace,\n         }\n     }\n@@ -345,7 +345,7 @@ impl Diagnostic {\n                 je.fluent_bundle.clone(),\n                 je.fallback_bundle.clone(),\n                 false,\n-                je.terminal_width,\n+                je.diagnostic_width,\n                 je.macro_backtrace,\n             )\n             .ui_testing(je.ui_testing)"}, {"sha": "d566634a49203b9272a9ed4802f51f3d2fd70d04", "filename": "compiler/rustc_infer/src/infer/free_regions.rs", "status": "modified", "additions": 5, "deletions": 19, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/0f97e02bdc7a53176aa96a53ff8b533947d7649c/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffree_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f97e02bdc7a53176aa96a53ff8b533947d7649c/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffree_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffree_regions.rs?ref=0f97e02bdc7a53176aa96a53ff8b533947d7649c", "patch": "@@ -4,7 +4,7 @@\n //! and use that to decide when one free region outlives another, and so forth.\n \n use rustc_data_structures::transitive_relation::TransitiveRelation;\n-use rustc_middle::ty::{self, Lift, Region, TyCtxt};\n+use rustc_middle::ty::{Lift, Region, TyCtxt};\n \n /// Combines a `FreeRegionMap` and a `TyCtxt`.\n ///\n@@ -49,7 +49,7 @@ impl<'tcx> FreeRegionMap<'tcx> {\n     // (with the exception that `'static: 'x` is not notable)\n     pub fn relate_regions(&mut self, sub: Region<'tcx>, sup: Region<'tcx>) {\n         debug!(\"relate_regions(sub={:?}, sup={:?})\", sub, sup);\n-        if self.is_free_or_static(sub) && self.is_free(sup) {\n+        if sub.is_free_or_static() && sup.is_free() {\n             self.relation.add(sub, sup)\n         }\n     }\n@@ -68,7 +68,7 @@ impl<'tcx> FreeRegionMap<'tcx> {\n         r_a: Region<'tcx>,\n         r_b: Region<'tcx>,\n     ) -> bool {\n-        assert!(self.is_free_or_static(r_a) && self.is_free_or_static(r_b));\n+        assert!(r_a.is_free_or_static() && r_b.is_free_or_static());\n         let re_static = tcx.lifetimes.re_static;\n         if self.check_relation(re_static, r_b) {\n             // `'a <= 'static` is always true, and not stored in the\n@@ -85,20 +85,6 @@ impl<'tcx> FreeRegionMap<'tcx> {\n         r_a == r_b || self.relation.contains(r_a, r_b)\n     }\n \n-    /// True for free regions other than `'static`.\n-    pub fn is_free(&self, r: Region<'_>) -> bool {\n-        matches!(*r, ty::ReEarlyBound(_) | ty::ReFree(_))\n-    }\n-\n-    /// True if `r` is a free region or static of the sort that this\n-    /// free region map can be used with.\n-    pub fn is_free_or_static(&self, r: Region<'_>) -> bool {\n-        match *r {\n-            ty::ReStatic => true,\n-            _ => self.is_free(r),\n-        }\n-    }\n-\n     /// Computes the least-upper-bound of two free regions. In some\n     /// cases, this is more conservative than necessary, in order to\n     /// avoid making arbitrary choices. See\n@@ -110,8 +96,8 @@ impl<'tcx> FreeRegionMap<'tcx> {\n         r_b: Region<'tcx>,\n     ) -> Region<'tcx> {\n         debug!(\"lub_free_regions(r_a={:?}, r_b={:?})\", r_a, r_b);\n-        assert!(self.is_free(r_a));\n-        assert!(self.is_free(r_b));\n+        assert!(r_a.is_free());\n+        assert!(r_b.is_free());\n         let result = if r_a == r_b {\n             r_a\n         } else {"}, {"sha": "3783cfb4cc5c85c85aaf53e674bdfb7916a95ba8", "filename": "compiler/rustc_infer/src/infer/lexical_region_resolve/mod.rs", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/0f97e02bdc7a53176aa96a53ff8b533947d7649c/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f97e02bdc7a53176aa96a53ff8b533947d7649c/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flexical_region_resolve%2Fmod.rs?ref=0f97e02bdc7a53176aa96a53ff8b533947d7649c", "patch": "@@ -47,7 +47,6 @@ pub(crate) fn resolve<'tcx>(\n #[derive(Clone)]\n pub struct LexicalRegionResolutions<'tcx> {\n     pub(crate) values: IndexVec<RegionVid, VarValue<'tcx>>,\n-    pub(crate) error_region: ty::Region<'tcx>,\n }\n \n #[derive(Copy, Clone, Debug)]\n@@ -140,7 +139,6 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n     /// empty region. The `expansion` phase will grow this larger.\n     fn construct_var_data(&self, tcx: TyCtxt<'tcx>) -> LexicalRegionResolutions<'tcx> {\n         LexicalRegionResolutions {\n-            error_region: tcx.lifetimes.re_static,\n             values: IndexVec::from_fn_n(\n                 |vid| {\n                     let vid_universe = self.var_infos[vid].universe;\n@@ -310,7 +308,7 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n \n         // Check for the case where we know that `'b: 'static` -- in that case,\n         // `a <= b` for all `a`.\n-        let b_free_or_static = self.region_rels.free_regions.is_free_or_static(b);\n+        let b_free_or_static = b.is_free_or_static();\n         if b_free_or_static && sub_free_regions(tcx.lifetimes.re_static, b) {\n             return true;\n         }\n@@ -320,7 +318,7 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n         // `lub` relationship defined below, since sometimes the \"lub\"\n         // is actually the `postdom_upper_bound` (see\n         // `TransitiveRelation` for more details).\n-        let a_free_or_static = self.region_rels.free_regions.is_free_or_static(a);\n+        let a_free_or_static = a.is_free_or_static();\n         if a_free_or_static && b_free_or_static {\n             return sub_free_regions(a, b);\n         }\n@@ -864,10 +862,7 @@ impl<'tcx> LexicalRegionResolutions<'tcx> {\n     where\n         T: TypeFoldable<'tcx>,\n     {\n-        tcx.fold_regions(value, |r, _db| match *r {\n-            ty::ReVar(rid) => self.resolve_var(rid),\n-            _ => r,\n-        })\n+        tcx.fold_regions(value, |r, _db| self.resolve_region(tcx, r))\n     }\n \n     fn value(&self, rid: RegionVid) -> &VarValue<'tcx> {\n@@ -878,12 +873,19 @@ impl<'tcx> LexicalRegionResolutions<'tcx> {\n         &mut self.values[rid]\n     }\n \n-    pub fn resolve_var(&self, rid: RegionVid) -> ty::Region<'tcx> {\n-        let result = match self.values[rid] {\n-            VarValue::Value(r) => r,\n-            VarValue::ErrorValue => self.error_region,\n+    pub(crate) fn resolve_region(\n+        &self,\n+        tcx: TyCtxt<'tcx>,\n+        r: ty::Region<'tcx>,\n+    ) -> ty::Region<'tcx> {\n+        let result = match *r {\n+            ty::ReVar(rid) => match self.values[rid] {\n+                VarValue::Value(r) => r,\n+                VarValue::ErrorValue => tcx.lifetimes.re_static,\n+            },\n+            _ => r,\n         };\n-        debug!(\"resolve_var({:?}) = {:?}\", rid, result);\n+        debug!(\"resolve_region({:?}) = {:?}\", r, result);\n         result\n     }\n }"}, {"sha": "6e0f2d687437b6bc38324f1ddcc45385a3c2f65f", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f97e02bdc7a53176aa96a53ff8b533947d7649c/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f97e02bdc7a53176aa96a53ff8b533947d7649c/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=0f97e02bdc7a53176aa96a53ff8b533947d7649c", "patch": "@@ -466,9 +466,6 @@ pub enum NllRegionVariableOrigin {\n     /// from a `for<'a> T` binder). Meant to represent \"any region\".\n     Placeholder(ty::PlaceholderRegion),\n \n-    /// The variable we create to represent `'empty(U0)`.\n-    RootEmptyRegion,\n-\n     Existential {\n         /// If this is true, then this variable was created to represent a lifetime\n         /// bound in a `for` binder. For example, it might have been created to\n@@ -1250,7 +1247,6 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         };\n \n         let lexical_region_resolutions = LexicalRegionResolutions {\n-            error_region: self.tcx.lifetimes.re_static,\n             values: rustc_index::vec::IndexVec::from_elem_n(\n                 crate::infer::lexical_region_resolve::VarValue::Value(self.tcx.lifetimes.re_erased),\n                 var_infos.len(),"}, {"sha": "3d99f0958f7f9a7220a0c8d946272b7520564ae5", "filename": "compiler/rustc_infer/src/infer/resolve.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f97e02bdc7a53176aa96a53ff8b533947d7649c/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f97e02bdc7a53176aa96a53ff8b533947d7649c/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fresolve.rs?ref=0f97e02bdc7a53176aa96a53ff8b533947d7649c", "patch": "@@ -206,13 +206,13 @@ impl<'a, 'tcx> FallibleTypeFolder<'tcx> for FullTypeResolver<'a, 'tcx> {\n \n     fn try_fold_region(&mut self, r: ty::Region<'tcx>) -> Result<ty::Region<'tcx>, Self::Error> {\n         match *r {\n-            ty::ReVar(rid) => Ok(self\n+            ty::ReVar(_) => Ok(self\n                 .infcx\n                 .lexical_region_resolutions\n                 .borrow()\n                 .as_ref()\n                 .expect(\"region resolution not performed\")\n-                .resolve_var(rid)),\n+                .resolve_region(self.infcx.tcx, r)),\n             _ => Ok(r),\n         }\n     }"}, {"sha": "81145416437b759de95009b17f571c4bd46c2316", "filename": "compiler/rustc_interface/src/tests.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0f97e02bdc7a53176aa96a53ff8b533947d7649c/compiler%2Frustc_interface%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f97e02bdc7a53176aa96a53ff8b533947d7649c/compiler%2Frustc_interface%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Ftests.rs?ref=0f97e02bdc7a53176aa96a53ff8b533947d7649c", "patch": "@@ -689,7 +689,6 @@ fn test_debugging_options_tracking_hash() {\n     untracked!(span_debug, true);\n     untracked!(span_free_formats, true);\n     untracked!(temps_dir, Some(String::from(\"abc\")));\n-    untracked!(terminal_width, Some(80));\n     untracked!(threads, 99);\n     untracked!(time, true);\n     untracked!(time_llvm_passes, true);"}, {"sha": "f136b8e236824ca3a50de017b20381082824bd88", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0f97e02bdc7a53176aa96a53ff8b533947d7649c/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f97e02bdc7a53176aa96a53ff8b533947d7649c/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=0f97e02bdc7a53176aa96a53ff8b533947d7649c", "patch": "@@ -1048,6 +1048,8 @@ impl BasicBlock {\n ///////////////////////////////////////////////////////////////////////////\n // BasicBlockData\n \n+/// Data for a basic block, including a list of its statements.\n+///\n /// See [`BasicBlock`] for documentation on what basic blocks are at a high level.\n #[derive(Clone, Debug, TyEncodable, TyDecodable, HashStable, TypeFoldable, TypeVisitable)]\n pub struct BasicBlockData<'tcx> {\n@@ -1079,7 +1081,7 @@ impl<'tcx> BasicBlockData<'tcx> {\n     /// Accessor for terminator.\n     ///\n     /// Terminator may not be None after construction of the basic block is complete. This accessor\n-    /// provides a convenience way to reach the terminator.\n+    /// provides a convenient way to reach the terminator.\n     #[inline]\n     pub fn terminator(&self) -> &Terminator<'tcx> {\n         self.terminator.as_ref().expect(\"invalid terminator state\")\n@@ -1286,6 +1288,7 @@ impl<O: fmt::Debug> fmt::Debug for AssertKind<O> {\n ///////////////////////////////////////////////////////////////////////////\n // Statements\n \n+/// A statement in a basic block, including information about its source code.\n #[derive(Clone, TyEncodable, TyDecodable, HashStable, TypeFoldable, TypeVisitable)]\n pub struct Statement<'tcx> {\n     pub source_info: SourceInfo,"}, {"sha": "03e4319bbf1a8fa1ad1e212d80aadfbf37d3133c", "filename": "compiler/rustc_middle/src/ty/sty.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0f97e02bdc7a53176aa96a53ff8b533947d7649c/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f97e02bdc7a53176aa96a53ff8b533947d7649c/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs?ref=0f97e02bdc7a53176aa96a53ff8b533947d7649c", "patch": "@@ -1570,6 +1570,19 @@ impl<'tcx> Region<'tcx> {\n             _ => bug!(\"free_region_binding_scope invoked on inappropriate region: {:?}\", self),\n         }\n     }\n+\n+    /// True for free regions other than `'static`.\n+    pub fn is_free(self) -> bool {\n+        matches!(*self, ty::ReEarlyBound(_) | ty::ReFree(_))\n+    }\n+\n+    /// True if `self` is a free region or static.\n+    pub fn is_free_or_static(self) -> bool {\n+        match *self {\n+            ty::ReStatic => true,\n+            _ => self.is_free(),\n+        }\n+    }\n }\n \n /// Type utilities"}, {"sha": "b7da0f229420bdf16101473e3bd679089792dcaa", "filename": "compiler/rustc_session/src/config.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0f97e02bdc7a53176aa96a53ff8b533947d7649c/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f97e02bdc7a53176aa96a53ff8b533947d7649c/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fconfig.rs?ref=0f97e02bdc7a53176aa96a53ff8b533947d7649c", "patch": "@@ -726,6 +726,7 @@ impl Default for Options {\n             prints: Vec::new(),\n             cg: Default::default(),\n             error_format: ErrorOutputType::default(),\n+            diagnostic_width: None,\n             externs: Externs(BTreeMap::new()),\n             crate_name: None,\n             libs: Vec::new(),\n@@ -1427,6 +1428,12 @@ pub fn rustc_optgroups() -> Vec<RustcOptGroup> {\n                                  never  = never colorize output\",\n             \"auto|always|never\",\n         ),\n+        opt::opt_s(\n+            \"\",\n+            \"diagnostic-width\",\n+            \"Inform rustc of the width of the output so that diagnostics can be truncated to fit\",\n+            \"WIDTH\",\n+        ),\n         opt::multi_s(\n             \"\",\n             \"remap-path-prefix\",\n@@ -2202,6 +2209,10 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n \n     let error_format = parse_error_format(matches, color, json_rendered);\n \n+    let diagnostic_width = matches.opt_get(\"diagnostic-width\").unwrap_or_else(|_| {\n+        early_error(error_format, \"`--diagnostic-width` must be an positive integer\");\n+    });\n+\n     let unparsed_crate_types = matches.opt_strs(\"crate-type\");\n     let crate_types = parse_crate_types_from_list(unparsed_crate_types)\n         .unwrap_or_else(|e| early_error(error_format, &e));\n@@ -2474,6 +2485,7 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n         prints,\n         cg,\n         error_format,\n+        diagnostic_width,\n         externs,\n         unstable_features: UnstableFeatures::from_environment(crate_name.as_deref()),\n         crate_name,"}, {"sha": "b0c74ffb6dcc13d2fb99d95f2186239058603d12", "filename": "compiler/rustc_session/src/options.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0f97e02bdc7a53176aa96a53ff8b533947d7649c/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f97e02bdc7a53176aa96a53ff8b533947d7649c/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Foptions.rs?ref=0f97e02bdc7a53176aa96a53ff8b533947d7649c", "patch": "@@ -170,6 +170,7 @@ top_level_options!(\n \n         test: bool [TRACKED],\n         error_format: ErrorOutputType [UNTRACKED],\n+        diagnostic_width: Option<usize> [UNTRACKED],\n \n         /// If `Some`, enable incremental compilation, using the given\n         /// directory to store intermediate results.\n@@ -1388,6 +1389,8 @@ options! {\n         \"panic strategy for out-of-memory handling\"),\n     osx_rpath_install_name: bool = (false, parse_bool, [TRACKED],\n         \"pass `-install_name @rpath/...` to the macOS linker (default: no)\"),\n+    diagnostic_width: Option<usize> = (None, parse_opt_number, [UNTRACKED],\n+        \"set the current output width for diagnostic truncation\"),\n     panic_abort_tests: bool = (false, parse_bool, [TRACKED],\n         \"support compiling tests with panic=abort (default: no)\"),\n     panic_in_drop: PanicStrategy = (PanicStrategy::Unwind, parse_panic_strategy, [TRACKED],\n@@ -1514,8 +1517,6 @@ options! {\n         \"show extended diagnostic help (default: no)\"),\n     temps_dir: Option<String> = (None, parse_opt_string, [UNTRACKED],\n         \"the directory the intermediate files are written to\"),\n-    terminal_width: Option<usize> = (None, parse_opt_number, [UNTRACKED],\n-        \"set the current terminal width\"),\n     // Diagnostics are considered side-effects of a query (see `QuerySideEffects`) and are saved\n     // alongside query results and changes to translation options can affect diagnostics - so\n     // translation options should be tracked."}, {"sha": "52b9ee94718028b03875d1fbfd174858d43a6041", "filename": "compiler/rustc_session/src/session.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0f97e02bdc7a53176aa96a53ff8b533947d7649c/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f97e02bdc7a53176aa96a53ff8b533947d7649c/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fsession.rs?ref=0f97e02bdc7a53176aa96a53ff8b533947d7649c", "patch": "@@ -1162,7 +1162,7 @@ fn default_emitter(\n                         fallback_bundle,\n                         short,\n                         sopts.debugging_opts.teach,\n-                        sopts.debugging_opts.terminal_width,\n+                        sopts.diagnostic_width,\n                         macro_backtrace,\n                     ),\n                     Some(dst) => EmitterWriter::new(\n@@ -1173,7 +1173,7 @@ fn default_emitter(\n                         short,\n                         false, // no teach messages when writing to a buffer\n                         false, // no colors when writing to a buffer\n-                        None,  // no terminal width\n+                        None,  // no diagnostic width\n                         macro_backtrace,\n                     ),\n                 };\n@@ -1188,7 +1188,7 @@ fn default_emitter(\n                 fallback_bundle,\n                 pretty,\n                 json_rendered,\n-                sopts.debugging_opts.terminal_width,\n+                sopts.diagnostic_width,\n                 macro_backtrace,\n             )\n             .ui_testing(sopts.debugging_opts.ui_testing),\n@@ -1202,7 +1202,7 @@ fn default_emitter(\n                 fallback_bundle,\n                 pretty,\n                 json_rendered,\n-                sopts.debugging_opts.terminal_width,\n+                sopts.diagnostic_width,\n                 macro_backtrace,\n             )\n             .ui_testing(sopts.debugging_opts.ui_testing),"}, {"sha": "282ee632ce5817dcf32fd54458f6663f7bf2264b", "filename": "compiler/rustc_trait_selection/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0f97e02bdc7a53176aa96a53ff8b533947d7649c/compiler%2Frustc_trait_selection%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f97e02bdc7a53176aa96a53ff8b533947d7649c/compiler%2Frustc_trait_selection%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Flib.rs?ref=0f97e02bdc7a53176aa96a53ff8b533947d7649c", "patch": "@@ -37,5 +37,4 @@ extern crate smallvec;\n \n pub mod autoderef;\n pub mod infer;\n-pub mod opaque_types;\n pub mod traits;"}, {"sha": "d290f7b074cb5a894d89d704c227324ae5afa762", "filename": "compiler/rustc_trait_selection/src/opaque_types.rs", "status": "removed", "additions": 0, "deletions": 545, "changes": 545, "blob_url": "https://github.com/rust-lang/rust/blob/eba361ae36be41e42fb8fdf138455307e0ad407c/compiler%2Frustc_trait_selection%2Fsrc%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eba361ae36be41e42fb8fdf138455307e0ad407c/compiler%2Frustc_trait_selection%2Fsrc%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fopaque_types.rs?ref=eba361ae36be41e42fb8fdf138455307e0ad407c", "patch": "@@ -1,545 +0,0 @@\n-use crate::traits;\n-use crate::traits::error_reporting::InferCtxtExt as _;\n-use crate::traits::TraitEngineExt as _;\n-use rustc_data_structures::fx::FxHashMap;\n-use rustc_hir::def_id::DefId;\n-use rustc_hir::OpaqueTyOrigin;\n-use rustc_infer::infer::error_reporting::unexpected_hidden_region_diagnostic;\n-use rustc_infer::infer::{InferCtxt, TyCtxtInferExt as _};\n-use rustc_infer::traits::{Obligation, ObligationCause, TraitEngine};\n-use rustc_middle::ty::fold::{TypeFoldable, TypeFolder, TypeSuperFoldable};\n-use rustc_middle::ty::subst::{GenericArg, GenericArgKind, InternalSubsts};\n-use rustc_middle::ty::visit::TypeVisitable;\n-use rustc_middle::ty::{self, OpaqueHiddenType, OpaqueTypeKey, ToPredicate, Ty, TyCtxt};\n-use rustc_span::Span;\n-\n-pub trait InferCtxtExt<'tcx> {\n-    fn infer_opaque_definition_from_instantiation(\n-        &self,\n-        opaque_type_key: OpaqueTypeKey<'tcx>,\n-        instantiated_ty: OpaqueHiddenType<'tcx>,\n-        origin: OpaqueTyOrigin,\n-    ) -> Ty<'tcx>;\n-}\n-\n-impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n-    /// Given the fully resolved, instantiated type for an opaque\n-    /// type, i.e., the value of an inference variable like C1 or C2\n-    /// (*), computes the \"definition type\" for an opaque type\n-    /// definition -- that is, the inferred value of `Foo1<'x>` or\n-    /// `Foo2<'x>` that we would conceptually use in its definition:\n-    /// ```ignore (illustrative)\n-    /// type Foo1<'x> = impl Bar<'x> = AAA;  // <-- this type AAA\n-    /// type Foo2<'x> = impl Bar<'x> = BBB;  // <-- or this type BBB\n-    /// fn foo<'a, 'b>(..) -> (Foo1<'a>, Foo2<'b>) { .. }\n-    /// ```\n-    /// Note that these values are defined in terms of a distinct set of\n-    /// generic parameters (`'x` instead of `'a`) from C1 or C2. The main\n-    /// purpose of this function is to do that translation.\n-    ///\n-    /// (*) C1 and C2 were introduced in the comments on\n-    /// `register_member_constraints`. Read that comment for more context.\n-    ///\n-    /// # Parameters\n-    ///\n-    /// - `def_id`, the `impl Trait` type\n-    /// - `substs`, the substs  used to instantiate this opaque type\n-    /// - `instantiated_ty`, the inferred type C1 -- fully resolved, lifted version of\n-    ///   `opaque_defn.concrete_ty`\n-    #[instrument(level = \"debug\", skip(self))]\n-    fn infer_opaque_definition_from_instantiation(\n-        &self,\n-        opaque_type_key: OpaqueTypeKey<'tcx>,\n-        instantiated_ty: OpaqueHiddenType<'tcx>,\n-        origin: OpaqueTyOrigin,\n-    ) -> Ty<'tcx> {\n-        if self.is_tainted_by_errors() {\n-            return self.tcx.ty_error();\n-        }\n-\n-        let OpaqueTypeKey { def_id, substs } = opaque_type_key;\n-\n-        // Use substs to build up a reverse map from regions to their\n-        // identity mappings. This is necessary because of `impl\n-        // Trait` lifetimes are computed by replacing existing\n-        // lifetimes with 'static and remapping only those used in the\n-        // `impl Trait` return type, resulting in the parameters\n-        // shifting.\n-        let id_substs = InternalSubsts::identity_for_item(self.tcx, def_id);\n-        debug!(?id_substs);\n-        let map: FxHashMap<GenericArg<'tcx>, GenericArg<'tcx>> =\n-            substs.iter().enumerate().map(|(index, subst)| (subst, id_substs[index])).collect();\n-        debug!(\"map = {:#?}\", map);\n-\n-        // Convert the type from the function into a type valid outside\n-        // the function, by replacing invalid regions with 'static,\n-        // after producing an error for each of them.\n-        let definition_ty = instantiated_ty.ty.fold_with(&mut ReverseMapper::new(\n-            self.tcx,\n-            def_id,\n-            map,\n-            instantiated_ty.ty,\n-            instantiated_ty.span,\n-        ));\n-        debug!(?definition_ty);\n-\n-        if !check_opaque_type_parameter_valid(\n-            self.tcx,\n-            opaque_type_key,\n-            origin,\n-            instantiated_ty.span,\n-        ) {\n-            return self.tcx.ty_error();\n-        }\n-\n-        // Only check this for TAIT. RPIT already supports `src/test/ui/impl-trait/nested-return-type2.rs`\n-        // on stable and we'd break that.\n-        if let OpaqueTyOrigin::TyAlias = origin {\n-            // This logic duplicates most of `check_opaque_meets_bounds`.\n-            // FIXME(oli-obk): Also do region checks here and then consider removing `check_opaque_meets_bounds` entirely.\n-            let param_env = self.tcx.param_env(def_id);\n-            let body_id = self.tcx.local_def_id_to_hir_id(def_id.as_local().unwrap());\n-            self.tcx.infer_ctxt().enter(move |infcx| {\n-                // Require the hidden type to be well-formed with only the generics of the opaque type.\n-                // Defining use functions may have more bounds than the opaque type, which is ok, as long as the\n-                // hidden type is well formed even without those bounds.\n-                let predicate =\n-                    ty::Binder::dummy(ty::PredicateKind::WellFormed(definition_ty.into()))\n-                        .to_predicate(infcx.tcx);\n-                let mut fulfillment_cx = <dyn TraitEngine<'tcx>>::new(infcx.tcx);\n-\n-                // Require that the hidden type actually fulfills all the bounds of the opaque type, even without\n-                // the bounds that the function supplies.\n-                match infcx.register_hidden_type(\n-                    OpaqueTypeKey { def_id, substs: id_substs },\n-                    ObligationCause::misc(instantiated_ty.span, body_id),\n-                    param_env,\n-                    definition_ty,\n-                    origin,\n-                ) {\n-                    Ok(infer_ok) => {\n-                        for obligation in infer_ok.obligations {\n-                            fulfillment_cx.register_predicate_obligation(&infcx, obligation);\n-                        }\n-                    }\n-                    Err(err) => {\n-                        infcx\n-                            .report_mismatched_types(\n-                                &ObligationCause::misc(instantiated_ty.span, body_id),\n-                                self.tcx.mk_opaque(def_id, id_substs),\n-                                definition_ty,\n-                                err,\n-                            )\n-                            .emit();\n-                    }\n-                }\n-\n-                fulfillment_cx.register_predicate_obligation(\n-                    &infcx,\n-                    Obligation::misc(instantiated_ty.span, body_id, param_env, predicate),\n-                );\n-\n-                // Check that all obligations are satisfied by the implementation's\n-                // version.\n-                let errors = fulfillment_cx.select_all_or_error(&infcx);\n-\n-                let _ = infcx.inner.borrow_mut().opaque_type_storage.take_opaque_types();\n-\n-                if errors.is_empty() {\n-                    definition_ty\n-                } else {\n-                    infcx.report_fulfillment_errors(&errors, None, false);\n-                    self.tcx.ty_error()\n-                }\n-            })\n-        } else {\n-            definition_ty\n-        }\n-    }\n-}\n-\n-fn check_opaque_type_parameter_valid(\n-    tcx: TyCtxt<'_>,\n-    opaque_type_key: OpaqueTypeKey<'_>,\n-    origin: OpaqueTyOrigin,\n-    span: Span,\n-) -> bool {\n-    match origin {\n-        // No need to check return position impl trait (RPIT)\n-        // because for type and const parameters they are correct\n-        // by construction: we convert\n-        //\n-        // fn foo<P0..Pn>() -> impl Trait\n-        //\n-        // into\n-        //\n-        // type Foo<P0...Pn>\n-        // fn foo<P0..Pn>() -> Foo<P0...Pn>.\n-        //\n-        // For lifetime parameters we convert\n-        //\n-        // fn foo<'l0..'ln>() -> impl Trait<'l0..'lm>\n-        //\n-        // into\n-        //\n-        // type foo::<'p0..'pn>::Foo<'q0..'qm>\n-        // fn foo<l0..'ln>() -> foo::<'static..'static>::Foo<'l0..'lm>.\n-        //\n-        // which would error here on all of the `'static` args.\n-        OpaqueTyOrigin::FnReturn(..) | OpaqueTyOrigin::AsyncFn(..) => return true,\n-        // Check these\n-        OpaqueTyOrigin::TyAlias => {}\n-    }\n-    let opaque_generics = tcx.generics_of(opaque_type_key.def_id);\n-    let mut seen_params: FxHashMap<_, Vec<_>> = FxHashMap::default();\n-    for (i, arg) in opaque_type_key.substs.iter().enumerate() {\n-        let arg_is_param = match arg.unpack() {\n-            GenericArgKind::Type(ty) => matches!(ty.kind(), ty::Param(_)),\n-            GenericArgKind::Lifetime(lt) if lt.is_static() => {\n-                tcx.sess\n-                    .struct_span_err(span, \"non-defining opaque type use in defining scope\")\n-                    .span_label(\n-                        tcx.def_span(opaque_generics.param_at(i, tcx).def_id),\n-                        \"cannot use static lifetime; use a bound lifetime \\\n-                                    instead or remove the lifetime parameter from the \\\n-                                    opaque type\",\n-                    )\n-                    .emit();\n-                return false;\n-            }\n-            GenericArgKind::Lifetime(lt) => {\n-                matches!(*lt, ty::ReEarlyBound(_) | ty::ReFree(_))\n-            }\n-            GenericArgKind::Const(ct) => matches!(ct.kind(), ty::ConstKind::Param(_)),\n-        };\n-\n-        if arg_is_param {\n-            seen_params.entry(arg).or_default().push(i);\n-        } else {\n-            // Prevent `fn foo() -> Foo<u32>` from being defining.\n-            let opaque_param = opaque_generics.param_at(i, tcx);\n-            tcx.sess\n-                .struct_span_err(span, \"non-defining opaque type use in defining scope\")\n-                .span_note(\n-                    tcx.def_span(opaque_param.def_id),\n-                    &format!(\n-                        \"used non-generic {} `{}` for generic parameter\",\n-                        opaque_param.kind.descr(),\n-                        arg,\n-                    ),\n-                )\n-                .emit();\n-            return false;\n-        }\n-    }\n-\n-    for (_, indices) in seen_params {\n-        if indices.len() > 1 {\n-            let descr = opaque_generics.param_at(indices[0], tcx).kind.descr();\n-            let spans: Vec<_> = indices\n-                .into_iter()\n-                .map(|i| tcx.def_span(opaque_generics.param_at(i, tcx).def_id))\n-                .collect();\n-            tcx.sess\n-                .struct_span_err(span, \"non-defining opaque type use in defining scope\")\n-                .span_note(spans, &format!(\"{} used multiple times\", descr))\n-                .emit();\n-            return false;\n-        }\n-    }\n-    true\n-}\n-\n-struct ReverseMapper<'tcx> {\n-    tcx: TyCtxt<'tcx>,\n-\n-    opaque_type_def_id: DefId,\n-    map: FxHashMap<GenericArg<'tcx>, GenericArg<'tcx>>,\n-    map_missing_regions_to_empty: bool,\n-\n-    /// initially `Some`, set to `None` once error has been reported\n-    hidden_ty: Option<Ty<'tcx>>,\n-\n-    /// Span of function being checked.\n-    span: Span,\n-}\n-\n-impl<'tcx> ReverseMapper<'tcx> {\n-    fn new(\n-        tcx: TyCtxt<'tcx>,\n-        opaque_type_def_id: DefId,\n-        map: FxHashMap<GenericArg<'tcx>, GenericArg<'tcx>>,\n-        hidden_ty: Ty<'tcx>,\n-        span: Span,\n-    ) -> Self {\n-        Self {\n-            tcx,\n-            opaque_type_def_id,\n-            map,\n-            map_missing_regions_to_empty: false,\n-            hidden_ty: Some(hidden_ty),\n-            span,\n-        }\n-    }\n-\n-    fn fold_kind_mapping_missing_regions_to_empty(\n-        &mut self,\n-        kind: GenericArg<'tcx>,\n-    ) -> GenericArg<'tcx> {\n-        assert!(!self.map_missing_regions_to_empty);\n-        self.map_missing_regions_to_empty = true;\n-        let kind = kind.fold_with(self);\n-        self.map_missing_regions_to_empty = false;\n-        kind\n-    }\n-\n-    fn fold_kind_normally(&mut self, kind: GenericArg<'tcx>) -> GenericArg<'tcx> {\n-        assert!(!self.map_missing_regions_to_empty);\n-        kind.fold_with(self)\n-    }\n-}\n-\n-impl<'tcx> TypeFolder<'tcx> for ReverseMapper<'tcx> {\n-    fn tcx(&self) -> TyCtxt<'tcx> {\n-        self.tcx\n-    }\n-\n-    #[instrument(skip(self), level = \"debug\")]\n-    fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n-        match *r {\n-            // Ignore bound regions and `'static` regions that appear in the\n-            // type, we only need to remap regions that reference lifetimes\n-            // from the function declaration.\n-            // This would ignore `'r` in a type like `for<'r> fn(&'r u32)`.\n-            ty::ReLateBound(..) | ty::ReStatic => return r,\n-\n-            // If regions have been erased (by writeback), don't try to unerase\n-            // them.\n-            ty::ReErased => return r,\n-\n-            // The regions that we expect from borrow checking.\n-            ty::ReEarlyBound(_) | ty::ReFree(_) | ty::ReEmpty(ty::UniverseIndex::ROOT) => {}\n-\n-            ty::ReEmpty(_) | ty::RePlaceholder(_) | ty::ReVar(_) => {\n-                // All of the regions in the type should either have been\n-                // erased by writeback, or mapped back to named regions by\n-                // borrow checking.\n-                bug!(\"unexpected region kind in opaque type: {:?}\", r);\n-            }\n-        }\n-\n-        let generics = self.tcx().generics_of(self.opaque_type_def_id);\n-        match self.map.get(&r.into()).map(|k| k.unpack()) {\n-            Some(GenericArgKind::Lifetime(r1)) => r1,\n-            Some(u) => panic!(\"region mapped to unexpected kind: {:?}\", u),\n-            None if self.map_missing_regions_to_empty => self.tcx.lifetimes.re_root_empty,\n-            None if generics.parent.is_some() => {\n-                if let Some(hidden_ty) = self.hidden_ty.take() {\n-                    unexpected_hidden_region_diagnostic(\n-                        self.tcx,\n-                        self.tcx.def_span(self.opaque_type_def_id),\n-                        hidden_ty,\n-                        r,\n-                    )\n-                    .emit();\n-                }\n-                self.tcx.lifetimes.re_root_empty\n-            }\n-            None => {\n-                self.tcx\n-                    .sess\n-                    .struct_span_err(self.span, \"non-defining opaque type use in defining scope\")\n-                    .span_label(\n-                        self.span,\n-                        format!(\n-                            \"lifetime `{}` is part of concrete type but not used in \\\n-                                 parameter list of the `impl Trait` type alias\",\n-                            r\n-                        ),\n-                    )\n-                    .emit();\n-\n-                self.tcx().lifetimes.re_static\n-            }\n-        }\n-    }\n-\n-    fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n-        match *ty.kind() {\n-            ty::Closure(def_id, substs) => {\n-                // I am a horrible monster and I pray for death. When\n-                // we encounter a closure here, it is always a closure\n-                // from within the function that we are currently\n-                // type-checking -- one that is now being encapsulated\n-                // in an opaque type. Ideally, we would\n-                // go through the types/lifetimes that it references\n-                // and treat them just like we would any other type,\n-                // which means we would error out if we find any\n-                // reference to a type/region that is not in the\n-                // \"reverse map\".\n-                //\n-                // **However,** in the case of closures, there is a\n-                // somewhat subtle (read: hacky) consideration. The\n-                // problem is that our closure types currently include\n-                // all the lifetime parameters declared on the\n-                // enclosing function, even if they are unused by the\n-                // closure itself. We can't readily filter them out,\n-                // so here we replace those values with `'empty`. This\n-                // can't really make a difference to the rest of the\n-                // compiler; those regions are ignored for the\n-                // outlives relation, and hence don't affect trait\n-                // selection or auto traits, and they are erased\n-                // during codegen.\n-\n-                let generics = self.tcx.generics_of(def_id);\n-                let substs = self.tcx.mk_substs(substs.iter().enumerate().map(|(index, kind)| {\n-                    if index < generics.parent_count {\n-                        // Accommodate missing regions in the parent kinds...\n-                        self.fold_kind_mapping_missing_regions_to_empty(kind)\n-                    } else {\n-                        // ...but not elsewhere.\n-                        self.fold_kind_normally(kind)\n-                    }\n-                }));\n-\n-                self.tcx.mk_closure(def_id, substs)\n-            }\n-\n-            ty::Generator(def_id, substs, movability) => {\n-                let generics = self.tcx.generics_of(def_id);\n-                let substs = self.tcx.mk_substs(substs.iter().enumerate().map(|(index, kind)| {\n-                    if index < generics.parent_count {\n-                        // Accommodate missing regions in the parent kinds...\n-                        self.fold_kind_mapping_missing_regions_to_empty(kind)\n-                    } else {\n-                        // ...but not elsewhere.\n-                        self.fold_kind_normally(kind)\n-                    }\n-                }));\n-\n-                self.tcx.mk_generator(def_id, substs, movability)\n-            }\n-\n-            ty::Param(param) => {\n-                // Look it up in the substitution list.\n-                match self.map.get(&ty.into()).map(|k| k.unpack()) {\n-                    // Found it in the substitution list; replace with the parameter from the\n-                    // opaque type.\n-                    Some(GenericArgKind::Type(t1)) => t1,\n-                    Some(u) => panic!(\"type mapped to unexpected kind: {:?}\", u),\n-                    None => {\n-                        debug!(?param, ?self.map);\n-                        self.tcx\n-                            .sess\n-                            .struct_span_err(\n-                                self.span,\n-                                &format!(\n-                                    \"type parameter `{}` is part of concrete type but not \\\n-                                          used in parameter list for the `impl Trait` type alias\",\n-                                    ty\n-                                ),\n-                            )\n-                            .emit();\n-\n-                        self.tcx().ty_error()\n-                    }\n-                }\n-            }\n-\n-            _ => ty.super_fold_with(self),\n-        }\n-    }\n-\n-    fn fold_const(&mut self, ct: ty::Const<'tcx>) -> ty::Const<'tcx> {\n-        trace!(\"checking const {:?}\", ct);\n-        // Find a const parameter\n-        match ct.kind() {\n-            ty::ConstKind::Param(..) => {\n-                // Look it up in the substitution list.\n-                match self.map.get(&ct.into()).map(|k| k.unpack()) {\n-                    // Found it in the substitution list, replace with the parameter from the\n-                    // opaque type.\n-                    Some(GenericArgKind::Const(c1)) => c1,\n-                    Some(u) => panic!(\"const mapped to unexpected kind: {:?}\", u),\n-                    None => {\n-                        self.tcx\n-                            .sess\n-                            .struct_span_err(\n-                                self.span,\n-                                &format!(\n-                                    \"const parameter `{}` is part of concrete type but not \\\n-                                          used in parameter list for the `impl Trait` type alias\",\n-                                    ct\n-                                ),\n-                            )\n-                            .emit();\n-\n-                        self.tcx().const_error(ct.ty())\n-                    }\n-                }\n-            }\n-\n-            _ => ct,\n-        }\n-    }\n-}\n-\n-/// Given a set of predicates that apply to an object type, returns\n-/// the region bounds that the (erased) `Self` type must\n-/// outlive. Precisely *because* the `Self` type is erased, the\n-/// parameter `erased_self_ty` must be supplied to indicate what type\n-/// has been used to represent `Self` in the predicates\n-/// themselves. This should really be a unique type; `FreshTy(0)` is a\n-/// popular choice.\n-///\n-/// N.B., in some cases, particularly around higher-ranked bounds,\n-/// this function returns a kind of conservative approximation.\n-/// That is, all regions returned by this function are definitely\n-/// required, but there may be other region bounds that are not\n-/// returned, as well as requirements like `for<'a> T: 'a`.\n-///\n-/// Requires that trait definitions have been processed so that we can\n-/// elaborate predicates and walk supertraits.\n-#[instrument(skip(tcx, predicates), level = \"debug\")]\n-pub(crate) fn required_region_bounds<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    erased_self_ty: Ty<'tcx>,\n-    predicates: impl Iterator<Item = ty::Predicate<'tcx>>,\n-) -> Vec<ty::Region<'tcx>> {\n-    assert!(!erased_self_ty.has_escaping_bound_vars());\n-\n-    traits::elaborate_predicates(tcx, predicates)\n-        .filter_map(|obligation| {\n-            debug!(?obligation);\n-            match obligation.predicate.kind().skip_binder() {\n-                ty::PredicateKind::Projection(..)\n-                | ty::PredicateKind::Trait(..)\n-                | ty::PredicateKind::Subtype(..)\n-                | ty::PredicateKind::Coerce(..)\n-                | ty::PredicateKind::WellFormed(..)\n-                | ty::PredicateKind::ObjectSafe(..)\n-                | ty::PredicateKind::ClosureKind(..)\n-                | ty::PredicateKind::RegionOutlives(..)\n-                | ty::PredicateKind::ConstEvaluatable(..)\n-                | ty::PredicateKind::ConstEquate(..)\n-                | ty::PredicateKind::TypeWellFormedFromEnv(..) => None,\n-                ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(ref t, ref r)) => {\n-                    // Search for a bound of the form `erased_self_ty\n-                    // : 'a`, but be wary of something like `for<'a>\n-                    // erased_self_ty : 'a` (we interpret a\n-                    // higher-ranked bound like that as 'static,\n-                    // though at present the code in `fulfill.rs`\n-                    // considers such bounds to be unsatisfiable, so\n-                    // it's kind of a moot point since you could never\n-                    // construct such an object, but this seems\n-                    // correct even if that code changes).\n-                    if t == &erased_self_ty && !r.has_escaping_bound_vars() {\n-                        Some(*r)\n-                    } else {\n-                        None\n-                    }\n-                }\n-            }\n-        })\n-        .collect()\n-}"}, {"sha": "3dfc7a9cacd97c69016e67242cc660040724c7bb", "filename": "compiler/rustc_trait_selection/src/traits/wf.rs", "status": "modified", "additions": 60, "deletions": 1, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/0f97e02bdc7a53176aa96a53ff8b533947d7649c/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f97e02bdc7a53176aa96a53ff8b533947d7649c/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs?ref=0f97e02bdc7a53176aa96a53ff8b533947d7649c", "patch": "@@ -1,5 +1,4 @@\n use crate::infer::InferCtxt;\n-use crate::opaque_types::required_region_bounds;\n use crate::traits;\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n@@ -810,3 +809,63 @@ pub fn object_region_bounds<'tcx>(\n \n     required_region_bounds(tcx, open_ty, predicates)\n }\n+\n+/// Given a set of predicates that apply to an object type, returns\n+/// the region bounds that the (erased) `Self` type must\n+/// outlive. Precisely *because* the `Self` type is erased, the\n+/// parameter `erased_self_ty` must be supplied to indicate what type\n+/// has been used to represent `Self` in the predicates\n+/// themselves. This should really be a unique type; `FreshTy(0)` is a\n+/// popular choice.\n+///\n+/// N.B., in some cases, particularly around higher-ranked bounds,\n+/// this function returns a kind of conservative approximation.\n+/// That is, all regions returned by this function are definitely\n+/// required, but there may be other region bounds that are not\n+/// returned, as well as requirements like `for<'a> T: 'a`.\n+///\n+/// Requires that trait definitions have been processed so that we can\n+/// elaborate predicates and walk supertraits.\n+#[instrument(skip(tcx, predicates), level = \"debug\")]\n+pub(crate) fn required_region_bounds<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    erased_self_ty: Ty<'tcx>,\n+    predicates: impl Iterator<Item = ty::Predicate<'tcx>>,\n+) -> Vec<ty::Region<'tcx>> {\n+    assert!(!erased_self_ty.has_escaping_bound_vars());\n+\n+    traits::elaborate_predicates(tcx, predicates)\n+        .filter_map(|obligation| {\n+            debug!(?obligation);\n+            match obligation.predicate.kind().skip_binder() {\n+                ty::PredicateKind::Projection(..)\n+                | ty::PredicateKind::Trait(..)\n+                | ty::PredicateKind::Subtype(..)\n+                | ty::PredicateKind::Coerce(..)\n+                | ty::PredicateKind::WellFormed(..)\n+                | ty::PredicateKind::ObjectSafe(..)\n+                | ty::PredicateKind::ClosureKind(..)\n+                | ty::PredicateKind::RegionOutlives(..)\n+                | ty::PredicateKind::ConstEvaluatable(..)\n+                | ty::PredicateKind::ConstEquate(..)\n+                | ty::PredicateKind::TypeWellFormedFromEnv(..) => None,\n+                ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(ref t, ref r)) => {\n+                    // Search for a bound of the form `erased_self_ty\n+                    // : 'a`, but be wary of something like `for<'a>\n+                    // erased_self_ty : 'a` (we interpret a\n+                    // higher-ranked bound like that as 'static,\n+                    // though at present the code in `fulfill.rs`\n+                    // considers such bounds to be unsatisfiable, so\n+                    // it's kind of a moot point since you could never\n+                    // construct such an object, but this seems\n+                    // correct even if that code changes).\n+                    if t == &erased_self_ty && !r.has_escaping_bound_vars() {\n+                        Some(*r)\n+                    } else {\n+                        None\n+                    }\n+                }\n+            }\n+        })\n+        .collect()\n+}"}, {"sha": "649b4338772226762f67194e650621463d1075f6", "filename": "library/core/src/future/into_future.rs", "status": "modified", "additions": 5, "deletions": 13, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0f97e02bdc7a53176aa96a53ff8b533947d7649c/library%2Fcore%2Fsrc%2Ffuture%2Finto_future.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f97e02bdc7a53176aa96a53ff8b533947d7649c/library%2Fcore%2Fsrc%2Ffuture%2Finto_future.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ffuture%2Finto_future.rs?ref=0f97e02bdc7a53176aa96a53ff8b533947d7649c", "patch": "@@ -13,8 +13,6 @@ use crate::future::Future;\n /// on all futures.\n ///\n /// ```no_run\n-/// #![feature(into_future)]\n-///\n /// use std::future::IntoFuture;\n ///\n /// # async fn foo() {\n@@ -33,8 +31,6 @@ use crate::future::Future;\n /// multiple times before being `.await`ed.\n ///\n /// ```rust\n-/// #![feature(into_future)]\n-///\n /// use std::future::{ready, Ready, IntoFuture};\n ///\n /// /// Eventually multiply two numbers\n@@ -91,8 +87,6 @@ use crate::future::Future;\n /// `IntoFuture::into_future` to obtain an instance of `Future`:\n ///\n /// ```rust\n-/// #![feature(into_future)]\n-///\n /// use std::future::IntoFuture;\n ///\n /// /// Convert the output of a future to a string.\n@@ -104,14 +98,14 @@ use crate::future::Future;\n ///     format!(\"{:?}\", fut.await)\n /// }\n /// ```\n-#[unstable(feature = \"into_future\", issue = \"67644\")]\n+#[stable(feature = \"into_future\", since = \"1.64.0\")]\n pub trait IntoFuture {\n     /// The output that the future will produce on completion.\n-    #[unstable(feature = \"into_future\", issue = \"67644\")]\n+    #[stable(feature = \"into_future\", since = \"1.64.0\")]\n     type Output;\n \n     /// Which kind of future are we turning this into?\n-    #[unstable(feature = \"into_future\", issue = \"67644\")]\n+    #[stable(feature = \"into_future\", since = \"1.64.0\")]\n     type IntoFuture: Future<Output = Self::Output>;\n \n     /// Creates a future from a value.\n@@ -121,8 +115,6 @@ pub trait IntoFuture {\n     /// Basic usage:\n     ///\n     /// ```no_run\n-    /// #![feature(into_future)]\n-    ///\n     /// use std::future::IntoFuture;\n     ///\n     /// # async fn foo() {\n@@ -131,12 +123,12 @@ pub trait IntoFuture {\n     /// assert_eq!(\"meow\", fut.await);\n     /// # }\n     /// ```\n-    #[unstable(feature = \"into_future\", issue = \"67644\")]\n+    #[stable(feature = \"into_future\", since = \"1.64.0\")]\n     #[lang = \"into_future\"]\n     fn into_future(self) -> Self::IntoFuture;\n }\n \n-#[unstable(feature = \"into_future\", issue = \"67644\")]\n+#[stable(feature = \"into_future\", since = \"1.64.0\")]\n impl<F: Future> IntoFuture for F {\n     type Output = F::Output;\n     type IntoFuture = F;"}, {"sha": "90eecb9d4a0003e0a9507e3b28d8592e2346f1cb", "filename": "library/core/src/future/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f97e02bdc7a53176aa96a53ff8b533947d7649c/library%2Fcore%2Fsrc%2Ffuture%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f97e02bdc7a53176aa96a53ff8b533947d7649c/library%2Fcore%2Fsrc%2Ffuture%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ffuture%2Fmod.rs?ref=0f97e02bdc7a53176aa96a53ff8b533947d7649c", "patch": "@@ -29,7 +29,7 @@ pub use self::future::Future;\n #[unstable(feature = \"future_join\", issue = \"91642\")]\n pub use self::join::join;\n \n-#[unstable(feature = \"into_future\", issue = \"67644\")]\n+#[stable(feature = \"into_future\", since = \"1.64.0\")]\n pub use into_future::IntoFuture;\n \n #[stable(feature = \"future_readiness_fns\", since = \"1.48.0\")]"}, {"sha": "fa6a5ee1668f8edf229af72c600e19cd35b03472", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0f97e02bdc7a53176aa96a53ff8b533947d7649c/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f97e02bdc7a53176aa96a53ff8b533947d7649c/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=0f97e02bdc7a53176aa96a53ff8b533947d7649c", "patch": "@@ -949,6 +949,7 @@ impl<'a> Builder<'a> {\n     }\n \n     pub(crate) fn download_component(&self, url: &str, dest_path: &Path, help_on_error: &str) {\n+        self.verbose(&format!(\"download {url}\"));\n         // Use a temporary file in case we crash while downloading, to avoid a corrupt download in cache/.\n         let tempfile = self.tempdir().join(dest_path.file_name().unwrap());\n         // While bootstrap itself only supports http and https downloads, downstream forks might"}, {"sha": "ee3b072fe35f2944cf35938a7379973e9f012292", "filename": "src/bootstrap/config.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0f97e02bdc7a53176aa96a53ff8b533947d7649c/src%2Fbootstrap%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f97e02bdc7a53176aa96a53ff8b533947d7649c/src%2Fbootstrap%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.rs?ref=0f97e02bdc7a53176aa96a53ff8b533947d7649c", "patch": "@@ -1558,7 +1558,7 @@ fn download_ci_rustc(builder: &Builder<'_>, commit: &str) {\n         builder.fix_bin_or_dylib(&bin_root.join(\"bin\").join(\"rustc\"));\n         builder.fix_bin_or_dylib(&bin_root.join(\"bin\").join(\"rustdoc\"));\n         let lib_dir = bin_root.join(\"lib\");\n-        for lib in t!(fs::read_dir(lib_dir)) {\n+        for lib in t!(fs::read_dir(&lib_dir), lib_dir.display().to_string()) {\n             let lib = t!(lib);\n             if lib.path().extension() == Some(OsStr::new(\"so\")) {\n                 builder.fix_bin_or_dylib(&lib.path());\n@@ -1634,6 +1634,7 @@ fn download_component(\n         }\n         Some(sha256)\n     } else if tarball.exists() {\n+        builder.unpack(&tarball, &bin_root, prefix);\n         return;\n     } else {\n         None"}, {"sha": "272188f82994c05f2579490d89f6e9d15cafeb9e", "filename": "src/librustdoc/config.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0f97e02bdc7a53176aa96a53ff8b533947d7649c/src%2Flibrustdoc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f97e02bdc7a53176aa96a53ff8b533947d7649c/src%2Flibrustdoc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fconfig.rs?ref=0f97e02bdc7a53176aa96a53ff8b533947d7649c", "patch": "@@ -73,6 +73,8 @@ pub(crate) struct Options {\n     pub(crate) proc_macro_crate: bool,\n     /// How to format errors and warnings.\n     pub(crate) error_format: ErrorOutputType,\n+    /// Width of output buffer to truncate errors appropriately.\n+    pub(crate) diagnostic_width: Option<usize>,\n     /// Library search paths to hand to the compiler.\n     pub(crate) libs: Vec<SearchPath>,\n     /// Library search paths strings to hand to the compiler.\n@@ -331,11 +333,12 @@ impl Options {\n         let config::JsonConfig { json_rendered, json_unused_externs, .. } =\n             config::parse_json(matches);\n         let error_format = config::parse_error_format(matches, color, json_rendered);\n+        let diagnostic_width = matches.opt_get(\"diagnostic-width\").unwrap_or_default();\n \n         let codegen_options = CodegenOptions::build(matches, error_format);\n         let debugging_opts = DebuggingOptions::build(matches, error_format);\n \n-        let diag = new_handler(error_format, None, &debugging_opts);\n+        let diag = new_handler(error_format, None, diagnostic_width, &debugging_opts);\n \n         // check for deprecated options\n         check_deprecated_options(matches, &diag);\n@@ -699,6 +702,7 @@ impl Options {\n             input,\n             proc_macro_crate,\n             error_format,\n+            diagnostic_width,\n             libs,\n             lib_strs,\n             externs,"}, {"sha": "8c494ee28cc1f404963da09a9a58ac9e79b2e3e1", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0f97e02bdc7a53176aa96a53ff8b533947d7649c/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f97e02bdc7a53176aa96a53ff8b533947d7649c/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=0f97e02bdc7a53176aa96a53ff8b533947d7649c", "patch": "@@ -154,6 +154,7 @@ impl<'tcx> DocContext<'tcx> {\n pub(crate) fn new_handler(\n     error_format: ErrorOutputType,\n     source_map: Option<Lrc<source_map::SourceMap>>,\n+    diagnostic_width: Option<usize>,\n     debugging_opts: &DebuggingOptions,\n ) -> rustc_errors::Handler {\n     let fallback_bundle =\n@@ -169,7 +170,7 @@ pub(crate) fn new_handler(\n                     fallback_bundle,\n                     short,\n                     debugging_opts.teach,\n-                    debugging_opts.terminal_width,\n+                    diagnostic_width,\n                     false,\n                 )\n                 .ui_testing(debugging_opts.ui_testing),\n@@ -187,7 +188,7 @@ pub(crate) fn new_handler(\n                     fallback_bundle,\n                     pretty,\n                     json_rendered,\n-                    debugging_opts.terminal_width,\n+                    diagnostic_width,\n                     false,\n                 )\n                 .ui_testing(debugging_opts.ui_testing),\n@@ -208,6 +209,7 @@ pub(crate) fn create_config(\n         crate_name,\n         proc_macro_crate,\n         error_format,\n+        diagnostic_width,\n         libs,\n         externs,\n         mut cfgs,\n@@ -266,6 +268,7 @@ pub(crate) fn create_config(\n         actually_rustdoc: true,\n         debugging_opts,\n         error_format,\n+        diagnostic_width,\n         edition,\n         describe_lints,\n         crate_name,"}, {"sha": "0d3ec7ecb6448052f90987cb3517c9f90c5f9971", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/0f97e02bdc7a53176aa96a53ff8b533947d7649c/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f97e02bdc7a53176aa96a53ff8b533947d7649c/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=0f97e02bdc7a53176aa96a53ff8b533947d7649c", "patch": "@@ -462,6 +462,14 @@ fn opts() -> Vec<RustcOptGroup> {\n                 \"human|json|short\",\n             )\n         }),\n+        unstable(\"diagnostic-width\", |o| {\n+            o.optopt(\n+                \"\",\n+                \"diagnostic-width\",\n+                \"Provide width of the output for truncated error messages\",\n+                \"WIDTH\",\n+            )\n+        }),\n         stable(\"json\", |o| {\n             o.optopt(\"\", \"json\", \"Configure the structure of JSON diagnostics\", \"CONFIG\")\n         }),\n@@ -733,7 +741,12 @@ fn run_renderer<'tcx, T: formats::FormatRenderer<'tcx>>(\n }\n \n fn main_options(options: config::Options) -> MainResult {\n-    let diag = core::new_handler(options.error_format, None, &options.debugging_opts);\n+    let diag = core::new_handler(\n+        options.error_format,\n+        None,\n+        options.diagnostic_width,\n+        &options.debugging_opts,\n+    );\n \n     match (options.should_test, options.markdown_input()) {\n         (true, true) => return wrap_return(&diag, markdown::test(options)),"}, {"sha": "08877af92865742980f71988f10e2a814cc5a4ba", "filename": "src/test/run-make/issue-88756-default-output/output-default.stdout", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0f97e02bdc7a53176aa96a53ff8b533947d7649c/src%2Ftest%2Frun-make%2Fissue-88756-default-output%2Foutput-default.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/0f97e02bdc7a53176aa96a53ff8b533947d7649c/src%2Ftest%2Frun-make%2Fissue-88756-default-output%2Foutput-default.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fissue-88756-default-output%2Foutput-default.stdout?ref=0f97e02bdc7a53176aa96a53ff8b533947d7649c", "patch": "@@ -110,6 +110,9 @@ Options:\n                         never = never colorize output\n         --error-format human|json|short\n                         How errors and other messages are produced\n+        --diagnostic-width WIDTH\n+                        Provide width of the output for truncated error\n+                        messages\n         --json CONFIG   Configure the structure of JSON diagnostics\n         --disable-minification \n                         Disable minification applied on JS files"}, {"sha": "61961d5ec710e2527735863bbce062387b02279b", "filename": "src/test/rustdoc-ui/diagnostic-width.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0f97e02bdc7a53176aa96a53ff8b533947d7649c/src%2Ftest%2Frustdoc-ui%2Fdiagnostic-width.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f97e02bdc7a53176aa96a53ff8b533947d7649c/src%2Ftest%2Frustdoc-ui%2Fdiagnostic-width.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fdiagnostic-width.rs?ref=0f97e02bdc7a53176aa96a53ff8b533947d7649c", "patch": "@@ -0,0 +1,5 @@\n+// compile-flags: -Zunstable-options --diagnostic-width=10\n+#![deny(rustdoc::bare_urls)]\n+\n+/// This is a long line that contains a http://link.com\n+pub struct Foo; //~^ ERROR"}, {"sha": "fed049d2b37bcdb5f7c60b218d04b312dabec6b4", "filename": "src/test/rustdoc-ui/diagnostic-width.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/0f97e02bdc7a53176aa96a53ff8b533947d7649c/src%2Ftest%2Frustdoc-ui%2Fdiagnostic-width.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f97e02bdc7a53176aa96a53ff8b533947d7649c/src%2Ftest%2Frustdoc-ui%2Fdiagnostic-width.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fdiagnostic-width.stderr?ref=0f97e02bdc7a53176aa96a53ff8b533947d7649c", "patch": "@@ -0,0 +1,15 @@\n+error: this URL is not a hyperlink\n+  --> $DIR/diagnostic-width.rs:4:41\n+   |\n+LL | ... a http://link.com\n+   |       ^^^^^^^^^^^^^^^ help: use an automatic link instead: `<http://link.com>`\n+   |\n+note: the lint level is defined here\n+  --> $DIR/diagnostic-width.rs:2:9\n+   |\n+LL | ...ny(rustdoc::bare_url...\n+   |       ^^^^^^^^^^^^^^^^^^\n+   = note: bare URLs are not automatically turned into clickable links\n+\n+error: aborting due to previous error\n+"}, {"sha": "8bf1385b3c5cde4b0f1b105759a2c0151f6aaf34", "filename": "src/test/ui/async-await/await-into-future.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f97e02bdc7a53176aa96a53ff8b533947d7649c/src%2Ftest%2Fui%2Fasync-await%2Fawait-into-future.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f97e02bdc7a53176aa96a53ff8b533947d7649c/src%2Ftest%2Fui%2Fasync-await%2Fawait-into-future.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fawait-into-future.rs?ref=0f97e02bdc7a53176aa96a53ff8b533947d7649c", "patch": "@@ -1,8 +1,6 @@\n // run-pass\n // aux-build: issue-72470-lib.rs\n // edition:2021\n-#![feature(into_future)]\n-\n extern crate issue_72470_lib;\n use std::{future::{Future, IntoFuture}, pin::Pin};\n "}, {"sha": "289bfbabd949bb48264eb4fb431164c26077c393", "filename": "src/test/ui/diagnostic-width/flag-human.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0f97e02bdc7a53176aa96a53ff8b533947d7649c/src%2Ftest%2Fui%2Fdiagnostic-width%2Fflag-human.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f97e02bdc7a53176aa96a53ff8b533947d7649c/src%2Ftest%2Fui%2Fdiagnostic-width%2Fflag-human.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdiagnostic-width%2Fflag-human.rs?ref=0f97e02bdc7a53176aa96a53ff8b533947d7649c", "patch": "@@ -0,0 +1,9 @@\n+// compile-flags: --diagnostic-width=20\n+\n+// This test checks that `-Z output-width` effects the human error output by restricting it to an\n+// arbitrarily low value so that the effect is visible.\n+\n+fn main() {\n+    let _: () = 42;\n+    //~^ ERROR mismatched types\n+}"}, {"sha": "393dcf2b82845b1da2a4d6d0352d44c7cdc978a1", "filename": "src/test/ui/diagnostic-width/flag-human.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/0f97e02bdc7a53176aa96a53ff8b533947d7649c/src%2Ftest%2Fui%2Fdiagnostic-width%2Fflag-human.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f97e02bdc7a53176aa96a53ff8b533947d7649c/src%2Ftest%2Fui%2Fdiagnostic-width%2Fflag-human.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdiagnostic-width%2Fflag-human.stderr?ref=0f97e02bdc7a53176aa96a53ff8b533947d7649c", "previous_filename": "src/test/ui/terminal-width/flag-human.stderr"}, {"sha": "51a1fb447c7d22df069e10271318c75b40c5100d", "filename": "src/test/ui/diagnostic-width/flag-json.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0f97e02bdc7a53176aa96a53ff8b533947d7649c/src%2Ftest%2Fui%2Fdiagnostic-width%2Fflag-json.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f97e02bdc7a53176aa96a53ff8b533947d7649c/src%2Ftest%2Fui%2Fdiagnostic-width%2Fflag-json.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdiagnostic-width%2Fflag-json.rs?ref=0f97e02bdc7a53176aa96a53ff8b533947d7649c", "patch": "@@ -0,0 +1,9 @@\n+// compile-flags: --diagnostic-width=20 --error-format=json\n+\n+// This test checks that `-Z output-width` effects the JSON error output by restricting it to an\n+// arbitrarily low value so that the effect is visible.\n+\n+fn main() {\n+    let _: () = 42;\n+    //~^ ERROR arguments to this function are incorrect\n+}"}, {"sha": "b21391d1640efce3144aee31a623d5ae5691a3a4", "filename": "src/test/ui/diagnostic-width/flag-json.stderr", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f97e02bdc7a53176aa96a53ff8b533947d7649c/src%2Ftest%2Fui%2Fdiagnostic-width%2Fflag-json.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f97e02bdc7a53176aa96a53ff8b533947d7649c/src%2Ftest%2Fui%2Fdiagnostic-width%2Fflag-json.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdiagnostic-width%2Fflag-json.stderr?ref=0f97e02bdc7a53176aa96a53ff8b533947d7649c", "patch": "@@ -24,7 +24,7 @@ This error occurs when an expression was used in a place where the compiler\n expected an expression of a different type. It can occur in several cases, the\n most common being when calling a function and passing an argument which has a\n different type than the matching type in the function declaration.\n-\"},\"level\":\"error\",\"spans\":[{\"file_name\":\"$DIR/flag-json.rs\",\"byte_start\":244,\"byte_end\":246,\"line_start\":7,\"line_end\":7,\"column_start\":17,\"column_end\":19,\"is_primary\":true,\"text\":[{\"text\":\"    let _: () = 42;\",\"highlight_start\":17,\"highlight_end\":19}],\"label\":\"expected `()`, found integer\",\"suggested_replacement\":null,\"suggestion_applicability\":null,\"expansion\":null},{\"file_name\":\"$DIR/flag-json.rs\",\"byte_start\":239,\"byte_end\":241,\"line_start\":7,\"line_end\":7,\"column_start\":12,\"column_end\":14,\"is_primary\":false,\"text\":[{\"text\":\"    let _: () = 42;\",\"highlight_start\":12,\"highlight_end\":14}],\"label\":\"expected due to this\",\"suggested_replacement\":null,\"suggestion_applicability\":null,\"expansion\":null}],\"children\":[],\"rendered\":\"error[E0308]: mismatched types\n+\"},\"level\":\"error\",\"spans\":[{\"file_name\":\"$DIR/flag-json.rs\",\"byte_start\":243,\"byte_end\":245,\"line_start\":7,\"line_end\":7,\"column_start\":17,\"column_end\":19,\"is_primary\":true,\"text\":[{\"text\":\"    let _: () = 42;\",\"highlight_start\":17,\"highlight_end\":19}],\"label\":\"expected `()`, found integer\",\"suggested_replacement\":null,\"suggestion_applicability\":null,\"expansion\":null},{\"file_name\":\"$DIR/flag-json.rs\",\"byte_start\":238,\"byte_end\":240,\"line_start\":7,\"line_end\":7,\"column_start\":12,\"column_end\":14,\"is_primary\":false,\"text\":[{\"text\":\"    let _: () = 42;\",\"highlight_start\":12,\"highlight_end\":14}],\"label\":\"expected due to this\",\"suggested_replacement\":null,\"suggestion_applicability\":null,\"expansion\":null}],\"children\":[],\"rendered\":\"error[E0308]: mismatched types\n   --> $DIR/flag-json.rs:7:17\n    |\n LL | ..._: () = 42;", "previous_filename": "src/test/ui/terminal-width/flag-json.stderr"}, {"sha": "1989ea8863592038e57e42fb4a0015ac448cccfb", "filename": "src/test/ui/diagnostic-width/non-1-width-unicode-multiline-label.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/0f97e02bdc7a53176aa96a53ff8b533947d7649c/src%2Ftest%2Fui%2Fdiagnostic-width%2Fnon-1-width-unicode-multiline-label.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f97e02bdc7a53176aa96a53ff8b533947d7649c/src%2Ftest%2Fui%2Fdiagnostic-width%2Fnon-1-width-unicode-multiline-label.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdiagnostic-width%2Fnon-1-width-unicode-multiline-label.rs?ref=0f97e02bdc7a53176aa96a53ff8b533947d7649c", "previous_filename": "src/test/ui/terminal-width/non-1-width-unicode-multiline-label.rs"}, {"sha": "bf277362dbab2977369c18f05f6b47754dc456c2", "filename": "src/test/ui/diagnostic-width/non-1-width-unicode-multiline-label.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/0f97e02bdc7a53176aa96a53ff8b533947d7649c/src%2Ftest%2Fui%2Fdiagnostic-width%2Fnon-1-width-unicode-multiline-label.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f97e02bdc7a53176aa96a53ff8b533947d7649c/src%2Ftest%2Fui%2Fdiagnostic-width%2Fnon-1-width-unicode-multiline-label.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdiagnostic-width%2Fnon-1-width-unicode-multiline-label.stderr?ref=0f97e02bdc7a53176aa96a53ff8b533947d7649c", "previous_filename": "src/test/ui/terminal-width/non-1-width-unicode-multiline-label.stderr"}, {"sha": "abd9e189a75378d59123d8feec47890d2a69cc3e", "filename": "src/test/ui/diagnostic-width/non-whitespace-trimming-2.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/0f97e02bdc7a53176aa96a53ff8b533947d7649c/src%2Ftest%2Fui%2Fdiagnostic-width%2Fnon-whitespace-trimming-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f97e02bdc7a53176aa96a53ff8b533947d7649c/src%2Ftest%2Fui%2Fdiagnostic-width%2Fnon-whitespace-trimming-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdiagnostic-width%2Fnon-whitespace-trimming-2.rs?ref=0f97e02bdc7a53176aa96a53ff8b533947d7649c", "previous_filename": "src/test/ui/terminal-width/non-whitespace-trimming-2.rs"}, {"sha": "5dbb9ce45ee9e7b929756560f532e2cab7eb68c2", "filename": "src/test/ui/diagnostic-width/non-whitespace-trimming-2.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/0f97e02bdc7a53176aa96a53ff8b533947d7649c/src%2Ftest%2Fui%2Fdiagnostic-width%2Fnon-whitespace-trimming-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f97e02bdc7a53176aa96a53ff8b533947d7649c/src%2Ftest%2Fui%2Fdiagnostic-width%2Fnon-whitespace-trimming-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdiagnostic-width%2Fnon-whitespace-trimming-2.stderr?ref=0f97e02bdc7a53176aa96a53ff8b533947d7649c", "previous_filename": "src/test/ui/terminal-width/non-whitespace-trimming-2.stderr"}, {"sha": "8d4d1b1627940c2ab2e5d5b08f1d1c9e01b7e57f", "filename": "src/test/ui/diagnostic-width/non-whitespace-trimming-unicode.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/0f97e02bdc7a53176aa96a53ff8b533947d7649c/src%2Ftest%2Fui%2Fdiagnostic-width%2Fnon-whitespace-trimming-unicode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f97e02bdc7a53176aa96a53ff8b533947d7649c/src%2Ftest%2Fui%2Fdiagnostic-width%2Fnon-whitespace-trimming-unicode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdiagnostic-width%2Fnon-whitespace-trimming-unicode.rs?ref=0f97e02bdc7a53176aa96a53ff8b533947d7649c", "previous_filename": "src/test/ui/terminal-width/non-whitespace-trimming-unicode.rs"}, {"sha": "1e5ff9398321fd91a345e29371d5543f836812c4", "filename": "src/test/ui/diagnostic-width/non-whitespace-trimming-unicode.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/0f97e02bdc7a53176aa96a53ff8b533947d7649c/src%2Ftest%2Fui%2Fdiagnostic-width%2Fnon-whitespace-trimming-unicode.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f97e02bdc7a53176aa96a53ff8b533947d7649c/src%2Ftest%2Fui%2Fdiagnostic-width%2Fnon-whitespace-trimming-unicode.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdiagnostic-width%2Fnon-whitespace-trimming-unicode.stderr?ref=0f97e02bdc7a53176aa96a53ff8b533947d7649c", "previous_filename": "src/test/ui/terminal-width/non-whitespace-trimming-unicode.stderr"}, {"sha": "f6c8d345c652e89226f96b5c0bdc157679bebb44", "filename": "src/test/ui/diagnostic-width/non-whitespace-trimming.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/0f97e02bdc7a53176aa96a53ff8b533947d7649c/src%2Ftest%2Fui%2Fdiagnostic-width%2Fnon-whitespace-trimming.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f97e02bdc7a53176aa96a53ff8b533947d7649c/src%2Ftest%2Fui%2Fdiagnostic-width%2Fnon-whitespace-trimming.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdiagnostic-width%2Fnon-whitespace-trimming.rs?ref=0f97e02bdc7a53176aa96a53ff8b533947d7649c", "previous_filename": "src/test/ui/terminal-width/non-whitespace-trimming.rs"}, {"sha": "c4ff0e16890b23e94fe26b237ef4f80eb7da6f3a", "filename": "src/test/ui/diagnostic-width/non-whitespace-trimming.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/0f97e02bdc7a53176aa96a53ff8b533947d7649c/src%2Ftest%2Fui%2Fdiagnostic-width%2Fnon-whitespace-trimming.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f97e02bdc7a53176aa96a53ff8b533947d7649c/src%2Ftest%2Fui%2Fdiagnostic-width%2Fnon-whitespace-trimming.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdiagnostic-width%2Fnon-whitespace-trimming.stderr?ref=0f97e02bdc7a53176aa96a53ff8b533947d7649c", "previous_filename": "src/test/ui/terminal-width/non-whitespace-trimming.stderr"}, {"sha": "ade21753b457c8084d47cec2e909122630a7700b", "filename": "src/test/ui/diagnostic-width/tabs-trimming.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/0f97e02bdc7a53176aa96a53ff8b533947d7649c/src%2Ftest%2Fui%2Fdiagnostic-width%2Ftabs-trimming.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f97e02bdc7a53176aa96a53ff8b533947d7649c/src%2Ftest%2Fui%2Fdiagnostic-width%2Ftabs-trimming.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdiagnostic-width%2Ftabs-trimming.rs?ref=0f97e02bdc7a53176aa96a53ff8b533947d7649c", "previous_filename": "src/test/ui/terminal-width/tabs-trimming.rs"}, {"sha": "6c8d9afc73b2aabb35bf5e98266ce9f32cda4277", "filename": "src/test/ui/diagnostic-width/tabs-trimming.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/0f97e02bdc7a53176aa96a53ff8b533947d7649c/src%2Ftest%2Fui%2Fdiagnostic-width%2Ftabs-trimming.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f97e02bdc7a53176aa96a53ff8b533947d7649c/src%2Ftest%2Fui%2Fdiagnostic-width%2Ftabs-trimming.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdiagnostic-width%2Ftabs-trimming.stderr?ref=0f97e02bdc7a53176aa96a53ff8b533947d7649c", "previous_filename": "src/test/ui/terminal-width/tabs-trimming.stderr"}, {"sha": "c68f678aab3495a7dcc4cd6fc7f9c627a96326bf", "filename": "src/test/ui/diagnostic-width/whitespace-trimming-2.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/0f97e02bdc7a53176aa96a53ff8b533947d7649c/src%2Ftest%2Fui%2Fdiagnostic-width%2Fwhitespace-trimming-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f97e02bdc7a53176aa96a53ff8b533947d7649c/src%2Ftest%2Fui%2Fdiagnostic-width%2Fwhitespace-trimming-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdiagnostic-width%2Fwhitespace-trimming-2.rs?ref=0f97e02bdc7a53176aa96a53ff8b533947d7649c", "previous_filename": "src/test/ui/terminal-width/whitespace-trimming-2.rs"}, {"sha": "97a64e603b761b49bd93b33e22c86e3bdeffa05f", "filename": "src/test/ui/diagnostic-width/whitespace-trimming-2.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/0f97e02bdc7a53176aa96a53ff8b533947d7649c/src%2Ftest%2Fui%2Fdiagnostic-width%2Fwhitespace-trimming-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f97e02bdc7a53176aa96a53ff8b533947d7649c/src%2Ftest%2Fui%2Fdiagnostic-width%2Fwhitespace-trimming-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdiagnostic-width%2Fwhitespace-trimming-2.stderr?ref=0f97e02bdc7a53176aa96a53ff8b533947d7649c", "previous_filename": "src/test/ui/terminal-width/whitespace-trimming-2.stderr"}, {"sha": "f747bcf17e0b427992a72926029dba912cd0b181", "filename": "src/test/ui/diagnostic-width/whitespace-trimming.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/0f97e02bdc7a53176aa96a53ff8b533947d7649c/src%2Ftest%2Fui%2Fdiagnostic-width%2Fwhitespace-trimming.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f97e02bdc7a53176aa96a53ff8b533947d7649c/src%2Ftest%2Fui%2Fdiagnostic-width%2Fwhitespace-trimming.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdiagnostic-width%2Fwhitespace-trimming.rs?ref=0f97e02bdc7a53176aa96a53ff8b533947d7649c", "previous_filename": "src/test/ui/terminal-width/whitespace-trimming.rs"}, {"sha": "e296d48893cdac7b50f0df5f0bbb296351a35ce1", "filename": "src/test/ui/diagnostic-width/whitespace-trimming.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/0f97e02bdc7a53176aa96a53ff8b533947d7649c/src%2Ftest%2Fui%2Fdiagnostic-width%2Fwhitespace-trimming.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f97e02bdc7a53176aa96a53ff8b533947d7649c/src%2Ftest%2Fui%2Fdiagnostic-width%2Fwhitespace-trimming.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdiagnostic-width%2Fwhitespace-trimming.stderr?ref=0f97e02bdc7a53176aa96a53ff8b533947d7649c", "previous_filename": "src/test/ui/terminal-width/whitespace-trimming.stderr"}, {"sha": "e445a84fd012e7b2089b3d848bcbaed194dd986e", "filename": "src/test/ui/terminal-width/flag-human.rs", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/eba361ae36be41e42fb8fdf138455307e0ad407c/src%2Ftest%2Fui%2Fterminal-width%2Fflag-human.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eba361ae36be41e42fb8fdf138455307e0ad407c/src%2Ftest%2Fui%2Fterminal-width%2Fflag-human.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fterminal-width%2Fflag-human.rs?ref=eba361ae36be41e42fb8fdf138455307e0ad407c", "patch": "@@ -1,9 +0,0 @@\n-// compile-flags: -Z terminal-width=20\n-\n-// This test checks that `-Z terminal-width` effects the human error output by restricting it to an\n-// arbitrarily low value so that the effect is visible.\n-\n-fn main() {\n-    let _: () = 42;\n-    //~^ ERROR mismatched types\n-}"}, {"sha": "3d2530e204b3336943d618c880414612be503df2", "filename": "src/test/ui/terminal-width/flag-json.rs", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/eba361ae36be41e42fb8fdf138455307e0ad407c/src%2Ftest%2Fui%2Fterminal-width%2Fflag-json.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eba361ae36be41e42fb8fdf138455307e0ad407c/src%2Ftest%2Fui%2Fterminal-width%2Fflag-json.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fterminal-width%2Fflag-json.rs?ref=eba361ae36be41e42fb8fdf138455307e0ad407c", "patch": "@@ -1,9 +0,0 @@\n-// compile-flags: -Z terminal-width=20 --error-format=json\n-\n-// This test checks that `-Z terminal-width` effects the JSON error output by restricting it to an\n-// arbitrarily low value so that the effect is visible.\n-\n-fn main() {\n-    let _: () = 42;\n-    //~^ ERROR arguments to this function are incorrect\n-}"}, {"sha": "be7df08d89f0521de6f2bd871d415ded2e639c2d", "filename": "src/tools/clippy/clippy_lints/src/misc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f97e02bdc7a53176aa96a53ff8b533947d7649c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f97e02bdc7a53176aa96a53ff8b533947d7649c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmisc.rs?ref=0f97e02bdc7a53176aa96a53ff8b533947d7649c", "patch": "@@ -301,7 +301,7 @@ fn in_attributes_expansion(expr: &Expr<'_>) -> bool {\n     use rustc_span::hygiene::MacroKind;\n     if expr.span.from_expansion() {\n         let data = expr.span.ctxt().outer_expn_data();\n-        matches!(data.kind, ExpnKind::Macro(MacroKind::Attr, _))\n+        matches!(data.kind, ExpnKind::Macro(MacroKind::Attr|MacroKind::Derive, _))\n     } else {\n         false\n     }"}, {"sha": "d20977d55d29de60b79fe9202716b827c917c21b", "filename": "src/tools/clippy/tests/ui/used_underscore_binding.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0f97e02bdc7a53176aa96a53ff8b533947d7649c/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fused_underscore_binding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f97e02bdc7a53176aa96a53ff8b533947d7649c/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fused_underscore_binding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fused_underscore_binding.rs?ref=0f97e02bdc7a53176aa96a53ff8b533947d7649c", "patch": "@@ -44,6 +44,12 @@ fn in_struct_field() {\n     s._underscore_field += 1;\n }\n \n+/// Tests that we do not lint if the struct field is used in code created with derive.\n+#[derive(Clone, Debug)]\n+pub struct UnderscoreInStruct {\n+    _foo: u32,\n+}\n+\n /// Tests that we do not lint if the underscore is not a prefix\n fn non_prefix_underscore(some_foo: u32) -> u32 {\n     some_foo + 1"}, {"sha": "61a9161d212da9a281d20bd840948e0dabc81763", "filename": "src/tools/clippy/tests/ui/used_underscore_binding.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f97e02bdc7a53176aa96a53ff8b533947d7649c/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fused_underscore_binding.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f97e02bdc7a53176aa96a53ff8b533947d7649c/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fused_underscore_binding.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fused_underscore_binding.stderr?ref=0f97e02bdc7a53176aa96a53ff8b533947d7649c", "patch": "@@ -31,7 +31,7 @@ LL |     s._underscore_field += 1;\n    |     ^^^^^^^^^^^^^^^^^^^\n \n error: used binding `_i` which is prefixed with an underscore. A leading underscore signals that a binding will not be used\n-  --> $DIR/used_underscore_binding.rs:99:16\n+  --> $DIR/used_underscore_binding.rs:105:16\n    |\n LL |         uses_i(_i);\n    |                ^^"}]}