{"sha": "eff1b3fe4d17dcecf0ec9a30c35d6c88715cb8ea", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVmZjFiM2ZlNGQxN2RjZWNmMGVjOWEzMGMzNWQ2Yzg4NzE1Y2I4ZWE=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-03-23T16:41:46Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-03-23T16:41:46Z"}, "message": "Merge #3689\n\n3689: implement fill match arm assist for tuple of enums r=matklad a=JoshMcguigan\n\nThis updates the fill match arm assist to work in cases where the user is matching on a tuple of enums. \r\n\r\nNote, for now this does not apply when some match arms exist (other than the trivial `_`), but I think this could be added in the future.\r\n\r\nI think this also lays the groundwork for filling match arms when matching on tuples of non-enum values, for example a tuple of an enum and a boolean.\n\nCo-authored-by: Josh Mcguigan <joshmcg88@gmail.com>", "tree": {"sha": "7f5abbc9336a3476de08d8ee5c3284b8d41db72d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7f5abbc9336a3476de08d8ee5c3284b8d41db72d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/eff1b3fe4d17dcecf0ec9a30c35d6c88715cb8ea", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeeObKCRBK7hj4Ov3rIwAAdHIIABfWryiCVMrdyGNHMtDSGPHL\nT2iXeCgCEA+0ugTWmCv+NPTVqRjFWeL9IRxgfJpD+m2VpX81RTRNUe1WxIV6UJ0I\nKcB77UOZTOZiLsTAWI4NBGUkYzgiwzfCg89AGTMaz9cRccj731kdGIuKqopG/1hS\n4zATpFHkBCL9T2kJ0Txm4ultWOl6DtCyfaajoXJfbuwBDcHswufzFNDAg0zG4w2a\nofVVZdlrCLlzZAFumaunNMYYuonFPhq2drd2oKABawNqsPRh+9dPyhMgKSndufYN\nzwl2MlRchr8CP3YkTJnP5xorjxj1Qn7gKT/HadI7eQ3izVmjXx+SJ0jtXWG2Gmk=\n=MH8W\n-----END PGP SIGNATURE-----\n", "payload": "tree 7f5abbc9336a3476de08d8ee5c3284b8d41db72d\nparent b605271d7f3fa3fd3ac4dd0e1520b80b5fb13b40\nparent bc48c9d5116f08efea26da94c82a3eaa1622fc5d\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1584981706 +0000\ncommitter GitHub <noreply@github.com> 1584981706 +0000\n\nMerge #3689\n\n3689: implement fill match arm assist for tuple of enums r=matklad a=JoshMcguigan\n\nThis updates the fill match arm assist to work in cases where the user is matching on a tuple of enums. \r\n\r\nNote, for now this does not apply when some match arms exist (other than the trivial `_`), but I think this could be added in the future.\r\n\r\nI think this also lays the groundwork for filling match arms when matching on tuples of non-enum values, for example a tuple of an enum and a boolean.\n\nCo-authored-by: Josh Mcguigan <joshmcg88@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/eff1b3fe4d17dcecf0ec9a30c35d6c88715cb8ea", "html_url": "https://github.com/rust-lang/rust/commit/eff1b3fe4d17dcecf0ec9a30c35d6c88715cb8ea", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/eff1b3fe4d17dcecf0ec9a30c35d6c88715cb8ea/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b605271d7f3fa3fd3ac4dd0e1520b80b5fb13b40", "url": "https://api.github.com/repos/rust-lang/rust/commits/b605271d7f3fa3fd3ac4dd0e1520b80b5fb13b40", "html_url": "https://github.com/rust-lang/rust/commit/b605271d7f3fa3fd3ac4dd0e1520b80b5fb13b40"}, {"sha": "bc48c9d5116f08efea26da94c82a3eaa1622fc5d", "url": "https://api.github.com/repos/rust-lang/rust/commits/bc48c9d5116f08efea26da94c82a3eaa1622fc5d", "html_url": "https://github.com/rust-lang/rust/commit/bc48c9d5116f08efea26da94c82a3eaa1622fc5d"}], "stats": {"total": 271, "additions": 257, "deletions": 14}, "files": [{"sha": "eb5247b6974e205eb51ead78a5b5a5a80800698e", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/eff1b3fe4d17dcecf0ec9a30c35d6c88715cb8ea/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/eff1b3fe4d17dcecf0ec9a30c35d6c88715cb8ea/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=eff1b3fe4d17dcecf0ec9a30c35d6c88715cb8ea", "patch": "@@ -876,6 +876,7 @@ name = \"ra_assists\"\n version = \"0.1.0\"\n dependencies = [\n  \"format-buf\",\n+ \"itertools\",\n  \"join_to_string\",\n  \"ra_db\",\n  \"ra_fmt\","}, {"sha": "85adddb5bb57217e0f97669dae0234f303816ea0", "filename": "crates/ra_assists/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/eff1b3fe4d17dcecf0ec9a30c35d6c88715cb8ea/crates%2Fra_assists%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/eff1b3fe4d17dcecf0ec9a30c35d6c88715cb8ea/crates%2Fra_assists%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2FCargo.toml?ref=eff1b3fe4d17dcecf0ec9a30c35d6c88715cb8ea", "patch": "@@ -11,6 +11,7 @@ doctest = false\n format-buf = \"1.0.0\"\n join_to_string = \"0.1.3\"\n rustc-hash = \"1.1.0\"\n+itertools = \"0.8.2\"\n \n ra_syntax = { path = \"../ra_syntax\" }\n ra_text_edit = { path = \"../ra_text_edit\" }"}, {"sha": "7463b2af77a3a5cb0339b32b9a75b12333636e93", "filename": "crates/ra_assists/src/handlers/fill_match_arms.rs", "status": "modified", "additions": 241, "deletions": 14, "changes": 255, "blob_url": "https://github.com/rust-lang/rust/blob/eff1b3fe4d17dcecf0ec9a30c35d6c88715cb8ea/crates%2Fra_assists%2Fsrc%2Fhandlers%2Ffill_match_arms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eff1b3fe4d17dcecf0ec9a30c35d6c88715cb8ea/crates%2Fra_assists%2Fsrc%2Fhandlers%2Ffill_match_arms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Ffill_match_arms.rs?ref=eff1b3fe4d17dcecf0ec9a30c35d6c88715cb8ea", "patch": "@@ -3,6 +3,7 @@\n use std::iter;\n \n use hir::{Adt, HasSource, Semantics};\n+use itertools::Itertools;\n use ra_ide_db::RootDatabase;\n \n use crate::{Assist, AssistCtx, AssistId};\n@@ -39,13 +40,6 @@ pub(crate) fn fill_match_arms(ctx: AssistCtx) -> Option<Assist> {\n     let match_arm_list = match_expr.match_arm_list()?;\n \n     let expr = match_expr.expr()?;\n-    let enum_def = resolve_enum_def(&ctx.sema, &expr)?;\n-    let module = ctx.sema.scope(expr.syntax()).module()?;\n-\n-    let variants = enum_def.variants(ctx.db);\n-    if variants.is_empty() {\n-        return None;\n-    }\n \n     let mut arms: Vec<MatchArm> = match_arm_list.arms().collect();\n     if arms.len() == 1 {\n@@ -54,13 +48,49 @@ pub(crate) fn fill_match_arms(ctx: AssistCtx) -> Option<Assist> {\n         }\n     }\n \n-    let db = ctx.db;\n-    let missing_arms: Vec<MatchArm> = variants\n-        .into_iter()\n-        .filter_map(|variant| build_pat(db, module, variant))\n-        .filter(|variant_pat| is_variant_missing(&mut arms, variant_pat))\n-        .map(|pat| make::match_arm(iter::once(pat), make::expr_unit()))\n-        .collect();\n+    let module = ctx.sema.scope(expr.syntax()).module()?;\n+\n+    let missing_arms: Vec<MatchArm> = if let Some(enum_def) = resolve_enum_def(&ctx.sema, &expr) {\n+        let variants = enum_def.variants(ctx.db);\n+\n+        variants\n+            .into_iter()\n+            .filter_map(|variant| build_pat(ctx.db, module, variant))\n+            .filter(|variant_pat| is_variant_missing(&mut arms, variant_pat))\n+            .map(|pat| make::match_arm(iter::once(pat), make::expr_unit()))\n+            .collect()\n+    } else if let Some(enum_defs) = resolve_tuple_of_enum_def(&ctx.sema, &expr) {\n+        // Partial fill not currently supported for tuple of enums.\n+        if !arms.is_empty() {\n+            return None;\n+        }\n+\n+        // We do not currently support filling match arms for a tuple\n+        // containing a single enum.\n+        if enum_defs.len() < 2 {\n+            return None;\n+        }\n+\n+        // When calculating the match arms for a tuple of enums, we want\n+        // to create a match arm for each possible combination of enum\n+        // values. The `multi_cartesian_product` method transforms\n+        // Vec<Vec<EnumVariant>> into Vec<(EnumVariant, .., EnumVariant)>\n+        // where each tuple represents a proposed match arm.\n+        enum_defs\n+            .into_iter()\n+            .map(|enum_def| enum_def.variants(ctx.db))\n+            .multi_cartesian_product()\n+            .map(|variants| {\n+                let patterns =\n+                    variants.into_iter().filter_map(|variant| build_pat(ctx.db, module, variant));\n+                ast::Pat::from(make::tuple_pat(patterns))\n+            })\n+            .filter(|variant_pat| is_variant_missing(&mut arms, variant_pat))\n+            .map(|pat| make::match_arm(iter::once(pat), make::expr_unit()))\n+            .collect()\n+    } else {\n+        return None;\n+    };\n \n     if missing_arms.is_empty() {\n         return None;\n@@ -104,6 +134,25 @@ fn resolve_enum_def(sema: &Semantics<RootDatabase>, expr: &ast::Expr) -> Option<\n     })\n }\n \n+fn resolve_tuple_of_enum_def(\n+    sema: &Semantics<RootDatabase>,\n+    expr: &ast::Expr,\n+) -> Option<Vec<hir::Enum>> {\n+    sema.type_of_expr(&expr)?\n+        .tuple_fields(sema.db)\n+        .iter()\n+        .map(|ty| {\n+            ty.autoderef(sema.db).find_map(|ty| match ty.as_adt() {\n+                Some(Adt::Enum(e)) => Some(e),\n+                // For now we only handle expansion for a tuple of enums. Here\n+                // we map non-enum items to None and rely on `collect` to\n+                // convert Vec<Option<hir::Enum>> into Option<Vec<hir::Enum>>.\n+                _ => None,\n+            })\n+        })\n+        .collect()\n+}\n+\n fn build_pat(db: &RootDatabase, module: hir::Module, var: hir::EnumVariant) -> Option<ast::Pat> {\n     let path = crate::ast_transform::path_to_ast(module.find_use_path(db, var.into())?);\n \n@@ -151,6 +200,21 @@ mod tests {\n         );\n     }\n \n+    #[test]\n+    fn tuple_of_non_enum() {\n+        // for now this case is not handled, although it potentially could be\n+        // in the future\n+        check_assist_not_applicable(\n+            fill_match_arms,\n+            r#\"\n+            fn main() {\n+                match (0, false)<|> {\n+                }\n+            }\n+            \"#,\n+        );\n+    }\n+\n     #[test]\n     fn partial_fill_record_tuple() {\n         check_assist(\n@@ -307,6 +371,169 @@ mod tests {\n         );\n     }\n \n+    #[test]\n+    fn fill_match_arms_tuple_of_enum() {\n+        check_assist(\n+            fill_match_arms,\n+            r#\"\n+            enum A {\n+                One,\n+                Two,\n+            }\n+            enum B {\n+                One,\n+                Two,\n+            }\n+\n+            fn main() {\n+                let a = A::One;\n+                let b = B::One;\n+                match (a<|>, b) {}\n+            }\n+            \"#,\n+            r#\"\n+            enum A {\n+                One,\n+                Two,\n+            }\n+            enum B {\n+                One,\n+                Two,\n+            }\n+\n+            fn main() {\n+                let a = A::One;\n+                let b = B::One;\n+                match <|>(a, b) {\n+                    (A::One, B::One) => (),\n+                    (A::One, B::Two) => (),\n+                    (A::Two, B::One) => (),\n+                    (A::Two, B::Two) => (),\n+                }\n+            }\n+            \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn fill_match_arms_tuple_of_enum_ref() {\n+        check_assist(\n+            fill_match_arms,\n+            r#\"\n+            enum A {\n+                One,\n+                Two,\n+            }\n+            enum B {\n+                One,\n+                Two,\n+            }\n+\n+            fn main() {\n+                let a = A::One;\n+                let b = B::One;\n+                match (&a<|>, &b) {}\n+            }\n+            \"#,\n+            r#\"\n+            enum A {\n+                One,\n+                Two,\n+            }\n+            enum B {\n+                One,\n+                Two,\n+            }\n+\n+            fn main() {\n+                let a = A::One;\n+                let b = B::One;\n+                match <|>(&a, &b) {\n+                    (A::One, B::One) => (),\n+                    (A::One, B::Two) => (),\n+                    (A::Two, B::One) => (),\n+                    (A::Two, B::Two) => (),\n+                }\n+            }\n+            \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn fill_match_arms_tuple_of_enum_partial() {\n+        check_assist_not_applicable(\n+            fill_match_arms,\n+            r#\"\n+            enum A {\n+                One,\n+                Two,\n+            }\n+            enum B {\n+                One,\n+                Two,\n+            }\n+\n+            fn main() {\n+                let a = A::One;\n+                let b = B::One;\n+                match (a<|>, b) {\n+                    (A::Two, B::One) => (),\n+                }\n+            }\n+            \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn fill_match_arms_tuple_of_enum_not_applicable() {\n+        check_assist_not_applicable(\n+            fill_match_arms,\n+            r#\"\n+            enum A {\n+                One,\n+                Two,\n+            }\n+            enum B {\n+                One,\n+                Two,\n+            }\n+\n+            fn main() {\n+                let a = A::One;\n+                let b = B::One;\n+                match (a<|>, b) {\n+                    (A::Two, B::One) => (),\n+                    (A::One, B::One) => (),\n+                    (A::One, B::Two) => (),\n+                    (A::Two, B::Two) => (),\n+                }\n+            }\n+            \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn fill_match_arms_single_element_tuple_of_enum() {\n+        // For now we don't hande the case of a single element tuple, but\n+        // we could handle this in the future if `make::tuple_pat` allowed\n+        // creating a tuple with a single pattern.\n+        check_assist_not_applicable(\n+            fill_match_arms,\n+            r#\"\n+            enum A {\n+                One,\n+                Two,\n+            }\n+\n+            fn main() {\n+                let a = A::One;\n+                match (a<|>, ) {\n+                }\n+            }\n+            \"#,\n+        );\n+    }\n+\n     #[test]\n     fn test_fill_match_arm_refs() {\n         check_assist("}, {"sha": "9257ccd1a444b021cfc772b83df4e13de828a2d9", "filename": "crates/ra_syntax/src/ast/make.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/eff1b3fe4d17dcecf0ec9a30c35d6c88715cb8ea/crates%2Fra_syntax%2Fsrc%2Fast%2Fmake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eff1b3fe4d17dcecf0ec9a30c35d6c88715cb8ea/crates%2Fra_syntax%2Fsrc%2Fast%2Fmake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fmake.rs?ref=eff1b3fe4d17dcecf0ec9a30c35d6c88715cb8ea", "patch": "@@ -136,6 +136,20 @@ pub fn placeholder_pat() -> ast::PlaceholderPat {\n     }\n }\n \n+/// Creates a tuple of patterns from an interator of patterns.\n+///\n+/// Invariant: `pats` must be length > 1\n+///\n+/// FIXME handle `pats` length == 1\n+pub fn tuple_pat(pats: impl IntoIterator<Item = ast::Pat>) -> ast::TuplePat {\n+    let pats_str = pats.into_iter().map(|p| p.to_string()).join(\", \");\n+    return from_text(&format!(\"({})\", pats_str));\n+\n+    fn from_text(text: &str) -> ast::TuplePat {\n+        ast_from_text(&format!(\"fn f({}: ())\", text))\n+    }\n+}\n+\n pub fn tuple_struct_pat(\n     path: ast::Path,\n     pats: impl IntoIterator<Item = ast::Pat>,"}]}