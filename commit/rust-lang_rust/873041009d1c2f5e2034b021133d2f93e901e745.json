{"sha": "873041009d1c2f5e2034b021133d2f93e901e745", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg3MzA0MTAwOWQxYzJmNWUyMDM0YjAyMTEzM2QyZjkzZTkwMWU3NDU=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-11-02T13:06:43Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-11-05T09:15:25Z"}, "message": "make ValueVisitor mut-polymorphic", "tree": {"sha": "8b73b8045132b61257abd43996cda028fd0d63e9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8b73b8045132b61257abd43996cda028fd0d63e9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/873041009d1c2f5e2034b021133d2f93e901e745", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/873041009d1c2f5e2034b021133d2f93e901e745", "html_url": "https://github.com/rust-lang/rust/commit/873041009d1c2f5e2034b021133d2f93e901e745", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/873041009d1c2f5e2034b021133d2f93e901e745/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7565b5ac6760e16295e1f16dc2af5232278977dc", "url": "https://api.github.com/repos/rust-lang/rust/commits/7565b5ac6760e16295e1f16dc2af5232278977dc", "html_url": "https://github.com/rust-lang/rust/commit/7565b5ac6760e16295e1f16dc2af5232278977dc"}], "stats": {"total": 409, "additions": 190, "deletions": 219}, "files": [{"sha": "011887090eefe8002f3ffffc9b02f2ef415b718c", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/873041009d1c2f5e2034b021133d2f93e901e745/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/873041009d1c2f5e2034b021133d2f93e901e745/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=873041009d1c2f5e2034b021133d2f93e901e745", "patch": "@@ -535,7 +535,7 @@ fn validate_const<'a, 'tcx>(\n     key: ty::ParamEnvAnd<'tcx, GlobalId<'tcx>>,\n ) -> ::rustc::mir::interpret::ConstEvalResult<'tcx> {\n     let cid = key.value;\n-    let mut ecx = mk_eval_cx(tcx, cid.instance, key.param_env).unwrap();\n+    let ecx = mk_eval_cx(tcx, cid.instance, key.param_env).unwrap();\n     let val = (|| {\n         let op = ecx.const_to_op(constant)?;\n         let mut ref_tracking = RefTracking::new(op);"}, {"sha": "8c8b3e2ca77c49ddea6244d1ce8318a12a25a195", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/873041009d1c2f5e2034b021133d2f93e901e745/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/873041009d1c2f5e2034b021133d2f93e901e745/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=873041009d1c2f5e2034b021133d2f93e901e745", "patch": "@@ -129,7 +129,7 @@ struct ValidityVisitor<'rt, 'a: 'rt, 'mir: 'rt, 'tcx: 'a+'rt+'mir, M: Machine<'a\n     path: Vec<PathElem>,\n     ref_tracking: Option<&'rt mut RefTracking<'tcx, M::PointerTag>>,\n     const_mode: bool,\n-    ecx: &'rt mut EvalContext<'a, 'mir, 'tcx, M>,\n+    ecx: &'rt EvalContext<'a, 'mir, 'tcx, M>,\n }\n \n impl<'rt, 'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> ValidityVisitor<'rt, 'a, 'mir, 'tcx, M> {\n@@ -188,8 +188,8 @@ impl<'rt, 'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>>\n     type V = OpTy<'tcx, M::PointerTag>;\n \n     #[inline(always)]\n-    fn ecx(&mut self) -> &mut EvalContext<'a, 'mir, 'tcx, M> {\n-        &mut self.ecx\n+    fn ecx(&self) -> &EvalContext<'a, 'mir, 'tcx, M> {\n+        &self.ecx\n     }\n \n     #[inline]\n@@ -557,7 +557,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n     /// This also toggles between \"run-time\" (no recursion) and \"compile-time\" (with recursion)\n     /// validation (e.g., pointer values are fine in integers at runtime).\n     pub fn validate_operand(\n-        &mut self,\n+        &self,\n         op: OpTy<'tcx, M::PointerTag>,\n         path: Vec<PathElem>,\n         ref_tracking: Option<&mut RefTracking<'tcx, M::PointerTag>>,"}, {"sha": "24789ee1ebfe5b02859b366f0925ebe54fcc8869", "filename": "src/librustc_mir/interpret/visitor.rs", "status": "modified", "additions": 185, "deletions": 214, "changes": 399, "blob_url": "https://github.com/rust-lang/rust/blob/873041009d1c2f5e2034b021133d2f93e901e745/src%2Flibrustc_mir%2Finterpret%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/873041009d1c2f5e2034b021133d2f93e901e745/src%2Flibrustc_mir%2Finterpret%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvisitor.rs?ref=873041009d1c2f5e2034b021133d2f93e901e745", "patch": "@@ -8,7 +8,7 @@ use rustc::mir::interpret::{\n };\n \n use super::{\n-    Machine, EvalContext, MPlaceTy, PlaceTy, OpTy, ImmTy,\n+    Machine, EvalContext, MPlaceTy, OpTy, ImmTy,\n };\n \n // A thing that we can project into, and that has a layout.\n@@ -38,12 +38,13 @@ pub trait Value<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>>: Copy\n     /// Project to the n-th field.\n     fn project_field(\n         self,\n-        ecx: &mut EvalContext<'a, 'mir, 'tcx, M>,\n+        ecx: &EvalContext<'a, 'mir, 'tcx, M>,\n         field: u64,\n     ) -> EvalResult<'tcx, Self>;\n }\n \n-// Operands and places are both values\n+// Operands and memory-places are both values.\n+// Places in general are not due to `place_field` having to do `force_allocation`.\n impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Value<'a, 'mir, 'tcx, M>\n     for OpTy<'tcx, M::PointerTag>\n {\n@@ -77,7 +78,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Value<'a, 'mir, 'tcx, M>\n     #[inline(always)]\n     fn project_field(\n         self,\n-        ecx: &mut EvalContext<'a, 'mir, 'tcx, M>,\n+        ecx: &EvalContext<'a, 'mir, 'tcx, M>,\n         field: u64,\n     ) -> EvalResult<'tcx, Self> {\n         ecx.operand_field(self, field)\n@@ -115,234 +116,204 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Value<'a, 'mir, 'tcx, M>\n \n     #[inline(always)]\n     fn project_field(\n-        self,\n-        ecx: &mut EvalContext<'a, 'mir, 'tcx, M>,\n-        field: u64,\n-    ) -> EvalResult<'tcx, Self> {\n-        ecx.mplace_field(self, field)\n-    }\n-}\n-impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Value<'a, 'mir, 'tcx, M>\n-    for PlaceTy<'tcx, M::PointerTag>\n-{\n-    #[inline(always)]\n-    fn layout(&self) -> TyLayout<'tcx> {\n-        self.layout\n-    }\n-\n-    #[inline(always)]\n-    fn to_op(\n-        self,\n-        ecx: &EvalContext<'a, 'mir, 'tcx, M>,\n-    ) -> EvalResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n-        ecx.place_to_op(self)\n-    }\n-\n-    #[inline(always)]\n-    fn from_mem_place(mplace: MPlaceTy<'tcx, M::PointerTag>) -> Self {\n-        mplace.into()\n-    }\n-\n-    #[inline(always)]\n-    fn project_downcast(\n         self,\n         ecx: &EvalContext<'a, 'mir, 'tcx, M>,\n-        variant: usize,\n-    ) -> EvalResult<'tcx, Self> {\n-        ecx.place_downcast(self, variant)\n-    }\n-\n-    #[inline(always)]\n-    fn project_field(\n-        self,\n-        ecx: &mut EvalContext<'a, 'mir, 'tcx, M>,\n         field: u64,\n     ) -> EvalResult<'tcx, Self> {\n-        ecx.place_field(self, field)\n+        ecx.mplace_field(self, field)\n     }\n }\n \n-// How to traverse a value and what to do when we are at the leaves.\n-pub trait ValueVisitor<'a, 'mir, 'tcx: 'mir+'a, M: Machine<'a, 'mir, 'tcx>>: Sized {\n-    type V: Value<'a, 'mir, 'tcx, M>;\n+macro_rules! make_value_visitor {\n+    ($visitor_trait_name:ident, $($mutability:ident)*) => {\n+        // How to traverse a value and what to do when we are at the leaves.\n+        pub trait $visitor_trait_name<'a, 'mir, 'tcx: 'mir+'a, M: Machine<'a, 'mir, 'tcx>>: Sized {\n+            type V: Value<'a, 'mir, 'tcx, M>;\n \n-    /// The visitor must have an `EvalContext` in it.\n-    fn ecx(&mut self) -> &mut EvalContext<'a, 'mir, 'tcx, M>;\n+            /// The visitor must have an `EvalContext` in it.\n+            fn ecx(&$($mutability)* self)\n+                -> &$($mutability)* EvalContext<'a, 'mir, 'tcx, M>;\n \n-    // Recursive actions, ready to be overloaded.\n-    /// Visit the given value, dispatching as appropriate to more specialized visitors.\n-    #[inline(always)]\n-    fn visit_value(&mut self, v: Self::V) -> EvalResult<'tcx>\n-    {\n-        self.walk_value(v)\n-    }\n-    /// Visit the given value as a union.  No automatic recursion can happen here.\n-    #[inline(always)]\n-    fn visit_union(&mut self, _v: Self::V) -> EvalResult<'tcx>\n-    {\n-        Ok(())\n-    }\n-    /// Visit this vale as an aggregate, you are even getting an iterator yielding\n-    /// all the fields (still in an `EvalResult`, you have to do error handling yourself).\n-    /// Recurses into the fields.\n-    #[inline(always)]\n-    fn visit_aggregate(\n-        &mut self,\n-        v: Self::V,\n-        fields: impl Iterator<Item=EvalResult<'tcx, Self::V>>,\n-    ) -> EvalResult<'tcx> {\n-        self.walk_aggregate(v, fields)\n-    }\n-    /// Called each time we recurse down to a field, passing in old and new value.\n-    /// This gives the visitor the chance to track the stack of nested fields that\n-    /// we are descending through.\n-    #[inline(always)]\n-    fn visit_field(\n-        &mut self,\n-        _old_val: Self::V,\n-        _field: usize,\n-        new_val: Self::V,\n-    ) -> EvalResult<'tcx> {\n-        self.visit_value(new_val)\n-    }\n+            // Recursive actions, ready to be overloaded.\n+            /// Visit the given value, dispatching as appropriate to more specialized visitors.\n+            #[inline(always)]\n+            fn visit_value(&mut self, v: Self::V) -> EvalResult<'tcx>\n+            {\n+                self.walk_value(v)\n+            }\n+            /// Visit the given value as a union.  No automatic recursion can happen here.\n+            #[inline(always)]\n+            fn visit_union(&mut self, _v: Self::V) -> EvalResult<'tcx>\n+            {\n+                Ok(())\n+            }\n+            /// Visit this vale as an aggregate, you are even getting an iterator yielding\n+            /// all the fields (still in an `EvalResult`, you have to do error handling yourself).\n+            /// Recurses into the fields.\n+            #[inline(always)]\n+            fn visit_aggregate(\n+                &mut self,\n+                v: Self::V,\n+                fields: impl Iterator<Item=EvalResult<'tcx, Self::V>>,\n+            ) -> EvalResult<'tcx> {\n+                self.walk_aggregate(v, fields)\n+            }\n+            /// Called each time we recurse down to a field, passing in old and new value.\n+            /// This gives the visitor the chance to track the stack of nested fields that\n+            /// we are descending through.\n+            #[inline(always)]\n+            fn visit_field(\n+                &mut self,\n+                _old_val: Self::V,\n+                _field: usize,\n+                new_val: Self::V,\n+            ) -> EvalResult<'tcx> {\n+                self.visit_value(new_val)\n+            }\n \n-    /// Called whenever we reach a value with uninhabited layout.\n-    /// Recursing to fields will *always* continue after this!  This is not meant to control\n-    /// whether and how we descend recursively/ into the scalar's fields if there are any, it is\n-    /// meant to provide the chance for additional checks when a value of uninhabited layout is\n-    /// detected.\n-    #[inline(always)]\n-    fn visit_uninhabited(&mut self) -> EvalResult<'tcx>\n-    { Ok(()) }\n-    /// Called whenever we reach a value with scalar layout.\n-    /// We do NOT provide a `ScalarMaybeUndef` here to avoid accessing memory if the visitor is not\n-    /// even interested in scalars.\n-    /// Recursing to fields will *always* continue after this!  This is not meant to control\n-    /// whether and how we descend recursively/ into the scalar's fields if there are any, it is\n-    /// meant to provide the chance for additional checks when a value of scalar layout is detected.\n-    #[inline(always)]\n-    fn visit_scalar(&mut self, _v: Self::V, _layout: &layout::Scalar) -> EvalResult<'tcx>\n-    { Ok(()) }\n+            /// Called whenever we reach a value with uninhabited layout.\n+            /// Recursing to fields will *always* continue after this!  This is not meant to control\n+            /// whether and how we descend recursively/ into the scalar's fields if there are any,\n+            /// it is meant to provide the chance for additional checks when a value of uninhabited\n+            /// layout is detected.\n+            #[inline(always)]\n+            fn visit_uninhabited(&mut self) -> EvalResult<'tcx>\n+            { Ok(()) }\n+            /// Called whenever we reach a value with scalar layout.\n+            /// We do NOT provide a `ScalarMaybeUndef` here to avoid accessing memory if the\n+            /// visitor is not even interested in scalars.\n+            /// Recursing to fields will *always* continue after this!  This is not meant to control\n+            /// whether and how we descend recursively/ into the scalar's fields if there are any,\n+            /// it is meant to provide the chance for additional checks when a value of scalar\n+            /// layout is detected.\n+            #[inline(always)]\n+            fn visit_scalar(&mut self, _v: Self::V, _layout: &layout::Scalar) -> EvalResult<'tcx>\n+            { Ok(()) }\n \n-    /// Called whenever we reach a value of primitive type.  There can be no recursion\n-    /// below such a value.  This is the leave function.\n-    #[inline(always)]\n-    fn visit_primitive(&mut self, _val: ImmTy<'tcx, M::PointerTag>) -> EvalResult<'tcx>\n-    { Ok(()) }\n+            /// Called whenever we reach a value of primitive type.  There can be no recursion\n+            /// below such a value.  This is the leave function.\n+            #[inline(always)]\n+            fn visit_primitive(&mut self, _val: ImmTy<'tcx, M::PointerTag>) -> EvalResult<'tcx>\n+            { Ok(()) }\n \n-    // Default recursors. Not meant to be overloaded.\n-    fn walk_aggregate(\n-        &mut self,\n-        v: Self::V,\n-        fields: impl Iterator<Item=EvalResult<'tcx, Self::V>>,\n-    ) -> EvalResult<'tcx> {\n-        // Now iterate over it.\n-        for (idx, field_val) in fields.enumerate() {\n-            self.visit_field(v, idx, field_val?)?;\n-        }\n-        Ok(())\n-    }\n-    fn walk_value(&mut self, v: Self::V) -> EvalResult<'tcx>\n-    {\n-        // If this is a multi-variant layout, we have find the right one and proceed with that.\n-        // (No benefit from making this recursion, but it is equivalent to that.)\n-        match v.layout().variants {\n-            layout::Variants::NicheFilling { .. } |\n-            layout::Variants::Tagged { .. } => {\n-                let op = v.to_op(self.ecx())?;\n-                let idx = self.ecx().read_discriminant(op)?.1;\n-                let inner = v.project_downcast(self.ecx(), idx)?;\n-                trace!(\"walk_value: variant layout: {:#?}\", inner.layout());\n-                // recurse with the inner type\n-                return self.visit_field(v, idx, inner);\n+            // Default recursors. Not meant to be overloaded.\n+            fn walk_aggregate(\n+                &mut self,\n+                v: Self::V,\n+                fields: impl Iterator<Item=EvalResult<'tcx, Self::V>>,\n+            ) -> EvalResult<'tcx> {\n+                // Now iterate over it.\n+                for (idx, field_val) in fields.enumerate() {\n+                    self.visit_field(v, idx, field_val?)?;\n+                }\n+                Ok(())\n             }\n-            layout::Variants::Single { .. } => {}\n-        }\n-\n-        // Even for single variants, we might be able to get a more refined type:\n-        // If it is a trait object, switch to the actual type that was used to create it.\n-        match v.layout().ty.sty {\n-            ty::Dynamic(..) => {\n-                // immediate trait objects are not a thing\n-                let dest = v.to_op(self.ecx())?.to_mem_place();\n-                let inner = self.ecx().unpack_dyn_trait(dest)?.1;\n-                trace!(\"walk_value: dyn object layout: {:#?}\", inner.layout);\n-                // recurse with the inner type\n-                return self.visit_field(v, 0, Value::from_mem_place(inner));\n-            },\n-            _ => {},\n-        };\n+            fn walk_value(&mut self, v: Self::V) -> EvalResult<'tcx>\n+            {\n+                // If this is a multi-variant layout, we have find the right one and proceed with\n+                // that.\n+                match v.layout().variants {\n+                    layout::Variants::NicheFilling { .. } |\n+                    layout::Variants::Tagged { .. } => {\n+                        let op = v.to_op(self.ecx())?;\n+                        let idx = self.ecx().read_discriminant(op)?.1;\n+                        let inner = v.project_downcast(self.ecx(), idx)?;\n+                        trace!(\"walk_value: variant layout: {:#?}\", inner.layout());\n+                        // recurse with the inner type\n+                        return self.visit_field(v, idx, inner);\n+                    }\n+                    layout::Variants::Single { .. } => {}\n+                }\n \n-        // If this is a scalar, visit it as such.\n-        // Things can be aggregates and have scalar layout at the same time, and that\n-        // is very relevant for `NonNull` and similar structs: We need to visit them\n-        // at their scalar layout *before* descending into their fields.\n-        // FIXME: We could avoid some redundant checks here. For newtypes wrapping\n-        // scalars, we do the same check on every \"level\" (e.g. first we check\n-        // MyNewtype and then the scalar in there).\n-        match v.layout().abi {\n-            layout::Abi::Uninhabited => {\n-                self.visit_uninhabited()?;\n-            }\n-            layout::Abi::Scalar(ref layout) => {\n-                self.visit_scalar(v, layout)?;\n-            }\n-            // FIXME: Should we do something for ScalarPair? Vector?\n-            _ => {}\n-        }\n+                // Even for single variants, we might be able to get a more refined type:\n+                // If it is a trait object, switch to the actual type that was used to create it.\n+                match v.layout().ty.sty {\n+                    ty::Dynamic(..) => {\n+                        // immediate trait objects are not a thing\n+                        let dest = v.to_op(self.ecx())?.to_mem_place();\n+                        let inner = self.ecx().unpack_dyn_trait(dest)?.1;\n+                        trace!(\"walk_value: dyn object layout: {:#?}\", inner.layout);\n+                        // recurse with the inner type\n+                        return self.visit_field(v, 0, Value::from_mem_place(inner));\n+                    },\n+                    _ => {},\n+                };\n \n-        // Check primitive types.  We do this after checking the scalar layout,\n-        // just to have that done as well.  Primitives can have varying layout,\n-        // so we check them separately and before aggregate handling.\n-        // It is CRITICAL that we get this check right, or we might be\n-        // validating the wrong thing!\n-        let primitive = match v.layout().fields {\n-            // Primitives appear as Union with 0 fields -- except for Boxes and fat pointers.\n-            layout::FieldPlacement::Union(0) => true,\n-            _ => v.layout().ty.builtin_deref(true).is_some(),\n-        };\n-        if primitive {\n-            let op = v.to_op(self.ecx())?;\n-            let val = self.ecx().read_immediate(op)?;\n-            return self.visit_primitive(val);\n-        }\n+                // If this is a scalar, visit it as such.\n+                // Things can be aggregates and have scalar layout at the same time, and that\n+                // is very relevant for `NonNull` and similar structs: We need to visit them\n+                // at their scalar layout *before* descending into their fields.\n+                // FIXME: We could avoid some redundant checks here. For newtypes wrapping\n+                // scalars, we do the same check on every \"level\" (e.g. first we check\n+                // MyNewtype and then the scalar in there).\n+                match v.layout().abi {\n+                    layout::Abi::Uninhabited => {\n+                        self.visit_uninhabited()?;\n+                    }\n+                    layout::Abi::Scalar(ref layout) => {\n+                        self.visit_scalar(v, layout)?;\n+                    }\n+                    // FIXME: Should we do something for ScalarPair? Vector?\n+                    _ => {}\n+                }\n \n-        // Proceed into the fields.\n-        match v.layout().fields {\n-            layout::FieldPlacement::Union(fields) => {\n-                // Empty unions are not accepted by rustc. That's great, it means we can\n-                // use that as an unambiguous signal for detecting primitives.  Make sure\n-                // we did not miss any primitive.\n-                debug_assert!(fields > 0);\n-                self.visit_union(v)?;\n-            },\n-            layout::FieldPlacement::Arbitrary { ref offsets, .. } => {\n-                // FIXME: We collect in a vec because otherwise there are lifetime errors:\n-                // Projecting to a field needs (mutable!) access to `ecx`.\n-                let fields: Vec<EvalResult<'tcx, Self::V>> =\n-                    (0..offsets.len()).map(|i| {\n-                        v.project_field(self.ecx(), i as u64)\n-                    })\n-                    .collect();\n-                self.visit_aggregate(v, fields.into_iter())?;\n-            },\n-            layout::FieldPlacement::Array { .. } => {\n-                // Let's get an mplace first.\n-                let mplace = if v.layout().is_zst() {\n-                    // it's a ZST, the memory content cannot matter\n-                    MPlaceTy::dangling(v.layout(), self.ecx())\n-                } else {\n-                    // non-ZST array/slice/str cannot be immediate\n-                    v.to_op(self.ecx())?.to_mem_place()\n+                // Check primitive types.  We do this after checking the scalar layout,\n+                // just to have that done as well.  Primitives can have varying layout,\n+                // so we check them separately and before aggregate handling.\n+                // It is CRITICAL that we get this check right, or we might be\n+                // validating the wrong thing!\n+                let primitive = match v.layout().fields {\n+                    // Primitives appear as Union with 0 fields - except for Boxes and fat pointers.\n+                    layout::FieldPlacement::Union(0) => true,\n+                    _ => v.layout().ty.builtin_deref(true).is_some(),\n                 };\n-                // Now we can go over all the fields.\n-                let iter = self.ecx().mplace_array_fields(mplace)?\n-                    .map(|f| f.and_then(|f| {\n-                        Ok(Value::from_mem_place(f))\n-                    }));\n-                self.visit_aggregate(v, iter)?;\n+                if primitive {\n+                    let op = v.to_op(self.ecx())?;\n+                    let val = self.ecx().read_immediate(op)?;\n+                    return self.visit_primitive(val);\n+                }\n+\n+                // Proceed into the fields.\n+                match v.layout().fields {\n+                    layout::FieldPlacement::Union(fields) => {\n+                        // Empty unions are not accepted by rustc. That's great, it means we can\n+                        // use that as an unambiguous signal for detecting primitives.  Make sure\n+                        // we did not miss any primitive.\n+                        debug_assert!(fields > 0);\n+                        self.visit_union(v)?;\n+                    },\n+                    layout::FieldPlacement::Arbitrary { ref offsets, .. } => {\n+                        // FIXME: We collect in a vec because otherwise there are lifetime errors:\n+                        // Projecting to a field needs (mutable!) access to `ecx`.\n+                        let fields: Vec<EvalResult<'tcx, Self::V>> =\n+                            (0..offsets.len()).map(|i| {\n+                                v.project_field(self.ecx(), i as u64)\n+                            })\n+                            .collect();\n+                        self.visit_aggregate(v, fields.into_iter())?;\n+                    },\n+                    layout::FieldPlacement::Array { .. } => {\n+                        // Let's get an mplace first.\n+                        let mplace = if v.layout().is_zst() {\n+                            // it's a ZST, the memory content cannot matter\n+                            MPlaceTy::dangling(v.layout(), self.ecx())\n+                        } else {\n+                            // non-ZST array/slice/str cannot be immediate\n+                            v.to_op(self.ecx())?.to_mem_place()\n+                        };\n+                        // Now we can go over all the fields.\n+                        let iter = self.ecx().mplace_array_fields(mplace)?\n+                            .map(|f| f.and_then(|f| {\n+                                Ok(Value::from_mem_place(f))\n+                            }));\n+                        self.visit_aggregate(v, iter)?;\n+                    }\n+                }\n+                Ok(())\n             }\n         }\n-        Ok(())\n     }\n }\n+\n+make_value_visitor!(ValueVisitor,);\n+make_value_visitor!(MutValueVisitor,mut);"}]}