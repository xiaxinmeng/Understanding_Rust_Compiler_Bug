{"sha": "f2878a656b944ceed6f4a98d7e255784266a3dc0", "node_id": "C_kwDOAAsO6NoAKGYyODc4YTY1NmI5NDRjZWVkNmY0YTk4ZDdlMjU1Nzg0MjY2YTNkYzA", "commit": {"author": {"name": "Yuki Okushi", "email": "jtitor@2k36.org", "date": "2022-08-24T23:51:01Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-08-24T23:51:01Z"}, "message": "Rollup merge of #100964 - bjorn3:sync_cg_clif-2022-08-24, r=bjorn3\n\nSync rustc_codegen_cranelift\n\nThe main highlights this time are support for parallel compilation of codegen units (by me) and improved windows support (by ``@afonso360)`` In addition ``@afonso360`` added abi-checker to cg_clif's CI. This has already catched an abi compatibility issue with AArch64. The fix has landed on Cranelift's main branch, but doesn't yet have a release. ``@uweigand`` also submitted a couple of PR's that will are prerequisites for supporting IBM's s390x architecture.\n\nr? ``@ghost``\n\n``@rustbot`` label +A-codegen +A-cranelift +T-compiler", "tree": {"sha": "d16e04edbb8652251bf70dbef0283e5c372f2d0c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d16e04edbb8652251bf70dbef0283e5c372f2d0c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f2878a656b944ceed6f4a98d7e255784266a3dc0", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjBrllCRBK7hj4Ov3rIwAArWEIAHsJQSkbIWTq41w3LEmVwUEz\n+6VxgVmW22s70wS07sp//zk0xyE3o9I211b1mWbnuIhbAUGS6xAeQGvWqyssICm3\nmm/5teCRKB+DLVKxHVleHgY2AI3s4uOyvPylaGjs65s5Ikh7rTgvd4nPqE09lINo\n9PgZyAChhOL4sczFr+FqvSu76ojin/eU1LE/4cRkaluNDTnlHN83M1wi8cdT9BSB\nvYXlpELp1OaZkySAcZ7S57U2Z8T3LTEiWIudrxKZ22dK6abMZSMtje8EH1ZtsChH\nB1gwyEinEU2IHXsbZjw1BsAF/IVVwHBgxbBmSEa9gJyDITQNXVQ3r4JXoZV1J9Y=\n=Rd4B\n-----END PGP SIGNATURE-----\n", "payload": "tree d16e04edbb8652251bf70dbef0283e5c372f2d0c\nparent 1e1dc7b4c34f57c72d9f07cced15e18596b4c59d\nparent e62e1d4347198e17cfb1fe6fec531cac3b223019\nauthor Yuki Okushi <jtitor@2k36.org> 1661385061 +0900\ncommitter GitHub <noreply@github.com> 1661385061 +0900\n\nRollup merge of #100964 - bjorn3:sync_cg_clif-2022-08-24, r=bjorn3\n\nSync rustc_codegen_cranelift\n\nThe main highlights this time are support for parallel compilation of codegen units (by me) and improved windows support (by ``@afonso360)`` In addition ``@afonso360`` added abi-checker to cg_clif's CI. This has already catched an abi compatibility issue with AArch64. The fix has landed on Cranelift's main branch, but doesn't yet have a release. ``@uweigand`` also submitted a couple of PR's that will are prerequisites for supporting IBM's s390x architecture.\n\nr? ``@ghost``\n\n``@rustbot`` label +A-codegen +A-cranelift +T-compiler\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f2878a656b944ceed6f4a98d7e255784266a3dc0", "html_url": "https://github.com/rust-lang/rust/commit/f2878a656b944ceed6f4a98d7e255784266a3dc0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f2878a656b944ceed6f4a98d7e255784266a3dc0/comments", "author": {"login": "JohnTitor", "id": 25030997, "node_id": "MDQ6VXNlcjI1MDMwOTk3", "avatar_url": "https://avatars.githubusercontent.com/u/25030997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JohnTitor", "html_url": "https://github.com/JohnTitor", "followers_url": "https://api.github.com/users/JohnTitor/followers", "following_url": "https://api.github.com/users/JohnTitor/following{/other_user}", "gists_url": "https://api.github.com/users/JohnTitor/gists{/gist_id}", "starred_url": "https://api.github.com/users/JohnTitor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JohnTitor/subscriptions", "organizations_url": "https://api.github.com/users/JohnTitor/orgs", "repos_url": "https://api.github.com/users/JohnTitor/repos", "events_url": "https://api.github.com/users/JohnTitor/events{/privacy}", "received_events_url": "https://api.github.com/users/JohnTitor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1e1dc7b4c34f57c72d9f07cced15e18596b4c59d", "url": "https://api.github.com/repos/rust-lang/rust/commits/1e1dc7b4c34f57c72d9f07cced15e18596b4c59d", "html_url": "https://github.com/rust-lang/rust/commit/1e1dc7b4c34f57c72d9f07cced15e18596b4c59d"}, {"sha": "e62e1d4347198e17cfb1fe6fec531cac3b223019", "url": "https://api.github.com/repos/rust-lang/rust/commits/e62e1d4347198e17cfb1fe6fec531cac3b223019", "html_url": "https://github.com/rust-lang/rust/commit/e62e1d4347198e17cfb1fe6fec531cac3b223019"}], "stats": {"total": 3558, "additions": 2299, "deletions": 1259}, "files": [{"sha": "732edd66196d7de4c3d8d18e0c944e05d279906c", "filename": "compiler/rustc_codegen_cranelift/.cirrus.yml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f2878a656b944ceed6f4a98d7e255784266a3dc0/compiler%2Frustc_codegen_cranelift%2F.cirrus.yml", "raw_url": "https://github.com/rust-lang/rust/raw/f2878a656b944ceed6f4a98d7e255784266a3dc0/compiler%2Frustc_codegen_cranelift%2F.cirrus.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2F.cirrus.yml?ref=f2878a656b944ceed6f4a98d7e255784266a3dc0", "patch": "@@ -22,4 +22,4 @@ task:\n     - # Reduce amount of benchmark runs as they are slow\n     - export COMPILE_RUNS=2\n     - export RUN_RUNS=2\n-    - ./test.sh\n+    - ./y.rs test"}, {"sha": "e8897e9ae81454a01145a9b4343f66cafdb00565", "filename": "compiler/rustc_codegen_cranelift/.github/workflows/main.yml", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f2878a656b944ceed6f4a98d7e255784266a3dc0/compiler%2Frustc_codegen_cranelift%2F.github%2Fworkflows%2Fmain.yml", "raw_url": "https://github.com/rust-lang/rust/raw/f2878a656b944ceed6f4a98d7e255784266a3dc0/compiler%2Frustc_codegen_cranelift%2F.github%2Fworkflows%2Fmain.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2F.github%2Fworkflows%2Fmain.yml?ref=f2878a656b944ceed6f4a98d7e255784266a3dc0", "patch": "@@ -103,7 +103,7 @@ jobs:\n         # Enable extra checks\n         export CG_CLIF_ENABLE_VERIFIER=1\n \n-        ./test.sh\n+        ./y.rs test\n \n     - name: Package prebuilt cg_clif\n       run: tar cvfJ cg_clif.tar.xz build\n@@ -162,14 +162,14 @@ jobs:\n       #name: Test\n       run: |\n         # Enable backtraces for easier debugging\n-        #export RUST_BACKTRACE=1\n+        #$Env:RUST_BACKTRACE=1\n \n         # Reduce amount of benchmark runs as they are slow\n-        #export COMPILE_RUNS=2\n-        #export RUN_RUNS=2\n+        #$Env:COMPILE_RUNS=2\n+        #$Env:RUN_RUNS=2\n \n         # Enable extra checks\n-        #export CG_CLIF_ENABLE_VERIFIER=1\n+        #$Env:CG_CLIF_ENABLE_VERIFIER=1\n \n         ./y.exe build\n "}, {"sha": "6fd3e4443de5c29a78797daa438342723ce3468b", "filename": "compiler/rustc_codegen_cranelift/.gitignore", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f2878a656b944ceed6f4a98d7e255784266a3dc0/compiler%2Frustc_codegen_cranelift%2F.gitignore", "raw_url": "https://github.com/rust-lang/rust/raw/f2878a656b944ceed6f4a98d7e255784266a3dc0/compiler%2Frustc_codegen_cranelift%2F.gitignore", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2F.gitignore?ref=f2878a656b944ceed6f4a98d7e255784266a3dc0", "patch": "@@ -8,6 +8,8 @@ perf.data.old\n *.string*\n /y.bin\n /y.bin.dSYM\n+/y.exe\n+/y.pdb\n /build\n /build_sysroot/sysroot_src\n /build_sysroot/compiler-builtins\n@@ -17,3 +19,4 @@ perf.data.old\n /regex\n /simple-raytracer\n /portable-simd\n+/abi-checker"}, {"sha": "edae7e471578a88a9ec482c52397ab5330ac4cda", "filename": "compiler/rustc_codegen_cranelift/Cargo.lock", "status": "modified", "additions": 92, "deletions": 55, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/f2878a656b944ceed6f4a98d7e255784266a3dc0/compiler%2Frustc_codegen_cranelift%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/f2878a656b944ceed6f4a98d7e255784266a3dc0/compiler%2Frustc_codegen_cranelift%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2FCargo.lock?ref=f2878a656b944ceed6f4a98d7e255784266a3dc0", "patch": "@@ -50,18 +50,18 @@ checksum = \"baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd\"\n \n [[package]]\n name = \"cranelift-bforest\"\n-version = \"0.85.3\"\n+version = \"0.87.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"749d0d6022c9038dccf480bdde2a38d435937335bf2bb0f14e815d94517cdce8\"\n+checksum = \"93945adbccc8d731503d3038814a51e8317497c9e205411820348132fa01a358\"\n dependencies = [\n  \"cranelift-entity\",\n ]\n \n [[package]]\n name = \"cranelift-codegen\"\n-version = \"0.85.3\"\n+version = \"0.87.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"e94370cc7b37bf652ccd8bb8f09bd900997f7ccf97520edfc75554bb5c4abbea\"\n+checksum = \"2b482acc9d0d0d1ad3288a90a8150ee648be3dce8dc8c8669ff026f72debdc31\"\n dependencies = [\n  \"cranelift-bforest\",\n  \"cranelift-codegen-meta\",\n@@ -77,30 +77,30 @@ dependencies = [\n \n [[package]]\n name = \"cranelift-codegen-meta\"\n-version = \"0.85.3\"\n+version = \"0.87.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"e0a3cea8fdab90e44018c5b9a1dfd460d8ee265ac354337150222a354628bdb6\"\n+checksum = \"f9ec188d71e663192ef9048f204e410a7283b609942efc9fcc77da6d496edbb8\"\n dependencies = [\n  \"cranelift-codegen-shared\",\n ]\n \n [[package]]\n name = \"cranelift-codegen-shared\"\n-version = \"0.85.3\"\n+version = \"0.87.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"5ac72f76f2698598951ab26d8c96eaa854810e693e7dd52523958b5909fde6b2\"\n+checksum = \"3ad794b1b1c2c7bd9f7b76cfe0f084eaf7753e55d56191c3f7d89e8fa4978b99\"\n \n [[package]]\n name = \"cranelift-entity\"\n-version = \"0.85.3\"\n+version = \"0.87.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"09eaeacfcd2356fe0e66b295e8f9d59fdd1ac3ace53ba50de14d628ec902f72d\"\n+checksum = \"342da0d5056f4119d3c311c4aab2460ceb6ee6e127bb395b76dd2279a09ea7a5\"\n \n [[package]]\n name = \"cranelift-frontend\"\n-version = \"0.85.3\"\n+version = \"0.87.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"dba69c9980d5ffd62c18a2bde927855fcd7c8dc92f29feaf8636052662cbd99c\"\n+checksum = \"dfff792f775b07d4d9cfe9f1c767ce755c6cbadda1bbd6db18a1c75ff9f7376a\"\n dependencies = [\n  \"cranelift-codegen\",\n  \"log\",\n@@ -110,15 +110,15 @@ dependencies = [\n \n [[package]]\n name = \"cranelift-isle\"\n-version = \"0.85.3\"\n+version = \"0.87.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"d2920dc1e05cac40304456ed3301fde2c09bd6a9b0210bcfa2f101398d628d5b\"\n+checksum = \"8d51089478849f2ac8ef60a8a2d5346c8d4abfec0e45ac5b24530ef9f9499e1e\"\n \n [[package]]\n name = \"cranelift-jit\"\n-version = \"0.85.3\"\n+version = \"0.87.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"1c3c5ed067f2c81577e431f3039148a9c187b33cc79e0d1731fede27d801ec56\"\n+checksum = \"095936e41720f86004b4c57ce88e6a13af28646bb3a6fb4afbebd5ae90c50029\"\n dependencies = [\n  \"anyhow\",\n  \"cranelift-codegen\",\n@@ -129,24 +129,24 @@ dependencies = [\n  \"log\",\n  \"region\",\n  \"target-lexicon\",\n- \"winapi\",\n+ \"windows-sys\",\n ]\n \n [[package]]\n name = \"cranelift-module\"\n-version = \"0.85.3\"\n+version = \"0.87.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"eee6784303bf9af235237a4885f7417e09a35df896d38ea969a0081064b3ede4\"\n+checksum = \"704a1aea4723d97eafe0fb7af110f6f6868b1ac95f5380bbc9adb2a3b8cf97e8\"\n dependencies = [\n  \"anyhow\",\n  \"cranelift-codegen\",\n ]\n \n [[package]]\n name = \"cranelift-native\"\n-version = \"0.85.3\"\n+version = \"0.87.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"f04dfa45f9b2a6f587c564d6b63388e00cd6589d2df6ea2758cf79e1a13285e6\"\n+checksum = \"885debe62f2078638d6585f54c9f05f5c2008f22ce5a2a9100ada785fc065dbd\"\n dependencies = [\n  \"cranelift-codegen\",\n  \"libc\",\n@@ -155,9 +155,9 @@ dependencies = [\n \n [[package]]\n name = \"cranelift-object\"\n-version = \"0.85.3\"\n+version = \"0.87.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"0bf38b2c505db749276793116c0cb30bd096206c7810e471677a453134881881\"\n+checksum = \"aac1310cf1081ae8eca916c92cd163b977c77cab6e831fa812273c26ff921816\"\n dependencies = [\n  \"anyhow\",\n  \"cranelift-codegen\",\n@@ -187,9 +187,9 @@ dependencies = [\n \n [[package]]\n name = \"getrandom\"\n-version = \"0.2.6\"\n+version = \"0.2.7\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"9be70c98951c83b8d2f8f60d7065fa6d5146873094452a1008da8c2f1e4205ad\"\n+checksum = \"4eb1a864a501629691edf6c15a593b7a51eebaa1e8468e9ddc623de7c9b58ec6\"\n dependencies = [\n  \"cfg-if\",\n  \"libc\",\n@@ -198,43 +198,37 @@ dependencies = [\n \n [[package]]\n name = \"gimli\"\n-version = \"0.26.1\"\n+version = \"0.26.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"78cc372d058dcf6d5ecd98510e7fbc9e5aec4d21de70f65fea8fecebcd881bd4\"\n+checksum = \"22030e2c5a68ec659fde1e949a745124b48e6fa8b045b7ed5bd1fe4ccc5c4e5d\"\n dependencies = [\n  \"indexmap\",\n ]\n \n [[package]]\n name = \"hashbrown\"\n-version = \"0.11.2\"\n+version = \"0.12.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"ab5ef0d4909ef3724cc8cce6ccc8572c5c817592e9285f5464f8e86f8bd3726e\"\n+checksum = \"8a9ee70c43aaf417c914396645a0fa852624801b24ebb7ae78fe8272889ac888\"\n dependencies = [\n  \"ahash\",\n ]\n \n-[[package]]\n-name = \"hashbrown\"\n-version = \"0.12.3\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"8a9ee70c43aaf417c914396645a0fa852624801b24ebb7ae78fe8272889ac888\"\n-\n [[package]]\n name = \"indexmap\"\n version = \"1.9.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"10a35a97730320ffe8e2d410b5d3b69279b98d2c14bdb8b70ea89ecf7888d41e\"\n dependencies = [\n  \"autocfg\",\n- \"hashbrown 0.12.3\",\n+ \"hashbrown\",\n ]\n \n [[package]]\n name = \"libc\"\n-version = \"0.2.126\"\n+version = \"0.2.127\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"349d5a591cd28b49e1d1037471617a32ddcda5731b99419008085f72d5a53836\"\n+checksum = \"505e71a4706fa491e9b1b55f51b95d4037d0821ee40131190475f692b35b009b\"\n \n [[package]]\n name = \"libloading\"\n@@ -248,9 +242,9 @@ dependencies = [\n \n [[package]]\n name = \"log\"\n-version = \"0.4.14\"\n+version = \"0.4.17\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"51b9bbe6c47d51fc3e1a9b945965946b4c44142ab8792c50835a980d362c2710\"\n+checksum = \"abb12e687cfb44aa40f41fc3978ef76448f9b6038cad6aef4259d3c095a2382e\"\n dependencies = [\n  \"cfg-if\",\n ]\n@@ -266,33 +260,33 @@ dependencies = [\n \n [[package]]\n name = \"memchr\"\n-version = \"2.4.1\"\n+version = \"2.5.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"308cc39be01b73d0d18f82a0e7b2a3df85245f84af96fdddc5d202d27e47b86a\"\n+checksum = \"2dffe52ecf27772e601905b7522cb4ef790d2cc203488bbd0e2fe85fcb74566d\"\n \n [[package]]\n name = \"object\"\n-version = \"0.28.4\"\n+version = \"0.29.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"e42c982f2d955fac81dd7e1d0e1426a7d702acd9c98d19ab01083a6a0328c424\"\n+checksum = \"21158b2c33aa6d4561f1c0a6ea283ca92bc54802a93b263e910746d679a7eb53\"\n dependencies = [\n  \"crc32fast\",\n- \"hashbrown 0.11.2\",\n+ \"hashbrown\",\n  \"indexmap\",\n  \"memchr\",\n ]\n \n [[package]]\n name = \"once_cell\"\n-version = \"1.10.0\"\n+version = \"1.13.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"87f3e037eac156d1775da914196f0f37741a274155e34a0b7e427c35d2a2ecb9\"\n+checksum = \"18a6dbe30758c9f83eb00cbea4ac95966305f5a7772f3f42ebfc7fc7eddbd8e1\"\n \n [[package]]\n name = \"regalloc2\"\n-version = \"0.2.3\"\n+version = \"0.3.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"4a8d23b35d7177df3b9d31ed8a9ab4bf625c668be77a319d4f5efd4a5257701c\"\n+checksum = \"d43a209257d978ef079f3d446331d0f1794f5e0fc19b306a199983857833a779\"\n dependencies = [\n  \"fxhash\",\n  \"log\",\n@@ -340,15 +334,15 @@ checksum = \"03b634d87b960ab1a38c4fe143b508576f075e7c978bfad18217645ebfdfa2ec\"\n \n [[package]]\n name = \"smallvec\"\n-version = \"1.8.1\"\n+version = \"1.9.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"cc88c725d61fc6c3132893370cac4a0200e3fedf5da8331c570664b1987f5ca2\"\n+checksum = \"2fd0db749597d91ff862fd1d55ea87f7855a744a8425a64695b6fca237d1dad1\"\n \n [[package]]\n name = \"target-lexicon\"\n-version = \"0.12.3\"\n+version = \"0.12.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"d7fa7e55043acb85fca6b3c01485a2eeb6b69c5d21002e273c79e465f43b7ac1\"\n+checksum = \"c02424087780c9b71cc96799eaeddff35af2bc513278cda5c99fc1f5d026d3c1\"\n \n [[package]]\n name = \"version_check\"\n@@ -358,9 +352,9 @@ checksum = \"49874b5167b65d7193b8aba1567f5c7d93d001cafc34600cee003eda787e483f\"\n \n [[package]]\n name = \"wasi\"\n-version = \"0.10.2+wasi-snapshot-preview1\"\n+version = \"0.11.0+wasi-snapshot-preview1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"fd6fbd9a79829dd1ad0cc20627bf1ed606756a7f77edff7b66b7064f9cb327c6\"\n+checksum = \"9c8d87e72b64a3b4db28d11ce29237c246188f4f51057d65a7eab63b7987e423\"\n \n [[package]]\n name = \"winapi\"\n@@ -383,3 +377,46 @@ name = \"winapi-x86_64-pc-windows-gnu\"\n version = \"0.4.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"712e227841d057c1ee1cd2fb22fa7e5a5461ae8e48fa2ca79ec42cfc1931183f\"\n+\n+[[package]]\n+name = \"windows-sys\"\n+version = \"0.36.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"ea04155a16a59f9eab786fe12a4a450e75cdb175f9e0d80da1e17db09f55b8d2\"\n+dependencies = [\n+ \"windows_aarch64_msvc\",\n+ \"windows_i686_gnu\",\n+ \"windows_i686_msvc\",\n+ \"windows_x86_64_gnu\",\n+ \"windows_x86_64_msvc\",\n+]\n+\n+[[package]]\n+name = \"windows_aarch64_msvc\"\n+version = \"0.36.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"9bb8c3fd39ade2d67e9874ac4f3db21f0d710bee00fe7cab16949ec184eeaa47\"\n+\n+[[package]]\n+name = \"windows_i686_gnu\"\n+version = \"0.36.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"180e6ccf01daf4c426b846dfc66db1fc518f074baa793aa7d9b9aaeffad6a3b6\"\n+\n+[[package]]\n+name = \"windows_i686_msvc\"\n+version = \"0.36.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"e2e7917148b2812d1eeafaeb22a97e4813dfa60a3f8f78ebe204bcc88f12f024\"\n+\n+[[package]]\n+name = \"windows_x86_64_gnu\"\n+version = \"0.36.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"4dcd171b8776c41b97521e5da127a2d86ad280114807d0b2ab1e462bc764d9e1\"\n+\n+[[package]]\n+name = \"windows_x86_64_msvc\"\n+version = \"0.36.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"c811ca4a8c853ef420abd8592ba53ddbbac90410fab6903b3e79972a631f7680\""}, {"sha": "e7c3427485480119829d0322b76cb0feb217e5f8", "filename": "compiler/rustc_codegen_cranelift/Cargo.toml", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f2878a656b944ceed6f4a98d7e255784266a3dc0/compiler%2Frustc_codegen_cranelift%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f2878a656b944ceed6f4a98d7e255784266a3dc0/compiler%2Frustc_codegen_cranelift%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2FCargo.toml?ref=f2878a656b944ceed6f4a98d7e255784266a3dc0", "patch": "@@ -8,15 +8,15 @@ crate-type = [\"dylib\"]\n \n [dependencies]\n # These have to be in sync with each other\n-cranelift-codegen = { version = \"0.85.3\", features = [\"unwind\", \"all-arch\"] }\n-cranelift-frontend = \"0.85.3\"\n-cranelift-module = \"0.85.3\"\n-cranelift-native = \"0.85.3\"\n-cranelift-jit = { version = \"0.85.3\", optional = true }\n-cranelift-object = \"0.85.3\"\n+cranelift-codegen = { version = \"0.87.0\", features = [\"unwind\", \"all-arch\"] }\n+cranelift-frontend = \"0.87.0\"\n+cranelift-module = \"0.87.0\"\n+cranelift-native = \"0.87.0\"\n+cranelift-jit = { version = \"0.87.0\", optional = true }\n+cranelift-object = \"0.87.0\"\n target-lexicon = \"0.12.0\"\n gimli = { version = \"0.26.0\", default-features = false, features = [\"write\"]}\n-object = { version = \"0.28.0\", default-features = false, features = [\"std\", \"read_core\", \"write\", \"archive\", \"coff\", \"elf\", \"macho\", \"pe\"] }\n+object = { version = \"0.29.0\", default-features = false, features = [\"std\", \"read_core\", \"write\", \"archive\", \"coff\", \"elf\", \"macho\", \"pe\"] }\n \n ar = { git = \"https://github.com/bjorn3/rust-ar.git\", branch = \"do_not_remove_cg_clif_ranlib\" }\n indexmap = \"1.9.1\""}, {"sha": "1e84c7fa3657b37afeb26614a49896fab8846b40", "filename": "compiler/rustc_codegen_cranelift/Readme.md", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f2878a656b944ceed6f4a98d7e255784266a3dc0/compiler%2Frustc_codegen_cranelift%2FReadme.md", "raw_url": "https://github.com/rust-lang/rust/raw/f2878a656b944ceed6f4a98d7e255784266a3dc0/compiler%2Frustc_codegen_cranelift%2FReadme.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2FReadme.md?ref=f2878a656b944ceed6f4a98d7e255784266a3dc0", "patch": "@@ -52,9 +52,7 @@ configuration options.\n ## Not yet supported\n \n * Inline assembly ([no cranelift support](https://github.com/bytecodealliance/wasmtime/issues/1041))\n-    * On Linux there is support for invoking an external assembler for `global_asm!` and `asm!`.\n-      `llvm_asm!` will remain unimplemented forever. `asm!` doesn't yet support reg classes. You\n-      have to specify specific registers instead.\n+    * On UNIX there is support for invoking an external assembler for `global_asm!` and `asm!`.\n * SIMD ([tracked here](https://github.com/bjorn3/rustc_codegen_cranelift/issues/171), some basic things work)\n \n ## License"}, {"sha": "6c5043bb6f8e1e86cdde105d5607a4355581d5a4", "filename": "compiler/rustc_codegen_cranelift/build_sysroot/Cargo.lock", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f2878a656b944ceed6f4a98d7e255784266a3dc0/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/f2878a656b944ceed6f4a98d7e255784266a3dc0/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2FCargo.lock?ref=f2878a656b944ceed6f4a98d7e255784266a3dc0", "patch": "@@ -56,9 +56,9 @@ dependencies = [\n \n [[package]]\n name = \"compiler_builtins\"\n-version = \"0.1.75\"\n+version = \"0.1.79\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"c6e3183e88f659a862835db8f4b67dbeed3d93e44dd4927eef78edb1c149d784\"\n+checksum = \"4f873ce2bd3550b0b565f878b3d04ea8253f4259dc3d20223af2e1ba86f5ecca\"\n dependencies = [\n  \"rustc-std-workspace-core\",\n ]\n@@ -69,9 +69,9 @@ version = \"0.0.0\"\n \n [[package]]\n name = \"dlmalloc\"\n-version = \"0.2.3\"\n+version = \"0.2.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"a6fe28e0bf9357092740362502f5cc7955d8dc125ebda71dec72336c2e15c62e\"\n+checksum = \"203540e710bfadb90e5e29930baf5d10270cec1f43ab34f46f78b147b2de715a\"\n dependencies = [\n  \"compiler_builtins\",\n  \"libc\",\n@@ -80,9 +80,9 @@ dependencies = [\n \n [[package]]\n name = \"fortanix-sgx-abi\"\n-version = \"0.3.3\"\n+version = \"0.5.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"c56c422ef86062869b2d57ae87270608dc5929969dd130a6e248979cf4fb6ca6\"\n+checksum = \"57cafc2274c10fab234f176b25903ce17e690fca7597090d50880e047a0389c5\"\n dependencies = [\n  \"compiler_builtins\",\n  \"rustc-std-workspace-core\",\n@@ -123,9 +123,9 @@ dependencies = [\n \n [[package]]\n name = \"hermit-abi\"\n-version = \"0.2.4\"\n+version = \"0.2.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"7668753748e445859e4e373c3d41117235d9feed578392f5a3a73efdc751ca4a\"\n+checksum = \"897cd85af6387be149f55acf168e41be176a02de7872403aaab184afc2f327e6\"\n dependencies = [\n  \"compiler_builtins\",\n  \"libc\",\n@@ -135,9 +135,9 @@ dependencies = [\n \n [[package]]\n name = \"libc\"\n-version = \"0.2.126\"\n+version = \"0.2.132\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"349d5a591cd28b49e1d1037471617a32ddcda5731b99419008085f72d5a53836\"\n+checksum = \"8371e4e5341c3a96db127eb2465ac681ced4c433e01dd0e938adbef26ba93ba5\"\n dependencies = [\n  \"rustc-std-workspace-core\",\n ]"}, {"sha": "67dbd0a38a4fb4d44d0579e907bbc1a4c6bc9de0", "filename": "compiler/rustc_codegen_cranelift/build_system/abi_checker.rs", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/f2878a656b944ceed6f4a98d7e255784266a3dc0/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fabi_checker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2878a656b944ceed6f4a98d7e255784266a3dc0/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fabi_checker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fabi_checker.rs?ref=f2878a656b944ceed6f4a98d7e255784266a3dc0", "patch": "@@ -0,0 +1,60 @@\n+use super::build_sysroot;\n+use super::config;\n+use super::utils::spawn_and_wait;\n+use build_system::SysrootKind;\n+use std::env;\n+use std::path::Path;\n+use std::process::Command;\n+\n+pub(crate) fn run(\n+    channel: &str,\n+    sysroot_kind: SysrootKind,\n+    target_dir: &Path,\n+    cg_clif_build_dir: &Path,\n+    host_triple: &str,\n+    target_triple: &str,\n+) {\n+    if !config::get_bool(\"testsuite.abi-checker\") {\n+        eprintln!(\"[SKIP] abi-checker\");\n+        return;\n+    }\n+\n+    if host_triple != target_triple {\n+        eprintln!(\"[SKIP] abi-checker (cross-compilation not supported)\");\n+        return;\n+    }\n+\n+    eprintln!(\"Building sysroot for abi-checker\");\n+    build_sysroot::build_sysroot(\n+        channel,\n+        sysroot_kind,\n+        target_dir,\n+        cg_clif_build_dir,\n+        host_triple,\n+        target_triple,\n+    );\n+\n+    eprintln!(\"Running abi-checker\");\n+    let mut abi_checker_path = env::current_dir().unwrap();\n+    abi_checker_path.push(\"abi-checker\");\n+    env::set_current_dir(abi_checker_path.clone()).unwrap();\n+\n+    let build_dir = abi_checker_path.parent().unwrap().join(\"build\");\n+    let cg_clif_dylib_path = build_dir.join(if cfg!(windows) { \"bin\" } else { \"lib\" }).join(\n+        env::consts::DLL_PREFIX.to_string() + \"rustc_codegen_cranelift\" + env::consts::DLL_SUFFIX,\n+    );\n+\n+    let pairs = [\"rustc_calls_cgclif\", \"cgclif_calls_rustc\", \"cgclif_calls_cc\", \"cc_calls_cgclif\"];\n+\n+    let mut cmd = Command::new(\"cargo\");\n+    cmd.arg(\"run\");\n+    cmd.arg(\"--target\");\n+    cmd.arg(target_triple);\n+    cmd.arg(\"--\");\n+    cmd.arg(\"--pairs\");\n+    cmd.args(pairs);\n+    cmd.arg(\"--add-rustc-codegen-backend\");\n+    cmd.arg(format!(\"cgclif:{}\", cg_clif_dylib_path.display()));\n+\n+    spawn_and_wait(cmd);\n+}"}, {"sha": "9e59b8199b4123076a960771b4f2132a86d3cd54", "filename": "compiler/rustc_codegen_cranelift/build_system/build_backend.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f2878a656b944ceed6f4a98d7e255784266a3dc0/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fbuild_backend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2878a656b944ceed6f4a98d7e255784266a3dc0/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fbuild_backend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fbuild_backend.rs?ref=f2878a656b944ceed6f4a98d7e255784266a3dc0", "patch": "@@ -2,6 +2,8 @@ use std::env;\n use std::path::{Path, PathBuf};\n use std::process::Command;\n \n+use super::utils::is_ci;\n+\n pub(crate) fn build_backend(\n     channel: &str,\n     host_triple: &str,\n@@ -14,7 +16,7 @@ pub(crate) fn build_backend(\n \n     let mut rustflags = env::var(\"RUSTFLAGS\").unwrap_or_default();\n \n-    if env::var(\"CI\").as_ref().map(|val| &**val) == Ok(\"true\") {\n+    if is_ci() {\n         // Deny warnings on CI\n         rustflags += \" -Dwarnings\";\n "}, {"sha": "7e205b0fd0b3b85dab07cb83a620a56fd256a233", "filename": "compiler/rustc_codegen_cranelift/build_system/build_sysroot.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f2878a656b944ceed6f4a98d7e255784266a3dc0/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fbuild_sysroot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2878a656b944ceed6f4a98d7e255784266a3dc0/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fbuild_sysroot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fbuild_sysroot.rs?ref=f2878a656b944ceed6f4a98d7e255784266a3dc0", "patch": "@@ -2,18 +2,20 @@ use std::fs;\n use std::path::{Path, PathBuf};\n use std::process::{self, Command};\n \n-use super::rustc_info::{get_file_name, get_rustc_version};\n+use super::rustc_info::{get_file_name, get_rustc_version, get_wrapper_file_name};\n use super::utils::{spawn_and_wait, try_hard_link};\n use super::SysrootKind;\n \n pub(crate) fn build_sysroot(\n     channel: &str,\n     sysroot_kind: SysrootKind,\n     target_dir: &Path,\n-    cg_clif_build_dir: PathBuf,\n+    cg_clif_build_dir: &Path,\n     host_triple: &str,\n     target_triple: &str,\n ) {\n+    eprintln!(\"[BUILD] sysroot {:?}\", sysroot_kind);\n+\n     if target_dir.exists() {\n         fs::remove_dir_all(target_dir).unwrap();\n     }\n@@ -35,11 +37,13 @@ pub(crate) fn build_sysroot(\n \n     // Build and copy rustc and cargo wrappers\n     for wrapper in [\"rustc-clif\", \"cargo-clif\"] {\n+        let wrapper_name = get_wrapper_file_name(wrapper, \"bin\");\n+\n         let mut build_cargo_wrapper_cmd = Command::new(\"rustc\");\n         build_cargo_wrapper_cmd\n             .arg(PathBuf::from(\"scripts\").join(format!(\"{wrapper}.rs\")))\n             .arg(\"-o\")\n-            .arg(target_dir.join(wrapper))\n+            .arg(target_dir.join(wrapper_name))\n             .arg(\"-g\");\n         spawn_and_wait(build_cargo_wrapper_cmd);\n     }"}, {"sha": "c3706dc6f82039cfee03fe18fdb7ef7c3f8c36d6", "filename": "compiler/rustc_codegen_cranelift/build_system/mod.rs", "status": "modified", "additions": 48, "deletions": 10, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/f2878a656b944ceed6f4a98d7e255784266a3dc0/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2878a656b944ceed6f4a98d7e255784266a3dc0/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fmod.rs?ref=f2878a656b944ceed6f4a98d7e255784266a3dc0", "patch": "@@ -2,11 +2,15 @@ use std::env;\n use std::path::PathBuf;\n use std::process;\n \n+use self::utils::is_ci;\n+\n+mod abi_checker;\n mod build_backend;\n mod build_sysroot;\n mod config;\n mod prepare;\n mod rustc_info;\n+mod tests;\n mod utils;\n \n fn usage() {\n@@ -15,6 +19,9 @@ fn usage() {\n     eprintln!(\n         \"  ./y.rs build [--debug] [--sysroot none|clif|llvm] [--target-dir DIR] [--no-unstable-features]\"\n     );\n+    eprintln!(\n+        \"  ./y.rs test [--debug] [--sysroot none|clif|llvm] [--target-dir DIR] [--no-unstable-features]\"\n+    );\n }\n \n macro_rules! arg_error {\n@@ -25,11 +32,13 @@ macro_rules! arg_error {\n     }};\n }\n \n+#[derive(PartialEq, Debug)]\n enum Command {\n     Build,\n+    Test,\n }\n \n-#[derive(Copy, Clone)]\n+#[derive(Copy, Clone, Debug)]\n pub(crate) enum SysrootKind {\n     None,\n     Clif,\n@@ -42,16 +51,22 @@ pub fn main() {\n     // The target dir is expected in the default location. Guard against the user changing it.\n     env::set_var(\"CARGO_TARGET_DIR\", \"target\");\n \n+    if is_ci() {\n+        // Disabling incr comp reduces cache size and incr comp doesn't save as much on CI anyway\n+        env::set_var(\"CARGO_BUILD_INCREMENTAL\", \"false\");\n+    }\n+\n     let mut args = env::args().skip(1);\n     let command = match args.next().as_deref() {\n         Some(\"prepare\") => {\n             if args.next().is_some() {\n-                arg_error!(\"./x.rs prepare doesn't expect arguments\");\n+                arg_error!(\"./y.rs prepare doesn't expect arguments\");\n             }\n             prepare::prepare();\n             process::exit(0);\n         }\n         Some(\"build\") => Command::Build,\n+        Some(\"test\") => Command::Test,\n         Some(flag) if flag.starts_with('-') => arg_error!(\"Expected command found flag {}\", flag),\n         Some(command) => arg_error!(\"Unknown command {}\", command),\n         None => {\n@@ -117,12 +132,35 @@ pub fn main() {\n \n     let cg_clif_build_dir =\n         build_backend::build_backend(channel, &host_triple, use_unstable_features);\n-    build_sysroot::build_sysroot(\n-        channel,\n-        sysroot_kind,\n-        &target_dir,\n-        cg_clif_build_dir,\n-        &host_triple,\n-        &target_triple,\n-    );\n+    match command {\n+        Command::Test => {\n+            tests::run_tests(\n+                channel,\n+                sysroot_kind,\n+                &target_dir,\n+                &cg_clif_build_dir,\n+                &host_triple,\n+                &target_triple,\n+            );\n+\n+            abi_checker::run(\n+                channel,\n+                sysroot_kind,\n+                &target_dir,\n+                &cg_clif_build_dir,\n+                &host_triple,\n+                &target_triple,\n+            );\n+        }\n+        Command::Build => {\n+            build_sysroot::build_sysroot(\n+                channel,\n+                sysroot_kind,\n+                &target_dir,\n+                &cg_clif_build_dir,\n+                &host_triple,\n+                &target_triple,\n+            );\n+        }\n+    }\n }"}, {"sha": "d23b7f00dcf16da744be926925043d5716cad145", "filename": "compiler/rustc_codegen_cranelift/build_system/prepare.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f2878a656b944ceed6f4a98d7e255784266a3dc0/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fprepare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2878a656b944ceed6f4a98d7e255784266a3dc0/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fprepare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fprepare.rs?ref=f2878a656b944ceed6f4a98d7e255784266a3dc0", "patch": "@@ -14,6 +14,14 @@ pub(crate) fn prepare() {\n     eprintln!(\"[INSTALL] hyperfine\");\n     Command::new(\"cargo\").arg(\"install\").arg(\"hyperfine\").spawn().unwrap().wait().unwrap();\n \n+    clone_repo_shallow_github(\n+        \"abi-checker\",\n+        \"Gankra\",\n+        \"abi-checker\",\n+        \"a2232d45f202846f5c02203c9f27355360f9a2ff\",\n+    );\n+    apply_patches(\"abi-checker\", Path::new(\"abi-checker\"));\n+\n     clone_repo_shallow_github(\n         \"rand\",\n         \"rust-random\",\n@@ -50,8 +58,7 @@ pub(crate) fn prepare() {\n     spawn_and_wait(build_cmd);\n     fs::copy(\n         Path::new(\"simple-raytracer/target/debug\").join(get_file_name(\"main\", \"bin\")),\n-        // FIXME use get_file_name here too once testing is migrated to rust\n-        \"simple-raytracer/raytracer_cg_llvm\",\n+        Path::new(\"simple-raytracer\").join(get_file_name(\"raytracer_cg_llvm\", \"bin\")),\n     )\n     .unwrap();\n }"}, {"sha": "913b589afcc87f658510195969fd03aef5d683e2", "filename": "compiler/rustc_codegen_cranelift/build_system/rustc_info.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f2878a656b944ceed6f4a98d7e255784266a3dc0/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Frustc_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2878a656b944ceed6f4a98d7e255784266a3dc0/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Frustc_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Frustc_info.rs?ref=f2878a656b944ceed6f4a98d7e255784266a3dc0", "patch": "@@ -63,3 +63,12 @@ pub(crate) fn get_file_name(crate_name: &str, crate_type: &str) -> String {\n     assert!(file_name.contains(crate_name));\n     file_name\n }\n+\n+/// Similar to `get_file_name`, but converts any dashes (`-`) in the `crate_name` to\n+/// underscores (`_`). This is specially made for the the rustc and cargo wrappers\n+/// which have a dash in the name, and that is not allowed in a crate name.\n+pub(crate) fn get_wrapper_file_name(crate_name: &str, crate_type: &str) -> String {\n+    let crate_name = crate_name.replace('-', \"_\");\n+    let wrapper_name = get_file_name(&crate_name, crate_type);\n+    wrapper_name.replace('_', \"-\")\n+}"}, {"sha": "e21397cece8b32e28d7d7d6c206d4dad07e79ca1", "filename": "compiler/rustc_codegen_cranelift/build_system/tests.rs", "status": "added", "additions": 619, "deletions": 0, "changes": 619, "blob_url": "https://github.com/rust-lang/rust/blob/f2878a656b944ceed6f4a98d7e255784266a3dc0/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2878a656b944ceed6f4a98d7e255784266a3dc0/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Ftests.rs?ref=f2878a656b944ceed6f4a98d7e255784266a3dc0", "patch": "@@ -0,0 +1,619 @@\n+use super::build_sysroot;\n+use super::config;\n+use super::rustc_info::get_wrapper_file_name;\n+use super::utils::{spawn_and_wait, spawn_and_wait_with_input};\n+use build_system::SysrootKind;\n+use std::env;\n+use std::ffi::OsStr;\n+use std::fs;\n+use std::path::{Path, PathBuf};\n+use std::process::Command;\n+\n+struct TestCase {\n+    config: &'static str,\n+    func: &'static dyn Fn(&TestRunner),\n+}\n+\n+impl TestCase {\n+    const fn new(config: &'static str, func: &'static dyn Fn(&TestRunner)) -> Self {\n+        Self { config, func }\n+    }\n+}\n+\n+const NO_SYSROOT_SUITE: &[TestCase] = &[\n+    TestCase::new(\"build.mini_core\", &|runner| {\n+        runner.run_rustc([\n+            \"example/mini_core.rs\",\n+            \"--crate-name\",\n+            \"mini_core\",\n+            \"--crate-type\",\n+            \"lib,dylib\",\n+            \"--target\",\n+            &runner.target_triple,\n+        ]);\n+    }),\n+    TestCase::new(\"build.example\", &|runner| {\n+        runner.run_rustc([\n+            \"example/example.rs\",\n+            \"--crate-type\",\n+            \"lib\",\n+            \"--target\",\n+            &runner.target_triple,\n+        ]);\n+    }),\n+    TestCase::new(\"jit.mini_core_hello_world\", &|runner| {\n+        let mut jit_cmd = runner.rustc_command([\n+            \"-Zunstable-options\",\n+            \"-Cllvm-args=mode=jit\",\n+            \"-Cprefer-dynamic\",\n+            \"example/mini_core_hello_world.rs\",\n+            \"--cfg\",\n+            \"jit\",\n+            \"--target\",\n+            &runner.host_triple,\n+        ]);\n+        jit_cmd.env(\"CG_CLIF_JIT_ARGS\", \"abc bcd\");\n+        spawn_and_wait(jit_cmd);\n+\n+        eprintln!(\"[JIT-lazy] mini_core_hello_world\");\n+        let mut jit_cmd = runner.rustc_command([\n+            \"-Zunstable-options\",\n+            \"-Cllvm-args=mode=jit-lazy\",\n+            \"-Cprefer-dynamic\",\n+            \"example/mini_core_hello_world.rs\",\n+            \"--cfg\",\n+            \"jit\",\n+            \"--target\",\n+            &runner.host_triple,\n+        ]);\n+        jit_cmd.env(\"CG_CLIF_JIT_ARGS\", \"abc bcd\");\n+        spawn_and_wait(jit_cmd);\n+    }),\n+    TestCase::new(\"aot.mini_core_hello_world\", &|runner| {\n+        runner.run_rustc([\n+            \"example/mini_core_hello_world.rs\",\n+            \"--crate-name\",\n+            \"mini_core_hello_world\",\n+            \"--crate-type\",\n+            \"bin\",\n+            \"-g\",\n+            \"--target\",\n+            &runner.target_triple,\n+        ]);\n+        runner.run_out_command(\"mini_core_hello_world\", [\"abc\", \"bcd\"]);\n+    }),\n+];\n+\n+const BASE_SYSROOT_SUITE: &[TestCase] = &[\n+    TestCase::new(\"aot.arbitrary_self_types_pointers_and_wrappers\", &|runner| {\n+        runner.run_rustc([\n+            \"example/arbitrary_self_types_pointers_and_wrappers.rs\",\n+            \"--crate-name\",\n+            \"arbitrary_self_types_pointers_and_wrappers\",\n+            \"--crate-type\",\n+            \"bin\",\n+            \"--target\",\n+            &runner.target_triple,\n+        ]);\n+        runner.run_out_command(\"arbitrary_self_types_pointers_and_wrappers\", []);\n+    }),\n+    TestCase::new(\"aot.issue_91827_extern_types\", &|runner| {\n+        runner.run_rustc([\n+            \"example/issue-91827-extern-types.rs\",\n+            \"--crate-name\",\n+            \"issue_91827_extern_types\",\n+            \"--crate-type\",\n+            \"bin\",\n+            \"--target\",\n+            &runner.target_triple,\n+        ]);\n+        runner.run_out_command(\"issue_91827_extern_types\", []);\n+    }),\n+    TestCase::new(\"build.alloc_system\", &|runner| {\n+        runner.run_rustc([\n+            \"example/alloc_system.rs\",\n+            \"--crate-type\",\n+            \"lib\",\n+            \"--target\",\n+            &runner.target_triple,\n+        ]);\n+    }),\n+    TestCase::new(\"aot.alloc_example\", &|runner| {\n+        runner.run_rustc([\n+            \"example/alloc_example.rs\",\n+            \"--crate-type\",\n+            \"bin\",\n+            \"--target\",\n+            &runner.target_triple,\n+        ]);\n+        runner.run_out_command(\"alloc_example\", []);\n+    }),\n+    TestCase::new(\"jit.std_example\", &|runner| {\n+        runner.run_rustc([\n+            \"-Zunstable-options\",\n+            \"-Cllvm-args=mode=jit\",\n+            \"-Cprefer-dynamic\",\n+            \"example/std_example.rs\",\n+            \"--target\",\n+            &runner.host_triple,\n+        ]);\n+\n+        eprintln!(\"[JIT-lazy] std_example\");\n+        runner.run_rustc([\n+            \"-Zunstable-options\",\n+            \"-Cllvm-args=mode=jit-lazy\",\n+            \"-Cprefer-dynamic\",\n+            \"example/std_example.rs\",\n+            \"--target\",\n+            &runner.host_triple,\n+        ]);\n+    }),\n+    TestCase::new(\"aot.std_example\", &|runner| {\n+        runner.run_rustc([\n+            \"example/std_example.rs\",\n+            \"--crate-type\",\n+            \"bin\",\n+            \"--target\",\n+            &runner.target_triple,\n+        ]);\n+        runner.run_out_command(\"std_example\", [\"arg\"]);\n+    }),\n+    TestCase::new(\"aot.dst_field_align\", &|runner| {\n+        runner.run_rustc([\n+            \"example/dst-field-align.rs\",\n+            \"--crate-name\",\n+            \"dst_field_align\",\n+            \"--crate-type\",\n+            \"bin\",\n+            \"--target\",\n+            &runner.target_triple,\n+        ]);\n+        runner.run_out_command(\"dst_field_align\", []);\n+    }),\n+    TestCase::new(\"aot.subslice-patterns-const-eval\", &|runner| {\n+        runner.run_rustc([\n+            \"example/subslice-patterns-const-eval.rs\",\n+            \"--crate-type\",\n+            \"bin\",\n+            \"-Cpanic=abort\",\n+            \"--target\",\n+            &runner.target_triple,\n+        ]);\n+        runner.run_out_command(\"subslice-patterns-const-eval\", []);\n+    }),\n+    TestCase::new(\"aot.track-caller-attribute\", &|runner| {\n+        runner.run_rustc([\n+            \"example/track-caller-attribute.rs\",\n+            \"--crate-type\",\n+            \"bin\",\n+            \"-Cpanic=abort\",\n+            \"--target\",\n+            &runner.target_triple,\n+        ]);\n+        runner.run_out_command(\"track-caller-attribute\", []);\n+    }),\n+    TestCase::new(\"aot.float-minmax-pass\", &|runner| {\n+        runner.run_rustc([\n+            \"example/float-minmax-pass.rs\",\n+            \"--crate-type\",\n+            \"bin\",\n+            \"-Cpanic=abort\",\n+            \"--target\",\n+            &runner.target_triple,\n+        ]);\n+        runner.run_out_command(\"float-minmax-pass\", []);\n+    }),\n+    TestCase::new(\"aot.mod_bench\", &|runner| {\n+        runner.run_rustc([\n+            \"example/mod_bench.rs\",\n+            \"--crate-type\",\n+            \"bin\",\n+            \"--target\",\n+            &runner.target_triple,\n+        ]);\n+        runner.run_out_command(\"mod_bench\", []);\n+    }),\n+];\n+\n+const EXTENDED_SYSROOT_SUITE: &[TestCase] = &[\n+    TestCase::new(\"test.rust-random/rand\", &|runner| {\n+        runner.in_dir([\"rand\"], |runner| {\n+            runner.run_cargo([\"clean\"]);\n+\n+            if runner.host_triple == runner.target_triple {\n+                eprintln!(\"[TEST] rust-random/rand\");\n+                runner.run_cargo([\"test\", \"--workspace\"]);\n+            } else {\n+                eprintln!(\"[AOT] rust-random/rand\");\n+                runner.run_cargo([\n+                    \"build\",\n+                    \"--workspace\",\n+                    \"--target\",\n+                    &runner.target_triple,\n+                    \"--tests\",\n+                ]);\n+            }\n+        });\n+    }),\n+    TestCase::new(\"bench.simple-raytracer\", &|runner| {\n+        runner.in_dir([\"simple-raytracer\"], |runner| {\n+            let run_runs = env::var(\"RUN_RUNS\").unwrap_or(\"10\".to_string());\n+\n+            if runner.host_triple == runner.target_triple {\n+                eprintln!(\"[BENCH COMPILE] ebobby/simple-raytracer\");\n+                let mut bench_compile = Command::new(\"hyperfine\");\n+                bench_compile.arg(\"--runs\");\n+                bench_compile.arg(&run_runs);\n+                bench_compile.arg(\"--warmup\");\n+                bench_compile.arg(\"1\");\n+                bench_compile.arg(\"--prepare\");\n+                bench_compile.arg(format!(\"{:?}\", runner.cargo_command([\"clean\"])));\n+\n+                if cfg!(windows) {\n+                    bench_compile.arg(\"cmd /C \\\"set RUSTFLAGS= && cargo build\\\"\");\n+                } else {\n+                    bench_compile.arg(\"RUSTFLAGS='' cargo build\");\n+                }\n+\n+                bench_compile.arg(format!(\"{:?}\", runner.cargo_command([\"build\"])));\n+                spawn_and_wait(bench_compile);\n+\n+                eprintln!(\"[BENCH RUN] ebobby/simple-raytracer\");\n+                fs::copy(PathBuf::from(\"./target/debug/main\"), PathBuf::from(\"raytracer_cg_clif\"))\n+                    .unwrap();\n+\n+                let mut bench_run = Command::new(\"hyperfine\");\n+                bench_run.arg(\"--runs\");\n+                bench_run.arg(&run_runs);\n+                bench_run.arg(PathBuf::from(\"./raytracer_cg_llvm\"));\n+                bench_run.arg(PathBuf::from(\"./raytracer_cg_clif\"));\n+                spawn_and_wait(bench_run);\n+            } else {\n+                runner.run_cargo([\"clean\"]);\n+                eprintln!(\"[BENCH COMPILE] ebobby/simple-raytracer (skipped)\");\n+                eprintln!(\"[COMPILE] ebobby/simple-raytracer\");\n+                runner.run_cargo([\"build\", \"--target\", &runner.target_triple]);\n+                eprintln!(\"[BENCH RUN] ebobby/simple-raytracer (skipped)\");\n+            }\n+        });\n+    }),\n+    TestCase::new(\"test.libcore\", &|runner| {\n+        runner.in_dir([\"build_sysroot\", \"sysroot_src\", \"library\", \"core\", \"tests\"], |runner| {\n+            runner.run_cargo([\"clean\"]);\n+\n+            if runner.host_triple == runner.target_triple {\n+                runner.run_cargo([\"test\"]);\n+            } else {\n+                eprintln!(\"Cross-Compiling: Not running tests\");\n+                runner.run_cargo([\"build\", \"--target\", &runner.target_triple, \"--tests\"]);\n+            }\n+        });\n+    }),\n+    TestCase::new(\"test.regex-shootout-regex-dna\", &|runner| {\n+        runner.in_dir([\"regex\"], |runner| {\n+            runner.run_cargo([\"clean\"]);\n+\n+            // newer aho_corasick versions throw a deprecation warning\n+            let lint_rust_flags = format!(\"{} --cap-lints warn\", runner.rust_flags);\n+\n+            let mut build_cmd = runner.cargo_command([\n+                \"build\",\n+                \"--example\",\n+                \"shootout-regex-dna\",\n+                \"--target\",\n+                &runner.target_triple,\n+            ]);\n+            build_cmd.env(\"RUSTFLAGS\", lint_rust_flags.clone());\n+            spawn_and_wait(build_cmd);\n+\n+            if runner.host_triple == runner.target_triple {\n+                let mut run_cmd = runner.cargo_command([\n+                    \"run\",\n+                    \"--example\",\n+                    \"shootout-regex-dna\",\n+                    \"--target\",\n+                    &runner.target_triple,\n+                ]);\n+                run_cmd.env(\"RUSTFLAGS\", lint_rust_flags);\n+\n+                let input =\n+                    fs::read_to_string(PathBuf::from(\"examples/regexdna-input.txt\")).unwrap();\n+                let expected_path = PathBuf::from(\"examples/regexdna-output.txt\");\n+                let expected = fs::read_to_string(&expected_path).unwrap();\n+\n+                let output = spawn_and_wait_with_input(run_cmd, input);\n+                // Make sure `[codegen mono items] start` doesn't poison the diff\n+                let output = output\n+                    .lines()\n+                    .filter(|line| !line.contains(\"codegen mono items\"))\n+                    .chain(Some(\"\")) // This just adds the trailing newline\n+                    .collect::<Vec<&str>>()\n+                    .join(\"\\r\\n\");\n+\n+                let output_matches = expected.lines().eq(output.lines());\n+                if !output_matches {\n+                    let res_path = PathBuf::from(\"res.txt\");\n+                    fs::write(&res_path, &output).unwrap();\n+\n+                    if cfg!(windows) {\n+                        println!(\"Output files don't match!\");\n+                        println!(\"Expected Output:\\n{}\", expected);\n+                        println!(\"Actual Output:\\n{}\", output);\n+                    } else {\n+                        let mut diff = Command::new(\"diff\");\n+                        diff.arg(\"-u\");\n+                        diff.arg(res_path);\n+                        diff.arg(expected_path);\n+                        spawn_and_wait(diff);\n+                    }\n+\n+                    std::process::exit(1);\n+                }\n+            }\n+        });\n+    }),\n+    TestCase::new(\"test.regex\", &|runner| {\n+        runner.in_dir([\"regex\"], |runner| {\n+            runner.run_cargo([\"clean\"]);\n+\n+            // newer aho_corasick versions throw a deprecation warning\n+            let lint_rust_flags = format!(\"{} --cap-lints warn\", runner.rust_flags);\n+\n+            if runner.host_triple == runner.target_triple {\n+                let mut run_cmd = runner.cargo_command([\n+                    \"test\",\n+                    \"--tests\",\n+                    \"--\",\n+                    \"--exclude-should-panic\",\n+                    \"--test-threads\",\n+                    \"1\",\n+                    \"-Zunstable-options\",\n+                    \"-q\",\n+                ]);\n+                run_cmd.env(\"RUSTFLAGS\", lint_rust_flags);\n+                spawn_and_wait(run_cmd);\n+            } else {\n+                eprintln!(\"Cross-Compiling: Not running tests\");\n+                let mut build_cmd =\n+                    runner.cargo_command([\"build\", \"--tests\", \"--target\", &runner.target_triple]);\n+                build_cmd.env(\"RUSTFLAGS\", lint_rust_flags.clone());\n+                spawn_and_wait(build_cmd);\n+            }\n+        });\n+    }),\n+    TestCase::new(\"test.portable-simd\", &|runner| {\n+        runner.in_dir([\"portable-simd\"], |runner| {\n+            runner.run_cargo([\"clean\"]);\n+            runner.run_cargo([\"build\", \"--all-targets\", \"--target\", &runner.target_triple]);\n+\n+            if runner.host_triple == runner.target_triple {\n+                runner.run_cargo([\"test\", \"-q\"]);\n+            }\n+        });\n+    }),\n+];\n+\n+pub(crate) fn run_tests(\n+    channel: &str,\n+    sysroot_kind: SysrootKind,\n+    target_dir: &Path,\n+    cg_clif_build_dir: &Path,\n+    host_triple: &str,\n+    target_triple: &str,\n+) {\n+    let runner = TestRunner::new(host_triple.to_string(), target_triple.to_string());\n+\n+    if config::get_bool(\"testsuite.no_sysroot\") {\n+        build_sysroot::build_sysroot(\n+            channel,\n+            SysrootKind::None,\n+            &target_dir,\n+            cg_clif_build_dir,\n+            &host_triple,\n+            &target_triple,\n+        );\n+\n+        let _ = fs::remove_dir_all(Path::new(\"target\").join(\"out\"));\n+        runner.run_testsuite(NO_SYSROOT_SUITE);\n+    } else {\n+        eprintln!(\"[SKIP] no_sysroot tests\");\n+    }\n+\n+    let run_base_sysroot = config::get_bool(\"testsuite.base_sysroot\");\n+    let run_extended_sysroot = config::get_bool(\"testsuite.extended_sysroot\");\n+\n+    if run_base_sysroot || run_extended_sysroot {\n+        build_sysroot::build_sysroot(\n+            channel,\n+            sysroot_kind,\n+            &target_dir,\n+            cg_clif_build_dir,\n+            &host_triple,\n+            &target_triple,\n+        );\n+    }\n+\n+    if run_base_sysroot {\n+        runner.run_testsuite(BASE_SYSROOT_SUITE);\n+    } else {\n+        eprintln!(\"[SKIP] base_sysroot tests\");\n+    }\n+\n+    if run_extended_sysroot {\n+        runner.run_testsuite(EXTENDED_SYSROOT_SUITE);\n+    } else {\n+        eprintln!(\"[SKIP] extended_sysroot tests\");\n+    }\n+}\n+\n+struct TestRunner {\n+    root_dir: PathBuf,\n+    out_dir: PathBuf,\n+    jit_supported: bool,\n+    rust_flags: String,\n+    run_wrapper: Vec<String>,\n+    host_triple: String,\n+    target_triple: String,\n+}\n+\n+impl TestRunner {\n+    pub fn new(host_triple: String, target_triple: String) -> Self {\n+        let root_dir = env::current_dir().unwrap();\n+\n+        let mut out_dir = root_dir.clone();\n+        out_dir.push(\"target\");\n+        out_dir.push(\"out\");\n+\n+        let is_native = host_triple == target_triple;\n+        let jit_supported =\n+            target_triple.contains(\"x86_64\") && is_native && !host_triple.contains(\"windows\");\n+\n+        let mut rust_flags = env::var(\"RUSTFLAGS\").ok().unwrap_or(\"\".to_string());\n+        let mut run_wrapper = Vec::new();\n+\n+        if !is_native {\n+            match target_triple.as_str() {\n+                \"aarch64-unknown-linux-gnu\" => {\n+                    // We are cross-compiling for aarch64. Use the correct linker and run tests in qemu.\n+                    rust_flags = format!(\"-Clinker=aarch64-linux-gnu-gcc{}\", rust_flags);\n+                    run_wrapper = vec![\"qemu-aarch64\", \"-L\", \"/usr/aarch64-linux-gnu\"];\n+                }\n+                \"x86_64-pc-windows-gnu\" => {\n+                    // We are cross-compiling for Windows. Run tests in wine.\n+                    run_wrapper = vec![\"wine\"];\n+                }\n+                _ => {\n+                    println!(\"Unknown non-native platform\");\n+                }\n+            }\n+        }\n+\n+        // FIXME fix `#[linkage = \"extern_weak\"]` without this\n+        if host_triple.contains(\"darwin\") {\n+            rust_flags = format!(\"{} -Clink-arg=-undefined -Clink-arg=dynamic_lookup\", rust_flags);\n+        }\n+\n+        Self {\n+            root_dir,\n+            out_dir,\n+            jit_supported,\n+            rust_flags,\n+            run_wrapper: run_wrapper.iter().map(|s| s.to_string()).collect(),\n+            host_triple,\n+            target_triple,\n+        }\n+    }\n+\n+    pub fn run_testsuite(&self, tests: &[TestCase]) {\n+        for &TestCase { config, func } in tests {\n+            let (tag, testname) = config.split_once('.').unwrap();\n+            let tag = tag.to_uppercase();\n+            let is_jit_test = tag == \"JIT\";\n+\n+            if !config::get_bool(config) || (is_jit_test && !self.jit_supported) {\n+                eprintln!(\"[{tag}] {testname} (skipped)\");\n+                continue;\n+            } else {\n+                eprintln!(\"[{tag}] {testname}\");\n+            }\n+\n+            func(self);\n+        }\n+    }\n+\n+    fn in_dir<'a, I, F>(&self, dir: I, callback: F)\n+    where\n+        I: IntoIterator<Item = &'a str>,\n+        F: FnOnce(&TestRunner),\n+    {\n+        let current = env::current_dir().unwrap();\n+        let mut new = current.clone();\n+        for d in dir {\n+            new.push(d);\n+        }\n+\n+        env::set_current_dir(new).unwrap();\n+        callback(self);\n+        env::set_current_dir(current).unwrap();\n+    }\n+\n+    fn rustc_command<I, S>(&self, args: I) -> Command\n+    where\n+        I: IntoIterator<Item = S>,\n+        S: AsRef<OsStr>,\n+    {\n+        let mut rustc_clif = self.root_dir.clone();\n+        rustc_clif.push(\"build\");\n+        rustc_clif.push(get_wrapper_file_name(\"rustc-clif\", \"bin\"));\n+\n+        let mut cmd = Command::new(rustc_clif);\n+        cmd.args(self.rust_flags.split_whitespace());\n+        cmd.arg(\"-L\");\n+        cmd.arg(format!(\"crate={}\", self.out_dir.display()));\n+        cmd.arg(\"--out-dir\");\n+        cmd.arg(format!(\"{}\", self.out_dir.display()));\n+        cmd.arg(\"-Cdebuginfo=2\");\n+        cmd.args(args);\n+        cmd\n+    }\n+\n+    fn run_rustc<I, S>(&self, args: I)\n+    where\n+        I: IntoIterator<Item = S>,\n+        S: AsRef<OsStr>,\n+    {\n+        spawn_and_wait(self.rustc_command(args));\n+    }\n+\n+    fn run_out_command<'a, I>(&self, name: &str, args: I)\n+    where\n+        I: IntoIterator<Item = &'a str>,\n+    {\n+        let mut full_cmd = vec![];\n+\n+        // Prepend the RUN_WRAPPER's\n+        if !self.run_wrapper.is_empty() {\n+            full_cmd.extend(self.run_wrapper.iter().cloned());\n+        }\n+\n+        full_cmd.push({\n+            let mut out_path = self.out_dir.clone();\n+            out_path.push(name);\n+            out_path.to_str().unwrap().to_string()\n+        });\n+\n+        for arg in args.into_iter() {\n+            full_cmd.push(arg.to_string());\n+        }\n+\n+        let mut cmd_iter = full_cmd.into_iter();\n+        let first = cmd_iter.next().unwrap();\n+\n+        let mut cmd = Command::new(first);\n+        cmd.args(cmd_iter);\n+\n+        spawn_and_wait(cmd);\n+    }\n+\n+    fn cargo_command<I, S>(&self, args: I) -> Command\n+    where\n+        I: IntoIterator<Item = S>,\n+        S: AsRef<OsStr>,\n+    {\n+        let mut cargo_clif = self.root_dir.clone();\n+        cargo_clif.push(\"build\");\n+        cargo_clif.push(get_wrapper_file_name(\"cargo-clif\", \"bin\"));\n+\n+        let mut cmd = Command::new(cargo_clif);\n+        cmd.args(args);\n+        cmd.env(\"RUSTFLAGS\", &self.rust_flags);\n+        cmd\n+    }\n+\n+    fn run_cargo<'a, I>(&self, args: I)\n+    where\n+        I: IntoIterator<Item = &'a str>,\n+    {\n+        spawn_and_wait(self.cargo_command(args));\n+    }\n+}"}, {"sha": "bdf8f8ecd9970cb4b71976de33a953101047c808", "filename": "compiler/rustc_codegen_cranelift/build_system/utils.rs", "status": "modified", "additions": 28, "deletions": 1, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/f2878a656b944ceed6f4a98d7e255784266a3dc0/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2878a656b944ceed6f4a98d7e255784266a3dc0/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Futils.rs?ref=f2878a656b944ceed6f4a98d7e255784266a3dc0", "patch": "@@ -1,6 +1,8 @@\n+use std::env;\n use std::fs;\n+use std::io::Write;\n use std::path::Path;\n-use std::process::{self, Command};\n+use std::process::{self, Command, Stdio};\n \n #[track_caller]\n pub(crate) fn try_hard_link(src: impl AsRef<Path>, dst: impl AsRef<Path>) {\n@@ -18,6 +20,27 @@ pub(crate) fn spawn_and_wait(mut cmd: Command) {\n     }\n }\n \n+#[track_caller]\n+pub(crate) fn spawn_and_wait_with_input(mut cmd: Command, input: String) -> String {\n+    let mut child = cmd\n+        .stdin(Stdio::piped())\n+        .stdout(Stdio::piped())\n+        .spawn()\n+        .expect(\"Failed to spawn child process\");\n+\n+    let mut stdin = child.stdin.take().expect(\"Failed to open stdin\");\n+    std::thread::spawn(move || {\n+        stdin.write_all(input.as_bytes()).expect(\"Failed to write to stdin\");\n+    });\n+\n+    let output = child.wait_with_output().expect(\"Failed to read stdout\");\n+    if !output.status.success() {\n+        process::exit(1);\n+    }\n+\n+    String::from_utf8(output.stdout).unwrap()\n+}\n+\n pub(crate) fn copy_dir_recursively(from: &Path, to: &Path) {\n     for entry in fs::read_dir(from).unwrap() {\n         let entry = entry.unwrap();\n@@ -33,3 +56,7 @@ pub(crate) fn copy_dir_recursively(from: &Path, to: &Path) {\n         }\n     }\n }\n+\n+pub(crate) fn is_ci() -> bool {\n+    env::var(\"CI\").as_ref().map(|val| &**val) == Ok(\"true\")\n+}"}, {"sha": "62e52bd1958005655adbe4609fa3fbfe05c4b907", "filename": "compiler/rustc_codegen_cranelift/clean_all.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f2878a656b944ceed6f4a98d7e255784266a3dc0/compiler%2Frustc_codegen_cranelift%2Fclean_all.sh", "raw_url": "https://github.com/rust-lang/rust/raw/f2878a656b944ceed6f4a98d7e255784266a3dc0/compiler%2Frustc_codegen_cranelift%2Fclean_all.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fclean_all.sh?ref=f2878a656b944ceed6f4a98d7e255784266a3dc0", "patch": "@@ -3,4 +3,4 @@ set -e\n \n rm -rf build_sysroot/{sysroot_src/,target/,compiler-builtins/,rustc_version}\n rm -rf target/ build/ perf.data{,.old} y.bin\n-rm -rf rand/ regex/ simple-raytracer/ portable-simd/\n+rm -rf rand/ regex/ simple-raytracer/ portable-simd/ abi-checker/"}, {"sha": "2264d301d592003b27f679becdeb32e90d583023", "filename": "compiler/rustc_codegen_cranelift/config.txt", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/f2878a656b944ceed6f4a98d7e255784266a3dc0/compiler%2Frustc_codegen_cranelift%2Fconfig.txt", "raw_url": "https://github.com/rust-lang/rust/raw/f2878a656b944ceed6f4a98d7e255784266a3dc0/compiler%2Frustc_codegen_cranelift%2Fconfig.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fconfig.txt?ref=f2878a656b944ceed6f4a98d7e255784266a3dc0", "patch": "@@ -15,3 +15,38 @@\n # This option can be changed while the build system is already running for as long as sysroot\n # building hasn't started yet.\n #keep_sysroot\n+\n+\n+# Testsuite\n+#\n+# Each test suite item has a corresponding key here. The default is to run all tests.\n+# Comment any of these lines to skip individual tests.\n+\n+testsuite.no_sysroot\n+build.mini_core\n+build.example\n+jit.mini_core_hello_world\n+aot.mini_core_hello_world\n+\n+testsuite.base_sysroot\n+aot.arbitrary_self_types_pointers_and_wrappers\n+aot.issue_91827_extern_types\n+build.alloc_system\n+aot.alloc_example\n+jit.std_example\n+aot.std_example\n+aot.dst_field_align\n+aot.subslice-patterns-const-eval\n+aot.track-caller-attribute\n+aot.float-minmax-pass\n+aot.mod_bench\n+\n+testsuite.extended_sysroot\n+test.rust-random/rand\n+bench.simple-raytracer\n+test.libcore\n+test.regex-shootout-regex-dna\n+test.regex\n+test.portable-simd\n+\n+testsuite.abi-checker"}, {"sha": "42f8aa50ba1a99d73f84d9de07eb550d1c778637", "filename": "compiler/rustc_codegen_cranelift/example/mini_core.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f2878a656b944ceed6f4a98d7e255784266a3dc0/compiler%2Frustc_codegen_cranelift%2Fexample%2Fmini_core.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2878a656b944ceed6f4a98d7e255784266a3dc0/compiler%2Frustc_codegen_cranelift%2Fexample%2Fmini_core.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fexample%2Fmini_core.rs?ref=f2878a656b944ceed6f4a98d7e255784266a3dc0", "patch": "@@ -535,7 +535,7 @@ unsafe fn allocate(size: usize, _align: usize) -> *mut u8 {\n }\n \n #[lang = \"box_free\"]\n-unsafe fn box_free<T: ?Sized>(ptr: Unique<T>, alloc: ()) {\n+unsafe fn box_free<T: ?Sized>(ptr: Unique<T>, _alloc: ()) {\n     libc::free(ptr.pointer.0 as *mut u8);\n }\n \n@@ -575,11 +575,19 @@ pub mod intrinsics {\n }\n \n pub mod libc {\n+    // With the new Universal CRT, msvc has switched to all the printf functions being inline wrapper\n+    // functions. legacy_stdio_definitions.lib which provides the printf wrapper functions as normal\n+    // symbols to link against.\n+    #[cfg_attr(unix, link(name = \"c\"))]\n+    #[cfg_attr(target_env=\"msvc\", link(name=\"legacy_stdio_definitions\"))]\n+    extern \"C\" {\n+        pub fn printf(format: *const i8, ...) -> i32;\n+    }\n+\n     #[cfg_attr(unix, link(name = \"c\"))]\n     #[cfg_attr(target_env = \"msvc\", link(name = \"msvcrt\"))]\n     extern \"C\" {\n         pub fn puts(s: *const i8) -> i32;\n-        pub fn printf(format: *const i8, ...) -> i32;\n         pub fn malloc(size: usize) -> *mut u8;\n         pub fn free(ptr: *mut u8);\n         pub fn memcpy(dst: *mut u8, src: *const u8, size: usize);"}, {"sha": "e83be3a3df5c4f410f470099f1d623df22a2c76b", "filename": "compiler/rustc_codegen_cranelift/example/mini_core_hello_world.rs", "status": "modified", "additions": 101, "deletions": 16, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/f2878a656b944ceed6f4a98d7e255784266a3dc0/compiler%2Frustc_codegen_cranelift%2Fexample%2Fmini_core_hello_world.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2878a656b944ceed6f4a98d7e255784266a3dc0/compiler%2Frustc_codegen_cranelift%2Fexample%2Fmini_core_hello_world.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fexample%2Fmini_core_hello_world.rs?ref=f2878a656b944ceed6f4a98d7e255784266a3dc0", "patch": "@@ -139,7 +139,7 @@ pub struct bool_11 {\n     field10: bool,\n }\n \n-extern \"C\" fn bool_struct_in_11(arg0: bool_11) {}\n+extern \"C\" fn bool_struct_in_11(_arg0: bool_11) {}\n \n #[allow(unreachable_code)] // FIXME false positive\n fn main() {\n@@ -321,7 +321,7 @@ fn main() {\n     #[cfg(not(any(jit, windows)))]\n     test_tls();\n \n-    #[cfg(all(not(jit), target_arch = \"x86_64\", target_os = \"linux\"))]\n+    #[cfg(all(not(jit), target_arch = \"x86_64\", any(target_os = \"linux\", target_os = \"darwin\")))]\n     unsafe {\n         global_asm_test();\n     }\n@@ -343,7 +343,7 @@ fn main() {\n }\n }\n \n-#[cfg(all(not(jit), target_arch = \"x86_64\", target_os = \"linux\"))]\n+#[cfg(all(not(jit), target_arch = \"x86_64\", any(target_os = \"linux\", target_os = \"darwin\")))]\n extern \"C\" {\n     fn global_asm_test();\n }\n@@ -358,6 +358,16 @@ global_asm! {\n     \"\n }\n \n+#[cfg(all(not(jit), target_arch = \"x86_64\", target_os = \"darwin\"))]\n+global_asm! {\n+    \"\n+    .global _global_asm_test\n+    _global_asm_test:\n+    // comment that would normally be removed by LLVM\n+    ret\n+    \"\n+}\n+\n #[repr(C)]\n enum c_void {\n     _1,\n@@ -375,6 +385,7 @@ struct pthread_attr_t {\n }\n \n #[link(name = \"pthread\")]\n+#[cfg(unix)]\n extern \"C\" {\n     fn pthread_attr_init(attr: *mut pthread_attr_t) -> c_int;\n \n@@ -391,6 +402,91 @@ extern \"C\" {\n     ) -> c_int;\n }\n \n+type DWORD = u32;\n+type LPDWORD = *mut u32;\n+\n+type LPVOID = *mut c_void;\n+type HANDLE = *mut c_void;\n+\n+#[link(name = \"msvcrt\")]\n+#[cfg(windows)]\n+extern \"C\" {\n+    fn WaitForSingleObject(\n+        hHandle: LPVOID,\n+        dwMilliseconds: DWORD\n+    ) -> DWORD;\n+\n+    fn CreateThread(\n+        lpThreadAttributes: LPVOID, // Technically LPSECURITY_ATTRIBUTES, but we don't use it anyway\n+        dwStackSize: usize,\n+        lpStartAddress: extern \"C\" fn(_: *mut c_void) -> *mut c_void,\n+        lpParameter: LPVOID,\n+        dwCreationFlags: DWORD,\n+        lpThreadId: LPDWORD\n+    ) -> HANDLE;\n+}\n+\n+struct Thread {\n+    #[cfg(windows)]\n+    handle: HANDLE,\n+    #[cfg(unix)]\n+    handle: pthread_t,\n+}\n+\n+impl Thread {\n+    unsafe fn create(f: extern \"C\" fn(_: *mut c_void) -> *mut c_void) -> Self {\n+        #[cfg(unix)]\n+        {\n+            let mut attr: pthread_attr_t = zeroed();\n+            let mut thread: pthread_t = 0;\n+\n+            if pthread_attr_init(&mut attr) != 0 {\n+                assert!(false);\n+            }\n+\n+            if pthread_create(&mut thread, &attr, f, 0 as *mut c_void) != 0 {\n+                assert!(false);\n+            }\n+\n+            Thread {\n+                handle: thread,\n+            }\n+        }\n+\n+        #[cfg(windows)]\n+        {\n+            let handle = CreateThread(0 as *mut c_void, 0, f, 0 as *mut c_void, 0, 0 as *mut u32);\n+\n+            if (handle as u64) == 0 {\n+                assert!(false);\n+            }\n+\n+            Thread {\n+                handle,\n+            }\n+        }\n+    }\n+\n+\n+    unsafe fn join(self) {\n+        #[cfg(unix)]\n+        {\n+            let mut res = 0 as *mut c_void;\n+            pthread_join(self.handle, &mut res);\n+        }\n+\n+        #[cfg(windows)]\n+        {\n+            // The INFINITE macro is used to signal operations that do not timeout.\n+            let infinite = 0xffffffff;\n+            assert!(WaitForSingleObject(self.handle, infinite) == 0);\n+        }\n+    }\n+}\n+\n+\n+\n+\n #[thread_local]\n #[cfg(not(jit))]\n static mut TLS: u8 = 42;\n@@ -404,21 +500,10 @@ extern \"C\" fn mutate_tls(_: *mut c_void) -> *mut c_void {\n #[cfg(not(jit))]\n fn test_tls() {\n     unsafe {\n-        let mut attr: pthread_attr_t = zeroed();\n-        let mut thread: pthread_t = 0;\n-\n         assert_eq!(TLS, 42);\n \n-        if pthread_attr_init(&mut attr) != 0 {\n-            assert!(false);\n-        }\n-\n-        if pthread_create(&mut thread, &attr, mutate_tls, 0 as *mut c_void) != 0 {\n-            assert!(false);\n-        }\n-\n-        let mut res = 0 as *mut c_void;\n-        pthread_join(thread, &mut res);\n+        let thread = Thread::create(mutate_tls);\n+        thread.join();\n \n         // TLS of main thread must not have been changed by the other thread.\n         assert_eq!(TLS, 42);"}, {"sha": "526366a7598760b95bb6d107ca3dbf20a8f0f871", "filename": "compiler/rustc_codegen_cranelift/patches/0001-abi-checker-Disable-failing-tests.patch", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/f2878a656b944ceed6f4a98d7e255784266a3dc0/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0001-abi-checker-Disable-failing-tests.patch", "raw_url": "https://github.com/rust-lang/rust/raw/f2878a656b944ceed6f4a98d7e255784266a3dc0/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0001-abi-checker-Disable-failing-tests.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0001-abi-checker-Disable-failing-tests.patch?ref=f2878a656b944ceed6f4a98d7e255784266a3dc0", "patch": "@@ -0,0 +1,36 @@\n+From 1a315ba225577dbbd1f449d9609f16f984f68708 Mon Sep 17 00:00:00 2001\n+From: Afonso Bordado <afonso360@users.noreply.github.com>\n+Date: Fri, 12 Aug 2022 22:51:58 +0000\n+Subject: [PATCH] Disable abi-checker tests\n+\n+---\n+ src/report.rs | 14 ++++++++++++++\n+ 1 file changed, 14 insertions(+)\n+\n+diff --git a/src/report.rs b/src/report.rs\n+index 7346f5e..8347762 100644\n+--- a/src/report.rs\n++++ b/src/report.rs\n+@@ -45,6 +45,20 @@ pub fn get_test_rules(test: &TestKey, caller: &dyn AbiImpl, callee: &dyn AbiImpl\n+     //\n+     // THIS AREA RESERVED FOR VENDORS TO APPLY PATCHES\n+\n++    // Currently MSVC has some broken ABI issues. Furthermore, they cause\n++    // a STATUS_ACCESS_VIOLATION, so we can't even run them. Ensure that they compile and link.\n++    if cfg!(windows) && (test.test_name == \"bool\" || test.test_name == \"ui128\") {\n++        result.run = Link;\n++        result.check = Pass(Link);\n++    }\n++\n++    // structs is broken in the current release of cranelift for aarch64.\n++    // It has been fixed for cranelift 0.88: https://github.com/bytecodealliance/wasmtime/pull/4634\n++    if cfg!(target_arch = \"aarch64\") && test.test_name == \"structs\" {\n++        result.run = Link;\n++        result.check = Pass(Link);\n++    }\n++\n+     // END OF VENDOR RESERVED AREA\n+     //\n+     //\n+--\n+2.34.1"}, {"sha": "f3cd7ee77e26e34586ac8cc146d0791f960c4520", "filename": "compiler/rustc_codegen_cranelift/patches/0023-sysroot-Ignore-failing-tests.patch", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f2878a656b944ceed6f4a98d7e255784266a3dc0/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0023-sysroot-Ignore-failing-tests.patch", "raw_url": "https://github.com/rust-lang/rust/raw/f2878a656b944ceed6f4a98d7e255784266a3dc0/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0023-sysroot-Ignore-failing-tests.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0023-sysroot-Ignore-failing-tests.patch?ref=f2878a656b944ceed6f4a98d7e255784266a3dc0", "patch": "@@ -46,5 +46,17 @@ index 4bc44e9..8e3c7a4 100644\n  \n  #[test]\n  fn cell_allows_array_cycle() {\n+diff --git a/library/core/tests/atomic.rs b/library/core/tests/atomic.rs\n+index 13b12db..96fe4b9 100644\n+--- a/library/core/tests/atomic.rs\n++++ b/library/core/tests/atomic.rs\n+@@ -185,6 +185,7 @@ fn ptr_bitops() {\n+ }\n+ \n+ #[test]\n++#[cfg_attr(target_arch = \"s390x\", ignore)] // s390x backend doesn't support stack alignment >8 bytes\n+ #[cfg(any(not(target_arch = \"arm\"), target_os = \"linux\"))] // Missing intrinsic in compiler-builtins\n+ fn ptr_bitops_tagging() {\n+     #[repr(align(16))]\n -- \n 2.21.0 (Apple Git-122)"}, {"sha": "14f2746ecb19f0f342a286bf752732d678a94414", "filename": "compiler/rustc_codegen_cranelift/rust-toolchain", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f2878a656b944ceed6f4a98d7e255784266a3dc0/compiler%2Frustc_codegen_cranelift%2Frust-toolchain", "raw_url": "https://github.com/rust-lang/rust/raw/f2878a656b944ceed6f4a98d7e255784266a3dc0/compiler%2Frustc_codegen_cranelift%2Frust-toolchain", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Frust-toolchain?ref=f2878a656b944ceed6f4a98d7e255784266a3dc0", "patch": "@@ -1,3 +1,3 @@\n [toolchain]\n-channel = \"nightly-2022-07-25\"\n+channel = \"nightly-2022-08-24\"\n components = [\"rust-src\", \"rustc-dev\", \"llvm-tools-preview\"]"}, {"sha": "9b5ffa4096049c04b9b2b509e9ec80107a7e1a92", "filename": "compiler/rustc_codegen_cranelift/scripts/tests.sh", "status": "removed", "additions": 0, "deletions": 203, "changes": 203, "blob_url": "https://github.com/rust-lang/rust/blob/1e1dc7b4c34f57c72d9f07cced15e18596b4c59d/compiler%2Frustc_codegen_cranelift%2Fscripts%2Ftests.sh", "raw_url": "https://github.com/rust-lang/rust/raw/1e1dc7b4c34f57c72d9f07cced15e18596b4c59d/compiler%2Frustc_codegen_cranelift%2Fscripts%2Ftests.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fscripts%2Ftests.sh?ref=1e1dc7b4c34f57c72d9f07cced15e18596b4c59d", "patch": "@@ -1,203 +0,0 @@\n-#!/usr/bin/env bash\n-\n-set -e\n-\n-export CG_CLIF_DISPLAY_CG_TIME=1\n-export CG_CLIF_DISABLE_INCR_CACHE=1\n-\n-export HOST_TRIPLE=$(rustc -vV | grep host | cut -d: -f2 | tr -d \" \")\n-export TARGET_TRIPLE=${TARGET_TRIPLE:-$HOST_TRIPLE}\n-\n-export RUN_WRAPPER=''\n-\n-case \"$TARGET_TRIPLE\" in\n-   x86_64*)\n-      export JIT_SUPPORTED=1\n-      ;;\n-   *)\n-      export JIT_SUPPORTED=0\n-      ;;\n-esac\n-\n-if [[ \"$HOST_TRIPLE\" != \"$TARGET_TRIPLE\" ]]; then\n-   export JIT_SUPPORTED=0\n-   if [[ \"$TARGET_TRIPLE\" == \"aarch64-unknown-linux-gnu\" ]]; then\n-      # We are cross-compiling for aarch64. Use the correct linker and run tests in qemu.\n-      export RUSTFLAGS='-Clinker=aarch64-linux-gnu-gcc '$RUSTFLAGS\n-      export RUN_WRAPPER='qemu-aarch64 -L /usr/aarch64-linux-gnu'\n-   elif [[ \"$TARGET_TRIPLE\" == \"x86_64-pc-windows-gnu\" ]]; then\n-      # We are cross-compiling for Windows. Run tests in wine.\n-      export RUN_WRAPPER='wine'\n-   else\n-      echo \"Unknown non-native platform\"\n-   fi\n-fi\n-\n-# FIXME fix `#[linkage = \"extern_weak\"]` without this\n-if [[ \"$(uname)\" == 'Darwin' ]]; then\n-   export RUSTFLAGS=\"$RUSTFLAGS -Clink-arg=-undefined -Clink-arg=dynamic_lookup\"\n-fi\n-\n-MY_RUSTC=\"$(pwd)/build/rustc-clif $RUSTFLAGS -L crate=target/out --out-dir target/out -Cdebuginfo=2\"\n-\n-function no_sysroot_tests() {\n-    echo \"[BUILD] mini_core\"\n-    $MY_RUSTC example/mini_core.rs --crate-name mini_core --crate-type lib,dylib --target \"$TARGET_TRIPLE\"\n-\n-    echo \"[BUILD] example\"\n-    $MY_RUSTC example/example.rs --crate-type lib --target \"$TARGET_TRIPLE\"\n-\n-    if [[ \"$JIT_SUPPORTED\" = \"1\" ]]; then\n-        echo \"[JIT] mini_core_hello_world\"\n-        CG_CLIF_JIT_ARGS=\"abc bcd\" $MY_RUSTC -Zunstable-options -Cllvm-args=mode=jit -Cprefer-dynamic example/mini_core_hello_world.rs --cfg jit --target \"$HOST_TRIPLE\"\n-\n-        echo \"[JIT-lazy] mini_core_hello_world\"\n-        CG_CLIF_JIT_ARGS=\"abc bcd\" $MY_RUSTC -Zunstable-options -Cllvm-args=mode=jit-lazy -Cprefer-dynamic example/mini_core_hello_world.rs --cfg jit --target \"$HOST_TRIPLE\"\n-    else\n-        echo \"[JIT] mini_core_hello_world (skipped)\"\n-    fi\n-\n-    echo \"[AOT] mini_core_hello_world\"\n-    $MY_RUSTC example/mini_core_hello_world.rs --crate-name mini_core_hello_world --crate-type bin -g --target \"$TARGET_TRIPLE\"\n-    $RUN_WRAPPER ./target/out/mini_core_hello_world abc bcd\n-    # (echo \"break set -n main\"; echo \"run\"; sleep 1; echo \"si -c 10\"; sleep 1; echo \"frame variable\") | lldb -- ./target/out/mini_core_hello_world abc bcd\n-}\n-\n-function base_sysroot_tests() {\n-    echo \"[AOT] arbitrary_self_types_pointers_and_wrappers\"\n-    $MY_RUSTC example/arbitrary_self_types_pointers_and_wrappers.rs --crate-name arbitrary_self_types_pointers_and_wrappers --crate-type bin --target \"$TARGET_TRIPLE\"\n-    $RUN_WRAPPER ./target/out/arbitrary_self_types_pointers_and_wrappers\n-\n-    echo \"[AOT] issue_91827_extern_types\"\n-    $MY_RUSTC example/issue-91827-extern-types.rs --crate-name issue_91827_extern_types --crate-type bin --target \"$TARGET_TRIPLE\"\n-    $RUN_WRAPPER ./target/out/issue_91827_extern_types\n-\n-    echo \"[BUILD] alloc_system\"\n-    $MY_RUSTC example/alloc_system.rs --crate-type lib --target \"$TARGET_TRIPLE\"\n-\n-    echo \"[AOT] alloc_example\"\n-    $MY_RUSTC example/alloc_example.rs --crate-type bin --target \"$TARGET_TRIPLE\"\n-    $RUN_WRAPPER ./target/out/alloc_example\n-\n-    if [[ \"$JIT_SUPPORTED\" = \"1\" ]]; then\n-        echo \"[JIT] std_example\"\n-        $MY_RUSTC -Zunstable-options -Cllvm-args=mode=jit -Cprefer-dynamic example/std_example.rs --target \"$HOST_TRIPLE\"\n-\n-        echo \"[JIT-lazy] std_example\"\n-        $MY_RUSTC -Zunstable-options -Cllvm-args=mode=jit-lazy -Cprefer-dynamic example/std_example.rs --target \"$HOST_TRIPLE\"\n-    else\n-        echo \"[JIT] std_example (skipped)\"\n-    fi\n-\n-    echo \"[AOT] std_example\"\n-    $MY_RUSTC example/std_example.rs --crate-type bin --target \"$TARGET_TRIPLE\"\n-    $RUN_WRAPPER ./target/out/std_example arg\n-\n-    echo \"[AOT] dst_field_align\"\n-    $MY_RUSTC example/dst-field-align.rs --crate-name dst_field_align --crate-type bin --target \"$TARGET_TRIPLE\"\n-    $RUN_WRAPPER ./target/out/dst_field_align\n-\n-    echo \"[AOT] subslice-patterns-const-eval\"\n-    $MY_RUSTC example/subslice-patterns-const-eval.rs --crate-type bin -Cpanic=abort --target \"$TARGET_TRIPLE\"\n-    $RUN_WRAPPER ./target/out/subslice-patterns-const-eval\n-\n-    echo \"[AOT] track-caller-attribute\"\n-    $MY_RUSTC example/track-caller-attribute.rs --crate-type bin -Cpanic=abort --target \"$TARGET_TRIPLE\"\n-    $RUN_WRAPPER ./target/out/track-caller-attribute\n-\n-    echo \"[AOT] float-minmax-pass\"\n-    $MY_RUSTC example/float-minmax-pass.rs --crate-type bin -Cpanic=abort --target \"$TARGET_TRIPLE\"\n-    $RUN_WRAPPER ./target/out/float-minmax-pass\n-\n-    echo \"[AOT] mod_bench\"\n-    $MY_RUSTC example/mod_bench.rs --crate-type bin --target \"$TARGET_TRIPLE\"\n-    $RUN_WRAPPER ./target/out/mod_bench\n-}\n-\n-function extended_sysroot_tests() {\n-    pushd rand\n-    ../build/cargo-clif clean\n-    if [[ \"$HOST_TRIPLE\" = \"$TARGET_TRIPLE\" ]]; then\n-        echo \"[TEST] rust-random/rand\"\n-        ../build/cargo-clif test --workspace\n-    else\n-        echo \"[AOT] rust-random/rand\"\n-        ../build/cargo-clif build --workspace --target $TARGET_TRIPLE --tests\n-    fi\n-    popd\n-\n-    pushd simple-raytracer\n-    if [[ \"$HOST_TRIPLE\" = \"$TARGET_TRIPLE\" ]]; then\n-        echo \"[BENCH COMPILE] ebobby/simple-raytracer\"\n-        hyperfine --runs \"${RUN_RUNS:-10}\" --warmup 1 --prepare \"../build/cargo-clif clean\" \\\n-        \"RUSTFLAGS='' cargo build\" \\\n-        \"../build/cargo-clif build\"\n-\n-        echo \"[BENCH RUN] ebobby/simple-raytracer\"\n-        cp ./target/debug/main ./raytracer_cg_clif\n-        hyperfine --runs \"${RUN_RUNS:-10}\" ./raytracer_cg_llvm ./raytracer_cg_clif\n-    else\n-        ../build/cargo-clif clean\n-        echo \"[BENCH COMPILE] ebobby/simple-raytracer (skipped)\"\n-        echo \"[COMPILE] ebobby/simple-raytracer\"\n-        ../build/cargo-clif build --target $TARGET_TRIPLE\n-        echo \"[BENCH RUN] ebobby/simple-raytracer (skipped)\"\n-    fi\n-    popd\n-\n-    pushd build_sysroot/sysroot_src/library/core/tests\n-    echo \"[TEST] libcore\"\n-    ../../../../../build/cargo-clif clean\n-    if [[ \"$HOST_TRIPLE\" = \"$TARGET_TRIPLE\" ]]; then\n-        ../../../../../build/cargo-clif test\n-    else\n-        ../../../../../build/cargo-clif build --target $TARGET_TRIPLE --tests\n-    fi\n-    popd\n-\n-    pushd regex\n-    echo \"[TEST] rust-lang/regex example shootout-regex-dna\"\n-    ../build/cargo-clif clean\n-    export RUSTFLAGS=\"$RUSTFLAGS --cap-lints warn\" # newer aho_corasick versions throw a deprecation warning\n-    # Make sure `[codegen mono items] start` doesn't poison the diff\n-    ../build/cargo-clif build --example shootout-regex-dna --target $TARGET_TRIPLE\n-    if [[ \"$HOST_TRIPLE\" = \"$TARGET_TRIPLE\" ]]; then\n-        cat examples/regexdna-input.txt \\\n-            | ../build/cargo-clif run --example shootout-regex-dna --target $TARGET_TRIPLE \\\n-            | grep -v \"Spawned thread\" > res.txt\n-        diff -u res.txt examples/regexdna-output.txt\n-    fi\n-\n-    if [[ \"$HOST_TRIPLE\" = \"$TARGET_TRIPLE\" ]]; then\n-        echo \"[TEST] rust-lang/regex tests\"\n-        ../build/cargo-clif test --tests -- --exclude-should-panic --test-threads 1 -Zunstable-options -q\n-    else\n-        echo \"[AOT] rust-lang/regex tests\"\n-        ../build/cargo-clif build --tests --target $TARGET_TRIPLE\n-    fi\n-    popd\n-\n-    pushd portable-simd\n-    echo \"[TEST] rust-lang/portable-simd\"\n-    ../build/cargo-clif clean\n-    ../build/cargo-clif build --all-targets --target $TARGET_TRIPLE\n-    if [[ \"$HOST_TRIPLE\" = \"$TARGET_TRIPLE\" ]]; then\n-        ../build/cargo-clif test -q\n-    fi\n-    popd\n-}\n-\n-case \"$1\" in\n-    \"no_sysroot\")\n-        no_sysroot_tests\n-        ;;\n-    \"base_sysroot\")\n-        base_sysroot_tests\n-        ;;\n-    \"extended_sysroot\")\n-        extended_sysroot_tests\n-        ;;\n-    *)\n-        echo \"unknown test suite\"\n-        ;;\n-esac"}, {"sha": "f4ad76b3bab3c77edeb007f2c8b8c6dd9ef1e193", "filename": "compiler/rustc_codegen_cranelift/src/abi/pass_mode.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f2878a656b944ceed6f4a98d7e255784266a3dc0/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fpass_mode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2878a656b944ceed6f4a98d7e255784266a3dc0/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fpass_mode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fpass_mode.rs?ref=f2878a656b944ceed6f4a98d7e255784266a3dc0", "patch": "@@ -23,7 +23,7 @@ fn reg_to_abi_param(reg: Reg) -> AbiParam {\n         (RegKind::Integer, 9..=16) => types::I128,\n         (RegKind::Float, 4) => types::F32,\n         (RegKind::Float, 8) => types::F64,\n-        (RegKind::Vector, size) => types::I8.by(u16::try_from(size).unwrap()).unwrap(),\n+        (RegKind::Vector, size) => types::I8.by(u32::try_from(size).unwrap()).unwrap(),\n         _ => unreachable!(\"{:?}\", reg),\n     };\n     AbiParam::new(clif_ty)\n@@ -184,7 +184,7 @@ pub(super) fn from_casted_value<'tcx>(\n     let abi_params = cast_target_to_abi_params(cast);\n     let abi_param_size: u32 = abi_params.iter().map(|param| param.value_type.bytes()).sum();\n     let layout_size = u32::try_from(layout.size.bytes()).unwrap();\n-    let stack_slot = fx.bcx.create_stack_slot(StackSlotData {\n+    let stack_slot = fx.bcx.create_sized_stack_slot(StackSlotData {\n         kind: StackSlotKind::ExplicitSlot,\n         // FIXME Don't force the size to a multiple of 16 bytes once Cranelift gets a way to\n         // specify stack slot alignment.\n@@ -193,7 +193,7 @@ pub(super) fn from_casted_value<'tcx>(\n         // larger alignment than the integer.\n         size: (std::cmp::max(abi_param_size, layout_size) + 15) / 16 * 16,\n     });\n-    let ptr = Pointer::new(fx.bcx.ins().stack_addr(pointer_ty(fx.tcx), stack_slot, 0));\n+    let ptr = Pointer::stack_slot(stack_slot);\n     let mut offset = 0;\n     let mut block_params_iter = block_params.iter().copied();\n     for param in abi_params {"}, {"sha": "44c34d6c8cb79928ecf5aacac453df0f292bed82", "filename": "compiler/rustc_codegen_cranelift/src/base.rs", "status": "modified", "additions": 109, "deletions": 118, "changes": 227, "blob_url": "https://github.com/rust-lang/rust/blob/f2878a656b944ceed6f4a98d7e255784266a3dc0/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2878a656b944ceed6f4a98d7e255784266a3dc0/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs?ref=f2878a656b944ceed6f4a98d7e255784266a3dc0", "patch": "@@ -6,21 +6,43 @@ use rustc_middle::ty::adjustment::PointerCast;\n use rustc_middle::ty::layout::FnAbiOf;\n use rustc_middle::ty::print::with_no_trimmed_paths;\n \n-use indexmap::IndexSet;\n-\n use crate::constant::ConstantCx;\n+use crate::debuginfo::FunctionDebugContext;\n use crate::prelude::*;\n use crate::pretty_clif::CommentWriter;\n \n-pub(crate) fn codegen_fn<'tcx>(\n-    cx: &mut crate::CodegenCx<'tcx>,\n+pub(crate) struct CodegenedFunction {\n+    symbol_name: String,\n+    func_id: FuncId,\n+    func: Function,\n+    clif_comments: CommentWriter,\n+    func_debug_cx: Option<FunctionDebugContext>,\n+}\n+\n+#[cfg_attr(not(feature = \"jit\"), allow(dead_code))]\n+pub(crate) fn codegen_and_compile_fn<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    cx: &mut crate::CodegenCx,\n+    cached_context: &mut Context,\n     module: &mut dyn Module,\n     instance: Instance<'tcx>,\n ) {\n-    let tcx = cx.tcx;\n-\n     let _inst_guard =\n         crate::PrintOnPanic(|| format!(\"{:?} {}\", instance, tcx.symbol_name(instance).name));\n+\n+    let cached_func = std::mem::replace(&mut cached_context.func, Function::new());\n+    let codegened_func = codegen_fn(tcx, cx, cached_func, module, instance);\n+\n+    compile_fn(cx, cached_context, module, codegened_func);\n+}\n+\n+pub(crate) fn codegen_fn<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    cx: &mut crate::CodegenCx,\n+    cached_func: Function,\n+    module: &mut dyn Module,\n+    instance: Instance<'tcx>,\n+) -> CodegenedFunction {\n     debug_assert!(!instance.substs.needs_infer());\n \n     let mir = tcx.instance_mir(instance.def);\n@@ -34,15 +56,14 @@ pub(crate) fn codegen_fn<'tcx>(\n     });\n \n     // Declare function\n-    let symbol_name = tcx.symbol_name(instance);\n+    let symbol_name = tcx.symbol_name(instance).name.to_string();\n     let sig = get_function_sig(tcx, module.isa().triple(), instance);\n-    let func_id = module.declare_function(symbol_name.name, Linkage::Local, &sig).unwrap();\n-\n-    cx.cached_context.clear();\n+    let func_id = module.declare_function(&symbol_name, Linkage::Local, &sig).unwrap();\n \n     // Make the FunctionBuilder\n     let mut func_ctx = FunctionBuilderContext::new();\n-    let mut func = std::mem::replace(&mut cx.cached_context.func, Function::new());\n+    let mut func = cached_func;\n+    func.clear();\n     func.name = ExternalName::user(0, func_id.as_u32());\n     func.signature = sig;\n     func.collect_debug_info();\n@@ -59,13 +80,20 @@ pub(crate) fn codegen_fn<'tcx>(\n     let pointer_type = target_config.pointer_type();\n     let clif_comments = crate::pretty_clif::CommentWriter::new(tcx, instance);\n \n+    let func_debug_cx = if let Some(debug_context) = &mut cx.debug_context {\n+        Some(debug_context.define_function(tcx, &symbol_name, mir.span))\n+    } else {\n+        None\n+    };\n+\n     let mut fx = FunctionCx {\n         cx,\n         module,\n         tcx,\n         target_config,\n         pointer_type,\n         constants_cx: ConstantCx::new(),\n+        func_debug_cx,\n \n         instance,\n         symbol_name,\n@@ -78,81 +106,48 @@ pub(crate) fn codegen_fn<'tcx>(\n         caller_location: None, // set by `codegen_fn_prelude`\n \n         clif_comments,\n-        source_info_set: indexmap::IndexSet::new(),\n+        last_source_file: None,\n         next_ssa_var: 0,\n     };\n \n-    let arg_uninhabited = fx\n-        .mir\n-        .args_iter()\n-        .any(|arg| fx.layout_of(fx.monomorphize(fx.mir.local_decls[arg].ty)).abi.is_uninhabited());\n-\n-    if !crate::constant::check_constants(&mut fx) {\n-        fx.bcx.append_block_params_for_function_params(fx.block_map[START_BLOCK]);\n-        fx.bcx.switch_to_block(fx.block_map[START_BLOCK]);\n-        crate::trap::trap_unreachable(&mut fx, \"compilation should have been aborted\");\n-    } else if arg_uninhabited {\n-        fx.bcx.append_block_params_for_function_params(fx.block_map[START_BLOCK]);\n-        fx.bcx.switch_to_block(fx.block_map[START_BLOCK]);\n-        fx.bcx.ins().trap(TrapCode::UnreachableCodeReached);\n-    } else {\n-        tcx.sess.time(\"codegen clif ir\", || {\n-            tcx.sess\n-                .time(\"codegen prelude\", || crate::abi::codegen_fn_prelude(&mut fx, start_block));\n-            codegen_fn_content(&mut fx);\n-        });\n-    }\n+    tcx.sess.time(\"codegen clif ir\", || codegen_fn_body(&mut fx, start_block));\n \n     // Recover all necessary data from fx, before accessing func will prevent future access to it.\n-    let instance = fx.instance;\n+    let symbol_name = fx.symbol_name;\n     let clif_comments = fx.clif_comments;\n-    let source_info_set = fx.source_info_set;\n-    let local_map = fx.local_map;\n+    let func_debug_cx = fx.func_debug_cx;\n \n     fx.constants_cx.finalize(fx.tcx, &mut *fx.module);\n \n-    crate::pretty_clif::write_clif_file(\n-        tcx,\n-        \"unopt\",\n-        module.isa(),\n-        instance,\n-        &func,\n-        &clif_comments,\n-    );\n+    if cx.should_write_ir {\n+        crate::pretty_clif::write_clif_file(\n+            tcx.output_filenames(()),\n+            &symbol_name,\n+            \"unopt\",\n+            module.isa(),\n+            &func,\n+            &clif_comments,\n+        );\n+    }\n \n     // Verify function\n     verify_func(tcx, &clif_comments, &func);\n \n-    compile_fn(\n-        cx,\n-        module,\n-        instance,\n-        symbol_name.name,\n-        func_id,\n-        func,\n-        clif_comments,\n-        source_info_set,\n-        local_map,\n-    );\n+    CodegenedFunction { symbol_name, func_id, func, clif_comments, func_debug_cx }\n }\n \n-fn compile_fn<'tcx>(\n-    cx: &mut crate::CodegenCx<'tcx>,\n+pub(crate) fn compile_fn(\n+    cx: &mut crate::CodegenCx,\n+    cached_context: &mut Context,\n     module: &mut dyn Module,\n-    instance: Instance<'tcx>,\n-    symbol_name: &str,\n-    func_id: FuncId,\n-    func: Function,\n-    mut clif_comments: CommentWriter,\n-    source_info_set: IndexSet<SourceInfo>,\n-    local_map: IndexVec<mir::Local, CPlace<'tcx>>,\n+    codegened_func: CodegenedFunction,\n ) {\n-    let tcx = cx.tcx;\n+    let clif_comments = codegened_func.clif_comments;\n \n     // Store function in context\n-    let context = &mut cx.cached_context;\n+    let context = cached_context;\n     context.clear();\n-    context.func = func;\n+    context.func = codegened_func.func;\n \n     // If the return block is not reachable, then the SSA builder may have inserted an `iconst.i128`\n     // instruction, which doesn't have an encoding.\n@@ -164,17 +159,6 @@ fn compile_fn<'tcx>(\n     // invalidate it when it would change.\n     context.domtree.clear();\n \n-    // Perform rust specific optimizations\n-    tcx.sess.time(\"optimize clif ir\", || {\n-        crate::optimize::optimize_function(\n-            tcx,\n-            module.isa(),\n-            instance,\n-            context,\n-            &mut clif_comments,\n-        );\n-    });\n-\n     #[cfg(any())] // This is never true\n     let _clif_guard = {\n         use std::fmt::Write;\n@@ -203,46 +187,44 @@ fn compile_fn<'tcx>(\n     };\n \n     // Define function\n-    tcx.sess.time(\"define function\", || {\n-        context.want_disasm = crate::pretty_clif::should_write_ir(tcx);\n-        module.define_function(func_id, context).unwrap();\n+    cx.profiler.verbose_generic_activity(\"define function\").run(|| {\n+        context.want_disasm = cx.should_write_ir;\n+        module.define_function(codegened_func.func_id, context).unwrap();\n     });\n \n-    // Write optimized function to file for debugging\n-    crate::pretty_clif::write_clif_file(\n-        tcx,\n-        \"opt\",\n-        module.isa(),\n-        instance,\n-        &context.func,\n-        &clif_comments,\n-    );\n+    if cx.should_write_ir {\n+        // Write optimized function to file for debugging\n+        crate::pretty_clif::write_clif_file(\n+            &cx.output_filenames,\n+            &codegened_func.symbol_name,\n+            \"opt\",\n+            module.isa(),\n+            &context.func,\n+            &clif_comments,\n+        );\n \n-    if let Some(disasm) = &context.mach_compile_result.as_ref().unwrap().disasm {\n-        crate::pretty_clif::write_ir_file(\n-            tcx,\n-            || format!(\"{}.vcode\", tcx.symbol_name(instance).name),\n-            |file| file.write_all(disasm.as_bytes()),\n-        )\n+        if let Some(disasm) = &context.compiled_code().unwrap().disasm {\n+            crate::pretty_clif::write_ir_file(\n+                &cx.output_filenames,\n+                &format!(\"{}.vcode\", codegened_func.symbol_name),\n+                |file| file.write_all(disasm.as_bytes()),\n+            )\n+        }\n     }\n \n     // Define debuginfo for function\n     let isa = module.isa();\n     let debug_context = &mut cx.debug_context;\n     let unwind_context = &mut cx.unwind_context;\n-    tcx.sess.time(\"generate debug info\", || {\n+    cx.profiler.verbose_generic_activity(\"generate debug info\").run(|| {\n         if let Some(debug_context) = debug_context {\n-            debug_context.define_function(\n-                instance,\n-                func_id,\n-                symbol_name,\n-                isa,\n+            codegened_func.func_debug_cx.unwrap().finalize(\n+                debug_context,\n+                codegened_func.func_id,\n                 context,\n-                &source_info_set,\n-                local_map,\n             );\n         }\n-        unwind_context.add_function(func_id, &context, isa);\n+        unwind_context.add_function(codegened_func.func_id, &context, isa);\n     });\n }\n \n@@ -268,7 +250,27 @@ pub(crate) fn verify_func(\n     });\n }\n \n-fn codegen_fn_content(fx: &mut FunctionCx<'_, '_, '_>) {\n+fn codegen_fn_body(fx: &mut FunctionCx<'_, '_, '_>, start_block: Block) {\n+    if !crate::constant::check_constants(fx) {\n+        fx.bcx.append_block_params_for_function_params(fx.block_map[START_BLOCK]);\n+        fx.bcx.switch_to_block(fx.block_map[START_BLOCK]);\n+        // compilation should have been aborted\n+        fx.bcx.ins().trap(TrapCode::UnreachableCodeReached);\n+        return;\n+    }\n+\n+    let arg_uninhabited = fx\n+        .mir\n+        .args_iter()\n+        .any(|arg| fx.layout_of(fx.monomorphize(fx.mir.local_decls[arg].ty)).abi.is_uninhabited());\n+    if arg_uninhabited {\n+        fx.bcx.append_block_params_for_function_params(fx.block_map[START_BLOCK]);\n+        fx.bcx.switch_to_block(fx.block_map[START_BLOCK]);\n+        fx.bcx.ins().trap(TrapCode::UnreachableCodeReached);\n+        return;\n+    }\n+    fx.tcx.sess.time(\"codegen prelude\", || crate::abi::codegen_fn_prelude(fx, start_block));\n+\n     for (bb, bb_data) in fx.mir.basic_blocks().iter_enumerated() {\n         let block = fx.get_block(bb);\n         fx.bcx.switch_to_block(block);\n@@ -457,17 +459,8 @@ fn codegen_fn_content(fx: &mut FunctionCx<'_, '_, '_>) {\n                     template,\n                     operands,\n                     *options,\n+                    *destination,\n                 );\n-\n-                match *destination {\n-                    Some(destination) => {\n-                        let destination_block = fx.get_block(destination);\n-                        fx.bcx.ins().jump(destination_block, &[]);\n-                    }\n-                    None => {\n-                        fx.bcx.ins().trap(TrapCode::UnreachableCodeReached);\n-                    }\n-                }\n             }\n             TerminatorKind::Resume | TerminatorKind::Abort => {\n                 // FIXME implement unwinding\n@@ -711,9 +704,7 @@ fn codegen_stmt<'tcx>(\n                 Rvalue::Discriminant(place) => {\n                     let place = codegen_place(fx, place);\n                     let value = place.to_cvalue(fx);\n-                    let discr =\n-                        crate::discriminant::codegen_get_discriminant(fx, value, dest_layout);\n-                    lval.write_cvalue(fx, discr);\n+                    crate::discriminant::codegen_get_discriminant(fx, lval, value, dest_layout);\n                 }\n                 Rvalue::Repeat(ref operand, times) => {\n                     let operand = codegen_operand(fx, operand);"}, {"sha": "589594465783e1611c688cd17f5c82325ae9576f", "filename": "compiler/rustc_codegen_cranelift/src/common.rs", "status": "modified", "additions": 39, "deletions": 7, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/f2878a656b944ceed6f4a98d7e255784266a3dc0/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2878a656b944ceed6f4a98d7e255784266a3dc0/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcommon.rs?ref=f2878a656b944ceed6f4a98d7e255784266a3dc0", "patch": "@@ -1,14 +1,18 @@\n use cranelift_codegen::isa::TargetFrontendConfig;\n+use gimli::write::FileId;\n+\n+use rustc_data_structures::sync::Lrc;\n use rustc_index::vec::IndexVec;\n use rustc_middle::ty::layout::{\n     FnAbiError, FnAbiOfHelpers, FnAbiRequest, LayoutError, LayoutOfHelpers,\n };\n-use rustc_middle::ty::SymbolName;\n+use rustc_span::SourceFile;\n use rustc_target::abi::call::FnAbi;\n use rustc_target::abi::{Integer, Primitive};\n use rustc_target::spec::{HasTargetSpec, Target};\n \n use crate::constant::ConstantCx;\n+use crate::debuginfo::FunctionDebugContext;\n use crate::prelude::*;\n \n pub(crate) fn pointer_ty(tcx: TyCtxt<'_>) -> types::Type {\n@@ -74,7 +78,7 @@ fn clif_type_from_ty<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> Option<types::Typ\n                 _ => unreachable!(),\n             };\n \n-            match scalar_to_clif_type(tcx, element).by(u16::try_from(count).unwrap()) {\n+            match scalar_to_clif_type(tcx, element).by(u32::try_from(count).unwrap()) {\n                 // Cranelift currently only implements icmp for 128bit vectors.\n                 Some(vector_ty) if vector_ty.bits() == 128 => vector_ty,\n                 _ => return None,\n@@ -232,15 +236,16 @@ pub(crate) fn type_sign(ty: Ty<'_>) -> bool {\n }\n \n pub(crate) struct FunctionCx<'m, 'clif, 'tcx: 'm> {\n-    pub(crate) cx: &'clif mut crate::CodegenCx<'tcx>,\n+    pub(crate) cx: &'clif mut crate::CodegenCx,\n     pub(crate) module: &'m mut dyn Module,\n     pub(crate) tcx: TyCtxt<'tcx>,\n     pub(crate) target_config: TargetFrontendConfig, // Cached from module\n     pub(crate) pointer_type: Type,                  // Cached from module\n     pub(crate) constants_cx: ConstantCx,\n+    pub(crate) func_debug_cx: Option<FunctionDebugContext>,\n \n     pub(crate) instance: Instance<'tcx>,\n-    pub(crate) symbol_name: SymbolName<'tcx>,\n+    pub(crate) symbol_name: String,\n     pub(crate) mir: &'tcx Body<'tcx>,\n     pub(crate) fn_abi: Option<&'tcx FnAbi<'tcx, Ty<'tcx>>>,\n \n@@ -252,7 +257,11 @@ pub(crate) struct FunctionCx<'m, 'clif, 'tcx: 'm> {\n     pub(crate) caller_location: Option<CValue<'tcx>>,\n \n     pub(crate) clif_comments: crate::pretty_clif::CommentWriter,\n-    pub(crate) source_info_set: indexmap::IndexSet<SourceInfo>,\n+\n+    /// Last accessed source file and it's debuginfo file id.\n+    ///\n+    /// For optimization purposes only\n+    pub(crate) last_source_file: Option<(Lrc<SourceFile>, FileId)>,\n \n     /// This should only be accessed by `CPlace::new_var`.\n     pub(crate) next_ssa_var: u32,\n@@ -336,8 +345,31 @@ impl<'tcx> FunctionCx<'_, '_, 'tcx> {\n     }\n \n     pub(crate) fn set_debug_loc(&mut self, source_info: mir::SourceInfo) {\n-        let (index, _) = self.source_info_set.insert_full(source_info);\n-        self.bcx.set_srcloc(SourceLoc::new(index as u32));\n+        if let Some(debug_context) = &mut self.cx.debug_context {\n+            let (file, line, column) =\n+                DebugContext::get_span_loc(self.tcx, self.mir.span, source_info.span);\n+\n+            // add_source_file is very slow.\n+            // Optimize for the common case of the current file not being changed.\n+            let mut cached_file_id = None;\n+            if let Some((ref last_source_file, last_file_id)) = self.last_source_file {\n+                // If the allocations are not equal, the files may still be equal, but that\n+                // doesn't matter, as this is just an optimization.\n+                if rustc_data_structures::sync::Lrc::ptr_eq(last_source_file, &file) {\n+                    cached_file_id = Some(last_file_id);\n+                }\n+            }\n+\n+            let file_id = if let Some(file_id) = cached_file_id {\n+                file_id\n+            } else {\n+                debug_context.add_source_file(&file)\n+            };\n+\n+            let source_loc =\n+                self.func_debug_cx.as_mut().unwrap().add_dbg_loc(file_id, line, column);\n+            self.bcx.set_srcloc(source_loc);\n+        }\n     }\n \n     // Note: must be kept in sync with get_caller_location from cg_ssa"}, {"sha": "dfde97920461e21de9d6cfcc40581d5eda55234e", "filename": "compiler/rustc_codegen_cranelift/src/concurrency_limiter.rs", "status": "added", "additions": 168, "deletions": 0, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/f2878a656b944ceed6f4a98d7e255784266a3dc0/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconcurrency_limiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2878a656b944ceed6f4a98d7e255784266a3dc0/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconcurrency_limiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconcurrency_limiter.rs?ref=f2878a656b944ceed6f4a98d7e255784266a3dc0", "patch": "@@ -0,0 +1,168 @@\n+use std::sync::{Arc, Condvar, Mutex};\n+\n+use rustc_session::Session;\n+\n+use jobserver::HelperThread;\n+\n+// FIXME don't panic when a worker thread panics\n+\n+pub(super) struct ConcurrencyLimiter {\n+    helper_thread: Option<HelperThread>,\n+    state: Arc<Mutex<state::ConcurrencyLimiterState>>,\n+    available_token_condvar: Arc<Condvar>,\n+}\n+\n+impl ConcurrencyLimiter {\n+    pub(super) fn new(sess: &Session, pending_jobs: usize) -> Self {\n+        let state = Arc::new(Mutex::new(state::ConcurrencyLimiterState::new(pending_jobs)));\n+        let available_token_condvar = Arc::new(Condvar::new());\n+\n+        let state_helper = state.clone();\n+        let available_token_condvar_helper = available_token_condvar.clone();\n+        let helper_thread = sess\n+            .jobserver\n+            .clone()\n+            .into_helper_thread(move |token| {\n+                let mut state = state_helper.lock().unwrap();\n+                state.add_new_token(token.unwrap());\n+                available_token_condvar_helper.notify_one();\n+            })\n+            .unwrap();\n+        ConcurrencyLimiter {\n+            helper_thread: Some(helper_thread),\n+            state,\n+            available_token_condvar: Arc::new(Condvar::new()),\n+        }\n+    }\n+\n+    pub(super) fn acquire(&mut self) -> ConcurrencyLimiterToken {\n+        let mut state = self.state.lock().unwrap();\n+        loop {\n+            state.assert_invariants();\n+\n+            if state.try_start_job() {\n+                return ConcurrencyLimiterToken {\n+                    state: self.state.clone(),\n+                    available_token_condvar: self.available_token_condvar.clone(),\n+                };\n+            }\n+\n+            self.helper_thread.as_mut().unwrap().request_token();\n+            state = self.available_token_condvar.wait(state).unwrap();\n+        }\n+    }\n+\n+    pub(super) fn job_already_done(&mut self) {\n+        let mut state = self.state.lock().unwrap();\n+        state.job_already_done();\n+    }\n+}\n+\n+impl Drop for ConcurrencyLimiter {\n+    fn drop(&mut self) {\n+        //\n+        self.helper_thread.take();\n+\n+        // Assert that all jobs have finished\n+        let state = Mutex::get_mut(Arc::get_mut(&mut self.state).unwrap()).unwrap();\n+        state.assert_done();\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub(super) struct ConcurrencyLimiterToken {\n+    state: Arc<Mutex<state::ConcurrencyLimiterState>>,\n+    available_token_condvar: Arc<Condvar>,\n+}\n+\n+impl Drop for ConcurrencyLimiterToken {\n+    fn drop(&mut self) {\n+        let mut state = self.state.lock().unwrap();\n+        state.job_finished();\n+        self.available_token_condvar.notify_one();\n+    }\n+}\n+\n+mod state {\n+    use jobserver::Acquired;\n+\n+    #[derive(Debug)]\n+    pub(super) struct ConcurrencyLimiterState {\n+        pending_jobs: usize,\n+        active_jobs: usize,\n+\n+        // None is used to represent the implicit token, Some to represent explicit tokens\n+        tokens: Vec<Option<Acquired>>,\n+    }\n+\n+    impl ConcurrencyLimiterState {\n+        pub(super) fn new(pending_jobs: usize) -> Self {\n+            ConcurrencyLimiterState { pending_jobs, active_jobs: 0, tokens: vec![None] }\n+        }\n+\n+        pub(super) fn assert_invariants(&self) {\n+            // There must be no excess active jobs\n+            assert!(self.active_jobs <= self.pending_jobs);\n+\n+            // There may not be more active jobs than there are tokens\n+            assert!(self.active_jobs <= self.tokens.len());\n+        }\n+\n+        pub(super) fn assert_done(&self) {\n+            assert_eq!(self.pending_jobs, 0);\n+            assert_eq!(self.active_jobs, 0);\n+        }\n+\n+        pub(super) fn add_new_token(&mut self, token: Acquired) {\n+            self.tokens.push(Some(token));\n+            self.drop_excess_capacity();\n+        }\n+\n+        pub(super) fn try_start_job(&mut self) -> bool {\n+            if self.active_jobs < self.tokens.len() {\n+                // Using existing token\n+                self.job_started();\n+                return true;\n+            }\n+\n+            false\n+        }\n+\n+        pub(super) fn job_started(&mut self) {\n+            self.assert_invariants();\n+            self.active_jobs += 1;\n+            self.drop_excess_capacity();\n+            self.assert_invariants();\n+        }\n+\n+        pub(super) fn job_finished(&mut self) {\n+            self.assert_invariants();\n+            self.pending_jobs -= 1;\n+            self.active_jobs -= 1;\n+            self.assert_invariants();\n+            self.drop_excess_capacity();\n+            self.assert_invariants();\n+        }\n+\n+        pub(super) fn job_already_done(&mut self) {\n+            self.assert_invariants();\n+            self.pending_jobs -= 1;\n+            self.assert_invariants();\n+            self.drop_excess_capacity();\n+            self.assert_invariants();\n+        }\n+\n+        fn drop_excess_capacity(&mut self) {\n+            self.assert_invariants();\n+\n+            // Drop all tokens that can never be used anymore\n+            self.tokens.truncate(std::cmp::max(self.pending_jobs, 1));\n+\n+            // Keep some excess tokens to satisfy requests faster\n+            const MAX_EXTRA_CAPACITY: usize = 2;\n+            self.tokens.truncate(std::cmp::max(self.active_jobs + MAX_EXTRA_CAPACITY, 1));\n+\n+            self.assert_invariants();\n+        }\n+    }\n+}"}, {"sha": "9583cd2ec60f8a5bcf3bb3d4b0b74ea806f97614", "filename": "compiler/rustc_codegen_cranelift/src/debuginfo/emit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f2878a656b944ceed6f4a98d7e255784266a3dc0/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Femit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2878a656b944ceed6f4a98d7e255784266a3dc0/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Femit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Femit.rs?ref=f2878a656b944ceed6f4a98d7e255784266a3dc0", "patch": "@@ -9,7 +9,7 @@ use gimli::{RunTimeEndian, SectionId};\n use super::object::WriteDebugInfo;\n use super::DebugContext;\n \n-impl DebugContext<'_> {\n+impl DebugContext {\n     pub(crate) fn emit(&mut self, product: &mut ObjectProduct) {\n         let unit_range_list_id = self.dwarf.unit.ranges.add(self.unit_range_list.clone());\n         let root = self.dwarf.unit.root();"}, {"sha": "3ad0c420eaf0b010b313e4dae0a785778eb21f0f", "filename": "compiler/rustc_codegen_cranelift/src/debuginfo/line_info.rs", "status": "modified", "additions": 93, "deletions": 120, "changes": 213, "blob_url": "https://github.com/rust-lang/rust/blob/f2878a656b944ceed6f4a98d7e255784266a3dc0/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Fline_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2878a656b944ceed6f4a98d7e255784266a3dc0/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Fline_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Fline_info.rs?ref=f2878a656b944ceed6f4a98d7e255784266a3dc0", "patch": "@@ -3,8 +3,10 @@\n use std::ffi::OsStr;\n use std::path::{Component, Path};\n \n+use crate::debuginfo::FunctionDebugContext;\n use crate::prelude::*;\n \n+use rustc_data_structures::sync::Lrc;\n use rustc_span::{\n     FileName, Pos, SourceFile, SourceFileAndLine, SourceFileHash, SourceFileHashAlgorithm,\n };\n@@ -14,7 +16,6 @@ use cranelift_codegen::MachSrcLoc;\n \n use gimli::write::{\n     Address, AttributeValue, FileId, FileInfo, LineProgram, LineString, LineStringTable,\n-    UnitEntryId,\n };\n \n // OPTIMIZATION: It is cheaper to do this in one pass than using `.parent()` and `.file_name()`.\n@@ -47,9 +48,9 @@ fn osstr_as_utf8_bytes(path: &OsStr) -> &[u8] {\n     }\n }\n \n-pub(crate) const MD5_LEN: usize = 16;\n+const MD5_LEN: usize = 16;\n \n-pub(crate) fn make_file_info(hash: SourceFileHash) -> Option<FileInfo> {\n+fn make_file_info(hash: SourceFileHash) -> Option<FileInfo> {\n     if hash.kind == SourceFileHashAlgorithm::Md5 {\n         let mut buf = [0u8; MD5_LEN];\n         buf.copy_from_slice(hash.hash_bytes());\n@@ -59,160 +60,132 @@ pub(crate) fn make_file_info(hash: SourceFileHash) -> Option<FileInfo> {\n     }\n }\n \n-fn line_program_add_file(\n-    line_program: &mut LineProgram,\n-    line_strings: &mut LineStringTable,\n-    file: &SourceFile,\n-) -> FileId {\n-    match &file.name {\n-        FileName::Real(path) => {\n-            let (dir_path, file_name) = split_path_dir_and_file(path.remapped_path_if_available());\n-            let dir_name = osstr_as_utf8_bytes(dir_path.as_os_str());\n-            let file_name = osstr_as_utf8_bytes(file_name);\n-\n-            let dir_id = if !dir_name.is_empty() {\n-                let dir_name = LineString::new(dir_name, line_program.encoding(), line_strings);\n-                line_program.add_directory(dir_name)\n-            } else {\n-                line_program.default_directory()\n-            };\n-            let file_name = LineString::new(file_name, line_program.encoding(), line_strings);\n+impl DebugContext {\n+    pub(crate) fn get_span_loc(\n+        tcx: TyCtxt<'_>,\n+        function_span: Span,\n+        span: Span,\n+    ) -> (Lrc<SourceFile>, u64, u64) {\n+        // Based on https://github.com/rust-lang/rust/blob/e369d87b015a84653343032833d65d0545fd3f26/src/librustc_codegen_ssa/mir/mod.rs#L116-L131\n+        // In order to have a good line stepping behavior in debugger, we overwrite debug\n+        // locations of macro expansions with that of the outermost expansion site\n+        // (unless the crate is being compiled with `-Z debug-macros`).\n+        let span = if !span.from_expansion() || tcx.sess.opts.unstable_opts.debug_macros {\n+            span\n+        } else {\n+            // Walk up the macro expansion chain until we reach a non-expanded span.\n+            // We also stop at the function body level because no line stepping can occur\n+            // at the level above that.\n+            rustc_span::hygiene::walk_chain(span, function_span.ctxt())\n+        };\n \n-            let info = make_file_info(file.src_hash);\n+        match tcx.sess.source_map().lookup_line(span.lo()) {\n+            Ok(SourceFileAndLine { sf: file, line }) => {\n+                let line_pos = file.line_begin_pos(span.lo());\n \n-            line_program.file_has_md5 &= info.is_some();\n-            line_program.add_file(file_name, dir_id, info)\n+                (\n+                    file,\n+                    u64::try_from(line).unwrap() + 1,\n+                    u64::from((span.lo() - line_pos).to_u32()) + 1,\n+                )\n+            }\n+            Err(file) => (file, 0, 0),\n         }\n-        // FIXME give more appropriate file names\n-        filename => {\n-            let dir_id = line_program.default_directory();\n-            let dummy_file_name = LineString::new(\n-                filename.prefer_remapped().to_string().into_bytes(),\n-                line_program.encoding(),\n-                line_strings,\n-            );\n-            line_program.add_file(dummy_file_name, dir_id, None)\n+    }\n+\n+    pub(crate) fn add_source_file(&mut self, source_file: &SourceFile) -> FileId {\n+        let line_program: &mut LineProgram = &mut self.dwarf.unit.line_program;\n+        let line_strings: &mut LineStringTable = &mut self.dwarf.line_strings;\n+\n+        match &source_file.name {\n+            FileName::Real(path) => {\n+                let (dir_path, file_name) =\n+                    split_path_dir_and_file(path.remapped_path_if_available());\n+                let dir_name = osstr_as_utf8_bytes(dir_path.as_os_str());\n+                let file_name = osstr_as_utf8_bytes(file_name);\n+\n+                let dir_id = if !dir_name.is_empty() {\n+                    let dir_name = LineString::new(dir_name, line_program.encoding(), line_strings);\n+                    line_program.add_directory(dir_name)\n+                } else {\n+                    line_program.default_directory()\n+                };\n+                let file_name = LineString::new(file_name, line_program.encoding(), line_strings);\n+\n+                let info = make_file_info(source_file.src_hash);\n+\n+                line_program.file_has_md5 &= info.is_some();\n+                line_program.add_file(file_name, dir_id, info)\n+            }\n+            // FIXME give more appropriate file names\n+            filename => {\n+                let dir_id = line_program.default_directory();\n+                let dummy_file_name = LineString::new(\n+                    filename.prefer_remapped().to_string().into_bytes(),\n+                    line_program.encoding(),\n+                    line_strings,\n+                );\n+                line_program.add_file(dummy_file_name, dir_id, None)\n+            }\n         }\n     }\n }\n \n-impl<'tcx> DebugContext<'tcx> {\n-    pub(super) fn emit_location(&mut self, entry_id: UnitEntryId, span: Span) {\n-        let loc = self.tcx.sess.source_map().lookup_char_pos(span.lo());\n-\n-        let file_id = line_program_add_file(\n-            &mut self.dwarf.unit.line_program,\n-            &mut self.dwarf.line_strings,\n-            &loc.file,\n-        );\n-\n-        let entry = self.dwarf.unit.get_mut(entry_id);\n-\n-        entry.set(gimli::DW_AT_decl_file, AttributeValue::FileIndex(Some(file_id)));\n-        entry.set(gimli::DW_AT_decl_line, AttributeValue::Udata(loc.line as u64));\n-        entry.set(gimli::DW_AT_decl_column, AttributeValue::Udata(loc.col.to_usize() as u64));\n+impl FunctionDebugContext {\n+    pub(crate) fn add_dbg_loc(&mut self, file_id: FileId, line: u64, column: u64) -> SourceLoc {\n+        let (index, _) = self.source_loc_set.insert_full((file_id, line, column));\n+        SourceLoc::new(u32::try_from(index).unwrap())\n     }\n \n     pub(super) fn create_debug_lines(\n         &mut self,\n+        debug_context: &mut DebugContext,\n         symbol: usize,\n-        entry_id: UnitEntryId,\n         context: &Context,\n-        function_span: Span,\n-        source_info_set: &indexmap::IndexSet<SourceInfo>,\n     ) -> CodeOffset {\n-        let tcx = self.tcx;\n-        let line_program = &mut self.dwarf.unit.line_program;\n-\n-        let line_strings = &mut self.dwarf.line_strings;\n-        let mut last_span = None;\n-        let mut last_file = None;\n-        let mut create_row_for_span = |line_program: &mut LineProgram, span: Span| {\n-            if let Some(last_span) = last_span {\n-                if span == last_span {\n-                    line_program.generate_row();\n-                    return;\n-                }\n-            }\n-            last_span = Some(span);\n-\n-            // Based on https://github.com/rust-lang/rust/blob/e369d87b015a84653343032833d65d0545fd3f26/src/librustc_codegen_ssa/mir/mod.rs#L116-L131\n-            // In order to have a good line stepping behavior in debugger, we overwrite debug\n-            // locations of macro expansions with that of the outermost expansion site\n-            // (unless the crate is being compiled with `-Z debug-macros`).\n-            let span = if !span.from_expansion() || tcx.sess.opts.unstable_opts.debug_macros {\n-                span\n-            } else {\n-                // Walk up the macro expansion chain until we reach a non-expanded span.\n-                // We also stop at the function body level because no line stepping can occur\n-                // at the level above that.\n-                rustc_span::hygiene::walk_chain(span, function_span.ctxt())\n+        let create_row_for_span =\n+            |debug_context: &mut DebugContext, source_loc: (FileId, u64, u64)| {\n+                let (file_id, line, col) = source_loc;\n+\n+                debug_context.dwarf.unit.line_program.row().file = file_id;\n+                debug_context.dwarf.unit.line_program.row().line = line;\n+                debug_context.dwarf.unit.line_program.row().column = col;\n+                debug_context.dwarf.unit.line_program.generate_row();\n             };\n \n-            let (file, line, col) = match tcx.sess.source_map().lookup_line(span.lo()) {\n-                Ok(SourceFileAndLine { sf: file, line }) => {\n-                    let line_pos = file.line_begin_pos(span.lo());\n-\n-                    (\n-                        file,\n-                        u64::try_from(line).unwrap() + 1,\n-                        u64::from((span.lo() - line_pos).to_u32()) + 1,\n-                    )\n-                }\n-                Err(file) => (file, 0, 0),\n-            };\n-\n-            // line_program_add_file is very slow.\n-            // Optimize for the common case of the current file not being changed.\n-            let current_file_changed = if let Some(last_file) = &last_file {\n-                // If the allocations are not equal, then the files may still be equal, but that\n-                // is not a problem, as this is just an optimization.\n-                !rustc_data_structures::sync::Lrc::ptr_eq(last_file, &file)\n-            } else {\n-                true\n-            };\n-            if current_file_changed {\n-                let file_id = line_program_add_file(line_program, line_strings, &file);\n-                line_program.row().file = file_id;\n-                last_file = Some(file);\n-            }\n-\n-            line_program.row().line = line;\n-            line_program.row().column = col;\n-            line_program.generate_row();\n-        };\n-\n-        line_program.begin_sequence(Some(Address::Symbol { symbol, addend: 0 }));\n+        debug_context\n+            .dwarf\n+            .unit\n+            .line_program\n+            .begin_sequence(Some(Address::Symbol { symbol, addend: 0 }));\n \n         let mut func_end = 0;\n \n-        let mcr = context.mach_compile_result.as_ref().unwrap();\n+        let mcr = context.compiled_code().unwrap();\n         for &MachSrcLoc { start, end, loc } in mcr.buffer.get_srclocs_sorted() {\n-            line_program.row().address_offset = u64::from(start);\n+            debug_context.dwarf.unit.line_program.row().address_offset = u64::from(start);\n             if !loc.is_default() {\n-                let source_info = *source_info_set.get_index(loc.bits() as usize).unwrap();\n-                create_row_for_span(line_program, source_info.span);\n+                let source_loc = *self.source_loc_set.get_index(loc.bits() as usize).unwrap();\n+                create_row_for_span(debug_context, source_loc);\n             } else {\n-                create_row_for_span(line_program, function_span);\n+                create_row_for_span(debug_context, self.function_source_loc);\n             }\n             func_end = end;\n         }\n \n-        line_program.end_sequence(u64::from(func_end));\n+        debug_context.dwarf.unit.line_program.end_sequence(u64::from(func_end));\n \n         let func_end = mcr.buffer.total_size();\n \n         assert_ne!(func_end, 0);\n \n-        let entry = self.dwarf.unit.get_mut(entry_id);\n+        let entry = debug_context.dwarf.unit.get_mut(self.entry_id);\n         entry.set(\n             gimli::DW_AT_low_pc,\n             AttributeValue::Address(Address::Symbol { symbol, addend: 0 }),\n         );\n         entry.set(gimli::DW_AT_high_pc, AttributeValue::Udata(u64::from(func_end)));\n \n-        self.emit_location(entry_id, function_span);\n-\n         func_end\n     }\n }"}, {"sha": "c55db2017ee68c31c53b0a59e12c82b6b72c6c7e", "filename": "compiler/rustc_codegen_cranelift/src/debuginfo/mod.rs", "status": "modified", "additions": 44, "deletions": 238, "changes": 282, "blob_url": "https://github.com/rust-lang/rust/blob/f2878a656b944ceed6f4a98d7e255784266a3dc0/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2878a656b944ceed6f4a98d7e255784266a3dc0/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Fmod.rs?ref=f2878a656b944ceed6f4a98d7e255784266a3dc0", "patch": "@@ -7,35 +7,34 @@ mod unwind;\n \n use crate::prelude::*;\n \n-use rustc_index::vec::IndexVec;\n-\n-use cranelift_codegen::entity::EntityRef;\n-use cranelift_codegen::ir::{Endianness, LabelValueLoc, ValueLabel};\n+use cranelift_codegen::ir::Endianness;\n use cranelift_codegen::isa::TargetIsa;\n-use cranelift_codegen::ValueLocRange;\n \n use gimli::write::{\n-    Address, AttributeValue, DwarfUnit, Expression, LineProgram, LineString, Location,\n-    LocationList, Range, RangeList, UnitEntryId,\n+    Address, AttributeValue, DwarfUnit, FileId, LineProgram, LineString, Range, RangeList,\n+    UnitEntryId,\n };\n-use gimli::{Encoding, Format, LineEncoding, RunTimeEndian, X86_64};\n+use gimli::{Encoding, Format, LineEncoding, RunTimeEndian};\n+use indexmap::IndexSet;\n \n pub(crate) use emit::{DebugReloc, DebugRelocName};\n pub(crate) use unwind::UnwindContext;\n \n-pub(crate) struct DebugContext<'tcx> {\n-    tcx: TyCtxt<'tcx>,\n-\n+pub(crate) struct DebugContext {\n     endian: RunTimeEndian,\n \n     dwarf: DwarfUnit,\n     unit_range_list: RangeList,\n+}\n \n-    types: FxHashMap<Ty<'tcx>, UnitEntryId>,\n+pub(crate) struct FunctionDebugContext {\n+    entry_id: UnitEntryId,\n+    function_source_loc: (FileId, u64, u64),\n+    source_loc_set: indexmap::IndexSet<(FileId, u64, u64)>,\n }\n \n-impl<'tcx> DebugContext<'tcx> {\n-    pub(crate) fn new(tcx: TyCtxt<'tcx>, isa: &dyn TargetIsa) -> Self {\n+impl DebugContext {\n+    pub(crate) fn new(tcx: TyCtxt<'_>, isa: &dyn TargetIsa) -> Self {\n         let encoding = Encoding {\n             format: Format::Dwarf32,\n             // FIXME this should be configurable\n@@ -101,127 +100,18 @@ impl<'tcx> DebugContext<'tcx> {\n             root.set(gimli::DW_AT_low_pc, AttributeValue::Address(Address::Constant(0)));\n         }\n \n-        DebugContext {\n-            tcx,\n-\n-            endian,\n-\n-            dwarf,\n-            unit_range_list: RangeList(Vec::new()),\n-\n-            types: FxHashMap::default(),\n-        }\n-    }\n-\n-    fn dwarf_ty(&mut self, ty: Ty<'tcx>) -> UnitEntryId {\n-        if let Some(type_id) = self.types.get(&ty) {\n-            return *type_id;\n-        }\n-\n-        let new_entry = |dwarf: &mut DwarfUnit, tag| dwarf.unit.add(dwarf.unit.root(), tag);\n-\n-        let primitive = |dwarf: &mut DwarfUnit, ate| {\n-            let type_id = new_entry(dwarf, gimli::DW_TAG_base_type);\n-            let type_entry = dwarf.unit.get_mut(type_id);\n-            type_entry.set(gimli::DW_AT_encoding, AttributeValue::Encoding(ate));\n-            type_id\n-        };\n-\n-        let name = format!(\"{}\", ty);\n-        let layout = self.tcx.layout_of(ParamEnv::reveal_all().and(ty)).unwrap();\n-\n-        let type_id = match ty.kind() {\n-            ty::Bool => primitive(&mut self.dwarf, gimli::DW_ATE_boolean),\n-            ty::Char => primitive(&mut self.dwarf, gimli::DW_ATE_UTF),\n-            ty::Uint(_) => primitive(&mut self.dwarf, gimli::DW_ATE_unsigned),\n-            ty::Int(_) => primitive(&mut self.dwarf, gimli::DW_ATE_signed),\n-            ty::Float(_) => primitive(&mut self.dwarf, gimli::DW_ATE_float),\n-            ty::Ref(_, pointee_ty, _mutbl)\n-            | ty::RawPtr(ty::TypeAndMut { ty: pointee_ty, mutbl: _mutbl }) => {\n-                let type_id = new_entry(&mut self.dwarf, gimli::DW_TAG_pointer_type);\n-\n-                // Ensure that type is inserted before recursing to avoid duplicates\n-                self.types.insert(ty, type_id);\n-\n-                let pointee = self.dwarf_ty(*pointee_ty);\n-\n-                let type_entry = self.dwarf.unit.get_mut(type_id);\n-\n-                //type_entry.set(gimli::DW_AT_mutable, AttributeValue::Flag(mutbl == rustc_hir::Mutability::Mut));\n-                type_entry.set(gimli::DW_AT_type, AttributeValue::UnitRef(pointee));\n-\n-                type_id\n-            }\n-            ty::Adt(adt_def, _substs) if adt_def.is_struct() && !layout.is_unsized() => {\n-                let type_id = new_entry(&mut self.dwarf, gimli::DW_TAG_structure_type);\n-\n-                // Ensure that type is inserted before recursing to avoid duplicates\n-                self.types.insert(ty, type_id);\n-\n-                let variant = adt_def.non_enum_variant();\n-\n-                for (field_idx, field_def) in variant.fields.iter().enumerate() {\n-                    let field_offset = layout.fields.offset(field_idx);\n-                    let field_layout = layout.field(\n-                        &layout::LayoutCx { tcx: self.tcx, param_env: ParamEnv::reveal_all() },\n-                        field_idx,\n-                    );\n-\n-                    let field_type = self.dwarf_ty(field_layout.ty);\n-\n-                    let field_id = self.dwarf.unit.add(type_id, gimli::DW_TAG_member);\n-                    let field_entry = self.dwarf.unit.get_mut(field_id);\n-\n-                    field_entry.set(\n-                        gimli::DW_AT_name,\n-                        AttributeValue::String(field_def.name.as_str().to_string().into_bytes()),\n-                    );\n-                    field_entry.set(\n-                        gimli::DW_AT_data_member_location,\n-                        AttributeValue::Udata(field_offset.bytes()),\n-                    );\n-                    field_entry.set(gimli::DW_AT_type, AttributeValue::UnitRef(field_type));\n-                }\n-\n-                type_id\n-            }\n-            _ => new_entry(&mut self.dwarf, gimli::DW_TAG_structure_type),\n-        };\n-\n-        let type_entry = self.dwarf.unit.get_mut(type_id);\n-\n-        type_entry.set(gimli::DW_AT_name, AttributeValue::String(name.into_bytes()));\n-        type_entry.set(gimli::DW_AT_byte_size, AttributeValue::Udata(layout.size.bytes()));\n-\n-        self.types.insert(ty, type_id);\n-\n-        type_id\n-    }\n-\n-    fn define_local(&mut self, scope: UnitEntryId, name: String, ty: Ty<'tcx>) -> UnitEntryId {\n-        let dw_ty = self.dwarf_ty(ty);\n-\n-        let var_id = self.dwarf.unit.add(scope, gimli::DW_TAG_variable);\n-        let var_entry = self.dwarf.unit.get_mut(var_id);\n-\n-        var_entry.set(gimli::DW_AT_name, AttributeValue::String(name.into_bytes()));\n-        var_entry.set(gimli::DW_AT_type, AttributeValue::UnitRef(dw_ty));\n-\n-        var_id\n+        DebugContext { endian, dwarf, unit_range_list: RangeList(Vec::new()) }\n     }\n \n     pub(crate) fn define_function(\n         &mut self,\n-        instance: Instance<'tcx>,\n-        func_id: FuncId,\n+        tcx: TyCtxt<'_>,\n         name: &str,\n-        isa: &dyn TargetIsa,\n-        context: &Context,\n-        source_info_set: &indexmap::IndexSet<SourceInfo>,\n-        local_map: IndexVec<mir::Local, CPlace<'tcx>>,\n-    ) {\n-        let symbol = func_id.as_u32() as usize;\n-        let mir = self.tcx.instance_mir(instance.def);\n+        function_span: Span,\n+    ) -> FunctionDebugContext {\n+        let (file, line, column) = DebugContext::get_span_loc(tcx, function_span, function_span);\n+\n+        let file_id = self.add_source_file(&file);\n \n         // FIXME: add to appropriate scope instead of root\n         let scope = self.dwarf.unit.root();\n@@ -233,125 +123,41 @@ impl<'tcx> DebugContext<'tcx> {\n         entry.set(gimli::DW_AT_name, AttributeValue::StringRef(name_id));\n         entry.set(gimli::DW_AT_linkage_name, AttributeValue::StringRef(name_id));\n \n-        let end = self.create_debug_lines(symbol, entry_id, context, mir.span, source_info_set);\n+        entry.set(gimli::DW_AT_decl_file, AttributeValue::FileIndex(Some(file_id)));\n+        entry.set(gimli::DW_AT_decl_line, AttributeValue::Udata(line));\n+        entry.set(gimli::DW_AT_decl_column, AttributeValue::Udata(column));\n \n-        self.unit_range_list.0.push(Range::StartLength {\n+        FunctionDebugContext {\n+            entry_id,\n+            function_source_loc: (file_id, line, column),\n+            source_loc_set: IndexSet::new(),\n+        }\n+    }\n+}\n+\n+impl FunctionDebugContext {\n+    pub(crate) fn finalize(\n+        mut self,\n+        debug_context: &mut DebugContext,\n+        func_id: FuncId,\n+        context: &Context,\n+    ) {\n+        let symbol = func_id.as_u32() as usize;\n+\n+        let end = self.create_debug_lines(debug_context, symbol, context);\n+\n+        debug_context.unit_range_list.0.push(Range::StartLength {\n             begin: Address::Symbol { symbol, addend: 0 },\n             length: u64::from(end),\n         });\n \n-        let func_entry = self.dwarf.unit.get_mut(entry_id);\n+        let func_entry = debug_context.dwarf.unit.get_mut(self.entry_id);\n         // Gdb requires both DW_AT_low_pc and DW_AT_high_pc. Otherwise the DW_TAG_subprogram is skipped.\n         func_entry.set(\n             gimli::DW_AT_low_pc,\n             AttributeValue::Address(Address::Symbol { symbol, addend: 0 }),\n         );\n         // Using Udata for DW_AT_high_pc requires at least DWARF4\n         func_entry.set(gimli::DW_AT_high_pc, AttributeValue::Udata(u64::from(end)));\n-\n-        // FIXME make it more reliable and implement scopes before re-enabling this.\n-        if false {\n-            let value_labels_ranges = std::collections::HashMap::new(); // FIXME\n-\n-            for (local, _local_decl) in mir.local_decls.iter_enumerated() {\n-                let ty = self.tcx.subst_and_normalize_erasing_regions(\n-                    instance.substs,\n-                    ty::ParamEnv::reveal_all(),\n-                    mir.local_decls[local].ty,\n-                );\n-                let var_id = self.define_local(entry_id, format!(\"{:?}\", local), ty);\n-\n-                let location = place_location(\n-                    self,\n-                    isa,\n-                    symbol,\n-                    &local_map,\n-                    &value_labels_ranges,\n-                    Place { local, projection: ty::List::empty() },\n-                );\n-\n-                let var_entry = self.dwarf.unit.get_mut(var_id);\n-                var_entry.set(gimli::DW_AT_location, location);\n-            }\n-        }\n-\n-        // FIXME create locals for all entries in mir.var_debug_info\n-    }\n-}\n-\n-fn place_location<'tcx>(\n-    debug_context: &mut DebugContext<'tcx>,\n-    isa: &dyn TargetIsa,\n-    symbol: usize,\n-    local_map: &IndexVec<mir::Local, CPlace<'tcx>>,\n-    #[allow(rustc::default_hash_types)] value_labels_ranges: &std::collections::HashMap<\n-        ValueLabel,\n-        Vec<ValueLocRange>,\n-    >,\n-    place: Place<'tcx>,\n-) -> AttributeValue {\n-    assert!(place.projection.is_empty()); // FIXME implement them\n-\n-    match local_map[place.local].inner() {\n-        CPlaceInner::Var(_local, var) => {\n-            let value_label = cranelift_codegen::ir::ValueLabel::new(var.index());\n-            if let Some(value_loc_ranges) = value_labels_ranges.get(&value_label) {\n-                let loc_list = LocationList(\n-                    value_loc_ranges\n-                        .iter()\n-                        .map(|value_loc_range| Location::StartEnd {\n-                            begin: Address::Symbol {\n-                                symbol,\n-                                addend: i64::from(value_loc_range.start),\n-                            },\n-                            end: Address::Symbol { symbol, addend: i64::from(value_loc_range.end) },\n-                            data: translate_loc(isa, value_loc_range.loc).unwrap(),\n-                        })\n-                        .collect(),\n-                );\n-                let loc_list_id = debug_context.dwarf.unit.locations.add(loc_list);\n-\n-                AttributeValue::LocationListRef(loc_list_id)\n-            } else {\n-                // FIXME set value labels for unused locals\n-\n-                AttributeValue::Exprloc(Expression::new())\n-            }\n-        }\n-        CPlaceInner::VarPair(_, _, _) => {\n-            // FIXME implement this\n-\n-            AttributeValue::Exprloc(Expression::new())\n-        }\n-        CPlaceInner::VarLane(_, _, _) => {\n-            // FIXME implement this\n-\n-            AttributeValue::Exprloc(Expression::new())\n-        }\n-        CPlaceInner::Addr(_, _) => {\n-            // FIXME implement this (used by arguments and returns)\n-\n-            AttributeValue::Exprloc(Expression::new())\n-\n-            // For PointerBase::Stack:\n-            //AttributeValue::Exprloc(translate_loc(ValueLoc::Stack(*stack_slot)).unwrap())\n-        }\n-    }\n-}\n-\n-// Adapted from https://github.com/CraneStation/wasmtime/blob/5a1845b4caf7a5dba8eda1fef05213a532ed4259/crates/debug/src/transform/expression.rs#L59-L137\n-fn translate_loc(isa: &dyn TargetIsa, loc: LabelValueLoc) -> Option<Expression> {\n-    match loc {\n-        LabelValueLoc::Reg(reg) => {\n-            let machine_reg = isa.map_regalloc_reg_to_dwarf(reg).unwrap();\n-            let mut expr = Expression::new();\n-            expr.op_reg(gimli::Register(machine_reg));\n-            Some(expr)\n-        }\n-        LabelValueLoc::SPOffset(offset) => {\n-            let mut expr = Expression::new();\n-            expr.op_breg(X86_64::RSP, offset);\n-            Some(expr)\n-        }\n     }\n }"}, {"sha": "e41ae1fbdbac54cd9a58bb80f4d8c9905e1738dc", "filename": "compiler/rustc_codegen_cranelift/src/discriminant.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f2878a656b944ceed6f4a98d7e255784266a3dc0/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdiscriminant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2878a656b944ceed6f4a98d7e255784266a3dc0/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdiscriminant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdiscriminant.rs?ref=f2878a656b944ceed6f4a98d7e255784266a3dc0", "patch": "@@ -62,16 +62,14 @@ pub(crate) fn codegen_set_discriminant<'tcx>(\n \n pub(crate) fn codegen_get_discriminant<'tcx>(\n     fx: &mut FunctionCx<'_, '_, 'tcx>,\n+    dest: CPlace<'tcx>,\n     value: CValue<'tcx>,\n     dest_layout: TyAndLayout<'tcx>,\n-) -> CValue<'tcx> {\n+) {\n     let layout = value.layout();\n \n-    if layout.abi == Abi::Uninhabited {\n-        let true_ = fx.bcx.ins().iconst(types::I32, 1);\n-        fx.bcx.ins().trapnz(true_, TrapCode::UnreachableCodeReached);\n-        // Return a dummy value\n-        return CValue::by_ref(Pointer::const_addr(fx, 0), dest_layout);\n+    if layout.abi.is_uninhabited() {\n+        return;\n     }\n \n     let (tag_scalar, tag_field, tag_encoding) = match &layout.variants {\n@@ -89,7 +87,9 @@ pub(crate) fn codegen_get_discriminant<'tcx>(\n             } else {\n                 ty::ScalarInt::try_from_uint(discr_val, dest_layout.size).unwrap()\n             };\n-            return CValue::const_val(fx, dest_layout, discr_val);\n+            let res = CValue::const_val(fx, dest_layout, discr_val);\n+            dest.write_cvalue(fx, res);\n+            return;\n         }\n         Variants::Multiple { tag, tag_field, tag_encoding, variants: _ } => {\n             (tag, *tag_field, tag_encoding)\n@@ -110,7 +110,8 @@ pub(crate) fn codegen_get_discriminant<'tcx>(\n                 _ => false,\n             };\n             let val = clif_intcast(fx, tag, cast_to, signed);\n-            CValue::by_val(val, dest_layout)\n+            let res = CValue::by_val(val, dest_layout);\n+            dest.write_cvalue(fx, res);\n         }\n         TagEncoding::Niche { dataful_variant, ref niche_variants, niche_start } => {\n             // Rebase from niche values to discriminants, and check\n@@ -170,7 +171,8 @@ pub(crate) fn codegen_get_discriminant<'tcx>(\n \n             let dataful_variant = fx.bcx.ins().iconst(cast_to, i64::from(dataful_variant.as_u32()));\n             let discr = fx.bcx.ins().select(is_niche, niche_discr, dataful_variant);\n-            CValue::by_val(discr, dest_layout)\n+            let res = CValue::by_val(discr, dest_layout);\n+            dest.write_cvalue(fx, res);\n         }\n     }\n }"}, {"sha": "8eabe1cbcb15030380e0ac333315d3326c765629", "filename": "compiler/rustc_codegen_cranelift/src/driver/aot.rs", "status": "modified", "additions": 315, "deletions": 245, "changes": 560, "blob_url": "https://github.com/rust-lang/rust/blob/f2878a656b944ceed6f4a98d7e255784266a3dc0/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Faot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2878a656b944ceed6f4a98d7e255784266a3dc0/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Faot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Faot.rs?ref=f2878a656b944ceed6f4a98d7e255784266a3dc0", "patch": "@@ -1,33 +1,129 @@\n //! The AOT driver uses [`cranelift_object`] to write object files suitable for linking into a\n //! standalone executable.\n \n+use std::fs::File;\n use std::path::PathBuf;\n+use std::sync::Arc;\n+use std::thread::JoinHandle;\n \n-use rustc_ast::{InlineAsmOptions, InlineAsmTemplatePiece};\n use rustc_codegen_ssa::back::metadata::create_compressed_metadata_file;\n use rustc_codegen_ssa::{CodegenResults, CompiledModule, CrateInfo, ModuleKind};\n+use rustc_data_structures::profiling::SelfProfilerRef;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_metadata::EncodedMetadata;\n use rustc_middle::dep_graph::{WorkProduct, WorkProductId};\n use rustc_middle::mir::mono::{CodegenUnit, MonoItem};\n use rustc_session::cgu_reuse_tracker::CguReuse;\n-use rustc_session::config::{DebugInfo, OutputType};\n+use rustc_session::config::{DebugInfo, OutputFilenames, OutputType};\n use rustc_session::Session;\n \n-use cranelift_codegen::isa::TargetIsa;\n use cranelift_object::{ObjectBuilder, ObjectModule};\n \n+use crate::concurrency_limiter::{ConcurrencyLimiter, ConcurrencyLimiterToken};\n+use crate::global_asm::GlobalAsmConfig;\n use crate::{prelude::*, BackendConfig};\n \n-struct ModuleCodegenResult(CompiledModule, Option<(WorkProductId, WorkProduct)>);\n+struct ModuleCodegenResult {\n+    module_regular: CompiledModule,\n+    module_global_asm: Option<CompiledModule>,\n+    existing_work_product: Option<(WorkProductId, WorkProduct)>,\n+}\n+\n+enum OngoingModuleCodegen {\n+    Sync(Result<ModuleCodegenResult, String>),\n+    Async(JoinHandle<Result<ModuleCodegenResult, String>>),\n+}\n \n-impl<HCX> HashStable<HCX> for ModuleCodegenResult {\n+impl<HCX> HashStable<HCX> for OngoingModuleCodegen {\n     fn hash_stable(&self, _: &mut HCX, _: &mut StableHasher) {\n         // do nothing\n     }\n }\n \n-fn make_module(sess: &Session, isa: Box<dyn TargetIsa>, name: String) -> ObjectModule {\n+pub(crate) struct OngoingCodegen {\n+    modules: Vec<OngoingModuleCodegen>,\n+    allocator_module: Option<CompiledModule>,\n+    metadata_module: Option<CompiledModule>,\n+    metadata: EncodedMetadata,\n+    crate_info: CrateInfo,\n+    concurrency_limiter: ConcurrencyLimiter,\n+}\n+\n+impl OngoingCodegen {\n+    pub(crate) fn join(\n+        self,\n+        sess: &Session,\n+        backend_config: &BackendConfig,\n+    ) -> (CodegenResults, FxHashMap<WorkProductId, WorkProduct>) {\n+        let mut work_products = FxHashMap::default();\n+        let mut modules = vec![];\n+\n+        for module_codegen in self.modules {\n+            let module_codegen_result = match module_codegen {\n+                OngoingModuleCodegen::Sync(module_codegen_result) => module_codegen_result,\n+                OngoingModuleCodegen::Async(join_handle) => match join_handle.join() {\n+                    Ok(module_codegen_result) => module_codegen_result,\n+                    Err(panic) => std::panic::resume_unwind(panic),\n+                },\n+            };\n+\n+            let module_codegen_result = match module_codegen_result {\n+                Ok(module_codegen_result) => module_codegen_result,\n+                Err(err) => sess.fatal(&err),\n+            };\n+            let ModuleCodegenResult { module_regular, module_global_asm, existing_work_product } =\n+                module_codegen_result;\n+\n+            if let Some((work_product_id, work_product)) = existing_work_product {\n+                work_products.insert(work_product_id, work_product);\n+            } else {\n+                let work_product = if backend_config.disable_incr_cache {\n+                    None\n+                } else if let Some(module_global_asm) = &module_global_asm {\n+                    rustc_incremental::copy_cgu_workproduct_to_incr_comp_cache_dir(\n+                        sess,\n+                        &module_regular.name,\n+                        &[\n+                            (\"o\", &module_regular.object.as_ref().unwrap()),\n+                            (\"asm.o\", &module_global_asm.object.as_ref().unwrap()),\n+                        ],\n+                    )\n+                } else {\n+                    rustc_incremental::copy_cgu_workproduct_to_incr_comp_cache_dir(\n+                        sess,\n+                        &module_regular.name,\n+                        &[(\"o\", &module_regular.object.as_ref().unwrap())],\n+                    )\n+                };\n+                if let Some((work_product_id, work_product)) = work_product {\n+                    work_products.insert(work_product_id, work_product);\n+                }\n+            }\n+\n+            modules.push(module_regular);\n+            if let Some(module_global_asm) = module_global_asm {\n+                modules.push(module_global_asm);\n+            }\n+        }\n+\n+        drop(self.concurrency_limiter);\n+\n+        (\n+            CodegenResults {\n+                modules,\n+                allocator_module: self.allocator_module,\n+                metadata_module: self.metadata_module,\n+                metadata: self.metadata,\n+                crate_info: self.crate_info,\n+            },\n+            work_products,\n+        )\n+    }\n+}\n+\n+fn make_module(sess: &Session, backend_config: &BackendConfig, name: String) -> ObjectModule {\n+    let isa = crate::build_isa(sess, backend_config);\n+\n     let mut builder =\n         ObjectBuilder::new(isa, name + \".o\", cranelift_module::default_libcall_names()).unwrap();\n     // Unlike cg_llvm, cg_clif defaults to disabling -Zfunction-sections. For cg_llvm binary size\n@@ -37,15 +133,15 @@ fn make_module(sess: &Session, isa: Box<dyn TargetIsa>, name: String) -> ObjectM\n     ObjectModule::new(builder)\n }\n \n-fn emit_module(\n-    tcx: TyCtxt<'_>,\n-    backend_config: &BackendConfig,\n+fn emit_cgu(\n+    output_filenames: &OutputFilenames,\n+    prof: &SelfProfilerRef,\n     name: String,\n-    kind: ModuleKind,\n     module: ObjectModule,\n-    debug: Option<DebugContext<'_>>,\n+    debug: Option<DebugContext>,\n     unwind_context: UnwindContext,\n-) -> ModuleCodegenResult {\n+    global_asm_object_file: Option<PathBuf>,\n+) -> Result<ModuleCodegenResult, String> {\n     let mut product = module.finish();\n \n     if let Some(mut debug) = debug {\n@@ -54,144 +150,199 @@ fn emit_module(\n \n     unwind_context.emit(&mut product);\n \n-    let tmp_file = tcx.output_filenames(()).temp_path(OutputType::Object, Some(&name));\n-    let obj = product.object.write().unwrap();\n+    let module_regular =\n+        emit_module(output_filenames, prof, product.object, ModuleKind::Regular, name.clone())?;\n+\n+    Ok(ModuleCodegenResult {\n+        module_regular,\n+        module_global_asm: global_asm_object_file.map(|global_asm_object_file| CompiledModule {\n+            name: format!(\"{name}.asm\"),\n+            kind: ModuleKind::Regular,\n+            object: Some(global_asm_object_file),\n+            dwarf_object: None,\n+            bytecode: None,\n+        }),\n+        existing_work_product: None,\n+    })\n+}\n \n-    tcx.sess.prof.artifact_size(\"object_file\", name.clone(), obj.len().try_into().unwrap());\n+fn emit_module(\n+    output_filenames: &OutputFilenames,\n+    prof: &SelfProfilerRef,\n+    object: cranelift_object::object::write::Object<'_>,\n+    kind: ModuleKind,\n+    name: String,\n+) -> Result<CompiledModule, String> {\n+    let tmp_file = output_filenames.temp_path(OutputType::Object, Some(&name));\n+    let mut file = match File::create(&tmp_file) {\n+        Ok(file) => file,\n+        Err(err) => return Err(format!(\"error creating object file: {}\", err)),\n+    };\n \n-    if let Err(err) = std::fs::write(&tmp_file, obj) {\n-        tcx.sess.fatal(&format!(\"error writing object file: {}\", err));\n+    if let Err(err) = object.write_stream(&mut file) {\n+        return Err(format!(\"error writing object file: {}\", err));\n     }\n \n-    let work_product = if backend_config.disable_incr_cache {\n-        None\n-    } else {\n-        rustc_incremental::copy_cgu_workproduct_to_incr_comp_cache_dir(\n-            tcx.sess,\n-            &name,\n-            &[(\"o\", &tmp_file)],\n-        )\n-    };\n+    prof.artifact_size(\"object_file\", &*name, file.metadata().unwrap().len());\n \n-    ModuleCodegenResult(\n-        CompiledModule { name, kind, object: Some(tmp_file), dwarf_object: None, bytecode: None },\n-        work_product,\n-    )\n+    Ok(CompiledModule { name, kind, object: Some(tmp_file), dwarf_object: None, bytecode: None })\n }\n \n fn reuse_workproduct_for_cgu(\n     tcx: TyCtxt<'_>,\n     cgu: &CodegenUnit<'_>,\n-    work_products: &mut FxHashMap<WorkProductId, WorkProduct>,\n-) -> CompiledModule {\n+) -> Result<ModuleCodegenResult, String> {\n     let work_product = cgu.previous_work_product(tcx);\n-    let obj_out = tcx.output_filenames(()).temp_path(OutputType::Object, Some(cgu.name().as_str()));\n-    let source_file = rustc_incremental::in_incr_comp_dir_sess(\n+    let obj_out_regular =\n+        tcx.output_filenames(()).temp_path(OutputType::Object, Some(cgu.name().as_str()));\n+    let source_file_regular = rustc_incremental::in_incr_comp_dir_sess(\n         &tcx.sess,\n         &work_product.saved_files.get(\"o\").expect(\"no saved object file in work product\"),\n     );\n-    if let Err(err) = rustc_fs_util::link_or_copy(&source_file, &obj_out) {\n-        tcx.sess.err(&format!(\n+\n+    if let Err(err) = rustc_fs_util::link_or_copy(&source_file_regular, &obj_out_regular) {\n+        return Err(format!(\n             \"unable to copy {} to {}: {}\",\n-            source_file.display(),\n-            obj_out.display(),\n+            source_file_regular.display(),\n+            obj_out_regular.display(),\n             err\n         ));\n     }\n+    let obj_out_global_asm =\n+        crate::global_asm::add_file_stem_postfix(obj_out_regular.clone(), \".asm\");\n+    let has_global_asm = if let Some(asm_o) = work_product.saved_files.get(\"asm.o\") {\n+        let source_file_global_asm = rustc_incremental::in_incr_comp_dir_sess(&tcx.sess, asm_o);\n+        if let Err(err) = rustc_fs_util::link_or_copy(&source_file_global_asm, &obj_out_global_asm)\n+        {\n+            return Err(format!(\n+                \"unable to copy {} to {}: {}\",\n+                source_file_regular.display(),\n+                obj_out_regular.display(),\n+                err\n+            ));\n+        }\n+        true\n+    } else {\n+        false\n+    };\n \n-    work_products.insert(cgu.work_product_id(), work_product);\n-\n-    CompiledModule {\n-        name: cgu.name().to_string(),\n-        kind: ModuleKind::Regular,\n-        object: Some(obj_out),\n-        dwarf_object: None,\n-        bytecode: None,\n-    }\n+    Ok(ModuleCodegenResult {\n+        module_regular: CompiledModule {\n+            name: cgu.name().to_string(),\n+            kind: ModuleKind::Regular,\n+            object: Some(obj_out_regular),\n+            dwarf_object: None,\n+            bytecode: None,\n+        },\n+        module_global_asm: if has_global_asm {\n+            Some(CompiledModule {\n+                name: cgu.name().to_string(),\n+                kind: ModuleKind::Regular,\n+                object: Some(obj_out_global_asm),\n+                dwarf_object: None,\n+                bytecode: None,\n+            })\n+        } else {\n+            None\n+        },\n+        existing_work_product: Some((cgu.work_product_id(), work_product)),\n+    })\n }\n \n fn module_codegen(\n     tcx: TyCtxt<'_>,\n-    (backend_config, cgu_name): (BackendConfig, rustc_span::Symbol),\n-) -> ModuleCodegenResult {\n-    let cgu = tcx.codegen_unit(cgu_name);\n-    let mono_items = cgu.items_in_deterministic_order(tcx);\n-\n-    let isa = crate::build_isa(tcx.sess, &backend_config);\n-    let mut module = make_module(tcx.sess, isa, cgu_name.as_str().to_string());\n-\n-    let mut cx = crate::CodegenCx::new(\n-        tcx,\n-        backend_config.clone(),\n-        module.isa(),\n-        tcx.sess.opts.debuginfo != DebugInfo::None,\n-        cgu_name,\n-    );\n-    super::predefine_mono_items(tcx, &mut module, &mono_items);\n-    for (mono_item, _) in mono_items {\n-        match mono_item {\n-            MonoItem::Fn(inst) => {\n-                cx.tcx\n-                    .sess\n-                    .time(\"codegen fn\", || crate::base::codegen_fn(&mut cx, &mut module, inst));\n-            }\n-            MonoItem::Static(def_id) => crate::constant::codegen_static(tcx, &mut module, def_id),\n-            MonoItem::GlobalAsm(item_id) => {\n-                let item = cx.tcx.hir().item(item_id);\n-                if let rustc_hir::ItemKind::GlobalAsm(asm) = item.kind {\n-                    if !asm.options.contains(InlineAsmOptions::ATT_SYNTAX) {\n-                        cx.global_asm.push_str(\"\\n.intel_syntax noprefix\\n\");\n-                    } else {\n-                        cx.global_asm.push_str(\"\\n.att_syntax\\n\");\n-                    }\n-                    for piece in asm.template {\n-                        match *piece {\n-                            InlineAsmTemplatePiece::String(ref s) => cx.global_asm.push_str(s),\n-                            InlineAsmTemplatePiece::Placeholder { .. } => todo!(),\n-                        }\n-                    }\n-                    cx.global_asm.push_str(\"\\n.att_syntax\\n\\n\");\n-                } else {\n-                    bug!(\"Expected GlobalAsm found {:?}\", item);\n+    (backend_config, global_asm_config, cgu_name, token): (\n+        BackendConfig,\n+        Arc<GlobalAsmConfig>,\n+        rustc_span::Symbol,\n+        ConcurrencyLimiterToken,\n+    ),\n+) -> OngoingModuleCodegen {\n+    let (cgu_name, mut cx, mut module, codegened_functions) = tcx.sess.time(\"codegen cgu\", || {\n+        let cgu = tcx.codegen_unit(cgu_name);\n+        let mono_items = cgu.items_in_deterministic_order(tcx);\n+\n+        let mut module = make_module(tcx.sess, &backend_config, cgu_name.as_str().to_string());\n+\n+        let mut cx = crate::CodegenCx::new(\n+            tcx,\n+            backend_config.clone(),\n+            module.isa(),\n+            tcx.sess.opts.debuginfo != DebugInfo::None,\n+            cgu_name,\n+        );\n+        super::predefine_mono_items(tcx, &mut module, &mono_items);\n+        let mut codegened_functions = vec![];\n+        for (mono_item, _) in mono_items {\n+            match mono_item {\n+                MonoItem::Fn(inst) => {\n+                    tcx.sess.time(\"codegen fn\", || {\n+                        let codegened_function = crate::base::codegen_fn(\n+                            tcx,\n+                            &mut cx,\n+                            Function::new(),\n+                            &mut module,\n+                            inst,\n+                        );\n+                        codegened_functions.push(codegened_function);\n+                    });\n+                }\n+                MonoItem::Static(def_id) => {\n+                    crate::constant::codegen_static(tcx, &mut module, def_id)\n+                }\n+                MonoItem::GlobalAsm(item_id) => {\n+                    crate::global_asm::codegen_global_asm_item(tcx, &mut cx.global_asm, item_id);\n                 }\n             }\n         }\n-    }\n-    crate::main_shim::maybe_create_entry_wrapper(\n-        tcx,\n-        &mut module,\n-        &mut cx.unwind_context,\n-        false,\n-        cgu.is_primary(),\n-    );\n-\n-    let debug_context = cx.debug_context;\n-    let unwind_context = cx.unwind_context;\n-    let codegen_result = tcx.sess.time(\"write object file\", || {\n-        emit_module(\n+        crate::main_shim::maybe_create_entry_wrapper(\n             tcx,\n-            &backend_config,\n-            cgu.name().as_str().to_string(),\n-            ModuleKind::Regular,\n-            module,\n-            debug_context,\n-            unwind_context,\n-        )\n+            &mut module,\n+            &mut cx.unwind_context,\n+            false,\n+            cgu.is_primary(),\n+        );\n+\n+        let cgu_name = cgu.name().as_str().to_owned();\n+\n+        (cgu_name, cx, module, codegened_functions)\n     });\n \n-    codegen_global_asm(tcx, cgu.name().as_str(), &cx.global_asm);\n+    OngoingModuleCodegen::Async(std::thread::spawn(move || {\n+        cx.profiler.clone().verbose_generic_activity(\"compile functions\").run(|| {\n+            let mut cached_context = Context::new();\n+            for codegened_func in codegened_functions {\n+                crate::base::compile_fn(&mut cx, &mut cached_context, &mut module, codegened_func);\n+            }\n+        });\n \n-    codegen_result\n+        let global_asm_object_file =\n+            cx.profiler.verbose_generic_activity(\"compile assembly\").run(|| {\n+                crate::global_asm::compile_global_asm(&global_asm_config, &cgu_name, &cx.global_asm)\n+            })?;\n+\n+        let codegen_result = cx.profiler.verbose_generic_activity(\"write object file\").run(|| {\n+            emit_cgu(\n+                &global_asm_config.output_filenames,\n+                &cx.profiler,\n+                cgu_name,\n+                module,\n+                cx.debug_context,\n+                cx.unwind_context,\n+                global_asm_object_file,\n+            )\n+        });\n+        std::mem::drop(token);\n+        codegen_result\n+    }))\n }\n \n pub(crate) fn run_aot(\n     tcx: TyCtxt<'_>,\n     backend_config: BackendConfig,\n     metadata: EncodedMetadata,\n     need_metadata_module: bool,\n-) -> Box<(CodegenResults, FxHashMap<WorkProductId, WorkProduct>)> {\n-    let mut work_products = FxHashMap::default();\n-\n+) -> Box<OngoingCodegen> {\n     let cgus = if tcx.sess.opts.output_types.should_codegen() {\n         tcx.collect_and_partition_mono_items(()).1\n     } else {\n@@ -206,62 +357,69 @@ pub(crate) fn run_aot(\n         }\n     }\n \n+    let global_asm_config = Arc::new(crate::global_asm::GlobalAsmConfig::new(tcx));\n+\n+    let mut concurrency_limiter = ConcurrencyLimiter::new(tcx.sess, cgus.len());\n+\n     let modules = super::time(tcx, backend_config.display_cg_time, \"codegen mono items\", || {\n         cgus.iter()\n             .map(|cgu| {\n-                let cgu_reuse = determine_cgu_reuse(tcx, cgu);\n+                let cgu_reuse = if backend_config.disable_incr_cache {\n+                    CguReuse::No\n+                } else {\n+                    determine_cgu_reuse(tcx, cgu)\n+                };\n                 tcx.sess.cgu_reuse_tracker.set_actual_reuse(cgu.name().as_str(), cgu_reuse);\n \n                 match cgu_reuse {\n-                    _ if backend_config.disable_incr_cache => {}\n-                    CguReuse::No => {}\n-                    CguReuse::PreLto => {\n-                        return reuse_workproduct_for_cgu(tcx, &*cgu, &mut work_products);\n+                    CguReuse::No => {\n+                        let dep_node = cgu.codegen_dep_node(tcx);\n+                        tcx.dep_graph\n+                            .with_task(\n+                                dep_node,\n+                                tcx,\n+                                (\n+                                    backend_config.clone(),\n+                                    global_asm_config.clone(),\n+                                    cgu.name(),\n+                                    concurrency_limiter.acquire(),\n+                                ),\n+                                module_codegen,\n+                                Some(rustc_middle::dep_graph::hash_result),\n+                            )\n+                            .0\n+                    }\n+                    CguReuse::PreLto => unreachable!(),\n+                    CguReuse::PostLto => {\n+                        concurrency_limiter.job_already_done();\n+                        OngoingModuleCodegen::Sync(reuse_workproduct_for_cgu(tcx, &*cgu))\n                     }\n-                    CguReuse::PostLto => unreachable!(),\n-                }\n-\n-                let dep_node = cgu.codegen_dep_node(tcx);\n-                let (ModuleCodegenResult(module, work_product), _) = tcx.dep_graph.with_task(\n-                    dep_node,\n-                    tcx,\n-                    (backend_config.clone(), cgu.name()),\n-                    module_codegen,\n-                    Some(rustc_middle::dep_graph::hash_result),\n-                );\n-\n-                if let Some((id, product)) = work_product {\n-                    work_products.insert(id, product);\n                 }\n-\n-                module\n             })\n             .collect::<Vec<_>>()\n     });\n \n     tcx.sess.abort_if_errors();\n \n-    let isa = crate::build_isa(tcx.sess, &backend_config);\n-    let mut allocator_module = make_module(tcx.sess, isa, \"allocator_shim\".to_string());\n-    assert_eq!(pointer_ty(tcx), allocator_module.target_config().pointer_type());\n+    let mut allocator_module = make_module(tcx.sess, &backend_config, \"allocator_shim\".to_string());\n     let mut allocator_unwind_context = UnwindContext::new(allocator_module.isa(), true);\n     let created_alloc_shim =\n         crate::allocator::codegen(tcx, &mut allocator_module, &mut allocator_unwind_context);\n \n     let allocator_module = if created_alloc_shim {\n-        let ModuleCodegenResult(module, work_product) = emit_module(\n-            tcx,\n-            &backend_config,\n-            \"allocator_shim\".to_string(),\n+        let mut product = allocator_module.finish();\n+        allocator_unwind_context.emit(&mut product);\n+\n+        match emit_module(\n+            tcx.output_filenames(()),\n+            &tcx.sess.prof,\n+            product.object,\n             ModuleKind::Allocator,\n-            allocator_module,\n-            None,\n-            allocator_unwind_context,\n-        );\n-        if let Some((id, product)) = work_product {\n-            work_products.insert(id, product);\n+            \"allocator_shim\".to_owned(),\n+        ) {\n+            Ok(allocator_module) => Some(allocator_module),\n+            Err(err) => tcx.sess.fatal(err),\n         }\n-        Some(module)\n     } else {\n         None\n     };\n@@ -308,102 +466,14 @@ pub(crate) fn run_aot(\n     }\n     .to_owned();\n \n-    Box::new((\n-        CodegenResults {\n-            modules,\n-            allocator_module,\n-            metadata_module,\n-            metadata,\n-            crate_info: CrateInfo::new(tcx, target_cpu),\n-        },\n-        work_products,\n-    ))\n-}\n-\n-fn codegen_global_asm(tcx: TyCtxt<'_>, cgu_name: &str, global_asm: &str) {\n-    use std::io::Write;\n-    use std::process::{Command, Stdio};\n-\n-    if global_asm.is_empty() {\n-        return;\n-    }\n-\n-    if cfg!(not(feature = \"inline_asm\"))\n-        || tcx.sess.target.is_like_osx\n-        || tcx.sess.target.is_like_windows\n-    {\n-        if global_asm.contains(\"__rust_probestack\") {\n-            return;\n-        }\n-\n-        // FIXME fix linker error on macOS\n-        if cfg!(not(feature = \"inline_asm\")) {\n-            tcx.sess.fatal(\n-                \"asm! and global_asm! support is disabled while compiling rustc_codegen_cranelift\",\n-            );\n-        } else {\n-            tcx.sess.fatal(\"asm! and global_asm! are not yet supported on macOS and Windows\");\n-        }\n-    }\n-\n-    let assembler = crate::toolchain::get_toolchain_binary(tcx.sess, \"as\");\n-    let linker = crate::toolchain::get_toolchain_binary(tcx.sess, \"ld\");\n-\n-    // Remove all LLVM style comments\n-    let global_asm = global_asm\n-        .lines()\n-        .map(|line| if let Some(index) = line.find(\"//\") { &line[0..index] } else { line })\n-        .collect::<Vec<_>>()\n-        .join(\"\\n\");\n-\n-    let output_object_file = tcx.output_filenames(()).temp_path(OutputType::Object, Some(cgu_name));\n-\n-    // Assemble `global_asm`\n-    let global_asm_object_file = add_file_stem_postfix(output_object_file.clone(), \".asm\");\n-    let mut child = Command::new(assembler)\n-        .arg(\"-o\")\n-        .arg(&global_asm_object_file)\n-        .stdin(Stdio::piped())\n-        .spawn()\n-        .expect(\"Failed to spawn `as`.\");\n-    child.stdin.take().unwrap().write_all(global_asm.as_bytes()).unwrap();\n-    let status = child.wait().expect(\"Failed to wait for `as`.\");\n-    if !status.success() {\n-        tcx.sess.fatal(&format!(\"Failed to assemble `{}`\", global_asm));\n-    }\n-\n-    // Link the global asm and main object file together\n-    let main_object_file = add_file_stem_postfix(output_object_file.clone(), \".main\");\n-    std::fs::rename(&output_object_file, &main_object_file).unwrap();\n-    let status = Command::new(linker)\n-        .arg(\"-r\") // Create a new object file\n-        .arg(\"-o\")\n-        .arg(output_object_file)\n-        .arg(&main_object_file)\n-        .arg(&global_asm_object_file)\n-        .status()\n-        .unwrap();\n-    if !status.success() {\n-        tcx.sess.fatal(&format!(\n-            \"Failed to link `{}` and `{}` together\",\n-            main_object_file.display(),\n-            global_asm_object_file.display(),\n-        ));\n-    }\n-\n-    std::fs::remove_file(global_asm_object_file).unwrap();\n-    std::fs::remove_file(main_object_file).unwrap();\n-}\n-\n-fn add_file_stem_postfix(mut path: PathBuf, postfix: &str) -> PathBuf {\n-    let mut new_filename = path.file_stem().unwrap().to_owned();\n-    new_filename.push(postfix);\n-    if let Some(extension) = path.extension() {\n-        new_filename.push(\".\");\n-        new_filename.push(extension);\n-    }\n-    path.set_file_name(new_filename);\n-    path\n+    Box::new(OngoingCodegen {\n+        modules,\n+        allocator_module,\n+        metadata_module,\n+        metadata,\n+        crate_info: CrateInfo::new(tcx, target_cpu),\n+        concurrency_limiter,\n+    })\n }\n \n // Adapted from https://github.com/rust-lang/rust/blob/303d8aff6092709edd4dbd35b1c88e9aa40bf6d8/src/librustc_codegen_ssa/base.rs#L922-L953\n@@ -432,5 +502,5 @@ fn determine_cgu_reuse<'tcx>(tcx: TyCtxt<'tcx>, cgu: &CodegenUnit<'tcx>) -> CguR\n         cgu.name()\n     );\n \n-    if tcx.try_mark_green(&dep_node) { CguReuse::PreLto } else { CguReuse::No }\n+    if tcx.try_mark_green(&dep_node) { CguReuse::PostLto } else { CguReuse::No }\n }"}, {"sha": "0e77e4004c0bb5d0ef4c814c9003fa114c1b51d1", "filename": "compiler/rustc_codegen_cranelift/src/driver/jit.rs", "status": "modified", "additions": 36, "deletions": 13, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/f2878a656b944ceed6f4a98d7e255784266a3dc0/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Fjit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2878a656b944ceed6f4a98d7e255784266a3dc0/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Fjit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Fjit.rs?ref=f2878a656b944ceed6f4a98d7e255784266a3dc0", "patch": "@@ -61,11 +61,11 @@ impl UnsafeMessage {\n     }\n }\n \n-fn create_jit_module<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n+fn create_jit_module(\n+    tcx: TyCtxt<'_>,\n     backend_config: &BackendConfig,\n     hotswap: bool,\n-) -> (JITModule, CodegenCx<'tcx>) {\n+) -> (JITModule, CodegenCx) {\n     let crate_info = CrateInfo::new(tcx, \"dummy_target_cpu\".to_string());\n     let imported_symbols = load_imported_symbols_for_jit(tcx.sess, crate_info);\n \n@@ -111,6 +111,7 @@ pub(crate) fn run_jit(tcx: TyCtxt<'_>, backend_config: BackendConfig) -> ! {\n         &backend_config,\n         matches!(backend_config.codegen_mode, CodegenMode::JitLazy),\n     );\n+    let mut cached_context = Context::new();\n \n     let (_, cgus) = tcx.collect_and_partition_mono_items(());\n     let mono_items = cgus\n@@ -128,11 +129,19 @@ pub(crate) fn run_jit(tcx: TyCtxt<'_>, backend_config: BackendConfig) -> ! {\n                 MonoItem::Fn(inst) => match backend_config.codegen_mode {\n                     CodegenMode::Aot => unreachable!(),\n                     CodegenMode::Jit => {\n-                        cx.tcx.sess.time(\"codegen fn\", || {\n-                            crate::base::codegen_fn(&mut cx, &mut jit_module, inst)\n+                        tcx.sess.time(\"codegen fn\", || {\n+                            crate::base::codegen_and_compile_fn(\n+                                tcx,\n+                                &mut cx,\n+                                &mut cached_context,\n+                                &mut jit_module,\n+                                inst,\n+                            )\n                         });\n                     }\n-                    CodegenMode::JitLazy => codegen_shim(&mut cx, &mut jit_module, inst),\n+                    CodegenMode::JitLazy => {\n+                        codegen_shim(tcx, &mut cx, &mut cached_context, &mut jit_module, inst)\n+                    }\n                 },\n                 MonoItem::Static(def_id) => {\n                     crate::constant::codegen_static(tcx, &mut jit_module, def_id);\n@@ -259,7 +268,15 @@ fn jit_fn(instance_ptr: *const Instance<'static>, trampoline_ptr: *const u8) ->\n                 false,\n                 Symbol::intern(\"dummy_cgu_name\"),\n             );\n-            tcx.sess.time(\"codegen fn\", || crate::base::codegen_fn(&mut cx, jit_module, instance));\n+            tcx.sess.time(\"codegen fn\", || {\n+                crate::base::codegen_and_compile_fn(\n+                    tcx,\n+                    &mut cx,\n+                    &mut Context::new(),\n+                    jit_module,\n+                    instance,\n+                )\n+            });\n \n             assert!(cx.global_asm.is_empty());\n             jit_module.finalize_definitions();\n@@ -334,9 +351,13 @@ fn load_imported_symbols_for_jit(\n     imported_symbols\n }\n \n-fn codegen_shim<'tcx>(cx: &mut CodegenCx<'tcx>, module: &mut JITModule, inst: Instance<'tcx>) {\n-    let tcx = cx.tcx;\n-\n+fn codegen_shim<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    cx: &mut CodegenCx,\n+    cached_context: &mut Context,\n+    module: &mut JITModule,\n+    inst: Instance<'tcx>,\n+) {\n     let pointer_type = module.target_config().pointer_type();\n \n     let name = tcx.symbol_name(inst).name;\n@@ -357,8 +378,9 @@ fn codegen_shim<'tcx>(cx: &mut CodegenCx<'tcx>, module: &mut JITModule, inst: In\n         )\n         .unwrap();\n \n-    cx.cached_context.clear();\n-    let trampoline = &mut cx.cached_context.func;\n+    let context = cached_context;\n+    context.clear();\n+    let trampoline = &mut context.func;\n     trampoline.signature = sig.clone();\n \n     let mut builder_ctx = FunctionBuilderContext::new();\n@@ -381,5 +403,6 @@ fn codegen_shim<'tcx>(cx: &mut CodegenCx<'tcx>, module: &mut JITModule, inst: In\n     let ret_vals = trampoline_builder.func.dfg.inst_results(call_inst).to_vec();\n     trampoline_builder.ins().return_(&ret_vals);\n \n-    module.define_function(func_id, &mut cx.cached_context).unwrap();\n+    module.define_function(func_id, context).unwrap();\n+    cx.unwind_context.add_function(func_id, context, module.isa());\n }"}, {"sha": "dcbcaba30feeda219cea9d7042dd73e40167fe82", "filename": "compiler/rustc_codegen_cranelift/src/global_asm.rs", "status": "added", "additions": 114, "deletions": 0, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/f2878a656b944ceed6f4a98d7e255784266a3dc0/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fglobal_asm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2878a656b944ceed6f4a98d7e255784266a3dc0/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fglobal_asm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fglobal_asm.rs?ref=f2878a656b944ceed6f4a98d7e255784266a3dc0", "patch": "@@ -0,0 +1,114 @@\n+//! The AOT driver uses [`cranelift_object`] to write object files suitable for linking into a\n+//! standalone executable.\n+\n+use std::io::Write;\n+use std::path::PathBuf;\n+use std::process::{Command, Stdio};\n+use std::sync::Arc;\n+\n+use rustc_ast::{InlineAsmOptions, InlineAsmTemplatePiece};\n+use rustc_hir::ItemId;\n+use rustc_session::config::{OutputFilenames, OutputType};\n+\n+use crate::prelude::*;\n+\n+pub(crate) fn codegen_global_asm_item(tcx: TyCtxt<'_>, global_asm: &mut String, item_id: ItemId) {\n+    let item = tcx.hir().item(item_id);\n+    if let rustc_hir::ItemKind::GlobalAsm(asm) = item.kind {\n+        if !asm.options.contains(InlineAsmOptions::ATT_SYNTAX) {\n+            global_asm.push_str(\"\\n.intel_syntax noprefix\\n\");\n+        } else {\n+            global_asm.push_str(\"\\n.att_syntax\\n\");\n+        }\n+        for piece in asm.template {\n+            match *piece {\n+                InlineAsmTemplatePiece::String(ref s) => global_asm.push_str(s),\n+                InlineAsmTemplatePiece::Placeholder { .. } => todo!(),\n+            }\n+        }\n+        global_asm.push_str(\"\\n.att_syntax\\n\\n\");\n+    } else {\n+        bug!(\"Expected GlobalAsm found {:?}\", item);\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub(crate) struct GlobalAsmConfig {\n+    asm_enabled: bool,\n+    assembler: PathBuf,\n+    pub(crate) output_filenames: Arc<OutputFilenames>,\n+}\n+\n+impl GlobalAsmConfig {\n+    pub(crate) fn new(tcx: TyCtxt<'_>) -> Self {\n+        let asm_enabled = cfg!(feature = \"inline_asm\") && !tcx.sess.target.is_like_windows;\n+\n+        GlobalAsmConfig {\n+            asm_enabled,\n+            assembler: crate::toolchain::get_toolchain_binary(tcx.sess, \"as\"),\n+            output_filenames: tcx.output_filenames(()).clone(),\n+        }\n+    }\n+}\n+\n+pub(crate) fn compile_global_asm(\n+    config: &GlobalAsmConfig,\n+    cgu_name: &str,\n+    global_asm: &str,\n+) -> Result<Option<PathBuf>, String> {\n+    if global_asm.is_empty() {\n+        return Ok(None);\n+    }\n+\n+    if !config.asm_enabled {\n+        if global_asm.contains(\"__rust_probestack\") {\n+            return Ok(None);\n+        }\n+\n+        // FIXME fix linker error on macOS\n+        if cfg!(not(feature = \"inline_asm\")) {\n+            return Err(\n+                \"asm! and global_asm! support is disabled while compiling rustc_codegen_cranelift\"\n+                    .to_owned(),\n+            );\n+        } else {\n+            return Err(\"asm! and global_asm! are not yet supported on Windows\".to_owned());\n+        }\n+    }\n+\n+    // Remove all LLVM style comments\n+    let global_asm = global_asm\n+        .lines()\n+        .map(|line| if let Some(index) = line.find(\"//\") { &line[0..index] } else { line })\n+        .collect::<Vec<_>>()\n+        .join(\"\\n\");\n+\n+    let output_object_file = config.output_filenames.temp_path(OutputType::Object, Some(cgu_name));\n+\n+    // Assemble `global_asm`\n+    let global_asm_object_file = add_file_stem_postfix(output_object_file.clone(), \".asm\");\n+    let mut child = Command::new(&config.assembler)\n+        .arg(\"-o\")\n+        .arg(&global_asm_object_file)\n+        .stdin(Stdio::piped())\n+        .spawn()\n+        .expect(\"Failed to spawn `as`.\");\n+    child.stdin.take().unwrap().write_all(global_asm.as_bytes()).unwrap();\n+    let status = child.wait().expect(\"Failed to wait for `as`.\");\n+    if !status.success() {\n+        return Err(format!(\"Failed to assemble `{}`\", global_asm));\n+    }\n+\n+    Ok(Some(global_asm_object_file))\n+}\n+\n+pub(crate) fn add_file_stem_postfix(mut path: PathBuf, postfix: &str) -> PathBuf {\n+    let mut new_filename = path.file_stem().unwrap().to_owned();\n+    new_filename.push(postfix);\n+    if let Some(extension) = path.extension() {\n+        new_filename.push(\".\");\n+        new_filename.push(extension);\n+    }\n+    path.set_file_name(new_filename);\n+    path\n+}"}, {"sha": "8b3d475cb1802dcc1662145ca0cc4a1c99a8119c", "filename": "compiler/rustc_codegen_cranelift/src/inline_asm.rs", "status": "modified", "additions": 136, "deletions": 40, "changes": 176, "blob_url": "https://github.com/rust-lang/rust/blob/f2878a656b944ceed6f4a98d7e255784266a3dc0/compiler%2Frustc_codegen_cranelift%2Fsrc%2Finline_asm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2878a656b944ceed6f4a98d7e255784266a3dc0/compiler%2Frustc_codegen_cranelift%2Fsrc%2Finline_asm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Finline_asm.rs?ref=f2878a656b944ceed6f4a98d7e255784266a3dc0", "patch": "@@ -15,15 +15,19 @@ pub(crate) fn codegen_inline_asm<'tcx>(\n     template: &[InlineAsmTemplatePiece],\n     operands: &[InlineAsmOperand<'tcx>],\n     options: InlineAsmOptions,\n+    destination: Option<mir::BasicBlock>,\n ) {\n     // FIXME add .eh_frame unwind info directives\n \n     if !template.is_empty() {\n+        // Used by panic_abort\n         if template[0] == InlineAsmTemplatePiece::String(\"int $$0x29\".to_string()) {\n-            let true_ = fx.bcx.ins().iconst(types::I32, 1);\n-            fx.bcx.ins().trapnz(true_, TrapCode::User(1));\n+            fx.bcx.ins().trap(TrapCode::User(1));\n             return;\n-        } else if template[0] == InlineAsmTemplatePiece::String(\"movq %rbx, \".to_string())\n+        }\n+\n+        // Used by stdarch\n+        if template[0] == InlineAsmTemplatePiece::String(\"movq %rbx, \".to_string())\n             && matches!(\n                 template[1],\n                 InlineAsmTemplatePiece::Placeholder {\n@@ -47,51 +51,46 @@ pub(crate) fn codegen_inline_asm<'tcx>(\n         {\n             assert_eq!(operands.len(), 4);\n             let (leaf, eax_place) = match operands[1] {\n-                InlineAsmOperand::InOut { reg, late: true, ref in_value, out_place } => {\n-                    assert_eq!(\n-                        reg,\n-                        InlineAsmRegOrRegClass::Reg(InlineAsmReg::X86(X86InlineAsmReg::ax))\n-                    );\n-                    (\n-                        crate::base::codegen_operand(fx, in_value).load_scalar(fx),\n-                        crate::base::codegen_place(fx, out_place.unwrap()),\n-                    )\n-                }\n+                InlineAsmOperand::InOut {\n+                    reg: InlineAsmRegOrRegClass::Reg(InlineAsmReg::X86(X86InlineAsmReg::ax)),\n+                    late: true,\n+                    ref in_value,\n+                    out_place: Some(out_place),\n+                } => (\n+                    crate::base::codegen_operand(fx, in_value).load_scalar(fx),\n+                    crate::base::codegen_place(fx, out_place),\n+                ),\n                 _ => unreachable!(),\n             };\n             let ebx_place = match operands[0] {\n-                InlineAsmOperand::Out { reg, late: true, place } => {\n-                    assert_eq!(\n-                        reg,\n+                InlineAsmOperand::Out {\n+                    reg:\n                         InlineAsmRegOrRegClass::RegClass(InlineAsmRegClass::X86(\n-                            X86InlineAsmRegClass::reg\n-                        ))\n-                    );\n-                    crate::base::codegen_place(fx, place.unwrap())\n-                }\n+                            X86InlineAsmRegClass::reg,\n+                        )),\n+                    late: true,\n+                    place: Some(place),\n+                } => crate::base::codegen_place(fx, place),\n                 _ => unreachable!(),\n             };\n             let (sub_leaf, ecx_place) = match operands[2] {\n-                InlineAsmOperand::InOut { reg, late: true, ref in_value, out_place } => {\n-                    assert_eq!(\n-                        reg,\n-                        InlineAsmRegOrRegClass::Reg(InlineAsmReg::X86(X86InlineAsmReg::cx))\n-                    );\n-                    (\n-                        crate::base::codegen_operand(fx, in_value).load_scalar(fx),\n-                        crate::base::codegen_place(fx, out_place.unwrap()),\n-                    )\n-                }\n+                InlineAsmOperand::InOut {\n+                    reg: InlineAsmRegOrRegClass::Reg(InlineAsmReg::X86(X86InlineAsmReg::cx)),\n+                    late: true,\n+                    ref in_value,\n+                    out_place: Some(out_place),\n+                } => (\n+                    crate::base::codegen_operand(fx, in_value).load_scalar(fx),\n+                    crate::base::codegen_place(fx, out_place),\n+                ),\n                 _ => unreachable!(),\n             };\n             let edx_place = match operands[3] {\n-                InlineAsmOperand::Out { reg, late: true, place } => {\n-                    assert_eq!(\n-                        reg,\n-                        InlineAsmRegOrRegClass::Reg(InlineAsmReg::X86(X86InlineAsmReg::dx))\n-                    );\n-                    crate::base::codegen_place(fx, place.unwrap())\n-                }\n+                InlineAsmOperand::Out {\n+                    reg: InlineAsmRegOrRegClass::Reg(InlineAsmReg::X86(X86InlineAsmReg::dx)),\n+                    late: true,\n+                    place: Some(place),\n+                } => crate::base::codegen_place(fx, place),\n                 _ => unreachable!(),\n             };\n \n@@ -101,12 +100,99 @@ pub(crate) fn codegen_inline_asm<'tcx>(\n             ebx_place.write_cvalue(fx, CValue::by_val(ebx, fx.layout_of(fx.tcx.types.u32)));\n             ecx_place.write_cvalue(fx, CValue::by_val(ecx, fx.layout_of(fx.tcx.types.u32)));\n             edx_place.write_cvalue(fx, CValue::by_val(edx, fx.layout_of(fx.tcx.types.u32)));\n+            let destination_block = fx.get_block(destination.unwrap());\n+            fx.bcx.ins().jump(destination_block, &[]);\n             return;\n-        } else if fx.tcx.symbol_name(fx.instance).name.starts_with(\"___chkstk\") {\n+        }\n+\n+        // Used by compiler-builtins\n+        if fx.tcx.symbol_name(fx.instance).name.starts_with(\"___chkstk\") {\n             // ___chkstk, ___chkstk_ms and __alloca are only used on Windows\n             crate::trap::trap_unimplemented(fx, \"Stack probes are not supported\");\n+            return;\n         } else if fx.tcx.symbol_name(fx.instance).name == \"__alloca\" {\n             crate::trap::trap_unimplemented(fx, \"Alloca is not supported\");\n+            return;\n+        }\n+\n+        // Used by measureme\n+        if template[0] == InlineAsmTemplatePiece::String(\"xor %eax, %eax\".to_string())\n+            && template[1] == InlineAsmTemplatePiece::String(\"\\n\".to_string())\n+            && template[2] == InlineAsmTemplatePiece::String(\"mov %rbx, \".to_string())\n+            && matches!(\n+                template[3],\n+                InlineAsmTemplatePiece::Placeholder {\n+                    operand_idx: 0,\n+                    modifier: Some('r'),\n+                    span: _\n+                }\n+            )\n+            && template[4] == InlineAsmTemplatePiece::String(\"\\n\".to_string())\n+            && template[5] == InlineAsmTemplatePiece::String(\"cpuid\".to_string())\n+            && template[6] == InlineAsmTemplatePiece::String(\"\\n\".to_string())\n+            && template[7] == InlineAsmTemplatePiece::String(\"mov \".to_string())\n+            && matches!(\n+                template[8],\n+                InlineAsmTemplatePiece::Placeholder {\n+                    operand_idx: 0,\n+                    modifier: Some('r'),\n+                    span: _\n+                }\n+            )\n+            && template[9] == InlineAsmTemplatePiece::String(\", %rbx\".to_string())\n+        {\n+            let destination_block = fx.get_block(destination.unwrap());\n+            fx.bcx.ins().jump(destination_block, &[]);\n+            return;\n+        } else if template[0] == InlineAsmTemplatePiece::String(\"rdpmc\".to_string()) {\n+            // Return zero dummy values for all performance counters\n+            match operands[0] {\n+                InlineAsmOperand::In {\n+                    reg: InlineAsmRegOrRegClass::Reg(InlineAsmReg::X86(X86InlineAsmReg::cx)),\n+                    value: _,\n+                } => {}\n+                _ => unreachable!(),\n+            };\n+            let lo = match operands[1] {\n+                InlineAsmOperand::Out {\n+                    reg: InlineAsmRegOrRegClass::Reg(InlineAsmReg::X86(X86InlineAsmReg::ax)),\n+                    late: true,\n+                    place: Some(place),\n+                } => crate::base::codegen_place(fx, place),\n+                _ => unreachable!(),\n+            };\n+            let hi = match operands[2] {\n+                InlineAsmOperand::Out {\n+                    reg: InlineAsmRegOrRegClass::Reg(InlineAsmReg::X86(X86InlineAsmReg::dx)),\n+                    late: true,\n+                    place: Some(place),\n+                } => crate::base::codegen_place(fx, place),\n+                _ => unreachable!(),\n+            };\n+\n+            let u32_layout = fx.layout_of(fx.tcx.types.u32);\n+            let zero = fx.bcx.ins().iconst(types::I32, 0);\n+            lo.write_cvalue(fx, CValue::by_val(zero, u32_layout));\n+            hi.write_cvalue(fx, CValue::by_val(zero, u32_layout));\n+\n+            let destination_block = fx.get_block(destination.unwrap());\n+            fx.bcx.ins().jump(destination_block, &[]);\n+            return;\n+        } else if template[0] == InlineAsmTemplatePiece::String(\"lock xadd \".to_string())\n+            && matches!(\n+                template[1],\n+                InlineAsmTemplatePiece::Placeholder { operand_idx: 1, modifier: None, span: _ }\n+            )\n+            && template[2] == InlineAsmTemplatePiece::String(\", (\".to_string())\n+            && matches!(\n+                template[3],\n+                InlineAsmTemplatePiece::Placeholder { operand_idx: 0, modifier: None, span: _ }\n+            )\n+            && template[4] == InlineAsmTemplatePiece::String(\")\".to_string())\n+        {\n+            let destination_block = fx.get_block(destination.unwrap());\n+            fx.bcx.ins().jump(destination_block, &[]);\n+            return;\n         }\n     }\n \n@@ -175,6 +261,16 @@ pub(crate) fn codegen_inline_asm<'tcx>(\n     }\n \n     call_inline_asm(fx, &asm_name, asm_gen.stack_slot_size, inputs, outputs);\n+\n+    match destination {\n+        Some(destination) => {\n+            let destination_block = fx.get_block(destination);\n+            fx.bcx.ins().jump(destination_block, &[]);\n+        }\n+        None => {\n+            fx.bcx.ins().trap(TrapCode::UnreachableCodeReached);\n+        }\n+    }\n }\n \n struct InlineAssemblyGenerator<'a, 'tcx> {\n@@ -637,7 +733,7 @@ fn call_inline_asm<'tcx>(\n     inputs: Vec<(Size, Value)>,\n     outputs: Vec<(Size, CPlace<'tcx>)>,\n ) {\n-    let stack_slot = fx.bcx.func.create_stack_slot(StackSlotData {\n+    let stack_slot = fx.bcx.func.create_sized_stack_slot(StackSlotData {\n         kind: StackSlotKind::ExplicitSlot,\n         size: u32::try_from(slot_size.bytes()).unwrap(),\n     });"}, {"sha": "5120b89c4e8b0b28dba764aac67ed47cbfac3f1a", "filename": "compiler/rustc_codegen_cranelift/src/intrinsics/cpuid.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f2878a656b944ceed6f4a98d7e255784266a3dc0/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fcpuid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2878a656b944ceed6f4a98d7e255784266a3dc0/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fcpuid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fcpuid.rs?ref=f2878a656b944ceed6f4a98d7e255784266a3dc0", "patch": "@@ -62,7 +62,7 @@ pub(crate) fn codegen_cpuid_call<'tcx>(\n     fx.bcx.ins().jump(dest, &[zero, zero, proc_info_ecx, proc_info_edx]);\n \n     fx.bcx.switch_to_block(unsupported_leaf);\n-    crate::trap::trap_unreachable(\n+    crate::trap::trap_unimplemented(\n         fx,\n         \"__cpuid_count arch intrinsic doesn't yet support specified leaf\",\n     );"}, {"sha": "a799dca938e21bb4ef79027aaf408263aa961389", "filename": "compiler/rustc_codegen_cranelift/src/intrinsics/llvm.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f2878a656b944ceed6f4a98d7e255784266a3dc0/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2878a656b944ceed6f4a98d7e255784266a3dc0/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fllvm.rs?ref=f2878a656b944ceed6f4a98d7e255784266a3dc0", "patch": "@@ -139,6 +139,7 @@ pub(crate) fn codegen_llvm_intrinsic_call<'tcx>(\n                 .sess\n                 .warn(&format!(\"unsupported llvm intrinsic {}; replacing with trap\", intrinsic));\n             crate::trap::trap_unimplemented(fx, intrinsic);\n+            return;\n         }\n     }\n "}, {"sha": "ef3d5ccea8a2406d42d1cae971cd9a1658a94473", "filename": "compiler/rustc_codegen_cranelift/src/intrinsics/mod.rs", "status": "modified", "additions": 40, "deletions": 7, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/f2878a656b944ceed6f4a98d7e255784266a3dc0/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2878a656b944ceed6f4a98d7e255784266a3dc0/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fmod.rs?ref=f2878a656b944ceed6f4a98d7e255784266a3dc0", "patch": "@@ -44,7 +44,7 @@ fn report_atomic_type_validation_error<'tcx>(\n         ),\n     );\n     // Prevent verifier error\n-    crate::trap::trap_unreachable(fx, \"compilation should not have succeeded\");\n+    fx.bcx.ins().trap(TrapCode::UnreachableCodeReached);\n }\n \n pub(crate) fn clif_vector_type<'tcx>(tcx: TyCtxt<'tcx>, layout: TyAndLayout<'tcx>) -> Option<Type> {\n@@ -53,7 +53,7 @@ pub(crate) fn clif_vector_type<'tcx>(tcx: TyCtxt<'tcx>, layout: TyAndLayout<'tcx\n         _ => unreachable!(),\n     };\n \n-    match scalar_to_clif_type(tcx, element).by(u16::try_from(count).unwrap()) {\n+    match scalar_to_clif_type(tcx, element).by(u32::try_from(count).unwrap()) {\n         // Cranelift currently only implements icmp for 128bit vectors.\n         Some(vector_ty) if vector_ty.bits() == 128 => Some(vector_ty),\n         _ => None,\n@@ -301,7 +301,44 @@ fn codegen_float_intrinsic_call<'tcx>(\n         _ => unreachable!(),\n     };\n \n-    let res = fx.easy_call(name, &args, ty);\n+    let layout = fx.layout_of(ty);\n+    let res = match intrinsic {\n+        sym::fmaf32 | sym::fmaf64 => {\n+            let a = args[0].load_scalar(fx);\n+            let b = args[1].load_scalar(fx);\n+            let c = args[2].load_scalar(fx);\n+            CValue::by_val(fx.bcx.ins().fma(a, b, c), layout)\n+        }\n+        sym::copysignf32 | sym::copysignf64 => {\n+            let a = args[0].load_scalar(fx);\n+            let b = args[1].load_scalar(fx);\n+            CValue::by_val(fx.bcx.ins().fcopysign(a, b), layout)\n+        }\n+        sym::fabsf32\n+        | sym::fabsf64\n+        | sym::floorf32\n+        | sym::floorf64\n+        | sym::ceilf32\n+        | sym::ceilf64\n+        | sym::truncf32\n+        | sym::truncf64 => {\n+            let a = args[0].load_scalar(fx);\n+\n+            let val = match intrinsic {\n+                sym::fabsf32 | sym::fabsf64 => fx.bcx.ins().fabs(a),\n+                sym::floorf32 | sym::floorf64 => fx.bcx.ins().floor(a),\n+                sym::ceilf32 | sym::ceilf64 => fx.bcx.ins().ceil(a),\n+                sym::truncf32 | sym::truncf64 => fx.bcx.ins().trunc(a),\n+                _ => unreachable!(),\n+            };\n+\n+            CValue::by_val(val, layout)\n+        }\n+        // These intrinsics aren't supported natively by Cranelift.\n+        // Lower them to a libcall.\n+        _ => fx.easy_call(name, &args, ty),\n+    };\n+\n     ret.write_cvalue(fx, res);\n \n     true\n@@ -818,8 +855,6 @@ fn codegen_regular_intrinsic_call<'tcx>(\n                     if fx.tcx.is_compiler_builtins(LOCAL_CRATE) {\n                         // special case for compiler-builtins to avoid having to patch it\n                         crate::trap::trap_unimplemented(fx, \"128bit atomics not yet supported\");\n-                        let ret_block = fx.get_block(destination.unwrap());\n-                        fx.bcx.ins().jump(ret_block, &[]);\n                         return;\n                     } else {\n                         fx.tcx\n@@ -851,8 +886,6 @@ fn codegen_regular_intrinsic_call<'tcx>(\n                     if fx.tcx.is_compiler_builtins(LOCAL_CRATE) {\n                         // special case for compiler-builtins to avoid having to patch it\n                         crate::trap::trap_unimplemented(fx, \"128bit atomics not yet supported\");\n-                        let ret_block = fx.get_block(destination.unwrap());\n-                        fx.bcx.ins().jump(ret_block, &[]);\n                         return;\n                     } else {\n                         fx.tcx"}, {"sha": "a32b413d45f938d093f7f4efcae7e3a8fc2a240a", "filename": "compiler/rustc_codegen_cranelift/src/intrinsics/simd.rs", "status": "modified", "additions": 16, "deletions": 17, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/f2878a656b944ceed6f4a98d7e255784266a3dc0/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fsimd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2878a656b944ceed6f4a98d7e255784266a3dc0/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fsimd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fsimd.rs?ref=f2878a656b944ceed6f4a98d7e255784266a3dc0", "patch": "@@ -14,7 +14,7 @@ fn report_simd_type_validation_error(\n ) {\n     fx.tcx.sess.span_err(span, &format!(\"invalid monomorphization of `{}` intrinsic: expected SIMD input type, found non-SIMD `{}`\", intrinsic, ty));\n     // Prevent verifier error\n-    crate::trap::trap_unreachable(fx, \"compilation should not have succeeded\");\n+    fx.bcx.ins().trap(TrapCode::UnreachableCodeReached);\n }\n \n pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n@@ -157,7 +157,7 @@ pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n                             ),\n                         );\n                         // Prevent verifier error\n-                        crate::trap::trap_unreachable(fx, \"compilation should not have succeeded\");\n+                        fx.bcx.ins().trap(TrapCode::UnreachableCodeReached);\n                         return;\n                     }\n                 }\n@@ -274,12 +274,17 @@ pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n                 idx_const\n             } else {\n                 fx.tcx.sess.span_warn(span, \"Index argument for `simd_extract` is not a constant\");\n-                let res = crate::trap::trap_unimplemented_ret_value(\n+                let trap_block = fx.bcx.create_block();\n+                let dummy_block = fx.bcx.create_block();\n+                let true_ = fx.bcx.ins().iconst(types::I8, 1);\n+                fx.bcx.ins().brnz(true_, trap_block, &[]);\n+                fx.bcx.ins().jump(dummy_block, &[]);\n+                fx.bcx.switch_to_block(trap_block);\n+                crate::trap::trap_unimplemented(\n                     fx,\n-                    ret.layout(),\n                     \"Index argument for `simd_extract` is not a constant\",\n                 );\n-                ret.write_cvalue(fx, res);\n+                fx.bcx.switch_to_block(dummy_block);\n                 return;\n             };\n \n@@ -392,21 +397,15 @@ pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n \n             let layout = a.layout();\n             let (lane_count, lane_ty) = layout.ty.simd_size_and_type(fx.tcx);\n+            let res_lane_layout = fx.layout_of(lane_ty);\n \n             for lane in 0..lane_count {\n-                let a_lane = a.value_lane(fx, lane);\n-                let b_lane = b.value_lane(fx, lane);\n-                let c_lane = c.value_lane(fx, lane);\n+                let a_lane = a.value_lane(fx, lane).load_scalar(fx);\n+                let b_lane = b.value_lane(fx, lane).load_scalar(fx);\n+                let c_lane = c.value_lane(fx, lane).load_scalar(fx);\n \n-                let res_lane = match lane_ty.kind() {\n-                    ty::Float(FloatTy::F32) => {\n-                        fx.easy_call(\"fmaf\", &[a_lane, b_lane, c_lane], lane_ty)\n-                    }\n-                    ty::Float(FloatTy::F64) => {\n-                        fx.easy_call(\"fma\", &[a_lane, b_lane, c_lane], lane_ty)\n-                    }\n-                    _ => unreachable!(),\n-                };\n+                let res_lane = fx.bcx.ins().fma(a_lane, b_lane, c_lane);\n+                let res_lane = CValue::by_val(res_lane, res_lane_layout);\n \n                 ret.place_lane(fx, lane).write_cvalue(fx, res_lane);\n             }"}, {"sha": "913414e7618213d99adb63a711ef18412e747695", "filename": "compiler/rustc_codegen_cranelift/src/lib.rs", "status": "modified", "additions": 31, "deletions": 24, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/f2878a656b944ceed6f4a98d7e255784266a3dc0/compiler%2Frustc_codegen_cranelift%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2878a656b944ceed6f4a98d7e255784266a3dc0/compiler%2Frustc_codegen_cranelift%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Flib.rs?ref=f2878a656b944ceed6f4a98d7e255784266a3dc0", "patch": "@@ -4,6 +4,7 @@\n #![warn(unused_lifetimes)]\n #![warn(unreachable_pub)]\n \n+extern crate jobserver;\n #[macro_use]\n extern crate rustc_middle;\n extern crate rustc_ast;\n@@ -25,10 +26,12 @@ extern crate rustc_target;\n extern crate rustc_driver;\n \n use std::any::Any;\n-use std::cell::Cell;\n+use std::cell::{Cell, RefCell};\n+use std::sync::Arc;\n \n use rustc_codegen_ssa::traits::CodegenBackend;\n use rustc_codegen_ssa::CodegenResults;\n+use rustc_data_structures::profiling::SelfProfilerRef;\n use rustc_errors::ErrorGuaranteed;\n use rustc_metadata::EncodedMetadata;\n use rustc_middle::dep_graph::{WorkProduct, WorkProductId};\n@@ -51,11 +54,13 @@ mod cast;\n mod codegen_i128;\n mod common;\n mod compiler_builtins;\n+mod concurrency_limiter;\n mod config;\n mod constant;\n mod debuginfo;\n mod discriminant;\n mod driver;\n+mod global_asm;\n mod inline_asm;\n mod intrinsics;\n mod linkage;\n@@ -119,19 +124,20 @@ impl<F: Fn() -> String> Drop for PrintOnPanic<F> {\n \n /// The codegen context holds any information shared between the codegen of individual functions\n /// inside a single codegen unit with the exception of the Cranelift [`Module`](cranelift_module::Module).\n-struct CodegenCx<'tcx> {\n-    tcx: TyCtxt<'tcx>,\n+struct CodegenCx {\n+    profiler: SelfProfilerRef,\n+    output_filenames: Arc<OutputFilenames>,\n+    should_write_ir: bool,\n     global_asm: String,\n     inline_asm_index: Cell<usize>,\n-    cached_context: Context,\n-    debug_context: Option<DebugContext<'tcx>>,\n+    debug_context: Option<DebugContext>,\n     unwind_context: UnwindContext,\n     cgu_name: Symbol,\n }\n \n-impl<'tcx> CodegenCx<'tcx> {\n+impl CodegenCx {\n     fn new(\n-        tcx: TyCtxt<'tcx>,\n+        tcx: TyCtxt<'_>,\n         backend_config: BackendConfig,\n         isa: &dyn TargetIsa,\n         debug_info: bool,\n@@ -147,10 +153,11 @@ impl<'tcx> CodegenCx<'tcx> {\n             None\n         };\n         CodegenCx {\n-            tcx,\n+            profiler: tcx.prof.clone(),\n+            output_filenames: tcx.output_filenames(()).clone(),\n+            should_write_ir: crate::pretty_clif::should_write_ir(tcx),\n             global_asm: String::new(),\n             inline_asm_index: Cell::new(0),\n-            cached_context: Context::new(),\n             debug_context,\n             unwind_context,\n             cgu_name,\n@@ -159,7 +166,7 @@ impl<'tcx> CodegenCx<'tcx> {\n }\n \n pub struct CraneliftCodegenBackend {\n-    pub config: Option<BackendConfig>,\n+    pub config: RefCell<Option<BackendConfig>>,\n }\n \n impl CodegenBackend for CraneliftCodegenBackend {\n@@ -169,6 +176,13 @@ impl CodegenBackend for CraneliftCodegenBackend {\n             Lto::No | Lto::ThinLocal => {}\n             Lto::Thin | Lto::Fat => sess.warn(\"LTO is not supported. You may get a linker error.\"),\n         }\n+\n+        let mut config = self.config.borrow_mut();\n+        if config.is_none() {\n+            let new_config = BackendConfig::from_opts(&sess.opts.cg.llvm_args)\n+                .unwrap_or_else(|err| sess.fatal(&err));\n+            *config = Some(new_config);\n+        }\n     }\n \n     fn target_features(&self, _sess: &Session, _allow_unstable: bool) -> Vec<rustc_span::Symbol> {\n@@ -186,15 +200,7 @@ impl CodegenBackend for CraneliftCodegenBackend {\n         need_metadata_module: bool,\n     ) -> Box<dyn Any> {\n         tcx.sess.abort_if_errors();\n-        let config = if let Some(config) = self.config.clone() {\n-            config\n-        } else {\n-            if !tcx.sess.unstable_options() && !tcx.sess.opts.cg.llvm_args.is_empty() {\n-                tcx.sess.fatal(\"`-Z unstable-options` must be passed to allow configuring cg_clif\");\n-            }\n-            BackendConfig::from_opts(&tcx.sess.opts.cg.llvm_args)\n-                .unwrap_or_else(|err| tcx.sess.fatal(&err))\n-        };\n+        let config = self.config.borrow().clone().unwrap();\n         match config.codegen_mode {\n             CodegenMode::Aot => driver::aot::run_aot(tcx, config, metadata, need_metadata_module),\n             CodegenMode::Jit | CodegenMode::JitLazy => {\n@@ -210,12 +216,13 @@ impl CodegenBackend for CraneliftCodegenBackend {\n     fn join_codegen(\n         &self,\n         ongoing_codegen: Box<dyn Any>,\n-        _sess: &Session,\n+        sess: &Session,\n         _outputs: &OutputFilenames,\n     ) -> Result<(CodegenResults, FxHashMap<WorkProductId, WorkProduct>), ErrorGuaranteed> {\n-        Ok(*ongoing_codegen\n-            .downcast::<(CodegenResults, FxHashMap<WorkProductId, WorkProduct>)>()\n-            .unwrap())\n+        Ok(ongoing_codegen\n+            .downcast::<driver::aot::OngoingCodegen>()\n+            .unwrap()\n+            .join(sess, self.config.borrow().as_ref().unwrap()))\n     }\n \n     fn link(\n@@ -312,5 +319,5 @@ fn build_isa(sess: &Session, backend_config: &BackendConfig) -> Box<dyn isa::Tar\n /// This is the entrypoint for a hot plugged rustc_codegen_cranelift\n #[no_mangle]\n pub fn __rustc_codegen_backend() -> Box<dyn CodegenBackend> {\n-    Box::new(CraneliftCodegenBackend { config: None })\n+    Box::new(CraneliftCodegenBackend { config: RefCell::new(None) })\n }"}, {"sha": "0df7e82294bd23521b72225d3746116488cac4d3", "filename": "compiler/rustc_codegen_cranelift/src/optimize/mod.rs", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/f2878a656b944ceed6f4a98d7e255784266a3dc0/compiler%2Frustc_codegen_cranelift%2Fsrc%2Foptimize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2878a656b944ceed6f4a98d7e255784266a3dc0/compiler%2Frustc_codegen_cranelift%2Fsrc%2Foptimize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Foptimize%2Fmod.rs?ref=f2878a656b944ceed6f4a98d7e255784266a3dc0", "patch": "@@ -1,20 +1,3 @@\n //! Various optimizations specific to cg_clif\n \n-use cranelift_codegen::isa::TargetIsa;\n-\n-use crate::prelude::*;\n-\n pub(crate) mod peephole;\n-\n-pub(crate) fn optimize_function<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    isa: &dyn TargetIsa,\n-    instance: Instance<'tcx>,\n-    ctx: &mut Context,\n-    clif_comments: &mut crate::pretty_clif::CommentWriter,\n-) {\n-    // FIXME classify optimizations over opt levels once we have more\n-\n-    crate::pretty_clif::write_clif_file(tcx, \"preopt\", isa, instance, &ctx.func, &*clif_comments);\n-    crate::base::verify_func(tcx, &*clif_comments, &ctx.func);\n-}"}, {"sha": "a7af162687c34c5cd0fa4ffbea65459779231eb7", "filename": "compiler/rustc_codegen_cranelift/src/pretty_clif.rs", "status": "modified", "additions": 28, "deletions": 33, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/f2878a656b944ceed6f4a98d7e255784266a3dc0/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fpretty_clif.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2878a656b944ceed6f4a98d7e255784266a3dc0/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fpretty_clif.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fpretty_clif.rs?ref=f2878a656b944ceed6f4a98d7e255784266a3dc0", "patch": "@@ -62,7 +62,7 @@ use cranelift_codegen::{\n };\n \n use rustc_middle::ty::layout::FnAbiOf;\n-use rustc_session::config::OutputType;\n+use rustc_session::config::{OutputFilenames, OutputType};\n \n use crate::prelude::*;\n \n@@ -205,60 +205,55 @@ pub(crate) fn should_write_ir(tcx: TyCtxt<'_>) -> bool {\n }\n \n pub(crate) fn write_ir_file(\n-    tcx: TyCtxt<'_>,\n-    name: impl FnOnce() -> String,\n+    output_filenames: &OutputFilenames,\n+    name: &str,\n     write: impl FnOnce(&mut dyn Write) -> std::io::Result<()>,\n ) {\n-    if !should_write_ir(tcx) {\n-        return;\n-    }\n-\n-    let clif_output_dir = tcx.output_filenames(()).with_extension(\"clif\");\n+    let clif_output_dir = output_filenames.with_extension(\"clif\");\n \n     match std::fs::create_dir(&clif_output_dir) {\n         Ok(()) => {}\n         Err(err) if err.kind() == std::io::ErrorKind::AlreadyExists => {}\n         res @ Err(_) => res.unwrap(),\n     }\n \n-    let clif_file_name = clif_output_dir.join(name());\n+    let clif_file_name = clif_output_dir.join(name);\n \n     let res = std::fs::File::create(clif_file_name).and_then(|mut file| write(&mut file));\n     if let Err(err) = res {\n-        tcx.sess.warn(&format!(\"error writing ir file: {}\", err));\n+        // Using early_warn as no Session is available here\n+        rustc_session::early_warn(\n+            rustc_session::config::ErrorOutputType::default(),\n+            &format!(\"error writing ir file: {}\", err),\n+        );\n     }\n }\n \n-pub(crate) fn write_clif_file<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n+pub(crate) fn write_clif_file(\n+    output_filenames: &OutputFilenames,\n+    symbol_name: &str,\n     postfix: &str,\n     isa: &dyn cranelift_codegen::isa::TargetIsa,\n-    instance: Instance<'tcx>,\n     func: &cranelift_codegen::ir::Function,\n     mut clif_comments: &CommentWriter,\n ) {\n     // FIXME work around filename too long errors\n-    write_ir_file(\n-        tcx,\n-        || format!(\"{}.{}.clif\", tcx.symbol_name(instance).name, postfix),\n-        |file| {\n-            let mut clif = String::new();\n-            cranelift_codegen::write::decorate_function(&mut clif_comments, &mut clif, func)\n-                .unwrap();\n+    write_ir_file(output_filenames, &format!(\"{}.{}.clif\", symbol_name, postfix), |file| {\n+        let mut clif = String::new();\n+        cranelift_codegen::write::decorate_function(&mut clif_comments, &mut clif, func).unwrap();\n \n-            for flag in isa.flags().iter() {\n-                writeln!(file, \"set {}\", flag)?;\n-            }\n-            write!(file, \"target {}\", isa.triple().architecture.to_string())?;\n-            for isa_flag in isa.isa_flags().iter() {\n-                write!(file, \" {}\", isa_flag)?;\n-            }\n-            writeln!(file, \"\\n\")?;\n-            writeln!(file)?;\n-            file.write_all(clif.as_bytes())?;\n-            Ok(())\n-        },\n-    );\n+        for flag in isa.flags().iter() {\n+            writeln!(file, \"set {}\", flag)?;\n+        }\n+        write!(file, \"target {}\", isa.triple().architecture.to_string())?;\n+        for isa_flag in isa.isa_flags().iter() {\n+            write!(file, \" {}\", isa_flag)?;\n+        }\n+        writeln!(file, \"\\n\")?;\n+        writeln!(file)?;\n+        file.write_all(clif.as_bytes())?;\n+        Ok(())\n+    });\n }\n \n impl fmt::Debug for FunctionCx<'_, '_, '_> {"}, {"sha": "b6b465e1f4e0a808a394c07b68ee0563d1538314", "filename": "compiler/rustc_codegen_cranelift/src/toolchain.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f2878a656b944ceed6f4a98d7e255784266a3dc0/compiler%2Frustc_codegen_cranelift%2Fsrc%2Ftoolchain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2878a656b944ceed6f4a98d7e255784266a3dc0/compiler%2Frustc_codegen_cranelift%2Fsrc%2Ftoolchain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Ftoolchain.rs?ref=f2878a656b944ceed6f4a98d7e255784266a3dc0", "patch": "@@ -8,10 +8,8 @@ use rustc_session::Session;\n /// Tries to infer the path of a binary for the target toolchain from the linker name.\n pub(crate) fn get_toolchain_binary(sess: &Session, tool: &str) -> PathBuf {\n     let (mut linker, _linker_flavor) = linker_and_flavor(sess);\n-    let linker_file_name = linker\n-        .file_name()\n-        .and_then(|name| name.to_str())\n-        .unwrap_or_else(|| sess.fatal(\"couldn't extract file name from specified linker\"));\n+    let linker_file_name =\n+        linker.file_name().unwrap().to_str().expect(\"linker filename should be valid UTF-8\");\n \n     if linker_file_name == \"ld.lld\" {\n         if tool != \"ld\" {"}, {"sha": "82a2ec579549669afca23f19c1fac2e0eba12936", "filename": "compiler/rustc_codegen_cranelift/src/trap.rs", "status": "modified", "additions": 1, "deletions": 24, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/f2878a656b944ceed6f4a98d7e255784266a3dc0/compiler%2Frustc_codegen_cranelift%2Fsrc%2Ftrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2878a656b944ceed6f4a98d7e255784266a3dc0/compiler%2Frustc_codegen_cranelift%2Fsrc%2Ftrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Ftrap.rs?ref=f2878a656b944ceed6f4a98d7e255784266a3dc0", "patch": "@@ -25,33 +25,10 @@ fn codegen_print(fx: &mut FunctionCx<'_, '_, '_>, msg: &str) {\n     fx.bcx.ins().call(puts, &[msg_ptr]);\n }\n \n-/// Use this for example when a function call should never return. This will fill the current block,\n-/// so you can **not** add instructions to it afterwards.\n-///\n-/// Trap code: user65535\n-pub(crate) fn trap_unreachable(fx: &mut FunctionCx<'_, '_, '_>, msg: impl AsRef<str>) {\n-    codegen_print(fx, msg.as_ref());\n-    fx.bcx.ins().trap(TrapCode::UnreachableCodeReached);\n-}\n /// Use this when something is unimplemented, but `libcore` or `libstd` requires it to codegen.\n-/// Unlike `trap_unreachable` this will not fill the current block, so you **must** add instructions\n-/// to it afterwards.\n ///\n /// Trap code: user65535\n pub(crate) fn trap_unimplemented(fx: &mut FunctionCx<'_, '_, '_>, msg: impl AsRef<str>) {\n     codegen_print(fx, msg.as_ref());\n-    let true_ = fx.bcx.ins().iconst(types::I32, 1);\n-    fx.bcx.ins().trapnz(true_, TrapCode::User(!0));\n-}\n-\n-/// Like `trap_unimplemented` but returns a fake value of the specified type.\n-///\n-/// Trap code: user65535\n-pub(crate) fn trap_unimplemented_ret_value<'tcx>(\n-    fx: &mut FunctionCx<'_, '_, 'tcx>,\n-    dest_layout: TyAndLayout<'tcx>,\n-    msg: impl AsRef<str>,\n-) -> CValue<'tcx> {\n-    trap_unimplemented(fx, msg);\n-    CValue::by_ref(Pointer::const_addr(fx, 0), dest_layout)\n+    fx.bcx.ins().trap(TrapCode::User(!0));\n }"}, {"sha": "2ee98546c992a1ec8cce8ccd3c7e2a2fdb9d06a8", "filename": "compiler/rustc_codegen_cranelift/src/value_and_place.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f2878a656b944ceed6f4a98d7e255784266a3dc0/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvalue_and_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2878a656b944ceed6f4a98d7e255784266a3dc0/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvalue_and_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvalue_and_place.rs?ref=f2878a656b944ceed6f4a98d7e255784266a3dc0", "patch": "@@ -122,7 +122,7 @@ impl<'tcx> CValue<'tcx> {\n                 let clif_ty = match layout.abi {\n                     Abi::Scalar(scalar) => scalar_to_clif_type(fx.tcx, scalar),\n                     Abi::Vector { element, count } => scalar_to_clif_type(fx.tcx, element)\n-                        .by(u16::try_from(count).unwrap())\n+                        .by(u32::try_from(count).unwrap())\n                         .unwrap(),\n                     _ => unreachable!(\"{:?}\", layout.ty),\n                 };\n@@ -330,7 +330,7 @@ impl<'tcx> CPlace<'tcx> {\n                 .fatal(&format!(\"values of type {} are too big to store on the stack\", layout.ty));\n         }\n \n-        let stack_slot = fx.bcx.create_stack_slot(StackSlotData {\n+        let stack_slot = fx.bcx.create_sized_stack_slot(StackSlotData {\n             kind: StackSlotKind::ExplicitSlot,\n             // FIXME Don't force the size to a multiple of 16 bytes once Cranelift gets a way to\n             // specify stack slot alignment.\n@@ -472,7 +472,7 @@ impl<'tcx> CPlace<'tcx> {\n                 }\n                 _ if src_ty.is_vector() || dst_ty.is_vector() => {\n                     // FIXME do something more efficient for transmutes between vectors and integers.\n-                    let stack_slot = fx.bcx.create_stack_slot(StackSlotData {\n+                    let stack_slot = fx.bcx.create_sized_stack_slot(StackSlotData {\n                         kind: StackSlotKind::ExplicitSlot,\n                         // FIXME Don't force the size to a multiple of 16 bytes once Cranelift gets a way to\n                         // specify stack slot alignment.\n@@ -519,7 +519,7 @@ impl<'tcx> CPlace<'tcx> {\n                 if let ty::Array(element, len) = dst_layout.ty.kind() {\n                     // Can only happen for vector types\n                     let len =\n-                        u16::try_from(len.eval_usize(fx.tcx, ParamEnv::reveal_all())).unwrap();\n+                        u32::try_from(len.eval_usize(fx.tcx, ParamEnv::reveal_all())).unwrap();\n                     let vector_ty = fx.clif_type(*element).unwrap().by(len).unwrap();\n \n                     let data = match from.0 {\n@@ -614,7 +614,7 @@ impl<'tcx> CPlace<'tcx> {\n                     dst_align,\n                     src_align,\n                     true,\n-                    MemFlags::trusted(),\n+                    flags,\n                 );\n             }\n             CValueInner::ByRef(_, Some(_)) => todo!(),"}, {"sha": "3d929a1d50ce2435307a7834c1fe04c1c73b94bd", "filename": "compiler/rustc_codegen_cranelift/test.sh", "status": "modified", "additions": 1, "deletions": 12, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f2878a656b944ceed6f4a98d7e255784266a3dc0/compiler%2Frustc_codegen_cranelift%2Ftest.sh", "raw_url": "https://github.com/rust-lang/rust/raw/f2878a656b944ceed6f4a98d7e255784266a3dc0/compiler%2Frustc_codegen_cranelift%2Ftest.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Ftest.sh?ref=f2878a656b944ceed6f4a98d7e255784266a3dc0", "patch": "@@ -1,13 +1,2 @@\n #!/usr/bin/env bash\n-set -e\n-\n-./y.rs build --sysroot none \"$@\"\n-\n-rm -r target/out || true\n-\n-scripts/tests.sh no_sysroot\n-\n-./y.rs build \"$@\"\n-\n-scripts/tests.sh base_sysroot\n-scripts/tests.sh extended_sysroot\n+exec ./y.rs test"}, {"sha": "7f8d6ad12888c2a31fe3133427f7230799863f46", "filename": "src/tools/tidy/src/deps.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f2878a656b944ceed6f4a98d7e255784266a3dc0/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2878a656b944ceed6f4a98d7e255784266a3dc0/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs?ref=f2878a656b944ceed6f4a98d7e255784266a3dc0", "patch": "@@ -300,6 +300,12 @@ const PERMITTED_CRANELIFT_DEPENDENCIES: &[&str] = &[\n     \"winapi\",\n     \"winapi-i686-pc-windows-gnu\",\n     \"winapi-x86_64-pc-windows-gnu\",\n+    \"windows-sys\",\n+    \"windows_aarch64_msvc\",\n+    \"windows_i686_gnu\",\n+    \"windows_i686_msvc\",\n+    \"windows_x86_64_gnu\",\n+    \"windows_x86_64_msvc\",\n ];\n \n const FORBIDDEN_TO_HAVE_DUPLICATES: &[&str] = &["}]}