{"sha": "8c06d1bcb01f1b45946adb8620149056b8e70d54", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhjMDZkMWJjYjAxZjFiNDU5NDZhZGI4NjIwMTQ5MDU2YjhlNzBkNTQ=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-06-14T12:46:46Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-06-14T12:53:01Z"}, "message": "Remove 'peeking_at_item' from parser\n\nparse_item now returns a value to indicate it didn't find an item", "tree": {"sha": "c1ff23a68ecf660589133eb3510fcab2053095d1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c1ff23a68ecf660589133eb3510fcab2053095d1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8c06d1bcb01f1b45946adb8620149056b8e70d54", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8c06d1bcb01f1b45946adb8620149056b8e70d54", "html_url": "https://github.com/rust-lang/rust/commit/8c06d1bcb01f1b45946adb8620149056b8e70d54", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8c06d1bcb01f1b45946adb8620149056b8e70d54/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "355c417267371293f48333388fed7eb56c3a8b1f", "url": "https://api.github.com/repos/rust-lang/rust/commits/355c417267371293f48333388fed7eb56c3a8b1f", "html_url": "https://github.com/rust-lang/rust/commit/355c417267371293f48333388fed7eb56c3a8b1f"}], "stats": {"total": 93, "additions": 41, "deletions": 52}, "files": [{"sha": "68d57b87340c83a6360bc29d1ee28ff5bee9d3e3", "filename": "src/comp/front/parser.rs", "status": "modified", "additions": 41, "deletions": 52, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/8c06d1bcb01f1b45946adb8620149056b8e70d54/src%2Fcomp%2Ffront%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c06d1bcb01f1b45946adb8620149056b8e70d54/src%2Fcomp%2Ffront%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fparser.rs?ref=8c06d1bcb01f1b45946adb8620149056b8e70d54", "patch": "@@ -1624,18 +1624,18 @@ fn parse_source_stmt(&parser p) -> @ast::stmt {\n         auto hi = p.get_span();\n         ret @spanned(lo, decl.span.hi, ast::stmt_decl(decl, p.get_ann()));\n     } else {\n-        if (peeking_at_item(p)) {\n-            // Might be a local item decl.\n-            auto i = parse_item(p);\n-            auto hi = i.span.hi;\n-            auto decl = @spanned(lo, hi, ast::decl_item(i));\n-            ret @spanned(lo, hi, ast::stmt_decl(decl, p.get_ann()));\n-\n-        } else {\n-            // Remainder are line-expr stmts.\n-            auto e = parse_expr(p);\n-            auto hi = p.get_span();\n-            ret @spanned(lo, e.span.hi, ast::stmt_expr(e, p.get_ann()));\n+        alt (parse_item(p)) {\n+            case (got_item(?i)) {\n+                auto hi = i.span.hi;\n+                auto decl = @spanned(lo, hi, ast::decl_item(i));\n+                ret @spanned(lo, hi, ast::stmt_decl(decl, p.get_ann()));\n+            }\n+            case (no_item) {\n+                // Remainder are line-expr stmts.\n+                auto e = parse_expr(p);\n+                auto hi = p.get_span();\n+                ret @spanned(lo, e.span.hi, ast::stmt_expr(e, p.get_ann()));\n+            }\n         }\n     }\n     p.err(\"expected statement\");\n@@ -1918,7 +1918,15 @@ fn parse_mod_items(&parser p, token::token term) -> ast::_mod {\n     auto view_items = parse_view(p);\n     let vec[@ast::item] items = [];\n     while (p.peek() != term) {\n-        items += [parse_item(p)];\n+        alt (parse_item(p)) {\n+            case (got_item(?i)) {\n+                vec::push(items, i);\n+            }\n+            case (_) {\n+                p.err(\"expected item but found \" +\n+                      token::to_str(p.get_reader(), p.peek()));\n+            }\n+        }\n     }\n     ret rec(view_items=view_items, items=items);\n }\n@@ -2144,57 +2152,38 @@ fn parse_auth(&parser p) -> ast::_auth {\n     fail;\n }\n \n-fn peeking_at_item(&parser p) -> bool {\n-    alt (p.peek()) {\n-        case (token::IDENT(?sid, false)) {\n-            auto st = p.get_str(sid);\n-            ret str::eq(st, \"state\") ||\n-                str::eq(st, \"gc\") ||\n-                str::eq(st, \"const\") ||\n-                str::eq(st, \"fn\") ||\n-                str::eq(st, \"pred\") ||\n-                str::eq(st, \"iter\") ||\n-                str::eq(st, \"mod\") ||\n-                str::eq(st, \"type\") ||\n-                str::eq(st, \"tag\") ||\n-                str::eq(st, \"obj\");\n-        }\n-        case (_) { ret false; }\n-    }\n+// FIXME will be extended to help parse anon functions\n+tag parsed_item {\n+    got_item(@ast::item);\n+    no_item;\n }\n \n-fn parse_item(&parser p) -> @ast::item {\n-    let ast::layer lyr = parse_layer(p);\n-\n+fn parse_item(&parser p) -> parsed_item {\n     if (eat_word(p, \"const\")) {\n-        assert (lyr == ast::layer_value);\n-        ret parse_item_const(p);\n+        ret got_item(parse_item_const(p));\n     } else if (eat_word(p, \"fn\")) {\n-        assert (lyr == ast::layer_value);\n-        ret parse_item_fn_or_iter(p, ast::impure_fn, ast::proto_fn);\n+        ret got_item(parse_item_fn_or_iter(p, ast::impure_fn, ast::proto_fn));\n     } else if (eat_word(p, \"pred\")) {\n-        assert (lyr == ast::layer_value);\n-        ret parse_item_fn_or_iter(p, ast::pure_fn, ast::proto_fn);\n+        ret got_item(parse_item_fn_or_iter(p, ast::pure_fn, ast::proto_fn));\n     } else if (eat_word(p, \"iter\")) {\n-        assert (lyr == ast::layer_value);\n-        ret parse_item_fn_or_iter(p, ast::impure_fn, ast::proto_iter);\n+        ret got_item(parse_item_fn_or_iter(p, ast::impure_fn,\n+                                           ast::proto_iter));\n     } else if (eat_word(p, \"mod\")) {\n-        assert (lyr == ast::layer_value);\n-        ret parse_item_mod(p);\n+        ret got_item(parse_item_mod(p));\n     } else if (eat_word(p, \"native\")) {\n-        assert (lyr == ast::layer_value);\n-        ret parse_item_native_mod(p);\n-    } else if (eat_word(p, \"type\")) {\n-        ret parse_item_type(p);\n+        ret got_item(parse_item_native_mod(p));\n+    }\n+\n+    auto lyr = parse_layer(p);\n+    if (eat_word(p, \"type\")) {\n+        ret got_item(parse_item_type(p));\n     } else if (eat_word(p, \"tag\")) {\n-        ret parse_item_tag(p);\n+        ret got_item(parse_item_tag(p));\n     } else if (eat_word(p, \"obj\")) {\n-        ret parse_item_obj(p, lyr);\n+        ret got_item(parse_item_obj(p, lyr));\n     } else {\n-        p.err(\"expected item but found \" +\n-              token::to_str(p.get_reader(), p.peek()));\n+        ret no_item;\n     }\n-    fail;\n }\n \n fn parse_meta_item(&parser p) -> @ast::meta_item {"}]}