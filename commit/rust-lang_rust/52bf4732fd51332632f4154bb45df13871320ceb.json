{"sha": "52bf4732fd51332632f4154bb45df13871320ceb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUyYmY0NzMyZmQ1MTMzMjYzMmY0MTU0YmI0NWRmMTM4NzEzMjBjZWI=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2018-07-10T15:32:38Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2018-07-10T15:32:38Z"}, "message": "Fix some clippy lints", "tree": {"sha": "d8396baf41f31346b36c8faaa4db8080cb95292c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d8396baf41f31346b36c8faaa4db8080cb95292c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/52bf4732fd51332632f4154bb45df13871320ceb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/52bf4732fd51332632f4154bb45df13871320ceb", "html_url": "https://github.com/rust-lang/rust/commit/52bf4732fd51332632f4154bb45df13871320ceb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/52bf4732fd51332632f4154bb45df13871320ceb/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f321593655b9ba2d5e475474dbc9ee2b5ae6285d", "url": "https://api.github.com/repos/rust-lang/rust/commits/f321593655b9ba2d5e475474dbc9ee2b5ae6285d", "html_url": "https://github.com/rust-lang/rust/commit/f321593655b9ba2d5e475474dbc9ee2b5ae6285d"}], "stats": {"total": 85, "additions": 39, "deletions": 46}, "files": [{"sha": "d2149ee5dbe7d3ee75280440acf226f16237b25f", "filename": "src/fn_call.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/52bf4732fd51332632f4154bb45df13871320ceb/src%2Ffn_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52bf4732fd51332632f4154bb45df13871320ceb/src%2Ffn_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffn_call.rs?ref=52bf4732fd51332632f4154bb45df13871320ceb", "patch": "@@ -268,7 +268,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx> for EvalContext<'a, 'mir, '\n                 )?;\n                 let mut args = self.frame().mir.args_iter();\n \n-                let arg_local = args.next().ok_or(\n+                let arg_local = args.next().ok_or_else(||\n                     EvalErrorKind::AbiViolation(\n                         \"Argument to __rust_maybe_catch_panic does not take enough arguments.\"\n                             .to_owned(),\n@@ -504,7 +504,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx> for EvalContext<'a, 'mir, '\n \n                 // Figure out how large a pthread TLS key actually is. This is libc::pthread_key_t.\n                 let key_type = args[0].ty.builtin_deref(true)\n-                                   .ok_or(EvalErrorKind::AbiViolation(\"Wrong signature used for pthread_key_create: First argument must be a raw pointer.\".to_owned()))?.ty;\n+                                   .ok_or_else(|| EvalErrorKind::AbiViolation(\"Wrong signature used for pthread_key_create: First argument must be a raw pointer.\".to_owned()))?.ty;\n                 let key_size = self.layout_of(key_type)?.size;\n \n                 // Create key and write it into the memory where key_ptr wants it\n@@ -747,7 +747,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx> for EvalContext<'a, 'mir, '\n         // current frame.\n         self.dump_local(dest);\n         self.goto_block(dest_block);\n-        return Ok(());\n+        Ok(())\n     }\n \n     fn write_null(&mut self, dest: Place, dest_ty: Ty<'tcx>) -> EvalResult<'tcx> {"}, {"sha": "aa699b509fad8a4210c7ac177b475afdcfe2082f", "filename": "src/helpers.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/52bf4732fd51332632f4154bb45df13871320ceb/src%2Fhelpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52bf4732fd51332632f4154bb45df13871320ceb/src%2Fhelpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fhelpers.rs?ref=52bf4732fd51332632f4154bb45df13871320ceb", "patch": "@@ -75,7 +75,7 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n         }\n         // FIXME: assuming here that type size is < i64::max_value()\n         let pointee_size = self.layout_of(pointee_ty)?.size.bytes() as i64;\n-        return if let Some(offset) = offset.checked_mul(pointee_size) {\n+         if let Some(offset) = offset.checked_mul(pointee_size) {\n             let ptr = ptr.ptr_signed_offset(offset, self)?;\n             // Do not do bounds-checking for integers; they can never alias a normal pointer anyway.\n             if let Scalar::Ptr(ptr) = ptr {\n@@ -87,7 +87,7 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n             Ok(ptr)\n         } else {\n             err!(Overflow(mir::BinOp::Mul))\n-        };\n+        }\n     }\n \n     fn value_to_isize("}, {"sha": "88bca91aa2de5ab2c0ff251e50976be06c9de031", "filename": "src/lib.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/52bf4732fd51332632f4154bb45df13871320ceb/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52bf4732fd51332632f4154bb45df13871320ceb/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=52bf4732fd51332632f4154bb45df13871320ceb", "patch": "@@ -5,6 +5,8 @@\n     inclusive_range_methods,\n )]\n \n+#![cfg_attr(feature = \"cargo-clippy\", allow(cast_lossless))]\n+\n #[macro_use]\n extern crate log;\n \n@@ -427,14 +429,11 @@ impl<'mir, 'tcx: 'mir> Machine<'mir, 'tcx> for Evaluator<'tcx> {\n                 let frame = ecx.frame_mut();\n                 let bb = &frame.mir.basic_blocks()[frame.block];\n                 if bb.statements.len() == frame.stmt && !bb.is_cleanup {\n-                    match bb.terminator().kind {\n-                        ::rustc::mir::TerminatorKind::Return => {\n-                            for (local, _local_decl) in mir.local_decls.iter_enumerated().skip(1) {\n-                                // Don't deallocate locals, because the return value might reference them\n-                                frame.storage_dead(local);\n-                            }\n+                    if let ::rustc::mir::TerminatorKind::Return = bb.terminator().kind {\n+                        for (local, _local_decl) in mir.local_decls.iter_enumerated().skip(1) {\n+                            // Don't deallocate locals, because the return value might reference them\n+                            frame.storage_dead(local);\n                         }\n-                        _ => {}\n                     }\n                 }\n             }\n@@ -478,7 +477,7 @@ impl<'mir, 'tcx: 'mir> Machine<'mir, 'tcx> for Evaluator<'tcx> {\n                 value: Value::Scalar(Scalar::from_u128(match layout.size.bytes() {\n                     0 => 1 as u128,\n                     size => size as u128,\n-                }.into())),\n+                })),\n                 ty: usize,\n             },\n             dest,"}, {"sha": "3b67c9bb7f3e4ef020095a2f25a45fc253f30fb5", "filename": "src/locks.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/52bf4732fd51332632f4154bb45df13871320ceb/src%2Flocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52bf4732fd51332632f4154bb45df13871320ceb/src%2Flocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flocks.rs?ref=52bf4732fd51332632f4154bb45df13871320ceb", "patch": "@@ -241,11 +241,9 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> MemoryExt<'tcx> for Memory<'a, 'mir, 'tcx, Evalu\n                     // All is well\n                     continue 'locks;\n                 }\n-            } else {\n-                if !is_our_lock {\n-                    // All is well.\n-                    continue 'locks;\n-                }\n+            } else if !is_our_lock {\n+                // All is well.\n+                continue 'locks;\n             }\n             // If we get here, releasing this is an error except for NoLock.\n             if lock.active != NoLock {\n@@ -377,7 +375,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> MemoryExt<'tcx> for Memory<'a, 'mir, 'tcx, Evalu\n             }\n             // Clean up the map\n             alloc_locks.retain(|lock| match lock.active {\n-                NoLock => lock.suspended.len() > 0,\n+                NoLock => !lock.suspended.is_empty(),\n                 _ => true,\n             });\n         }"}, {"sha": "1440f1dab4e0fc8187cadb09490907e0d329d7b0", "filename": "src/operator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52bf4732fd51332632f4154bb45df13871320ceb/src%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52bf4732fd51332632f4154bb45df13871320ceb/src%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Foperator.rs?ref=52bf4732fd51332632f4154bb45df13871320ceb", "patch": "@@ -69,7 +69,7 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n                     .expect(\"Offset called on non-ptr type\")\n                     .ty;\n                 let ptr = self.pointer_offset(\n-                    left.into(),\n+                    left,\n                     pointee_ty,\n                     right.to_bits(self.memory.pointer_size())? as i64,\n                 )?;"}, {"sha": "fcffaf7128f11704a663a0b41b983486868527ef", "filename": "src/range_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52bf4732fd51332632f4154bb45df13871320ceb/src%2Frange_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52bf4732fd51332632f4154bb45df13871320ceb/src%2Frange_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frange_map.rs?ref=52bf4732fd51332632f4154bb45df13871320ceb", "patch": "@@ -189,7 +189,7 @@ impl<T> RangeMap<T> {\n         F: FnMut(&T) -> bool,\n     {\n         let mut remove = Vec::new();\n-        for (range, data) in self.map.iter() {\n+        for (range, data) in &self.map {\n             if !f(data) {\n                 remove.push(*range);\n             }"}, {"sha": "45805f3aa8cc1199e15b24ede7dfecf42b95f57e", "filename": "src/tls.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/52bf4732fd51332632f4154bb45df13871320ceb/src%2Ftls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52bf4732fd51332632f4154bb45df13871320ceb/src%2Ftls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftls.rs?ref=52bf4732fd51332632f4154bb45df13871320ceb", "patch": "@@ -30,38 +30,38 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> MemoryExt<'tcx> for Memory<'a, 'mir, 'tcx, Evalu\n             },\n         );\n         trace!(\"New TLS key allocated: {} with dtor {:?}\", new_key, dtor);\n-        return new_key;\n+        new_key\n     }\n \n     fn delete_tls_key(&mut self, key: TlsKey) -> EvalResult<'tcx> {\n-        return match self.data.thread_local.remove(&key) {\n+        match self.data.thread_local.remove(&key) {\n             Some(_) => {\n                 trace!(\"TLS key {} removed\", key);\n                 Ok(())\n             }\n             None => err!(TlsOutOfBounds),\n-        };\n+        }\n     }\n \n     fn load_tls(&mut self, key: TlsKey) -> EvalResult<'tcx, Scalar> {\n-        return match self.data.thread_local.get(&key) {\n+        match self.data.thread_local.get(&key) {\n             Some(&TlsEntry { data, .. }) => {\n                 trace!(\"TLS key {} loaded: {:?}\", key, data);\n                 Ok(data)\n             }\n             None => err!(TlsOutOfBounds),\n-        };\n+        }\n     }\n \n     fn store_tls(&mut self, key: TlsKey, new_data: Scalar) -> EvalResult<'tcx> {\n-        return match self.data.thread_local.get_mut(&key) {\n+        match self.data.thread_local.get_mut(&key) {\n             Some(&mut TlsEntry { ref mut data, .. }) => {\n                 trace!(\"TLS key {} stored: {:?}\", key, new_data);\n                 *data = new_data;\n                 Ok(())\n             }\n             None => err!(TlsOutOfBounds),\n-        };\n+        }\n     }\n \n     /// Returns a dtor, its argument and its index, if one is supposed to run\n@@ -104,7 +104,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> MemoryExt<'tcx> for Memory<'a, 'mir, 'tcx, Evalu\n                 }\n             }\n         }\n-        return Ok(None);\n+        Ok(None)\n     }\n }\n \n@@ -124,8 +124,8 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx> for EvalContext<'a, 'mir, '\n                 Place::undef(),\n                 StackPopCleanup::None,\n             )?;\n-            let arg_local = self.frame().mir.args_iter().next().ok_or(\n-                EvalErrorKind::AbiViolation(\"TLS dtor does not take enough arguments.\".to_owned()),\n+            let arg_local = self.frame().mir.args_iter().next().ok_or_else(\n+                || EvalErrorKind::AbiViolation(\"TLS dtor does not take enough arguments.\".to_owned()),\n             )?;\n             let dest = self.eval_place(&mir::Place::Local(arg_local))?;\n             let ty = self.tcx.mk_mut_ptr(self.tcx.types.u8);"}, {"sha": "758fd5d274701c409415b8e42f1504a0978eaf8d", "filename": "src/validation.rs", "status": "modified", "additions": 11, "deletions": 15, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/52bf4732fd51332632f4154bb45df13871320ceb/src%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52bf4732fd51332632f4154bb45df13871320ceb/src%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvalidation.rs?ref=52bf4732fd51332632f4154bb45df13871320ceb", "patch": "@@ -135,10 +135,10 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx> for EvalContext<'a, 'mir, '\n     }\n \n     fn abstract_place(&self, place: &mir::Place<'tcx>) -> EvalResult<'tcx, AbsPlace<'tcx>> {\n-        Ok(match place {\n-            &mir::Place::Local(l) => AbsPlace::Local(l),\n-            &mir::Place::Static(ref s) => AbsPlace::Static(s.def_id),\n-            &mir::Place::Projection(ref p) =>\n+        Ok(match *place {\n+            mir::Place::Local(l) => AbsPlace::Local(l),\n+            mir::Place::Static(ref s) => AbsPlace::Static(s.def_id),\n+            mir::Place::Projection(ref p) =>\n                 AbsPlace::Projection(Box::new(self.abstract_place_projection(&*p)?)),\n         })\n     }\n@@ -378,11 +378,8 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx> for EvalContext<'a, 'mir, '\n         mut layout: ty::layout::TyLayout<'tcx>,\n         i: usize,\n     ) -> EvalResult<'tcx, Ty<'tcx>> {\n-        match base {\n-            Place::Ptr { extra: PlaceExtra::DowncastVariant(variant_index), .. } => {\n-                layout = layout.for_variant(&self, variant_index);\n-            }\n-            _ => {}\n+        if let Place::Ptr { extra: PlaceExtra::DowncastVariant(variant_index), .. } = base {\n+            layout = layout.for_variant(&self, variant_index);\n         }\n         let tcx = self.tcx.tcx;\n         Ok(match layout.ty.sty {\n@@ -667,12 +664,11 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx> for EvalContext<'a, 'mir, '\n                     // Inner lifetimes *outlive* outer ones, so only if we have no lifetime restriction yet,\n                     // we record the region of this borrow to the context.\n                     if query.re == None {\n-                        match *region {\n-                            ReScope(scope) => query.re = Some(scope),\n-                            // It is possible for us to encounter erased lifetimes here because the lifetimes in\n-                            // this functions' Subst will be erased.\n-                            _ => {}\n+                        if let ReScope(scope) = *region {\n+                            query.re = Some(scope);\n                         }\n+                        // It is possible for us to encounter erased lifetimes here because the lifetimes in\n+                        // this functions' Subst will be erased.\n                     }\n                     self.validate_ptr(val, query.place.0, pointee_ty, query.re, query.mutbl, mode)?;\n                 }\n@@ -772,7 +768,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx> for EvalContext<'a, 'mir, '\n                             let variant_idx = self.read_discriminant_as_variant_index(query.place.1, query.ty)?;\n                             let variant = &adt.variants[variant_idx];\n \n-                            if variant.fields.len() > 0 {\n+                            if !variant.fields.is_empty() {\n                                 // Downcast to this variant, if needed\n                                 let place = if adt.is_enum() {\n                                     ("}]}