{"sha": "4010788b3a0a7c2add7187c1e0021454c3331f25", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQwMTA3ODhiM2EwYTdjMmFkZDcxODdjMWUwMDIxNDU0YzMzMzFmMjU=", "commit": {"author": {"name": "Philipp Krones", "email": "uwdkn@student.kit.edu", "date": "2018-07-29T21:54:03Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-07-29T21:54:03Z"}, "message": "Merge pull request #2917 from mikerite/issue2894\n\nFix #2894", "tree": {"sha": "6d17baf1fce881cdf4d9765f13c1d759af6bdf81", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6d17baf1fce881cdf4d9765f13c1d759af6bdf81"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4010788b3a0a7c2add7187c1e0021454c3331f25", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJbXjd7CRBK7hj4Ov3rIwAAdHIIAEIhMxJwlOdLRkWr1rOh8Id+\nbrtLTthRaDL5FgZIBv01siAP6dWJx+CbZY0FLGiMhOCf6px2eFeBdlK9oZ8AHzvd\nZdoLx+7saFCIZgZUEWvSdR2urBem0SEaUQWcDgQh0A7dvwJGSC/2fANvgWFTJMwf\n+hRnnB9PRfhdXPJLt1waIoOJngjCW/KFjRCuAPeNVJMzdHaAslT4Jt76HAEnd8+u\ndWAckH1z8sCG4h0DmXomI8/oBvbxSm8H8M0rdiOiKAZV6EuOr1pYbx5N2MQ9faqE\nWWAzAP7dD+dp62B+sj3d5Am8KvVX4A/2D4PrGat/2KTCeNMSQmqzBUZYvJFtYw8=\n=yQGm\n-----END PGP SIGNATURE-----\n", "payload": "tree 6d17baf1fce881cdf4d9765f13c1d759af6bdf81\nparent 0aeb82cb674b4a78b41eb1cddf604d799da5e0f7\nparent d7ddb2abba435aae10d4357ae299876795749265\nauthor Philipp Krones <uwdkn@student.kit.edu> 1532901243 +0200\ncommitter GitHub <noreply@github.com> 1532901243 +0200\n\nMerge pull request #2917 from mikerite/issue2894\n\nFix #2894"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4010788b3a0a7c2add7187c1e0021454c3331f25", "html_url": "https://github.com/rust-lang/rust/commit/4010788b3a0a7c2add7187c1e0021454c3331f25", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4010788b3a0a7c2add7187c1e0021454c3331f25/comments", "author": {"login": "flip1995", "id": 9744647, "node_id": "MDQ6VXNlcjk3NDQ2NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/9744647?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flip1995", "html_url": "https://github.com/flip1995", "followers_url": "https://api.github.com/users/flip1995/followers", "following_url": "https://api.github.com/users/flip1995/following{/other_user}", "gists_url": "https://api.github.com/users/flip1995/gists{/gist_id}", "starred_url": "https://api.github.com/users/flip1995/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flip1995/subscriptions", "organizations_url": "https://api.github.com/users/flip1995/orgs", "repos_url": "https://api.github.com/users/flip1995/repos", "events_url": "https://api.github.com/users/flip1995/events{/privacy}", "received_events_url": "https://api.github.com/users/flip1995/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0aeb82cb674b4a78b41eb1cddf604d799da5e0f7", "url": "https://api.github.com/repos/rust-lang/rust/commits/0aeb82cb674b4a78b41eb1cddf604d799da5e0f7", "html_url": "https://github.com/rust-lang/rust/commit/0aeb82cb674b4a78b41eb1cddf604d799da5e0f7"}, {"sha": "d7ddb2abba435aae10d4357ae299876795749265", "url": "https://api.github.com/repos/rust-lang/rust/commits/d7ddb2abba435aae10d4357ae299876795749265", "html_url": "https://github.com/rust-lang/rust/commit/d7ddb2abba435aae10d4357ae299876795749265"}], "stats": {"total": 474, "additions": 355, "deletions": 119}, "files": [{"sha": "79da4c7d288d51afba0f642afa3a6c07a0f63dfb", "filename": "clippy_lints/src/use_self.rs", "status": "modified", "additions": 126, "deletions": 9, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/4010788b3a0a7c2add7187c1e0021454c3331f25/clippy_lints%2Fsrc%2Fuse_self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4010788b3a0a7c2add7187c1e0021454c3331f25/clippy_lints%2Fsrc%2Fuse_self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fuse_self.rs?ref=4010788b3a0a7c2add7187c1e0021454c3331f25", "patch": "@@ -1,9 +1,10 @@\n-use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n-use rustc::{declare_lint, lint_array};\n+use crate::utils::{in_macro, span_lint_and_sugg};\n use if_chain::if_chain;\n+use rustc::hir::intravisit::{walk_path, walk_ty, NestedVisitorMap, Visitor};\n use rustc::hir::*;\n-use rustc::hir::intravisit::{walk_path, NestedVisitorMap, Visitor};\n-use crate::utils::{in_macro, span_lint_and_then};\n+use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n+use rustc::ty;\n+use rustc::{declare_lint, lint_array};\n use syntax::ast::NodeId;\n use syntax_pos::symbol::keywords::SelfType;\n \n@@ -51,6 +52,105 @@ impl LintPass for UseSelf {\n \n const SEGMENTS_MSG: &str = \"segments should be composed of at least 1 element\";\n \n+fn span_use_self_lint(cx: &LateContext<'_, '_>, path: &Path) {\n+    span_lint_and_sugg(\n+        cx,\n+        USE_SELF,\n+        path.span,\n+        \"unnecessary structure name repetition\",\n+        \"use the applicable keyword\",\n+        \"Self\".to_owned(),\n+    );\n+}\n+\n+struct TraitImplTyVisitor<'a, 'tcx: 'a> {\n+    item_path: &'a Path,\n+    cx: &'a LateContext<'a, 'tcx>,\n+    trait_type_walker: ty::walk::TypeWalker<'tcx>,\n+    impl_type_walker: ty::walk::TypeWalker<'tcx>,\n+}\n+\n+impl<'a, 'tcx> Visitor<'tcx> for TraitImplTyVisitor<'a, 'tcx> {\n+    fn visit_ty(&mut self, t: &'tcx Ty) {\n+        let trait_ty = self.trait_type_walker.next();\n+        let impl_ty = self.impl_type_walker.next();\n+\n+        if let TyKind::Path(QPath::Resolved(_, path)) = &t.node {\n+            if self.item_path.def == path.def {\n+                let is_self_ty = if let def::Def::SelfTy(..) = path.def {\n+                    true\n+                } else {\n+                    false\n+                };\n+\n+                if !is_self_ty && impl_ty != trait_ty {\n+                    // The implementation and trait types don't match which means that\n+                    // the concrete type was specified by the implementation but\n+                    // it didn't use `Self`\n+                    span_use_self_lint(self.cx, path);\n+                }\n+            }\n+        }\n+        walk_ty(self, t)\n+    }\n+\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::None\n+    }\n+}\n+\n+fn check_trait_method_impl_decl<'a, 'tcx: 'a>(\n+    cx: &'a LateContext<'a, 'tcx>,\n+    item_path: &'a Path,\n+    impl_item: &ImplItem,\n+    impl_decl: &'tcx FnDecl,\n+    impl_trait_ref: &ty::TraitRef<'_>,\n+) {\n+    let trait_method = cx\n+        .tcx\n+        .associated_items(impl_trait_ref.def_id)\n+        .find(|assoc_item| {\n+            assoc_item.kind == ty::AssociatedKind::Method\n+                && cx\n+                    .tcx\n+                    .hygienic_eq(impl_item.ident, assoc_item.ident, impl_trait_ref.def_id)\n+        })\n+        .expect(\"impl method matches a trait method\");\n+\n+    let trait_method_sig = cx.tcx.fn_sig(trait_method.def_id);\n+    let trait_method_sig = cx.tcx.erase_late_bound_regions(&trait_method_sig);\n+\n+    let impl_method_def_id = cx.tcx.hir.local_def_id(impl_item.id);\n+    let impl_method_sig = cx.tcx.fn_sig(impl_method_def_id);\n+    let impl_method_sig = cx.tcx.erase_late_bound_regions(&impl_method_sig);\n+\n+    let output_ty = if let FunctionRetTy::Return(ty) = &impl_decl.output {\n+        Some(&**ty)\n+    } else {\n+        None\n+    };\n+\n+    // `impl_decl_ty` (of type `hir::Ty`) represents the type declared in the signature.\n+    // `impl_ty` (of type `ty:TyS`) is the concrete type that the compiler has determined for\n+    // that declaration.  We use `impl_decl_ty` to see if the type was declared as `Self`\n+    // and use `impl_ty` to check its concrete type.\n+    for (impl_decl_ty, (impl_ty, trait_ty)) in impl_decl.inputs.iter().chain(output_ty).zip(\n+        impl_method_sig\n+            .inputs_and_output\n+            .iter()\n+            .zip(trait_method_sig.inputs_and_output),\n+    ) {\n+        let mut visitor = TraitImplTyVisitor {\n+            cx,\n+            item_path,\n+            trait_type_walker: trait_ty.walk(),\n+            impl_type_walker: impl_ty.walk(),\n+        };\n+\n+        visitor.visit_ty(&impl_decl_ty);\n+    }\n+}\n+\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UseSelf {\n     fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx Item) {\n         if in_macro(item.span) {\n@@ -69,13 +169,32 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UseSelf {\n                 } else {\n                     true\n                 };\n+\n                 if should_check {\n                     let visitor = &mut UseSelfVisitor {\n                         item_path,\n                         cx,\n                     };\n-                    for impl_item_ref in refs {\n-                        visitor.visit_impl_item(cx.tcx.hir.impl_item(impl_item_ref.id));\n+                    let impl_def_id = cx.tcx.hir.local_def_id(item.id);\n+                    let impl_trait_ref = cx.tcx.impl_trait_ref(impl_def_id);\n+\n+                    if let Some(impl_trait_ref) = impl_trait_ref {\n+                        for impl_item_ref in refs {\n+                            let impl_item = cx.tcx.hir.impl_item(impl_item_ref.id);\n+                            if let ImplItemKind::Method(MethodSig{ decl: impl_decl, .. }, impl_body_id)\n+                                    = &impl_item.node {\n+                                check_trait_method_impl_decl(cx, item_path, impl_item, impl_decl, &impl_trait_ref);\n+                                let body = cx.tcx.hir.body(*impl_body_id);\n+                                visitor.visit_body(body);\n+                            } else {\n+                                visitor.visit_impl_item(impl_item);\n+                            }\n+                        }\n+                    } else {\n+                        for impl_item_ref in refs {\n+                            let impl_item = cx.tcx.hir.impl_item(impl_item_ref.id);\n+                            visitor.visit_impl_item(impl_item);\n+                        }\n                     }\n                 }\n             }\n@@ -91,9 +210,7 @@ struct UseSelfVisitor<'a, 'tcx: 'a> {\n impl<'a, 'tcx> Visitor<'tcx> for UseSelfVisitor<'a, 'tcx> {\n     fn visit_path(&mut self, path: &'tcx Path, _id: NodeId) {\n         if self.item_path.def == path.def && path.segments.last().expect(SEGMENTS_MSG).ident.name != SelfType.name() {\n-            span_lint_and_then(self.cx, USE_SELF, path.span, \"unnecessary structure name repetition\", |db| {\n-                db.span_suggestion(path.span, \"use the applicable keyword\", \"Self\".to_owned());\n-            });\n+            span_use_self_lint(self.cx, path);\n         }\n \n         walk_path(self, path);"}, {"sha": "7f0da364c7a35c8604230ae6e0079ae59bb919b3", "filename": "tests/ui/methods.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4010788b3a0a7c2add7187c1e0021454c3331f25/tests%2Fui%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4010788b3a0a7c2add7187c1e0021454c3331f25/tests%2Fui%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmethods.rs?ref=4010788b3a0a7c2add7187c1e0021454c3331f25", "patch": "@@ -4,7 +4,7 @@\n #![warn(clippy, clippy_pedantic, option_unwrap_used)]\n #![allow(blacklisted_name, unused, print_stdout, non_ascii_literal, new_without_default,\n     new_without_default_derive, missing_docs_in_private_items, needless_pass_by_value,\n-    default_trait_access)]\n+    default_trait_access, use_self)]\n \n use std::collections::BTreeMap;\n use std::collections::HashMap;"}, {"sha": "12665244b9d59488c434587c99e598ec3c83ae5a", "filename": "tests/ui/methods.stderr", "status": "modified", "additions": 1, "deletions": 93, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/4010788b3a0a7c2add7187c1e0021454c3331f25/tests%2Fui%2Fmethods.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4010788b3a0a7c2add7187c1e0021454c3331f25/tests%2Fui%2Fmethods.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmethods.stderr?ref=4010788b3a0a7c2add7187c1e0021454c3331f25", "patch": "@@ -1,47 +1,3 @@\n-error: unnecessary structure name repetition\n-  --> $DIR/methods.rs:21:29\n-   |\n-21 |     pub fn add(self, other: T) -> T { self }\n-   |                             ^ help: use the applicable keyword: `Self`\n-   |\n-   = note: `-D use-self` implied by `-D warnings`\n-\n-error: unnecessary structure name repetition\n-  --> $DIR/methods.rs:21:35\n-   |\n-21 |     pub fn add(self, other: T) -> T { self }\n-   |                                   ^ help: use the applicable keyword: `Self`\n-\n-error: unnecessary structure name repetition\n-  --> $DIR/methods.rs:25:25\n-   |\n-25 |     fn eq(&self, other: T) -> bool { true } // no error, private function\n-   |                         ^ help: use the applicable keyword: `Self`\n-\n-error: unnecessary structure name repetition\n-  --> $DIR/methods.rs:27:26\n-   |\n-27 |     fn sub(&self, other: T) -> &T { self } // no error, self is a ref\n-   |                          ^ help: use the applicable keyword: `Self`\n-\n-error: unnecessary structure name repetition\n-  --> $DIR/methods.rs:27:33\n-   |\n-27 |     fn sub(&self, other: T) -> &T { self } // no error, self is a ref\n-   |                                 ^ help: use the applicable keyword: `Self`\n-\n-error: unnecessary structure name repetition\n-  --> $DIR/methods.rs:28:21\n-   |\n-28 |     fn div(self) -> T { self } // no error, different #arguments\n-   |                     ^ help: use the applicable keyword: `Self`\n-\n-error: unnecessary structure name repetition\n-  --> $DIR/methods.rs:29:25\n-   |\n-29 |     fn rem(self, other: T) { } // no error, wrong return type\n-   |                         ^ help: use the applicable keyword: `Self`\n-\n error: defining a method called `add` on this type; consider implementing the `std::ops::Add` trait or choosing a less ambiguous name\n   --> $DIR/methods.rs:21:5\n    |\n@@ -78,30 +34,6 @@ error: methods called `new` usually return `Self`\n    |\n    = note: `-D new-ret-no-self` implied by `-D warnings`\n \n-error: unnecessary structure name repetition\n-  --> $DIR/methods.rs:80:24\n-   |\n-80 |     fn new() -> Option<V<T>> { None }\n-   |                        ^^^^ help: use the applicable keyword: `Self`\n-\n-error: unnecessary structure name repetition\n-  --> $DIR/methods.rs:84:19\n-   |\n-84 |     type Output = T;\n-   |                   ^ help: use the applicable keyword: `Self`\n-\n-error: unnecessary structure name repetition\n-  --> $DIR/methods.rs:85:25\n-   |\n-85 |     fn mul(self, other: T) -> T { self } // no error, obviously\n-   |                         ^ help: use the applicable keyword: `Self`\n-\n-error: unnecessary structure name repetition\n-  --> $DIR/methods.rs:85:31\n-   |\n-85 |     fn mul(self, other: T) -> T { self } // no error, obviously\n-   |                               ^ help: use the applicable keyword: `Self`\n-\n error: called `map(f).unwrap_or(a)` on an Option value. This can be done more directly by calling `map_or(a, f)` instead\n    --> $DIR/methods.rs:104:13\n     |\n@@ -251,24 +183,6 @@ error: called `map(f).unwrap_or_else(g)` on a Result value. This can be done mor\n 174 | |                 );\n     | |_________________^\n \n-error: unnecessary structure name repetition\n-   --> $DIR/methods.rs:200:24\n-    |\n-200 |     fn filter(self) -> IteratorFalsePositives {\n-    |                        ^^^^^^^^^^^^^^^^^^^^^^ help: use the applicable keyword: `Self`\n-\n-error: unnecessary structure name repetition\n-   --> $DIR/methods.rs:204:22\n-    |\n-204 |     fn next(self) -> IteratorFalsePositives {\n-    |                      ^^^^^^^^^^^^^^^^^^^^^^ help: use the applicable keyword: `Self`\n-\n-error: unnecessary structure name repetition\n-   --> $DIR/methods.rs:224:32\n-    |\n-224 |     fn skip(self, _: usize) -> IteratorFalsePositives {\n-    |                                ^^^^^^^^^^^^^^^^^^^^^^ help: use the applicable keyword: `Self`\n-\n error: called `filter(p).next()` on an `Iterator`. This is more succinctly expressed by calling `.find(p)` instead.\n    --> $DIR/methods.rs:234:13\n     |\n@@ -343,12 +257,6 @@ error: called `is_some()` after searching an `Iterator` with rposition. This is\n 276 | |                    ).is_some();\n     | |______________________________^\n \n-error: unnecessary structure name repetition\n-   --> $DIR/methods.rs:290:21\n-    |\n-290 |         fn new() -> Foo { Foo }\n-    |                     ^^^ help: use the applicable keyword: `Self`\n-\n error: use of `unwrap_or` followed by a function call\n    --> $DIR/methods.rs:308:22\n     |\n@@ -527,5 +435,5 @@ error: used unwrap() on an Option value. If you don't want to handle the None ca\n     |\n     = note: `-D option-unwrap-used` implied by `-D warnings`\n \n-error: aborting due to 70 previous errors\n+error: aborting due to 55 previous errors\n "}, {"sha": "689c9d68d1208aa7504f6f985f32ad4a7f0bc074", "filename": "tests/ui/use_self.rs", "status": "modified", "additions": 130, "deletions": 3, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/4010788b3a0a7c2add7187c1e0021454c3331f25/tests%2Fui%2Fuse_self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4010788b3a0a7c2add7187c1e0021454c3331f25/tests%2Fui%2Fuse_self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fuse_self.rs?ref=4010788b3a0a7c2add7187c1e0021454c3331f25", "patch": "@@ -1,10 +1,7 @@\n-\n-\n #![warn(use_self)]\n #![allow(dead_code)]\n #![allow(should_implement_trait)]\n \n-\n fn main() {}\n \n mod use_self {\n@@ -66,3 +63,133 @@ mod lifetimes {\n         }\n     }\n }\n+\n+#[allow(boxed_local)]\n+mod traits {\n+\n+    use std::ops::Mul;\n+\n+    trait SelfTrait {\n+        fn refs(p1: &Self) -> &Self;\n+        fn ref_refs<'a>(p1: &'a &'a Self) -> &'a &'a Self;\n+        fn mut_refs(p1: &mut Self) -> &mut Self;\n+        fn nested(p1: Box<Self>, p2: (&u8, &Self));\n+        fn vals(r: Self) -> Self;\n+    }\n+\n+    #[derive(Default)]\n+    struct Bad;\n+\n+    impl SelfTrait for Bad {\n+        fn refs(p1: &Bad) -> &Bad {\n+            p1\n+        }\n+\n+        fn ref_refs<'a>(p1: &'a &'a Bad) -> &'a &'a Bad {\n+            p1\n+        }\n+\n+        fn mut_refs(p1: &mut Bad) -> &mut Bad {\n+            p1\n+        }\n+\n+        fn nested(_p1: Box<Bad>, _p2: (&u8, &Bad)) {\n+        }\n+\n+        fn vals(_: Bad) -> Bad {\n+            Bad::default()\n+        }\n+    }\n+\n+    impl Mul for Bad {\n+        type Output = Bad;\n+\n+        fn mul(self, rhs: Bad) -> Bad {\n+            rhs\n+        }\n+    }\n+\n+    #[derive(Default)]\n+    struct Good;\n+\n+    impl SelfTrait for Good {\n+        fn refs(p1: &Self) -> &Self {\n+            p1\n+        }\n+\n+        fn ref_refs<'a>(p1: &'a &'a Self) -> &'a &'a Self {\n+            p1\n+        }\n+\n+        fn mut_refs(p1: &mut Self) -> &mut Self {\n+            p1\n+        }\n+\n+        fn nested(_p1: Box<Self>, _p2: (&u8, &Self)) {\n+        }\n+\n+        fn vals(_: Self) -> Self {\n+            Self::default()\n+        }\n+    }\n+\n+    impl Mul for Good {\n+        type Output = Self;\n+\n+        fn mul(self, rhs: Self) -> Self {\n+            rhs\n+        }\n+    }\n+\n+    trait NameTrait {\n+        fn refs(p1: &u8) -> &u8;\n+        fn ref_refs<'a>(p1: &'a &'a u8) -> &'a &'a u8;\n+        fn mut_refs(p1: &mut u8) -> &mut u8;\n+        fn nested(p1: Box<u8>, p2: (&u8, &u8));\n+        fn vals(p1: u8) -> u8;\n+    }\n+\n+    // Using `Self` instead of the type name is OK\n+    impl NameTrait for u8 {\n+        fn refs(p1: &Self) -> &Self {\n+            p1\n+        }\n+\n+        fn ref_refs<'a>(p1: &'a &'a Self) -> &'a &'a Self {\n+            p1\n+        }\n+\n+        fn mut_refs(p1: &mut Self) -> &mut Self {\n+            p1\n+        }\n+\n+        fn nested(_p1: Box<Self>, _p2: (&Self, &Self)) {\n+        }\n+\n+        fn vals(_: Self) -> Self {\n+            Self::default()\n+        }\n+    }\n+\n+    // Check that self arg isn't linted\n+    impl Clone for Good {\n+        fn clone(&self) -> Self {\n+            // Note: Not linted and it wouldn't be valid\n+            // because \"can't use `Self` as a constructor`\"\n+            Good\n+        }\n+    }\n+}\n+\n+mod issue2894 {\n+    trait IntoBytes {\n+        fn into_bytes(&self) -> Vec<u8>;\n+    }\n+\n+    // This should not be linted\n+    impl IntoBytes for u8 {\n+        fn into_bytes(&self) -> Vec<u8> {\n+            vec![*self]\n+        }\n+    }\n+}"}, {"sha": "899361012524f94e5550ad082c2ab033276b6c08", "filename": "tests/ui/use_self.stderr", "status": "modified", "additions": 97, "deletions": 13, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/4010788b3a0a7c2add7187c1e0021454c3331f25/tests%2Fui%2Fuse_self.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4010788b3a0a7c2add7187c1e0021454c3331f25/tests%2Fui%2Fuse_self.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fuse_self.stderr?ref=4010788b3a0a7c2add7187c1e0021454c3331f25", "patch": "@@ -1,40 +1,124 @@\n error: unnecessary structure name repetition\n-  --> $DIR/use_self.rs:14:21\n+  --> $DIR/use_self.rs:11:21\n    |\n-14 |         fn new() -> Foo {\n+11 |         fn new() -> Foo {\n    |                     ^^^ help: use the applicable keyword: `Self`\n    |\n    = note: `-D use-self` implied by `-D warnings`\n \n error: unnecessary structure name repetition\n-  --> $DIR/use_self.rs:15:13\n+  --> $DIR/use_self.rs:12:13\n    |\n-15 |             Foo {}\n+12 |             Foo {}\n    |             ^^^ help: use the applicable keyword: `Self`\n \n error: unnecessary structure name repetition\n-  --> $DIR/use_self.rs:17:22\n+  --> $DIR/use_self.rs:14:22\n    |\n-17 |         fn test() -> Foo {\n+14 |         fn test() -> Foo {\n    |                      ^^^ help: use the applicable keyword: `Self`\n \n error: unnecessary structure name repetition\n-  --> $DIR/use_self.rs:18:13\n+  --> $DIR/use_self.rs:15:13\n    |\n-18 |             Foo::new()\n+15 |             Foo::new()\n    |             ^^^^^^^^ help: use the applicable keyword: `Self`\n \n error: unnecessary structure name repetition\n-  --> $DIR/use_self.rs:23:25\n+  --> $DIR/use_self.rs:20:25\n    |\n-23 |         fn default() -> Foo {\n+20 |         fn default() -> Foo {\n    |                         ^^^ help: use the applicable keyword: `Self`\n \n error: unnecessary structure name repetition\n-  --> $DIR/use_self.rs:24:13\n+  --> $DIR/use_self.rs:21:13\n    |\n-24 |             Foo::new()\n+21 |             Foo::new()\n    |             ^^^^^^^^ help: use the applicable keyword: `Self`\n \n-error: aborting due to 6 previous errors\n+error: unnecessary structure name repetition\n+  --> $DIR/use_self.rs:84:22\n+   |\n+84 |         fn refs(p1: &Bad) -> &Bad {\n+   |                      ^^^ help: use the applicable keyword: `Self`\n+\n+error: unnecessary structure name repetition\n+  --> $DIR/use_self.rs:84:31\n+   |\n+84 |         fn refs(p1: &Bad) -> &Bad {\n+   |                               ^^^ help: use the applicable keyword: `Self`\n+\n+error: unnecessary structure name repetition\n+  --> $DIR/use_self.rs:88:37\n+   |\n+88 |         fn ref_refs<'a>(p1: &'a &'a Bad) -> &'a &'a Bad {\n+   |                                     ^^^ help: use the applicable keyword: `Self`\n+\n+error: unnecessary structure name repetition\n+  --> $DIR/use_self.rs:88:53\n+   |\n+88 |         fn ref_refs<'a>(p1: &'a &'a Bad) -> &'a &'a Bad {\n+   |                                                     ^^^ help: use the applicable keyword: `Self`\n+\n+error: unnecessary structure name repetition\n+  --> $DIR/use_self.rs:92:30\n+   |\n+92 |         fn mut_refs(p1: &mut Bad) -> &mut Bad {\n+   |                              ^^^ help: use the applicable keyword: `Self`\n+\n+error: unnecessary structure name repetition\n+  --> $DIR/use_self.rs:92:43\n+   |\n+92 |         fn mut_refs(p1: &mut Bad) -> &mut Bad {\n+   |                                           ^^^ help: use the applicable keyword: `Self`\n+\n+error: unnecessary structure name repetition\n+  --> $DIR/use_self.rs:96:28\n+   |\n+96 |         fn nested(_p1: Box<Bad>, _p2: (&u8, &Bad)) {\n+   |                            ^^^ help: use the applicable keyword: `Self`\n+\n+error: unnecessary structure name repetition\n+  --> $DIR/use_self.rs:96:46\n+   |\n+96 |         fn nested(_p1: Box<Bad>, _p2: (&u8, &Bad)) {\n+   |                                              ^^^ help: use the applicable keyword: `Self`\n+\n+error: unnecessary structure name repetition\n+  --> $DIR/use_self.rs:99:20\n+   |\n+99 |         fn vals(_: Bad) -> Bad {\n+   |                    ^^^ help: use the applicable keyword: `Self`\n+\n+error: unnecessary structure name repetition\n+  --> $DIR/use_self.rs:99:28\n+   |\n+99 |         fn vals(_: Bad) -> Bad {\n+   |                            ^^^ help: use the applicable keyword: `Self`\n+\n+error: unnecessary structure name repetition\n+   --> $DIR/use_self.rs:100:13\n+    |\n+100 |             Bad::default()\n+    |             ^^^^^^^^^^^^ help: use the applicable keyword: `Self`\n+\n+error: unnecessary structure name repetition\n+   --> $DIR/use_self.rs:105:23\n+    |\n+105 |         type Output = Bad;\n+    |                       ^^^ help: use the applicable keyword: `Self`\n+\n+error: unnecessary structure name repetition\n+   --> $DIR/use_self.rs:107:27\n+    |\n+107 |         fn mul(self, rhs: Bad) -> Bad {\n+    |                           ^^^ help: use the applicable keyword: `Self`\n+\n+error: unnecessary structure name repetition\n+   --> $DIR/use_self.rs:107:35\n+    |\n+107 |         fn mul(self, rhs: Bad) -> Bad {\n+    |                                   ^^^ help: use the applicable keyword: `Self`\n+\n+error: aborting due to 20 previous errors\n "}]}