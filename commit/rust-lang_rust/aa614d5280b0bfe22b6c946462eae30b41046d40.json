{"sha": "aa614d5280b0bfe22b6c946462eae30b41046d40", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFhNjE0ZDUyODBiMGJmZTIyYjZjOTQ2NDYyZWFlMzBiNDEwNDZkNDA=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-07-01T08:13:42Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-07-01T08:13:42Z"}, "message": "Modify manual to reflect new box/local terminology and new slot/type roles for box and mutable.", "tree": {"sha": "19d61444dee01ac795162898e2bb70665de3fb25", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/19d61444dee01ac795162898e2bb70665de3fb25"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/aa614d5280b0bfe22b6c946462eae30b41046d40", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/aa614d5280b0bfe22b6c946462eae30b41046d40", "html_url": "https://github.com/rust-lang/rust/commit/aa614d5280b0bfe22b6c946462eae30b41046d40", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/aa614d5280b0bfe22b6c946462eae30b41046d40/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6a0b06e56287f1de7ff096ed79fbf86e1e527290", "url": "https://api.github.com/repos/rust-lang/rust/commits/6a0b06e56287f1de7ff096ed79fbf86e1e527290", "html_url": "https://github.com/rust-lang/rust/commit/6a0b06e56287f1de7ff096ed79fbf86e1e527290"}], "stats": {"total": 494, "additions": 262, "deletions": 232}, "files": [{"sha": "659f1389812fa18c0a08e2afb9cce0a32f570d7f", "filename": "doc/rust.texi", "status": "modified", "additions": 262, "deletions": 232, "changes": 494, "blob_url": "https://github.com/rust-lang/rust/blob/aa614d5280b0bfe22b6c946462eae30b41046d40/doc%2Frust.texi", "raw_url": "https://github.com/rust-lang/rust/raw/aa614d5280b0bfe22b6c946462eae30b41046d40/doc%2Frust.texi", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.texi?ref=aa614d5280b0bfe22b6c946462eae30b41046d40", "patch": "@@ -223,6 +223,67 @@ Unlike many languages, individual modules do @emph{not} carry all the\n mechanisms or restrictions of crates. Modules and crates serve different\n roles.\n \n+@sp 1\n+@item Static control over memory allocation, packing and aliasing.\n+\n+Many values in Rust are allocated @emph{within} their containing stack-frame\n+or parent strucure. Numbers, records, tuples and tags are all allocated this\n+way. To allocate such values in the heap, they must be explicitly\n+@emph{boxed}. A @dfn{box} is a pointer to a heap allocation that holds another\n+value, its @emph{content}. If the content of a box is a @emph{state} value --\n+the sort that may contain mutable members -- then the heap allocation is also\n+subject to garbage collection.\n+\n+Boxing and unboxing in Rust is explicit, though in many cases (arithmetic\n+operations, name-component dereferencing) Rust will automatically ``reach\n+through'' the box to access its content. Box values can be passed and assigned\n+independently, like pointers in C; the difference is that in Rust they always\n+point to live contents, and are not subject to pointer arithmetic.\n+\n+In addition to boxes, Rust supports a kind of pass-by-reference slot called an\n+alias. Forming or releasing an alias does not perform reference-count\n+operations; aliases can only be formed on referents that will provably outlive\n+the alias, and are therefore only used for passing arguments to\n+functions. Aliases are not ``general values'', in the sense that they cannot\n+be independently manipulated. They are more like C++ references, except that\n+like boxes, aliases are safe: they always point to live values.\n+\n+In addition, each slot (stack-local allocation or alias) has a static\n+initialization state that is calculated by the typestate system. This permits\n+late initialization of slotsx in functions with complex control-flow, while\n+still guaranteeing that every use of a slot occurs after it has been\n+initialized.\n+\n+@sp 1\n+@item Static control over mutability.\n+\n+Types in Rust are classified as either immutable or mutable. By default,\n+all types are immutable.\n+\n+If a type is declared as @code{mutable}, then the type is a @code{state} type\n+and must be declared as such. Any type directly marked as @code{mutable}\n+@emph{or indirectly containing} a state type is also a state type.\n+\n+This classification of data types in Rust interacts with the memory allocation\n+and transmission rules. In particular:\n+\n+@itemize\n+@item Only immutable (non-state) values can be sent over channels.\n+@item Only immutable (non-state) objects can have destructor functions.\n+@end itemize\n+\n+Boxed state values are subject to local (per-task) garbage-collection. Garbage\n+collection costs are therefore also task-local and do not interrupt or suspend\n+other tasks.\n+\n+Boxed immutable values are reference-counted and have a deterministic\n+destruction order: top-down, immediately upon release of the last live\n+reference.\n+\n+State values can refer to immutable values, but not vice-versa. Rust therefore\n+encourages the programmer to write in a style that consists primarily of\n+immutable types, but also permits limited, local (per-task) mutability.\n+\n @sp 1\n @item Stack-based iterators\n \n@@ -284,9 +345,9 @@ destructors.\n @sp 1\n @item Dynamic type\n \n-Rust includes support for slots of a top type, @code{any}, that can hold any\n-type of value whatsoever. An @code{any} slot is a pair of a type code and an\n-exterior value of that type. Injection into an @code{any} and projection by\n+Rust includes support for values of a top type, @code{any}, that can hold any\n+type of value whatsoever. An @code{any} value is a pair of a type code and a\n+boxed value of that type. Injection into an @code{any} and projection by\n type-case-selection is integrated into the language.\n \n @sp 1\n@@ -331,100 +392,41 @@ and/or objects are otherwise freed from data structures holding them. The same\n destructors are run in the same order whether the object is deleted by\n unwinding during failure or normal execution.\n \n-Similarly, the rules for freeing immutable memory are deterministic and\n-predictable: on scope-exit or structure-release, interior slots are released\n-immediately, exterior slots have their reference count decreased and are\n-released if the count drops to zero. Alias slots are not affected by scope\n-exit.\n-\n-Mutable memory is local to a task, and is subject to per-task garbage\n-collection. As a result, unreferenced mutable memory is not necessarily freed\n-immediately; if it is acyclic it is freed when the last reference to it drops,\n-but if it is part of a reference cycle it will be freed when the GC collects\n-it (or when the owning task terminates, at the latest).\n-\n-Mutable memory can point to immutable memory but not vice-versa. Doing so\n-merely delays (to an undefined future time) the moment when the deterministic,\n-top-down destruction sequence for the referenced immutable memory\n-@emph{starts}. In other words, the immutable ``leaves'' of a mutable structure\n-are released in a locally-predictable order, even if the ``interior'' of the\n-mutable structure is released in an unpredictable order.\n+Similarly, the rules for freeing immutable values are deterministic and\n+predictable: on scope-exit or structure-release, local slots are released\n+immediately. Referenced boxes have their reference count decreased and are\n+released if the count drops to zero. Aliases are silently forgotten.\n+\n+State values are local to a task, and are subject to per-task garbage\n+collection. As a result, unreferenced state boxes are not necessarily freed\n+immediately; if an unreferenced state box is part of an acyclic graph, it is\n+freed when the last reference to it drops, but if it is part of a reference\n+cycle it will be freed when the GC collects it (or when the owning task\n+terminates, at the latest).\n+\n+State values can point to immutable values but not vice-versa. Doing so merely\n+delays (to an undefined future time) the moment when the deterministic,\n+top-down destruction sequence for the referenced immutable values\n+@emph{start}. In other words, the immutable ``leaves'' of a state value are\n+released in a locally-predictable order, even if the ``interior'' of the state\n+value is released in an unpredictable order.\n \n @sp 1\n @item Typestate system\n \n-Every storage slot in Rust participates in not only a conventional structural\n-static type system, describing the interpretation of memory in the slot, but\n-also a @emph{typestate} system. The static typestates of a program describe\n-the set of @emph{pure, dynamic predicates} that provably hold over some set of\n-slots, at each point in the program's control flow graph. The static\n-calculation of the typestates of a program is a dataflow problem, and handles\n-user-defined predicates in a similar fashion to the way the type system\n-permits user-defined types.\n+Every storage slot in a Rust frame participates in not only a conventional\n+structural static type system, describing the interpretation of memory in the\n+slot, but also a @emph{typestate} system. The static typestates of a program\n+describe the set of @emph{pure, dynamic predicates} that provably hold over\n+some set of slots, at each point in the program's control flow graph within\n+each frame. The static calculation of the typestates of a program is a\n+function-local dataflow problem, and handles user-defined predicates in a\n+similar fashion to the way the type system permits user-defined types.\n \n A short way of thinking of this is: types statically model the kinds of values\n held in slots, typestates statically model @emph{assertions that hold} before\n and after statements.\n \n-@sp 1\n-@item Static control over memory allocation, packing and aliasing.\n-\n-Every variable or field in Rust is a combination of a type, a mutability flag\n-and a @emph{mode}; this combination is called a @emph{slot}. There are 3 kinds\n-of @dfn{slot mode}, denoting 3 ways of referring to a value:\n-\n-@itemize\n-@item ``interior'' (slot contains value)\n-@item ``exterior'', (slot points to to managed heap allocation)\n-@item ``alias'', (slot points directly to provably-live address)\n-@end itemize\n-\n-Interior slots declared as variables in a function are allocated very quickly\n-on the stack, as part of a local activation frame, as in C or C++. Alias slots\n-permit efficient by-reference parameter passing without adjusting heap\n-reference counts or interacting with garbage collection, as alias lifetimes\n-are statically guaranteed to outlive callee lifetimes.\n-\n-Copying data between slots of different modes may cause either a simple\n-address assignment or reference-count adjustment, or may cause a value to be\n-``transplanted'': copied by value from the interior of one memory structure to\n-another, or between stack and heap. Transplanting, when necessary, is\n-predictable and automatic, as part of the definition of the copy operator\n-(@code{=}).\n-\n-In addition, slots have a static initialization state that is calculated by\n-the typestate system. This permits late initialization of variables in\n-functions with complex control-flow, while still guaranteeing that every use\n-of a slot occurs after it has been initialized.\n-\n-@sp 1\n-@item Static control over mutability.\n-\n-Slots in Rust are classified as either immutable or mutable. By default,\n-all slots are immutable.\n-\n-If a slot within a type is declared as @code{mutable}, the type is a\n-@code{state} type and must be declared as such.\n-\n-This classification of data types in Rust interacts with the memory allocation\n-and transmission rules. In particular:\n-\n-@itemize\n-@item Only immutable (non-state) values can be sent over channels.\n-@item Only immutable (non-state) objects can have destructor functions.\n-@end itemize\n-\n-State values are subject to local (per-task) garbage-collection. Garbage\n-collection costs are therefore also task-local and do not interrupt or suspend\n-other tasks.\n-\n-Immutable values are reference-counted and have a deterministic destruction\n-order: top-down, immediately upon release of the last live reference.\n-\n-State values can refer to immutable values, but not vice-versa. Rust therefore\n-encourages the programmer to write in a style that consists primarily of\n-immutable types, but also permits limited, local (per-task) mutability.\n-\n @end itemize\n \n \n@@ -817,9 +819,10 @@ Paths fall into two important categories: @emph{names} and\n A @dfn{name} denotes an item, and is statically resolved to its\n referent at compile time.\n \n-An @dfn{lval} denotes a slot, and is statically resolved to a sequence of\n-memory operations and primitive (arithmetic) expressions required to load or\n-store to the slot at compile time.\n+An @dfn{lval} denotes a slot or some component of a value held within a slot,\n+and is statically resolved at compile time to a sequence of memory operations\n+and primitive (arithmetic) expressions that will be executed to load or store\n+the associated value, starting from the task stack frame, at run time.\n \n In some contexts, the Rust grammar accepts a general @emph{path}, but a\n subsequent syntactic restriction requires the path to be an lval or a name. In\n@@ -1039,13 +1042,14 @@ A Rust task's memory consists of a static set of @emph{items}, a set of tasks\n each with its own @emph{stack}, and a @emph{heap}. Immutable portions of the\n heap may be shared between tasks, mutable portions may not.\n \n-Allocations in the stack and the heap consist of @emph{slots}.\n+Allocations in the stack consist of @emph{slots}, and allocations in the heap\n+consist of @emph{boxes}.\n \n @menu\n * Ref.Mem.Alloc::               Memory allocation model.\n * Ref.Mem.Own::                 Memory ownership model.\n-* Ref.Mem.Slot::                Memory containment and reference model.\n-* Ref.Mem.Init::                Initialization state of memory.\n+* Ref.Mem.Slot::                Stack memory model.\n+* Ref.Mem.Box::                 Heap memory model.\n * Ref.Mem.Acct::                Memory accounting model.\n @end menu\n \n@@ -1063,21 +1067,23 @@ A task's @dfn{stack} consists of activation frames automatically allocated on\n entry to each function as the task executes. A stack allocation is reclaimed\n when control leaves the frame containing it.\n \n-The @dfn{heap} is a general term that describes two separate sets of exterior\n-allocations: @emph{local heap} allocations and the @emph{shared heap}\n-allocations.\n+The @dfn{heap} is a general term that describes two separate sets of boxes:\n+@emph{task-local} state boxes and the @emph{shared} immutable boxes.\n \n-Exterior allocations of mutable types are @dfn{local heap} allocations,\n-owned by the task. Such @dfn{local allocations} cannot pass over channels and\n-do not outlive the task that owns them. When unreferenced, they are collected\n-using a general (cycle-aware) garbage-collector local to each task. Garbage\n-collection within a local heap does not interrupt execution of other tasks.\n+State boxes are @dfn{task-local}, owned by the task. Like any other state\n+value, they cannot pass over channels. State boxes do not outlive the task\n+that owns them. When unreferenced, they are collected using a general\n+(cycle-aware) garbage-collector local to each task. Garbage collection within\n+a local heap does not interrupt execution of other tasks.\n \n-Exterior allocations of immutable types are @dfn{shared heap} allocations,\n-and can be multiply-referenced by many different tasks. Such @dfn{shared\n-allocations} can pass over channels, and live as long as the last task\n-referencing them. When unreferenced, they are collected immediately using\n-reference-counting.\n+Immutable boxes are @dfn{shared}, and can be multiply-referenced by many\n+different tasks. Like any other immutable type, they can pass over channels,\n+and live as long as the last task referencing them within a given domain. When\n+unreferenced, they are destroyed immediately (due to reference-counting) and\n+returned to the heap memory allocator. Destruction of an immutable box also\n+executes within the context of task that drops the last reference to a shared\n+heap allocation, so executing a long-running destructor does not interrupt\n+execution of other tasks.\n \n \n \n@@ -1086,72 +1092,57 @@ reference-counting.\n @subsection Ref.Mem.Own\n @c * Ref.Mem.Own::                 Memory ownership model.\n \n-A task @emph{owns} all the interior allocations in its stack and @emph{local}\n-exterior allocations. A task @emph{shares} ownership of @emph{shared} exterior\n-allocations. A task does not own any items.\n+A task @emph{owns} all the @emph{stack-local} slot allocations in its stack\n+and @emph{task-local} boxes accessible from its stack. A task @emph{shares}\n+ownership of @emph{shared} boxes accessible from its stack. A task does not\n+own any items.\n \n @dfn{Ownership} of an allocation means that the owning task is the only task\n that can access the allocation.\n \n @dfn{Sharing} of an allocation means that the same allocation may be\n-concurrently referenced by multiple tasks. The only shared allocations are\n-those that are immutable.\n+concurrently read by multiple tasks. The only shared allocations are those\n+that are immutable.\n \n-When a stack frame is exited, its interior allocations are all released, and\n-its references to heap allocations (both shared and owned) are dropped.\n+When a stack frame is exited, its local allocations are all released, and its\n+references to boxes (both shared and owned) are dropped.\n \n-When a task finishes, its stack is necessarily empty. The task's interior\n-slots are released as the task itself is released, and its references to heap\n-allocations are dropped.\n+When a task finishes, its stack is necessarily empty and it therefore has no\n+references to any boxes.\n \n @page\n @node       Ref.Mem.Slot\n @subsection Ref.Mem.Slot\n-@c * Ref.Mem.Slot::                Memory containment and reference model.\n+@c * Ref.Mem.Slot::                Stack memory model.\n \n-A @dfn{slot} is a component of an allocation. A slot either holds a value or\n-the address of another allocation. Every slot has one of three possible\n-@emph{modes}.\n+A task's stack contains slots.\n \n-The possible @dfn{modes} of a slot are:\n+A @dfn{slot} is a component of a stack frame. A slot is either @emph{local} or\n+an @emph{alias}.\n \n-@itemize\n-@sp 1\n-@item @dfn{Interior mode}\n-\n-The slot holds the value of the slot.\n+A @dfn{local} slot (or @emph{stack-local} allocation) holds a value directly,\n+allocated within the stack's memory. The value is a part of the stack frame.\n \n-@sp 1\n-@item @dfn{Exterior mode}\n+An @dfn{alias} references a value outside the frame. An alias may refer to a\n+value allocated in another frame @emph{or} a boxed valaue in the heap. The\n+alias-formation rules ensure that the referent of an alias will outlive the\n+alias.\n \n-The slot holds the address of a heap allocation that holds the value of the\n-slot.\n+Local slots are always implicitly mutable.\n \n-Exterior slots are indicated by the @emph{at} sigil @code{@@}.\n+Local slots are not initialized when allocated; the entire frame worth of\n+local slots are allocated at once, on frame-entry, in an uninitialized\n+state. Subsequent statements within a function may or may not initialize the\n+local slots. Local slots can only be used after they have been initialized;\n+this condition is guaranteed by the typestate system.\n \n-For example, the following code allocates an exterior record, copies it by\n-counted-reference to a second exterior slot, then modifies the record through\n-the second exterior slot that points to the same exterior allocation.\n-@example\n-type point3d = rec(int x, int y, int z);\n-let @@point3d pt1 = rec(x=1, y=2, z=3);\n-let @@point3d pt2 = pt1;\n-pt2.z = 4;\n-@end example\n-\n-@sp 1\n-@item @dfn{Alias mode}\n-\n-The slot holds the address of a value. The referenced value may reside within\n-a stack allocation @emph{or} a heap allocation.\n-\n-Alias slots can @emph{only} be declared as members of a function or iterator\n-signature, bound to the lifetime of a stack frame. Alias slots cannot be\n-declared as members of general data types.\n+Aliases can @emph{only} be declared as arguments in a function or iterator\n+signature, bound to the lifetime of a stack frame. Aliases are not general\n+values and cannot be held in boxed allocations or other general data types.\n \n Alias slots are indicated by the @emph{ampersand} sigil @code{&}.\n \n-The following example function accepts a single read-only alias parameter:\n+An example function that accepts an alias parameter:\n @example\n type point3d = rec(int x, int y, int z);\n \n@@ -1160,28 +1151,68 @@ fn extract_z(&point3d p) -> int @{\n @}\n @end example\n \n-The following example function accepts a single mutable alias\n-parameter:\n+An example function that accepts an alias to a mutable value:\n @example\n-fn incr(mutable &int i) @{\n+fn incr(& mutable int i) @{\n     i = i + 1;\n @}\n @end example\n \n+@page\n+@node       Ref.Mem.Box\n+@subsection Ref.Mem.Box\n+@c * Ref.Mem.Box::                 Heap memory model.\n+\n+A @dfn{box} is a reference to a reference-counted heap allocation holding\n+another value.\n+\n+Box types and values are constructed by the @emph{at} sigil @code{@@}.\n+\n+An example of constructing a box type and value:\n+@example\n+let @@int x = @@10;\n+@end example\n+\n+Some operations implicitly dereference boxes. Examples of such @dfn{implicit\n+dereference} operations are:\n+@itemize\n+@item arithmetic operators (@code{x + y - z})\n+@item name-component selection (@code{x.y.z})\n @end itemize\n \n-@page\n-@node       Ref.Mem.Init\n-@subsection Ref.Mem.Init\n-@c * Ref.Mem.Init::                Initialization state of memory.\n+An example of an implicit-dereference operation performed on box values:\n+@example\n+let @@int x = @@10;\n+let @@int y = @@12;\n+check (x + y == 22);\n+@end example\n+\n+Other operations act on box values as single-word-sized address values,\n+automatically adjusting reference counts on the associated heap\n+allocation. For these operations, to access the value held in the box requires\n+an explicit dereference of the box value. Explicitly dereferencing a box is\n+indicated with the @emph{star} sigil @code{*}. Examples of such @dfn{explicit\n+dererence} operations are:\n+@itemize\n+@item copying box values (@code{x = y})\n+@item passing box values to functions (@code{f(x,y)})\n+@end itemize\n+\n+An example of an explicit-dereference operation performed on box values:\n+@example\n+fn takes_boxed(@@int b) @{\n+@}\n+\n+fn takes_unboxed(int b) @{\n+@}\n+\n+fn main() @{\n+    let @@int x = @@10;\n+    takes_boxed(x);\n+    takes_unboxed(*x);\n+@}\n+@end example\n \n-A slot is either initialized or uninitialized at every point in a program. An\n-@dfn{initialized} slot is one that holds a value. An @dfn{uninitialized} slot\n-is one that has not yet had a value written into it, or has had its value\n-deleted, and so holds undefined memory. The typestate system ensures that an\n-uninitialized slot cannot be read, but can be written to. A slot becomes\n-initialized in any statement that writes to it, and remains initialized until\n-explicitly destroyed or until its enclosing allocation is destroyed.\n \n @page\n @node       Ref.Mem.Acct\n@@ -1245,10 +1276,10 @@ messages. Ports receive messages from channels.\n A @dfn{channel} is a communication endpoint that can @emph{send}\n messages. Channels send messages to ports.\n \n-Each port has a unique identity and cannot be replicated. If a port value is\n-copied from one slot to another, both slots refer to the @emph{same} port,\n-even if the slots are declared as interior-mode. New ports can be constructed\n-dynamically and stored in data structures.\n+Each port is implicitly boxed and mutable; as such a port has has a unique\n+per-task identity and cannot be replicated or transmitted. If a port value is\n+copied, both copies refer to the @emph{same} port. New ports can be\n+constructed dynamically and stored in data structures.\n \n Each channel is bound to a port when the channel is constructed, so the\n destination port for a channel must exist before the channel itself. A channel\n@@ -1672,8 +1703,8 @@ Rust; they cannot be used as user-defined identifiers in any context.\n @subsection Ref.Type.Any\n \n The type @code{any} is the union of all possible Rust types. A value of type\n-@code{any} is represented in memory as a pair consisting of an exterior value\n-of some non-@code{any} type @var{T} and a reflection of the type @var{T}.\n+@code{any} is represented in memory as a pair consisting of a boxed value of\n+some non-@code{any} type @var{T} and a reflection of the type @var{T}.\n \n Values of type @code{any} can be used in an @code{alt type} statement, in\n which the reflection is used to select a block corresponding to a particular\n@@ -1754,10 +1785,10 @@ The primitive types are the following:\n @item\n The ``nil'' type @code{()}, having the single ``nil'' value\n @code{()}.@footnote{The ``nil'' value @code{()} is @emph{not} a sentinel\n-``null pointer'' value for alias or exterior slots; the ``nil'' type is the\n-implicit return type from functions otherwise lacking a return type, and can\n-be used in other contexts (such as message-sending or type-parametric code) as\n-a zero-byte type.}\n+``null pointer'' value for alias slots; the ``nil'' type is the implicit\n+return type from functions otherwise lacking a return type, and can be used in\n+other contexts (such as message-sending or type-parametric code) as a\n+zero-size type.}\n @item\n The boolean type @code{bool} with values @code{true} and @code{false}.\n @item\n@@ -1798,7 +1829,7 @@ A value of type @code{str} is a Unicode string, represented as a vector of\n @subsection Ref.Type.Rec\n \n The record type-constructor @code{rec} forms a new heterogeneous product of\n-slots.@footnote{The @code{rec} type-constructor is analogous to the\n+values.@footnote{The @code{rec} type-constructor is analogous to the\n @code{struct} type-constructor in the Algol/C family, the @emph{record} types\n of the ML family, or the @emph{structure} types of the Lisp family.} Fields of\n a @code{rec} type are accessed by name and are arranged in memory in the order\n@@ -1816,10 +1847,10 @@ let int px = p.x;\n @subsection Ref.Type.Tup\n \n The tuple type-constructor @code{tup} forms a new heterogeneous product of\n-slots exactly as the @code{rec} type-constructor does, with the difference\n-that tuple slots are automatically assigned implicit field names, given by\n+values exactly as the @code{rec} type-constructor does, with the difference\n+that tuple members are automatically assigned implicit field names, given by\n ascending integers prefixed by the underscore character: @code{_0}, @code{_1},\n-@code{_2}, etc. The fields of a tuple are laid out in memory contiguously,\n+@code{_2}, etc. The members of a tuple are laid out in memory contiguously,\n like a record, in order specified by the tuple type.\n \n An example of a tuple type and its use:\n@@ -1837,9 +1868,9 @@ check (p._1 == \"world\");\n @subsection Ref.Type.Vec\n \n The vector type-constructor @code{vec} represents a homogeneous array of\n-slots. A vector has a fixed size, and may or may not have mutable member\n-slots.  If the slots of a vector are mutable, the vector is a @emph{state}\n-type.\n+values of a given type. A vector has a fixed size. If the member-type of a\n+vector is a state type, then vector is a @emph{state} type, like any type\n+containing another type.\n \n Vectors can be sliced. A slice expression builds a new vector by copying a\n contiguous range -- given by a pair of indices representing a half-open\n@@ -1854,8 +1885,8 @@ let vec[int] v2 = v.(0,1); // Form a slice.\n \n Vectors always @emph{allocate} a storage region sufficient to store the first\n power of two worth of elements greater than or equal to the size of the\n-largest slice sharing the storage. This behaviour supports idiomatic in-place\n-``growth'' of a mutable slot holding a vector:\n+vector. This behaviour supports idiomatic in-place ``growth'' of a mutable\n+slot holding a vector:\n \n @example\n let mutable vec[int] v = vec(1, 2, 3);\n@@ -1888,8 +1919,8 @@ a @code{tag} type may refer to type definitions that include the defined\n @item Recursive types can only be introduced through @code{tag} types.\n @item A recursive @code{tag} type must have at least one non-recursive\n variant (in order to give the recursion a basis case).\n-@item The recursive slots of recursive variants must be @emph{exterior}\n-slots (in order to bound the in-memory size of the variant).\n+@item The recursively-typed members of recursive variants must be @emph{box}\n+values (in order to bound the in-memory size of the variant).\n @item Recursive type definitions can cross module boundaries, but not module\n @emph{visibility} boundaries, nor crate boundaries (in order to simplify the\n module system).\n@@ -2028,7 +2059,7 @@ Like ports, tasks are modeled as mutable native types with built-in meaning to\n the language. They cannot be transmitted over channels or otherwise\n replicated, and are always local to the task that spawns them.\n \n-If all references to a task are dropped (due to the release of any slots\n+If all references to a task are dropped (due to the release of any structure\n holding those references), the released task immediately fails.\n @xref{Ref.Task.Life}.\n \n@@ -2163,7 +2194,7 @@ actions.\n @menu\n * Ref.Stmt.Stat::               The static typestate system of statement analysis.\n * Ref.Stmt.Decl::               Statement declaring an item or slot.\n-* Ref.Stmt.Copy::               Statement for copying a value between two slots.\n+* Ref.Stmt.Copy::               Statement for copying a value.\n * Ref.Stmt.Spawn::              Statements for creating new tasks.\n * Ref.Stmt.Send::               Statements for sending a value into a channel.\n * Ref.Stmt.Flush::              Statement for flushing a channel queue.\n@@ -2198,7 +2229,7 @@ on a statement-by-statement basis, the @emph{effects} the statement has on its\n environment, as well the @emph{legality} of the statement in its environment.\n \n The legality of a statement is partly governed by syntactic rules, partly by\n-its conformance to the types of slots it affects, and partly by a\n+its conformance to the types of value it affects, and partly by a\n statement-oriented static dataflow analysis. This section describes the\n statement-oriented static dataflow analysis, also called the @emph{typestate}\n system.\n@@ -2427,42 +2458,44 @@ declaring a function-local item.\n A @code{slot declaration statement} has one one of two forms:\n \n @itemize\n-@item @code{let} @var{mode-and-type} @var{slot} @var{optional-init};\n+@item @code{let} @var{type} @var{slot} @var{optional-init};\n @item @code{auto} @var{slot} @var{optional-init};\n @end itemize\n \n-Where @var{mode-and-type} is a slot mode and type expression, @var{slot} is\n-the name of the slot being declared, and @var{optional-init} is either the\n-empty string or an equals sign (@code{=}) followed by a primitive expression.\n+Where @var{type} is a type expression, @var{slot} is the name of the slot\n+being declared, and @var{optional-init} is either the empty string or an\n+equals sign (@code{=}) followed by a primitive expression.\n \n Both forms introduce a new slot into the containing block scope. The new slot\n is visible across the entire scope, but is initialized only at the point\n following the declaration statement.\n \n The latter (@code{auto}) form of slot declaration causes the compiler to infer\n the static type of the slot through unification with the types of values\n-assigned to the slot in the the remaining code in the block scope. Inferred\n-slots always have @emph{interior} mode. @xref{Ref.Mem.Slot}.\n+assigned to the slot in the the remaining code in the block scope. Inference\n+only occurs on frame-local slots, not argument slots. Function, iterator and\n+object signatures must always declared types for all argument slots.\n+@xref{Ref.Mem.Slot}.\n \n \n \n @page\n @node       Ref.Stmt.Copy\n @subsection Ref.Stmt.Copy\n-@c * Ref.Stmt.Copy::                Statement for copying a value between two slots.\n+@c * Ref.Stmt.Copy::                Statement for copying a value.\n \n-A @dfn{copy statement} consists of an @emph{lval} -- a name denoting a slot --\n-followed by an equals-sign (@code{=}) and a primitive\n-expression. @xref{Ref.Expr}.\n+A @dfn{copy statement} consists of an @emph{lval} followed by an equals-sign\n+(@code{=}) and a primitive expression. @xref{Ref.Expr}.\n \n Executing a copy statement causes the value denoted by the expression --\n-either a value in a slot or a primitive combination of values held in slots --\n-to be copied into the slot denoted by the @emph{lval}.\n+either a value or a primitive combination of values -- to be copied into the\n+memory location denoted by the @emph{lval}.\n \n-A copy may entail the formation of references, the adjustment of reference\n-counts, execution of destructors, or similar adjustments in order to respect\n-the @code{lval} slot mode and any existing value held in it. All such\n-adjustment is automatic and implied by the @code{=} operator.\n+A copy may entail the the adjustment of reference counts, execution of\n+destructors, or similar adjustments in order to respect the path through the\n+memory graph implied by the @code{lval}, as well as any existing value held in\n+the memory being written-to. All such adjustment is automatic and implied by\n+the @code{=} operator.\n \n An example of three different copy statements:\n @example\n@@ -2483,8 +2516,8 @@ function.  The called function is referred to as the @dfn{entry function} for\n the spawned task, and its arguments are copied form the spawning task to the\n spawned task before the spawned task begins execution.\n \n-Only arguments of interior or exterior mode are permitted in the function\n-called by a spawn statement, not arguments with alias mode.\n+Functions taking alias-slot arguments, or returning non-nil values, cannot be\n+spawned. Iterators cannot be spawned.\n \n The result of a @code{spawn} statement is a @code{task} value.\n \n@@ -2561,8 +2594,8 @@ expression denoting a port, and applies the @emph{receive operator}\n @var{lval}. The statement causes the receiving task to enter the @emph{blocked\n reading} state until a task is sending a value to the port, at which point the\n runtime pseudo-randomly selects a sending task and copies a value from the\n-head of one of the task queues to the receiving slot, and un-blocks the\n-receiving task. @xref{Ref.Run.Comm}.\n+head of one of the task queues to the receiving location in memory, and\n+un-blocks the receiving task. @xref{Ref.Run.Comm}.\n \n An example of a @emph{receive}:\n @example\n@@ -2576,7 +2609,8 @@ let str s <- p;\n @c * Ref.Stmt.Call::               Statement for calling a function.\n \n A @dfn{call statement} invokes a function, providing a tuple of input slots\n-and a reference to an output slot. If the function eventually returns, then\n+and an alias slot to serve as the function's output, bound to the @var{lval}\n+on the right hand side of the call. If the function eventually returns, then\n the statement completes.\n \n A call statement statically requires that the precondition declared in the\n@@ -2596,7 +2630,7 @@ let int x = add(1, 2);\n A @dfn{bind statement} constructs a new function from an existing\n function.@footnote{The @code{bind} statement is analogous to the @code{bind}\n expression in the Sather language.} The new function has zero or more of its\n-arguments @emph{bound} into a new, hidden exterior tuple that holds the\n+arguments @emph{bound} into a new, hidden boxed tuple that holds the\n bindings. For each concrete argument passed in the @code{bind} statement, the\n corresponding parameter in the existing function is @emph{omitted} as a\n parameter of the new function. For each argument passed the placeholder symbol\n@@ -2624,11 +2658,9 @@ check (add(4,5) == add5(4));\n @end example\n \n A @code{bind} statement generally stores a copy of the bound arguments in the\n-hidden exterior tuple. For bound interior slots and alias slots in the bound\n-function signature, an interior slot is allocated in the hidden tuple and\n-populated with a copy of the bound value. For bound exterior slots in the\n-bound function signature, an exterior slot is allocated in the hidden tuple\n-and populated with a copy of the bound value, an exterior (pointer) value.\n+hidden, boxed tuple, owned by the resulting first-class function. For each\n+bound slot in the bound function's signature, space is allocated in the hidden\n+tuple and populated with a copy of the bound value.\n \n The @code{bind} statement is a lightweight mechanism for simulating the more\n elaborate construct of @emph{lexical closures} that exist in other\n@@ -2641,11 +2673,10 @@ of them can be achieved with @code{bind} statements.\n @subsection Ref.Stmt.Ret\n @c * Ref.Stmt.Ret::                Statement for stopping and producing a value.\n \n-Executing a @code{ret} statement@footnote{A @code{ret} statement is\n-analogous to a @code{return} statement in the C family.}  copies a\n-value into the return slot of the current function, destroys the\n-current function activation frame, and transfers control to the caller\n-frame.\n+Executing a @code{ret} statement@footnote{A @code{ret} statement is analogous\n+to a @code{return} statement in the C family.}  copies a value into the output\n+slot of the current function, destroys the current function activation frame,\n+and transfers control to the caller frame.\n \n An example of a @code{ret} statement:\n @example\n@@ -2692,7 +2723,7 @@ copy of itself.\n @subsection Ref.Stmt.Put\n @c * Ref.Stmt.Put::                Statement for pausing and producing a value.\n \n-Executing a @code{put} statement copies a value into the put slot of the\n+Executing a @code{put} statement copies a value into the output slot of the\n current iterator, suspends execution of the current iterator, and transfers\n control to the current put-recipient frame.\n \n@@ -2772,13 +2803,12 @@ In this example, if the task fails while attempting to open or read a file,\n the runtime will log the path name that was being read. If the function\n completes normally, the runtime will not log the path.\n \n-A slot that is marked by a @code{note} statement does @emph{not} have its\n-value copied aside when control passes through the @code{note}. In other\n-words, if a @code{note} statement notes a particular slot, and code after the\n-@code{note} that slot, and then a subsequent failure occurs, the\n-@emph{mutated} value will be logged during unwinding, @emph{not} the original\n-value that was held in the slot at the moment control passed through the\n-@code{note} statement.\n+A value that is marked by a @code{note} statement is @emph{not} copied aside\n+when control passes through the @code{note}. In other words, if a @code{note}\n+statement notes a particular @var{lval}, and code after the @code{note} that\n+slot, and then a subsequent failure occurs, the @emph{mutated} value will be\n+logged during unwinding, @emph{not} the original value that was denoted by the\n+@var{lval} at the moment control passed through the @code{note} statement.\n \n @page\n @node       Ref.Stmt.While\n@@ -3124,7 +3154,7 @@ if check even(x) @{\n The Rust @dfn{runtime} is a relatively compact collection of C and Rust code\n that provides fundamental services and datatypes to all Rust tasks at\n run-time. It is smaller and simpler than many modern language runtimes. It is\n-tightly integrated into the language's execution model of slots, tasks,\n+tightly integrated into the language's execution model of memory, tasks,\n communication, reflection, logging and signal handling.\n \n @menu\n@@ -3149,7 +3179,7 @@ of the C runtime functions @code{malloc} and @code{free}.\n \n The runtime memory-management system in turn supplies Rust tasks with\n facilities for allocating, extending and releasing stacks, as well as\n-allocating and freeing exterior values.\n+allocating and freeing boxed values.\n \n @page\n @node       Ref.Run.Type"}]}