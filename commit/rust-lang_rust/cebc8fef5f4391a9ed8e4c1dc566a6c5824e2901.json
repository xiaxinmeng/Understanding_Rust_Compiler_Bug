{"sha": "cebc8fef5f4391a9ed8e4c1dc566a6c5824e2901", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNlYmM4ZmVmNWY0MzkxYTllZDhlNGMxZGM1NjZhNmM1ODI0ZTI5MDE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-03-19T18:23:44Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-03-19T18:23:44Z"}, "message": "Auto merge of #82951 - sexxi-goose:wr-mir-replace-methods2, r=nikomatsakis\n\nReplace closures_captures and upvar_capture with closure_min_captures\n\nRemoved all uses of closures_captures and upvar_capture and refactored code to work with closure_min_captures. This also involved removing functions that were no longer needed like the bridge.\n\nCloses https://github.com/rust-lang/project-rfc-2229/issues/18\nr? `@nikomatsakis`", "tree": {"sha": "b4a728bb49f4d48f0787e1f9e32b3bd1d0f1c470", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b4a728bb49f4d48f0787e1f9e32b3bd1d0f1c470"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cebc8fef5f4391a9ed8e4c1dc566a6c5824e2901", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cebc8fef5f4391a9ed8e4c1dc566a6c5824e2901", "html_url": "https://github.com/rust-lang/rust/commit/cebc8fef5f4391a9ed8e4c1dc566a6c5824e2901", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cebc8fef5f4391a9ed8e4c1dc566a6c5824e2901/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9f4bc3ead43a57783d8abea2fa6931a6736f3490", "url": "https://api.github.com/repos/rust-lang/rust/commits/9f4bc3ead43a57783d8abea2fa6931a6736f3490", "html_url": "https://github.com/rust-lang/rust/commit/9f4bc3ead43a57783d8abea2fa6931a6736f3490"}, {"sha": "88db752e570f8fb57526cb13009da84a96aa11c6", "url": "https://api.github.com/repos/rust-lang/rust/commits/88db752e570f8fb57526cb13009da84a96aa11c6", "html_url": "https://github.com/rust-lang/rust/commit/88db752e570f8fb57526cb13009da84a96aa11c6"}], "stats": {"total": 720, "additions": 478, "deletions": 242}, "files": [{"sha": "c31a882c272a41e59a1c2e6062df01d5f6fcdefc", "filename": "compiler/rustc_middle/src/ty/closure.rs", "status": "modified", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/cebc8fef5f4391a9ed8e4c1dc566a6c5824e2901/compiler%2Frustc_middle%2Fsrc%2Fty%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cebc8fef5f4391a9ed8e4c1dc566a6c5824e2901/compiler%2Frustc_middle%2Fsrc%2Fty%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fclosure.rs?ref=cebc8fef5f4391a9ed8e4c1dc566a6c5824e2901", "patch": "@@ -168,6 +168,56 @@ impl CapturedPlace<'tcx> {\n             base => bug!(\"Expected upvar, found={:?}\", base),\n         }\n     }\n+\n+    /// Returns the `LocalDefId` of the closure that captureed this Place\n+    pub fn get_closure_local_def_id(&self) -> LocalDefId {\n+        match self.place.base {\n+            HirPlaceBase::Upvar(upvar_id) => upvar_id.closure_expr_id,\n+            base => bug!(\"expected upvar, found={:?}\", base),\n+        }\n+    }\n+\n+    /// Return span pointing to use that resulted in selecting the current capture kind\n+    pub fn get_capture_kind_span(&self, tcx: TyCtxt<'tcx>) -> Span {\n+        if let Some(capture_kind_expr_id) = self.info.capture_kind_expr_id {\n+            tcx.hir().span(capture_kind_expr_id)\n+        } else if let Some(path_expr_id) = self.info.path_expr_id {\n+            tcx.hir().span(path_expr_id)\n+        } else {\n+            // Fallback on upvars mentioned if neither path or capture expr id is captured\n+\n+            // Safe to unwrap since we know this place is captured by the closure, therefore the closure must have upvars.\n+            tcx.upvars_mentioned(self.get_closure_local_def_id()).unwrap()\n+                [&self.get_root_variable()]\n+                .span\n+        }\n+    }\n+}\n+\n+/// Return true if the `proj_possible_ancestor` represents an ancestor path\n+/// to `proj_capture` or `proj_possible_ancestor` is same as `proj_capture`,\n+/// assuming they both start off of the same root variable.\n+///\n+/// **Note:** It's the caller's responsibility to ensure that both lists of projections\n+///           start off of the same root variable.\n+///\n+/// Eg: 1. `foo.x` which is represented using `projections=[Field(x)]` is an ancestor of\n+///        `foo.x.y` which is represented using `projections=[Field(x), Field(y)]`.\n+///        Note both `foo.x` and `foo.x.y` start off of the same root variable `foo`.\n+///     2. Since we only look at the projections here function will return `bar.x` as an a valid\n+///        ancestor of `foo.x.y`. It's the caller's responsibility to ensure that both projections\n+///        list are being applied to the same root variable.\n+pub fn is_ancestor_or_same_capture(\n+    proj_possible_ancestor: &[HirProjectionKind],\n+    proj_capture: &[HirProjectionKind],\n+) -> bool {\n+    // We want to make sure `is_ancestor_or_same_capture(\"x.0.0\", \"x.0\")` to return false.\n+    // Therefore we can't just check if all projections are same in the zipped iterator below.\n+    if proj_possible_ancestor.len() > proj_capture.len() {\n+        return false;\n+    }\n+\n+    proj_possible_ancestor.iter().zip(proj_capture).all(|(a, b)| a == b)\n }\n \n /// Part of `MinCaptureInformationMap`; describes the capture kind (&, &mut, move)"}, {"sha": "41a8bc10c8de2424502bfa0fecffce7c2931eeaa", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 3, "deletions": 34, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/cebc8fef5f4391a9ed8e4c1dc566a6c5824e2901/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cebc8fef5f4391a9ed8e4c1dc566a6c5824e2901/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=cebc8fef5f4391a9ed8e4c1dc566a6c5824e2901", "patch": "@@ -30,9 +30,7 @@ use rustc_attr as attr;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::profiling::SelfProfilerRef;\n use rustc_data_structures::sharded::{IntoPointer, ShardedHashMap};\n-use rustc_data_structures::stable_hasher::{\n-    hash_stable_hashmap, HashStable, StableHasher, StableVec,\n-};\n+use rustc_data_structures::stable_hasher::{HashStable, StableHasher, StableVec};\n use rustc_data_structures::steal::Steal;\n use rustc_data_structures::sync::{self, Lock, Lrc, WorkerLocal};\n use rustc_errors::ErrorReported;\n@@ -386,9 +384,6 @@ pub struct TypeckResults<'tcx> {\n     /// <https://github.com/rust-lang/rfcs/blob/master/text/2005-match-ergonomics.md#definitions>\n     pat_adjustments: ItemLocalMap<Vec<Ty<'tcx>>>,\n \n-    /// Borrows\n-    pub upvar_capture_map: ty::UpvarCaptureMap<'tcx>,\n-\n     /// Records the reasons that we picked the kind of each closure;\n     /// not all closures are present in the map.\n     closure_kind_origins: ItemLocalMap<(Span, HirPlace<'tcx>)>,\n@@ -424,12 +419,6 @@ pub struct TypeckResults<'tcx> {\n     /// by this function.\n     pub concrete_opaque_types: FxHashMap<DefId, ResolvedOpaqueTy<'tcx>>,\n \n-    /// Given the closure ID this map provides the list of UpvarIDs used by it.\n-    /// The upvarID contains the HIR node ID and it also contains the full path\n-    /// leading to the member of the struct or tuple that is used instead of the\n-    /// entire variable.\n-    pub closure_captures: ty::UpvarListMap,\n-\n     /// Tracks the minimum captures required for a closure;\n     /// see `MinCaptureInformationMap` for more details.\n     pub closure_min_captures: ty::MinCaptureInformationMap<'tcx>,\n@@ -482,15 +471,13 @@ impl<'tcx> TypeckResults<'tcx> {\n             adjustments: Default::default(),\n             pat_binding_modes: Default::default(),\n             pat_adjustments: Default::default(),\n-            upvar_capture_map: Default::default(),\n             closure_kind_origins: Default::default(),\n             liberated_fn_sigs: Default::default(),\n             fru_field_types: Default::default(),\n             coercion_casts: Default::default(),\n             used_trait_imports: Lrc::new(Default::default()),\n             tainted_by_errors: None,\n             concrete_opaque_types: Default::default(),\n-            closure_captures: Default::default(),\n             closure_min_captures: Default::default(),\n             closure_fake_reads: Default::default(),\n             generator_interior_types: ty::Binder::dummy(Default::default()),\n@@ -675,10 +662,6 @@ impl<'tcx> TypeckResults<'tcx> {\n             .flatten()\n     }\n \n-    pub fn upvar_capture(&self, upvar_id: ty::UpvarId) -> ty::UpvarCapture<'tcx> {\n-        self.upvar_capture_map[&upvar_id]\n-    }\n-\n     pub fn closure_kind_origins(&self) -> LocalTableInContext<'_, (Span, HirPlace<'tcx>)> {\n         LocalTableInContext { hir_owner: self.hir_owner, data: &self.closure_kind_origins }\n     }\n@@ -732,24 +715,22 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for TypeckResults<'tcx> {\n             ref adjustments,\n             ref pat_binding_modes,\n             ref pat_adjustments,\n-            ref upvar_capture_map,\n             ref closure_kind_origins,\n             ref liberated_fn_sigs,\n             ref fru_field_types,\n-\n             ref coercion_casts,\n-\n             ref used_trait_imports,\n             tainted_by_errors,\n             ref concrete_opaque_types,\n-            ref closure_captures,\n             ref closure_min_captures,\n             ref closure_fake_reads,\n             ref generator_interior_types,\n             ref treat_byte_string_as_slice,\n         } = *self;\n \n         hcx.with_node_id_hashing_mode(NodeIdHashingMode::HashDefPath, |hcx| {\n+            hcx.local_def_path_hash(hir_owner);\n+\n             type_dependent_defs.hash_stable(hcx, hasher);\n             field_indices.hash_stable(hcx, hasher);\n             user_provided_types.hash_stable(hcx, hasher);\n@@ -759,17 +740,6 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for TypeckResults<'tcx> {\n             adjustments.hash_stable(hcx, hasher);\n             pat_binding_modes.hash_stable(hcx, hasher);\n             pat_adjustments.hash_stable(hcx, hasher);\n-            hash_stable_hashmap(hcx, hasher, upvar_capture_map, |up_var_id, hcx| {\n-                let ty::UpvarId { var_path, closure_expr_id } = *up_var_id;\n-\n-                assert_eq!(var_path.hir_id.owner, hir_owner);\n-\n-                (\n-                    hcx.local_def_path_hash(var_path.hir_id.owner),\n-                    var_path.hir_id.local_id,\n-                    hcx.local_def_path_hash(closure_expr_id),\n-                )\n-            });\n \n             closure_kind_origins.hash_stable(hcx, hasher);\n             liberated_fn_sigs.hash_stable(hcx, hasher);\n@@ -778,7 +748,6 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for TypeckResults<'tcx> {\n             used_trait_imports.hash_stable(hcx, hasher);\n             tainted_by_errors.hash_stable(hcx, hasher);\n             concrete_opaque_types.hash_stable(hcx, hasher);\n-            closure_captures.hash_stable(hcx, hasher);\n             closure_min_captures.hash_stable(hcx, hasher);\n             closure_fake_reads.hash_stable(hcx, hasher);\n             generator_interior_types.hash_stable(hcx, hasher);"}, {"sha": "ec561fa38580cc5e37ca3d3e5a86b87034d591b3", "filename": "compiler/rustc_mir/src/borrow_check/diagnostics/mod.rs", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/cebc8fef5f4391a9ed8e4c1dc566a6c5824e2901/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cebc8fef5f4391a9ed8e4c1dc566a6c5824e2901/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fmod.rs?ref=cebc8fef5f4391a9ed8e4c1dc566a6c5824e2901", "patch": "@@ -388,10 +388,14 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     // so it's safe to call `expect_local`.\n                     //\n                     // We know the field exists so it's safe to call operator[] and `unwrap` here.\n-                    let (&var_id, _) =\n-                        self.infcx.tcx.typeck(def_id.expect_local()).closure_captures[&def_id]\n-                            .get_index(field.index())\n-                            .unwrap();\n+                    let var_id = self\n+                        .infcx\n+                        .tcx\n+                        .typeck(def_id.expect_local())\n+                        .closure_min_captures_flattened(def_id)\n+                        .nth(field.index())\n+                        .unwrap()\n+                        .get_root_variable();\n \n                     self.infcx.tcx.hir().name(var_id).to_string()\n                 }\n@@ -966,35 +970,35 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         let expr = &self.infcx.tcx.hir().expect_expr(hir_id).kind;\n         debug!(\"closure_span: hir_id={:?} expr={:?}\", hir_id, expr);\n         if let hir::ExprKind::Closure(.., body_id, args_span, _) = expr {\n-            for (upvar_hir_id, place) in\n-                self.infcx.tcx.typeck(def_id.expect_local()).closure_captures[&def_id]\n-                    .keys()\n-                    .zip(places)\n+            for (captured_place, place) in self\n+                .infcx\n+                .tcx\n+                .typeck(def_id.expect_local())\n+                .closure_min_captures_flattened(def_id)\n+                .zip(places)\n             {\n-                let span = self.infcx.tcx.upvars_mentioned(local_did)?[upvar_hir_id].span;\n+                let upvar_hir_id = captured_place.get_root_variable();\n+                //FIXME(project-rfc-2229#8): Use better span from captured_place\n+                let span = self.infcx.tcx.upvars_mentioned(local_did)?[&upvar_hir_id].span;\n                 match place {\n                     Operand::Copy(place) | Operand::Move(place)\n                         if target_place == place.as_ref() =>\n                     {\n                         debug!(\"closure_span: found captured local {:?}\", place);\n                         let body = self.infcx.tcx.hir().body(*body_id);\n                         let generator_kind = body.generator_kind();\n-                        let upvar_id = ty::UpvarId {\n-                            var_path: ty::UpvarPath { hir_id: *upvar_hir_id },\n-                            closure_expr_id: local_did,\n-                        };\n \n                         // If we have a more specific span available, point to that.\n                         // We do this even though this span might be part of a borrow error\n                         // message rather than a move error message. Our goal is to point\n                         // to a span that shows why the upvar is used in the closure,\n                         // so a move-related span is as good as any (and potentially better,\n                         // if the overall error is due to a move of the upvar).\n-                        let usage_span =\n-                            match self.infcx.tcx.typeck(local_did).upvar_capture(upvar_id) {\n-                                ty::UpvarCapture::ByValue(Some(span)) => span,\n-                                _ => span,\n-                            };\n+\n+                        let usage_span = match captured_place.info.capture_kind {\n+                            ty::UpvarCapture::ByValue(Some(span)) => span,\n+                            _ => span,\n+                        };\n                         return Some((*args_span, generator_kind, usage_span));\n                     }\n                     _ => {}"}, {"sha": "28f6508cab2dadf449e32e0a5f3380b07a977a2c", "filename": "compiler/rustc_mir/src/borrow_check/diagnostics/mutability_errors.rs", "status": "modified", "additions": 46, "deletions": 16, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/cebc8fef5f4391a9ed8e4c1dc566a6c5824e2901/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cebc8fef5f4391a9ed8e4c1dc566a6c5824e2901/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs?ref=cebc8fef5f4391a9ed8e4c1dc566a6c5824e2901", "patch": "@@ -510,24 +510,54 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         the_place_err: PlaceRef<'tcx>,\n         err: &mut DiagnosticBuilder<'_>,\n     ) {\n-        let id = id.expect_local();\n-        let tables = tcx.typeck(id);\n-        let hir_id = tcx.hir().local_def_id_to_hir_id(id);\n-        if let Some((span, place)) = tables.closure_kind_origins().get(hir_id) {\n-            let reason = if let PlaceBase::Upvar(upvar_id) = place.base {\n-                let upvar = ty::place_to_string_for_capture(tcx, place);\n-                match tables.upvar_capture(upvar_id) {\n-                    ty::UpvarCapture::ByRef(ty::UpvarBorrow {\n-                        kind: ty::BorrowKind::MutBorrow | ty::BorrowKind::UniqueImmBorrow,\n-                        ..\n-                    }) => {\n-                        format!(\"mutable borrow of `{}`\", upvar)\n-                    }\n-                    ty::UpvarCapture::ByValue(_) => {\n-                        format!(\"possible mutation of `{}`\", upvar)\n+        let closure_local_def_id = id.expect_local();\n+        let tables = tcx.typeck(closure_local_def_id);\n+        let closure_hir_id = tcx.hir().local_def_id_to_hir_id(closure_local_def_id);\n+        if let Some((span, closure_kind_origin)) =\n+            &tables.closure_kind_origins().get(closure_hir_id)\n+        {\n+            let reason = if let PlaceBase::Upvar(upvar_id) = closure_kind_origin.base {\n+                let upvar = ty::place_to_string_for_capture(tcx, closure_kind_origin);\n+                let root_hir_id = upvar_id.var_path.hir_id;\n+                // we have a origin for this closure kind starting at this root variable so it's safe to unwrap here\n+                let captured_places = tables.closure_min_captures[id].get(&root_hir_id).unwrap();\n+\n+                let origin_projection = closure_kind_origin\n+                    .projections\n+                    .iter()\n+                    .map(|proj| proj.kind)\n+                    .collect::<Vec<_>>();\n+                let mut capture_reason = String::new();\n+                for captured_place in captured_places {\n+                    let captured_place_kinds = captured_place\n+                        .place\n+                        .projections\n+                        .iter()\n+                        .map(|proj| proj.kind)\n+                        .collect::<Vec<_>>();\n+                    if rustc_middle::ty::is_ancestor_or_same_capture(\n+                        &captured_place_kinds,\n+                        &origin_projection,\n+                    ) {\n+                        match captured_place.info.capture_kind {\n+                            ty::UpvarCapture::ByRef(ty::UpvarBorrow {\n+                                kind: ty::BorrowKind::MutBorrow | ty::BorrowKind::UniqueImmBorrow,\n+                                ..\n+                            }) => {\n+                                capture_reason = format!(\"mutable borrow of `{}`\", upvar);\n+                            }\n+                            ty::UpvarCapture::ByValue(_) => {\n+                                capture_reason = format!(\"possible mutation of `{}`\", upvar);\n+                            }\n+                            _ => bug!(\"upvar `{}` borrowed, but not mutably\", upvar),\n+                        }\n+                        break;\n                     }\n-                    val => bug!(\"upvar `{}` borrowed, but not mutably: {:?}\", upvar, val),\n                 }\n+                if capture_reason.is_empty() {\n+                    bug!(\"upvar `{}` borrowed, but cannot find reason\", upvar);\n+                }\n+                capture_reason\n             } else {\n                 bug!(\"not an upvar\")\n             };"}, {"sha": "062ef7d8b4cbf7aa0d1a731880bea54d5002782e", "filename": "compiler/rustc_mir/src/interpret/validity.rs", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/cebc8fef5f4391a9ed8e4c1dc566a6c5824e2901/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cebc8fef5f4391a9ed8e4c1dc566a6c5824e2901/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fvalidity.rs?ref=cebc8fef5f4391a9ed8e4c1dc566a6c5824e2901", "patch": "@@ -77,7 +77,7 @@ macro_rules! throw_validation_failure {\n ///\n macro_rules! try_validation {\n     ($e:expr, $where:expr,\n-     $( $( $p:pat )|+ => { $( $what_fmt:expr ),+ } $( expected { $( $expected_fmt:expr ),+ } )? ),+ $(,)?\n+    $( $( $p:pat )|+ => { $( $what_fmt:expr ),+ } $( expected { $( $expected_fmt:expr ),+ } )? ),+ $(,)?\n     ) => {{\n         match $e {\n             Ok(x) => x,\n@@ -244,17 +244,20 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n             // generators and closures.\n             ty::Closure(def_id, _) | ty::Generator(def_id, _, _) => {\n                 let mut name = None;\n-                if let Some(def_id) = def_id.as_local() {\n-                    let tables = self.ecx.tcx.typeck(def_id);\n-                    if let Some(upvars) = tables.closure_captures.get(&def_id.to_def_id()) {\n+                // FIXME this should be more descriptive i.e. CapturePlace instead of CapturedVar\n+                // https://github.com/rust-lang/project-rfc-2229/issues/46\n+                if let Some(local_def_id) = def_id.as_local() {\n+                    let tables = self.ecx.tcx.typeck(local_def_id);\n+                    if let Some(captured_place) =\n+                        tables.closure_min_captures_flattened(*def_id).nth(field)\n+                    {\n                         // Sometimes the index is beyond the number of upvars (seen\n                         // for a generator).\n-                        if let Some((&var_hir_id, _)) = upvars.get_index(field) {\n-                            let node = self.ecx.tcx.hir().get(var_hir_id);\n-                            if let hir::Node::Binding(pat) = node {\n-                                if let hir::PatKind::Binding(_, _, ident, _) = pat.kind {\n-                                    name = Some(ident.name);\n-                                }\n+                        let var_hir_id = captured_place.get_root_variable();\n+                        let node = self.ecx.tcx.hir().get(var_hir_id);\n+                        if let hir::Node::Binding(pat) = node {\n+                            if let hir::PatKind::Binding(_, _, ident, _) = pat.kind {\n+                                name = Some(ident.name);\n                             }\n                         }\n                     }"}, {"sha": "9f1de3349a56e04528233b20a7a981d64e75fc94", "filename": "compiler/rustc_mir_build/src/build/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cebc8fef5f4391a9ed8e4c1dc566a6c5824e2901/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cebc8fef5f4391a9ed8e4c1dc566a6c5824e2901/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs?ref=cebc8fef5f4391a9ed8e4c1dc566a6c5824e2901", "patch": "@@ -881,7 +881,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         let hir_typeck_results = self.typeck_results;\n \n         // In analyze_closure() in upvar.rs we gathered a list of upvars used by a\n-        // indexed closure and we stored in a map called closure_captures in TypeckResults\n+        // indexed closure and we stored in a map called closure_min_captures in TypeckResults\n         // with the closure's DefId. Here, we run through that vec of UpvarIds for\n         // the given closure and use the necessary information to create upvar\n         // debuginfo and to fill `self.upvar_mutbls`."}, {"sha": "9aef49df7b4ff4323345fe93100fcab24dc43de8", "filename": "compiler/rustc_passes/src/liveness.rs", "status": "modified", "additions": 54, "deletions": 55, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/cebc8fef5f4391a9ed8e4c1dc566a6c5824e2901/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cebc8fef5f4391a9ed8e4c1dc566a6c5824e2901/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs?ref=cebc8fef5f4391a9ed8e4c1dc566a6c5824e2901", "patch": "@@ -95,7 +95,7 @@ use rustc_hir::{Expr, HirId, HirIdMap, HirIdSet};\n use rustc_index::vec::IndexVec;\n use rustc_middle::hir::map::Map;\n use rustc_middle::ty::query::Providers;\n-use rustc_middle::ty::{self, DefIdTree, TyCtxt};\n+use rustc_middle::ty::{self, DefIdTree, RootVariableMinCaptureList, TyCtxt};\n use rustc_session::lint;\n use rustc_span::symbol::{kw, sym, Symbol};\n use rustc_span::Span;\n@@ -331,7 +331,7 @@ impl<'tcx> Visitor<'tcx> for IrMaps<'tcx> {\n             }\n         }\n \n-        if let Some(captures) = maps.tcx.typeck(local_def_id).closure_captures.get(&def_id) {\n+        if let Some(captures) = maps.tcx.typeck(local_def_id).closure_min_captures.get(&def_id) {\n             for &var_hir_id in captures.keys() {\n                 let var_name = maps.tcx.hir().name(var_hir_id);\n                 maps.add_variable(Upvar(var_hir_id, var_name));\n@@ -408,10 +408,10 @@ impl<'tcx> Visitor<'tcx> for IrMaps<'tcx> {\n                 if let Some(captures) = self\n                     .tcx\n                     .typeck(closure_def_id)\n-                    .closure_captures\n+                    .closure_min_captures\n                     .get(&closure_def_id.to_def_id())\n                 {\n-                    // If closure captures is Some, upvars_mentioned must also be Some\n+                    // If closure_min_captures is Some, upvars_mentioned must also be Some\n                     let upvars = self.tcx.upvars_mentioned(closure_def_id).unwrap();\n                     call_caps.extend(captures.keys().map(|var_id| {\n                         let upvar = upvars[var_id];\n@@ -481,11 +481,10 @@ const ACC_USE: u32 = 4;\n \n struct Liveness<'a, 'tcx> {\n     ir: &'a mut IrMaps<'tcx>,\n-    body_owner: LocalDefId,\n     typeck_results: &'a ty::TypeckResults<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     upvars: Option<&'tcx FxIndexMap<hir::HirId, hir::Upvar>>,\n-    closure_captures: Option<&'tcx FxIndexMap<hir::HirId, ty::UpvarId>>,\n+    closure_min_captures: Option<&'tcx RootVariableMinCaptureList<'tcx>>,\n     successors: IndexVec<LiveNode, Option<LiveNode>>,\n     rwu_table: rwu_table::RWUTable,\n \n@@ -509,8 +508,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         let typeck_results = ir.tcx.typeck(body_owner);\n         let param_env = ir.tcx.param_env(body_owner);\n         let upvars = ir.tcx.upvars_mentioned(body_owner);\n-        let closure_captures = typeck_results.closure_captures.get(&body_owner.to_def_id());\n-\n+        let closure_min_captures = typeck_results.closure_min_captures.get(&body_owner.to_def_id());\n         let closure_ln = ir.add_live_node(ClosureNode);\n         let exit_ln = ir.add_live_node(ExitNode);\n \n@@ -519,11 +517,10 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n         Liveness {\n             ir,\n-            body_owner,\n             typeck_results,\n             param_env,\n             upvars,\n-            closure_captures,\n+            closure_min_captures,\n             successors: IndexVec::from_elem_n(None, num_live_nodes),\n             rwu_table: rwu_table::RWUTable::new(num_live_nodes, num_vars),\n             closure_ln,\n@@ -707,25 +704,27 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         // if they are live on the entry to the closure, since only the closure\n         // itself can access them on subsequent calls.\n \n-        if let Some(closure_captures) = self.closure_captures {\n+        if let Some(closure_min_captures) = self.closure_min_captures {\n             // Mark upvars captured by reference as used after closure exits.\n-            // Since closure_captures is Some, upvars must exists too.\n-            let upvars = self.upvars.unwrap();\n-            for (&var_hir_id, upvar_id) in closure_captures {\n-                let upvar = upvars[&var_hir_id];\n-                match self.typeck_results.upvar_capture(*upvar_id) {\n-                    ty::UpvarCapture::ByRef(_) => {\n-                        let var = self.variable(var_hir_id, upvar.span);\n-                        self.acc(self.exit_ln, var, ACC_READ | ACC_USE);\n+            for (&var_hir_id, min_capture_list) in closure_min_captures {\n+                for captured_place in min_capture_list {\n+                    match captured_place.info.capture_kind {\n+                        ty::UpvarCapture::ByRef(_) => {\n+                            let var = self.variable(\n+                                var_hir_id,\n+                                captured_place.get_capture_kind_span(self.ir.tcx),\n+                            );\n+                            self.acc(self.exit_ln, var, ACC_READ | ACC_USE);\n+                        }\n+                        ty::UpvarCapture::ByValue(_) => {}\n                     }\n-                    ty::UpvarCapture::ByValue(_) => {}\n                 }\n             }\n         }\n \n         let succ = self.propagate_through_expr(&body.value, self.exit_ln);\n \n-        if self.closure_captures.is_none() {\n+        if self.closure_min_captures.is_none() {\n             // Either not a closure, or closure without any captured variables.\n             // No need to determine liveness of captured variables, since there\n             // are none.\n@@ -1221,7 +1220,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         match path.res {\n             Res::Local(hid) => {\n                 let in_upvars = self.upvars.map_or(false, |u| u.contains_key(&hid));\n-                let in_captures = self.closure_captures.map_or(false, |c| c.contains_key(&hid));\n+                let in_captures = self.closure_min_captures.map_or(false, |c| c.contains_key(&hid));\n \n                 match (in_upvars, in_captures) {\n                     (false, _) | (true, true) => self.access_var(hir_id, hid, succ, acc, path.span),\n@@ -1422,52 +1421,52 @@ impl<'tcx> Liveness<'_, 'tcx> {\n     }\n \n     fn warn_about_unused_upvars(&self, entry_ln: LiveNode) {\n-        let closure_captures = match self.closure_captures {\n+        let closure_min_captures = match self.closure_min_captures {\n             None => return,\n-            Some(closure_captures) => closure_captures,\n+            Some(closure_min_captures) => closure_min_captures,\n         };\n \n-        // If closure_captures is Some(), upvars must be Some() too.\n-        let upvars = self.upvars.unwrap();\n-        for &var_hir_id in closure_captures.keys() {\n-            let upvar = upvars[&var_hir_id];\n-            let var = self.variable(var_hir_id, upvar.span);\n-            let upvar_id = ty::UpvarId {\n-                var_path: ty::UpvarPath { hir_id: var_hir_id },\n-                closure_expr_id: self.body_owner,\n-            };\n-            match self.typeck_results.upvar_capture(upvar_id) {\n-                ty::UpvarCapture::ByValue(_) => {}\n-                ty::UpvarCapture::ByRef(..) => continue,\n-            };\n-            if self.used_on_entry(entry_ln, var) {\n-                if !self.live_on_entry(entry_ln, var) {\n+        // If closure_min_captures is Some(), upvars must be Some() too.\n+        for (&var_hir_id, min_capture_list) in closure_min_captures {\n+            for captured_place in min_capture_list {\n+                match captured_place.info.capture_kind {\n+                    ty::UpvarCapture::ByValue(_) => {}\n+                    ty::UpvarCapture::ByRef(..) => continue,\n+                };\n+                let span = captured_place.get_capture_kind_span(self.ir.tcx);\n+                let var = self.variable(var_hir_id, span);\n+                if self.used_on_entry(entry_ln, var) {\n+                    if !self.live_on_entry(entry_ln, var) {\n+                        if let Some(name) = self.should_warn(var) {\n+                            self.ir.tcx.struct_span_lint_hir(\n+                                lint::builtin::UNUSED_ASSIGNMENTS,\n+                                var_hir_id,\n+                                vec![span],\n+                                |lint| {\n+                                    lint.build(&format!(\n+                                        \"value captured by `{}` is never read\",\n+                                        name\n+                                    ))\n+                                    .help(\"did you mean to capture by reference instead?\")\n+                                    .emit();\n+                                },\n+                            );\n+                        }\n+                    }\n+                } else {\n                     if let Some(name) = self.should_warn(var) {\n                         self.ir.tcx.struct_span_lint_hir(\n-                            lint::builtin::UNUSED_ASSIGNMENTS,\n+                            lint::builtin::UNUSED_VARIABLES,\n                             var_hir_id,\n-                            vec![upvar.span],\n+                            vec![span],\n                             |lint| {\n-                                lint.build(&format!(\"value captured by `{}` is never read\", name))\n+                                lint.build(&format!(\"unused variable: `{}`\", name))\n                                     .help(\"did you mean to capture by reference instead?\")\n                                     .emit();\n                             },\n                         );\n                     }\n                 }\n-            } else {\n-                if let Some(name) = self.should_warn(var) {\n-                    self.ir.tcx.struct_span_lint_hir(\n-                        lint::builtin::UNUSED_VARIABLES,\n-                        var_hir_id,\n-                        vec![upvar.span],\n-                        |lint| {\n-                            lint.build(&format!(\"unused variable: `{}`\", name))\n-                                .help(\"did you mean to capture by reference instead?\")\n-                                .emit();\n-                        },\n-                    );\n-                }\n             }\n         }\n     }"}, {"sha": "8f8514cadb745ddb179b198ca1a345f424edf4d5", "filename": "compiler/rustc_typeck/src/check/regionck.rs", "status": "modified", "additions": 30, "deletions": 12, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/cebc8fef5f4391a9ed8e4c1dc566a6c5824e2901/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cebc8fef5f4391a9ed8e4c1dc566a6c5824e2901/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fregionck.rs?ref=cebc8fef5f4391a9ed8e4c1dc566a6c5824e2901", "patch": "@@ -771,21 +771,39 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n         debug!(\"link_upvar_region(borrorw_region={:?}, upvar_id={:?}\", borrow_region, upvar_id);\n         // A by-reference upvar can't be borrowed for longer than the\n         // upvar is borrowed from the environment.\n-        match self.typeck_results.borrow().upvar_capture(upvar_id) {\n-            ty::UpvarCapture::ByRef(upvar_borrow) => {\n-                self.sub_regions(\n-                    infer::ReborrowUpvar(span, upvar_id),\n-                    borrow_region,\n-                    upvar_borrow.region,\n-                );\n-                if let ty::ImmBorrow = upvar_borrow.kind {\n-                    debug!(\"link_upvar_region: capture by shared ref\");\n-                    return;\n+        let closure_local_def_id = upvar_id.closure_expr_id;\n+        let mut all_captures_are_imm_borrow = true;\n+        for captured_place in self\n+            .typeck_results\n+            .borrow()\n+            .closure_min_captures\n+            .get(&closure_local_def_id.to_def_id())\n+            .and_then(|root_var_min_cap| root_var_min_cap.get(&upvar_id.var_path.hir_id))\n+            .into_iter()\n+            .flatten()\n+        {\n+            match captured_place.info.capture_kind {\n+                ty::UpvarCapture::ByRef(upvar_borrow) => {\n+                    self.sub_regions(\n+                        infer::ReborrowUpvar(span, upvar_id),\n+                        borrow_region,\n+                        upvar_borrow.region,\n+                    );\n+                    if let ty::ImmBorrow = upvar_borrow.kind {\n+                        debug!(\"link_upvar_region: capture by shared ref\");\n+                    } else {\n+                        all_captures_are_imm_borrow = false;\n+                    }\n+                }\n+                ty::UpvarCapture::ByValue(_) => {\n+                    all_captures_are_imm_borrow = false;\n                 }\n             }\n-            ty::UpvarCapture::ByValue(_) => {}\n         }\n-        let fn_hir_id = self.tcx.hir().local_def_id_to_hir_id(upvar_id.closure_expr_id);\n+        if all_captures_are_imm_borrow {\n+            return;\n+        }\n+        let fn_hir_id = self.tcx.hir().local_def_id_to_hir_id(closure_local_def_id);\n         let ty = self.resolve_node_type(fn_hir_id);\n         debug!(\"link_upvar_region: ty={:?}\", ty);\n "}, {"sha": "8a4c69b5ac8f934d503f7839b05e005d644708cf", "filename": "compiler/rustc_typeck/src/check/upvar.rs", "status": "modified", "additions": 0, "deletions": 76, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/cebc8fef5f4391a9ed8e4c1dc566a6c5824e2901/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cebc8fef5f4391a9ed8e4c1dc566a6c5824e2901/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs?ref=cebc8fef5f4391a9ed8e4c1dc566a6c5824e2901", "patch": "@@ -222,8 +222,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         self.log_closure_min_capture_info(closure_def_id, span);\n \n-        self.min_captures_to_closure_captures_bridge(closure_def_id);\n-\n         // Now that we've analyzed the closure, we know how each\n         // variable is borrowed, and we know what traits the closure\n         // implements (Fn vs FnMut etc). We now have some updates to do\n@@ -293,80 +291,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             .collect()\n     }\n \n-    /// Bridge for closure analysis\n-    /// ----------------------------\n-    ///\n-    /// For closure with DefId `c`, the bridge converts structures required for supporting RFC 2229,\n-    /// to structures currently used in the compiler for handling closure captures.\n-    ///\n-    /// For example the following structure will be converted:\n-    ///\n-    /// closure_min_captures\n-    /// foo -> [ {foo.x, ImmBorrow}, {foo.y, MutBorrow} ]\n-    /// bar -> [ {bar.z, ByValue}, {bar.q, MutBorrow} ]\n-    ///\n-    /// to\n-    ///\n-    /// 1. closure_captures\n-    /// foo -> UpvarId(foo, c), bar -> UpvarId(bar, c)\n-    ///\n-    /// 2. upvar_capture_map\n-    /// UpvarId(foo,c) -> MutBorrow, UpvarId(bar, c) -> ByValue\n-    fn min_captures_to_closure_captures_bridge(&self, closure_def_id: DefId) {\n-        let mut closure_captures: FxIndexMap<hir::HirId, ty::UpvarId> = Default::default();\n-        let mut upvar_capture_map = ty::UpvarCaptureMap::default();\n-\n-        if let Some(min_captures) =\n-            self.typeck_results.borrow().closure_min_captures.get(&closure_def_id)\n-        {\n-            for (var_hir_id, min_list) in min_captures.iter() {\n-                for captured_place in min_list {\n-                    let place = &captured_place.place;\n-                    let capture_info = captured_place.info;\n-\n-                    let upvar_id = match place.base {\n-                        PlaceBase::Upvar(upvar_id) => upvar_id,\n-                        base => bug!(\"Expected upvar, found={:?}\", base),\n-                    };\n-\n-                    assert_eq!(upvar_id.var_path.hir_id, *var_hir_id);\n-                    assert_eq!(upvar_id.closure_expr_id, closure_def_id.expect_local());\n-\n-                    closure_captures.insert(*var_hir_id, upvar_id);\n-\n-                    let new_capture_kind =\n-                        if let Some(capture_kind) = upvar_capture_map.get(&upvar_id) {\n-                            // upvar_capture_map only stores the UpvarCapture (CaptureKind),\n-                            // so we create a fake capture info with no expression.\n-                            let fake_capture_info = ty::CaptureInfo {\n-                                capture_kind_expr_id: None,\n-                                path_expr_id: None,\n-                                capture_kind: *capture_kind,\n-                            };\n-                            determine_capture_info(fake_capture_info, capture_info).capture_kind\n-                        } else {\n-                            capture_info.capture_kind\n-                        };\n-                    upvar_capture_map.insert(upvar_id, new_capture_kind);\n-                }\n-            }\n-        }\n-        debug!(\"For closure_def_id={:?}, closure_captures={:#?}\", closure_def_id, closure_captures);\n-        debug!(\n-            \"For closure_def_id={:?}, upvar_capture_map={:#?}\",\n-            closure_def_id, upvar_capture_map\n-        );\n-\n-        if !closure_captures.is_empty() {\n-            self.typeck_results\n-                .borrow_mut()\n-                .closure_captures\n-                .insert(closure_def_id, closure_captures);\n-\n-            self.typeck_results.borrow_mut().upvar_capture_map.extend(upvar_capture_map);\n-        }\n-    }\n-\n     /// Analyzes the information collected by `InferBorrowKind` to compute the min number of\n     /// Places (and corresponding capture kind) that we need to keep track of to support all\n     /// the required captured paths."}, {"sha": "9a183ed9e629eb6eaadd1c870fdf8e3033db8cde", "filename": "compiler/rustc_typeck/src/check/writeback.rs", "status": "modified", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/cebc8fef5f4391a9ed8e4c1dc566a6c5824e2901/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cebc8fef5f4391a9ed8e4c1dc566a6c5824e2901/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs?ref=cebc8fef5f4391a9ed8e4c1dc566a6c5824e2901", "patch": "@@ -61,7 +61,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         wbcx.visit_body(body);\n         wbcx.visit_min_capture_map();\n         wbcx.visit_fake_reads_map();\n-        wbcx.visit_upvar_capture_map();\n         wbcx.visit_closures();\n         wbcx.visit_liberated_fn_sigs();\n         wbcx.visit_fru_field_types();\n@@ -79,9 +78,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         wbcx.typeck_results.treat_byte_string_as_slice =\n             mem::take(&mut self.typeck_results.borrow_mut().treat_byte_string_as_slice);\n \n-        wbcx.typeck_results.closure_captures =\n-            mem::take(&mut self.typeck_results.borrow_mut().closure_captures);\n-\n         if self.is_tainted_by_errors() {\n             // FIXME(eddyb) keep track of `ErrorReported` from where the error was emitted.\n             wbcx.typeck_results.tainted_by_errors = Some(ErrorReported);\n@@ -389,22 +385,6 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n         self.typeck_results.closure_fake_reads = resolved_closure_fake_reads;\n     }\n \n-    fn visit_upvar_capture_map(&mut self) {\n-        for (upvar_id, upvar_capture) in self.fcx.typeck_results.borrow().upvar_capture_map.iter() {\n-            let new_upvar_capture = match *upvar_capture {\n-                ty::UpvarCapture::ByValue(span) => ty::UpvarCapture::ByValue(span),\n-                ty::UpvarCapture::ByRef(ref upvar_borrow) => {\n-                    ty::UpvarCapture::ByRef(ty::UpvarBorrow {\n-                        kind: upvar_borrow.kind,\n-                        region: self.tcx().lifetimes.re_erased,\n-                    })\n-                }\n-            };\n-            debug!(\"Upvar capture for {:?} resolved to {:?}\", upvar_id, new_upvar_capture);\n-            self.typeck_results.upvar_capture_map.insert(*upvar_id, new_upvar_capture);\n-        }\n-    }\n-\n     fn visit_closures(&mut self) {\n         let fcx_typeck_results = self.fcx.typeck_results.borrow();\n         assert_eq!(fcx_typeck_results.hir_owner, self.typeck_results.hir_owner);"}, {"sha": "09491f296f6672a346892bef646fa71deb504c70", "filename": "src/test/ui/closures/2229_closure_analysis/diagnostics/liveness.rs", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/cebc8fef5f4391a9ed8e4c1dc566a6c5824e2901/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cebc8fef5f4391a9ed8e4c1dc566a6c5824e2901/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fliveness.rs?ref=cebc8fef5f4391a9ed8e4c1dc566a6c5824e2901", "patch": "@@ -0,0 +1,91 @@\n+// check-pass\n+#![feature(capture_disjoint_fields)]\n+//~^ WARNING: the feature `capture_disjoint_fields` is incomplete\n+#![allow(unreachable_code)]\n+#![warn(unused)]\n+\n+#[derive(Debug)]\n+struct Point {\n+    x: i32,\n+    y: i32,\n+}\n+\n+pub fn f() {\n+    let mut a = 1;\n+    let mut c = Point{ x:1, y:0 };\n+\n+    // Captured by value, but variable is dead on entry.\n+    (move || {\n+        // This will not trigger a warning for unused variable as\n+        // c.x will be treated as a Non-tracked place\n+        c.x = 1;\n+        println!(\"{}\", c.x);\n+        a = 1; //~ WARN value captured by `a` is never read\n+        println!(\"{}\", a);\n+    })();\n+\n+    // Read and written to, but never actually used.\n+    (move || {\n+        // This will not trigger a warning for unused variable as\n+        // c.x will be treated as a Non-tracked place\n+        c.x += 1;\n+        a += 1; //~ WARN unused variable: `a`\n+    })();\n+\n+    (move || {\n+        println!(\"{}\", c.x);\n+        // Value is read by closure itself on later invocations.\n+        // This will not trigger a warning for unused variable as\n+        // c.x will be treated as a Non-tracked place\n+        c.x += 1;\n+        println!(\"{}\", a);\n+        a += 1;\n+    })();\n+    let b = Box::new(42);\n+    (move || {\n+        println!(\"{}\", c.x);\n+        // Never read because this is FnOnce closure.\n+        // This will not trigger a warning for unused variable as\n+        // c.x will be treated as a Non-tracked place\n+        c.x += 1;\n+        println!(\"{}\", a);\n+        a += 1; //~ WARN value assigned to `a` is never read\n+        drop(b);\n+    })();\n+}\n+\n+#[derive(Debug)]\n+struct MyStruct<'a>  {\n+    x: Option<& 'a str>,\n+    y: i32,\n+}\n+\n+pub fn nested() {\n+    let mut a : Option<& str>;\n+    a = None;\n+    let mut b : Option<& str>;\n+    b = None;\n+    let mut d = MyStruct{ x: None, y: 1};\n+    let mut e = MyStruct{ x: None, y: 1};\n+    (|| {\n+        (|| {\n+            // This will not trigger a warning for unused variable as\n+            // d.x will be treated as a Non-tracked place\n+            d.x = Some(\"d1\");\n+            d.x = Some(\"d2\");\n+            a = Some(\"d1\"); //~ WARN value assigned to `a` is never read\n+            a = Some(\"d2\");\n+        })();\n+        (move || {\n+            // This will not trigger a warning for unused variable as\n+            //e.x will be treated as a Non-tracked place\n+            e.x = Some(\"e1\");\n+            e.x = Some(\"e2\");\n+            b = Some(\"e1\"); //~ WARN value assigned to `b` is never read\n+                            //~| WARN unused variable: `b`\n+            b = Some(\"e2\"); //~ WARN value assigned to `b` is never read\n+        })();\n+    })();\n+}\n+\n+fn main() {}"}, {"sha": "81bbc4e1dc0c24166912805efd0e6a7f098448aa", "filename": "src/test/ui/closures/2229_closure_analysis/diagnostics/liveness.stderr", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/cebc8fef5f4391a9ed8e4c1dc566a6c5824e2901/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fliveness.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cebc8fef5f4391a9ed8e4c1dc566a6c5824e2901/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fliveness.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fliveness.stderr?ref=cebc8fef5f4391a9ed8e4c1dc566a6c5824e2901", "patch": "@@ -0,0 +1,79 @@\n+warning: the feature `capture_disjoint_fields` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/liveness.rs:2:12\n+   |\n+LL | #![feature(capture_disjoint_fields)]\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+   = note: see issue #53488 <https://github.com/rust-lang/rust/issues/53488> for more information\n+\n+warning: value captured by `a` is never read\n+  --> $DIR/liveness.rs:23:9\n+   |\n+LL |         a = 1;\n+   |         ^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/liveness.rs:5:9\n+   |\n+LL | #![warn(unused)]\n+   |         ^^^^^^\n+   = note: `#[warn(unused_assignments)]` implied by `#[warn(unused)]`\n+   = help: did you mean to capture by reference instead?\n+\n+warning: unused variable: `a`\n+  --> $DIR/liveness.rs:32:9\n+   |\n+LL |         a += 1;\n+   |         ^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/liveness.rs:5:9\n+   |\n+LL | #![warn(unused)]\n+   |         ^^^^^^\n+   = note: `#[warn(unused_variables)]` implied by `#[warn(unused)]`\n+   = help: did you mean to capture by reference instead?\n+\n+warning: value assigned to `a` is never read\n+  --> $DIR/liveness.rs:52:9\n+   |\n+LL |         a += 1;\n+   |         ^\n+   |\n+   = help: maybe it is overwritten before being read?\n+\n+warning: value assigned to `a` is never read\n+  --> $DIR/liveness.rs:76:13\n+   |\n+LL |             a = Some(\"d1\");\n+   |             ^\n+   |\n+   = help: maybe it is overwritten before being read?\n+\n+warning: value assigned to `b` is never read\n+  --> $DIR/liveness.rs:84:13\n+   |\n+LL |             b = Some(\"e1\");\n+   |             ^\n+   |\n+   = help: maybe it is overwritten before being read?\n+\n+warning: value assigned to `b` is never read\n+  --> $DIR/liveness.rs:86:13\n+   |\n+LL |             b = Some(\"e2\");\n+   |             ^\n+   |\n+   = help: maybe it is overwritten before being read?\n+\n+warning: unused variable: `b`\n+  --> $DIR/liveness.rs:84:13\n+   |\n+LL |             b = Some(\"e1\");\n+   |             ^\n+   |\n+   = help: did you mean to capture by reference instead?\n+\n+warning: 8 warnings emitted\n+"}, {"sha": "e2035464dfa8a658cdc0f378f96a2669cfb6985c", "filename": "src/test/ui/closures/2229_closure_analysis/diagnostics/liveness_unintentional_copy.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/cebc8fef5f4391a9ed8e4c1dc566a6c5824e2901/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fliveness_unintentional_copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cebc8fef5f4391a9ed8e4c1dc566a6c5824e2901/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fliveness_unintentional_copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fliveness_unintentional_copy.rs?ref=cebc8fef5f4391a9ed8e4c1dc566a6c5824e2901", "patch": "@@ -0,0 +1,42 @@\n+// check-pass\n+#![feature(capture_disjoint_fields)]\n+//~^ WARNING: the feature `capture_disjoint_fields` is incomplete\n+#![warn(unused)]\n+\n+#[derive(Debug)]\n+struct MyStruct {\n+    a: i32,\n+    b: i32,\n+}\n+\n+pub fn unintentional_copy_one() {\n+    let mut a = 1;\n+    let mut last = MyStruct{ a: 1, b: 1};\n+    let mut f = move |s| {\n+        // This will not trigger a warning for unused variable\n+        // as last.a will be treated as a Non-tracked place\n+        last.a = s;\n+        a = s;\n+        //~^ WARN value assigned to `a` is never read\n+        //~| WARN unused variable: `a`\n+    };\n+    f(2);\n+    f(3);\n+    f(4);\n+}\n+\n+pub fn unintentional_copy_two() {\n+    let mut a = 1;\n+    let mut sum = MyStruct{ a: 1, b: 0};\n+    (1..10).for_each(move |x| {\n+        // This will not trigger a warning for unused variable\n+        // as sum.b will be treated as a Non-tracked place\n+        sum.b += x;\n+        a += x; //~ WARN unused variable: `a`\n+    });\n+}\n+\n+fn main() {\n+    unintentional_copy_one();\n+    unintentional_copy_two();\n+}"}, {"sha": "35b0c22fc4fb97dae4b1ebc9c0a2e7cd928c693a", "filename": "src/test/ui/closures/2229_closure_analysis/diagnostics/liveness_unintentional_copy.stderr", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/cebc8fef5f4391a9ed8e4c1dc566a6c5824e2901/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fliveness_unintentional_copy.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cebc8fef5f4391a9ed8e4c1dc566a6c5824e2901/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fliveness_unintentional_copy.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fliveness_unintentional_copy.stderr?ref=cebc8fef5f4391a9ed8e4c1dc566a6c5824e2901", "patch": "@@ -0,0 +1,47 @@\n+warning: the feature `capture_disjoint_fields` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/liveness_unintentional_copy.rs:2:12\n+   |\n+LL | #![feature(capture_disjoint_fields)]\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+   = note: see issue #53488 <https://github.com/rust-lang/rust/issues/53488> for more information\n+\n+warning: value assigned to `a` is never read\n+  --> $DIR/liveness_unintentional_copy.rs:19:9\n+   |\n+LL |         a = s;\n+   |         ^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/liveness_unintentional_copy.rs:4:9\n+   |\n+LL | #![warn(unused)]\n+   |         ^^^^^^\n+   = note: `#[warn(unused_assignments)]` implied by `#[warn(unused)]`\n+   = help: maybe it is overwritten before being read?\n+\n+warning: unused variable: `a`\n+  --> $DIR/liveness_unintentional_copy.rs:19:9\n+   |\n+LL |         a = s;\n+   |         ^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/liveness_unintentional_copy.rs:4:9\n+   |\n+LL | #![warn(unused)]\n+   |         ^^^^^^\n+   = note: `#[warn(unused_variables)]` implied by `#[warn(unused)]`\n+   = help: did you mean to capture by reference instead?\n+\n+warning: unused variable: `a`\n+  --> $DIR/liveness_unintentional_copy.rs:35:9\n+   |\n+LL |         a += x;\n+   |         ^\n+   |\n+   = help: did you mean to capture by reference instead?\n+\n+warning: 4 warnings emitted\n+"}]}