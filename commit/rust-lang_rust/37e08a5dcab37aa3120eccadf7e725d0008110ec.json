{"sha": "37e08a5dcab37aa3120eccadf7e725d0008110ec", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM3ZTA4YTVkY2FiMzdhYTMxMjBlY2NhZGY3ZTcyNWQwMDA4MTEwZWM=", "commit": {"author": {"name": "Basile Desloges", "email": "basile.desloges@gmail.com", "date": "2017-10-21T19:15:04Z"}, "committer": {"name": "Basile Desloges", "email": "basile.desloges@gmail.com", "date": "2017-11-13T20:53:09Z"}, "message": "mir-borrowck: Check access permissions in `access_lvalue()`", "tree": {"sha": "7e6a8c728bb43c4904817ed970d45a2d5eddce99", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7e6a8c728bb43c4904817ed970d45a2d5eddce99"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/37e08a5dcab37aa3120eccadf7e725d0008110ec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/37e08a5dcab37aa3120eccadf7e725d0008110ec", "html_url": "https://github.com/rust-lang/rust/commit/37e08a5dcab37aa3120eccadf7e725d0008110ec", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/37e08a5dcab37aa3120eccadf7e725d0008110ec/comments", "author": {"login": "zilbuz", "id": 434964, "node_id": "MDQ6VXNlcjQzNDk2NA==", "avatar_url": "https://avatars.githubusercontent.com/u/434964?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zilbuz", "html_url": "https://github.com/zilbuz", "followers_url": "https://api.github.com/users/zilbuz/followers", "following_url": "https://api.github.com/users/zilbuz/following{/other_user}", "gists_url": "https://api.github.com/users/zilbuz/gists{/gist_id}", "starred_url": "https://api.github.com/users/zilbuz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zilbuz/subscriptions", "organizations_url": "https://api.github.com/users/zilbuz/orgs", "repos_url": "https://api.github.com/users/zilbuz/repos", "events_url": "https://api.github.com/users/zilbuz/events{/privacy}", "received_events_url": "https://api.github.com/users/zilbuz/received_events", "type": "User", "site_admin": false}, "committer": {"login": "zilbuz", "id": 434964, "node_id": "MDQ6VXNlcjQzNDk2NA==", "avatar_url": "https://avatars.githubusercontent.com/u/434964?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zilbuz", "html_url": "https://github.com/zilbuz", "followers_url": "https://api.github.com/users/zilbuz/followers", "following_url": "https://api.github.com/users/zilbuz/following{/other_user}", "gists_url": "https://api.github.com/users/zilbuz/gists{/gist_id}", "starred_url": "https://api.github.com/users/zilbuz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zilbuz/subscriptions", "organizations_url": "https://api.github.com/users/zilbuz/orgs", "repos_url": "https://api.github.com/users/zilbuz/repos", "events_url": "https://api.github.com/users/zilbuz/events{/privacy}", "received_events_url": "https://api.github.com/users/zilbuz/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0bb77bdb5423402b583372abf2f097be6b4e46bc", "url": "https://api.github.com/repos/rust-lang/rust/commits/0bb77bdb5423402b583372abf2f097be6b4e46bc", "html_url": "https://github.com/rust-lang/rust/commit/0bb77bdb5423402b583372abf2f097be6b4e46bc"}], "stats": {"total": 156, "additions": 154, "deletions": 2}, "files": [{"sha": "c56631d429cb4fd214f483f3ef4a13dba10916f5", "filename": "src/librustc_mir/borrow_check.rs", "status": "modified", "additions": 154, "deletions": 2, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/37e08a5dcab37aa3120eccadf7e725d0008110ec/src%2Flibrustc_mir%2Fborrow_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37e08a5dcab37aa3120eccadf7e725d0008110ec/src%2Flibrustc_mir%2Fborrow_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check.rs?ref=37e08a5dcab37aa3120eccadf7e725d0008110ec", "patch": "@@ -10,6 +10,7 @@\n \n //! This query borrow-checks the MIR to (further) ensure it is not broken.\n \n+use rustc::hir;\n use rustc::hir::def_id::{DefId};\n use rustc::infer::{InferCtxt};\n use rustc::ty::{self, TyCtxt, ParamEnv};\n@@ -447,9 +448,12 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n                      lvalue_span: (&Lvalue<'tcx>, Span),\n                      kind: (ShallowOrDeep, ReadOrWrite),\n                      flow_state: &InProgress<'b, 'gcx, 'tcx>) {\n-        // FIXME: also need to check permissions (e.g. reject mut\n-        // borrow of immutable ref, moves through non-`Box`-ref)\n+\n         let (sd, rw) = kind;\n+\n+        // Check permissions\n+        self.check_access_permissions(lvalue_span, rw);\n+\n         self.each_borrow_involving_path(\n             context, (sd, lvalue_span.0), flow_state, |this, _index, borrow, common_prefix| {\n                 match (rw, borrow.kind) {\n@@ -861,6 +865,154 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n             }\n         }\n     }\n+\n+    /// Check the permissions for the given lvalue and read or write kind\n+    fn check_access_permissions(&self, (lvalue, span): (&Lvalue<'tcx>, Span), kind: ReadOrWrite) {\n+        match kind {\n+            Write(WriteKind::MutableBorrow(BorrowKind::Unique)) => {\n+                if let Err(_lvalue_err) = self.is_unique(lvalue) {\n+                    span_bug!(span, \"&unique borrow for `{}` should not fail\",\n+                        self.describe_lvalue(lvalue));\n+                }\n+            },\n+            Write(WriteKind::MutableBorrow(BorrowKind::Mut)) => {\n+                if let Err(lvalue_err) = self.is_mutable(lvalue) {\n+                    let mut err = self.tcx.cannot_borrow_path_as_mutable(span,\n+                        &format!(\"immutable item `{}`\",\n+                                  self.describe_lvalue(lvalue)),\n+                        Origin::Mir);\n+                    err.span_label(span, \"cannot borrow as mutable\");\n+\n+                    if lvalue != lvalue_err {\n+                        err.note(&format!(\"Value not mutable causing this error: `{}`\",\n+                            self.describe_lvalue(lvalue_err)));\n+                    }\n+\n+                    err.emit();\n+                }\n+            },\n+            _ => {}// Access authorized\n+        }\n+    }\n+\n+    /// Can this value be written or borrowed mutably\n+    fn is_mutable<'d>(&self, lvalue: &'d Lvalue<'tcx>) -> Result<(), &'d Lvalue<'tcx>> {\n+        match *lvalue {\n+            Lvalue::Local(local) => {\n+                let local = &self.mir.local_decls[local];\n+                match local.mutability {\n+                    Mutability::Not => Err(lvalue),\n+                    Mutability::Mut => Ok(())\n+                }\n+            },\n+            Lvalue::Static(ref static_) => {\n+                if !self.tcx.is_static_mut(static_.def_id) {\n+                    Err(lvalue)\n+                } else {\n+                    Ok(())\n+                }\n+            },\n+            Lvalue::Projection(ref proj) => {\n+                match proj.elem {\n+                    ProjectionElem::Deref => {\n+                        let base_ty = proj.base.ty(self.mir, self.tcx).to_ty(self.tcx);\n+\n+                        // `Box<T>` owns its content, so mutable if its location is mutable\n+                        if base_ty.is_box() {\n+                            return self.is_mutable(&proj.base);\n+                        }\n+\n+                        // Otherwise we check the kind of deref to decide\n+                        match base_ty.sty {\n+                            ty::TyRef(_, tnm) => {\n+                                match tnm.mutbl {\n+                                    // Shared borrowed data is never mutable\n+                                    hir::MutImmutable => Err(lvalue),\n+                                    // Mutably borrowed data is mutable, but only if we have a\n+                                    // unique path to the `&mut`\n+                                    hir::MutMutable => self.is_unique(&proj.base),\n+                                }\n+                            },\n+                            ty::TyRawPtr(tnm) => {\n+                                match tnm.mutbl {\n+                                    // `*const` raw pointers are not mutable\n+                                    hir::MutImmutable => Err(lvalue),\n+                                    // `*mut` raw pointers are always mutable, regardless of context\n+                                    // The users have to check by themselve.\n+                                    hir::MutMutable => Ok(()),\n+                                }\n+                            },\n+                            // Deref should only be for reference, pointers or boxes\n+                            _ => bug!(\"Deref of unexpected type: {:?}\", base_ty)\n+                        }\n+                    },\n+                    // All other projections are owned by their base path, so mutable if\n+                    // base path is mutable\n+                    ProjectionElem::Field(..) |\n+                    ProjectionElem::Index(..) |\n+                    ProjectionElem::ConstantIndex{..} |\n+                    ProjectionElem::Subslice{..} |\n+                    ProjectionElem::Downcast(..) =>\n+                        self.is_mutable(&proj.base)\n+                }\n+            }\n+        }\n+    }\n+\n+    /// Does this lvalue have a unique path\n+    fn is_unique<'d>(&self, lvalue: &'d Lvalue<'tcx>) -> Result<(), &'d Lvalue<'tcx>> {\n+        match *lvalue {\n+            Lvalue::Local(..) => {\n+                // Local variables are unique\n+                Ok(())\n+            },\n+            Lvalue::Static(..) => {\n+                // Static variables are not\n+                Err(lvalue)\n+            },\n+            Lvalue::Projection(ref proj) => {\n+                match proj.elem {\n+                    ProjectionElem::Deref => {\n+                        let base_ty = proj.base.ty(self.mir, self.tcx).to_ty(self.tcx);\n+\n+                        // `Box<T>` referent is unique if box is a unique spot\n+                        if base_ty.is_box() {\n+                            return self.is_unique(&proj.base);\n+                        }\n+\n+                        // Otherwise we check the kind of deref to decide\n+                        match base_ty.sty {\n+                            ty::TyRef(_, tnm) => {\n+                                match tnm.mutbl {\n+                                    // lvalue represent an aliased location\n+                                    hir::MutImmutable => Err(lvalue),\n+                                    // `&mut T` is as unique as the context in which it is found\n+                                    hir::MutMutable => self.is_unique(&proj.base),\n+                                }\n+                            },\n+                            ty::TyRawPtr(tnm) => {\n+                                match tnm.mutbl {\n+                                    // `*mut` can be aliased, but we leave it to user\n+                                    hir::MutMutable => Ok(()),\n+                                    // `*const` is treated the same as `*mut`\n+                                    hir::MutImmutable => Ok(()),\n+                                }\n+                            },\n+                            // Deref should only be for reference, pointers or boxes\n+                            _ => bug!(\"Deref of unexpected type: {:?}\", base_ty)\n+                        }\n+                    },\n+                    // Other projections are unique if the base is unique\n+                    ProjectionElem::Field(..) |\n+                    ProjectionElem::Index(..) |\n+                    ProjectionElem::ConstantIndex{..} |\n+                    ProjectionElem::Subslice{..} |\n+                    ProjectionElem::Downcast(..) =>\n+                        self.is_unique(&proj.base)\n+                }\n+            }\n+        }\n+    }\n }\n \n #[derive(Copy, Clone, PartialEq, Eq, Debug)]"}]}