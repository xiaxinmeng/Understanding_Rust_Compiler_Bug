{"sha": "a71a81948074f7a3e2b5ce0dee3ad98fa22f793b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE3MWE4MTk0ODA3NGY3YTNlMmI1Y2UwZGVlM2FkOThmYTIyZjc5M2I=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2021-01-22T03:35:05Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2021-02-05T02:29:49Z"}, "message": "Revert \"Avoid leaking block expression values\"\n\nThis reverts commit 4fef39113a514bb270f5661a82fdba17d3e41dbb.", "tree": {"sha": "0222d8b0134ac0f0c5434d4308e4127ff96fc7b5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0222d8b0134ac0f0c5434d4308e4127ff96fc7b5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a71a81948074f7a3e2b5ce0dee3ad98fa22f793b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a71a81948074f7a3e2b5ce0dee3ad98fa22f793b", "html_url": "https://github.com/rust-lang/rust/commit/a71a81948074f7a3e2b5ce0dee3ad98fa22f793b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a71a81948074f7a3e2b5ce0dee3ad98fa22f793b/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dab3a80f235ed86d64d002e58b35adc3664e21a4", "url": "https://api.github.com/repos/rust-lang/rust/commits/dab3a80f235ed86d64d002e58b35adc3664e21a4", "html_url": "https://github.com/rust-lang/rust/commit/dab3a80f235ed86d64d002e58b35adc3664e21a4"}], "stats": {"total": 21663, "additions": 10733, "deletions": 10930}, "files": [{"sha": "d5f72e6f22dfa29af8a3c5870d9ab593a17428b7", "filename": "compiler/rustc_mir_build/src/build/block.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a71a81948074f7a3e2b5ce0dee3ad98fa22f793b/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a71a81948074f7a3e2b5ce0dee3ad98fa22f793b/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fblock.rs?ref=a71a81948074f7a3e2b5ce0dee3ad98fa22f793b", "patch": "@@ -3,7 +3,6 @@ use crate::build::ForGuard::OutsideGuard;\n use crate::build::{BlockAnd, BlockAndExtension, BlockFrame, Builder};\n use crate::thir::*;\n use rustc_hir as hir;\n-use rustc_middle::middle::region;\n use rustc_middle::mir::*;\n use rustc_session::lint::builtin::UNSAFE_OP_IN_UNSAFE_FN;\n use rustc_session::lint::Level;\n@@ -13,7 +12,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     crate fn ast_block(\n         &mut self,\n         destination: Place<'tcx>,\n-        scope: Option<region::Scope>,\n         block: BasicBlock,\n         ast_block: &'tcx hir::Block<'tcx>,\n         source_info: SourceInfo,\n@@ -30,10 +28,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         self.in_opt_scope(opt_destruction_scope.map(|de| (de, source_info)), move |this| {\n             this.in_scope((region_scope, source_info), LintLevel::Inherited, move |this| {\n                 if targeted_by_break {\n-                    this.in_breakable_scope(None, destination, scope, span, |this| {\n+                    this.in_breakable_scope(None, destination, span, |this| {\n                         Some(this.ast_block_stmts(\n                             destination,\n-                            scope,\n                             block,\n                             span,\n                             stmts,\n@@ -42,7 +39,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                         ))\n                     })\n                 } else {\n-                    this.ast_block_stmts(destination, scope, block, span, stmts, expr, safety_mode)\n+                    this.ast_block_stmts(destination, block, span, stmts, expr, safety_mode)\n                 }\n             })\n         })\n@@ -51,7 +48,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     fn ast_block_stmts(\n         &mut self,\n         destination: Place<'tcx>,\n-        scope: Option<region::Scope>,\n         mut block: BasicBlock,\n         span: Span,\n         stmts: Vec<StmtRef<'tcx>>,\n@@ -186,7 +182,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             };\n             this.block_context.push(BlockFrame::TailExpr { tail_result_is_ignored, span });\n \n-            unpack!(block = this.into(destination, scope, block, expr));\n+            unpack!(block = this.into(destination, block, expr));\n             let popped = this.block_context.pop();\n \n             assert!(popped.map_or(false, |bf| bf.is_tail_expr()));"}, {"sha": "fb2df93df34a9511aff8f76b369bc913f14b2df4", "filename": "compiler/rustc_mir_build/src/build/expr/as_rvalue.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a71a81948074f7a3e2b5ce0dee3ad98fa22f793b/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a71a81948074f7a3e2b5ce0dee3ad98fa22f793b/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=a71a81948074f7a3e2b5ce0dee3ad98fa22f793b", "patch": "@@ -115,15 +115,10 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 let box_ = Rvalue::NullaryOp(NullOp::Box, value.ty);\n                 this.cfg.push_assign(block, source_info, Place::from(result), box_);\n \n-                // Initialize the box contents. No scope is needed since the\n-                // `Box` is already scheduled to be dropped.\n+                // initialize the box contents:\n                 unpack!(\n-                    block = this.into(\n-                        this.hir.tcx().mk_place_deref(Place::from(result)),\n-                        None,\n-                        block,\n-                        value,\n-                    )\n+                    block =\n+                        this.into(this.hir.tcx().mk_place_deref(Place::from(result)), block, value)\n                 );\n                 let result_operand = Operand::Move(Place::from(result));\n                 this.record_operands_moved(slice::from_ref(&result_operand));"}, {"sha": "9984b527ffdb4c00611c8e0b843f6ab5b25c072a", "filename": "compiler/rustc_mir_build/src/build/expr/as_temp.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a71a81948074f7a3e2b5ce0dee3ad98fa22f793b/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_temp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a71a81948074f7a3e2b5ce0dee3ad98fa22f793b/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_temp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_temp.rs?ref=a71a81948074f7a3e2b5ce0dee3ad98fa22f793b", "patch": "@@ -114,7 +114,11 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             }\n         }\n \n-        unpack!(block = this.into(temp_place, temp_lifetime, block, expr));\n+        unpack!(block = this.into(temp_place, block, expr));\n+\n+        if let Some(temp_lifetime) = temp_lifetime {\n+            this.schedule_drop(expr_span, temp_lifetime, temp, DropKind::Value);\n+        }\n \n         block.and(temp)\n     }"}, {"sha": "fdea4a505166005cf0085d7ad21773b2824c9c21", "filename": "compiler/rustc_mir_build/src/build/expr/into.rs", "status": "modified", "additions": 27, "deletions": 59, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/a71a81948074f7a3e2b5ce0dee3ad98fa22f793b/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a71a81948074f7a3e2b5ce0dee3ad98fa22f793b/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs?ref=a71a81948074f7a3e2b5ce0dee3ad98fa22f793b", "patch": "@@ -1,14 +1,12 @@\n //! See docs in build/expr/mod.rs\n \n use crate::build::expr::category::{Category, RvalueFunc};\n-use crate::build::scope::DropKind;\n use crate::build::{BlockAnd, BlockAndExtension, BlockFrame, Builder};\n use crate::thir::*;\n use rustc_ast::InlineAsmOptions;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::stack::ensure_sufficient_stack;\n use rustc_hir as hir;\n-use rustc_middle::middle::region;\n use rustc_middle::mir::*;\n use rustc_middle::ty::CanonicalUserTypeAnnotation;\n \n@@ -17,19 +15,13 @@ use std::slice;\n impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// Compile `expr`, storing the result into `destination`, which\n     /// is assumed to be uninitialized.\n-    /// If a `drop_scope` is provided, `destination` is scheduled to be dropped\n-    /// in `scope` once it has been initialized.\n     crate fn into_expr(\n         &mut self,\n         destination: Place<'tcx>,\n-        scope: Option<region::Scope>,\n         mut block: BasicBlock,\n         expr: Expr<'tcx>,\n     ) -> BlockAnd<()> {\n-        debug!(\n-            \"into_expr(destination={:?}, scope={:?}, block={:?}, expr={:?})\",\n-            destination, scope, block, expr\n-        );\n+        debug!(\"into_expr(destination={:?}, block={:?}, expr={:?})\", destination, block, expr);\n \n         // since we frequently have to reference `self` from within a\n         // closure, where `self` would be shadowed, it's easier to\n@@ -41,14 +33,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         let expr_is_block_or_scope =\n             matches!(expr.kind, ExprKind::Block { .. } | ExprKind::Scope { .. });\n \n-        let schedule_drop = move |this: &mut Self| {\n-            if let Some(drop_scope) = scope {\n-                let local =\n-                    destination.as_local().expect(\"cannot schedule drop of non-Local place\");\n-                this.schedule_drop(expr_span, drop_scope, local, DropKind::Value);\n-            }\n-        };\n-\n         if !expr_is_block_or_scope {\n             this.block_context.push(BlockFrame::SubExpr);\n         }\n@@ -58,15 +42,15 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 let region_scope = (region_scope, source_info);\n                 ensure_sufficient_stack(|| {\n                     this.in_scope(region_scope, lint_level, |this| {\n-                        this.into(destination, scope, block, value)\n+                        this.into(destination, block, value)\n                     })\n                 })\n             }\n             ExprKind::Block { body: ast_block } => {\n-                this.ast_block(destination, scope, block, ast_block, source_info)\n+                this.ast_block(destination, block, ast_block, source_info)\n             }\n             ExprKind::Match { scrutinee, arms } => {\n-                this.match_expr(destination, scope, expr_span, block, scrutinee, arms)\n+                this.match_expr(destination, expr_span, block, scrutinee, arms)\n             }\n             ExprKind::If { cond, then, else_opt } => {\n                 let place = unpack!(\n@@ -79,9 +63,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 let term = TerminatorKind::if_(this.hir.tcx(), operand, then_block, else_block);\n                 this.cfg.terminate(block, source_info, term);\n \n-                unpack!(then_block = this.into(destination, scope, then_block, then));\n+                unpack!(then_block = this.into(destination, then_block, then));\n                 else_block = if let Some(else_opt) = else_opt {\n-                    unpack!(this.into(destination, None, else_block, else_opt))\n+                    unpack!(this.into(destination, else_block, else_opt))\n                 } else {\n                     // Body of the `if` expression without an `else` clause must return `()`, thus\n                     // we implicitly generate a `else {}` if it is not specified.\n@@ -117,7 +101,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n                 // This is an optimization. If the expression was a call then we already have an\n                 // unreachable block. Don't bother to terminate it and create a new one.\n-                schedule_drop(this);\n                 if is_call {\n                     block.unit()\n                 } else {\n@@ -193,35 +176,26 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 // Start the loop.\n                 this.cfg.goto(block, source_info, loop_block);\n \n-                this.in_breakable_scope(\n-                    Some(loop_block),\n-                    destination,\n-                    scope,\n-                    expr_span,\n-                    move |this| {\n-                        // conduct the test, if necessary\n-                        let body_block = this.cfg.start_new_block();\n-                        this.cfg.terminate(\n-                            loop_block,\n-                            source_info,\n-                            TerminatorKind::FalseUnwind { real_target: body_block, unwind: None },\n-                        );\n-                        this.diverge_from(loop_block);\n-\n-                        // The \u201creturn\u201d value of the loop body must always be an unit. We therefore\n-                        // introduce a unit temporary as the destination for the loop body.\n-                        let tmp = this.get_unit_temp();\n-                        // Execute the body, branching back to the test.\n-                        // We don't need to provide a drop scope because `tmp`\n-                        // has type `()`.\n-                        let body_block_end = unpack!(this.into(tmp, None, body_block, body));\n-                        this.cfg.goto(body_block_end, source_info, loop_block);\n-                        schedule_drop(this);\n-\n-                        // Loops are only exited by `break` expressions.\n-                        None\n-                    },\n-                )\n+                this.in_breakable_scope(Some(loop_block), destination, expr_span, move |this| {\n+                    // conduct the test, if necessary\n+                    let body_block = this.cfg.start_new_block();\n+                    this.cfg.terminate(\n+                        loop_block,\n+                        source_info,\n+                        TerminatorKind::FalseUnwind { real_target: body_block, unwind: None },\n+                    );\n+                    this.diverge_from(loop_block);\n+\n+                    // The \u201creturn\u201d value of the loop body must always be an unit. We therefore\n+                    // introduce a unit temporary as the destination for the loop body.\n+                    let tmp = this.get_unit_temp();\n+                    // Execute the body, branching back to the test.\n+                    let body_block_end = unpack!(this.into(tmp, body_block, body));\n+                    this.cfg.goto(body_block_end, source_info, loop_block);\n+\n+                    // Loops are only exited by `break` expressions.\n+                    None\n+                })\n             }\n             ExprKind::Call { ty: _, fun, args, from_hir_call, fn_span } => {\n                 let fun = unpack!(block = this.as_local_operand(block, fun));\n@@ -256,10 +230,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     },\n                 );\n                 this.diverge_from(block);\n-                schedule_drop(this);\n                 success.unit()\n             }\n-            ExprKind::Use { source } => this.into(destination, scope, block, source),\n+            ExprKind::Use { source } => this.into(destination, block, source),\n             ExprKind::Borrow { arg, borrow_kind } => {\n                 // We don't do this in `as_rvalue` because we use `as_place`\n                 // for borrow expressions, so we cannot create an `RValue` that\n@@ -348,7 +321,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     destination,\n                     Rvalue::Aggregate(adt, fields),\n                 );\n-                schedule_drop(this);\n                 block.unit()\n             }\n             ExprKind::InlineAsm { template, operands, options, line_spans } => {\n@@ -445,7 +417,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 let place = unpack!(block = this.as_place(block, expr));\n                 let rvalue = Rvalue::Use(this.consume_by_copy_or_move(place));\n                 this.cfg.push_assign(block, source_info, destination, rvalue);\n-                schedule_drop(this);\n                 block.unit()\n             }\n             ExprKind::Index { .. } | ExprKind::Deref { .. } | ExprKind::Field { .. } => {\n@@ -463,7 +434,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 let place = unpack!(block = this.as_place(block, expr));\n                 let rvalue = Rvalue::Use(this.consume_by_copy_or_move(place));\n                 this.cfg.push_assign(block, source_info, destination, rvalue);\n-                schedule_drop(this);\n                 block.unit()\n             }\n \n@@ -478,7 +448,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     TerminatorKind::Yield { value, resume, resume_arg: destination, drop: None },\n                 );\n                 this.generator_drop_cleanup(block);\n-                schedule_drop(this);\n                 resume.unit()\n             }\n \n@@ -510,7 +479,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n                 let rvalue = unpack!(block = this.as_local_rvalue(block, expr));\n                 this.cfg.push_assign(block, source_info, destination, rvalue);\n-                schedule_drop(this);\n                 block.unit()\n             }\n         };"}, {"sha": "7264e495b84fd0dc6026c67f156f4cb25c40a428", "filename": "compiler/rustc_mir_build/src/build/into.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a71a81948074f7a3e2b5ce0dee3ad98fa22f793b/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a71a81948074f7a3e2b5ce0dee3ad98fa22f793b/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Finto.rs?ref=a71a81948074f7a3e2b5ce0dee3ad98fa22f793b", "patch": "@@ -6,15 +6,13 @@\n \n use crate::build::{BlockAnd, Builder};\n use crate::thir::*;\n-use rustc_middle::middle::region;\n use rustc_middle::mir::*;\n \n pub(in crate::build) trait EvalInto<'tcx> {\n     fn eval_into(\n         self,\n         builder: &mut Builder<'_, 'tcx>,\n         destination: Place<'tcx>,\n-        scope: Option<region::Scope>,\n         block: BasicBlock,\n     ) -> BlockAnd<()>;\n }\n@@ -23,14 +21,13 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     crate fn into<E>(\n         &mut self,\n         destination: Place<'tcx>,\n-        scope: Option<region::Scope>,\n         block: BasicBlock,\n         expr: E,\n     ) -> BlockAnd<()>\n     where\n         E: EvalInto<'tcx>,\n     {\n-        expr.eval_into(self, destination, scope, block)\n+        expr.eval_into(self, destination, block)\n     }\n }\n \n@@ -39,11 +36,10 @@ impl<'tcx> EvalInto<'tcx> for ExprRef<'tcx> {\n         self,\n         builder: &mut Builder<'_, 'tcx>,\n         destination: Place<'tcx>,\n-        scope: Option<region::Scope>,\n         block: BasicBlock,\n     ) -> BlockAnd<()> {\n         let expr = builder.hir.mirror(self);\n-        builder.into_expr(destination, scope, block, expr)\n+        builder.into_expr(destination, block, expr)\n     }\n }\n \n@@ -52,9 +48,8 @@ impl<'tcx> EvalInto<'tcx> for Expr<'tcx> {\n         self,\n         builder: &mut Builder<'_, 'tcx>,\n         destination: Place<'tcx>,\n-        scope: Option<region::Scope>,\n         block: BasicBlock,\n     ) -> BlockAnd<()> {\n-        builder.into_expr(destination, scope, block, self)\n+        builder.into_expr(destination, block, self)\n     }\n }"}, {"sha": "0e1d5b2b7ca2c63fcc396cddfb2bfb81ddeda437", "filename": "compiler/rustc_mir_build/src/build/matches/mod.rs", "status": "modified", "additions": 83, "deletions": 15, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/a71a81948074f7a3e2b5ce0dee3ad98fa22f793b/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a71a81948074f7a3e2b5ce0dee3ad98fa22f793b/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs?ref=a71a81948074f7a3e2b5ce0dee3ad98fa22f793b", "patch": "@@ -87,7 +87,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     crate fn match_expr(\n         &mut self,\n         destination: Place<'tcx>,\n-        destination_scope: Option<region::Scope>,\n         span: Span,\n         mut block: BasicBlock,\n         scrutinee: ExprRef<'tcx>,\n@@ -108,7 +107,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n         self.lower_match_arms(\n             destination,\n-            destination_scope,\n             scrutinee_place,\n             scrutinee_span,\n             arm_candidates,\n@@ -215,13 +213,76 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         }\n     }\n \n+    /// Lower the bindings, guards and arm bodies of a `match` expression.\n+    ///\n+    /// The decision tree should have already been created\n+    /// (by [Builder::lower_match_tree]).\n+    ///\n+    /// `outer_source_info` is the SourceInfo for the whole match.\n+    fn lower_match_arms(\n+        &mut self,\n+        destination: Place<'tcx>,\n+        scrutinee_place: Place<'tcx>,\n+        scrutinee_span: Span,\n+        arm_candidates: Vec<(&'_ Arm<'tcx>, Candidate<'_, 'tcx>)>,\n+        outer_source_info: SourceInfo,\n+        fake_borrow_temps: Vec<(Place<'tcx>, Local)>,\n+    ) -> BlockAnd<()> {\n+        let arm_end_blocks: Vec<_> = arm_candidates\n+            .into_iter()\n+            .map(|(arm, candidate)| {\n+                debug!(\"lowering arm {:?}\\ncandidate = {:?}\", arm, candidate);\n+\n+                let arm_source_info = self.source_info(arm.span);\n+                let arm_scope = (arm.scope, arm_source_info);\n+                self.in_scope(arm_scope, arm.lint_level, |this| {\n+                    let body = this.hir.mirror(arm.body.clone());\n+                    let scope = this.declare_bindings(\n+                        None,\n+                        arm.span,\n+                        &arm.pattern,\n+                        ArmHasGuard(arm.guard.is_some()),\n+                        Some((Some(&scrutinee_place), scrutinee_span)),\n+                    );\n+\n+                    let arm_block = this.bind_pattern(\n+                        outer_source_info,\n+                        candidate,\n+                        arm.guard.as_ref(),\n+                        &fake_borrow_temps,\n+                        scrutinee_span,\n+                        Some(arm.span),\n+                        Some(arm.scope),\n+                    );\n+\n+                    if let Some(source_scope) = scope {\n+                        this.source_scope = source_scope;\n+                    }\n+\n+                    this.into(destination, arm_block, body)\n+                })\n+            })\n+            .collect();\n+\n+        // all the arm blocks will rejoin here\n+        let end_block = self.cfg.start_new_block();\n+\n+        for arm_block in arm_end_blocks {\n+            self.cfg.goto(unpack!(arm_block), outer_source_info, end_block);\n+        }\n+\n+        self.source_scope = outer_source_info.scope;\n+\n+        end_block.unit()\n+    }\n+\n     /// Binds the variables and ascribes types for a given `match` arm or\n     /// `let` binding.\n     ///\n     /// Also check if the guard matches, if it's provided.\n     /// `arm_scope` should be `Some` if and only if this is called for a\n     /// `match` arm.\n-    crate fn bind_pattern(\n+    fn bind_pattern(\n         &mut self,\n         outer_source_info: SourceInfo,\n         candidate: Candidate<'_, 'tcx>,\n@@ -308,14 +369,13 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             PatKind::Binding { mode: BindingMode::ByValue, var, subpattern: None, .. } => {\n                 let place =\n                     self.storage_live_binding(block, var, irrefutable_pat.span, OutsideGuard, true);\n-                let region_scope = self.hir.region_scope_tree.var_scope(var.local_id);\n-\n-                unpack!(block = self.into(place, Some(region_scope), block, initializer));\n+                unpack!(block = self.into(place, block, initializer));\n \n                 // Inject a fake read, see comments on `FakeReadCause::ForLet`.\n                 let source_info = self.source_info(irrefutable_pat.span);\n                 self.cfg.push_fake_read(block, source_info, FakeReadCause::ForLet, place);\n \n+                self.schedule_drop_for_binding(var, irrefutable_pat.span, OutsideGuard);\n                 block.unit()\n             }\n \n@@ -342,10 +402,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 ascription:\n                     thir::pattern::Ascription { user_ty: pat_ascription_ty, variance: _, user_ty_span },\n             } => {\n-                let region_scope = self.hir.region_scope_tree.var_scope(var.local_id);\n                 let place =\n                     self.storage_live_binding(block, var, irrefutable_pat.span, OutsideGuard, true);\n-                unpack!(block = self.into(place, Some(region_scope), block, initializer));\n+                unpack!(block = self.into(place, block, initializer));\n \n                 // Inject a fake read, see comments on `FakeReadCause::ForLet`.\n                 let pattern_source_info = self.source_info(irrefutable_pat.span);\n@@ -383,6 +442,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     },\n                 );\n \n+                self.schedule_drop_for_binding(var, irrefutable_pat.span, OutsideGuard);\n                 block.unit()\n             }\n \n@@ -629,7 +689,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n }\n \n #[derive(Debug)]\n-pub(super) struct Candidate<'pat, 'tcx> {\n+struct Candidate<'pat, 'tcx> {\n     /// [`Span`] of the original pattern that gave rise to this candidate.\n     span: Span,\n \n@@ -1362,7 +1422,12 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         match test.kind {\n             TestKind::SwitchInt { switch_ty, ref mut options } => {\n                 for candidate in candidates.iter() {\n-                    if !self.add_cases_to_switch(&match_place, candidate, switch_ty, options) {\n+                    if !self.add_cases_to_switch(\n+                        &match_place,\n+                        candidate,\n+                        switch_ty,\n+                        options,\n+                    ) {\n                         break;\n                     }\n                 }\n@@ -1777,11 +1842,14 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             // ```\n             //\n             // and that is clearly not correct.\n-            let by_value_bindings = parent_bindings\n-                .iter()\n-                .flat_map(|(bindings, _)| bindings)\n-                .chain(&candidate.bindings)\n-                .filter(|binding| matches!(binding.binding_mode, BindingMode::ByValue));\n+            let by_value_bindings =\n+                parent_bindings\n+                    .iter()\n+                    .flat_map(|(bindings, _)| bindings)\n+                    .chain(&candidate.bindings)\n+                    .filter(|binding| {\n+                        matches!(binding.binding_mode, BindingMode::ByValue )\n+                    });\n             // Read all of the by reference bindings to ensure that the\n             // place they refer to can't be modified by the guard.\n             for binding in by_value_bindings.clone() {"}, {"sha": "41a8d15b47f02b7b43b7be0e309020ea6bfefed6", "filename": "compiler/rustc_mir_build/src/build/mod.rs", "status": "modified", "additions": 10, "deletions": 24, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/a71a81948074f7a3e2b5ce0dee3ad98fa22f793b/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a71a81948074f7a3e2b5ce0dee3ad98fa22f793b/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs?ref=a71a81948074f7a3e2b5ce0dee3ad98fa22f793b", "patch": "@@ -76,9 +76,7 @@ fn mir_build(tcx: TyCtxt<'_>, def: ty::WithOptConstParam<LocalDefId>) -> Body<'_\n             kind: hir::TraitItemKind::Const(ty, Some(body_id)),\n             ..\n         }) => (*body_id, ty.span, None),\n-        Node::AnonConst(hir::AnonConst { body, hir_id, .. }) => {\n-            (*body, tcx.hir().span(*hir_id), None)\n-        }\n+        Node::AnonConst(hir::AnonConst { body, hir_id, .. }) => (*body, tcx.hir().span(*hir_id), None),\n \n         _ => span_bug!(tcx.hir().span(id), \"can't build MIR for {:?}\", def.did),\n     };\n@@ -186,7 +184,7 @@ fn mir_build(tcx: TyCtxt<'_>, def: ty::WithOptConstParam<LocalDefId>) -> Body<'_\n                 return_ty,\n                 return_ty_span,\n                 body,\n-                span_with_body,\n+                span_with_body\n             );\n             mir.yield_ty = yield_ty;\n             mir\n@@ -584,7 +582,7 @@ fn construct_fn<'a, 'tcx, A>(\n     return_ty: Ty<'tcx>,\n     return_ty_span: Span,\n     body: &'tcx hir::Body<'tcx>,\n-    span_with_body: Span,\n+    span_with_body: Span\n ) -> Body<'tcx>\n where\n     A: Iterator<Item = ArgInfo<'tcx>>,\n@@ -618,12 +616,8 @@ where\n         let arg_scope_s = (arg_scope, source_info);\n         // Attribute epilogue to function's closing brace\n         let fn_end = span_with_body.shrink_to_hi();\n-        let return_block = unpack!(builder.in_breakable_scope(\n-            None,\n-            Place::return_place(),\n-            Some(call_site_scope),\n-            fn_end,\n-            |builder| {\n+        let return_block =\n+            unpack!(builder.in_breakable_scope(None, Place::return_place(), fn_end, |builder| {\n                 Some(builder.in_scope(arg_scope_s, LintLevel::Inherited, |builder| {\n                     builder.args_and_body(\n                         START_BLOCK,\n@@ -633,13 +627,11 @@ where\n                         &body.value,\n                     )\n                 }))\n-            },\n-        ));\n+            }));\n         let source_info = builder.source_info(fn_end);\n         builder.cfg.terminate(return_block, source_info, TerminatorKind::Return);\n         let should_abort = should_abort_on_panic(tcx, fn_def_id, abi);\n         builder.build_drop_trees(should_abort);\n-        builder.unschedule_return_place_drop();\n         return_block.unit()\n     }));\n \n@@ -666,15 +658,12 @@ fn construct_const<'a, 'tcx>(\n     let owner_id = tcx.hir().body_owner(body_id);\n     let def_id = tcx.hir().local_def_id(owner_id);\n     let span = tcx.hir().span(owner_id);\n-    let mut builder =\n-        Builder::new(hir, def_id.to_def_id(), span, 0, Safety::Safe, const_ty, const_ty_span, None);\n+    let mut builder = Builder::new(hir, def_id.to_def_id(), span, 0, Safety::Safe, const_ty, const_ty_span, None);\n \n     let mut block = START_BLOCK;\n     let ast_expr = &tcx.hir().body(body_id).value;\n     let expr = builder.hir.mirror(ast_expr);\n-    // We don't provide a scope because we can't unwind in constants, so won't\n-    // need to drop the return place.\n-    unpack!(block = builder.into_expr(Place::return_place(), None, block, expr));\n+    unpack!(block = builder.into_expr(Place::return_place(), block, expr));\n \n     let source_info = builder.source_info(span);\n     builder.cfg.terminate(block, source_info, TerminatorKind::Return);\n@@ -709,8 +698,7 @@ fn construct_error<'a, 'tcx>(hir: Cx<'a, 'tcx>, body_id: hir::BodyId) -> Body<'t\n         hir::BodyOwnerKind::Const => 0,\n         hir::BodyOwnerKind::Static(_) => 0,\n     };\n-    let mut builder =\n-        Builder::new(hir, def_id.to_def_id(), span, num_params, Safety::Safe, ty, span, None);\n+    let mut builder = Builder::new(hir, def_id.to_def_id(), span, num_params, Safety::Safe, ty, span, None);\n     let source_info = builder.source_info(span);\n     // Some MIR passes will expect the number of parameters to match the\n     // function declaration.\n@@ -953,9 +941,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         }\n \n         let body = self.hir.mirror(ast_body);\n-        let call_site =\n-            region::Scope { id: ast_body.hir_id.local_id, data: region::ScopeData::CallSite };\n-        self.into(Place::return_place(), Some(call_site), block, body)\n+        self.into(Place::return_place(), block, body)\n     }\n \n     fn set_correct_source_scope_for_arg("}, {"sha": "51503e6afa05533f2063c2ca6d405b2bbbaafc30", "filename": "compiler/rustc_mir_build/src/build/scope.rs", "status": "modified", "additions": 16, "deletions": 162, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/a71a81948074f7a3e2b5ce0dee3ad98fa22f793b/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a71a81948074f7a3e2b5ce0dee3ad98fa22f793b/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fscope.rs?ref=a71a81948074f7a3e2b5ce0dee3ad98fa22f793b", "patch": "@@ -81,9 +81,8 @@ that contains only loops and breakable blocks. It tracks where a `break`,\n \n */\n \n-use crate::build::matches::{ArmHasGuard, Candidate};\n use crate::build::{BlockAnd, BlockAndExtension, BlockFrame, Builder, CFG};\n-use crate::thir::{Arm, Expr, ExprRef, LintLevel};\n+use crate::thir::{Expr, ExprRef, LintLevel};\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_index::vec::IndexVec;\n use rustc_middle::middle::region;\n@@ -156,8 +155,6 @@ struct BreakableScope<'tcx> {\n     /// The destination of the loop/block expression itself (i.e., where to put\n     /// the result of a `break` or `return` expression)\n     break_destination: Place<'tcx>,\n-    /// The scope that the destination should have its drop scheduled in.\n-    destination_scope: Option<region::Scope>,\n     /// Drops that happen on the `break`/`return` path.\n     break_drops: DropTree,\n     /// Drops that happen on the `continue` path.\n@@ -440,7 +437,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         &mut self,\n         loop_block: Option<BasicBlock>,\n         break_destination: Place<'tcx>,\n-        destination_scope: Option<region::Scope>,\n         span: Span,\n         f: F,\n     ) -> BlockAnd<()>\n@@ -451,19 +447,15 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         let scope = BreakableScope {\n             region_scope,\n             break_destination,\n-            destination_scope,\n             break_drops: DropTree::new(),\n             continue_drops: loop_block.map(|_| DropTree::new()),\n         };\n-        let continue_block = loop_block.map(|block| (block, self.diverge_cleanup()));\n         self.scopes.breakable_scopes.push(scope);\n         let normal_exit_block = f(self);\n         let breakable_scope = self.scopes.breakable_scopes.pop().unwrap();\n         assert!(breakable_scope.region_scope == region_scope);\n-        if let Some(drops) = breakable_scope.continue_drops {\n-            self.build_exit_tree(drops, continue_block);\n-        }\n         let break_block = self.build_exit_tree(breakable_scope.break_drops, None);\n+        if let Some(drops) = breakable_scope.continue_drops { self.build_exit_tree(drops, loop_block); }\n         match (normal_exit_block, break_block) {\n             (Some(block), None) | (None, Some(block)) => block,\n             (None, None) => self.cfg.start_new_block().unit(),\n@@ -592,33 +584,30 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 .rposition(|breakable_scope| breakable_scope.region_scope == scope)\n                 .unwrap_or_else(|| span_bug!(span, \"no enclosing breakable scope found\"))\n         };\n-        let (break_index, destination, dest_scope) = match target {\n+        let (break_index, destination) = match target {\n             BreakableTarget::Return => {\n                 let scope = &self.scopes.breakable_scopes[0];\n                 if scope.break_destination != Place::return_place() {\n                     span_bug!(span, \"`return` in item with no return scope\");\n                 }\n-                (0, Some(scope.break_destination), scope.destination_scope)\n+                (0, Some(scope.break_destination))\n             }\n             BreakableTarget::Break(scope) => {\n                 let break_index = get_scope_index(scope);\n                 let scope = &self.scopes.breakable_scopes[break_index];\n-                (break_index, Some(scope.break_destination), scope.destination_scope)\n+                (break_index, Some(scope.break_destination))\n             }\n             BreakableTarget::Continue(scope) => {\n                 let break_index = get_scope_index(scope);\n-                (break_index, None, None)\n+                (break_index, None)\n             }\n         };\n \n         if let Some(destination) = destination {\n             if let Some(value) = value {\n                 debug!(\"stmt_expr Break val block_context.push(SubExpr)\");\n                 self.block_context.push(BlockFrame::SubExpr);\n-                unpack!(block = self.into(destination, dest_scope, block, value));\n-                if let Some(scope) = dest_scope {\n-                    self.unschedule_drop(scope, destination.as_local().unwrap())\n-                };\n+                unpack!(block = self.into(destination, block, value));\n                 self.block_context.pop();\n             } else {\n                 self.cfg.push_assign_unit(block, source_info, destination, self.hir.tcx())\n@@ -858,47 +847,14 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         span_bug!(span, \"region scope {:?} not in scope to drop {:?}\", region_scope, local);\n     }\n \n-    /// Unschedule a drop. Used for `break`, `return` and `match` expressions,\n-    /// where `record_operands_moved` is not powerful enough.\n-    ///\n-    /// The given local is expected to have a value drop scheduled in the given\n-    /// scope and for that drop to be the most recent thing scheduled in that\n-    /// scope.\n-    fn unschedule_drop(&mut self, region_scope: region::Scope, local: Local) {\n-        if !self.hir.needs_drop(self.local_decls[local].ty) {\n-            return;\n-        }\n-        for scope in self.scopes.scopes.iter_mut().rev() {\n-            scope.invalidate_cache();\n-\n-            if scope.region_scope == region_scope {\n-                let drop = scope.drops.pop();\n-\n-                match drop {\n-                    Some(DropData { local: removed_local, kind: DropKind::Value, .. })\n-                        if removed_local == local =>\n-                    {\n-                        return;\n-                    }\n-                    _ => bug!(\n-                        \"found wrong drop, expected value drop of {:?}, found {:?}\",\n-                        local,\n-                        drop,\n-                    ),\n-                }\n-            }\n-        }\n-\n-        bug!(\"region scope {:?} not in scope to unschedule drop of {:?}\", region_scope, local);\n-    }\n-\n-    /// Indicates that the \"local operands\" stored in `local` is\n+    /// Indicates that the \"local operand\" stored in `local` is\n     /// *moved* at some point during execution (see `local_scope` for\n     /// more information about what a \"local operand\" is -- in short,\n     /// it's an intermediate operand created as part of preparing some\n     /// MIR instruction). We use this information to suppress\n-    /// redundant drops. This results in less MIR, but also avoids spurious\n-    /// borrow check errors (c.f. #64391).\n+    /// redundant drops on the non-unwind paths. This results in less\n+    /// MIR, but also avoids spurious borrow check errors\n+    /// (c.f. #64391).\n     ///\n     /// Example: when compiling the call to `foo` here:\n     ///\n@@ -1133,116 +1089,18 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         success_block\n     }\n \n-    /// Lower the arms and guards of a match.\n-    ///\n-    /// The decision tree should have already been created (by\n-    /// [Builder::lower_match_tree]).\n-    ///\n-    /// This is this module, and not in `build::matches` because we have to do\n-    /// some careful scope manipulation to have the drop of the destination be\n-    /// scheduled at the end of each arm and then cleared for the next arm.\n-    crate fn lower_match_arms(\n-        &mut self,\n-        destination: Place<'tcx>,\n-        destination_scope: Option<region::Scope>,\n-        scrutinee_place: Place<'tcx>,\n-        scrutinee_span: Span,\n-        arm_candidates: Vec<(&'_ Arm<'tcx>, Candidate<'_, 'tcx>)>,\n-        outer_source_info: SourceInfo,\n-        fake_borrow_temps: Vec<(Place<'tcx>, Local)>,\n-    ) -> BlockAnd<()> {\n-        if arm_candidates.is_empty() {\n-            // If there are no arms to schedule drops, then we have to do it\n-            // manually.\n-            if let Some(scope) = destination_scope {\n-                self.schedule_drop(\n-                    outer_source_info.span,\n-                    scope,\n-                    destination.as_local().unwrap(),\n-                    DropKind::Value,\n-                );\n-            }\n-            return self.cfg.start_new_block().unit();\n-        }\n-        let mut first_arm = true;\n-        let arm_end_blocks: Vec<_> = arm_candidates\n-            .into_iter()\n-            .map(|(arm, candidate)| {\n-                debug!(\"lowering arm {:?}\\ncandidate = {:?}\", arm, candidate);\n-\n-                if first_arm {\n-                    first_arm = false;\n-                } else if let Some(scope) = destination_scope {\n-                    self.unschedule_drop(scope, destination.as_local().unwrap());\n-                }\n-\n-                let arm_source_info = self.source_info(arm.span);\n-                let arm_scope = (arm.scope, arm_source_info);\n-                self.in_scope(arm_scope, arm.lint_level, |this| {\n-                    let body = this.hir.mirror(arm.body.clone());\n-                    let scope = this.declare_bindings(\n-                        None,\n-                        arm.span,\n-                        &arm.pattern,\n-                        ArmHasGuard(arm.guard.is_some()),\n-                        Some((Some(&scrutinee_place), scrutinee_span)),\n-                    );\n-\n-                    let arm_block = this.bind_pattern(\n-                        outer_source_info,\n-                        candidate,\n-                        arm.guard.as_ref(),\n-                        &fake_borrow_temps,\n-                        scrutinee_span,\n-                        Some(arm.span),\n-                        Some(arm.scope),\n-                    );\n-\n-                    if let Some(source_scope) = scope {\n-                        this.source_scope = source_scope;\n-                    }\n-\n-                    this.into(destination, destination_scope, arm_block, body)\n-                })\n-            })\n-            .collect();\n-\n-        // all the arm blocks will rejoin here\n-        let end_block = self.cfg.start_new_block();\n-\n-        for arm_block in arm_end_blocks {\n-            self.cfg.goto(unpack!(arm_block), outer_source_info, end_block);\n-        }\n-\n-        self.source_scope = outer_source_info.scope;\n-\n-        end_block.unit()\n-    }\n-\n     /// Unschedules any drops in the top scope.\n     ///\n     /// This is only needed for `match` arm scopes, because they have one\n     /// entrance per pattern, but only one exit.\n-    pub(super) fn clear_top_scope(&mut self, region_scope: region::Scope) {\n+    crate fn clear_top_scope(&mut self, region_scope: region::Scope) {\n         let top_scope = self.scopes.scopes.last_mut().unwrap();\n \n         assert_eq!(top_scope.region_scope, region_scope);\n \n         top_scope.drops.clear();\n         top_scope.invalidate_cache();\n     }\n-\n-    /// Unschedules the drop of the return place.\n-    ///\n-    /// If the return type of a function requires drop, then we schedule it\n-    /// in the outermost scope so that it's dropped if there's a panic while\n-    /// we drop any local variables. But we don't want to drop it if we\n-    /// return normally.\n-    crate fn unschedule_return_place_drop(&mut self) {\n-        assert_eq!(self.scopes.scopes.len(), 1);\n-        assert!(self.scopes.scopes[0].drops.len() <= 1);\n-        self.scopes.scopes[0].drops.clear();\n-    }\n }\n \n /// Builds drops for `pop_scope` and `leave_top_scope`.\n@@ -1318,24 +1176,20 @@ impl<'a, 'tcx: 'a> Builder<'a, 'tcx> {\n     /// Build a drop tree for a breakable scope.\n     ///\n     /// If `continue_block` is `Some`, then the tree is for `continue` inside a\n-    /// loop. Otherwise this is for `break` or `return`. The `DropIdx` is the\n-    /// next drop in the case that the drop tree unwinds. This is needed\n-    /// because the drop of the break destination has already been scheduled\n-    /// but it hasn't been initialized on the `continue` paths.\n+    /// loop. Otherwise this is for `break` or `return`.\n     fn build_exit_tree(\n         &mut self,\n         mut drops: DropTree,\n-        continue_block: Option<(BasicBlock, DropIdx)>,\n+        continue_block: Option<BasicBlock>,\n     ) -> Option<BlockAnd<()>> {\n         let mut blocks = IndexVec::from_elem(None, &drops.drops);\n-        blocks[ROOT_NODE] = continue_block.map(|(block, _)| block);\n+        blocks[ROOT_NODE] = continue_block;\n \n         drops.build_mir::<ExitScopes>(&mut self.cfg, &mut blocks);\n \n         // Link the exit drop tree to unwind drop tree.\n         if drops.drops.iter().any(|(drop, _)| drop.kind == DropKind::Value) {\n-            let unwind_target = continue_block\n-                .map_or_else(|| self.diverge_cleanup(), |(_, unwind_target)| unwind_target);\n+            let unwind_target = self.diverge_cleanup();\n             let mut unwind_indices = IndexVec::from_elem_n(unwind_target, 1);\n             for (drop_idx, drop_data) in drops.drops.iter_enumerated().skip(1) {\n                 match drop_data.0.kind {"}, {"sha": "cf6bf7c7c99ed746e83da011876e8369de340484", "filename": "library/alloc/src/collections/btree/map/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a71a81948074f7a3e2b5ce0dee3ad98fa22f793b/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a71a81948074f7a3e2b5ce0dee3ad98fa22f793b/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs?ref=a71a81948074f7a3e2b5ce0dee3ad98fa22f793b", "patch": "@@ -1882,7 +1882,7 @@ fn test_append_drop_leak() {\n \n     catch_unwind(move || left.append(&mut right)).unwrap_err();\n \n-    assert_eq!(DROPS.load(SeqCst), 5);\n+    assert_eq!(DROPS.load(SeqCst), 4); // Rust issue #47949 ate one little piggy\n }\n \n #[test]"}, {"sha": "07994eb3c16613170e83220a715df13a0c14d475", "filename": "src/test/mir-opt/inline/inline_diverging.h.Inline.diff", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a71a81948074f7a3e2b5ce0dee3ad98fa22f793b/src%2Ftest%2Fmir-opt%2Finline%2Finline_diverging.h.Inline.diff", "raw_url": "https://github.com/rust-lang/rust/raw/a71a81948074f7a3e2b5ce0dee3ad98fa22f793b/src%2Ftest%2Fmir-opt%2Finline%2Finline_diverging.h.Inline.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finline%2Finline_diverging.h.Inline.diff?ref=a71a81948074f7a3e2b5ce0dee3ad98fa22f793b", "patch": "@@ -5,19 +5,18 @@\n       let mut _0: ();                      // return place in scope 0 at $DIR/inline-diverging.rs:21:12: 21:12\n       let _1: (!, !);                      // in scope 0 at $DIR/inline-diverging.rs:22:5: 22:22\n +     let mut _2: fn() -> ! {sleep};       // in scope 0 at $DIR/inline-diverging.rs:22:5: 22:22\n++     let mut _7: ();                      // in scope 0 at $DIR/inline-diverging.rs:22:5: 22:22\n +     let mut _8: ();                      // in scope 0 at $DIR/inline-diverging.rs:22:5: 22:22\n-+     let mut _9: ();                      // in scope 0 at $DIR/inline-diverging.rs:22:5: 22:22\n +     scope 1 (inlined call_twice::<!, fn() -> ! {sleep}>) { // at $DIR/inline-diverging.rs:22:5: 22:22\n +         debug f => _2;                   // in scope 1 at $DIR/inline-diverging.rs:22:5: 22:22\n +         let _3: !;                       // in scope 1 at $DIR/inline-diverging.rs:22:5: 22:22\n +         let mut _4: &fn() -> ! {sleep};  // in scope 1 at $DIR/inline-diverging.rs:22:5: 22:22\n +         let mut _5: &fn() -> ! {sleep};  // in scope 1 at $DIR/inline-diverging.rs:22:5: 22:22\n +         let mut _6: !;                   // in scope 1 at $DIR/inline-diverging.rs:22:5: 22:22\n-+         let mut _7: !;                   // in scope 1 at $DIR/inline-diverging.rs:22:5: 22:22\n +         scope 2 {\n +             debug a => _3;               // in scope 2 at $DIR/inline-diverging.rs:22:5: 22:22\n +             scope 3 {\n-+                 debug b => _7;           // in scope 3 at $DIR/inline-diverging.rs:22:5: 22:22\n++                 debug b => _6;           // in scope 3 at $DIR/inline-diverging.rs:22:5: 22:22\n +             }\n +             scope 6 (inlined <fn() -> ! {sleep} as Fn<()>>::call - shim(fn() -> ! {sleep})) { // at $DIR/inline-diverging.rs:22:5: 22:22\n +                 scope 7 (inlined sleep) { // at $DIR/inline-diverging.rs:22:5: 22:22\n@@ -41,12 +40,12 @@\n -                                          // mir::Constant\n                                            // + span: $DIR/inline-diverging.rs:22:16: 22:21\n                                            // + literal: Const { ty: fn() -> ! {sleep}, val: Value(Scalar(<ZST>)) }\n-+         StorageLive(_7);                 // scope 0 at $DIR/inline-diverging.rs:22:5: 22:22\n++         StorageLive(_6);                 // scope 0 at $DIR/inline-diverging.rs:22:5: 22:22\n +         StorageLive(_3);                 // scope 1 at $DIR/inline-diverging.rs:22:5: 22:22\n +         StorageLive(_4);                 // scope 1 at $DIR/inline-diverging.rs:22:5: 22:22\n +         _4 = &_2;                        // scope 1 at $DIR/inline-diverging.rs:22:5: 22:22\n-+         StorageLive(_8);                 // scope 1 at $DIR/inline-diverging.rs:22:5: 22:22\n-+         _8 = const ();                   // scope 1 at $DIR/inline-diverging.rs:22:5: 22:22\n++         StorageLive(_7);                 // scope 1 at $DIR/inline-diverging.rs:22:5: 22:22\n++         _7 = const ();                   // scope 1 at $DIR/inline-diverging.rs:22:5: 22:22\n +         goto -> bb1;                     // scope 5 at $DIR/inline-diverging.rs:22:5: 22:22\n       }\n   "}, {"sha": "ab6e7ea7b38a3a0bd752ce379bad49207e20d390", "filename": "src/test/mir-opt/issue_62289.test.ElaborateDrops.before.mir", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a71a81948074f7a3e2b5ce0dee3ad98fa22f793b/src%2Ftest%2Fmir-opt%2Fissue_62289.test.ElaborateDrops.before.mir", "raw_url": "https://github.com/rust-lang/rust/raw/a71a81948074f7a3e2b5ce0dee3ad98fa22f793b/src%2Ftest%2Fmir-opt%2Fissue_62289.test.ElaborateDrops.before.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fissue_62289.test.ElaborateDrops.before.mir?ref=a71a81948074f7a3e2b5ce0dee3ad98fa22f793b", "patch": "@@ -30,7 +30,7 @@ fn test() -> Option<Box<u32>> {\n         StorageLive(_3);                 // scope 0 at $DIR/issue-62289.rs:9:15: 9:20\n         StorageLive(_4);                 // scope 0 at $DIR/issue-62289.rs:9:15: 9:19\n         _4 = Option::<u32>::None;        // scope 0 at $DIR/issue-62289.rs:9:15: 9:19\n-        _3 = <Option<u32> as Try>::into_result(move _4) -> [return: bb1, unwind: bb10]; // scope 0 at $DIR/issue-62289.rs:9:15: 9:20\n+        _3 = <Option<u32> as Try>::into_result(move _4) -> [return: bb1, unwind: bb9]; // scope 0 at $DIR/issue-62289.rs:9:15: 9:20\n                                          // mir::Constant\n                                          // + span: $DIR/issue-62289.rs:9:15: 9:20\n                                          // + literal: Const { ty: fn(std::option::Option<u32>) -> std::result::Result<<std::option::Option<u32> as std::ops::Try>::Ok, <std::option::Option<u32> as std::ops::Try>::Error> {<std::option::Option<u32> as std::ops::Try>::into_result}, val: Value(Scalar(<ZST>)) }\n@@ -65,15 +65,15 @@ fn test() -> Option<Box<u32>> {\n         StorageLive(_8);                 // scope 2 at $DIR/issue-62289.rs:9:19: 9:20\n         StorageLive(_9);                 // scope 2 at $DIR/issue-62289.rs:9:19: 9:20\n         _9 = _6;                         // scope 2 at $DIR/issue-62289.rs:9:19: 9:20\n-        _8 = <NoneError as From<NoneError>>::from(move _9) -> [return: bb5, unwind: bb10]; // scope 2 at $DIR/issue-62289.rs:9:19: 9:20\n+        _8 = <NoneError as From<NoneError>>::from(move _9) -> [return: bb5, unwind: bb9]; // scope 2 at $DIR/issue-62289.rs:9:19: 9:20\n                                          // mir::Constant\n                                          // + span: $DIR/issue-62289.rs:9:19: 9:20\n                                          // + literal: Const { ty: fn(std::option::NoneError) -> std::option::NoneError {<std::option::NoneError as std::convert::From<std::option::NoneError>>::from}, val: Value(Scalar(<ZST>)) }\n     }\n \n     bb5: {\n         StorageDead(_9);                 // scope 2 at $DIR/issue-62289.rs:9:19: 9:20\n-        _0 = <Option<Box<u32>> as Try>::from_error(move _8) -> [return: bb6, unwind: bb10]; // scope 2 at $DIR/issue-62289.rs:9:15: 9:20\n+        _0 = <Option<Box<u32>> as Try>::from_error(move _8) -> [return: bb6, unwind: bb9]; // scope 2 at $DIR/issue-62289.rs:9:15: 9:20\n                                          // mir::Constant\n                                          // + span: $DIR/issue-62289.rs:9:15: 9:20\n                                          // + literal: Const { ty: fn(<std::option::Option<std::boxed::Box<u32>> as std::ops::Try>::Error) -> std::option::Option<std::boxed::Box<u32>> {<std::option::Option<std::boxed::Box<u32>> as std::ops::Try>::from_error}, val: Value(Scalar(<ZST>)) }\n@@ -82,7 +82,7 @@ fn test() -> Option<Box<u32>> {\n     bb6: {\n         StorageDead(_8);                 // scope 2 at $DIR/issue-62289.rs:9:19: 9:20\n         StorageDead(_6);                 // scope 0 at $DIR/issue-62289.rs:9:19: 9:20\n-        drop(_2) -> [return: bb7, unwind: bb9]; // scope 0 at $DIR/issue-62289.rs:9:20: 9:21\n+        drop(_2) -> bb7;                 // scope 0 at $DIR/issue-62289.rs:9:20: 9:21\n     }\n \n     bb7: {\n@@ -97,14 +97,10 @@ fn test() -> Option<Box<u32>> {\n     }\n \n     bb9 (cleanup): {\n-        drop(_0) -> bb11;                // scope 0 at $DIR/issue-62289.rs:10:1: 10:2\n+        drop(_2) -> bb10;                // scope 0 at $DIR/issue-62289.rs:9:20: 9:21\n     }\n \n     bb10 (cleanup): {\n-        drop(_2) -> bb11;                // scope 0 at $DIR/issue-62289.rs:9:20: 9:21\n-    }\n-\n-    bb11 (cleanup): {\n         resume;                          // scope 0 at $DIR/issue-62289.rs:8:1: 10:2\n     }\n }"}, {"sha": "e14e733fff6d4cbe55f76924985cb802434c4a49", "filename": "src/test/run-make-fulldeps/coverage-reports/expected_show_coverage.uses_crate.txt", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a71a81948074f7a3e2b5ce0dee3ad98fa22f793b/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.uses_crate.txt", "raw_url": "https://github.com/rust-lang/rust/raw/a71a81948074f7a3e2b5ce0dee3ad98fa22f793b/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.uses_crate.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.uses_crate.txt?ref=a71a81948074f7a3e2b5ce0dee3ad98fa22f793b", "patch": "@@ -19,12 +19,12 @@\n    18|      2|    println!(\"used_only_from_bin_crate_generic_function with {:?}\", arg);\n    19|      2|}\n   ------------------\n-  | used_crate::used_only_from_bin_crate_generic_function::<&alloc::vec::Vec<i32>>:\n+  | used_crate::used_only_from_bin_crate_generic_function::<&str>:\n   |   17|      1|pub fn used_only_from_bin_crate_generic_function<T: Debug>(arg: T) {\n   |   18|      1|    println!(\"used_only_from_bin_crate_generic_function with {:?}\", arg);\n   |   19|      1|}\n   ------------------\n-  | used_crate::used_only_from_bin_crate_generic_function::<&str>:\n+  | used_crate::used_only_from_bin_crate_generic_function::<&alloc::vec::Vec<i32>>:\n   |   17|      1|pub fn used_only_from_bin_crate_generic_function<T: Debug>(arg: T) {\n   |   18|      1|    println!(\"used_only_from_bin_crate_generic_function with {:?}\", arg);\n   |   19|      1|}"}, {"sha": "81310c8cb25aa9c55d2cf1f37ad616fdb7f78bf2", "filename": "src/test/run-make-fulldeps/coverage-spanview/expected_mir_dump.async/async.executor-block_on.-------.InstrumentCoverage.0.html", "status": "modified", "additions": 57, "deletions": 57, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/a71a81948074f7a3e2b5ce0dee3ad98fa22f793b/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-spanview%2Fexpected_mir_dump.async%2Fasync.executor-block_on.-------.InstrumentCoverage.0.html", "raw_url": "https://github.com/rust-lang/rust/raw/a71a81948074f7a3e2b5ce0dee3ad98fa22f793b/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-spanview%2Fexpected_mir_dump.async%2Fasync.executor-block_on.-------.InstrumentCoverage.0.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-spanview%2Fexpected_mir_dump.async%2Fasync.executor-block_on.-------.InstrumentCoverage.0.html?ref=a71a81948074f7a3e2b5ce0dee3ad98fa22f793b", "patch": "@@ -70,166 +70,166 @@\n </head>\n <body>\n <div class=\"code\" style=\"counter-reset: line 109\"><span class=\"line\">    <span><span class=\"code even\" style=\"--layer: 1\" title=\"111:54-111:65: @0[2]: _3 = &amp;mut _1\n-111:35-111:66: @0.Call: _2 = Pin::&lt;&amp;mut F&gt;::new_unchecked(move _3) -&gt; [return: bb1, unwind: bb23]\n+111:35-111:66: @0.Call: _2 = Pin::&lt;&amp;mut F&gt;::new_unchecked(move _3) -&gt; [return: bb1, unwind: bb20]\n 111:13-111:23: @1[1]: FakeRead(ForLet, _2)\n-119:60-119:77: @1.Call: _6 = null::&lt;()&gt;() -&gt; [return: bb2, unwind: bb23]\n+119:60-119:77: @1.Call: _6 = null::&lt;()&gt;() -&gt; [return: bb2, unwind: bb20]\n 119:80-119:86: @2[3]: _9 = const {alloc0: &amp;RawWakerVTable}\n 119:79-119:86: @2[4]: _8 = &amp;(*_9)\n 119:79-119:86: @2[5]: _7 = &amp;(*_8)\n-119:46-119:87: @2.Call: _5 = RawWaker::new(move _6, move _7) -&gt; [return: bb3, unwind: bb23]\n-119:30-119:88: @3.Call: _4 = Waker::from_raw(move _5) -&gt; [return: bb4, unwind: bb23]\n+119:46-119:87: @2.Call: _5 = RawWaker::new(move _6, move _7) -&gt; [return: bb3, unwind: bb20]\n+119:30-119:88: @3.Call: _4 = Waker::from_raw(move _5) -&gt; [return: bb4, unwind: bb20]\n 119:13-119:18: @4[1]: FakeRead(ForLet, _4)\n 120:47-120:53: @4[7]: _12 = &amp;_4\n 120:47-120:53: @4[8]: _11 = &amp;(*_12)\n-120:27-120:54: @4.Call: _10 = Context::from_waker(move _11) -&gt; [return: bb5, unwind: bb22]\n+120:27-120:54: @4.Call: _10 = Context::from_waker(move _11) -&gt; [return: bb5, unwind: bb19]\n 120:13-120:24: @5[1]: FakeRead(ForLet, _10)\"><span class=\"annotation\">@0,1,2,3,4,5\u298a</span>pub fn block_on&lt;F: Future&gt;(mut future: F) -&gt; F::Output {</span></span>\n <span class=\"line\"><span class=\"code even\" style=\"--layer: 1\" title=\"111:54-111:65: @0[2]: _3 = &amp;mut _1\n-111:35-111:66: @0.Call: _2 = Pin::&lt;&amp;mut F&gt;::new_unchecked(move _3) -&gt; [return: bb1, unwind: bb23]\n+111:35-111:66: @0.Call: _2 = Pin::&lt;&amp;mut F&gt;::new_unchecked(move _3) -&gt; [return: bb1, unwind: bb20]\n 111:13-111:23: @1[1]: FakeRead(ForLet, _2)\n-119:60-119:77: @1.Call: _6 = null::&lt;()&gt;() -&gt; [return: bb2, unwind: bb23]\n+119:60-119:77: @1.Call: _6 = null::&lt;()&gt;() -&gt; [return: bb2, unwind: bb20]\n 119:80-119:86: @2[3]: _9 = const {alloc0: &amp;RawWakerVTable}\n 119:79-119:86: @2[4]: _8 = &amp;(*_9)\n 119:79-119:86: @2[5]: _7 = &amp;(*_8)\n-119:46-119:87: @2.Call: _5 = RawWaker::new(move _6, move _7) -&gt; [return: bb3, unwind: bb23]\n-119:30-119:88: @3.Call: _4 = Waker::from_raw(move _5) -&gt; [return: bb4, unwind: bb23]\n+119:46-119:87: @2.Call: _5 = RawWaker::new(move _6, move _7) -&gt; [return: bb3, unwind: bb20]\n+119:30-119:88: @3.Call: _4 = Waker::from_raw(move _5) -&gt; [return: bb4, unwind: bb20]\n 119:13-119:18: @4[1]: FakeRead(ForLet, _4)\n 120:47-120:53: @4[7]: _12 = &amp;_4\n 120:47-120:53: @4[8]: _11 = &amp;(*_12)\n-120:27-120:54: @4.Call: _10 = Context::from_waker(move _11) -&gt; [return: bb5, unwind: bb22]\n+120:27-120:54: @4.Call: _10 = Context::from_waker(move _11) -&gt; [return: bb5, unwind: bb19]\n 120:13-120:24: @5[1]: FakeRead(ForLet, _10)\">        let mut future = unsafe { Pin::new_unchecked(&amp;mut future) };</span></span>\n <span class=\"line\"><span class=\"code even\" style=\"--layer: 1\" title=\"111:54-111:65: @0[2]: _3 = &amp;mut _1\n-111:35-111:66: @0.Call: _2 = Pin::&lt;&amp;mut F&gt;::new_unchecked(move _3) -&gt; [return: bb1, unwind: bb23]\n+111:35-111:66: @0.Call: _2 = Pin::&lt;&amp;mut F&gt;::new_unchecked(move _3) -&gt; [return: bb1, unwind: bb20]\n 111:13-111:23: @1[1]: FakeRead(ForLet, _2)\n-119:60-119:77: @1.Call: _6 = null::&lt;()&gt;() -&gt; [return: bb2, unwind: bb23]\n+119:60-119:77: @1.Call: _6 = null::&lt;()&gt;() -&gt; [return: bb2, unwind: bb20]\n 119:80-119:86: @2[3]: _9 = const {alloc0: &amp;RawWakerVTable}\n 119:79-119:86: @2[4]: _8 = &amp;(*_9)\n 119:79-119:86: @2[5]: _7 = &amp;(*_8)\n-119:46-119:87: @2.Call: _5 = RawWaker::new(move _6, move _7) -&gt; [return: bb3, unwind: bb23]\n-119:30-119:88: @3.Call: _4 = Waker::from_raw(move _5) -&gt; [return: bb4, unwind: bb23]\n+119:46-119:87: @2.Call: _5 = RawWaker::new(move _6, move _7) -&gt; [return: bb3, unwind: bb20]\n+119:30-119:88: @3.Call: _4 = Waker::from_raw(move _5) -&gt; [return: bb4, unwind: bb20]\n 119:13-119:18: @4[1]: FakeRead(ForLet, _4)\n 120:47-120:53: @4[7]: _12 = &amp;_4\n 120:47-120:53: @4[8]: _11 = &amp;(*_12)\n-120:27-120:54: @4.Call: _10 = Context::from_waker(move _11) -&gt; [return: bb5, unwind: bb22]\n+120:27-120:54: @4.Call: _10 = Context::from_waker(move _11) -&gt; [return: bb5, unwind: bb19]\n 120:13-120:24: @5[1]: FakeRead(ForLet, _10)\"></span></span>\n <span class=\"line\"><span class=\"code even\" style=\"--layer: 1\" title=\"111:54-111:65: @0[2]: _3 = &amp;mut _1\n-111:35-111:66: @0.Call: _2 = Pin::&lt;&amp;mut F&gt;::new_unchecked(move _3) -&gt; [return: bb1, unwind: bb23]\n+111:35-111:66: @0.Call: _2 = Pin::&lt;&amp;mut F&gt;::new_unchecked(move _3) -&gt; [return: bb1, unwind: bb20]\n 111:13-111:23: @1[1]: FakeRead(ForLet, _2)\n-119:60-119:77: @1.Call: _6 = null::&lt;()&gt;() -&gt; [return: bb2, unwind: bb23]\n+119:60-119:77: @1.Call: _6 = null::&lt;()&gt;() -&gt; [return: bb2, unwind: bb20]\n 119:80-119:86: @2[3]: _9 = const {alloc0: &amp;RawWakerVTable}\n 119:79-119:86: @2[4]: _8 = &amp;(*_9)\n 119:79-119:86: @2[5]: _7 = &amp;(*_8)\n-119:46-119:87: @2.Call: _5 = RawWaker::new(move _6, move _7) -&gt; [return: bb3, unwind: bb23]\n-119:30-119:88: @3.Call: _4 = Waker::from_raw(move _5) -&gt; [return: bb4, unwind: bb23]\n+119:46-119:87: @2.Call: _5 = RawWaker::new(move _6, move _7) -&gt; [return: bb3, unwind: bb20]\n+119:30-119:88: @3.Call: _4 = Waker::from_raw(move _5) -&gt; [return: bb4, unwind: bb20]\n 119:13-119:18: @4[1]: FakeRead(ForLet, _4)\n 120:47-120:53: @4[7]: _12 = &amp;_4\n 120:47-120:53: @4[8]: _11 = &amp;(*_12)\n-120:27-120:54: @4.Call: _10 = Context::from_waker(move _11) -&gt; [return: bb5, unwind: bb22]\n+120:27-120:54: @4.Call: _10 = Context::from_waker(move _11) -&gt; [return: bb5, unwind: bb19]\n 120:13-120:24: @5[1]: FakeRead(ForLet, _10)\">        static VTABLE: RawWakerVTable = RawWakerVTable::new(</span></span>\n <span class=\"line\"><span class=\"code even\" style=\"--layer: 1\" title=\"111:54-111:65: @0[2]: _3 = &amp;mut _1\n-111:35-111:66: @0.Call: _2 = Pin::&lt;&amp;mut F&gt;::new_unchecked(move _3) -&gt; [return: bb1, unwind: bb23]\n+111:35-111:66: @0.Call: _2 = Pin::&lt;&amp;mut F&gt;::new_unchecked(move _3) -&gt; [return: bb1, unwind: bb20]\n 111:13-111:23: @1[1]: FakeRead(ForLet, _2)\n-119:60-119:77: @1.Call: _6 = null::&lt;()&gt;() -&gt; [return: bb2, unwind: bb23]\n+119:60-119:77: @1.Call: _6 = null::&lt;()&gt;() -&gt; [return: bb2, unwind: bb20]\n 119:80-119:86: @2[3]: _9 = const {alloc0: &amp;RawWakerVTable}\n 119:79-119:86: @2[4]: _8 = &amp;(*_9)\n 119:79-119:86: @2[5]: _7 = &amp;(*_8)\n-119:46-119:87: @2.Call: _5 = RawWaker::new(move _6, move _7) -&gt; [return: bb3, unwind: bb23]\n-119:30-119:88: @3.Call: _4 = Waker::from_raw(move _5) -&gt; [return: bb4, unwind: bb23]\n+119:46-119:87: @2.Call: _5 = RawWaker::new(move _6, move _7) -&gt; [return: bb3, unwind: bb20]\n+119:30-119:88: @3.Call: _4 = Waker::from_raw(move _5) -&gt; [return: bb4, unwind: bb20]\n 119:13-119:18: @4[1]: FakeRead(ForLet, _4)\n 120:47-120:53: @4[7]: _12 = &amp;_4\n 120:47-120:53: @4[8]: _11 = &amp;(*_12)\n-120:27-120:54: @4.Call: _10 = Context::from_waker(move _11) -&gt; [return: bb5, unwind: bb22]\n+120:27-120:54: @4.Call: _10 = Context::from_waker(move _11) -&gt; [return: bb5, unwind: bb19]\n 120:13-120:24: @5[1]: FakeRead(ForLet, _10)\">            |_| unimplemented!(\"clone\"),</span></span>\n <span class=\"line\"><span class=\"code even\" style=\"--layer: 1\" title=\"111:54-111:65: @0[2]: _3 = &amp;mut _1\n-111:35-111:66: @0.Call: _2 = Pin::&lt;&amp;mut F&gt;::new_unchecked(move _3) -&gt; [return: bb1, unwind: bb23]\n+111:35-111:66: @0.Call: _2 = Pin::&lt;&amp;mut F&gt;::new_unchecked(move _3) -&gt; [return: bb1, unwind: bb20]\n 111:13-111:23: @1[1]: FakeRead(ForLet, _2)\n-119:60-119:77: @1.Call: _6 = null::&lt;()&gt;() -&gt; [return: bb2, unwind: bb23]\n+119:60-119:77: @1.Call: _6 = null::&lt;()&gt;() -&gt; [return: bb2, unwind: bb20]\n 119:80-119:86: @2[3]: _9 = const {alloc0: &amp;RawWakerVTable}\n 119:79-119:86: @2[4]: _8 = &amp;(*_9)\n 119:79-119:86: @2[5]: _7 = &amp;(*_8)\n-119:46-119:87: @2.Call: _5 = RawWaker::new(move _6, move _7) -&gt; [return: bb3, unwind: bb23]\n-119:30-119:88: @3.Call: _4 = Waker::from_raw(move _5) -&gt; [return: bb4, unwind: bb23]\n+119:46-119:87: @2.Call: _5 = RawWaker::new(move _6, move _7) -&gt; [return: bb3, unwind: bb20]\n+119:30-119:88: @3.Call: _4 = Waker::from_raw(move _5) -&gt; [return: bb4, unwind: bb20]\n 119:13-119:18: @4[1]: FakeRead(ForLet, _4)\n 120:47-120:53: @4[7]: _12 = &amp;_4\n 120:47-120:53: @4[8]: _11 = &amp;(*_12)\n-120:27-120:54: @4.Call: _10 = Context::from_waker(move _11) -&gt; [return: bb5, unwind: bb22]\n+120:27-120:54: @4.Call: _10 = Context::from_waker(move _11) -&gt; [return: bb5, unwind: bb19]\n 120:13-120:24: @5[1]: FakeRead(ForLet, _10)\">            |_| unimplemented!(\"wake\"),</span></span>\n <span class=\"line\"><span class=\"code even\" style=\"--layer: 1\" title=\"111:54-111:65: @0[2]: _3 = &amp;mut _1\n-111:35-111:66: @0.Call: _2 = Pin::&lt;&amp;mut F&gt;::new_unchecked(move _3) -&gt; [return: bb1, unwind: bb23]\n+111:35-111:66: @0.Call: _2 = Pin::&lt;&amp;mut F&gt;::new_unchecked(move _3) -&gt; [return: bb1, unwind: bb20]\n 111:13-111:23: @1[1]: FakeRead(ForLet, _2)\n-119:60-119:77: @1.Call: _6 = null::&lt;()&gt;() -&gt; [return: bb2, unwind: bb23]\n+119:60-119:77: @1.Call: _6 = null::&lt;()&gt;() -&gt; [return: bb2, unwind: bb20]\n 119:80-119:86: @2[3]: _9 = const {alloc0: &amp;RawWakerVTable}\n 119:79-119:86: @2[4]: _8 = &amp;(*_9)\n 119:79-119:86: @2[5]: _7 = &amp;(*_8)\n-119:46-119:87: @2.Call: _5 = RawWaker::new(move _6, move _7) -&gt; [return: bb3, unwind: bb23]\n-119:30-119:88: @3.Call: _4 = Waker::from_raw(move _5) -&gt; [return: bb4, unwind: bb23]\n+119:46-119:87: @2.Call: _5 = RawWaker::new(move _6, move _7) -&gt; [return: bb3, unwind: bb20]\n+119:30-119:88: @3.Call: _4 = Waker::from_raw(move _5) -&gt; [return: bb4, unwind: bb20]\n 119:13-119:18: @4[1]: FakeRead(ForLet, _4)\n 120:47-120:53: @4[7]: _12 = &amp;_4\n 120:47-120:53: @4[8]: _11 = &amp;(*_12)\n-120:27-120:54: @4.Call: _10 = Context::from_waker(move _11) -&gt; [return: bb5, unwind: bb22]\n+120:27-120:54: @4.Call: _10 = Context::from_waker(move _11) -&gt; [return: bb5, unwind: bb19]\n 120:13-120:24: @5[1]: FakeRead(ForLet, _10)\">            |_| unimplemented!(\"wake_by_ref\"),</span></span>\n <span class=\"line\"><span class=\"code even\" style=\"--layer: 1\" title=\"111:54-111:65: @0[2]: _3 = &amp;mut _1\n-111:35-111:66: @0.Call: _2 = Pin::&lt;&amp;mut F&gt;::new_unchecked(move _3) -&gt; [return: bb1, unwind: bb23]\n+111:35-111:66: @0.Call: _2 = Pin::&lt;&amp;mut F&gt;::new_unchecked(move _3) -&gt; [return: bb1, unwind: bb20]\n 111:13-111:23: @1[1]: FakeRead(ForLet, _2)\n-119:60-119:77: @1.Call: _6 = null::&lt;()&gt;() -&gt; [return: bb2, unwind: bb23]\n+119:60-119:77: @1.Call: _6 = null::&lt;()&gt;() -&gt; [return: bb2, unwind: bb20]\n 119:80-119:86: @2[3]: _9 = const {alloc0: &amp;RawWakerVTable}\n 119:79-119:86: @2[4]: _8 = &amp;(*_9)\n 119:79-119:86: @2[5]: _7 = &amp;(*_8)\n-119:46-119:87: @2.Call: _5 = RawWaker::new(move _6, move _7) -&gt; [return: bb3, unwind: bb23]\n-119:30-119:88: @3.Call: _4 = Waker::from_raw(move _5) -&gt; [return: bb4, unwind: bb23]\n+119:46-119:87: @2.Call: _5 = RawWaker::new(move _6, move _7) -&gt; [return: bb3, unwind: bb20]\n+119:30-119:88: @3.Call: _4 = Waker::from_raw(move _5) -&gt; [return: bb4, unwind: bb20]\n 119:13-119:18: @4[1]: FakeRead(ForLet, _4)\n 120:47-120:53: @4[7]: _12 = &amp;_4\n 120:47-120:53: @4[8]: _11 = &amp;(*_12)\n-120:27-120:54: @4.Call: _10 = Context::from_waker(move _11) -&gt; [return: bb5, unwind: bb22]\n+120:27-120:54: @4.Call: _10 = Context::from_waker(move _11) -&gt; [return: bb5, unwind: bb19]\n 120:13-120:24: @5[1]: FakeRead(ForLet, _10)\">            |_| (),</span></span>\n <span class=\"line\"><span class=\"code even\" style=\"--layer: 1\" title=\"111:54-111:65: @0[2]: _3 = &amp;mut _1\n-111:35-111:66: @0.Call: _2 = Pin::&lt;&amp;mut F&gt;::new_unchecked(move _3) -&gt; [return: bb1, unwind: bb23]\n+111:35-111:66: @0.Call: _2 = Pin::&lt;&amp;mut F&gt;::new_unchecked(move _3) -&gt; [return: bb1, unwind: bb20]\n 111:13-111:23: @1[1]: FakeRead(ForLet, _2)\n-119:60-119:77: @1.Call: _6 = null::&lt;()&gt;() -&gt; [return: bb2, unwind: bb23]\n+119:60-119:77: @1.Call: _6 = null::&lt;()&gt;() -&gt; [return: bb2, unwind: bb20]\n 119:80-119:86: @2[3]: _9 = const {alloc0: &amp;RawWakerVTable}\n 119:79-119:86: @2[4]: _8 = &amp;(*_9)\n 119:79-119:86: @2[5]: _7 = &amp;(*_8)\n-119:46-119:87: @2.Call: _5 = RawWaker::new(move _6, move _7) -&gt; [return: bb3, unwind: bb23]\n-119:30-119:88: @3.Call: _4 = Waker::from_raw(move _5) -&gt; [return: bb4, unwind: bb23]\n+119:46-119:87: @2.Call: _5 = RawWaker::new(move _6, move _7) -&gt; [return: bb3, unwind: bb20]\n+119:30-119:88: @3.Call: _4 = Waker::from_raw(move _5) -&gt; [return: bb4, unwind: bb20]\n 119:13-119:18: @4[1]: FakeRead(ForLet, _4)\n 120:47-120:53: @4[7]: _12 = &amp;_4\n 120:47-120:53: @4[8]: _11 = &amp;(*_12)\n-120:27-120:54: @4.Call: _10 = Context::from_waker(move _11) -&gt; [return: bb5, unwind: bb22]\n+120:27-120:54: @4.Call: _10 = Context::from_waker(move _11) -&gt; [return: bb5, unwind: bb19]\n 120:13-120:24: @5[1]: FakeRead(ForLet, _10)\">        );</span></span>\n <span class=\"line\"><span class=\"code even\" style=\"--layer: 1\" title=\"111:54-111:65: @0[2]: _3 = &amp;mut _1\n-111:35-111:66: @0.Call: _2 = Pin::&lt;&amp;mut F&gt;::new_unchecked(move _3) -&gt; [return: bb1, unwind: bb23]\n+111:35-111:66: @0.Call: _2 = Pin::&lt;&amp;mut F&gt;::new_unchecked(move _3) -&gt; [return: bb1, unwind: bb20]\n 111:13-111:23: @1[1]: FakeRead(ForLet, _2)\n-119:60-119:77: @1.Call: _6 = null::&lt;()&gt;() -&gt; [return: bb2, unwind: bb23]\n+119:60-119:77: @1.Call: _6 = null::&lt;()&gt;() -&gt; [return: bb2, unwind: bb20]\n 119:80-119:86: @2[3]: _9 = const {alloc0: &amp;RawWakerVTable}\n 119:79-119:86: @2[4]: _8 = &amp;(*_9)\n 119:79-119:86: @2[5]: _7 = &amp;(*_8)\n-119:46-119:87: @2.Call: _5 = RawWaker::new(move _6, move _7) -&gt; [return: bb3, unwind: bb23]\n-119:30-119:88: @3.Call: _4 = Waker::from_raw(move _5) -&gt; [return: bb4, unwind: bb23]\n+119:46-119:87: @2.Call: _5 = RawWaker::new(move _6, move _7) -&gt; [return: bb3, unwind: bb20]\n+119:30-119:88: @3.Call: _4 = Waker::from_raw(move _5) -&gt; [return: bb4, unwind: bb20]\n 119:13-119:18: @4[1]: FakeRead(ForLet, _4)\n 120:47-120:53: @4[7]: _12 = &amp;_4\n 120:47-120:53: @4[8]: _11 = &amp;(*_12)\n-120:27-120:54: @4.Call: _10 = Context::from_waker(move _11) -&gt; [return: bb5, unwind: bb22]\n+120:27-120:54: @4.Call: _10 = Context::from_waker(move _11) -&gt; [return: bb5, unwind: bb19]\n 120:13-120:24: @5[1]: FakeRead(ForLet, _10)\">        let waker = unsafe { Waker::from_raw(RawWaker::new(core::ptr::null(), &amp;VTABLE)) };</span></span>\n <span class=\"line\"><span class=\"code even\" style=\"--layer: 1\" title=\"111:54-111:65: @0[2]: _3 = &amp;mut _1\n-111:35-111:66: @0.Call: _2 = Pin::&lt;&amp;mut F&gt;::new_unchecked(move _3) -&gt; [return: bb1, unwind: bb23]\n+111:35-111:66: @0.Call: _2 = Pin::&lt;&amp;mut F&gt;::new_unchecked(move _3) -&gt; [return: bb1, unwind: bb20]\n 111:13-111:23: @1[1]: FakeRead(ForLet, _2)\n-119:60-119:77: @1.Call: _6 = null::&lt;()&gt;() -&gt; [return: bb2, unwind: bb23]\n+119:60-119:77: @1.Call: _6 = null::&lt;()&gt;() -&gt; [return: bb2, unwind: bb20]\n 119:80-119:86: @2[3]: _9 = const {alloc0: &amp;RawWakerVTable}\n 119:79-119:86: @2[4]: _8 = &amp;(*_9)\n 119:79-119:86: @2[5]: _7 = &amp;(*_8)\n-119:46-119:87: @2.Call: _5 = RawWaker::new(move _6, move _7) -&gt; [return: bb3, unwind: bb23]\n-119:30-119:88: @3.Call: _4 = Waker::from_raw(move _5) -&gt; [return: bb4, unwind: bb23]\n+119:46-119:87: @2.Call: _5 = RawWaker::new(move _6, move _7) -&gt; [return: bb3, unwind: bb20]\n+119:30-119:88: @3.Call: _4 = Waker::from_raw(move _5) -&gt; [return: bb4, unwind: bb20]\n 119:13-119:18: @4[1]: FakeRead(ForLet, _4)\n 120:47-120:53: @4[7]: _12 = &amp;_4\n 120:47-120:53: @4[8]: _11 = &amp;(*_12)\n-120:27-120:54: @4.Call: _10 = Context::from_waker(move _11) -&gt; [return: bb5, unwind: bb22]\n+120:27-120:54: @4.Call: _10 = Context::from_waker(move _11) -&gt; [return: bb5, unwind: bb19]\n 120:13-120:24: @5[1]: FakeRead(ForLet, _10)\">        let mut context = Context::from_waker(&amp;waker)<span class=\"annotation\">\u2989@0,1,2,3,4,5</span></span></span><span class=\"code\" style=\"--layer: 0\">;</span></span>\n <span class=\"line\"><span class=\"code\" style=\"--layer: 0\"></span></span>\n <span class=\"line\"><span class=\"code\" style=\"--layer: 0\">        loop {</span></span>\n <span class=\"line\"><span class=\"code\" style=\"--layer: 0\">            if let Poll::Ready(</span><span><span class=\"code odd\" style=\"--layer: 1\" title=\"123:32-123:35: @12[1]: _20 = move ((_14 as Ready).0: &lt;F as std::future::Future&gt;::Output)\"><span class=\"annotation\">@10,12,14,15,16,17\u298a</span>val<span class=\"annotation\">\u2989@10,12,14,15,16,17</span></span></span><span class=\"code\" style=\"--layer: 0\">) = </span><span><span class=\"code even\" style=\"--layer: 1\" title=\"123:39-123:45: @7[3]: _16 = &amp;mut _2\n-123:39-123:54: @7.Call: _15 = Pin::&lt;&amp;mut F&gt;::as_mut(move _16) -&gt; [return: bb8, unwind: bb22]\n+123:39-123:54: @7.Call: _15 = Pin::&lt;&amp;mut F&gt;::as_mut(move _16) -&gt; [return: bb8, unwind: bb19]\n 123:60-123:72: @8[3]: _18 = &amp;mut _10\n 123:60-123:72: @8[4]: _17 = &amp;mut (*_18)\n-123:39-123:73: @8.Call: _14 = &lt;F as Future&gt;::poll(move _15, move _17) -&gt; [return: bb9, unwind: bb22]\n+123:39-123:73: @8.Call: _14 = &lt;F as Future&gt;::poll(move _15, move _17) -&gt; [return: bb9, unwind: bb19]\n 123:39-123:73: @9[2]: FakeRead(ForMatchedPlace, _14)\"><span class=\"annotation\">@6,7,8,9\u298a</span>future.as_mut().poll(&amp;mut context)<span class=\"annotation\">\u2989@6,7,8,9</span></span></span><span class=\"code\" style=\"--layer: 0\"> {</span></span>\n <span class=\"line\"><span class=\"code\" style=\"--layer: 0\">                break </span><span><span class=\"code odd\" style=\"--layer: 1\" title=\"124:23-124:26: @12[2]: _0 = move _20\"><span class=\"annotation\">@10,12,14,15,16,17\u298a</span>val<span class=\"annotation\">\u2989@10,12,14,15,16,17</span></span></span><span class=\"code\" style=\"--layer: 0\">;</span></span>\n <span class=\"line\"><span class=\"code\" style=\"--layer: 0\">            }</span><span><span class=\"code even\" style=\"--layer: 1\" title=\"125:14-125:14: @11[0]: _13 = const ()\"><span class=\"annotation\">@11,13\u298a</span>\u2038<span class=\"annotation\">\u2989@11,13</span></span></span><span class=\"code\" style=\"--layer: 0\"></span></span>"}, {"sha": "313a36ed6c2f27192ed8704f63bd88bf5b4567d1", "filename": "src/test/run-make-fulldeps/coverage-spanview/expected_mir_dump.async/async.main.-------.InstrumentCoverage.0.html", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/a71a81948074f7a3e2b5ce0dee3ad98fa22f793b/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-spanview%2Fexpected_mir_dump.async%2Fasync.main.-------.InstrumentCoverage.0.html", "raw_url": "https://github.com/rust-lang/rust/raw/a71a81948074f7a3e2b5ce0dee3ad98fa22f793b/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-spanview%2Fexpected_mir_dump.async%2Fasync.main.-------.InstrumentCoverage.0.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-spanview%2Fexpected_mir_dump.async%2Fasync.main.-------.InstrumentCoverage.0.html?ref=a71a81948074f7a3e2b5ce0dee3ad98fa22f793b", "patch": "@@ -69,9 +69,9 @@\n </style>\n </head>\n <body>\n-<div class=\"code\" style=\"counter-reset: line 92\"><span class=\"line\"><span><span class=\"code even\" style=\"--layer: 1\" title=\"94:13-94:18: @0.Call: _1 = g(const 10_u8) -&gt; [return: bb1, unwind: bb15]\n-95:13-95:17: @2.Call: _2 = h(const 9_usize) -&gt; [return: bb3, unwind: bb15]\n-96:31-96:35: @4.Call: _4 = i(const 8_u8) -&gt; [return: bb5, unwind: bb15]\n+<div class=\"code\" style=\"counter-reset: line 92\"><span class=\"line\"><span><span class=\"code even\" style=\"--layer: 1\" title=\"94:13-94:18: @0.Call: _1 = g(const 10_u8) -&gt; [return: bb1, unwind: bb16]\n+95:13-95:17: @2.Call: _2 = h(const 9_usize) -&gt; [return: bb3, unwind: bb16]\n+96:31-96:35: @4.Call: _4 = i(const 8_u8) -&gt; [return: bb5, unwind: bb16]\n 96:22-96:36: @5.Call: _3 = Box::&lt;impl Future&gt;::pin(move _4) -&gt; [return: bb6, unwind: bb15]\n 96:9-96:19: @6[1]: FakeRead(ForLet, _3)\n 97:5-97:9: @6.Call: _5 = j(const 7_u8) -&gt; [return: bb7, unwind: bb14]\n@@ -82,9 +82,9 @@\n 100:5-100:40: @11.Call: _8 = block_on::&lt;Pin&lt;&amp;mut impl Future&gt;&gt;(move _9) -&gt; [return: bb12, unwind: bb14]\n 93:11-101:2: @12[2]: _0 = const ()\n 101:2-101:2: @13.Return: return\"><span class=\"annotation\">@0,1,2,3,4,5,6,7,8,9,10,11,12,13\u298a</span>fn main() {</span></span>\n-<span class=\"line\"><span class=\"code even\" style=\"--layer: 1\" title=\"94:13-94:18: @0.Call: _1 = g(const 10_u8) -&gt; [return: bb1, unwind: bb15]\n-95:13-95:17: @2.Call: _2 = h(const 9_usize) -&gt; [return: bb3, unwind: bb15]\n-96:31-96:35: @4.Call: _4 = i(const 8_u8) -&gt; [return: bb5, unwind: bb15]\n+<span class=\"line\"><span class=\"code even\" style=\"--layer: 1\" title=\"94:13-94:18: @0.Call: _1 = g(const 10_u8) -&gt; [return: bb1, unwind: bb16]\n+95:13-95:17: @2.Call: _2 = h(const 9_usize) -&gt; [return: bb3, unwind: bb16]\n+96:31-96:35: @4.Call: _4 = i(const 8_u8) -&gt; [return: bb5, unwind: bb16]\n 96:22-96:36: @5.Call: _3 = Box::&lt;impl Future&gt;::pin(move _4) -&gt; [return: bb6, unwind: bb15]\n 96:9-96:19: @6[1]: FakeRead(ForLet, _3)\n 97:5-97:9: @6.Call: _5 = j(const 7_u8) -&gt; [return: bb7, unwind: bb14]\n@@ -95,9 +95,9 @@\n 100:5-100:40: @11.Call: _8 = block_on::&lt;Pin&lt;&amp;mut impl Future&gt;&gt;(move _9) -&gt; [return: bb12, unwind: bb14]\n 93:11-101:2: @12[2]: _0 = const ()\n 101:2-101:2: @13.Return: return\">    let _ = g(10);</span></span>\n-<span class=\"line\"><span class=\"code even\" style=\"--layer: 1\" title=\"94:13-94:18: @0.Call: _1 = g(const 10_u8) -&gt; [return: bb1, unwind: bb15]\n-95:13-95:17: @2.Call: _2 = h(const 9_usize) -&gt; [return: bb3, unwind: bb15]\n-96:31-96:35: @4.Call: _4 = i(const 8_u8) -&gt; [return: bb5, unwind: bb15]\n+<span class=\"line\"><span class=\"code even\" style=\"--layer: 1\" title=\"94:13-94:18: @0.Call: _1 = g(const 10_u8) -&gt; [return: bb1, unwind: bb16]\n+95:13-95:17: @2.Call: _2 = h(const 9_usize) -&gt; [return: bb3, unwind: bb16]\n+96:31-96:35: @4.Call: _4 = i(const 8_u8) -&gt; [return: bb5, unwind: bb16]\n 96:22-96:36: @5.Call: _3 = Box::&lt;impl Future&gt;::pin(move _4) -&gt; [return: bb6, unwind: bb15]\n 96:9-96:19: @6[1]: FakeRead(ForLet, _3)\n 97:5-97:9: @6.Call: _5 = j(const 7_u8) -&gt; [return: bb7, unwind: bb14]\n@@ -108,9 +108,9 @@\n 100:5-100:40: @11.Call: _8 = block_on::&lt;Pin&lt;&amp;mut impl Future&gt;&gt;(move _9) -&gt; [return: bb12, unwind: bb14]\n 93:11-101:2: @12[2]: _0 = const ()\n 101:2-101:2: @13.Return: return\">    let _ = h(9);</span></span>\n-<span class=\"line\"><span class=\"code even\" style=\"--layer: 1\" title=\"94:13-94:18: @0.Call: _1 = g(const 10_u8) -&gt; [return: bb1, unwind: bb15]\n-95:13-95:17: @2.Call: _2 = h(const 9_usize) -&gt; [return: bb3, unwind: bb15]\n-96:31-96:35: @4.Call: _4 = i(const 8_u8) -&gt; [return: bb5, unwind: bb15]\n+<span class=\"line\"><span class=\"code even\" style=\"--layer: 1\" title=\"94:13-94:18: @0.Call: _1 = g(const 10_u8) -&gt; [return: bb1, unwind: bb16]\n+95:13-95:17: @2.Call: _2 = h(const 9_usize) -&gt; [return: bb3, unwind: bb16]\n+96:31-96:35: @4.Call: _4 = i(const 8_u8) -&gt; [return: bb5, unwind: bb16]\n 96:22-96:36: @5.Call: _3 = Box::&lt;impl Future&gt;::pin(move _4) -&gt; [return: bb6, unwind: bb15]\n 96:9-96:19: @6[1]: FakeRead(ForLet, _3)\n 97:5-97:9: @6.Call: _5 = j(const 7_u8) -&gt; [return: bb7, unwind: bb14]\n@@ -121,9 +121,9 @@\n 100:5-100:40: @11.Call: _8 = block_on::&lt;Pin&lt;&amp;mut impl Future&gt;&gt;(move _9) -&gt; [return: bb12, unwind: bb14]\n 93:11-101:2: @12[2]: _0 = const ()\n 101:2-101:2: @13.Return: return\">    let mut future = Box::pin(i(8));</span></span>\n-<span class=\"line\"><span class=\"code even\" style=\"--layer: 1\" title=\"94:13-94:18: @0.Call: _1 = g(const 10_u8) -&gt; [return: bb1, unwind: bb15]\n-95:13-95:17: @2.Call: _2 = h(const 9_usize) -&gt; [return: bb3, unwind: bb15]\n-96:31-96:35: @4.Call: _4 = i(const 8_u8) -&gt; [return: bb5, unwind: bb15]\n+<span class=\"line\"><span class=\"code even\" style=\"--layer: 1\" title=\"94:13-94:18: @0.Call: _1 = g(const 10_u8) -&gt; [return: bb1, unwind: bb16]\n+95:13-95:17: @2.Call: _2 = h(const 9_usize) -&gt; [return: bb3, unwind: bb16]\n+96:31-96:35: @4.Call: _4 = i(const 8_u8) -&gt; [return: bb5, unwind: bb16]\n 96:22-96:36: @5.Call: _3 = Box::&lt;impl Future&gt;::pin(move _4) -&gt; [return: bb6, unwind: bb15]\n 96:9-96:19: @6[1]: FakeRead(ForLet, _3)\n 97:5-97:9: @6.Call: _5 = j(const 7_u8) -&gt; [return: bb7, unwind: bb14]\n@@ -134,9 +134,9 @@\n 100:5-100:40: @11.Call: _8 = block_on::&lt;Pin&lt;&amp;mut impl Future&gt;&gt;(move _9) -&gt; [return: bb12, unwind: bb14]\n 93:11-101:2: @12[2]: _0 = const ()\n 101:2-101:2: @13.Return: return\">    j(7);</span></span>\n-<span class=\"line\"><span class=\"code even\" style=\"--layer: 1\" title=\"94:13-94:18: @0.Call: _1 = g(const 10_u8) -&gt; [return: bb1, unwind: bb15]\n-95:13-95:17: @2.Call: _2 = h(const 9_usize) -&gt; [return: bb3, unwind: bb15]\n-96:31-96:35: @4.Call: _4 = i(const 8_u8) -&gt; [return: bb5, unwind: bb15]\n+<span class=\"line\"><span class=\"code even\" style=\"--layer: 1\" title=\"94:13-94:18: @0.Call: _1 = g(const 10_u8) -&gt; [return: bb1, unwind: bb16]\n+95:13-95:17: @2.Call: _2 = h(const 9_usize) -&gt; [return: bb3, unwind: bb16]\n+96:31-96:35: @4.Call: _4 = i(const 8_u8) -&gt; [return: bb5, unwind: bb16]\n 96:22-96:36: @5.Call: _3 = Box::&lt;impl Future&gt;::pin(move _4) -&gt; [return: bb6, unwind: bb15]\n 96:9-96:19: @6[1]: FakeRead(ForLet, _3)\n 97:5-97:9: @6.Call: _5 = j(const 7_u8) -&gt; [return: bb7, unwind: bb14]\n@@ -147,9 +147,9 @@\n 100:5-100:40: @11.Call: _8 = block_on::&lt;Pin&lt;&amp;mut impl Future&gt;&gt;(move _9) -&gt; [return: bb12, unwind: bb14]\n 93:11-101:2: @12[2]: _0 = const ()\n 101:2-101:2: @13.Return: return\">    l(6);</span></span>\n-<span class=\"line\"><span class=\"code even\" style=\"--layer: 1\" title=\"94:13-94:18: @0.Call: _1 = g(const 10_u8) -&gt; [return: bb1, unwind: bb15]\n-95:13-95:17: @2.Call: _2 = h(const 9_usize) -&gt; [return: bb3, unwind: bb15]\n-96:31-96:35: @4.Call: _4 = i(const 8_u8) -&gt; [return: bb5, unwind: bb15]\n+<span class=\"line\"><span class=\"code even\" style=\"--layer: 1\" title=\"94:13-94:18: @0.Call: _1 = g(const 10_u8) -&gt; [return: bb1, unwind: bb16]\n+95:13-95:17: @2.Call: _2 = h(const 9_usize) -&gt; [return: bb3, unwind: bb16]\n+96:31-96:35: @4.Call: _4 = i(const 8_u8) -&gt; [return: bb5, unwind: bb16]\n 96:22-96:36: @5.Call: _3 = Box::&lt;impl Future&gt;::pin(move _4) -&gt; [return: bb6, unwind: bb15]\n 96:9-96:19: @6[1]: FakeRead(ForLet, _3)\n 97:5-97:9: @6.Call: _5 = j(const 7_u8) -&gt; [return: bb7, unwind: bb14]\n@@ -160,9 +160,9 @@\n 100:5-100:40: @11.Call: _8 = block_on::&lt;Pin&lt;&amp;mut impl Future&gt;&gt;(move _9) -&gt; [return: bb12, unwind: bb14]\n 93:11-101:2: @12[2]: _0 = const ()\n 101:2-101:2: @13.Return: return\">    let _ = m(5);</span></span>\n-<span class=\"line\"><span class=\"code even\" style=\"--layer: 1\" title=\"94:13-94:18: @0.Call: _1 = g(const 10_u8) -&gt; [return: bb1, unwind: bb15]\n-95:13-95:17: @2.Call: _2 = h(const 9_usize) -&gt; [return: bb3, unwind: bb15]\n-96:31-96:35: @4.Call: _4 = i(const 8_u8) -&gt; [return: bb5, unwind: bb15]\n+<span class=\"line\"><span class=\"code even\" style=\"--layer: 1\" title=\"94:13-94:18: @0.Call: _1 = g(const 10_u8) -&gt; [return: bb1, unwind: bb16]\n+95:13-95:17: @2.Call: _2 = h(const 9_usize) -&gt; [return: bb3, unwind: bb16]\n+96:31-96:35: @4.Call: _4 = i(const 8_u8) -&gt; [return: bb5, unwind: bb16]\n 96:22-96:36: @5.Call: _3 = Box::&lt;impl Future&gt;::pin(move _4) -&gt; [return: bb6, unwind: bb15]\n 96:9-96:19: @6[1]: FakeRead(ForLet, _3)\n 97:5-97:9: @6.Call: _5 = j(const 7_u8) -&gt; [return: bb7, unwind: bb14]\n@@ -173,9 +173,9 @@\n 100:5-100:40: @11.Call: _8 = block_on::&lt;Pin&lt;&amp;mut impl Future&gt;&gt;(move _9) -&gt; [return: bb12, unwind: bb14]\n 93:11-101:2: @12[2]: _0 = const ()\n 101:2-101:2: @13.Return: return\">    executor::block_on(future.as_mut());</span></span>\n-<span class=\"line\"><span class=\"code even\" style=\"--layer: 1\" title=\"94:13-94:18: @0.Call: _1 = g(const 10_u8) -&gt; [return: bb1, unwind: bb15]\n-95:13-95:17: @2.Call: _2 = h(const 9_usize) -&gt; [return: bb3, unwind: bb15]\n-96:31-96:35: @4.Call: _4 = i(const 8_u8) -&gt; [return: bb5, unwind: bb15]\n+<span class=\"line\"><span class=\"code even\" style=\"--layer: 1\" title=\"94:13-94:18: @0.Call: _1 = g(const 10_u8) -&gt; [return: bb1, unwind: bb16]\n+95:13-95:17: @2.Call: _2 = h(const 9_usize) -&gt; [return: bb3, unwind: bb16]\n+96:31-96:35: @4.Call: _4 = i(const 8_u8) -&gt; [return: bb5, unwind: bb16]\n 96:22-96:36: @5.Call: _3 = Box::&lt;impl Future&gt;::pin(move _4) -&gt; [return: bb6, unwind: bb15]\n 96:9-96:19: @6[1]: FakeRead(ForLet, _3)\n 97:5-97:9: @6.Call: _5 = j(const 7_u8) -&gt; [return: bb7, unwind: bb14]"}, {"sha": "9c3407cd52cb9135a79edfa3e9a51b04c3e89fc7", "filename": "src/test/run-make-fulldeps/coverage-spanview/expected_mir_dump.closure/closure.main-{closure#2}.-------.InstrumentCoverage.0.html", "status": "modified", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/a71a81948074f7a3e2b5ce0dee3ad98fa22f793b/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-spanview%2Fexpected_mir_dump.closure%2Fclosure.main-%7Bclosure%232%7D.-------.InstrumentCoverage.0.html", "raw_url": "https://github.com/rust-lang/rust/raw/a71a81948074f7a3e2b5ce0dee3ad98fa22f793b/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-spanview%2Fexpected_mir_dump.closure%2Fclosure.main-%7Bclosure%232%7D.-------.InstrumentCoverage.0.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-spanview%2Fexpected_mir_dump.closure%2Fclosure.main-%7Bclosure%232%7D.-------.InstrumentCoverage.0.html?ref=a71a81948074f7a3e2b5ce0dee3ad98fa22f793b", "patch": "@@ -78,6 +78,7 @@\n 100:12-100:20: @0[5]: _5 = (*((*_1).0: &amp;bool))\">        let mut countdown = 0;</span></span>\n <span class=\"line\"><span class=\"code even\" style=\"--layer: 1\" title=\"99:29-99:30: @0[1]: _3 = const 0_i32\n 99:13-99:26: @0[2]: FakeRead(ForLet, _3)\n+<<<<<<< HEAD\n 100:12-100:20: @0[5]: _5 = (*((*_1).0: &amp;bool))\">        if is_false<span class=\"annotation\">\u2989@0</span></span></span><span class=\"code\" style=\"--layer: 0\"> </span><span><span class=\"code odd\" style=\"--layer: 1\" title=\"101:13-101:27: @1[0]: _3 = const 10_i32\n 100:21-102:10: @1[1]: _4 = const ()\"><span class=\"annotation\">@1\u298a</span>{</span></span>\n <span class=\"line\"><span class=\"code odd\" style=\"--layer: 1\" title=\"101:13-101:27: @1[0]: _3 = const 10_i32\n@@ -124,5 +125,102 @@\n 103:9-103:29: @6[1]: FakeRead(ForLet, _6)\n 103:9-103:29: @6[6]: _0 = move _6\n 104:6-104:6: @7.Return: return\">    }<span class=\"annotation\">\u2989@3,4,5,6,7</span></span></span></span></div>\n+||||||| parent of 3873f4c114a... Revert \"Avoid leaking block expression values\"\n+100:12-100:20: @0[5]: _5 = (*((*_1).0: &amp;bool))\n+100:12-100:20: @0[6]: FakeRead(ForMatchedPlace, _5)\">        if is_false<span class=\"annotation\">\u2989@0</span></span></span><span class=\"code\" style=\"--layer: 0\"> </span><span><span class=\"code odd\" style=\"--layer: 1\" title=\"101:13-101:27: @3[0]: _3 = const 10_i32\n+100:21-102:10: @3[1]: _4 = const ()\"><span class=\"annotation\">@1,3\u298a</span>{</span></span>\n+<span class=\"line\"><span class=\"code odd\" style=\"--layer: 1\" title=\"101:13-101:27: @3[0]: _3 = const 10_i32\n+100:21-102:10: @3[1]: _4 = const ()\">            countdown = 10;</span></span>\n+<span class=\"line\"><span class=\"code odd\" style=\"--layer: 1\" title=\"101:13-101:27: @3[0]: _3 = const 10_i32\n+100:21-102:10: @3[1]: _4 = const ()\">        }<span class=\"annotation\">\u2989@1,3</span></span></span><span><span class=\"code even\" style=\"--layer: 1\" title=\"102:10-102:10: @2[0]: _4 = const ()\"><span class=\"annotation\">@2\u298a</span>\u2038<span class=\"annotation\">\u2989@2</span></span></span><span class=\"code\" style=\"--layer: 0\"></span></span>\n+<span class=\"line\"><span class=\"code\" style=\"--layer: 0\">        </span><span><span class=\"code odd\" style=\"--layer: 1\" title=\"103:17-103:23: @4[7]: _22 = const main::{closure#2}::promoted[0]\n+103:17-103:23: @4[8]: _10 = &amp;(*_22)\n+103:17-103:23: @4[9]: _9 = &amp;(*_10)\n+103:17-103:23: @4[10]: _8 = move _9 as &amp;[&amp;str] (Pointer(Unsize))\n+103:25-103:28: @4[18]: _17 = &amp;_2\n+103:9-103:29: @4[19]: _16 = (move _17,)\n+103:9-103:29: @4[21]: FakeRead(ForMatchedPlace, _16)\n+103:9-103:29: @4[23]: _18 = (_16.0: &amp;&amp;str)\n+103:9-103:29: @4[26]: _20 = &amp;(*_18)\n+103:9-103:29: @4[28]: _21 = &lt;&amp;str as std::fmt::Display&gt;::fmt as for&lt;&#39;r, &#39;s, &#39;t0&gt; fn(&amp;&#39;r &amp;str, &amp;&#39;s mut std::fmt::Formatter&lt;&#39;t0&gt;) -&gt; std::result::Result&lt;(), std::fmt::Error&gt; (Pointer(ReifyFnPointer))\n+103:9-103:29: @4.Call: _19 = ArgumentV1::new::&lt;&amp;str&gt;(move _20, move _21) -&gt; [return: bb5, unwind: bb10]\n+103:9-103:29: @5[2]: _15 = [move _19]\n+103:9-103:29: @5[5]: _14 = &amp;_15\n+103:9-103:29: @5[6]: _13 = &amp;(*_14)\n+103:9-103:29: @5[7]: _12 = move _13 as &amp;[std::fmt::ArgumentV1] (Pointer(Unsize))\n+103:9-103:29: @5.Call: _7 = Arguments::new_v1(move _8, move _12) -&gt; [return: bb6, unwind: bb10]\n+103:9-103:29: @6.Call: _6 = format(move _7) -&gt; [return: bb7, unwind: bb10]\n+103:9-103:29: @7[1]: FakeRead(ForLet, _6)\n+103:9-103:29: @7[6]: _0 = move _6\n+104:6-104:6: @8.Return: return\"><span class=\"annotation\">@4,5,6,7,8\u298a</span>format!(\"'{}'\", val)</span></span>\n+<span class=\"line\"><span class=\"code odd\" style=\"--layer: 1\" title=\"103:17-103:23: @4[7]: _22 = const main::{closure#2}::promoted[0]\n+103:17-103:23: @4[8]: _10 = &amp;(*_22)\n+103:17-103:23: @4[9]: _9 = &amp;(*_10)\n+103:17-103:23: @4[10]: _8 = move _9 as &amp;[&amp;str] (Pointer(Unsize))\n+103:25-103:28: @4[18]: _17 = &amp;_2\n+103:9-103:29: @4[19]: _16 = (move _17,)\n+103:9-103:29: @4[21]: FakeRead(ForMatchedPlace, _16)\n+103:9-103:29: @4[23]: _18 = (_16.0: &amp;&amp;str)\n+103:9-103:29: @4[26]: _20 = &amp;(*_18)\n+103:9-103:29: @4[28]: _21 = &lt;&amp;str as std::fmt::Display&gt;::fmt as for&lt;&#39;r, &#39;s, &#39;t0&gt; fn(&amp;&#39;r &amp;str, &amp;&#39;s mut std::fmt::Formatter&lt;&#39;t0&gt;) -&gt; std::result::Result&lt;(), std::fmt::Error&gt; (Pointer(ReifyFnPointer))\n+103:9-103:29: @4.Call: _19 = ArgumentV1::new::&lt;&amp;str&gt;(move _20, move _21) -&gt; [return: bb5, unwind: bb10]\n+103:9-103:29: @5[2]: _15 = [move _19]\n+103:9-103:29: @5[5]: _14 = &amp;_15\n+103:9-103:29: @5[6]: _13 = &amp;(*_14)\n+103:9-103:29: @5[7]: _12 = move _13 as &amp;[std::fmt::ArgumentV1] (Pointer(Unsize))\n+103:9-103:29: @5.Call: _7 = Arguments::new_v1(move _8, move _12) -&gt; [return: bb6, unwind: bb10]\n+103:9-103:29: @6.Call: _6 = format(move _7) -&gt; [return: bb7, unwind: bb10]\n+103:9-103:29: @7[1]: FakeRead(ForLet, _6)\n+103:9-103:29: @7[6]: _0 = move _6\n+104:6-104:6: @8.Return: return\">    }<span class=\"annotation\">\u2989@4,5,6,7,8</span></span></span></span></div>\n+=======\n+100:12-100:20: @0[5]: _5 = (*((*_1).0: &amp;bool))\n+100:12-100:20: @0[6]: FakeRead(ForMatchedPlace, _5)\">        if is_false<span class=\"annotation\">\u2989@0</span></span></span><span class=\"code\" style=\"--layer: 0\"> </span><span><span class=\"code odd\" style=\"--layer: 1\" title=\"101:13-101:27: @3[0]: _3 = const 10_i32\n+100:21-102:10: @3[1]: _4 = const ()\"><span class=\"annotation\">@1,3\u298a</span>{</span></span>\n+<span class=\"line\"><span class=\"code odd\" style=\"--layer: 1\" title=\"101:13-101:27: @3[0]: _3 = const 10_i32\n+100:21-102:10: @3[1]: _4 = const ()\">            countdown = 10;</span></span>\n+<span class=\"line\"><span class=\"code odd\" style=\"--layer: 1\" title=\"101:13-101:27: @3[0]: _3 = const 10_i32\n+100:21-102:10: @3[1]: _4 = const ()\">        }<span class=\"annotation\">\u2989@1,3</span></span></span><span><span class=\"code even\" style=\"--layer: 1\" title=\"102:10-102:10: @2[0]: _4 = const ()\"><span class=\"annotation\">@2\u298a</span>\u2038<span class=\"annotation\">\u2989@2</span></span></span><span class=\"code\" style=\"--layer: 0\"></span></span>\n+<span class=\"line\"><span class=\"code\" style=\"--layer: 0\">        </span><span><span class=\"code odd\" style=\"--layer: 1\" title=\"103:17-103:23: @4[7]: _22 = const main::{closure#2}::promoted[0]\n+103:17-103:23: @4[8]: _10 = &amp;(*_22)\n+103:17-103:23: @4[9]: _9 = &amp;(*_10)\n+103:17-103:23: @4[10]: _8 = move _9 as &amp;[&amp;str] (Pointer(Unsize))\n+103:25-103:28: @4[18]: _17 = &amp;_2\n+103:9-103:29: @4[19]: _16 = (move _17,)\n+103:9-103:29: @4[21]: FakeRead(ForMatchedPlace, _16)\n+103:9-103:29: @4[23]: _18 = (_16.0: &amp;&amp;str)\n+103:9-103:29: @4[26]: _20 = &amp;(*_18)\n+103:9-103:29: @4[28]: _21 = &lt;&amp;str as std::fmt::Display&gt;::fmt as for&lt;&#39;r, &#39;s, &#39;t0&gt; fn(&amp;&#39;r &amp;str, &amp;&#39;s mut std::fmt::Formatter&lt;&#39;t0&gt;) -&gt; std::result::Result&lt;(), std::fmt::Error&gt; (Pointer(ReifyFnPointer))\n+103:9-103:29: @4.Call: _19 = ArgumentV1::new::&lt;&amp;str&gt;(move _20, move _21) -&gt; [return: bb5, unwind: bb9]\n+103:9-103:29: @5[2]: _15 = [move _19]\n+103:9-103:29: @5[5]: _14 = &amp;_15\n+103:9-103:29: @5[6]: _13 = &amp;(*_14)\n+103:9-103:29: @5[7]: _12 = move _13 as &amp;[std::fmt::ArgumentV1] (Pointer(Unsize))\n+103:9-103:29: @5.Call: _7 = Arguments::new_v1(move _8, move _12) -&gt; [return: bb6, unwind: bb9]\n+103:9-103:29: @6.Call: _6 = format(move _7) -&gt; [return: bb7, unwind: bb9]\n+103:9-103:29: @7[1]: FakeRead(ForLet, _6)\n+103:9-103:29: @7[6]: _0 = move _6\n+104:6-104:6: @8.Return: return\"><span class=\"annotation\">@4,5,6,7,8\u298a</span>format!(\"'{}'\", val)</span></span>\n+<span class=\"line\"><span class=\"code odd\" style=\"--layer: 1\" title=\"103:17-103:23: @4[7]: _22 = const main::{closure#2}::promoted[0]\n+103:17-103:23: @4[8]: _10 = &amp;(*_22)\n+103:17-103:23: @4[9]: _9 = &amp;(*_10)\n+103:17-103:23: @4[10]: _8 = move _9 as &amp;[&amp;str] (Pointer(Unsize))\n+103:25-103:28: @4[18]: _17 = &amp;_2\n+103:9-103:29: @4[19]: _16 = (move _17,)\n+103:9-103:29: @4[21]: FakeRead(ForMatchedPlace, _16)\n+103:9-103:29: @4[23]: _18 = (_16.0: &amp;&amp;str)\n+103:9-103:29: @4[26]: _20 = &amp;(*_18)\n+103:9-103:29: @4[28]: _21 = &lt;&amp;str as std::fmt::Display&gt;::fmt as for&lt;&#39;r, &#39;s, &#39;t0&gt; fn(&amp;&#39;r &amp;str, &amp;&#39;s mut std::fmt::Formatter&lt;&#39;t0&gt;) -&gt; std::result::Result&lt;(), std::fmt::Error&gt; (Pointer(ReifyFnPointer))\n+103:9-103:29: @4.Call: _19 = ArgumentV1::new::&lt;&amp;str&gt;(move _20, move _21) -&gt; [return: bb5, unwind: bb9]\n+103:9-103:29: @5[2]: _15 = [move _19]\n+103:9-103:29: @5[5]: _14 = &amp;_15\n+103:9-103:29: @5[6]: _13 = &amp;(*_14)\n+103:9-103:29: @5[7]: _12 = move _13 as &amp;[std::fmt::ArgumentV1] (Pointer(Unsize))\n+103:9-103:29: @5.Call: _7 = Arguments::new_v1(move _8, move _12) -&gt; [return: bb6, unwind: bb9]\n+103:9-103:29: @6.Call: _6 = format(move _7) -&gt; [return: bb7, unwind: bb9]\n+103:9-103:29: @7[1]: FakeRead(ForLet, _6)\n+103:9-103:29: @7[6]: _0 = move _6\n+104:6-104:6: @8.Return: return\">    }<span class=\"annotation\">\u2989@4,5,6,7,8</span></span></span></span></div>\n+>>>>>>> 3873f4c114a... Revert \"Avoid leaking block expression values\"\n </body>\n </html>"}, {"sha": "702c7937064b75ed351bb47be067793841436f5b", "filename": "src/test/run-make-fulldeps/coverage-spanview/expected_mir_dump.closure/closure.main.-------.InstrumentCoverage.0.html", "status": "modified", "additions": 9996, "deletions": 9996, "changes": 19992, "blob_url": "https://github.com/rust-lang/rust/blob/a71a81948074f7a3e2b5ce0dee3ad98fa22f793b/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-spanview%2Fexpected_mir_dump.closure%2Fclosure.main.-------.InstrumentCoverage.0.html", "raw_url": "https://github.com/rust-lang/rust/raw/a71a81948074f7a3e2b5ce0dee3ad98fa22f793b/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-spanview%2Fexpected_mir_dump.closure%2Fclosure.main.-------.InstrumentCoverage.0.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-spanview%2Fexpected_mir_dump.closure%2Fclosure.main.-------.InstrumentCoverage.0.html?ref=a71a81948074f7a3e2b5ce0dee3ad98fa22f793b"}, {"sha": "bed5e7bb7ce888f49489df085f81d52a8e85412a", "filename": "src/test/run-make-fulldeps/coverage-spanview/expected_mir_dump.used_crate/used_crate.use_this_lib_crate.-------.InstrumentCoverage.0.html", "status": "modified", "additions": 81, "deletions": 81, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/a71a81948074f7a3e2b5ce0dee3ad98fa22f793b/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-spanview%2Fexpected_mir_dump.used_crate%2Fused_crate.use_this_lib_crate.-------.InstrumentCoverage.0.html", "raw_url": "https://github.com/rust-lang/rust/raw/a71a81948074f7a3e2b5ce0dee3ad98fa22f793b/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-spanview%2Fexpected_mir_dump.used_crate%2Fused_crate.use_this_lib_crate.-------.InstrumentCoverage.0.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-spanview%2Fexpected_mir_dump.used_crate%2Fused_crate.use_this_lib_crate.-------.InstrumentCoverage.0.html?ref=a71a81948074f7a3e2b5ce0dee3ad98fa22f793b", "patch": "@@ -69,122 +69,122 @@\n </style>\n </head>\n <body>\n-<div class=\"code\" style=\"counter-reset: line 52\"><span class=\"line\"><span><span class=\"code even\" style=\"--layer: 1\" title=\"54:5-54:90: @0.Call: _1 = used_from_bin_crate_and_lib_crate_generic_function::&lt;&amp;str&gt;(const &quot;used from library used_crate.rs&quot;) -&gt; [return: bb1, unwind: bb10]\n-55:5-57:6: @1.Call: _2 = used_with_same_type_from_bin_crate_and_lib_crate_generic_function::&lt;&amp;str&gt;(const &quot;used from library used_crate.rs&quot;) -&gt; [return: bb2, unwind: bb10]\n+<div class=\"code\" style=\"counter-reset: line 52\"><span class=\"line\"><span><span class=\"code even\" style=\"--layer: 1\" title=\"54:5-54:90: @0.Call: _1 = used_from_bin_crate_and_lib_crate_generic_function::&lt;&amp;str&gt;(const &quot;used from library used_crate.rs&quot;) -&gt; [return: bb1, unwind: bb13]\n+55:5-57:6: @1.Call: _2 = used_with_same_type_from_bin_crate_and_lib_crate_generic_function::&lt;&amp;str&gt;(const &quot;used from library used_crate.rs&quot;) -&gt; [return: bb2, unwind: bb13]\n 58:20-58:36: @2[5]: _6 = Box([i32; 4])\n 58:20-58:36: @2[6]: (*_6) = [const 5_i32, const 6_i32, const 7_i32, const 8_i32]\n 58:20-58:36: @2[7]: _5 = move _6\n 58:20-58:36: @2[8]: _4 = move _5 as std::boxed::Box&lt;[i32]&gt; (Pointer(Unsize))\n-58:20-58:36: @3.Call: _3 = slice::&lt;impl [i32]&gt;::into_vec::&lt;std::alloc::Global&gt;(move _4) -&gt; [return: bb4, unwind: bb10]\n-58:9-58:17: @4[1]: FakeRead(ForLet, _3)\n-59:52-59:60: @4[4]: _8 = move _3\n-59:5-59:61: @4.Call: _7 = used_only_from_this_lib_crate_generic_function::&lt;Vec&lt;i32&gt;&gt;(move _8) -&gt; [return: bb5, unwind: bb8]\n-60:5-60:91: @5.Call: _9 = used_only_from_this_lib_crate_generic_function::&lt;&amp;str&gt;(const &quot;used ONLY from library used_crate.rs&quot;) -&gt; [return: bb6, unwind: bb8]\n-53:25-61:2: @6[1]: _0 = const ()\n-61:2-61:2: @7.Return: return\"><span class=\"annotation\">@0,1,2,3,4,5,6,7\u298a</span>fn use_this_lib_crate() {</span></span>\n-<span class=\"line\"><span class=\"code even\" style=\"--layer: 1\" title=\"54:5-54:90: @0.Call: _1 = used_from_bin_crate_and_lib_crate_generic_function::&lt;&amp;str&gt;(const &quot;used from library used_crate.rs&quot;) -&gt; [return: bb1, unwind: bb10]\n-55:5-57:6: @1.Call: _2 = used_with_same_type_from_bin_crate_and_lib_crate_generic_function::&lt;&amp;str&gt;(const &quot;used from library used_crate.rs&quot;) -&gt; [return: bb2, unwind: bb10]\n+58:20-58:36: @4.Call: _3 = slice::&lt;impl [i32]&gt;::into_vec::&lt;std::alloc::Global&gt;(move _4) -&gt; [return: bb5, unwind: bb12]\n+58:9-58:17: @5[1]: FakeRead(ForLet, _3)\n+59:52-59:60: @5[4]: _8 = move _3\n+59:5-59:61: @5.Call: _7 = used_only_from_this_lib_crate_generic_function::&lt;Vec&lt;i32&gt;&gt;(move _8) -&gt; [return: bb6, unwind: bb9]\n+60:5-60:91: @6.Call: _9 = used_only_from_this_lib_crate_generic_function::&lt;&amp;str&gt;(const &quot;used ONLY from library used_crate.rs&quot;) -&gt; [return: bb7, unwind: bb10]\n+53:25-61:2: @7[1]: _0 = const ()\n+61:2-61:2: @8.Return: return\"><span class=\"annotation\">@0,1,2,3,4,5,6,7,8\u298a</span>fn use_this_lib_crate() {</span></span>\n+<span class=\"line\"><span class=\"code even\" style=\"--layer: 1\" title=\"54:5-54:90: @0.Call: _1 = used_from_bin_crate_and_lib_crate_generic_function::&lt;&amp;str&gt;(const &quot;used from library used_crate.rs&quot;) -&gt; [return: bb1, unwind: bb13]\n+55:5-57:6: @1.Call: _2 = used_with_same_type_from_bin_crate_and_lib_crate_generic_function::&lt;&amp;str&gt;(const &quot;used from library used_crate.rs&quot;) -&gt; [return: bb2, unwind: bb13]\n 58:20-58:36: @2[5]: _6 = Box([i32; 4])\n 58:20-58:36: @2[6]: (*_6) = [const 5_i32, const 6_i32, const 7_i32, const 8_i32]\n 58:20-58:36: @2[7]: _5 = move _6\n 58:20-58:36: @2[8]: _4 = move _5 as std::boxed::Box&lt;[i32]&gt; (Pointer(Unsize))\n-58:20-58:36: @3.Call: _3 = slice::&lt;impl [i32]&gt;::into_vec::&lt;std::alloc::Global&gt;(move _4) -&gt; [return: bb4, unwind: bb10]\n-58:9-58:17: @4[1]: FakeRead(ForLet, _3)\n-59:52-59:60: @4[4]: _8 = move _3\n-59:5-59:61: @4.Call: _7 = used_only_from_this_lib_crate_generic_function::&lt;Vec&lt;i32&gt;&gt;(move _8) -&gt; [return: bb5, unwind: bb8]\n-60:5-60:91: @5.Call: _9 = used_only_from_this_lib_crate_generic_function::&lt;&amp;str&gt;(const &quot;used ONLY from library used_crate.rs&quot;) -&gt; [return: bb6, unwind: bb8]\n-53:25-61:2: @6[1]: _0 = const ()\n-61:2-61:2: @7.Return: return\">    used_from_bin_crate_and_lib_crate_generic_function(\"used from library used_crate.rs\");</span></span>\n-<span class=\"line\"><span class=\"code even\" style=\"--layer: 1\" title=\"54:5-54:90: @0.Call: _1 = used_from_bin_crate_and_lib_crate_generic_function::&lt;&amp;str&gt;(const &quot;used from library used_crate.rs&quot;) -&gt; [return: bb1, unwind: bb10]\n-55:5-57:6: @1.Call: _2 = used_with_same_type_from_bin_crate_and_lib_crate_generic_function::&lt;&amp;str&gt;(const &quot;used from library used_crate.rs&quot;) -&gt; [return: bb2, unwind: bb10]\n+58:20-58:36: @4.Call: _3 = slice::&lt;impl [i32]&gt;::into_vec::&lt;std::alloc::Global&gt;(move _4) -&gt; [return: bb5, unwind: bb12]\n+58:9-58:17: @5[1]: FakeRead(ForLet, _3)\n+59:52-59:60: @5[4]: _8 = move _3\n+59:5-59:61: @5.Call: _7 = used_only_from_this_lib_crate_generic_function::&lt;Vec&lt;i32&gt;&gt;(move _8) -&gt; [return: bb6, unwind: bb9]\n+60:5-60:91: @6.Call: _9 = used_only_from_this_lib_crate_generic_function::&lt;&amp;str&gt;(const &quot;used ONLY from library used_crate.rs&quot;) -&gt; [return: bb7, unwind: bb10]\n+53:25-61:2: @7[1]: _0 = const ()\n+61:2-61:2: @8.Return: return\">    used_from_bin_crate_and_lib_crate_generic_function(\"used from library used_crate.rs\");</span></span>\n+<span class=\"line\"><span class=\"code even\" style=\"--layer: 1\" title=\"54:5-54:90: @0.Call: _1 = used_from_bin_crate_and_lib_crate_generic_function::&lt;&amp;str&gt;(const &quot;used from library used_crate.rs&quot;) -&gt; [return: bb1, unwind: bb13]\n+55:5-57:6: @1.Call: _2 = used_with_same_type_from_bin_crate_and_lib_crate_generic_function::&lt;&amp;str&gt;(const &quot;used from library used_crate.rs&quot;) -&gt; [return: bb2, unwind: bb13]\n 58:20-58:36: @2[5]: _6 = Box([i32; 4])\n 58:20-58:36: @2[6]: (*_6) = [const 5_i32, const 6_i32, const 7_i32, const 8_i32]\n 58:20-58:36: @2[7]: _5 = move _6\n 58:20-58:36: @2[8]: _4 = move _5 as std::boxed::Box&lt;[i32]&gt; (Pointer(Unsize))\n-58:20-58:36: @3.Call: _3 = slice::&lt;impl [i32]&gt;::into_vec::&lt;std::alloc::Global&gt;(move _4) -&gt; [return: bb4, unwind: bb10]\n-58:9-58:17: @4[1]: FakeRead(ForLet, _3)\n-59:52-59:60: @4[4]: _8 = move _3\n-59:5-59:61: @4.Call: _7 = used_only_from_this_lib_crate_generic_function::&lt;Vec&lt;i32&gt;&gt;(move _8) -&gt; [return: bb5, unwind: bb8]\n-60:5-60:91: @5.Call: _9 = used_only_from_this_lib_crate_generic_function::&lt;&amp;str&gt;(const &quot;used ONLY from library used_crate.rs&quot;) -&gt; [return: bb6, unwind: bb8]\n-53:25-61:2: @6[1]: _0 = const ()\n-61:2-61:2: @7.Return: return\">    used_with_same_type_from_bin_crate_and_lib_crate_generic_function(</span></span>\n-<span class=\"line\"><span class=\"code even\" style=\"--layer: 1\" title=\"54:5-54:90: @0.Call: _1 = used_from_bin_crate_and_lib_crate_generic_function::&lt;&amp;str&gt;(const &quot;used from library used_crate.rs&quot;) -&gt; [return: bb1, unwind: bb10]\n-55:5-57:6: @1.Call: _2 = used_with_same_type_from_bin_crate_and_lib_crate_generic_function::&lt;&amp;str&gt;(const &quot;used from library used_crate.rs&quot;) -&gt; [return: bb2, unwind: bb10]\n+58:20-58:36: @4.Call: _3 = slice::&lt;impl [i32]&gt;::into_vec::&lt;std::alloc::Global&gt;(move _4) -&gt; [return: bb5, unwind: bb12]\n+58:9-58:17: @5[1]: FakeRead(ForLet, _3)\n+59:52-59:60: @5[4]: _8 = move _3\n+59:5-59:61: @5.Call: _7 = used_only_from_this_lib_crate_generic_function::&lt;Vec&lt;i32&gt;&gt;(move _8) -&gt; [return: bb6, unwind: bb9]\n+60:5-60:91: @6.Call: _9 = used_only_from_this_lib_crate_generic_function::&lt;&amp;str&gt;(const &quot;used ONLY from library used_crate.rs&quot;) -&gt; [return: bb7, unwind: bb10]\n+53:25-61:2: @7[1]: _0 = const ()\n+61:2-61:2: @8.Return: return\">    used_with_same_type_from_bin_crate_and_lib_crate_generic_function(</span></span>\n+<span class=\"line\"><span class=\"code even\" style=\"--layer: 1\" title=\"54:5-54:90: @0.Call: _1 = used_from_bin_crate_and_lib_crate_generic_function::&lt;&amp;str&gt;(const &quot;used from library used_crate.rs&quot;) -&gt; [return: bb1, unwind: bb13]\n+55:5-57:6: @1.Call: _2 = used_with_same_type_from_bin_crate_and_lib_crate_generic_function::&lt;&amp;str&gt;(const &quot;used from library used_crate.rs&quot;) -&gt; [return: bb2, unwind: bb13]\n 58:20-58:36: @2[5]: _6 = Box([i32; 4])\n 58:20-58:36: @2[6]: (*_6) = [const 5_i32, const 6_i32, const 7_i32, const 8_i32]\n 58:20-58:36: @2[7]: _5 = move _6\n 58:20-58:36: @2[8]: _4 = move _5 as std::boxed::Box&lt;[i32]&gt; (Pointer(Unsize))\n-58:20-58:36: @3.Call: _3 = slice::&lt;impl [i32]&gt;::into_vec::&lt;std::alloc::Global&gt;(move _4) -&gt; [return: bb4, unwind: bb10]\n-58:9-58:17: @4[1]: FakeRead(ForLet, _3)\n-59:52-59:60: @4[4]: _8 = move _3\n-59:5-59:61: @4.Call: _7 = used_only_from_this_lib_crate_generic_function::&lt;Vec&lt;i32&gt;&gt;(move _8) -&gt; [return: bb5, unwind: bb8]\n-60:5-60:91: @5.Call: _9 = used_only_from_this_lib_crate_generic_function::&lt;&amp;str&gt;(const &quot;used ONLY from library used_crate.rs&quot;) -&gt; [return: bb6, unwind: bb8]\n-53:25-61:2: @6[1]: _0 = const ()\n-61:2-61:2: @7.Return: return\">        \"used from library used_crate.rs\",</span></span>\n-<span class=\"line\"><span class=\"code even\" style=\"--layer: 1\" title=\"54:5-54:90: @0.Call: _1 = used_from_bin_crate_and_lib_crate_generic_function::&lt;&amp;str&gt;(const &quot;used from library used_crate.rs&quot;) -&gt; [return: bb1, unwind: bb10]\n-55:5-57:6: @1.Call: _2 = used_with_same_type_from_bin_crate_and_lib_crate_generic_function::&lt;&amp;str&gt;(const &quot;used from library used_crate.rs&quot;) -&gt; [return: bb2, unwind: bb10]\n+58:20-58:36: @4.Call: _3 = slice::&lt;impl [i32]&gt;::into_vec::&lt;std::alloc::Global&gt;(move _4) -&gt; [return: bb5, unwind: bb12]\n+58:9-58:17: @5[1]: FakeRead(ForLet, _3)\n+59:52-59:60: @5[4]: _8 = move _3\n+59:5-59:61: @5.Call: _7 = used_only_from_this_lib_crate_generic_function::&lt;Vec&lt;i32&gt;&gt;(move _8) -&gt; [return: bb6, unwind: bb9]\n+60:5-60:91: @6.Call: _9 = used_only_from_this_lib_crate_generic_function::&lt;&amp;str&gt;(const &quot;used ONLY from library used_crate.rs&quot;) -&gt; [return: bb7, unwind: bb10]\n+53:25-61:2: @7[1]: _0 = const ()\n+61:2-61:2: @8.Return: return\">        \"used from library used_crate.rs\",</span></span>\n+<span class=\"line\"><span class=\"code even\" style=\"--layer: 1\" title=\"54:5-54:90: @0.Call: _1 = used_from_bin_crate_and_lib_crate_generic_function::&lt;&amp;str&gt;(const &quot;used from library used_crate.rs&quot;) -&gt; [return: bb1, unwind: bb13]\n+55:5-57:6: @1.Call: _2 = used_with_same_type_from_bin_crate_and_lib_crate_generic_function::&lt;&amp;str&gt;(const &quot;used from library used_crate.rs&quot;) -&gt; [return: bb2, unwind: bb13]\n 58:20-58:36: @2[5]: _6 = Box([i32; 4])\n 58:20-58:36: @2[6]: (*_6) = [const 5_i32, const 6_i32, const 7_i32, const 8_i32]\n 58:20-58:36: @2[7]: _5 = move _6\n 58:20-58:36: @2[8]: _4 = move _5 as std::boxed::Box&lt;[i32]&gt; (Pointer(Unsize))\n-58:20-58:36: @3.Call: _3 = slice::&lt;impl [i32]&gt;::into_vec::&lt;std::alloc::Global&gt;(move _4) -&gt; [return: bb4, unwind: bb10]\n-58:9-58:17: @4[1]: FakeRead(ForLet, _3)\n-59:52-59:60: @4[4]: _8 = move _3\n-59:5-59:61: @4.Call: _7 = used_only_from_this_lib_crate_generic_function::&lt;Vec&lt;i32&gt;&gt;(move _8) -&gt; [return: bb5, unwind: bb8]\n-60:5-60:91: @5.Call: _9 = used_only_from_this_lib_crate_generic_function::&lt;&amp;str&gt;(const &quot;used ONLY from library used_crate.rs&quot;) -&gt; [return: bb6, unwind: bb8]\n-53:25-61:2: @6[1]: _0 = const ()\n-61:2-61:2: @7.Return: return\">    );</span></span>\n-<span class=\"line\"><span class=\"code even\" style=\"--layer: 1\" title=\"54:5-54:90: @0.Call: _1 = used_from_bin_crate_and_lib_crate_generic_function::&lt;&amp;str&gt;(const &quot;used from library used_crate.rs&quot;) -&gt; [return: bb1, unwind: bb10]\n-55:5-57:6: @1.Call: _2 = used_with_same_type_from_bin_crate_and_lib_crate_generic_function::&lt;&amp;str&gt;(const &quot;used from library used_crate.rs&quot;) -&gt; [return: bb2, unwind: bb10]\n+58:20-58:36: @4.Call: _3 = slice::&lt;impl [i32]&gt;::into_vec::&lt;std::alloc::Global&gt;(move _4) -&gt; [return: bb5, unwind: bb12]\n+58:9-58:17: @5[1]: FakeRead(ForLet, _3)\n+59:52-59:60: @5[4]: _8 = move _3\n+59:5-59:61: @5.Call: _7 = used_only_from_this_lib_crate_generic_function::&lt;Vec&lt;i32&gt;&gt;(move _8) -&gt; [return: bb6, unwind: bb9]\n+60:5-60:91: @6.Call: _9 = used_only_from_this_lib_crate_generic_function::&lt;&amp;str&gt;(const &quot;used ONLY from library used_crate.rs&quot;) -&gt; [return: bb7, unwind: bb10]\n+53:25-61:2: @7[1]: _0 = const ()\n+61:2-61:2: @8.Return: return\">    );</span></span>\n+<span class=\"line\"><span class=\"code even\" style=\"--layer: 1\" title=\"54:5-54:90: @0.Call: _1 = used_from_bin_crate_and_lib_crate_generic_function::&lt;&amp;str&gt;(const &quot;used from library used_crate.rs&quot;) -&gt; [return: bb1, unwind: bb13]\n+55:5-57:6: @1.Call: _2 = used_with_same_type_from_bin_crate_and_lib_crate_generic_function::&lt;&amp;str&gt;(const &quot;used from library used_crate.rs&quot;) -&gt; [return: bb2, unwind: bb13]\n 58:20-58:36: @2[5]: _6 = Box([i32; 4])\n 58:20-58:36: @2[6]: (*_6) = [const 5_i32, const 6_i32, const 7_i32, const 8_i32]\n 58:20-58:36: @2[7]: _5 = move _6\n 58:20-58:36: @2[8]: _4 = move _5 as std::boxed::Box&lt;[i32]&gt; (Pointer(Unsize))\n-58:20-58:36: @3.Call: _3 = slice::&lt;impl [i32]&gt;::into_vec::&lt;std::alloc::Global&gt;(move _4) -&gt; [return: bb4, unwind: bb10]\n-58:9-58:17: @4[1]: FakeRead(ForLet, _3)\n-59:52-59:60: @4[4]: _8 = move _3\n-59:5-59:61: @4.Call: _7 = used_only_from_this_lib_crate_generic_function::&lt;Vec&lt;i32&gt;&gt;(move _8) -&gt; [return: bb5, unwind: bb8]\n-60:5-60:91: @5.Call: _9 = used_only_from_this_lib_crate_generic_function::&lt;&amp;str&gt;(const &quot;used ONLY from library used_crate.rs&quot;) -&gt; [return: bb6, unwind: bb8]\n-53:25-61:2: @6[1]: _0 = const ()\n-61:2-61:2: @7.Return: return\">    let some_vec = vec![5, 6, 7, 8];</span></span>\n-<span class=\"line\"><span class=\"code even\" style=\"--layer: 1\" title=\"54:5-54:90: @0.Call: _1 = used_from_bin_crate_and_lib_crate_generic_function::&lt;&amp;str&gt;(const &quot;used from library used_crate.rs&quot;) -&gt; [return: bb1, unwind: bb10]\n-55:5-57:6: @1.Call: _2 = used_with_same_type_from_bin_crate_and_lib_crate_generic_function::&lt;&amp;str&gt;(const &quot;used from library used_crate.rs&quot;) -&gt; [return: bb2, unwind: bb10]\n+58:20-58:36: @4.Call: _3 = slice::&lt;impl [i32]&gt;::into_vec::&lt;std::alloc::Global&gt;(move _4) -&gt; [return: bb5, unwind: bb12]\n+58:9-58:17: @5[1]: FakeRead(ForLet, _3)\n+59:52-59:60: @5[4]: _8 = move _3\n+59:5-59:61: @5.Call: _7 = used_only_from_this_lib_crate_generic_function::&lt;Vec&lt;i32&gt;&gt;(move _8) -&gt; [return: bb6, unwind: bb9]\n+60:5-60:91: @6.Call: _9 = used_only_from_this_lib_crate_generic_function::&lt;&amp;str&gt;(const &quot;used ONLY from library used_crate.rs&quot;) -&gt; [return: bb7, unwind: bb10]\n+53:25-61:2: @7[1]: _0 = const ()\n+61:2-61:2: @8.Return: return\">    let some_vec = vec![5, 6, 7, 8];</span></span>\n+<span class=\"line\"><span class=\"code even\" style=\"--layer: 1\" title=\"54:5-54:90: @0.Call: _1 = used_from_bin_crate_and_lib_crate_generic_function::&lt;&amp;str&gt;(const &quot;used from library used_crate.rs&quot;) -&gt; [return: bb1, unwind: bb13]\n+55:5-57:6: @1.Call: _2 = used_with_same_type_from_bin_crate_and_lib_crate_generic_function::&lt;&amp;str&gt;(const &quot;used from library used_crate.rs&quot;) -&gt; [return: bb2, unwind: bb13]\n 58:20-58:36: @2[5]: _6 = Box([i32; 4])\n 58:20-58:36: @2[6]: (*_6) = [const 5_i32, const 6_i32, const 7_i32, const 8_i32]\n 58:20-58:36: @2[7]: _5 = move _6\n 58:20-58:36: @2[8]: _4 = move _5 as std::boxed::Box&lt;[i32]&gt; (Pointer(Unsize))\n-58:20-58:36: @3.Call: _3 = slice::&lt;impl [i32]&gt;::into_vec::&lt;std::alloc::Global&gt;(move _4) -&gt; [return: bb4, unwind: bb10]\n-58:9-58:17: @4[1]: FakeRead(ForLet, _3)\n-59:52-59:60: @4[4]: _8 = move _3\n-59:5-59:61: @4.Call: _7 = used_only_from_this_lib_crate_generic_function::&lt;Vec&lt;i32&gt;&gt;(move _8) -&gt; [return: bb5, unwind: bb8]\n-60:5-60:91: @5.Call: _9 = used_only_from_this_lib_crate_generic_function::&lt;&amp;str&gt;(const &quot;used ONLY from library used_crate.rs&quot;) -&gt; [return: bb6, unwind: bb8]\n-53:25-61:2: @6[1]: _0 = const ()\n-61:2-61:2: @7.Return: return\">    used_only_from_this_lib_crate_generic_function(some_vec);</span></span>\n-<span class=\"line\"><span class=\"code even\" style=\"--layer: 1\" title=\"54:5-54:90: @0.Call: _1 = used_from_bin_crate_and_lib_crate_generic_function::&lt;&amp;str&gt;(const &quot;used from library used_crate.rs&quot;) -&gt; [return: bb1, unwind: bb10]\n-55:5-57:6: @1.Call: _2 = used_with_same_type_from_bin_crate_and_lib_crate_generic_function::&lt;&amp;str&gt;(const &quot;used from library used_crate.rs&quot;) -&gt; [return: bb2, unwind: bb10]\n+58:20-58:36: @4.Call: _3 = slice::&lt;impl [i32]&gt;::into_vec::&lt;std::alloc::Global&gt;(move _4) -&gt; [return: bb5, unwind: bb12]\n+58:9-58:17: @5[1]: FakeRead(ForLet, _3)\n+59:52-59:60: @5[4]: _8 = move _3\n+59:5-59:61: @5.Call: _7 = used_only_from_this_lib_crate_generic_function::&lt;Vec&lt;i32&gt;&gt;(move _8) -&gt; [return: bb6, unwind: bb9]\n+60:5-60:91: @6.Call: _9 = used_only_from_this_lib_crate_generic_function::&lt;&amp;str&gt;(const &quot;used ONLY from library used_crate.rs&quot;) -&gt; [return: bb7, unwind: bb10]\n+53:25-61:2: @7[1]: _0 = const ()\n+61:2-61:2: @8.Return: return\">    used_only_from_this_lib_crate_generic_function(some_vec);</span></span>\n+<span class=\"line\"><span class=\"code even\" style=\"--layer: 1\" title=\"54:5-54:90: @0.Call: _1 = used_from_bin_crate_and_lib_crate_generic_function::&lt;&amp;str&gt;(const &quot;used from library used_crate.rs&quot;) -&gt; [return: bb1, unwind: bb13]\n+55:5-57:6: @1.Call: _2 = used_with_same_type_from_bin_crate_and_lib_crate_generic_function::&lt;&amp;str&gt;(const &quot;used from library used_crate.rs&quot;) -&gt; [return: bb2, unwind: bb13]\n 58:20-58:36: @2[5]: _6 = Box([i32; 4])\n 58:20-58:36: @2[6]: (*_6) = [const 5_i32, const 6_i32, const 7_i32, const 8_i32]\n 58:20-58:36: @2[7]: _5 = move _6\n 58:20-58:36: @2[8]: _4 = move _5 as std::boxed::Box&lt;[i32]&gt; (Pointer(Unsize))\n-58:20-58:36: @3.Call: _3 = slice::&lt;impl [i32]&gt;::into_vec::&lt;std::alloc::Global&gt;(move _4) -&gt; [return: bb4, unwind: bb10]\n-58:9-58:17: @4[1]: FakeRead(ForLet, _3)\n-59:52-59:60: @4[4]: _8 = move _3\n-59:5-59:61: @4.Call: _7 = used_only_from_this_lib_crate_generic_function::&lt;Vec&lt;i32&gt;&gt;(move _8) -&gt; [return: bb5, unwind: bb8]\n-60:5-60:91: @5.Call: _9 = used_only_from_this_lib_crate_generic_function::&lt;&amp;str&gt;(const &quot;used ONLY from library used_crate.rs&quot;) -&gt; [return: bb6, unwind: bb8]\n-53:25-61:2: @6[1]: _0 = const ()\n-61:2-61:2: @7.Return: return\">    used_only_from_this_lib_crate_generic_function(\"used ONLY from library used_crate.rs\");</span></span>\n-<span class=\"line\"><span class=\"code even\" style=\"--layer: 1\" title=\"54:5-54:90: @0.Call: _1 = used_from_bin_crate_and_lib_crate_generic_function::&lt;&amp;str&gt;(const &quot;used from library used_crate.rs&quot;) -&gt; [return: bb1, unwind: bb10]\n-55:5-57:6: @1.Call: _2 = used_with_same_type_from_bin_crate_and_lib_crate_generic_function::&lt;&amp;str&gt;(const &quot;used from library used_crate.rs&quot;) -&gt; [return: bb2, unwind: bb10]\n+58:20-58:36: @4.Call: _3 = slice::&lt;impl [i32]&gt;::into_vec::&lt;std::alloc::Global&gt;(move _4) -&gt; [return: bb5, unwind: bb12]\n+58:9-58:17: @5[1]: FakeRead(ForLet, _3)\n+59:52-59:60: @5[4]: _8 = move _3\n+59:5-59:61: @5.Call: _7 = used_only_from_this_lib_crate_generic_function::&lt;Vec&lt;i32&gt;&gt;(move _8) -&gt; [return: bb6, unwind: bb9]\n+60:5-60:91: @6.Call: _9 = used_only_from_this_lib_crate_generic_function::&lt;&amp;str&gt;(const &quot;used ONLY from library used_crate.rs&quot;) -&gt; [return: bb7, unwind: bb10]\n+53:25-61:2: @7[1]: _0 = const ()\n+61:2-61:2: @8.Return: return\">    used_only_from_this_lib_crate_generic_function(\"used ONLY from library used_crate.rs\");</span></span>\n+<span class=\"line\"><span class=\"code even\" style=\"--layer: 1\" title=\"54:5-54:90: @0.Call: _1 = used_from_bin_crate_and_lib_crate_generic_function::&lt;&amp;str&gt;(const &quot;used from library used_crate.rs&quot;) -&gt; [return: bb1, unwind: bb13]\n+55:5-57:6: @1.Call: _2 = used_with_same_type_from_bin_crate_and_lib_crate_generic_function::&lt;&amp;str&gt;(const &quot;used from library used_crate.rs&quot;) -&gt; [return: bb2, unwind: bb13]\n 58:20-58:36: @2[5]: _6 = Box([i32; 4])\n 58:20-58:36: @2[6]: (*_6) = [const 5_i32, const 6_i32, const 7_i32, const 8_i32]\n 58:20-58:36: @2[7]: _5 = move _6\n 58:20-58:36: @2[8]: _4 = move _5 as std::boxed::Box&lt;[i32]&gt; (Pointer(Unsize))\n-58:20-58:36: @3.Call: _3 = slice::&lt;impl [i32]&gt;::into_vec::&lt;std::alloc::Global&gt;(move _4) -&gt; [return: bb4, unwind: bb10]\n-58:9-58:17: @4[1]: FakeRead(ForLet, _3)\n-59:52-59:60: @4[4]: _8 = move _3\n-59:5-59:61: @4.Call: _7 = used_only_from_this_lib_crate_generic_function::&lt;Vec&lt;i32&gt;&gt;(move _8) -&gt; [return: bb5, unwind: bb8]\n-60:5-60:91: @5.Call: _9 = used_only_from_this_lib_crate_generic_function::&lt;&amp;str&gt;(const &quot;used ONLY from library used_crate.rs&quot;) -&gt; [return: bb6, unwind: bb8]\n-53:25-61:2: @6[1]: _0 = const ()\n-61:2-61:2: @7.Return: return\">}<span class=\"annotation\">\u2989@0,1,2,3,4,5,6,7</span></span></span></span></div>\n+58:20-58:36: @4.Call: _3 = slice::&lt;impl [i32]&gt;::into_vec::&lt;std::alloc::Global&gt;(move _4) -&gt; [return: bb5, unwind: bb12]\n+58:9-58:17: @5[1]: FakeRead(ForLet, _3)\n+59:52-59:60: @5[4]: _8 = move _3\n+59:5-59:61: @5.Call: _7 = used_only_from_this_lib_crate_generic_function::&lt;Vec&lt;i32&gt;&gt;(move _8) -&gt; [return: bb6, unwind: bb9]\n+60:5-60:91: @6.Call: _9 = used_only_from_this_lib_crate_generic_function::&lt;&amp;str&gt;(const &quot;used ONLY from library used_crate.rs&quot;) -&gt; [return: bb7, unwind: bb10]\n+53:25-61:2: @7[1]: _0 = const ()\n+61:2-61:2: @8.Return: return\">}<span class=\"annotation\">\u2989@0,1,2,3,4,5,6,7,8</span></span></span></span></div>\n </body>\n </html>"}, {"sha": "acb2c7d63f51b3b383a83d59579298852f66d8d0", "filename": "src/test/run-make-fulldeps/coverage-spanview/expected_mir_dump.uses_crate/uses_crate.main.-------.InstrumentCoverage.0.html", "status": "modified", "additions": 88, "deletions": 88, "changes": 176, "blob_url": "https://github.com/rust-lang/rust/blob/a71a81948074f7a3e2b5ce0dee3ad98fa22f793b/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-spanview%2Fexpected_mir_dump.uses_crate%2Fuses_crate.main.-------.InstrumentCoverage.0.html", "raw_url": "https://github.com/rust-lang/rust/raw/a71a81948074f7a3e2b5ce0dee3ad98fa22f793b/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-spanview%2Fexpected_mir_dump.uses_crate%2Fuses_crate.main.-------.InstrumentCoverage.0.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-spanview%2Fexpected_mir_dump.uses_crate%2Fuses_crate.main.-------.InstrumentCoverage.0.html?ref=a71a81948074f7a3e2b5ce0dee3ad98fa22f793b", "patch": "@@ -69,125 +69,125 @@\n </style>\n </head>\n <body>\n-<div class=\"code\" style=\"counter-reset: line 4\"><span class=\"line\"><span><span class=\"code even\" style=\"--layer: 1\" title=\"6:5-6:32: @0.Call: _1 = used_function() -&gt; [return: bb1, unwind: bb11]\n+<div class=\"code\" style=\"counter-reset: line 4\"><span class=\"line\"><span><span class=\"code even\" style=\"--layer: 1\" title=\"6:5-6:32: @0.Call: _1 = used_function() -&gt; [return: bb1, unwind: bb14]\n 7:20-7:36: @1[5]: _5 = Box([i32; 4])\n 7:20-7:36: @1[6]: (*_5) = [const 1_i32, const 2_i32, const 3_i32, const 4_i32]\n 7:20-7:36: @1[7]: _4 = move _5\n 7:20-7:36: @1[8]: _3 = move _4 as std::boxed::Box&lt;[i32]&gt; (Pointer(Unsize))\n-7:20-7:36: @2.Call: _2 = slice::&lt;impl [i32]&gt;::into_vec::&lt;std::alloc::Global&gt;(move _3) -&gt; [return: bb3, unwind: bb11]\n-7:9-7:17: @3[1]: FakeRead(ForLet, _2)\n-8:59-8:68: @3[4]: _7 = &amp;_2\n-8:5-8:69: @3.Call: _6 = used_only_from_bin_crate_generic_function::&lt;&amp;Vec&lt;i32&gt;&gt;(move _7) -&gt; [return: bb4, unwind: bb9]\n-9:5-9:89: @4.Call: _8 = used_only_from_bin_crate_generic_function::&lt;&amp;str&gt;(const &quot;used from bin uses_crate.rs&quot;) -&gt; [return: bb5, unwind: bb9]\n-10:68-10:76: @5[3]: _10 = move _2\n-10:5-10:77: @5.Call: _9 = used_from_bin_crate_and_lib_crate_generic_function::&lt;Vec&lt;i32&gt;&gt;(move _10) -&gt; [return: bb6, unwind: bb9]\n-11:5-11:98: @6.Call: _11 = used_with_same_type_from_bin_crate_and_lib_crate_generic_function::&lt;&amp;str&gt;(const &quot;interesting?&quot;) -&gt; [return: bb7, unwind: bb9]\n-5:11-12:2: @7[1]: _0 = const ()\n-12:2-12:2: @8.Return: return\"><span class=\"annotation\">@0,1,2,3,4,5,6,7,8\u298a</span>fn main() {</span></span>\n-<span class=\"line\"><span class=\"code even\" style=\"--layer: 1\" title=\"6:5-6:32: @0.Call: _1 = used_function() -&gt; [return: bb1, unwind: bb11]\n+7:20-7:36: @3.Call: _2 = slice::&lt;impl [i32]&gt;::into_vec::&lt;std::alloc::Global&gt;(move _3) -&gt; [return: bb4, unwind: bb13]\n+7:9-7:17: @4[1]: FakeRead(ForLet, _2)\n+8:59-8:68: @4[4]: _7 = &amp;_2\n+8:5-8:69: @4.Call: _6 = used_only_from_bin_crate_generic_function::&lt;&amp;Vec&lt;i32&gt;&gt;(move _7) -&gt; [return: bb5, unwind: bb11]\n+9:5-9:89: @5.Call: _8 = used_only_from_bin_crate_generic_function::&lt;&amp;str&gt;(const &quot;used from bin uses_crate.rs&quot;) -&gt; [return: bb6, unwind: bb11]\n+10:68-10:76: @6[3]: _10 = move _2\n+10:5-10:77: @6.Call: _9 = used_from_bin_crate_and_lib_crate_generic_function::&lt;Vec&lt;i32&gt;&gt;(move _10) -&gt; [return: bb7, unwind: bb10]\n+11:5-11:98: @7.Call: _11 = used_with_same_type_from_bin_crate_and_lib_crate_generic_function::&lt;&amp;str&gt;(const &quot;interesting?&quot;) -&gt; [return: bb8, unwind: bb11]\n+5:11-12:2: @8[1]: _0 = const ()\n+12:2-12:2: @9.Return: return\"><span class=\"annotation\">@0,1,2,3,4,5,6,7,8,9\u298a</span>fn main() {</span></span>\n+<span class=\"line\"><span class=\"code even\" style=\"--layer: 1\" title=\"6:5-6:32: @0.Call: _1 = used_function() -&gt; [return: bb1, unwind: bb14]\n 7:20-7:36: @1[5]: _5 = Box([i32; 4])\n 7:20-7:36: @1[6]: (*_5) = [const 1_i32, const 2_i32, const 3_i32, const 4_i32]\n 7:20-7:36: @1[7]: _4 = move _5\n 7:20-7:36: @1[8]: _3 = move _4 as std::boxed::Box&lt;[i32]&gt; (Pointer(Unsize))\n-7:20-7:36: @2.Call: _2 = slice::&lt;impl [i32]&gt;::into_vec::&lt;std::alloc::Global&gt;(move _3) -&gt; [return: bb3, unwind: bb11]\n-7:9-7:17: @3[1]: FakeRead(ForLet, _2)\n-8:59-8:68: @3[4]: _7 = &amp;_2\n-8:5-8:69: @3.Call: _6 = used_only_from_bin_crate_generic_function::&lt;&amp;Vec&lt;i32&gt;&gt;(move _7) -&gt; [return: bb4, unwind: bb9]\n-9:5-9:89: @4.Call: _8 = used_only_from_bin_crate_generic_function::&lt;&amp;str&gt;(const &quot;used from bin uses_crate.rs&quot;) -&gt; [return: bb5, unwind: bb9]\n-10:68-10:76: @5[3]: _10 = move _2\n-10:5-10:77: @5.Call: _9 = used_from_bin_crate_and_lib_crate_generic_function::&lt;Vec&lt;i32&gt;&gt;(move _10) -&gt; [return: bb6, unwind: bb9]\n-11:5-11:98: @6.Call: _11 = used_with_same_type_from_bin_crate_and_lib_crate_generic_function::&lt;&amp;str&gt;(const &quot;interesting?&quot;) -&gt; [return: bb7, unwind: bb9]\n-5:11-12:2: @7[1]: _0 = const ()\n-12:2-12:2: @8.Return: return\">    used_crate::used_function();</span></span>\n-<span class=\"line\"><span class=\"code even\" style=\"--layer: 1\" title=\"6:5-6:32: @0.Call: _1 = used_function() -&gt; [return: bb1, unwind: bb11]\n+7:20-7:36: @3.Call: _2 = slice::&lt;impl [i32]&gt;::into_vec::&lt;std::alloc::Global&gt;(move _3) -&gt; [return: bb4, unwind: bb13]\n+7:9-7:17: @4[1]: FakeRead(ForLet, _2)\n+8:59-8:68: @4[4]: _7 = &amp;_2\n+8:5-8:69: @4.Call: _6 = used_only_from_bin_crate_generic_function::&lt;&amp;Vec&lt;i32&gt;&gt;(move _7) -&gt; [return: bb5, unwind: bb11]\n+9:5-9:89: @5.Call: _8 = used_only_from_bin_crate_generic_function::&lt;&amp;str&gt;(const &quot;used from bin uses_crate.rs&quot;) -&gt; [return: bb6, unwind: bb11]\n+10:68-10:76: @6[3]: _10 = move _2\n+10:5-10:77: @6.Call: _9 = used_from_bin_crate_and_lib_crate_generic_function::&lt;Vec&lt;i32&gt;&gt;(move _10) -&gt; [return: bb7, unwind: bb10]\n+11:5-11:98: @7.Call: _11 = used_with_same_type_from_bin_crate_and_lib_crate_generic_function::&lt;&amp;str&gt;(const &quot;interesting?&quot;) -&gt; [return: bb8, unwind: bb11]\n+5:11-12:2: @8[1]: _0 = const ()\n+12:2-12:2: @9.Return: return\">    used_crate::used_function();</span></span>\n+<span class=\"line\"><span class=\"code even\" style=\"--layer: 1\" title=\"6:5-6:32: @0.Call: _1 = used_function() -&gt; [return: bb1, unwind: bb14]\n 7:20-7:36: @1[5]: _5 = Box([i32; 4])\n 7:20-7:36: @1[6]: (*_5) = [const 1_i32, const 2_i32, const 3_i32, const 4_i32]\n 7:20-7:36: @1[7]: _4 = move _5\n 7:20-7:36: @1[8]: _3 = move _4 as std::boxed::Box&lt;[i32]&gt; (Pointer(Unsize))\n-7:20-7:36: @2.Call: _2 = slice::&lt;impl [i32]&gt;::into_vec::&lt;std::alloc::Global&gt;(move _3) -&gt; [return: bb3, unwind: bb11]\n-7:9-7:17: @3[1]: FakeRead(ForLet, _2)\n-8:59-8:68: @3[4]: _7 = &amp;_2\n-8:5-8:69: @3.Call: _6 = used_only_from_bin_crate_generic_function::&lt;&amp;Vec&lt;i32&gt;&gt;(move _7) -&gt; [return: bb4, unwind: bb9]\n-9:5-9:89: @4.Call: _8 = used_only_from_bin_crate_generic_function::&lt;&amp;str&gt;(const &quot;used from bin uses_crate.rs&quot;) -&gt; [return: bb5, unwind: bb9]\n-10:68-10:76: @5[3]: _10 = move _2\n-10:5-10:77: @5.Call: _9 = used_from_bin_crate_and_lib_crate_generic_function::&lt;Vec&lt;i32&gt;&gt;(move _10) -&gt; [return: bb6, unwind: bb9]\n-11:5-11:98: @6.Call: _11 = used_with_same_type_from_bin_crate_and_lib_crate_generic_function::&lt;&amp;str&gt;(const &quot;interesting?&quot;) -&gt; [return: bb7, unwind: bb9]\n-5:11-12:2: @7[1]: _0 = const ()\n-12:2-12:2: @8.Return: return\">    let some_vec = vec![1, 2, 3, 4];</span></span>\n-<span class=\"line\"><span class=\"code even\" style=\"--layer: 1\" title=\"6:5-6:32: @0.Call: _1 = used_function() -&gt; [return: bb1, unwind: bb11]\n+7:20-7:36: @3.Call: _2 = slice::&lt;impl [i32]&gt;::into_vec::&lt;std::alloc::Global&gt;(move _3) -&gt; [return: bb4, unwind: bb13]\n+7:9-7:17: @4[1]: FakeRead(ForLet, _2)\n+8:59-8:68: @4[4]: _7 = &amp;_2\n+8:5-8:69: @4.Call: _6 = used_only_from_bin_crate_generic_function::&lt;&amp;Vec&lt;i32&gt;&gt;(move _7) -&gt; [return: bb5, unwind: bb11]\n+9:5-9:89: @5.Call: _8 = used_only_from_bin_crate_generic_function::&lt;&amp;str&gt;(const &quot;used from bin uses_crate.rs&quot;) -&gt; [return: bb6, unwind: bb11]\n+10:68-10:76: @6[3]: _10 = move _2\n+10:5-10:77: @6.Call: _9 = used_from_bin_crate_and_lib_crate_generic_function::&lt;Vec&lt;i32&gt;&gt;(move _10) -&gt; [return: bb7, unwind: bb10]\n+11:5-11:98: @7.Call: _11 = used_with_same_type_from_bin_crate_and_lib_crate_generic_function::&lt;&amp;str&gt;(const &quot;interesting?&quot;) -&gt; [return: bb8, unwind: bb11]\n+5:11-12:2: @8[1]: _0 = const ()\n+12:2-12:2: @9.Return: return\">    let some_vec = vec![1, 2, 3, 4];</span></span>\n+<span class=\"line\"><span class=\"code even\" style=\"--layer: 1\" title=\"6:5-6:32: @0.Call: _1 = used_function() -&gt; [return: bb1, unwind: bb14]\n 7:20-7:36: @1[5]: _5 = Box([i32; 4])\n 7:20-7:36: @1[6]: (*_5) = [const 1_i32, const 2_i32, const 3_i32, const 4_i32]\n 7:20-7:36: @1[7]: _4 = move _5\n 7:20-7:36: @1[8]: _3 = move _4 as std::boxed::Box&lt;[i32]&gt; (Pointer(Unsize))\n-7:20-7:36: @2.Call: _2 = slice::&lt;impl [i32]&gt;::into_vec::&lt;std::alloc::Global&gt;(move _3) -&gt; [return: bb3, unwind: bb11]\n-7:9-7:17: @3[1]: FakeRead(ForLet, _2)\n-8:59-8:68: @3[4]: _7 = &amp;_2\n-8:5-8:69: @3.Call: _6 = used_only_from_bin_crate_generic_function::&lt;&amp;Vec&lt;i32&gt;&gt;(move _7) -&gt; [return: bb4, unwind: bb9]\n-9:5-9:89: @4.Call: _8 = used_only_from_bin_crate_generic_function::&lt;&amp;str&gt;(const &quot;used from bin uses_crate.rs&quot;) -&gt; [return: bb5, unwind: bb9]\n-10:68-10:76: @5[3]: _10 = move _2\n-10:5-10:77: @5.Call: _9 = used_from_bin_crate_and_lib_crate_generic_function::&lt;Vec&lt;i32&gt;&gt;(move _10) -&gt; [return: bb6, unwind: bb9]\n-11:5-11:98: @6.Call: _11 = used_with_same_type_from_bin_crate_and_lib_crate_generic_function::&lt;&amp;str&gt;(const &quot;interesting?&quot;) -&gt; [return: bb7, unwind: bb9]\n-5:11-12:2: @7[1]: _0 = const ()\n-12:2-12:2: @8.Return: return\">    used_crate::used_only_from_bin_crate_generic_function(&amp;some_vec);</span></span>\n-<span class=\"line\"><span class=\"code even\" style=\"--layer: 1\" title=\"6:5-6:32: @0.Call: _1 = used_function() -&gt; [return: bb1, unwind: bb11]\n+7:20-7:36: @3.Call: _2 = slice::&lt;impl [i32]&gt;::into_vec::&lt;std::alloc::Global&gt;(move _3) -&gt; [return: bb4, unwind: bb13]\n+7:9-7:17: @4[1]: FakeRead(ForLet, _2)\n+8:59-8:68: @4[4]: _7 = &amp;_2\n+8:5-8:69: @4.Call: _6 = used_only_from_bin_crate_generic_function::&lt;&amp;Vec&lt;i32&gt;&gt;(move _7) -&gt; [return: bb5, unwind: bb11]\n+9:5-9:89: @5.Call: _8 = used_only_from_bin_crate_generic_function::&lt;&amp;str&gt;(const &quot;used from bin uses_crate.rs&quot;) -&gt; [return: bb6, unwind: bb11]\n+10:68-10:76: @6[3]: _10 = move _2\n+10:5-10:77: @6.Call: _9 = used_from_bin_crate_and_lib_crate_generic_function::&lt;Vec&lt;i32&gt;&gt;(move _10) -&gt; [return: bb7, unwind: bb10]\n+11:5-11:98: @7.Call: _11 = used_with_same_type_from_bin_crate_and_lib_crate_generic_function::&lt;&amp;str&gt;(const &quot;interesting?&quot;) -&gt; [return: bb8, unwind: bb11]\n+5:11-12:2: @8[1]: _0 = const ()\n+12:2-12:2: @9.Return: return\">    used_crate::used_only_from_bin_crate_generic_function(&amp;some_vec);</span></span>\n+<span class=\"line\"><span class=\"code even\" style=\"--layer: 1\" title=\"6:5-6:32: @0.Call: _1 = used_function() -&gt; [return: bb1, unwind: bb14]\n 7:20-7:36: @1[5]: _5 = Box([i32; 4])\n 7:20-7:36: @1[6]: (*_5) = [const 1_i32, const 2_i32, const 3_i32, const 4_i32]\n 7:20-7:36: @1[7]: _4 = move _5\n 7:20-7:36: @1[8]: _3 = move _4 as std::boxed::Box&lt;[i32]&gt; (Pointer(Unsize))\n-7:20-7:36: @2.Call: _2 = slice::&lt;impl [i32]&gt;::into_vec::&lt;std::alloc::Global&gt;(move _3) -&gt; [return: bb3, unwind: bb11]\n-7:9-7:17: @3[1]: FakeRead(ForLet, _2)\n-8:59-8:68: @3[4]: _7 = &amp;_2\n-8:5-8:69: @3.Call: _6 = used_only_from_bin_crate_generic_function::&lt;&amp;Vec&lt;i32&gt;&gt;(move _7) -&gt; [return: bb4, unwind: bb9]\n-9:5-9:89: @4.Call: _8 = used_only_from_bin_crate_generic_function::&lt;&amp;str&gt;(const &quot;used from bin uses_crate.rs&quot;) -&gt; [return: bb5, unwind: bb9]\n-10:68-10:76: @5[3]: _10 = move _2\n-10:5-10:77: @5.Call: _9 = used_from_bin_crate_and_lib_crate_generic_function::&lt;Vec&lt;i32&gt;&gt;(move _10) -&gt; [return: bb6, unwind: bb9]\n-11:5-11:98: @6.Call: _11 = used_with_same_type_from_bin_crate_and_lib_crate_generic_function::&lt;&amp;str&gt;(const &quot;interesting?&quot;) -&gt; [return: bb7, unwind: bb9]\n-5:11-12:2: @7[1]: _0 = const ()\n-12:2-12:2: @8.Return: return\">    used_crate::used_only_from_bin_crate_generic_function(\"used from bin uses_crate.rs\");</span></span>\n-<span class=\"line\"><span class=\"code even\" style=\"--layer: 1\" title=\"6:5-6:32: @0.Call: _1 = used_function() -&gt; [return: bb1, unwind: bb11]\n+7:20-7:36: @3.Call: _2 = slice::&lt;impl [i32]&gt;::into_vec::&lt;std::alloc::Global&gt;(move _3) -&gt; [return: bb4, unwind: bb13]\n+7:9-7:17: @4[1]: FakeRead(ForLet, _2)\n+8:59-8:68: @4[4]: _7 = &amp;_2\n+8:5-8:69: @4.Call: _6 = used_only_from_bin_crate_generic_function::&lt;&amp;Vec&lt;i32&gt;&gt;(move _7) -&gt; [return: bb5, unwind: bb11]\n+9:5-9:89: @5.Call: _8 = used_only_from_bin_crate_generic_function::&lt;&amp;str&gt;(const &quot;used from bin uses_crate.rs&quot;) -&gt; [return: bb6, unwind: bb11]\n+10:68-10:76: @6[3]: _10 = move _2\n+10:5-10:77: @6.Call: _9 = used_from_bin_crate_and_lib_crate_generic_function::&lt;Vec&lt;i32&gt;&gt;(move _10) -&gt; [return: bb7, unwind: bb10]\n+11:5-11:98: @7.Call: _11 = used_with_same_type_from_bin_crate_and_lib_crate_generic_function::&lt;&amp;str&gt;(const &quot;interesting?&quot;) -&gt; [return: bb8, unwind: bb11]\n+5:11-12:2: @8[1]: _0 = const ()\n+12:2-12:2: @9.Return: return\">    used_crate::used_only_from_bin_crate_generic_function(\"used from bin uses_crate.rs\");</span></span>\n+<span class=\"line\"><span class=\"code even\" style=\"--layer: 1\" title=\"6:5-6:32: @0.Call: _1 = used_function() -&gt; [return: bb1, unwind: bb14]\n 7:20-7:36: @1[5]: _5 = Box([i32; 4])\n 7:20-7:36: @1[6]: (*_5) = [const 1_i32, const 2_i32, const 3_i32, const 4_i32]\n 7:20-7:36: @1[7]: _4 = move _5\n 7:20-7:36: @1[8]: _3 = move _4 as std::boxed::Box&lt;[i32]&gt; (Pointer(Unsize))\n-7:20-7:36: @2.Call: _2 = slice::&lt;impl [i32]&gt;::into_vec::&lt;std::alloc::Global&gt;(move _3) -&gt; [return: bb3, unwind: bb11]\n-7:9-7:17: @3[1]: FakeRead(ForLet, _2)\n-8:59-8:68: @3[4]: _7 = &amp;_2\n-8:5-8:69: @3.Call: _6 = used_only_from_bin_crate_generic_function::&lt;&amp;Vec&lt;i32&gt;&gt;(move _7) -&gt; [return: bb4, unwind: bb9]\n-9:5-9:89: @4.Call: _8 = used_only_from_bin_crate_generic_function::&lt;&amp;str&gt;(const &quot;used from bin uses_crate.rs&quot;) -&gt; [return: bb5, unwind: bb9]\n-10:68-10:76: @5[3]: _10 = move _2\n-10:5-10:77: @5.Call: _9 = used_from_bin_crate_and_lib_crate_generic_function::&lt;Vec&lt;i32&gt;&gt;(move _10) -&gt; [return: bb6, unwind: bb9]\n-11:5-11:98: @6.Call: _11 = used_with_same_type_from_bin_crate_and_lib_crate_generic_function::&lt;&amp;str&gt;(const &quot;interesting?&quot;) -&gt; [return: bb7, unwind: bb9]\n-5:11-12:2: @7[1]: _0 = const ()\n-12:2-12:2: @8.Return: return\">    used_crate::used_from_bin_crate_and_lib_crate_generic_function(some_vec);</span></span>\n-<span class=\"line\"><span class=\"code even\" style=\"--layer: 1\" title=\"6:5-6:32: @0.Call: _1 = used_function() -&gt; [return: bb1, unwind: bb11]\n+7:20-7:36: @3.Call: _2 = slice::&lt;impl [i32]&gt;::into_vec::&lt;std::alloc::Global&gt;(move _3) -&gt; [return: bb4, unwind: bb13]\n+7:9-7:17: @4[1]: FakeRead(ForLet, _2)\n+8:59-8:68: @4[4]: _7 = &amp;_2\n+8:5-8:69: @4.Call: _6 = used_only_from_bin_crate_generic_function::&lt;&amp;Vec&lt;i32&gt;&gt;(move _7) -&gt; [return: bb5, unwind: bb11]\n+9:5-9:89: @5.Call: _8 = used_only_from_bin_crate_generic_function::&lt;&amp;str&gt;(const &quot;used from bin uses_crate.rs&quot;) -&gt; [return: bb6, unwind: bb11]\n+10:68-10:76: @6[3]: _10 = move _2\n+10:5-10:77: @6.Call: _9 = used_from_bin_crate_and_lib_crate_generic_function::&lt;Vec&lt;i32&gt;&gt;(move _10) -&gt; [return: bb7, unwind: bb10]\n+11:5-11:98: @7.Call: _11 = used_with_same_type_from_bin_crate_and_lib_crate_generic_function::&lt;&amp;str&gt;(const &quot;interesting?&quot;) -&gt; [return: bb8, unwind: bb11]\n+5:11-12:2: @8[1]: _0 = const ()\n+12:2-12:2: @9.Return: return\">    used_crate::used_from_bin_crate_and_lib_crate_generic_function(some_vec);</span></span>\n+<span class=\"line\"><span class=\"code even\" style=\"--layer: 1\" title=\"6:5-6:32: @0.Call: _1 = used_function() -&gt; [return: bb1, unwind: bb14]\n 7:20-7:36: @1[5]: _5 = Box([i32; 4])\n 7:20-7:36: @1[6]: (*_5) = [const 1_i32, const 2_i32, const 3_i32, const 4_i32]\n 7:20-7:36: @1[7]: _4 = move _5\n 7:20-7:36: @1[8]: _3 = move _4 as std::boxed::Box&lt;[i32]&gt; (Pointer(Unsize))\n-7:20-7:36: @2.Call: _2 = slice::&lt;impl [i32]&gt;::into_vec::&lt;std::alloc::Global&gt;(move _3) -&gt; [return: bb3, unwind: bb11]\n-7:9-7:17: @3[1]: FakeRead(ForLet, _2)\n-8:59-8:68: @3[4]: _7 = &amp;_2\n-8:5-8:69: @3.Call: _6 = used_only_from_bin_crate_generic_function::&lt;&amp;Vec&lt;i32&gt;&gt;(move _7) -&gt; [return: bb4, unwind: bb9]\n-9:5-9:89: @4.Call: _8 = used_only_from_bin_crate_generic_function::&lt;&amp;str&gt;(const &quot;used from bin uses_crate.rs&quot;) -&gt; [return: bb5, unwind: bb9]\n-10:68-10:76: @5[3]: _10 = move _2\n-10:5-10:77: @5.Call: _9 = used_from_bin_crate_and_lib_crate_generic_function::&lt;Vec&lt;i32&gt;&gt;(move _10) -&gt; [return: bb6, unwind: bb9]\n-11:5-11:98: @6.Call: _11 = used_with_same_type_from_bin_crate_and_lib_crate_generic_function::&lt;&amp;str&gt;(const &quot;interesting?&quot;) -&gt; [return: bb7, unwind: bb9]\n-5:11-12:2: @7[1]: _0 = const ()\n-12:2-12:2: @8.Return: return\">    used_crate::used_with_same_type_from_bin_crate_and_lib_crate_generic_function(\"interesting?\");</span></span>\n-<span class=\"line\"><span class=\"code even\" style=\"--layer: 1\" title=\"6:5-6:32: @0.Call: _1 = used_function() -&gt; [return: bb1, unwind: bb11]\n+7:20-7:36: @3.Call: _2 = slice::&lt;impl [i32]&gt;::into_vec::&lt;std::alloc::Global&gt;(move _3) -&gt; [return: bb4, unwind: bb13]\n+7:9-7:17: @4[1]: FakeRead(ForLet, _2)\n+8:59-8:68: @4[4]: _7 = &amp;_2\n+8:5-8:69: @4.Call: _6 = used_only_from_bin_crate_generic_function::&lt;&amp;Vec&lt;i32&gt;&gt;(move _7) -&gt; [return: bb5, unwind: bb11]\n+9:5-9:89: @5.Call: _8 = used_only_from_bin_crate_generic_function::&lt;&amp;str&gt;(const &quot;used from bin uses_crate.rs&quot;) -&gt; [return: bb6, unwind: bb11]\n+10:68-10:76: @6[3]: _10 = move _2\n+10:5-10:77: @6.Call: _9 = used_from_bin_crate_and_lib_crate_generic_function::&lt;Vec&lt;i32&gt;&gt;(move _10) -&gt; [return: bb7, unwind: bb10]\n+11:5-11:98: @7.Call: _11 = used_with_same_type_from_bin_crate_and_lib_crate_generic_function::&lt;&amp;str&gt;(const &quot;interesting?&quot;) -&gt; [return: bb8, unwind: bb11]\n+5:11-12:2: @8[1]: _0 = const ()\n+12:2-12:2: @9.Return: return\">    used_crate::used_with_same_type_from_bin_crate_and_lib_crate_generic_function(\"interesting?\");</span></span>\n+<span class=\"line\"><span class=\"code even\" style=\"--layer: 1\" title=\"6:5-6:32: @0.Call: _1 = used_function() -&gt; [return: bb1, unwind: bb14]\n 7:20-7:36: @1[5]: _5 = Box([i32; 4])\n 7:20-7:36: @1[6]: (*_5) = [const 1_i32, const 2_i32, const 3_i32, const 4_i32]\n 7:20-7:36: @1[7]: _4 = move _5\n 7:20-7:36: @1[8]: _3 = move _4 as std::boxed::Box&lt;[i32]&gt; (Pointer(Unsize))\n-7:20-7:36: @2.Call: _2 = slice::&lt;impl [i32]&gt;::into_vec::&lt;std::alloc::Global&gt;(move _3) -&gt; [return: bb3, unwind: bb11]\n-7:9-7:17: @3[1]: FakeRead(ForLet, _2)\n-8:59-8:68: @3[4]: _7 = &amp;_2\n-8:5-8:69: @3.Call: _6 = used_only_from_bin_crate_generic_function::&lt;&amp;Vec&lt;i32&gt;&gt;(move _7) -&gt; [return: bb4, unwind: bb9]\n-9:5-9:89: @4.Call: _8 = used_only_from_bin_crate_generic_function::&lt;&amp;str&gt;(const &quot;used from bin uses_crate.rs&quot;) -&gt; [return: bb5, unwind: bb9]\n-10:68-10:76: @5[3]: _10 = move _2\n-10:5-10:77: @5.Call: _9 = used_from_bin_crate_and_lib_crate_generic_function::&lt;Vec&lt;i32&gt;&gt;(move _10) -&gt; [return: bb6, unwind: bb9]\n-11:5-11:98: @6.Call: _11 = used_with_same_type_from_bin_crate_and_lib_crate_generic_function::&lt;&amp;str&gt;(const &quot;interesting?&quot;) -&gt; [return: bb7, unwind: bb9]\n-5:11-12:2: @7[1]: _0 = const ()\n-12:2-12:2: @8.Return: return\">}<span class=\"annotation\">\u2989@0,1,2,3,4,5,6,7,8</span></span></span></span></div>\n+7:20-7:36: @3.Call: _2 = slice::&lt;impl [i32]&gt;::into_vec::&lt;std::alloc::Global&gt;(move _3) -&gt; [return: bb4, unwind: bb13]\n+7:9-7:17: @4[1]: FakeRead(ForLet, _2)\n+8:59-8:68: @4[4]: _7 = &amp;_2\n+8:5-8:69: @4.Call: _6 = used_only_from_bin_crate_generic_function::&lt;&amp;Vec&lt;i32&gt;&gt;(move _7) -&gt; [return: bb5, unwind: bb11]\n+9:5-9:89: @5.Call: _8 = used_only_from_bin_crate_generic_function::&lt;&amp;str&gt;(const &quot;used from bin uses_crate.rs&quot;) -&gt; [return: bb6, unwind: bb11]\n+10:68-10:76: @6[3]: _10 = move _2\n+10:5-10:77: @6.Call: _9 = used_from_bin_crate_and_lib_crate_generic_function::&lt;Vec&lt;i32&gt;&gt;(move _10) -&gt; [return: bb7, unwind: bb10]\n+11:5-11:98: @7.Call: _11 = used_with_same_type_from_bin_crate_and_lib_crate_generic_function::&lt;&amp;str&gt;(const &quot;interesting?&quot;) -&gt; [return: bb8, unwind: bb11]\n+5:11-12:2: @8[1]: _0 = const ()\n+12:2-12:2: @9.Return: return\">}<span class=\"annotation\">\u2989@0,1,2,3,4,5,6,7,8,9</span></span></span></span></div>\n </body>\n </html>"}, {"sha": "c0bf0bdf731e69ee56144a6a67d55d55dcea2fa4", "filename": "src/test/ui/drop/dynamic-drop-async.rs", "status": "modified", "additions": 54, "deletions": 111, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/a71a81948074f7a3e2b5ce0dee3ad98fa22f793b/src%2Ftest%2Fui%2Fdrop%2Fdynamic-drop-async.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a71a81948074f7a3e2b5ce0dee3ad98fa22f793b/src%2Ftest%2Fui%2Fdrop%2Fdynamic-drop-async.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdrop%2Fdynamic-drop-async.rs?ref=a71a81948074f7a3e2b5ce0dee3ad98fa22f793b", "patch": "@@ -43,7 +43,6 @@ impl<T: Unpin> Future for Defer<T> {\n /// The `failing_op`-th operation will panic.\n struct Allocator {\n     data: RefCell<Vec<bool>>,\n-    name: &'static str,\n     failing_op: usize,\n     cur_ops: Cell<usize>,\n }\n@@ -55,28 +54,23 @@ impl Drop for Allocator {\n     fn drop(&mut self) {\n         let data = self.data.borrow();\n         if data.iter().any(|d| *d) {\n-            panic!(\"missing free in {:?}: {:?}\", self.name, data);\n+            panic!(\"missing free: {:?}\", data);\n         }\n     }\n }\n \n impl Allocator {\n-    fn new(failing_op: usize, name: &'static str) -> Self {\n-        Allocator {\n-            failing_op,\n-            name,\n-            cur_ops: Cell::new(0),\n-            data: RefCell::new(vec![]),\n-        }\n+    fn new(failing_op: usize) -> Self {\n+        Allocator { failing_op, cur_ops: Cell::new(0), data: RefCell::new(vec![]) }\n     }\n-    fn alloc(self: &Rc<Allocator>) -> impl Future<Output = Ptr> + 'static {\n+    fn alloc(&self) -> impl Future<Output = Ptr<'_>> + '_ {\n         self.fallible_operation();\n \n         let mut data = self.data.borrow_mut();\n \n         let addr = data.len();\n         data.push(true);\n-        Defer { ready: false, value: Some(Ptr(addr, self.clone())) }\n+        Defer { ready: false, value: Some(Ptr(addr, self)) }\n     }\n     fn fallible_operation(&self) {\n         self.cur_ops.set(self.cur_ops.get() + 1);\n@@ -89,11 +83,11 @@ impl Allocator {\n \n // Type that tracks whether it was dropped and can panic when it's created or\n // destroyed.\n-struct Ptr(usize, Rc<Allocator>);\n-impl Drop for Ptr {\n+struct Ptr<'a>(usize, &'a Allocator);\n+impl<'a> Drop for Ptr<'a> {\n     fn drop(&mut self) {\n         match self.1.data.borrow_mut()[self.0] {\n-            false => panic!(\"double free in {:?} at index {:?}\", self.1.name, self.0),\n+            false => panic!(\"double free at index {:?}\", self.0),\n             ref mut d => *d = false,\n         }\n \n@@ -117,7 +111,7 @@ async fn dynamic_drop(a: Rc<Allocator>, c: bool) {\n     };\n }\n \n-struct TwoPtrs(Ptr, Ptr);\n+struct TwoPtrs<'a>(Ptr<'a>, Ptr<'a>);\n async fn struct_dynamic_drop(a: Rc<Allocator>, c0: bool, c1: bool, c: bool) {\n     for i in 0..2 {\n         let x;\n@@ -238,62 +232,21 @@ async fn move_ref_pattern(a: Rc<Allocator>) {\n     a.alloc().await;\n }\n \n-async fn panic_after_return(a: Rc<Allocator>, c: bool) -> (Ptr,) {\n-    a.alloc().await;\n-    let p = a.alloc().await;\n-    if c {\n-        a.alloc().await;\n-        let q = a.alloc().await;\n-        // We use a return type that isn't used anywhere else to make sure that\n-        // the return place doesn't incorrectly end up in the generator state.\n-        return (a.alloc().await,);\n-    }\n-    (a.alloc().await,)\n-}\n-\n-\n-async fn panic_after_init_by_loop(a: Rc<Allocator>) {\n-    a.alloc().await;\n-    let p = a.alloc().await;\n-    let q = loop {\n-        a.alloc().await;\n-        let r = a.alloc().await;\n-        break a.alloc().await;\n-    };\n-}\n-\n-async fn panic_after_init_by_match_with_bindings_and_guard(a: Rc<Allocator>, b: bool) {\n-    a.alloc().await;\n-    let p = a.alloc().await;\n-    let q = match a.alloc().await {\n-        ref _x if b => {\n-            a.alloc().await;\n-            let r = a.alloc().await;\n-            a.alloc().await\n-        }\n-        _x => {\n-            a.alloc().await;\n-            let r = a.alloc().await;\n-            a.alloc().await\n-        },\n-    };\n-}\n-\n-fn run_test<F, G, O>(cx: &mut Context<'_>, ref f: F, name: &'static str)\n+fn run_test<F, G>(cx: &mut Context<'_>, ref f: F)\n where\n     F: Fn(Rc<Allocator>) -> G,\n-    G: Future<Output = O>,\n+    G: Future<Output = ()>,\n {\n     for polls in 0.. {\n         // Run without any panics to find which operations happen after the\n         // penultimate `poll`.\n-        let first_alloc = Rc::new(Allocator::new(usize::MAX, name));\n+        let first_alloc = Rc::new(Allocator::new(usize::MAX));\n         let mut fut = Box::pin(f(first_alloc.clone()));\n         let mut ops_before_last_poll = 0;\n         let mut completed = false;\n         for _ in 0..polls {\n             ops_before_last_poll = first_alloc.cur_ops.get();\n-            if let Poll::Ready(_) = fut.as_mut().poll(cx) {\n+            if let Poll::Ready(()) = fut.as_mut().poll(cx) {\n                 completed = true;\n             }\n         }\n@@ -302,7 +255,7 @@ where\n         // Start at `ops_before_last_poll` so that we will always be able to\n         // `poll` the expected number of times.\n         for failing_op in ops_before_last_poll..first_alloc.cur_ops.get() {\n-            let alloc = Rc::new(Allocator::new(failing_op + 1, name));\n+            let alloc = Rc::new(Allocator::new(failing_op + 1));\n             let f = &f;\n             let cx = &mut *cx;\n             let result = panic::catch_unwind(panic::AssertUnwindSafe(move || {\n@@ -332,58 +285,48 @@ fn clone_waker(data: *const ()) -> RawWaker {\n     RawWaker::new(data, &RawWakerVTable::new(clone_waker, drop, drop, drop))\n }\n \n-macro_rules! run_test {\n-    ($ctxt:expr, $e:expr) => { run_test($ctxt, $e, stringify!($e)); };\n-}\n-\n fn main() {\n     let waker = unsafe { Waker::from_raw(clone_waker(ptr::null())) };\n     let context = &mut Context::from_waker(&waker);\n \n-    run_test!(context, |a| dynamic_init(a, false));\n-    run_test!(context, |a| dynamic_init(a, true));\n-    run_test!(context, |a| dynamic_drop(a, false));\n-    run_test!(context, |a| dynamic_drop(a, true));\n-\n-    run_test!(context, |a| assignment(a, false, false));\n-    run_test!(context, |a| assignment(a, false, true));\n-    run_test!(context, |a| assignment(a, true, false));\n-    run_test!(context, |a| assignment(a, true, true));\n-\n-    run_test!(context, |a| array_simple(a));\n-    run_test!(context, |a| vec_simple(a));\n-    run_test!(context, |a| vec_unreachable(a));\n-\n-    run_test!(context, |a| struct_dynamic_drop(a, false, false, false));\n-    run_test!(context, |a| struct_dynamic_drop(a, false, false, true));\n-    run_test!(context, |a| struct_dynamic_drop(a, false, true, false));\n-    run_test!(context, |a| struct_dynamic_drop(a, false, true, true));\n-    run_test!(context, |a| struct_dynamic_drop(a, true, false, false));\n-    run_test!(context, |a| struct_dynamic_drop(a, true, false, true));\n-    run_test!(context, |a| struct_dynamic_drop(a, true, true, false));\n-    run_test!(context, |a| struct_dynamic_drop(a, true, true, true));\n-\n-    run_test!(context, |a| field_assignment(a, false));\n-    run_test!(context, |a| field_assignment(a, true));\n-\n-    run_test!(context, |a| mixed_drop_and_nondrop(a));\n-\n-    run_test!(context, |a| slice_pattern_one_of(a, 0));\n-    run_test!(context, |a| slice_pattern_one_of(a, 1));\n-    run_test!(context, |a| slice_pattern_one_of(a, 2));\n-    run_test!(context, |a| slice_pattern_one_of(a, 3));\n-\n-    run_test!(context, |a| subslice_pattern_from_end_with_drop(a, true, true));\n-    run_test!(context, |a| subslice_pattern_from_end_with_drop(a, true, false));\n-    run_test!(context, |a| subslice_pattern_from_end_with_drop(a, false, true));\n-    run_test!(context, |a| subslice_pattern_from_end_with_drop(a, false, false));\n-    run_test!(context, |a| subslice_pattern_reassign(a));\n-\n-    run_test!(context, |a| move_ref_pattern(a));\n-\n-    run_test!(context, |a| panic_after_return(a, false));\n-    run_test!(context, |a| panic_after_return(a, true));\n-    run_test!(context, |a| panic_after_init_by_loop(a));\n-    run_test!(context, |a| panic_after_init_by_match_with_bindings_and_guard(a, false));\n-    run_test!(context, |a| panic_after_init_by_match_with_bindings_and_guard(a, true));\n+    run_test(context, |a| dynamic_init(a, false));\n+    run_test(context, |a| dynamic_init(a, true));\n+    run_test(context, |a| dynamic_drop(a, false));\n+    run_test(context, |a| dynamic_drop(a, true));\n+\n+    run_test(context, |a| assignment(a, false, false));\n+    run_test(context, |a| assignment(a, false, true));\n+    run_test(context, |a| assignment(a, true, false));\n+    run_test(context, |a| assignment(a, true, true));\n+\n+    run_test(context, |a| array_simple(a));\n+    run_test(context, |a| vec_simple(a));\n+    run_test(context, |a| vec_unreachable(a));\n+\n+    run_test(context, |a| struct_dynamic_drop(a, false, false, false));\n+    run_test(context, |a| struct_dynamic_drop(a, false, false, true));\n+    run_test(context, |a| struct_dynamic_drop(a, false, true, false));\n+    run_test(context, |a| struct_dynamic_drop(a, false, true, true));\n+    run_test(context, |a| struct_dynamic_drop(a, true, false, false));\n+    run_test(context, |a| struct_dynamic_drop(a, true, false, true));\n+    run_test(context, |a| struct_dynamic_drop(a, true, true, false));\n+    run_test(context, |a| struct_dynamic_drop(a, true, true, true));\n+\n+    run_test(context, |a| field_assignment(a, false));\n+    run_test(context, |a| field_assignment(a, true));\n+\n+    run_test(context, |a| mixed_drop_and_nondrop(a));\n+\n+    run_test(context, |a| slice_pattern_one_of(a, 0));\n+    run_test(context, |a| slice_pattern_one_of(a, 1));\n+    run_test(context, |a| slice_pattern_one_of(a, 2));\n+    run_test(context, |a| slice_pattern_one_of(a, 3));\n+\n+    run_test(context, |a| subslice_pattern_from_end_with_drop(a, true, true));\n+    run_test(context, |a| subslice_pattern_from_end_with_drop(a, true, false));\n+    run_test(context, |a| subslice_pattern_from_end_with_drop(a, false, true));\n+    run_test(context, |a| subslice_pattern_from_end_with_drop(a, false, false));\n+    run_test(context, |a| subslice_pattern_reassign(a));\n+\n+    run_test(context, |a| move_ref_pattern(a));\n }"}, {"sha": "e90ea1c55b0c1707c58f9f7b04b7f178f6259491", "filename": "src/test/ui/drop/dynamic-drop.rs", "status": "modified", "additions": 169, "deletions": 268, "changes": 437, "blob_url": "https://github.com/rust-lang/rust/blob/a71a81948074f7a3e2b5ce0dee3ad98fa22f793b/src%2Ftest%2Fui%2Fdrop%2Fdynamic-drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a71a81948074f7a3e2b5ce0dee3ad98fa22f793b/src%2Ftest%2Fui%2Fdrop%2Fdynamic-drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdrop%2Fdynamic-drop.rs?ref=a71a81948074f7a3e2b5ce0dee3ad98fa22f793b", "patch": "@@ -3,6 +3,7 @@\n \n #![feature(generators, generator_trait)]\n #![feature(bindings_after_at)]\n+\n #![allow(unused_assignments)]\n #![allow(unused_variables)]\n \n@@ -16,7 +17,6 @@ struct InjectedFailure;\n \n struct Allocator {\n     data: RefCell<Vec<bool>>,\n-    name: &'static str,\n     failing_op: usize,\n     cur_ops: Cell<usize>,\n }\n@@ -28,18 +28,17 @@ impl Drop for Allocator {\n     fn drop(&mut self) {\n         let data = self.data.borrow();\n         if data.iter().any(|d| *d) {\n-            panic!(\"missing free in {:?}: {:?}\", self.name, data);\n+            panic!(\"missing free: {:?}\", data);\n         }\n     }\n }\n \n impl Allocator {\n-    fn new(failing_op: usize, name: &'static str) -> Self {\n+    fn new(failing_op: usize) -> Self {\n         Allocator {\n             failing_op: failing_op,\n             cur_ops: Cell::new(0),\n-            data: RefCell::new(vec![]),\n-            name,\n+            data: RefCell::new(vec![])\n         }\n     }\n     fn alloc(&self) -> Ptr<'_> {\n@@ -54,17 +53,33 @@ impl Allocator {\n         data.push(true);\n         Ptr(addr, self)\n     }\n+    // FIXME(#47949) Any use of this indicates a bug in rustc: we should never\n+    // be leaking values in the cases here.\n+    //\n+    // Creates a `Ptr<'_>` and checks that the allocated value is leaked if the\n+    // `failing_op` is in the list of exception.\n+    fn alloc_leaked(&self, exceptions: Vec<usize>) -> Ptr<'_> {\n+        let ptr = self.alloc();\n+\n+        if exceptions.iter().any(|operation| *operation == self.failing_op) {\n+            let mut data = self.data.borrow_mut();\n+            data[ptr.0] = false;\n+        }\n+        ptr\n+    }\n }\n \n struct Ptr<'a>(usize, &'a Allocator);\n impl<'a> Drop for Ptr<'a> {\n     fn drop(&mut self) {\n         match self.1.data.borrow_mut()[self.0] {\n-            false => panic!(\"double free in {:?} at index {:?}\", self.1.name, self.0),\n-            ref mut d => *d = false,\n+            false => {\n+                panic!(\"double free at index {:?}\", self.0)\n+            }\n+            ref mut d => *d = false\n         }\n \n-        self.1.cur_ops.set(self.1.cur_ops.get() + 1);\n+        self.1.cur_ops.set(self.1.cur_ops.get()+1);\n \n         if self.1.cur_ops.get() == self.1.failing_op {\n             panic::panic_any(InjectedFailure);\n@@ -162,7 +177,11 @@ fn generator(a: &Allocator, run_count: usize) {\n     assert!(run_count < 4);\n \n     let mut gen = || {\n-        (a.alloc(), yield a.alloc(), a.alloc(), yield a.alloc());\n+        (a.alloc(),\n+         yield a.alloc(),\n+         a.alloc(),\n+         yield a.alloc()\n+         );\n     };\n     for _ in 0..run_count {\n         Pin::new(&mut gen).resume(());\n@@ -186,50 +205,38 @@ fn vec_unreachable(a: &Allocator) {\n }\n \n fn slice_pattern_first(a: &Allocator) {\n-    let [_x, ..] = [a.alloc(), a.alloc(), a.alloc()];\n+    let[_x, ..] = [a.alloc(), a.alloc(), a.alloc()];\n }\n \n fn slice_pattern_middle(a: &Allocator) {\n-    let [_, _x, _] = [a.alloc(), a.alloc(), a.alloc()];\n+    let[_, _x, _] = [a.alloc(), a.alloc(), a.alloc()];\n }\n \n fn slice_pattern_two(a: &Allocator) {\n-    let [_x, _, _y, _] = [a.alloc(), a.alloc(), a.alloc(), a.alloc()];\n+    let[_x, _, _y, _] = [a.alloc(), a.alloc(), a.alloc(), a.alloc()];\n }\n \n fn slice_pattern_last(a: &Allocator) {\n-    let [.., _y] = [a.alloc(), a.alloc(), a.alloc(), a.alloc()];\n+    let[.., _y] = [a.alloc(), a.alloc(), a.alloc(), a.alloc()];\n }\n \n fn slice_pattern_one_of(a: &Allocator, i: usize) {\n     let array = [a.alloc(), a.alloc(), a.alloc(), a.alloc()];\n     let _x = match i {\n-        0 => {\n-            let [a, ..] = array;\n-            a\n-        }\n-        1 => {\n-            let [_, a, ..] = array;\n-            a\n-        }\n-        2 => {\n-            let [_, _, a, _] = array;\n-            a\n-        }\n-        3 => {\n-            let [_, _, _, a] = array;\n-            a\n-        }\n+        0 => { let [a, ..] = array; a }\n+        1 => { let [_, a, ..] = array; a }\n+        2 => { let [_, _, a, _] = array; a }\n+        3 => { let [_, _, _, a] = array; a }\n         _ => panic!(\"unmatched\"),\n     };\n }\n \n fn subslice_pattern_from_end(a: &Allocator, arg: bool) {\n     let a = [a.alloc(), a.alloc(), a.alloc()];\n     if arg {\n-        let [.., _x, _] = a;\n+        let[.., _x, _] = a;\n     } else {\n-        let [_, _y @ ..] = a;\n+        let[_, _y @ ..] = a;\n     }\n }\n \n@@ -241,61 +248,45 @@ fn subslice_pattern_from_end_with_drop(a: &Allocator, arg: bool, arg2: bool) {\n     }\n \n     if arg {\n-        let [.., _x, _] = a;\n+        let[.., _x, _] = a;\n     } else {\n-        let [_, _y @ ..] = a;\n+        let[_, _y @ ..] = a;\n     }\n }\n \n fn slice_pattern_reassign(a: &Allocator) {\n     let mut ar = [a.alloc(), a.alloc()];\n-    let [_, _x] = ar;\n+    let[_, _x] = ar;\n     ar = [a.alloc(), a.alloc()];\n-    let [.., _y] = ar;\n+    let[.., _y] = ar;\n }\n \n fn subslice_pattern_reassign(a: &Allocator) {\n     let mut ar = [a.alloc(), a.alloc(), a.alloc()];\n-    let [_, _, _x] = ar;\n+    let[_, _, _x] = ar;\n     ar = [a.alloc(), a.alloc(), a.alloc()];\n-    let [_, _y @ ..] = ar;\n+    let[_, _y @ ..] = ar;\n }\n \n fn index_field_mixed_ends(a: &Allocator) {\n     let ar = [(a.alloc(), a.alloc()), (a.alloc(), a.alloc())];\n-    let [(_x, _), ..] = ar;\n-    let [(_, _y), _] = ar;\n-    let [_, (_, _w)] = ar;\n-    let [.., (_z, _)] = ar;\n+    let[(_x, _), ..] = ar;\n+    let[(_, _y), _] = ar;\n+    let[_, (_, _w)] = ar;\n+    let[.., (_z, _)] = ar;\n }\n \n fn subslice_mixed_min_lengths(a: &Allocator, c: i32) {\n     let ar = [(a.alloc(), a.alloc()), (a.alloc(), a.alloc())];\n     match c {\n-        0 => {\n-            let [_x, ..] = ar;\n-        }\n-        1 => {\n-            let [_x, _, ..] = ar;\n-        }\n-        2 => {\n-            let [_x, _] = ar;\n-        }\n-        3 => {\n-            let [(_x, _), _, ..] = ar;\n-        }\n-        4 => {\n-            let [.., (_x, _)] = ar;\n-        }\n-        5 => {\n-            let [.., (_x, _), _] = ar;\n-        }\n-        6 => {\n-            let [_y @ ..] = ar;\n-        }\n-        _ => {\n-            let [_y @ .., _] = ar;\n-        }\n+        0 => { let[_x, ..] = ar; }\n+        1 => { let[_x, _, ..] = ar; }\n+        2 => { let[_x, _] = ar; }\n+        3 => { let[(_x, _), _, ..] = ar; }\n+        4 => { let[.., (_x, _)] = ar; }\n+        5 => { let[.., (_x, _), _] = ar; }\n+        6 => { let [_y @ ..] = ar; }\n+        _ => { let [_y @ .., _] = ar; }\n     }\n }\n \n@@ -343,160 +334,87 @@ fn move_ref_pattern(a: &Allocator) {\n }\n \n fn panic_after_return(a: &Allocator) -> Ptr<'_> {\n+    // Panic in the drop of `p` or `q` can leak\n+    let exceptions = vec![8, 9];\n     a.alloc();\n     let p = a.alloc();\n     {\n         a.alloc();\n         let p = a.alloc();\n-        a.alloc()\n+        // FIXME (#47949) We leak values when we panic in a destructor after\n+        // evaluating an expression with `rustc_mir::build::Builder::into`.\n+        a.alloc_leaked(exceptions)\n     }\n }\n \n fn panic_after_return_expr(a: &Allocator) -> Ptr<'_> {\n+    // Panic in the drop of `p` or `q` can leak\n+    let exceptions = vec![8, 9];\n     a.alloc();\n     let p = a.alloc();\n     {\n         a.alloc();\n         let q = a.alloc();\n-        return a.alloc();\n+        // FIXME (#47949)\n+        return a.alloc_leaked(exceptions);\n     }\n }\n \n fn panic_after_init(a: &Allocator) {\n+    // Panic in the drop of `r` can leak\n+    let exceptions = vec![8];\n     a.alloc();\n     let p = a.alloc();\n     let q = {\n         a.alloc();\n         let r = a.alloc();\n-        a.alloc()\n+        // FIXME (#47949)\n+        a.alloc_leaked(exceptions)\n     };\n }\n \n fn panic_after_init_temp(a: &Allocator) {\n+    // Panic in the drop of `r` can leak\n+    let exceptions = vec![8];\n     a.alloc();\n     let p = a.alloc();\n     {\n         a.alloc();\n         let r = a.alloc();\n-        a.alloc()\n+        // FIXME (#47949)\n+        a.alloc_leaked(exceptions)\n     };\n }\n \n fn panic_after_init_by_loop(a: &Allocator) {\n+    // Panic in the drop of `r` can leak\n+    let exceptions = vec![8];\n     a.alloc();\n     let p = a.alloc();\n     let q = loop {\n         a.alloc();\n         let r = a.alloc();\n-        break a.alloc();\n-    };\n-}\n-\n-fn panic_after_init_by_match(a: &Allocator, b: bool) {\n-    a.alloc();\n-    let p = a.alloc();\n-    let _ = loop {\n-        let q = match b {\n-            true => {\n-                a.alloc();\n-                let r = a.alloc();\n-                a.alloc()\n-            }\n-            false => {\n-                a.alloc();\n-                let r = a.alloc();\n-                break a.alloc();\n-            }\n-        };\n-        return;\n-    };\n-}\n-\n-fn panic_after_init_by_match_with_guard(a: &Allocator, b: bool) {\n-    a.alloc();\n-    let p = a.alloc();\n-    let q = match a.alloc() {\n-        _ if b => {\n-            a.alloc();\n-            let r = a.alloc();\n-            a.alloc()\n-        }\n-        _ => {\n-            a.alloc();\n-            let r = a.alloc();\n-            a.alloc()\n-        }\n-    };\n-}\n-\n-fn panic_after_init_by_match_with_bindings_and_guard(a: &Allocator, b: bool) {\n-    a.alloc();\n-    let p = a.alloc();\n-    let q = match a.alloc() {\n-        _x if b => {\n-            a.alloc();\n-            let r = a.alloc();\n-            a.alloc()\n-        }\n-        _x => {\n-            a.alloc();\n-            let r = a.alloc();\n-            a.alloc()\n-        }\n-    };\n-}\n-\n-fn panic_after_init_by_match_with_ref_bindings_and_guard(a: &Allocator, b: bool) {\n-    a.alloc();\n-    let p = a.alloc();\n-    let q = match a.alloc() {\n-        ref _x if b => {\n-            a.alloc();\n-            let r = a.alloc();\n-            a.alloc()\n-        }\n-        ref _x => {\n-            a.alloc();\n-            let r = a.alloc();\n-            a.alloc()\n-        }\n-    };\n-}\n-\n-fn panic_after_init_by_break_if(a: &Allocator, b: bool) {\n-    a.alloc();\n-    let p = a.alloc();\n-    let q = loop {\n-        let r = a.alloc();\n-        break if b {\n-            let s = a.alloc();\n-            a.alloc()\n-        } else {\n-            a.alloc()\n-        };\n+        // FIXME (#47949)\n+        break a.alloc_leaked(exceptions);\n     };\n }\n \n-fn run_test<F>(mut f: F, name: &'static str)\n-where\n-    F: FnMut(&Allocator),\n+fn run_test<F>(mut f: F)\n+    where F: FnMut(&Allocator)\n {\n-    let first_alloc = Allocator::new(usize::MAX, name);\n+    let first_alloc = Allocator::new(usize::MAX);\n     f(&first_alloc);\n \n-    for failing_op in 1..first_alloc.cur_ops.get() + 1 {\n-        let alloc = Allocator::new(failing_op, name);\n+    for failing_op in 1..first_alloc.cur_ops.get()+1 {\n+        let alloc = Allocator::new(failing_op);\n         let alloc = &alloc;\n         let f = panic::AssertUnwindSafe(&mut f);\n         let result = panic::catch_unwind(move || {\n             f.0(alloc);\n         });\n         match result {\n-            Ok(..) => panic!(\n-                \"test executed {} ops but now {}\",\n-                first_alloc.cur_ops.get(),\n-                alloc.cur_ops.get()\n-            ),\n+            Ok(..) => panic!(\"test executed {} ops but now {}\",\n+                             first_alloc.cur_ops.get(), alloc.cur_ops.get()),\n             Err(e) => {\n                 if e.downcast_ref::<InjectedFailure>().is_none() {\n                     panic::resume_unwind(e);\n@@ -506,115 +424,98 @@ where\n     }\n }\n \n-fn run_test_nopanic<F>(mut f: F, name: &'static str)\n-where\n-    F: FnMut(&Allocator),\n+fn run_test_nopanic<F>(mut f: F)\n+    where F: FnMut(&Allocator)\n {\n-    let first_alloc = Allocator::new(usize::MAX, name);\n+    let first_alloc = Allocator::new(usize::MAX);\n     f(&first_alloc);\n }\n \n-macro_rules! run_test {\n-    ($e:expr) => {\n-        run_test($e, stringify!($e));\n-    };\n-}\n-\n fn main() {\n-    run_test!(|a| dynamic_init(a, false));\n-    run_test!(|a| dynamic_init(a, true));\n-    run_test!(|a| dynamic_drop(a, false));\n-    run_test!(|a| dynamic_drop(a, true));\n-\n-    run_test!(|a| assignment2(a, false, false));\n-    run_test!(|a| assignment2(a, false, true));\n-    run_test!(|a| assignment2(a, true, false));\n-    run_test!(|a| assignment2(a, true, true));\n-\n-    run_test!(|a| assignment1(a, false));\n-    run_test!(|a| assignment1(a, true));\n-\n-    run_test!(|a| array_simple(a));\n-    run_test!(|a| vec_simple(a));\n-    run_test!(|a| vec_unreachable(a));\n-\n-    run_test!(|a| struct_dynamic_drop(a, false, false, false));\n-    run_test!(|a| struct_dynamic_drop(a, false, false, true));\n-    run_test!(|a| struct_dynamic_drop(a, false, true, false));\n-    run_test!(|a| struct_dynamic_drop(a, false, true, true));\n-    run_test!(|a| struct_dynamic_drop(a, true, false, false));\n-    run_test!(|a| struct_dynamic_drop(a, true, false, true));\n-    run_test!(|a| struct_dynamic_drop(a, true, true, false));\n-    run_test!(|a| struct_dynamic_drop(a, true, true, true));\n-\n-    run_test!(|a| field_assignment(a, false));\n-    run_test!(|a| field_assignment(a, true));\n-\n-    run_test!(|a| generator(a, 0));\n-    run_test!(|a| generator(a, 1));\n-    run_test!(|a| generator(a, 2));\n-    run_test!(|a| generator(a, 3));\n-\n-    run_test!(|a| mixed_drop_and_nondrop(a));\n-\n-    run_test!(|a| slice_pattern_first(a));\n-    run_test!(|a| slice_pattern_middle(a));\n-    run_test!(|a| slice_pattern_two(a));\n-    run_test!(|a| slice_pattern_last(a));\n-    run_test!(|a| slice_pattern_one_of(a, 0));\n-    run_test!(|a| slice_pattern_one_of(a, 1));\n-    run_test!(|a| slice_pattern_one_of(a, 2));\n-    run_test!(|a| slice_pattern_one_of(a, 3));\n-\n-    run_test!(|a| subslice_pattern_from_end(a, true));\n-    run_test!(|a| subslice_pattern_from_end(a, false));\n-    run_test!(|a| subslice_pattern_from_end_with_drop(a, true, true));\n-    run_test!(|a| subslice_pattern_from_end_with_drop(a, true, false));\n-    run_test!(|a| subslice_pattern_from_end_with_drop(a, false, true));\n-    run_test!(|a| subslice_pattern_from_end_with_drop(a, false, false));\n-    run_test!(|a| slice_pattern_reassign(a));\n-    run_test!(|a| subslice_pattern_reassign(a));\n-\n-    run_test!(|a| index_field_mixed_ends(a));\n-    run_test!(|a| subslice_mixed_min_lengths(a, 0));\n-    run_test!(|a| subslice_mixed_min_lengths(a, 1));\n-    run_test!(|a| subslice_mixed_min_lengths(a, 2));\n-    run_test!(|a| subslice_mixed_min_lengths(a, 3));\n-    run_test!(|a| subslice_mixed_min_lengths(a, 4));\n-    run_test!(|a| subslice_mixed_min_lengths(a, 5));\n-    run_test!(|a| subslice_mixed_min_lengths(a, 6));\n-    run_test!(|a| subslice_mixed_min_lengths(a, 7));\n-\n-    run_test!(|a| move_ref_pattern(a));\n-\n-    run_test!(|a| {\n+    run_test(|a| dynamic_init(a, false));\n+    run_test(|a| dynamic_init(a, true));\n+    run_test(|a| dynamic_drop(a, false));\n+    run_test(|a| dynamic_drop(a, true));\n+\n+    run_test(|a| assignment2(a, false, false));\n+    run_test(|a| assignment2(a, false, true));\n+    run_test(|a| assignment2(a, true, false));\n+    run_test(|a| assignment2(a, true, true));\n+\n+    run_test(|a| assignment1(a, false));\n+    run_test(|a| assignment1(a, true));\n+\n+    run_test(|a| array_simple(a));\n+    run_test(|a| vec_simple(a));\n+    run_test(|a| vec_unreachable(a));\n+\n+    run_test(|a| struct_dynamic_drop(a, false, false, false));\n+    run_test(|a| struct_dynamic_drop(a, false, false, true));\n+    run_test(|a| struct_dynamic_drop(a, false, true, false));\n+    run_test(|a| struct_dynamic_drop(a, false, true, true));\n+    run_test(|a| struct_dynamic_drop(a, true, false, false));\n+    run_test(|a| struct_dynamic_drop(a, true, false, true));\n+    run_test(|a| struct_dynamic_drop(a, true, true, false));\n+    run_test(|a| struct_dynamic_drop(a, true, true, true));\n+\n+    run_test(|a| field_assignment(a, false));\n+    run_test(|a| field_assignment(a, true));\n+\n+    run_test(|a| generator(a, 0));\n+    run_test(|a| generator(a, 1));\n+    run_test(|a| generator(a, 2));\n+    run_test(|a| generator(a, 3));\n+\n+    run_test(|a| mixed_drop_and_nondrop(a));\n+\n+    run_test(|a| slice_pattern_first(a));\n+    run_test(|a| slice_pattern_middle(a));\n+    run_test(|a| slice_pattern_two(a));\n+    run_test(|a| slice_pattern_last(a));\n+    run_test(|a| slice_pattern_one_of(a, 0));\n+    run_test(|a| slice_pattern_one_of(a, 1));\n+    run_test(|a| slice_pattern_one_of(a, 2));\n+    run_test(|a| slice_pattern_one_of(a, 3));\n+\n+    run_test(|a| subslice_pattern_from_end(a, true));\n+    run_test(|a| subslice_pattern_from_end(a, false));\n+    run_test(|a| subslice_pattern_from_end_with_drop(a, true, true));\n+    run_test(|a| subslice_pattern_from_end_with_drop(a, true, false));\n+    run_test(|a| subslice_pattern_from_end_with_drop(a, false, true));\n+    run_test(|a| subslice_pattern_from_end_with_drop(a, false, false));\n+    run_test(|a| slice_pattern_reassign(a));\n+    run_test(|a| subslice_pattern_reassign(a));\n+\n+    run_test(|a| index_field_mixed_ends(a));\n+    run_test(|a| subslice_mixed_min_lengths(a, 0));\n+    run_test(|a| subslice_mixed_min_lengths(a, 1));\n+    run_test(|a| subslice_mixed_min_lengths(a, 2));\n+    run_test(|a| subslice_mixed_min_lengths(a, 3));\n+    run_test(|a| subslice_mixed_min_lengths(a, 4));\n+    run_test(|a| subslice_mixed_min_lengths(a, 5));\n+    run_test(|a| subslice_mixed_min_lengths(a, 6));\n+    run_test(|a| subslice_mixed_min_lengths(a, 7));\n+\n+    run_test(|a| move_ref_pattern(a));\n+\n+    run_test(|a| {\n         panic_after_return(a);\n     });\n-    run_test!(|a| {\n+    run_test(|a| {\n         panic_after_return_expr(a);\n     });\n-    run_test!(|a| panic_after_init(a));\n-    run_test!(|a| panic_after_init_temp(a));\n-    run_test!(|a| panic_after_init_by_loop(a));\n-    run_test!(|a| panic_after_init_by_match(a, false));\n-    run_test!(|a| panic_after_init_by_match(a, true));\n-    run_test!(|a| panic_after_init_by_match_with_guard(a, false));\n-    run_test!(|a| panic_after_init_by_match_with_guard(a, true));\n-    run_test!(|a| panic_after_init_by_match_with_bindings_and_guard(a, false));\n-    run_test!(|a| panic_after_init_by_match_with_bindings_and_guard(a, true));\n-    run_test!(|a| panic_after_init_by_match_with_ref_bindings_and_guard(a, false));\n-    run_test!(|a| panic_after_init_by_match_with_ref_bindings_and_guard(a, true));\n-    run_test!(|a| panic_after_init_by_break_if(a, false));\n-    run_test!(|a| panic_after_init_by_break_if(a, true));\n-\n-    run_test!(|a| bindings_after_at_dynamic_init_move(a, true));\n-    run_test!(|a| bindings_after_at_dynamic_init_move(a, false));\n-    run_test!(|a| bindings_after_at_dynamic_init_ref(a, true));\n-    run_test!(|a| bindings_after_at_dynamic_init_ref(a, false));\n-    run_test!(|a| bindings_after_at_dynamic_drop_move(a, true));\n-    run_test!(|a| bindings_after_at_dynamic_drop_move(a, false));\n-    run_test!(|a| bindings_after_at_dynamic_drop_ref(a, true));\n-    run_test!(|a| bindings_after_at_dynamic_drop_ref(a, false));\n-\n-    run_test_nopanic(|a| union1(a), \"|a| union1(a)\");\n+    run_test(|a| panic_after_init(a));\n+    run_test(|a| panic_after_init_temp(a));\n+    run_test(|a| panic_after_init_by_loop(a));\n+\n+    run_test(|a| bindings_after_at_dynamic_init_move(a, true));\n+    run_test(|a| bindings_after_at_dynamic_init_move(a, false));\n+    run_test(|a| bindings_after_at_dynamic_init_ref(a, true));\n+    run_test(|a| bindings_after_at_dynamic_init_ref(a, false));\n+    run_test(|a| bindings_after_at_dynamic_drop_move(a, true));\n+    run_test(|a| bindings_after_at_dynamic_drop_move(a, false));\n+    run_test(|a| bindings_after_at_dynamic_drop_ref(a, true));\n+    run_test(|a| bindings_after_at_dynamic_drop_ref(a, false));\n+\n+    run_test_nopanic(|a| union1(a));\n }"}]}