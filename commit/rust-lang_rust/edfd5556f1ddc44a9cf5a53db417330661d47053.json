{"sha": "edfd5556f1ddc44a9cf5a53db417330661d47053", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVkZmQ1NTU2ZjFkZGM0NGE5Y2Y1YTUzZGI0MTczMzA2NjFkNDcwNTM=", "commit": {"author": {"name": "Mark Rousskov", "email": "mark.simulacrum@gmail.com", "date": "2019-08-12T18:36:09Z"}, "committer": {"name": "Mark Rousskov", "email": "mark.simulacrum@gmail.com", "date": "2019-08-27T00:30:10Z"}, "message": "Transition a few fmt::Display impls to functions\n\nThis introduces a WithFormatter abstraction that permits one-time\nfmt::Display on an arbitrary closure, created via `display_fn`. This\nallows us to prevent allocation while still using functions instead of\nstructs, which are a bit unwieldy to thread arguments through as they\ncan't easily call each other (and are generally a bit opaque).\n\nThe eventual goal here is likely to move us off of the formatting\ninfrastructure entirely in favor of something more structured, but this\nis a good step to move us in that direction as it makes, for example,\npassing a context describing current state to the formatting impl much\neasier.", "tree": {"sha": "5e4bbcf6ac59c252937f2934918b5c9bd038988c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5e4bbcf6ac59c252937f2934918b5c9bd038988c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/edfd5556f1ddc44a9cf5a53db417330661d47053", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/edfd5556f1ddc44a9cf5a53db417330661d47053", "html_url": "https://github.com/rust-lang/rust/commit/edfd5556f1ddc44a9cf5a53db417330661d47053", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/edfd5556f1ddc44a9cf5a53db417330661d47053/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dafdfee33e8e78c3f34dd5befb3581fff0041ebd", "url": "https://api.github.com/repos/rust-lang/rust/commits/dafdfee33e8e78c3f34dd5befb3581fff0041ebd", "html_url": "https://github.com/rust-lang/rust/commit/dafdfee33e8e78c3f34dd5befb3581fff0041ebd"}], "stats": {"total": 108, "additions": 56, "deletions": 52}, "files": [{"sha": "313734e3fdd6b339a85a1f88eafcadff830b0960", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 53, "deletions": 49, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/edfd5556f1ddc44a9cf5a53db417330661d47053/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edfd5556f1ddc44a9cf5a53db417330661d47053/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=edfd5556f1ddc44a9cf5a53db417330661d47053", "patch": "@@ -6,6 +6,7 @@\n //! them in the future to instead emit any format desired.\n \n use std::borrow::Cow;\n+use std::cell::Cell;\n use std::fmt;\n \n use rustc::hir::def_id::DefId;\n@@ -38,8 +39,6 @@ pub struct AsyncSpace(pub hir::IsAsync);\n pub struct MutableSpace(pub clean::Mutability);\n /// Wrapper struct for emitting type parameter bounds.\n pub struct GenericBounds<'a>(pub &'a [clean::GenericBound]);\n-/// Wrapper struct for emitting a comma-separated list of items\n-pub struct CommaSep<'a, T>(pub &'a [T]);\n pub struct AbiSpace(pub Abi);\n pub struct DefaultSpace(pub bool);\n \n@@ -68,11 +67,6 @@ pub struct WhereClause<'a>{\n     pub end_newline: bool,\n }\n \n-pub struct HRef<'a> {\n-    did: DefId,\n-    text: &'a str,\n-}\n-\n impl<'a> VisSpace<'a> {\n     pub fn get(self) -> &'a Option<clean::Visibility> {\n         let VisSpace(v) = self; v\n@@ -91,14 +85,14 @@ impl ConstnessSpace {\n     }\n }\n \n-impl<'a, T: fmt::Display> fmt::Display for CommaSep<'a, T> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        for (i, item) in self.0.iter().enumerate() {\n+fn comma_sep<T: fmt::Display>(items: &[T]) -> impl fmt::Display + '_ {\n+    display_fn(move |f| {\n+        for (i, item) in items.iter().enumerate() {\n             if i != 0 { write!(f, \", \")?; }\n             fmt::Display::fmt(item, f)?;\n         }\n         Ok(())\n-    }\n+    })\n }\n \n impl<'a> fmt::Display for GenericBounds<'a> {\n@@ -165,9 +159,9 @@ impl fmt::Display for clean::Generics {\n             return Ok(());\n         }\n         if f.alternate() {\n-            write!(f, \"<{:#}>\", CommaSep(&real_params))\n+            write!(f, \"<{:#}>\", comma_sep(&real_params))\n         } else {\n-            write!(f, \"&lt;{}&gt;\", CommaSep(&real_params))\n+            write!(f, \"&lt;{}&gt;\", comma_sep(&real_params))\n         }\n     }\n }\n@@ -265,9 +259,9 @@ impl fmt::Display for clean::PolyTrait {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         if !self.generic_params.is_empty() {\n             if f.alternate() {\n-                write!(f, \"for<{:#}> \", CommaSep(&self.generic_params))?;\n+                write!(f, \"for<{:#}> \", comma_sep(&self.generic_params))?;\n             } else {\n-                write!(f, \"for&lt;{}&gt; \", CommaSep(&self.generic_params))?;\n+                write!(f, \"for&lt;{}&gt; \", comma_sep(&self.generic_params))?;\n             }\n         }\n         if f.alternate() {\n@@ -452,16 +446,15 @@ fn resolved_path(w: &mut fmt::Formatter<'_>, did: DefId, path: &clean::Path,\n         write!(w, \"{}{:#}\", &last.name, last.args)?;\n     } else {\n         let path = if use_absolute {\n-            match href(did) {\n-                Some((_, _, fqp)) => {\n-                    format!(\"{}::{}\",\n-                            fqp[..fqp.len() - 1].join(\"::\"),\n-                            HRef::new(did, fqp.last().unwrap()))\n-                }\n-                None => HRef::new(did, &last.name).to_string(),\n+            if let Some((_, _, fqp)) = href(did) {\n+                format!(\"{}::{}\",\n+                        fqp[..fqp.len() - 1].join(\"::\"),\n+                        anchor(did, fqp.last().unwrap()))\n+            } else {\n+                last.name.to_string()\n             }\n         } else {\n-            HRef::new(did, &last.name).to_string()\n+            anchor(did, &last.name).to_string()\n         };\n         write!(w, \"{}{}\", path, last.args)?;\n     }\n@@ -513,35 +506,30 @@ fn primitive_link(f: &mut fmt::Formatter<'_>,\n }\n \n /// Helper to render type parameters\n-fn tybounds(w: &mut fmt::Formatter<'_>,\n-            param_names: &Option<Vec<clean::GenericBound>>) -> fmt::Result {\n-    match *param_names {\n-        Some(ref params) => {\n-            for param in params {\n-                write!(w, \" + \")?;\n-                fmt::Display::fmt(param, w)?;\n+fn tybounds(param_names: &Option<Vec<clean::GenericBound>>) -> impl fmt::Display + '_ {\n+    display_fn(move |f| {\n+        match *param_names {\n+            Some(ref params) => {\n+                for param in params {\n+                    write!(f, \" + \")?;\n+                    fmt::Display::fmt(param, f)?;\n+                }\n+                Ok(())\n             }\n-            Ok(())\n+            None => Ok(())\n         }\n-        None => Ok(())\n-    }\n-}\n-\n-impl<'a> HRef<'a> {\n-    pub fn new(did: DefId, text: &'a str) -> HRef<'a> {\n-        HRef { did: did, text: text }\n-    }\n+    })\n }\n \n-impl<'a> fmt::Display for HRef<'a> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        if let Some((url, short_ty, fqp)) = href(self.did) {\n+pub fn anchor(did: DefId, text: &str) -> impl fmt::Display + '_ {\n+    display_fn(move |f| {\n+        if let Some((url, short_ty, fqp)) = href(did) {\n             write!(f, r#\"<a class=\"{}\" href=\"{}\" title=\"{} {}\">{}</a>\"#,\n-                short_ty, url, short_ty, fqp.join(\"::\"), self.text)\n+                short_ty, url, short_ty, fqp.join(\"::\"), text)\n         } else {\n-            write!(f, \"{}\", self.text)\n+            write!(f, \"{}\", text)\n         }\n-    }\n+    })\n }\n \n fn fmt_type(t: &clean::Type, f: &mut fmt::Formatter<'_>, use_absolute: bool) -> fmt::Result {\n@@ -555,7 +543,7 @@ fn fmt_type(t: &clean::Type, f: &mut fmt::Formatter<'_>, use_absolute: bool) ->\n             }\n             // Paths like `T::Output` and `Self::Output` should be rendered with all segments.\n             resolved_path(f, did, path, is_generic, use_absolute)?;\n-            tybounds(f, param_names)\n+            fmt::Display::fmt(&tybounds(param_names), f)\n         }\n         clean::Infer => write!(f, \"_\"),\n         clean::Primitive(prim) => primitive_link(f, prim, prim.as_str()),\n@@ -564,12 +552,12 @@ fn fmt_type(t: &clean::Type, f: &mut fmt::Formatter<'_>, use_absolute: bool) ->\n                 write!(f, \"{}{:#}fn{:#}{:#}\",\n                        UnsafetySpace(decl.unsafety),\n                        AbiSpace(decl.abi),\n-                       CommaSep(&decl.generic_params),\n+                       comma_sep(&decl.generic_params),\n                        decl.decl)\n             } else {\n                 write!(f, \"{}{}\", UnsafetySpace(decl.unsafety), AbiSpace(decl.abi))?;\n                 primitive_link(f, PrimitiveType::Fn, \"fn\")?;\n-                write!(f, \"{}{}\", CommaSep(&decl.generic_params), decl.decl)\n+                write!(f, \"{}{}\", comma_sep(&decl.generic_params), decl.decl)\n             }\n         }\n         clean::Tuple(ref typs) => {\n@@ -583,7 +571,7 @@ fn fmt_type(t: &clean::Type, f: &mut fmt::Formatter<'_>, use_absolute: bool) ->\n                 }\n                 many => {\n                     primitive_link(f, PrimitiveType::Tuple, \"(\")?;\n-                    fmt::Display::fmt(&CommaSep(many), f)?;\n+                    fmt::Display::fmt(&comma_sep(many), f)?;\n                     primitive_link(f, PrimitiveType::Tuple, \")\")\n                 }\n             }\n@@ -1063,3 +1051,19 @@ impl fmt::Display for DefaultSpace {\n         }\n     }\n }\n+\n+crate fn display_fn(\n+    f: impl FnOnce(&mut fmt::Formatter<'_>) -> fmt::Result,\n+) -> impl fmt::Display {\n+    WithFormatter(Cell::new(Some(f)))\n+}\n+\n+struct WithFormatter<F>(Cell<Option<F>>);\n+\n+impl<F> fmt::Display for WithFormatter<F>\n+    where F: FnOnce(&mut fmt::Formatter<'_>) -> fmt::Result,\n+{\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        (self.0.take()).unwrap()(f)\n+    }\n+}"}, {"sha": "c37c8ef9e6c3479fd830ab8ff02a7b652ff5222b", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/edfd5556f1ddc44a9cf5a53db417330661d47053/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edfd5556f1ddc44a9cf5a53db417330661d47053/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=edfd5556f1ddc44a9cf5a53db417330661d47053", "patch": "@@ -2644,19 +2644,19 @@ fn item_module(w: &mut fmt::Formatter<'_>, cx: &Context,\n \n         match myitem.inner {\n             clean::ExternCrateItem(ref name, ref src) => {\n-                use crate::html::format::HRef;\n+                use crate::html::format::anchor;\n \n                 match *src {\n                     Some(ref src) => {\n                         write!(w, \"<tr><td><code>{}extern crate {} as {};\",\n                                VisSpace(&myitem.visibility),\n-                               HRef::new(myitem.def_id, src),\n+                               anchor(myitem.def_id, src),\n                                name)?\n                     }\n                     None => {\n                         write!(w, \"<tr><td><code>{}extern crate {};\",\n                                VisSpace(&myitem.visibility),\n-                               HRef::new(myitem.def_id, name))?\n+                               anchor(myitem.def_id, name))?\n                     }\n                 }\n                 write!(w, \"</code></td></tr>\")?;"}]}