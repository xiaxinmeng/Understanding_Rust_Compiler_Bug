{"sha": "d34588bf83898870d7f9b4b49ac2a5f71c77dabb", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQzNDU4OGJmODM4OTg4NzBkN2Y5YjRiNDlhYzJhNWY3MWM3N2RhYmI=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-08-28T15:22:52Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-08-28T15:22:59Z"}, "message": "create module smartly", "tree": {"sha": "a0b6eb7b41cb586d1c10e408a4791edf7c341a1f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a0b6eb7b41cb586d1c10e408a4791edf7c341a1f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d34588bf83898870d7f9b4b49ac2a5f71c77dabb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d34588bf83898870d7f9b4b49ac2a5f71c77dabb", "html_url": "https://github.com/rust-lang/rust/commit/d34588bf83898870d7f9b4b49ac2a5f71c77dabb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d34588bf83898870d7f9b4b49ac2a5f71c77dabb/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "748a4cacd24d9ecdca995e66117a10a1562e7d5d", "url": "https://api.github.com/repos/rust-lang/rust/commits/748a4cacd24d9ecdca995e66117a10a1562e7d5d", "html_url": "https://github.com/rust-lang/rust/commit/748a4cacd24d9ecdca995e66117a10a1562e7d5d"}], "stats": {"total": 528, "additions": 345, "deletions": 183}, "files": [{"sha": "3b24b73b641e6c77986e707c1ec1ad646774ce07", "filename": "code/src/extension.ts", "status": "modified", "additions": 25, "deletions": 4, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/d34588bf83898870d7f9b4b49ac2a5f71c77dabb/code%2Fsrc%2Fextension.ts", "raw_url": "https://github.com/rust-lang/rust/raw/d34588bf83898870d7f9b4b49ac2a5f71c77dabb/code%2Fsrc%2Fextension.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/code%2Fsrc%2Fextension.ts?ref=d34588bf83898870d7f9b4b49ac2a5f71c77dabb", "patch": "@@ -113,12 +113,26 @@ export function activate(context: vscode.ExtensionContext) {\n             return await vscode.tasks.executeTask(task)\n         }\n     })\n-    registerCommand('libsyntax-rust.createFile', async (uri_: string) => {\n-        let uri = vscode.Uri.parse(uri_)\n+    registerCommand('libsyntax-rust.fsEdit', async (ops: FsOp[]) => {\n         let edit = new vscode.WorkspaceEdit()\n-        edit.createFile(uri)\n+        let created;\n+        let moved;\n+        for (let op of ops) {\n+            if (op.type == \"createFile\") {\n+                let uri = vscode.Uri.parse(op.uri!)\n+                edit.createFile(uri)\n+                created = uri\n+            } else if (op.type == \"moveFile\") {\n+                let src = vscode.Uri.parse(op.src!)\n+                let dst = vscode.Uri.parse(op.dst!)\n+                edit.renameFile(src, dst)\n+                moved = dst\n+            } else {\n+                console.error(`unknown op: ${JSON.stringify(op)}`)\n+            }\n+        }\n         await vscode.workspace.applyEdit(edit)\n-        let doc = await vscode.workspace.openTextDocument(uri)\n+        let doc = await vscode.workspace.openTextDocument((created || moved)!)\n         await vscode.window.showTextDocument(doc)\n     })\n \n@@ -368,3 +382,10 @@ function createTask(spec: Runnable): vscode.Task {\n     let t = new vscode.Task(definition, f, definition.label, TASK_SOURCE, exec, ['$rustc']);\n     return t;\n }\n+\n+interface FsOp {\n+    type: string;\n+    uri?: string;\n+    src?: string;\n+    dst?: string;\n+}"}, {"sha": "5aca84f0ecd096aaf5c54ed651b05a40efce7bcb", "filename": "crates/libanalysis/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d34588bf83898870d7f9b4b49ac2a5f71c77dabb/crates%2Flibanalysis%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/d34588bf83898870d7f9b4b49ac2a5f71c77dabb/crates%2Flibanalysis%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibanalysis%2FCargo.toml?ref=d34588bf83898870d7f9b4b49ac2a5f71c77dabb", "patch": "@@ -4,6 +4,7 @@ version = \"0.1.0\"\n authors = [\"Aleksey Kladov <aleksey.kladov@gmail.com>\"]\n \n [dependencies]\n+relative-path = \"0.3.7\"\n log = \"0.4.2\"\n failure = \"0.1.2\"\n parking_lot = \"0.6.3\""}, {"sha": "96d10a087c99f50006ca8e98ffa892401b3f9e3b", "filename": "crates/libanalysis/src/lib.rs", "status": "modified", "additions": 64, "deletions": 19, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/d34588bf83898870d7f9b4b49ac2a5f71c77dabb/crates%2Flibanalysis%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d34588bf83898870d7f9b4b49ac2a5f71c77dabb/crates%2Flibanalysis%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibanalysis%2Fsrc%2Flib.rs?ref=d34588bf83898870d7f9b4b49ac2a5f71c77dabb", "patch": "@@ -8,13 +8,13 @@ extern crate libsyntax2;\n extern crate libeditor;\n extern crate fst;\n extern crate rayon;\n+extern crate relative_path;\n \n mod symbol_index;\n mod module_map;\n \n use std::{\n     fmt,\n-    path::{Path, PathBuf},\n     panic,\n     sync::{\n         Arc,\n@@ -24,6 +24,7 @@ use std::{\n     time::Instant,\n };\n \n+use relative_path::{RelativePath,RelativePathBuf};\n use once_cell::sync::OnceCell;\n use rayon::prelude::*;\n \n@@ -37,13 +38,16 @@ use libeditor::{Diagnostic, LineIndex, FileSymbol, find_node_at_offset};\n \n use self::{\n     symbol_index::FileSymbols,\n-    module_map::{ModuleMap, ChangeKind},\n+    module_map::{ModuleMap, ChangeKind, Problem},\n };\n pub use self::symbol_index::Query;\n \n pub type Result<T> = ::std::result::Result<T, ::failure::Error>;\n \n-pub type FileResolver = dyn Fn(FileId, &Path) -> Option<FileId> + Send + Sync;\n+pub trait FileResolver: Send + Sync + 'static {\n+    fn file_stem(&self, id: FileId) -> String;\n+    fn resolve(&self, id: FileId, path: &RelativePath) -> Option<FileId>;\n+}\n \n #[derive(Debug)]\n pub struct WorldState {\n@@ -84,7 +88,7 @@ impl WorldState {\n \n     pub fn snapshot(\n         &self,\n-        file_resolver: impl Fn(FileId, &Path) -> Option<FileId> + 'static + Send + Sync,\n+        file_resolver: impl FileResolver,\n     ) -> World {\n         World {\n             needs_reindex: AtomicBool::new(false),\n@@ -132,8 +136,20 @@ impl WorldState {\n }\n \n #[derive(Debug)]\n-pub enum QuickFix {\n-    CreateFile(PathBuf),\n+pub struct QuickFix {\n+    pub fs_ops: Vec<FsOp>,\n+}\n+\n+#[derive(Debug)]\n+pub enum FsOp {\n+    CreateFile {\n+        anchor: FileId,\n+        path: RelativePathBuf,\n+    },\n+    MoveFile {\n+        file: FileId,\n+        path: RelativePathBuf,\n+    }\n }\n \n impl World {\n@@ -221,20 +237,49 @@ impl World {\n             .into_iter()\n             .map(|d| (d, None))\n             .collect::<Vec<_>>();\n-        for module in syntax.ast().modules() {\n-            if module.has_semi() && self.resolve_module(file_id, module).is_empty() {\n-                if let Some(name) = module.name() {\n-                    let d = Diagnostic {\n-                        range: name.syntax().range(),\n-                        msg: \"unresolved module\".to_string(),\n-                    };\n-                    let quick_fix = self.data.module_map.suggested_child_mod_path(module)\n-                        .map(QuickFix::CreateFile);\n-\n-                    res.push((d, quick_fix))\n-                }\n+\n+        self.data.module_map.problems(\n+            file_id,\n+            &*self.file_resolver,\n+            &|file_id| self.file_syntax(file_id).unwrap(),\n+            |name_node, problem| {\n+                let (diag, fix) = match problem {\n+                    Problem::UnresolvedModule { candidate } => {\n+                        let diag = Diagnostic {\n+                            range: name_node.syntax().range(),\n+                            msg: \"unresolved module\".to_string(),\n+                        };\n+                        let fix = QuickFix {\n+                            fs_ops: vec![FsOp::CreateFile {\n+                                anchor: file_id,\n+                                path: candidate.clone(),\n+                            }]\n+                        };\n+                        (diag, fix)\n+                    }\n+                    Problem::NotDirOwner { move_to, candidate } => {\n+                        let diag = Diagnostic {\n+                            range: name_node.syntax().range(),\n+                            msg: \"can't declare module at this location\".to_string(),\n+                        };\n+                        let fix = QuickFix {\n+                            fs_ops: vec![\n+                                FsOp::MoveFile {\n+                                    file: file_id,\n+                                    path: move_to.clone(),\n+                                },\n+                                FsOp::CreateFile {\n+                                    anchor: file_id,\n+                                    path: move_to.join(candidate),\n+                                }\n+                            ],\n+                        };\n+                        (diag, fix)\n+                    }\n+                };\n+                res.push((diag, Some(fix)))\n             }\n-        }\n+        );\n         Ok(res)\n     }\n "}, {"sha": "b65569c46e3baffe667d047633590e539b0e592f", "filename": "crates/libanalysis/src/module_map.rs", "status": "modified", "additions": 62, "deletions": 18, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/d34588bf83898870d7f9b4b49ac2a5f71c77dabb/crates%2Flibanalysis%2Fsrc%2Fmodule_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d34588bf83898870d7f9b4b49ac2a5f71c77dabb/crates%2Flibanalysis%2Fsrc%2Fmodule_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibanalysis%2Fsrc%2Fmodule_map.rs?ref=d34588bf83898870d7f9b4b49ac2a5f71c77dabb", "patch": "@@ -1,6 +1,4 @@\n-use std::{\n-    path::{PathBuf},\n-};\n+use relative_path::RelativePathBuf;\n \n use parking_lot::{RwLock, RwLockReadGuard, RwLockWriteGuard};\n use libsyntax2::{\n@@ -43,6 +41,18 @@ struct Link {\n     owner: ModuleId,\n     syntax: SyntaxNode,\n     points_to: Vec<ModuleId>,\n+    problem: Option<Problem>,\n+}\n+\n+#[derive(Clone, Debug)]\n+pub enum Problem {\n+    UnresolvedModule {\n+        candidate: RelativePathBuf,\n+    },\n+    NotDirOwner {\n+        move_to: RelativePathBuf,\n+        candidate: RelativePathBuf,\n+    }\n }\n \n impl ModuleMap {\n@@ -93,9 +103,24 @@ impl ModuleMap {\n         res\n     }\n \n-    pub fn suggested_child_mod_path(&self, m: ast::Module) -> Option<PathBuf> {\n-        let name = m.name()?;\n-        Some(PathBuf::from(format!(\"../{}.rs\", name.text())))\n+    pub fn problems(\n+        &self,\n+        file: FileId,\n+        file_resolver: &FileResolver,\n+        syntax_provider: &SyntaxProvider,\n+        mut cb: impl FnMut(ast::Name, &Problem),\n+    ) {\n+        let module = self.file2module(file);\n+        let links = self.links(file_resolver, syntax_provider);\n+        links\n+            .links\n+            .iter()\n+            .filter(|link| link.owner == module)\n+            .filter_map(|link| {\n+                let problem = link.problem.as_ref()?;\n+                Some((link, problem))\n+            })\n+            .for_each(|(link, problem)| cb(link.name_node(), problem))\n     }\n \n     fn links(\n@@ -176,14 +201,17 @@ impl Link {\n             owner,\n             syntax: module.syntax().owned(),\n             points_to: Vec::new(),\n+            problem: None,\n         };\n         Some(link)\n     }\n \n     fn name(&self) -> SmolStr {\n-        self.ast().name()\n-            .unwrap()\n-            .text()\n+        self.name_node().text()\n+    }\n+\n+    fn name_node(&self) -> ast::Name {\n+        self.ast().name().unwrap()\n     }\n \n     fn ast(&self) -> ast::Module {\n@@ -192,14 +220,30 @@ impl Link {\n     }\n \n     fn resolve(&mut self, file_resolver: &FileResolver) {\n-        let name = self.name();\n-        let paths = &[\n-            PathBuf::from(format!(\"../{}.rs\", name)),\n-            PathBuf::from(format!(\"../{}/mod.rs\", name)),\n-        ];\n-        self.points_to = paths.iter()\n-            .filter_map(|path| file_resolver(self.owner.0, path))\n-            .map(ModuleId)\n-            .collect();\n+        let mod_name = file_resolver.file_stem(self.owner.0);\n+        let is_dir_owner =\n+            mod_name == \"mod\" || mod_name == \"lib\" || mod_name == \"main\";\n+\n+        let file_mod = RelativePathBuf::from(format!(\"../{}.rs\", self.name()));\n+        let dir_mod = RelativePathBuf::from(format!(\"../{}/mod.rs\", self.name()));\n+        if is_dir_owner {\n+            self.points_to = [&file_mod, &dir_mod].iter()\n+                .filter_map(|path| file_resolver.resolve(self.owner.0, path))\n+                .map(ModuleId)\n+                .collect();\n+            self.problem = if self.points_to.is_empty() {\n+                Some(Problem::UnresolvedModule {\n+                    candidate: file_mod,\n+                })\n+            } else {\n+                None\n+            }\n+        } else {\n+            self.points_to = Vec::new();\n+            self.problem = Some(Problem::NotDirOwner {\n+                move_to: RelativePathBuf::from(format!(\"../{}/mod.rs\", mod_name)),\n+                candidate: file_mod,\n+            });\n+        }\n     }\n }"}, {"sha": "e378ab9868689ce0f4ab04da85d43b95a4a7685d", "filename": "crates/libanalysis/tests/tests.rs", "status": "modified", "additions": 44, "deletions": 28, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/d34588bf83898870d7f9b4b49ac2a5f71c77dabb/crates%2Flibanalysis%2Ftests%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d34588bf83898870d7f9b4b49ac2a5f71c77dabb/crates%2Flibanalysis%2Ftests%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibanalysis%2Ftests%2Ftests.rs?ref=d34588bf83898870d7f9b4b49ac2a5f71c77dabb", "patch": "@@ -1,41 +1,61 @@\n extern crate libanalysis;\n+extern crate relative_path;\n extern crate test_utils;\n \n-use std::path::PathBuf;\n+use std::path::{Path};\n \n-use libanalysis::{WorldState, FileId};\n+use relative_path::RelativePath;\n+use libanalysis::{WorldState, FileId, FileResolver};\n use test_utils::assert_eq_dbg;\n \n+struct FileMap(&'static [(u32, &'static str)]);\n+\n+impl FileMap {\n+    fn path(&self, id: FileId) -> &'static Path {\n+        let s = self.0.iter()\n+            .find(|it| it.0 == id.0)\n+            .unwrap()\n+            .1;\n+        Path::new(s)\n+    }\n+}\n+\n+impl FileResolver for FileMap {\n+    fn file_stem(&self, id: FileId) -> String {\n+        self.path(id).file_stem().unwrap().to_str().unwrap().to_string()\n+    }\n+    fn resolve(&self, id: FileId, rel: &RelativePath) -> Option<FileId> {\n+        let path = rel.to_path(self.path(id));\n+        let path = path.to_str().unwrap();\n+        let path = RelativePath::new(&path[1..]).normalize();\n+        let &(id, _) = self.0.iter()\n+            .find(|it| path == RelativePath::new(&it.1[1..]).normalize())?;\n+        Some(FileId(id))\n+    }\n+}\n+\n \n #[test]\n fn test_resolve_module() {\n     let mut world = WorldState::new();\n     world.change_file(FileId(1), Some(\"mod foo;\".to_string()));\n     world.change_file(FileId(2), Some(\"\".to_string()));\n \n-    let snap = world.snapshot(|id, path| {\n-        assert_eq!(id, FileId(1));\n-        if path == PathBuf::from(\"../foo/mod.rs\") {\n-            return None;\n-        }\n-        assert_eq!(path, PathBuf::from(\"../foo.rs\"));\n-        Some(FileId(2))\n-    });\n+    let snap = world.snapshot(FileMap(&[\n+        (1, \"/lib.rs\"),\n+        (2, \"/foo.rs\"),\n+    ]));\n     let symbols = snap.approximately_resolve_symbol(FileId(1), 4.into())\n         .unwrap();\n     assert_eq_dbg(\n         r#\"[(FileId(2), FileSymbol { name: \"foo\", node_range: [0; 0), kind: MODULE })]\"#,\n         &symbols,\n     );\n \n-    let snap = world.snapshot(|id, path| {\n-        assert_eq!(id, FileId(1));\n-        if path == PathBuf::from(\"../foo.rs\") {\n-            return None;\n-        }\n-        assert_eq!(path, PathBuf::from(\"../foo/mod.rs\"));\n-        Some(FileId(2))\n-    });\n+    let snap = world.snapshot(FileMap(&[\n+        (1, \"/lib.rs\"),\n+        (2, \"/foo/mod.rs\")\n+    ]));\n     let symbols = snap.approximately_resolve_symbol(FileId(1), 4.into())\n         .unwrap();\n     assert_eq_dbg(\n@@ -49,11 +69,11 @@ fn test_unresolved_module_diagnostic() {\n     let mut world = WorldState::new();\n     world.change_file(FileId(1), Some(\"mod foo;\".to_string()));\n \n-    let snap = world.snapshot(|_id, _path| None);\n+    let snap = world.snapshot(FileMap(&[(1, \"/lib.rs\")]));\n     let diagnostics = snap.diagnostics(FileId(1)).unwrap();\n     assert_eq_dbg(\n         r#\"[(Diagnostic { range: [4; 7), msg: \"unresolved module\" },\n-             Some(CreateFile(\"../foo.rs\")))]\"#,\n+             Some(QuickFix { fs_ops: [CreateFile { anchor: FileId(1), path: \"../foo.rs\" }] }))]\"#,\n         &diagnostics,\n     );\n }\n@@ -64,14 +84,10 @@ fn test_resolve_parent_module() {\n     world.change_file(FileId(1), Some(\"mod foo;\".to_string()));\n     world.change_file(FileId(2), Some(\"\".to_string()));\n \n-    let snap = world.snapshot(|id, path| {\n-        assert_eq!(id, FileId(1));\n-        if path == PathBuf::from(\"../foo/mod.rs\") {\n-            return None;\n-        }\n-        assert_eq!(path, PathBuf::from(\"../foo.rs\"));\n-        Some(FileId(2))\n-    });\n+    let snap = world.snapshot(FileMap(&[\n+        (1, \"/lib.rs\"),\n+        (2, \"/foo.rs\"),\n+    ]));\n     let symbols = snap.parent_module(FileId(2));\n     assert_eq_dbg(\n         r#\"[(FileId(1), FileSymbol { name: \"foo\", node_range: [0; 8), kind: MODULE })]\"#,"}, {"sha": "e807c6c71f08ca0c26bec9d514b7c344418fa520", "filename": "crates/libeditor/src/scope/fn_scope.rs", "status": "renamed", "additions": 89, "deletions": 89, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/d34588bf83898870d7f9b4b49ac2a5f71c77dabb/crates%2Flibeditor%2Fsrc%2Fscope%2Ffn_scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d34588bf83898870d7f9b4b49ac2a5f71c77dabb/crates%2Flibeditor%2Fsrc%2Fscope%2Ffn_scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibeditor%2Fsrc%2Fscope%2Ffn_scope.rs?ref=d34588bf83898870d7f9b4b49ac2a5f71c77dabb", "patch": "@@ -9,6 +9,95 @@ use libsyntax2::{\n     algo::{ancestors, generate, walk::preorder}\n };\n \n+type ScopeId = usize;\n+\n+#[derive(Debug)]\n+pub struct FnScopes {\n+    scopes: Vec<ScopeData>,\n+    scope_for: HashMap<SyntaxNode, ScopeId>,\n+}\n+\n+impl FnScopes {\n+    pub fn new(fn_def: ast::FnDef) -> FnScopes {\n+        let mut scopes = FnScopes {\n+            scopes: Vec::new(),\n+            scope_for: HashMap::new()\n+        };\n+        let root = scopes.root_scope();\n+        fn_def.param_list().into_iter()\n+            .flat_map(|it| it.params())\n+            .filter_map(|it| it.pat())\n+            .for_each(|it| scopes.add_bindings(root, it));\n+\n+        if let Some(body) = fn_def.body() {\n+            compute_block_scopes(body, &mut scopes, root)\n+        }\n+        scopes\n+    }\n+    pub fn entries(&self, scope: ScopeId) -> &[ScopeEntry] {\n+        &self.scopes[scope].entries\n+    }\n+    pub fn scope_chain<'a>(&'a self, node: SyntaxNodeRef) -> impl Iterator<Item=ScopeId> + 'a {\n+        generate(self.scope_for(node), move |&scope| self.scopes[scope].parent)\n+    }\n+    fn root_scope(&mut self) -> ScopeId {\n+        let res = self.scopes.len();\n+        self.scopes.push(ScopeData { parent: None, entries: vec![] });\n+        res\n+    }\n+    fn new_scope(&mut self, parent: ScopeId) -> ScopeId {\n+        let res = self.scopes.len();\n+        self.scopes.push(ScopeData { parent: Some(parent), entries: vec![] });\n+        res\n+    }\n+    fn add_bindings(&mut self, scope: ScopeId, pat: ast::Pat) {\n+        let entries = preorder(pat.syntax())\n+            .filter_map(ast::BindPat::cast)\n+            .filter_map(ScopeEntry::new);\n+        self.scopes[scope].entries.extend(entries);\n+    }\n+    fn set_scope(&mut self, node: SyntaxNodeRef, scope: ScopeId) {\n+        self.scope_for.insert(node.owned(), scope);\n+    }\n+    fn scope_for(&self, node: SyntaxNodeRef) -> Option<ScopeId> {\n+        ancestors(node)\n+            .filter_map(|it| self.scope_for.get(&it.owned()).map(|&scope| scope))\n+            .next()\n+    }\n+}\n+\n+pub struct ScopeEntry {\n+    syntax: SyntaxNode\n+}\n+\n+impl ScopeEntry {\n+    fn new(pat: ast::BindPat) -> Option<ScopeEntry> {\n+        if pat.name().is_some() {\n+            Some(ScopeEntry { syntax: pat.syntax().owned() })\n+        } else {\n+            None\n+        }\n+    }\n+    pub fn name(&self) -> SmolStr {\n+        self.ast().name()\n+            .unwrap()\n+            .text()\n+    }\n+    fn ast(&self) -> ast::BindPat {\n+        ast::BindPat::cast(self.syntax.borrowed())\n+            .unwrap()\n+    }\n+}\n+\n+impl fmt::Debug for ScopeEntry {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_struct(\"ScopeEntry\")\n+         .field(\"name\", &self.name())\n+         .field(\"syntax\", &self.syntax)\n+         .finish()\n+    }\n+}\n+\n fn compute_block_scopes(block: ast::Block, scopes: &mut FnScopes, mut scope: ScopeId) {\n     for stmt in block.statements() {\n         match stmt {\n@@ -95,97 +184,8 @@ fn compute_expr_scopes(expr: ast::Expr, scopes: &mut FnScopes, scope: ScopeId) {\n     }\n }\n \n-type ScopeId = usize;\n-\n-#[derive(Debug)]\n-pub struct FnScopes {\n-    scopes: Vec<ScopeData>,\n-    scope_for: HashMap<SyntaxNode, ScopeId>,\n-}\n-\n-impl FnScopes {\n-    pub fn new(fn_def: ast::FnDef) -> FnScopes {\n-        let mut scopes = FnScopes {\n-            scopes: Vec::new(),\n-            scope_for: HashMap::new()\n-        };\n-        let root = scopes.root_scope();\n-        fn_def.param_list().into_iter()\n-            .flat_map(|it| it.params())\n-            .filter_map(|it| it.pat())\n-            .for_each(|it| scopes.add_bindings(root, it));\n-\n-        if let Some(body) = fn_def.body() {\n-            compute_block_scopes(body, &mut scopes, root)\n-        }\n-        scopes\n-    }\n-    pub fn entries(&self, scope: ScopeId) -> &[ScopeEntry] {\n-        &self.scopes[scope].entries\n-    }\n-    pub fn scope_chain<'a>(&'a self, node: SyntaxNodeRef) -> impl Iterator<Item=ScopeId> + 'a {\n-        generate(self.scope_for(node), move |&scope| self.scopes[scope].parent)\n-    }\n-    fn root_scope(&mut self) -> ScopeId {\n-        let res = self.scopes.len();\n-        self.scopes.push(ScopeData { parent: None, entries: vec![] });\n-        res\n-    }\n-    fn new_scope(&mut self, parent: ScopeId) -> ScopeId {\n-        let res = self.scopes.len();\n-        self.scopes.push(ScopeData { parent: Some(parent), entries: vec![] });\n-        res\n-    }\n-    fn add_bindings(&mut self, scope: ScopeId, pat: ast::Pat) {\n-        let entries = preorder(pat.syntax())\n-            .filter_map(ast::BindPat::cast)\n-            .filter_map(ScopeEntry::new);\n-        self.scopes[scope].entries.extend(entries);\n-    }\n-    fn set_scope(&mut self, node: SyntaxNodeRef, scope: ScopeId) {\n-        self.scope_for.insert(node.owned(), scope);\n-    }\n-    fn scope_for(&self, node: SyntaxNodeRef) -> Option<ScopeId> {\n-        ancestors(node)\n-            .filter_map(|it| self.scope_for.get(&it.owned()).map(|&scope| scope))\n-            .next()\n-    }\n-}\n-\n #[derive(Debug)]\n struct ScopeData {\n     parent: Option<ScopeId>,\n     entries: Vec<ScopeEntry>\n }\n-\n-pub struct ScopeEntry {\n-    syntax: SyntaxNode\n-}\n-\n-impl ScopeEntry {\n-    fn new(pat: ast::BindPat) -> Option<ScopeEntry> {\n-        if pat.name().is_some() {\n-            Some(ScopeEntry { syntax: pat.syntax().owned() })\n-        } else {\n-            None\n-        }\n-    }\n-    pub fn name(&self) -> SmolStr {\n-        self.ast().name()\n-            .unwrap()\n-            .text()\n-    }\n-    fn ast(&self) -> ast::BindPat {\n-        ast::BindPat::cast(self.syntax.borrowed())\n-            .unwrap()\n-    }\n-}\n-\n-impl fmt::Debug for ScopeEntry {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.debug_struct(\"ScopeEntry\")\n-         .field(\"name\", &self.name())\n-         .field(\"syntax\", &self.syntax)\n-         .finish()\n-    }\n-}", "previous_filename": "crates/libeditor/src/scope.rs"}, {"sha": "1a77a8b6e27a1cc63dfacf05a1adc508c3a3f8f3", "filename": "crates/libeditor/src/scope/mod.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d34588bf83898870d7f9b4b49ac2a5f71c77dabb/crates%2Flibeditor%2Fsrc%2Fscope%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d34588bf83898870d7f9b4b49ac2a5f71c77dabb/crates%2Flibeditor%2Fsrc%2Fscope%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibeditor%2Fsrc%2Fscope%2Fmod.rs?ref=d34588bf83898870d7f9b4b49ac2a5f71c77dabb", "patch": "@@ -0,0 +1,3 @@\n+mod fn_scope;\n+\n+pub use self::fn_scope::FnScopes;"}, {"sha": "35ced91ac79ddf570f1b12d968e3bdd25e62adc1", "filename": "crates/server/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d34588bf83898870d7f9b4b49ac2a5f71c77dabb/crates%2Fserver%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/d34588bf83898870d7f9b4b49ac2a5f71c77dabb/crates%2Fserver%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fserver%2FCargo.toml?ref=d34588bf83898870d7f9b4b49ac2a5f71c77dabb", "patch": "@@ -4,6 +4,7 @@ version = \"0.1.0\"\n authors = [\"Aleksey Kladov <aleksey.kladov@gmail.com>\"]\n \n [dependencies]\n+relative-path = \"0.3.7\"\n failure = \"0.1.2\"\n serde_json = \"1.0.24\"\n serde = \"1.0.71\""}, {"sha": "1a93af65b73a0868174c7f4b283960737bb71812", "filename": "crates/server/src/main.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d34588bf83898870d7f9b4b49ac2a5f71c77dabb/crates%2Fserver%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d34588bf83898870d7f9b4b49ac2a5f71c77dabb/crates%2Fserver%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fserver%2Fsrc%2Fmain.rs?ref=d34588bf83898870d7f9b4b49ac2a5f71c77dabb", "patch": "@@ -18,6 +18,7 @@ extern crate libeditor;\n extern crate libanalysis;\n extern crate libsyntax2;\n extern crate im;\n+extern crate relative_path;\n \n mod io;\n mod caps;"}, {"sha": "92ffb30c30b8c9842daf4effaa69f38a3ddc978f", "filename": "crates/server/src/main_loop/handlers.rs", "status": "modified", "additions": 39, "deletions": 13, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/d34588bf83898870d7f9b4b49ac2a5f71c77dabb/crates%2Fserver%2Fsrc%2Fmain_loop%2Fhandlers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d34588bf83898870d7f9b4b49ac2a5f71c77dabb/crates%2Fserver%2Fsrc%2Fmain_loop%2Fhandlers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fserver%2Fsrc%2Fmain_loop%2Fhandlers.rs?ref=d34588bf83898870d7f9b4b49ac2a5f71c77dabb", "patch": "@@ -7,7 +7,8 @@ use languageserver_types::{\n     CompletionItem,\n };\n use serde_json::{to_value, from_value};\n-use libanalysis::{Query, QuickFix, FileId};\n+use url_serde;\n+use libanalysis::{self, Query, FileId};\n use libeditor;\n use libsyntax2::{\n     TextUnit,\n@@ -144,24 +145,49 @@ pub fn handle_code_action(\n         if !contains_offset_nonstrict(diag.range, offset) {\n             continue;\n         }\n-        let cmd = match quick_fix {\n-            QuickFix::CreateFile(path) => {\n-                let path = &path.to_str().unwrap()[3..]; // strip `../` b/c url is weird\n-                let uri = params.text_document.uri.join(path)\n-                    .unwrap();\n-                let uri = ::url_serde::Ser::new(&uri);\n-                Command {\n-                    title: \"Create file\".to_string(),\n-                    command: \"libsyntax-rust.createFile\".to_string(),\n-                    arguments: Some(vec![to_value(uri).unwrap()]),\n-                }\n-            }\n+        let mut ops = Vec::new();\n+        for op in quick_fix.fs_ops {\n+            let op = match op {\n+                libanalysis::FsOp::CreateFile { anchor, path } => {\n+                    let uri = world.file_id_to_uri(anchor)?;\n+                    let path = &path.as_str()[3..]; // strip `../` b/c url is weird\n+                    let uri = uri.join(path)?;\n+                    FsOp::CreateFile { uri }\n+                },\n+                libanalysis::FsOp::MoveFile { file, path } => {\n+                    let src = world.file_id_to_uri(file)?;\n+                    let path = &path.as_str()[3..]; // strip `../` b/c url is weird\n+                    let dst = src.join(path)?;\n+                    FsOp::MoveFile { src, dst }\n+                },\n+            };\n+            ops.push(op)\n+        }\n+        let cmd = Command {\n+            title: \"Create module\".to_string(),\n+            command: \"libsyntax-rust.fsEdit\".to_string(),\n+            arguments: Some(vec![to_value(ops).unwrap()]),\n         };\n         res.push(cmd)\n     }\n     return Ok(Some(res));\n }\n \n+#[derive(Serialize)]\n+#[serde(tag = \"type\", rename_all = \"camelCase\")]\n+enum FsOp {\n+    CreateFile {\n+        #[serde(with = \"url_serde\")]\n+        uri: Url\n+    },\n+    MoveFile {\n+        #[serde(with = \"url_serde\")]\n+        src: Url,\n+        #[serde(with = \"url_serde\")]\n+        dst: Url,\n+    }\n+}\n+\n pub fn handle_runnables(\n     world: ServerWorld,\n     params: req::RunnablesParams,"}, {"sha": "f4ac47e70dddf1ead5bc0978b6ebe7ce4ca6414e", "filename": "crates/server/src/path_map.rs", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/d34588bf83898870d7f9b4b49ac2a5f71c77dabb/crates%2Fserver%2Fsrc%2Fpath_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d34588bf83898870d7f9b4b49ac2a5f71c77dabb/crates%2Fserver%2Fsrc%2Fpath_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fserver%2Fsrc%2Fpath_map.rs?ref=d34588bf83898870d7f9b4b49ac2a5f71c77dabb", "patch": "@@ -1,6 +1,7 @@\n use std::path::{PathBuf, Path, Component};\n use im;\n-use libanalysis::{FileId};\n+use relative_path::RelativePath;\n+use libanalysis::{FileId, FileResolver};\n \n #[derive(Debug, Default, Clone)]\n pub struct PathMap {\n@@ -34,12 +35,6 @@ impl PathMap {\n             .as_path()\n     }\n \n-    pub fn resolve(&self, id: FileId, relpath: &Path) -> Option<FileId> {\n-        let path = self.get_path(id).join(relpath);\n-        let path = normalize(&path);\n-        self.get_id(&path)\n-    }\n-\n     fn insert(&mut self, path: PathBuf, id: FileId) {\n         self.path2id.insert(path.clone(), id);\n         self.id2path.insert(id, path.clone());\n@@ -52,6 +47,18 @@ impl PathMap {\n     }\n }\n \n+impl FileResolver for PathMap {\n+    fn file_stem(&self, id: FileId) -> String {\n+        self.get_path(id).file_stem().unwrap().to_str().unwrap().to_string()\n+    }\n+\n+    fn resolve(&self, id: FileId, path: &RelativePath) -> Option<FileId> {\n+        let path = path.to_path(&self.get_path(id));\n+        let path = normalize(&path);\n+        self.get_id(&path)\n+    }\n+}\n+\n fn normalize(path: &Path) -> PathBuf {\n     let mut components = path.components().peekable();\n     let mut ret = if let Some(c @ Component::Prefix(..)) = components.peek().cloned() {\n@@ -89,7 +96,7 @@ mod test {\n         let id1 = m.get_or_insert(PathBuf::from(\"/foo\"));\n         let id2 = m.get_or_insert(PathBuf::from(\"/foo/bar.rs\"));\n         assert_eq!(\n-            m.resolve(id1, &PathBuf::from(\"bar.rs\")),\n+            m.resolve(id1, &RelativePath::new(\"bar.rs\")),\n             Some(id2),\n         )\n     }"}, {"sha": "1593cd59f68cbde30847c3c230485f9a492b533f", "filename": "crates/server/src/server_world.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d34588bf83898870d7f9b4b49ac2a5f71c77dabb/crates%2Fserver%2Fsrc%2Fserver_world.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d34588bf83898870d7f9b4b49ac2a5f71c77dabb/crates%2Fserver%2Fsrc%2Fserver_world.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fserver%2Fsrc%2Fserver_world.rs?ref=d34588bf83898870d7f9b4b49ac2a5f71c77dabb", "patch": "@@ -87,11 +87,8 @@ impl ServerWorldState {\n     }\n \n     pub fn snapshot(&self) -> ServerWorld {\n-        let pm = self.path_map.clone();\n         ServerWorld {\n-            analysis: self.analysis.snapshot(move |id, path| {\n-                pm.resolve(id, path)\n-            }),\n+            analysis: self.analysis.snapshot(self.path_map.clone()),\n             path_map: self.path_map.clone()\n         }\n     }"}]}