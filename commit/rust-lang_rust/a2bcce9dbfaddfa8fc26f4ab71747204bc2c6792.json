{"sha": "a2bcce9dbfaddfa8fc26f4ab71747204bc2c6792", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEyYmNjZTlkYmZhZGRmYThmYzI2ZjRhYjcxNzQ3MjA0YmMyYzY3OTI=", "commit": {"author": {"name": "sinkuu", "email": "sinkuupump@gmail.com", "date": "2017-01-07T14:39:50Z"}, "committer": {"name": "sinkuu", "email": "sinkuupump@gmail.com", "date": "2017-01-07T14:52:48Z"}, "message": "Move `is_try` to util\n\nRemoved unnecessary condition\n\nAlso changed lint span of `try` from surrounded expression to entire `try`\ninvocation. It turned out that compiletest misses errors for macro invocations.", "tree": {"sha": "d7c656ca297c3e424cc4f42cdaeb7dd814d581c6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d7c656ca297c3e424cc4f42cdaeb7dd814d581c6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a2bcce9dbfaddfa8fc26f4ab71747204bc2c6792", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a2bcce9dbfaddfa8fc26f4ab71747204bc2c6792", "html_url": "https://github.com/rust-lang/rust/commit/a2bcce9dbfaddfa8fc26f4ab71747204bc2c6792", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a2bcce9dbfaddfa8fc26f4ab71747204bc2c6792/comments", "author": {"login": "sinkuu", "id": 7091080, "node_id": "MDQ6VXNlcjcwOTEwODA=", "avatar_url": "https://avatars.githubusercontent.com/u/7091080?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sinkuu", "html_url": "https://github.com/sinkuu", "followers_url": "https://api.github.com/users/sinkuu/followers", "following_url": "https://api.github.com/users/sinkuu/following{/other_user}", "gists_url": "https://api.github.com/users/sinkuu/gists{/gist_id}", "starred_url": "https://api.github.com/users/sinkuu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sinkuu/subscriptions", "organizations_url": "https://api.github.com/users/sinkuu/orgs", "repos_url": "https://api.github.com/users/sinkuu/repos", "events_url": "https://api.github.com/users/sinkuu/events{/privacy}", "received_events_url": "https://api.github.com/users/sinkuu/received_events", "type": "User", "site_admin": false}, "committer": {"login": "sinkuu", "id": 7091080, "node_id": "MDQ6VXNlcjcwOTEwODA=", "avatar_url": "https://avatars.githubusercontent.com/u/7091080?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sinkuu", "html_url": "https://github.com/sinkuu", "followers_url": "https://api.github.com/users/sinkuu/followers", "following_url": "https://api.github.com/users/sinkuu/following{/other_user}", "gists_url": "https://api.github.com/users/sinkuu/gists{/gist_id}", "starred_url": "https://api.github.com/users/sinkuu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sinkuu/subscriptions", "organizations_url": "https://api.github.com/users/sinkuu/orgs", "repos_url": "https://api.github.com/users/sinkuu/repos", "events_url": "https://api.github.com/users/sinkuu/events{/privacy}", "received_events_url": "https://api.github.com/users/sinkuu/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ce6e037ac5527c7dd2153a929f2ce8bda2c2bb1a", "url": "https://api.github.com/repos/rust-lang/rust/commits/ce6e037ac5527c7dd2153a929f2ce8bda2c2bb1a", "html_url": "https://github.com/rust-lang/rust/commit/ce6e037ac5527c7dd2153a929f2ce8bda2c2bb1a"}], "stats": {"total": 105, "additions": 49, "deletions": 56}, "files": [{"sha": "fc50e668c85d4ca8863afc12c74aaa1fdab91dc9", "filename": "clippy_lints/src/unused_io_amount.rs", "status": "modified", "additions": 4, "deletions": 54, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/a2bcce9dbfaddfa8fc26f4ab71747204bc2c6792/clippy_lints%2Fsrc%2Funused_io_amount.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2bcce9dbfaddfa8fc26f4ab71747204bc2c6792/clippy_lints%2Fsrc%2Funused_io_amount.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funused_io_amount.rs?ref=a2bcce9dbfaddfa8fc26f4ab71747204bc2c6792", "patch": "@@ -1,6 +1,6 @@\n use rustc::lint::*;\n use rustc::hir;\n-use utils::{span_lint, match_path, match_trait_method, paths};\n+use utils::{span_lint, match_path, match_trait_method, is_try, paths};\n \n /// **What it does:** Checks for unused written/read amount.\n ///\n@@ -42,20 +42,16 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedIoAmount {\n             _ => return,\n         };\n \n-        if let hir::ExprRet(..) = expr.node {\n-            return;\n-        }\n-\n         match expr.node {\n-            hir::ExprMatch(ref expr, ref arms, _) if is_try(arms) => {\n-                if let hir::ExprCall(ref func, ref args) = expr.node {\n+            hir::ExprMatch(ref res, _, _) if is_try(expr).is_some() => {\n+                if let hir::ExprCall(ref func, ref args) = res.node {\n                     if let hir::ExprPath(ref path) = func.node {\n                         if match_path(path, &paths::CARRIER_TRANSLATE) && args.len() == 1 {\n                             check_method_call(cx, &args[0], expr);\n                         }\n                     }\n                 } else {\n-                    check_method_call(cx, expr, expr);\n+                    check_method_call(cx, res, expr);\n                 }\n             },\n \n@@ -90,49 +86,3 @@ fn check_method_call(cx: &LateContext, call: &hir::Expr, expr: &hir::Expr) {\n         }\n     }\n }\n-\n-fn is_try(arms: &[hir::Arm]) -> bool {\n-    // `Ok(x) => x` or `Ok(_) => ...`\n-    fn is_ok(arm: &hir::Arm) -> bool {\n-        if let hir::PatKind::TupleStruct(ref path, ref pat, ref dotdot) = arm.pats[0].node {\n-            // cut off `core`\n-            if match_path(path, &paths::RESULT_OK[1..]) {\n-                if *dotdot == Some(0) {\n-                    return true;\n-                }\n-\n-                match pat[0].node {\n-                    hir::PatKind::Wild => {\n-                        return true;\n-                    },\n-                    hir::PatKind::Binding(_, defid, _, None) => {\n-                        if let hir::ExprPath(hir::QPath::Resolved(None, ref path)) = arm.body.node {\n-                            if path.def.def_id() == defid {\n-                                return true;\n-                            }\n-                        }\n-                    },\n-                    _ => (),\n-                }\n-            }\n-        }\n-\n-        false\n-    }\n-\n-    /// Detects `_ => ...` or `Err(x) => ...`\n-    fn is_err_or_wild(arm: &hir::Arm) -> bool {\n-        match arm.pats[0].node {\n-            hir::PatKind::Wild => true,\n-            hir::PatKind::TupleStruct(ref path, _, _) => match_path(path, &paths::RESULT_ERR[1..]),\n-            _ => false,\n-        }\n-    }\n-\n-    if arms.len() == 2 && arms[0].pats.len() == 1 && arms[0].guard.is_none() && arms[1].pats.len() == 1 &&\n-       arms[1].guard.is_none() {\n-        (is_ok(&arms[0]) && is_err_or_wild(&arms[1])) || (is_ok(&arms[1]) && is_err_or_wild(&arms[0]))\n-    } else {\n-        false\n-    }\n-}"}, {"sha": "866a35427624d50eaade33f05548b3f869510cb4", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/a2bcce9dbfaddfa8fc26f4ab71747204bc2c6792/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2bcce9dbfaddfa8fc26f4ab71747204bc2c6792/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=a2bcce9dbfaddfa8fc26f4ab71747204bc2c6792", "patch": "@@ -920,3 +920,47 @@ pub fn is_self_ty(slf: &Ty) -> bool {\n pub fn iter_input_pats<'tcx>(decl: &FnDecl, body: &'tcx Body) -> impl Iterator<Item = &'tcx Arg> {\n     (0..decl.inputs.len()).map(move |i| &body.arguments[i])\n }\n+\n+/// Check if a given expression is a match expression\n+/// expanded from `?` operator or `try` macro.\n+pub fn is_try(expr: &Expr) -> Option<&Expr> {\n+    fn is_ok(arm: &Arm) -> bool {\n+        if_let_chain! {[\n+            let PatKind::TupleStruct(ref path, ref pat, None) = arm.pats[0].node,\n+            match_path(path, &paths::RESULT_OK[1..]),\n+            let PatKind::Binding(_, defid, _, None) = pat[0].node,\n+            let ExprPath(QPath::Resolved(None, ref path)) = arm.body.node,\n+            path.def.def_id() == defid,\n+        ], {\n+            return true;\n+        }}\n+        false\n+    }\n+\n+    fn is_err(arm: &Arm) -> bool {\n+        if let PatKind::TupleStruct(ref path, _, _) = arm.pats[0].node {\n+            match_path(path, &paths::RESULT_ERR[1..])\n+        } else {\n+            false\n+        }\n+    }\n+\n+    if let ExprMatch(_, ref arms, ref source) = expr.node {\n+        // desugared from a `?` operator\n+        if let MatchSource::TryDesugar = *source {\n+            return Some(expr);\n+        }\n+\n+        if_let_chain! {[\n+            arms.len() == 2,\n+            arms[0].pats.len() == 1 && arms[0].guard.is_none(),\n+            arms[1].pats.len() == 1 && arms[1].guard.is_none(),\n+            (is_ok(&arms[0]) && is_err(&arms[1])) ||\n+                (is_ok(&arms[1]) && is_err(&arms[0])),\n+        ], {\n+            return Some(expr);\n+        }}\n+    }\n+\n+    None\n+}"}, {"sha": "2e63705c5107cb5028408f343a9254813ca9325a", "filename": "tests/compile-fail/unused_io_amount.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a2bcce9dbfaddfa8fc26f4ab71747204bc2c6792/tests%2Fcompile-fail%2Funused_io_amount.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2bcce9dbfaddfa8fc26f4ab71747204bc2c6792/tests%2Fcompile-fail%2Funused_io_amount.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Funused_io_amount.rs?ref=a2bcce9dbfaddfa8fc26f4ab71747204bc2c6792", "patch": "@@ -5,12 +5,11 @@\n \n use std::io;\n \n+// FIXME: compiletest doesn't understand errors from macro invocation span\n fn try_macro<T: io::Read + io::Write>(s: &mut T) -> io::Result<()> {\n     try!(s.write(b\"test\"));\n-    //~^ ERROR handle written amount returned\n     let mut buf = [0u8; 4];\n     try!(s.read(&mut buf));\n-    //~^ ERROR handle read amount returned\n     Ok(())\n }\n "}]}