{"sha": "4eb7a335c0f6f2dd7b94b92701f46b5ae2a0081b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRlYjdhMzM1YzBmNmYyZGQ3Yjk0YjkyNzAxZjQ2YjVhZTJhMDA4MWI=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "arielb1@mail.tau.ac.il", "date": "2017-03-08T18:53:56Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-03-08T18:53:56Z"}, "message": "Rollup merge of #40268 - Mark-Simulacrum:normalization-followup, r=arielb1\n\nFix normalization error\n\nFollows #40163. I don't know whether this is good, but seems logical.\n\n[This block of code](https://github.com/rust-lang/rust/blob/ba07bd5d23aced6d4baa5696213b11ca832c1a5d/src/librustc_typeck/check/mod.rs#L2110-L2138) doesn't contain a call to `normalize_associated_types_in`, while [this](https://github.com/rust-lang/rust/blob/master/src/librustc_typeck/check/mod.rs#L2027-L2028) block does, and is nearly identical.\n\nIdeally these two blocks should be unified into one, but since the change doesn't seem trivial and I'm unsure if this patch will be accepted it hasn't been done yet.\n\nr? @arielb1", "tree": {"sha": "fdc818ce89dd1f2d71f88ea404ca712af579e80d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fdc818ce89dd1f2d71f88ea404ca712af579e80d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4eb7a335c0f6f2dd7b94b92701f46b5ae2a0081b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4eb7a335c0f6f2dd7b94b92701f46b5ae2a0081b", "html_url": "https://github.com/rust-lang/rust/commit/4eb7a335c0f6f2dd7b94b92701f46b5ae2a0081b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4eb7a335c0f6f2dd7b94b92701f46b5ae2a0081b/comments", "author": null, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5694ac9e7bc9a6f7785743a48591dfd4e5cbfdab", "url": "https://api.github.com/repos/rust-lang/rust/commits/5694ac9e7bc9a6f7785743a48591dfd4e5cbfdab", "html_url": "https://github.com/rust-lang/rust/commit/5694ac9e7bc9a6f7785743a48591dfd4e5cbfdab"}, {"sha": "403ae37ce8f680e378dc77904a27453df0867b99", "url": "https://api.github.com/repos/rust-lang/rust/commits/403ae37ce8f680e378dc77904a27453df0867b99", "html_url": "https://github.com/rust-lang/rust/commit/403ae37ce8f680e378dc77904a27453df0867b99"}], "stats": {"total": 139, "additions": 54, "deletions": 85}, "files": [{"sha": "2b9ccf6d3e246c666e0eabf9c9d812638324313f", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 54, "deletions": 85, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/4eb7a335c0f6f2dd7b94b92701f46b5ae2a0081b/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4eb7a335c0f6f2dd7b94b92701f46b5ae2a0081b/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=4eb7a335c0f6f2dd7b94b92701f46b5ae2a0081b", "patch": "@@ -1935,10 +1935,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             // We must collect the defaults *before* we do any unification. Because we have\n             // directly attached defaults to the type variables any unification that occurs\n             // will erase defaults causing conflicting defaults to be completely ignored.\n-            let default_map: FxHashMap<_, _> =\n+            let default_map: FxHashMap<Ty<'tcx>, _> =\n                 unsolved_variables\n                     .iter()\n-                    .filter_map(|t| self.default(t).map(|d| (t, d)))\n+                    .filter_map(|t| self.default(t).map(|d| (*t, d)))\n                     .collect();\n \n             let mut unbound_tyvars = FxHashSet();\n@@ -2007,37 +2007,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             // we will rollback the inference context to its prior state so we can probe\n             // for conflicts and correctly report them.\n \n-\n             let _ = self.commit_if_ok(|_: &infer::CombinedSnapshot| {\n-                for ty in &unbound_tyvars {\n-                    if self.type_var_diverges(ty) {\n-                        self.demand_eqtype(syntax_pos::DUMMY_SP, *ty,\n-                                           self.tcx.mk_diverging_default());\n-                    } else {\n-                        match self.type_is_unconstrained_numeric(ty) {\n-                            UnconstrainedInt => {\n-                                self.demand_eqtype(syntax_pos::DUMMY_SP, *ty, self.tcx.types.i32)\n-                            },\n-                            UnconstrainedFloat => {\n-                                self.demand_eqtype(syntax_pos::DUMMY_SP, *ty, self.tcx.types.f64)\n-                            }\n-                            Neither => {\n-                                if let Some(default) = default_map.get(ty) {\n-                                    let default = default.clone();\n-                                    let default_ty = self.normalize_associated_types_in(\n-                                        default.origin_span, &default.ty);\n-                                    match self.eq_types(false,\n-                                                        &self.misc(default.origin_span),\n-                                                        ty,\n-                                                        default_ty) {\n-                                        Ok(ok) => self.register_infer_ok_obligations(ok),\n-                                        Err(_) => conflicts.push((*ty, default)),\n-                                    }\n-                                }\n-                            }\n-                        }\n-                    }\n-                }\n+                conflicts.extend(\n+                    self.apply_defaults_and_return_conflicts(&unbound_tyvars, &default_map, None)\n+                );\n \n                 // If there are conflicts we rollback, otherwise commit\n                 if conflicts.len() > 0 {\n@@ -2047,37 +2020,41 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 }\n             });\n \n-            if conflicts.len() > 0 {\n-                // Loop through each conflicting default, figuring out the default that caused\n-                // a unification failure and then report an error for each.\n-                for (conflict, default) in conflicts {\n-                    let conflicting_default =\n-                        self.find_conflicting_default(&unbound_tyvars, &default_map, conflict)\n-                            .unwrap_or(type_variable::Default {\n-                                ty: self.next_ty_var(\n-                                    TypeVariableOrigin::MiscVariable(syntax_pos::DUMMY_SP)),\n-                                origin_span: syntax_pos::DUMMY_SP,\n-                                // what do I put here?\n-                                def_id: self.tcx.hir.local_def_id(ast::CRATE_NODE_ID)\n-                            });\n-\n-                    // This is to ensure that we elimnate any non-determinism from the error\n-                    // reporting by fixing an order, it doesn't matter what order we choose\n-                    // just that it is consistent.\n-                    let (first_default, second_default) =\n-                        if default.def_id < conflicting_default.def_id {\n-                            (default, conflicting_default)\n-                        } else {\n-                            (conflicting_default, default)\n-                        };\n+            // Loop through each conflicting default, figuring out the default that caused\n+            // a unification failure and then report an error for each.\n+            for (conflict, default) in conflicts {\n+                let conflicting_default =\n+                    self.apply_defaults_and_return_conflicts(\n+                            &unbound_tyvars,\n+                            &default_map,\n+                            Some(conflict)\n+                        )\n+                        .last()\n+                        .map(|(_, tv)| tv)\n+                        .unwrap_or(type_variable::Default {\n+                            ty: self.next_ty_var(\n+                                TypeVariableOrigin::MiscVariable(syntax_pos::DUMMY_SP)),\n+                            origin_span: syntax_pos::DUMMY_SP,\n+                            // what do I put here?\n+                            def_id: self.tcx.hir.local_def_id(ast::CRATE_NODE_ID)\n+                        });\n+\n+                // This is to ensure that we elimnate any non-determinism from the error\n+                // reporting by fixing an order, it doesn't matter what order we choose\n+                // just that it is consistent.\n+                let (first_default, second_default) =\n+                    if default.def_id < conflicting_default.def_id {\n+                        (default, conflicting_default)\n+                    } else {\n+                        (conflicting_default, default)\n+                    };\n \n \n-                    self.report_conflicting_default_types(\n-                        first_default.origin_span,\n-                        self.body_id,\n-                        first_default,\n-                        second_default)\n-                }\n+                self.report_conflicting_default_types(\n+                    first_default.origin_span,\n+                    self.body_id,\n+                    first_default,\n+                    second_default)\n             }\n         }\n \n@@ -2088,56 +2065,48 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     // apply the default that caused conflict first to a local version of the type variable\n     // table then apply defaults until we find a conflict. That default must be the one\n     // that caused conflict earlier.\n-    fn find_conflicting_default(&self,\n-                                unbound_vars: &FxHashSet<Ty<'tcx>>,\n-                                default_map: &FxHashMap<&Ty<'tcx>, type_variable::Default<'tcx>>,\n-                                conflict: Ty<'tcx>)\n-                                -> Option<type_variable::Default<'tcx>> {\n+    fn apply_defaults_and_return_conflicts<'b>(\n+        &'b self,\n+        unbound_vars: &'b FxHashSet<Ty<'tcx>>,\n+        default_map: &'b FxHashMap<Ty<'tcx>, type_variable::Default<'tcx>>,\n+        conflict: Option<Ty<'tcx>>,\n+    ) -> impl Iterator<Item=(Ty<'tcx>, type_variable::Default<'tcx>)> + 'b {\n         use rustc::ty::error::UnconstrainedNumeric::Neither;\n         use rustc::ty::error::UnconstrainedNumeric::{UnconstrainedInt, UnconstrainedFloat};\n \n-        // Ensure that we apply the conflicting default first\n-        let mut unbound_tyvars = Vec::with_capacity(unbound_vars.len() + 1);\n-        unbound_tyvars.push(conflict);\n-        unbound_tyvars.extend(unbound_vars.iter());\n-\n-        let mut result = None;\n-        // We run the same code as above applying defaults in order, this time when\n-        // we find the conflict we just return it for error reporting above.\n-\n-        // We also run this inside snapshot that never commits so we can do error\n-        // reporting for more then one conflict.\n-        for ty in &unbound_tyvars {\n+        conflict.into_iter().chain(unbound_vars.iter().cloned()).flat_map(move |ty| {\n             if self.type_var_diverges(ty) {\n-                self.demand_eqtype(syntax_pos::DUMMY_SP, *ty,\n+                self.demand_eqtype(syntax_pos::DUMMY_SP, ty,\n                                    self.tcx.mk_diverging_default());\n             } else {\n                 match self.type_is_unconstrained_numeric(ty) {\n                     UnconstrainedInt => {\n-                        self.demand_eqtype(syntax_pos::DUMMY_SP, *ty, self.tcx.types.i32)\n+                        self.demand_eqtype(syntax_pos::DUMMY_SP, ty, self.tcx.types.i32)\n                     },\n                     UnconstrainedFloat => {\n-                        self.demand_eqtype(syntax_pos::DUMMY_SP, *ty, self.tcx.types.f64)\n+                        self.demand_eqtype(syntax_pos::DUMMY_SP, ty, self.tcx.types.f64)\n                     },\n                     Neither => {\n                         if let Some(default) = default_map.get(ty) {\n                             let default = default.clone();\n+                            let default_ty = self.normalize_associated_types_in(\n+                                default.origin_span, &default.ty);\n                             match self.eq_types(false,\n                                                 &self.misc(default.origin_span),\n                                                 ty,\n-                                                default.ty) {\n+                                                default_ty) {\n                                 Ok(ok) => self.register_infer_ok_obligations(ok),\n                                 Err(_) => {\n-                                    result = Some(default);\n+                                    return Some((ty, default));\n                                 }\n                             }\n                         }\n                     }\n                 }\n             }\n-        }\n \n-        return result;\n+            None\n+        })\n     }\n \n     fn select_all_obligations_or_error(&self) {"}]}