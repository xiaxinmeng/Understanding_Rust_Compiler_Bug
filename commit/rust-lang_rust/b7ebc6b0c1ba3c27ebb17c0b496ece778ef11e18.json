{"sha": "b7ebc6b0c1ba3c27ebb17c0b496ece778ef11e18", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI3ZWJjNmIwYzFiYTNjMjdlYmIxN2MwYjQ5NmVjZTc3OGVmMTFlMTg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-11-30T09:00:52Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-11-30T09:00:52Z"}, "message": "Auto merge of #76467 - jyn514:intra-link-self, r=Manishearth\n\nFix intra-doc links for `Self` on cross-crate items and primitives\n\n- Remove the difference between `parent_item` and `current_item`; these\n  should never have been different.\n- Remove `current_item` from `resolve` and `variant_field` so that\n  `Self` is only substituted in one place at the very start.\n- Resolve the current item as a `DefId`, not a `HirId`. This is what\n  actually fixed the bug.\n\nHacks:\n- `clean` uses `TypedefItem` when it _really_ should be\n  `AssociatedTypeItem`. I tried fixing this without success and hacked\n  around it instead (see comments)\n- This second-guesses the `to_string()` impl since it wants\n  fully-qualified paths. Possibly there's a better way to do this.", "tree": {"sha": "942c74c777f9ea954f387d1e7a9380390393d502", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/942c74c777f9ea954f387d1e7a9380390393d502"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b7ebc6b0c1ba3c27ebb17c0b496ece778ef11e18", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b7ebc6b0c1ba3c27ebb17c0b496ece778ef11e18", "html_url": "https://github.com/rust-lang/rust/commit/b7ebc6b0c1ba3c27ebb17c0b496ece778ef11e18", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b7ebc6b0c1ba3c27ebb17c0b496ece778ef11e18/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "28b86e0860f0593b85cda6c2c7b03ae8a582962f", "url": "https://api.github.com/repos/rust-lang/rust/commits/28b86e0860f0593b85cda6c2c7b03ae8a582962f", "html_url": "https://github.com/rust-lang/rust/commit/28b86e0860f0593b85cda6c2c7b03ae8a582962f"}, {"sha": "2b17f025610077b2b45bdb6401756e404e6c34b2", "url": "https://api.github.com/repos/rust-lang/rust/commits/2b17f025610077b2b45bdb6401756e404e6c34b2", "html_url": "https://github.com/rust-lang/rust/commit/2b17f025610077b2b45bdb6401756e404e6c34b2"}], "stats": {"total": 228, "additions": 105, "deletions": 123}, "files": [{"sha": "3dcc0f240a3f8b29ce4baa0474658c65bbbe0e01", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 56, "deletions": 123, "changes": 179, "blob_url": "https://github.com/rust-lang/rust/blob/b7ebc6b0c1ba3c27ebb17c0b496ece778ef11e18/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7ebc6b0c1ba3c27ebb17c0b496ece778ef11e18/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=b7ebc6b0c1ba3c27ebb17c0b496ece778ef11e18", "patch": "@@ -31,7 +31,7 @@ use std::cell::Cell;\n use std::mem;\n use std::ops::Range;\n \n-use crate::clean::{self, Crate, GetDefId, Import, Item, ItemLink, PrimitiveType};\n+use crate::clean::{self, Crate, GetDefId, Item, ItemLink, PrimitiveType};\n use crate::core::DocContext;\n use crate::fold::DocFolder;\n use crate::html::markdown::markdown_links;\n@@ -195,7 +195,6 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n     fn variant_field(\n         &self,\n         path_str: &'path str,\n-        current_item: &Option<String>,\n         module_id: DefId,\n     ) -> Result<(Res, Option<String>), ErrorKind<'path>> {\n         let cx = self.cx;\n@@ -218,14 +217,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n             split.next().map(|f| (f, Symbol::intern(f))).ok_or_else(no_res)?;\n         let path = split\n             .next()\n-            .map(|f| {\n-                if f == \"self\" || f == \"Self\" {\n-                    if let Some(name) = current_item.as_ref() {\n-                        return name.clone();\n-                    }\n-                }\n-                f.to_owned()\n-            })\n+            .map(|f| f.to_owned())\n             // If there's no third component, we saw `[a::b]` before and it failed to resolve.\n             // So there's no partial res.\n             .ok_or_else(no_res)?;\n@@ -405,8 +397,6 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n         &self,\n         path_str: &'path str,\n         ns: Namespace,\n-        // FIXME(#76467): This is for `Self`, and it's wrong.\n-        current_item: &Option<String>,\n         module_id: DefId,\n         extra_fragment: &Option<String>,\n     ) -> Result<(Res, Option<String>), ErrorKind<'path>> {\n@@ -449,14 +439,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n         let (item_str, item_name) = split.next().map(|i| (i, Symbol::intern(i))).unwrap();\n         let path_root = split\n             .next()\n-            .map(|f| {\n-                if f == \"self\" || f == \"Self\" {\n-                    if let Some(name) = current_item.as_ref() {\n-                        return name.clone();\n-                    }\n-                }\n-                f.to_owned()\n-            })\n+            .map(|f| f.to_owned())\n             // If there's no `::`, it's not an associated item.\n             // So we can be sure that `rustc_resolve` was accurate when it said it wasn't resolved.\n             .ok_or_else(|| {\n@@ -477,7 +460,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n         } else {\n             // FIXME: this is duplicated on the end of this function.\n             return if ns == Namespace::ValueNS {\n-                self.variant_field(path_str, current_item, module_id)\n+                self.variant_field(path_str, module_id)\n             } else {\n                 Err(ResolutionFailure::NotResolved {\n                     module_id,\n@@ -617,7 +600,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n         };\n         res.unwrap_or_else(|| {\n             if ns == Namespace::ValueNS {\n-                self.variant_field(path_str, current_item, module_id)\n+                self.variant_field(path_str, module_id)\n             } else {\n                 Err(ResolutionFailure::NotResolved {\n                     module_id,\n@@ -640,15 +623,14 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n         ns: Namespace,\n         path_str: &str,\n         module_id: DefId,\n-        current_item: &Option<String>,\n         extra_fragment: &Option<String>,\n     ) -> Option<Res> {\n         // resolve() can't be used for macro namespace\n         let result = match ns {\n             Namespace::MacroNS => self.resolve_macro(path_str, module_id).map_err(ErrorKind::from),\n-            Namespace::TypeNS | Namespace::ValueNS => self\n-                .resolve(path_str, ns, current_item, module_id, extra_fragment)\n-                .map(|(res, _)| res),\n+            Namespace::TypeNS | Namespace::ValueNS => {\n+                self.resolve(path_str, ns, module_id, extra_fragment).map(|(res, _)| res)\n+            }\n         };\n \n         let res = match result {\n@@ -839,77 +821,49 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n             trace!(\"got parent node for {:?} {:?}, id {:?}\", item.type_(), item.name, item.def_id);\n         }\n \n-        let current_item = match item.kind {\n-            clean::ModuleItem(..) => {\n-                if item.attrs.inner_docs {\n-                    if item.def_id.is_top_level_module() { item.name.clone() } else { None }\n-                } else {\n-                    match parent_node.or(self.mod_ids.last().copied()) {\n-                        Some(parent) if !parent.is_top_level_module() => {\n-                            Some(self.cx.tcx.item_name(parent).to_string())\n-                        }\n-                        _ => None,\n-                    }\n-                }\n-            }\n-            clean::ImplItem(clean::Impl { ref for_, .. }) => {\n-                for_.def_id().map(|did| self.cx.tcx.item_name(did).to_string())\n-            }\n-            // we don't display docs on `extern crate` items anyway, so don't process them.\n-            clean::ExternCrateItem(..) => {\n-                debug!(\"ignoring extern crate item {:?}\", item.def_id);\n-                return Some(self.fold_item_recur(item));\n-            }\n-            clean::ImportItem(Import { kind: clean::ImportKind::Simple(ref name, ..), .. }) => {\n-                Some(name.clone())\n-            }\n-            clean::MacroItem(..) => None,\n-            _ => item.name.clone(),\n+        // find item's parent to resolve `Self` in item's docs below\n+        debug!(\"looking for the `Self` type\");\n+        let self_id = if item.is_fake() {\n+            None\n+        } else if matches!(\n+            self.cx.tcx.def_kind(item.def_id),\n+            DefKind::AssocConst\n+                | DefKind::AssocFn\n+                | DefKind::AssocTy\n+                | DefKind::Variant\n+                | DefKind::Field\n+        ) {\n+            self.cx.tcx.parent(item.def_id)\n+        // HACK(jynelson): `clean` marks associated types as `TypedefItem`, not as `AssocTypeItem`.\n+        // Fixing this breaks `fn render_deref_methods`.\n+        // As a workaround, see if the parent of the item is an `impl`; if so this must be an associated item,\n+        // regardless of what rustdoc wants to call it.\n+        } else if let Some(parent) = self.cx.tcx.parent(item.def_id) {\n+            let parent_kind = self.cx.tcx.def_kind(parent);\n+            Some(if parent_kind == DefKind::Impl { parent } else { item.def_id })\n+        } else {\n+            Some(item.def_id)\n         };\n \n+        // FIXME(jynelson): this shouldn't go through stringification, rustdoc should just use the DefId directly\n+        let self_name = self_id.and_then(|self_id| {\n+            if matches!(self.cx.tcx.def_kind(self_id), DefKind::Impl) {\n+                // using `ty.to_string()` directly has issues with shortening paths\n+                let ty = self.cx.tcx.type_of(self_id);\n+                let name = ty::print::with_crate_prefix(|| ty.to_string());\n+                debug!(\"using type_of(): {}\", name);\n+                Some(name)\n+            } else {\n+                let name = self.cx.tcx.opt_item_name(self_id).map(|sym| sym.to_string());\n+                debug!(\"using item_name(): {:?}\", name);\n+                name\n+            }\n+        });\n+\n         if item.is_mod() && item.attrs.inner_docs {\n             self.mod_ids.push(item.def_id);\n         }\n \n-        // find item's parent to resolve `Self` in item's docs below\n-        // FIXME(#76467, #75809): this is a mess and doesn't handle cross-crate\n-        // re-exports\n-        let parent_name = self.cx.as_local_hir_id(item.def_id).and_then(|item_hir| {\n-            let parent_hir = self.cx.tcx.hir().get_parent_item(item_hir);\n-            let item_parent = self.cx.tcx.hir().find(parent_hir);\n-            match item_parent {\n-                Some(hir::Node::Item(hir::Item {\n-                    kind:\n-                        hir::ItemKind::Impl {\n-                            self_ty:\n-                                hir::Ty {\n-                                    kind:\n-                                        hir::TyKind::Path(hir::QPath::Resolved(\n-                                            _,\n-                                            hir::Path { segments, .. },\n-                                        )),\n-                                    ..\n-                                },\n-                            ..\n-                        },\n-                    ..\n-                })) => segments.first().map(|seg| seg.ident.to_string()),\n-                Some(hir::Node::Item(hir::Item {\n-                    ident, kind: hir::ItemKind::Enum(..), ..\n-                }))\n-                | Some(hir::Node::Item(hir::Item {\n-                    ident, kind: hir::ItemKind::Struct(..), ..\n-                }))\n-                | Some(hir::Node::Item(hir::Item {\n-                    ident, kind: hir::ItemKind::Union(..), ..\n-                }))\n-                | Some(hir::Node::Item(hir::Item {\n-                    ident, kind: hir::ItemKind::Trait(..), ..\n-                })) => Some(ident.to_string()),\n-                _ => None,\n-            }\n-        });\n-\n         // We want to resolve in the lexical scope of the documentation.\n         // In the presence of re-exports, this is not the same as the module of the item.\n         // Rather than merging all documentation into one, resolve it one attribute at a time\n@@ -945,9 +899,8 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n                 let link = self.resolve_link(\n                     &item,\n                     &combined_docs,\n-                    &current_item,\n+                    &self_name,\n                     parent_node,\n-                    &parent_name,\n                     krate,\n                     ori_link,\n                     link_range,\n@@ -980,9 +933,8 @@ impl LinkCollector<'_, '_> {\n         &self,\n         item: &Item,\n         dox: &str,\n-        current_item: &Option<String>,\n+        self_name: &Option<String>,\n         parent_node: Option<DefId>,\n-        parent_name: &Option<String>,\n         krate: CrateNum,\n         ori_link: String,\n         link_range: Option<Range<usize>>,\n@@ -1069,7 +1021,7 @@ impl LinkCollector<'_, '_> {\n         let resolved_self;\n         // replace `Self` with suitable item's parent name\n         if path_str.starts_with(\"Self::\") {\n-            if let Some(ref name) = parent_name {\n+            if let Some(ref name) = self_name {\n                 resolved_self = format!(\"{}::{}\", name, &path_str[6..]);\n                 path_str = &resolved_self;\n             }\n@@ -1122,7 +1074,6 @@ impl LinkCollector<'_, '_> {\n             item,\n             dox,\n             path_str,\n-            current_item,\n             module_id,\n             extra_fragment,\n             &ori_link,\n@@ -1243,15 +1194,14 @@ impl LinkCollector<'_, '_> {\n         item: &Item,\n         dox: &str,\n         path_str: &str,\n-        current_item: &Option<String>,\n         base_node: DefId,\n         extra_fragment: Option<String>,\n         ori_link: &str,\n         link_range: Option<Range<usize>>,\n     ) -> Option<(Res, Option<String>)> {\n         match disambiguator.map(Disambiguator::ns) {\n             Some(ns @ (ValueNS | TypeNS)) => {\n-                match self.resolve(path_str, ns, &current_item, base_node, &extra_fragment) {\n+                match self.resolve(path_str, ns, base_node, &extra_fragment) {\n                     Ok(res) => Some(res),\n                     Err(ErrorKind::Resolve(box mut kind)) => {\n                         // We only looked in one namespace. Try to give a better error if possible.\n@@ -1264,7 +1214,6 @@ impl LinkCollector<'_, '_> {\n                                     new_ns,\n                                     path_str,\n                                     base_node,\n-                                    &current_item,\n                                     &extra_fragment,\n                                 ) {\n                                     kind = ResolutionFailure::WrongNamespace(res, ns);\n@@ -1298,13 +1247,7 @@ impl LinkCollector<'_, '_> {\n                     macro_ns: self\n                         .resolve_macro(path_str, base_node)\n                         .map(|res| (res, extra_fragment.clone())),\n-                    type_ns: match self.resolve(\n-                        path_str,\n-                        TypeNS,\n-                        &current_item,\n-                        base_node,\n-                        &extra_fragment,\n-                    ) {\n+                    type_ns: match self.resolve(path_str, TypeNS, base_node, &extra_fragment) {\n                         Ok(res) => {\n                             debug!(\"got res in TypeNS: {:?}\", res);\n                             Ok(res)\n@@ -1315,13 +1258,7 @@ impl LinkCollector<'_, '_> {\n                         }\n                         Err(ErrorKind::Resolve(box kind)) => Err(kind),\n                     },\n-                    value_ns: match self.resolve(\n-                        path_str,\n-                        ValueNS,\n-                        &current_item,\n-                        base_node,\n-                        &extra_fragment,\n-                    ) {\n+                    value_ns: match self.resolve(path_str, ValueNS, base_node, &extra_fragment) {\n                         Ok(res) => Ok(res),\n                         Err(ErrorKind::AnchorFailure(msg)) => {\n                             anchor_failure(self.cx, &item, ori_link, dox, link_range, msg);\n@@ -1389,13 +1326,9 @@ impl LinkCollector<'_, '_> {\n                     Err(mut kind) => {\n                         // `resolve_macro` only looks in the macro namespace. Try to give a better error if possible.\n                         for &ns in &[TypeNS, ValueNS] {\n-                            if let Some(res) = self.check_full_res(\n-                                ns,\n-                                path_str,\n-                                base_node,\n-                                &current_item,\n-                                &extra_fragment,\n-                            ) {\n+                            if let Some(res) =\n+                                self.check_full_res(ns, path_str, base_node, &extra_fragment)\n+                            {\n                                 kind = ResolutionFailure::WrongNamespace(res, MacroNS);\n                                 break;\n                             }\n@@ -1734,7 +1667,7 @@ fn resolution_failure(\n                         name = start;\n                         for &ns in &[TypeNS, ValueNS, MacroNS] {\n                             if let Some(res) =\n-                                collector.check_full_res(ns, &start, module_id, &None, &None)\n+                                collector.check_full_res(ns, &start, module_id, &None)\n                             {\n                                 debug!(\"found partial_res={:?}\", res);\n                                 *partial_res = Some(res);\n@@ -2131,7 +2064,7 @@ fn strip_generics_from_path(path_str: &str) -> Result<String, ResolutionFailure<\n             }\n             _ => segment.push(chr),\n         }\n-        debug!(\"raw segment: {:?}\", segment);\n+        trace!(\"raw segment: {:?}\", segment);\n     }\n \n     if !segment.is_empty() {"}, {"sha": "cdfe842f3ccbb7709641d63534ec22fa0fdaf325", "filename": "src/test/rustdoc/intra-doc-crate/auxiliary/self.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b7ebc6b0c1ba3c27ebb17c0b496ece778ef11e18/src%2Ftest%2Frustdoc%2Fintra-doc-crate%2Fauxiliary%2Fself.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7ebc6b0c1ba3c27ebb17c0b496ece778ef11e18/src%2Ftest%2Frustdoc%2Fintra-doc-crate%2Fauxiliary%2Fself.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fintra-doc-crate%2Fauxiliary%2Fself.rs?ref=b7ebc6b0c1ba3c27ebb17c0b496ece778ef11e18", "patch": "@@ -0,0 +1,7 @@\n+#![crate_name = \"cross_crate_self\"]\n+pub struct S;\n+\n+impl S {\n+    /// Link to [Self::f]\n+    pub fn f() {}\n+}"}, {"sha": "62aef8e85afc98a8df4973ba82d8b25bda6ccd27", "filename": "src/test/rustdoc/intra-doc-crate/self.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b7ebc6b0c1ba3c27ebb17c0b496ece778ef11e18/src%2Ftest%2Frustdoc%2Fintra-doc-crate%2Fself.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7ebc6b0c1ba3c27ebb17c0b496ece778ef11e18/src%2Ftest%2Frustdoc%2Fintra-doc-crate%2Fself.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fintra-doc-crate%2Fself.rs?ref=b7ebc6b0c1ba3c27ebb17c0b496ece778ef11e18", "patch": "@@ -0,0 +1,6 @@\n+// aux-build:self.rs\n+\n+extern crate cross_crate_self;\n+\n+// @has self/struct.S.html '//a[@href=\"../self/struct.S.html#method.f\"]' \"Self::f\"\n+pub use cross_crate_self::S;"}, {"sha": "1189d266c536e72edade4540b15896af7a79d1c8", "filename": "src/test/rustdoc/intra-link-prim-self.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/b7ebc6b0c1ba3c27ebb17c0b496ece778ef11e18/src%2Ftest%2Frustdoc%2Fintra-link-prim-self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7ebc6b0c1ba3c27ebb17c0b496ece778ef11e18/src%2Ftest%2Frustdoc%2Fintra-link-prim-self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fintra-link-prim-self.rs?ref=b7ebc6b0c1ba3c27ebb17c0b496ece778ef11e18", "patch": "@@ -0,0 +1,36 @@\n+// ignore-tidy-linelength\n+#![deny(broken_intra_doc_links)]\n+#![feature(lang_items)]\n+#![feature(no_core)]\n+#![no_core]\n+\n+#[lang = \"usize\"]\n+/// [Self::f]\n+/// [Self::MAX]\n+// @has intra_link_prim_self/primitive.usize.html\n+// @has - '//a[@href=\"https://doc.rust-lang.org/nightly/std/primitive.usize.html#method.f\"]' 'Self::f'\n+// @has - '//a[@href=\"https://doc.rust-lang.org/nightly/std/primitive.usize.html#associatedconstant.MAX\"]' 'Self::MAX'\n+impl usize {\n+    /// Some docs\n+    pub fn f() {}\n+\n+    /// 10 and 2^32 are basically the same.\n+    pub const MAX: usize = 10;\n+\n+    // FIXME(#8995) uncomment this when associated types in inherent impls are supported\n+    // @ has - '//a[@href=\"https://doc.rust-lang.org/nightly/std/primitive.usize.html#associatedtype.ME\"]' 'Self::ME'\n+    // / [Self::ME]\n+    //pub type ME = usize;\n+}\n+\n+#[doc(primitive = \"usize\")]\n+/// This has some docs.\n+mod usize {}\n+\n+/// [S::f]\n+/// [Self::f]\n+pub struct S;\n+\n+impl S {\n+    pub fn f() {}\n+}"}]}