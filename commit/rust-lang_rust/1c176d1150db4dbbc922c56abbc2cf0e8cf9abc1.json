{"sha": "1c176d1150db4dbbc922c56abbc2cf0e8cf9abc1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFjMTc2ZDExNTBkYjRkYmJjOTIyYzU2YWJiYzJjZjBlOGNmOWFiYzE=", "commit": {"author": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2020-12-19T07:11:00Z"}, "committer": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2020-12-22T15:20:23Z"}, "message": "Simplify field filtering", "tree": {"sha": "ca94cf67ddc6b42b15952cb0f3eb0c4c6b334ee0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ca94cf67ddc6b42b15952cb0f3eb0c4c6b334ee0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1c176d1150db4dbbc922c56abbc2cf0e8cf9abc1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1c176d1150db4dbbc922c56abbc2cf0e8cf9abc1", "html_url": "https://github.com/rust-lang/rust/commit/1c176d1150db4dbbc922c56abbc2cf0e8cf9abc1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1c176d1150db4dbbc922c56abbc2cf0e8cf9abc1/comments", "author": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "53e03fb7c10f39229241fedc001a2c28ffb569e6", "url": "https://api.github.com/repos/rust-lang/rust/commits/53e03fb7c10f39229241fedc001a2c28ffb569e6", "html_url": "https://github.com/rust-lang/rust/commit/53e03fb7c10f39229241fedc001a2c28ffb569e6"}], "stats": {"total": 120, "additions": 56, "deletions": 64}, "files": [{"sha": "357735d6c16ca3b08f92928ee300279ac945f995", "filename": "compiler/rustc_mir_build/src/thir/pattern/deconstruct_pat.rs", "status": "modified", "additions": 55, "deletions": 63, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/1c176d1150db4dbbc922c56abbc2cf0e8cf9abc1/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c176d1150db4dbbc922c56abbc2cf0e8cf9abc1/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs?ref=1c176d1150db4dbbc922c56abbc2cf0e8cf9abc1", "patch": "@@ -1058,41 +1058,30 @@ impl<'tcx> SplitWildcard<'tcx> {\n }\n \n /// Some fields need to be explicitly hidden away in certain cases; see the comment above the\n-/// `Fields` struct. This struct represents such a potentially-hidden field. When a field is hidden\n-/// we still keep its type around.\n+/// `Fields` struct. This struct represents such a potentially-hidden field.\n #[derive(Debug, Copy, Clone)]\n pub(super) enum FilteredField<'p, 'tcx> {\n     Kept(&'p Pat<'tcx>),\n-    Hidden(Ty<'tcx>),\n+    Hidden,\n }\n \n impl<'p, 'tcx> FilteredField<'p, 'tcx> {\n     fn kept(self) -> Option<&'p Pat<'tcx>> {\n         match self {\n             FilteredField::Kept(p) => Some(p),\n-            FilteredField::Hidden(_) => None,\n-        }\n-    }\n-\n-    fn to_pattern(self) -> Pat<'tcx> {\n-        match self {\n-            FilteredField::Kept(p) => p.clone(),\n-            FilteredField::Hidden(ty) => Pat::wildcard_from_ty(ty),\n+            FilteredField::Hidden => None,\n         }\n     }\n }\n \n /// A value can be decomposed into a constructor applied to some fields. This struct represents\n /// those fields, generalized to allow patterns in each field. See also `Constructor`.\n+/// This is constructed from a constructor using [`Fields::wildcards()`].\n ///\n /// If a private or `non_exhaustive` field is uninhabited, the code mustn't observe that it is\n-/// uninhabited. For that, we filter these fields out of the matrix. This is subtle because we\n-/// still need to have those fields back when going to/from a `Pat`. Most of this is handled\n-/// automatically in `Fields`, but when constructing or deconstructing `Fields` you need to be\n-/// careful. As a rule, when going to/from the matrix, use the filtered field list; when going\n-/// to/from `Pat`, use the full field list.\n-/// This filtering is uncommon in practice, because uninhabited fields are rarely used, so we avoid\n-/// it when possible to preserve performance.\n+/// uninhabited. For that, we filter these fields out of the matrix. This is handled automatically\n+/// in `Fields`. This filtering is uncommon in practice, because uninhabited fields are rare used,\n+/// so we avoid it when possible to preserve performance.\n #[derive(Debug, Clone)]\n pub(super) enum Fields<'p, 'tcx> {\n     /// Lists of patterns that don't contain any filtered fields.\n@@ -1101,21 +1090,19 @@ pub(super) enum Fields<'p, 'tcx> {\n     /// have not measured if it really made a difference.\n     Slice(&'p [Pat<'tcx>]),\n     Vec(SmallVec<[&'p Pat<'tcx>; 2]>),\n-    /// Patterns where some of the fields need to be hidden. `kept_count` caches the number of\n-    /// non-hidden fields.\n+    /// Patterns where some of the fields need to be hidden. For all intents and purposes we only\n+    /// care about the non-hidden fields. We need to keep the real field index for those fields;\n+    /// we're morally storing a `Vec<(usize, &Pat)>` but what we do is more convenient.\n+    /// `len` counts the number of non-hidden fields\n     Filtered {\n         fields: SmallVec<[FilteredField<'p, 'tcx>; 2]>,\n-        kept_count: usize,\n+        len: usize,\n     },\n }\n \n impl<'p, 'tcx> Fields<'p, 'tcx> {\n-    fn empty() -> Self {\n-        Fields::Slice(&[])\n-    }\n-\n-    /// Construct a new `Fields` from the given pattern. Must not be used if the pattern is a field\n-    /// of a struct/tuple/variant.\n+    /// Internal use. Use `Fields::wildcards()` instead.\n+    /// Must not be used if the pattern is a field of a struct/tuple/variant.\n     fn from_single_pattern(pat: &'p Pat<'tcx>) -> Self {\n         Fields::Slice(std::slice::from_ref(pat))\n     }\n@@ -1160,7 +1147,7 @@ impl<'p, 'tcx> Fields<'p, 'tcx> {\n                         if has_no_hidden_fields {\n                             Fields::wildcards_from_tys(cx, field_tys)\n                         } else {\n-                            let mut kept_count = 0;\n+                            let mut len = 0;\n                             let fields = variant\n                                 .fields\n                                 .iter()\n@@ -1175,14 +1162,14 @@ impl<'p, 'tcx> Fields<'p, 'tcx> {\n                                     // order not to reveal the uninhabitedness of the whole\n                                     // variant.\n                                     if is_uninhabited && (!is_visible || is_non_exhaustive) {\n-                                        FilteredField::Hidden(ty)\n+                                        FilteredField::Hidden\n                                     } else {\n-                                        kept_count += 1;\n+                                        len += 1;\n                                         FilteredField::Kept(wildcard_from_ty(ty))\n                                     }\n                                 })\n                                 .collect();\n-                            Fields::Filtered { fields, kept_count }\n+                            Fields::Filtered { fields, len }\n                         }\n                     }\n                 }\n@@ -1196,7 +1183,7 @@ impl<'p, 'tcx> Fields<'p, 'tcx> {\n                 _ => bug!(\"bad slice pattern {:?} {:?}\", constructor, ty),\n             },\n             Str(..) | FloatRange(..) | IntRange(..) | NonExhaustive | Opaque | Missing\n-            | Wildcard => Fields::empty(),\n+            | Wildcard => Fields::Slice(&[]),\n         };\n         debug!(\"Fields::wildcards({:?}, {:?}) = {:#?}\", constructor, ty, ret);\n         ret\n@@ -1218,14 +1205,16 @@ impl<'p, 'tcx> Fields<'p, 'tcx> {\n     /// `self`: `[false]`\n     /// returns `Some(false)`\n     pub(super) fn apply(self, pcx: PatCtxt<'_, 'p, 'tcx>, ctor: &Constructor<'tcx>) -> Pat<'tcx> {\n-        let mut subpatterns = self.all_patterns();\n+        let subpatterns_and_indices = self.patterns_and_indices();\n+        let mut subpatterns = subpatterns_and_indices.iter().map(|&(_, p)| p).cloned();\n \n         let pat = match ctor {\n             Single | Variant(_) => match pcx.ty.kind() {\n                 ty::Adt(..) | ty::Tuple(..) => {\n-                    let subpatterns = subpatterns\n-                        .enumerate()\n-                        .map(|(i, p)| FieldPat { field: Field::new(i), pattern: p })\n+                    // We want the real indices here.\n+                    let subpatterns = subpatterns_and_indices\n+                        .iter()\n+                        .map(|&(field, p)| FieldPat { field, pattern: p.clone() })\n                         .collect();\n \n                     if let ty::Adt(adt, substs) = pcx.ty.kind() {\n@@ -1290,39 +1279,42 @@ impl<'p, 'tcx> Fields<'p, 'tcx> {\n         Pat { ty: pcx.ty, span: DUMMY_SP, kind: Box::new(pat) }\n     }\n \n-    /// Returns the number of patterns from the viewpoint of match-checking, i.e. excluding hidden\n-    /// fields. This is what we want in most cases in this file, the only exception being\n-    /// conversion to/from `Pat`.\n+    /// Returns the number of patterns. This is the same as the arity of the constructor used to\n+    /// construct `self`.\n     pub(super) fn len(&self) -> usize {\n         match self {\n             Fields::Slice(pats) => pats.len(),\n             Fields::Vec(pats) => pats.len(),\n-            Fields::Filtered { kept_count, .. } => *kept_count,\n+            Fields::Filtered { len, .. } => *len,\n         }\n     }\n \n-    /// Returns the complete list of patterns, including hidden fields.\n-    fn all_patterns(self) -> impl Iterator<Item = Pat<'tcx>> {\n-        let pats: SmallVec<[_; 2]> = match self {\n-            Fields::Slice(pats) => pats.iter().cloned().collect(),\n-            Fields::Vec(pats) => pats.into_iter().cloned().collect(),\n+    /// Returns the list of patterns along with the corresponding field indices.\n+    fn patterns_and_indices(&self) -> SmallVec<[(Field, &'p Pat<'tcx>); 2]> {\n+        match self {\n+            Fields::Slice(pats) => {\n+                pats.iter().enumerate().map(|(i, p)| (Field::new(i), p)).collect()\n+            }\n+            Fields::Vec(pats) => {\n+                pats.iter().copied().enumerate().map(|(i, p)| (Field::new(i), p)).collect()\n+            }\n             Fields::Filtered { fields, .. } => {\n-                // We don't skip any fields here.\n-                fields.into_iter().map(|p| p.to_pattern()).collect()\n+                // Indices must be relative to the full list of patterns\n+                fields\n+                    .iter()\n+                    .enumerate()\n+                    .filter_map(|(i, p)| Some((Field::new(i), p.kept()?)))\n+                    .collect()\n             }\n-        };\n-        pats.into_iter()\n+        }\n     }\n \n-    /// Returns the filtered list of patterns, not including hidden fields.\n-    pub(super) fn filtered_patterns(self) -> SmallVec<[&'p Pat<'tcx>; 2]> {\n+    /// Returns the list of patterns.\n+    pub(super) fn into_patterns(self) -> SmallVec<[&'p Pat<'tcx>; 2]> {\n         match self {\n             Fields::Slice(pats) => pats.iter().collect(),\n             Fields::Vec(pats) => pats,\n-            Fields::Filtered { fields, .. } => {\n-                // We skip hidden fields here\n-                fields.into_iter().filter_map(|p| p.kept()).collect()\n-            }\n+            Fields::Filtered { fields, .. } => fields.iter().filter_map(|p| p.kept()).collect(),\n         }\n     }\n \n@@ -1338,10 +1330,10 @@ impl<'p, 'tcx> Fields<'p, 'tcx> {\n     }\n \n     /// Overrides some of the fields with the provided patterns. This is used when a pattern\n-    /// defines some fields but not all, for example `Foo { field1: Some(_), .. }`: here we start with a\n-    /// `Fields` that is just one wildcard per field of the `Foo` struct, and override the entry\n-    /// corresponding to `field1` with the pattern `Some(_)`. This is also used for slice patterns\n-    /// for the same reason.\n+    /// defines some fields but not all, for example `Foo { field1: Some(_), .. }`: here we start\n+    /// with a `Fields` that is just one wildcard per field of the `Foo` struct, and override the\n+    /// entry corresponding to `field1` with the pattern `Some(_)`. This is also used for slice\n+    /// patterns for the same reason.\n     fn replace_fields_indexed(\n         &self,\n         new_pats: impl IntoIterator<Item = (usize, &'p Pat<'tcx>)>,\n@@ -1369,8 +1361,8 @@ impl<'p, 'tcx> Fields<'p, 'tcx> {\n         fields\n     }\n \n-    /// Replaces contained fields with the given filtered list of patterns, e.g. taken from the\n-    /// matrix. There must be `len()` patterns in `pats`.\n+    /// Replaces contained fields with the given list of patterns. There must be `len()` patterns\n+    /// in `pats`.\n     pub(super) fn replace_fields(\n         &self,\n         cx: &MatchCheckCtxt<'p, 'tcx>,\n@@ -1379,7 +1371,7 @@ impl<'p, 'tcx> Fields<'p, 'tcx> {\n         let pats: &[_] = cx.pattern_arena.alloc_from_iter(pats);\n \n         match self {\n-            Fields::Filtered { fields, kept_count } => {\n+            Fields::Filtered { fields, len } => {\n                 let mut pats = pats.iter();\n                 let mut fields = fields.clone();\n                 for f in &mut fields {\n@@ -1388,7 +1380,7 @@ impl<'p, 'tcx> Fields<'p, 'tcx> {\n                         *p = pats.next().unwrap();\n                     }\n                 }\n-                Fields::Filtered { fields, kept_count: *kept_count }\n+                Fields::Filtered { fields, len: *len }\n             }\n             _ => Fields::Slice(pats),\n         }"}, {"sha": "6c40abf3f20be495d966b10a91e926a423521eba", "filename": "compiler/rustc_mir_build/src/thir/pattern/usefulness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1c176d1150db4dbbc922c56abbc2cf0e8cf9abc1/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c176d1150db4dbbc922c56abbc2cf0e8cf9abc1/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs?ref=1c176d1150db4dbbc922c56abbc2cf0e8cf9abc1", "patch": "@@ -447,7 +447,7 @@ impl<'p, 'tcx> PatStack<'p, 'tcx> {\n         // We pop the head pattern and push the new fields extracted from the arguments of\n         // `self.head()`.\n         let mut new_fields =\n-            ctor_wild_subpatterns.replace_with_pattern_arguments(self.head()).filtered_patterns();\n+            ctor_wild_subpatterns.replace_with_pattern_arguments(self.head()).into_patterns();\n         new_fields.extend_from_slice(&self.pats[1..]);\n         PatStack::from_vec(new_fields)\n     }"}]}