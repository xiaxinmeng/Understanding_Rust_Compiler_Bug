{"sha": "6df7c041bc6bbc5218edb21145c8640799d0b4f1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZkZjdjMDQxYmM2YmJjNTIxOGVkYjIxMTQ1Yzg2NDA3OTlkMGI0ZjE=", "commit": {"author": {"name": "Lindsey Kuper", "email": "lkuper@mozilla.com", "date": "2011-08-04T01:31:56Z"}, "committer": {"name": "Lindsey Kuper", "email": "lkuper@mozilla.com", "date": "2011-08-04T02:50:19Z"}, "message": "Pointer-ifying llenv.  Step 1 of 2 steps to object system sanity.", "tree": {"sha": "a897d80907201c880f214cf57b61c073827d1386", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a897d80907201c880f214cf57b61c073827d1386"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6df7c041bc6bbc5218edb21145c8640799d0b4f1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6df7c041bc6bbc5218edb21145c8640799d0b4f1", "html_url": "https://github.com/rust-lang/rust/commit/6df7c041bc6bbc5218edb21145c8640799d0b4f1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6df7c041bc6bbc5218edb21145c8640799d0b4f1/comments", "author": {"login": "lkuper", "id": 535218, "node_id": "MDQ6VXNlcjUzNTIxOA==", "avatar_url": "https://avatars.githubusercontent.com/u/535218?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lkuper", "html_url": "https://github.com/lkuper", "followers_url": "https://api.github.com/users/lkuper/followers", "following_url": "https://api.github.com/users/lkuper/following{/other_user}", "gists_url": "https://api.github.com/users/lkuper/gists{/gist_id}", "starred_url": "https://api.github.com/users/lkuper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lkuper/subscriptions", "organizations_url": "https://api.github.com/users/lkuper/orgs", "repos_url": "https://api.github.com/users/lkuper/repos", "events_url": "https://api.github.com/users/lkuper/events{/privacy}", "received_events_url": "https://api.github.com/users/lkuper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lkuper", "id": 535218, "node_id": "MDQ6VXNlcjUzNTIxOA==", "avatar_url": "https://avatars.githubusercontent.com/u/535218?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lkuper", "html_url": "https://github.com/lkuper", "followers_url": "https://api.github.com/users/lkuper/followers", "following_url": "https://api.github.com/users/lkuper/following{/other_user}", "gists_url": "https://api.github.com/users/lkuper/gists{/gist_id}", "starred_url": "https://api.github.com/users/lkuper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lkuper/subscriptions", "organizations_url": "https://api.github.com/users/lkuper/orgs", "repos_url": "https://api.github.com/users/lkuper/repos", "events_url": "https://api.github.com/users/lkuper/events{/privacy}", "received_events_url": "https://api.github.com/users/lkuper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "29ec2503db2b0c1e1b438dcb190d82ae3dfc4bec", "url": "https://api.github.com/repos/rust-lang/rust/commits/29ec2503db2b0c1e1b438dcb190d82ae3dfc4bec", "html_url": "https://github.com/rust-lang/rust/commit/29ec2503db2b0c1e1b438dcb190d82ae3dfc4bec"}], "stats": {"total": 46, "additions": 8, "deletions": 38}, "files": [{"sha": "57324f7a2fd8dd7f8f8ea877dc17a3b0c44ca76c", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 8, "deletions": 38, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/6df7c041bc6bbc5218edb21145c8640799d0b4f1/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6df7c041bc6bbc5218edb21145c8640799d0b4f1/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=6df7c041bc6bbc5218edb21145c8640799d0b4f1", "patch": "@@ -122,7 +122,7 @@ fn type_of_fn_full(cx: &@crate_ctxt, sp: &span, proto: ast::proto,\n \n     // Arg 2: Env (closure-bindings / self-obj)\n     if is_method {\n-        atys += ~[cx.rust_object_type];\n+        atys += ~[T_ptr(cx.rust_object_type)];\n     } else { atys += ~[T_opaque_closure_ptr(*cx)]; }\n \n     // Args >3: ty params, if not acquired via capture...\n@@ -4273,6 +4273,7 @@ fn trans_lval_gen(cx: &@block_ctxt, e: &@ast::expr) -> lval_result {\n       ast::expr_self_method(ident) {\n         alt { cx.fcx.llself } {\n           some(pair) {\n+            // TODO: do we actually need cx.build.Load(pair.v)?\n             let r = pair.v;\n             let t = pair.t;\n             ret trans_field(cx, e.span, r, t, ident, e.id);\n@@ -4752,16 +4753,7 @@ fn trans_args(cx: &@block_ctxt, llenv: ValueRef, llobj: &option::t[ValueRef],\n     llargs += ~[bcx.fcx.lltaskptr];\n \n     // Arg 2: Env (closure-bindings / self-obj)\n-    alt llobj {\n-      some(ob) {\n-        // Every object is always found in memory,\n-        // and not-yet-loaded (as part of an lval x.y\n-        // doted method-call).\n-\n-        llargs += ~[bcx.build.Load(ob)];\n-      }\n-      _ { llargs += ~[llenv]; }\n-    }\n+    llargs += ~[llenv];\n \n     // Args >3: ty_params ...\n     llargs += lltydescs;\n@@ -4812,9 +4804,10 @@ fn trans_call(cx: &@block_ctxt, f: &@ast::expr,\n     let faddr = f_res.res.val;\n     let llenv = C_null(T_opaque_closure_ptr(*bcx_ccx(cx)));\n     alt f_res.llobj {\n-      some(_) {\n+      some(ob) {\n         // It's a vtbl entry.\n         faddr = bcx.build.Load(faddr);\n+        llenv = ob;\n       }\n       none. {\n         // It's a closure. We have to autoderef.\n@@ -6238,22 +6231,6 @@ fn create_llargs_for_fn_args(cx: &@fn_ctxt, proto: ast::proto,\n     }\n }\n \n-\n-// Recommended LLVM style, strange though this is, is to copy from args to\n-// allocas immediately upon entry; this permits us to GEP into structures we\n-// were passed and whatnot. Apparently mem2reg will mop up.\n-fn copy_any_self_to_alloca(fcx: @fn_ctxt) {\n-    let bcx = llstaticallocas_block_ctxt(fcx);\n-    alt { fcx.llself } {\n-      some(pair) {\n-        let a = alloca(bcx, fcx.lcx.ccx.rust_object_type);\n-        bcx.build.Store(pair.v, a);\n-        fcx.llself = some[val_self_pair]({v: a, t: pair.t});\n-      }\n-      _ { }\n-    }\n-}\n-\n fn copy_args_to_allocas(fcx: @fn_ctxt, args: &ast::arg[],\n                         arg_tys: &ty::arg[]) {\n     let bcx = new_raw_block_ctxt(fcx, fcx.llcopyargs);\n@@ -6384,7 +6361,6 @@ fn trans_closure(bcx_maybe: &option::t[@block_ctxt],\n     create_llargs_for_fn_args(fcx, f.proto, ty_self,\n                               ty::ret_ty_of_fn(cx.ccx.tcx, id), f.decl.inputs,\n                               ty_params);\n-    copy_any_self_to_alloca(fcx);\n     alt { fcx.llself } {\n       some(llself) { populate_fn_ctxt_from_llself(fcx, llself); }\n       _ { }\n@@ -6539,9 +6515,8 @@ fn process_fwding_mthd(cx: @local_ctxt, sp: &span, m: @ty::method,\n     let lltop = bcx.llbb;\n \n     // The outer object will arrive in the forwarding function via the llenv\n-    // argument.  Put it in an alloca so that we can GEP into it later.\n-    let llself_obj_ptr = alloca(bcx, fcx.lcx.ccx.rust_object_type);\n-    bcx.build.Store(fcx.llenv, llself_obj_ptr);\n+    // argument.\n+    let llself_obj_ptr = fcx.llenv;\n \n     // Do backwarding if necessary.\n     alt (backwarding_vtbl) {\n@@ -6566,11 +6541,6 @@ fn process_fwding_mthd(cx: @local_ctxt, sp: &span, m: @ty::method,\n       }\n     }\n \n-    // Grab hold of the outer object so we can pass it into the inner object,\n-    // in case that inner object needs to make any self-calls.  (Such calls\n-    // will need to dispatch back through the outer object.)\n-    let llself_obj = bcx.build.Load(llself_obj_ptr);\n-\n     // The 'llretptr' that will arrive in the forwarding function we're\n     // creating also needs to be the correct type.  Cast it to the method's\n     // return type, if necessary.\n@@ -6681,7 +6651,7 @@ fn process_fwding_mthd(cx: @local_ctxt, sp: &span, m: @ty::method,\n \n     // Set up the three implicit arguments to the original method we'll need\n     // to call.\n-    let self_arg = llself_obj;\n+    let self_arg = llself_obj_ptr;\n     let llorig_mthd_args: ValueRef[] = ~[llretptr, fcx.lltaskptr, self_arg];\n \n     // Copy the explicit arguments that are being passed into the forwarding"}]}