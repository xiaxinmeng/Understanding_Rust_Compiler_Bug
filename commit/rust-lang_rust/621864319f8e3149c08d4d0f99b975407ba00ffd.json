{"sha": "621864319f8e3149c08d4d0f99b975407ba00ffd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYyMTg2NDMxOWY4ZTMxNDljMDhkNGQwZjk5Yjk3NTQwN2JhMDBmZmQ=", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2019-05-04T13:42:00Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2019-05-04T16:18:30Z"}, "message": "Make canonicalization API a bit nicer", "tree": {"sha": "cbb6f7a9aa414ec0770556899559e746c740d2c9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cbb6f7a9aa414ec0770556899559e746c740d2c9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/621864319f8e3149c08d4d0f99b975407ba00ffd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/621864319f8e3149c08d4d0f99b975407ba00ffd", "html_url": "https://github.com/rust-lang/rust/commit/621864319f8e3149c08d4d0f99b975407ba00ffd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/621864319f8e3149c08d4d0f99b975407ba00ffd/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0bcf47b22b01f66c2f2056f5871e32071ba95b01", "url": "https://api.github.com/repos/rust-lang/rust/commits/0bcf47b22b01f66c2f2056f5871e32071ba95b01", "html_url": "https://github.com/rust-lang/rust/commit/0bcf47b22b01f66c2f2056f5871e32071ba95b01"}], "stats": {"total": 87, "additions": 56, "deletions": 31}, "files": [{"sha": "cc74c632215cb51e6716a66e9508cba6dc0e4ba5", "filename": "crates/ra_hir/src/ty/infer.rs", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/621864319f8e3149c08d4d0f99b975407ba00ffd/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/621864319f8e3149c08d4d0f99b975407ba00ffd/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs?ref=621864319f8e3149c08d4d0f99b975407ba00ffd", "patch": "@@ -324,23 +324,25 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n     fn resolve_obligations_as_possible(&mut self) {\n         let obligations = mem::replace(&mut self.obligations, Vec::new());\n         for obligation in obligations {\n-            let mut canonicalizer = self.canonicalizer();\n-            let solution = match &obligation {\n+            let (solution, canonicalized) = match &obligation {\n                 Obligation::Trait(tr) => {\n-                    let canonical = canonicalizer.canonicalize_trait_ref(tr.clone());\n-                    super::traits::implements(\n-                        canonicalizer.ctx.db,\n-                        canonicalizer.ctx.resolver.krate().unwrap(),\n-                        canonical,\n+                    let canonicalized = self.canonicalizer().canonicalize_trait_ref(tr.clone());\n+                    (\n+                        super::traits::implements(\n+                            self.db,\n+                            self.resolver.krate().unwrap(),\n+                            canonicalized.value.clone(),\n+                        ),\n+                        canonicalized,\n                     )\n                 }\n             };\n             match solution {\n                 Some(Solution::Unique(substs)) => {\n-                    canonicalizer.apply_solution(substs.0);\n+                    canonicalized.apply_solution(self, substs.0);\n                 }\n                 Some(Solution::Ambig(Guidance::Definite(substs))) => {\n-                    canonicalizer.apply_solution(substs.0);\n+                    canonicalized.apply_solution(self, substs.0);\n                     self.obligations.push(obligation);\n                 }\n                 Some(_) => {\n@@ -877,17 +879,16 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         generic_args: Option<&GenericArgs>,\n     ) -> Ty {\n         let receiver_ty = self.infer_expr(receiver, &Expectation::none());\n-        let mut canonicalizer = self.canonicalizer();\n-        let canonical_receiver = canonicalizer.canonicalize_ty(receiver_ty.clone());\n+        let canonicalized_receiver = self.canonicalizer().canonicalize_ty(receiver_ty.clone());\n         let resolved = method_resolution::lookup_method(\n-            &canonical_receiver,\n-            canonicalizer.ctx.db,\n+            &canonicalized_receiver.value,\n+            self.db,\n             method_name,\n-            &canonicalizer.ctx.resolver,\n+            &self.resolver,\n         );\n         let (derefed_receiver_ty, method_ty, def_generics) = match resolved {\n             Some((ty, func)) => {\n-                let ty = canonicalizer.decanonicalize_ty(ty);\n+                let ty = canonicalized_receiver.decanonicalize_ty(ty);\n                 self.write_method_resolution(tgt_expr, func);\n                 (\n                     ty,"}, {"sha": "c9c8959c4a820450827e7e43b865259ff66e7376", "filename": "crates/ra_hir/src/ty/infer/unify.rs", "status": "modified", "additions": 40, "deletions": 16, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/621864319f8e3149c08d4d0f99b975407ba00ffd/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/621864319f8e3149c08d4d0f99b975407ba00ffd/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Funify.rs?ref=621864319f8e3149c08d4d0f99b975407ba00ffd", "patch": "@@ -13,14 +13,17 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n     }\n }\n \n-// TODO improve the interface of this\n-\n pub(super) struct Canonicalizer<'a, 'b, D: HirDatabase>\n where\n     'a: 'b,\n {\n-    pub ctx: &'b mut InferenceContext<'a, D>,\n-    pub free_vars: Vec<InferTy>,\n+    ctx: &'b mut InferenceContext<'a, D>,\n+    free_vars: Vec<InferTy>,\n+}\n+\n+pub(super) struct Canonicalized<T> {\n+    pub value: Canonical<T>,\n+    free_vars: Vec<InferTy>,\n }\n \n impl<'a, 'b, D: HirDatabase> Canonicalizer<'a, 'b, D>\n@@ -35,34 +38,51 @@ where\n         })\n     }\n \n-    pub fn canonicalize_ty(&mut self, ty: Ty) -> Canonical<Ty> {\n-        let value = ty.fold(&mut |ty| match ty {\n+    fn do_canonicalize_ty(&mut self, ty: Ty) -> Ty {\n+        ty.fold(&mut |ty| match ty {\n             Ty::Infer(tv) => {\n                 let inner = tv.to_inner();\n                 // TODO prevent infinite loops? => keep var stack\n                 if let Some(known_ty) = self.ctx.var_unification_table.probe_value(inner).known() {\n-                    self.canonicalize_ty(known_ty.clone()).value\n+                    self.do_canonicalize_ty(known_ty.clone())\n                 } else {\n                     let free_var = InferTy::TypeVar(self.ctx.var_unification_table.find(inner));\n                     let position = self.add(free_var);\n                     Ty::Bound(position as u32)\n                 }\n             }\n             _ => ty,\n-        });\n-        Canonical { value, num_vars: self.free_vars.len() }\n+        })\n     }\n \n-    pub fn canonicalize_trait_ref(&mut self, trait_ref: TraitRef) -> Canonical<TraitRef> {\n+    fn do_canonicalize_trait_ref(&mut self, trait_ref: TraitRef) -> TraitRef {\n         let substs = trait_ref\n             .substs\n             .iter()\n-            .map(|ty| self.canonicalize_ty(ty.clone()).value)\n+            .map(|ty| self.do_canonicalize_ty(ty.clone()))\n             .collect::<Vec<_>>();\n-        let value = TraitRef { trait_: trait_ref.trait_, substs: substs.into() };\n-        Canonical { value, num_vars: self.free_vars.len() }\n+        TraitRef { trait_: trait_ref.trait_, substs: substs.into() }\n     }\n \n+    fn into_canonicalized<T>(self, result: T) -> Canonicalized<T> {\n+        Canonicalized {\n+            value: Canonical { value: result, num_vars: self.free_vars.len() },\n+            free_vars: self.free_vars,\n+        }\n+    }\n+\n+    pub fn canonicalize_ty(mut self, ty: Ty) -> Canonicalized<Ty> {\n+        let result = self.do_canonicalize_ty(ty);\n+        self.into_canonicalized(result)\n+    }\n+\n+    pub fn canonicalize_trait_ref(mut self, trait_ref: TraitRef) -> Canonicalized<TraitRef> {\n+        let result = self.do_canonicalize_trait_ref(trait_ref);\n+        self.into_canonicalized(result)\n+    }\n+}\n+\n+impl<T> Canonicalized<T> {\n     pub fn decanonicalize_ty(&self, ty: Ty) -> Ty {\n         ty.fold(&mut |ty| match ty {\n             Ty::Bound(idx) => {\n@@ -76,13 +96,17 @@ where\n         })\n     }\n \n-    pub fn apply_solution(&mut self, solution: Canonical<Vec<Ty>>) {\n+    pub fn apply_solution(\n+        &self,\n+        ctx: &mut InferenceContext<'_, impl HirDatabase>,\n+        solution: Canonical<Vec<Ty>>,\n+    ) {\n         // the solution may contain new variables, which we need to convert to new inference vars\n         let new_vars =\n-            (0..solution.num_vars).map(|_| self.ctx.new_type_var()).collect::<Vec<_>>().into();\n+            (0..solution.num_vars).map(|_| ctx.new_type_var()).collect::<Vec<_>>().into();\n         for (i, ty) in solution.value.into_iter().enumerate() {\n             let var = self.free_vars[i].clone();\n-            self.ctx.unify(&Ty::Infer(var), &ty.subst_bound_vars(&new_vars));\n+            ctx.unify(&Ty::Infer(var), &ty.subst_bound_vars(&new_vars));\n         }\n     }\n }"}]}