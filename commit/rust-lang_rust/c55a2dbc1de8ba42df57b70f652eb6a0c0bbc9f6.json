{"sha": "c55a2dbc1de8ba42df57b70f652eb6a0c0bbc9f6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM1NWEyZGJjMWRlOGJhNDJkZjU3YjcwZjY1MmViNmEwYzBiYmM5ZjY=", "commit": {"author": {"name": "Edwin Cheng", "email": "edwin0cheng@gmail.com", "date": "2019-04-25T15:12:57Z"}, "committer": {"name": "Edwin Cheng", "email": "edwin0cheng@gmail.com", "date": "2019-04-25T18:03:56Z"}, "message": "Fix more bugs", "tree": {"sha": "082cbca15c8af95ea0be73319a9ac00e45ba5cf1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/082cbca15c8af95ea0be73319a9ac00e45ba5cf1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c55a2dbc1de8ba42df57b70f652eb6a0c0bbc9f6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c55a2dbc1de8ba42df57b70f652eb6a0c0bbc9f6", "html_url": "https://github.com/rust-lang/rust/commit/c55a2dbc1de8ba42df57b70f652eb6a0c0bbc9f6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c55a2dbc1de8ba42df57b70f652eb6a0c0bbc9f6/comments", "author": {"login": "edwin0cheng", "id": 11014119, "node_id": "MDQ6VXNlcjExMDE0MTE5", "avatar_url": "https://avatars.githubusercontent.com/u/11014119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/edwin0cheng", "html_url": "https://github.com/edwin0cheng", "followers_url": "https://api.github.com/users/edwin0cheng/followers", "following_url": "https://api.github.com/users/edwin0cheng/following{/other_user}", "gists_url": "https://api.github.com/users/edwin0cheng/gists{/gist_id}", "starred_url": "https://api.github.com/users/edwin0cheng/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/edwin0cheng/subscriptions", "organizations_url": "https://api.github.com/users/edwin0cheng/orgs", "repos_url": "https://api.github.com/users/edwin0cheng/repos", "events_url": "https://api.github.com/users/edwin0cheng/events{/privacy}", "received_events_url": "https://api.github.com/users/edwin0cheng/received_events", "type": "User", "site_admin": false}, "committer": {"login": "edwin0cheng", "id": 11014119, "node_id": "MDQ6VXNlcjExMDE0MTE5", "avatar_url": "https://avatars.githubusercontent.com/u/11014119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/edwin0cheng", "html_url": "https://github.com/edwin0cheng", "followers_url": "https://api.github.com/users/edwin0cheng/followers", "following_url": "https://api.github.com/users/edwin0cheng/following{/other_user}", "gists_url": "https://api.github.com/users/edwin0cheng/gists{/gist_id}", "starred_url": "https://api.github.com/users/edwin0cheng/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/edwin0cheng/subscriptions", "organizations_url": "https://api.github.com/users/edwin0cheng/orgs", "repos_url": "https://api.github.com/users/edwin0cheng/repos", "events_url": "https://api.github.com/users/edwin0cheng/events{/privacy}", "received_events_url": "https://api.github.com/users/edwin0cheng/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "299d97b6d98cec673ff056c188ac45a17febc7d4", "url": "https://api.github.com/repos/rust-lang/rust/commits/299d97b6d98cec673ff056c188ac45a17febc7d4", "html_url": "https://github.com/rust-lang/rust/commit/299d97b6d98cec673ff056c188ac45a17febc7d4"}], "stats": {"total": 227, "additions": 203, "deletions": 24}, "files": [{"sha": "de6e9ec9ab50288b0a2b9350f447528cad7b98b5", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c55a2dbc1de8ba42df57b70f652eb6a0c0bbc9f6/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/c55a2dbc1de8ba42df57b70f652eb6a0c0bbc9f6/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=c55a2dbc1de8ba42df57b70f652eb6a0c0bbc9f6", "patch": "@@ -1059,6 +1059,7 @@ name = \"ra_mbe\"\n version = \"0.1.0\"\n dependencies = [\n  \"itertools 0.8.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"log 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"ra_parser 0.1.0\",\n  \"ra_syntax 0.1.0\",\n  \"ra_tt 0.1.0\","}, {"sha": "68f5592958f5e1339c1d082f567f255b9d738aea", "filename": "crates/ra_mbe/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c55a2dbc1de8ba42df57b70f652eb6a0c0bbc9f6/crates%2Fra_mbe%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/c55a2dbc1de8ba42df57b70f652eb6a0c0bbc9f6/crates%2Fra_mbe%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2FCargo.toml?ref=c55a2dbc1de8ba42df57b70f652eb6a0c0bbc9f6", "patch": "@@ -11,3 +11,4 @@ tt = { path = \"../ra_tt\", package = \"ra_tt\" }\n itertools = \"0.8.0\"\n rustc-hash = \"1.0.0\"\n smallvec = \"0.6.9\"\n+log = \"0.4.5\""}, {"sha": "7817232d629ddb3b7faa92e1e20258d7c33aba81", "filename": "crates/ra_mbe/src/lib.rs", "status": "modified", "additions": 110, "deletions": 2, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/c55a2dbc1de8ba42df57b70f652eb6a0c0bbc9f6/crates%2Fra_mbe%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c55a2dbc1de8ba42df57b70f652eb6a0c0bbc9f6/crates%2Fra_mbe%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Flib.rs?ref=c55a2dbc1de8ba42df57b70f652eb6a0c0bbc9f6", "patch": "@@ -436,6 +436,30 @@ impl_froms!(TokenTree: Leaf, Subtree);\n         assert_expansion(&rules, \"foo! (fn baz {true true} )\", \"fn baz () -> bool {true &&true}\");\n     }\n \n+    #[test]\n+    fn test_match_group_zero_match() {\n+        let rules = create_rules(\n+            r#\"\n+        macro_rules! foo {            \n+            ( $($i:ident)* ) => ();            \n+        }\"#,\n+        );\n+\n+        assert_expansion(&rules, \"foo! ()\", \"\");\n+    }\n+\n+    #[test]\n+    fn test_match_group_in_group() {\n+        let rules = create_rules(\n+            r#\"\n+        macro_rules! foo {            \n+            { $( ( $($i:ident)* ) )* } => ( $( ( $($i)* ) )* );\n+        }\"#,\n+        );\n+\n+        assert_expansion(&rules, \"foo! ( (a b) )\", \"(a b)\");\n+    }\n+\n     #[test]\n     fn test_expand_to_item_list() {\n         let rules = create_rules(\n@@ -1118,7 +1142,37 @@ macro_rules! impl_fn_for_zst  {\n             |$( $arg: ident: $ArgTy: ty ),*| -> $ReturnTy: ty\n $body: block; )+\n         } => {\n-            fn foo(){}\n+           $(\n+            $( #[$attr] )*\n+            struct $Name;\n+\n+            impl $( <$( $lifetime ),+> )? Fn<($( $ArgTy, )*)> for $Name {\n+                #[inline]\n+                extern \"rust-call\" fn call(&self, ($( $arg, )*): ($( $ArgTy, )*)) -> $ReturnTy {\n+                    $body\n+                }\n+            }\n+\n+            impl $( <$( $lifetime ),+> )? FnMut<($( $ArgTy, )*)> for $Name {\n+                #[inline]\n+                extern \"rust-call\" fn call_mut(\n+                    &mut self,\n+                    ($( $arg, )*): ($( $ArgTy, )*)\n+                ) -> $ReturnTy {\n+                    Fn::call(&*self, ($( $arg, )*))\n+                }\n+            }\n+\n+            impl $( <$( $lifetime ),+> )? FnOnce<($( $ArgTy, )*)> for $Name {\n+                type Output = $ReturnTy;\n+\n+                #[inline]\n+                extern \"rust-call\" fn call_once(self, ($( $arg, )*): ($( $ArgTy, )*)) -> $ReturnTy {\n+                    Fn::call(&self, ($( $arg, )*))\n+                }\n+            }\n+        )+\n+}\n         }\n }\n \"#,\n@@ -1141,7 +1195,7 @@ impl_fn_for_zst !   {\n      } ; \n  }\n \"#, \n-        \"fn foo () {}\");\n+        \"# [derive (Clone)] struct CharEscapeDebugContinue ; impl  Fn < (char ,) > for CharEscapeDebugContinue {# [inline] extern \\\"rust-call\\\" fn call (& self , (c ,) : (char ,)) -> char :: EscapeDebug {{c . escape_debug_ext (false)}}} impl  FnMut < (char ,) > for CharEscapeDebugContinue {# [inline] extern \\\"rust-call\\\" fn call_mut (& mut self , (c ,) : (char ,)) -> char :: EscapeDebug {Fn :: call (&* self , (c ,))}} impl  FnOnce < (char ,) > for CharEscapeDebugContinue {type Output = char :: EscapeDebug ; # [inline] extern \\\"rust-call\\\" fn call_once (self , (c ,) : (char ,)) -> char :: EscapeDebug {Fn :: call (& self , (c ,))}} # [derive (Clone)] struct CharEscapeUnicode ; impl  Fn < (char ,) > for CharEscapeUnicode {# [inline] extern \\\"rust-call\\\" fn call (& self , (c ,) : (char ,)) -> char :: EscapeUnicode {{c . escape_unicode ()}}} impl  FnMut < (char ,) > for CharEscapeUnicode {# [inline] extern \\\"rust-call\\\" fn call_mut (& mut self , (c ,) : (char ,)) -> char :: EscapeUnicode {Fn :: call (&* self , (c ,))}} impl  FnOnce < (char ,) > for CharEscapeUnicode {type Output = char :: EscapeUnicode ; # [inline] extern \\\"rust-call\\\" fn call_once (self , (c ,) : (char ,)) -> char :: EscapeUnicode {Fn :: call (& self , (c ,))}} # [derive (Clone)] struct CharEscapeDefault ; impl  Fn < (char ,) > for CharEscapeDefault {# [inline] extern \\\"rust-call\\\" fn call (& self , (c ,) : (char ,)) -> char :: EscapeDefault {{c . escape_default ()}}} impl  FnMut < (char ,) > for CharEscapeDefault {# [inline] extern \\\"rust-call\\\" fn call_mut (& mut self , (c ,) : (char ,)) -> char :: EscapeDefault {Fn :: call (&* self , (c ,))}} impl  FnOnce < (char ,) > for CharEscapeDefault {type Output = char :: EscapeDefault ; # [inline] extern \\\"rust-call\\\" fn call_once (self , (c ,) : (char ,)) -> char :: EscapeDefault {Fn :: call (& self , (c ,))}}\");\n     }\n \n     #[test]\n@@ -1160,4 +1214,58 @@ impl_fn_for_zst !   {\n         assert_expansion(&rules, r#\"impl_nonzero_fmt ! { # [ stable ( feature = \"nonzero\" , since = \"1.28.0\" ) ] ( Debug , Display , Binary , Octal , LowerHex , UpperHex ) for NonZeroU8 }\"#, \n         \"fn foo () {}\");\n     }\n+\n+    #[test]\n+    fn test_cfg_if_items() {\n+        // from https://github.com/rust-lang/rust/blob/33fe1131cadba69d317156847be9a402b89f11bb/src/libstd/macros.rs#L986\n+        let rules = create_rules(\n+            r#\"\n+        macro_rules! __cfg_if_items {\n+            (($($not:meta,)*) ; ) => {};\n+            (($($not:meta,)*) ; ( ($($m:meta),*) ($($it:item)*) ), $($rest:tt)*) => {\n+                 __cfg_if_items! { ($($not,)* $($m,)*) ; $($rest)* }\n+            }\n+        }\n+\"#,\n+        );\n+\n+        assert_expansion(&rules, r#\"__cfg_if_items ! { ( rustdoc , ) ; ( ( ) ( # [ cfg ( any ( target_os = \"redox\" , unix ) ) ] # [ stable ( feature = \"rust1\" , since = \"1.0.0\" ) ] pub use sys :: ext as unix ; # [ cfg ( windows ) ] # [ stable ( feature = \"rust1\" , since = \"1.0.0\" ) ] pub use sys :: ext as windows ; # [ cfg ( any ( target_os = \"linux\" , target_os = \"l4re\" ) ) ] pub mod linux ; ) ) , }\"#,         \n+        \"__cfg_if_items ! {(rustdoc , ) ; }\");\n+    }\n+\n+    #[test]\n+    fn test_cfg_if_main() {\n+        // from https://github.com/rust-lang/rust/blob/3d211248393686e0f73851fc7548f6605220fbe1/src/libpanic_unwind/macros.rs#L9\n+        let rules = create_rules(\n+            r#\"\n+        macro_rules! cfg_if {\n+            ($(\n+                if #[cfg($($meta:meta),*)] { $($it:item)* }\n+            ) else * else {\n+                $($it2:item)*\n+            }) => {\n+                __cfg_if_items! {\n+                    () ;\n+                    $( ( ($($meta),*) ($($it)*) ), )*\n+                    ( () ($($it2)*) ),\n+                }\n+            }\n+        }\n+\"#,\n+        );\n+\n+        assert_expansion(&rules, r#\"\n+cfg_if !   { \n+     if   # [ cfg ( target_env   =   \"msvc\" ) ]   { \n+         // no extra unwinder support needed \n+     }   else   if   # [ cfg ( all ( target_arch   =   \"wasm32\" ,   not ( target_os   =   \"emscripten\" ) ) ) ]   { \n+         // no unwinder on the system! \n+     }   else   { \n+         mod   libunwind ; \n+         pub   use   libunwind :: * ; \n+     } \n+ }        \n+\"#,         \n+        \"__cfg_if_items ! {() ;  (() (mod libunwind ; pub use libunwind :: * ;)) ,}\");\n+    }\n }"}, {"sha": "d5189b53745138914d09ba8312c0b706aadf9625", "filename": "crates/ra_mbe/src/mbe_expander.rs", "status": "modified", "additions": 54, "deletions": 15, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/c55a2dbc1de8ba42df57b70f652eb6a0c0bbc9f6/crates%2Fra_mbe%2Fsrc%2Fmbe_expander.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c55a2dbc1de8ba42df57b70f652eb6a0c0bbc9f6/crates%2Fra_mbe%2Fsrc%2Fmbe_expander.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Fmbe_expander.rs?ref=c55a2dbc1de8ba42df57b70f652eb6a0c0bbc9f6", "patch": "@@ -21,7 +21,10 @@ fn expand_rule(rule: &crate::Rule, input: &tt::Subtree) -> Result<tt::Subtree, E\n     if !input.is_eof() {\n         return Err(ExpandError::UnexpectedToken);\n     }\n-    expand_subtree(&rule.rhs, &bindings, &mut Vec::new())\n+\n+    let mut ctx = ExpandCtx { bindings: &bindings, nesting: Vec::new(), var_expanded: false };\n+\n+    expand_subtree(&rule.rhs, &mut ctx)\n }\n \n /// The actual algorithm for expansion is not too hard, but is pretty tricky.\n@@ -225,7 +228,7 @@ fn match_lhs(pattern: &crate::Subtree, input: &mut TtCursor) -> Result<Bindings,\n             crate::TokenTree::Repeat(crate::Repeat { subtree, kind, separator }) => {\n                 // Dirty hack to make macro-expansion terminate.\n                 // This should be replaced by a propper macro-by-example implementation\n-                let mut limit = 128;\n+                let mut limit = 65536;\n                 let mut counter = 0;\n \n                 let mut memento = input.save();\n@@ -236,6 +239,7 @@ fn match_lhs(pattern: &crate::Subtree, input: &mut TtCursor) -> Result<Bindings,\n                             counter += 1;\n                             limit -= 1;\n                             if limit == 0 {\n+                                log::warn!(\"match_lhs excced in repeat pattern exceed limit => {:#?}\\n{:#?}\\n{:#?}\\n{:#?}\", subtree, input, kind, separator);\n                                 break;\n                             }\n \n@@ -303,15 +307,21 @@ fn match_lhs(pattern: &crate::Subtree, input: &mut TtCursor) -> Result<Bindings,\n     Ok(res)\n }\n \n+#[derive(Debug)]\n+struct ExpandCtx<'a> {\n+    bindings: &'a Bindings,\n+    nesting: Vec<usize>,\n+    var_expanded: bool,\n+}\n+\n fn expand_subtree(\n     template: &crate::Subtree,\n-    bindings: &Bindings,\n-    nesting: &mut Vec<usize>,\n+    ctx: &mut ExpandCtx,\n ) -> Result<tt::Subtree, ExpandError> {\n     let token_trees = template\n         .token_trees\n         .iter()\n-        .map(|it| expand_tt(it, bindings, nesting))\n+        .map(|it| expand_tt(it, ctx))\n         .collect::<Result<Vec<_>, ExpandError>>()?;\n \n     Ok(tt::Subtree { token_trees, delimiter: template.delimiter })\n@@ -333,26 +343,43 @@ fn reduce_single_token(mut subtree: tt::Subtree) -> tt::TokenTree {\n \n fn expand_tt(\n     template: &crate::TokenTree,\n-    bindings: &Bindings,\n-    nesting: &mut Vec<usize>,\n+    ctx: &mut ExpandCtx,\n ) -> Result<tt::TokenTree, ExpandError> {\n     let res: tt::TokenTree = match template {\n-        crate::TokenTree::Subtree(subtree) => expand_subtree(subtree, bindings, nesting)?.into(),\n+        crate::TokenTree::Subtree(subtree) => expand_subtree(subtree, ctx)?.into(),\n         crate::TokenTree::Repeat(repeat) => {\n             let mut token_trees: Vec<tt::TokenTree> = Vec::new();\n-            nesting.push(0);\n+            ctx.nesting.push(0);\n             // Dirty hack to make macro-expansion terminate.\n             // This should be replaced by a propper macro-by-example implementation\n-            let mut limit = 128;\n+            let mut limit = 65536;\n             let mut has_seps = 0;\n+            let mut counter = 0;\n+\n+            let mut some_var_expanded = false;\n+            ctx.var_expanded = false;\n+\n+            while let Ok(t) = expand_subtree(&repeat.subtree, ctx) {\n+                // if no var expaned in the child, we count it as a fail\n+                if !ctx.var_expanded {\n+                    break;\n+                }\n+                some_var_expanded = true;\n+                ctx.var_expanded = false;\n \n-            while let Ok(t) = expand_subtree(&repeat.subtree, bindings, nesting) {\n+                counter += 1;\n                 limit -= 1;\n                 if limit == 0 {\n+                    log::warn!(\n+                        \"expand_tt excced in repeat pattern exceed limit => {:#?}\\n{:#?}\",\n+                        template,\n+                        ctx\n+                    );\n                     break;\n                 }\n-                let idx = nesting.pop().unwrap();\n-                nesting.push(idx + 1);\n+\n+                let idx = ctx.nesting.pop().unwrap();\n+                ctx.nesting.push(idx + 1);\n                 token_trees.push(reduce_single_token(t).into());\n \n                 if let Some(ref sep) = repeat.separator {\n@@ -374,12 +401,23 @@ fn expand_tt(\n                         }\n                     }\n                 }\n+\n+                if let crate::RepeatKind::ZeroOrOne = repeat.kind {\n+                    break;\n+                }\n             }\n-            nesting.pop().unwrap();\n+\n+            ctx.var_expanded = some_var_expanded;\n+\n+            ctx.nesting.pop().unwrap();\n             for _ in 0..has_seps {\n                 token_trees.pop();\n             }\n \n+            if crate::RepeatKind::OneOrMore == repeat.kind && counter == 0 {\n+                return Err(ExpandError::UnexpectedToken);\n+            }\n+\n             // Check if it is a singel token subtree without any delimiter\n             // e.g {Delimiter:None> ['>'] /Delimiter:None>}\n             reduce_single_token(tt::Subtree { token_trees, delimiter: tt::Delimiter::None })\n@@ -396,7 +434,8 @@ fn expand_tt(\n                     tt::Leaf::from(tt::Ident { text: \"$crate\".into(), id: TokenId::unspecified() })\n                         .into()\n                 } else {\n-                    let tkn = bindings.get(&v.text, nesting)?.clone();\n+                    let tkn = ctx.bindings.get(&v.text, &ctx.nesting)?.clone();\n+                    ctx.var_expanded = true;\n \n                     if let tt::TokenTree::Subtree(subtree) = tkn {\n                         reduce_single_token(subtree)"}, {"sha": "845020f4ec12b1d5f782203fa43ee6a61cd2135c", "filename": "crates/ra_mbe/src/subtree_source.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c55a2dbc1de8ba42df57b70f652eb6a0c0bbc9f6/crates%2Fra_mbe%2Fsrc%2Fsubtree_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c55a2dbc1de8ba42df57b70f652eb6a0c0bbc9f6/crates%2Fra_mbe%2Fsrc%2Fsubtree_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Fsubtree_source.rs?ref=c55a2dbc1de8ba42df57b70f652eb6a0c0bbc9f6", "patch": "@@ -212,7 +212,7 @@ impl<'a> SubTreeWalker<'a> {\n }\n \n pub(crate) trait Querier {\n-    fn token(&self, uidx: usize) -> (SyntaxKind, SmolStr);\n+    fn token(&self, uidx: usize) -> (SyntaxKind, SmolStr, bool);\n }\n \n // A wrapper class for ref cell\n@@ -292,9 +292,10 @@ impl<'a> WalkerOwner<'a> {\n }\n \n impl<'a> Querier for WalkerOwner<'a> {\n-    fn token(&self, uidx: usize) -> (SyntaxKind, SmolStr) {\n-        let tkn = self.get(uidx).unwrap();\n-        (tkn.kind, tkn.text)\n+    fn token(&self, uidx: usize) -> (SyntaxKind, SmolStr, bool) {\n+        self.get(uidx)\n+            .map(|tkn| (tkn.kind, tkn.text, tkn.is_joint_to_next))\n+            .unwrap_or_else(|| (SyntaxKind::EOF, \"\".into(), false))\n     }\n }\n "}, {"sha": "e0f228ce9bcb866025ea82aff8f609a59e65f3ee", "filename": "crates/ra_mbe/src/syntax_bridge.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c55a2dbc1de8ba42df57b70f652eb6a0c0bbc9f6/crates%2Fra_mbe%2Fsrc%2Fsyntax_bridge.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c55a2dbc1de8ba42df57b70f652eb6a0c0bbc9f6/crates%2Fra_mbe%2Fsrc%2Fsyntax_bridge.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Fsyntax_bridge.rs?ref=c55a2dbc1de8ba42df57b70f652eb6a0c0bbc9f6", "patch": "@@ -123,6 +123,11 @@ fn convert_tt(\n     global_offset: TextUnit,\n     tt: &SyntaxNode,\n ) -> Option<tt::Subtree> {\n+    // This tree is empty\n+    if tt.first_child_or_token().is_none() {\n+        return Some(tt::Subtree { token_trees: vec![], delimiter: tt::Delimiter::None });\n+    }\n+\n     let first_child = tt.first_child_or_token()?;\n     let last_child = tt.last_child_or_token()?;\n     let (delimiter, skip_first) = match (first_child.kind(), last_child.kind()) {\n@@ -233,7 +238,16 @@ impl<'a, Q: Querier> TreeSink for TtTreeSink<'a, Q> {\n         self.text_pos += TextUnit::of_str(&self.buf);\n         let text = SmolStr::new(self.buf.as_str());\n         self.buf.clear();\n-        self.inner.token(kind, text)\n+        self.inner.token(kind, text);\n+\n+        // // Add a white space to token\n+        // let (last_kind, _, last_joint_to_next ) = self.src_querier.token(self.token_pos-n_tokens as usize);\n+        // if !last_joint_to_next && last_kind.is_punct() {\n+        //     let (cur_kind, _, _ ) = self.src_querier.token(self.token_pos);\n+        //     if cur_kind.is_punct() {\n+        //         self.inner.token(WHITESPACE, \" \".into());\n+        //     }\n+        // }\n     }\n \n     fn start_node(&mut self, kind: SyntaxKind) {"}, {"sha": "eef642a9c0a1cd447c3c441320eecd972a9bf237", "filename": "crates/ra_mbe/src/tt_cursor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c55a2dbc1de8ba42df57b70f652eb6a0c0bbc9f6/crates%2Fra_mbe%2Fsrc%2Ftt_cursor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c55a2dbc1de8ba42df57b70f652eb6a0c0bbc9f6/crates%2Fra_mbe%2Fsrc%2Ftt_cursor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Ftt_cursor.rs?ref=c55a2dbc1de8ba42df57b70f652eb6a0c0bbc9f6", "patch": "@@ -3,7 +3,7 @@ use crate::subtree_parser::Parser;\n use crate::subtree_source::TokenPeek;\n use smallvec::{SmallVec, smallvec};\n \n-#[derive(Clone)]\n+#[derive(Debug, Clone)]\n pub(crate) struct TtCursor<'a> {\n     subtree: &'a tt::Subtree,\n     pos: usize,"}, {"sha": "a538ec081f1a62df4cc86eea990a3e5734f3b424", "filename": "crates/ra_parser/src/grammar.rs", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/c55a2dbc1de8ba42df57b70f652eb6a0c0bbc9f6/crates%2Fra_parser%2Fsrc%2Fgrammar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c55a2dbc1de8ba42df57b70f652eb6a0c0bbc9f6/crates%2Fra_parser%2Fsrc%2Fgrammar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fgrammar.rs?ref=c55a2dbc1de8ba42df57b70f652eb6a0c0bbc9f6", "patch": "@@ -119,7 +119,22 @@ pub(crate) fn meta_item(p: &mut Parser) {\n             items::token_tree(p);\n             break;\n         } else {\n-            p.bump();\n+            // https://doc.rust-lang.org/reference/attributes.html\n+            // https://doc.rust-lang.org/reference/paths.html#simple-paths\n+            // The start of an meta must be a simple path\n+            match p.current() {\n+                IDENT | COLONCOLON | SUPER_KW | SELF_KW | CRATE_KW => p.bump(),\n+                EQ => {\n+                    p.bump();\n+                    match p.current() {\n+                        c if c.is_literal() => p.bump(),\n+                        TRUE_KW | FALSE_KW => p.bump(),\n+                        _ => {}\n+                    }\n+                    break;\n+                }\n+                _ => break,\n+            }\n         }\n     }\n "}]}