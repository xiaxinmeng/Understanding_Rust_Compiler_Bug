{"sha": "073744f554cf170942aa43893f292199ad44e3d4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA3Mzc0NGY1NTRjZjE3MDk0MmFhNDM4OTNmMjkyMTk5YWQ0NGUzZDQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-04-21T01:26:56Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-04-21T01:26:56Z"}, "message": "Auto merge of #71367 - Dylan-DPC:rollup-ysj4olr, r=Dylan-DPC\n\nRollup of 4 pull requests\n\nSuccessful merges:\n\n - #69362 (Stabilize most common subset of alloc_layout_extras)\n - #71174 (Check that main/start is not async)\n - #71285 (MIR: use HirId instead of NodeId to avoid cycles while inlining)\n - #71346 (Do not build tools if user do not want them)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "7460d5414cb1ed93377e6effe1f8d724c8c4d7dd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7460d5414cb1ed93377e6effe1f8d724c8c4d7dd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/073744f554cf170942aa43893f292199ad44e3d4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/073744f554cf170942aa43893f292199ad44e3d4", "html_url": "https://github.com/rust-lang/rust/commit/073744f554cf170942aa43893f292199ad44e3d4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/073744f554cf170942aa43893f292199ad44e3d4/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "20fc02f836f3035b86b56a7cedb97c5cd4ed9612", "url": "https://api.github.com/repos/rust-lang/rust/commits/20fc02f836f3035b86b56a7cedb97c5cd4ed9612", "html_url": "https://github.com/rust-lang/rust/commit/20fc02f836f3035b86b56a7cedb97c5cd4ed9612"}, {"sha": "9a0e7029062fb74a71a200b1f7ce0c212c9ea3a6", "url": "https://api.github.com/repos/rust-lang/rust/commits/9a0e7029062fb74a71a200b1f7ce0c212c9ea3a6", "html_url": "https://github.com/rust-lang/rust/commit/9a0e7029062fb74a71a200b1f7ce0c212c9ea3a6"}], "stats": {"total": 180, "additions": 145, "deletions": 35}, "files": [{"sha": "f756b1235abee997d0f77da3bbec8f53b7db8a5d", "filename": "src/bootstrap/tool.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/073744f554cf170942aa43893f292199ad44e3d4/src%2Fbootstrap%2Ftool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/073744f554cf170942aa43893f292199ad44e3d4/src%2Fbootstrap%2Ftool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftool.rs?ref=073744f554cf170942aa43893f292199ad44e3d4", "patch": "@@ -607,7 +607,15 @@ macro_rules! tool_extended {\n \n             fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n                 let builder = run.builder;\n-                run.path($path).default_condition(builder.config.extended)\n+                run.path($path).default_condition(\n+                    builder.config.extended\n+                        && builder.config.tools.as_ref().map_or(true, |tools| {\n+                            tools.iter().any(|tool| match tool.as_ref() {\n+                                \"clippy\" => $tool_name == \"clippy-driver\",\n+                                x => $tool_name == x,\n+                            })\n+                        }),\n+                )\n             }\n \n             fn make_run(run: RunConfig<'_>) {"}, {"sha": "6200cd242667f13f3cc09e6ff31ea9f6a4276972", "filename": "src/libcore/alloc/layout.rs", "status": "modified", "additions": 43, "deletions": 13, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/073744f554cf170942aa43893f292199ad44e3d4/src%2Flibcore%2Falloc%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/073744f554cf170942aa43893f292199ad44e3d4/src%2Flibcore%2Falloc%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Falloc%2Flayout.rs?ref=073744f554cf170942aa43893f292199ad44e3d4", "patch": "@@ -162,7 +162,7 @@ impl Layout {\n     /// Returns an error if the combination of `self.size()` and the given\n     /// `align` violates the conditions listed in\n     /// [`Layout::from_size_align`](#method.from_size_align).\n-    #[unstable(feature = \"alloc_layout_extra\", issue = \"55724\")]\n+    #[stable(feature = \"alloc_layout_manipulation\", since = \"1.44.0\")]\n     #[inline]\n     pub fn align_to(&self, align: usize) -> Result<Self, LayoutErr> {\n         Layout::from_size_align(self.size(), cmp::max(self.align(), align))\n@@ -218,7 +218,7 @@ impl Layout {\n     ///\n     /// This is equivalent to adding the result of `padding_needed_for`\n     /// to the layout's current size.\n-    #[unstable(feature = \"alloc_layout_extra\", issue = \"55724\")]\n+    #[stable(feature = \"alloc_layout_manipulation\", since = \"1.44.0\")]\n     #[inline]\n     pub fn pad_to_align(&self) -> Layout {\n         let pad = self.padding_needed_for(self.align());\n@@ -258,19 +258,50 @@ impl Layout {\n \n     /// Creates a layout describing the record for `self` followed by\n     /// `next`, including any necessary padding to ensure that `next`\n-    /// will be properly aligned. Note that the resulting layout will\n-    /// satisfy the alignment properties of both `self` and `next`.\n+    /// will be properly aligned, but *no trailing padding*.\n     ///\n-    /// The resulting layout will be the same as that of a C struct containing\n-    /// two fields with the layouts of `self` and `next`, in that order.\n+    /// In order to match C representation layout `repr(C)`, you should\n+    /// call `pad_to_align` after extending the layout with all fields.\n+    /// (There is no way to match the default Rust representation\n+    /// layout `repr(Rust)`, as it is unspecified.)\n     ///\n-    /// Returns `Some((k, offset))`, where `k` is layout of the concatenated\n+    /// Note that the alignment of the resulting layout will be the maximum of\n+    /// those of `self` and `next`, in order to ensure alignment of both parts.\n+    ///\n+    /// Returns `Ok((k, offset))`, where `k` is layout of the concatenated\n     /// record and `offset` is the relative location, in bytes, of the\n     /// start of the `next` embedded within the concatenated record\n     /// (assuming that the record itself starts at offset 0).\n     ///\n     /// On arithmetic overflow, returns `LayoutErr`.\n-    #[unstable(feature = \"alloc_layout_extra\", issue = \"55724\")]\n+    ///\n+    /// # Examples\n+    ///\n+    /// To calculate the layout of a `#[repr(C)]` structure and the offsets of\n+    /// the fields from its fields' layouts:\n+    ///\n+    /// ```rust\n+    /// # use std::alloc::{Layout, LayoutErr};\n+    /// pub fn repr_c(fields: &[Layout]) -> Result<(Layout, Vec<usize>), LayoutErr> {\n+    ///     let mut offsets = Vec::new();\n+    ///     let mut layout = Layout::from_size_align(0, 1)?;\n+    ///     for &field in fields {\n+    ///         let (new_layout, offset) = layout.extend(field)?;\n+    ///         layout = new_layout;\n+    ///         offsets.push(offset);\n+    ///     }\n+    ///     // Remember to finalize with `pad_to_align`!\n+    ///     Ok((layout.pad_to_align(), offsets))\n+    /// }\n+    /// # // test that it works\n+    /// # #[repr(C)] struct S { a: u64, b: u32, c: u16, d: u32 }\n+    /// # let s = Layout::new::<S>();\n+    /// # let u16 = Layout::new::<u16>();\n+    /// # let u32 = Layout::new::<u32>();\n+    /// # let u64 = Layout::new::<u64>();\n+    /// # assert_eq!(repr_c(&[u64, u32, u16, u32]), Ok((s, vec![0, 8, 12, 16])));\n+    /// ```\n+    #[stable(feature = \"alloc_layout_manipulation\", since = \"1.44.0\")]\n     #[inline]\n     pub fn extend(&self, next: Self) -> Result<(Self, usize), LayoutErr> {\n         let new_align = cmp::max(self.align(), next.align());\n@@ -318,13 +349,12 @@ impl Layout {\n     /// Creates a layout describing the record for a `[T; n]`.\n     ///\n     /// On arithmetic overflow, returns `LayoutErr`.\n-    #[unstable(feature = \"alloc_layout_extra\", issue = \"55724\")]\n+    #[stable(feature = \"alloc_layout_manipulation\", since = \"1.44.0\")]\n     #[inline]\n     pub fn array<T>(n: usize) -> Result<Self, LayoutErr> {\n-        Layout::new::<T>().repeat(n).map(|(k, offs)| {\n-            debug_assert!(offs == mem::size_of::<T>());\n-            k\n-        })\n+        let (layout, offset) = Layout::new::<T>().repeat(n)?;\n+        debug_assert_eq!(offset, mem::size_of::<T>());\n+        Ok(layout.pad_to_align())\n     }\n }\n "}, {"sha": "bc04809eaa1dfd59e97927d5a90eedf1224dda9b", "filename": "src/librustc_error_codes/error_codes.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/073744f554cf170942aa43893f292199ad44e3d4/src%2Flibrustc_error_codes%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/073744f554cf170942aa43893f292199ad44e3d4/src%2Flibrustc_error_codes%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes.rs?ref=073744f554cf170942aa43893f292199ad44e3d4", "patch": "@@ -431,6 +431,7 @@ E0748: include_str!(\"./error_codes/E0748.md\"),\n E0749: include_str!(\"./error_codes/E0749.md\"),\n E0750: include_str!(\"./error_codes/E0750.md\"),\n E0751: include_str!(\"./error_codes/E0751.md\"),\n+E0752: include_str!(\"./error_codes/E0752.md\"),\n ;\n //  E0006, // merged with E0005\n //  E0008, // cannot bind by-move into a pattern guard"}, {"sha": "86945f83b55240a30af21ecd8c5460a666dbbb80", "filename": "src/librustc_error_codes/error_codes/E0752.md", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/073744f554cf170942aa43893f292199ad44e3d4/src%2Flibrustc_error_codes%2Ferror_codes%2FE0752.md", "raw_url": "https://github.com/rust-lang/rust/raw/073744f554cf170942aa43893f292199ad44e3d4/src%2Flibrustc_error_codes%2Ferror_codes%2FE0752.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0752.md?ref=073744f554cf170942aa43893f292199ad44e3d4", "patch": "@@ -0,0 +1,11 @@\n+`fn main()` or the specified start function is not allowed to be\n+async. You might be seeing this error because your async runtime\n+library is not set up correctly.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0752\n+async fn main() -> Result<i32, ()> {\n+    Ok(1)\n+}\n+```"}, {"sha": "173c2a3f1d8641b2201c05aa9d7f5f57b8799d81", "filename": "src/librustc_mir/transform/inline.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/073744f554cf170942aa43893f292199ad44e3d4/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/073744f554cf170942aa43893f292199ad44e3d4/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finline.rs?ref=073744f554cf170942aa43893f292199ad44e3d4", "patch": "@@ -94,17 +94,15 @@ impl Inliner<'tcx> {\n                     continue;\n                 }\n \n-                let self_node_id = self.tcx.hir().as_local_node_id(self.source.def_id()).unwrap();\n-                let callee_node_id = self.tcx.hir().as_local_node_id(callsite.callee);\n+                let callee_hir_id = self.tcx.hir().as_local_hir_id(callsite.callee);\n \n-                let callee_body = if let Some(callee_node_id) = callee_node_id {\n+                let callee_body = if let Some(callee_hir_id) = callee_hir_id {\n+                    let self_hir_id = self.tcx.hir().as_local_hir_id(self.source.def_id()).unwrap();\n                     // Avoid a cycle here by only using `optimized_mir` only if we have\n-                    // a lower node id than the callee. This ensures that the callee will\n+                    // a lower `HirId` than the callee. This ensures that the callee will\n                     // not inline us. This trick only works without incremental compilation.\n                     // So don't do it if that is enabled.\n-                    if !self.tcx.dep_graph.is_fully_enabled()\n-                        && self_node_id.as_u32() < callee_node_id.as_u32()\n-                    {\n+                    if !self.tcx.dep_graph.is_fully_enabled() && self_hir_id < callee_hir_id {\n                         self.tcx.optimized_mir(callsite.callee)\n                     } else {\n                         continue;"}, {"sha": "fd87759a7621f1bed44e2a2af3d1983f0f3643d3", "filename": "src/librustc_trait_selection/traits/error_reporting/on_unimplemented.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/073744f554cf170942aa43893f292199ad44e3d4/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fon_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/073744f554cf170942aa43893f292199ad44e3d4/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fon_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fon_unimplemented.rs?ref=073744f554cf170942aa43893f292199ad44e3d4", "patch": "@@ -82,10 +82,9 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         match &node {\n             hir::Node::Item(hir::Item { kind: hir::ItemKind::Fn(sig, _, body_id), .. }) => {\n                 self.describe_generator(*body_id).or_else(|| {\n-                    Some(if let hir::FnHeader { asyncness: hir::IsAsync::Async, .. } = sig.header {\n-                        \"an async function\"\n-                    } else {\n-                        \"a function\"\n+                    Some(match sig.header {\n+                        hir::FnHeader { asyncness: hir::IsAsync::Async, .. } => \"an async function\",\n+                        _ => \"a function\",\n                     })\n                 })\n             }\n@@ -97,10 +96,9 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 kind: hir::ImplItemKind::Fn(sig, body_id),\n                 ..\n             }) => self.describe_generator(*body_id).or_else(|| {\n-                Some(if let hir::FnHeader { asyncness: hir::IsAsync::Async, .. } = sig.header {\n-                    \"an async method\"\n-                } else {\n-                    \"a method\"\n+                Some(match sig.header {\n+                    hir::FnHeader { asyncness: hir::IsAsync::Async, .. } => \"an async method\",\n+                    _ => \"a method\",\n                 })\n             }),\n             hir::Node::Expr(hir::Expr {"}, {"sha": "331c8f3be841a2a5952b5399b42be1201620bacd", "filename": "src/librustc_trait_selection/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/073744f554cf170942aa43893f292199ad44e3d4/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/073744f554cf170942aa43893f292199ad44e3d4/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=073744f554cf170942aa43893f292199ad44e3d4", "patch": "@@ -1318,10 +1318,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n \n         let is_async = inner_generator_body\n             .and_then(|body| body.generator_kind())\n-            .map(|generator_kind| match generator_kind {\n-                hir::GeneratorKind::Async(..) => true,\n-                _ => false,\n-            })\n+            .map(|generator_kind| matches!(generator_kind, hir::GeneratorKind::Async(..)))\n             .unwrap_or(false);\n         let (await_or_yield, an_await_or_yield) =\n             if is_async { (\"await\", \"an await\") } else { (\"yield\", \"a yield\") };"}, {"sha": "cd76184c9bf2d30ae55946ff253fc440ac80025a", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 26, "deletions": 2, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/073744f554cf170942aa43893f292199ad44e3d4/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/073744f554cf170942aa43893f292199ad44e3d4/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=073744f554cf170942aa43893f292199ad44e3d4", "patch": "@@ -159,7 +159,7 @@ fn check_main_fn_ty(tcx: TyCtxt<'_>, main_def_id: DefId) {\n     match main_t.kind {\n         ty::FnDef(..) => {\n             if let Some(Node::Item(it)) = tcx.hir().find(main_id) {\n-                if let hir::ItemKind::Fn(.., ref generics, _) = it.kind {\n+                if let hir::ItemKind::Fn(ref sig, ref generics, _) = it.kind {\n                     let mut error = false;\n                     if !generics.params.is_empty() {\n                         let msg = \"`main` function is not allowed to have generic \\\n@@ -182,6 +182,18 @@ fn check_main_fn_ty(tcx: TyCtxt<'_>, main_def_id: DefId) {\n                         .emit();\n                         error = true;\n                     }\n+                    if let hir::IsAsync::Async = sig.header.asyncness {\n+                        let span = tcx.sess.source_map().guess_head_span(it.span);\n+                        struct_span_err!(\n+                            tcx.sess,\n+                            span,\n+                            E0752,\n+                            \"`main` function is not allowed to be `async`\"\n+                        )\n+                        .span_label(span, \"`main` function is not allowed to be `async`\")\n+                        .emit();\n+                        error = true;\n+                    }\n                     if error {\n                         return;\n                     }\n@@ -226,7 +238,7 @@ fn check_start_fn_ty(tcx: TyCtxt<'_>, start_def_id: DefId) {\n     match start_t.kind {\n         ty::FnDef(..) => {\n             if let Some(Node::Item(it)) = tcx.hir().find(start_id) {\n-                if let hir::ItemKind::Fn(.., ref generics, _) = it.kind {\n+                if let hir::ItemKind::Fn(ref sig, ref generics, _) = it.kind {\n                     let mut error = false;\n                     if !generics.params.is_empty() {\n                         struct_span_err!(\n@@ -250,6 +262,18 @@ fn check_start_fn_ty(tcx: TyCtxt<'_>, start_def_id: DefId) {\n                         .emit();\n                         error = true;\n                     }\n+                    if let hir::IsAsync::Async = sig.header.asyncness {\n+                        let span = tcx.sess.source_map().guess_head_span(it.span);\n+                        struct_span_err!(\n+                            tcx.sess,\n+                            span,\n+                            E0752,\n+                            \"start is not allowed to be `async`\"\n+                        )\n+                        .span_label(span, \"start is not allowed to be `async`\")\n+                        .emit();\n+                        error = true;\n+                    }\n                     if error {\n                         return;\n                     }"}, {"sha": "5988dffd68fa799a5e94421587235c82c48b26fa", "filename": "src/test/ui/async-await/issue-68523-start.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/073744f554cf170942aa43893f292199ad44e3d4/src%2Ftest%2Fui%2Fasync-await%2Fissue-68523-start.rs", "raw_url": "https://github.com/rust-lang/rust/raw/073744f554cf170942aa43893f292199ad44e3d4/src%2Ftest%2Fui%2Fasync-await%2Fissue-68523-start.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-68523-start.rs?ref=073744f554cf170942aa43893f292199ad44e3d4", "patch": "@@ -0,0 +1,9 @@\n+// edition:2018\n+\n+#![feature(start)]\n+\n+#[start]\n+pub async fn start(_: isize, _: *const *const u8) -> isize {\n+//~^ ERROR start is not allowed to be `async`\n+    0\n+}"}, {"sha": "e471945900e7d462e06a627ce85042da162b012b", "filename": "src/test/ui/async-await/issue-68523-start.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/073744f554cf170942aa43893f292199ad44e3d4/src%2Ftest%2Fui%2Fasync-await%2Fissue-68523-start.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/073744f554cf170942aa43893f292199ad44e3d4/src%2Ftest%2Fui%2Fasync-await%2Fissue-68523-start.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-68523-start.stderr?ref=073744f554cf170942aa43893f292199ad44e3d4", "patch": "@@ -0,0 +1,9 @@\n+error[E0752]: start is not allowed to be `async`\n+  --> $DIR/issue-68523-start.rs:6:1\n+   |\n+LL | pub async fn start(_: isize, _: *const *const u8) -> isize {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ start is not allowed to be `async`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0752`."}, {"sha": "e6250c40c714c3f2147fe02a0d5baf644b3e8479", "filename": "src/test/ui/async-await/issue-68523.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/073744f554cf170942aa43893f292199ad44e3d4/src%2Ftest%2Fui%2Fasync-await%2Fissue-68523.rs", "raw_url": "https://github.com/rust-lang/rust/raw/073744f554cf170942aa43893f292199ad44e3d4/src%2Ftest%2Fui%2Fasync-await%2Fissue-68523.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-68523.rs?ref=073744f554cf170942aa43893f292199ad44e3d4", "patch": "@@ -0,0 +1,7 @@\n+// edition:2018\n+\n+async fn main() -> Result<i32, ()> {\n+//~^ ERROR `main` function is not allowed to be `async`\n+//~^^ ERROR `main` has invalid return type `impl std::future::Future`\n+    Ok(1)\n+}"}, {"sha": "62e37cf2629d73de3e9f4b30ca1c3ce04909b17f", "filename": "src/test/ui/async-await/issue-68523.stderr", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/073744f554cf170942aa43893f292199ad44e3d4/src%2Ftest%2Fui%2Fasync-await%2Fissue-68523.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/073744f554cf170942aa43893f292199ad44e3d4/src%2Ftest%2Fui%2Fasync-await%2Fissue-68523.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-68523.stderr?ref=073744f554cf170942aa43893f292199ad44e3d4", "patch": "@@ -0,0 +1,18 @@\n+error[E0277]: `main` has invalid return type `impl std::future::Future`\n+  --> $DIR/issue-68523.rs:3:20\n+   |\n+LL | async fn main() -> Result<i32, ()> {\n+   |                    ^^^^^^^^^^^^^^^ `main` can only return types that implement `std::process::Termination`\n+   |\n+   = help: consider using `()`, or a `Result`\n+\n+error[E0752]: `main` function is not allowed to be `async`\n+  --> $DIR/issue-68523.rs:3:1\n+   |\n+LL | async fn main() -> Result<i32, ()> {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `main` function is not allowed to be `async`\n+\n+error: aborting due to 2 previous errors\n+\n+Some errors have detailed explanations: E0277, E0752.\n+For more information about an error, try `rustc --explain E0277`."}]}