{"sha": "33179a0ae1ba9a908cc34a4cf87599ed779b9886", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMzMTc5YTBhZTFiYTlhOTA4Y2MzNGE0Y2Y4NzU5OWVkNzc5Yjk4ODY=", "commit": {"author": {"name": "Kirill Bulatov", "email": "mail4score@gmail.com", "date": "2020-09-07T13:17:50Z"}, "committer": {"name": "Kirill Bulatov", "email": "mail4score@gmail.com", "date": "2020-09-09T22:42:20Z"}, "message": "Move rust-related logic from vfs to base_db level", "tree": {"sha": "13d5b6f0ad9894305a1268d9e76d66973a9ce122", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/13d5b6f0ad9894305a1268d9e76d66973a9ce122"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/33179a0ae1ba9a908cc34a4cf87599ed779b9886", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/33179a0ae1ba9a908cc34a4cf87599ed779b9886", "html_url": "https://github.com/rust-lang/rust/commit/33179a0ae1ba9a908cc34a4cf87599ed779b9886", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/33179a0ae1ba9a908cc34a4cf87599ed779b9886/comments", "author": {"login": "SomeoneToIgnore", "id": 2690773, "node_id": "MDQ6VXNlcjI2OTA3NzM=", "avatar_url": "https://avatars.githubusercontent.com/u/2690773?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SomeoneToIgnore", "html_url": "https://github.com/SomeoneToIgnore", "followers_url": "https://api.github.com/users/SomeoneToIgnore/followers", "following_url": "https://api.github.com/users/SomeoneToIgnore/following{/other_user}", "gists_url": "https://api.github.com/users/SomeoneToIgnore/gists{/gist_id}", "starred_url": "https://api.github.com/users/SomeoneToIgnore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SomeoneToIgnore/subscriptions", "organizations_url": "https://api.github.com/users/SomeoneToIgnore/orgs", "repos_url": "https://api.github.com/users/SomeoneToIgnore/repos", "events_url": "https://api.github.com/users/SomeoneToIgnore/events{/privacy}", "received_events_url": "https://api.github.com/users/SomeoneToIgnore/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SomeoneToIgnore", "id": 2690773, "node_id": "MDQ6VXNlcjI2OTA3NzM=", "avatar_url": "https://avatars.githubusercontent.com/u/2690773?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SomeoneToIgnore", "html_url": "https://github.com/SomeoneToIgnore", "followers_url": "https://api.github.com/users/SomeoneToIgnore/followers", "following_url": "https://api.github.com/users/SomeoneToIgnore/following{/other_user}", "gists_url": "https://api.github.com/users/SomeoneToIgnore/gists{/gist_id}", "starred_url": "https://api.github.com/users/SomeoneToIgnore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SomeoneToIgnore/subscriptions", "organizations_url": "https://api.github.com/users/SomeoneToIgnore/orgs", "repos_url": "https://api.github.com/users/SomeoneToIgnore/repos", "events_url": "https://api.github.com/users/SomeoneToIgnore/events{/privacy}", "received_events_url": "https://api.github.com/users/SomeoneToIgnore/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b2bcc5278db23c3ba0a4f47a3ef6ee411aaaa8dc", "url": "https://api.github.com/repos/rust-lang/rust/commits/b2bcc5278db23c3ba0a4f47a3ef6ee411aaaa8dc", "html_url": "https://github.com/rust-lang/rust/commit/b2bcc5278db23c3ba0a4f47a3ef6ee411aaaa8dc"}], "stats": {"total": 135, "additions": 74, "deletions": 61}, "files": [{"sha": "9733e1fd3b1df061491634eb20aa53ed8ae0aad2", "filename": "crates/base_db/src/lib.rs", "status": "modified", "additions": 69, "deletions": 1, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/33179a0ae1ba9a908cc34a4cf87599ed779b9886/crates%2Fbase_db%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33179a0ae1ba9a908cc34a4cf87599ed779b9886/crates%2Fbase_db%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fbase_db%2Fsrc%2Flib.rs?ref=33179a0ae1ba9a908cc34a4cf87599ed779b9886", "patch": "@@ -167,7 +167,7 @@ impl<T: SourceDatabaseExt> FileLoader for FileLoaderDelegate<&'_ T> {\n     }\n \n     fn possible_sudmobule_names(&self, module_file: FileId) -> Vec<String> {\n-        self.source_root(module_file).file_set.possible_sudmobule_names(module_file)\n+        possible_sudmobule_names(&self.source_root(module_file).file_set, module_file)\n     }\n }\n \n@@ -177,3 +177,71 @@ impl<T: SourceDatabaseExt> FileLoaderDelegate<&'_ T> {\n         self.0.source_root(source_root)\n     }\n }\n+\n+fn possible_sudmobule_names(module_files: &FileSet, module_file: FileId) -> Vec<String> {\n+    let directory_to_look_for_submodules = match module_files\n+        .path_for_file(&module_file)\n+        .and_then(|module_file_path| get_directory_with_submodules(module_file_path))\n+    {\n+        Some(directory) => directory,\n+        None => return Vec::new(),\n+    };\n+    module_files\n+        .iter()\n+        .filter(|submodule_file| submodule_file != &module_file)\n+        .filter_map(|submodule_file| {\n+            let submodule_path = module_files.path_for_file(&submodule_file)?;\n+            if submodule_path.parent()? == directory_to_look_for_submodules {\n+                submodule_path.file_name_and_extension()\n+            } else {\n+                None\n+            }\n+        })\n+        .filter_map(|file_name_and_extension| {\n+            match file_name_and_extension {\n+                // TODO kb wrong resolution for nested non-file modules (mod tests {mod <|>)\n+                // TODO kb in src/bin when a module is included into another,\n+                // the included file gets \"moved\" into a directory below and now cannot add any other modules\n+                (\"mod\", Some(\"rs\")) | (\"lib\", Some(\"rs\")) | (\"main\", Some(\"rs\")) => None,\n+                (file_name, Some(\"rs\")) => Some(file_name.to_owned()),\n+                (subdirectory_name, None) => {\n+                    let mod_rs_path =\n+                        directory_to_look_for_submodules.join(subdirectory_name)?.join(\"mod.rs\")?;\n+                    if module_files.file_for_path(&mod_rs_path).is_some() {\n+                        Some(subdirectory_name.to_owned())\n+                    } else {\n+                        None\n+                    }\n+                }\n+                _ => None,\n+            }\n+        })\n+        .collect()\n+}\n+\n+fn get_directory_with_submodules(module_file_path: &VfsPath) -> Option<VfsPath> {\n+    let module_directory_path = module_file_path.parent()?;\n+    match module_file_path.file_name_and_extension()? {\n+        (\"mod\", Some(\"rs\")) | (\"lib\", Some(\"rs\")) | (\"main\", Some(\"rs\")) => {\n+            Some(module_directory_path)\n+        }\n+        (regular_rust_file_name, Some(\"rs\")) => {\n+            if matches!(\n+                (\n+                    module_directory_path\n+                        .parent()\n+                        .as_ref()\n+                        .and_then(|path| path.file_name_and_extension()),\n+                    module_directory_path.file_name_and_extension(),\n+                ),\n+                (Some((\"src\", None)), Some((\"bin\", None)))\n+            ) {\n+                // files in /src/bin/ can import each other directly\n+                Some(module_directory_path)\n+            } else {\n+                module_directory_path.join(regular_rust_file_name)\n+            }\n+        }\n+        _ => None,\n+    }\n+}"}, {"sha": "4aa2d6526be782bc26262922eb766f8669a08fd4", "filename": "crates/vfs/src/file_set.rs", "status": "modified", "additions": 5, "deletions": 60, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/33179a0ae1ba9a908cc34a4cf87599ed779b9886/crates%2Fvfs%2Fsrc%2Ffile_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33179a0ae1ba9a908cc34a4cf87599ed779b9886/crates%2Fvfs%2Fsrc%2Ffile_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fvfs%2Fsrc%2Ffile_set.rs?ref=33179a0ae1ba9a908cc34a4cf87599ed779b9886", "patch": "@@ -26,74 +26,19 @@ impl FileSet {\n         self.files.get(&path).copied()\n     }\n \n-    pub fn possible_sudmobule_names(&self, module_file: FileId) -> Vec<String> {\n-        let directory_to_look_for_submodules = match self.get_directory_with_submodules(module_file)\n-        {\n-            Some(directory) => directory,\n-            None => return Vec::new(),\n-        };\n-        self.paths\n-            .iter()\n-            .filter_map(|(_, path)| {\n-                if path.parent()? == directory_to_look_for_submodules {\n-                    path.file_name_and_extension()\n-                } else {\n-                    None\n-                }\n-            })\n-            .filter_map(|file_name_and_extension| match file_name_and_extension {\n-                // TODO kb do not include the module file name itself, if present\n-                // TODO kb wrong resolution for nes\u0421\u043f\u0430ted non-file modules (mod tests {mod <|>)\n-                // TODO kb in src/bin when a module is included into another,\n-                // the included file gets \"moved\" into a directory below and now cannot add any other modules\n-                (\"mod\", Some(\"rs\")) | (\"lib\", Some(\"rs\")) | (\"main\", Some(\"rs\")) => None,\n-                (file_name, Some(\"rs\")) => Some(file_name.to_owned()),\n-                (subdirectory_name, None) => {\n-                    let mod_rs_path =\n-                        directory_to_look_for_submodules.join(subdirectory_name)?.join(\"mod.rs\")?;\n-                    if self.files.contains_key(&mod_rs_path) {\n-                        Some(subdirectory_name.to_owned())\n-                    } else {\n-                        None\n-                    }\n-                }\n-                _ => None,\n-            })\n-            .collect()\n+    pub fn file_for_path(&self, path: &VfsPath) -> Option<&FileId> {\n+        self.files.get(path)\n     }\n \n-    fn get_directory_with_submodules(&self, module_file: FileId) -> Option<VfsPath> {\n-        let module_file_path = &self.paths[&module_file];\n-        let module_directory_path = module_file_path.parent()?;\n-        match module_file_path.file_name_and_extension() {\n-            Some((\"mod\", Some(\"rs\"))) | Some((\"lib\", Some(\"rs\"))) | Some((\"main\", Some(\"rs\"))) => {\n-                Some(module_directory_path)\n-            }\n-            Some((regular_rust_file_name, Some(\"rs\"))) => {\n-                if matches!(\n-                    (\n-                        module_directory_path\n-                            .parent()\n-                            .as_ref()\n-                            .and_then(|path| path.file_name_and_extension()),\n-                        module_directory_path.file_name_and_extension(),\n-                    ),\n-                    (Some((\"src\", None)), Some((\"bin\", None)))\n-                ) {\n-                    // files in /src/bin/ can import each other directly\n-                    Some(module_directory_path)\n-                } else {\n-                    module_directory_path.join(regular_rust_file_name)\n-                }\n-            }\n-            _ => None,\n-        }\n+    pub fn path_for_file(&self, file: &FileId) -> Option<&VfsPath> {\n+        self.paths.get(file)\n     }\n \n     pub fn insert(&mut self, file_id: FileId, path: VfsPath) {\n         self.files.insert(path.clone(), file_id);\n         self.paths.insert(file_id, path);\n     }\n+\n     pub fn iter(&self) -> impl Iterator<Item = FileId> + '_ {\n         self.paths.keys().copied()\n     }"}]}