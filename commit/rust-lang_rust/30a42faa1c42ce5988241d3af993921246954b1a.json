{"sha": "30a42faa1c42ce5988241d3af993921246954b1a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMwYTQyZmFhMWM0MmNlNTk4ODI0MWQzYWY5OTM5MjEyNDY5NTRiMWE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-05-13T04:55:31Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-05-13T04:55:31Z"}, "message": "Auto merge of #25357 - steveklabnik:rollup, r=steveklabnik\n\n- Successful merges: #25224, #25317, #25321, #25324, #25348\n- Failed merges: #25174, #25334, #25341", "tree": {"sha": "4e53d596836bfef1f6a4d85596377722b5fb668e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4e53d596836bfef1f6a4d85596377722b5fb668e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/30a42faa1c42ce5988241d3af993921246954b1a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/30a42faa1c42ce5988241d3af993921246954b1a", "html_url": "https://github.com/rust-lang/rust/commit/30a42faa1c42ce5988241d3af993921246954b1a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/30a42faa1c42ce5988241d3af993921246954b1a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c2b30b86df6b34ba19e87e63402e43d9e81a64fb", "url": "https://api.github.com/repos/rust-lang/rust/commits/c2b30b86df6b34ba19e87e63402e43d9e81a64fb", "html_url": "https://github.com/rust-lang/rust/commit/c2b30b86df6b34ba19e87e63402e43d9e81a64fb"}, {"sha": "11f945cd00e14381b0f31cf0fab98a76e8e9fc89", "url": "https://api.github.com/repos/rust-lang/rust/commits/11f945cd00e14381b0f31cf0fab98a76e8e9fc89", "html_url": "https://github.com/rust-lang/rust/commit/11f945cd00e14381b0f31cf0fab98a76e8e9fc89"}], "stats": {"total": 1549, "additions": 1379, "deletions": 170}, "files": [{"sha": "da59629b049f349282da4eebc5191f33c8e1d39e", "filename": "README.md", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/30a42faa1c42ce5988241d3af993921246954b1a/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/30a42faa1c42ce5988241d3af993921246954b1a/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=30a42faa1c42ce5988241d3af993921246954b1a", "patch": "@@ -87,9 +87,11 @@ fetch snapshots, and an OS that can execute the available snapshot binaries.\n \n Snapshot binaries are currently built and tested on several platforms:\n \n-* Windows (7, 8, Server 2008 R2), x86 and x86-64 (64-bit support added in Rust 0.12.0)\n-* Linux (2.6.18 or later, various distributions), x86 and x86-64\n-* OSX 10.7 (Lion) or greater, x86 and x86-64\n+| Platform \\ Architecture        | x86 | x86_64 |\n+|--------------------------------|-----|--------|\n+| Windows (7, 8, Server 2008 R2) | \u2713   | \u2713      |\n+| Linux (2.6.18 or later)        | \u2713   | \u2713      |\n+| OSX (10.7 Lion or later)       | \u2713   | \u2713      |\n \n You may find that other platforms work, but these are our officially\n supported build environments that are most likely to work."}, {"sha": "584f24b54ada504aa7b873fe70c86b03005dae30", "filename": "src/doc/trpl/SUMMARY.md", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/30a42faa1c42ce5988241d3af993921246954b1a/src%2Fdoc%2Ftrpl%2FSUMMARY.md", "raw_url": "https://github.com/rust-lang/rust/raw/30a42faa1c42ce5988241d3af993921246954b1a/src%2Fdoc%2Ftrpl%2FSUMMARY.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2FSUMMARY.md?ref=30a42faa1c42ce5988241d3af993921246954b1a", "patch": "@@ -6,6 +6,8 @@\n     * [Hello, Cargo!](hello-cargo.md)\n * [Learn Rust](learn-rust.md)\n     * [Guessing Game](guessing-game.md)\n+    * [Dining Philosophers](dining-philosophers.md)\n+    * [Rust inside other languages](rust-inside-other-languages.md)\n * [Effective Rust](effective-rust.md)\n     * [The Stack and the Heap](the-stack-and-the-heap.md)\n     * [Testing](testing.md)\n@@ -16,6 +18,7 @@\n     * [Error Handling](error-handling.md)\n     * [FFI](ffi.md)\n     * [Borrow and AsRef](borrow-and-asref.md)\n+    * [Release Channels](release-channels.md)\n * [Syntax and Semantics](syntax-and-semantics.md)\n     * [Variable Bindings](variable-bindings.md)\n     * [Functions](functions.md)\n@@ -28,9 +31,9 @@\n     * [References and Borrowing](references-and-borrowing.md)\n     * [Lifetimes](lifetimes.md)\n     * [Mutability](mutability.md)\n+    * [Structs](structs.md)\n     * [Enums](enums.md)\n     * [Match](match.md)\n-    * [Structs](structs.md)\n     * [Patterns](patterns.md)\n     * [Method Syntax](method-syntax.md)\n     * [Vectors](vectors.md)\n@@ -44,7 +47,6 @@\n     * [Universal Function Call Syntax](ufcs.md)\n     * [Crates and Modules](crates-and-modules.md)\n     * [`const` and `static`](const-and-static.md)\n-    * [Tuple Structs](tuple-structs.md)\n     * [Attributes](attributes.md)\n     * [`type` aliases](type-aliases.md)\n     * [Casting between types](casting-between-types.md)"}, {"sha": "b1bea4f819ef4b0120759fbf1bbd716db4efcfcf", "filename": "src/doc/trpl/dining-philosophers.md", "status": "added", "additions": 690, "deletions": 0, "changes": 690, "blob_url": "https://github.com/rust-lang/rust/blob/30a42faa1c42ce5988241d3af993921246954b1a/src%2Fdoc%2Ftrpl%2Fdining-philosophers.md", "raw_url": "https://github.com/rust-lang/rust/raw/30a42faa1c42ce5988241d3af993921246954b1a/src%2Fdoc%2Ftrpl%2Fdining-philosophers.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fdining-philosophers.md?ref=30a42faa1c42ce5988241d3af993921246954b1a", "patch": "@@ -0,0 +1,690 @@\n+% Dining Philosophers\n+\n+For our second project, let\u2019s look at a classic concurrency problem. It\u2019s\n+called \u2018the dining philosophers\u2019. It was originally conceived by Dijkstra in\n+1965, but we\u2019ll use the version from [this paper][paper] by Tony Hoare in 1985.\n+\n+[paper]: http://www.usingcsp.com/cspbook.pdf\n+\n+> In ancient times, a wealthy philanthropist endowed a College to accommodate\n+> five eminent philosophers. Each philosopher had a room in which he could\n+> engage in his professional activity of thinking; there was also a common\n+> dining room, furnished with a circular table, surrounded by five chairs, each\n+> labelled by the name of the philosopher who was to sit in it. They sat\n+> anticlockwise around the table. To the left of each philosopher there was\n+> laid a golden fork, and in the centre stood a large bowl of spaghetti, which\n+> was constantly replenished. A philosopher was expected to spend most of his\n+> time thinking; but when he felt hungry, he went to the dining room, sat down\n+> in his own chair, picked up his own fork on his left, and plunged it into the\n+> spaghetti. But such is the tangled nature of spaghetti that a second fork is\n+> required to carry it to the mouth. The philosopher therefore had also to pick\n+> up the fork on his right. When we was finished he would put down both his\n+> forks, get up from his chair, and continue thinking. Of course, a fork can be\n+> used by only one philosopher at a time. If the other philosopher wants it, he\n+> just has to wait until the fork is available again.\n+\n+This classic problem shows off a few different elements of concurrency. The\n+reason is that it's actually slightly tricky to implement: a simple\n+implementation can deadlock. For example, let's consider a simple algorithm\n+that would solve this problem:\n+\n+1. A philosopher picks up the fork on their left.\n+2. They then pick up the fork on their right.\n+3. They eat.\n+4. They return the forks.\n+\n+Now, let\u2019s imagine this sequence of events:\n+\n+1. Philosopher 1 begins the algorithm, picking up the fork on their left.\n+2. Philosopher 2 begins the algorithm, picking up the fork on their left.\n+3. Philosopher 3 begins the algorithm, picking up the fork on their left.\n+4. Philosopher 4 begins the algorithm, picking up the fork on their left.\n+5. Philosopher 5 begins the algorithm, picking up the fork on their left.\n+6. ... ? All the forks are taken, but nobody can eat!\n+\n+There are different ways to solve this problem. We\u2019ll get to our solution in\n+the tutorial itself. For now, let\u2019s get started modelling the problem itself.\n+We\u2019ll start with the philosophers:\n+\n+```rust\n+struct Philosopher {\n+    name: String,\n+}\n+\n+impl Philosopher {\n+    fn new(name: &str) -> Philosopher {\n+        Philosopher {\n+            name: name.to_string(),\n+        }\n+    }\n+}\n+\n+fn main() {\n+    let p1 = Philosopher::new(\"Baruch Spinoza\");\n+    let p2 = Philosopher::new(\"Gilles Deleuze\");\n+    let p3 = Philosopher::new(\"Karl Marx\");\n+    let p4 = Philosopher::new(\"Friedrich Nietzsche\");\n+    let p5 = Philosopher::new(\"Michel Foucault\");\n+}\n+```\n+\n+Here, we make a [`struct`][struct] to represent a philosopher. For now,\n+a name is all we need. We choose the [`String`][string] type for the name,\n+rather than `&str`. Generally speaking, working with a type which owns its\n+data is easier than working with one that uses references.\n+\n+Let\u2019s continue:\n+\n+```rust\n+# struct Philosopher {\n+#     name: String,\n+# }\n+impl Philosopher {\n+    fn new(name: &str) -> Philosopher {\n+        Philosopher {\n+            name: name.to_string(),\n+        }\n+    }\n+}\n+```\n+\n+This `impl` block lets us define things on `Philosopher` structs. In this case,\n+we define an \u2018associated function\u2019 called `new`. The first line looks like this:\n+\n+```rust\n+# struct Philosopher {\n+#     name: String,\n+# }\n+# impl Philosopher {\n+fn new(name: &str) -> Philosopher {\n+#         Philosopher {\n+#             name: name.to_string(),\n+#         }\n+#     }\n+# }\n+```\n+\n+We take one argument, a `name`, of type `&str`. This is a reference to another\n+string. It returns an instance of our `Philosopher` struct.\n+\n+```rust\n+# struct Philosopher {\n+#     name: String,\n+# }\n+# impl Philosopher {\n+#    fn new(name: &str) -> Philosopher {\n+Philosopher {\n+    name: name.to_string(),\n+}\n+#     }\n+# }\n+```\n+\n+This creates a new `Philosopher`, and sets its `name` to our `name` argument.\n+Not just the argument itself, though, as we call `.to_string()` on it. This\n+will create a copy of the string that our `&str` points to, and give us a new\n+`String`, which is the type of the `name` field of `Philosopher`.\n+\n+Why not accept a `String` directly? It\u2019s nicer to call. If we took a `String`,\n+but our caller had a `&str`, they\u2019d have to call this method themselves. The\n+downside of this flexibility is that we _always_ make a copy. For this small\n+program, that\u2019s not particularly important, as we know we\u2019ll just be using\n+short strings anyway.\n+\n+One last thing you\u2019ll notice: we just define a `Philosopher`, and seemingly\n+don\u2019t do anything with it. Rust is an \u2018expression based\u2019 language, which means\n+that almost everything in Rust is an expression which returns a value. This is\n+true of functions as well, the last expression is automatically returned. Since\n+we create a new `Philosopher` as the last expression of this function, we end\n+up returning it.\n+\n+This name, `new()`, isn\u2019t anything special to Rust, but it is a convention for\n+functions that create new instances of structs. Before we talk about why, let\u2019s\n+look at `main()` again:\n+\n+```rust\n+# struct Philosopher {\n+#     name: String,\n+# }\n+# \n+# impl Philosopher {\n+#     fn new(name: &str) -> Philosopher {\n+#         Philosopher {\n+#             name: name.to_string(),\n+#         }\n+#     }\n+# }\n+# \n+fn main() {\n+    let p1 = Philosopher::new(\"Baruch Spinoza\");\n+    let p2 = Philosopher::new(\"Gilles Deleuze\");\n+    let p3 = Philosopher::new(\"Karl Marx\");\n+    let p4 = Philosopher::new(\"Friedrich Nietzsche\");\n+    let p5 = Philosopher::new(\"Michel Foucault\");\n+}\n+```\n+\n+Here, we create five variable bindings with five new philosophers. These are my\n+favorite five, but you can substitute anyone you want. If we _didn\u2019t_ define\n+that `new()` function, it would look like this:\n+\n+```rust\n+# struct Philosopher {\n+#     name: String,\n+# }\n+fn main() {\n+    let p1 = Philosopher { name: \"Baruch Spinoza\".to_string() };\n+    let p2 = Philosopher { name: \"Gilles Deleuze\".to_string() };\n+    let p3 = Philosopher { name: \"Karl Marx\".to_string() };\n+    let p4 = Philosopher { name: \"Friedrich Nietzche\".to_string() };\n+    let p5 = Philosopher { name: \"Michel Foucault\".to_string() };\n+}\n+```\n+\n+That\u2019s much noisier. Using `new` has other advantages too, but even in\n+this simple case, it ends up being nicer to use.\n+\n+Now that we\u2019ve got the basics in place, there\u2019s a number of ways that we can\n+tackle the broader problem here. I like to start from the end first: let\u2019s\n+set up a way for each philosopher to finish eating. As a tiny step, let\u2019s make\n+a method, and then loop through all the philosophers, calling it:\n+\n+```rust\n+struct Philosopher {\n+    name: String,\n+}   \n+\n+impl Philosopher { \n+    fn new(name: &str) -> Philosopher {\n+        Philosopher {\n+            name: name.to_string(),\n+        }\n+    }\n+    \n+    fn eat(&self) {\n+        println!(\"{} is done eating.\", self.name);\n+    }\n+}\n+\n+fn main() {\n+    let philosophers = vec![\n+        Philosopher::new(\"Baruch Spinoza\"),\n+        Philosopher::new(\"Gilles Deleuze\"),\n+        Philosopher::new(\"Karl Marx\"),\n+        Philosopher::new(\"Friedrich Nietzsche\"),\n+        Philosopher::new(\"Michel Foucault\"),\n+    ];\n+\n+    for p in &philosophers {\n+        p.eat();\n+    }\n+}\n+```\n+\n+Let\u2019s look at `main()` first. Rather than have five individual variable\n+bindings for our philosophers, we make a `Vec<T>` of them instead. `Vec<T>` is\n+also called a \u2018vector\u2019, and it\u2019s a growable array type. We then use a\n+[`for`][for] loop to iterate through the vector, getting a reference to each\n+philosopher in turn.\n+\n+[for]: for-loops.html\n+\n+In the body of the loop, we call `p.eat()`, which is defined above:\n+\n+```rust,ignore\n+fn eat(&self) {\n+    println!(\"{} is done eating.\", self.name);\n+}\n+```\n+\n+In Rust, methods take an explicit `self` parameter. That\u2019s why `eat()` is a\n+method, but `new` is an associated function: `new()` has no `self`. For our\n+first version of `eat()`, we just print out the name of the philosopher, and\n+mention they\u2019re done eating. Running this program should give you the following\n+output:\n+\n+```text\n+Baruch Spinoza is done eating.\n+Gilles Deleuze is done eating.\n+Karl Marx is done eating.\n+Friedrich Nietzsche is done eating.\n+Michel Foucault is done eating.\n+```\n+\n+Easy enough, they\u2019re all done! We haven\u2019t actually implemented the real problem\n+yet, though, so we\u2019re not done yet!\n+\n+Next, we want to make our philosophers not just finish eating, but actually\n+eat. Here\u2019s the next version:\n+\n+```rust\n+use std::thread;\n+\n+struct Philosopher {\n+    name: String,\n+}   \n+\n+impl Philosopher { \n+    fn new(name: &str) -> Philosopher {\n+        Philosopher {\n+            name: name.to_string(),\n+        }\n+    }\n+    \n+    fn eat(&self) {\n+        println!(\"{} is eating.\", self.name);\n+\n+        thread::sleep_ms(1000);\n+\n+        println!(\"{} is done eating.\", self.name);\n+    }\n+}\n+\n+fn main() {\n+    let philosophers = vec![\n+        Philosopher::new(\"Baruch Spinoza\"),\n+        Philosopher::new(\"Gilles Deleuze\"),\n+        Philosopher::new(\"Karl Marx\"),\n+        Philosopher::new(\"Friedrich Nietzsche\"),\n+        Philosopher::new(\"Michel Foucault\"),\n+    ];\n+\n+    for p in &philosophers {\n+        p.eat();\n+    }\n+}\n+```\n+\n+Just a few changes. Let\u2019s break it down.\n+\n+```rust,ignore\n+use std::thread;\n+```\n+\n+`use` brings names into scope. We\u2019re going to start using the `thread` module\n+from the standard library, and so we need to `use` it.\n+\n+```rust,ignore\n+    fn eat(&self) {\n+        println!(\"{} is eating.\", self.name);\n+\n+        thread::sleep_ms(1000);\n+\n+        println!(\"{} is done eating.\", self.name);\n+    }\n+```\n+\n+We now print out two messages, with a `sleep_ms()` in the middle. This will\n+simulate the time it takes a philosopher to eat.\n+\n+If you run this program, You should see each philosopher eat in turn:\n+\n+```text\n+Baruch Spinoza is eating.\n+Baruch Spinoza is done eating.\n+Gilles Deleuze is eating.\n+Gilles Deleuze is done eating.\n+Karl Marx is eating.\n+Karl Marx is done eating.\n+Friedrich Nietzsche is eating.\n+Friedrich Nietzsche is done eating.\n+Michel Foucault is eating.\n+Michel Foucault is done eating.\n+```\n+\n+Excellent! We\u2019re getting there. There\u2019s just one problem: we aren\u2019t actually\n+operating in a concurrent fashion, which is a core part of the problem!\n+\n+To make our philosophers eat concurrently, we need to make a small change.\n+Here\u2019s the next iteration:\n+\n+```rust\n+use std::thread;\n+\n+struct Philosopher {\n+    name: String,\n+}   \n+\n+impl Philosopher { \n+    fn new(name: &str) -> Philosopher {\n+        Philosopher {\n+            name: name.to_string(),\n+        }\n+    }\n+\n+    fn eat(&self) {\n+        println!(\"{} is eating.\", self.name);\n+\n+        thread::sleep_ms(1000);\n+\n+        println!(\"{} is done eating.\", self.name);\n+    }\n+}\n+\n+fn main() {\n+    let philosophers = vec![\n+        Philosopher::new(\"Baruch Spinoza\"),\n+        Philosopher::new(\"Gilles Deleuze\"),\n+        Philosopher::new(\"Karl Marx\"),\n+        Philosopher::new(\"Friedrich Nietzsche\"),\n+        Philosopher::new(\"Michel Foucault\"),\n+    ];\n+\n+    let handles: Vec<_> = philosophers.into_iter().map(|p| {\n+        thread::spawn(move || {\n+            p.eat();\n+        })\n+    }).collect();\n+\n+    for h in handles {\n+        h.join().unwrap();\n+    }\n+}\n+```\n+\n+All we\u2019ve done is change the loop in `main()`, and added a second one! Here\u2019s the\n+first change:\n+\n+```rust,ignore\n+let handles: Vec<_> = philosophers.into_iter().map(|p| {\n+    thread::spawn(move || {\n+        p.eat();\n+    })\n+}).collect();\n+```\n+\n+While this is only five lines, they\u2019re a dense four. Let\u2019s break it down.\n+\n+```rust,ignore\n+let handles: Vec<_> = \n+```\n+\n+We introduce a new binding, called `handles`. We\u2019ve given it this name because\n+we are going to make some new threads, and that will return some handles to those\n+threads that let us control their operation. We need to explicitly annotate\n+the type here, though, due to an issue we\u2019ll talk about later. The `_` is\n+a type placeholder. We\u2019re saying \u201c`handles` is a vector of something, but you\n+can figure out what that something is, Rust.\u201d\n+\n+```rust,ignore\n+philosophers.into_iter().map(|p| {\n+```\n+\n+We take our list of philosophers and call `into_iter()` on it. This creates an\n+iterator that takes ownership of each philosopher. We need to do this to pass\n+them to our threads. We take that iterator and call `map` on it, which takes a\n+closure as an argument and calls that closure on each element in turn.\n+\n+```rust,ignore\n+    thread::spawn(move || {\n+        p.eat();\n+    })\n+```\n+\n+Here\u2019s where the concurrency happens. The `thread::spawn` function takes a closure\n+as an argument and executes that closure in a new thread. This closure needs\n+an extra annotation, `move`, to indicate that the closure is going to take\n+ownership of the values it\u2019s capturing. Primarily, the `p` variable of the\n+`map` function.\n+\n+Inside the thread, all we do is call `eat()` on `p`.\n+\n+```rust,ignore\n+}).collect();\n+```\n+\n+Finally, we take the result of all those `map` calls and collect them up.\n+`collect()` will make them into a collection of some kind, which is why we\n+needed to annotate the return type: we want a `Vec<T>`. The elements are the\n+return values of the `thread::spawn` calls, which are handles to those threads.\n+Whew!\n+\n+```rust,ignore\n+for h in handles {\n+    h.join().unwrap();\n+}\n+```\n+\n+At the end of `main()`, we loop through the handles and call `join()` on them,\n+which blocks execution until the thread has completed execution. This ensures\n+that the threads complete their work before the program exits.\n+\n+If you run this program, you\u2019ll see that the philosophers eat out of order!\n+We have mult-threading!\n+\n+```text\n+Gilles Deleuze is eating.\n+Gilles Deleuze is done eating.\n+Friedrich Nietzsche is eating.\n+Friedrich Nietzsche is done eating.\n+Michel Foucault is eating.\n+Baruch Spinoza is eating.\n+Baruch Spinoza is done eating.\n+Karl Marx is eating.\n+Karl Marx is done eating.\n+Michel Foucault is done eating.\n+```\n+\n+But what about the forks? We haven\u2019t modeled them at all yet.\n+\n+To do that, let\u2019s make a new `struct`:\n+\n+```rust\n+use std::sync::Mutex;\n+\n+struct Table {\n+    forks: Vec<Mutex<()>>,\n+}\n+```\n+\n+This `Table` has an vector of `Mutex`es. A mutex is a way to control\n+concurrency: only one thread can access the contents at once. This is exactly\n+the property we need with our forks. We use an empty tuple, `()`, inside the\n+mutex, since we\u2019re not actually going to use the value, just hold onto it.\n+\n+Let\u2019s modify the program to use the `Table`:\n+\n+```rust\n+use std::thread;\n+use std::sync::{Mutex, Arc};\n+\n+struct Philosopher {\n+    name: String,\n+    left: usize,\n+    right: usize,\n+}\n+\n+impl Philosopher {\n+    fn new(name: &str, left: usize, right: usize) -> Philosopher {\n+        Philosopher {\n+            name: name.to_string(),\n+            left: left,\n+            right: right,\n+        }\n+    }\n+\n+    fn eat(&self, table: &Table) {\n+        let _left = table.forks[self.left].lock().unwrap();\n+        let _right = table.forks[self.right].lock().unwrap();\n+\n+        println!(\"{} is eating.\", self.name);\n+\n+        thread::sleep_ms(1000);\n+\n+        println!(\"{} is done eating.\", self.name);\n+    }\n+}\n+\n+struct Table {\n+    forks: Vec<Mutex<()>>,\n+}\n+\n+fn main() {\n+    let table = Arc::new(Table { forks: vec![\n+        Mutex::new(()),\n+        Mutex::new(()),\n+        Mutex::new(()),\n+        Mutex::new(()),\n+        Mutex::new(()),\n+    ]});\n+\n+    let philosophers = vec![\n+        Philosopher::new(\"Baruch Spinoza\", 0, 1),\n+        Philosopher::new(\"Gilles Deleuze\", 1, 2),\n+        Philosopher::new(\"Karl Marx\", 2, 3),\n+        Philosopher::new(\"Friedrich Nietzsche\", 3, 4),\n+        Philosopher::new(\"Michel Foucault\", 0, 4),\n+    ];\n+\n+    let handles: Vec<_> = philosophers.into_iter().map(|p| {\n+        let table = table.clone();\n+\n+        thread::spawn(move || {\n+            p.eat(&table);\n+        })\n+    }).collect();\n+\n+    for h in handles {\n+        h.join().unwrap();\n+    }\n+}\n+```\n+\n+Lots of changes! However, with this iteration, we\u2019ve got a working program.\n+Let\u2019s go over the details:\n+\n+```rust,ignore\n+use std::sync::{Mutex, Arc};\n+```\n+\n+We\u2019re going to use another structure from the `std::sync` package: `Arc<T>`.\n+We\u2019ll talk more about it when we use it.\n+\n+```rust,ignore\n+struct Philosopher {\n+    name: String,\n+    left: usize,\n+    right: usize,\n+}\n+```\n+\n+We need to add two more fields to our `Philosopher`. Each philosopher is going\n+to have two forks: the one on their left, and the one on their right.\n+We\u2019ll use the `usize` type to indicate them, as it\u2019s the type that you index\n+vectors with. These two values will be the indexes into the `forks` our `Table`\n+has.\n+\n+```rust,ignore\n+fn new(name: &str, left: usize, right: usize) -> Philosopher {\n+    Philosopher {\n+        name: name.to_string(),\n+        left: left,\n+        right: right,\n+    }\n+}\n+```\n+\n+We now need to construct those `left` and `right` values, so we add them to\n+`new()`.\n+\n+```rust,ignore\n+fn eat(&self, table: &Table) {\n+    let _left = table.forks[self.left].lock().unwrap();\n+    let _right = table.forks[self.right].lock().unwrap();\n+\n+    println!(\"{} is eating.\", self.name);\n+\n+    thread::sleep_ms(1000);\n+\n+    println!(\"{} is done eating.\", self.name);\n+}\n+```\n+\n+We have two new lines. We\u2019ve also added an argument, `table`. We access the\n+`Table`\u2019s list of forks, and then use `self.left` and `self.right` to access\n+the fork at that particular index. That gives us access to the `Mutex` at that\n+index, and we call `lock()` on it. If the mutex is currently being accessed by\n+someone else, we\u2019ll block until it becomes available.\n+\n+The call to `lock()` might fail, and if it does, we want to crash. In this\n+case, the error that could happen is that the mutex is [\u2018poisoned\u2019][poison],\n+which is what happens when the thread panics while the lock is held. Since this\n+shouldn\u2019t happen, we just use `unwrap()`.\n+\n+[poison]: ../std/sync/struct.Mutex.html#poisoning\n+\n+One other odd thing about these lines: we\u2019ve named the results `_left` and\n+`_right`. What\u2019s up with that underscore? Well, we aren\u2019t planning on\n+_using_ the value inside the lock. We just want to acquire it. As such,\n+Rust will warn us that we never use the value. By using the underscore,\n+we tell Rust that this is what we intended, and it won\u2019t throw a warning.\n+\n+What about releasing the lock? Well, that will happen when `_left` and\n+`_right` go out of scope, automatically.\n+\n+```rust,ignore\n+    let table = Arc::new(Table { forks: vec![\n+        Mutex::new(()),\n+        Mutex::new(()),\n+        Mutex::new(()),\n+        Mutex::new(()),\n+        Mutex::new(()),\n+    ]});\n+```\n+\n+Next, in `main()`, we make a new `Table` and wrap it in an `Arc<T>`.\n+\u2018arc\u2019 stands for \u2018atomic reference count\u2019, and we need that to share\n+our `Table` across multiple threads. As we share it, the reference\n+count will go up, and when each thread ends, it will go back down.\n+\n+\n+```rust,ignore\n+let philosophers = vec![\n+    Philosopher::new(\"Baruch Spinoza\", 0, 1),\n+    Philosopher::new(\"Gilles Deleuze\", 1, 2),\n+    Philosopher::new(\"Karl Marx\", 2, 3),\n+    Philosopher::new(\"Friedrich Nietzsche\", 3, 4),\n+    Philosopher::new(\"Michel Foucault\", 0, 4),\n+];\n+```\n+\n+We need to pass in our `left` and `right` values to the constructors for our\n+`Philosopher`s. But there\u2019s one more detail here, and it\u2019s _very_ important. If\n+you look at the pattern, it\u2019s all consistent until the very end. Monsieur\n+Foucault should have `4, 0` as arguments, but instead, has `0, 4`. This is what\n+prevents deadlock, actually: one of our philosophers is left handed! This is\n+one way to solve the problem, and in my opinion, it\u2019s the simplest.\n+\n+```rust,ignore\n+let handles: Vec<_> = philosophers.into_iter().map(|p| {\n+    let table = table.clone();\n+\n+    thread::spawn(move || {\n+        p.eat(&table);\n+    })\n+}).collect();\n+```\n+\n+Finally, inside of our `map()`/`collect()` loop, we call `table.clone()`. The\n+`clone()` method on `Arc<T>` is what bumps up the reference count, and when it\n+goes out of scope, it decrements the count. You\u2019ll notice we can introduce a\n+new binding to `table` here, and it will shadow the old one. This is often used\n+so that you don\u2019t need to come up with two unique names.\n+\n+With this, our program works! Only two philosophers can eat at any one time,\n+and so you\u2019ll get some output like this:\n+\n+```text\n+Gilles Deleuze is eating.\n+Friedrich Nietzsche is eating.\n+Friedrich Nietzsche is done eating.\n+Gilles Deleuze is done eating.\n+Baruch Spinoza is eating.\n+Karl Marx is eating.\n+Baruch Spinoza is done eating.\n+Michel Foucault is eating.\n+Karl Marx is done eating.\n+Michel Foucault is done eating.\n+```\n+\n+Congrats! You\u2019ve implemented a classic concurrency problem in Rust."}, {"sha": "8bc25ef90d382391c45af0682a29d69d3abcf279", "filename": "src/doc/trpl/drop.md", "status": "modified", "additions": 66, "deletions": 2, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/30a42faa1c42ce5988241d3af993921246954b1a/src%2Fdoc%2Ftrpl%2Fdrop.md", "raw_url": "https://github.com/rust-lang/rust/raw/30a42faa1c42ce5988241d3af993921246954b1a/src%2Fdoc%2Ftrpl%2Fdrop.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fdrop.md?ref=30a42faa1c42ce5988241d3af993921246954b1a", "patch": "@@ -1,3 +1,67 @@\n-% `Drop`\n+% Drop\n \n-Coming soon!\n+Now that we\u2019ve discussed traits, let\u2019s talk about a particular trait provided\n+by the Rust standard library, [`Drop`][drop]. The `Drop` trait provides a way\n+to run some code when a value goes out of scope. For example:\n+\n+[drop]: ../std/ops/trait.Drop.html\n+\n+```rust\n+struct HasDrop;\n+\n+impl Drop for HasDrop {\n+    fn drop(&mut self) {\n+        println!(\"Dropping!\");\n+    }\n+}\n+\n+fn main() {\n+    let x = HasDrop;\n+\n+    // do stuff\n+\n+} // x goes out of scope here\n+```\n+\n+When `x` goes out of scope at the end of `main()`, the code for `Drop` will\n+run. `Drop` has one method, which is also called `drop()`. It takes a mutable\n+reference to `self`.\n+\n+That\u2019s it! The mechanics of `Drop` are very simple, but there are some\n+subtleties. For example, values are dropped in the opposite order they are\n+declared. Here\u2019s another example:\n+\n+```rust\n+struct Firework {\n+    strength: i32,\n+}\n+\n+impl Drop for Firework {\n+    fn drop(&mut self) {\n+        println!(\"BOOM times {}!!!\", self.strength);\n+    }\n+}\n+\n+fn main() {\n+    let firecracker = Firework { strength: 1 };\n+    let tnt = Firework { strength: 100 };\n+}\n+```\n+\n+This will output:\n+\n+```text\n+BOOM times 100!!!\n+BOOM times 1!!!\n+```\n+\n+The TNT goes off before the firecracker does, because it was declared\n+afterwards. Last in, first out.\n+\n+So what is `Drop` good for? Generally, `Drop` is used to clean up any resources\n+associated with a `struct`. For example, the [`Arc<T>` type][arc] is a\n+reference-counted type. When `Drop` is called, it will decrement the reference\n+count, and if the total number of references is zero, will clean up the\n+underlying value.\n+\n+[arc]: ../std/sync/struct.Arc.html"}, {"sha": "ad15d19eae1433804f3dbc3e5fcd624617591262", "filename": "src/doc/trpl/enums.md", "status": "modified", "additions": 43, "deletions": 43, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/30a42faa1c42ce5988241d3af993921246954b1a/src%2Fdoc%2Ftrpl%2Fenums.md", "raw_url": "https://github.com/rust-lang/rust/raw/30a42faa1c42ce5988241d3af993921246954b1a/src%2Fdoc%2Ftrpl%2Fenums.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fenums.md?ref=30a42faa1c42ce5988241d3af993921246954b1a", "patch": "@@ -1,62 +1,62 @@\n % Enums\n \n-Rust has a \u2018sum type\u2019, an `enum`. Enums are an incredibly useful feature of\n-Rust, and are used throughout the standard library. An `enum` is a type which\n-relates a set of alternates to a specific name. For example, below we define\n-`Character` to be either a `Digit` or something else.\n+An `enum` in Rust is a type that represents data that could be one of\n+several possible variants:\n \n ```rust\n-enum Character {\n-    Digit(i32),\n-    Other,\n+enum Message {\n+    Quit,\n+    ChangeColor(i32, i32, i32),\n+    Move { x: i32, y: i32 },\n+    Write(String),\n }\n ```\n \n-Most types are allowed as the variant components of an `enum`. Here are some\n-examples:\n+Each variant can optionally have data associated with it. The syntax for\n+defining variants resembles the syntaxes used to define structs: you can\n+have variants with no data (like unit-like structs), variants with named\n+data, and variants with unnamed data (like tuple structs). Unlike\n+separate struct definitions, however, an `enum` is a single type. A\n+value of the enum can match any of the variants. For this reason, an\n+enum is sometimes called a \u2018sum type\u2019: the set of possible values of the\n+enum is the sum of the sets of possible values for each variant.\n \n-```rust\n-struct Empty;\n-struct Color(i32, i32, i32);\n-struct Length(i32);\n-struct Stats { Health: i32, Mana: i32, Attack: i32, Defense: i32 }\n-struct HeightDatabase(Vec<i32>);\n-```\n-\n-You see that, depending on its type, an `enum` variant may or may not hold data.\n-In `Character`, for instance, `Digit` gives a meaningful name for an `i32`\n-value, where `Other` is only a name. However, the fact that they represent\n-distinct categories of `Character` is a very useful property.\n-\n-The variants of an `enum` by default are not comparable with equality operators\n-(`==`, `!=`), have no ordering (`<`, `>=`, etc.), and do not support other\n-binary operations such as `*` and `+`. As such, the following code is invalid\n-for the example `Character` type:\n-\n-```rust,ignore\n-// These assignments both succeed\n-let ten  = Character::Digit(10);\n-let four = Character::Digit(4);\n+We use the `::` syntax to use the name of each variant: they\u2019re scoped by the name\n+of the `enum` itself. This allows both of these to work:\n \n-// Error: `*` is not implemented for type `Character`\n-let forty = ten * four;\n+```rust\n+# enum Message {\n+#     Move { x: i32, y: i32 },\n+# }\n+let x: Message = Message::Move { x: 3, y: 4 };\n \n-// Error: `<=` is not implemented for type `Character`\n-let four_is_smaller = four <= ten;\n+enum BoardGameTurn {\n+    Move { squares: i32 },\n+    Pass,\n+}\n \n-// Error: `==` is not implemented for type `Character`\n-let four_equals_ten = four == ten;\n+let y: BoardGameTurn = BoardGameTurn::Move { squares: 1 };\n ```\n \n-We use the `::` syntax to use the name of each variant: They\u2019re scoped by the name\n-of the `enum` itself. This allows both of these to work:\n+Both variants are named `Move`, but since they\u2019re scoped to the name of\n+the enum, they can both be used without conflict.\n+\n+A value of an enum type contains information about which variant it is,\n+in addition to any data associated with that variant. This is sometimes\n+referred to as a \u2018tagged union\u2019, since the data includes a \u2018tag\u2019\n+indicating what type it is. The compiler uses this information to\n+enforce that you\u2019re accessing the data in the enum safely. For instance,\n+you can\u2019t simply try to destructure a value as if it were one of the\n+possible variants:\n \n ```rust,ignore\n-Character::Digit(10);\n-Hand::Digit;\n+fn process_color_change(msg: Message) {\n+    let Message::ChangeColor(r, g, b) = msg; // compile-time error\n+}\n ```\n \n-Both variants are named `Digit`, but since they\u2019re scoped to the `enum` name,\n+Both variants are named `Digit`, but since they\u2019re scoped to the `enum` name\n+there's no ambiguity.\n \n Not supporting these operations may seem rather limiting, but it\u2019s a limitation\n which we can overcome. There are two ways: by implementing equality ourselves,\n@@ -65,4 +65,4 @@ learn in the next section. We don\u2019t know enough about Rust to implement\n equality yet, but we\u2019ll find out in the [`traits`][traits] section.\n \n [match]: match.html\n-[traits]: traits.html\n+[if-let]: if-let.html"}, {"sha": "b3689968b7fd1cacfb2e6ec79616e884c5ad6a2e", "filename": "src/doc/trpl/error-handling.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/30a42faa1c42ce5988241d3af993921246954b1a/src%2Fdoc%2Ftrpl%2Ferror-handling.md", "raw_url": "https://github.com/rust-lang/rust/raw/30a42faa1c42ce5988241d3af993921246954b1a/src%2Fdoc%2Ftrpl%2Ferror-handling.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Ferror-handling.md?ref=30a42faa1c42ce5988241d3af993921246954b1a", "patch": "@@ -204,7 +204,7 @@ Because these kinds of situations are relatively rare, use panics sparingly.\n \n In certain circumstances, even though a function may fail, we may want to treat\n it as a panic instead. For example, `io::stdin().read_line(&mut buffer)` returns\n-an `Result<usize>`, when there is an error reading the line. This allows us to\n+a `Result<usize>`, when there is an error reading the line. This allows us to\n handle and possibly recover from error.\n \n If we don't want to handle this error, and would rather just abort the program,"}, {"sha": "e0cc45c254b9974c32538223cf568f7dafe8d8ef", "filename": "src/doc/trpl/iterators.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/30a42faa1c42ce5988241d3af993921246954b1a/src%2Fdoc%2Ftrpl%2Fiterators.md", "raw_url": "https://github.com/rust-lang/rust/raw/30a42faa1c42ce5988241d3af993921246954b1a/src%2Fdoc%2Ftrpl%2Fiterators.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fiterators.md?ref=30a42faa1c42ce5988241d3af993921246954b1a", "patch": "@@ -212,9 +212,9 @@ see why consumers matter.\n As we've said before, an iterator is something that we can call the\n `.next()` method on repeatedly, and it gives us a sequence of things.\n Because you need to call the method, this means that iterators\n-are *lazy* and don't need to generate all of the values upfront.\n-This code, for example, does not actually generate the numbers\n-`1-100`, and just creates a value that represents the sequence:\n+can be *lazy* and not generate all of the values upfront. This code,\n+for example, does not actually generate the numbers `1-100`, instead\n+creating a value that merely represents the sequence:\n \n ```rust\n let nums = 1..100;"}, {"sha": "342de413f0b9aab34a72de6036002bf3d8e677f1", "filename": "src/doc/trpl/lifetimes.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/30a42faa1c42ce5988241d3af993921246954b1a/src%2Fdoc%2Ftrpl%2Flifetimes.md", "raw_url": "https://github.com/rust-lang/rust/raw/30a42faa1c42ce5988241d3af993921246954b1a/src%2Fdoc%2Ftrpl%2Flifetimes.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Flifetimes.md?ref=30a42faa1c42ce5988241d3af993921246954b1a", "patch": "@@ -41,7 +41,7 @@ With that in mind, let\u2019s learn about lifetimes.\n # Lifetimes\n \n Lending out a reference to a resource that someone else owns can be\n-complicated, however. For example, imagine this set of operations:\n+complicated. For example, imagine this set of operations:\n \n - I acquire a handle to some kind of resource.\n - I lend you a reference to the resource."}, {"sha": "2bb2359ba5a01f82b98af858b81f2303d0bd7aaa", "filename": "src/doc/trpl/match.md", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/30a42faa1c42ce5988241d3af993921246954b1a/src%2Fdoc%2Ftrpl%2Fmatch.md", "raw_url": "https://github.com/rust-lang/rust/raw/30a42faa1c42ce5988241d3af993921246954b1a/src%2Fdoc%2Ftrpl%2Fmatch.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fmatch.md?ref=30a42faa1c42ce5988241d3af993921246954b1a", "patch": "@@ -61,3 +61,40 @@ let number = match x {\n ```\n \n Sometimes it\u2019s a nice way of converting something from one type to another.\n+\n+# Matching on enums\n+\n+Another important use of the `match` keyword is to process the possible\n+variants of an enum:\n+\n+```rust\n+enum Message {\n+    Quit,\n+    ChangeColor(i32, i32, i32),\n+    Move { x: i32, y: i32 },\n+    Write(String),\n+}\n+\n+fn quit() { /* ... */ }\n+fn change_color(r: i32, g: i32, b: i32) { /* ... */ }\n+fn move_cursor(x: i32, y: i32) { /* ... */ }\n+\n+fn process_message(msg: Message) {\n+    match msg {\n+        Message::Quit => quit(),\n+        Message::ChangeColor(r, g, b) => change_color(r, g, b),\n+        Message::Move { x: x, y: y } => move_cursor(x, y),\n+        Message::Write(s) => println!(\"{}\", s),\n+    };\n+}\n+```\n+\n+Again, the Rust compiler checks exhaustiveness, so it demands that you\n+have a match arm for every variant of the enum. If you leave one off, it\n+will give you a compile-time error unless you use `_`.\n+\n+Unlike the previous uses of `match`, you can\u2019t use the normal `if`\n+statement to do this. You can use the [`if let`][if-let] statement,\n+which can be seen as an abbreviated form of `match`.\n+\n+[if-let][if-let.html]"}, {"sha": "0ba2b33759cd518cde8964bcc2bc335f5705dde0", "filename": "src/doc/trpl/ownership.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/30a42faa1c42ce5988241d3af993921246954b1a/src%2Fdoc%2Ftrpl%2Fownership.md", "raw_url": "https://github.com/rust-lang/rust/raw/30a42faa1c42ce5988241d3af993921246954b1a/src%2Fdoc%2Ftrpl%2Fownership.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fownership.md?ref=30a42faa1c42ce5988241d3af993921246954b1a", "patch": "@@ -107,7 +107,7 @@ println!(\"v[0] is: {}\", v[0]);\n ```\n \n Same error: \u2018use of moved value\u2019. When we transfer ownership to something else,\n-we say that we\u2019ve \u2018moved\u2019 the thing we refer to. You don\u2019t need any sort of\n+we say that we\u2019ve \u2018moved\u2019 the thing we refer to. You don\u2019t need some sort of\n special annotation here, it\u2019s the default thing that Rust does.\n \n ## The details"}, {"sha": "d3bf61434c9e5c75c63f649d9ffe2e2154019c49", "filename": "src/doc/trpl/primitive-types.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/30a42faa1c42ce5988241d3af993921246954b1a/src%2Fdoc%2Ftrpl%2Fprimitive-types.md", "raw_url": "https://github.com/rust-lang/rust/raw/30a42faa1c42ce5988241d3af993921246954b1a/src%2Fdoc%2Ftrpl%2Fprimitive-types.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fprimitive-types.md?ref=30a42faa1c42ce5988241d3af993921246954b1a", "patch": "@@ -82,7 +82,7 @@ Let\u2019s go over them by category:\n Integer types come in two varieties: signed and unsigned. To understand the\n difference, let\u2019s consider a number with four bits of size. A signed, four-bit\n number would let you store numbers from `-8` to `+7`. Signed numbers use\n-\u201ctwo\u2019s compliment representation\u201d. An unsigned four bit number, since it does\n+\u201ctwo\u2019s complement representation\u201d. An unsigned four bit number, since it does\n not need to store negatives, can store values from `0` to `+15`.\n \n Unsigned types use a `u` for their category, and signed types use `i`. The `i`"}, {"sha": "03e65539a20429e4ba50c2880e63224315ff4b42", "filename": "src/doc/trpl/release-channels.md", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/30a42faa1c42ce5988241d3af993921246954b1a/src%2Fdoc%2Ftrpl%2Frelease-channels.md", "raw_url": "https://github.com/rust-lang/rust/raw/30a42faa1c42ce5988241d3af993921246954b1a/src%2Fdoc%2Ftrpl%2Frelease-channels.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Frelease-channels.md?ref=30a42faa1c42ce5988241d3af993921246954b1a", "patch": "@@ -0,0 +1,45 @@\n+% Release Channels\n+\n+The Rust project uses a concept called \u2018release channels\u2019 to manage releases.\n+It\u2019s important to understand this process to choose which version of Rust\n+your project should use.\n+\n+# Overview\n+\n+There are three channels for Rust releases:\n+\n+* Nightly\n+* Beta\n+* Stable\n+\n+New nightly releases are created once a day. Every six weeks, the latest\n+nightly release is promoted to \u2018Beta\u2019. At that point, it will only receive\n+patches to fix serious errors. Six weeks later, the beta is promoted to\n+\u2018Stable\u2019, and becomes the next release of `1.x`.\n+\n+This process happens in parallel. So every six weeks, on the same day,\n+nightly goes to beta, beta goes to stable. When `1.x` is released, at\n+the same time, `1.(x + 1)-beta` is released, and the nightly becomes the\n+first version of `1.(x + 2)-nightly`.\n+\n+# Choosing a version\n+\n+Generally speaking, unless you have a specific reason, you should be using the\n+stable release channel. These releases are intended for a general audience.\n+\n+However, depending on your interest in Rust, you may choose to use nightly\n+instead. The basic tradeoff is this: in the nightly channel, you can use\n+unstable, new Rust features. However, unstable features are subject to change,\n+and so any new nightly release may break your code. If you use the stable\n+release, you cannot use experimental features, but the next release of Rust\n+will not cause significant issues through breaking changes.\n+\n+# Helping the ecosystem through CI\n+\n+What about beta? We encourage all Rust users who use the stable release channel\n+to also test against the beta channel in their continuous integration systems.\n+This will help alert the team in case there\u2019s an accidental regression.\n+\n+Additionally, testing against nightly can catch regressions even sooner, and so\n+if you don\u2019t mind a third build, we\u2019d appreciate testing against all channels.\n+"}, {"sha": "a1ae50a0c5396565b4298e0f365d3b04078d9740", "filename": "src/doc/trpl/rust-inside-other-languages.md", "status": "added", "additions": 353, "deletions": 0, "changes": 353, "blob_url": "https://github.com/rust-lang/rust/blob/30a42faa1c42ce5988241d3af993921246954b1a/src%2Fdoc%2Ftrpl%2Frust-inside-other-languages.md", "raw_url": "https://github.com/rust-lang/rust/raw/30a42faa1c42ce5988241d3af993921246954b1a/src%2Fdoc%2Ftrpl%2Frust-inside-other-languages.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Frust-inside-other-languages.md?ref=30a42faa1c42ce5988241d3af993921246954b1a", "patch": "@@ -0,0 +1,353 @@\n+% Rust Inside Other Languages\n+\n+For our third project, we\u2019re going to choose something that shows off one of\n+Rust\u2019s greatest strengths: a lack of a substantial runtime.\n+\n+As organizations grow, they increasingly rely on a multitude of programming\n+languages. Different programming languages have different strengths and\n+weaknesses, and a polyglot stack lets you use a particular language where\n+its strengths make sense, and use a different language where it\u2019s weak.\n+\n+A very common area where many programming languages are weak is in runtime\n+performance of programs. Often, using a language that is slower, but offers\n+greater programmer productivity is a worthwhile trade-off. To help mitigate\n+this, they provide a way to write some of your system in C, and then call\n+the C code as though it were written in the higher-level language. This is\n+called a \u2018foreign function interface\u2019, often shortened to \u2018FFI\u2019.\n+\n+Rust has support for FFI in both directions: it can call into C code easily,\n+but crucially, it can also be called _into_ as easily as C. Combined with\n+Rust\u2019s lack of a garbage collector and low runtime requirements, this makes\n+Rust a great candidate to embed inside of other languages when you need\n+some extra oomph.\n+\n+There is a whole [chapter devoted to FFI][ffi] and its specifics elsewhere in\n+the book, but in this chapter, we\u2019ll examine this particular use-case of FFI,\n+with three examples, in Ruby, Python, and JavaScript.\n+\n+[ffi]: ffi.html\n+\n+# The problem\n+\n+There are many different projects we could choose here, but we\u2019re going to\n+pick an example where Rust has a clear advantage over many other languages:\n+numeric computing and threading.\n+\n+Many languages, for the sake of consistency, place numbers on the heap, rather\n+than on the stack. Especially in languages that focus on object-oriented\n+programming and use garbage collection, heap allocation is the default. Sometimes\n+optimizations can stack allocate particular numbers, but rather than relying\n+on an optimizer to do its job, we may want to ensure that we\u2019re always using\n+primitive number types rather than some sort of object type.\n+\n+Second, many languages have a \u2018global interpreter lock\u2019, which limits\n+concurrency in many situations. This is done in the name of safety, which is\n+a positive effect, but it limits the amount of work that can be done at the\n+same time, which is a big negative.\n+\n+To emphasize these two aspects, we\u2019re going to create a little project that\n+uses these two aspects heavily. Since the focus of the example is the embedding\n+of Rust into the languages, rather than the problem itself, we\u2019ll just use a\n+toy example:\n+\n+> Start ten threads. Inside each thread, count from one to five million. After\n+> All ten threads are finished, print out \u2018done!\u2019.\n+\n+I chose five million based on my particular computer. Here\u2019s an example of this\n+code in Ruby:\n+\n+```ruby\n+threads = []\n+\n+10.times do\n+  threads << Thread.new do\n+    count = 0\n+\n+    5_000_000.times do\n+      count += 1\n+    end\n+  end\n+end\n+\n+threads.each {|t| t.join }\n+puts \"done!\"\n+```\n+\n+Try running this example, and choose a number that runs for a few seconds.\n+Depending on your computer\u2019s hardware, you may have to increase or decrease the\n+number.\n+\n+On my system, running this program takes `2.156` seconds. And, if I use some\n+sort of process monitoring tool, like `top`, I can see that it only uses one\n+core on my machine. That\u2019s the GIL kicking in.\n+\n+While it\u2019s true that this is a synthetic program, one can imagine many problems\n+that are similar to this in the real world. For our purposes, spinning up some\n+busy threads represents some sort of parallel, expensive computation.\n+\n+# A Rust library\n+\n+Let\u2019s re-write this problem in Rust. First, let\u2019s make a new project with\n+Cargo:\n+\n+```bash\n+$ cargo new embed\n+$ cd embed\n+```\n+\n+This program is fairly easy to write in Rust:\n+\n+```rust\n+use std::thread;\n+\n+fn process() {\n+    let handles: Vec<_> = (0..10).map(|_| {\n+        thread::spawn(|| {\n+            let mut _x = 0;\n+            for _ in (0..5_000_001) {\n+                _x += 1\n+            }\n+        })\n+    }).collect();\n+\n+    for h in handles {\n+        h.join().ok().expect(\"Could not join a thread!\");\n+    }\n+}\n+```\n+\n+Some of this should look familiar from previous examples. We spin up ten\n+threads, collecting them into a `handles` vector. Inside of each thread, we\n+loop five million times, and add one to `_x` each time. Why the underscore?\n+Well, if we remove it and compile:\n+\n+```bash\n+$ cargo build\n+   Compiling embed v0.1.0 (file:///home/steve/src/embed)\n+src/lib.rs:3:1: 16:2 warning: function is never used: `process`, #[warn(dead_code)] on by default\n+src/lib.rs:3 fn process() {\n+src/lib.rs:4     let handles: Vec<_> = (0..10).map(|_| {\n+src/lib.rs:5         thread::spawn(|| {\n+src/lib.rs:6             let mut x = 0;\n+src/lib.rs:7             for _ in (0..5_000_001) {\n+src/lib.rs:8                 x += 1\n+             ...\n+src/lib.rs:6:17: 6:22 warning: variable `x` is assigned to, but never used, #[warn(unused_variables)] on by default\n+src/lib.rs:6             let mut x = 0;\n+                             ^~~~~\n+```\n+\n+That first warning is because we are building a library. If we had a test\n+for this function, the warning would go away. But for now, it\u2019s never\n+called.\n+\n+The second is related to `x` versus `_x`. Because we never actually _do_\n+anything with `x`, we get a warning about it. In our case, that\u2019s perfectly\n+okay, as we\u2019re just trying to waste CPU cycles. Prefixing `x` with the\n+underscore removes the warning.\n+\n+Finally, we join on each thread.\n+\n+Right now, however, this is a Rust library, and it doesn\u2019t expose anything\n+that\u2019s callable from C. If we tried to hook this up to another language right\n+now, it wouldn\u2019t work. We only need to make two small changes to fix this,\n+though. The first is modify the beginning of our code:\n+\n+```rust,ignore\n+#[no_mangle]\n+pub extern fn process() {\n+```\n+\n+We have to add a new attribute, `no_mangle`. When you create a Rust library, it\n+changes the name of the function in the compiled output. The reasons for this\n+are outside the scope of this tutorial, but in order for other languages to\n+know how to call the function, we need to not do that. This attribute turns\n+that behavior off.\n+\n+The other change is the `pub extern`. The `pub` means that this function should\n+be callable from outside of this module, and the `extern` says that it should\n+be able to be called from C. That\u2019s it! Not a whole lot of change.\n+\n+The second thing we need to do is to change a setting in our `Cargo.toml`. Add\n+this at the bottom:\n+\n+```toml\n+[lib]\n+name = \"embed\"\n+crate-type = [\"dylib\"]\n+```\n+\n+This tells Rust that we want to compile our library into a standard dynamic\n+library. By default, Rust compiles into an \u2018rlib\u2019, a Rust-specific format.\n+\n+Let\u2019s build the project now:\n+\n+```bash\n+$ cargo build --release\n+   Compiling embed v0.1.0 (file:///home/steve/src/embed)\n+```\n+\n+We\u2019ve chosen `cargo build --release`, which builds with optimizations on. We\n+want this to be as fast as possible! You can find the output of the library in\n+`target/release`:\n+\n+```bash\n+$ ls target/release/\n+build  deps  examples  libembed.so  native\n+```\n+\n+That `libembed.so` is our \u2018shared object\u2019 library. We can use this file\n+just like any shared object library written in C! As an aside, this may be\n+`embed.dll` or `libembed.dylib`, depending on the platform.\n+\n+Now that we\u2019ve got our Rust library built, let\u2019s use it from our Ruby.\n+\n+# Ruby\n+\n+Open up a `embed.rb` file inside of our project, and do this:\n+\n+```ruby\n+require 'ffi'\n+\n+module Hello\n+  extend FFI::Library\n+  ffi_lib 'target/release/libembed.so'\n+  attach_function :process, [], :void\n+end\n+\n+Hello.process\n+\n+puts \"done!\u201d\n+```\n+\n+Before we can run this, we need to install the `ffi` gem:\n+\n+```bash\n+$ gem install ffi # this may need sudo\n+Fetching: ffi-1.9.8.gem (100%)\n+Building native extensions.  This could take a while...\n+Successfully installed ffi-1.9.8\n+Parsing documentation for ffi-1.9.8\n+Installing ri documentation for ffi-1.9.8\n+Done installing documentation for ffi after 0 seconds\n+1 gem installed\n+```\n+\n+And finally, we can try running it:\n+\n+```bash\n+$ ruby embed.rb\n+done!\n+$\n+```\n+\n+Whoah, that was fast! On my system, this took `0.086` seconds, rather than\n+the two seconds the pure Ruby version took. Let\u2019s break down this Ruby\n+code:\n+\n+```ruby\n+require 'ffi'\n+```\n+\n+We first need to require the `ffi` gem. This lets us interface with our\n+Rust library like a C library.\n+\n+```ruby\n+module Hello\n+  extend FFI::Library\n+  ffi_lib 'target/release/libembed.so'\n+```\n+\n+The `ffi` gem\u2019s authors recommend using a module to scope the functions\n+we\u2019ll import from the shared library. Inside, we `extend` the necessary\n+`FFI::Library` module, and then call `ffi_lib` to load up our shared\n+object library. We just pass it the path that our library is stored,\n+which as we saw before, is `target/release/libembed.so`.\n+\n+```ruby\n+attach_function :process, [], :void\n+```\n+\n+The `attach_function` method is provided by the FFI gem. It\u2019s what\n+connects our `process()` function in Rust to a Ruby function of the\n+same name. Since `process()` takes no arguments, the second parameter\n+is an empty array, and since it returns nothing, we pass `:void` as\n+the final argument.\n+\n+```ruby\n+Hello.process\n+```\n+\n+This is the actual call into Rust. The combination of our `module`\n+and the call to `attach_function` sets this all up. It looks like\n+a Ruby function, but is actually Rust!\n+\n+```ruby\n+puts \"done!\"\n+```\n+\n+Finally, as per our project\u2019s requirements, we print out `done!`.\n+\n+That\u2019s it! As we\u2019ve seen, bridging between the two languages is really easy,\n+and buys us a lot of performance.\n+\n+Next, let\u2019s try Python!\n+\n+# Python\n+\n+Create an `embed.py` file in this directory, and put this in it:\n+\n+```python\n+from ctypes import cdll\n+\n+lib = cdll.LoadLibrary(\"target/release/libembed.so\")\n+\n+lib.process()\n+\n+print(\"done!\")\n+```\n+\n+Even easier! We use `cdll` from the `ctypes` module. A quick call\n+to `LoadLibrary` later, and we can call `process()`.\n+\n+On my system, this takes `0.017` seconds. Speedy!\n+\n+# Node.js\n+\n+Node isn\u2019t a language, but it\u2019s currently the dominant implementation of\n+server-side JavaScript.\n+\n+In order to do FFI with Node, we first need to install the library:\n+\n+```bash\n+$ npm install ffi\n+```\n+\n+After that installs, we can use it:\n+\n+```javascript\n+var ffi = require('ffi');\n+\n+var lib = ffi.Library('target/release/libembed', {\n+  'process': [ 'void', []  ]\n+});\n+\n+lib.process();\n+\n+console.log(\"done!\");\n+```\n+\n+It looks more like the Ruby example than the Python example. We use\n+the `ffi` module to get access to `ffi.Library()`, which loads up\n+our shared object. We need to annotate the return type and argument\n+types of the function, which are 'void' for return, and an empty\n+array to signify no arguments. From there, we just call it and\n+print the result.\n+\n+On my system, this takes a quick `0.092` seconds.\n+\n+# Conclusion\n+\n+As you can see, the basics of doing this are _very_ easy. Of course,\n+there's a lot more that we could do here. Check out the [FFI][ffi]\n+chapter for more details."}, {"sha": "ad7ead9319989f2339a5dae9f0b89bb15812ffa4", "filename": "src/doc/trpl/structs.md", "status": "modified", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/30a42faa1c42ce5988241d3af993921246954b1a/src%2Fdoc%2Ftrpl%2Fstructs.md", "raw_url": "https://github.com/rust-lang/rust/raw/30a42faa1c42ce5988241d3af993921246954b1a/src%2Fdoc%2Ftrpl%2Fstructs.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fstructs.md?ref=30a42faa1c42ce5988241d3af993921246954b1a", "patch": "@@ -117,3 +117,82 @@ ones, and it will copy the values you don\u2019t specify:\n let origin = Point3d { x: 0, y: 0, z: 0 };\n let point = Point3d { z: 1, x: 2, .. origin };\n ```\n+\n+# Tuple structs\n+\n+Rust has another data type that\u2019s like a hybrid between a [tuple][tuple] and a\n+struct, called a \u2018tuple struct\u2019. Tuple structs have a name, but\n+their fields don\u2019t:\n+\n+```rust\n+struct Color(i32, i32, i32);\n+struct Point(i32, i32, i32);\n+```\n+\n+[tuple]: primitive-types.html#tuples\n+\n+These two will not be equal, even if they have the same values:\n+\n+```rust\n+# struct Color(i32, i32, i32);\n+# struct Point(i32, i32, i32);\n+let black = Color(0, 0, 0);\n+let origin = Point(0, 0, 0);\n+```\n+\n+It is almost always better to use a struct than a tuple struct. We would write\n+`Color` and `Point` like this instead:\n+\n+```rust\n+struct Color {\n+    red: i32,\n+    blue: i32,\n+    green: i32,\n+}\n+\n+struct Point {\n+    x: i32,\n+    y: i32,\n+    z: i32,\n+}\n+```\n+\n+Now, we have actual names, rather than positions. Good names are important,\n+and with a struct, we have actual names.\n+\n+There _is_ one case when a tuple struct is very useful, though, and that\u2019s a\n+tuple struct with only one element. We call this the \u2018newtype\u2019 pattern, because\n+it allows you to create a new type, distinct from that of its contained value\n+and expressing its own semantic meaning:\n+\n+```rust\n+struct Inches(i32);\n+\n+let length = Inches(10);\n+\n+let Inches(integer_length) = length;\n+println!(\"length is {} inches\", integer_length);\n+```\n+\n+As you can see here, you can extract the inner integer type through a\n+destructuring `let`, just as with regular tuples. In this case, the\n+`let Inches(integer_length)` assigns `10` to `integer_length`.\n+\n+# Unit-like structs\n+\n+You can define a struct with no members at all:\n+\n+```rust\n+struct Electron;\n+```\n+\n+Such a struct is called \u2018unit-like\u2019 because it resembles the empty\n+tuple, `()`, sometimes called \u2018unit\u2019. Like a tuple struct, it defines a\n+new type.\n+\n+This is rarely useful on its own (although sometimes it can serve as a\n+marker type), but in combination with other features, it can become\n+useful. For instance, a library may ask you to create a structure that\n+implements a certain [trait][trait] to handle events. If you don\u2019t have\n+any data you need to store in the structure, you can just create a\n+unit-like struct."}, {"sha": "bdaef70711ae418990568151a86fa624d00f135a", "filename": "src/doc/trpl/tuple-structs.md", "status": "removed", "additions": 0, "deletions": 60, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/c2b30b86df6b34ba19e87e63402e43d9e81a64fb/src%2Fdoc%2Ftrpl%2Ftuple-structs.md", "raw_url": "https://github.com/rust-lang/rust/raw/c2b30b86df6b34ba19e87e63402e43d9e81a64fb/src%2Fdoc%2Ftrpl%2Ftuple-structs.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Ftuple-structs.md?ref=c2b30b86df6b34ba19e87e63402e43d9e81a64fb", "patch": "@@ -1,60 +0,0 @@\n-% Tuple Structs\n-\n-Rust has another data type that's like a hybrid between a [tuple][tuple] and a\n-[struct][struct], called a \u2018tuple struct\u2019. Tuple structs have a name, but\n-their fields don\u2019t:\n-\n-```rust\n-struct Color(i32, i32, i32);\n-struct Point(i32, i32, i32);\n-```\n-\n-[tuple]: primitive-types.html#tuples\n-[struct]: structs.html\n-\n-These two will not be equal, even if they have the same values:\n-\n-```rust\n-# struct Color(i32, i32, i32);\n-# struct Point(i32, i32, i32);\n-let black = Color(0, 0, 0);\n-let origin = Point(0, 0, 0);\n-```\n-\n-It is almost always better to use a struct than a tuple struct. We would write\n-`Color` and `Point` like this instead:\n-\n-```rust\n-struct Color {\n-    red: i32,\n-    blue: i32,\n-    green: i32,\n-}\n-\n-struct Point {\n-    x: i32,\n-    y: i32,\n-    z: i32,\n-}\n-```\n-\n-Now, we have actual names, rather than positions. Good names are important,\n-and with a struct, we have actual names.\n-\n-There _is_ one case when a tuple struct is very useful, though, and that\u2019s a\n-tuple struct with only one element. We call this the \u2018newtype\u2019 pattern, because\n-it allows you to create a new type, distinct from that of its contained value\n-and expressing its own semantic meaning:\n-\n-```rust\n-struct Inches(i32);\n-\n-let length = Inches(10);\n-\n-let Inches(integer_length) = length;\n-println!(\"length is {} inches\", integer_length);\n-```\n-\n-As you can see here, you can extract the inner integer type through a\n-destructuring `let`, as we discussed previously in \u2018tuples\u2019. In this case, the\n-`let Inches(integer_length)` assigns `10` to `integer_length`."}, {"sha": "c0d8d8eacf797f8702c27e1a97f89ea9682cfeb9", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 48, "deletions": 51, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/30a42faa1c42ce5988241d3af993921246954b1a/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30a42faa1c42ce5988241d3af993921246954b1a/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=30a42faa1c42ce5988241d3af993921246954b1a", "patch": "@@ -12,33 +12,36 @@\n //!\n //! The Rust Standard Library provides the essential runtime\n //! functionality for building portable Rust software.\n-//! It is linked to all Rust crates by default.\n //!\n-//! ## Intrinsic types and operations\n+//! The rust standard library is available to all rust crates by\n+//! default, just as if contained an `extern crate std` import at the\n+//! crate root. Therefore the standard library can be accessed in\n+//! `use` statements through the path `std`, as in `use std::thread`,\n+//! or in expressions through the absolute path `::std`, as in\n+//! `::std::thread::sleep_ms(100)`.\n //!\n-//! The [`ptr`](ptr/index.html) and [`mem`](mem/index.html)\n-//! modules deal with unsafe pointers and memory manipulation.\n-//! [`marker`](marker/index.html) defines the special built-in traits,\n-//! and [`raw`](raw/index.html) the runtime representation of Rust types.\n-//! These are some of the lowest-level building blocks in Rust.\n+//! Furthermore, the standard library defines [The Rust\n+//! Prelude](prelude/index.html), a small collection of items, mostly\n+//! traits, that are imported into and available in every module.\n //!\n-//! ## Math on primitive types and math traits\n+//! ## What is in the standard library\n //!\n-//! Although basic operations on primitive types are implemented\n-//! directly by the compiler, the standard library additionally\n-//! defines many common operations through traits defined in\n-//! mod [`num`](num/index.html).\n+//! The standard library is minimal, a set of battle-tested\n+//! core types and shared abstractions for the [broader Rust\n+//! ecosystem][https://crates.io] to build on.\n //!\n-//! ## Pervasive types\n+//! The [primitive types](#primitives), though not defined in the\n+//! standard library, are documented here, as are the predefined\n+//! [macros](#macros).\n //!\n-//! The [`option`](option/index.html) and [`result`](result/index.html)\n-//! modules define optional and error-handling types, `Option` and `Result`.\n-//! [`iter`](iter/index.html) defines Rust's iterator protocol\n-//! along with a wide variety of iterators.\n-//! [`Cell` and `RefCell`](cell/index.html) are for creating types that\n-//! manage their own mutability.\n+//! ## Containers and collections\n //!\n-//! ## Vectors, slices and strings\n+//! The [`option`](option/index.html) and\n+//! [`result`](result/index.html) modules define optional and\n+//! error-handling types, `Option` and `Result`. The\n+//! [`iter`](iter/index.html) module defines Rust's iterator trait,\n+//! [`Iterater`](iter/trait.Iterator.html), which works with the `for`\n+//! loop to access collections.\n //!\n //! The common container type, `Vec`, a growable vector backed by an array,\n //! lives in the [`vec`](vec/index.html) module. Contiguous, unsized regions\n@@ -56,42 +59,36 @@\n //! macro, and for converting from strings use the\n //! [`FromStr`](str/trait.FromStr.html) trait.\n //!\n-//! ## Platform abstractions\n+//! Data may be shared by placing it in a reference-counted box or the\n+//! [`Rc`][rc/index.html] type, and if further contained in a [`Cell`\n+//! or `RefCell`](cell/index.html), may be mutated as well as shared.\n+//! Likewise, in a concurrent setting it is common to pair an\n+//! atomically-reference-counted box, [`Arc`](sync/struct.Arc.html),\n+//! with a [`Mutex`](sync/struct.Mutex.html) to get the same effect.\n //!\n-//! Besides basic data types, the standard library is largely concerned\n-//! with abstracting over differences in common platforms, most notably\n-//! Windows and Unix derivatives. The [`os`](os/index.html) module\n-//! provides a number of basic functions for interacting with the\n-//! operating environment, including program arguments, environment\n-//! variables, and directory navigation. The [`path`](path/index.html)\n-//! module encapsulates the platform-specific rules for dealing\n-//! with file paths.\n-//!\n-//! `std` also includes the [`ffi`](ffi/index.html) module for interoperating\n-//! with the C language.\n-//!\n-//! ## Concurrency, I/O, and the runtime\n+//! The [`collections`](collections/index.html) module defines maps,\n+//! sets, linked lists and other typical collection types, including\n+//! the common [`HashMap`](collections/struct.HashMap.html).\n //!\n-//! The [`thread`](thread/index.html) module contains Rust's threading abstractions.\n-//! [`sync`](sync/index.html) contains further, primitive, shared memory types,\n-//! including [`atomic`](sync/atomic/index.html), and [`mpsc`](sync/mpsc/index.html),\n-//! which contains the channel types for message passing.\n+//! ## Platform abstractions and I/O\n //!\n-//! Common types of I/O, including files, TCP, UDP, pipes, Unix domain sockets, and\n-//! process spawning, are defined in the [`io`](io/index.html) module.\n-//!\n-//! Rust's I/O and concurrency depends on a small runtime interface\n-//! that lives, along with its support code, in mod [`rt`](rt/index.html).\n-//! While a notable part of the standard library's architecture, this\n-//! module is not intended for public use.\n+//! Besides basic data types, the standard library is largely concerned\n+//! with abstracting over differences in common platforms, most notably\n+//! Windows and Unix derivatives.\n //!\n-//! ## The Rust prelude and macros\n+//! Common types of I/O, including [files](fs/struct.File.html),\n+//! [TCP](net/struct.TcpStream.html),\n+//! [UDP](net/struct.UdpSocket.html), are defined in the\n+//! [`io`](io/index.html), [`fs`](fs/index.html), and\n+//! [`net`](net/index.html) modules.\n //!\n-//! Finally, the [`prelude`](prelude/index.html) defines a\n-//! common set of traits, types, and functions that are made available\n-//! to all code by default. [`macros`](macros/index.html) contains\n-//! all the standard macros, such as `assert!`, `panic!`, `println!`,\n-//! and `format!`, also available to all Rust code.\n+//! The [`thread`](thread/index.html) module contains Rust's threading\n+//! abstractions. [`sync`](sync/index.html) contains further\n+//! primitive shared memory types, including\n+//! [`atomic`](sync/atomic/index.html) and\n+//! [`mpsc`](sync/mpsc/index.html), which contains the channel types\n+//! for message passing.\n+\n // Do not remove on snapshot creation. Needed for bootstrap. (Issue #22364)\n #![cfg_attr(stage0, feature(custom_attribute))]\n #![crate_name = \"std\"]"}, {"sha": "156a3d428debd7f6ec2f046be90663c5982df7a3", "filename": "src/libstd/prelude/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/30a42faa1c42ce5988241d3af993921246954b1a/src%2Flibstd%2Fprelude%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30a42faa1c42ce5988241d3af993921246954b1a/src%2Flibstd%2Fprelude%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude%2Fmod.rs?ref=30a42faa1c42ce5988241d3af993921246954b1a", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! The Rust prelude\n+//! The Rust Prelude\n //!\n //! Because `std` is required by most serious Rust software, it is\n //! imported at the topmost level of every crate by default, as if the"}, {"sha": "46c0103e0876495cf88f7903fdc2b1a6335327b5", "filename": "src/libstd/prelude/v1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/30a42faa1c42ce5988241d3af993921246954b1a/src%2Flibstd%2Fprelude%2Fv1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30a42faa1c42ce5988241d3af993921246954b1a/src%2Flibstd%2Fprelude%2Fv1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude%2Fv1.rs?ref=30a42faa1c42ce5988241d3af993921246954b1a", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! The first version of the prelude of the standard library.\n+//! The first version of the prelude of The Rust Standard Library.\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n "}]}