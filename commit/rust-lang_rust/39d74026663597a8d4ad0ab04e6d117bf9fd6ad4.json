{"sha": "39d74026663597a8d4ad0ab04e6d117bf9fd6ad4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM5ZDc0MDI2NjYzNTk3YThkNGFkMGFiMDRlNmQxMTdiZjlmZDZhZDQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-01-01T15:51:08Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-01-01T15:51:08Z"}, "message": "auto merge of #20190 : cmr/rust/gate-macro-args, r=alexcrichton\n\nUses the same approach as https://github.com/rust-lang/rust/pull/17286 (and\r\nsubsequent changes making it more correct), where the visitor will skip any\r\npieces of the AST that are from \"foreign code\", where the spans don't line up,\r\nindicating that that piece of code is due to a macro expansion.\r\n\r\nIf this breaks your code, read the error message to determine which feature\r\ngate you should add to your crate.\r\n\r\nCloses #18102\r\n\r\n[breaking-change]", "tree": {"sha": "0d444a5841d9d9b6d01c2c47c50e378ff6e9ea5f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0d444a5841d9d9b6d01c2c47c50e378ff6e9ea5f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/39d74026663597a8d4ad0ab04e6d117bf9fd6ad4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/39d74026663597a8d4ad0ab04e6d117bf9fd6ad4", "html_url": "https://github.com/rust-lang/rust/commit/39d74026663597a8d4ad0ab04e6d117bf9fd6ad4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/39d74026663597a8d4ad0ab04e6d117bf9fd6ad4/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c594959cdff07b5545747809bb045bfa2868ebcc", "url": "https://api.github.com/repos/rust-lang/rust/commits/c594959cdff07b5545747809bb045bfa2868ebcc", "html_url": "https://github.com/rust-lang/rust/commit/c594959cdff07b5545747809bb045bfa2868ebcc"}, {"sha": "41da99dff417eadf8f296a93529d9810f79e1d1b", "url": "https://api.github.com/repos/rust-lang/rust/commits/41da99dff417eadf8f296a93529d9810f79e1d1b", "html_url": "https://github.com/rust-lang/rust/commit/41da99dff417eadf8f296a93529d9810f79e1d1b"}], "stats": {"total": 250, "additions": 172, "deletions": 78}, "files": [{"sha": "59f86db73c903ccf6c3a9acf3e376ecb3f1ebb6f", "filename": "src/librand/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/39d74026663597a8d4ad0ab04e6d117bf9fd6ad4/src%2Flibrand%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d74026663597a8d4ad0ab04e6d117bf9fd6ad4/src%2Flibrand%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Flib.rs?ref=39d74026663597a8d4ad0ab04e6d117bf9fd6ad4", "patch": "@@ -271,7 +271,8 @@ pub trait Rng {\n     /// let choices = [1i, 2, 4, 8, 16, 32];\n     /// let mut rng = thread_rng();\n     /// println!(\"{}\", rng.choose(&choices));\n-    /// assert_eq!(rng.choose(choices[..0]), None);\n+    /// # // replace with slicing syntax when it's stable!\n+    /// assert_eq!(rng.choose(choices.slice_to(0)), None);\n     /// ```\n     fn choose<'a, T>(&mut self, values: &'a [T]) -> Option<&'a T> {\n         if values.is_empty() {"}, {"sha": "692ecf75091c4bd622108b574d2382eddd07ed33", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 1, "deletions": 27, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/39d74026663597a8d4ad0ab04e6d117bf9fd6ad4/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d74026663597a8d4ad0ab04e6d117bf9fd6ad4/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=39d74026663597a8d4ad0ab04e6d117bf9fd6ad4", "patch": "@@ -1682,33 +1682,7 @@ impl Stability {\n     }\n \n     fn is_internal(&self, cx: &Context, span: Span) -> bool {\n-        // first, check if the given expression was generated by a macro or not\n-        // we need to go back the expn_info tree to check only the arguments\n-        // of the initial macro call, not the nested ones.\n-        let mut expnid = span.expn_id;\n-        let mut is_internal = false;\n-        while cx.tcx.sess.codemap().with_expn_info(expnid, |expninfo| {\n-            match expninfo {\n-                Some(ref info) => {\n-                    // save the parent expn_id for next loop iteration\n-                    expnid = info.call_site.expn_id;\n-                    if info.callee.span.is_none() {\n-                        // it's a compiler built-in, we *really* don't want to mess with it\n-                        // so we skip it, unless it was called by a regular macro, in which case\n-                        // we will handle the caller macro next turn\n-                        is_internal = true;\n-                        true // continue looping\n-                    } else {\n-                        // was this expression from the current macro arguments ?\n-                        is_internal = !( span.lo > info.call_site.lo &&\n-                                         span.hi < info.call_site.hi );\n-                        true // continue looping\n-                    }\n-                },\n-                _ => false // stop looping\n-            }\n-        }) { /* empty while loop body */ }\n-        return is_internal;\n+        cx.tcx.sess.codemap().span_is_internal(span)\n     }\n }\n "}, {"sha": "91902b906735b2ef2f50e2678519b64eb7fe0023", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 25, "deletions": 15, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/39d74026663597a8d4ad0ab04e6d117bf9fd6ad4/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d74026663597a8d4ad0ab04e6d117bf9fd6ad4/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=39d74026663597a8d4ad0ab04e6d117bf9fd6ad4", "patch": "@@ -178,21 +178,6 @@ pub fn phase_2_configure_and_expand(sess: &Session,\n     *sess.crate_metadata.borrow_mut() =\n         collect_crate_metadata(sess, krate.attrs[]);\n \n-    time(time_passes, \"gated feature checking\", (), |_| {\n-        let (features, unknown_features) =\n-            syntax::feature_gate::check_crate(&sess.parse_sess.span_diagnostic, &krate);\n-\n-        for uf in unknown_features.iter() {\n-            sess.add_lint(lint::builtin::UNKNOWN_FEATURES,\n-                          ast::CRATE_NODE_ID,\n-                          *uf,\n-                          \"unknown feature\".to_string());\n-        }\n-\n-        sess.abort_if_errors();\n-        *sess.features.borrow_mut() = features;\n-    });\n-\n     time(time_passes, \"recursion limit\", (), |_| {\n         middle::recursion_limit::update_recursion_limit(sess, &krate);\n     });\n@@ -205,6 +190,23 @@ pub fn phase_2_configure_and_expand(sess: &Session,\n     //\n     // baz! should not use this definition unless foo is enabled.\n \n+    time(time_passes, \"gated macro checking\", (), |_| {\n+        let (features, unknown_features) =\n+            syntax::feature_gate::check_crate_macros(sess.codemap(),\n+                                                     &sess.parse_sess.span_diagnostic,\n+                                                     &krate);\n+        for uf in unknown_features.iter() {\n+            sess.add_lint(lint::builtin::UNKNOWN_FEATURES,\n+                          ast::CRATE_NODE_ID,\n+                          *uf,\n+                          \"unknown feature\".to_string());\n+        }\n+\n+        // these need to be set \"early\" so that expansion sees `quote` if enabled.\n+        *sess.features.borrow_mut() = features;\n+        sess.abort_if_errors();\n+    });\n+\n     krate = time(time_passes, \"configuration 1\", krate, |krate|\n                  syntax::config::strip_unconfigured_items(sess.diagnostic(), krate));\n \n@@ -289,6 +291,14 @@ pub fn phase_2_configure_and_expand(sess: &Session,\n         }\n     );\n \n+    // Needs to go *after* expansion to be able to check the results of macro expansion.\n+    time(time_passes, \"complete gated feature checking\", (), |_| {\n+        syntax::feature_gate::check_crate(sess.codemap(),\n+                                          &sess.parse_sess.span_diagnostic,\n+                                          &krate);\n+        sess.abort_if_errors();\n+    });\n+\n     // JBC: make CFG processing part of expansion to avoid this problem:\n \n     // strip again, in case expansion added anything with a #[cfg]."}, {"sha": "e61afb8b193af128f223c5568d539734c32a347c", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/39d74026663597a8d4ad0ab04e6d117bf9fd6ad4/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d74026663597a8d4ad0ab04e6d117bf9fd6ad4/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=39d74026663597a8d4ad0ab04e6d117bf9fd6ad4", "patch": "@@ -563,6 +563,38 @@ impl CodeMap {\n             ExpnId(i) => f(Some(&(*self.expansions.borrow())[i as uint]))\n         }\n     }\n+\n+    /// Check if a span is \"internal\" to a macro. This means that it is entirely generated by a\n+    /// macro expansion and contains no code that was passed in as an argument.\n+    pub fn span_is_internal(&self, span: Span) -> bool {\n+        // first, check if the given expression was generated by a macro or not\n+        // we need to go back the expn_info tree to check only the arguments\n+        // of the initial macro call, not the nested ones.\n+        let mut is_internal = false;\n+        let mut expnid = span.expn_id;\n+        while self.with_expn_info(expnid, |expninfo| {\n+            match expninfo {\n+                Some(ref info) => {\n+                    // save the parent expn_id for next loop iteration\n+                    expnid = info.call_site.expn_id;\n+                    if info.callee.span.is_none() {\n+                        // it's a compiler built-in, we *really* don't want to mess with it\n+                        // so we skip it, unless it was called by a regular macro, in which case\n+                        // we will handle the caller macro next turn\n+                        is_internal = true;\n+                        true // continue looping\n+                    } else {\n+                        // was this expression from the current macro arguments ?\n+                        is_internal = !( span.lo > info.call_site.lo &&\n+                                         span.hi < info.call_site.hi );\n+                        true // continue looping\n+                    }\n+                },\n+                _ => false // stop looping\n+            }\n+        }) { /* empty while loop body */ }\n+        return is_internal;\n+    }\n }\n \n #[cfg(test)]"}, {"sha": "b2c2d7eb626d15bffd3fab0ebb2a4401c41780d7", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 88, "deletions": 35, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/39d74026663597a8d4ad0ab04e6d117bf9fd6ad4/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d74026663597a8d4ad0ab04e6d117bf9fd6ad4/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=39d74026663597a8d4ad0ab04e6d117bf9fd6ad4", "patch": "@@ -24,7 +24,7 @@ use ast::NodeId;\n use ast;\n use attr;\n use attr::AttrMetaMethods;\n-use codemap::Span;\n+use codemap::{CodeMap, Span};\n use diagnostic::SpanHandler;\n use visit;\n use visit::Visitor;\n@@ -127,6 +127,7 @@ impl Features {\n struct Context<'a> {\n     features: Vec<&'static str>,\n     span_handler: &'a SpanHandler,\n+    cm: &'a CodeMap,\n }\n \n impl<'a> Context<'a> {\n@@ -144,7 +145,71 @@ impl<'a> Context<'a> {\n     }\n }\n \n-impl<'a, 'v> Visitor<'v> for Context<'a> {\n+struct MacroVisitor<'a> {\n+    context: &'a Context<'a>\n+}\n+\n+impl<'a, 'v> Visitor<'v> for MacroVisitor<'a> {\n+    fn visit_view_item(&mut self, i: &ast::ViewItem) {\n+        match i.node {\n+            ast::ViewItemExternCrate(..) => {\n+                for attr in i.attrs.iter() {\n+                    if attr.name().get() == \"phase\"{\n+                        self.context.gate_feature(\"phase\", attr.span,\n+                                          \"compile time crate loading is \\\n+                                           experimental and possibly buggy\");\n+                    }\n+                }\n+            },\n+            _ => { }\n+        }\n+        visit::walk_view_item(self, i)\n+    }\n+\n+    fn visit_mac(&mut self, macro: &ast::Mac) {\n+        let ast::MacInvocTT(ref path, _, _) = macro.node;\n+        let id = path.segments.last().unwrap().identifier;\n+\n+        if id == token::str_to_ident(\"macro_rules\") {\n+            self.context.gate_feature(\"macro_rules\", path.span, \"macro definitions are \\\n+                not stable enough for use and are subject to change\");\n+        }\n+\n+        else if id == token::str_to_ident(\"asm\") {\n+            self.context.gate_feature(\"asm\", path.span, \"inline assembly is not \\\n+                stable enough for use and is subject to change\");\n+        }\n+\n+        else if id == token::str_to_ident(\"log_syntax\") {\n+            self.context.gate_feature(\"log_syntax\", path.span, \"`log_syntax!` is not \\\n+                stable enough for use and is subject to change\");\n+        }\n+\n+        else if id == token::str_to_ident(\"trace_macros\") {\n+            self.context.gate_feature(\"trace_macros\", path.span, \"`trace_macros` is not \\\n+                stable enough for use and is subject to change\");\n+        }\n+\n+        else if id == token::str_to_ident(\"concat_idents\") {\n+            self.context.gate_feature(\"concat_idents\", path.span, \"`concat_idents` is not \\\n+                stable enough for use and is subject to change\");\n+        }\n+    }\n+}\n+\n+struct PostExpansionVisitor<'a> {\n+    context: &'a Context<'a>\n+}\n+\n+impl<'a> PostExpansionVisitor<'a> {\n+    fn gate_feature(&self, feature: &str, span: Span, explain: &str) {\n+        if !self.context.cm.span_is_internal(span) {\n+            self.context.gate_feature(feature, span, explain)\n+        }\n+    }\n+}\n+\n+impl<'a, 'v> Visitor<'v> for PostExpansionVisitor<'a> {\n     fn visit_name(&mut self, sp: Span, name: ast::Name) {\n         if !token::get_name(name).get().is_ascii() {\n             self.gate_feature(\"non_ascii_idents\", sp,\n@@ -217,7 +282,7 @@ impl<'a, 'v> Visitor<'v> for Context<'a> {\n             }\n \n             ast::ItemImpl(_, _, _, _, ref items) => {\n-                if attr::contains_name(i.attrs.as_slice(),\n+                if attr::contains_name(i.attrs[],\n                                        \"unsafe_destructor\") {\n                     self.gate_feature(\"unsafe_destructor\",\n                                       i.span,\n@@ -256,36 +321,6 @@ impl<'a, 'v> Visitor<'v> for Context<'a> {\n         }\n     }\n \n-    fn visit_mac(&mut self, macro: &ast::Mac) {\n-        let ast::MacInvocTT(ref path, _, _) = macro.node;\n-        let id = path.segments.last().unwrap().identifier;\n-\n-        if id == token::str_to_ident(\"macro_rules\") {\n-            self.gate_feature(\"macro_rules\", path.span, \"macro definitions are \\\n-                not stable enough for use and are subject to change\");\n-        }\n-\n-        else if id == token::str_to_ident(\"asm\") {\n-            self.gate_feature(\"asm\", path.span, \"inline assembly is not \\\n-                stable enough for use and is subject to change\");\n-        }\n-\n-        else if id == token::str_to_ident(\"log_syntax\") {\n-            self.gate_feature(\"log_syntax\", path.span, \"`log_syntax!` is not \\\n-                stable enough for use and is subject to change\");\n-        }\n-\n-        else if id == token::str_to_ident(\"trace_macros\") {\n-            self.gate_feature(\"trace_macros\", path.span, \"`trace_macros` is not \\\n-                stable enough for use and is subject to change\");\n-        }\n-\n-        else if id == token::str_to_ident(\"concat_idents\") {\n-            self.gate_feature(\"concat_idents\", path.span, \"`concat_idents` is not \\\n-                stable enough for use and is subject to change\");\n-        }\n-    }\n-\n     fn visit_foreign_item(&mut self, i: &ast::ForeignItem) {\n         if attr::contains_name(i.attrs[], \"linkage\") {\n             self.gate_feature(\"linkage\", i.span,\n@@ -371,10 +406,15 @@ impl<'a, 'v> Visitor<'v> for Context<'a> {\n     }\n }\n \n-pub fn check_crate(span_handler: &SpanHandler, krate: &ast::Crate) -> (Features, Vec<Span>) {\n+fn check_crate_inner<F>(cm: &CodeMap, span_handler: &SpanHandler, krate: &ast::Crate,\n+                        check: F)\n+                       -> (Features, Vec<Span>)\n+    where F: FnOnce(&mut Context, &ast::Crate)\n+{\n     let mut cx = Context {\n         features: Vec::new(),\n         span_handler: span_handler,\n+        cm: cm,\n     };\n \n     let mut unknown_features = Vec::new();\n@@ -419,7 +459,7 @@ pub fn check_crate(span_handler: &SpanHandler, krate: &ast::Crate) -> (Features,\n         }\n     }\n \n-    visit::walk_crate(&mut cx, krate);\n+    check(&mut cx, krate);\n \n     (Features {\n         default_type_params: cx.has_feature(\"default_type_params\"),\n@@ -432,3 +472,16 @@ pub fn check_crate(span_handler: &SpanHandler, krate: &ast::Crate) -> (Features,\n     },\n     unknown_features)\n }\n+\n+pub fn check_crate_macros(cm: &CodeMap, span_handler: &SpanHandler, krate: &ast::Crate)\n+-> (Features, Vec<Span>) {\n+    check_crate_inner(cm, span_handler, krate,\n+                      |ctx, krate| visit::walk_crate(&mut MacroVisitor { context: ctx }, krate))\n+}\n+\n+pub fn check_crate(cm: &CodeMap, span_handler: &SpanHandler, krate: &ast::Crate)\n+-> (Features, Vec<Span>) {\n+    check_crate_inner(cm, span_handler, krate,\n+                      |ctx, krate| visit::walk_crate(&mut PostExpansionVisitor { context: ctx },\n+                                                     krate))\n+}"}, {"sha": "cd49c7c016eeb88bd596cf8f4d3baa6b2d4466f4", "filename": "src/test/compile-fail/feature-gated-feature-in-macro-arg.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/39d74026663597a8d4ad0ab04e6d117bf9fd6ad4/src%2Ftest%2Fcompile-fail%2Ffeature-gated-feature-in-macro-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d74026663597a8d4ad0ab04e6d117bf9fd6ad4/src%2Ftest%2Fcompile-fail%2Ffeature-gated-feature-in-macro-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffeature-gated-feature-in-macro-arg.rs?ref=39d74026663597a8d4ad0ab04e6d117bf9fd6ad4", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// tests that input to a macro is checked for use of gated features. If this\n+// test succeeds due to the acceptance of a feature, pick a new feature to\n+// test. Not ideal, but oh well :(\n+\n+fn main() {\n+    let a = &[1i32, 2, 3];\n+    println!(\"{}\", {\n+        extern \"rust-intrinsic\" { //~ ERROR intrinsics are subject to change\n+            fn atomic_fence();\n+        }\n+        atomic_fence();\n+        42\n+    });\n+}"}]}