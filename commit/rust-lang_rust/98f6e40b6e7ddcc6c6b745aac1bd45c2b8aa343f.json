{"sha": "98f6e40b6e7ddcc6c6b745aac1bd45c2b8aa343f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk4ZjZlNDBiNmU3ZGRjYzZjNmI3NDVhYWMxYmQ0NWMyYjhhYTM0M2Y=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-06-06T18:40:11Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-06-06T18:40:11Z"}, "message": "Auto merge of #26050 - bluss:linked-list, r=Gankro\n\nThe recent bug that was found in LinkedList reminded me of some general cleanup\r\nthat's been waiting for some time.\r\n\r\n- Use a loop from the front in Drop, it works just as well and without an unsafe block\r\n- Change Rawlink methods to use `unsafe` in an idiomatic way. This does mean that\r\nwe need an unsafe block for each dereference of a raw link. Even then, the extent\r\nof unsafe-critical code is even larger of course, since safety depends on the whole\r\ndata structure's integrity. This is a general problem we are aware of.\r\n- Some cleanup just to try to decrease the amount of Rawlink handling.", "tree": {"sha": "668a2d78175ae0764f12e1c8b200802889b24436", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/668a2d78175ae0764f12e1c8b200802889b24436"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/98f6e40b6e7ddcc6c6b745aac1bd45c2b8aa343f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/98f6e40b6e7ddcc6c6b745aac1bd45c2b8aa343f", "html_url": "https://github.com/rust-lang/rust/commit/98f6e40b6e7ddcc6c6b745aac1bd45c2b8aa343f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/98f6e40b6e7ddcc6c6b745aac1bd45c2b8aa343f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bfd072db45d07a7c0ed2248737ef3c61131729fc", "url": "https://api.github.com/repos/rust-lang/rust/commits/bfd072db45d07a7c0ed2248737ef3c61131729fc", "html_url": "https://github.com/rust-lang/rust/commit/bfd072db45d07a7c0ed2248737ef3c61131729fc"}, {"sha": "32037a5696272f1c34f3692dcdc59b4ada91bdc7", "url": "https://api.github.com/repos/rust-lang/rust/commits/32037a5696272f1c34f3692dcdc59b4ada91bdc7", "html_url": "https://github.com/rust-lang/rust/commit/32037a5696272f1c34f3692dcdc59b4ada91bdc7"}], "stats": {"total": 215, "additions": 132, "deletions": 83}, "files": [{"sha": "980fe00f1e5b4e1b4c65fc59b2ea2c76a2fbc39e", "filename": "src/libcollections/linked_list.rs", "status": "modified", "additions": 132, "deletions": 83, "changes": 215, "blob_url": "https://github.com/rust-lang/rust/blob/98f6e40b6e7ddcc6c6b745aac1bd45c2b8aa343f/src%2Flibcollections%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98f6e40b6e7ddcc6c6b745aac1bd45c2b8aa343f/src%2Flibcollections%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flinked_list.rs?ref=98f6e40b6e7ddcc6c6b745aac1bd45c2b8aa343f", "patch": "@@ -104,17 +104,23 @@ impl<T> Rawlink<T> {\n     }\n \n     /// Convert the `Rawlink` into an Option value\n-    fn resolve_immut<'a>(&self) -> Option<&'a T> {\n-        unsafe {\n-            self.p.as_ref()\n-        }\n+    ///\n+    /// **unsafe** because:\n+    ///\n+    /// - Dereference of raw pointer.\n+    /// - Returns reference of arbitrary lifetime.\n+    unsafe fn resolve<'a>(&self) -> Option<&'a T> {\n+        self.p.as_ref()\n     }\n \n     /// Convert the `Rawlink` into an Option value\n-    fn resolve<'a>(&mut self) -> Option<&'a mut T> {\n-        unsafe {\n-            self.p.as_mut()\n-        }\n+    ///\n+    /// **unsafe** because:\n+    ///\n+    /// - Dereference of raw pointer.\n+    /// - Returns reference of arbitrary lifetime.\n+    unsafe fn resolve_mut<'a>(&mut self) -> Option<&'a mut T> {\n+        self.p.as_mut()\n     }\n \n     /// Return the `Rawlink` and replace with `Rawlink::none()`\n@@ -123,6 +129,15 @@ impl<T> Rawlink<T> {\n     }\n }\n \n+impl<'a, T> From<&'a mut Link<T>> for Rawlink<Node<T>> {\n+    fn from(node: &'a mut Link<T>) -> Self {\n+        match node.as_mut() {\n+            None => Rawlink::none(),\n+            Some(ptr) => Rawlink::some(ptr),\n+        }\n+    }\n+}\n+\n impl<T> Clone for Rawlink<T> {\n     #[inline]\n     fn clone(&self) -> Rawlink<T> {\n@@ -134,12 +149,21 @@ impl<T> Node<T> {\n     fn new(v: T) -> Node<T> {\n         Node{value: v, next: None, prev: Rawlink::none()}\n     }\n+\n+    /// Update the `prev` link on `next`, then set self's next pointer.\n+    ///\n+    /// `self.next` should be `None` when you call this\n+    /// (otherwise a Node is probably being dropped by mistake).\n+    fn set_next(&mut self, mut next: Box<Node<T>>) {\n+        debug_assert!(self.next.is_none());\n+        next.prev = Rawlink::some(self);\n+        self.next = Some(next);\n+    }\n }\n \n-/// Set the .prev field on `next`, then return `Some(next)`\n-fn link_with_prev<T>(mut next: Box<Node<T>>, prev: Rawlink<Node<T>>)\n-                  -> Link<T> {\n-    next.prev = prev;\n+/// Clear the .prev field on `next`, then return `Some(next)`\n+fn link_no_prev<T>(mut next: Box<Node<T>>) -> Link<T> {\n+    next.prev = Rawlink::none();\n     Some(next)\n }\n \n@@ -150,8 +174,8 @@ impl<T> LinkedList<T> {\n     fn push_front_node(&mut self, mut new_head: Box<Node<T>>) {\n         match self.list_head {\n             None => {\n-                self.list_tail = Rawlink::some(&mut *new_head);\n-                self.list_head = link_with_prev(new_head, Rawlink::none());\n+                self.list_head = link_no_prev(new_head);\n+                self.list_tail = Rawlink::from(&mut self.list_head);\n             }\n             Some(ref mut head) => {\n                 new_head.prev = Rawlink::none();\n@@ -169,7 +193,7 @@ impl<T> LinkedList<T> {\n         self.list_head.take().map(|mut front_node| {\n             self.length -= 1;\n             match front_node.next.take() {\n-                Some(node) => self.list_head = link_with_prev(node, Rawlink::none()),\n+                Some(node) => self.list_head = link_no_prev(node),\n                 None => self.list_tail = Rawlink::none()\n             }\n             front_node\n@@ -178,12 +202,12 @@ impl<T> LinkedList<T> {\n \n     /// Add a Node last in the list\n     #[inline]\n-    fn push_back_node(&mut self, mut new_tail: Box<Node<T>>) {\n-        match self.list_tail.resolve() {\n+    fn push_back_node(&mut self, new_tail: Box<Node<T>>) {\n+        match unsafe { self.list_tail.resolve_mut() } {\n             None => return self.push_front_node(new_tail),\n             Some(tail) => {\n-                self.list_tail = Rawlink::some(&mut *new_tail);\n-                tail.next = link_with_prev(new_tail, Rawlink::some(tail));\n+                tail.set_next(new_tail);\n+                self.list_tail = Rawlink::from(&mut tail.next);\n             }\n         }\n         self.length += 1;\n@@ -192,14 +216,16 @@ impl<T> LinkedList<T> {\n     /// Remove the last Node and return it, or None if the list is empty\n     #[inline]\n     fn pop_back_node(&mut self) -> Option<Box<Node<T>>> {\n-        self.list_tail.resolve().map_or(None, |tail| {\n-            self.length -= 1;\n-            self.list_tail = tail.prev;\n-            match tail.prev.resolve() {\n-                None => self.list_head.take(),\n-                Some(tail_prev) => tail_prev.next.take()\n-            }\n-        })\n+        unsafe {\n+            self.list_tail.resolve_mut().and_then(|tail| {\n+                self.length -= 1;\n+                self.list_tail = tail.prev;\n+                match tail.prev.resolve_mut() {\n+                    None => self.list_head.take(),\n+                    Some(tail_prev) => tail_prev.next.take()\n+                }\n+            })\n+        }\n     }\n }\n \n@@ -246,7 +272,7 @@ impl<T> LinkedList<T> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn append(&mut self, other: &mut LinkedList<T>) {\n-        match self.list_tail.resolve() {\n+        match unsafe { self.list_tail.resolve_mut() } {\n             None => {\n                 self.length = other.length;\n                 self.list_head = other.list_head.take();\n@@ -259,7 +285,7 @@ impl<T> LinkedList<T> {\n                 match other.list_head.take() {\n                     None => return,\n                     Some(node) => {\n-                        tail.next = link_with_prev(node, self.list_tail);\n+                        tail.set_next(node);\n                         self.list_tail = o_tail;\n                         self.length += o_length;\n                     }\n@@ -280,13 +306,9 @@ impl<T> LinkedList<T> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn iter_mut(&mut self) -> IterMut<T> {\n-        let head_raw = match self.list_head {\n-            Some(ref mut h) => Rawlink::some(&mut **h),\n-            None => Rawlink::none(),\n-        };\n-        IterMut{\n+        IterMut {\n             nelem: self.len(),\n-            head: head_raw,\n+            head: Rawlink::from(&mut self.list_head),\n             tail: self.list_tail,\n             list: self\n         }\n@@ -433,7 +455,9 @@ impl<T> LinkedList<T> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn back(&self) -> Option<&T> {\n-        self.list_tail.resolve_immut().as_ref().map(|tail| &tail.value)\n+        unsafe {\n+            self.list_tail.resolve().map(|tail| &tail.value)\n+        }\n     }\n \n     /// Provides a mutable reference to the back element, or `None` if the list\n@@ -460,7 +484,9 @@ impl<T> LinkedList<T> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn back_mut(&mut self) -> Option<&mut T> {\n-        self.list_tail.resolve().map(|tail| &mut tail.value)\n+        unsafe {\n+            self.list_tail.resolve_mut().map(|tail| &mut tail.value)\n+        }\n     }\n \n     /// Adds an element first in the list.\n@@ -603,44 +629,42 @@ impl<T> LinkedList<T> {\n             iter.tail\n         };\n \n-        let mut splitted_list = LinkedList {\n-            list_head: None,\n+        // The split node is the new tail node of the first part and owns\n+        // the head of the second part.\n+        let mut second_part_head;\n+\n+        unsafe {\n+            second_part_head = split_node.resolve_mut().unwrap().next.take();\n+            match second_part_head {\n+                None => {}\n+                Some(ref mut head) => head.prev = Rawlink::none(),\n+            }\n+        }\n+\n+        let second_part = LinkedList {\n+            list_head: second_part_head,\n             list_tail: self.list_tail,\n             length: len - at\n         };\n \n-        // Swap split_node.next with list_head (which is None), nulling out split_node.next,\n-        // as it is the new tail.\n-        mem::swap(&mut split_node.resolve().unwrap().next, &mut splitted_list.list_head);\n-        // Null out list_head.prev. Note this `unwrap` won't fail because if at == len\n-        // we already branched out at the top of the fn to return the empty list.\n-        splitted_list.list_head.as_mut().unwrap().prev = Rawlink::none();\n-        // Fix the tail ptr\n+        // Fix the tail ptr of the first part\n         self.list_tail = split_node;\n         self.length = at;\n \n-        splitted_list\n+        second_part\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Drop for LinkedList<T> {\n     fn drop(&mut self) {\n-        // Dissolve the linked_list in backwards direction\n+        // Dissolve the linked_list in a loop.\n         // Just dropping the list_head can lead to stack exhaustion\n         // when length is >> 1_000_000\n-        let mut tail = self.list_tail;\n-        loop {\n-            match tail.resolve() {\n-                None => break,\n-                Some(prev) => {\n-                    prev.next.take(); // release Box<Node<T>>\n-                    tail = prev.prev;\n-                }\n-            }\n+        while let Some(mut head_) = self.list_head.take() {\n+            self.list_head = head_.next.take();\n         }\n         self.length = 0;\n-        self.list_head = None;\n         self.list_tail = Rawlink::none();\n     }\n }\n@@ -674,11 +698,13 @@ impl<'a, A> DoubleEndedIterator for Iter<'a, A> {\n         if self.nelem == 0 {\n             return None;\n         }\n-        self.tail.resolve_immut().as_ref().map(|prev| {\n-            self.nelem -= 1;\n-            self.tail = prev.prev;\n-            &prev.value\n-        })\n+        unsafe {\n+            self.tail.resolve().map(|prev| {\n+                self.nelem -= 1;\n+                self.tail = prev.prev;\n+                &prev.value\n+            })\n+        }\n     }\n }\n \n@@ -693,14 +719,13 @@ impl<'a, A> Iterator for IterMut<'a, A> {\n         if self.nelem == 0 {\n             return None;\n         }\n-        self.head.resolve().map(|next| {\n-            self.nelem -= 1;\n-            self.head = match next.next {\n-                Some(ref mut node) => Rawlink::some(&mut **node),\n-                None => Rawlink::none(),\n-            };\n-            &mut next.value\n-        })\n+        unsafe {\n+            self.head.resolve_mut().map(|next| {\n+                self.nelem -= 1;\n+                self.head = Rawlink::from(&mut next.next);\n+                &mut next.value\n+            })\n+        }\n     }\n \n     #[inline]\n@@ -716,11 +741,13 @@ impl<'a, A> DoubleEndedIterator for IterMut<'a, A> {\n         if self.nelem == 0 {\n             return None;\n         }\n-        self.tail.resolve().map(|prev| {\n-            self.nelem -= 1;\n-            self.tail = prev.prev;\n-            &mut prev.value\n-        })\n+        unsafe {\n+            self.tail.resolve_mut().map(|prev| {\n+                self.nelem -= 1;\n+                self.tail = prev.prev;\n+                &mut prev.value\n+            })\n+        }\n     }\n }\n \n@@ -734,16 +761,16 @@ impl<'a, A> IterMut<'a, A> {\n         // previously yielded element and self.head.\n         //\n         // The inserted node will not appear in further iteration.\n-        match self.head.resolve() {\n+        match unsafe { self.head.resolve_mut() } {\n             None => { self.list.push_back_node(ins_node); }\n             Some(node) => {\n-                let prev_node = match node.prev.resolve() {\n+                let prev_node = match unsafe { node.prev.resolve_mut() } {\n                     None => return self.list.push_front_node(ins_node),\n                     Some(prev) => prev,\n                 };\n                 let node_own = prev_node.next.take().unwrap();\n-                ins_node.next = link_with_prev(node_own, Rawlink::some(&mut *ins_node));\n-                prev_node.next = link_with_prev(ins_node, Rawlink::some(prev_node));\n+                ins_node.set_next(node_own);\n+                prev_node.set_next(ins_node);\n                 self.list.length += 1;\n             }\n         }\n@@ -803,7 +830,9 @@ impl<'a, A> IterMut<'a, A> {\n         if self.nelem == 0 {\n             return None\n         }\n-        self.head.resolve().map(|head| &mut head.value)\n+        unsafe {\n+            self.head.resolve_mut().map(|head| &mut head.value)\n+        }\n     }\n }\n \n@@ -933,7 +962,7 @@ impl<A: Hash> Hash for LinkedList<A> {\n #[cfg(test)]\n mod tests {\n     use std::clone::Clone;\n-    use std::iter::{Iterator, IntoIterator};\n+    use std::iter::{Iterator, IntoIterator, Extend};\n     use std::option::Option::{Some, None, self};\n     use std::__rand::{thread_rng, Rng};\n     use std::thread;\n@@ -955,7 +984,7 @@ mod tests {\n             Some(ref node) => node_ptr = &**node,\n         }\n         loop {\n-            match (last_ptr, node_ptr.prev.resolve_immut()) {\n+            match unsafe { (last_ptr, node_ptr.prev.resolve()) } {\n                 (None   , None      ) => {}\n                 (None   , _         ) => panic!(\"prev link for list_head\"),\n                 (Some(p), Some(pptr)) => {\n@@ -1101,6 +1130,26 @@ mod tests {\n         assert_eq!(v1.iter().collect::<Vec<_>>().len(), 3);\n     }\n \n+    #[test]\n+    fn test_split_off() {\n+        let mut v1 = LinkedList::new();\n+        v1.push_front(1u8);\n+        v1.push_front(1u8);\n+        v1.push_front(1u8);\n+        v1.push_front(1u8);\n+\n+        // test all splits\n+        for ix in 0..1 + v1.len() {\n+            let mut a = v1.clone();\n+            let b = a.split_off(ix);\n+            check_links(&a);\n+            check_links(&b);\n+            a.extend(b);\n+            assert_eq!(v1, a);\n+        }\n+    }\n+\n+\n     #[cfg(test)]\n     fn fuzz_test(sz: i32) {\n         let mut m: LinkedList<_> = LinkedList::new();"}]}