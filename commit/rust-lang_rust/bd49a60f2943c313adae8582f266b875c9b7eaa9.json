{"sha": "bd49a60f2943c313adae8582f266b875c9b7eaa9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJkNDlhNjBmMjk0M2MzMTNhZGFlODU4MmYyNjZiODc1YzliN2VhYTk=", "commit": {"author": {"name": "C", "email": "DeveloperC@protonmail.com", "date": "2020-12-05T01:41:44Z"}, "committer": {"name": "C", "email": "DeveloperC@protonmail.com", "date": "2020-12-29T14:03:30Z"}, "message": "refactor: moved SpecExtend into spec_extend.rs", "tree": {"sha": "1dd0b0772898acee65921b6a91e7d280ebc36c8a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1dd0b0772898acee65921b6a91e7d280ebc36c8a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bd49a60f2943c313adae8582f266b875c9b7eaa9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bd49a60f2943c313adae8582f266b875c9b7eaa9", "html_url": "https://github.com/rust-lang/rust/commit/bd49a60f2943c313adae8582f266b875c9b7eaa9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bd49a60f2943c313adae8582f266b875c9b7eaa9/comments", "author": {"login": "DeveloperC286", "id": 65925405, "node_id": "MDQ6VXNlcjY1OTI1NDA1", "avatar_url": "https://avatars.githubusercontent.com/u/65925405?v=4", "gravatar_id": "", "url": "https://api.github.com/users/DeveloperC286", "html_url": "https://github.com/DeveloperC286", "followers_url": "https://api.github.com/users/DeveloperC286/followers", "following_url": "https://api.github.com/users/DeveloperC286/following{/other_user}", "gists_url": "https://api.github.com/users/DeveloperC286/gists{/gist_id}", "starred_url": "https://api.github.com/users/DeveloperC286/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/DeveloperC286/subscriptions", "organizations_url": "https://api.github.com/users/DeveloperC286/orgs", "repos_url": "https://api.github.com/users/DeveloperC286/repos", "events_url": "https://api.github.com/users/DeveloperC286/events{/privacy}", "received_events_url": "https://api.github.com/users/DeveloperC286/received_events", "type": "User", "site_admin": false}, "committer": {"login": "DeveloperC286", "id": 65925405, "node_id": "MDQ6VXNlcjY1OTI1NDA1", "avatar_url": "https://avatars.githubusercontent.com/u/65925405?v=4", "gravatar_id": "", "url": "https://api.github.com/users/DeveloperC286", "html_url": "https://github.com/DeveloperC286", "followers_url": "https://api.github.com/users/DeveloperC286/followers", "following_url": "https://api.github.com/users/DeveloperC286/following{/other_user}", "gists_url": "https://api.github.com/users/DeveloperC286/gists{/gist_id}", "starred_url": "https://api.github.com/users/DeveloperC286/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/DeveloperC286/subscriptions", "organizations_url": "https://api.github.com/users/DeveloperC286/orgs", "repos_url": "https://api.github.com/users/DeveloperC286/repos", "events_url": "https://api.github.com/users/DeveloperC286/events{/privacy}", "received_events_url": "https://api.github.com/users/DeveloperC286/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d24a27797df96bb1dbc886f0997138965c5d7b50", "url": "https://api.github.com/repos/rust-lang/rust/commits/d24a27797df96bb1dbc886f0997138965c5d7b50", "html_url": "https://github.com/rust-lang/rust/commit/d24a27797df96bb1dbc886f0997138965c5d7b50"}], "stats": {"total": 166, "additions": 87, "deletions": 79}, "files": [{"sha": "32470941755a760db801d09e5e79422abc00c7c5", "filename": "library/alloc/src/vec/mod.rs", "status": "modified", "additions": 5, "deletions": 79, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/bd49a60f2943c313adae8582f266b875c9b7eaa9/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd49a60f2943c313adae8582f266b875c9b7eaa9/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs?ref=bd49a60f2943c313adae8582f266b875c9b7eaa9", "patch": "@@ -59,9 +59,7 @@ use core::convert::TryFrom;\n use core::fmt;\n use core::hash::{Hash, Hasher};\n use core::intrinsics::{arith_offset, assume};\n-use core::iter::{\n-    FromIterator, TrustedLen,\n-};\n+use core::iter::{FromIterator};\n use core::marker::PhantomData;\n use core::mem::{self, ManuallyDrop, MaybeUninit};\n use core::ops::{self, Index, IndexMut, Range, RangeBounds};\n@@ -125,6 +123,10 @@ use self::spec_from_iter::SpecFromIter;\n \n mod spec_from_iter;\n \n+use self::spec_extend::SpecExtend;\n+\n+mod spec_extend;\n+\n /// A contiguous growable array type, written `Vec<T>` but pronounced 'vector'.\n ///\n /// # Examples\n@@ -2160,82 +2162,6 @@ impl<T, A: Allocator> Extend<T> for Vec<T, A> {\n     }\n }\n \n-// Specialization trait used for Vec::extend\n-trait SpecExtend<T, I> {\n-    fn spec_extend(&mut self, iter: I);\n-}\n-\n-impl<T, I, A: Allocator> SpecExtend<T, I> for Vec<T, A>\n-where\n-    I: Iterator<Item = T>,\n-{\n-    default fn spec_extend(&mut self, iter: I) {\n-        self.extend_desugared(iter)\n-    }\n-}\n-\n-impl<T, I, A: Allocator> SpecExtend<T, I> for Vec<T, A>\n-where\n-    I: TrustedLen<Item = T>,\n-{\n-    default fn spec_extend(&mut self, iterator: I) {\n-        // This is the case for a TrustedLen iterator.\n-        let (low, high) = iterator.size_hint();\n-        if let Some(high_value) = high {\n-            debug_assert_eq!(\n-                low,\n-                high_value,\n-                \"TrustedLen iterator's size hint is not exact: {:?}\",\n-                (low, high)\n-            );\n-        }\n-        if let Some(additional) = high {\n-            self.reserve(additional);\n-            unsafe {\n-                let mut ptr = self.as_mut_ptr().add(self.len());\n-                let mut local_len = SetLenOnDrop::new(&mut self.len);\n-                iterator.for_each(move |element| {\n-                    ptr::write(ptr, element);\n-                    ptr = ptr.offset(1);\n-                    // NB can't overflow since we would have had to alloc the address space\n-                    local_len.increment_len(1);\n-                });\n-            }\n-        } else {\n-            self.extend_desugared(iterator)\n-        }\n-    }\n-}\n-\n-impl<T, A: Allocator> SpecExtend<T, IntoIter<T>> for Vec<T, A> {\n-    fn spec_extend(&mut self, mut iterator: IntoIter<T>) {\n-        unsafe {\n-            self.append_elements(iterator.as_slice() as _);\n-        }\n-        iterator.ptr = iterator.end;\n-    }\n-}\n-\n-impl<'a, T: 'a, I, A: Allocator + 'a> SpecExtend<&'a T, I> for Vec<T, A>\n-where\n-    I: Iterator<Item = &'a T>,\n-    T: Clone,\n-{\n-    default fn spec_extend(&mut self, iterator: I) {\n-        self.spec_extend(iterator.cloned())\n-    }\n-}\n-\n-impl<'a, T: 'a, A: Allocator + 'a> SpecExtend<&'a T, slice::Iter<'a, T>> for Vec<T, A>\n-where\n-    T: Copy,\n-{\n-    fn spec_extend(&mut self, iterator: slice::Iter<'a, T>) {\n-        let slice = iterator.as_slice();\n-        unsafe { self.append_elements(slice) };\n-    }\n-}\n-\n impl<T, A: Allocator> Vec<T, A> {\n     // leaf method to which various SpecFrom/SpecExtend implementations delegate when\n     // they have no further optimizations to apply"}, {"sha": "6959733d0744ab41a8e136217fb5f6d7eef4fa7b", "filename": "library/alloc/src/vec/spec_extend.rs", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/bd49a60f2943c313adae8582f266b875c9b7eaa9/library%2Falloc%2Fsrc%2Fvec%2Fspec_extend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd49a60f2943c313adae8582f266b875c9b7eaa9/library%2Falloc%2Fsrc%2Fvec%2Fspec_extend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fspec_extend.rs?ref=bd49a60f2943c313adae8582f266b875c9b7eaa9", "patch": "@@ -0,0 +1,82 @@\n+use crate::alloc::{Allocator};\n+use core::iter::{TrustedLen};\n+use core::slice::{self};\n+use core::ptr::{self};\n+\n+use super::{Vec, IntoIter, SetLenOnDrop};\n+\n+// Specialization trait used for Vec::extend\n+pub(super) trait SpecExtend<T, I> {\n+    fn spec_extend(&mut self, iter: I);\n+}\n+\n+impl<T, I, A: Allocator> SpecExtend<T, I> for Vec<T, A>\n+    where\n+        I: Iterator<Item = T>,\n+{\n+    default fn spec_extend(&mut self, iter: I) {\n+        self.extend_desugared(iter)\n+    }\n+}\n+\n+impl<T, I, A: Allocator> SpecExtend<T, I> for Vec<T, A>\n+    where\n+        I: TrustedLen<Item = T>,\n+{\n+    default fn spec_extend(&mut self, iterator: I) {\n+        // This is the case for a TrustedLen iterator.\n+        let (low, high) = iterator.size_hint();\n+        if let Some(high_value) = high {\n+            debug_assert_eq!(\n+                low,\n+                high_value,\n+                \"TrustedLen iterator's size hint is not exact: {:?}\",\n+                (low, high)\n+            );\n+        }\n+        if let Some(additional) = high {\n+            self.reserve(additional);\n+            unsafe {\n+                let mut ptr = self.as_mut_ptr().add(self.len());\n+                let mut local_len = SetLenOnDrop::new(&mut self.len);\n+                iterator.for_each(move |element| {\n+                    ptr::write(ptr, element);\n+                    ptr = ptr.offset(1);\n+                    // NB can't overflow since we would have had to alloc the address space\n+                    local_len.increment_len(1);\n+                });\n+            }\n+        } else {\n+            self.extend_desugared(iterator)\n+        }\n+    }\n+}\n+\n+impl<T, A: Allocator> SpecExtend<T, IntoIter<T>> for Vec<T, A> {\n+    fn spec_extend(&mut self, mut iterator: IntoIter<T>) {\n+        unsafe {\n+            self.append_elements(iterator.as_slice() as _);\n+        }\n+        iterator.ptr = iterator.end;\n+    }\n+}\n+\n+impl<'a, T: 'a, I, A: Allocator + 'a> SpecExtend<&'a T, I> for Vec<T, A>\n+    where\n+        I: Iterator<Item = &'a T>,\n+        T: Clone,\n+{\n+    default fn spec_extend(&mut self, iterator: I) {\n+        self.spec_extend(iterator.cloned())\n+    }\n+}\n+\n+impl<'a, T: 'a, A: Allocator + 'a> SpecExtend<&'a T, slice::Iter<'a, T>> for Vec<T, A>\n+    where\n+        T: Copy,\n+{\n+    fn spec_extend(&mut self, iterator: slice::Iter<'a, T>) {\n+        let slice = iterator.as_slice();\n+        unsafe { self.append_elements(slice) };\n+    }\n+}"}]}