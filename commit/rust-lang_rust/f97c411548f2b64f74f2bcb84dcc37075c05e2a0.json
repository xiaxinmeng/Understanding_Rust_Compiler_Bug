{"sha": "f97c411548f2b64f74f2bcb84dcc37075c05e2a0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY5N2M0MTE1NDhmMmI2NGY3NGYyYmNiODRkY2MzNzA3NWMwNWUyYTA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-06-05T06:49:29Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-06-05T06:49:29Z"}, "message": "Auto merge of #33622 - arielb1:elaborate-drops, r=nikomatsakis\n\n[MIR] non-zeroing drop\n\nThis enables non-zeroing drop through stack flags for MIR.\n\nFixes #30380.\nFixes #5016.", "tree": {"sha": "78f88d09614f89ea7e955252407bc0da5f02332b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/78f88d09614f89ea7e955252407bc0da5f02332b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f97c411548f2b64f74f2bcb84dcc37075c05e2a0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f97c411548f2b64f74f2bcb84dcc37075c05e2a0", "html_url": "https://github.com/rust-lang/rust/commit/f97c411548f2b64f74f2bcb84dcc37075c05e2a0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f97c411548f2b64f74f2bcb84dcc37075c05e2a0/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ccfaaa7d989356ff440e9960da28909491e2f00d", "url": "https://api.github.com/repos/rust-lang/rust/commits/ccfaaa7d989356ff440e9960da28909491e2f00d", "html_url": "https://github.com/rust-lang/rust/commit/ccfaaa7d989356ff440e9960da28909491e2f00d"}, {"sha": "063f8826e7addbe644e3dfd532736ce72d8990bc", "url": "https://api.github.com/repos/rust-lang/rust/commits/063f8826e7addbe644e3dfd532736ce72d8990bc", "html_url": "https://github.com/rust-lang/rust/commit/063f8826e7addbe644e3dfd532736ce72d8990bc"}], "stats": {"total": 2419, "additions": 2101, "deletions": 318}, "files": [{"sha": "620e6504f413fa0d7bdf22f3d0e3fae23e66e58c", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f97c411548f2b64f74f2bcb84dcc37075c05e2a0/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f97c411548f2b64f74f2bcb84dcc37075c05e2a0/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=f97c411548f2b64f74f2bcb84dcc37075c05e2a0", "patch": "@@ -624,6 +624,24 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n             value.trans_normalize(&infcx)\n         })\n     }\n+\n+    pub fn normalize_associated_type_in_env<T>(\n+        self, value: &T, env: &'a ty::ParameterEnvironment<'tcx>\n+    ) -> T\n+        where T: TransNormalize<'tcx>\n+    {\n+        debug!(\"normalize_associated_type_in_env(t={:?})\", value);\n+\n+        let value = self.erase_regions(value);\n+\n+        if !value.has_projection_types() {\n+            return value;\n+        }\n+\n+        self.infer_ctxt(None, Some(env.clone()), ProjectionMode::Any).enter(|infcx| {\n+            value.trans_normalize(&infcx)\n+       })\n+    }\n }\n \n impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {"}, {"sha": "d85ea961462276a8ee7d74c909b640d1e9c0621d", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f97c411548f2b64f74f2bcb84dcc37075c05e2a0/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f97c411548f2b64f74f2bcb84dcc37075c05e2a0/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=f97c411548f2b64f74f2bcb84dcc37075c05e2a0", "patch": "@@ -163,6 +163,7 @@ pub trait CrateStore<'tcx> {\n                      -> ty::TypeScheme<'tcx>;\n     fn visible_parent_map<'a>(&'a self) -> ::std::cell::RefMut<'a, DefIdMap<DefId>>;\n     fn item_name(&self, def: DefId) -> ast::Name;\n+    fn opt_item_name(&self, def: DefId) -> Option<ast::Name>;\n     fn item_predicates<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n                            -> ty::GenericPredicates<'tcx>;\n     fn item_super_predicates<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n@@ -345,6 +346,7 @@ impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n         bug!(\"visible_parent_map\")\n     }\n     fn item_name(&self, def: DefId) -> ast::Name { bug!(\"item_name\") }\n+    fn opt_item_name(&self, def: DefId) -> Option<ast::Name> { bug!(\"opt_item_name\") }\n     fn item_predicates<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n                            -> ty::GenericPredicates<'tcx> { bug!(\"item_predicates\") }\n     fn item_super_predicates<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)"}, {"sha": "1cd837e4853b01745c97d186b3316fe230b99cb9", "filename": "src/librustc/mir/repr.rs", "status": "modified", "additions": 34, "deletions": 9, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/f97c411548f2b64f74f2bcb84dcc37075c05e2a0/src%2Flibrustc%2Fmir%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f97c411548f2b64f74f2bcb84dcc37075c05e2a0/src%2Flibrustc%2Fmir%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Frepr.rs?ref=f97c411548f2b64f74f2bcb84dcc37075c05e2a0", "patch": "@@ -330,11 +330,19 @@ pub enum TerminatorKind<'tcx> {\n \n     /// Drop the Lvalue\n     Drop {\n-        value: Lvalue<'tcx>,\n+        location: Lvalue<'tcx>,\n         target: BasicBlock,\n         unwind: Option<BasicBlock>\n     },\n \n+    /// Drop the Lvalue and assign the new value over it\n+    DropAndReplace {\n+        location: Lvalue<'tcx>,\n+        value: Operand<'tcx>,\n+        target: BasicBlock,\n+        unwind: Option<BasicBlock>,\n+    },\n+\n     /// Block ends with a call of a converging function\n     Call {\n         /// The function that\u2019s being called\n@@ -373,8 +381,14 @@ impl<'tcx> TerminatorKind<'tcx> {\n                 slice::ref_slice(t).into_cow(),\n             Call { destination: None, cleanup: Some(ref c), .. } => slice::ref_slice(c).into_cow(),\n             Call { destination: None, cleanup: None, .. } => (&[]).into_cow(),\n-            Drop { target, unwind: Some(unwind), .. } => vec![target, unwind].into_cow(),\n-            Drop { ref target, .. } => slice::ref_slice(target).into_cow(),\n+            DropAndReplace { target, unwind: Some(unwind), .. } |\n+            Drop { target, unwind: Some(unwind), .. } => {\n+                vec![target, unwind].into_cow()\n+            }\n+            DropAndReplace { ref target, unwind: None, .. } |\n+            Drop { ref target, unwind: None, .. } => {\n+                slice::ref_slice(target).into_cow()\n+            }\n         }\n     }\n \n@@ -393,8 +407,12 @@ impl<'tcx> TerminatorKind<'tcx> {\n             Call { destination: Some((_, ref mut t)), cleanup: None, .. } => vec![t],\n             Call { destination: None, cleanup: Some(ref mut c), .. } => vec![c],\n             Call { destination: None, cleanup: None, .. } => vec![],\n+            DropAndReplace { ref mut target, unwind: Some(ref mut unwind), .. } |\n             Drop { ref mut target, unwind: Some(ref mut unwind), .. } => vec![target, unwind],\n-            Drop { ref mut target, .. } => vec![target]\n+            DropAndReplace { ref mut target, unwind: None, .. } |\n+            Drop { ref mut target, unwind: None, .. } => {\n+                vec![target]\n+            }\n         }\n     }\n }\n@@ -461,7 +479,9 @@ impl<'tcx> TerminatorKind<'tcx> {\n             SwitchInt { discr: ref lv, .. } => write!(fmt, \"switchInt({:?})\", lv),\n             Return => write!(fmt, \"return\"),\n             Resume => write!(fmt, \"resume\"),\n-            Drop { ref value, .. } => write!(fmt, \"drop({:?})\", value),\n+            Drop { ref location, .. } => write!(fmt, \"drop({:?})\", location),\n+            DropAndReplace { ref location, ref value, .. } =>\n+                write!(fmt, \"replace({:?} <- {:?})\", location, value),\n             Call { ref func, ref args, ref destination, .. } => {\n                 if let Some((ref destination, _)) = *destination {\n                     write!(fmt, \"{:?} = \", destination)?;\n@@ -506,8 +526,12 @@ impl<'tcx> TerminatorKind<'tcx> {\n             Call { destination: Some(_), cleanup: None, .. } => vec![\"return\".into_cow()],\n             Call { destination: None, cleanup: Some(_), .. } => vec![\"unwind\".into_cow()],\n             Call { destination: None, cleanup: None, .. } => vec![],\n+            DropAndReplace { unwind: None, .. } |\n             Drop { unwind: None, .. } => vec![\"return\".into_cow()],\n-            Drop { .. } => vec![\"return\".into_cow(), \"unwind\".into_cow()],\n+            DropAndReplace { unwind: Some(_), .. } |\n+            Drop { unwind: Some(_), .. } => {\n+                vec![\"return\".into_cow(), \"unwind\".into_cow()]\n+            }\n         }\n     }\n }\n@@ -918,7 +942,7 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n                         ppaux::parameterized(fmt, substs, variant_def.did,\n                                              ppaux::Ns::Value, &[],\n                                              |tcx| {\n-                            tcx.lookup_item_type(variant_def.did).generics\n+                            Some(tcx.lookup_item_type(variant_def.did).generics)\n                         })?;\n \n                         match variant_def.kind() {\n@@ -1010,8 +1034,9 @@ impl<'tcx> Debug for Literal<'tcx> {\n         use self::Literal::*;\n         match *self {\n             Item { def_id, substs } => {\n-                ppaux::parameterized(fmt, substs, def_id, ppaux::Ns::Value, &[],\n-                                     |tcx| tcx.lookup_item_type(def_id).generics)\n+                ppaux::parameterized(\n+                    fmt, substs, def_id, ppaux::Ns::Value, &[],\n+                    |tcx| Some(tcx.lookup_item_type(def_id).generics))\n             }\n             Value { ref value } => {\n                 write!(fmt, \"const \")?;"}, {"sha": "17a8d040ab4787fa69b9ac08c2df10e8247e9d19", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f97c411548f2b64f74f2bcb84dcc37075c05e2a0/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f97c411548f2b64f74f2bcb84dcc37075c05e2a0/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=f97c411548f2b64f74f2bcb84dcc37075c05e2a0", "patch": "@@ -394,10 +394,20 @@ macro_rules! make_mir_visitor {\n                     TerminatorKind::Return => {\n                     }\n \n-                    TerminatorKind::Drop { ref $($mutability)* value,\n+                    TerminatorKind::Drop { ref $($mutability)* location,\n                                            target,\n                                            unwind } => {\n-                        self.visit_lvalue(value, LvalueContext::Drop);\n+                        self.visit_lvalue(location, LvalueContext::Drop);\n+                        self.visit_branch(block, target);\n+                        unwind.map(|t| self.visit_branch(block, t));\n+                    }\n+\n+                    TerminatorKind::DropAndReplace { ref $($mutability)* location,\n+                                                     ref $($mutability)* value,\n+                                                     target,\n+                                                     unwind } => {\n+                        self.visit_lvalue(location, LvalueContext::Drop);\n+                        self.visit_operand(value);\n                         self.visit_branch(block, target);\n                         unwind.map(|t| self.visit_branch(block, t));\n                     }"}, {"sha": "74c05feb6d16a5822464da1319f591f3b8d62b69", "filename": "src/librustc/ty/item_path.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f97c411548f2b64f74f2bcb84dcc37075c05e2a0/src%2Flibrustc%2Fty%2Fitem_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f97c411548f2b64f74f2bcb84dcc37075c05e2a0/src%2Flibrustc%2Fty%2Fitem_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fitem_path.rs?ref=f97c411548f2b64f74f2bcb84dcc37075c05e2a0", "patch": "@@ -13,6 +13,7 @@ use middle::cstore::LOCAL_CRATE;\n use hir::def_id::{DefId, CRATE_DEF_INDEX};\n use ty::{self, Ty, TyCtxt};\n use syntax::ast;\n+use syntax::parse::token;\n \n use std::cell::Cell;\n \n@@ -138,7 +139,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                 }\n             }\n \n-            cur_path.push(self.sess.cstore.item_name(cur_def));\n+            cur_path.push(self.sess.cstore.opt_item_name(cur_def).unwrap_or_else(||\n+                token::intern(\"<unnamed>\")));\n             match visible_parent_map.get(&cur_def) {\n                 Some(&def) => cur_def = def,\n                 None => return false,"}, {"sha": "3ab7d90bf8cd85ca497766abaea13afd57db1c2c", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f97c411548f2b64f74f2bcb84dcc37075c05e2a0/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f97c411548f2b64f74f2bcb84dcc37075c05e2a0/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=f97c411548f2b64f74f2bcb84dcc37075c05e2a0", "patch": "@@ -2503,6 +2503,18 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             || self.sess.cstore.item_type(self.global_tcx(), did))\n     }\n \n+    pub fn opt_lookup_item_type(self, did: DefId) -> Option<TypeScheme<'gcx>> {\n+        if let Some(scheme) = self.tcache.borrow_mut().get(&did) {\n+            return Some(scheme.clone());\n+        }\n+\n+        if did.krate == LOCAL_CRATE {\n+            None\n+        } else {\n+            Some(self.sess.cstore.item_type(self.global_tcx(), did))\n+        }\n+    }\n+\n     /// Given the did of a trait, returns its canonical trait ref.\n     pub fn lookup_trait_def(self, did: DefId) -> &'gcx TraitDef<'gcx> {\n         lookup_locally_or_in_crate_store("}, {"sha": "e600e7b72da0e6be5c6483fd1c31ab98e1c6eba9", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 23, "deletions": 21, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/f97c411548f2b64f74f2bcb84dcc37075c05e2a0/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f97c411548f2b64f74f2bcb84dcc37075c05e2a0/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=f97c411548f2b64f74f2bcb84dcc37075c05e2a0", "patch": "@@ -69,15 +69,12 @@ pub enum Ns {\n     Value\n }\n \n-fn number_of_supplied_defaults<'a, 'gcx, 'tcx, GG>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                                                   substs: &subst::Substs,\n-                                                   space: subst::ParamSpace,\n-                                                   get_generics: GG)\n-                                                   -> usize\n-    where GG: FnOnce(TyCtxt<'a, 'gcx, 'tcx>) -> ty::Generics<'tcx>\n+fn number_of_supplied_defaults<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                                               substs: &subst::Substs,\n+                                               space: subst::ParamSpace,\n+                                               generics: ty::Generics<'tcx>)\n+                                               -> usize\n {\n-    let generics = get_generics(tcx);\n-\n     let has_self = substs.self_ty().is_some();\n     let ty_params = generics.types.get_slice(space);\n     let tps = substs.types.get_slice(space);\n@@ -115,7 +112,8 @@ pub fn parameterized<GG>(f: &mut fmt::Formatter,\n                          projections: &[ty::ProjectionPredicate],\n                          get_generics: GG)\n                          -> fmt::Result\n-    where GG: for<'a, 'gcx, 'tcx> FnOnce(TyCtxt<'a, 'gcx, 'tcx>) -> ty::Generics<'tcx>\n+    where GG: for<'a, 'gcx, 'tcx> FnOnce(TyCtxt<'a, 'gcx, 'tcx>)\n+                                         -> Option<ty::Generics<'tcx>>\n {\n     if let (Ns::Value, Some(self_ty)) = (ns, substs.self_ty()) {\n         write!(f, \"<{} as \", self_ty)?;\n@@ -176,13 +174,12 @@ pub fn parameterized<GG>(f: &mut fmt::Formatter,\n     let num_supplied_defaults = if verbose {\n         0\n     } else {\n-        // It is important to execute this conditionally, only if -Z\n-        // verbose is false. Otherwise, debug logs can sometimes cause\n-        // ICEs trying to fetch the generics early in the pipeline. This\n-        // is kind of a hacky workaround in that -Z verbose is required to\n-        // avoid those ICEs.\n         ty::tls::with(|tcx| {\n-            number_of_supplied_defaults(tcx, substs, subst::TypeSpace, get_generics)\n+            if let Some(generics) = get_generics(tcx) {\n+                number_of_supplied_defaults(tcx, substs, subst::TypeSpace, generics)\n+            } else {\n+                0\n+            }\n         })\n     };\n \n@@ -312,7 +309,7 @@ impl<'tcx> fmt::Display for TraitAndProjections<'tcx> {\n                       trait_ref.def_id,\n                       Ns::Type,\n                       projection_bounds,\n-                      |tcx| tcx.lookup_trait_def(trait_ref.def_id).generics.clone())\n+                      |tcx| Some(tcx.lookup_trait_def(trait_ref.def_id).generics.clone()))\n     }\n }\n \n@@ -814,7 +811,7 @@ impl fmt::Display for ty::Binder<ty::OutlivesPredicate<ty::Region, ty::Region>>\n impl<'tcx> fmt::Display for ty::TraitRef<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         parameterized(f, self.substs, self.def_id, Ns::Type, &[],\n-                      |tcx| tcx.lookup_trait_def(self.def_id).generics.clone())\n+                      |tcx| Some(tcx.lookup_trait_def(self.def_id).generics.clone()))\n     }\n }\n \n@@ -866,8 +863,9 @@ impl<'tcx> fmt::Display for ty::TypeVariants<'tcx> {\n                 }\n \n                 write!(f, \"{} {{\", bare_fn.sig.0)?;\n-                parameterized(f, substs, def_id, Ns::Value, &[],\n-                              |tcx| tcx.lookup_item_type(def_id).generics)?;\n+                parameterized(\n+                    f, substs, def_id, Ns::Value, &[],\n+                    |tcx| tcx.opt_lookup_item_type(def_id).map(|t| t.generics))?;\n                 write!(f, \"}}\")\n             }\n             TyFnPtr(ref bare_fn) => {\n@@ -890,8 +888,12 @@ impl<'tcx> fmt::Display for ty::TypeVariants<'tcx> {\n                           !tcx.tcache.borrow().contains_key(&def.did) {\n                         write!(f, \"{}<..>\", tcx.item_path_str(def.did))\n                     } else {\n-                        parameterized(f, substs, def.did, Ns::Type, &[],\n-                                      |tcx| tcx.lookup_item_type(def.did).generics)\n+                        parameterized(\n+                            f, substs, def.did, Ns::Type, &[],\n+                            |tcx| {\n+                                tcx.opt_lookup_item_type(def.did).\n+                                    map(|t| t.generics)\n+                            })\n                     }\n                 })\n             }"}, {"sha": "293d2863733f759aee055d487cfb2c9c6dfaa4f7", "filename": "src/librustc_borrowck/borrowck/mir/dataflow/mod.rs", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/f97c411548f2b64f74f2bcb84dcc37075c05e2a0/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f97c411548f2b64f74f2bcb84dcc37075c05e2a0/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fmod.rs?ref=f97c411548f2b64f74f2bcb84dcc37075c05e2a0", "patch": "@@ -200,6 +200,12 @@ impl<'a, 'tcx: 'a, O> DataflowAnalysis<'a, 'tcx, O>\n \n pub struct DataflowResults<O>(DataflowState<O>) where O: BitDenotation;\n \n+impl<O: BitDenotation> DataflowResults<O> {\n+    pub fn sets(&self) -> &AllSets<O::Idx> {\n+        &self.0.sets\n+    }\n+}\n+\n // FIXME: This type shouldn't be public, but the graphviz::MirWithFlowState trait\n // references it in a method signature. Look into using `pub(crate)` to address this.\n pub struct DataflowState<O: BitDenotation>\n@@ -444,10 +450,17 @@ impl<'a, 'tcx: 'a, D> DataflowAnalysis<'a, 'tcx, D>\n             repr::TerminatorKind::Return |\n             repr::TerminatorKind::Resume => {}\n             repr::TerminatorKind::Goto { ref target } |\n-            repr::TerminatorKind::Drop { ref target, value: _, unwind: None } => {\n+            repr::TerminatorKind::Drop { ref target, location: _, unwind: None } |\n+\n+            repr::TerminatorKind::DropAndReplace {\n+                ref target, value: _, location: _, unwind: None\n+            } => {\n                 self.propagate_bits_into_entry_set_for(in_out, changed, target);\n             }\n-            repr::TerminatorKind::Drop { ref target, value: _, unwind: Some(ref unwind) } => {\n+            repr::TerminatorKind::Drop { ref target, location: _, unwind: Some(ref unwind) } |\n+            repr::TerminatorKind::DropAndReplace {\n+                ref target, value: _, location: _, unwind: Some(ref unwind)\n+            } => {\n                 self.propagate_bits_into_entry_set_for(in_out, changed, target);\n                 self.propagate_bits_into_entry_set_for(in_out, changed, unwind);\n             }"}, {"sha": "e783420fa065ce138f68361141b56e03386ce527", "filename": "src/librustc_borrowck/borrowck/mir/elaborate_drops.rs", "status": "added", "additions": 1048, "deletions": 0, "changes": 1048, "blob_url": "https://github.com/rust-lang/rust/blob/f97c411548f2b64f74f2bcb84dcc37075c05e2a0/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f97c411548f2b64f74f2bcb84dcc37075c05e2a0/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs?ref=f97c411548f2b64f74f2bcb84dcc37075c05e2a0", "patch": "@@ -0,0 +1,1048 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use indexed_set::IdxSetBuf;\n+use super::gather_moves::{MoveData, MovePathIndex, MovePathContent, Location};\n+use super::dataflow::{MaybeInitializedLvals, MaybeUninitializedLvals};\n+use super::dataflow::{DataflowResults};\n+use super::{drop_flag_effects_for_location, on_all_children_bits};\n+use super::{DropFlagState, MoveDataParamEnv};\n+use super::patch::MirPatch;\n+use rustc::ty::{self, Ty, TyCtxt};\n+use rustc::ty::subst::{Subst, Substs, VecPerParamSpace};\n+use rustc::mir::repr::*;\n+use rustc::mir::transform::{Pass, MirPass, MirSource};\n+use rustc::middle::const_val::ConstVal;\n+use rustc::middle::lang_items;\n+use rustc::util::nodemap::FnvHashMap;\n+use rustc_mir::pretty;\n+use syntax::codemap::Span;\n+\n+use std::fmt;\n+use std::u32;\n+\n+pub struct ElaborateDrops;\n+\n+impl<'tcx> MirPass<'tcx> for ElaborateDrops {\n+    fn run_pass<'a>(&mut self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                    src: MirSource, mir: &mut Mir<'tcx>)\n+    {\n+        debug!(\"elaborate_drops({:?} @ {:?})\", src, mir.span);\n+        match src {\n+            MirSource::Fn(..) => {},\n+            _ => return\n+        }\n+        let id = src.item_id();\n+        let param_env = ty::ParameterEnvironment::for_item(tcx, id);\n+        let move_data = MoveData::gather_moves(mir, tcx);\n+        let elaborate_patch = {\n+            let mir = &*mir;\n+            let env = MoveDataParamEnv {\n+                move_data: move_data,\n+                param_env: param_env\n+            };\n+            let flow_inits =\n+                super::do_dataflow(tcx, mir, id, &[], &env,\n+                                   MaybeInitializedLvals::new(tcx, mir));\n+            let flow_uninits =\n+                super::do_dataflow(tcx, mir, id, &[], &env,\n+                                   MaybeUninitializedLvals::new(tcx, mir));\n+\n+            ElaborateDropsCtxt {\n+                tcx: tcx,\n+                mir: mir,\n+                env: &env,\n+                flow_inits: flow_inits,\n+                flow_uninits: flow_uninits,\n+                drop_flags: FnvHashMap(),\n+                patch: MirPatch::new(mir),\n+            }.elaborate()\n+        };\n+        pretty::dump_mir(tcx, \"elaborate_drops\", &0, src, mir, None);\n+        elaborate_patch.apply(mir);\n+        pretty::dump_mir(tcx, \"elaborate_drops\", &1, src, mir, None);\n+    }\n+}\n+\n+impl Pass for ElaborateDrops {}\n+\n+struct InitializationData {\n+    live: IdxSetBuf<MovePathIndex>,\n+    dead: IdxSetBuf<MovePathIndex>\n+}\n+\n+impl InitializationData {\n+    fn apply_location<'a,'tcx>(&mut self,\n+                               tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                               mir: &Mir<'tcx>,\n+                               env: &MoveDataParamEnv<'tcx>,\n+                               loc: Location)\n+    {\n+        drop_flag_effects_for_location(tcx, mir, env, loc, |path, df| {\n+            debug!(\"at location {:?}: setting {:?} to {:?}\",\n+                   loc, path, df);\n+            match df {\n+                DropFlagState::Present => {\n+                    self.live.add(&path);\n+                    self.dead.remove(&path);\n+                }\n+                DropFlagState::Absent => {\n+                    self.dead.add(&path);\n+                    self.live.remove(&path);\n+                }\n+            }\n+        });\n+    }\n+\n+    fn state(&self, path: MovePathIndex) -> (bool, bool) {\n+        (self.live.contains(&path), self.dead.contains(&path))\n+    }\n+}\n+\n+impl fmt::Debug for InitializationData {\n+    fn fmt(&self, _f: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n+        Ok(())\n+    }\n+}\n+\n+struct ElaborateDropsCtxt<'a, 'tcx: 'a> {\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    mir: &'a Mir<'tcx>,\n+    env: &'a MoveDataParamEnv<'tcx>,\n+    flow_inits: DataflowResults<MaybeInitializedLvals<'a, 'tcx>>,\n+    flow_uninits:  DataflowResults<MaybeUninitializedLvals<'a, 'tcx>>,\n+    drop_flags: FnvHashMap<MovePathIndex, u32>,\n+    patch: MirPatch<'tcx>,\n+}\n+\n+#[derive(Copy, Clone, Debug)]\n+struct DropCtxt<'a, 'tcx: 'a> {\n+    span: Span,\n+    scope: ScopeId,\n+    is_cleanup: bool,\n+\n+    init_data: &'a InitializationData,\n+\n+    lvalue: &'a Lvalue<'tcx>,\n+    path: MovePathIndex,\n+    succ: BasicBlock,\n+    unwind: Option<BasicBlock>\n+}\n+\n+impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n+    fn move_data(&self) -> &'b MoveData<'tcx> { &self.env.move_data }\n+    fn param_env(&self) -> &'b ty::ParameterEnvironment<'tcx> {\n+        &self.env.param_env\n+    }\n+\n+    fn initialization_data_at(&self, loc: Location) -> InitializationData {\n+        let mut data = InitializationData {\n+            live: self.flow_inits.sets().on_entry_set_for(loc.block.index())\n+                .to_owned(),\n+            dead: self.flow_uninits.sets().on_entry_set_for(loc.block.index())\n+                .to_owned(),\n+        };\n+        for stmt in 0..loc.index {\n+            data.apply_location(self.tcx, self.mir, self.env,\n+                                Location { block: loc.block, index: stmt });\n+        }\n+        data\n+    }\n+\n+    fn create_drop_flag(&mut self, index: MovePathIndex) {\n+        let tcx = self.tcx;\n+        let patch = &mut self.patch;\n+        self.drop_flags.entry(index).or_insert_with(|| {\n+            patch.new_temp(tcx.types.bool)\n+        });\n+    }\n+\n+    fn drop_flag(&mut self, index: MovePathIndex) -> Option<Lvalue<'tcx>> {\n+        self.drop_flags.get(&index).map(|t| Lvalue::Temp(*t))\n+    }\n+\n+    /// create a patch that elaborates all drops in the input\n+    /// MIR.\n+    fn elaborate(mut self) -> MirPatch<'tcx>\n+    {\n+        self.collect_drop_flags();\n+\n+        self.elaborate_drops();\n+\n+        self.drop_flags_on_init();\n+        self.drop_flags_for_fn_rets();\n+        self.drop_flags_for_args();\n+        self.drop_flags_for_locs();\n+\n+        self.patch\n+    }\n+\n+    fn path_needs_drop(&self, path: MovePathIndex) -> bool\n+    {\n+        match self.move_data().move_paths[path].content {\n+            MovePathContent::Lvalue(ref lvalue) => {\n+                let ty = self.mir.lvalue_ty(self.tcx, lvalue).to_ty(self.tcx);\n+                debug!(\"path_needs_drop({:?}, {:?} : {:?})\", path, lvalue, ty);\n+\n+                self.tcx.type_needs_drop_given_env(ty, self.param_env())\n+            }\n+            _ => false\n+        }\n+    }\n+\n+    /// Returns whether this lvalue is tracked by drop elaboration. This\n+    /// includes all lvalues, except these behind references or arrays.\n+    ///\n+    /// Lvalues behind references or arrays are not tracked by elaboration\n+    /// and are always assumed to be initialized when accessible. As\n+    /// references and indexes can be reseated, trying to track them\n+    /// can only lead to trouble.\n+    fn lvalue_is_tracked(&self, lv: &Lvalue<'tcx>) -> bool\n+    {\n+        if let &Lvalue::Projection(ref data) = lv {\n+            self.lvalue_contents_are_tracked(&data.base)\n+        } else {\n+            true\n+        }\n+    }\n+\n+    fn lvalue_contents_are_tracked(&self, lv: &Lvalue<'tcx>) -> bool {\n+        let ty = self.mir.lvalue_ty(self.tcx, lv).to_ty(self.tcx);\n+        match ty.sty {\n+            ty::TyArray(..) | ty::TySlice(..) | ty::TyRef(..) | ty::TyRawPtr(..) => {\n+                false\n+            }\n+            _ => self.lvalue_is_tracked(lv)\n+        }\n+    }\n+\n+    fn collect_drop_flags(&mut self)\n+    {\n+        for bb in self.mir.all_basic_blocks() {\n+            let data = self.mir.basic_block_data(bb);\n+            let terminator = data.terminator();\n+            let location = match terminator.kind {\n+                TerminatorKind::Drop { ref location, .. } |\n+                TerminatorKind::DropAndReplace { ref location, .. } => location,\n+                _ => continue\n+            };\n+\n+            if !self.lvalue_is_tracked(location) {\n+                continue\n+            }\n+\n+            let init_data = self.initialization_data_at(Location {\n+                block: bb,\n+                index: data.statements.len()\n+            });\n+\n+            let path = self.move_data().rev_lookup.find(location);\n+            debug!(\"collect_drop_flags: {:?}, lv {:?} (index {:?})\",\n+                   bb, location, path);\n+\n+            on_all_children_bits(self.tcx, self.mir, self.move_data(), path, |child| {\n+                if self.path_needs_drop(child) {\n+                    let (maybe_live, maybe_dead) = init_data.state(child);\n+                    debug!(\"collect_drop_flags: collecting {:?} from {:?}@{:?} - {:?}\",\n+                           child, location, path, (maybe_live, maybe_dead));\n+                    if maybe_live && maybe_dead {\n+                        self.create_drop_flag(child)\n+                    }\n+                }\n+            });\n+        }\n+    }\n+\n+    fn elaborate_drops(&mut self)\n+    {\n+        for bb in self.mir.all_basic_blocks() {\n+            let data = self.mir.basic_block_data(bb);\n+            let loc = Location { block: bb, index: data.statements.len() };\n+            let terminator = data.terminator();\n+\n+            let resume_block = self.patch.resume_block();\n+            match terminator.kind {\n+                TerminatorKind::Drop { ref location, target, unwind } => {\n+                    let init_data = self.initialization_data_at(loc);\n+                    let path = self.move_data().rev_lookup.find(location);\n+                    self.elaborate_drop(&DropCtxt {\n+                        span: terminator.span,\n+                        scope: terminator.scope,\n+                        is_cleanup: data.is_cleanup,\n+                        init_data: &init_data,\n+                        lvalue: location,\n+                        path: path,\n+                        succ: target,\n+                        unwind: if data.is_cleanup {\n+                            None\n+                        } else {\n+                            Some(Option::unwrap_or(unwind, resume_block))\n+                        }\n+                    }, bb);\n+                }\n+                TerminatorKind::DropAndReplace { ref location, ref value,\n+                                                 target, unwind } =>\n+                {\n+                    assert!(!data.is_cleanup);\n+\n+                    self.elaborate_replace(\n+                        loc,\n+                        location, value,\n+                        target, unwind\n+                    );\n+                }\n+                _ => continue\n+            }\n+        }\n+    }\n+\n+    /// Elaborate a MIR `replace` terminator. This instruction\n+    /// is not directly handled by translation, and therefore\n+    /// must be desugared.\n+    ///\n+    /// The desugaring drops the location if needed, and then writes\n+    /// the value (including setting the drop flag) over it in *both* arms.\n+    ///\n+    /// The `replace` terminator can also be called on lvalues that\n+    /// are not tracked by elaboration (for example,\n+    /// `replace x[i] <- tmp0`). The borrow checker requires that\n+    /// these locations are initialized before the assignment,\n+    /// so we just generate an unconditional drop.\n+    fn elaborate_replace(\n+        &mut self,\n+        loc: Location,\n+        location: &Lvalue<'tcx>,\n+        value: &Operand<'tcx>,\n+        target: BasicBlock,\n+        unwind: Option<BasicBlock>)\n+    {\n+        let bb = loc.block;\n+        let data = self.mir.basic_block_data(bb);\n+        let terminator = data.terminator();\n+\n+        let assign = Statement {\n+            kind: StatementKind::Assign(location.clone(), Rvalue::Use(value.clone())),\n+            span: terminator.span,\n+            scope: terminator.scope\n+        };\n+\n+        let unwind = unwind.unwrap_or(self.patch.resume_block());\n+        let unwind = self.patch.new_block(BasicBlockData {\n+            statements: vec![assign.clone()],\n+            terminator: Some(Terminator {\n+                kind: TerminatorKind::Goto { target: unwind },\n+                ..*terminator\n+            }),\n+            is_cleanup: true\n+        });\n+\n+        let target = self.patch.new_block(BasicBlockData {\n+            statements: vec![assign],\n+            terminator: Some(Terminator {\n+                kind: TerminatorKind::Goto { target: target },\n+                ..*terminator\n+            }),\n+            is_cleanup: data.is_cleanup,\n+        });\n+\n+        if !self.lvalue_is_tracked(location) {\n+            // drop and replace behind a pointer/array/whatever. The location\n+            // must be initialized.\n+            debug!(\"elaborate_drop_and_replace({:?}) - untracked\", terminator);\n+            self.patch.patch_terminator(bb, TerminatorKind::Drop {\n+                location: location.clone(),\n+                target: target,\n+                unwind: Some(unwind)\n+            });\n+        } else {\n+            debug!(\"elaborate_drop_and_replace({:?}) - tracked\", terminator);\n+            let init_data = self.initialization_data_at(loc);\n+            let path = self.move_data().rev_lookup.find(location);\n+\n+            self.elaborate_drop(&DropCtxt {\n+                span: terminator.span,\n+                scope: terminator.scope,\n+                is_cleanup: data.is_cleanup,\n+                init_data: &init_data,\n+                lvalue: location,\n+                path: path,\n+                succ: target,\n+                unwind: Some(unwind)\n+            }, bb);\n+            on_all_children_bits(self.tcx, self.mir, self.move_data(), path, |child| {\n+                self.set_drop_flag(Location { block: target, index: 0 },\n+                                   child, DropFlagState::Present);\n+                self.set_drop_flag(Location { block: unwind, index: 0 },\n+                                   child, DropFlagState::Present);\n+            });\n+        }\n+    }\n+\n+    /// This elaborates a single drop instruction, located at `bb`, and\n+    /// patches over it.\n+    ///\n+    /// The elaborated drop checks the drop flags to only drop what\n+    /// is initialized.\n+    ///\n+    /// In addition, the relevant drop flags also need to be cleared\n+    /// to avoid double-drops. However, in the middle of a complex\n+    /// drop, one must avoid clearing some of the flags before they\n+    /// are read, as that would cause a memory leak.\n+    ///\n+    /// In particular, when dropping an ADT, multiple fields may be\n+    /// joined together under the `rest` subpath. They are all controlled\n+    /// by the primary drop flag, but only the last rest-field dropped\n+    /// should clear it (and it must also not clear anything else).\n+    ///\n+    /// FIXME: I think we should just control the flags externally\n+    /// and then we do not need this machinery.\n+    fn elaborate_drop<'a>(&mut self, c: &DropCtxt<'a, 'tcx>, bb: BasicBlock) {\n+        debug!(\"elaborate_drop({:?})\", c);\n+\n+        let mut some_live = false;\n+        let mut some_dead = false;\n+        let mut children_count = 0;\n+        on_all_children_bits(\n+            self.tcx, self.mir, self.move_data(),\n+            c.path, |child| {\n+                if self.path_needs_drop(child) {\n+                    let (live, dead) = c.init_data.state(child);\n+                    debug!(\"elaborate_drop: state({:?}) = {:?}\",\n+                           child, (live, dead));\n+                    some_live |= live;\n+                    some_dead |= dead;\n+                    children_count += 1;\n+                }\n+            });\n+\n+        debug!(\"elaborate_drop({:?}): live - {:?}\", c,\n+               (some_live, some_dead));\n+        match (some_live, some_dead) {\n+            (false, false) | (false, true) => {\n+                // dead drop - patch it out\n+                self.patch.patch_terminator(bb, TerminatorKind::Goto {\n+                    target: c.succ\n+                });\n+            }\n+            (true, false) => {\n+                // static drop - just set the flag\n+                self.patch.patch_terminator(bb, TerminatorKind::Drop {\n+                    location: c.lvalue.clone(),\n+                    target: c.succ,\n+                    unwind: c.unwind\n+                });\n+                self.drop_flags_for_drop(c, bb);\n+            }\n+            (true, true) => {\n+                // dynamic drop\n+                let drop_bb = if children_count == 1 || self.must_complete_drop(c) {\n+                    self.conditional_drop(c)\n+                } else {\n+                    self.open_drop(c)\n+                };\n+                self.patch.patch_terminator(bb, TerminatorKind::Goto {\n+                    target: drop_bb\n+                });\n+            }\n+        }\n+    }\n+\n+    /// Return the lvalue and move path for each field of `variant`,\n+    /// (the move path is `None` if the field is a rest field).\n+    fn move_paths_for_fields(&self,\n+                             base_lv: &Lvalue<'tcx>,\n+                             variant_path: MovePathIndex,\n+                             variant: ty::VariantDef<'tcx>,\n+                             substs: &'tcx Substs<'tcx>)\n+                             -> Vec<(Lvalue<'tcx>, Option<MovePathIndex>)>\n+    {\n+        let move_paths = &self.move_data().move_paths;\n+        variant.fields.iter().enumerate().map(|(i, f)| {\n+            let subpath =\n+                super::move_path_children_matching(move_paths, variant_path, |p| {\n+                    match p {\n+                        &Projection {\n+                            elem: ProjectionElem::Field(idx, _), ..\n+                        } => idx.index() == i,\n+                        _ => false\n+                    }\n+                });\n+\n+            let field_ty =\n+                self.tcx.normalize_associated_type_in_env(\n+                    &f.ty(self.tcx, substs),\n+                    self.param_env()\n+                );\n+            (base_lv.clone().field(Field::new(i), field_ty), subpath)\n+        }).collect()\n+    }\n+\n+    /// Create one-half of the drop ladder for a list of fields, and return\n+    /// the list of steps in it in reverse order.\n+    ///\n+    /// `unwind_ladder` is such a list of steps in reverse order,\n+    /// which is called instead of the next step if the drop unwinds\n+    /// (the first field is never reached). If it is `None`, all\n+    /// unwind targets are left blank.\n+    fn drop_halfladder<'a>(&mut self,\n+                           c: &DropCtxt<'a, 'tcx>,\n+                           unwind_ladder: Option<Vec<BasicBlock>>,\n+                           succ: BasicBlock,\n+                           fields: &[(Lvalue<'tcx>, Option<MovePathIndex>)],\n+                           is_cleanup: bool)\n+                           -> Vec<BasicBlock>\n+    {\n+        let mut succ = succ;\n+        let mut unwind_succ = if is_cleanup {\n+            None\n+        } else {\n+            c.unwind\n+        };\n+        let mut update_drop_flag = true;\n+\n+        fields.iter().rev().enumerate().map(|(i, &(ref lv, path))| {\n+            let drop_block = match path {\n+                Some(path) => {\n+                    debug!(\"drop_ladder: for std field {} ({:?})\", i, lv);\n+\n+                    self.elaborated_drop_block(&DropCtxt {\n+                        span: c.span,\n+                        scope: c.scope,\n+                        is_cleanup: is_cleanup,\n+                        init_data: c.init_data,\n+                        lvalue: lv,\n+                        path: path,\n+                        succ: succ,\n+                        unwind: unwind_succ,\n+                    })\n+                }\n+                None => {\n+                    debug!(\"drop_ladder: for rest field {} ({:?})\", i, lv);\n+\n+                    let blk = self.complete_drop(&DropCtxt {\n+                        span: c.span,\n+                        scope: c.scope,\n+                        is_cleanup: is_cleanup,\n+                        init_data: c.init_data,\n+                        lvalue: lv,\n+                        path: c.path,\n+                        succ: succ,\n+                        unwind: unwind_succ,\n+                    }, update_drop_flag);\n+\n+                    // the drop flag has been updated - updating\n+                    // it again would clobber it.\n+                    update_drop_flag = false;\n+\n+                    blk\n+                }\n+            };\n+\n+            succ = drop_block;\n+            unwind_succ = unwind_ladder.as_ref().map(|p| p[i]);\n+\n+            drop_block\n+        }).collect()\n+    }\n+\n+    /// Create a full drop ladder, consisting of 2 connected half-drop-ladders\n+    ///\n+    /// For example, with 3 fields, the drop ladder is\n+    ///\n+    /// .d0:\n+    ///     ELAB(drop location.0 [target=.d1, unwind=.c1])\n+    /// .d1:\n+    ///     ELAB(drop location.1 [target=.d2, unwind=.c2])\n+    /// .d2:\n+    ///     ELAB(drop location.2 [target=`c.succ`, unwind=`c.unwind`])\n+    /// .c1:\n+    ///     ELAB(drop location.1 [target=.c2])\n+    /// .c2:\n+    ///     ELAB(drop location.2 [target=`c.unwind])\n+    fn drop_ladder<'a>(&mut self,\n+                       c: &DropCtxt<'a, 'tcx>,\n+                       fields: &[(Lvalue<'tcx>, Option<MovePathIndex>)])\n+                       -> BasicBlock\n+    {\n+        debug!(\"drop_ladder({:?}, {:?})\", c, fields);\n+        let unwind_ladder = if c.is_cleanup {\n+            None\n+        } else {\n+            Some(self.drop_halfladder(c, None, c.unwind.unwrap(), &fields, true))\n+        };\n+\n+        self.drop_halfladder(c, unwind_ladder, c.succ, fields, c.is_cleanup)\n+            .last().cloned().unwrap_or(c.succ)\n+    }\n+\n+    fn open_drop_for_tuple<'a>(&mut self, c: &DropCtxt<'a, 'tcx>, tys: &[Ty<'tcx>])\n+                               -> BasicBlock\n+    {\n+        debug!(\"open_drop_for_tuple({:?}, {:?})\", c, tys);\n+\n+        let fields: Vec<_> = tys.iter().enumerate().map(|(i, &ty)| {\n+            (c.lvalue.clone().field(Field::new(i), ty),\n+             super::move_path_children_matching(\n+                 &self.move_data().move_paths, c.path, |proj| match proj {\n+                     &Projection {\n+                         elem: ProjectionElem::Field(f, _), ..\n+                     } => f.index() == i,\n+                     _ => false\n+                 }\n+            ))\n+        }).collect();\n+\n+        self.drop_ladder(c, &fields)\n+    }\n+\n+    fn open_drop_for_box<'a>(&mut self, c: &DropCtxt<'a, 'tcx>, ty: Ty<'tcx>)\n+                             -> BasicBlock\n+    {\n+        debug!(\"open_drop_for_box({:?}, {:?})\", c, ty);\n+\n+        let interior_path = super::move_path_children_matching(\n+            &self.move_data().move_paths, c.path, |proj| match proj {\n+                &Projection { elem: ProjectionElem::Deref, .. } => true,\n+                _ => false\n+            }).unwrap();\n+\n+        let interior = c.lvalue.clone().deref();\n+        let inner_c = DropCtxt {\n+            lvalue: &interior,\n+            unwind: c.unwind.map(|u| {\n+                self.box_free_block(c, ty, u, true)\n+            }),\n+            succ: self.box_free_block(c, ty, c.succ, c.is_cleanup),\n+            path: interior_path,\n+            ..*c\n+        };\n+\n+        self.elaborated_drop_block(&inner_c)\n+    }\n+\n+    fn open_drop_for_variant<'a>(&mut self,\n+                                 c: &DropCtxt<'a, 'tcx>,\n+                                 drop_block: &mut Option<BasicBlock>,\n+                                 adt: ty::AdtDef<'tcx>,\n+                                 substs: &'tcx Substs<'tcx>,\n+                                 variant_index: usize)\n+                                 -> BasicBlock\n+    {\n+        let move_paths = &self.move_data().move_paths;\n+\n+        let subpath = super::move_path_children_matching(\n+            move_paths, c.path, |proj| match proj {\n+                &Projection {\n+                    elem: ProjectionElem::Downcast(_, idx), ..\n+                } => idx == variant_index,\n+                _ => false\n+            });\n+\n+        if let Some(variant_path) = subpath {\n+            let base_lv = c.lvalue.clone().elem(\n+                ProjectionElem::Downcast(adt, variant_index)\n+            );\n+            let fields = self.move_paths_for_fields(\n+                &base_lv,\n+                variant_path,\n+                &adt.variants[variant_index],\n+                substs);\n+            self.drop_ladder(c, &fields)\n+        } else {\n+            // variant not found - drop the entire enum\n+            if let None = *drop_block {\n+                *drop_block = Some(self.complete_drop(c, true));\n+            }\n+            return drop_block.unwrap();\n+        }\n+    }\n+\n+    fn open_drop_for_adt<'a>(&mut self, c: &DropCtxt<'a, 'tcx>,\n+                             adt: ty::AdtDef<'tcx>, substs: &'tcx Substs<'tcx>)\n+                             -> BasicBlock {\n+        debug!(\"open_drop_for_adt({:?}, {:?}, {:?})\", c, adt, substs);\n+\n+        let mut drop_block = None;\n+\n+        match adt.variants.len() {\n+            1 => {\n+                let fields = self.move_paths_for_fields(\n+                    c.lvalue,\n+                    c.path,\n+                    &adt.variants[0],\n+                    substs\n+                );\n+                self.drop_ladder(c, &fields)\n+            }\n+            _ => {\n+                let variant_drops : Vec<BasicBlock> =\n+                    (0..adt.variants.len()).map(|i| {\n+                        self.open_drop_for_variant(c, &mut drop_block,\n+                                                   adt, substs, i)\n+                    }).collect();\n+\n+                // If there are multiple variants, then if something\n+                // is present within the enum the discriminant, tracked\n+                // by the rest path, must be initialized.\n+                //\n+                // Additionally, we do not want to switch on the\n+                // discriminant after it is free-ed, because that\n+                // way lies only trouble.\n+\n+                let switch_block = self.new_block(\n+                    c, c.is_cleanup, TerminatorKind::Switch {\n+                        discr: c.lvalue.clone(),\n+                        adt_def: adt,\n+                        targets: variant_drops\n+                    });\n+\n+                self.drop_flag_test_block(c, switch_block)\n+            }\n+        }\n+    }\n+\n+    /// The slow-path - create an \"open\", elaborated drop for a type\n+    /// which is moved-out-of only partially, and patch `bb` to a jump\n+    /// to it. This must not be called on ADTs with a destructor,\n+    /// as these can't be moved-out-of, except for `Box<T>`, which is\n+    /// special-cased.\n+    ///\n+    /// This creates a \"drop ladder\" that drops the needed fields of the\n+    /// ADT, both in the success case or if one of the destructors fail.\n+    fn open_drop<'a>(&mut self, c: &DropCtxt<'a, 'tcx>) -> BasicBlock {\n+        let ty = self.mir.lvalue_ty(self.tcx, c.lvalue).to_ty(self.tcx);\n+        match ty.sty {\n+            ty::TyStruct(def, substs) | ty::TyEnum(def, substs) => {\n+                self.open_drop_for_adt(c, def, substs)\n+            }\n+            ty::TyTuple(tys) | ty::TyClosure(_, ty::ClosureSubsts {\n+                upvar_tys: tys, ..\n+            }) => {\n+                self.open_drop_for_tuple(c, tys)\n+            }\n+            ty::TyBox(ty) => {\n+                self.open_drop_for_box(c, ty)\n+            }\n+            _ => bug!(\"open drop from non-ADT `{:?}`\", ty)\n+        }\n+    }\n+\n+    /// Return a basic block that drop an lvalue using the context\n+    /// and path in `c`. If `update_drop_flag` is true, also\n+    /// clear `c`.\n+    ///\n+    /// if FLAG(c.path)\n+    ///     if(update_drop_flag) FLAG(c.path) = false\n+    ///     drop(c.lv)\n+    fn complete_drop<'a>(\n+        &mut self,\n+        c: &DropCtxt<'a, 'tcx>,\n+        update_drop_flag: bool)\n+        -> BasicBlock\n+    {\n+        debug!(\"complete_drop({:?},{:?})\", c, update_drop_flag);\n+\n+        let drop_block = self.drop_block(c);\n+        if update_drop_flag {\n+            self.set_drop_flag(\n+                Location { block: drop_block, index: 0 },\n+                c.path,\n+                DropFlagState::Absent\n+            );\n+        }\n+\n+        self.drop_flag_test_block(c, drop_block)\n+    }\n+\n+    /// Create a simple conditional drop.\n+    ///\n+    /// if FLAG(c.lv)\n+    ///     FLAGS(c.lv) = false\n+    ///     drop(c.lv)\n+    fn conditional_drop<'a>(&mut self, c: &DropCtxt<'a, 'tcx>)\n+                            -> BasicBlock\n+    {\n+        debug!(\"conditional_drop({:?})\", c);\n+        let drop_bb = self.drop_block(c);\n+        self.drop_flags_for_drop(c, drop_bb);\n+\n+        self.drop_flag_test_block(c, drop_bb)\n+    }\n+\n+    fn new_block<'a>(&mut self,\n+                     c: &DropCtxt<'a, 'tcx>,\n+                     is_cleanup: bool,\n+                     k: TerminatorKind<'tcx>)\n+                     -> BasicBlock\n+    {\n+        self.patch.new_block(BasicBlockData {\n+            statements: vec![],\n+            terminator: Some(Terminator {\n+                scope: c.scope, span: c.span, kind: k\n+            }),\n+            is_cleanup: is_cleanup\n+        })\n+    }\n+\n+    fn elaborated_drop_block<'a>(&mut self, c: &DropCtxt<'a, 'tcx>) -> BasicBlock {\n+        debug!(\"elaborated_drop_block({:?})\", c);\n+        let blk = self.drop_block(c);\n+        self.elaborate_drop(c, blk);\n+        blk\n+    }\n+\n+    fn drop_flag_test_block<'a>(&mut self,\n+                                c: &DropCtxt<'a, 'tcx>,\n+                                on_set: BasicBlock)\n+                                -> BasicBlock {\n+        self.drop_flag_test_block_with_succ(c, c.is_cleanup, on_set, c.succ)\n+    }\n+\n+    fn drop_flag_test_block_with_succ<'a>(&mut self,\n+                                          c: &DropCtxt<'a, 'tcx>,\n+                                          is_cleanup: bool,\n+                                          on_set: BasicBlock,\n+                                          on_unset: BasicBlock)\n+                                          -> BasicBlock\n+    {\n+        let (maybe_live, maybe_dead) = c.init_data.state(c.path);\n+        debug!(\"drop_flag_test_block({:?},{:?},{:?}) - {:?}\",\n+               c, is_cleanup, on_set, (maybe_live, maybe_dead));\n+\n+        match (maybe_live, maybe_dead) {\n+            (false, _) => on_unset,\n+            (true, false) => on_set,\n+            (true, true) => {\n+                let flag = self.drop_flag(c.path).unwrap();\n+                self.new_block(c, is_cleanup, TerminatorKind::If {\n+                    cond: Operand::Consume(flag),\n+                    targets: (on_set, on_unset)\n+                })\n+            }\n+        }\n+    }\n+\n+    fn drop_block<'a>(&mut self, c: &DropCtxt<'a, 'tcx>) -> BasicBlock {\n+        self.new_block(c, c.is_cleanup, TerminatorKind::Drop {\n+            location: c.lvalue.clone(),\n+            target: c.succ,\n+            unwind: c.unwind\n+        })\n+    }\n+\n+    fn box_free_block<'a>(\n+        &mut self,\n+        c: &DropCtxt<'a, 'tcx>,\n+        ty: Ty<'tcx>,\n+        target: BasicBlock,\n+        is_cleanup: bool\n+    ) -> BasicBlock {\n+        let block = self.unelaborated_free_block(c, ty, target, is_cleanup);\n+        self.drop_flag_test_block_with_succ(c, is_cleanup, block, target)\n+    }\n+\n+    fn unelaborated_free_block<'a>(\n+        &mut self,\n+        c: &DropCtxt<'a, 'tcx>,\n+        ty: Ty<'tcx>,\n+        target: BasicBlock,\n+        is_cleanup: bool\n+    ) -> BasicBlock {\n+        let mut statements = vec![];\n+        if let Some(&flag) = self.drop_flags.get(&c.path) {\n+            statements.push(Statement {\n+                span: c.span,\n+                scope: c.scope,\n+                kind: StatementKind::Assign(\n+                    Lvalue::Temp(flag),\n+                    self.constant_bool(c.span, false)\n+                )\n+            });\n+        }\n+\n+        let tcx = self.tcx;\n+        let unit_temp = Lvalue::Temp(self.patch.new_temp(tcx.mk_nil()));\n+        let free_func = tcx.lang_items.require(lang_items::BoxFreeFnLangItem)\n+            .unwrap_or_else(|e| tcx.sess.fatal(&e));\n+        let substs = tcx.mk_substs(Substs::new(\n+            VecPerParamSpace::new(vec![], vec![], vec![ty]),\n+            VecPerParamSpace::new(vec![], vec![], vec![])\n+        ));\n+        let fty = tcx.lookup_item_type(free_func).ty.subst(tcx, substs);\n+\n+        self.patch.new_block(BasicBlockData {\n+            statements: statements,\n+            terminator: Some(Terminator {\n+                scope: c.scope, span: c.span, kind: TerminatorKind::Call {\n+                    func: Operand::Constant(Constant {\n+                        span: c.span,\n+                        ty: fty,\n+                        literal: Literal::Item {\n+                            def_id: free_func,\n+                            substs: substs\n+                        }\n+                    }),\n+                    args: vec![Operand::Consume(c.lvalue.clone())],\n+                    destination: Some((unit_temp, target)),\n+                    cleanup: None\n+                }\n+            }),\n+            is_cleanup: is_cleanup\n+        })\n+    }\n+\n+    fn must_complete_drop<'a>(&self, c: &DropCtxt<'a, 'tcx>) -> bool {\n+        // if we have a destuctor, we must *not* split the drop.\n+\n+        // dataflow can create unneeded children in some cases\n+        // - be sure to ignore them.\n+\n+        let ty = self.mir.lvalue_ty(self.tcx, c.lvalue).to_ty(self.tcx);\n+\n+        match ty.sty {\n+            ty::TyStruct(def, _) | ty::TyEnum(def, _) => {\n+                if def.has_dtor() {\n+                    self.tcx.sess.span_warn(\n+                        c.span,\n+                        &format!(\"dataflow bug??? moving out of type with dtor {:?}\",\n+                                 c));\n+                    true\n+                } else {\n+                    false\n+                }\n+            }\n+            _ => false\n+        }\n+    }\n+\n+    fn constant_bool(&self, span: Span, val: bool) -> Rvalue<'tcx> {\n+        Rvalue::Use(Operand::Constant(Constant {\n+            span: span,\n+            ty: self.tcx.types.bool,\n+            literal: Literal::Value { value: ConstVal::Bool(val) }\n+        }))\n+    }\n+\n+    fn set_drop_flag(&mut self, loc: Location, path: MovePathIndex, val: DropFlagState) {\n+        if let Some(&flag) = self.drop_flags.get(&path) {\n+            let span = self.patch.context_for_location(self.mir, loc).0;\n+            let val = self.constant_bool(span, val.value());\n+            self.patch.add_assign(loc, Lvalue::Temp(flag), val);\n+        }\n+    }\n+\n+    fn drop_flags_on_init(&mut self) {\n+        let loc = Location { block: START_BLOCK, index: 0 };\n+        let span = self.patch.context_for_location(self.mir, loc).0;\n+        let false_ = self.constant_bool(span, false);\n+        for flag in self.drop_flags.values() {\n+            self.patch.add_assign(loc, Lvalue::Temp(*flag), false_.clone());\n+        }\n+    }\n+\n+    fn drop_flags_for_fn_rets(&mut self) {\n+        for bb in self.mir.all_basic_blocks() {\n+            let data = self.mir.basic_block_data(bb);\n+            if let TerminatorKind::Call {\n+                destination: Some((ref lv, tgt)), cleanup: Some(_), ..\n+            } = data.terminator().kind {\n+                assert!(!self.patch.is_patched(bb));\n+\n+                let loc = Location { block: tgt, index: 0 };\n+                let path = self.move_data().rev_lookup.find(lv);\n+                on_all_children_bits(\n+                    self.tcx, self.mir, self.move_data(), path,\n+                    |child| self.set_drop_flag(loc, child, DropFlagState::Present)\n+                );\n+            }\n+        }\n+    }\n+\n+    fn drop_flags_for_args(&mut self) {\n+        let loc = Location { block: START_BLOCK, index: 0 };\n+        super::drop_flag_effects_for_function_entry(\n+            self.tcx, self.mir, self.env, |path, ds| {\n+                self.set_drop_flag(loc, path, ds);\n+            }\n+        )\n+    }\n+\n+    fn drop_flags_for_locs(&mut self) {\n+        // We intentionally iterate only over the *old* basic blocks.\n+        //\n+        // Basic blocks created by drop elaboration update their\n+        // drop flags by themselves, to avoid the drop flags being\n+        // clobbered before they are read.\n+\n+        for bb in self.mir.all_basic_blocks() {\n+            let data = self.mir.basic_block_data(bb);\n+            debug!(\"drop_flags_for_locs({:?})\", data);\n+            for i in 0..(data.statements.len()+1) {\n+                debug!(\"drop_flag_for_locs: stmt {}\", i);\n+                let mut allow_initializations = true;\n+                if i == data.statements.len() {\n+                    match data.terminator().kind {\n+                        TerminatorKind::Drop { .. } => {\n+                            // drop elaboration should handle that by itself\n+                            continue\n+                        }\n+                        TerminatorKind::DropAndReplace { .. } => {\n+                            // this contains the move of the source and\n+                            // the initialization of the destination. We\n+                            // only want the former - the latter is handled\n+                            // by the elaboration code and must be done\n+                            // *after* the destination is dropped.\n+                            assert!(self.patch.is_patched(bb));\n+                            allow_initializations = false;\n+                        }\n+                        _ => {\n+                            assert!(!self.patch.is_patched(bb));\n+                        }\n+                    }\n+                }\n+                let loc = Location { block: bb, index: i };\n+                super::drop_flag_effects_for_location(\n+                    self.tcx, self.mir, self.env, loc, |path, ds| {\n+                        if ds == DropFlagState::Absent || allow_initializations {\n+                            self.set_drop_flag(loc, path, ds)\n+                        }\n+                    }\n+                )\n+            }\n+\n+            // There may be a critical edge after this call,\n+            // so mark the return as initialized *before* the\n+            // call.\n+            if let TerminatorKind::Call {\n+                destination: Some((ref lv, _)), cleanup: None, ..\n+            } = data.terminator().kind {\n+                assert!(!self.patch.is_patched(bb));\n+\n+                let loc = Location { block: bb, index: data.statements.len() };\n+                let path = self.move_data().rev_lookup.find(lv);\n+                on_all_children_bits(\n+                    self.tcx, self.mir, self.move_data(), path,\n+                    |child| self.set_drop_flag(loc, child, DropFlagState::Present)\n+                );\n+            }\n+        }\n+    }\n+\n+    fn drop_flags_for_drop<'a>(&mut self,\n+                               c: &DropCtxt<'a, 'tcx>,\n+                               bb: BasicBlock)\n+    {\n+        let loc = self.patch.terminator_loc(self.mir, bb);\n+        on_all_children_bits(\n+            self.tcx, self.mir, self.move_data(), c.path,\n+            |child| self.set_drop_flag(loc, child, DropFlagState::Absent)\n+        );\n+    }\n+}"}, {"sha": "fcaa655f749d53421c466b2c496dccdb6fc9287d", "filename": "src/librustc_borrowck/borrowck/mir/gather_moves.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f97c411548f2b64f74f2bcb84dcc37075c05e2a0/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f97c411548f2b64f74f2bcb84dcc37075c05e2a0/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs?ref=f97c411548f2b64f74f2bcb84dcc37075c05e2a0", "patch": "@@ -671,10 +671,18 @@ fn gather_moves<'a, 'tcx>(mir: &Mir<'tcx>, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> MoveD\n                 let _ = discr;\n             }\n \n-            TerminatorKind::Drop { value: ref lval, target: _, unwind: _ } => {\n+            TerminatorKind::Drop { ref location, target: _, unwind: _ } => {\n                 let source = Location { block: bb,\n                                         index: bb_data.statements.len() };\n-                bb_ctxt.on_move_out_lval(SK::Drop, lval, source);\n+                bb_ctxt.on_move_out_lval(SK::Drop, location, source);\n+            }\n+            TerminatorKind::DropAndReplace { ref location, ref value, .. } => {\n+                let assigned_path = bb_ctxt.builder.move_path_for(location);\n+                bb_ctxt.path_map.fill_to(assigned_path.idx());\n+\n+                let source = Location { block: bb,\n+                                        index: bb_data.statements.len() };\n+                bb_ctxt.on_operand(SK::Use, value, source);\n             }\n             TerminatorKind::Call { ref func, ref args, ref destination, cleanup: _ } => {\n                 let source = Location { block: bb,"}, {"sha": "007cde156f40f12ca3496dfaf064394d4a73b43a", "filename": "src/librustc_borrowck/borrowck/mir/mod.rs", "status": "modified", "additions": 46, "deletions": 5, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/f97c411548f2b64f74f2bcb84dcc37075c05e2a0/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f97c411548f2b64f74f2bcb84dcc37075c05e2a0/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs?ref=f97c411548f2b64f74f2bcb84dcc37075c05e2a0", "patch": "@@ -24,8 +24,10 @@ use rustc::session::Session;\n use rustc::ty::{self, TyCtxt};\n \n mod abs_domain;\n+pub mod elaborate_drops;\n mod dataflow;\n mod gather_moves;\n+mod patch;\n // mod graphviz;\n \n use self::dataflow::{BitDenotation};\n@@ -34,7 +36,7 @@ use self::dataflow::{Dataflow, DataflowAnalysis, DataflowResults};\n use self::dataflow::{MaybeInitializedLvals, MaybeUninitializedLvals};\n use self::dataflow::{DefinitelyInitializedLvals};\n use self::gather_moves::{MoveData, MovePathIndex, Location};\n-use self::gather_moves::{MovePathContent};\n+use self::gather_moves::{MovePathContent, MovePathData};\n \n fn has_rustc_mir_with(attrs: &[ast::Attribute], name: &str) -> Option<P<MetaItem>> {\n     for attr in attrs {\n@@ -202,6 +204,37 @@ enum DropFlagState {\n     Absent, // i.e. deinitialized or \"moved\"\n }\n \n+impl DropFlagState {\n+    fn value(self) -> bool {\n+        match self {\n+            DropFlagState::Present => true,\n+            DropFlagState::Absent => false\n+        }\n+    }\n+}\n+\n+fn move_path_children_matching<'tcx, F>(move_paths: &MovePathData<'tcx>,\n+                                        path: MovePathIndex,\n+                                        mut cond: F)\n+                                        -> Option<MovePathIndex>\n+    where F: FnMut(&repr::LvalueProjection<'tcx>) -> bool\n+{\n+    let mut next_child = move_paths[path].first_child;\n+    while let Some(child_index) = next_child {\n+        match move_paths[child_index].content {\n+            MovePathContent::Lvalue(repr::Lvalue::Projection(ref proj)) => {\n+                if cond(proj) {\n+                    return Some(child_index)\n+                }\n+            }\n+            _ => {}\n+        }\n+        next_child = move_paths[child_index].next_sibling;\n+    }\n+\n+    None\n+}\n+\n fn on_all_children_bits<'a, 'tcx, F>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     mir: &Mir<'tcx>,\n@@ -309,15 +342,23 @@ fn drop_flag_effects_for_location<'a, 'tcx, F>(\n         Some(stmt) => match stmt.kind {\n             repr::StatementKind::Assign(ref lvalue, _) => {\n                 debug!(\"drop_flag_effects: assignment {:?}\", stmt);\n-                on_all_children_bits(tcx, mir, move_data,\n+                 on_all_children_bits(tcx, mir, move_data,\n                                      move_data.rev_lookup.find(lvalue),\n                                      |moi| callback(moi, DropFlagState::Present))\n             }\n         },\n         None => {\n-            // terminator - no move-ins except for function return edge\n-            let term = bb.terminator();\n-            debug!(\"drop_flag_effects: terminator {:?}\", term);\n+            debug!(\"drop_flag_effects: replace {:?}\", bb.terminator());\n+            match bb.terminator().kind {\n+                repr::TerminatorKind::DropAndReplace { ref location, .. } => {\n+                    on_all_children_bits(tcx, mir, move_data,\n+                                         move_data.rev_lookup.find(location),\n+                                         |moi| callback(moi, DropFlagState::Present))\n+                }\n+                _ => {\n+                    // other terminators do not contain move-ins\n+                }\n+            }\n         }\n     }\n }"}, {"sha": "b390c19af1a5beadccbd90556e37f8d25281aa1b", "filename": "src/librustc_borrowck/borrowck/mir/patch.rs", "status": "added", "additions": 184, "deletions": 0, "changes": 184, "blob_url": "https://github.com/rust-lang/rust/blob/f97c411548f2b64f74f2bcb84dcc37075c05e2a0/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fpatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f97c411548f2b64f74f2bcb84dcc37075c05e2a0/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fpatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fpatch.rs?ref=f97c411548f2b64f74f2bcb84dcc37075c05e2a0", "patch": "@@ -0,0 +1,184 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use super::gather_moves::Location;\n+use rustc::ty::Ty;\n+use rustc::mir::repr::*;\n+use syntax::codemap::Span;\n+\n+use std::iter;\n+use std::u32;\n+\n+/// This struct represents a patch to MIR, which can add\n+/// new statements and basic blocks and patch over block\n+/// terminators.\n+pub struct MirPatch<'tcx> {\n+    patch_map: Vec<Option<TerminatorKind<'tcx>>>,\n+    new_blocks: Vec<BasicBlockData<'tcx>>,\n+    new_statements: Vec<(Location, StatementKind<'tcx>)>,\n+    new_temps: Vec<TempDecl<'tcx>>,\n+    resume_block: BasicBlock,\n+    next_temp: u32,\n+}\n+\n+impl<'tcx> MirPatch<'tcx> {\n+    pub fn new(mir: &Mir<'tcx>) -> Self {\n+        let mut result = MirPatch {\n+            patch_map: iter::repeat(None)\n+                .take(mir.basic_blocks.len()).collect(),\n+            new_blocks: vec![],\n+            new_temps: vec![],\n+            new_statements: vec![],\n+            next_temp: mir.temp_decls.len() as u32,\n+            resume_block: START_BLOCK\n+        };\n+\n+        // make sure the MIR we create has a resume block. It is\n+        // completely legal to convert jumps to the resume block\n+        // to jumps to None, but we occasionally have to add\n+        // instructions just before that.\n+\n+        let mut resume_block = None;\n+        let mut resume_stmt_block = None;\n+        for block in mir.all_basic_blocks() {\n+            let data = mir.basic_block_data(block);\n+            if let TerminatorKind::Resume = data.terminator().kind {\n+                if data.statements.len() > 0 {\n+                    resume_stmt_block = Some(block);\n+                } else {\n+                    resume_block = Some(block);\n+                }\n+                break\n+            }\n+        }\n+        let resume_block = resume_block.unwrap_or_else(|| {\n+            result.new_block(BasicBlockData {\n+                statements: vec![],\n+                terminator: Some(Terminator {\n+                    span: mir.span,\n+                    scope: ScopeId::new(0),\n+                    kind: TerminatorKind::Resume\n+                }),\n+                is_cleanup: true\n+            })});\n+        result.resume_block = resume_block;\n+        if let Some(resume_stmt_block) = resume_stmt_block {\n+            result.patch_terminator(resume_stmt_block, TerminatorKind::Goto {\n+                target: resume_block\n+            });\n+        }\n+        result\n+    }\n+\n+    pub fn resume_block(&self) -> BasicBlock {\n+        self.resume_block\n+    }\n+\n+    pub fn is_patched(&self, bb: BasicBlock) -> bool {\n+        self.patch_map[bb.index()].is_some()\n+    }\n+\n+    pub fn terminator_loc(&self, mir: &Mir<'tcx>, bb: BasicBlock) -> Location {\n+        let offset = match bb.index().checked_sub(mir.basic_blocks.len()) {\n+            Some(index) => self.new_blocks[index].statements.len(),\n+            None => mir.basic_block_data(bb).statements.len()\n+        };\n+        Location {\n+            block: bb,\n+            index: offset\n+        }\n+    }\n+\n+    pub fn new_temp(&mut self, ty: Ty<'tcx>) -> u32 {\n+        let index = self.next_temp;\n+        assert!(self.next_temp < u32::MAX);\n+        self.next_temp += 1;\n+        self.new_temps.push(TempDecl { ty: ty });\n+        index\n+    }\n+\n+    pub fn new_block(&mut self, data: BasicBlockData<'tcx>) -> BasicBlock {\n+        let block = BasicBlock::new(self.patch_map.len());\n+        debug!(\"MirPatch: new_block: {:?}: {:?}\", block, data);\n+        self.new_blocks.push(data);\n+        self.patch_map.push(None);\n+        block\n+    }\n+\n+    pub fn patch_terminator(&mut self, block: BasicBlock, new: TerminatorKind<'tcx>) {\n+        assert!(self.patch_map[block.index()].is_none());\n+        debug!(\"MirPatch: patch_terminator({:?}, {:?})\", block, new);\n+        self.patch_map[block.index()] = Some(new);\n+    }\n+\n+    pub fn add_statement(&mut self, loc: Location, stmt: StatementKind<'tcx>) {\n+        debug!(\"MirPatch: add_statement({:?}, {:?})\", loc, stmt);\n+        self.new_statements.push((loc, stmt));\n+    }\n+\n+    pub fn add_assign(&mut self, loc: Location, lv: Lvalue<'tcx>, rv: Rvalue<'tcx>) {\n+        self.add_statement(loc, StatementKind::Assign(lv, rv));\n+    }\n+\n+    pub fn apply(self, mir: &mut Mir<'tcx>) {\n+        debug!(\"MirPatch: {:?} new temps, starting from index {}: {:?}\",\n+               self.new_temps.len(), mir.temp_decls.len(), self.new_temps);\n+        debug!(\"MirPatch: {} new blocks, starting from index {}\",\n+               self.new_blocks.len(), mir.basic_blocks.len());\n+        mir.basic_blocks.extend(self.new_blocks);\n+        mir.temp_decls.extend(self.new_temps);\n+        for (src, patch) in self.patch_map.into_iter().enumerate() {\n+            if let Some(patch) = patch {\n+                debug!(\"MirPatch: patching block {:?}\", src);\n+                mir.basic_blocks[src].terminator_mut().kind = patch;\n+            }\n+        }\n+\n+        let mut new_statements = self.new_statements;\n+        new_statements.sort_by(|u,v| u.0.cmp(&v.0));\n+\n+        let mut delta = 0;\n+        let mut last_bb = START_BLOCK;\n+        for (mut loc, stmt) in new_statements {\n+            if loc.block != last_bb {\n+                delta = 0;\n+                last_bb = loc.block;\n+            }\n+            debug!(\"MirPatch: adding statement {:?} at loc {:?}+{}\",\n+                   stmt, loc, delta);\n+            loc.index += delta;\n+            let (span, scope) = Self::context_for_index(\n+                mir.basic_block_data(loc.block), loc\n+            );\n+            mir.basic_block_data_mut(loc.block).statements.insert(\n+                loc.index, Statement {\n+                    span: span,\n+                    scope: scope,\n+                    kind: stmt\n+                });\n+            delta += 1;\n+        }\n+    }\n+\n+    pub fn context_for_index(data: &BasicBlockData, loc: Location) -> (Span, ScopeId) {\n+        match data.statements.get(loc.index) {\n+            Some(stmt) => (stmt.span, stmt.scope),\n+            None => (data.terminator().span, data.terminator().scope)\n+        }\n+    }\n+\n+    pub fn context_for_location(&self, mir: &Mir, loc: Location) -> (Span, ScopeId) {\n+        let data = match loc.block.index().checked_sub(mir.basic_blocks.len()) {\n+            Some(new) => &self.new_blocks[new],\n+            None => mir.basic_block_data(loc.block)\n+        };\n+        Self::context_for_index(data, loc)\n+    }\n+}"}, {"sha": "5acbb18a2ffee857e2e9cff38f2271115d4ccaf6", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f97c411548f2b64f74f2bcb84dcc37075c05e2a0/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f97c411548f2b64f74f2bcb84dcc37075c05e2a0/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=f97c411548f2b64f74f2bcb84dcc37075c05e2a0", "patch": "@@ -18,6 +18,8 @@ pub use self::bckerr_code::*;\n pub use self::AliasableViolationKind::*;\n pub use self::MovedValueUseKind::*;\n \n+pub use self::mir::elaborate_drops::ElaborateDrops;\n+\n use self::InteriorKind::*;\n \n use rustc::dep_graph::DepNode;"}, {"sha": "cc694c59245f7f0ee41788eeffd4cff5bd267152", "filename": "src/librustc_borrowck/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f97c411548f2b64f74f2bcb84dcc37075c05e2a0/src%2Flibrustc_borrowck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f97c411548f2b64f74f2bcb84dcc37075c05e2a0/src%2Flibrustc_borrowck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Flib.rs?ref=f97c411548f2b64f74f2bcb84dcc37075c05e2a0", "patch": "@@ -39,7 +39,7 @@ extern crate core; // for NonZero\n \n pub use borrowck::check_crate;\n pub use borrowck::build_borrowck_dataflow_data_for_fn;\n-pub use borrowck::{AnalysisData, BorrowckCtxt};\n+pub use borrowck::{AnalysisData, BorrowckCtxt, ElaborateDrops};\n \n // NB: This module needs to be declared first so diagnostics are\n // registered before they are used."}, {"sha": "b28d203ed8dc266ab862baeffc91c062c33a4ea6", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f97c411548f2b64f74f2bcb84dcc37075c05e2a0/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f97c411548f2b64f74f2bcb84dcc37075c05e2a0/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=f97c411548f2b64f74f2bcb84dcc37075c05e2a0", "patch": "@@ -1037,7 +1037,12 @@ pub fn phase_4_translate_to_llvm<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         passes.push_pass(box mir::transform::no_landing_pads::NoLandingPads);\n         passes.push_pass(box mir::transform::remove_dead_blocks::RemoveDeadBlocks);\n         passes.push_pass(box mir::transform::erase_regions::EraseRegions);\n-        passes.push_pass(box mir::transform::break_cleanup_edges::BreakCleanupEdges);\n+        passes.push_pass(box mir::transform::add_call_guards::AddCallGuards);\n+        passes.push_pass(box borrowck::ElaborateDrops);\n+        passes.push_pass(box mir::transform::no_landing_pads::NoLandingPads);\n+        passes.push_pass(box mir::transform::simplify_cfg::SimplifyCfg);\n+        passes.push_pass(box mir::transform::add_call_guards::AddCallGuards);\n+        passes.push_pass(box mir::transform::dump_mir::DumpMir(\"pre_trans\"));\n         passes.run_passes(tcx, &mut mir_map);\n     });\n "}, {"sha": "3134a3844bc050caac4bf8732efd1784da49ec43", "filename": "src/librustc_metadata/csearch.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f97c411548f2b64f74f2bcb84dcc37075c05e2a0/src%2Flibrustc_metadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f97c411548f2b64f74f2bcb84dcc37075c05e2a0/src%2Flibrustc_metadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcsearch.rs?ref=f97c411548f2b64f74f2bcb84dcc37075c05e2a0", "patch": "@@ -142,6 +142,11 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         decoder::get_item_name(&self.intr, &cdata, def.index)\n     }\n \n+    fn opt_item_name(&self, def: DefId) -> Option<ast::Name> {\n+        self.dep_graph.read(DepNode::MetaData(def));\n+        let cdata = self.get_crate_data(def.krate);\n+        decoder::maybe_get_item_name(&self.intr, &cdata, def.index)\n+    }\n \n     fn inherent_implementations_for_type(&self, def_id: DefId) -> Vec<DefId>\n     {"}, {"sha": "68387941b65ed819ffaa17ff9358386351034df9", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f97c411548f2b64f74f2bcb84dcc37075c05e2a0/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f97c411548f2b64f74f2bcb84dcc37075c05e2a0/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=f97c411548f2b64f74f2bcb84dcc37075c05e2a0", "patch": "@@ -285,12 +285,17 @@ fn item_trait_ref<'a, 'tcx>(doc: rbml::Doc, tcx: TyCtxt<'a, 'tcx, 'tcx>, cdata:\n }\n \n fn item_name(intr: &IdentInterner, item: rbml::Doc) -> ast::Name {\n-    let name = reader::get_doc(item, tag_paths_data_name);\n-    let string = name.as_str_slice();\n-    match intr.find(string) {\n-        None => token::intern(string),\n-        Some(val) => val,\n-    }\n+    maybe_item_name(intr, item).expect(\"no item in item_name\")\n+}\n+\n+fn maybe_item_name(intr: &IdentInterner, item: rbml::Doc) -> Option<ast::Name> {\n+    reader::maybe_get_doc(item, tag_paths_data_name).map(|name| {\n+        let string = name.as_str_slice();\n+        match intr.find(string) {\n+            None => token::intern(string),\n+            Some(val) => val,\n+        }\n+    })\n }\n \n fn family_to_variant_kind<'tcx>(family: Family) -> Option<ty::VariantKind> {\n@@ -792,6 +797,11 @@ pub fn get_item_name(intr: &IdentInterner, cdata: Cmd, id: DefIndex) -> ast::Nam\n     item_name(intr, cdata.lookup_item(id))\n }\n \n+pub fn maybe_get_item_name(intr: &IdentInterner, cdata: Cmd, id: DefIndex)\n+                         -> Option<ast::Name> {\n+    maybe_item_name(intr, cdata.lookup_item(id))\n+}\n+\n pub fn maybe_get_item_ast<'a, 'tcx>(cdata: Cmd, tcx: TyCtxt<'a, 'tcx, 'tcx>, id: DefIndex)\n                                     -> FoundAst<'tcx> {\n     debug!(\"Looking up item: {:?}\", id);"}, {"sha": "3324467e70d1d868278071ce88f8eb3d4f45b472", "filename": "src/librustc_mir/build/expr/stmt.rs", "status": "modified", "additions": 12, "deletions": 16, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/f97c411548f2b64f74f2bcb84dcc37075c05e2a0/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f97c411548f2b64f74f2bcb84dcc37075c05e2a0/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fstmt.rs?ref=f97c411548f2b64f74f2bcb84dcc37075c05e2a0", "patch": "@@ -34,29 +34,25 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 let scope_id = this.innermost_scope_id();\n                 let lhs_span = lhs.span;\n \n-                let lhs_ty = lhs.ty;\n-                let rhs_ty = rhs.ty;\n-\n-                let lhs_needs_drop = this.hir.needs_drop(lhs_ty);\n-                let rhs_needs_drop = this.hir.needs_drop(rhs_ty);\n-\n                 // Note: we evaluate assignments right-to-left. This\n                 // is better for borrowck interaction with overloaded\n                 // operators like x[j] = x[i].\n \n                 // Generate better code for things that don't need to be\n                 // dropped.\n-                let rhs = if lhs_needs_drop || rhs_needs_drop {\n-                    let op = unpack!(block = this.as_operand(block, rhs));\n-                    Rvalue::Use(op)\n+                if this.hir.needs_drop(lhs.ty) {\n+                    let rhs = unpack!(block = this.as_operand(block, rhs));\n+                    let lhs = unpack!(block = this.as_lvalue(block, lhs));\n+                    unpack!(block = this.build_drop_and_replace(\n+                        block, lhs_span, lhs, rhs\n+                    ));\n+                    block.unit()\n                 } else {\n-                    unpack!(block = this.as_rvalue(block, rhs))\n-                };\n-\n-                let lhs = unpack!(block = this.as_lvalue(block, lhs));\n-                unpack!(block = this.build_drop(block, lhs_span, lhs.clone(), lhs_ty));\n-                this.cfg.push_assign(block, scope_id, expr_span, &lhs, rhs);\n-                block.unit()\n+                    let rhs = unpack!(block = this.as_rvalue(block, rhs));\n+                    let lhs = unpack!(block = this.as_lvalue(block, lhs));\n+                    this.cfg.push_assign(block, scope_id, expr_span, &lhs, rhs);\n+                    block.unit()\n+                }\n             }\n             ExprKind::AssignOp { op, lhs, rhs } => {\n                 // FIXME(#28160) there is an interesting semantics"}, {"sha": "cd81fc764f4aff13804e6d41a0e39349174a87cf", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 27, "deletions": 6, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/f97c411548f2b64f74f2bcb84dcc37075c05e2a0/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f97c411548f2b64f74f2bcb84dcc37075c05e2a0/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=f97c411548f2b64f74f2bcb84dcc37075c05e2a0", "patch": "@@ -139,7 +139,7 @@ struct DropData<'tcx> {\n     span: Span,\n \n     /// lvalue to drop\n-    value: Lvalue<'tcx>,\n+    location: Lvalue<'tcx>,\n \n     /// The cached block for the cleanups-on-diverge path. This block\n     /// contains code to run the current drop and all the preceding\n@@ -402,7 +402,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 // the drop that comes before it in the vector.\n                 scope.drops.push(DropData {\n                     span: span,\n-                    value: lvalue.clone(),\n+                    location: lvalue.clone(),\n                     cached_block: None\n                 });\n                 return;\n@@ -497,7 +497,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     pub fn build_drop(&mut self,\n                       block: BasicBlock,\n                       span: Span,\n-                      value: Lvalue<'tcx>,\n+                      location: Lvalue<'tcx>,\n                       ty: Ty<'tcx>) -> BlockAnd<()> {\n         if !self.hir.needs_drop(ty) {\n             return block.unit();\n@@ -509,14 +509,35 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                            scope_id,\n                            span,\n                            TerminatorKind::Drop {\n-                               value: value,\n+                               location: location,\n                                target: next_target,\n                                unwind: diverge_target,\n                            });\n         next_target.unit()\n     }\n \n \n+\n+    pub fn build_drop_and_replace(&mut self,\n+                                  block: BasicBlock,\n+                                  span: Span,\n+                                  location: Lvalue<'tcx>,\n+                                  value: Operand<'tcx>) -> BlockAnd<()> {\n+        let scope_id = self.innermost_scope_id();\n+        let next_target = self.cfg.start_new_block();\n+        let diverge_target = self.diverge_cleanup();\n+        self.cfg.terminate(block,\n+                           scope_id,\n+                           span,\n+                           TerminatorKind::DropAndReplace {\n+                               location: location,\n+                               value: value,\n+                               target: next_target,\n+                               unwind: diverge_target,\n+                           });\n+        next_target.unit()\n+    }\n+\n     // Panicking\n     // =========\n     // FIXME: should be moved into their own module\n@@ -653,7 +674,7 @@ fn build_scope_drops<'tcx>(cfg: &mut CFG<'tcx>,\n         });\n         let next = cfg.start_new_block();\n         cfg.terminate(block, scope.id, drop_data.span, TerminatorKind::Drop {\n-            value: drop_data.value.clone(),\n+            location: drop_data.location.clone(),\n             target: next,\n             unwind: on_diverge\n         });\n@@ -709,7 +730,7 @@ fn build_diverge_scope<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                           scope.id,\n                           drop_data.span,\n                           TerminatorKind::Drop {\n-                              value: drop_data.value.clone(),\n+                              location: drop_data.location.clone(),\n                               target: target,\n                               unwind: None\n                           });"}, {"sha": "bcdd62c189972021ccd58054817af3cb0b83ba3d", "filename": "src/librustc_mir/transform/add_call_guards.rs", "status": "renamed", "additions": 27, "deletions": 40, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/f97c411548f2b64f74f2bcb84dcc37075c05e2a0/src%2Flibrustc_mir%2Ftransform%2Fadd_call_guards.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f97c411548f2b64f74f2bcb84dcc37075c05e2a0/src%2Flibrustc_mir%2Ftransform%2Fadd_call_guards.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fadd_call_guards.rs?ref=f97c411548f2b64f74f2bcb84dcc37075c05e2a0", "patch": "@@ -12,13 +12,11 @@ use rustc::ty::TyCtxt;\n use rustc::mir::repr::*;\n use rustc::mir::transform::{MirPass, MirSource, Pass};\n \n-use rustc_data_structures::bitvec::BitVector;\n-\n use pretty;\n \n use traversal;\n \n-pub struct BreakCleanupEdges;\n+pub struct AddCallGuards;\n \n /**\n  * Breaks outgoing critical edges for call terminators in the MIR.\n@@ -40,7 +38,7 @@ pub struct BreakCleanupEdges;\n  *\n  */\n \n-impl<'tcx> MirPass<'tcx> for BreakCleanupEdges {\n+impl<'tcx> MirPass<'tcx> for AddCallGuards {\n     fn run_pass<'a>(&mut self, tcx: TyCtxt<'a, 'tcx, 'tcx>, src: MirSource, mir: &mut Mir<'tcx>) {\n         let mut pred_count = vec![0u32; mir.basic_blocks.len()];\n \n@@ -53,9 +51,6 @@ impl<'tcx> MirPass<'tcx> for BreakCleanupEdges {\n             }\n         }\n \n-        let cleanup_map : BitVector = mir.basic_blocks\n-            .iter().map(|bb| bb.is_cleanup).collect();\n-\n         // We need a place to store the new blocks generated\n         let mut new_blocks = Vec::new();\n \n@@ -65,30 +60,31 @@ impl<'tcx> MirPass<'tcx> for BreakCleanupEdges {\n         for &bb in &bbs {\n             let data = mir.basic_block_data_mut(bb);\n \n-            if let Some(ref mut term) = data.terminator {\n-                if term_is_invoke(term) {\n-                    let term_span = term.span;\n-                    let term_scope = term.scope;\n-                    let succs = term.successors_mut();\n-                    for tgt in succs {\n-                        let num_preds = pred_count[tgt.index()];\n-                        if num_preds > 1 {\n-                            // It's a critical edge, break it\n-                            let goto = Terminator {\n-                                span: term_span,\n-                                scope: term_scope,\n-                                kind: TerminatorKind::Goto { target: *tgt }\n-                            };\n-                            let mut data = BasicBlockData::new(Some(goto));\n-                            data.is_cleanup = cleanup_map.contains(tgt.index());\n-\n-                            // Get the index it will be when inserted into the MIR\n-                            let idx = cur_len + new_blocks.len();\n-                            new_blocks.push(data);\n-                            *tgt = BasicBlock::new(idx);\n-                        }\n-                    }\n+            match data.terminator {\n+                Some(Terminator {\n+                    kind: TerminatorKind::Call {\n+                        destination: Some((_, ref mut destination)),\n+                        cleanup: Some(_),\n+                        ..\n+                    }, span, scope\n+                }) if pred_count[destination.index()] > 1 => {\n+                    // It's a critical edge, break it\n+                    let call_guard = BasicBlockData {\n+                        statements: vec![],\n+                        is_cleanup: data.is_cleanup,\n+                        terminator: Some(Terminator {\n+                            span: span,\n+                            scope: scope,\n+                            kind: TerminatorKind::Goto { target: *destination }\n+                        })\n+                    };\n+\n+                    // Get the index it will be when inserted into the MIR\n+                    let idx = cur_len + new_blocks.len();\n+                    new_blocks.push(call_guard);\n+                    *destination = BasicBlock::new(idx);\n                 }\n+                _ => {}\n             }\n         }\n \n@@ -99,13 +95,4 @@ impl<'tcx> MirPass<'tcx> for BreakCleanupEdges {\n     }\n }\n \n-impl Pass for BreakCleanupEdges {}\n-\n-// Returns true if the terminator is a call that would use an invoke in LLVM.\n-fn term_is_invoke(term: &Terminator) -> bool {\n-    match term.kind {\n-        TerminatorKind::Call { cleanup: Some(_), .. } |\n-        TerminatorKind::Drop { unwind: Some(_), .. } => true,\n-        _ => false\n-    }\n-}\n+impl Pass for AddCallGuards {}", "previous_filename": "src/librustc_mir/transform/break_cleanup_edges.rs"}, {"sha": "fb49f951ecd5826db86b5d4daefc6300b4499ce2", "filename": "src/librustc_mir/transform/dump_mir.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/f97c411548f2b64f74f2bcb84dcc37075c05e2a0/src%2Flibrustc_mir%2Ftransform%2Fdump_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f97c411548f2b64f74f2bcb84dcc37075c05e2a0/src%2Flibrustc_mir%2Ftransform%2Fdump_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fdump_mir.rs?ref=f97c411548f2b64f74f2bcb84dcc37075c05e2a0", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! This pass just dumps MIR at a specified point.\n+\n+use rustc::ty::TyCtxt;\n+use rustc::mir::repr::*;\n+use rustc::mir::transform::{Pass, MirPass, MirSource};\n+use pretty;\n+\n+pub struct DumpMir<'a>(pub &'a str);\n+\n+impl<'b, 'tcx> MirPass<'tcx> for DumpMir<'b> {\n+    fn run_pass<'a>(&mut self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                    src: MirSource, mir: &mut Mir<'tcx>) {\n+        pretty::dump_mir(tcx, self.0, &0, src, mir, None);\n+    }\n+}\n+\n+impl<'b> Pass for DumpMir<'b> {}"}, {"sha": "339dcdec0608071f57f344012a7c177442c79911", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f97c411548f2b64f74f2bcb84dcc37075c05e2a0/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f97c411548f2b64f74f2bcb84dcc37075c05e2a0/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=f97c411548f2b64f74f2bcb84dcc37075c05e2a0", "patch": "@@ -13,6 +13,7 @@ pub mod simplify_cfg;\n pub mod erase_regions;\n pub mod no_landing_pads;\n pub mod type_check;\n-pub mod break_cleanup_edges;\n+pub mod add_call_guards;\n pub mod promote_consts;\n pub mod qualify_consts;\n+pub mod dump_mir;"}, {"sha": "67710c4328569bf82783362d15f0e0088056a41f", "filename": "src/librustc_mir/transform/no_landing_pads.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f97c411548f2b64f74f2bcb84dcc37075c05e2a0/src%2Flibrustc_mir%2Ftransform%2Fno_landing_pads.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f97c411548f2b64f74f2bcb84dcc37075c05e2a0/src%2Flibrustc_mir%2Ftransform%2Fno_landing_pads.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fno_landing_pads.rs?ref=f97c411548f2b64f74f2bcb84dcc37075c05e2a0", "patch": "@@ -29,12 +29,11 @@ impl<'tcx> MutVisitor<'tcx> for NoLandingPads {\n             TerminatorKind::SwitchInt { .. } => {\n                 /* nothing to do */\n             },\n+            TerminatorKind::Call { cleanup: ref mut unwind, .. } |\n+            TerminatorKind::DropAndReplace { ref mut unwind, .. } |\n             TerminatorKind::Drop { ref mut unwind, .. } => {\n                 unwind.take();\n             },\n-            TerminatorKind::Call { ref mut cleanup, .. } => {\n-                cleanup.take();\n-            },\n         }\n         self.super_terminator(bb, terminator);\n     }"}, {"sha": "d81c4e2dfb68ee9d72e8202feb1d615a981f082a", "filename": "src/librustc_mir/transform/promote_consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f97c411548f2b64f74f2bcb84dcc37075c05e2a0/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f97c411548f2b64f74f2bcb84dcc37075c05e2a0/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs?ref=f97c411548f2b64f74f2bcb84dcc37075c05e2a0", "patch": "@@ -399,7 +399,7 @@ pub fn promote_candidates<'a, 'tcx>(mir: &mut Mir<'tcx>,\n         });\n         let terminator = block.terminator_mut();\n         match terminator.kind {\n-            TerminatorKind::Drop { value: Lvalue::Temp(index), target, .. } => {\n+            TerminatorKind::Drop { location: Lvalue::Temp(index), target, .. } => {\n                 if promoted(index) {\n                     terminator.kind = TerminatorKind::Goto {\n                         target: target"}, {"sha": "18a1f1595f3c3ef758f49f807552a227e7594dce", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f97c411548f2b64f74f2bcb84dcc37075c05e2a0/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f97c411548f2b64f74f2bcb84dcc37075c05e2a0/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=f97c411548f2b64f74f2bcb84dcc37075c05e2a0", "patch": "@@ -422,6 +422,7 @@ impl<'a, 'tcx> Qualifier<'a, 'tcx, 'tcx> {\n \n                 TerminatorKind::Switch {..} |\n                 TerminatorKind::SwitchInt {..} |\n+                TerminatorKind::DropAndReplace { .. } |\n                 TerminatorKind::Resume => None,\n \n                 TerminatorKind::Return => {"}, {"sha": "efac8ea84611158524d635c7d74530898dd875c0", "filename": "src/librustc_mir/transform/type_check.rs", "status": "modified", "additions": 79, "deletions": 3, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/f97c411548f2b64f74f2bcb84dcc37075c05e2a0/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f97c411548f2b64f74f2bcb84dcc37075c05e2a0/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs?ref=f97c411548f2b64f74f2bcb84dcc37075c05e2a0", "patch": "@@ -363,6 +363,20 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                 // no checks needed for these\n             }\n \n+\n+            TerminatorKind::DropAndReplace {\n+                ref location,\n+                ref value,\n+                ..\n+            } => {\n+                let lv_ty = mir.lvalue_ty(tcx, location).to_ty(tcx);\n+                let rv_ty = mir.operand_ty(tcx, value);\n+                if let Err(terr) = self.sub_types(self.last_span, rv_ty, lv_ty) {\n+                    span_mirbug!(self, term, \"bad DropAndReplace ({:?} = {:?}): {:?}\",\n+                                 lv_ty, rv_ty, terr);\n+                }\n+            }\n+\n             TerminatorKind::If { ref cond, .. } => {\n                 let cond_ty = mir.operand_ty(tcx, cond);\n                 match cond_ty.sty {\n@@ -519,6 +533,69 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         }\n     }\n \n+    fn check_iscleanup(&mut self, mir: &Mir<'tcx>, block: &BasicBlockData<'tcx>)\n+    {\n+        let is_cleanup = block.is_cleanup;\n+        self.last_span = block.terminator().span;\n+        match block.terminator().kind {\n+            TerminatorKind::Goto { target } =>\n+                self.assert_iscleanup(mir, block, target, is_cleanup),\n+            TerminatorKind::If { targets: (on_true, on_false), .. } => {\n+                self.assert_iscleanup(mir, block, on_true, is_cleanup);\n+                self.assert_iscleanup(mir, block, on_false, is_cleanup);\n+            }\n+            TerminatorKind::Switch { ref targets, .. } |\n+            TerminatorKind::SwitchInt { ref targets, .. } => {\n+                for target in targets {\n+                    self.assert_iscleanup(mir, block, *target, is_cleanup);\n+                }\n+            }\n+            TerminatorKind::Resume => {\n+                if !is_cleanup {\n+                    span_mirbug!(self, block, \"resume on non-cleanup block!\")\n+                }\n+            }\n+            TerminatorKind::Return => {\n+                if is_cleanup {\n+                    span_mirbug!(self, block, \"return on cleanup block\")\n+                }\n+            }\n+            TerminatorKind::Drop { target, unwind, .. } |\n+            TerminatorKind::DropAndReplace { target, unwind, .. } => {\n+                self.assert_iscleanup(mir, block, target, is_cleanup);\n+                if let Some(unwind) = unwind {\n+                    if is_cleanup {\n+                        span_mirbug!(self, block, \"unwind on cleanup block\")\n+                    }\n+                    self.assert_iscleanup(mir, block, unwind, true);\n+                }\n+            }\n+            TerminatorKind::Call { ref destination, cleanup, .. } => {\n+                if let &Some((_, target)) = destination {\n+                    self.assert_iscleanup(mir, block, target, is_cleanup);\n+                }\n+                if let Some(cleanup) = cleanup {\n+                    if is_cleanup {\n+                        span_mirbug!(self, block, \"cleanup on cleanup block\")\n+                    }\n+                    self.assert_iscleanup(mir, block, cleanup, true);\n+                }\n+            }\n+        }\n+    }\n+\n+    fn assert_iscleanup(&mut self,\n+                        mir: &Mir<'tcx>,\n+                        ctxt: &fmt::Debug,\n+                        bb: BasicBlock,\n+                        iscleanuppad: bool)\n+    {\n+        if mir.basic_block_data(bb).is_cleanup != iscleanuppad {\n+            span_mirbug!(self, ctxt, \"cleanuppad mismatch: {:?} should be {:?}\",\n+                         bb, iscleanuppad);\n+        }\n+    }\n+\n     fn typeck_mir(&mut self, mir: &Mir<'tcx>) {\n         self.last_span = mir.span;\n         debug!(\"run_on_mir: {:?}\", mir.span);\n@@ -530,9 +607,8 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                 self.check_stmt(mir, stmt);\n             }\n \n-            if let Some(ref terminator) = block.terminator {\n-                self.check_terminator(mir, terminator);\n-            }\n+            self.check_terminator(mir, block.terminator());\n+            self.check_iscleanup(mir, block);\n         }\n     }\n "}, {"sha": "f35d87d0741ba584e3bd8785f33a268618f582c5", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/f97c411548f2b64f74f2bcb84dcc37075c05e2a0/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f97c411548f2b64f74f2bcb84dcc37075c05e2a0/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=f97c411548f2b64f74f2bcb84dcc37075c05e2a0", "patch": "@@ -577,6 +577,15 @@ impl<'blk, 'tcx> BlockS<'blk, 'tcx> {\n         self.lpad.get()\n     }\n \n+    pub fn set_lpad_ref(&self, lpad: Option<&'blk LandingPad>) {\n+        // FIXME: use an IVar?\n+        self.lpad.set(lpad);\n+    }\n+\n+    pub fn set_lpad(&self, lpad: Option<LandingPad>) {\n+        self.set_lpad_ref(lpad.map(|p| &*self.fcx().lpad_arena.alloc(p)))\n+    }\n+\n     pub fn mir(&self) -> CachedMir<'blk, 'tcx> {\n         self.fcx.mir()\n     }\n@@ -716,7 +725,16 @@ impl<'blk, 'tcx> BlockAndBuilder<'blk, 'tcx> {\n     }\n \n     pub fn set_lpad(&self, lpad: Option<LandingPad>) {\n-        self.bcx.lpad.set(lpad.map(|p| &*self.fcx().lpad_arena.alloc(p)))\n+        self.bcx.set_lpad(lpad)\n+    }\n+\n+    pub fn set_lpad_ref(&self, lpad: Option<&'blk LandingPad>) {\n+        // FIXME: use an IVar?\n+        self.bcx.set_lpad_ref(lpad);\n+    }\n+\n+    pub fn lpad(&self) -> Option<&'blk LandingPad> {\n+        self.bcx.lpad()\n     }\n }\n \n@@ -761,6 +779,10 @@ impl LandingPad {\n     pub fn bundle(&self) -> Option<&OperandBundleDef> {\n         self.operand.as_ref()\n     }\n+\n+    pub fn cleanuppad(&self) -> Option<ValueRef> {\n+        self.cleanuppad\n+    }\n }\n \n impl Clone for LandingPad {"}, {"sha": "03df1c451f0d1d30206e3bcc97b16ca6d8e5c3b1", "filename": "src/librustc_trans/mir/analyze.rs", "status": "modified", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/f97c411548f2b64f74f2bcb84dcc37075c05e2a0/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f97c411548f2b64f74f2bcb84dcc37075c05e2a0/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs?ref=f97c411548f2b64f74f2bcb84dcc37075c05e2a0", "patch": "@@ -13,7 +13,9 @@\n \n use rustc_data_structures::bitvec::BitVector;\n use rustc::mir::repr as mir;\n+use rustc::mir::repr::TerminatorKind;\n use rustc::mir::visit::{Visitor, LvalueContext};\n+use rustc_mir::traversal;\n use common::{self, Block, BlockAndBuilder};\n use super::rvalue;\n \n@@ -134,3 +136,104 @@ impl<'mir, 'bcx, 'tcx> Visitor<'tcx> for TempAnalyzer<'mir, 'bcx, 'tcx> {\n         self.super_lvalue(lvalue, context);\n     }\n }\n+\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+pub enum CleanupKind {\n+    NotCleanup,\n+    Funclet,\n+    Internal { funclet: mir::BasicBlock }\n+}\n+\n+pub fn cleanup_kinds<'bcx,'tcx>(_bcx: Block<'bcx,'tcx>,\n+                                mir: &mir::Mir<'tcx>)\n+                                -> Vec<CleanupKind>\n+{\n+    fn discover_masters<'tcx>(result: &mut [CleanupKind], mir: &mir::Mir<'tcx>) {\n+        for bb in mir.all_basic_blocks() {\n+            let data = mir.basic_block_data(bb);\n+            match data.terminator().kind {\n+                TerminatorKind::Goto { .. } |\n+                TerminatorKind::Resume |\n+                TerminatorKind::Return |\n+                TerminatorKind::If { .. } |\n+                TerminatorKind::Switch { .. } |\n+                TerminatorKind::SwitchInt { .. } => {\n+                    /* nothing to do */\n+                }\n+                TerminatorKind::Call { cleanup: unwind, .. } |\n+                TerminatorKind::DropAndReplace { unwind, .. } |\n+                TerminatorKind::Drop { unwind, .. } => {\n+                    if let Some(unwind) = unwind {\n+                        debug!(\"cleanup_kinds: {:?}/{:?} registering {:?} as funclet\",\n+                               bb, data, unwind);\n+                        result[unwind.index()] = CleanupKind::Funclet;\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    fn propagate<'tcx>(result: &mut [CleanupKind], mir: &mir::Mir<'tcx>) {\n+        let mut funclet_succs : Vec<_> =\n+            mir.all_basic_blocks().iter().map(|_| None).collect();\n+\n+        let mut set_successor = |funclet: mir::BasicBlock, succ| {\n+            match funclet_succs[funclet.index()] {\n+                ref mut s @ None => {\n+                    debug!(\"set_successor: updating successor of {:?} to {:?}\",\n+                           funclet, succ);\n+                    *s = Some(succ);\n+                },\n+                Some(s) => if s != succ {\n+                    span_bug!(mir.span, \"funclet {:?} has 2 parents - {:?} and {:?}\",\n+                              funclet, s, succ);\n+                }\n+            }\n+        };\n+\n+        for (bb, data) in traversal::reverse_postorder(mir) {\n+            let funclet = match result[bb.index()] {\n+                CleanupKind::NotCleanup => continue,\n+                CleanupKind::Funclet => bb,\n+                CleanupKind::Internal { funclet } => funclet,\n+            };\n+\n+            debug!(\"cleanup_kinds: {:?}/{:?}/{:?} propagating funclet {:?}\",\n+                   bb, data, result[bb.index()], funclet);\n+\n+            for &succ in data.terminator().successors().iter() {\n+                let kind = result[succ.index()];\n+                debug!(\"cleanup_kinds: propagating {:?} to {:?}/{:?}\",\n+                       funclet, succ, kind);\n+                match kind {\n+                    CleanupKind::NotCleanup => {\n+                        result[succ.index()] = CleanupKind::Internal { funclet: funclet };\n+                    }\n+                    CleanupKind::Funclet => {\n+                        set_successor(funclet, succ);\n+                    }\n+                    CleanupKind::Internal { funclet: succ_funclet } => {\n+                        if funclet != succ_funclet {\n+                            // `succ` has 2 different funclet going into it, so it must\n+                            // be a funclet by itself.\n+\n+                            debug!(\"promoting {:?} to a funclet and updating {:?}\", succ,\n+                                   succ_funclet);\n+                            result[succ.index()] = CleanupKind::Funclet;\n+                            set_successor(succ_funclet, succ);\n+                            set_successor(funclet, succ);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    let mut result : Vec<_> =\n+        mir.all_basic_blocks().iter().map(|_| CleanupKind::NotCleanup).collect();\n+\n+    discover_masters(&mut result, mir);\n+    propagate(&mut result, mir);\n+    debug!(\"cleanup_kinds: result={:?}\", result);\n+    result\n+}"}, {"sha": "eb962b6615442c735fe13c3829699c14b908ba1d", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 127, "deletions": 103, "changes": 230, "blob_url": "https://github.com/rust-lang/rust/blob/f97c411548f2b64f74f2bcb84dcc37075c05e2a0/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f97c411548f2b64f74f2bcb84dcc37075c05e2a0/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=f97c411548f2b64f74f2bcb84dcc37075c05e2a0", "patch": "@@ -8,15 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use llvm::{self, BasicBlockRef, ValueRef, OperandBundleDef};\n+use llvm::{self, ValueRef};\n use rustc::ty;\n use rustc::mir::repr as mir;\n use abi::{Abi, FnType, ArgType};\n use adt;\n use base;\n use build;\n use callee::{Callee, CalleeData, Fn, Intrinsic, NamedTupleConstructor, Virtual};\n-use common::{self, type_is_fat_ptr, Block, BlockAndBuilder, C_undef};\n+use common::{self, type_is_fat_ptr, Block, BlockAndBuilder, LandingPad, C_undef};\n use debuginfo::DebugLoc;\n use Disr;\n use machine::{llalign_of_min, llbitsize_of_real};\n@@ -26,30 +26,71 @@ use glue;\n use type_::Type;\n use rustc_data_structures::fnv::FnvHashMap;\n \n-use super::{MirContext, TempRef, drop};\n+use super::{MirContext, TempRef};\n+use super::analyze::CleanupKind;\n use super::constant::Const;\n use super::lvalue::{LvalueRef, load_fat_ptr};\n use super::operand::OperandRef;\n use super::operand::OperandValue::{self, FatPtr, Immediate, Ref};\n \n impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n     pub fn trans_block(&mut self, bb: mir::BasicBlock) {\n-        debug!(\"trans_block({:?})\", bb);\n-\n         let mut bcx = self.bcx(bb);\n         let mir = self.mir.clone();\n         let data = mir.basic_block_data(bb);\n \n-        // MSVC SEH bits\n-        let (cleanup_pad, cleanup_bundle) = if let Some((cp, cb)) = self.make_cleanup_pad(bb) {\n-            (Some(cp), Some(cb))\n-        } else {\n-            (None, None)\n+        debug!(\"trans_block({:?}={:?})\", bb, data);\n+\n+        // Create the cleanup bundle, if needed.\n+        let cleanup_pad = bcx.lpad().and_then(|lp| lp.cleanuppad());\n+        let cleanup_bundle = bcx.lpad().and_then(|l| l.bundle());\n+\n+        let funclet_br = |this: &Self, bcx: BlockAndBuilder, bb: mir::BasicBlock| {\n+            let lltarget = this.blocks[bb.index()].llbb;\n+            if let Some(cp) = cleanup_pad {\n+                match this.cleanup_kind(bb) {\n+                    CleanupKind::Funclet => {\n+                        // micro-optimization: generate a `ret` rather than a jump\n+                        // to a return block\n+                        bcx.cleanup_ret(cp, Some(lltarget));\n+                    }\n+                    CleanupKind::Internal { .. } => bcx.br(lltarget),\n+                    CleanupKind::NotCleanup => bug!(\"jump from cleanup bb to bb {:?}\", bb)\n+                }\n+            } else {\n+                bcx.br(lltarget);\n+            }\n         };\n-        let funclet_br = |bcx: BlockAndBuilder, llbb: BasicBlockRef| if let Some(cp) = cleanup_pad {\n-            bcx.cleanup_ret(cp, Some(llbb));\n-        } else {\n-            bcx.br(llbb);\n+\n+        let llblock = |this: &mut Self, target: mir::BasicBlock| {\n+            let lltarget = this.blocks[target.index()].llbb;\n+\n+            if let Some(cp) = cleanup_pad {\n+                match this.cleanup_kind(target) {\n+                    CleanupKind::Funclet => {\n+                        // MSVC cross-funclet jump - need a trampoline\n+\n+                        debug!(\"llblock: creating cleanup trampoline for {:?}\", target);\n+                        let name = &format!(\"{:?}_cleanup_trampoline_{:?}\", bb, target);\n+                        let trampoline = this.fcx.new_block(name, None).build();\n+                        trampoline.set_personality_fn(this.fcx.eh_personality());\n+                        trampoline.cleanup_ret(cp, Some(lltarget));\n+                        trampoline.llbb()\n+                    }\n+                    CleanupKind::Internal { .. } => lltarget,\n+                    CleanupKind::NotCleanup =>\n+                        bug!(\"jump from cleanup bb {:?} to bb {:?}\", bb, target)\n+                }\n+            } else {\n+                if let (CleanupKind::NotCleanup, CleanupKind::Funclet) =\n+                    (this.cleanup_kind(bb), this.cleanup_kind(target))\n+                {\n+                    // jump *into* cleanup - need a landing pad if GNU\n+                    this.landing_pad_to(target).llbb\n+                } else {\n+                    lltarget\n+                }\n+            }\n         };\n \n         for statement in &data.statements {\n@@ -78,13 +119,14 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n             }\n \n             mir::TerminatorKind::Goto { target } => {\n-                funclet_br(bcx, self.llblock(target));\n+                funclet_br(self, bcx, target);\n             }\n \n             mir::TerminatorKind::If { ref cond, targets: (true_bb, false_bb) } => {\n                 let cond = self.trans_operand(&bcx, cond);\n-                let lltrue = self.llblock(true_bb);\n-                let llfalse = self.llblock(false_bb);\n+\n+                let lltrue = llblock(self, true_bb);\n+                let llfalse = llblock(self, false_bb);\n                 bcx.cond_br(cond.immediate(), lltrue, llfalse);\n             }\n \n@@ -106,18 +148,18 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                     // code. This is especially helpful in cases like an if-let on a huge enum.\n                     // Note: This optimization is only valid for exhaustive matches.\n                     Some((&&bb, &c)) if c > targets.len() / 2 => {\n-                        (Some(bb), self.blocks[bb.index()])\n+                        (Some(bb), llblock(self, bb))\n                     }\n                     // We're generating an exhaustive switch, so the else branch\n                     // can't be hit.  Branching to an unreachable instruction\n                     // lets LLVM know this\n-                    _ => (None, self.unreachable_block())\n+                    _ => (None, self.unreachable_block().llbb)\n                 };\n-                let switch = bcx.switch(discr, default_blk.llbb, targets.len());\n+                let switch = bcx.switch(discr, default_blk, targets.len());\n                 assert_eq!(adt_def.variants.len(), targets.len());\n                 for (adt_variant, &target) in adt_def.variants.iter().zip(targets) {\n                     if default_bb != Some(target) {\n-                        let llbb = self.llblock(target);\n+                        let llbb = llblock(self, target);\n                         let llval = bcx.with_block(|bcx| adt::trans_case(\n                                 bcx, &repr, Disr::from(adt_variant.disr_val)));\n                         build::AddCase(switch, llval, llbb)\n@@ -129,10 +171,10 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 let (otherwise, targets) = targets.split_last().unwrap();\n                 let discr = bcx.load(self.trans_lvalue(&bcx, discr).llval);\n                 let discr = bcx.with_block(|bcx| base::to_immediate(bcx, discr, switch_ty));\n-                let switch = bcx.switch(discr, self.llblock(*otherwise), values.len());\n+                let switch = bcx.switch(discr, llblock(self, *otherwise), values.len());\n                 for (value, target) in values.iter().zip(targets) {\n                     let val = Const::from_constval(bcx.ccx(), value.clone(), switch_ty);\n-                    let llbb = self.llblock(*target);\n+                    let llbb = llblock(self, *target);\n                     build::AddCase(switch, val.llval, llbb)\n                 }\n             }\n@@ -143,12 +185,12 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 })\n             }\n \n-            mir::TerminatorKind::Drop { ref value, target, unwind } => {\n-                let lvalue = self.trans_lvalue(&bcx, value);\n+            mir::TerminatorKind::Drop { ref location, target, unwind } => {\n+                let lvalue = self.trans_lvalue(&bcx, location);\n                 let ty = lvalue.ty.to_ty(bcx.tcx());\n                 // Double check for necessity to drop\n                 if !glue::type_needs_drop(bcx.tcx(), ty) {\n-                    funclet_br(bcx, self.llblock(target));\n+                    funclet_br(self, bcx, target);\n                     return;\n                 }\n                 let drop_fn = glue::get_drop_glue(bcx.ccx(), ty);\n@@ -159,24 +201,21 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                     lvalue.llval\n                 };\n                 if let Some(unwind) = unwind {\n-                    let uwbcx = self.bcx(unwind);\n-                    let unwind = self.make_landing_pad(uwbcx);\n                     bcx.invoke(drop_fn,\n                                &[llvalue],\n-                               self.llblock(target),\n-                               unwind.llbb(),\n-                               cleanup_bundle.as_ref());\n-                    self.bcx(target).at_start(|bcx| {\n-                        debug_loc.apply_to_bcx(bcx);\n-                        drop::drop_fill(bcx, lvalue.llval, ty)\n-                    });\n+                               self.blocks[target.index()].llbb,\n+                               llblock(self, unwind),\n+                               cleanup_bundle);\n                 } else {\n-                    bcx.call(drop_fn, &[llvalue], cleanup_bundle.as_ref());\n-                    drop::drop_fill(&bcx, lvalue.llval, ty);\n-                    funclet_br(bcx, self.llblock(target));\n+                    bcx.call(drop_fn, &[llvalue], cleanup_bundle);\n+                    funclet_br(self, bcx, target);\n                 }\n             }\n \n+            mir::TerminatorKind::DropAndReplace { .. } => {\n+                bug!(\"undesugared DropAndReplace in trans: {:?}\", data);\n+            }\n+\n             mir::TerminatorKind::Call { ref func, ref args, ref destination, ref cleanup } => {\n                 // Create the callee. This is a fn ptr or zero-sized and hence a kind of scalar.\n                 let callee = self.trans_operand(&bcx, func);\n@@ -211,8 +250,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                     let llptr = self.trans_operand(&bcx, &args[0]).immediate();\n                     let val = self.trans_operand(&bcx, &args[1]);\n                     self.store_operand(&bcx, llptr, val);\n-                    self.set_operand_dropped(&bcx, &args[1]);\n-                    funclet_br(bcx, self.llblock(target));\n+                    funclet_br(self, bcx, target);\n                     return;\n                 }\n \n@@ -222,8 +260,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                         this.trans_transmute(&bcx, &args[0], dest);\n                     });\n \n-                    self.set_operand_dropped(&bcx, &args[0]);\n-                    funclet_br(bcx, self.llblock(target));\n+                    funclet_br(self, bcx, target);\n                     return;\n                 }\n \n@@ -328,10 +365,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                         }\n \n                         if let Some((_, target)) = *destination {\n-                            for op in args {\n-                                self.set_operand_dropped(&bcx, op);\n-                            }\n-                            funclet_br(bcx, self.llblock(target));\n+                            funclet_br(self, bcx, target);\n                         } else {\n                             // trans_intrinsic_call already used Unreachable.\n                             // bcx.unreachable();\n@@ -344,28 +378,19 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 };\n \n                 // Many different ways to call a function handled here\n-                if let Some(cleanup) = cleanup.map(|bb| self.bcx(bb)) {\n+                if let &Some(cleanup) = cleanup {\n                     let ret_bcx = if let Some((_, target)) = *destination {\n                         self.blocks[target.index()]\n                     } else {\n                         self.unreachable_block()\n                     };\n-                    let landingpad = self.make_landing_pad(cleanup);\n-\n                     let invokeret = bcx.invoke(fn_ptr,\n                                                &llargs,\n                                                ret_bcx.llbb,\n-                                               landingpad.llbb(),\n-                                               cleanup_bundle.as_ref());\n+                                               llblock(self, cleanup),\n+                                               cleanup_bundle);\n                     fn_ty.apply_attrs_callsite(invokeret);\n \n-                    landingpad.at_start(|bcx| {\n-                        debug_loc.apply_to_bcx(bcx);\n-                        for op in args {\n-                            self.set_operand_dropped(bcx, op);\n-                        }\n-                    });\n-\n                     if destination.is_some() {\n                         let ret_bcx = ret_bcx.build();\n                         ret_bcx.at_start(|ret_bcx| {\n@@ -375,26 +400,19 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                                 ty: sig.output.unwrap()\n                             };\n                             self.store_return(&ret_bcx, ret_dest, fn_ty.ret, op);\n-                            for op in args {\n-                                self.set_operand_dropped(&ret_bcx, op);\n-                            }\n                         });\n                     }\n                 } else {\n-                    let llret = bcx.call(fn_ptr, &llargs, cleanup_bundle.as_ref());\n+                    let llret = bcx.call(fn_ptr, &llargs, cleanup_bundle);\n                     fn_ty.apply_attrs_callsite(llret);\n                     if let Some((_, target)) = *destination {\n                         let op = OperandRef {\n                             val: OperandValue::Immediate(llret),\n                             ty: sig.output.unwrap()\n                         };\n                         self.store_return(&bcx, ret_dest, fn_ty.ret, op);\n-                        for op in args {\n-                            self.set_operand_dropped(&bcx, op);\n-                        }\n-                        funclet_br(bcx, self.llblock(target));\n+                        funclet_br(self, bcx, target);\n                     } else {\n-                        // no need to drop args, because the call never returns\n                         bcx.unreachable();\n                     }\n                 }\n@@ -534,54 +552,64 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n         }\n     }\n \n-    /// Create a landingpad wrapper around the given Block.\n+    fn cleanup_kind(&self, bb: mir::BasicBlock) -> CleanupKind {\n+        self.cleanup_kinds[bb.index()]\n+    }\n+\n+    /// Return the landingpad wrapper around the given basic block\n     ///\n     /// No-op in MSVC SEH scheme.\n-    fn make_landing_pad(&mut self,\n-                        cleanup: BlockAndBuilder<'bcx, 'tcx>)\n-                        -> BlockAndBuilder<'bcx, 'tcx>\n+    fn landing_pad_to(&mut self, target_bb: mir::BasicBlock) -> Block<'bcx, 'tcx>\n     {\n-        if base::wants_msvc_seh(cleanup.sess()) {\n-            return cleanup;\n+        if let Some(block) = self.landing_pads[target_bb.index()] {\n+            return block;\n+        }\n+\n+        if base::wants_msvc_seh(self.fcx.ccx.sess()) {\n+            return self.blocks[target_bb.index()];\n         }\n-        let bcx = self.fcx.new_block(\"cleanup\", None).build();\n+\n+        let target = self.bcx(target_bb);\n+\n+        let block = self.fcx.new_block(\"cleanup\", None);\n+        self.landing_pads[target_bb.index()] = Some(block);\n+\n+        let bcx = block.build();\n         let ccx = bcx.ccx();\n         let llpersonality = self.fcx.eh_personality();\n         let llretty = Type::struct_(ccx, &[Type::i8p(ccx), Type::i32(ccx)], false);\n         let llretval = bcx.landing_pad(llretty, llpersonality, 1, self.fcx.llfn);\n         bcx.set_cleanup(llretval);\n         let slot = self.get_personality_slot(&bcx);\n         bcx.store(llretval, slot);\n-        bcx.br(cleanup.llbb());\n-        bcx\n+        bcx.br(target.llbb());\n+        block\n     }\n \n-    /// Create prologue cleanuppad instruction under MSVC SEH handling scheme.\n-    ///\n-    /// Also handles setting some state for the original trans and creating an operand bundle for\n-    /// function calls.\n-    fn make_cleanup_pad(&mut self, bb: mir::BasicBlock) -> Option<(ValueRef, OperandBundleDef)> {\n+    pub fn init_cpad(&mut self, bb: mir::BasicBlock) {\n         let bcx = self.bcx(bb);\n         let data = self.mir.basic_block_data(bb);\n-        let use_funclets = base::wants_msvc_seh(bcx.sess()) && data.is_cleanup;\n-        let cleanup_pad = if use_funclets {\n-            bcx.set_personality_fn(self.fcx.eh_personality());\n-            bcx.at_start(|bcx| {\n-                DebugLoc::None.apply_to_bcx(bcx);\n-                Some(bcx.cleanup_pad(None, &[]))\n-            })\n-        } else {\n-            None\n+        debug!(\"init_cpad({:?})\", data);\n+\n+        match self.cleanup_kinds[bb.index()] {\n+            CleanupKind::NotCleanup => {\n+                bcx.set_lpad(None)\n+            }\n+            _ if !base::wants_msvc_seh(bcx.sess()) => {\n+                bcx.set_lpad(Some(LandingPad::gnu()))\n+            }\n+            CleanupKind::Internal { funclet } => {\n+                // FIXME: is this needed?\n+                bcx.set_personality_fn(self.fcx.eh_personality());\n+                bcx.set_lpad_ref(self.bcx(funclet).lpad());\n+            }\n+            CleanupKind::Funclet => {\n+                bcx.set_personality_fn(self.fcx.eh_personality());\n+                DebugLoc::None.apply_to_bcx(&bcx);\n+                let cleanup_pad = bcx.cleanup_pad(None, &[]);\n+                bcx.set_lpad(Some(LandingPad::msvc(cleanup_pad)));\n+            }\n         };\n-        // Set the landingpad global-state for old translator, so it knows about the SEH used.\n-        bcx.set_lpad(if let Some(cleanup_pad) = cleanup_pad {\n-            Some(common::LandingPad::msvc(cleanup_pad))\n-        } else if data.is_cleanup {\n-            Some(common::LandingPad::gnu())\n-        } else {\n-            None\n-        });\n-        cleanup_pad.map(|f| (f, OperandBundleDef::new(\"funclet\", &[f])))\n     }\n \n     fn unreachable_block(&mut self) -> Block<'bcx, 'tcx> {\n@@ -597,10 +625,6 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n         self.blocks[bb.index()].build()\n     }\n \n-    pub fn llblock(&self, bb: mir::BasicBlock) -> BasicBlockRef {\n-        self.blocks[bb.index()].llbb\n-    }\n-\n     fn make_return_dest(&mut self, bcx: &BlockAndBuilder<'bcx, 'tcx>,\n                         dest: &mir::Lvalue<'tcx>, fn_ret_ty: &ArgType,\n                         llargs: &mut Vec<ValueRef>, is_intrinsic: bool) -> ReturnDest {"}, {"sha": "623cd5a6f8cc9009914ac8f298e2392ea3556030", "filename": "src/librustc_trans/mir/drop.rs", "status": "removed", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/ccfaaa7d989356ff440e9960da28909491e2f00d/src%2Flibrustc_trans%2Fmir%2Fdrop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccfaaa7d989356ff440e9960da28909491e2f00d/src%2Flibrustc_trans%2Fmir%2Fdrop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fdrop.rs?ref=ccfaaa7d989356ff440e9960da28909491e2f00d", "patch": "@@ -1,27 +0,0 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use llvm::ValueRef;\n-use rustc::ty::Ty;\n-use adt;\n-use base;\n-use common::{self, BlockAndBuilder};\n-use machine;\n-use type_of;\n-use type_::Type;\n-\n-pub fn drop_fill<'bcx, 'tcx>(bcx: &BlockAndBuilder<'bcx, 'tcx>, value: ValueRef, ty: Ty<'tcx>) {\n-    let llty = type_of::type_of(bcx.ccx(), ty);\n-    let llptr = bcx.pointercast(value, Type::i8(bcx.ccx()).ptr_to());\n-    let filling = common::C_u8(bcx.ccx(), adt::DTOR_DONE);\n-    let size = machine::llsize_of(bcx.ccx(), llty);\n-    let align = common::C_u32(bcx.ccx(), machine::llalign_of_min(bcx.ccx(), llty));\n-    base::call_memset(&bcx, llptr, filling, size, align, false);\n-}"}, {"sha": "bc79482666c929c54ab7d7f2ef782b1ede917e6b", "filename": "src/librustc_trans/mir/lvalue.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f97c411548f2b64f74f2bcb84dcc37075c05e2a0/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f97c411548f2b64f74f2bcb84dcc37075c05e2a0/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Flvalue.rs?ref=f97c411548f2b64f74f2bcb84dcc37075c05e2a0", "patch": "@@ -20,7 +20,6 @@ use common::{self, BlockAndBuilder, CrateContext, C_uint, C_undef};\n use consts;\n use machine;\n use type_of::type_of;\n-use mir::drop;\n use Disr;\n \n use std::ptr;\n@@ -51,9 +50,6 @@ impl<'tcx> LvalueRef<'tcx> {\n     {\n         assert!(!ty.has_erasable_regions());\n         let lltemp = bcx.with_block(|bcx| base::alloc_ty(bcx, ty, name));\n-        if bcx.fcx().type_needs_drop(ty) {\n-            drop::drop_fill(bcx, lltemp, ty);\n-        }\n         LvalueRef::new_sized(lltemp, LvalueTy::from_ty(ty))\n     }\n "}, {"sha": "d1206550b13d6bb705acb99000522a914da3b4ce", "filename": "src/librustc_trans/mir/mod.rs", "status": "modified", "additions": 21, "deletions": 6, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/f97c411548f2b64f74f2bcb84dcc37075c05e2a0/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f97c411548f2b64f74f2bcb84dcc37075c05e2a0/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fmod.rs?ref=f97c411548f2b64f74f2bcb84dcc37075c05e2a0", "patch": "@@ -73,6 +73,13 @@ pub struct MirContext<'bcx, 'tcx:'bcx> {\n     /// A `Block` for each MIR `BasicBlock`\n     blocks: Vec<Block<'bcx, 'tcx>>,\n \n+    /// The funclet status of each basic block\n+    cleanup_kinds: Vec<analyze::CleanupKind>,\n+\n+    /// This stores the landing-pad block for a given BB, computed lazily on GNU\n+    /// and eagerly on MSVC.\n+    landing_pads: Vec<Option<Block<'bcx, 'tcx>>>,\n+\n     /// Cached unreachable block\n     unreachable_block: Option<Block<'bcx, 'tcx>>,\n \n@@ -139,8 +146,9 @@ pub fn trans_mir<'blk, 'tcx: 'blk>(fcx: &'blk FunctionContext<'blk, 'tcx>) {\n \n     // Analyze the temps to determine which must be lvalues\n     // FIXME\n-    let lvalue_temps = bcx.with_block(|bcx| {\n-      analyze::lvalue_temps(bcx, &mir)\n+    let (lvalue_temps, cleanup_kinds) = bcx.with_block(|bcx| {\n+        (analyze::lvalue_temps(bcx, &mir),\n+         analyze::cleanup_kinds(bcx, &mir))\n     });\n \n     // Compute debuginfo scopes from MIR scopes.\n@@ -206,6 +214,8 @@ pub fn trans_mir<'blk, 'tcx: 'blk>(fcx: &'blk FunctionContext<'blk, 'tcx>) {\n         llpersonalityslot: None,\n         blocks: block_bcxs,\n         unreachable_block: None,\n+        cleanup_kinds: cleanup_kinds,\n+        landing_pads: mir_blocks.iter().map(|_| None).collect(),\n         vars: vars,\n         temps: temps,\n         args: args,\n@@ -214,7 +224,14 @@ pub fn trans_mir<'blk, 'tcx: 'blk>(fcx: &'blk FunctionContext<'blk, 'tcx>) {\n \n     let mut visited = BitVector::new(mir_blocks.len());\n \n-    let rpo = traversal::reverse_postorder(&mir);\n+    let mut rpo = traversal::reverse_postorder(&mir);\n+\n+    // Prepare each block for translation.\n+    for (bb, _) in rpo.by_ref() {\n+        mircx.init_cpad(bb);\n+    }\n+    rpo.reset();\n+\n     // Translate the body of each block using reverse postorder\n     for (bb, _) in rpo {\n         visited.insert(bb.index());\n@@ -228,8 +245,7 @@ pub fn trans_mir<'blk, 'tcx: 'blk>(fcx: &'blk FunctionContext<'blk, 'tcx>) {\n         let block = BasicBlock(block.llbb);\n         // Unreachable block\n         if !visited.contains(bb.index()) {\n-            block.delete();\n-        } else if block.pred_iter().count() == 0 {\n+            debug!(\"trans_mir: block {:?} was not visited\", bb);\n             block.delete();\n         }\n     }\n@@ -431,7 +447,6 @@ fn arg_value_refs<'bcx, 'tcx>(bcx: &BlockAndBuilder<'bcx, 'tcx>,\n mod analyze;\n mod block;\n mod constant;\n-mod drop;\n mod lvalue;\n mod operand;\n mod rvalue;"}, {"sha": "107ec1159f010a7fd90730ed65578dbdf61d5d6f", "filename": "src/librustc_trans/mir/operand.rs", "status": "modified", "additions": 1, "deletions": 27, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/f97c411548f2b64f74f2bcb84dcc37075c05e2a0/src%2Flibrustc_trans%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f97c411548f2b64f74f2bcb84dcc37075c05e2a0/src%2Flibrustc_trans%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Foperand.rs?ref=f97c411548f2b64f74f2bcb84dcc37075c05e2a0", "patch": "@@ -15,12 +15,11 @@ use base;\n use common::{self, Block, BlockAndBuilder};\n use datum;\n use value::Value;\n-use glue;\n \n use std::fmt;\n \n use super::lvalue::load_fat_ptr;\n-use super::{MirContext, TempRef, drop};\n+use super::{MirContext, TempRef};\n \n /// The representation of a Rust value. The enum variant is in fact\n /// uniquely determined by the value's type, but is kept as a\n@@ -179,29 +178,4 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n             }\n         }\n     }\n-\n-    pub fn set_operand_dropped(&mut self,\n-                               bcx: &BlockAndBuilder<'bcx, 'tcx>,\n-                               operand: &mir::Operand<'tcx>) {\n-        match *operand {\n-            mir::Operand::Constant(_) => return,\n-            mir::Operand::Consume(ref lvalue) => {\n-                if let mir::Lvalue::Temp(idx) = *lvalue {\n-                    if let TempRef::Operand(..) = self.temps[idx as usize] {\n-                        // All lvalues which have an associated drop are promoted to an alloca\n-                        // beforehand. If this is an operand, it is safe to say this is never\n-                        // dropped and there\u2019s no reason for us to zero this out at all.\n-                        return\n-                    }\n-                }\n-                let lvalue = self.trans_lvalue(bcx, lvalue);\n-                let ty = lvalue.ty.to_ty(bcx.tcx());\n-                if !glue::type_needs_drop(bcx.tcx(), ty) {\n-                    return\n-                } else {\n-                    drop::drop_fill(bcx, lvalue.llval, ty);\n-                }\n-            }\n-        }\n-    }\n }"}, {"sha": "6d141862ac3fffdc911f01572c3123a78441e64d", "filename": "src/librustc_trans/mir/rvalue.rs", "status": "modified", "additions": 4, "deletions": 22, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/f97c411548f2b64f74f2bcb84dcc37075c05e2a0/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f97c411548f2b64f74f2bcb84dcc37075c05e2a0/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Frvalue.rs?ref=f97c411548f2b64f74f2bcb84dcc37075c05e2a0", "patch": "@@ -25,7 +25,6 @@ use type_of;\n use tvec;\n use value::Value;\n use Disr;\n-use glue;\n \n use super::MirContext;\n use super::operand::{OperandRef, OperandValue};\n@@ -48,7 +47,6 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                // FIXME: consider not copying constants through stack. (fixable by translating\n                // constants into OperandValue::Ref, why don\u2019t we do that yet if we don\u2019t?)\n                self.store_operand(&bcx, dest.llval, tr_operand);\n-               self.set_operand_dropped(&bcx, operand);\n                bcx\n            }\n \n@@ -92,7 +90,6 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                         }\n                     }\n                 });\n-                self.set_operand_dropped(&bcx, source);\n                 bcx\n             }\n \n@@ -107,7 +104,6 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                         block\n                     })\n                 });\n-                self.set_operand_dropped(&bcx, elem);\n                 bcx\n             }\n \n@@ -128,7 +124,6 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                                                                             val, disr, i);\n                                 self.store_operand(&bcx, lldest_i, op);\n                             }\n-                            self.set_operand_dropped(&bcx, operand);\n                         }\n                     },\n                     _ => {\n@@ -167,7 +162,6 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                                 let dest = bcx.gepi(dest.llval, &[0, i]);\n                                 self.store_operand(&bcx, dest, op);\n                             }\n-                            self.set_operand_dropped(&bcx, operand);\n                         }\n                     }\n                 }\n@@ -209,9 +203,6 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                     asm::trans_inline_asm(bcx, asm, outputs, input_vals);\n                 });\n \n-                for input in inputs {\n-                    self.set_operand_dropped(&bcx, input);\n-                }\n                 bcx\n             }\n \n@@ -269,7 +260,6 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                                 //   &'a fmt::Debug+Send => &'a fmt::Debug,\n                                 // So we need to pointercast the base to ensure\n                                 // the types match up.\n-                                self.set_operand_dropped(&bcx, source);\n                                 let llcast_ty = type_of::fat_ptr_base_ty(bcx.ccx(), cast_ty);\n                                 let lldata = bcx.pointercast(lldata, llcast_ty);\n                                 OperandValue::FatPtr(lldata, llextra)\n@@ -280,7 +270,6 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                                     base::unsize_thin_ptr(bcx, lldata,\n                                                           operand.ty, cast_ty)\n                                 });\n-                                self.set_operand_dropped(&bcx, source);\n                                 OperandValue::FatPtr(lldata, llextra)\n                             }\n                             OperandValue::Ref(_) => {\n@@ -569,30 +558,23 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n     }\n }\n \n-pub fn rvalue_creates_operand<'bcx, 'tcx>(mir: &mir::Mir<'tcx>,\n-                                          bcx: &BlockAndBuilder<'bcx, 'tcx>,\n+pub fn rvalue_creates_operand<'bcx, 'tcx>(_mir: &mir::Mir<'tcx>,\n+                                          _bcx: &BlockAndBuilder<'bcx, 'tcx>,\n                                           rvalue: &mir::Rvalue<'tcx>) -> bool {\n     match *rvalue {\n         mir::Rvalue::Ref(..) |\n         mir::Rvalue::Len(..) |\n         mir::Rvalue::Cast(..) | // (*)\n         mir::Rvalue::BinaryOp(..) |\n         mir::Rvalue::UnaryOp(..) |\n-        mir::Rvalue::Box(..) =>\n+        mir::Rvalue::Box(..) |\n+        mir::Rvalue::Use(..) =>\n             true,\n         mir::Rvalue::Repeat(..) |\n         mir::Rvalue::Aggregate(..) |\n         mir::Rvalue::Slice { .. } |\n         mir::Rvalue::InlineAsm { .. } =>\n             false,\n-        mir::Rvalue::Use(ref operand) => {\n-            let ty = mir.operand_ty(bcx.tcx(), operand);\n-            let ty = bcx.monomorphize(&ty);\n-            // Types that don't need dropping can just be an operand,\n-            // this allows temporary lvalues, used as rvalues, to\n-            // avoid a stack slot when it's unnecessary\n-            !glue::type_needs_drop(bcx.tcx(), ty)\n-        }\n     }\n \n     // (*) this is only true if the type is suitable"}, {"sha": "cf84dd57d0254e61a7f67a95a4c6098e7a90d574", "filename": "src/librustc_trans/monomorphize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f97c411548f2b64f74f2bcb84dcc37075c05e2a0/src%2Flibrustc_trans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f97c411548f2b64f74f2bcb84dcc37075c05e2a0/src%2Flibrustc_trans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmonomorphize.rs?ref=f97c411548f2b64f74f2bcb84dcc37075c05e2a0", "patch": "@@ -173,7 +173,7 @@ pub struct Instance<'tcx> {\n impl<'tcx> fmt::Display for Instance<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         ppaux::parameterized(f, &self.substs, self.def, ppaux::Ns::Value, &[],\n-                             |tcx| tcx.lookup_item_type(self.def).generics)\n+                             |tcx| Some(tcx.lookup_item_type(self.def).generics))\n     }\n }\n "}, {"sha": "80ad955b60b3ac02d0462a4a65fcea597d0ebfb1", "filename": "src/llvm", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fllvm?ref=f97c411548f2b64f74f2bcb84dcc37075c05e2a0", "patch": "@@ -1 +1 @@\n-Subproject commit a73c41e7f1c85cd814e9792fc6a6a8f8e31b8dd4\n+Subproject commit 80ad955b60b3ac02d0462a4a65fcea597d0ebfb1"}, {"sha": "195125793be8a7430bc08f437a96009b8bbed035", "filename": "src/test/codegen-units/item-collection/cross-crate-trait-method.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f97c411548f2b64f74f2bcb84dcc37075c05e2a0/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fcross-crate-trait-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f97c411548f2b64f74f2bcb84dcc37075c05e2a0/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fcross-crate-trait-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fcross-crate-trait-method.rs?ref=f97c411548f2b64f74f2bcb84dcc37075c05e2a0", "patch": "@@ -56,5 +56,3 @@ fn main()\n     //~ TRANS_ITEM fn cgu_export_trait_method::{{impl}}[0]::without_default_impl_generic[0]<bool>\n     let _: (char, bool) = Trait::without_default_impl_generic(false);\n }\n-\n-//~ TRANS_ITEM drop-glue i8"}, {"sha": "afe6ffc8bfe038527c5594e652428bd0635ae8b2", "filename": "src/test/codegen-units/item-collection/generic-functions.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f97c411548f2b64f74f2bcb84dcc37075c05e2a0/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fgeneric-functions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f97c411548f2b64f74f2bcb84dcc37075c05e2a0/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fgeneric-functions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fgeneric-functions.rs?ref=f97c411548f2b64f74f2bcb84dcc37075c05e2a0", "patch": "@@ -60,5 +60,3 @@ fn main() {\n     //~ TRANS_ITEM fn generic_functions::foo3[0]<char, (), ()>\n     let _ = foo3('v', (), ());\n }\n-\n-//~ TRANS_ITEM drop-glue i8"}, {"sha": "f5641f1f2ed7376210ca0a73e2bc34f11c3a840b", "filename": "src/test/codegen-units/partitioning/local-generic.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f97c411548f2b64f74f2bcb84dcc37075c05e2a0/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Flocal-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f97c411548f2b64f74f2bcb84dcc37075c05e2a0/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Flocal-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Flocal-generic.rs?ref=f97c411548f2b64f74f2bcb84dcc37075c05e2a0", "patch": "@@ -56,5 +56,3 @@ mod mod2 {\n         let _ = generic(\"abc\");\n     }\n }\n-\n-//~ TRANS_ITEM drop-glue i8"}, {"sha": "eb668517bdf348ba514bfa4b9f437ed740b9bbec", "filename": "src/test/run-fail/issue-30380.rs", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/f97c411548f2b64f74f2bcb84dcc37075c05e2a0/src%2Ftest%2Frun-fail%2Fissue-30380.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f97c411548f2b64f74f2bcb84dcc37075c05e2a0/src%2Ftest%2Frun-fail%2Fissue-30380.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fissue-30380.rs?ref=f97c411548f2b64f74f2bcb84dcc37075c05e2a0", "patch": "@@ -0,0 +1,47 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(rustc_attrs)]\n+\n+// check that panics in destructors during assignment do not leave\n+// destroyed values lying around for other destructors to observe.\n+\n+// error-pattern:panicking destructors ftw!\n+\n+struct Observer<'a>(&'a mut FilledOnDrop);\n+\n+struct FilledOnDrop(u32);\n+impl Drop for FilledOnDrop {\n+    fn drop(&mut self) {\n+        if self.0 == 0 {\n+            // this is only set during the destructor - safe\n+            // code should not be able to observe this.\n+            self.0 = 0x1c1c1c1c;\n+            panic!(\"panicking destructors ftw!\");\n+        }\n+    }\n+}\n+\n+impl<'a> Drop for Observer<'a> {\n+    fn drop(&mut self) {\n+        assert_eq!(self.0 .0, 1);\n+    }\n+}\n+\n+#[rustc_mir]\n+fn foo(b: &mut Observer) {\n+    *b.0 = FilledOnDrop(1);\n+}\n+\n+fn main() {\n+    let mut bomb = FilledOnDrop(0);\n+    let mut observer = Observer(&mut bomb);\n+    foo(&mut observer);\n+}"}, {"sha": "023f2218b87ae7e7afaf853e5d953b53363da95e", "filename": "src/test/run-make/atomic-lock-free/atomic_lock_free.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f97c411548f2b64f74f2bcb84dcc37075c05e2a0/src%2Ftest%2Frun-make%2Fatomic-lock-free%2Fatomic_lock_free.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f97c411548f2b64f74f2bcb84dcc37075c05e2a0/src%2Ftest%2Frun-make%2Fatomic-lock-free%2Fatomic_lock_free.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fatomic-lock-free%2Fatomic_lock_free.rs?ref=f97c411548f2b64f74f2bcb84dcc37075c05e2a0", "patch": "@@ -18,6 +18,8 @@ extern \"rust-intrinsic\" {\n \n #[lang = \"sized\"]\n trait Sized {}\n+#[lang = \"copy\"]\n+trait Copy {}\n \n #[cfg(target_has_atomic = \"8\")]\n pub unsafe fn atomic_u8(x: *mut u8) {"}, {"sha": "f917531e868f1ba29d93c75ce5b8a5a4bd287060", "filename": "src/test/run-pass/dynamic-drop.rs", "status": "added", "additions": 156, "deletions": 0, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/f97c411548f2b64f74f2bcb84dcc37075c05e2a0/src%2Ftest%2Frun-pass%2Fdynamic-drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f97c411548f2b64f74f2bcb84dcc37075c05e2a0/src%2Ftest%2Frun-pass%2Fdynamic-drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdynamic-drop.rs?ref=f97c411548f2b64f74f2bcb84dcc37075c05e2a0", "patch": "@@ -0,0 +1,156 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(rustc_attrs)]\n+\n+use std::cell::{Cell, RefCell};\n+use std::panic;\n+use std::usize;\n+\n+struct InjectedFailure;\n+\n+struct Allocator {\n+    data: RefCell<Vec<bool>>,\n+    failing_op: usize,\n+    cur_ops: Cell<usize>,\n+}\n+\n+impl panic::UnwindSafe for Allocator {}\n+impl panic::RefUnwindSafe for Allocator {}\n+\n+impl Drop for Allocator {\n+    fn drop(&mut self) {\n+        let data = self.data.borrow();\n+        if data.iter().any(|d| *d) {\n+            panic!(\"missing free: {:?}\", data);\n+        }\n+    }\n+}\n+\n+impl Allocator {\n+    fn new(failing_op: usize) -> Self {\n+        Allocator {\n+            failing_op: failing_op,\n+            cur_ops: Cell::new(0),\n+            data: RefCell::new(vec![])\n+        }\n+    }\n+    fn alloc(&self) -> Ptr {\n+        self.cur_ops.set(self.cur_ops.get() + 1);\n+\n+        if self.cur_ops.get() == self.failing_op {\n+            panic!(InjectedFailure);\n+        }\n+\n+        let mut data = self.data.borrow_mut();\n+        let addr = data.len();\n+        data.push(true);\n+        Ptr(addr, self)\n+    }\n+}\n+\n+struct Ptr<'a>(usize, &'a Allocator);\n+impl<'a> Drop for Ptr<'a> {\n+    fn drop(&mut self) {\n+        match self.1.data.borrow_mut()[self.0] {\n+            false => {\n+                panic!(\"double free at index {:?}\", self.0)\n+            }\n+            ref mut d => *d = false\n+        }\n+\n+        self.1.cur_ops.set(self.1.cur_ops.get()+1);\n+\n+        if self.1.cur_ops.get() == self.1.failing_op {\n+            panic!(InjectedFailure);\n+        }\n+    }\n+}\n+\n+#[rustc_mir]\n+fn dynamic_init(a: &Allocator, c: bool) {\n+    let _x;\n+    if c {\n+        _x = Some(a.alloc());\n+    }\n+}\n+\n+#[rustc_mir]\n+fn dynamic_drop(a: &Allocator, c: bool) {\n+    let x = a.alloc();\n+    if c {\n+        Some(x)\n+    } else {\n+        None\n+    };\n+}\n+\n+#[rustc_mir]\n+fn assignment2(a: &Allocator, c0: bool, c1: bool) {\n+    let mut _v = a.alloc();\n+    let mut _w = a.alloc();\n+    if c0 {\n+        drop(_v);\n+    }\n+    _v = _w;\n+    if c1 {\n+        _w = a.alloc();\n+    }\n+}\n+\n+#[rustc_mir]\n+fn assignment1(a: &Allocator, c0: bool) {\n+    let mut _v = a.alloc();\n+    let mut _w = a.alloc();\n+    if c0 {\n+        drop(_v);\n+    }\n+    _v = _w;\n+}\n+\n+fn run_test<F>(mut f: F)\n+    where F: FnMut(&Allocator)\n+{\n+    let first_alloc = Allocator::new(usize::MAX);\n+    f(&first_alloc);\n+\n+    for failing_op in 1..first_alloc.cur_ops.get()+1 {\n+        let alloc = Allocator::new(failing_op);\n+        let alloc = &alloc;\n+        let f = panic::AssertUnwindSafe(&mut f);\n+        let result = panic::catch_unwind(move || {\n+            f.0(alloc);\n+        });\n+        match result {\n+            Ok(..) => panic!(\"test executed {} ops but now {}\",\n+                             first_alloc.cur_ops.get(), alloc.cur_ops.get()),\n+            Err(e) => {\n+                if e.downcast_ref::<InjectedFailure>().is_none() {\n+                    panic::resume_unwind(e);\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+fn main() {\n+    run_test(|a| dynamic_init(a, false));\n+    run_test(|a| dynamic_init(a, true));\n+    run_test(|a| dynamic_drop(a, false));\n+    run_test(|a| dynamic_drop(a, true));\n+\n+    run_test(|a| assignment2(a, false, false));\n+    run_test(|a| assignment2(a, false, true));\n+    run_test(|a| assignment2(a, true, false));\n+    run_test(|a| assignment2(a, true, true));\n+\n+    run_test(|a| assignment1(a, false));\n+    run_test(|a| assignment1(a, true));\n+}"}]}