{"sha": "a19adefa0e5aca0aabca2430530577ee140e4efa", "node_id": "C_kwDOAAsO6NoAKGExOWFkZWZhMGU1YWNhMGFhYmNhMjQzMDUzMDU3N2VlMTQwZTRlZmE", "commit": {"author": {"name": "lcnr", "email": "rust@lcnr.de", "date": "2023-04-12T08:24:36Z"}, "committer": {"name": "lcnr", "email": "rust@lcnr.de", "date": "2023-04-12T08:24:36Z"}, "message": "region error cleanup\n\n- require `TypeErrCtxt` to always result in an error\n- move `resolve_regions_and_report_errors` to the `ObligationCtxt`\n- merge `process_registered_region_obligations` into `resolve_regions`", "tree": {"sha": "f180bf4a963ef803dbf21f3ed40035b626a81d34", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f180bf4a963ef803dbf21f3ed40035b626a81d34"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a19adefa0e5aca0aabca2430530577ee140e4efa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a19adefa0e5aca0aabca2430530577ee140e4efa", "html_url": "https://github.com/rust-lang/rust/commit/a19adefa0e5aca0aabca2430530577ee140e4efa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a19adefa0e5aca0aabca2430530577ee140e4efa/comments", "author": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0d7ed3ba8445452013dd873dc9abcad41a3d82b2", "url": "https://api.github.com/repos/rust-lang/rust/commits/0d7ed3ba8445452013dd873dc9abcad41a3d82b2", "html_url": "https://github.com/rust-lang/rust/commit/0d7ed3ba8445452013dd873dc9abcad41a3d82b2"}], "stats": {"total": 419, "additions": 183, "deletions": 236}, "files": [{"sha": "0bb98fdf2a23e157068cc496dd304276ae9180e4", "filename": "compiler/rustc_hir_analysis/src/check/check.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a19adefa0e5aca0aabca2430530577ee140e4efa/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a19adefa0e5aca0aabca2430530577ee140e4efa/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs?ref=a19adefa0e5aca0aabca2430530577ee140e4efa", "patch": "@@ -452,11 +452,8 @@ fn check_opaque_meets_bounds<'tcx>(\n         hir::OpaqueTyOrigin::FnReturn(..) | hir::OpaqueTyOrigin::AsyncFn(..) => {}\n         // Can have different predicates to their defining use\n         hir::OpaqueTyOrigin::TyAlias => {\n-            let outlives_environment = OutlivesEnvironment::new(param_env);\n-            let _ = infcx.err_ctxt().check_region_obligations_and_report_errors(\n-                defining_use_anchor,\n-                &outlives_environment,\n-            );\n+            let outlives_env = OutlivesEnvironment::new(param_env);\n+            let _ = ocx.resolve_regions_and_report_errors(defining_use_anchor, &outlives_env);\n         }\n     }\n     // Clean up after ourselves"}, {"sha": "5d119a7737a4cf4d740a34685300963ba6058cab", "filename": "compiler/rustc_hir_analysis/src/check/compare_impl_item.rs", "status": "modified", "additions": 11, "deletions": 29, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/a19adefa0e5aca0aabca2430530577ee140e4efa/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a19adefa0e5aca0aabca2430530577ee140e4efa/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs?ref=a19adefa0e5aca0aabca2430530577ee140e4efa", "patch": "@@ -332,10 +332,6 @@ fn compare_method_predicate_entailment<'tcx>(\n         param_env,\n         infcx.implied_bounds_tys(param_env, impl_m_def_id, wf_tys.clone()),\n     );\n-    infcx.process_registered_region_obligations(\n-        outlives_env.region_bound_pairs(),\n-        outlives_env.param_env,\n-    );\n     let errors = infcx.resolve_regions(&outlives_env);\n     if !errors.is_empty() {\n         // FIXME(compiler-errors): This can be simplified when IMPLIED_BOUNDS_ENTAILMENT\n@@ -722,18 +718,18 @@ pub(super) fn collect_return_position_impl_trait_in_trait_tys<'tcx>(\n         return Err(reported);\n     }\n \n+    let collected_types = collector.types;\n+\n     // Finally, resolve all regions. This catches wily misuses of\n     // lifetime parameters.\n-    let outlives_environment = OutlivesEnvironment::with_bounds(\n+    let outlives_env = OutlivesEnvironment::with_bounds(\n         param_env,\n         infcx.implied_bounds_tys(param_env, impl_m_def_id, wf_tys),\n     );\n-    infcx\n-        .err_ctxt()\n-        .check_region_obligations_and_report_errors(impl_m_def_id, &outlives_environment)?;\n+    ocx.resolve_regions_and_report_errors(impl_m_def_id, &outlives_env)?;\n \n     let mut collected_tys = FxHashMap::default();\n-    for (def_id, (ty, substs)) in collector.types {\n+    for (def_id, (ty, substs)) in collected_types {\n         match infcx.fully_resolve(ty) {\n             Ok(ty) => {\n                 // `ty` contains free regions that we created earlier while liberating the\n@@ -1742,11 +1738,8 @@ pub(super) fn compare_impl_const_raw(\n         return Err(infcx.err_ctxt().report_fulfillment_errors(&errors));\n     }\n \n-    let outlives_environment = OutlivesEnvironment::new(param_env);\n-    infcx\n-        .err_ctxt()\n-        .check_region_obligations_and_report_errors(impl_const_item_def, &outlives_environment)?;\n-    Ok(())\n+    let outlives_env = OutlivesEnvironment::new(param_env);\n+    ocx.resolve_regions_and_report_errors(impl_const_item_def, &outlives_env)\n }\n \n pub(super) fn compare_impl_ty<'tcx>(\n@@ -1845,13 +1838,8 @@ fn compare_type_predicate_entailment<'tcx>(\n \n     // Finally, resolve all regions. This catches wily misuses of\n     // lifetime parameters.\n-    let outlives_environment = OutlivesEnvironment::new(param_env);\n-    infcx.err_ctxt().check_region_obligations_and_report_errors(\n-        impl_ty.def_id.expect_local(),\n-        &outlives_environment,\n-    )?;\n-\n-    Ok(())\n+    let outlives_env = OutlivesEnvironment::new(param_env);\n+    ocx.resolve_regions_and_report_errors(impl_ty_def_id, &outlives_env)\n }\n \n /// Validate that `ProjectionCandidate`s created for this associated type will\n@@ -2063,14 +2051,8 @@ pub(super) fn check_type_bounds<'tcx>(\n     // Finally, resolve all regions. This catches wily misuses of\n     // lifetime parameters.\n     let implied_bounds = infcx.implied_bounds_tys(param_env, impl_ty_def_id, assumed_wf_types);\n-    let outlives_environment = OutlivesEnvironment::with_bounds(param_env, implied_bounds);\n-\n-    infcx.err_ctxt().check_region_obligations_and_report_errors(\n-        impl_ty.def_id.expect_local(),\n-        &outlives_environment,\n-    )?;\n-\n-    Ok(())\n+    let outlives_env = OutlivesEnvironment::with_bounds(param_env, implied_bounds);\n+    ocx.resolve_regions_and_report_errors(impl_ty_def_id, &outlives_env)\n }\n \n fn assoc_item_kind_str(impl_item: &ty::AssocItem) -> &'static str {"}, {"sha": "53197bc849106c44917b26b9a5c907634d5c9666", "filename": "compiler/rustc_hir_analysis/src/check/wfcheck.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a19adefa0e5aca0aabca2430530577ee140e4efa/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a19adefa0e5aca0aabca2430530577ee140e4efa/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=a19adefa0e5aca0aabca2430530577ee140e4efa", "patch": "@@ -114,11 +114,9 @@ pub(super) fn enter_wf_checking_ctxt<'tcx, F>(\n         return;\n     }\n \n-    let outlives_environment = OutlivesEnvironment::with_bounds(param_env, implied_bounds);\n+    let outlives_env = OutlivesEnvironment::with_bounds(param_env, implied_bounds);\n \n-    let _ = infcx\n-        .err_ctxt()\n-        .check_region_obligations_and_report_errors(body_def_id, &outlives_environment);\n+    let _ = wfcx.ocx.resolve_regions_and_report_errors(body_def_id, &outlives_env);\n }\n \n fn check_well_formed(tcx: TyCtxt<'_>, def_id: hir::OwnerId) {\n@@ -680,12 +678,7 @@ fn resolve_regions_with_wf_tys<'tcx>(\n \n     add_constraints(&infcx, region_bound_pairs);\n \n-    infcx.process_registered_region_obligations(\n-        outlives_environment.region_bound_pairs(),\n-        param_env,\n-    );\n     let errors = infcx.resolve_regions(&outlives_environment);\n-\n     debug!(?errors, \"errors\");\n \n     // If we were able to prove that the type outlives the region without"}, {"sha": "0f40cca9427b4500c02a03a8c19bbb785a1798c9", "filename": "compiler/rustc_hir_analysis/src/coherence/builtin.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a19adefa0e5aca0aabca2430530577ee140e4efa/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a19adefa0e5aca0aabca2430530577ee140e4efa/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs?ref=a19adefa0e5aca0aabca2430530577ee140e4efa", "patch": "@@ -354,9 +354,7 @@ fn visit_implementation_of_dispatch_from_dyn(tcx: TyCtxt<'_>, impl_did: LocalDef\n \n                 // Finally, resolve all regions.\n                 let outlives_env = OutlivesEnvironment::new(param_env);\n-                let _ = infcx\n-                    .err_ctxt()\n-                    .check_region_obligations_and_report_errors(impl_did, &outlives_env);\n+                let _ = ocx.resolve_regions_and_report_errors(impl_did, &outlives_env);\n             }\n         }\n         _ => {\n@@ -592,7 +590,7 @@ pub fn coerce_unsized_info<'tcx>(tcx: TyCtxt<'tcx>, impl_did: LocalDefId) -> Coe\n \n     // Finally, resolve all regions.\n     let outlives_env = OutlivesEnvironment::new(param_env);\n-    let _ = infcx.err_ctxt().check_region_obligations_and_report_errors(impl_did, &outlives_env);\n+    let _ = ocx.resolve_regions_and_report_errors(impl_did, &outlives_env);\n \n     CoerceUnsizedInfo { custom_kind: kind }\n }"}, {"sha": "eb2fc395223ed5f4c28728d834eae654e722b95b", "filename": "compiler/rustc_hir_analysis/src/impl_wf_check/min_specialization.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a19adefa0e5aca0aabca2430530577ee140e4efa/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a19adefa0e5aca0aabca2430530577ee140e4efa/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs?ref=a19adefa0e5aca0aabca2430530577ee140e4efa", "patch": "@@ -180,8 +180,7 @@ fn get_impl_substs(\n \n     let implied_bounds = infcx.implied_bounds_tys(param_env, impl1_def_id, assumed_wf_types);\n     let outlives_env = OutlivesEnvironment::with_bounds(param_env, implied_bounds);\n-    let _ =\n-        infcx.err_ctxt().check_region_obligations_and_report_errors(impl1_def_id, &outlives_env);\n+    let _ = ocx.resolve_regions_and_report_errors(impl1_def_id, &outlives_env);\n     let Ok(impl2_substs) = infcx.fully_resolve(impl2_substs) else {\n         let span = tcx.def_span(impl1_def_id);\n         tcx.sess.emit_err(SubstsOnOverriddenImpl { span });"}, {"sha": "f6bed12ee2d437d551e0db483170c7f775b9613a", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 28, "deletions": 2, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/a19adefa0e5aca0aabca2430530577ee140e4efa/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a19adefa0e5aca0aabca2430530577ee140e4efa/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=a19adefa0e5aca0aabca2430530577ee140e4efa", "patch": "@@ -74,6 +74,7 @@ use rustc_middle::ty::{\n     self, error::TypeError, List, Region, Ty, TyCtxt, TypeFoldable, TypeSuperVisitable,\n     TypeVisitable, TypeVisitableExt,\n };\n+use rustc_span::DUMMY_SP;\n use rustc_span::{sym, symbol::kw, BytePos, DesugaringKind, Pos, Span};\n use rustc_target::spec::abi;\n use std::ops::{ControlFlow, Deref};\n@@ -113,7 +114,11 @@ fn escape_literal(s: &str) -> String {\n \n /// A helper for building type related errors. The `typeck_results`\n /// field is only populated during an in-progress typeck.\n-/// Get an instance by calling `InferCtxt::err` or `FnCtxt::infer_err`.\n+/// Get an instance by calling `InferCtxt::err_ctxt` or `FnCtxt::err_ctxt`.\n+///\n+/// You must only create this if you intend to actually emit an error.\n+/// This provides a lot of utility methods which should not be used\n+/// during the happy path.\n pub struct TypeErrCtxt<'a, 'tcx> {\n     pub infcx: &'a InferCtxt<'tcx>,\n     pub typeck_results: Option<std::cell::Ref<'a, ty::TypeckResults<'tcx>>>,\n@@ -125,6 +130,19 @@ pub struct TypeErrCtxt<'a, 'tcx> {\n         Box<dyn Fn(Ty<'tcx>) -> Vec<(Ty<'tcx>, Vec<PredicateObligation<'tcx>>)> + 'a>,\n }\n \n+impl Drop for TypeErrCtxt<'_, '_> {\n+    fn drop(&mut self) {\n+        if let Some(_) = self.infcx.tcx.sess.has_errors_or_delayed_span_bugs() {\n+            // ok, emitted an error.\n+        } else {\n+            self.infcx\n+                .tcx\n+                .sess\n+                .delay_span_bug(DUMMY_SP, \"used a `TypeErrCtxt` without failing compilation\");\n+        }\n+    }\n+}\n+\n impl TypeErrCtxt<'_, '_> {\n     /// This is just to avoid a potential footgun of accidentally\n     /// dropping `typeck_results` by calling `InferCtxt::err_ctxt`\n@@ -419,7 +437,11 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n         &self,\n         generic_param_scope: LocalDefId,\n         errors: &[RegionResolutionError<'tcx>],\n-    ) {\n+    ) -> ErrorGuaranteed {\n+        if let Some(guaranteed) = self.infcx.tainted_by_errors() {\n+            return guaranteed;\n+        }\n+\n         debug!(\"report_region_errors(): {} errors to start\", errors.len());\n \n         // try to pre-process the errors, which will group some of them\n@@ -499,6 +521,10 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n                 }\n             }\n         }\n+\n+        self.tcx\n+            .sess\n+            .delay_span_bug(self.tcx.def_span(generic_param_scope), \"expected region errors\")\n     }\n \n     // This method goes through all the errors and try to group certain types"}, {"sha": "66f51328bbe7ce9f0dba71643d90c5b4595584b5", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 1, "deletions": 141, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/a19adefa0e5aca0aabca2430530577ee140e4efa/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a19adefa0e5aca0aabca2430530577ee140e4efa/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=a19adefa0e5aca0aabca2430530577ee140e4efa", "patch": "@@ -45,8 +45,7 @@ use self::combine::CombineFields;\n use self::error_reporting::TypeErrCtxt;\n use self::free_regions::RegionRelations;\n use self::lexical_region_resolve::LexicalRegionResolutions;\n-use self::outlives::env::OutlivesEnvironment;\n-use self::region_constraints::{GenericKind, RegionConstraintData, VarInfos, VerifyBound};\n+use self::region_constraints::{GenericKind, VarInfos, VerifyBound};\n use self::region_constraints::{\n     RegionConstraintCollector, RegionConstraintStorage, RegionSnapshot,\n };\n@@ -1213,95 +1212,6 @@ impl<'tcx> InferCtxt<'tcx> {\n         self.tainted_by_errors.set(Some(e));\n     }\n \n-    pub fn skip_region_resolution(&self) {\n-        let (var_infos, _) = {\n-            let mut inner = self.inner.borrow_mut();\n-            let inner = &mut *inner;\n-            // Note: `inner.region_obligations` may not be empty, because we\n-            // didn't necessarily call `process_registered_region_obligations`.\n-            // This is okay, because that doesn't introduce new vars.\n-            inner\n-                .region_constraint_storage\n-                .take()\n-                .expect(\"regions already resolved\")\n-                .with_log(&mut inner.undo_log)\n-                .into_infos_and_data()\n-        };\n-\n-        let lexical_region_resolutions = LexicalRegionResolutions {\n-            values: rustc_index::vec::IndexVec::from_elem_n(\n-                crate::infer::lexical_region_resolve::VarValue::Value(self.tcx.lifetimes.re_erased),\n-                var_infos.len(),\n-            ),\n-        };\n-\n-        let old_value = self.lexical_region_resolutions.replace(Some(lexical_region_resolutions));\n-        assert!(old_value.is_none());\n-    }\n-\n-    /// Process the region constraints and return any errors that\n-    /// result. After this, no more unification operations should be\n-    /// done -- or the compiler will panic -- but it is legal to use\n-    /// `resolve_vars_if_possible` as well as `fully_resolve`.\n-    pub fn resolve_regions(\n-        &self,\n-        outlives_env: &OutlivesEnvironment<'tcx>,\n-    ) -> Vec<RegionResolutionError<'tcx>> {\n-        let (var_infos, data) = {\n-            let mut inner = self.inner.borrow_mut();\n-            let inner = &mut *inner;\n-            assert!(\n-                self.tainted_by_errors().is_some() || inner.region_obligations.is_empty(),\n-                \"region_obligations not empty: {:#?}\",\n-                inner.region_obligations\n-            );\n-            inner\n-                .region_constraint_storage\n-                .take()\n-                .expect(\"regions already resolved\")\n-                .with_log(&mut inner.undo_log)\n-                .into_infos_and_data()\n-        };\n-\n-        let region_rels = &RegionRelations::new(self.tcx, outlives_env.free_region_map());\n-\n-        let (lexical_region_resolutions, errors) =\n-            lexical_region_resolve::resolve(outlives_env.param_env, region_rels, var_infos, data);\n-\n-        let old_value = self.lexical_region_resolutions.replace(Some(lexical_region_resolutions));\n-        assert!(old_value.is_none());\n-\n-        errors\n-    }\n-    /// Obtains (and clears) the current set of region\n-    /// constraints. The inference context is still usable: further\n-    /// unifications will simply add new constraints.\n-    ///\n-    /// This method is not meant to be used with normal lexical region\n-    /// resolution. Rather, it is used in the NLL mode as a kind of\n-    /// interim hack: basically we run normal type-check and generate\n-    /// region constraints as normal, but then we take them and\n-    /// translate them into the form that the NLL solver\n-    /// understands. See the NLL module for mode details.\n-    pub fn take_and_reset_region_constraints(&self) -> RegionConstraintData<'tcx> {\n-        assert!(\n-            self.inner.borrow().region_obligations.is_empty(),\n-            \"region_obligations not empty: {:#?}\",\n-            self.inner.borrow().region_obligations\n-        );\n-\n-        self.inner.borrow_mut().unwrap_region_constraints().take_and_reset_data()\n-    }\n-\n-    /// Gives temporary access to the region constraint data.\n-    pub fn with_region_constraints<R>(\n-        &self,\n-        op: impl FnOnce(&RegionConstraintData<'tcx>) -> R,\n-    ) -> R {\n-        let mut inner = self.inner.borrow_mut();\n-        op(inner.unwrap_region_constraints().data())\n-    }\n-\n     pub fn region_var_origin(&self, vid: ty::RegionVid) -> RegionVariableOrigin {\n         let mut inner = self.inner.borrow_mut();\n         let inner = &mut *inner;\n@@ -1754,56 +1664,6 @@ impl<'cx, 'tcx> Drop for CanonicalizationCtxtGuard<'cx, 'tcx> {\n }\n \n impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n-    /// Processes registered region obliations and resolves regions, reporting\n-    /// any errors if any were raised. Prefer using this function over manually\n-    /// calling `resolve_regions_and_report_errors`.\n-    pub fn check_region_obligations_and_report_errors(\n-        &self,\n-        generic_param_scope: LocalDefId,\n-        outlives_env: &OutlivesEnvironment<'tcx>,\n-    ) -> Result<(), ErrorGuaranteed> {\n-        self.process_registered_region_obligations(\n-            outlives_env.region_bound_pairs(),\n-            outlives_env.param_env,\n-        );\n-\n-        self.resolve_regions_and_report_errors(generic_param_scope, outlives_env)\n-    }\n-\n-    /// Process the region constraints and report any errors that\n-    /// result. After this, no more unification operations should be\n-    /// done -- or the compiler will panic -- but it is legal to use\n-    /// `resolve_vars_if_possible` as well as `fully_resolve`.\n-    ///\n-    /// Make sure to call [`InferCtxt::process_registered_region_obligations`]\n-    /// first, or preferably use [`TypeErrCtxt::check_region_obligations_and_report_errors`]\n-    /// to do both of these operations together.\n-    pub fn resolve_regions_and_report_errors(\n-        &self,\n-        generic_param_scope: LocalDefId,\n-        outlives_env: &OutlivesEnvironment<'tcx>,\n-    ) -> Result<(), ErrorGuaranteed> {\n-        let errors = self.resolve_regions(outlives_env);\n-\n-        if let None = self.tainted_by_errors() {\n-            // As a heuristic, just skip reporting region errors\n-            // altogether if other errors have been reported while\n-            // this infcx was in use. This is totally hokey but\n-            // otherwise we have a hard time separating legit region\n-            // errors from silly ones.\n-            self.report_region_errors(generic_param_scope, &errors);\n-        }\n-\n-        if errors.is_empty() {\n-            Ok(())\n-        } else {\n-            Err(self\n-                .tcx\n-                .sess\n-                .delay_span_bug(rustc_span::DUMMY_SP, \"error should have been emitted\"))\n-        }\n-    }\n-\n     // [Note-Type-error-reporting]\n     // An invariant is that anytime the expected or actual type is Error (the special\n     // error type, meaning that an error occurred when typechecking this expression),"}, {"sha": "21907c4b42340045e9c78789f0169b650b9958cc", "filename": "compiler/rustc_infer/src/infer/outlives/mod.rs", "status": "modified", "additions": 101, "deletions": 3, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/a19adefa0e5aca0aabca2430530577ee140e4efa/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a19adefa0e5aca0aabca2430530577ee140e4efa/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fmod.rs?ref=a19adefa0e5aca0aabca2430530577ee140e4efa", "patch": "@@ -1,14 +1,18 @@\n //! Various code related to computing outlives relations.\n+use self::env::OutlivesEnvironment;\n+use super::region_constraints::RegionConstraintData;\n+use super::{InferCtxt, RegionResolutionError};\n+use crate::infer::free_regions::RegionRelations;\n+use crate::infer::lexical_region_resolve::{self, LexicalRegionResolutions};\n+use rustc_middle::traits::query::OutlivesBound;\n+use rustc_middle::ty;\n \n pub mod components;\n pub mod env;\n pub mod obligations;\n pub mod test_type_match;\n pub mod verify;\n \n-use rustc_middle::traits::query::OutlivesBound;\n-use rustc_middle::ty;\n-\n #[instrument(level = \"debug\", skip(param_env), ret)]\n pub fn explicit_outlives_bounds<'tcx>(\n     param_env: ty::ParamEnv<'tcx>,\n@@ -39,3 +43,97 @@ pub fn explicit_outlives_bounds<'tcx>(\n             ))) => Some(OutlivesBound::RegionSubRegion(r_b, r_a)),\n         })\n }\n+\n+impl<'tcx> InferCtxt<'tcx> {\n+    pub fn skip_region_resolution(&self) {\n+        let (var_infos, _) = {\n+            let mut inner = self.inner.borrow_mut();\n+            let inner = &mut *inner;\n+            // Note: `inner.region_obligations` may not be empty, because we\n+            // didn't necessarily call `process_registered_region_obligations`.\n+            // This is okay, because that doesn't introduce new vars.\n+            inner\n+                .region_constraint_storage\n+                .take()\n+                .expect(\"regions already resolved\")\n+                .with_log(&mut inner.undo_log)\n+                .into_infos_and_data()\n+        };\n+\n+        let lexical_region_resolutions = LexicalRegionResolutions {\n+            values: rustc_index::vec::IndexVec::from_elem_n(\n+                crate::infer::lexical_region_resolve::VarValue::Value(self.tcx.lifetimes.re_erased),\n+                var_infos.len(),\n+            ),\n+        };\n+\n+        let old_value = self.lexical_region_resolutions.replace(Some(lexical_region_resolutions));\n+        assert!(old_value.is_none());\n+    }\n+\n+    /// Process the region constraints and return any errors that\n+    /// result. After this, no more unification operations should be\n+    /// done -- or the compiler will panic -- but it is legal to use\n+    /// `resolve_vars_if_possible` as well as `fully_resolve`.\n+    pub fn resolve_regions(\n+        &self,\n+        outlives_env: &OutlivesEnvironment<'tcx>,\n+    ) -> Vec<RegionResolutionError<'tcx>> {\n+        self.process_registered_region_obligations(outlives_env);\n+\n+        let (var_infos, data) = {\n+            let mut inner = self.inner.borrow_mut();\n+            let inner = &mut *inner;\n+            assert!(\n+                self.tainted_by_errors().is_some() || inner.region_obligations.is_empty(),\n+                \"region_obligations not empty: {:#?}\",\n+                inner.region_obligations\n+            );\n+            inner\n+                .region_constraint_storage\n+                .take()\n+                .expect(\"regions already resolved\")\n+                .with_log(&mut inner.undo_log)\n+                .into_infos_and_data()\n+        };\n+\n+        let region_rels = &RegionRelations::new(self.tcx, outlives_env.free_region_map());\n+\n+        let (lexical_region_resolutions, errors) =\n+            lexical_region_resolve::resolve(outlives_env.param_env, region_rels, var_infos, data);\n+\n+        let old_value = self.lexical_region_resolutions.replace(Some(lexical_region_resolutions));\n+        assert!(old_value.is_none());\n+\n+        errors\n+    }\n+\n+    /// Obtains (and clears) the current set of region\n+    /// constraints. The inference context is still usable: further\n+    /// unifications will simply add new constraints.\n+    ///\n+    /// This method is not meant to be used with normal lexical region\n+    /// resolution. Rather, it is used in the NLL mode as a kind of\n+    /// interim hack: basically we run normal type-check and generate\n+    /// region constraints as normal, but then we take them and\n+    /// translate them into the form that the NLL solver\n+    /// understands. See the NLL module for mode details.\n+    pub fn take_and_reset_region_constraints(&self) -> RegionConstraintData<'tcx> {\n+        assert!(\n+            self.inner.borrow().region_obligations.is_empty(),\n+            \"region_obligations not empty: {:#?}\",\n+            self.inner.borrow().region_obligations\n+        );\n+\n+        self.inner.borrow_mut().unwrap_region_constraints().take_and_reset_data()\n+    }\n+\n+    /// Gives temporary access to the region constraint data.\n+    pub fn with_region_constraints<R>(\n+        &self,\n+        op: impl FnOnce(&RegionConstraintData<'tcx>) -> R,\n+    ) -> R {\n+        let mut inner = self.inner.borrow_mut();\n+        op(inner.unwrap_region_constraints().data())\n+    }\n+}"}, {"sha": "ccf11c61b573bb6f88f027938d867ec6f6df6946", "filename": "compiler/rustc_infer/src/infer/outlives/obligations.rs", "status": "modified", "additions": 14, "deletions": 33, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/a19adefa0e5aca0aabca2430530577ee140e4efa/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a19adefa0e5aca0aabca2430530577ee140e4efa/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs?ref=a19adefa0e5aca0aabca2430530577ee140e4efa", "patch": "@@ -72,6 +72,8 @@ use rustc_middle::ty::subst::GenericArgKind;\n use rustc_middle::ty::{self, Region, SubstsRef, Ty, TyCtxt, TypeVisitableExt};\n use smallvec::smallvec;\n \n+use super::env::OutlivesEnvironment;\n+\n impl<'tcx> InferCtxt<'tcx> {\n     /// Registers that the given region obligation must be resolved\n     /// from within the scope of `body_id`. These regions are enqueued\n@@ -112,39 +114,17 @@ impl<'tcx> InferCtxt<'tcx> {\n         std::mem::take(&mut self.inner.borrow_mut().region_obligations)\n     }\n \n-    /// NOTE: Prefer using `TypeErrCtxt::check_region_obligations_and_report_errors`\n-    /// instead of calling this directly.\n-    ///\n     /// Process the region obligations that must be proven (during\n     /// `regionck`) for the given `body_id`, given information about\n-    /// the region bounds in scope and so forth. This function must be\n-    /// invoked for all relevant body-ids before region inference is\n-    /// done (or else an assert will fire).\n+    /// the region bounds in scope and so forth.\n     ///\n     /// See the `region_obligations` field of `InferCtxt` for some\n     /// comments about how this function fits into the overall expected\n     /// flow of the inferencer. The key point is that it is\n     /// invoked after all type-inference variables have been bound --\n-    /// towards the end of regionck. This also ensures that the\n-    /// region-bound-pairs are available (see comments above regarding\n-    /// closures).\n-    ///\n-    /// # Parameters\n-    ///\n-    /// - `region_bound_pairs_map`: the set of region bounds implied by\n-    ///   the parameters and where-clauses. In particular, each pair\n-    ///   `('a, K)` in this list tells us that the bounds in scope\n-    ///   indicate that `K: 'a`, where `K` is either a generic\n-    ///   parameter like `T` or a projection like `T::Item`.\n-    /// - `param_env` is the parameter environment for the enclosing function.\n-    /// - `body_id` is the body-id whose region obligations are being\n-    ///   processed.\n-    #[instrument(level = \"debug\", skip(self, region_bound_pairs))]\n-    pub fn process_registered_region_obligations(\n-        &self,\n-        region_bound_pairs: &RegionBoundPairs<'tcx>,\n-        param_env: ty::ParamEnv<'tcx>,\n-    ) {\n+    /// right before lexical region resolution.\n+    #[instrument(level = \"debug\", skip(self, outlives_env))]\n+    pub fn process_registered_region_obligations(&self, outlives_env: &OutlivesEnvironment<'tcx>) {\n         assert!(\n             !self.in_snapshot.get(),\n             \"cannot process registered region obligations in a snapshot\"\n@@ -153,15 +133,16 @@ impl<'tcx> InferCtxt<'tcx> {\n         let my_region_obligations = self.take_registered_region_obligations();\n \n         for RegionObligation { sup_type, sub_region, origin } in my_region_obligations {\n-            debug!(\n-                \"process_registered_region_obligations: sup_type={:?} sub_region={:?} origin={:?}\",\n-                sup_type, sub_region, origin\n-            );\n-\n+            debug!(?sup_type, ?sub_region, ?origin);\n             let sup_type = self.resolve_vars_if_possible(sup_type);\n \n-            let outlives =\n-                &mut TypeOutlives::new(self, self.tcx, &region_bound_pairs, None, param_env);\n+            let outlives = &mut TypeOutlives::new(\n+                self,\n+                self.tcx,\n+                &outlives_env.region_bound_pairs(),\n+                None,\n+                outlives_env.param_env,\n+            );\n             let category = origin.to_constraint_category();\n             outlives.type_must_outlive(origin, sup_type, sub_region, category);\n         }"}, {"sha": "fd45ef99aa9d043eea827155701edf99229cbc54", "filename": "compiler/rustc_trait_selection/src/traits/auto_trait.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a19adefa0e5aca0aabca2430530577ee140e4efa/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a19adefa0e5aca0aabca2430530577ee140e4efa/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs?ref=a19adefa0e5aca0aabca2430530577ee140e4efa", "patch": "@@ -187,7 +187,8 @@ impl<'tcx> AutoTraitFinder<'tcx> {\n             panic!(\"Unable to fulfill trait {:?} for '{:?}': {:?}\", trait_did, ty, errors);\n         }\n \n-        infcx.process_registered_region_obligations(&Default::default(), full_env);\n+        let outlives_env = OutlivesEnvironment::new(full_env);\n+        infcx.process_registered_region_obligations(&outlives_env);\n \n         let region_data =\n             infcx.inner.borrow_mut().unwrap_region_constraints().region_constraint_data().clone();"}, {"sha": "3c918b6028d475b584d83b1e6e3dbf0f88f81f11", "filename": "compiler/rustc_trait_selection/src/traits/coherence.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a19adefa0e5aca0aabca2430530577ee140e4efa/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a19adefa0e5aca0aabca2430530577ee140e4efa/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs?ref=a19adefa0e5aca0aabca2430530577ee140e4efa", "patch": "@@ -405,9 +405,6 @@ fn resolve_negative_obligation<'tcx>(\n         param_env,\n         infcx.implied_bounds_tys(param_env, body_def_id, wf_tys),\n     );\n-\n-    infcx.process_registered_region_obligations(outlives_env.region_bound_pairs(), param_env);\n-\n     infcx.resolve_regions(&outlives_env).is_empty()\n }\n "}, {"sha": "d2b39ed226f04d900b9aad82c18314f8fb8b1041", "filename": "compiler/rustc_trait_selection/src/traits/engine.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/a19adefa0e5aca0aabca2430530577ee140e4efa/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fengine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a19adefa0e5aca0aabca2430530577ee140e4efa/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fengine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fengine.rs?ref=a19adefa0e5aca0aabca2430530577ee140e4efa", "patch": "@@ -6,11 +6,13 @@ use super::{ChalkFulfillmentContext, FulfillmentContext};\n use crate::solve::FulfillmentCtxt as NextFulfillmentCtxt;\n use crate::traits::NormalizeExt;\n use rustc_data_structures::fx::FxIndexSet;\n+use rustc_errors::ErrorGuaranteed;\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_infer::infer::at::ToTrace;\n use rustc_infer::infer::canonical::{\n     Canonical, CanonicalQueryResponse, CanonicalVarValues, QueryResponse,\n };\n+use rustc_infer::infer::outlives::env::OutlivesEnvironment;\n use rustc_infer::infer::{DefineOpaqueTypes, InferCtxt, InferOk};\n use rustc_infer::traits::query::Fallible;\n use rustc_infer::traits::{\n@@ -181,6 +183,23 @@ impl<'a, 'tcx> ObligationCtxt<'a, 'tcx> {\n         self.engine.borrow_mut().select_all_or_error(self.infcx)\n     }\n \n+    /// Resolves regions and reports errors.\n+    ///\n+    /// Takes ownership of the context as doing trait solving afterwards\n+    /// will result in region constraints getting ignored.\n+    pub fn resolve_regions_and_report_errors(\n+        self,\n+        generic_param_scope: LocalDefId,\n+        outlives_env: &OutlivesEnvironment<'tcx>,\n+    ) -> Result<(), ErrorGuaranteed> {\n+        let errors = self.infcx.resolve_regions(&outlives_env);\n+        if errors.is_empty() {\n+            Ok(())\n+        } else {\n+            Err(self.infcx.err_ctxt().report_region_errors(generic_param_scope, &errors))\n+        }\n+    }\n+\n     pub fn assumed_wf_types(\n         &self,\n         param_env: ty::ParamEnv<'tcx>,"}, {"sha": "af567c074384e8fefb4dbb8d267f0a1ad2d117c9", "filename": "compiler/rustc_trait_selection/src/traits/misc.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a19adefa0e5aca0aabca2430530577ee140e4efa/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a19adefa0e5aca0aabca2430530577ee140e4efa/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmisc.rs?ref=a19adefa0e5aca0aabca2430530577ee140e4efa", "patch": "@@ -117,10 +117,6 @@ pub fn type_allowed_to_implement_copy<'tcx>(\n                     FxIndexSet::from_iter([self_type]),\n                 ),\n             );\n-            infcx.process_registered_region_obligations(\n-                outlives_env.region_bound_pairs(),\n-                param_env,\n-            );\n             let errors = infcx.resolve_regions(&outlives_env);\n             if !errors.is_empty() {\n                 infringing.push((field, ty, InfringingFieldsReason::Regions(errors)));"}]}