{"sha": "d81de4871fbaf15198857af06b4f15fd4e1bfb13", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ4MWRlNDg3MWZiYWYxNTE5ODg1N2FmMDZiNGYxNWZkNGUxYmZiMTM=", "commit": {"author": {"name": "Jonathan Turner", "email": "jturner@mozilla.com", "date": "2016-04-22T15:05:58Z"}, "committer": {"name": "Jonathan Turner", "email": "jturner@mozilla.com", "date": "2016-04-22T15:05:58Z"}, "message": "Merge remote-tracking branch 'rust-lang/master' into compiletest-json", "tree": {"sha": "2baad0776ce4fcebfcdaf22dc732ef4218470882", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2baad0776ce4fcebfcdaf22dc732ef4218470882"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d81de4871fbaf15198857af06b4f15fd4e1bfb13", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d81de4871fbaf15198857af06b4f15fd4e1bfb13", "html_url": "https://github.com/rust-lang/rust/commit/d81de4871fbaf15198857af06b4f15fd4e1bfb13", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d81de4871fbaf15198857af06b4f15fd4e1bfb13/comments", "author": null, "committer": null, "parents": [{"sha": "fd0632fad63d5eb83a1571a1f854af98c5557b2a", "url": "https://api.github.com/repos/rust-lang/rust/commits/fd0632fad63d5eb83a1571a1f854af98c5557b2a", "html_url": "https://github.com/rust-lang/rust/commit/fd0632fad63d5eb83a1571a1f854af98c5557b2a"}, {"sha": "a264f5b7e8df34c4bf7f10d0c6c7f9ab805ee672", "url": "https://api.github.com/repos/rust-lang/rust/commits/a264f5b7e8df34c4bf7f10d0c6c7f9ab805ee672", "html_url": "https://github.com/rust-lang/rust/commit/a264f5b7e8df34c4bf7f10d0c6c7f9ab805ee672"}], "stats": {"total": 11475, "additions": 5955, "deletions": 5520}, "files": [{"sha": "69f10d197f74b47ecdde0e50674e5f6d5221c8bc", "filename": "src/libcore/iter.rs", "status": "removed", "additions": 0, "deletions": 5012, "changes": 5012, "blob_url": "https://github.com/rust-lang/rust/blob/fd0632fad63d5eb83a1571a1f854af98c5557b2a/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd0632fad63d5eb83a1571a1f854af98c5557b2a/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=fd0632fad63d5eb83a1571a1f854af98c5557b2a"}, {"sha": "d130a0b873c2b582362f731f3278097de47bf07e", "filename": "src/libcore/iter/iterator.rs", "status": "added", "additions": 2112, "deletions": 0, "changes": 2112, "blob_url": "https://github.com/rust-lang/rust/blob/d81de4871fbaf15198857af06b4f15fd4e1bfb13/src%2Flibcore%2Fiter%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d81de4871fbaf15198857af06b4f15fd4e1bfb13/src%2Flibcore%2Fiter%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fiterator.rs?ref=d81de4871fbaf15198857af06b4f15fd4e1bfb13", "patch": "@@ -0,0 +1,2112 @@\n+// Copyright 2013-2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use clone::Clone;\n+use cmp::{Ord, PartialOrd, PartialEq, Ordering};\n+use default::Default;\n+use marker;\n+use num::{Zero, One};\n+use ops::{Add, FnMut, Mul};\n+use option::Option::{self, Some, None};\n+use marker::Sized;\n+\n+use super::{Chain, Cycle, Cloned, Enumerate, Filter, FilterMap, FlatMap, Fuse,\n+            Inspect, Map, Peekable, Scan, Skip, SkipWhile, Take, TakeWhile, Rev,\n+            Zip};\n+use super::ChainState;\n+use super::{DoubleEndedIterator, ExactSizeIterator, Extend, FromIterator,\n+            IntoIterator};\n+\n+fn _assert_is_object_safe(_: &Iterator<Item=()>) {}\n+\n+/// An interface for dealing with iterators.\n+///\n+/// This is the main iterator trait. For more about the concept of iterators\n+/// generally, please see the [module-level documentation]. In particular, you\n+/// may want to know how to [implement `Iterator`][impl].\n+///\n+/// [module-level documentation]: index.html\n+/// [impl]: index.html#implementing-iterator\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_on_unimplemented = \"`{Self}` is not an iterator; maybe try calling \\\n+                            `.iter()` or a similar method\"]\n+pub trait Iterator {\n+    /// The type of the elements being iterated over.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    type Item;\n+\n+    /// Advances the iterator and returns the next value.\n+    ///\n+    /// Returns `None` when iteration is finished. Individual iterator\n+    /// implementations may choose to resume iteration, and so calling `next()`\n+    /// again may or may not eventually start returning `Some(Item)` again at some\n+    /// point.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let a = [1, 2, 3];\n+    ///\n+    /// let mut iter = a.iter();\n+    ///\n+    /// // A call to next() returns the next value...\n+    /// assert_eq!(Some(&1), iter.next());\n+    /// assert_eq!(Some(&2), iter.next());\n+    /// assert_eq!(Some(&3), iter.next());\n+    ///\n+    /// // ... and then None once it's over.\n+    /// assert_eq!(None, iter.next());\n+    ///\n+    /// // More calls may or may not return None. Here, they always will.\n+    /// assert_eq!(None, iter.next());\n+    /// assert_eq!(None, iter.next());\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn next(&mut self) -> Option<Self::Item>;\n+\n+    /// Returns the bounds on the remaining length of the iterator.\n+    ///\n+    /// Specifically, `size_hint()` returns a tuple where the first element\n+    /// is the lower bound, and the second element is the upper bound.\n+    ///\n+    /// The second half of the tuple that is returned is an `Option<usize>`. A\n+    /// `None` here means that either there is no known upper bound, or the\n+    /// upper bound is larger than `usize`.\n+    ///\n+    /// # Implementation notes\n+    ///\n+    /// It is not enforced that an iterator implementation yields the declared\n+    /// number of elements. A buggy iterator may yield less than the lower bound\n+    /// or more than the upper bound of elements.\n+    ///\n+    /// `size_hint()` is primarily intended to be used for optimizations such as\n+    /// reserving space for the elements of the iterator, but must not be\n+    /// trusted to e.g. omit bounds checks in unsafe code. An incorrect\n+    /// implementation of `size_hint()` should not lead to memory safety\n+    /// violations.\n+    ///\n+    /// That said, the implementation should provide a correct estimation,\n+    /// because otherwise it would be a violation of the trait's protocol.\n+    ///\n+    /// The default implementation returns `(0, None)` which is correct for any\n+    /// iterator.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let a = [1, 2, 3];\n+    /// let iter = a.iter();\n+    ///\n+    /// assert_eq!((3, Some(3)), iter.size_hint());\n+    /// ```\n+    ///\n+    /// A more complex example:\n+    ///\n+    /// ```\n+    /// // The even numbers from zero to ten.\n+    /// let iter = (0..10).filter(|x| x % 2 == 0);\n+    ///\n+    /// // We might iterate from zero to ten times. Knowing that it's five\n+    /// // exactly wouldn't be possible without executing filter().\n+    /// assert_eq!((0, Some(10)), iter.size_hint());\n+    ///\n+    /// // Let's add one five more numbers with chain()\n+    /// let iter = (0..10).filter(|x| x % 2 == 0).chain(15..20);\n+    ///\n+    /// // now both bounds are increased by five\n+    /// assert_eq!((5, Some(15)), iter.size_hint());\n+    /// ```\n+    ///\n+    /// Returning `None` for an upper bound:\n+    ///\n+    /// ```\n+    /// // an infinite iterator has no upper bound\n+    /// let iter = 0..;\n+    ///\n+    /// assert_eq!((0, None), iter.size_hint());\n+    /// ```\n+    #[inline]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn size_hint(&self) -> (usize, Option<usize>) { (0, None) }\n+\n+    /// Consumes the iterator, counting the number of iterations and returning it.\n+    ///\n+    /// This method will evaluate the iterator until its [`next()`] returns\n+    /// `None`. Once `None` is encountered, `count()` returns the number of\n+    /// times it called [`next()`].\n+    ///\n+    /// [`next()`]: #tymethod.next\n+    ///\n+    /// # Overflow Behavior\n+    ///\n+    /// The method does no guarding against overflows, so counting elements of\n+    /// an iterator with more than `usize::MAX` elements either produces the\n+    /// wrong result or panics. If debug assertions are enabled, a panic is\n+    /// guaranteed.\n+    ///\n+    /// # Panics\n+    ///\n+    /// This function might panic if the iterator has more than `usize::MAX`\n+    /// elements.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let a = [1, 2, 3];\n+    /// assert_eq!(a.iter().count(), 3);\n+    ///\n+    /// let a = [1, 2, 3, 4, 5];\n+    /// assert_eq!(a.iter().count(), 5);\n+    /// ```\n+    #[inline]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn count(self) -> usize where Self: Sized {\n+        // Might overflow.\n+        self.fold(0, |cnt, _| cnt + 1)\n+    }\n+\n+    /// Consumes the iterator, returning the last element.\n+    ///\n+    /// This method will evaluate the iterator until it returns `None`. While\n+    /// doing so, it keeps track of the current element. After `None` is\n+    /// returned, `last()` will then return the last element it saw.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let a = [1, 2, 3];\n+    /// assert_eq!(a.iter().last(), Some(&3));\n+    ///\n+    /// let a = [1, 2, 3, 4, 5];\n+    /// assert_eq!(a.iter().last(), Some(&5));\n+    /// ```\n+    #[inline]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn last(self) -> Option<Self::Item> where Self: Sized {\n+        let mut last = None;\n+        for x in self { last = Some(x); }\n+        last\n+    }\n+\n+    /// Consumes the `n` first elements of the iterator, then returns the\n+    /// `next()` one.\n+    ///\n+    /// This method will evaluate the iterator `n` times, discarding those elements.\n+    /// After it does so, it will call [`next()`] and return its value.\n+    ///\n+    /// [`next()`]: #tymethod.next\n+    ///\n+    /// Like most indexing operations, the count starts from zero, so `nth(0)`\n+    /// returns the first value, `nth(1)` the second, and so on.\n+    ///\n+    /// `nth()` will return `None` if `n` is larger than the length of the\n+    /// iterator.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let a = [1, 2, 3];\n+    /// assert_eq!(a.iter().nth(1), Some(&2));\n+    /// ```\n+    ///\n+    /// Calling `nth()` multiple times doesn't rewind the iterator:\n+    ///\n+    /// ```\n+    /// let a = [1, 2, 3];\n+    ///\n+    /// let mut iter = a.iter();\n+    ///\n+    /// assert_eq!(iter.nth(1), Some(&2));\n+    /// assert_eq!(iter.nth(1), None);\n+    /// ```\n+    ///\n+    /// Returning `None` if there are less than `n` elements:\n+    ///\n+    /// ```\n+    /// let a = [1, 2, 3];\n+    /// assert_eq!(a.iter().nth(10), None);\n+    /// ```\n+    #[inline]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn nth(&mut self, mut n: usize) -> Option<Self::Item> where Self: Sized {\n+        for x in self {\n+            if n == 0 { return Some(x) }\n+            n -= 1;\n+        }\n+        None\n+    }\n+\n+    /// Takes two iterators and creates a new iterator over both in sequence.\n+    ///\n+    /// `chain()` will return a new iterator which will first iterate over\n+    /// values from the first iterator and then over values from the second\n+    /// iterator.\n+    ///\n+    /// In other words, it links two iterators together, in a chain. \ud83d\udd17\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let a1 = [1, 2, 3];\n+    /// let a2 = [4, 5, 6];\n+    ///\n+    /// let mut iter = a1.iter().chain(a2.iter());\n+    ///\n+    /// assert_eq!(iter.next(), Some(&1));\n+    /// assert_eq!(iter.next(), Some(&2));\n+    /// assert_eq!(iter.next(), Some(&3));\n+    /// assert_eq!(iter.next(), Some(&4));\n+    /// assert_eq!(iter.next(), Some(&5));\n+    /// assert_eq!(iter.next(), Some(&6));\n+    /// assert_eq!(iter.next(), None);\n+    /// ```\n+    ///\n+    /// Since the argument to `chain()` uses [`IntoIterator`], we can pass\n+    /// anything that can be converted into an [`Iterator`], not just an\n+    /// [`Iterator`] itself. For example, slices (`&[T]`) implement\n+    /// [`IntoIterator`], and so can be passed to `chain()` directly:\n+    ///\n+    /// [`IntoIterator`]: trait.IntoIterator.html\n+    /// [`Iterator`]: trait.Iterator.html\n+    ///\n+    /// ```\n+    /// let s1 = &[1, 2, 3];\n+    /// let s2 = &[4, 5, 6];\n+    ///\n+    /// let mut iter = s1.iter().chain(s2);\n+    ///\n+    /// assert_eq!(iter.next(), Some(&1));\n+    /// assert_eq!(iter.next(), Some(&2));\n+    /// assert_eq!(iter.next(), Some(&3));\n+    /// assert_eq!(iter.next(), Some(&4));\n+    /// assert_eq!(iter.next(), Some(&5));\n+    /// assert_eq!(iter.next(), Some(&6));\n+    /// assert_eq!(iter.next(), None);\n+    /// ```\n+    #[inline]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn chain<U>(self, other: U) -> Chain<Self, U::IntoIter> where\n+        Self: Sized, U: IntoIterator<Item=Self::Item>,\n+    {\n+        Chain{a: self, b: other.into_iter(), state: ChainState::Both}\n+    }\n+\n+    /// 'Zips up' two iterators into a single iterator of pairs.\n+    ///\n+    /// `zip()` returns a new iterator that will iterate over two other\n+    /// iterators, returning a tuple where the first element comes from the\n+    /// first iterator, and the second element comes from the second iterator.\n+    ///\n+    /// In other words, it zips two iterators together, into a single one.\n+    ///\n+    /// When either iterator returns `None`, all further calls to `next()`\n+    /// will return `None`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let a1 = [1, 2, 3];\n+    /// let a2 = [4, 5, 6];\n+    ///\n+    /// let mut iter = a1.iter().zip(a2.iter());\n+    ///\n+    /// assert_eq!(iter.next(), Some((&1, &4)));\n+    /// assert_eq!(iter.next(), Some((&2, &5)));\n+    /// assert_eq!(iter.next(), Some((&3, &6)));\n+    /// assert_eq!(iter.next(), None);\n+    /// ```\n+    ///\n+    /// Since the argument to `zip()` uses [`IntoIterator`], we can pass\n+    /// anything that can be converted into an [`Iterator`], not just an\n+    /// [`Iterator`] itself. For example, slices (`&[T]`) implement\n+    /// [`IntoIterator`], and so can be passed to `zip()` directly:\n+    ///\n+    /// [`IntoIterator`]: trait.IntoIterator.html\n+    /// [`Iterator`]: trait.Iterator.html\n+    ///\n+    /// ```\n+    /// let s1 = &[1, 2, 3];\n+    /// let s2 = &[4, 5, 6];\n+    ///\n+    /// let mut iter = s1.iter().zip(s2);\n+    ///\n+    /// assert_eq!(iter.next(), Some((&1, &4)));\n+    /// assert_eq!(iter.next(), Some((&2, &5)));\n+    /// assert_eq!(iter.next(), Some((&3, &6)));\n+    /// assert_eq!(iter.next(), None);\n+    /// ```\n+    ///\n+    /// `zip()` is often used to zip an infinite iterator to a finite one.\n+    /// This works because the finite iterator will eventually return `None`,\n+    /// ending the zipper. Zipping with `(0..)` can look a lot like [`enumerate()`]:\n+    ///\n+    /// ```\n+    /// let enumerate: Vec<_> = \"foo\".chars().enumerate().collect();\n+    ///\n+    /// let zipper: Vec<_> = (0..).zip(\"foo\".chars()).collect();\n+    ///\n+    /// assert_eq!((0, 'f'), enumerate[0]);\n+    /// assert_eq!((0, 'f'), zipper[0]);\n+    ///\n+    /// assert_eq!((1, 'o'), enumerate[1]);\n+    /// assert_eq!((1, 'o'), zipper[1]);\n+    ///\n+    /// assert_eq!((2, 'o'), enumerate[2]);\n+    /// assert_eq!((2, 'o'), zipper[2]);\n+    /// ```\n+    ///\n+    /// [`enumerate()`]: trait.Iterator.html#method.enumerate\n+    #[inline]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn zip<U>(self, other: U) -> Zip<Self, U::IntoIter> where\n+        Self: Sized, U: IntoIterator\n+    {\n+        Zip{a: self, b: other.into_iter()}\n+    }\n+\n+    /// Takes a closure and creates an iterator which calls that closure on each\n+    /// element.\n+    ///\n+    /// `map()` transforms one iterator into another, by means of its argument:\n+    /// something that implements `FnMut`. It produces a new iterator which\n+    /// calls this closure on each element of the original iterator.\n+    ///\n+    /// If you are good at thinking in types, you can think of `map()` like this:\n+    /// If you have an iterator that gives you elements of some type `A`, and\n+    /// you want an iterator of some other type `B`, you can use `map()`,\n+    /// passing a closure that takes an `A` and returns a `B`.\n+    ///\n+    /// `map()` is conceptually similar to a [`for`] loop. However, as `map()` is\n+    /// lazy, it is best used when you're already working with other iterators.\n+    /// If you're doing some sort of looping for a side effect, it's considered\n+    /// more idiomatic to use [`for`] than `map()`.\n+    ///\n+    /// [`for`]: ../../book/loops.html#for\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let a = [1, 2, 3];\n+    ///\n+    /// let mut iter = a.into_iter().map(|x| 2 * x);\n+    ///\n+    /// assert_eq!(iter.next(), Some(2));\n+    /// assert_eq!(iter.next(), Some(4));\n+    /// assert_eq!(iter.next(), Some(6));\n+    /// assert_eq!(iter.next(), None);\n+    /// ```\n+    ///\n+    /// If you're doing some sort of side effect, prefer [`for`] to `map()`:\n+    ///\n+    /// ```\n+    /// # #![allow(unused_must_use)]\n+    /// // don't do this:\n+    /// (0..5).map(|x| println!(\"{}\", x));\n+    ///\n+    /// // it won't even execute, as it is lazy. Rust will warn you about this.\n+    ///\n+    /// // Instead, use for:\n+    /// for x in 0..5 {\n+    ///     println!(\"{}\", x);\n+    /// }\n+    /// ```\n+    #[inline]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn map<B, F>(self, f: F) -> Map<Self, F> where\n+        Self: Sized, F: FnMut(Self::Item) -> B,\n+    {\n+        Map{iter: self, f: f}\n+    }\n+\n+    /// Creates an iterator which uses a closure to determine if an element\n+    /// should be yielded.\n+    ///\n+    /// The closure must return `true` or `false`. `filter()` creates an\n+    /// iterator which calls this closure on each element. If the closure\n+    /// returns `true`, then the element is returned. If the closure returns\n+    /// `false`, it will try again, and call the closure on the next element,\n+    /// seeing if it passes the test.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let a = [0i32, 1, 2];\n+    ///\n+    /// let mut iter = a.into_iter().filter(|x| x.is_positive());\n+    ///\n+    /// assert_eq!(iter.next(), Some(&1));\n+    /// assert_eq!(iter.next(), Some(&2));\n+    /// assert_eq!(iter.next(), None);\n+    /// ```\n+    ///\n+    /// Because the closure passed to `filter()` takes a reference, and many\n+    /// iterators iterate over references, this leads to a possibly confusing\n+    /// situation, where the type of the closure is a double reference:\n+    ///\n+    /// ```\n+    /// let a = [0, 1, 2];\n+    ///\n+    /// let mut iter = a.into_iter().filter(|x| **x > 1); // need two *s!\n+    ///\n+    /// assert_eq!(iter.next(), Some(&2));\n+    /// assert_eq!(iter.next(), None);\n+    /// ```\n+    ///\n+    /// It's common to instead use destructuring on the argument to strip away\n+    /// one:\n+    ///\n+    /// ```\n+    /// let a = [0, 1, 2];\n+    ///\n+    /// let mut iter = a.into_iter().filter(|&x| *x > 1); // both & and *\n+    ///\n+    /// assert_eq!(iter.next(), Some(&2));\n+    /// assert_eq!(iter.next(), None);\n+    /// ```\n+    ///\n+    /// or both:\n+    ///\n+    /// ```\n+    /// let a = [0, 1, 2];\n+    ///\n+    /// let mut iter = a.into_iter().filter(|&&x| x > 1); // two &s\n+    ///\n+    /// assert_eq!(iter.next(), Some(&2));\n+    /// assert_eq!(iter.next(), None);\n+    /// ```\n+    ///\n+    /// of these layers.\n+    #[inline]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn filter<P>(self, predicate: P) -> Filter<Self, P> where\n+        Self: Sized, P: FnMut(&Self::Item) -> bool,\n+    {\n+        Filter{iter: self, predicate: predicate}\n+    }\n+\n+    /// Creates an iterator that both filters and maps.\n+    ///\n+    /// The closure must return an [`Option<T>`]. `filter_map()` creates an\n+    /// iterator which calls this closure on each element. If the closure\n+    /// returns `Some(element)`, then that element is returned. If the\n+    /// closure returns `None`, it will try again, and call the closure on the\n+    /// next element, seeing if it will return `Some`.\n+    ///\n+    /// [`Option<T>`]: ../../std/option/enum.Option.html\n+    ///\n+    /// Why `filter_map()` and not just [`filter()`].[`map()`]? The key is in this\n+    /// part:\n+    ///\n+    /// [`filter()`]: #method.filter\n+    /// [`map()`]: #method.map\n+    ///\n+    /// > If the closure returns `Some(element)`, then that element is returned.\n+    ///\n+    /// In other words, it removes the [`Option<T>`] layer automatically. If your\n+    /// mapping is already returning an [`Option<T>`] and you want to skip over\n+    /// `None`s, then `filter_map()` is much, much nicer to use.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let a = [\"1\", \"2\", \"lol\"];\n+    ///\n+    /// let mut iter = a.iter().filter_map(|s| s.parse().ok());\n+    ///\n+    /// assert_eq!(iter.next(), Some(1));\n+    /// assert_eq!(iter.next(), Some(2));\n+    /// assert_eq!(iter.next(), None);\n+    /// ```\n+    ///\n+    /// Here's the same example, but with [`filter()`] and [`map()`]:\n+    ///\n+    /// ```\n+    /// let a = [\"1\", \"2\", \"lol\"];\n+    ///\n+    /// let mut iter = a.iter()\n+    ///                 .map(|s| s.parse().ok())\n+    ///                 .filter(|s| s.is_some());\n+    ///\n+    /// assert_eq!(iter.next(), Some(Some(1)));\n+    /// assert_eq!(iter.next(), Some(Some(2)));\n+    /// assert_eq!(iter.next(), None);\n+    /// ```\n+    ///\n+    /// There's an extra layer of `Some` in there.\n+    #[inline]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn filter_map<B, F>(self, f: F) -> FilterMap<Self, F> where\n+        Self: Sized, F: FnMut(Self::Item) -> Option<B>,\n+    {\n+        FilterMap { iter: self, f: f }\n+    }\n+\n+    /// Creates an iterator which gives the current iteration count as well as\n+    /// the next value.\n+    ///\n+    /// The iterator returned yields pairs `(i, val)`, where `i` is the\n+    /// current index of iteration and `val` is the value returned by the\n+    /// iterator.\n+    ///\n+    /// `enumerate()` keeps its count as a [`usize`]. If you want to count by a\n+    /// different sized integer, the [`zip()`] function provides similar\n+    /// functionality.\n+    ///\n+    /// [`usize`]: ../../std/primitive.usize.html\n+    /// [`zip()`]: #method.zip\n+    ///\n+    /// # Overflow Behavior\n+    ///\n+    /// The method does no guarding against overflows, so enumerating more than\n+    /// [`usize::MAX`] elements either produces the wrong result or panics. If\n+    /// debug assertions are enabled, a panic is guaranteed.\n+    ///\n+    /// [`usize::MAX`]: ../../std/usize/constant.MAX.html\n+    ///\n+    /// # Panics\n+    ///\n+    /// The returned iterator might panic if the to-be-returned index would\n+    /// overflow a `usize`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let a = [1, 2, 3];\n+    ///\n+    /// let mut iter = a.iter().enumerate();\n+    ///\n+    /// assert_eq!(iter.next(), Some((0, &1)));\n+    /// assert_eq!(iter.next(), Some((1, &2)));\n+    /// assert_eq!(iter.next(), Some((2, &3)));\n+    /// assert_eq!(iter.next(), None);\n+    /// ```\n+    #[inline]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn enumerate(self) -> Enumerate<Self> where Self: Sized {\n+        Enumerate { iter: self, count: 0 }\n+    }\n+\n+    /// Creates an iterator which can use `peek` to look at the next element of\n+    /// the iterator without consuming it.\n+    ///\n+    /// Adds a [`peek()`] method to an iterator. See its documentation for\n+    /// more information.\n+    ///\n+    /// Note that the underlying iterator is still advanced when `peek` is\n+    /// called for the first time: In order to retrieve the next element,\n+    /// `next` is called on the underlying iterator, hence any side effects of\n+    /// the `next` method will occur.\n+    ///\n+    /// [`peek()`]: struct.Peekable.html#method.peek\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let xs = [1, 2, 3];\n+    ///\n+    /// let mut iter = xs.iter().peekable();\n+    ///\n+    /// // peek() lets us see into the future\n+    /// assert_eq!(iter.peek(), Some(&&1));\n+    /// assert_eq!(iter.next(), Some(&1));\n+    ///\n+    /// assert_eq!(iter.next(), Some(&2));\n+    ///\n+    /// // we can peek() multiple times, the iterator won't advance\n+    /// assert_eq!(iter.peek(), Some(&&3));\n+    /// assert_eq!(iter.peek(), Some(&&3));\n+    ///\n+    /// assert_eq!(iter.next(), Some(&3));\n+    ///\n+    /// // after the iterator is finished, so is peek()\n+    /// assert_eq!(iter.peek(), None);\n+    /// assert_eq!(iter.next(), None);\n+    /// ```\n+    #[inline]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn peekable(self) -> Peekable<Self> where Self: Sized {\n+        Peekable{iter: self, peeked: None}\n+    }\n+\n+    /// Creates an iterator that [`skip()`]s elements based on a predicate.\n+    ///\n+    /// [`skip()`]: #method.skip\n+    ///\n+    /// `skip_while()` takes a closure as an argument. It will call this\n+    /// closure on each element of the iterator, and ignore elements\n+    /// until it returns `false`.\n+    ///\n+    /// After `false` is returned, `skip_while()`'s job is over, and the\n+    /// rest of the elements are yielded.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let a = [-1i32, 0, 1];\n+    ///\n+    /// let mut iter = a.into_iter().skip_while(|x| x.is_negative());\n+    ///\n+    /// assert_eq!(iter.next(), Some(&0));\n+    /// assert_eq!(iter.next(), Some(&1));\n+    /// assert_eq!(iter.next(), None);\n+    /// ```\n+    ///\n+    /// Because the closure passed to `skip_while()` takes a reference, and many\n+    /// iterators iterate over references, this leads to a possibly confusing\n+    /// situation, where the type of the closure is a double reference:\n+    ///\n+    /// ```\n+    /// let a = [-1, 0, 1];\n+    ///\n+    /// let mut iter = a.into_iter().skip_while(|x| **x < 0); // need two *s!\n+    ///\n+    /// assert_eq!(iter.next(), Some(&0));\n+    /// assert_eq!(iter.next(), Some(&1));\n+    /// assert_eq!(iter.next(), None);\n+    /// ```\n+    ///\n+    /// Stopping after an initial `false`:\n+    ///\n+    /// ```\n+    /// let a = [-1, 0, 1, -2];\n+    ///\n+    /// let mut iter = a.into_iter().skip_while(|x| **x < 0);\n+    ///\n+    /// assert_eq!(iter.next(), Some(&0));\n+    /// assert_eq!(iter.next(), Some(&1));\n+    ///\n+    /// // while this would have been false, since we already got a false,\n+    /// // skip_while() isn't used any more\n+    /// assert_eq!(iter.next(), Some(&-2));\n+    ///\n+    /// assert_eq!(iter.next(), None);\n+    /// ```\n+    #[inline]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn skip_while<P>(self, predicate: P) -> SkipWhile<Self, P> where\n+        Self: Sized, P: FnMut(&Self::Item) -> bool,\n+    {\n+        SkipWhile{iter: self, flag: false, predicate: predicate}\n+    }\n+\n+    /// Creates an iterator that yields elements based on a predicate.\n+    ///\n+    /// `take_while()` takes a closure as an argument. It will call this\n+    /// closure on each element of the iterator, and yield elements\n+    /// while it returns `true`.\n+    ///\n+    /// After `false` is returned, `take_while()`'s job is over, and the\n+    /// rest of the elements are ignored.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let a = [-1i32, 0, 1];\n+    ///\n+    /// let mut iter = a.into_iter().take_while(|x| x.is_negative());\n+    ///\n+    /// assert_eq!(iter.next(), Some(&-1));\n+    /// assert_eq!(iter.next(), None);\n+    /// ```\n+    ///\n+    /// Because the closure passed to `take_while()` takes a reference, and many\n+    /// iterators iterate over references, this leads to a possibly confusing\n+    /// situation, where the type of the closure is a double reference:\n+    ///\n+    /// ```\n+    /// let a = [-1, 0, 1];\n+    ///\n+    /// let mut iter = a.into_iter().take_while(|x| **x < 0); // need two *s!\n+    ///\n+    /// assert_eq!(iter.next(), Some(&-1));\n+    /// assert_eq!(iter.next(), None);\n+    /// ```\n+    ///\n+    /// Stopping after an initial `false`:\n+    ///\n+    /// ```\n+    /// let a = [-1, 0, 1, -2];\n+    ///\n+    /// let mut iter = a.into_iter().take_while(|x| **x < 0);\n+    ///\n+    /// assert_eq!(iter.next(), Some(&-1));\n+    ///\n+    /// // We have more elements that are less than zero, but since we already\n+    /// // got a false, take_while() isn't used any more\n+    /// assert_eq!(iter.next(), None);\n+    /// ```\n+    ///\n+    /// Because `take_while()` needs to look at the value in order to see if it\n+    /// should be included or not, consuming iterators will see that it is\n+    /// removed:\n+    ///\n+    /// ```\n+    /// let a = [1, 2, 3, 4];\n+    /// let mut iter = a.into_iter();\n+    ///\n+    /// let result: Vec<i32> = iter.by_ref()\n+    ///                            .take_while(|n| **n != 3)\n+    ///                            .cloned()\n+    ///                            .collect();\n+    ///\n+    /// assert_eq!(result, &[1, 2]);\n+    ///\n+    /// let result: Vec<i32> = iter.cloned().collect();\n+    ///\n+    /// assert_eq!(result, &[4]);\n+    /// ```\n+    ///\n+    /// The `3` is no longer there, because it was consumed in order to see if\n+    /// the iteration should stop, but wasn't placed back into the iterator or\n+    /// some similar thing.\n+    #[inline]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn take_while<P>(self, predicate: P) -> TakeWhile<Self, P> where\n+        Self: Sized, P: FnMut(&Self::Item) -> bool,\n+    {\n+        TakeWhile{iter: self, flag: false, predicate: predicate}\n+    }\n+\n+    /// Creates an iterator that skips the first `n` elements.\n+    ///\n+    /// After they have been consumed, the rest of the elements are yielded.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let a = [1, 2, 3];\n+    ///\n+    /// let mut iter = a.iter().skip(2);\n+    ///\n+    /// assert_eq!(iter.next(), Some(&3));\n+    /// assert_eq!(iter.next(), None);\n+    /// ```\n+    #[inline]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn skip(self, n: usize) -> Skip<Self> where Self: Sized {\n+        Skip{iter: self, n: n}\n+    }\n+\n+    /// Creates an iterator that yields its first `n` elements.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let a = [1, 2, 3];\n+    ///\n+    /// let mut iter = a.iter().take(2);\n+    ///\n+    /// assert_eq!(iter.next(), Some(&1));\n+    /// assert_eq!(iter.next(), Some(&2));\n+    /// assert_eq!(iter.next(), None);\n+    /// ```\n+    ///\n+    /// `take()` is often used with an infinite iterator, to make it finite:\n+    ///\n+    /// ```\n+    /// let mut iter = (0..).take(3);\n+    ///\n+    /// assert_eq!(iter.next(), Some(0));\n+    /// assert_eq!(iter.next(), Some(1));\n+    /// assert_eq!(iter.next(), Some(2));\n+    /// assert_eq!(iter.next(), None);\n+    /// ```\n+    #[inline]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn take(self, n: usize) -> Take<Self> where Self: Sized, {\n+        Take{iter: self, n: n}\n+    }\n+\n+    /// An iterator adaptor similar to [`fold()`] that holds internal state and\n+    /// produces a new iterator.\n+    ///\n+    /// [`fold()`]: #method.fold\n+    ///\n+    /// `scan()` takes two arguments: an initial value which seeds the internal\n+    /// state, and a closure with two arguments, the first being a mutable\n+    /// reference to the internal state and the second an iterator element.\n+    /// The closure can assign to the internal state to share state between\n+    /// iterations.\n+    ///\n+    /// On iteration, the closure will be applied to each element of the\n+    /// iterator and the return value from the closure, an [`Option`], is\n+    /// yielded by the iterator.\n+    ///\n+    /// [`Option`]: ../../std/option/enum.Option.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let a = [1, 2, 3];\n+    ///\n+    /// let mut iter = a.iter().scan(1, |state, &x| {\n+    ///     // each iteration, we'll multiply the state by the element\n+    ///     *state = *state * x;\n+    ///\n+    ///     // the value passed on to the next iteration\n+    ///     Some(*state)\n+    /// });\n+    ///\n+    /// assert_eq!(iter.next(), Some(1));\n+    /// assert_eq!(iter.next(), Some(2));\n+    /// assert_eq!(iter.next(), Some(6));\n+    /// assert_eq!(iter.next(), None);\n+    /// ```\n+    #[inline]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn scan<St, B, F>(self, initial_state: St, f: F) -> Scan<Self, St, F>\n+        where Self: Sized, F: FnMut(&mut St, Self::Item) -> Option<B>,\n+    {\n+        Scan{iter: self, f: f, state: initial_state}\n+    }\n+\n+    /// Creates an iterator that works like map, but flattens nested structure.\n+    ///\n+    /// The [`map()`] adapter is very useful, but only when the closure\n+    /// argument produces values. If it produces an iterator instead, there's\n+    /// an extra layer of indirection. `flat_map()` will remove this extra layer\n+    /// on its own.\n+    ///\n+    /// [`map()`]: #method.map\n+    ///\n+    /// Another way of thinking about `flat_map()`: [`map()`]'s closure returns\n+    /// one item for each element, and `flat_map()`'s closure returns an\n+    /// iterator for each element.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let words = [\"alpha\", \"beta\", \"gamma\"];\n+    ///\n+    /// // chars() returns an iterator\n+    /// let merged: String = words.iter()\n+    ///                           .flat_map(|s| s.chars())\n+    ///                           .collect();\n+    /// assert_eq!(merged, \"alphabetagamma\");\n+    /// ```\n+    #[inline]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn flat_map<U, F>(self, f: F) -> FlatMap<Self, U, F>\n+        where Self: Sized, U: IntoIterator, F: FnMut(Self::Item) -> U,\n+    {\n+        FlatMap{iter: self, f: f, frontiter: None, backiter: None }\n+    }\n+\n+    /// Creates an iterator which ends after the first `None`.\n+    ///\n+    /// After an iterator returns `None`, future calls may or may not yield\n+    /// `Some(T)` again. `fuse()` adapts an iterator, ensuring that after a\n+    /// `None` is given, it will always return `None` forever.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// // an iterator which alternates between Some and None\n+    /// struct Alternate {\n+    ///     state: i32,\n+    /// }\n+    ///\n+    /// impl Iterator for Alternate {\n+    ///     type Item = i32;\n+    ///\n+    ///     fn next(&mut self) -> Option<i32> {\n+    ///         let val = self.state;\n+    ///         self.state = self.state + 1;\n+    ///\n+    ///         // if it's even, Some(i32), else None\n+    ///         if val % 2 == 0 {\n+    ///             Some(val)\n+    ///         } else {\n+    ///             None\n+    ///         }\n+    ///     }\n+    /// }\n+    ///\n+    /// let mut iter = Alternate { state: 0 };\n+    ///\n+    /// // we can see our iterator going back and forth\n+    /// assert_eq!(iter.next(), Some(0));\n+    /// assert_eq!(iter.next(), None);\n+    /// assert_eq!(iter.next(), Some(2));\n+    /// assert_eq!(iter.next(), None);\n+    ///\n+    /// // however, once we fuse it...\n+    /// let mut iter = iter.fuse();\n+    ///\n+    /// assert_eq!(iter.next(), Some(4));\n+    /// assert_eq!(iter.next(), None);\n+    ///\n+    /// // it will always return None after the first time.\n+    /// assert_eq!(iter.next(), None);\n+    /// assert_eq!(iter.next(), None);\n+    /// assert_eq!(iter.next(), None);\n+    /// ```\n+    #[inline]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn fuse(self) -> Fuse<Self> where Self: Sized {\n+        Fuse{iter: self, done: false}\n+    }\n+\n+    /// Do something with each element of an iterator, passing the value on.\n+    ///\n+    /// When using iterators, you'll often chain several of them together.\n+    /// While working on such code, you might want to check out what's\n+    /// happening at various parts in the pipeline. To do that, insert\n+    /// a call to `inspect()`.\n+    ///\n+    /// It's much more common for `inspect()` to be used as a debugging tool\n+    /// than to exist in your final code, but never say never.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let a = [1, 4, 2, 3];\n+    ///\n+    /// // this iterator sequence is complex.\n+    /// let sum = a.iter()\n+    ///             .cloned()\n+    ///             .filter(|&x| x % 2 == 0)\n+    ///             .fold(0, |sum, i| sum + i);\n+    ///\n+    /// println!(\"{}\", sum);\n+    ///\n+    /// // let's add some inspect() calls to investigate what's happening\n+    /// let sum = a.iter()\n+    ///             .cloned()\n+    ///             .inspect(|x| println!(\"about to filter: {}\", x))\n+    ///             .filter(|&x| x % 2 == 0)\n+    ///             .inspect(|x| println!(\"made it through filter: {}\", x))\n+    ///             .fold(0, |sum, i| sum + i);\n+    ///\n+    /// println!(\"{}\", sum);\n+    /// ```\n+    ///\n+    /// This will print:\n+    ///\n+    /// ```text\n+    /// about to filter: 1\n+    /// about to filter: 4\n+    /// made it through filter: 4\n+    /// about to filter: 2\n+    /// made it through filter: 2\n+    /// about to filter: 3\n+    /// 6\n+    /// ```\n+    #[inline]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn inspect<F>(self, f: F) -> Inspect<Self, F> where\n+        Self: Sized, F: FnMut(&Self::Item),\n+    {\n+        Inspect{iter: self, f: f}\n+    }\n+\n+    /// Borrows an iterator, rather than consuming it.\n+    ///\n+    /// This is useful to allow applying iterator adaptors while still\n+    /// retaining ownership of the original iterator.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let a = [1, 2, 3];\n+    ///\n+    /// let iter = a.into_iter();\n+    ///\n+    /// let sum: i32 = iter.take(5)\n+    ///                    .fold(0, |acc, &i| acc + i );\n+    ///\n+    /// assert_eq!(sum, 6);\n+    ///\n+    /// // if we try to use iter again, it won't work. The following line\n+    /// // gives \"error: use of moved value: `iter`\n+    /// // assert_eq!(iter.next(), None);\n+    ///\n+    /// // let's try that again\n+    /// let a = [1, 2, 3];\n+    ///\n+    /// let mut iter = a.into_iter();\n+    ///\n+    /// // instead, we add in a .by_ref()\n+    /// let sum: i32 = iter.by_ref()\n+    ///                    .take(2)\n+    ///                    .fold(0, |acc, &i| acc + i );\n+    ///\n+    /// assert_eq!(sum, 3);\n+    ///\n+    /// // now this is just fine:\n+    /// assert_eq!(iter.next(), Some(&3));\n+    /// assert_eq!(iter.next(), None);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn by_ref(&mut self) -> &mut Self where Self: Sized { self }\n+\n+    /// Transforms an iterator into a collection.\n+    ///\n+    /// `collect()` can take anything iterable, and turn it into a relevant\n+    /// collection. This is one of the more powerful methods in the standard\n+    /// library, used in a variety of contexts.\n+    ///\n+    /// The most basic pattern in which `collect()` is used is to turn one\n+    /// collection into another. You take a collection, call `iter()` on it,\n+    /// do a bunch of transformations, and then `collect()` at the end.\n+    ///\n+    /// One of the keys to `collect()`'s power is that many things you might\n+    /// not think of as 'collections' actually are. For example, a [`String`]\n+    /// is a collection of [`char`]s. And a collection of [`Result<T, E>`] can\n+    /// be thought of as single `Result<Collection<T>, E>`. See the examples\n+    /// below for more.\n+    ///\n+    /// [`String`]: ../../std/string/struct.String.html\n+    /// [`Result<T, E>`]: ../../std/result/enum.Result.html\n+    /// [`char`]: ../../std/primitive.char.html\n+    ///\n+    /// Because `collect()` is so general, it can cause problems with type\n+    /// inference. As such, `collect()` is one of the few times you'll see\n+    /// the syntax affectionately known as the 'turbofish': `::<>`. This\n+    /// helps the inference algorithm understand specifically which collection\n+    /// you're trying to collect into.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let a = [1, 2, 3];\n+    ///\n+    /// let doubled: Vec<i32> = a.iter()\n+    ///                          .map(|&x| x * 2)\n+    ///                          .collect();\n+    ///\n+    /// assert_eq!(vec![2, 4, 6], doubled);\n+    /// ```\n+    ///\n+    /// Note that we needed the `: Vec<i32>` on the left-hand side. This is because\n+    /// we could collect into, for example, a [`VecDeque<T>`] instead:\n+    ///\n+    /// [`VecDeque<T>`]: ../../std/collections/struct.VecDeque.html\n+    ///\n+    /// ```\n+    /// use std::collections::VecDeque;\n+    ///\n+    /// let a = [1, 2, 3];\n+    ///\n+    /// let doubled: VecDeque<i32> = a.iter()\n+    ///                               .map(|&x| x * 2)\n+    ///                               .collect();\n+    ///\n+    /// assert_eq!(2, doubled[0]);\n+    /// assert_eq!(4, doubled[1]);\n+    /// assert_eq!(6, doubled[2]);\n+    /// ```\n+    ///\n+    /// Using the 'turbofish' instead of annotating `doubled`:\n+    ///\n+    /// ```\n+    /// let a = [1, 2, 3];\n+    ///\n+    /// let doubled = a.iter()\n+    ///                .map(|&x| x * 2)\n+    ///                .collect::<Vec<i32>>();\n+    ///\n+    /// assert_eq!(vec![2, 4, 6], doubled);\n+    /// ```\n+    ///\n+    /// Because `collect()` cares about what you're collecting into, you can\n+    /// still use a partial type hint, `_`, with the turbofish:\n+    ///\n+    /// ```\n+    /// let a = [1, 2, 3];\n+    ///\n+    /// let doubled = a.iter()\n+    ///                .map(|&x| x * 2)\n+    ///                .collect::<Vec<_>>();\n+    ///\n+    /// assert_eq!(vec![2, 4, 6], doubled);\n+    /// ```\n+    ///\n+    /// Using `collect()` to make a [`String`]:\n+    ///\n+    /// ```\n+    /// let chars = ['g', 'd', 'k', 'k', 'n'];\n+    ///\n+    /// let hello: String = chars.iter()\n+    ///                          .map(|&x| x as u8)\n+    ///                          .map(|x| (x + 1) as char)\n+    ///                          .collect();\n+    ///\n+    /// assert_eq!(\"hello\", hello);\n+    /// ```\n+    ///\n+    /// If you have a list of [`Result<T, E>`]s, you can use `collect()` to\n+    /// see if any of them failed:\n+    ///\n+    /// ```\n+    /// let results = [Ok(1), Err(\"nope\"), Ok(3), Err(\"bad\")];\n+    ///\n+    /// let result: Result<Vec<_>, &str> = results.iter().cloned().collect();\n+    ///\n+    /// // gives us the first error\n+    /// assert_eq!(Err(\"nope\"), result);\n+    ///\n+    /// let results = [Ok(1), Ok(3)];\n+    ///\n+    /// let result: Result<Vec<_>, &str> = results.iter().cloned().collect();\n+    ///\n+    /// // gives us the list of answers\n+    /// assert_eq!(Ok(vec![1, 3]), result);\n+    /// ```\n+    #[inline]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn collect<B: FromIterator<Self::Item>>(self) -> B where Self: Sized {\n+        FromIterator::from_iter(self)\n+    }\n+\n+    /// Consumes an iterator, creating two collections from it.\n+    ///\n+    /// The predicate passed to `partition()` can return `true`, or `false`.\n+    /// `partition()` returns a pair, all of the elements for which it returned\n+    /// `true`, and all of the elements for which it returned `false`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let a = [1, 2, 3];\n+    ///\n+    /// let (even, odd): (Vec<i32>, Vec<i32>) = a.into_iter()\n+    ///                                          .partition(|&n| n % 2 == 0);\n+    ///\n+    /// assert_eq!(even, vec![2]);\n+    /// assert_eq!(odd, vec![1, 3]);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn partition<B, F>(self, mut f: F) -> (B, B) where\n+        Self: Sized,\n+        B: Default + Extend<Self::Item>,\n+        F: FnMut(&Self::Item) -> bool\n+    {\n+        let mut left: B = Default::default();\n+        let mut right: B = Default::default();\n+\n+        for x in self {\n+            if f(&x) {\n+                left.extend(Some(x))\n+            } else {\n+                right.extend(Some(x))\n+            }\n+        }\n+\n+        (left, right)\n+    }\n+\n+    /// An iterator adaptor that applies a function, producing a single, final value.\n+    ///\n+    /// `fold()` takes two arguments: an initial value, and a closure with two\n+    /// arguments: an 'accumulator', and an element. The closure returns the value that\n+    /// the accumulator should have for the next iteration.\n+    ///\n+    /// The initial value is the value the accumulator will have on the first\n+    /// call.\n+    ///\n+    /// After applying this closure to every element of the iterator, `fold()`\n+    /// returns the accumulator.\n+    ///\n+    /// This operation is sometimes called 'reduce' or 'inject'.\n+    ///\n+    /// Folding is useful whenever you have a collection of something, and want\n+    /// to produce a single value from it.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let a = [1, 2, 3];\n+    ///\n+    /// // the sum of all of the elements of a\n+    /// let sum = a.iter()\n+    ///            .fold(0, |acc, &x| acc + x);\n+    ///\n+    /// assert_eq!(sum, 6);\n+    /// ```\n+    ///\n+    /// Let's walk through each step of the iteration here:\n+    ///\n+    /// | element | acc | x | result |\n+    /// |---------|-----|---|--------|\n+    /// |         | 0   |   |        |\n+    /// | 1       | 0   | 1 | 1      |\n+    /// | 2       | 1   | 2 | 3      |\n+    /// | 3       | 3   | 3 | 6      |\n+    ///\n+    /// And so, our final result, `6`.\n+    ///\n+    /// It's common for people who haven't used iterators a lot to\n+    /// use a `for` loop with a list of things to build up a result. Those\n+    /// can be turned into `fold()`s:\n+    ///\n+    /// ```\n+    /// let numbers = [1, 2, 3, 4, 5];\n+    ///\n+    /// let mut result = 0;\n+    ///\n+    /// // for loop:\n+    /// for i in &numbers {\n+    ///     result = result + i;\n+    /// }\n+    ///\n+    /// // fold:\n+    /// let result2 = numbers.iter().fold(0, |acc, &x| acc + x);\n+    ///\n+    /// // they're the same\n+    /// assert_eq!(result, result2);\n+    /// ```\n+    #[inline]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn fold<B, F>(self, init: B, mut f: F) -> B where\n+        Self: Sized, F: FnMut(B, Self::Item) -> B,\n+    {\n+        let mut accum = init;\n+        for x in self {\n+            accum = f(accum, x);\n+        }\n+        accum\n+    }\n+\n+    /// Tests if every element of the iterator matches a predicate.\n+    ///\n+    /// `all()` takes a closure that returns `true` or `false`. It applies\n+    /// this closure to each element of the iterator, and if they all return\n+    /// `true`, then so does `all()`. If any of them return `false`, it\n+    /// returns `false`.\n+    ///\n+    /// `all()` is short-circuiting; in other words, it will stop processing\n+    /// as soon as it finds a `false`, given that no matter what else happens,\n+    /// the result will also be `false`.\n+    ///\n+    /// An empty iterator returns `true`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let a = [1, 2, 3];\n+    ///\n+    /// assert!(a.iter().all(|&x| x > 0));\n+    ///\n+    /// assert!(!a.iter().all(|&x| x > 2));\n+    /// ```\n+    ///\n+    /// Stopping at the first `false`:\n+    ///\n+    /// ```\n+    /// let a = [1, 2, 3];\n+    ///\n+    /// let mut iter = a.iter();\n+    ///\n+    /// assert!(!iter.all(|&x| x != 2));\n+    ///\n+    /// // we can still use `iter`, as there are more elements.\n+    /// assert_eq!(iter.next(), Some(&3));\n+    /// ```\n+    #[inline]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn all<F>(&mut self, mut f: F) -> bool where\n+        Self: Sized, F: FnMut(Self::Item) -> bool\n+    {\n+        for x in self {\n+            if !f(x) {\n+                return false;\n+            }\n+        }\n+        true\n+    }\n+\n+    /// Tests if any element of the iterator matches a predicate.\n+    ///\n+    /// `any()` takes a closure that returns `true` or `false`. It applies\n+    /// this closure to each element of the iterator, and if any of them return\n+    /// `true`, then so does `any()`. If they all return `false`, it\n+    /// returns `false`.\n+    ///\n+    /// `any()` is short-circuiting; in other words, it will stop processing\n+    /// as soon as it finds a `true`, given that no matter what else happens,\n+    /// the result will also be `true`.\n+    ///\n+    /// An empty iterator returns `false`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let a = [1, 2, 3];\n+    ///\n+    /// assert!(a.iter().any(|&x| x > 0));\n+    ///\n+    /// assert!(!a.iter().any(|&x| x > 5));\n+    /// ```\n+    ///\n+    /// Stopping at the first `true`:\n+    ///\n+    /// ```\n+    /// let a = [1, 2, 3];\n+    ///\n+    /// let mut iter = a.iter();\n+    ///\n+    /// assert!(iter.any(|&x| x != 2));\n+    ///\n+    /// // we can still use `iter`, as there are more elements.\n+    /// assert_eq!(iter.next(), Some(&2));\n+    /// ```\n+    #[inline]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn any<F>(&mut self, mut f: F) -> bool where\n+        Self: Sized,\n+        F: FnMut(Self::Item) -> bool\n+    {\n+        for x in self {\n+            if f(x) {\n+                return true;\n+            }\n+        }\n+        false\n+    }\n+\n+    /// Searches for an element of an iterator that satisfies a predicate.\n+    ///\n+    /// `find()` takes a closure that returns `true` or `false`. It applies\n+    /// this closure to each element of the iterator, and if any of them return\n+    /// `true`, then `find()` returns `Some(element)`. If they all return\n+    /// `false`, it returns `None`.\n+    ///\n+    /// `find()` is short-circuiting; in other words, it will stop processing\n+    /// as soon as the closure returns `true`.\n+    ///\n+    /// Because `find()` takes a reference, and many iterators iterate over\n+    /// references, this leads to a possibly confusing situation where the\n+    /// argument is a double reference. You can see this effect in the\n+    /// examples below, with `&&x`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let a = [1, 2, 3];\n+    ///\n+    /// assert_eq!(a.iter().find(|&&x| x == 2), Some(&2));\n+    ///\n+    /// assert_eq!(a.iter().find(|&&x| x == 5), None);\n+    /// ```\n+    ///\n+    /// Stopping at the first `true`:\n+    ///\n+    /// ```\n+    /// let a = [1, 2, 3];\n+    ///\n+    /// let mut iter = a.iter();\n+    ///\n+    /// assert_eq!(iter.find(|&&x| x == 2), Some(&2));\n+    ///\n+    /// // we can still use `iter`, as there are more elements.\n+    /// assert_eq!(iter.next(), Some(&3));\n+    /// ```\n+    #[inline]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn find<P>(&mut self, mut predicate: P) -> Option<Self::Item> where\n+        Self: Sized,\n+        P: FnMut(&Self::Item) -> bool,\n+    {\n+        for x in self {\n+            if predicate(&x) { return Some(x) }\n+        }\n+        None\n+    }\n+\n+    /// Searches for an element in an iterator, returning its index.\n+    ///\n+    /// `position()` takes a closure that returns `true` or `false`. It applies\n+    /// this closure to each element of the iterator, and if one of them\n+    /// returns `true`, then `position()` returns `Some(index)`. If all of\n+    /// them return `false`, it returns `None`.\n+    ///\n+    /// `position()` is short-circuiting; in other words, it will stop\n+    /// processing as soon as it finds a `true`.\n+    ///\n+    /// # Overflow Behavior\n+    ///\n+    /// The method does no guarding against overflows, so if there are more\n+    /// than `usize::MAX` non-matching elements, it either produces the wrong\n+    /// result or panics. If debug assertions are enabled, a panic is\n+    /// guaranteed.\n+    ///\n+    /// # Panics\n+    ///\n+    /// This function might panic if the iterator has more than `usize::MAX`\n+    /// non-matching elements.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let a = [1, 2, 3];\n+    ///\n+    /// assert_eq!(a.iter().position(|&x| x == 2), Some(1));\n+    ///\n+    /// assert_eq!(a.iter().position(|&x| x == 5), None);\n+    /// ```\n+    ///\n+    /// Stopping at the first `true`:\n+    ///\n+    /// ```\n+    /// let a = [1, 2, 3];\n+    ///\n+    /// let mut iter = a.iter();\n+    ///\n+    /// assert_eq!(iter.position(|&x| x == 2), Some(1));\n+    ///\n+    /// // we can still use `iter`, as there are more elements.\n+    /// assert_eq!(iter.next(), Some(&3));\n+    /// ```\n+    #[inline]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn position<P>(&mut self, mut predicate: P) -> Option<usize> where\n+        Self: Sized,\n+        P: FnMut(Self::Item) -> bool,\n+    {\n+        // `enumerate` might overflow.\n+        for (i, x) in self.enumerate() {\n+            if predicate(x) {\n+                return Some(i);\n+            }\n+        }\n+        None\n+    }\n+\n+    /// Searches for an element in an iterator from the right, returning its\n+    /// index.\n+    ///\n+    /// `rposition()` takes a closure that returns `true` or `false`. It applies\n+    /// this closure to each element of the iterator, starting from the end,\n+    /// and if one of them returns `true`, then `rposition()` returns\n+    /// `Some(index)`. If all of them return `false`, it returns `None`.\n+    ///\n+    /// `rposition()` is short-circuiting; in other words, it will stop\n+    /// processing as soon as it finds a `true`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let a = [1, 2, 3];\n+    ///\n+    /// assert_eq!(a.iter().rposition(|&x| x == 3), Some(2));\n+    ///\n+    /// assert_eq!(a.iter().rposition(|&x| x == 5), None);\n+    /// ```\n+    ///\n+    /// Stopping at the first `true`:\n+    ///\n+    /// ```\n+    /// let a = [1, 2, 3];\n+    ///\n+    /// let mut iter = a.iter();\n+    ///\n+    /// assert_eq!(iter.rposition(|&x| x == 2), Some(1));\n+    ///\n+    /// // we can still use `iter`, as there are more elements.\n+    /// assert_eq!(iter.next(), Some(&1));\n+    /// ```\n+    #[inline]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn rposition<P>(&mut self, mut predicate: P) -> Option<usize> where\n+        P: FnMut(Self::Item) -> bool,\n+        Self: Sized + ExactSizeIterator + DoubleEndedIterator\n+    {\n+        let mut i = self.len();\n+\n+        while let Some(v) = self.next_back() {\n+            if predicate(v) {\n+                return Some(i - 1);\n+            }\n+            // No need for an overflow check here, because `ExactSizeIterator`\n+            // implies that the number of elements fits into a `usize`.\n+            i -= 1;\n+        }\n+        None\n+    }\n+\n+    /// Returns the maximum element of an iterator.\n+    ///\n+    /// If the two elements are equally maximum, the latest element is\n+    /// returned.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let a = [1, 2, 3];\n+    ///\n+    /// assert_eq!(a.iter().max(), Some(&3));\n+    /// ```\n+    #[inline]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn max(self) -> Option<Self::Item> where Self: Sized, Self::Item: Ord\n+    {\n+        select_fold1(self,\n+                     |_| (),\n+                     // switch to y even if it is only equal, to preserve\n+                     // stability.\n+                     |_, x, _, y| *x <= *y)\n+            .map(|(_, x)| x)\n+    }\n+\n+    /// Returns the minimum element of an iterator.\n+    ///\n+    /// If the two elements are equally minimum, the first element is\n+    /// returned.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let a = [1, 2, 3];\n+    ///\n+    /// assert_eq!(a.iter().min(), Some(&1));\n+    /// ```\n+    #[inline]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn min(self) -> Option<Self::Item> where Self: Sized, Self::Item: Ord\n+    {\n+        select_fold1(self,\n+                     |_| (),\n+                     // only switch to y if it is strictly smaller, to\n+                     // preserve stability.\n+                     |_, x, _, y| *x > *y)\n+            .map(|(_, x)| x)\n+    }\n+\n+    /// Returns the element that gives the maximum value from the\n+    /// specified function.\n+    ///\n+    /// Returns the rightmost element if the comparison determines two elements\n+    /// to be equally maximum.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let a = [-3_i32, 0, 1, 5, -10];\n+    /// assert_eq!(*a.iter().max_by_key(|x| x.abs()).unwrap(), -10);\n+    /// ```\n+    #[inline]\n+    #[stable(feature = \"iter_cmp_by_key\", since = \"1.6.0\")]\n+    fn max_by_key<B: Ord, F>(self, f: F) -> Option<Self::Item>\n+        where Self: Sized, F: FnMut(&Self::Item) -> B,\n+    {\n+        select_fold1(self,\n+                     f,\n+                     // switch to y even if it is only equal, to preserve\n+                     // stability.\n+                     |x_p, _, y_p, _| x_p <= y_p)\n+            .map(|(_, x)| x)\n+    }\n+\n+    /// Returns the element that gives the minimum value from the\n+    /// specified function.\n+    ///\n+    /// Returns the latest element if the comparison determines two elements\n+    /// to be equally minimum.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let a = [-3_i32, 0, 1, 5, -10];\n+    /// assert_eq!(*a.iter().min_by_key(|x| x.abs()).unwrap(), 0);\n+    /// ```\n+    #[stable(feature = \"iter_cmp_by_key\", since = \"1.6.0\")]\n+    fn min_by_key<B: Ord, F>(self, f: F) -> Option<Self::Item>\n+        where Self: Sized, F: FnMut(&Self::Item) -> B,\n+    {\n+        select_fold1(self,\n+                     f,\n+                     // only switch to y if it is strictly smaller, to\n+                     // preserve stability.\n+                     |x_p, _, y_p, _| x_p > y_p)\n+            .map(|(_, x)| x)\n+    }\n+\n+    /// Reverses an iterator's direction.\n+    ///\n+    /// Usually, iterators iterate from left to right. After using `rev()`,\n+    /// an iterator will instead iterate from right to left.\n+    ///\n+    /// This is only possible if the iterator has an end, so `rev()` only\n+    /// works on [`DoubleEndedIterator`]s.\n+    ///\n+    /// [`DoubleEndedIterator`]: trait.DoubleEndedIterator.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let a = [1, 2, 3];\n+    ///\n+    /// let mut iter = a.iter().rev();\n+    ///\n+    /// assert_eq!(iter.next(), Some(&3));\n+    /// assert_eq!(iter.next(), Some(&2));\n+    /// assert_eq!(iter.next(), Some(&1));\n+    ///\n+    /// assert_eq!(iter.next(), None);\n+    /// ```\n+    #[inline]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn rev(self) -> Rev<Self> where Self: Sized + DoubleEndedIterator {\n+        Rev{iter: self}\n+    }\n+\n+    /// Converts an iterator of pairs into a pair of containers.\n+    ///\n+    /// `unzip()` consumes an entire iterator of pairs, producing two\n+    /// collections: one from the left elements of the pairs, and one\n+    /// from the right elements.\n+    ///\n+    /// This function is, in some sense, the opposite of [`zip()`].\n+    ///\n+    /// [`zip()`]: #method.zip\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let a = [(1, 2), (3, 4)];\n+    ///\n+    /// let (left, right): (Vec<_>, Vec<_>) = a.iter().cloned().unzip();\n+    ///\n+    /// assert_eq!(left, [1, 3]);\n+    /// assert_eq!(right, [2, 4]);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn unzip<A, B, FromA, FromB>(self) -> (FromA, FromB) where\n+        FromA: Default + Extend<A>,\n+        FromB: Default + Extend<B>,\n+        Self: Sized + Iterator<Item=(A, B)>,\n+    {\n+        struct SizeHint<A>(usize, Option<usize>, marker::PhantomData<A>);\n+        impl<A> Iterator for SizeHint<A> {\n+            type Item = A;\n+\n+            fn next(&mut self) -> Option<A> { None }\n+            fn size_hint(&self) -> (usize, Option<usize>) {\n+                (self.0, self.1)\n+            }\n+        }\n+\n+        let (lo, hi) = self.size_hint();\n+        let mut ts: FromA = Default::default();\n+        let mut us: FromB = Default::default();\n+\n+        ts.extend(SizeHint(lo, hi, marker::PhantomData));\n+        us.extend(SizeHint(lo, hi, marker::PhantomData));\n+\n+        for (t, u) in self {\n+            ts.extend(Some(t));\n+            us.extend(Some(u));\n+        }\n+\n+        (ts, us)\n+    }\n+\n+    /// Creates an iterator which `clone()`s all of its elements.\n+    ///\n+    /// This is useful when you have an iterator over `&T`, but you need an\n+    /// iterator over `T`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let a = [1, 2, 3];\n+    ///\n+    /// let v_cloned: Vec<_> = a.iter().cloned().collect();\n+    ///\n+    /// // cloned is the same as .map(|&x| x), for integers\n+    /// let v_map: Vec<_> = a.iter().map(|&x| x).collect();\n+    ///\n+    /// assert_eq!(v_cloned, vec![1, 2, 3]);\n+    /// assert_eq!(v_map, vec![1, 2, 3]);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn cloned<'a, T: 'a>(self) -> Cloned<Self>\n+        where Self: Sized + Iterator<Item=&'a T>, T: Clone\n+    {\n+        Cloned { it: self }\n+    }\n+\n+    /// Repeats an iterator endlessly.\n+    ///\n+    /// Instead of stopping at `None`, the iterator will instead start again,\n+    /// from the beginning. After iterating again, it will start at the\n+    /// beginning again. And again. And again. Forever.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let a = [1, 2, 3];\n+    ///\n+    /// let mut it = a.iter().cycle();\n+    ///\n+    /// assert_eq!(it.next(), Some(&1));\n+    /// assert_eq!(it.next(), Some(&2));\n+    /// assert_eq!(it.next(), Some(&3));\n+    /// assert_eq!(it.next(), Some(&1));\n+    /// assert_eq!(it.next(), Some(&2));\n+    /// assert_eq!(it.next(), Some(&3));\n+    /// assert_eq!(it.next(), Some(&1));\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    fn cycle(self) -> Cycle<Self> where Self: Sized + Clone {\n+        Cycle{orig: self.clone(), iter: self}\n+    }\n+\n+    /// Sums the elements of an iterator.\n+    ///\n+    /// Takes each element, adds them together, and returns the result.\n+    ///\n+    /// An empty iterator returns the zero value of the type.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// #![feature(iter_arith)]\n+    ///\n+    /// let a = [1, 2, 3];\n+    /// let sum: i32 = a.iter().sum();\n+    ///\n+    /// assert_eq!(sum, 6);\n+    /// ```\n+    #[unstable(feature = \"iter_arith\", reason = \"bounds recently changed\",\n+               issue = \"27739\")]\n+    fn sum<S>(self) -> S where\n+        S: Add<Self::Item, Output=S> + Zero,\n+        Self: Sized,\n+    {\n+        self.fold(Zero::zero(), |s, e| s + e)\n+    }\n+\n+    /// Iterates over the entire iterator, multiplying all the elements\n+    ///\n+    /// An empty iterator returns the one value of the type.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(iter_arith)]\n+    ///\n+    /// fn factorial(n: u32) -> u32 {\n+    ///     (1..).take_while(|&i| i <= n).product()\n+    /// }\n+    /// assert_eq!(factorial(0), 1);\n+    /// assert_eq!(factorial(1), 1);\n+    /// assert_eq!(factorial(5), 120);\n+    /// ```\n+    #[unstable(feature=\"iter_arith\", reason = \"bounds recently changed\",\n+               issue = \"27739\")]\n+    fn product<P>(self) -> P where\n+        P: Mul<Self::Item, Output=P> + One,\n+        Self: Sized,\n+    {\n+        self.fold(One::one(), |p, e| p * e)\n+    }\n+\n+    /// Lexicographically compares the elements of this `Iterator` with those\n+    /// of another.\n+    #[stable(feature = \"iter_order\", since = \"1.5.0\")]\n+    fn cmp<I>(mut self, other: I) -> Ordering where\n+        I: IntoIterator<Item = Self::Item>,\n+        Self::Item: Ord,\n+        Self: Sized,\n+    {\n+        let mut other = other.into_iter();\n+\n+        loop {\n+            match (self.next(), other.next()) {\n+                (None, None) => return Ordering::Equal,\n+                (None, _   ) => return Ordering::Less,\n+                (_   , None) => return Ordering::Greater,\n+                (Some(x), Some(y)) => match x.cmp(&y) {\n+                    Ordering::Equal => (),\n+                    non_eq => return non_eq,\n+                },\n+            }\n+        }\n+    }\n+\n+    /// Lexicographically compares the elements of this `Iterator` with those\n+    /// of another.\n+    #[stable(feature = \"iter_order\", since = \"1.5.0\")]\n+    fn partial_cmp<I>(mut self, other: I) -> Option<Ordering> where\n+        I: IntoIterator,\n+        Self::Item: PartialOrd<I::Item>,\n+        Self: Sized,\n+    {\n+        let mut other = other.into_iter();\n+\n+        loop {\n+            match (self.next(), other.next()) {\n+                (None, None) => return Some(Ordering::Equal),\n+                (None, _   ) => return Some(Ordering::Less),\n+                (_   , None) => return Some(Ordering::Greater),\n+                (Some(x), Some(y)) => match x.partial_cmp(&y) {\n+                    Some(Ordering::Equal) => (),\n+                    non_eq => return non_eq,\n+                },\n+            }\n+        }\n+    }\n+\n+    /// Determines if the elements of this `Iterator` are equal to those of\n+    /// another.\n+    #[stable(feature = \"iter_order\", since = \"1.5.0\")]\n+    fn eq<I>(mut self, other: I) -> bool where\n+        I: IntoIterator,\n+        Self::Item: PartialEq<I::Item>,\n+        Self: Sized,\n+    {\n+        let mut other = other.into_iter();\n+\n+        loop {\n+            match (self.next(), other.next()) {\n+                (None, None) => return true,\n+                (None, _) | (_, None) => return false,\n+                (Some(x), Some(y)) => if x != y { return false },\n+            }\n+        }\n+    }\n+\n+    /// Determines if the elements of this `Iterator` are unequal to those of\n+    /// another.\n+    #[stable(feature = \"iter_order\", since = \"1.5.0\")]\n+    fn ne<I>(mut self, other: I) -> bool where\n+        I: IntoIterator,\n+        Self::Item: PartialEq<I::Item>,\n+        Self: Sized,\n+    {\n+        let mut other = other.into_iter();\n+\n+        loop {\n+            match (self.next(), other.next()) {\n+                (None, None) => return false,\n+                (None, _) | (_, None) => return true,\n+                (Some(x), Some(y)) => if x.ne(&y) { return true },\n+            }\n+        }\n+    }\n+\n+    /// Determines if the elements of this `Iterator` are lexicographically\n+    /// less than those of another.\n+    #[stable(feature = \"iter_order\", since = \"1.5.0\")]\n+    fn lt<I>(mut self, other: I) -> bool where\n+        I: IntoIterator,\n+        Self::Item: PartialOrd<I::Item>,\n+        Self: Sized,\n+    {\n+        let mut other = other.into_iter();\n+\n+        loop {\n+            match (self.next(), other.next()) {\n+                (None, None) => return false,\n+                (None, _   ) => return true,\n+                (_   , None) => return false,\n+                (Some(x), Some(y)) => {\n+                    match x.partial_cmp(&y) {\n+                        Some(Ordering::Less) => return true,\n+                        Some(Ordering::Equal) => {}\n+                        Some(Ordering::Greater) => return false,\n+                        None => return false,\n+                    }\n+                },\n+            }\n+        }\n+    }\n+\n+    /// Determines if the elements of this `Iterator` are lexicographically\n+    /// less or equal to those of another.\n+    #[stable(feature = \"iter_order\", since = \"1.5.0\")]\n+    fn le<I>(mut self, other: I) -> bool where\n+        I: IntoIterator,\n+        Self::Item: PartialOrd<I::Item>,\n+        Self: Sized,\n+    {\n+        let mut other = other.into_iter();\n+\n+        loop {\n+            match (self.next(), other.next()) {\n+                (None, None) => return true,\n+                (None, _   ) => return true,\n+                (_   , None) => return false,\n+                (Some(x), Some(y)) => {\n+                    match x.partial_cmp(&y) {\n+                        Some(Ordering::Less) => return true,\n+                        Some(Ordering::Equal) => {}\n+                        Some(Ordering::Greater) => return false,\n+                        None => return false,\n+                    }\n+                },\n+            }\n+        }\n+    }\n+\n+    /// Determines if the elements of this `Iterator` are lexicographically\n+    /// greater than those of another.\n+    #[stable(feature = \"iter_order\", since = \"1.5.0\")]\n+    fn gt<I>(mut self, other: I) -> bool where\n+        I: IntoIterator,\n+        Self::Item: PartialOrd<I::Item>,\n+        Self: Sized,\n+    {\n+        let mut other = other.into_iter();\n+\n+        loop {\n+            match (self.next(), other.next()) {\n+                (None, None) => return false,\n+                (None, _   ) => return false,\n+                (_   , None) => return true,\n+                (Some(x), Some(y)) => {\n+                    match x.partial_cmp(&y) {\n+                        Some(Ordering::Less) => return false,\n+                        Some(Ordering::Equal) => {}\n+                        Some(Ordering::Greater) => return true,\n+                        None => return false,\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /// Determines if the elements of this `Iterator` are lexicographically\n+    /// greater than or equal to those of another.\n+    #[stable(feature = \"iter_order\", since = \"1.5.0\")]\n+    fn ge<I>(mut self, other: I) -> bool where\n+        I: IntoIterator,\n+        Self::Item: PartialOrd<I::Item>,\n+        Self: Sized,\n+    {\n+        let mut other = other.into_iter();\n+\n+        loop {\n+            match (self.next(), other.next()) {\n+                (None, None) => return true,\n+                (None, _   ) => return false,\n+                (_   , None) => return true,\n+                (Some(x), Some(y)) => {\n+                    match x.partial_cmp(&y) {\n+                        Some(Ordering::Less) => return false,\n+                        Some(Ordering::Equal) => {}\n+                        Some(Ordering::Greater) => return true,\n+                        None => return false,\n+                    }\n+                },\n+            }\n+        }\n+    }\n+}\n+\n+/// Select an element from an iterator based on the given projection\n+/// and \"comparison\" function.\n+///\n+/// This is an idiosyncratic helper to try to factor out the\n+/// commonalities of {max,min}{,_by}. In particular, this avoids\n+/// having to implement optimizations several times.\n+#[inline]\n+fn select_fold1<I,B, FProj, FCmp>(mut it: I,\n+                                  mut f_proj: FProj,\n+                                  mut f_cmp: FCmp) -> Option<(B, I::Item)>\n+    where I: Iterator,\n+          FProj: FnMut(&I::Item) -> B,\n+          FCmp: FnMut(&B, &I::Item, &B, &I::Item) -> bool\n+{\n+    // start with the first element as our selection. This avoids\n+    // having to use `Option`s inside the loop, translating to a\n+    // sizeable performance gain (6x in one case).\n+    it.next().map(|mut sel| {\n+        let mut sel_p = f_proj(&sel);\n+\n+        for x in it {\n+            let x_p = f_proj(&x);\n+            if f_cmp(&sel_p,  &sel, &x_p, &x) {\n+                sel = x;\n+                sel_p = x_p;\n+            }\n+        }\n+        (sel_p, sel)\n+    })\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, I: Iterator + ?Sized> Iterator for &'a mut I {\n+    type Item = I::Item;\n+    fn next(&mut self) -> Option<I::Item> { (**self).next() }\n+    fn size_hint(&self) -> (usize, Option<usize>) { (**self).size_hint() }\n+}\n+"}, {"sha": "abc199cd1828baf2915c7706306faf45c0779927", "filename": "src/libcore/iter/mod.rs", "status": "added", "additions": 1657, "deletions": 0, "changes": 1657, "blob_url": "https://github.com/rust-lang/rust/blob/d81de4871fbaf15198857af06b4f15fd4e1bfb13/src%2Flibcore%2Fiter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d81de4871fbaf15198857af06b4f15fd4e1bfb13/src%2Flibcore%2Fiter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fmod.rs?ref=d81de4871fbaf15198857af06b4f15fd4e1bfb13", "patch": "@@ -0,0 +1,1657 @@\n+// Copyright 2013-2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Composable external iteration.\n+//!\n+//! If you've found yourself with a collection of some kind, and needed to\n+//! perform an operation on the elements of said collection, you'll quickly run\n+//! into 'iterators'. Iterators are heavily used in idiomatic Rust code, so\n+//! it's worth becoming familiar with them.\n+//!\n+//! Before explaining more, let's talk about how this module is structured:\n+//!\n+//! # Organization\n+//!\n+//! This module is largely organized by type:\n+//!\n+//! * [Traits] are the core portion: these traits define what kind of iterators\n+//!   exist and what you can do with them. The methods of these traits are worth\n+//!   putting some extra study time into.\n+//! * [Functions] provide some helpful ways to create some basic iterators.\n+//! * [Structs] are often the return types of the various methods on this\n+//!   module's traits. You'll usually want to look at the method that creates\n+//!   the `struct`, rather than the `struct` itself. For more detail about why,\n+//!   see '[Implementing Iterator](#implementing-iterator)'.\n+//!\n+//! [Traits]: #traits\n+//! [Functions]: #functions\n+//! [Structs]: #structs\n+//!\n+//! That's it! Let's dig into iterators.\n+//!\n+//! # Iterator\n+//!\n+//! The heart and soul of this module is the [`Iterator`] trait. The core of\n+//! [`Iterator`] looks like this:\n+//!\n+//! ```\n+//! trait Iterator {\n+//!     type Item;\n+//!     fn next(&mut self) -> Option<Self::Item>;\n+//! }\n+//! ```\n+//!\n+//! An iterator has a method, [`next()`], which when called, returns an\n+//! [`Option`]`<Item>`. [`next()`] will return `Some(Item)` as long as there\n+//! are elements, and once they've all been exhausted, will return `None` to\n+//! indicate that iteration is finished. Individual iterators may choose to\n+//! resume iteration, and so calling [`next()`] again may or may not eventually\n+//! start returning `Some(Item)` again at some point.\n+//!\n+//! [`Iterator`]'s full definition includes a number of other methods as well,\n+//! but they are default methods, built on top of [`next()`], and so you get\n+//! them for free.\n+//!\n+//! Iterators are also composable, and it's common to chain them together to do\n+//! more complex forms of processing. See the [Adapters](#adapters) section\n+//! below for more details.\n+//!\n+//! [`Iterator`]: trait.Iterator.html\n+//! [`next()`]: trait.Iterator.html#tymethod.next\n+//! [`Option`]: ../../std/option/enum.Option.html\n+//!\n+//! # The three forms of iteration\n+//!\n+//! There are three common methods which can create iterators from a collection:\n+//!\n+//! * `iter()`, which iterates over `&T`.\n+//! * `iter_mut()`, which iterates over `&mut T`.\n+//! * `into_iter()`, which iterates over `T`.\n+//!\n+//! Various things in the standard library may implement one or more of the\n+//! three, where appropriate.\n+//!\n+//! # Implementing Iterator\n+//!\n+//! Creating an iterator of your own involves two steps: creating a `struct` to\n+//! hold the iterator's state, and then `impl`ementing [`Iterator`] for that\n+//! `struct`. This is why there are so many `struct`s in this module: there is\n+//! one for each iterator and iterator adapter.\n+//!\n+//! Let's make an iterator named `Counter` which counts from `1` to `5`:\n+//!\n+//! ```\n+//! // First, the struct:\n+//!\n+//! /// An iterator which counts from one to five\n+//! struct Counter {\n+//!     count: usize,\n+//! }\n+//!\n+//! // we want our count to start at one, so let's add a new() method to help.\n+//! // This isn't strictly necessary, but is convenient. Note that we start\n+//! // `count` at zero, we'll see why in `next()`'s implementation below.\n+//! impl Counter {\n+//!     fn new() -> Counter {\n+//!         Counter { count: 0 }\n+//!     }\n+//! }\n+//!\n+//! // Then, we implement `Iterator` for our `Counter`:\n+//!\n+//! impl Iterator for Counter {\n+//!     // we will be counting with usize\n+//!     type Item = usize;\n+//!\n+//!     // next() is the only required method\n+//!     fn next(&mut self) -> Option<usize> {\n+//!         // increment our count. This is why we started at zero.\n+//!         self.count += 1;\n+//!\n+//!         // check to see if we've finished counting or not.\n+//!         if self.count < 6 {\n+//!             Some(self.count)\n+//!         } else {\n+//!             None\n+//!         }\n+//!     }\n+//! }\n+//!\n+//! // And now we can use it!\n+//!\n+//! let mut counter = Counter::new();\n+//!\n+//! let x = counter.next().unwrap();\n+//! println!(\"{}\", x);\n+//!\n+//! let x = counter.next().unwrap();\n+//! println!(\"{}\", x);\n+//!\n+//! let x = counter.next().unwrap();\n+//! println!(\"{}\", x);\n+//!\n+//! let x = counter.next().unwrap();\n+//! println!(\"{}\", x);\n+//!\n+//! let x = counter.next().unwrap();\n+//! println!(\"{}\", x);\n+//! ```\n+//!\n+//! This will print `1` through `5`, each on their own line.\n+//!\n+//! Calling `next()` this way gets repetitive. Rust has a construct which can\n+//! call `next()` on your iterator, until it reaches `None`. Let's go over that\n+//! next.\n+//!\n+//! # for Loops and IntoIterator\n+//!\n+//! Rust's `for` loop syntax is actually sugar for iterators. Here's a basic\n+//! example of `for`:\n+//!\n+//! ```\n+//! let values = vec![1, 2, 3, 4, 5];\n+//!\n+//! for x in values {\n+//!     println!(\"{}\", x);\n+//! }\n+//! ```\n+//!\n+//! This will print the numbers one through five, each on their own line. But\n+//! you'll notice something here: we never called anything on our vector to\n+//! produce an iterator. What gives?\n+//!\n+//! There's a trait in the standard library for converting something into an\n+//! iterator: [`IntoIterator`]. This trait has one method, [`into_iter()`],\n+//! which converts the thing implementing [`IntoIterator`] into an iterator.\n+//! Let's take a look at that `for` loop again, and what the compiler converts\n+//! it into:\n+//!\n+//! [`IntoIterator`]: trait.IntoIterator.html\n+//! [`into_iter()`]: trait.IntoIterator.html#tymethod.into_iter\n+//!\n+//! ```\n+//! let values = vec![1, 2, 3, 4, 5];\n+//!\n+//! for x in values {\n+//!     println!(\"{}\", x);\n+//! }\n+//! ```\n+//!\n+//! Rust de-sugars this into:\n+//!\n+//! ```\n+//! let values = vec![1, 2, 3, 4, 5];\n+//! {\n+//!     let result = match IntoIterator::into_iter(values) {\n+//!         mut iter => loop {\n+//!             match iter.next() {\n+//!                 Some(x) => { println!(\"{}\", x); },\n+//!                 None => break,\n+//!             }\n+//!         },\n+//!     };\n+//!     result\n+//! }\n+//! ```\n+//!\n+//! First, we call `into_iter()` on the value. Then, we match on the iterator\n+//! that returns, calling [`next()`] over and over until we see a `None`. At\n+//! that point, we `break` out of the loop, and we're done iterating.\n+//!\n+//! There's one more subtle bit here: the standard library contains an\n+//! interesting implementation of [`IntoIterator`]:\n+//!\n+//! ```ignore\n+//! impl<I: Iterator> IntoIterator for I\n+//! ```\n+//!\n+//! In other words, all [`Iterator`]s implement [`IntoIterator`], by just\n+//! returning themselves. This means two things:\n+//!\n+//! 1. If you're writing an [`Iterator`], you can use it with a `for` loop.\n+//! 2. If you're creating a collection, implementing [`IntoIterator`] for it\n+//!    will allow your collection to be used with the `for` loop.\n+//!\n+//! # Adapters\n+//!\n+//! Functions which take an [`Iterator`] and return another [`Iterator`] are\n+//! often called 'iterator adapters', as they're a form of the 'adapter\n+//! pattern'.\n+//!\n+//! Common iterator adapters include [`map()`], [`take()`], and [`collect()`].\n+//! For more, see their documentation.\n+//!\n+//! [`map()`]: trait.Iterator.html#method.map\n+//! [`take()`]: trait.Iterator.html#method.take\n+//! [`collect()`]: trait.Iterator.html#method.collect\n+//!\n+//! # Laziness\n+//!\n+//! Iterators (and iterator [adapters](#adapters)) are *lazy*. This means that\n+//! just creating an iterator doesn't _do_ a whole lot. Nothing really happens\n+//! until you call [`next()`]. This is sometimes a source of confusion when\n+//! creating an iterator solely for its side effects. For example, the [`map()`]\n+//! method calls a closure on each element it iterates over:\n+//!\n+//! ```\n+//! # #![allow(unused_must_use)]\n+//! let v = vec![1, 2, 3, 4, 5];\n+//! v.iter().map(|x| println!(\"{}\", x));\n+//! ```\n+//!\n+//! This will not print any values, as we only created an iterator, rather than\n+//! using it. The compiler will warn us about this kind of behavior:\n+//!\n+//! ```text\n+//! warning: unused result which must be used: iterator adaptors are lazy and\n+//! do nothing unless consumed\n+//! ```\n+//!\n+//! The idiomatic way to write a [`map()`] for its side effects is to use a\n+//! `for` loop instead:\n+//!\n+//! ```\n+//! let v = vec![1, 2, 3, 4, 5];\n+//!\n+//! for x in &v {\n+//!     println!(\"{}\", x);\n+//! }\n+//! ```\n+//!\n+//! [`map()`]: trait.Iterator.html#method.map\n+//!\n+//! The two most common ways to evaluate an iterator are to use a `for` loop\n+//! like this, or using the [`collect()`] adapter to produce a new collection.\n+//!\n+//! [`collect()`]: trait.Iterator.html#method.collect\n+//!\n+//! # Infinity\n+//!\n+//! Iterators do not have to be finite. As an example, an open-ended range is\n+//! an infinite iterator:\n+//!\n+//! ```\n+//! let numbers = 0..;\n+//! ```\n+//!\n+//! It is common to use the [`take()`] iterator adapter to turn an infinite\n+//! iterator into a finite one:\n+//!\n+//! ```\n+//! let numbers = 0..;\n+//! let five_numbers = numbers.take(5);\n+//!\n+//! for number in five_numbers {\n+//!     println!(\"{}\", number);\n+//! }\n+//! ```\n+//!\n+//! This will print the numbers `0` through `4`, each on their own line.\n+//!\n+//! [`take()`]: trait.Iterator.html#method.take\n+\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n+\n+use clone::Clone;\n+use cmp;\n+use fmt;\n+use ops::FnMut;\n+use option::Option::{self, Some, None};\n+use usize;\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub use self::iterator::Iterator;\n+\n+#[unstable(feature = \"step_trait\",\n+           reason = \"likely to be replaced by finer-grained traits\",\n+           issue = \"27741\")]\n+pub use self::range::Step;\n+#[unstable(feature = \"step_by\", reason = \"recent addition\",\n+           issue = \"27741\")]\n+pub use self::range::StepBy;\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub use self::sources::{Repeat, repeat};\n+#[stable(feature = \"iter_empty\", since = \"1.2.0\")]\n+pub use self::sources::{Empty, empty};\n+#[stable(feature = \"iter_once\", since = \"1.2.0\")]\n+pub use self::sources::{Once, once};\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub use self::traits::{FromIterator, IntoIterator, DoubleEndedIterator, Extend,\n+                       ExactSizeIterator};\n+\n+mod iterator;\n+mod range;\n+mod sources;\n+mod traits;\n+\n+/// An double-ended iterator with the direction inverted.\n+///\n+/// This `struct` is created by the [`rev()`] method on [`Iterator`]. See its\n+/// documentation for more.\n+///\n+/// [`rev()`]: trait.Iterator.html#method.rev\n+/// [`Iterator`]: trait.Iterator.html\n+#[derive(Clone, Debug)]\n+#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct Rev<T> {\n+    iter: T\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I> Iterator for Rev<I> where I: DoubleEndedIterator {\n+    type Item = <I as Iterator>::Item;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<<I as Iterator>::Item> { self.iter.next_back() }\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I> DoubleEndedIterator for Rev<I> where I: DoubleEndedIterator {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<<I as Iterator>::Item> { self.iter.next() }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I> ExactSizeIterator for Rev<I>\n+    where I: ExactSizeIterator + DoubleEndedIterator {}\n+\n+/// An iterator that clones the elements of an underlying iterator.\n+///\n+/// This `struct` is created by the [`cloned()`] method on [`Iterator`]. See its\n+/// documentation for more.\n+///\n+/// [`cloned()`]: trait.Iterator.html#method.cloned\n+/// [`Iterator`]: trait.Iterator.html\n+#[stable(feature = \"iter_cloned\", since = \"1.1.0\")]\n+#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n+#[derive(Clone, Debug)]\n+pub struct Cloned<I> {\n+    it: I,\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, I, T: 'a> Iterator for Cloned<I>\n+    where I: Iterator<Item=&'a T>, T: Clone\n+{\n+    type Item = T;\n+\n+    fn next(&mut self) -> Option<T> {\n+        self.it.next().cloned()\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.it.size_hint()\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, I, T: 'a> DoubleEndedIterator for Cloned<I>\n+    where I: DoubleEndedIterator<Item=&'a T>, T: Clone\n+{\n+    fn next_back(&mut self) -> Option<T> {\n+        self.it.next_back().cloned()\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, I, T: 'a> ExactSizeIterator for Cloned<I>\n+    where I: ExactSizeIterator<Item=&'a T>, T: Clone\n+{}\n+\n+/// An iterator that repeats endlessly.\n+///\n+/// This `struct` is created by the [`cycle()`] method on [`Iterator`]. See its\n+/// documentation for more.\n+///\n+/// [`cycle()`]: trait.Iterator.html#method.cycle\n+/// [`Iterator`]: trait.Iterator.html\n+#[derive(Clone, Debug)]\n+#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct Cycle<I> {\n+    orig: I,\n+    iter: I,\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I> Iterator for Cycle<I> where I: Clone + Iterator {\n+    type Item = <I as Iterator>::Item;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<<I as Iterator>::Item> {\n+        match self.iter.next() {\n+            None => { self.iter = self.orig.clone(); self.iter.next() }\n+            y => y\n+        }\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        // the cycle iterator is either empty or infinite\n+        match self.orig.size_hint() {\n+            sz @ (0, Some(0)) => sz,\n+            (0, _) => (0, None),\n+            _ => (usize::MAX, None)\n+        }\n+    }\n+}\n+\n+/// An iterator that strings two iterators together.\n+///\n+/// This `struct` is created by the [`chain()`] method on [`Iterator`]. See its\n+/// documentation for more.\n+///\n+/// [`chain()`]: trait.Iterator.html#method.chain\n+/// [`Iterator`]: trait.Iterator.html\n+#[derive(Clone, Debug)]\n+#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct Chain<A, B> {\n+    a: A,\n+    b: B,\n+    state: ChainState,\n+}\n+\n+// The iterator protocol specifies that iteration ends with the return value\n+// `None` from `.next()` (or `.next_back()`) and it is unspecified what\n+// further calls return. The chain adaptor must account for this since it uses\n+// two subiterators.\n+//\n+//  It uses three states:\n+//\n+//  - Both: `a` and `b` are remaining\n+//  - Front: `a` remaining\n+//  - Back: `b` remaining\n+//\n+//  The fourth state (neither iterator is remaining) only occurs after Chain has\n+//  returned None once, so we don't need to store this state.\n+#[derive(Clone, Debug)]\n+enum ChainState {\n+    // both front and back iterator are remaining\n+    Both,\n+    // only front is remaining\n+    Front,\n+    // only back is remaining\n+    Back,\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<A, B> Iterator for Chain<A, B> where\n+    A: Iterator,\n+    B: Iterator<Item = A::Item>\n+{\n+    type Item = A::Item;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<A::Item> {\n+        match self.state {\n+            ChainState::Both => match self.a.next() {\n+                elt @ Some(..) => elt,\n+                None => {\n+                    self.state = ChainState::Back;\n+                    self.b.next()\n+                }\n+            },\n+            ChainState::Front => self.a.next(),\n+            ChainState::Back => self.b.next(),\n+        }\n+    }\n+\n+    #[inline]\n+    fn count(self) -> usize {\n+        match self.state {\n+            ChainState::Both => self.a.count() + self.b.count(),\n+            ChainState::Front => self.a.count(),\n+            ChainState::Back => self.b.count(),\n+        }\n+    }\n+\n+    #[inline]\n+    fn nth(&mut self, mut n: usize) -> Option<A::Item> {\n+        match self.state {\n+            ChainState::Both | ChainState::Front => {\n+                for x in self.a.by_ref() {\n+                    if n == 0 {\n+                        return Some(x)\n+                    }\n+                    n -= 1;\n+                }\n+                if let ChainState::Both = self.state {\n+                    self.state = ChainState::Back;\n+                }\n+            }\n+            ChainState::Back => {}\n+        }\n+        if let ChainState::Back = self.state {\n+            self.b.nth(n)\n+        } else {\n+            None\n+        }\n+    }\n+\n+    #[inline]\n+    fn last(self) -> Option<A::Item> {\n+        match self.state {\n+            ChainState::Both => {\n+                // Must exhaust a before b.\n+                let a_last = self.a.last();\n+                let b_last = self.b.last();\n+                b_last.or(a_last)\n+            },\n+            ChainState::Front => self.a.last(),\n+            ChainState::Back => self.b.last()\n+        }\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        let (a_lower, a_upper) = self.a.size_hint();\n+        let (b_lower, b_upper) = self.b.size_hint();\n+\n+        let lower = a_lower.saturating_add(b_lower);\n+\n+        let upper = match (a_upper, b_upper) {\n+            (Some(x), Some(y)) => x.checked_add(y),\n+            _ => None\n+        };\n+\n+        (lower, upper)\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<A, B> DoubleEndedIterator for Chain<A, B> where\n+    A: DoubleEndedIterator,\n+    B: DoubleEndedIterator<Item=A::Item>,\n+{\n+    #[inline]\n+    fn next_back(&mut self) -> Option<A::Item> {\n+        match self.state {\n+            ChainState::Both => match self.b.next_back() {\n+                elt @ Some(..) => elt,\n+                None => {\n+                    self.state = ChainState::Front;\n+                    self.a.next_back()\n+                }\n+            },\n+            ChainState::Front => self.a.next_back(),\n+            ChainState::Back => self.b.next_back(),\n+        }\n+    }\n+}\n+\n+/// An iterator that iterates two other iterators simultaneously.\n+///\n+/// This `struct` is created by the [`zip()`] method on [`Iterator`]. See its\n+/// documentation for more.\n+///\n+/// [`zip()`]: trait.Iterator.html#method.zip\n+/// [`Iterator`]: trait.Iterator.html\n+#[derive(Clone, Debug)]\n+#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct Zip<A, B> {\n+    a: A,\n+    b: B\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<A, B> Iterator for Zip<A, B> where A: Iterator, B: Iterator\n+{\n+    type Item = (A::Item, B::Item);\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<(A::Item, B::Item)> {\n+        self.a.next().and_then(|x| {\n+            self.b.next().and_then(|y| {\n+                Some((x, y))\n+            })\n+        })\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        let (a_lower, a_upper) = self.a.size_hint();\n+        let (b_lower, b_upper) = self.b.size_hint();\n+\n+        let lower = cmp::min(a_lower, b_lower);\n+\n+        let upper = match (a_upper, b_upper) {\n+            (Some(x), Some(y)) => Some(cmp::min(x,y)),\n+            (Some(x), None) => Some(x),\n+            (None, Some(y)) => Some(y),\n+            (None, None) => None\n+        };\n+\n+        (lower, upper)\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<A, B> DoubleEndedIterator for Zip<A, B> where\n+    A: DoubleEndedIterator + ExactSizeIterator,\n+    B: DoubleEndedIterator + ExactSizeIterator,\n+{\n+    #[inline]\n+    fn next_back(&mut self) -> Option<(A::Item, B::Item)> {\n+        let a_sz = self.a.len();\n+        let b_sz = self.b.len();\n+        if a_sz != b_sz {\n+            // Adjust a, b to equal length\n+            if a_sz > b_sz {\n+                for _ in 0..a_sz - b_sz { self.a.next_back(); }\n+            } else {\n+                for _ in 0..b_sz - a_sz { self.b.next_back(); }\n+            }\n+        }\n+        match (self.a.next_back(), self.b.next_back()) {\n+            (Some(x), Some(y)) => Some((x, y)),\n+            (None, None) => None,\n+            _ => unreachable!(),\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<A, B> ExactSizeIterator for Zip<A, B>\n+    where A: ExactSizeIterator, B: ExactSizeIterator {}\n+\n+/// An iterator that maps the values of `iter` with `f`.\n+///\n+/// This `struct` is created by the [`map()`] method on [`Iterator`]. See its\n+/// documentation for more.\n+///\n+/// [`map()`]: trait.Iterator.html#method.map\n+/// [`Iterator`]: trait.Iterator.html\n+///\n+/// # Notes about side effects\n+///\n+/// The [`map()`] iterator implements [`DoubleEndedIterator`], meaning that\n+/// you can also [`map()`] backwards:\n+///\n+/// ```rust\n+/// let v: Vec<i32> = vec![1, 2, 3].into_iter().rev().map(|x| x + 1).collect();\n+///\n+/// assert_eq!(v, [4, 3, 2]);\n+/// ```\n+///\n+/// [`DoubleEndedIterator`]: trait.DoubleEndedIterator.html\n+///\n+/// But if your closure has state, iterating backwards may act in a way you do\n+/// not expect. Let's go through an example. First, in the forward direction:\n+///\n+/// ```rust\n+/// let mut c = 0;\n+///\n+/// for pair in vec!['a', 'b', 'c'].into_iter()\n+///                                .map(|letter| { c += 1; (letter, c) }) {\n+///     println!(\"{:?}\", pair);\n+/// }\n+/// ```\n+///\n+/// This will print \"('a', 1), ('b', 2), ('c', 3)\".\n+///\n+/// Now consider this twist where we add a call to `rev`. This version will\n+/// print `('c', 1), ('b', 2), ('a', 3)`. Note that the letters are reversed,\n+/// but the values of the counter still go in order. This is because `map()` is\n+/// still being called lazilly on each item, but we are popping items off the\n+/// back of the vector now, instead of shifting them from the front.\n+///\n+/// ```rust\n+/// let mut c = 0;\n+///\n+/// for pair in vec!['a', 'b', 'c'].into_iter()\n+///                                .map(|letter| { c += 1; (letter, c) })\n+///                                .rev() {\n+///     println!(\"{:?}\", pair);\n+/// }\n+/// ```\n+#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[derive(Clone)]\n+pub struct Map<I, F> {\n+    iter: I,\n+    f: F,\n+}\n+\n+#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n+impl<I: fmt::Debug, F> fmt::Debug for Map<I, F> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_struct(\"Map\")\n+            .field(\"iter\", &self.iter)\n+            .finish()\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<B, I: Iterator, F> Iterator for Map<I, F> where F: FnMut(I::Item) -> B {\n+    type Item = B;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<B> {\n+        self.iter.next().map(&mut self.f)\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.iter.size_hint()\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<B, I: DoubleEndedIterator, F> DoubleEndedIterator for Map<I, F> where\n+    F: FnMut(I::Item) -> B,\n+{\n+    #[inline]\n+    fn next_back(&mut self) -> Option<B> {\n+        self.iter.next_back().map(&mut self.f)\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<B, I: ExactSizeIterator, F> ExactSizeIterator for Map<I, F>\n+    where F: FnMut(I::Item) -> B {}\n+\n+/// An iterator that filters the elements of `iter` with `predicate`.\n+///\n+/// This `struct` is created by the [`filter()`] method on [`Iterator`]. See its\n+/// documentation for more.\n+///\n+/// [`filter()`]: trait.Iterator.html#method.filter\n+/// [`Iterator`]: trait.Iterator.html\n+#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[derive(Clone)]\n+pub struct Filter<I, P> {\n+    iter: I,\n+    predicate: P,\n+}\n+\n+#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n+impl<I: fmt::Debug, P> fmt::Debug for Filter<I, P> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_struct(\"Filter\")\n+            .field(\"iter\", &self.iter)\n+            .finish()\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I: Iterator, P> Iterator for Filter<I, P> where P: FnMut(&I::Item) -> bool {\n+    type Item = I::Item;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<I::Item> {\n+        for x in self.iter.by_ref() {\n+            if (self.predicate)(&x) {\n+                return Some(x);\n+            }\n+        }\n+        None\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        let (_, upper) = self.iter.size_hint();\n+        (0, upper) // can't know a lower bound, due to the predicate\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I: DoubleEndedIterator, P> DoubleEndedIterator for Filter<I, P>\n+    where P: FnMut(&I::Item) -> bool,\n+{\n+    #[inline]\n+    fn next_back(&mut self) -> Option<I::Item> {\n+        for x in self.iter.by_ref().rev() {\n+            if (self.predicate)(&x) {\n+                return Some(x);\n+            }\n+        }\n+        None\n+    }\n+}\n+\n+/// An iterator that uses `f` to both filter and map elements from `iter`.\n+///\n+/// This `struct` is created by the [`filter_map()`] method on [`Iterator`]. See its\n+/// documentation for more.\n+///\n+/// [`filter_map()`]: trait.Iterator.html#method.filter_map\n+/// [`Iterator`]: trait.Iterator.html\n+#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[derive(Clone)]\n+pub struct FilterMap<I, F> {\n+    iter: I,\n+    f: F,\n+}\n+\n+#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n+impl<I: fmt::Debug, F> fmt::Debug for FilterMap<I, F> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_struct(\"FilterMap\")\n+            .field(\"iter\", &self.iter)\n+            .finish()\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<B, I: Iterator, F> Iterator for FilterMap<I, F>\n+    where F: FnMut(I::Item) -> Option<B>,\n+{\n+    type Item = B;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<B> {\n+        for x in self.iter.by_ref() {\n+            if let Some(y) = (self.f)(x) {\n+                return Some(y);\n+            }\n+        }\n+        None\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        let (_, upper) = self.iter.size_hint();\n+        (0, upper) // can't know a lower bound, due to the predicate\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<B, I: DoubleEndedIterator, F> DoubleEndedIterator for FilterMap<I, F>\n+    where F: FnMut(I::Item) -> Option<B>,\n+{\n+    #[inline]\n+    fn next_back(&mut self) -> Option<B> {\n+        for x in self.iter.by_ref().rev() {\n+            if let Some(y) = (self.f)(x) {\n+                return Some(y);\n+            }\n+        }\n+        None\n+    }\n+}\n+\n+/// An iterator that yields the current count and the element during iteration.\n+///\n+/// This `struct` is created by the [`enumerate()`] method on [`Iterator`]. See its\n+/// documentation for more.\n+///\n+/// [`enumerate()`]: trait.Iterator.html#method.enumerate\n+/// [`Iterator`]: trait.Iterator.html\n+#[derive(Clone, Debug)]\n+#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct Enumerate<I> {\n+    iter: I,\n+    count: usize,\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I> Iterator for Enumerate<I> where I: Iterator {\n+    type Item = (usize, <I as Iterator>::Item);\n+\n+    /// # Overflow Behavior\n+    ///\n+    /// The method does no guarding against overflows, so enumerating more than\n+    /// `usize::MAX` elements either produces the wrong result or panics. If\n+    /// debug assertions are enabled, a panic is guaranteed.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Might panic if the index of the element overflows a `usize`.\n+    #[inline]\n+    fn next(&mut self) -> Option<(usize, <I as Iterator>::Item)> {\n+        self.iter.next().map(|a| {\n+            let ret = (self.count, a);\n+            // Possible undefined overflow.\n+            self.count += 1;\n+            ret\n+        })\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.iter.size_hint()\n+    }\n+\n+    #[inline]\n+    fn nth(&mut self, n: usize) -> Option<(usize, I::Item)> {\n+        self.iter.nth(n).map(|a| {\n+            let i = self.count + n;\n+            self.count = i + 1;\n+            (i, a)\n+        })\n+    }\n+\n+    #[inline]\n+    fn count(self) -> usize {\n+        self.iter.count()\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I> DoubleEndedIterator for Enumerate<I> where\n+    I: ExactSizeIterator + DoubleEndedIterator\n+{\n+    #[inline]\n+    fn next_back(&mut self) -> Option<(usize, <I as Iterator>::Item)> {\n+        self.iter.next_back().map(|a| {\n+            let len = self.iter.len();\n+            // Can safely add, `ExactSizeIterator` promises that the number of\n+            // elements fits into a `usize`.\n+            (self.count + len, a)\n+        })\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I> ExactSizeIterator for Enumerate<I> where I: ExactSizeIterator {}\n+\n+/// An iterator with a `peek()` that returns an optional reference to the next\n+/// element.\n+///\n+/// This `struct` is created by the [`peekable()`] method on [`Iterator`]. See its\n+/// documentation for more.\n+///\n+/// [`peekable()`]: trait.Iterator.html#method.peekable\n+/// [`Iterator`]: trait.Iterator.html\n+#[derive(Clone, Debug)]\n+#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct Peekable<I: Iterator> {\n+    iter: I,\n+    peeked: Option<I::Item>,\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I: Iterator> Iterator for Peekable<I> {\n+    type Item = I::Item;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<I::Item> {\n+        match self.peeked {\n+            Some(_) => self.peeked.take(),\n+            None => self.iter.next(),\n+        }\n+    }\n+\n+    #[inline]\n+    fn count(self) -> usize {\n+        (if self.peeked.is_some() { 1 } else { 0 }) + self.iter.count()\n+    }\n+\n+    #[inline]\n+    fn nth(&mut self, n: usize) -> Option<I::Item> {\n+        match self.peeked {\n+            Some(_) if n == 0 => self.peeked.take(),\n+            Some(_) => {\n+                self.peeked = None;\n+                self.iter.nth(n-1)\n+            },\n+            None => self.iter.nth(n)\n+        }\n+    }\n+\n+    #[inline]\n+    fn last(self) -> Option<I::Item> {\n+        self.iter.last().or(self.peeked)\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        let (lo, hi) = self.iter.size_hint();\n+        if self.peeked.is_some() {\n+            let lo = lo.saturating_add(1);\n+            let hi = hi.and_then(|x| x.checked_add(1));\n+            (lo, hi)\n+        } else {\n+            (lo, hi)\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I: ExactSizeIterator> ExactSizeIterator for Peekable<I> {}\n+\n+impl<I: Iterator> Peekable<I> {\n+    /// Returns a reference to the next() value without advancing the iterator.\n+    ///\n+    /// The `peek()` method will return the value that a call to [`next()`] would\n+    /// return, but does not advance the iterator. Like [`next()`], if there is\n+    /// a value, it's wrapped in a `Some(T)`, but if the iterator is over, it\n+    /// will return `None`.\n+    ///\n+    /// [`next()`]: trait.Iterator.html#tymethod.next\n+    ///\n+    /// Because `peek()` returns reference, and many iterators iterate over\n+    /// references, this leads to a possibly confusing situation where the\n+    /// return value is a double reference. You can see this effect in the\n+    /// examples below, with `&&i32`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let xs = [1, 2, 3];\n+    ///\n+    /// let mut iter = xs.iter().peekable();\n+    ///\n+    /// // peek() lets us see into the future\n+    /// assert_eq!(iter.peek(), Some(&&1));\n+    /// assert_eq!(iter.next(), Some(&1));\n+    ///\n+    /// assert_eq!(iter.next(), Some(&2));\n+    ///\n+    /// // we can peek() multiple times, the iterator won't advance\n+    /// assert_eq!(iter.peek(), Some(&&3));\n+    /// assert_eq!(iter.peek(), Some(&&3));\n+    ///\n+    /// assert_eq!(iter.next(), Some(&3));\n+    ///\n+    /// // after the iterator is finished, so is peek()\n+    /// assert_eq!(iter.peek(), None);\n+    /// assert_eq!(iter.next(), None);\n+    /// ```\n+    #[inline]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn peek(&mut self) -> Option<&I::Item> {\n+        if self.peeked.is_none() {\n+            self.peeked = self.iter.next();\n+        }\n+        match self.peeked {\n+            Some(ref value) => Some(value),\n+            None => None,\n+        }\n+    }\n+\n+    /// Checks if the iterator has finished iterating.\n+    ///\n+    /// Returns `true` if there are no more elements in the iterator, and\n+    /// `false` if there are.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// #![feature(peekable_is_empty)]\n+    ///\n+    /// let xs = [1, 2, 3];\n+    ///\n+    /// let mut iter = xs.iter().peekable();\n+    ///\n+    /// // there are still elements to iterate over\n+    /// assert_eq!(iter.is_empty(), false);\n+    ///\n+    /// // let's consume the iterator\n+    /// iter.next();\n+    /// iter.next();\n+    /// iter.next();\n+    ///\n+    /// assert_eq!(iter.is_empty(), true);\n+    /// ```\n+    #[unstable(feature = \"peekable_is_empty\", issue = \"32111\")]\n+    #[inline]\n+    pub fn is_empty(&mut self) -> bool {\n+        self.peek().is_none()\n+    }\n+}\n+\n+/// An iterator that rejects elements while `predicate` is true.\n+///\n+/// This `struct` is created by the [`skip_while()`] method on [`Iterator`]. See its\n+/// documentation for more.\n+///\n+/// [`skip_while()`]: trait.Iterator.html#method.skip_while\n+/// [`Iterator`]: trait.Iterator.html\n+#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[derive(Clone)]\n+pub struct SkipWhile<I, P> {\n+    iter: I,\n+    flag: bool,\n+    predicate: P,\n+}\n+\n+#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n+impl<I: fmt::Debug, P> fmt::Debug for SkipWhile<I, P> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_struct(\"SkipWhile\")\n+            .field(\"iter\", &self.iter)\n+            .field(\"flag\", &self.flag)\n+            .finish()\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I: Iterator, P> Iterator for SkipWhile<I, P>\n+    where P: FnMut(&I::Item) -> bool\n+{\n+    type Item = I::Item;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<I::Item> {\n+        for x in self.iter.by_ref() {\n+            if self.flag || !(self.predicate)(&x) {\n+                self.flag = true;\n+                return Some(x);\n+            }\n+        }\n+        None\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        let (_, upper) = self.iter.size_hint();\n+        (0, upper) // can't know a lower bound, due to the predicate\n+    }\n+}\n+\n+/// An iterator that only accepts elements while `predicate` is true.\n+///\n+/// This `struct` is created by the [`take_while()`] method on [`Iterator`]. See its\n+/// documentation for more.\n+///\n+/// [`take_while()`]: trait.Iterator.html#method.take_while\n+/// [`Iterator`]: trait.Iterator.html\n+#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[derive(Clone)]\n+pub struct TakeWhile<I, P> {\n+    iter: I,\n+    flag: bool,\n+    predicate: P,\n+}\n+\n+#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n+impl<I: fmt::Debug, P> fmt::Debug for TakeWhile<I, P> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_struct(\"TakeWhile\")\n+            .field(\"iter\", &self.iter)\n+            .field(\"flag\", &self.flag)\n+            .finish()\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I: Iterator, P> Iterator for TakeWhile<I, P>\n+    where P: FnMut(&I::Item) -> bool\n+{\n+    type Item = I::Item;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<I::Item> {\n+        if self.flag {\n+            None\n+        } else {\n+            self.iter.next().and_then(|x| {\n+                if (self.predicate)(&x) {\n+                    Some(x)\n+                } else {\n+                    self.flag = true;\n+                    None\n+                }\n+            })\n+        }\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        let (_, upper) = self.iter.size_hint();\n+        (0, upper) // can't know a lower bound, due to the predicate\n+    }\n+}\n+\n+/// An iterator that skips over `n` elements of `iter`.\n+///\n+/// This `struct` is created by the [`skip()`] method on [`Iterator`]. See its\n+/// documentation for more.\n+///\n+/// [`skip()`]: trait.Iterator.html#method.skip\n+/// [`Iterator`]: trait.Iterator.html\n+#[derive(Clone, Debug)]\n+#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct Skip<I> {\n+    iter: I,\n+    n: usize\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I> Iterator for Skip<I> where I: Iterator {\n+    type Item = <I as Iterator>::Item;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<I::Item> {\n+        if self.n == 0 {\n+            self.iter.next()\n+        } else {\n+            let old_n = self.n;\n+            self.n = 0;\n+            self.iter.nth(old_n)\n+        }\n+    }\n+\n+    #[inline]\n+    fn nth(&mut self, n: usize) -> Option<I::Item> {\n+        // Can't just add n + self.n due to overflow.\n+        if self.n == 0 {\n+            self.iter.nth(n)\n+        } else {\n+            let to_skip = self.n;\n+            self.n = 0;\n+            // nth(n) skips n+1\n+            if self.iter.nth(to_skip-1).is_none() {\n+                return None;\n+            }\n+            self.iter.nth(n)\n+        }\n+    }\n+\n+    #[inline]\n+    fn count(self) -> usize {\n+        self.iter.count().saturating_sub(self.n)\n+    }\n+\n+    #[inline]\n+    fn last(mut self) -> Option<I::Item> {\n+        if self.n == 0 {\n+            self.iter.last()\n+        } else {\n+            let next = self.next();\n+            if next.is_some() {\n+                // recurse. n should be 0.\n+                self.last().or(next)\n+            } else {\n+                None\n+            }\n+        }\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        let (lower, upper) = self.iter.size_hint();\n+\n+        let lower = lower.saturating_sub(self.n);\n+        let upper = upper.map(|x| x.saturating_sub(self.n));\n+\n+        (lower, upper)\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I> ExactSizeIterator for Skip<I> where I: ExactSizeIterator {}\n+\n+#[stable(feature = \"double_ended_skip_iterator\", since = \"1.8.0\")]\n+impl<I> DoubleEndedIterator for Skip<I> where I: DoubleEndedIterator + ExactSizeIterator {\n+    fn next_back(&mut self) -> Option<Self::Item> {\n+        if self.len() > 0 {\n+            self.iter.next_back()\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+/// An iterator that only iterates over the first `n` iterations of `iter`.\n+///\n+/// This `struct` is created by the [`take()`] method on [`Iterator`]. See its\n+/// documentation for more.\n+///\n+/// [`take()`]: trait.Iterator.html#method.take\n+/// [`Iterator`]: trait.Iterator.html\n+#[derive(Clone, Debug)]\n+#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct Take<I> {\n+    iter: I,\n+    n: usize\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I> Iterator for Take<I> where I: Iterator{\n+    type Item = <I as Iterator>::Item;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<<I as Iterator>::Item> {\n+        if self.n != 0 {\n+            self.n -= 1;\n+            self.iter.next()\n+        } else {\n+            None\n+        }\n+    }\n+\n+    #[inline]\n+    fn nth(&mut self, n: usize) -> Option<I::Item> {\n+        if self.n > n {\n+            self.n -= n + 1;\n+            self.iter.nth(n)\n+        } else {\n+            if self.n > 0 {\n+                self.iter.nth(self.n - 1);\n+                self.n = 0;\n+            }\n+            None\n+        }\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        let (lower, upper) = self.iter.size_hint();\n+\n+        let lower = cmp::min(lower, self.n);\n+\n+        let upper = match upper {\n+            Some(x) if x < self.n => Some(x),\n+            _ => Some(self.n)\n+        };\n+\n+        (lower, upper)\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I> ExactSizeIterator for Take<I> where I: ExactSizeIterator {}\n+\n+\n+/// An iterator to maintain state while iterating another iterator.\n+///\n+/// This `struct` is created by the [`scan()`] method on [`Iterator`]. See its\n+/// documentation for more.\n+///\n+/// [`scan()`]: trait.Iterator.html#method.scan\n+/// [`Iterator`]: trait.Iterator.html\n+#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[derive(Clone)]\n+pub struct Scan<I, St, F> {\n+    iter: I,\n+    f: F,\n+    state: St,\n+}\n+\n+#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n+impl<I: fmt::Debug, St: fmt::Debug, F> fmt::Debug for Scan<I, St, F> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_struct(\"Scan\")\n+            .field(\"iter\", &self.iter)\n+            .field(\"state\", &self.state)\n+            .finish()\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<B, I, St, F> Iterator for Scan<I, St, F> where\n+    I: Iterator,\n+    F: FnMut(&mut St, I::Item) -> Option<B>,\n+{\n+    type Item = B;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<B> {\n+        self.iter.next().and_then(|a| (self.f)(&mut self.state, a))\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        let (_, upper) = self.iter.size_hint();\n+        (0, upper) // can't know a lower bound, due to the scan function\n+    }\n+}\n+\n+/// An iterator that maps each element to an iterator, and yields the elements\n+/// of the produced iterators.\n+///\n+/// This `struct` is created by the [`flat_map()`] method on [`Iterator`]. See its\n+/// documentation for more.\n+///\n+/// [`flat_map()`]: trait.Iterator.html#method.flat_map\n+/// [`Iterator`]: trait.Iterator.html\n+#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[derive(Clone)]\n+pub struct FlatMap<I, U: IntoIterator, F> {\n+    iter: I,\n+    f: F,\n+    frontiter: Option<U::IntoIter>,\n+    backiter: Option<U::IntoIter>,\n+}\n+\n+#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n+impl<I: fmt::Debug, U: IntoIterator, F> fmt::Debug for FlatMap<I, U, F>\n+    where U::IntoIter: fmt::Debug\n+{\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_struct(\"FlatMap\")\n+            .field(\"iter\", &self.iter)\n+            .field(\"frontiter\", &self.frontiter)\n+            .field(\"backiter\", &self.backiter)\n+            .finish()\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I: Iterator, U: IntoIterator, F> Iterator for FlatMap<I, U, F>\n+    where F: FnMut(I::Item) -> U,\n+{\n+    type Item = U::Item;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<U::Item> {\n+        loop {\n+            if let Some(ref mut inner) = self.frontiter {\n+                if let Some(x) = inner.by_ref().next() {\n+                    return Some(x)\n+                }\n+            }\n+            match self.iter.next().map(&mut self.f) {\n+                None => return self.backiter.as_mut().and_then(|it| it.next()),\n+                next => self.frontiter = next.map(IntoIterator::into_iter),\n+            }\n+        }\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        let (flo, fhi) = self.frontiter.as_ref().map_or((0, Some(0)), |it| it.size_hint());\n+        let (blo, bhi) = self.backiter.as_ref().map_or((0, Some(0)), |it| it.size_hint());\n+        let lo = flo.saturating_add(blo);\n+        match (self.iter.size_hint(), fhi, bhi) {\n+            ((0, Some(0)), Some(a), Some(b)) => (lo, a.checked_add(b)),\n+            _ => (lo, None)\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I: DoubleEndedIterator, U, F> DoubleEndedIterator for FlatMap<I, U, F> where\n+    F: FnMut(I::Item) -> U,\n+    U: IntoIterator,\n+    U::IntoIter: DoubleEndedIterator\n+{\n+    #[inline]\n+    fn next_back(&mut self) -> Option<U::Item> {\n+        loop {\n+            if let Some(ref mut inner) = self.backiter {\n+                if let Some(y) = inner.next_back() {\n+                    return Some(y)\n+                }\n+            }\n+            match self.iter.next_back().map(&mut self.f) {\n+                None => return self.frontiter.as_mut().and_then(|it| it.next_back()),\n+                next => self.backiter = next.map(IntoIterator::into_iter),\n+            }\n+        }\n+    }\n+}\n+\n+/// An iterator that yields `None` forever after the underlying iterator\n+/// yields `None` once.\n+///\n+/// This `struct` is created by the [`fuse()`] method on [`Iterator`]. See its\n+/// documentation for more.\n+///\n+/// [`fuse()`]: trait.Iterator.html#method.fuse\n+/// [`Iterator`]: trait.Iterator.html\n+#[derive(Clone, Debug)]\n+#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct Fuse<I> {\n+    iter: I,\n+    done: bool\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I> Iterator for Fuse<I> where I: Iterator {\n+    type Item = <I as Iterator>::Item;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<<I as Iterator>::Item> {\n+        if self.done {\n+            None\n+        } else {\n+            let next = self.iter.next();\n+            self.done = next.is_none();\n+            next\n+        }\n+    }\n+\n+    #[inline]\n+    fn nth(&mut self, n: usize) -> Option<I::Item> {\n+        if self.done {\n+            None\n+        } else {\n+            let nth = self.iter.nth(n);\n+            self.done = nth.is_none();\n+            nth\n+        }\n+    }\n+\n+    #[inline]\n+    fn last(self) -> Option<I::Item> {\n+        if self.done {\n+            None\n+        } else {\n+            self.iter.last()\n+        }\n+    }\n+\n+    #[inline]\n+    fn count(self) -> usize {\n+        if self.done {\n+            0\n+        } else {\n+            self.iter.count()\n+        }\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        if self.done {\n+            (0, Some(0))\n+        } else {\n+            self.iter.size_hint()\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I> DoubleEndedIterator for Fuse<I> where I: DoubleEndedIterator {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<<I as Iterator>::Item> {\n+        if self.done {\n+            None\n+        } else {\n+            let next = self.iter.next_back();\n+            self.done = next.is_none();\n+            next\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I> ExactSizeIterator for Fuse<I> where I: ExactSizeIterator {}\n+\n+/// An iterator that calls a function with a reference to each element before\n+/// yielding it.\n+///\n+/// This `struct` is created by the [`inspect()`] method on [`Iterator`]. See its\n+/// documentation for more.\n+///\n+/// [`inspect()`]: trait.Iterator.html#method.inspect\n+/// [`Iterator`]: trait.Iterator.html\n+#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[derive(Clone)]\n+pub struct Inspect<I, F> {\n+    iter: I,\n+    f: F,\n+}\n+\n+#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n+impl<I: fmt::Debug, F> fmt::Debug for Inspect<I, F> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_struct(\"Inspect\")\n+            .field(\"iter\", &self.iter)\n+            .finish()\n+    }\n+}\n+\n+impl<I: Iterator, F> Inspect<I, F> where F: FnMut(&I::Item) {\n+    #[inline]\n+    fn do_inspect(&mut self, elt: Option<I::Item>) -> Option<I::Item> {\n+        if let Some(ref a) = elt {\n+            (self.f)(a);\n+        }\n+\n+        elt\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I: Iterator, F> Iterator for Inspect<I, F> where F: FnMut(&I::Item) {\n+    type Item = I::Item;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<I::Item> {\n+        let next = self.iter.next();\n+        self.do_inspect(next)\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.iter.size_hint()\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I: DoubleEndedIterator, F> DoubleEndedIterator for Inspect<I, F>\n+    where F: FnMut(&I::Item),\n+{\n+    #[inline]\n+    fn next_back(&mut self) -> Option<I::Item> {\n+        let next = self.iter.next_back();\n+        self.do_inspect(next)\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I: ExactSizeIterator, F> ExactSizeIterator for Inspect<I, F>\n+    where F: FnMut(&I::Item) {}"}, {"sha": "08143567beaf3892cfb82ff66ab5ab94c531fed8", "filename": "src/libcore/iter/range.rs", "status": "added", "additions": 548, "deletions": 0, "changes": 548, "blob_url": "https://github.com/rust-lang/rust/blob/d81de4871fbaf15198857af06b4f15fd4e1bfb13/src%2Flibcore%2Fiter%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d81de4871fbaf15198857af06b4f15fd4e1bfb13/src%2Flibcore%2Fiter%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Frange.rs?ref=d81de4871fbaf15198857af06b4f15fd4e1bfb13", "patch": "@@ -0,0 +1,548 @@\n+// Copyright 2013-2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use clone::Clone;\n+use cmp::PartialOrd;\n+use mem;\n+use num::{Zero, One};\n+use ops::{self, Add, Sub};\n+use option::Option::{self, Some, None};\n+use marker::Sized;\n+use usize;\n+\n+use super::{DoubleEndedIterator, ExactSizeIterator, Iterator};\n+\n+/// Objects that can be stepped over in both directions.\n+///\n+/// The `steps_between` function provides a way to efficiently compare\n+/// two `Step` objects.\n+#[unstable(feature = \"step_trait\",\n+           reason = \"likely to be replaced by finer-grained traits\",\n+           issue = \"27741\")]\n+pub trait Step: PartialOrd + Sized {\n+    /// Steps `self` if possible.\n+    fn step(&self, by: &Self) -> Option<Self>;\n+\n+    /// Returns the number of steps between two step objects. The count is\n+    /// inclusive of `start` and exclusive of `end`.\n+    ///\n+    /// Returns `None` if it is not possible to calculate `steps_between`\n+    /// without overflow.\n+    fn steps_between(start: &Self, end: &Self, by: &Self) -> Option<usize>;\n+}\n+\n+macro_rules! step_impl_unsigned {\n+    ($($t:ty)*) => ($(\n+        #[unstable(feature = \"step_trait\",\n+                   reason = \"likely to be replaced by finer-grained traits\",\n+                   issue = \"27741\")]\n+        impl Step for $t {\n+            #[inline]\n+            fn step(&self, by: &$t) -> Option<$t> {\n+                (*self).checked_add(*by)\n+            }\n+            #[inline]\n+            #[allow(trivial_numeric_casts)]\n+            fn steps_between(start: &$t, end: &$t, by: &$t) -> Option<usize> {\n+                if *by == 0 { return None; }\n+                if *start < *end {\n+                    // Note: We assume $t <= usize here\n+                    let diff = (*end - *start) as usize;\n+                    let by = *by as usize;\n+                    if diff % by > 0 {\n+                        Some(diff / by + 1)\n+                    } else {\n+                        Some(diff / by)\n+                    }\n+                } else {\n+                    Some(0)\n+                }\n+            }\n+        }\n+    )*)\n+}\n+macro_rules! step_impl_signed {\n+    ($($t:ty)*) => ($(\n+        #[unstable(feature = \"step_trait\",\n+                   reason = \"likely to be replaced by finer-grained traits\",\n+                   issue = \"27741\")]\n+        impl Step for $t {\n+            #[inline]\n+            fn step(&self, by: &$t) -> Option<$t> {\n+                (*self).checked_add(*by)\n+            }\n+            #[inline]\n+            #[allow(trivial_numeric_casts)]\n+            fn steps_between(start: &$t, end: &$t, by: &$t) -> Option<usize> {\n+                if *by == 0 { return None; }\n+                let diff: usize;\n+                let by_u: usize;\n+                if *by > 0 {\n+                    if *start >= *end {\n+                        return Some(0);\n+                    }\n+                    // Note: We assume $t <= isize here\n+                    // Use .wrapping_sub and cast to usize to compute the\n+                    // difference that may not fit inside the range of isize.\n+                    diff = (*end as isize).wrapping_sub(*start as isize) as usize;\n+                    by_u = *by as usize;\n+                } else {\n+                    if *start <= *end {\n+                        return Some(0);\n+                    }\n+                    diff = (*start as isize).wrapping_sub(*end as isize) as usize;\n+                    by_u = (*by as isize).wrapping_mul(-1) as usize;\n+                }\n+                if diff % by_u > 0 {\n+                    Some(diff / by_u + 1)\n+                } else {\n+                    Some(diff / by_u)\n+                }\n+            }\n+        }\n+    )*)\n+}\n+\n+macro_rules! step_impl_no_between {\n+    ($($t:ty)*) => ($(\n+        #[unstable(feature = \"step_trait\",\n+                   reason = \"likely to be replaced by finer-grained traits\",\n+                   issue = \"27741\")]\n+        impl Step for $t {\n+            #[inline]\n+            fn step(&self, by: &$t) -> Option<$t> {\n+                (*self).checked_add(*by)\n+            }\n+            #[inline]\n+            fn steps_between(_a: &$t, _b: &$t, _by: &$t) -> Option<usize> {\n+                None\n+            }\n+        }\n+    )*)\n+}\n+\n+step_impl_unsigned!(usize u8 u16 u32);\n+step_impl_signed!(isize i8 i16 i32);\n+#[cfg(target_pointer_width = \"64\")]\n+step_impl_unsigned!(u64);\n+#[cfg(target_pointer_width = \"64\")]\n+step_impl_signed!(i64);\n+// If the target pointer width is not 64-bits, we\n+// assume here that it is less than 64-bits.\n+#[cfg(not(target_pointer_width = \"64\"))]\n+step_impl_no_between!(u64 i64);\n+\n+/// An adapter for stepping range iterators by a custom amount.\n+///\n+/// The resulting iterator handles overflow by stopping. The `A`\n+/// parameter is the type being iterated over, while `R` is the range\n+/// type (usually one of `std::ops::{Range, RangeFrom, RangeInclusive}`.\n+#[derive(Clone, Debug)]\n+#[unstable(feature = \"step_by\", reason = \"recent addition\",\n+           issue = \"27741\")]\n+pub struct StepBy<A, R> {\n+    step_by: A,\n+    range: R,\n+}\n+\n+impl<A: Step> ops::RangeFrom<A> {\n+    /// Creates an iterator starting at the same point, but stepping by\n+    /// the given amount at each iteration.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// # #![feature(step_by)]\n+    ///\n+    /// for i in (0u8..).step_by(2).take(10) {\n+    ///     println!(\"{}\", i);\n+    /// }\n+    /// ```\n+    ///\n+    /// This prints the first ten even natural integers (0 to 18).\n+    #[unstable(feature = \"step_by\", reason = \"recent addition\",\n+               issue = \"27741\")]\n+    pub fn step_by(self, by: A) -> StepBy<A, Self> {\n+        StepBy {\n+            step_by: by,\n+            range: self\n+        }\n+    }\n+}\n+\n+impl<A: Step> ops::Range<A> {\n+    /// Creates an iterator with the same range, but stepping by the\n+    /// given amount at each iteration.\n+    ///\n+    /// The resulting iterator handles overflow by stopping.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(step_by)]\n+    ///\n+    /// for i in (0..10).step_by(2) {\n+    ///     println!(\"{}\", i);\n+    /// }\n+    /// ```\n+    ///\n+    /// This prints:\n+    ///\n+    /// ```text\n+    /// 0\n+    /// 2\n+    /// 4\n+    /// 6\n+    /// 8\n+    /// ```\n+    #[unstable(feature = \"step_by\", reason = \"recent addition\",\n+               issue = \"27741\")]\n+    pub fn step_by(self, by: A) -> StepBy<A, Self> {\n+        StepBy {\n+            step_by: by,\n+            range: self\n+        }\n+    }\n+}\n+\n+impl<A: Step> ops::RangeInclusive<A> {\n+    /// Creates an iterator with the same range, but stepping by the\n+    /// given amount at each iteration.\n+    ///\n+    /// The resulting iterator handles overflow by stopping.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(step_by, inclusive_range_syntax)]\n+    ///\n+    /// for i in (0...10).step_by(2) {\n+    ///     println!(\"{}\", i);\n+    /// }\n+    /// ```\n+    ///\n+    /// This prints:\n+    ///\n+    /// ```text\n+    /// 0\n+    /// 2\n+    /// 4\n+    /// 6\n+    /// 8\n+    /// 10\n+    /// ```\n+    #[unstable(feature = \"step_by\", reason = \"recent addition\",\n+               issue = \"27741\")]\n+    pub fn step_by(self, by: A) -> StepBy<A, Self> {\n+        StepBy {\n+            step_by: by,\n+            range: self\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<A> Iterator for StepBy<A, ops::RangeFrom<A>> where\n+    A: Clone,\n+    for<'a> &'a A: Add<&'a A, Output = A>\n+{\n+    type Item = A;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<A> {\n+        let mut n = &self.range.start + &self.step_by;\n+        mem::swap(&mut n, &mut self.range.start);\n+        Some(n)\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        (usize::MAX, None) // Too bad we can't specify an infinite lower bound\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<A: Step + Zero + Clone> Iterator for StepBy<A, ops::Range<A>> {\n+    type Item = A;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<A> {\n+        let rev = self.step_by < A::zero();\n+        if (rev && self.range.start > self.range.end) ||\n+           (!rev && self.range.start < self.range.end)\n+        {\n+            match self.range.start.step(&self.step_by) {\n+                Some(mut n) => {\n+                    mem::swap(&mut self.range.start, &mut n);\n+                    Some(n)\n+                },\n+                None => {\n+                    let mut n = self.range.end.clone();\n+                    mem::swap(&mut self.range.start, &mut n);\n+                    Some(n)\n+                }\n+            }\n+        } else {\n+            None\n+        }\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        match Step::steps_between(&self.range.start,\n+                                  &self.range.end,\n+                                  &self.step_by) {\n+            Some(hint) => (hint, Some(hint)),\n+            None       => (0, None)\n+        }\n+    }\n+}\n+\n+#[unstable(feature = \"inclusive_range\",\n+           reason = \"recently added, follows RFC\",\n+           issue = \"28237\")]\n+impl<A: Step + Zero + Clone> Iterator for StepBy<A, ops::RangeInclusive<A>> {\n+    type Item = A;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<A> {\n+        use ops::RangeInclusive::*;\n+\n+        // this function has a sort of odd structure due to borrowck issues\n+        // we may need to replace self.range, so borrows of start and end need to end early\n+\n+        let (finishing, n) = match self.range {\n+            Empty { .. } => return None, // empty iterators yield no values\n+\n+            NonEmpty { ref mut start, ref mut end } => {\n+                let zero = A::zero();\n+                let rev = self.step_by < zero;\n+\n+                // march start towards (maybe past!) end and yield the old value\n+                if (rev && start >= end) ||\n+                   (!rev && start <= end)\n+                {\n+                    match start.step(&self.step_by) {\n+                        Some(mut n) => {\n+                            mem::swap(start, &mut n);\n+                            (None, Some(n)) // yield old value, remain non-empty\n+                        },\n+                        None => {\n+                            let mut n = end.clone();\n+                            mem::swap(start, &mut n);\n+                            (None, Some(n)) // yield old value, remain non-empty\n+                        }\n+                    }\n+                } else {\n+                    // found range in inconsistent state (start at or past end), so become empty\n+                    (Some(mem::replace(end, zero)), None)\n+                }\n+            }\n+        };\n+\n+        // turn into an empty iterator if we've reached the end\n+        if let Some(end) = finishing {\n+            self.range = Empty { at: end };\n+        }\n+\n+        n\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        use ops::RangeInclusive::*;\n+\n+        match self.range {\n+            Empty { .. } => (0, Some(0)),\n+\n+            NonEmpty { ref start, ref end } =>\n+                match Step::steps_between(start,\n+                                          end,\n+                                          &self.step_by) {\n+                    Some(hint) => (hint.saturating_add(1), hint.checked_add(1)),\n+                    None       => (0, None)\n+                }\n+        }\n+    }\n+}\n+\n+macro_rules! range_exact_iter_impl {\n+    ($($t:ty)*) => ($(\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        impl ExactSizeIterator for ops::Range<$t> { }\n+\n+        #[unstable(feature = \"inclusive_range\",\n+                   reason = \"recently added, follows RFC\",\n+                   issue = \"28237\")]\n+        impl ExactSizeIterator for ops::RangeInclusive<$t> { }\n+    )*)\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<A: Step + One> Iterator for ops::Range<A> where\n+    for<'a> &'a A: Add<&'a A, Output = A>\n+{\n+    type Item = A;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<A> {\n+        if self.start < self.end {\n+            let mut n = &self.start + &A::one();\n+            mem::swap(&mut n, &mut self.start);\n+            Some(n)\n+        } else {\n+            None\n+        }\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        match Step::steps_between(&self.start, &self.end, &A::one()) {\n+            Some(hint) => (hint, Some(hint)),\n+            None => (0, None)\n+        }\n+    }\n+}\n+\n+// Ranges of u64 and i64 are excluded because they cannot guarantee having\n+// a length <= usize::MAX, which is required by ExactSizeIterator.\n+range_exact_iter_impl!(usize u8 u16 u32 isize i8 i16 i32);\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<A: Step + One + Clone> DoubleEndedIterator for ops::Range<A> where\n+    for<'a> &'a A: Add<&'a A, Output = A>,\n+    for<'a> &'a A: Sub<&'a A, Output = A>\n+{\n+    #[inline]\n+    fn next_back(&mut self) -> Option<A> {\n+        if self.start < self.end {\n+            self.end = &self.end - &A::one();\n+            Some(self.end.clone())\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<A: Step + One> Iterator for ops::RangeFrom<A> where\n+    for<'a> &'a A: Add<&'a A, Output = A>\n+{\n+    type Item = A;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<A> {\n+        let mut n = &self.start + &A::one();\n+        mem::swap(&mut n, &mut self.start);\n+        Some(n)\n+    }\n+}\n+\n+#[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n+impl<A: Step + One> Iterator for ops::RangeInclusive<A> where\n+    for<'a> &'a A: Add<&'a A, Output = A>\n+{\n+    type Item = A;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<A> {\n+        use ops::RangeInclusive::*;\n+\n+        // this function has a sort of odd structure due to borrowck issues\n+        // we may need to replace self, so borrows of self.start and self.end need to end early\n+\n+        let (finishing, n) = match *self {\n+            Empty { .. } => (None, None), // empty iterators yield no values\n+\n+            NonEmpty { ref mut start, ref mut end } => {\n+                if start == end {\n+                    (Some(mem::replace(end, A::one())), Some(mem::replace(start, A::one())))\n+                } else if start < end {\n+                    let one = A::one();\n+                    let mut n = &*start + &one;\n+                    mem::swap(&mut n, start);\n+\n+                    // if the iterator is done iterating, it will change from NonEmpty to Empty\n+                    // to avoid unnecessary drops or clones, we'll reuse either start or end\n+                    // (they are equal now, so it doesn't matter which)\n+                    // to pull out end, we need to swap something back in -- use the previously\n+                    // created A::one() as a dummy value\n+\n+                    (if n == *end { Some(mem::replace(end, one)) } else { None },\n+                    // ^ are we done yet?\n+                    Some(n)) // < the value to output\n+                } else {\n+                    (Some(mem::replace(start, A::one())), None)\n+                }\n+            }\n+        };\n+\n+        // turn into an empty iterator if this is the last value\n+        if let Some(end) = finishing {\n+            *self = Empty { at: end };\n+        }\n+\n+        n\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        use ops::RangeInclusive::*;\n+\n+        match *self {\n+            Empty { .. } => (0, Some(0)),\n+\n+            NonEmpty { ref start, ref end } =>\n+                match Step::steps_between(start, end, &A::one()) {\n+                    Some(hint) => (hint.saturating_add(1), hint.checked_add(1)),\n+                    None => (0, None),\n+                }\n+        }\n+    }\n+}\n+\n+#[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n+impl<A: Step + One> DoubleEndedIterator for ops::RangeInclusive<A> where\n+    for<'a> &'a A: Add<&'a A, Output = A>,\n+    for<'a> &'a A: Sub<&'a A, Output = A>\n+{\n+    #[inline]\n+    fn next_back(&mut self) -> Option<A> {\n+        use ops::RangeInclusive::*;\n+\n+        // see Iterator::next for comments\n+\n+        let (finishing, n) = match *self {\n+            Empty { .. } => return None,\n+\n+            NonEmpty { ref mut start, ref mut end } => {\n+                if start == end {\n+                    (Some(mem::replace(start, A::one())), Some(mem::replace(end, A::one())))\n+                } else if start < end {\n+                    let one = A::one();\n+                    let mut n = &*end - &one;\n+                    mem::swap(&mut n, end);\n+\n+                    (if n == *start { Some(mem::replace(start, one)) } else { None },\n+                     Some(n))\n+                } else {\n+                    (Some(mem::replace(end, A::one())), None)\n+                }\n+            }\n+        };\n+\n+        if let Some(start) = finishing {\n+            *self = Empty { at: start };\n+        }\n+\n+        n\n+    }\n+}\n+"}, {"sha": "ecd4a78b9e760000686fb8c50f51d7704d8eb31f", "filename": "src/libcore/iter/sources.rs", "status": "added", "additions": 270, "deletions": 0, "changes": 270, "blob_url": "https://github.com/rust-lang/rust/blob/d81de4871fbaf15198857af06b4f15fd4e1bfb13/src%2Flibcore%2Fiter%2Fsources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d81de4871fbaf15198857af06b4f15fd4e1bfb13/src%2Flibcore%2Fiter%2Fsources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fsources.rs?ref=d81de4871fbaf15198857af06b4f15fd4e1bfb13", "patch": "@@ -0,0 +1,270 @@\n+// Copyright 2013-2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use clone::Clone;\n+use default::Default;\n+use fmt;\n+use marker;\n+use option::Option::{self, Some, None};\n+use usize;\n+\n+use super::{DoubleEndedIterator, IntoIterator, Iterator, ExactSizeIterator};\n+\n+/// An iterator that repeats an element endlessly.\n+///\n+/// This `struct` is created by the [`repeat()`] function. See its documentation for more.\n+///\n+/// [`repeat()`]: fn.repeat.html\n+#[derive(Clone, Debug)]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct Repeat<A> {\n+    element: A\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<A: Clone> Iterator for Repeat<A> {\n+    type Item = A;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<A> { Some(self.element.clone()) }\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) { (usize::MAX, None) }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<A: Clone> DoubleEndedIterator for Repeat<A> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<A> { Some(self.element.clone()) }\n+}\n+\n+/// Creates a new iterator that endlessly repeats a single element.\n+///\n+/// The `repeat()` function repeats a single value over and over and over and\n+/// over and over and \ud83d\udd01.\n+///\n+/// Infinite iterators like `repeat()` are often used with adapters like\n+/// [`take()`], in order to make them finite.\n+///\n+/// [`take()`]: trait.Iterator.html#method.take\n+///\n+/// # Examples\n+///\n+/// Basic usage:\n+///\n+/// ```\n+/// use std::iter;\n+///\n+/// // the number four 4ever:\n+/// let mut fours = iter::repeat(4);\n+///\n+/// assert_eq!(Some(4), fours.next());\n+/// assert_eq!(Some(4), fours.next());\n+/// assert_eq!(Some(4), fours.next());\n+/// assert_eq!(Some(4), fours.next());\n+/// assert_eq!(Some(4), fours.next());\n+///\n+/// // yup, still four\n+/// assert_eq!(Some(4), fours.next());\n+/// ```\n+///\n+/// Going finite with [`take()`]:\n+///\n+/// ```\n+/// use std::iter;\n+///\n+/// // that last example was too many fours. Let's only have four fours.\n+/// let mut four_fours = iter::repeat(4).take(4);\n+///\n+/// assert_eq!(Some(4), four_fours.next());\n+/// assert_eq!(Some(4), four_fours.next());\n+/// assert_eq!(Some(4), four_fours.next());\n+/// assert_eq!(Some(4), four_fours.next());\n+///\n+/// // ... and now we're done\n+/// assert_eq!(None, four_fours.next());\n+/// ```\n+#[inline]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub fn repeat<T: Clone>(elt: T) -> Repeat<T> {\n+    Repeat{element: elt}\n+}\n+\n+/// An iterator that yields nothing.\n+///\n+/// This `struct` is created by the [`empty()`] function. See its documentation for more.\n+///\n+/// [`empty()`]: fn.empty.html\n+#[stable(feature = \"iter_empty\", since = \"1.2.0\")]\n+pub struct Empty<T>(marker::PhantomData<T>);\n+\n+#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n+impl<T> fmt::Debug for Empty<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.pad(\"Empty\")\n+    }\n+}\n+\n+#[stable(feature = \"iter_empty\", since = \"1.2.0\")]\n+impl<T> Iterator for Empty<T> {\n+    type Item = T;\n+\n+    fn next(&mut self) -> Option<T> {\n+        None\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>){\n+        (0, Some(0))\n+    }\n+}\n+\n+#[stable(feature = \"iter_empty\", since = \"1.2.0\")]\n+impl<T> DoubleEndedIterator for Empty<T> {\n+    fn next_back(&mut self) -> Option<T> {\n+        None\n+    }\n+}\n+\n+#[stable(feature = \"iter_empty\", since = \"1.2.0\")]\n+impl<T> ExactSizeIterator for Empty<T> {\n+    fn len(&self) -> usize {\n+        0\n+    }\n+}\n+\n+// not #[derive] because that adds a Clone bound on T,\n+// which isn't necessary.\n+#[stable(feature = \"iter_empty\", since = \"1.2.0\")]\n+impl<T> Clone for Empty<T> {\n+    fn clone(&self) -> Empty<T> {\n+        Empty(marker::PhantomData)\n+    }\n+}\n+\n+// not #[derive] because that adds a Default bound on T,\n+// which isn't necessary.\n+#[stable(feature = \"iter_empty\", since = \"1.2.0\")]\n+impl<T> Default for Empty<T> {\n+    fn default() -> Empty<T> {\n+        Empty(marker::PhantomData)\n+    }\n+}\n+\n+/// Creates an iterator that yields nothing.\n+///\n+/// # Examples\n+///\n+/// Basic usage:\n+///\n+/// ```\n+/// use std::iter;\n+///\n+/// // this could have been an iterator over i32, but alas, it's just not.\n+/// let mut nope = iter::empty::<i32>();\n+///\n+/// assert_eq!(None, nope.next());\n+/// ```\n+#[stable(feature = \"iter_empty\", since = \"1.2.0\")]\n+pub fn empty<T>() -> Empty<T> {\n+    Empty(marker::PhantomData)\n+}\n+\n+/// An iterator that yields an element exactly once.\n+///\n+/// This `struct` is created by the [`once()`] function. See its documentation for more.\n+///\n+/// [`once()`]: fn.once.html\n+#[derive(Clone, Debug)]\n+#[stable(feature = \"iter_once\", since = \"1.2.0\")]\n+pub struct Once<T> {\n+    inner: ::option::IntoIter<T>\n+}\n+\n+#[stable(feature = \"iter_once\", since = \"1.2.0\")]\n+impl<T> Iterator for Once<T> {\n+    type Item = T;\n+\n+    fn next(&mut self) -> Option<T> {\n+        self.inner.next()\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.inner.size_hint()\n+    }\n+}\n+\n+#[stable(feature = \"iter_once\", since = \"1.2.0\")]\n+impl<T> DoubleEndedIterator for Once<T> {\n+    fn next_back(&mut self) -> Option<T> {\n+        self.inner.next_back()\n+    }\n+}\n+\n+#[stable(feature = \"iter_once\", since = \"1.2.0\")]\n+impl<T> ExactSizeIterator for Once<T> {\n+    fn len(&self) -> usize {\n+        self.inner.len()\n+    }\n+}\n+\n+/// Creates an iterator that yields an element exactly once.\n+///\n+/// This is commonly used to adapt a single value into a [`chain()`] of other\n+/// kinds of iteration. Maybe you have an iterator that covers almost\n+/// everything, but you need an extra special case. Maybe you have a function\n+/// which works on iterators, but you only need to process one value.\n+///\n+/// [`chain()`]: trait.Iterator.html#method.chain\n+///\n+/// # Examples\n+///\n+/// Basic usage:\n+///\n+/// ```\n+/// use std::iter;\n+///\n+/// // one is the loneliest number\n+/// let mut one = iter::once(1);\n+///\n+/// assert_eq!(Some(1), one.next());\n+///\n+/// // just one, that's all we get\n+/// assert_eq!(None, one.next());\n+/// ```\n+///\n+/// Chaining together with another iterator. Let's say that we want to iterate\n+/// over each file of the `.foo` directory, but also a configuration file,\n+/// `.foorc`:\n+///\n+/// ```no_run\n+/// use std::iter;\n+/// use std::fs;\n+/// use std::path::PathBuf;\n+///\n+/// let dirs = fs::read_dir(\".foo\").unwrap();\n+///\n+/// // we need to convert from an iterator of DirEntry-s to an iterator of\n+/// // PathBufs, so we use map\n+/// let dirs = dirs.map(|file| file.unwrap().path());\n+///\n+/// // now, our iterator just for our config file\n+/// let config = iter::once(PathBuf::from(\".foorc\"));\n+///\n+/// // chain the two iterators together into one big iterator\n+/// let files = dirs.chain(config);\n+///\n+/// // this will give us all of the files in .foo as well as .foorc\n+/// for f in files {\n+///     println!(\"{:?}\", f);\n+/// }\n+/// ```\n+#[stable(feature = \"iter_once\", since = \"1.2.0\")]\n+pub fn once<T>(value: T) -> Once<T> {\n+    Once { inner: Some(value).into_iter() }\n+}"}, {"sha": "67503984450a45806a3af0bd1f8667397269a058", "filename": "src/libcore/iter/traits.rs", "status": "added", "additions": 526, "deletions": 0, "changes": 526, "blob_url": "https://github.com/rust-lang/rust/blob/d81de4871fbaf15198857af06b4f15fd4e1bfb13/src%2Flibcore%2Fiter%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d81de4871fbaf15198857af06b4f15fd4e1bfb13/src%2Flibcore%2Fiter%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits.rs?ref=d81de4871fbaf15198857af06b4f15fd4e1bfb13", "patch": "@@ -0,0 +1,526 @@\n+// Copyright 2013-2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use option::Option::{self, Some};\n+use marker::Sized;\n+\n+use super::Iterator;\n+\n+/// Conversion from an `Iterator`.\n+///\n+/// By implementing `FromIterator` for a type, you define how it will be\n+/// created from an iterator. This is common for types which describe a\n+/// collection of some kind.\n+///\n+/// `FromIterator`'s [`from_iter()`] is rarely called explicitly, and is instead\n+/// used through [`Iterator`]'s [`collect()`] method. See [`collect()`]'s\n+/// documentation for more examples.\n+///\n+/// [`from_iter()`]: #tymethod.from_iter\n+/// [`Iterator`]: trait.Iterator.html\n+/// [`collect()`]: trait.Iterator.html#method.collect\n+///\n+/// See also: [`IntoIterator`].\n+///\n+/// [`IntoIterator`]: trait.IntoIterator.html\n+///\n+/// # Examples\n+///\n+/// Basic usage:\n+///\n+/// ```\n+/// use std::iter::FromIterator;\n+///\n+/// let five_fives = std::iter::repeat(5).take(5);\n+///\n+/// let v = Vec::from_iter(five_fives);\n+///\n+/// assert_eq!(v, vec![5, 5, 5, 5, 5]);\n+/// ```\n+///\n+/// Using [`collect()`] to implicitly use `FromIterator`:\n+///\n+/// ```\n+/// let five_fives = std::iter::repeat(5).take(5);\n+///\n+/// let v: Vec<i32> = five_fives.collect();\n+///\n+/// assert_eq!(v, vec![5, 5, 5, 5, 5]);\n+/// ```\n+///\n+/// Implementing `FromIterator` for your type:\n+///\n+/// ```\n+/// use std::iter::FromIterator;\n+///\n+/// // A sample collection, that's just a wrapper over Vec<T>\n+/// #[derive(Debug)]\n+/// struct MyCollection(Vec<i32>);\n+///\n+/// // Let's give it some methods so we can create one and add things\n+/// // to it.\n+/// impl MyCollection {\n+///     fn new() -> MyCollection {\n+///         MyCollection(Vec::new())\n+///     }\n+///\n+///     fn add(&mut self, elem: i32) {\n+///         self.0.push(elem);\n+///     }\n+/// }\n+///\n+/// // and we'll implement FromIterator\n+/// impl FromIterator<i32> for MyCollection {\n+///     fn from_iter<I: IntoIterator<Item=i32>>(iter: I) -> Self {\n+///         let mut c = MyCollection::new();\n+///\n+///         for i in iter {\n+///             c.add(i);\n+///         }\n+///\n+///         c\n+///     }\n+/// }\n+///\n+/// // Now we can make a new iterator...\n+/// let iter = (0..5).into_iter();\n+///\n+/// // ... and make a MyCollection out of it\n+/// let c = MyCollection::from_iter(iter);\n+///\n+/// assert_eq!(c.0, vec![0, 1, 2, 3, 4]);\n+///\n+/// // collect works too!\n+///\n+/// let iter = (0..5).into_iter();\n+/// let c: MyCollection = iter.collect();\n+///\n+/// assert_eq!(c.0, vec![0, 1, 2, 3, 4]);\n+/// ```\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_on_unimplemented=\"a collection of type `{Self}` cannot be \\\n+                          built from an iterator over elements of type `{A}`\"]\n+pub trait FromIterator<A>: Sized {\n+    /// Creates a value from an iterator.\n+    ///\n+    /// See the [module-level documentation] for more.\n+    ///\n+    /// [module-level documentation]: trait.FromIterator.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// use std::iter::FromIterator;\n+    ///\n+    /// let five_fives = std::iter::repeat(5).take(5);\n+    ///\n+    /// let v = Vec::from_iter(five_fives);\n+    ///\n+    /// assert_eq!(v, vec![5, 5, 5, 5, 5]);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn from_iter<T: IntoIterator<Item=A>>(iter: T) -> Self;\n+}\n+\n+/// Conversion into an `Iterator`.\n+///\n+/// By implementing `IntoIterator` for a type, you define how it will be\n+/// converted to an iterator. This is common for types which describe a\n+/// collection of some kind.\n+///\n+/// One benefit of implementing `IntoIterator` is that your type will [work\n+/// with Rust's `for` loop syntax](index.html#for-loops-and-intoiterator).\n+///\n+/// See also: [`FromIterator`].\n+///\n+/// [`FromIterator`]: trait.FromIterator.html\n+///\n+/// # Examples\n+///\n+/// Basic usage:\n+///\n+/// ```\n+/// let v = vec![1, 2, 3];\n+///\n+/// let mut iter = v.into_iter();\n+///\n+/// let n = iter.next();\n+/// assert_eq!(Some(1), n);\n+///\n+/// let n = iter.next();\n+/// assert_eq!(Some(2), n);\n+///\n+/// let n = iter.next();\n+/// assert_eq!(Some(3), n);\n+///\n+/// let n = iter.next();\n+/// assert_eq!(None, n);\n+/// ```\n+///\n+/// Implementing `IntoIterator` for your type:\n+///\n+/// ```\n+/// // A sample collection, that's just a wrapper over Vec<T>\n+/// #[derive(Debug)]\n+/// struct MyCollection(Vec<i32>);\n+///\n+/// // Let's give it some methods so we can create one and add things\n+/// // to it.\n+/// impl MyCollection {\n+///     fn new() -> MyCollection {\n+///         MyCollection(Vec::new())\n+///     }\n+///\n+///     fn add(&mut self, elem: i32) {\n+///         self.0.push(elem);\n+///     }\n+/// }\n+///\n+/// // and we'll implement IntoIterator\n+/// impl IntoIterator for MyCollection {\n+///     type Item = i32;\n+///     type IntoIter = ::std::vec::IntoIter<i32>;\n+///\n+///     fn into_iter(self) -> Self::IntoIter {\n+///         self.0.into_iter()\n+///     }\n+/// }\n+///\n+/// // Now we can make a new collection...\n+/// let mut c = MyCollection::new();\n+///\n+/// // ... add some stuff to it ...\n+/// c.add(0);\n+/// c.add(1);\n+/// c.add(2);\n+///\n+/// // ... and then turn it into an Iterator:\n+/// for (i, n) in c.into_iter().enumerate() {\n+///     assert_eq!(i as i32, n);\n+/// }\n+/// ```\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub trait IntoIterator {\n+    /// The type of the elements being iterated over.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    type Item;\n+\n+    /// Which kind of iterator are we turning this into?\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    type IntoIter: Iterator<Item=Self::Item>;\n+\n+    /// Creates an iterator from a value.\n+    ///\n+    /// See the [module-level documentation] for more.\n+    ///\n+    /// [module-level documentation]: trait.IntoIterator.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let v = vec![1, 2, 3];\n+    ///\n+    /// let mut iter = v.into_iter();\n+    ///\n+    /// let n = iter.next();\n+    /// assert_eq!(Some(1), n);\n+    ///\n+    /// let n = iter.next();\n+    /// assert_eq!(Some(2), n);\n+    ///\n+    /// let n = iter.next();\n+    /// assert_eq!(Some(3), n);\n+    ///\n+    /// let n = iter.next();\n+    /// assert_eq!(None, n);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn into_iter(self) -> Self::IntoIter;\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I: Iterator> IntoIterator for I {\n+    type Item = I::Item;\n+    type IntoIter = I;\n+\n+    fn into_iter(self) -> I {\n+        self\n+    }\n+}\n+\n+/// Extend a collection with the contents of an iterator.\n+///\n+/// Iterators produce a series of values, and collections can also be thought\n+/// of as a series of values. The `Extend` trait bridges this gap, allowing you\n+/// to extend a collection by including the contents of that iterator.\n+///\n+/// # Examples\n+///\n+/// Basic usage:\n+///\n+/// ```\n+/// // You can extend a String with some chars:\n+/// let mut message = String::from(\"The first three letters are: \");\n+///\n+/// message.extend(&['a', 'b', 'c']);\n+///\n+/// assert_eq!(\"abc\", &message[29..32]);\n+/// ```\n+///\n+/// Implementing `Extend`:\n+///\n+/// ```\n+/// // A sample collection, that's just a wrapper over Vec<T>\n+/// #[derive(Debug)]\n+/// struct MyCollection(Vec<i32>);\n+///\n+/// // Let's give it some methods so we can create one and add things\n+/// // to it.\n+/// impl MyCollection {\n+///     fn new() -> MyCollection {\n+///         MyCollection(Vec::new())\n+///     }\n+///\n+///     fn add(&mut self, elem: i32) {\n+///         self.0.push(elem);\n+///     }\n+/// }\n+///\n+/// // since MyCollection has a list of i32s, we implement Extend for i32\n+/// impl Extend<i32> for MyCollection {\n+///\n+///     // This is a bit simpler with the concrete type signature: we can call\n+///     // extend on anything which can be turned into an Iterator which gives\n+///     // us i32s. Because we need i32s to put into MyCollection.\n+///     fn extend<T: IntoIterator<Item=i32>>(&mut self, iter: T) {\n+///\n+///         // The implementation is very straightforward: loop through the\n+///         // iterator, and add() each element to ourselves.\n+///         for elem in iter {\n+///             self.add(elem);\n+///         }\n+///     }\n+/// }\n+///\n+/// let mut c = MyCollection::new();\n+///\n+/// c.add(5);\n+/// c.add(6);\n+/// c.add(7);\n+///\n+/// // let's extend our collection with three more numbers\n+/// c.extend(vec![1, 2, 3]);\n+///\n+/// // we've added these elements onto the end\n+/// assert_eq!(\"MyCollection([5, 6, 7, 1, 2, 3])\", format!(\"{:?}\", c));\n+/// ```\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub trait Extend<A> {\n+    /// Extends a collection with the contents of an iterator.\n+    ///\n+    /// As this is the only method for this trait, the [trait-level] docs\n+    /// contain more details.\n+    ///\n+    /// [trait-level]: trait.Extend.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// // You can extend a String with some chars:\n+    /// let mut message = String::from(\"abc\");\n+    ///\n+    /// message.extend(['d', 'e', 'f'].iter());\n+    ///\n+    /// assert_eq!(\"abcdef\", &message);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn extend<T: IntoIterator<Item=A>>(&mut self, iter: T);\n+}\n+\n+/// An iterator able to yield elements from both ends.\n+///\n+/// Something that implements `DoubleEndedIterator` has one extra capability\n+/// over something that implements [`Iterator`]: the ability to also take\n+/// `Item`s from the back, as well as the front.\n+///\n+/// It is important to note that both back and forth work on the same range,\n+/// and do not cross: iteration is over when they meet in the middle.\n+///\n+/// In a similar fashion to the [`Iterator`] protocol, once a\n+/// `DoubleEndedIterator` returns `None` from a `next_back()`, calling it again\n+/// may or may not ever return `Some` again. `next()` and `next_back()` are\n+/// interchangable for this purpose.\n+///\n+/// [`Iterator`]: trait.Iterator.html\n+///\n+/// # Examples\n+///\n+/// Basic usage:\n+///\n+/// ```\n+/// let numbers = vec![1, 2, 3];\n+///\n+/// let mut iter = numbers.iter();\n+///\n+/// assert_eq!(Some(&1), iter.next());\n+/// assert_eq!(Some(&3), iter.next_back());\n+/// assert_eq!(Some(&2), iter.next_back());\n+/// assert_eq!(None, iter.next());\n+/// assert_eq!(None, iter.next_back());\n+/// ```\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub trait DoubleEndedIterator: Iterator {\n+    /// An iterator able to yield elements from both ends.\n+    ///\n+    /// As this is the only method for this trait, the [trait-level] docs\n+    /// contain more details.\n+    ///\n+    /// [trait-level]: trait.DoubleEndedIterator.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let numbers = vec![1, 2, 3];\n+    ///\n+    /// let mut iter = numbers.iter();\n+    ///\n+    /// assert_eq!(Some(&1), iter.next());\n+    /// assert_eq!(Some(&3), iter.next_back());\n+    /// assert_eq!(Some(&2), iter.next_back());\n+    /// assert_eq!(None, iter.next());\n+    /// assert_eq!(None, iter.next_back());\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn next_back(&mut self) -> Option<Self::Item>;\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, I: DoubleEndedIterator + ?Sized> DoubleEndedIterator for &'a mut I {\n+    fn next_back(&mut self) -> Option<I::Item> { (**self).next_back() }\n+}\n+\n+/// An iterator that knows its exact length.\n+///\n+/// Many [`Iterator`]s don't know how many times they will iterate, but some do.\n+/// If an iterator knows how many times it can iterate, providing access to\n+/// that information can be useful. For example, if you want to iterate\n+/// backwards, a good start is to know where the end is.\n+///\n+/// When implementing an `ExactSizeIterator`, You must also implement\n+/// [`Iterator`]. When doing so, the implementation of [`size_hint()`] *must*\n+/// return the exact size of the iterator.\n+///\n+/// [`Iterator`]: trait.Iterator.html\n+/// [`size_hint()`]: trait.Iterator.html#method.size_hint\n+///\n+/// The [`len()`] method has a default implementation, so you usually shouldn't\n+/// implement it. However, you may be able to provide a more performant\n+/// implementation than the default, so overriding it in this case makes sense.\n+///\n+/// [`len()`]: #method.len\n+///\n+/// # Examples\n+///\n+/// Basic usage:\n+///\n+/// ```\n+/// // a finite range knows exactly how many times it will iterate\n+/// let five = 0..5;\n+///\n+/// assert_eq!(5, five.len());\n+/// ```\n+///\n+/// In the [module level docs][moddocs], we implemented an [`Iterator`],\n+/// `Counter`. Let's implement `ExactSizeIterator` for it as well:\n+///\n+/// [moddocs]: index.html\n+///\n+/// ```\n+/// # struct Counter {\n+/// #     count: usize,\n+/// # }\n+/// # impl Counter {\n+/// #     fn new() -> Counter {\n+/// #         Counter { count: 0 }\n+/// #     }\n+/// # }\n+/// # impl Iterator for Counter {\n+/// #     type Item = usize;\n+/// #     fn next(&mut self) -> Option<usize> {\n+/// #         self.count += 1;\n+/// #         if self.count < 6 {\n+/// #             Some(self.count)\n+/// #         } else {\n+/// #             None\n+/// #         }\n+/// #     }\n+/// # }\n+/// impl ExactSizeIterator for Counter {\n+///     // We already have the number of iterations, so we can use it directly.\n+///     fn len(&self) -> usize {\n+///         self.count\n+///     }\n+/// }\n+///\n+/// // And now we can use it!\n+///\n+/// let counter = Counter::new();\n+///\n+/// assert_eq!(0, counter.len());\n+/// ```\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub trait ExactSizeIterator: Iterator {\n+    #[inline]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    /// Returns the exact number of times the iterator will iterate.\n+    ///\n+    /// This method has a default implementation, so you usually should not\n+    /// implement it directly. However, if you can provide a more efficient\n+    /// implementation, you can do so. See the [trait-level] docs for an\n+    /// example.\n+    ///\n+    /// This function has the same safety guarantees as the [`size_hint()`]\n+    /// function.\n+    ///\n+    /// [trait-level]: trait.ExactSizeIterator.html\n+    /// [`size_hint()`]: trait.Iterator.html#method.size_hint\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// // a finite range knows exactly how many times it will iterate\n+    /// let five = 0..5;\n+    ///\n+    /// assert_eq!(5, five.len());\n+    /// ```\n+    fn len(&self) -> usize {\n+        let (lower, upper) = self.size_hint();\n+        // Note: This assertion is overly defensive, but it checks the invariant\n+        // guaranteed by the trait. If this trait were rust-internal,\n+        // we could use debug_assert!; assert_eq! will check all Rust user\n+        // implementations too.\n+        assert_eq!(upper, Some(lower));\n+        lower\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, I: ExactSizeIterator + ?Sized> ExactSizeIterator for &'a mut I {}\n+"}, {"sha": "0a01cc91f0e30a05443633004f589f76fde33b63", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 148, "deletions": 70, "changes": 218, "blob_url": "https://github.com/rust-lang/rust/blob/d81de4871fbaf15198857af06b4f15fd4e1bfb13/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d81de4871fbaf15198857af06b4f15fd4e1bfb13/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=d81de4871fbaf15198857af06b4f15fd4e1bfb13", "patch": "@@ -62,6 +62,9 @@\n // in the HIR, especially for multiple identifiers.\n \n use hir;\n+use hir::map::Definitions;\n+use hir::map::definitions::DefPathData;\n+use hir::def_id::DefIndex;\n \n use std::collections::BTreeMap;\n use std::collections::HashMap;\n@@ -92,10 +95,20 @@ pub struct LoweringContext<'a> {\n     // A copy of cached_id, but is also set to an id while a node is lowered for\n     // the first time.\n     gensym_key: Cell<u32>,\n+    // We must keep the set of definitions up to date as we add nodes that\n+    // weren't in the AST.\n+    definitions: Option<&'a RefCell<Definitions>>,\n+    // As we walk the AST we must keep track of the current 'parent' def id (in\n+    // the form of a DefIndex) so that if we create a new node which introduces\n+    // a definition, then we can properly create the def id.\n+    parent_def: Cell<Option<DefIndex>>,\n }\n \n impl<'a, 'hir> LoweringContext<'a> {\n-    pub fn new(id_assigner: &'a NodeIdAssigner, c: Option<&Crate>) -> LoweringContext<'a> {\n+    pub fn new(id_assigner: &'a NodeIdAssigner,\n+               c: Option<&Crate>,\n+               defs: &'a RefCell<Definitions>)\n+               -> LoweringContext<'a> {\n         let crate_root = c.and_then(|c| {\n             if std_inject::no_core(c) {\n                 None\n@@ -113,6 +126,23 @@ impl<'a, 'hir> LoweringContext<'a> {\n             cached_id: Cell::new(0),\n             gensym_cache: RefCell::new(HashMap::new()),\n             gensym_key: Cell::new(0),\n+            definitions: Some(defs),\n+            parent_def: Cell::new(None),\n+        }\n+    }\n+\n+    // Only use this when you want a LoweringContext for testing and won't look\n+    // up def ids for anything created during lowering.\n+    pub fn testing_context(id_assigner: &'a NodeIdAssigner) -> LoweringContext<'a> {\n+        LoweringContext {\n+            crate_root: None,\n+            id_cache: RefCell::new(HashMap::new()),\n+            id_assigner: id_assigner,\n+            cached_id: Cell::new(0),\n+            gensym_cache: RefCell::new(HashMap::new()),\n+            gensym_key: Cell::new(0),\n+            definitions: None,\n+            parent_def: Cell::new(None),\n         }\n     }\n \n@@ -146,6 +176,25 @@ impl<'a, 'hir> LoweringContext<'a> {\n     fn diagnostic(&self) -> &Handler {\n         self.id_assigner.diagnostic()\n     }\n+\n+    fn with_parent_def<T, F: FnOnce() -> T>(&self, parent_id: NodeId, f: F) -> T {\n+        if self.definitions.is_none() {\n+            // This should only be used for testing.\n+            return f();\n+        }\n+\n+        let old_def = self.parent_def.get();\n+        self.parent_def.set(Some(self.get_def(parent_id)));\n+        let result = f();\n+        self.parent_def.set(old_def);\n+\n+        result\n+    }\n+\n+    fn get_def(&self, id: NodeId) -> DefIndex {\n+        let defs = self.definitions.unwrap().borrow();\n+        defs.opt_def_index(id).unwrap()\n+    }\n }\n \n // Utility fn for setting and unsetting the cached id.\n@@ -733,47 +782,51 @@ pub fn lower_item_kind(lctx: &LoweringContext, i: &ItemKind) -> hir::Item_ {\n }\n \n pub fn lower_trait_item(lctx: &LoweringContext, i: &TraitItem) -> hir::TraitItem {\n-    hir::TraitItem {\n-        id: i.id,\n-        name: i.ident.name,\n-        attrs: lower_attrs(lctx, &i.attrs),\n-        node: match i.node {\n-            TraitItemKind::Const(ref ty, ref default) => {\n-                hir::ConstTraitItem(lower_ty(lctx, ty),\n-                                    default.as_ref().map(|x| lower_expr(lctx, x)))\n-            }\n-            TraitItemKind::Method(ref sig, ref body) => {\n-                hir::MethodTraitItem(lower_method_sig(lctx, sig),\n-                                     body.as_ref().map(|x| lower_block(lctx, x)))\n-            }\n-            TraitItemKind::Type(ref bounds, ref default) => {\n-                hir::TypeTraitItem(lower_bounds(lctx, bounds),\n-                                   default.as_ref().map(|x| lower_ty(lctx, x)))\n-            }\n-        },\n-        span: i.span,\n-    }\n+    lctx.with_parent_def(i.id, || {\n+        hir::TraitItem {\n+            id: i.id,\n+            name: i.ident.name,\n+            attrs: lower_attrs(lctx, &i.attrs),\n+            node: match i.node {\n+                TraitItemKind::Const(ref ty, ref default) => {\n+                    hir::ConstTraitItem(lower_ty(lctx, ty),\n+                                        default.as_ref().map(|x| lower_expr(lctx, x)))\n+                }\n+                TraitItemKind::Method(ref sig, ref body) => {\n+                    hir::MethodTraitItem(lower_method_sig(lctx, sig),\n+                                         body.as_ref().map(|x| lower_block(lctx, x)))\n+                }\n+                TraitItemKind::Type(ref bounds, ref default) => {\n+                    hir::TypeTraitItem(lower_bounds(lctx, bounds),\n+                                       default.as_ref().map(|x| lower_ty(lctx, x)))\n+                }\n+            },\n+            span: i.span,\n+        }\n+    })\n }\n \n pub fn lower_impl_item(lctx: &LoweringContext, i: &ImplItem) -> hir::ImplItem {\n-    hir::ImplItem {\n-        id: i.id,\n-        name: i.ident.name,\n-        attrs: lower_attrs(lctx, &i.attrs),\n-        vis: lower_visibility(lctx, &i.vis),\n-        defaultness: lower_defaultness(lctx, i.defaultness),\n-        node: match i.node {\n-            ImplItemKind::Const(ref ty, ref expr) => {\n-                hir::ImplItemKind::Const(lower_ty(lctx, ty), lower_expr(lctx, expr))\n-            }\n-            ImplItemKind::Method(ref sig, ref body) => {\n-                hir::ImplItemKind::Method(lower_method_sig(lctx, sig), lower_block(lctx, body))\n-            }\n-            ImplItemKind::Type(ref ty) => hir::ImplItemKind::Type(lower_ty(lctx, ty)),\n-            ImplItemKind::Macro(..) => panic!(\"Shouldn't exist any more\"),\n-        },\n-        span: i.span,\n-    }\n+    lctx.with_parent_def(i.id, || {\n+        hir::ImplItem {\n+            id: i.id,\n+            name: i.ident.name,\n+            attrs: lower_attrs(lctx, &i.attrs),\n+            vis: lower_visibility(lctx, &i.vis),\n+            defaultness: lower_defaultness(lctx, i.defaultness),\n+            node: match i.node {\n+                ImplItemKind::Const(ref ty, ref expr) => {\n+                    hir::ImplItemKind::Const(lower_ty(lctx, ty), lower_expr(lctx, expr))\n+                }\n+                ImplItemKind::Method(ref sig, ref body) => {\n+                    hir::ImplItemKind::Method(lower_method_sig(lctx, sig), lower_block(lctx, body))\n+                }\n+                ImplItemKind::Type(ref ty) => hir::ImplItemKind::Type(lower_ty(lctx, ty)),\n+                ImplItemKind::Macro(..) => panic!(\"Shouldn't exist any more\"),\n+            },\n+            span: i.span,\n+        }\n+    })\n }\n \n pub fn lower_mod(lctx: &LoweringContext, m: &Mod) -> hir::Mod {\n@@ -831,7 +884,9 @@ pub fn lower_item_id(_lctx: &LoweringContext, i: &Item) -> hir::ItemId {\n }\n \n pub fn lower_item(lctx: &LoweringContext, i: &Item) -> hir::Item {\n-    let node = lower_item_kind(lctx, &i.node);\n+    let node = lctx.with_parent_def(i.id, || {\n+        lower_item_kind(lctx, &i.node)\n+    });\n \n     hir::Item {\n         id: i.id,\n@@ -844,21 +899,23 @@ pub fn lower_item(lctx: &LoweringContext, i: &Item) -> hir::Item {\n }\n \n pub fn lower_foreign_item(lctx: &LoweringContext, i: &ForeignItem) -> hir::ForeignItem {\n-    hir::ForeignItem {\n-        id: i.id,\n-        name: i.ident.name,\n-        attrs: lower_attrs(lctx, &i.attrs),\n-        node: match i.node {\n-            ForeignItemKind::Fn(ref fdec, ref generics) => {\n-                hir::ForeignItemFn(lower_fn_decl(lctx, fdec), lower_generics(lctx, generics))\n-            }\n-            ForeignItemKind::Static(ref t, m) => {\n-                hir::ForeignItemStatic(lower_ty(lctx, t), m)\n-            }\n-        },\n-        vis: lower_visibility(lctx, &i.vis),\n-        span: i.span,\n-    }\n+    lctx.with_parent_def(i.id, || {\n+        hir::ForeignItem {\n+            id: i.id,\n+            name: i.ident.name,\n+            attrs: lower_attrs(lctx, &i.attrs),\n+            node: match i.node {\n+                ForeignItemKind::Fn(ref fdec, ref generics) => {\n+                    hir::ForeignItemFn(lower_fn_decl(lctx, fdec), lower_generics(lctx, generics))\n+                }\n+                ForeignItemKind::Static(ref t, m) => {\n+                    hir::ForeignItemStatic(lower_ty(lctx, t), m)\n+                }\n+            },\n+            vis: lower_visibility(lctx, &i.vis),\n+            span: i.span,\n+        }\n+    })\n }\n \n pub fn lower_method_sig(lctx: &LoweringContext, sig: &MethodSig) -> hir::MethodSig {\n@@ -926,9 +983,11 @@ pub fn lower_pat(lctx: &LoweringContext, p: &Pat) -> P<hir::Pat> {\n         node: match p.node {\n             PatKind::Wild => hir::PatKind::Wild,\n             PatKind::Ident(ref binding_mode, pth1, ref sub) => {\n-                hir::PatKind::Ident(lower_binding_mode(lctx, binding_mode),\n-                              respan(pth1.span, lower_ident(lctx, pth1.node)),\n-                              sub.as_ref().map(|x| lower_pat(lctx, x)))\n+                lctx.with_parent_def(p.id, || {\n+                    hir::PatKind::Ident(lower_binding_mode(lctx, binding_mode),\n+                                  respan(pth1.span, lower_ident(lctx, pth1.node)),\n+                                  sub.as_ref().map(|x| lower_pat(lctx, x)))\n+                })\n             }\n             PatKind::Lit(ref e) => hir::PatKind::Lit(lower_expr(lctx, e)),\n             PatKind::TupleStruct(ref pth, ref pats) => {\n@@ -1202,9 +1261,11 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                                hir::MatchSource::Normal)\n             }\n             ExprKind::Closure(capture_clause, ref decl, ref body) => {\n-                hir::ExprClosure(lower_capture_clause(lctx, capture_clause),\n-                                 lower_fn_decl(lctx, decl),\n-                                 lower_block(lctx, body))\n+                lctx.with_parent_def(e.id, || {\n+                    hir::ExprClosure(lower_capture_clause(lctx, capture_clause),\n+                                     lower_fn_decl(lctx, decl),\n+                                     lower_block(lctx, body))\n+                })\n             }\n             ExprKind::Block(ref blk) => hir::ExprBlock(lower_block(lctx, blk)),\n             ExprKind::Assign(ref el, ref er) => {\n@@ -1602,7 +1663,12 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                     // `{ let _result = ...; _result }`\n                     // underscore prevents an unused_variables lint if the head diverges\n                     let result_ident = lctx.str_to_ident(\"_result\");\n-                    let let_stmt = stmt_let(lctx, e.span, false, result_ident, match_expr, None);\n+                    let let_stmt = stmt_let(lctx,\n+                                            e.span,\n+                                            false,\n+                                            result_ident,\n+                                            match_expr,\n+                                            None);\n                     let result = expr_ident(lctx, e.span, result_ident, None);\n                     let block = block_all(lctx, e.span, hir_vec![let_stmt], Some(result));\n                     // add the attributes to the outer returned expr node\n@@ -1655,7 +1721,8 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                             let err_ctor = expr_path(lctx, path, None);\n                             expr_call(lctx, e.span, err_ctor, hir_vec![from_expr], None)\n                         };\n-                        let err_pat = pat_err(lctx, e.span, pat_ident(lctx, e.span, err_ident));\n+                        let err_pat = pat_err(lctx, e.span,\n+                                              pat_ident(lctx, e.span, err_ident));\n                         let ret_expr = expr(lctx, e.span,\n                                             hir::Expr_::ExprRet(Some(err_expr)), None);\n \n@@ -1938,12 +2005,22 @@ fn pat_ident_binding_mode(lctx: &LoweringContext,\n                           bm: hir::BindingMode)\n                           -> P<hir::Pat> {\n     let pat_ident = hir::PatKind::Ident(bm,\n-                                  Spanned {\n-                                      span: span,\n-                                      node: ident,\n-                                  },\n-                                  None);\n-    pat(lctx, span, pat_ident)\n+                                        Spanned {\n+                                            span: span,\n+                                            node: ident,\n+                                        },\n+                                        None);\n+\n+    let pat = pat(lctx, span, pat_ident);\n+\n+    if let Some(defs) = lctx.definitions {\n+        let mut defs = defs.borrow_mut();\n+        defs.create_def_with_parent(lctx.parent_def.get(),\n+                                    pat.id,\n+                                    DefPathData::Binding(ident.name));\n+    }\n+\n+    pat\n }\n \n fn pat_wild(lctx: &LoweringContext, span: Span) -> P<hir::Pat> {\n@@ -2130,7 +2207,8 @@ mod test {\n         let ast_in = quote_expr!(&cx, in HEAP { foo() });\n         let ast_in = assigner.fold_expr(ast_in);\n \n-        let lctx = LoweringContext::new(&assigner, None);\n+        let lctx = LoweringContext::testing_context(&assigner);\n+\n         let hir1 = lower_expr(&lctx, &ast_if_let);\n         let hir2 = lower_expr(&lctx, &ast_if_let);\n         assert!(hir1 == hir2);"}, {"sha": "9f55f46541cfde4c007f99fb587ad0173e1cc42e", "filename": "src/librustc/hir/map/collector.rs", "status": "modified", "additions": 68, "deletions": 201, "changes": 269, "blob_url": "https://github.com/rust-lang/rust/blob/d81de4871fbaf15198857af06b4f15fd4e1bfb13/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d81de4871fbaf15198857af06b4f15fd4e1bfb13/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs?ref=d81de4871fbaf15198857af06b4f15fd4e1bfb13", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2015-2016 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -13,18 +13,16 @@ use super::MapEntry::*;\n \n use hir::*;\n use hir::intravisit::Visitor;\n-use hir::def_id::{CRATE_DEF_INDEX, DefId, DefIndex};\n+use hir::def_id::DefId;\n use middle::cstore::InlinedItem;\n use std::iter::repeat;\n-use syntax::ast::{NodeId, CRATE_NODE_ID, DUMMY_NODE_ID};\n+use syntax::ast::{NodeId, CRATE_NODE_ID};\n use syntax::codemap::Span;\n \n-/// A Visitor that walks over an AST and collects Node's into an AST\n-/// Map.\n+/// A Visitor that walks over the HIR and collects Node's into a HIR map.\n pub struct NodeCollector<'ast> {\n     pub krate: &'ast Crate,\n     pub map: Vec<MapEntry<'ast>>,\n-    pub definitions: Definitions,\n     pub parent_node: NodeId,\n }\n \n@@ -33,16 +31,10 @@ impl<'ast> NodeCollector<'ast> {\n         let mut collector = NodeCollector {\n             krate: krate,\n             map: vec![],\n-            definitions: Definitions::new(),\n             parent_node: CRATE_NODE_ID,\n         };\n         collector.insert_entry(CRATE_NODE_ID, RootCrate);\n \n-        let result = collector.create_def_with_parent(None, CRATE_NODE_ID, DefPathData::CrateRoot);\n-        assert_eq!(result, CRATE_DEF_INDEX);\n-\n-        collector.create_def_with_parent(Some(CRATE_DEF_INDEX), DUMMY_NODE_ID, DefPathData::Misc);\n-\n         collector\n     }\n \n@@ -51,53 +43,20 @@ impl<'ast> NodeCollector<'ast> {\n                   parent_node: NodeId,\n                   parent_def_path: DefPath,\n                   parent_def_id: DefId,\n-                  map: Vec<MapEntry<'ast>>,\n-                  definitions: Definitions)\n+                  map: Vec<MapEntry<'ast>>)\n                   -> NodeCollector<'ast> {\n         let mut collector = NodeCollector {\n             krate: krate,\n             map: map,\n             parent_node: parent_node,\n-            definitions: definitions,\n         };\n \n         assert_eq!(parent_def_path.krate, parent_def_id.krate);\n-        let root_path = Box::new(InlinedRootPath {\n-            data: parent_def_path.data,\n-            def_id: parent_def_id,\n-        });\n-\n         collector.insert_entry(parent_node, RootInlinedParent(parent));\n-        collector.create_def(parent_node, DefPathData::InlinedRoot(root_path));\n \n         collector\n     }\n \n-    fn parent_def(&self) -> Option<DefIndex> {\n-        let mut parent_node = Some(self.parent_node);\n-        while let Some(p) = parent_node {\n-            if let Some(q) = self.definitions.opt_def_index(p) {\n-                return Some(q);\n-            }\n-            parent_node = self.map[p as usize].parent_node();\n-        }\n-        None\n-    }\n-\n-    fn create_def(&mut self, node_id: NodeId, data: DefPathData) -> DefIndex {\n-        let parent_def = self.parent_def();\n-        debug!(\"create_def(node_id={:?}, data={:?}, parent_def={:?})\", node_id, data, parent_def);\n-        self.definitions.create_def_with_parent(parent_def, node_id, data)\n-    }\n-\n-    fn create_def_with_parent(&mut self,\n-                              parent: Option<DefIndex>,\n-                              node_id: NodeId,\n-                              data: DefPathData)\n-                              -> DefIndex {\n-        self.definitions.create_def_with_parent(parent, node_id, data)\n-    }\n-\n     fn insert_entry(&mut self, id: NodeId, entry: MapEntry<'ast>) {\n         debug!(\"ast_map: {:?} => {:?}\", id, entry);\n         let len = self.map.len();\n@@ -107,15 +66,17 @@ impl<'ast> NodeCollector<'ast> {\n         self.map[id as usize] = entry;\n     }\n \n-    fn insert_def(&mut self, id: NodeId, node: Node<'ast>, data: DefPathData) -> DefIndex {\n-        self.insert(id, node);\n-        self.create_def(id, data)\n-    }\n-\n     fn insert(&mut self, id: NodeId, node: Node<'ast>) {\n         let entry = MapEntry::from_node(self.parent_node, node);\n         self.insert_entry(id, entry);\n     }\n+\n+    fn with_parent<F: FnOnce(&mut Self)>(&mut self, parent_id: NodeId, f: F) {\n+        let parent_node = self.parent_node;\n+        self.parent_node = parent_id;\n+        f(self);\n+        self.parent_node = parent_node;\n+    }\n }\n \n impl<'ast> Visitor<'ast> for NodeCollector<'ast> {\n@@ -130,188 +91,104 @@ impl<'ast> Visitor<'ast> for NodeCollector<'ast> {\n     fn visit_item(&mut self, i: &'ast Item) {\n         debug!(\"visit_item: {:?}\", i);\n \n-        // Pick the def data. This need not be unique, but the more\n-        // information we encapsulate into\n-        let def_data = match i.node {\n-            ItemDefaultImpl(..) | ItemImpl(..) =>\n-                DefPathData::Impl,\n-            ItemEnum(..) | ItemStruct(..) | ItemTrait(..) |\n-            ItemExternCrate(..) | ItemForeignMod(..) | ItemTy(..) =>\n-                DefPathData::TypeNs(i.name),\n-            ItemMod(..) =>\n-                DefPathData::Module(i.name),\n-            ItemStatic(..) | ItemConst(..) | ItemFn(..) =>\n-                DefPathData::ValueNs(i.name),\n-            ItemUse(..) =>\n-                DefPathData::Misc,\n-        };\n-\n-        self.insert_def(i.id, NodeItem(i), def_data);\n+        self.insert(i.id, NodeItem(i));\n \n-        let parent_node = self.parent_node;\n-        self.parent_node = i.id;\n-\n-        match i.node {\n-            ItemImpl(..) => {}\n-            ItemEnum(ref enum_definition, _) => {\n-                for v in &enum_definition.variants {\n-                    let variant_def_index =\n-                        self.insert_def(v.node.data.id(),\n-                                        NodeVariant(v),\n-                                        DefPathData::EnumVariant(v.node.name));\n-\n-                    for field in v.node.data.fields() {\n-                        self.create_def_with_parent(\n-                            Some(variant_def_index),\n-                            field.id,\n-                            DefPathData::Field(field.name));\n+        self.with_parent(i.id, |this| {\n+            match i.node {\n+                ItemEnum(ref enum_definition, _) => {\n+                    for v in &enum_definition.variants {\n+                        this.insert(v.node.data.id(), NodeVariant(v));\n                     }\n                 }\n-            }\n-            ItemForeignMod(..) => {\n-            }\n-            ItemStruct(ref struct_def, _) => {\n-                // If this is a tuple-like struct, register the constructor.\n-                if !struct_def.is_struct() {\n-                    self.insert_def(struct_def.id(),\n-                                    NodeStructCtor(struct_def),\n-                                    DefPathData::StructCtor);\n-                }\n-\n-                for field in struct_def.fields() {\n-                    self.create_def(field.id, DefPathData::Field(field.name));\n+                ItemStruct(ref struct_def, _) => {\n+                    // If this is a tuple-like struct, register the constructor.\n+                    if !struct_def.is_struct() {\n+                        this.insert(struct_def.id(), NodeStructCtor(struct_def));\n+                    }\n                 }\n-            }\n-            ItemTrait(_, _, ref bounds, _) => {\n-                for b in bounds.iter() {\n-                    if let TraitTyParamBound(ref t, TraitBoundModifier::None) = *b {\n-                        self.insert(t.trait_ref.ref_id, NodeItem(i));\n+                ItemTrait(_, _, ref bounds, _) => {\n+                    for b in bounds.iter() {\n+                        if let TraitTyParamBound(ref t, TraitBoundModifier::None) = *b {\n+                            this.insert(t.trait_ref.ref_id, NodeItem(i));\n+                        }\n                     }\n                 }\n-            }\n-            ItemUse(ref view_path) => {\n-                match view_path.node {\n-                    ViewPathList(_, ref paths) => {\n-                        for path in paths {\n-                            self.insert(path.node.id(), NodeItem(i));\n+                ItemUse(ref view_path) => {\n+                    match view_path.node {\n+                        ViewPathList(_, ref paths) => {\n+                            for path in paths {\n+                                this.insert(path.node.id(), NodeItem(i));\n+                            }\n                         }\n+                        _ => ()\n                     }\n-                    _ => ()\n                 }\n+                _ => {}\n             }\n-            _ => {}\n-        }\n-        intravisit::walk_item(self, i);\n-        self.parent_node = parent_node;\n+            intravisit::walk_item(this, i);\n+        });\n     }\n \n     fn visit_foreign_item(&mut self, foreign_item: &'ast ForeignItem) {\n-        self.insert_def(foreign_item.id,\n-                        NodeForeignItem(foreign_item),\n-                        DefPathData::ValueNs(foreign_item.name));\n+        self.insert(foreign_item.id, NodeForeignItem(foreign_item));\n \n-        let parent_node = self.parent_node;\n-        self.parent_node = foreign_item.id;\n-        intravisit::walk_foreign_item(self, foreign_item);\n-        self.parent_node = parent_node;\n+        self.with_parent(foreign_item.id, |this| {\n+            intravisit::walk_foreign_item(this, foreign_item);\n+        });\n     }\n \n     fn visit_generics(&mut self, generics: &'ast Generics) {\n         for ty_param in generics.ty_params.iter() {\n-            self.insert_def(ty_param.id,\n-                            NodeTyParam(ty_param),\n-                            DefPathData::TypeParam(ty_param.name));\n+            self.insert(ty_param.id, NodeTyParam(ty_param));\n         }\n \n         intravisit::walk_generics(self, generics);\n     }\n \n     fn visit_trait_item(&mut self, ti: &'ast TraitItem) {\n-        let def_data = match ti.node {\n-            MethodTraitItem(..) | ConstTraitItem(..) => DefPathData::ValueNs(ti.name),\n-            TypeTraitItem(..) => DefPathData::TypeNs(ti.name),\n-        };\n-\n         self.insert(ti.id, NodeTraitItem(ti));\n-        self.create_def(ti.id, def_data);\n-\n-        let parent_node = self.parent_node;\n-        self.parent_node = ti.id;\n \n-        match ti.node {\n-            ConstTraitItem(_, Some(ref expr)) => {\n-                self.create_def(expr.id, DefPathData::Initializer);\n-            }\n-            _ => { }\n-        }\n-\n-        intravisit::walk_trait_item(self, ti);\n-\n-        self.parent_node = parent_node;\n+        self.with_parent(ti.id, |this| {\n+            intravisit::walk_trait_item(this, ti);\n+        });\n     }\n \n     fn visit_impl_item(&mut self, ii: &'ast ImplItem) {\n-        let def_data = match ii.node {\n-            ImplItemKind::Method(..) | ImplItemKind::Const(..) => DefPathData::ValueNs(ii.name),\n-            ImplItemKind::Type(..) => DefPathData::TypeNs(ii.name),\n-        };\n-\n-        self.insert_def(ii.id, NodeImplItem(ii), def_data);\n-\n-        let parent_node = self.parent_node;\n-        self.parent_node = ii.id;\n+        self.insert(ii.id, NodeImplItem(ii));\n \n-        match ii.node {\n-            ImplItemKind::Const(_, ref expr) => {\n-                self.create_def(expr.id, DefPathData::Initializer);\n-            }\n-            _ => { }\n-        }\n-\n-        intravisit::walk_impl_item(self, ii);\n-\n-        self.parent_node = parent_node;\n+        self.with_parent(ii.id, |this| {\n+            intravisit::walk_impl_item(this, ii);\n+        });\n     }\n \n     fn visit_pat(&mut self, pat: &'ast Pat) {\n-        let maybe_binding = match pat.node {\n-            PatKind::Ident(_, id, _) => Some(id.node),\n-            _ => None\n-        };\n-\n-        if let Some(id) = maybe_binding {\n-            self.insert_def(pat.id, NodeLocal(pat), DefPathData::Binding(id.name));\n+        let node = if let PatKind::Ident(..) = pat.node {\n+            NodeLocal(pat)\n         } else {\n-            self.insert(pat.id, NodePat(pat));\n-        }\n+            NodePat(pat)\n+        };\n+        self.insert(pat.id, node);\n \n-        let parent_node = self.parent_node;\n-        self.parent_node = pat.id;\n-        intravisit::walk_pat(self, pat);\n-        self.parent_node = parent_node;\n+        self.with_parent(pat.id, |this| {\n+            intravisit::walk_pat(this, pat);\n+        });\n     }\n \n     fn visit_expr(&mut self, expr: &'ast Expr) {\n         self.insert(expr.id, NodeExpr(expr));\n \n-        match expr.node {\n-            ExprClosure(..) => { self.create_def(expr.id, DefPathData::ClosureExpr); }\n-            _ => { }\n-        }\n-\n-        let parent_node = self.parent_node;\n-        self.parent_node = expr.id;\n-        intravisit::walk_expr(self, expr);\n-        self.parent_node = parent_node;\n+        self.with_parent(expr.id, |this| {\n+            intravisit::walk_expr(this, expr);\n+        });\n     }\n \n     fn visit_stmt(&mut self, stmt: &'ast Stmt) {\n         let id = stmt.node.id();\n         self.insert(id, NodeStmt(stmt));\n-        let parent_node = self.parent_node;\n-        self.parent_node = id;\n-        intravisit::walk_stmt(self, stmt);\n-        self.parent_node = parent_node;\n+\n+        self.with_parent(id, |this| {\n+            intravisit::walk_stmt(this, stmt);\n+        });\n     }\n \n     fn visit_fn(&mut self, fk: intravisit::FnKind<'ast>, fd: &'ast FnDecl,\n@@ -322,22 +199,12 @@ impl<'ast> Visitor<'ast> for NodeCollector<'ast> {\n \n     fn visit_block(&mut self, block: &'ast Block) {\n         self.insert(block.id, NodeBlock(block));\n-        let parent_node = self.parent_node;\n-        self.parent_node = block.id;\n-        intravisit::walk_block(self, block);\n-        self.parent_node = parent_node;\n+        self.with_parent(block.id, |this| {\n+            intravisit::walk_block(this, block);\n+        });\n     }\n \n     fn visit_lifetime(&mut self, lifetime: &'ast Lifetime) {\n         self.insert(lifetime.id, NodeLifetime(lifetime));\n     }\n-\n-    fn visit_lifetime_def(&mut self, def: &'ast LifetimeDef) {\n-        self.create_def(def.lifetime.id, DefPathData::LifetimeDef(def.lifetime.name));\n-        self.visit_lifetime(&def.lifetime);\n-    }\n-\n-    fn visit_macro_def(&mut self, macro_def: &'ast MacroDef) {\n-        self.create_def(macro_def.id, DefPathData::MacroDef(macro_def.name));\n-    }\n }"}, {"sha": "053d32305be03328c5396f4ac06acc9157e7840f", "filename": "src/librustc/hir/map/def_collector.rs", "status": "added", "additions": 384, "deletions": 0, "changes": 384, "blob_url": "https://github.com/rust-lang/rust/blob/d81de4871fbaf15198857af06b4f15fd4e1bfb13/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d81de4871fbaf15198857af06b4f15fd4e1bfb13/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs?ref=d81de4871fbaf15198857af06b4f15fd4e1bfb13", "patch": "@@ -0,0 +1,384 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use super::*;\n+\n+use hir;\n+use hir::intravisit;\n+use hir::def_id::{CRATE_DEF_INDEX, DefId, DefIndex};\n+\n+use middle::cstore::InlinedItem;\n+\n+use syntax::ast::*;\n+use syntax::visit;\n+use syntax::parse::token;\n+\n+/// Creates def ids for nodes in the HIR.\n+pub struct DefCollector<'ast> {\n+    // If we are walking HIR (c.f., AST), we need to keep a reference to the\n+    // crate.\n+    hir_crate: Option<&'ast hir::Crate>,\n+    pub definitions: Definitions,\n+    parent_def: Option<DefIndex>,\n+}\n+\n+impl<'ast> DefCollector<'ast> {\n+    pub fn root() -> DefCollector<'ast> {\n+        let mut collector = DefCollector {\n+            hir_crate: None,\n+            definitions: Definitions::new(),\n+            parent_def: None,\n+        };\n+        let root = collector.create_def_with_parent(None, CRATE_NODE_ID, DefPathData::CrateRoot);\n+        assert_eq!(root, CRATE_DEF_INDEX);\n+        collector.parent_def = Some(root);\n+\n+        collector.create_def_with_parent(Some(CRATE_DEF_INDEX), DUMMY_NODE_ID, DefPathData::Misc);\n+\n+        collector\n+    }\n+\n+    pub fn extend(parent_node: NodeId,\n+                  parent_def_path: DefPath,\n+                  parent_def_id: DefId,\n+                  definitions: Definitions)\n+                  -> DefCollector<'ast> {\n+        let mut collector = DefCollector {\n+            hir_crate: None,\n+            parent_def: None,\n+            definitions: definitions,\n+        };\n+\n+        assert_eq!(parent_def_path.krate, parent_def_id.krate);\n+        let root_path = Box::new(InlinedRootPath {\n+            data: parent_def_path.data,\n+            def_id: parent_def_id,\n+        });\n+\n+        let def = collector.create_def(parent_node, DefPathData::InlinedRoot(root_path));\n+        collector.parent_def = Some(def);\n+\n+        collector\n+    }\n+\n+    pub fn walk_item(&mut self, ii: &'ast InlinedItem, krate: &'ast hir::Crate) {\n+        self.hir_crate = Some(krate);\n+        ii.visit(self);\n+    }\n+\n+    fn parent_def(&self) -> Option<DefIndex> {\n+        self.parent_def\n+    }\n+\n+    fn create_def(&mut self, node_id: NodeId, data: DefPathData) -> DefIndex {\n+        let parent_def = self.parent_def();\n+        debug!(\"create_def(node_id={:?}, data={:?}, parent_def={:?})\", node_id, data, parent_def);\n+        self.definitions.create_def_with_parent(parent_def, node_id, data)\n+    }\n+\n+    fn create_def_with_parent(&mut self,\n+                              parent: Option<DefIndex>,\n+                              node_id: NodeId,\n+                              data: DefPathData)\n+                              -> DefIndex {\n+        self.definitions.create_def_with_parent(parent, node_id, data)\n+    }\n+\n+    fn with_parent<F: FnOnce(&mut Self)>(&mut self, parent_def: DefIndex, f: F) {\n+        let parent = self.parent_def;\n+        self.parent_def = Some(parent_def);\n+        f(self);\n+        self.parent_def = parent;\n+    }\n+}\n+\n+impl<'ast> visit::Visitor<'ast> for DefCollector<'ast> {\n+    fn visit_item(&mut self, i: &'ast Item) {\n+        debug!(\"visit_item: {:?}\", i);\n+\n+        // Pick the def data. This need not be unique, but the more\n+        // information we encapsulate into\n+        let def_data = match i.node {\n+            ItemKind::DefaultImpl(..) | ItemKind::Impl(..) =>\n+                DefPathData::Impl,\n+            ItemKind::Enum(..) | ItemKind::Struct(..) | ItemKind::Trait(..) |\n+            ItemKind::ExternCrate(..) | ItemKind::ForeignMod(..) | ItemKind::Ty(..) =>\n+                DefPathData::TypeNs(i.ident.name),\n+            ItemKind::Mod(..) => DefPathData::Module(i.ident.name),\n+            ItemKind::Static(..) | ItemKind::Const(..) | ItemKind::Fn(..) =>\n+                DefPathData::ValueNs(i.ident.name),\n+            ItemKind::Mac(..) => DefPathData::MacroDef(i.ident.name),\n+            ItemKind::Use(..) => DefPathData::Misc,\n+        };\n+        let def = self.create_def(i.id, def_data);\n+\n+        self.with_parent(def, |this| {\n+            match i.node {\n+                ItemKind::Enum(ref enum_definition, _) => {\n+                    for v in &enum_definition.variants {\n+                        let variant_def_index =\n+                            this.create_def(v.node.data.id(),\n+                                            DefPathData::EnumVariant(v.node.name.name));\n+\n+                        for (index, field) in v.node.data.fields().iter().enumerate() {\n+                            let name = field.ident.map(|ident| ident.name)\n+                                .unwrap_or(token::intern(&index.to_string()));\n+                            this.create_def_with_parent(Some(variant_def_index),\n+                                                        field.id,\n+                                                        DefPathData::Field(name));\n+                        }\n+                    }\n+                }\n+                ItemKind::Struct(ref struct_def, _) => {\n+                    // If this is a tuple-like struct, register the constructor.\n+                    if !struct_def.is_struct() {\n+                        this.create_def(struct_def.id(),\n+                                        DefPathData::StructCtor);\n+                    }\n+\n+                    for (index, field) in struct_def.fields().iter().enumerate() {\n+                        let name = field.ident.map(|ident| ident.name)\n+                            .unwrap_or(token::intern(&index.to_string()));\n+                        this.create_def(field.id, DefPathData::Field(name));\n+                    }\n+                }\n+                _ => {}\n+            }\n+            visit::walk_item(this, i);\n+        });\n+    }\n+\n+    fn visit_foreign_item(&mut self, foreign_item: &'ast ForeignItem) {\n+        let def = self.create_def(foreign_item.id, DefPathData::ValueNs(foreign_item.ident.name));\n+\n+        self.with_parent(def, |this| {\n+            visit::walk_foreign_item(this, foreign_item);\n+        });\n+    }\n+\n+    fn visit_generics(&mut self, generics: &'ast Generics) {\n+        for ty_param in generics.ty_params.iter() {\n+            self.create_def(ty_param.id, DefPathData::TypeParam(ty_param.ident.name));\n+        }\n+\n+        visit::walk_generics(self, generics);\n+    }\n+\n+    fn visit_trait_item(&mut self, ti: &'ast TraitItem) {\n+        let def_data = match ti.node {\n+            TraitItemKind::Method(..) | TraitItemKind::Const(..) =>\n+                DefPathData::ValueNs(ti.ident.name),\n+            TraitItemKind::Type(..) => DefPathData::TypeNs(ti.ident.name),\n+        };\n+\n+        let def = self.create_def(ti.id, def_data);\n+        self.with_parent(def, |this| {\n+            if let TraitItemKind::Const(_, Some(ref expr)) = ti.node {\n+                this.create_def(expr.id, DefPathData::Initializer);\n+            }\n+\n+            visit::walk_trait_item(this, ti);\n+        });\n+    }\n+\n+    fn visit_impl_item(&mut self, ii: &'ast ImplItem) {\n+        let def_data = match ii.node {\n+            ImplItemKind::Method(..) | ImplItemKind::Const(..) =>\n+                DefPathData::ValueNs(ii.ident.name),\n+            ImplItemKind::Type(..) => DefPathData::TypeNs(ii.ident.name),\n+            ImplItemKind::Macro(..) => DefPathData::MacroDef(ii.ident.name),\n+        };\n+\n+        let def = self.create_def(ii.id, def_data);\n+        self.with_parent(def, |this| {\n+            if let ImplItemKind::Const(_, ref expr) = ii.node {\n+                this.create_def(expr.id, DefPathData::Initializer);\n+            }\n+\n+            visit::walk_impl_item(this, ii);\n+        });\n+    }\n+\n+    fn visit_pat(&mut self, pat: &'ast Pat) {\n+        let parent_def = self.parent_def;\n+\n+        if let PatKind::Ident(_, id, _) = pat.node {\n+            let def = self.create_def(pat.id, DefPathData::Binding(id.node.name));\n+            self.parent_def = Some(def);\n+        }\n+\n+        visit::walk_pat(self, pat);\n+        self.parent_def = parent_def;\n+    }\n+\n+    fn visit_expr(&mut self, expr: &'ast Expr) {\n+        let parent_def = self.parent_def;\n+\n+        if let ExprKind::Closure(..) = expr.node {\n+            let def = self.create_def(expr.id, DefPathData::ClosureExpr);\n+            self.parent_def = Some(def);\n+        }\n+\n+        visit::walk_expr(self, expr);\n+        self.parent_def = parent_def;\n+    }\n+\n+    fn visit_lifetime_def(&mut self, def: &'ast LifetimeDef) {\n+        self.create_def(def.lifetime.id, DefPathData::LifetimeDef(def.lifetime.name));\n+    }\n+\n+    fn visit_macro_def(&mut self, macro_def: &'ast MacroDef) {\n+        self.create_def(macro_def.id, DefPathData::MacroDef(macro_def.ident.name));\n+    }\n+}\n+\n+// We walk the HIR rather than the AST when reading items from metadata.\n+impl<'ast> intravisit::Visitor<'ast> for DefCollector<'ast> {\n+    /// Because we want to track parent items and so forth, enable\n+    /// deep walking so that we walk nested items in the context of\n+    /// their outer items.\n+    fn visit_nested_item(&mut self, item_id: hir::ItemId) {\n+        debug!(\"visit_nested_item: {:?}\", item_id);\n+        let item = self.hir_crate.unwrap().item(item_id.id);\n+        self.visit_item(item)\n+    }\n+\n+    fn visit_item(&mut self, i: &'ast hir::Item) {\n+        debug!(\"visit_item: {:?}\", i);\n+\n+        // Pick the def data. This need not be unique, but the more\n+        // information we encapsulate into\n+        let def_data = match i.node {\n+            hir::ItemDefaultImpl(..) | hir::ItemImpl(..) =>\n+                DefPathData::Impl,\n+            hir::ItemEnum(..) | hir::ItemStruct(..) | hir::ItemTrait(..) |\n+            hir::ItemExternCrate(..) | hir::ItemMod(..) | hir::ItemForeignMod(..) |\n+            hir::ItemTy(..) =>\n+                DefPathData::TypeNs(i.name),\n+            hir::ItemStatic(..) | hir::ItemConst(..) | hir::ItemFn(..) =>\n+                DefPathData::ValueNs(i.name),\n+            hir::ItemUse(..) => DefPathData::Misc,\n+        };\n+        let def = self.create_def(i.id, def_data);\n+\n+        self.with_parent(def, |this| {\n+            match i.node {\n+                hir::ItemEnum(ref enum_definition, _) => {\n+                    for v in &enum_definition.variants {\n+                        let variant_def_index =\n+                            this.create_def(v.node.data.id(),\n+                                            DefPathData::EnumVariant(v.node.name));\n+\n+                        for field in v.node.data.fields() {\n+                            this.create_def_with_parent(Some(variant_def_index),\n+                                                        field.id,\n+                                                        DefPathData::Field(field.name));\n+                        }\n+                    }\n+                }\n+                hir::ItemStruct(ref struct_def, _) => {\n+                    // If this is a tuple-like struct, register the constructor.\n+                    if !struct_def.is_struct() {\n+                        this.create_def(struct_def.id(),\n+                                        DefPathData::StructCtor);\n+                    }\n+\n+                    for field in struct_def.fields() {\n+                        this.create_def(field.id, DefPathData::Field(field.name));\n+                    }\n+                }\n+                _ => {}\n+            }\n+            intravisit::walk_item(this, i);\n+        });\n+    }\n+\n+    fn visit_foreign_item(&mut self, foreign_item: &'ast hir::ForeignItem) {\n+        let def = self.create_def(foreign_item.id, DefPathData::ValueNs(foreign_item.name));\n+\n+        self.with_parent(def, |this| {\n+            intravisit::walk_foreign_item(this, foreign_item);\n+        });\n+    }\n+\n+    fn visit_generics(&mut self, generics: &'ast hir::Generics) {\n+        for ty_param in generics.ty_params.iter() {\n+            self.create_def(ty_param.id, DefPathData::TypeParam(ty_param.name));\n+        }\n+\n+        intravisit::walk_generics(self, generics);\n+    }\n+\n+    fn visit_trait_item(&mut self, ti: &'ast hir::TraitItem) {\n+        let def_data = match ti.node {\n+            hir::MethodTraitItem(..) | hir::ConstTraitItem(..) =>\n+                DefPathData::ValueNs(ti.name),\n+            hir::TypeTraitItem(..) => DefPathData::TypeNs(ti.name),\n+        };\n+\n+        let def = self.create_def(ti.id, def_data);\n+        self.with_parent(def, |this| {\n+            if let hir::ConstTraitItem(_, Some(ref expr)) = ti.node {\n+                this.create_def(expr.id, DefPathData::Initializer);\n+            }\n+\n+            intravisit::walk_trait_item(this, ti);\n+        });\n+    }\n+\n+    fn visit_impl_item(&mut self, ii: &'ast hir::ImplItem) {\n+        let def_data = match ii.node {\n+            hir::ImplItemKind::Method(..) | hir::ImplItemKind::Const(..) =>\n+                DefPathData::ValueNs(ii.name),\n+            hir::ImplItemKind::Type(..) => DefPathData::TypeNs(ii.name),\n+        };\n+\n+        let def = self.create_def(ii.id, def_data);\n+        self.with_parent(def, |this| {\n+            if let hir::ImplItemKind::Const(_, ref expr) = ii.node {\n+                this.create_def(expr.id, DefPathData::Initializer);\n+            }\n+\n+            intravisit::walk_impl_item(this, ii);\n+        });\n+    }\n+\n+    fn visit_pat(&mut self, pat: &'ast hir::Pat) {\n+        let parent_def = self.parent_def;\n+\n+        if let hir::PatKind::Ident(_, id, _) = pat.node {\n+            let def = self.create_def(pat.id, DefPathData::Binding(id.node.name));\n+            self.parent_def = Some(def);\n+        }\n+\n+        intravisit::walk_pat(self, pat);\n+        self.parent_def = parent_def;\n+    }\n+\n+    fn visit_expr(&mut self, expr: &'ast hir::Expr) {\n+        let parent_def = self.parent_def;\n+\n+        if let hir::ExprClosure(..) = expr.node {\n+            let def = self.create_def(expr.id, DefPathData::ClosureExpr);\n+            self.parent_def = Some(def);\n+        }\n+\n+        intravisit::walk_expr(self, expr);\n+        self.parent_def = parent_def;\n+    }\n+\n+    fn visit_lifetime_def(&mut self, def: &'ast hir::LifetimeDef) {\n+        self.create_def(def.lifetime.id, DefPathData::LifetimeDef(def.lifetime.name));\n+    }\n+\n+    fn visit_macro_def(&mut self, macro_def: &'ast hir::MacroDef) {\n+        self.create_def(macro_def.id, DefPathData::MacroDef(macro_def.name));\n+    }\n+}\n\\ No newline at end of file"}, {"sha": "92f8c9249c842937e45b55585d16faf9489aed80", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 33, "deletions": 21, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/d81de4871fbaf15198857af06b4f15fd4e1bfb13/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d81de4871fbaf15198857af06b4f15fd4e1bfb13/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=d81de4871fbaf15198857af06b4f15fd4e1bfb13", "patch": "@@ -11,6 +11,7 @@\n pub use self::Node::*;\n use self::MapEntry::*;\n use self::collector::NodeCollector;\n+use self::def_collector::DefCollector;\n pub use self::definitions::{Definitions, DefKey, DefPath, DefPathData,\n                             DisambiguatedDefPathData, InlinedRootPath};\n \n@@ -21,9 +22,10 @@ use middle::cstore::InlinedItem as II;\n use hir::def_id::{CRATE_DEF_INDEX, DefId};\n \n use syntax::abi::Abi;\n-use syntax::ast::{self, Name, NodeId, DUMMY_NODE_ID};\n+use syntax::ast::{self, Name, NodeId, DUMMY_NODE_ID, };\n use syntax::attr::ThinAttributesExt;\n use syntax::codemap::{Span, Spanned};\n+use syntax::visit;\n \n use hir::*;\n use hir::fold::Folder;\n@@ -36,6 +38,7 @@ use std::mem;\n \n pub mod blocks;\n mod collector;\n+mod def_collector;\n pub mod definitions;\n \n #[derive(Copy, Clone, Debug)]\n@@ -193,7 +196,7 @@ pub struct Map<'ast> {\n     /// plain old integers.\n     map: RefCell<Vec<MapEntry<'ast>>>,\n \n-    definitions: RefCell<Definitions>,\n+    definitions: &'ast RefCell<Definitions>,\n }\n \n impl<'ast> Map<'ast> {\n@@ -780,12 +783,18 @@ impl<F: FoldOps> Folder for IdAndSpanUpdater<F> {\n     }\n }\n \n-pub fn map_crate<'ast>(forest: &'ast mut Forest) -> Map<'ast> {\n-    let (map, definitions) = {\n-        let mut collector = NodeCollector::root(&forest.krate);\n-        intravisit::walk_crate(&mut collector, &forest.krate);\n-        (collector.map, collector.definitions)\n-    };\n+pub fn collect_definitions<'ast>(krate: &'ast ast::Crate) -> Definitions {\n+    let mut def_collector = DefCollector::root();\n+    visit::walk_crate(&mut def_collector, krate);\n+    def_collector.definitions\n+}\n+\n+pub fn map_crate<'ast>(forest: &'ast mut Forest,\n+                       definitions: &'ast RefCell<Definitions>)\n+                       -> Map<'ast> {\n+    let mut collector = NodeCollector::root(&forest.krate);\n+    intravisit::walk_crate(&mut collector, &forest.krate);\n+    let map = collector.map;\n \n     if log_enabled!(::log::DEBUG) {\n         // This only makes sense for ordered stores; note the\n@@ -807,7 +816,7 @@ pub fn map_crate<'ast>(forest: &'ast mut Forest) -> Map<'ast> {\n         forest: forest,\n         dep_graph: forest.dep_graph.clone(),\n         map: RefCell::new(map),\n-        definitions: RefCell::new(definitions),\n+        definitions: definitions,\n     }\n }\n \n@@ -834,21 +843,24 @@ pub fn map_decoded_item<'ast, F: FoldOps>(map: &Map<'ast>,\n     };\n \n     let ii = map.forest.inlined_items.alloc(ii);\n-\n     let ii_parent_id = fld.new_id(DUMMY_NODE_ID);\n-    let mut collector =\n-        NodeCollector::extend(\n-            map.krate(),\n-            ii,\n-            ii_parent_id,\n-            parent_def_path,\n-            parent_def_id,\n-            mem::replace(&mut *map.map.borrow_mut(), vec![]),\n-            mem::replace(&mut *map.definitions.borrow_mut(), Definitions::new()));\n-    ii.visit(&mut collector);\n \n+    let defs = mem::replace(&mut *map.definitions.borrow_mut(), Definitions::new());\n+    let mut def_collector = DefCollector::extend(ii_parent_id,\n+                                                 parent_def_path.clone(),\n+                                                 parent_def_id,\n+                                                 defs);\n+    def_collector.walk_item(ii, map.krate());\n+    *map.definitions.borrow_mut() = def_collector.definitions;\n+\n+    let mut collector = NodeCollector::extend(map.krate(),\n+                                              ii,\n+                                              ii_parent_id,\n+                                              parent_def_path,\n+                                              parent_def_id,\n+                                              mem::replace(&mut *map.map.borrow_mut(), vec![]));\n+    ii.visit(&mut collector);\n     *map.map.borrow_mut() = collector.map;\n-    *map.definitions.borrow_mut() = collector.definitions;\n \n     ii\n }"}, {"sha": "09383e69553beae1fc5d8fbe2d92ead358352451", "filename": "src/librustc/mir/repr.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d81de4871fbaf15198857af06b4f15fd4e1bfb13/src%2Flibrustc%2Fmir%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d81de4871fbaf15198857af06b4f15fd4e1bfb13/src%2Flibrustc%2Fmir%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Frepr.rs?ref=d81de4871fbaf15198857af06b4f15fd4e1bfb13", "patch": "@@ -63,9 +63,6 @@ pub struct Mir<'tcx> {\n /// where execution begins\n pub const START_BLOCK: BasicBlock = BasicBlock(0);\n \n-/// where execution ends, on normal return\n-pub const END_BLOCK: BasicBlock = BasicBlock(1);\n-\n impl<'tcx> Mir<'tcx> {\n     pub fn all_basic_blocks(&self) -> Vec<BasicBlock> {\n         (0..self.basic_blocks.len())\n@@ -322,8 +319,7 @@ pub enum TerminatorKind<'tcx> {\n     Resume,\n \n     /// Indicates a normal return. The ReturnPointer lvalue should\n-    /// have been filled in by now. This should only occur in the\n-    /// `END_BLOCK`.\n+    /// have been filled in by now. This should occur at most once.\n     Return,\n \n     /// Drop the Lvalue"}, {"sha": "5fc2a955c0602ed5a713413065f5c2abe7f0018a", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 26, "deletions": 24, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/d81de4871fbaf15198857af06b4f15fd4e1bfb13/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d81de4871fbaf15198857af06b4f15fd4e1bfb13/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=d81de4871fbaf15198857af06b4f15fd4e1bfb13", "patch": "@@ -43,6 +43,7 @@ use super::Compilation;\n \n use serialize::json;\n \n+use std::cell::RefCell;\n use std::collections::HashMap;\n use std::env;\n use std::ffi::{OsString, OsStr};\n@@ -120,13 +121,24 @@ pub fn compile_input(sess: &Session,\n                                 Ok(()));\n \n         let expanded_crate = assign_node_ids(sess, expanded_crate);\n-        // Lower ast -> hir.\n-        let lcx = LoweringContext::new(sess, Some(&expanded_crate));\n         let dep_graph = DepGraph::new(sess.opts.build_dep_graph());\n-        let mut hir_forest = time(sess.time_passes(),\n-                                  \"lowering ast -> hir\",\n-                                  || hir_map::Forest::new(lower_crate(&lcx, &expanded_crate),\n-                                                          dep_graph));\n+\n+        // Collect defintions for def ids.\n+        let defs = &RefCell::new(time(sess.time_passes(),\n+                                 \"collecting defs\",\n+                                 || hir_map::collect_definitions(&expanded_crate)));\n+\n+        time(sess.time_passes(),\n+             \"external crate/lib resolution\",\n+             || LocalCrateReader::new(sess, &cstore, &defs, &expanded_crate, &id)\n+                    .read_crates(&dep_graph));\n+\n+        // Lower ast -> hir.\n+        let lcx = LoweringContext::new(sess, Some(&expanded_crate), defs);\n+        let hir_forest = &mut time(sess.time_passes(),\n+                                   \"lowering ast -> hir\",\n+                                   || hir_map::Forest::new(lower_crate(&lcx, &expanded_crate),\n+                                                           dep_graph));\n \n         // Discard MTWT tables that aren't required past lowering to HIR.\n         if !sess.opts.debugging_opts.keep_mtwt_tables &&\n@@ -135,7 +147,12 @@ pub fn compile_input(sess: &Session,\n         }\n \n         let arenas = ty::CtxtArenas::new();\n-        let hir_map = make_map(sess, &mut hir_forest);\n+\n+        // Construct the HIR map\n+        let hir_map = time(sess.time_passes(),\n+                           \"indexing hir\",\n+                           move || hir_map::map_crate(hir_forest, defs));\n+\n \n         write_out_deps(sess, &outputs, &id);\n \n@@ -171,7 +188,6 @@ pub fn compile_input(sess: &Session,\n         };\n \n         phase_3_run_analysis_passes(sess,\n-                                    &cstore,\n                                     hir_map,\n                                     &arenas,\n                                     &id,\n@@ -726,20 +742,10 @@ pub fn assign_node_ids(sess: &Session, krate: ast::Crate) -> ast::Crate {\n     krate\n }\n \n-pub fn make_map<'ast>(sess: &Session,\n-                      forest: &'ast mut hir_map::Forest)\n-                      -> hir_map::Map<'ast> {\n-    // Construct the HIR map\n-    time(sess.time_passes(),\n-         \"indexing hir\",\n-         move || hir_map::map_crate(forest))\n-}\n-\n /// Run the resolution, typechecking, region checking and other\n /// miscellaneous analysis passes on the crate. Return various\n /// structures carrying the results of the analysis.\n pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n-                                               cstore: &CStore,\n                                                hir_map: hir_map::Map<'tcx>,\n                                                arenas: &'tcx ty::CtxtArenas<'tcx>,\n                                                name: &str,\n@@ -762,10 +768,6 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n \n     let time_passes = sess.time_passes();\n \n-    time(time_passes,\n-         \"external crate/lib resolution\",\n-         || LocalCrateReader::new(sess, cstore, &hir_map, name).read_crates());\n-\n     let lang_items = time(time_passes, \"language item collection\", || {\n         sess.track_errors(|| {\n             middle::lang_items::collect_language_items(&sess, &hir_map)\n@@ -778,8 +780,8 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n         export_map,\n         trait_map,\n         glob_map,\n-    } = time(time_passes,\n-             \"resolution\",\n+    } = time(sess.time_passes(),\n+             \"name resolution\",\n              || resolve::resolve_crate(sess, &hir_map, make_glob_map));\n \n     let mut analysis = ty::CrateAnalysis {"}, {"sha": "0e100f48ac38d64488defa10f3e3d7775c0e49ff", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d81de4871fbaf15198857af06b4f15fd4e1bfb13/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d81de4871fbaf15198857af06b4f15fd4e1bfb13/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=d81de4871fbaf15198857af06b4f15fd4e1bfb13", "patch": "@@ -199,14 +199,9 @@ pub fn run_compiler<'a>(args: &[String],\n     // It is somewhat unfortunate that this is hardwired in - this is forced by\n     // the fact that pretty_print_input requires the session by value.\n     let pretty = callbacks.parse_pretty(&sess, &matches);\n-    match pretty {\n-        Some((ppm, opt_uii)) => {\n-            pretty::pretty_print_input(sess, &cstore, cfg, &input, ppm, opt_uii, ofile);\n-            return (Ok(()), None);\n-        }\n-        None => {\n-            // continue\n-        }\n+    if let Some((ppm, opt_uii)) = pretty {\n+        pretty::pretty_print_input(sess, &cstore, cfg, &input, ppm, opt_uii, ofile);\n+        return (Ok(()), None);\n     }\n \n     let plugins = sess.opts.debugging_opts.extra_plugins.clone();"}, {"sha": "b1143fd3e845463339783d224442c3b191d1c6b0", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/d81de4871fbaf15198857af06b4f15fd4e1bfb13/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d81de4871fbaf15198857af06b4f15fd4e1bfb13/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=d81de4871fbaf15198857af06b4f15fd4e1bfb13", "patch": "@@ -29,6 +29,7 @@ use rustc_borrowck as borrowck;\n use rustc_borrowck::graphviz as borrowck_dot;\n use rustc_resolve as resolve;\n use rustc_metadata::cstore::CStore;\n+use rustc_metadata::creader::LocalCrateReader;\n \n use rustc_mir::pretty::write_mir_pretty;\n use rustc_mir::graphviz::write_mir_graphviz;\n@@ -43,6 +44,7 @@ use syntax::util::small_vector::SmallVector;\n \n use graphviz as dot;\n \n+use std::cell::RefCell;\n use std::fs::File;\n use std::io::{self, Write};\n use std::iter;\n@@ -179,7 +181,6 @@ impl PpSourceMode {\n     }\n     fn call_with_pp_support_hir<'tcx, A, B, F>(&self,\n                                                sess: &'tcx Session,\n-                                               cstore: &CStore,\n                                                ast_map: &hir_map::Map<'tcx>,\n                                                arenas: &'tcx ty::CtxtArenas<'tcx>,\n                                                id: &str,\n@@ -206,7 +207,6 @@ impl PpSourceMode {\n             }\n             PpmTyped => {\n                 abort_on_err(driver::phase_3_run_analysis_passes(sess,\n-                                                                 cstore,\n                                                                  ast_map.clone(),\n                                                                  arenas,\n                                                                  id,\n@@ -721,7 +721,7 @@ pub fn pretty_print_input(sess: Session,\n     let is_expanded = needs_expansion(&ppm);\n     let compute_ast_map = needs_ast_map(&ppm, &opt_uii);\n     let krate = if compute_ast_map {\n-        match driver::phase_2_configure_and_expand(&sess, &cstore, krate, &id[..], None) {\n+        match driver::phase_2_configure_and_expand(&sess, &cstore, krate, &id, None) {\n             Err(_) => return,\n             Ok(k) => driver::assign_node_ids(&sess, k),\n         }\n@@ -732,14 +732,18 @@ pub fn pretty_print_input(sess: Session,\n     // There is some twisted, god-forsaken tangle of lifetimes here which makes\n     // the ordering of stuff super-finicky.\n     let mut hir_forest;\n-    let lcx = LoweringContext::new(&sess, Some(&krate));\n-    let arenas = ty::CtxtArenas::new();\n+    let mut _defs = None;\n     let dep_graph = DepGraph::new(false);\n+    let arenas = ty::CtxtArenas::new();\n     let _ignore = dep_graph.in_ignore();\n     let ast_map = if compute_ast_map {\n+        _defs = Some(RefCell::new(hir_map::collect_definitions(&krate)));\n+        let defs = _defs.as_ref().unwrap();\n+        LocalCrateReader::new(&sess, &cstore, defs, &krate, &id).read_crates(&dep_graph);\n+        let lcx = LoweringContext::new(&sess, Some(&krate), defs);\n+\n         hir_forest = hir_map::Forest::new(lower_crate(&lcx, &krate), dep_graph.clone());\n-        let map = driver::make_map(&sess, &mut hir_forest);\n-        Some(map)\n+        Some(hir_map::map_crate(&mut hir_forest, defs))\n     } else {\n         None\n     };\n@@ -752,7 +756,7 @@ pub fn pretty_print_input(sess: Session,\n                   .unwrap()\n                   .as_bytes()\n                   .to_vec();\n-    let mut rdr = &src[..];\n+    let mut rdr = &*src;\n \n     let mut out = Vec::new();\n \n@@ -777,7 +781,6 @@ pub fn pretty_print_input(sess: Session,\n         (PpmHir(s), None) => {\n             let out: &mut Write = &mut out;\n             s.call_with_pp_support_hir(&sess,\n-                                       cstore,\n                                        &ast_map.unwrap(),\n                                        &arenas,\n                                        &id,\n@@ -799,7 +802,6 @@ pub fn pretty_print_input(sess: Session,\n         (PpmHir(s), Some(uii)) => {\n             let out: &mut Write = &mut out;\n             s.call_with_pp_support_hir(&sess,\n-                                       cstore,\n                                        &ast_map.unwrap(),\n                                        &arenas,\n                                        &id,\n@@ -840,7 +842,6 @@ pub fn pretty_print_input(sess: Session,\n                 None\n             };\n             abort_on_err(driver::phase_3_run_analysis_passes(&sess,\n-                                                             &cstore,\n                                                              ast_map,\n                                                              &arenas,\n                                                              &id,\n@@ -887,7 +888,6 @@ pub fn pretty_print_input(sess: Session,\n                 Some(code) => {\n                     let variants = gather_flowgraph_variants(&sess);\n                     abort_on_err(driver::phase_3_run_analysis_passes(&sess,\n-                                                                     &cstore,\n                                                                      ast_map,\n                                                                      &arenas,\n                                                                      &id,"}, {"sha": "ce92dd158c969e4b33a80b05125f25fe471f2518", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d81de4871fbaf15198857af06b4f15fd4e1bfb13/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d81de4871fbaf15198857af06b4f15fd4e1bfb13/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=d81de4871fbaf15198857af06b4f15fd4e1bfb13", "patch": "@@ -27,8 +27,10 @@ use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n use rustc::ty::relate::TypeRelation;\n use rustc::infer::{self, InferOk, InferResult, TypeOrigin};\n use rustc_metadata::cstore::CStore;\n+use rustc_metadata::creader::LocalCrateReader;\n use rustc::hir::map as hir_map;\n use rustc::session::{self, config};\n+use std::cell::RefCell;\n use std::rc::Rc;\n use syntax::ast;\n use syntax::abi::Abi;\n@@ -119,13 +121,15 @@ fn test_env<F>(source_string: &str,\n     let krate = driver::phase_2_configure_and_expand(&sess, &cstore, krate, \"test\", None)\n                     .expect(\"phase 2 aborted\");\n \n-    let krate = driver::assign_node_ids(&sess, krate);\n-    let lcx = LoweringContext::new(&sess, Some(&krate));\n     let dep_graph = DepGraph::new(false);\n+    let krate = driver::assign_node_ids(&sess, krate);\n+    let defs = &RefCell::new(hir_map::collect_definitions(&krate));\n+    LocalCrateReader::new(&sess, &cstore, defs, &krate, \"test_crate\").read_crates(&dep_graph);\n+    let lcx = LoweringContext::new(&sess, Some(&krate), defs);\n     let _ignore = dep_graph.in_ignore();\n-    let mut hir_forest = hir_map::Forest::new(lower_crate(&lcx, &krate), dep_graph.clone());\n+    let mut hir_forest = &mut hir_map::Forest::new(lower_crate(&lcx, &krate), dep_graph.clone());\n     let arenas = ty::CtxtArenas::new();\n-    let ast_map = driver::make_map(&sess, &mut hir_forest);\n+    let ast_map = hir_map::map_crate(hir_forest, defs);\n \n     // run just enough stuff to build a tcx:\n     let lang_items = lang_items::collect_language_items(&sess, &ast_map);"}, {"sha": "2d6a043e34aeb88fb280fb58bfdf03039d2f04d0", "filename": "src/librustc_metadata/astencode.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d81de4871fbaf15198857af06b4f15fd4e1bfb13/src%2Flibrustc_metadata%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d81de4871fbaf15198857af06b4f15fd4e1bfb13/src%2Flibrustc_metadata%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fastencode.rs?ref=d81de4871fbaf15198857af06b4f15fd4e1bfb13", "patch": "@@ -1339,7 +1339,7 @@ fn roundtrip(in_item: hir::Item) {\n fn test_basic() {\n     let cx = mk_ctxt();\n     let fnia = FakeNodeIdAssigner;\n-    let lcx = LoweringContext::new(&fnia, None);\n+    let lcx = LoweringContext::testing_context(&fnia);\n     roundtrip(lower_item(&lcx, &quote_item!(&cx,\n         fn foo() {}\n     ).unwrap()));\n@@ -1349,7 +1349,7 @@ fn test_basic() {\n fn test_smalltalk() {\n     let cx = mk_ctxt();\n     let fnia = FakeNodeIdAssigner;\n-    let lcx = LoweringContext::new(&fnia, None);\n+    let lcx = LoweringContext::testing_context(&fnia);\n     roundtrip(lower_item(&lcx, &quote_item!(&cx,\n         fn foo() -> isize { 3 + 4 } // first smalltalk program ever executed.\n     ).unwrap()));\n@@ -1359,7 +1359,7 @@ fn test_smalltalk() {\n fn test_more() {\n     let cx = mk_ctxt();\n     let fnia = FakeNodeIdAssigner;\n-    let lcx = LoweringContext::new(&fnia, None);\n+    let lcx = LoweringContext::testing_context(&fnia);\n     roundtrip(lower_item(&lcx, &quote_item!(&cx,\n         fn foo(x: usize, y: usize) -> usize {\n             let z = x + y;\n@@ -1378,7 +1378,7 @@ fn test_simplification() {\n         }\n     ).unwrap();\n     let fnia = FakeNodeIdAssigner;\n-    let lcx = LoweringContext::new(&fnia, None);\n+    let lcx = LoweringContext::testing_context(&fnia);\n     let hir_item = lower_item(&lcx, &item);\n     let item_in = InlinedItemRef::Item(&hir_item);\n     let item_out = simplify_ast(item_in);"}, {"sha": "635ef4ab3583619b4a74475625e4b0451362d380", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 37, "deletions": 63, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/d81de4871fbaf15198857af06b4f15fd4e1bfb13/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d81de4871fbaf15198857af06b4f15fd4e1bfb13/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=d81de4871fbaf15198857af06b4f15fd4e1bfb13", "patch": "@@ -18,7 +18,7 @@ use decoder;\n use loader::{self, CratePaths};\n \n use rustc::hir::svh::Svh;\n-use rustc::dep_graph::DepNode;\n+use rustc::dep_graph::{DepGraph, DepNode};\n use rustc::session::{config, Session};\n use rustc::session::search_paths::PathKind;\n use rustc::middle::cstore::{CrateStore, validate_crate_name, ExternCrate};\n@@ -37,15 +37,15 @@ use syntax::parse;\n use syntax::attr;\n use syntax::attr::AttrMetaMethods;\n use syntax::parse::token::InternedString;\n-use rustc::hir::intravisit::Visitor;\n-use rustc::hir;\n+use syntax::visit;\n use log;\n \n-pub struct LocalCrateReader<'a, 'b:'a> {\n+pub struct LocalCrateReader<'a> {\n     sess: &'a Session,\n     cstore: &'a CStore,\n     creader: CrateReader<'a>,\n-    ast_map: &'a hir_map::Map<'b>,\n+    krate: &'a ast::Crate,\n+    defintions: &'a RefCell<hir_map::Definitions>,\n }\n \n pub struct CrateReader<'a> {\n@@ -56,9 +56,10 @@ pub struct CrateReader<'a> {\n     local_crate_name: String,\n }\n \n-impl<'a, 'b, 'hir> Visitor<'hir> for LocalCrateReader<'a, 'b> {\n-    fn visit_item(&mut self, a: &'hir hir::Item) {\n+impl<'a, 'ast> visit::Visitor<'ast> for LocalCrateReader<'a> {\n+    fn visit_item(&mut self, a: &'ast ast::Item) {\n         self.process_item(a);\n+        visit::walk_item(self, a);\n     }\n }\n \n@@ -80,11 +81,8 @@ fn dump_crates(cstore: &CStore) {\n fn should_link(i: &ast::Item) -> bool {\n     !attr::contains_name(&i.attrs, \"no_link\")\n }\n-// Dup for the hir\n-fn should_link_hir(i: &hir::Item) -> bool {\n-    !attr::contains_name(&i.attrs, \"no_link\")\n-}\n \n+#[derive(Debug)]\n struct CrateInfo {\n     ident: String,\n     name: String,\n@@ -181,31 +179,6 @@ impl<'a> CrateReader<'a> {\n         }\n     }\n \n-    // Dup of the above, but for the hir\n-    fn extract_crate_info_hir(&self, i: &hir::Item) -> Option<CrateInfo> {\n-        match i.node {\n-            hir::ItemExternCrate(ref path_opt) => {\n-                debug!(\"resolving extern crate stmt. ident: {} path_opt: {:?}\",\n-                       i.name, path_opt);\n-                let name = match *path_opt {\n-                    Some(name) => {\n-                        validate_crate_name(Some(self.sess), &name.as_str(),\n-                                            Some(i.span));\n-                        name.to_string()\n-                    }\n-                    None => i.name.to_string(),\n-                };\n-                Some(CrateInfo {\n-                    ident: i.name.to_string(),\n-                    name: name,\n-                    id: i.id,\n-                    should_link: should_link_hir(i),\n-                })\n-            }\n-            _ => None\n-        }\n-    }\n-\n     fn existing_match(&self, name: &str, hash: Option<&Svh>, kind: PathKind)\n                       -> Option<ast::CrateNum> {\n         let mut ret = None;\n@@ -776,29 +749,30 @@ impl<'a> CrateReader<'a> {\n     }\n }\n \n-impl<'a, 'b> LocalCrateReader<'a, 'b> {\n+impl<'a> LocalCrateReader<'a> {\n     pub fn new(sess: &'a Session,\n                cstore: &'a CStore,\n-               map: &'a hir_map::Map<'b>,\n+               defs: &'a RefCell<hir_map::Definitions>,\n+               krate: &'a ast::Crate,\n                local_crate_name: &str)\n-               -> LocalCrateReader<'a, 'b> {\n+               -> LocalCrateReader<'a> {\n         LocalCrateReader {\n             sess: sess,\n             cstore: cstore,\n             creader: CrateReader::new(sess, cstore, local_crate_name),\n-            ast_map: map,\n+            krate: krate,\n+            defintions: defs,\n         }\n     }\n \n     // Traverses an AST, reading all the information about use'd crates and\n     // extern libraries necessary for later resolving, typechecking, linking,\n     // etc.\n-    pub fn read_crates(&mut self) {\n-        let _task = self.ast_map.dep_graph.in_task(DepNode::CrateReader);\n-        let krate = self.ast_map.krate();\n+    pub fn read_crates(&mut self, dep_graph: &DepGraph) {\n+        let _task = dep_graph.in_task(DepNode::CrateReader);\n \n-        self.process_crate(krate);\n-        krate.visit_all_items(self);\n+        self.process_crate(self.krate);\n+        visit::walk_crate(self, self.krate);\n         self.creader.inject_allocator_crate();\n \n         if log_enabled!(log::INFO) {\n@@ -811,34 +785,34 @@ impl<'a, 'b> LocalCrateReader<'a, 'b> {\n         self.creader.register_statically_included_foreign_items();\n     }\n \n-    fn process_crate(&self, c: &hir::Crate) {\n+    fn process_crate(&self, c: &ast::Crate) {\n         for a in c.attrs.iter().filter(|m| m.name() == \"link_args\") {\n-            match a.value_str() {\n-                Some(ref linkarg) => self.cstore.add_used_link_args(&linkarg),\n-                None => { /* fallthrough */ }\n+            if let Some(ref linkarg) = a.value_str() {\n+                self.cstore.add_used_link_args(&linkarg);\n             }\n         }\n     }\n \n-    fn process_item(&mut self, i: &hir::Item) {\n+    fn process_item(&mut self, i: &ast::Item) {\n         match i.node {\n-            hir::ItemExternCrate(_) => {\n-                if !should_link_hir(i) {\n+            ast::ItemKind::ExternCrate(_) => {\n+                if !should_link(i) {\n                     return;\n                 }\n \n-                match self.creader.extract_crate_info_hir(i) {\n+                match self.creader.extract_crate_info(i) {\n                     Some(info) => {\n                         let (cnum, _, _) = self.creader.resolve_crate(&None,\n-                                                                          &info.ident,\n-                                                                          &info.name,\n-                                                                          None,\n-                                                                          i.span,\n-                                                                          PathKind::Crate,\n-                                                                          true);\n-                        let def_id = self.ast_map.local_def_id(i.id);\n+                                                                      &info.ident,\n+                                                                      &info.name,\n+                                                                      None,\n+                                                                      i.span,\n+                                                                      PathKind::Crate,\n+                                                                      true);\n \n-                        let len = self.ast_map.def_path(def_id).data.len();\n+                        let defs = self.defintions.borrow();\n+                        let def_id = defs.opt_local_def_id(i.id).unwrap();\n+                        let len = defs.def_path(def_id.index).data.len();\n \n                         self.creader.update_extern_crate(cnum,\n                                                          ExternCrate {\n@@ -852,12 +826,12 @@ impl<'a, 'b> LocalCrateReader<'a, 'b> {\n                     None => ()\n                 }\n             }\n-            hir::ItemForeignMod(ref fm) => self.process_foreign_mod(i, fm),\n+            ast::ItemKind::ForeignMod(ref fm) => self.process_foreign_mod(i, fm),\n             _ => { }\n         }\n     }\n \n-    fn process_foreign_mod(&mut self, i: &hir::Item, fm: &hir::ForeignMod) {\n+    fn process_foreign_mod(&mut self, i: &ast::Item, fm: &ast::ForeignMod) {\n         if fm.abi == Abi::Rust || fm.abi == Abi::RustIntrinsic || fm.abi == Abi::PlatformIntrinsic {\n             return;\n         }"}, {"sha": "fe32f1de0c52053306ee6286d2b188a1432f7adc", "filename": "src/librustc_mir/build/expr/into.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d81de4871fbaf15198857af06b4f15fd4e1bfb13/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d81de4871fbaf15198857af06b4f15fd4e1bfb13/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs?ref=d81de4871fbaf15198857af06b4f15fd4e1bfb13", "patch": "@@ -262,7 +262,8 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                     }\n                 };\n                 let extent = this.extent_of_return_scope();\n-                this.exit_scope(expr_span, extent, block, END_BLOCK);\n+                let return_block = this.return_block();\n+                this.exit_scope(expr_span, extent, block, return_block);\n                 this.cfg.start_new_block().unit()\n             }\n             ExprKind::Call { ty, fun, args } => {"}, {"sha": "b1f35541134f051b50b528ff66e6b65871352977", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 31, "deletions": 19, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/d81de4871fbaf15198857af06b4f15fd4e1bfb13/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d81de4871fbaf15198857af06b4f15fd4e1bfb13/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=d81de4871fbaf15198857af06b4f15fd4e1bfb13", "patch": "@@ -26,33 +26,35 @@ pub struct Builder<'a, 'tcx: 'a> {\n \n     fn_span: Span,\n \n-    // the current set of scopes, updated as we traverse;\n-    // see the `scope` module for more details\n+    /// the current set of scopes, updated as we traverse;\n+    /// see the `scope` module for more details\n     scopes: Vec<scope::Scope<'tcx>>,\n \n-    // for each scope, a span of blocks that defines it;\n-    // we track these for use in region and borrow checking,\n-    // but these are liable to get out of date once optimization\n-    // begins. They are also hopefully temporary, and will be\n-    // no longer needed when we adopt graph-based regions.\n+    ///  for each scope, a span of blocks that defines it;\n+    ///  we track these for use in region and borrow checking,\n+    ///  but these are liable to get out of date once optimization\n+    ///  begins. They are also hopefully temporary, and will be\n+    ///  no longer needed when we adopt graph-based regions.\n     scope_auxiliary: ScopeAuxiliaryVec,\n \n-    // the current set of loops; see the `scope` module for more\n-    // details\n+    /// the current set of loops; see the `scope` module for more\n+    /// details\n     loop_scopes: Vec<scope::LoopScope>,\n \n-    // the vector of all scopes that we have created thus far;\n-    // we track this for debuginfo later\n+    /// the vector of all scopes that we have created thus far;\n+    /// we track this for debuginfo later\n     scope_datas: Vec<ScopeData>,\n \n     var_decls: Vec<VarDecl<'tcx>>,\n     var_indices: FnvHashMap<ast::NodeId, u32>,\n     temp_decls: Vec<TempDecl<'tcx>>,\n     unit_temp: Option<Lvalue<'tcx>>,\n \n-    // cached block with a RESUME terminator; we create this at the\n-    // first panic\n+    /// cached block with the RESUME terminator; this is created\n+    /// when first set of cleanups are built.\n     cached_resume_block: Option<BasicBlock>,\n+    /// cached block with the RETURN terminator\n+    cached_return_block: Option<BasicBlock>,\n }\n \n struct CFG<'tcx> {\n@@ -182,11 +184,10 @@ pub fn construct<'a,'tcx>(hir: Cx<'a,'tcx>,\n         var_indices: FnvHashMap(),\n         unit_temp: None,\n         cached_resume_block: None,\n+        cached_return_block: None\n     };\n \n     assert_eq!(builder.cfg.start_new_block(), START_BLOCK);\n-    assert_eq!(builder.cfg.start_new_block(), END_BLOCK);\n-\n \n     let mut arg_decls = None; // assigned to `Some` in closures below\n     let call_site_extent =\n@@ -206,12 +207,12 @@ pub fn construct<'a,'tcx>(hir: Cx<'a,'tcx>,\n             block.unit()\n         }));\n \n+        let return_block = builder.return_block();\n         builder.cfg.terminate(block, call_site_scope_id, span,\n-                              TerminatorKind::Goto { target: END_BLOCK });\n-        builder.cfg.terminate(END_BLOCK, call_site_scope_id, span,\n+                              TerminatorKind::Goto { target: return_block });\n+        builder.cfg.terminate(return_block, call_site_scope_id, span,\n                               TerminatorKind::Return);\n-\n-        END_BLOCK.unit()\n+        return_block.unit()\n     });\n \n     assert!(\n@@ -329,6 +330,17 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n             }\n         }\n     }\n+\n+    fn return_block(&mut self) -> BasicBlock {\n+        match self.cached_return_block {\n+            Some(rb) => rb,\n+            None => {\n+                let rb = self.cfg.start_new_block();\n+                self.cached_return_block = Some(rb);\n+                rb\n+            }\n+        }\n+    }\n }\n \n ///////////////////////////////////////////////////////////////////////////"}, {"sha": "2099e9a435a0f607112fc1396bc162b92a491ec5", "filename": "src/librustc_mir/transform/remove_dead_blocks.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d81de4871fbaf15198857af06b4f15fd4e1bfb13/src%2Flibrustc_mir%2Ftransform%2Fremove_dead_blocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d81de4871fbaf15198857af06b4f15fd4e1bfb13/src%2Flibrustc_mir%2Ftransform%2Fremove_dead_blocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fremove_dead_blocks.rs?ref=d81de4871fbaf15198857af06b4f15fd4e1bfb13", "patch": "@@ -43,9 +43,8 @@ pub struct RemoveDeadBlocks;\n impl<'tcx> MirPass<'tcx> for RemoveDeadBlocks {\n     fn run_pass(&mut self, _: &TyCtxt<'tcx>, _: NodeId, mir: &mut Mir<'tcx>) {\n         let mut seen = BitVector::new(mir.basic_blocks.len());\n-        // These blocks are always required.\n+        // This block is always required.\n         seen.insert(START_BLOCK.index());\n-        seen.insert(END_BLOCK.index());\n \n         let mut worklist = Vec::with_capacity(4);\n         worklist.push(START_BLOCK);"}, {"sha": "45ec9a97a11844308d27cc0a05eeaefcec7dd8d4", "filename": "src/librustc_save_analysis/csv_dumper.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d81de4871fbaf15198857af06b4f15fd4e1bfb13/src%2Flibrustc_save_analysis%2Fcsv_dumper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d81de4871fbaf15198857af06b4f15fd4e1bfb13/src%2Flibrustc_save_analysis%2Fcsv_dumper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fcsv_dumper.rs?ref=d81de4871fbaf15198857af06b4f15fd4e1bfb13", "patch": "@@ -17,10 +17,10 @@ use super::data::*;\n use super::dump::Dump;\n use super::span_utils::SpanUtils;\n \n-pub struct CsvDumper<'a, 'b, W: 'b> {\n+pub struct CsvDumper<'tcx, 'b, W: 'b> {\n     output: &'b mut W,\n     dump_spans: bool,\n-    span: SpanUtils<'a>\n+    span: SpanUtils<'tcx>\n }\n \n impl<'a, 'b, W: Write> CsvDumper<'a, 'b, W> {"}, {"sha": "bf6ad7039636e97697c919b34de5f10f6bcd27f5", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/d81de4871fbaf15198857af06b4f15fd4e1bfb13/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d81de4871fbaf15198857af06b4f15fd4e1bfb13/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=d81de4871fbaf15198857af06b4f15fd4e1bfb13", "patch": "@@ -42,7 +42,7 @@ use syntax::visit::{self, Visitor};\n use syntax::print::pprust::{path_to_string, ty_to_string};\n use syntax::ptr::P;\n \n-use rustc::hir::lowering::{lower_expr, LoweringContext};\n+use rustc::hir::lowering::lower_expr;\n \n use super::{escape, generated_code, SaveContext, PathCollector};\n use super::data::*;\n@@ -60,12 +60,12 @@ macro_rules! down_cast_data {\n     };\n }\n \n-pub struct DumpVisitor<'l, 'tcx: 'l, D: 'l> {\n+pub struct DumpVisitor<'l, 'tcx: 'l, 'll, D: 'll> {\n     save_ctxt: SaveContext<'l, 'tcx>,\n     sess: &'l Session,\n     tcx: &'l TyCtxt<'tcx>,\n     analysis: &'l ty::CrateAnalysis<'l>,\n-    dumper: &'l mut D,\n+    dumper: &'ll mut D,\n \n     span: SpanUtils<'l>,\n \n@@ -77,22 +77,19 @@ pub struct DumpVisitor<'l, 'tcx: 'l, D: 'l> {\n     // one macro use per unique callsite span.\n     mac_defs: HashSet<Span>,\n     mac_uses: HashSet<Span>,\n-\n }\n \n-impl <'l, 'tcx, D> DumpVisitor<'l, 'tcx, D>\n-where D: Dump\n-{\n+impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n     pub fn new(tcx: &'l TyCtxt<'tcx>,\n-               lcx: &'l LoweringContext<'l>,\n+               save_ctxt: SaveContext<'l, 'tcx>,\n                analysis: &'l ty::CrateAnalysis<'l>,\n-               dumper: &'l mut D)\n-               -> DumpVisitor<'l, 'tcx, D> {\n+               dumper: &'ll mut D)\n+               -> DumpVisitor<'l, 'tcx, 'll, D> {\n         let span_utils = SpanUtils::new(&tcx.sess);\n         DumpVisitor {\n             sess: &tcx.sess,\n             tcx: tcx,\n-            save_ctxt: SaveContext::from_span_utils(tcx, lcx, span_utils.clone()),\n+            save_ctxt: save_ctxt,\n             analysis: analysis,\n             dumper: dumper,\n             span: span_utils.clone(),\n@@ -103,7 +100,7 @@ where D: Dump\n     }\n \n     fn nest<F>(&mut self, scope_id: NodeId, f: F)\n-        where F: FnOnce(&mut DumpVisitor<'l, 'tcx, D>)\n+        where F: FnOnce(&mut DumpVisitor<'l, 'tcx, 'll, D>)\n     {\n         let parent_scope = self.cur_scope;\n         self.cur_scope = scope_id;\n@@ -982,7 +979,7 @@ where D: Dump\n     }\n }\n \n-impl<'l, 'tcx, 'v, D: Dump + 'l> Visitor<'v> for DumpVisitor<'l, 'tcx, D> {\n+impl<'v, 'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor<'v> for DumpVisitor<'l, 'tcx, 'll, D> {\n     fn visit_item(&mut self, item: &ast::Item) {\n         use syntax::ast::ItemKind::*;\n         self.process_macro_use(item.span, item.id);"}, {"sha": "9148b53322bfe61b125620c0d80f1e3011bdf097", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d81de4871fbaf15198857af06b4f15fd4e1bfb13/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d81de4871fbaf15198857af06b4f15fd4e1bfb13/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=d81de4871fbaf15198857af06b4f15fd4e1bfb13", "patch": "@@ -73,7 +73,7 @@ pub mod recorder {\n pub struct SaveContext<'l, 'tcx: 'l> {\n     tcx: &'l TyCtxt<'tcx>,\n     lcx: &'l lowering::LoweringContext<'l>,\n-    span_utils: SpanUtils<'l>,\n+    span_utils: SpanUtils<'tcx>,\n }\n \n macro_rules! option_try(\n@@ -90,7 +90,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n \n     pub fn from_span_utils(tcx: &'l TyCtxt<'tcx>,\n                            lcx: &'l lowering::LoweringContext<'l>,\n-                           span_utils: SpanUtils<'l>)\n+                           span_utils: SpanUtils<'tcx>)\n                            -> SaveContext<'l, 'tcx> {\n         SaveContext {\n             tcx: tcx,\n@@ -680,7 +680,7 @@ impl<'v> Visitor<'v> for PathCollector {\n pub fn process_crate<'l, 'tcx>(tcx: &'l TyCtxt<'tcx>,\n                                lcx: &'l lowering::LoweringContext<'l>,\n                                krate: &ast::Crate,\n-                               analysis: &ty::CrateAnalysis,\n+                               analysis: &'l ty::CrateAnalysis<'l>,\n                                cratename: &str,\n                                odir: Option<&Path>) {\n     let _ignore = tcx.dep_graph.in_ignore();\n@@ -726,9 +726,10 @@ pub fn process_crate<'l, 'tcx>(tcx: &'l TyCtxt<'tcx>,\n     });\n     root_path.pop();\n \n-    let utils = SpanUtils::new(&tcx.sess);\n+    let utils: SpanUtils<'tcx> = SpanUtils::new(&tcx.sess);\n+    let save_ctxt = SaveContext::new(tcx, lcx);\n     let mut dumper = CsvDumper::new(&mut output_file, utils);\n-    let mut visitor = DumpVisitor::new(tcx, lcx, analysis, &mut dumper);\n+    let mut visitor = DumpVisitor::new(tcx, save_ctxt, analysis, &mut dumper);\n     // FIXME: we don't write anything!\n \n     visitor.dump_crate_info(cratename, krate);"}, {"sha": "c64eeb92737e05ebcdbe2c62db8eeeb3f45d9bde", "filename": "src/librustc_save_analysis/span_utils.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d81de4871fbaf15198857af06b4f15fd4e1bfb13/src%2Flibrustc_save_analysis%2Fspan_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d81de4871fbaf15198857af06b4f15fd4e1bfb13/src%2Flibrustc_save_analysis%2Fspan_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fspan_utils.rs?ref=d81de4871fbaf15198857af06b4f15fd4e1bfb13", "patch": "@@ -26,6 +26,8 @@ use syntax::parse::token::{keywords, Token};\n #[derive(Clone)]\n pub struct SpanUtils<'a> {\n     pub sess: &'a Session,\n+    // FIXME given that we clone SpanUtils all over the place, this err_count is\n+    // probably useless and any logic relying on it is bogus.\n     pub err_count: Cell<isize>,\n }\n "}, {"sha": "3874ebc91307bd8a0f0957b59dc030a83af28edc", "filename": "src/librustc_trans/mir/mod.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d81de4871fbaf15198857af06b4f15fd4e1bfb13/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d81de4871fbaf15198857af06b4f15fd4e1bfb13/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fmod.rs?ref=d81de4871fbaf15198857af06b4f15fd4e1bfb13", "patch": "@@ -164,8 +164,6 @@ pub fn trans_mir<'blk, 'tcx: 'blk>(fcx: &'blk FunctionContext<'blk, 'tcx>) {\n                   .map(|&bb|{\n                       if bb == mir::START_BLOCK {\n                           fcx.new_block(\"start\", None)\n-                      } else if bb == mir::END_BLOCK {\n-                          fcx.new_block(\"end\", None)\n                       } else {\n                           fcx.new_block(&format!(\"{:?}\", bb), None)\n                       }"}, {"sha": "6d1e91a687e586074115bd8bb07654073643c28d", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d81de4871fbaf15198857af06b4f15fd4e1bfb13/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d81de4871fbaf15198857af06b4f15fd4e1bfb13/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=d81de4871fbaf15198857af06b4f15fd4e1bfb13", "patch": "@@ -22,6 +22,7 @@ use rustc_trans::back::link;\n use rustc_resolve as resolve;\n use rustc::hir::lowering::{lower_crate, LoweringContext};\n use rustc_metadata::cstore::CStore;\n+use rustc_metadata::creader::LocalCrateReader;\n \n use syntax::{ast, codemap, errors};\n use syntax::errors::emitter::ColorConfig;\n@@ -151,14 +152,18 @@ pub fn run_core(search_paths: SearchPaths,\n                     .expect(\"phase_2_configure_and_expand aborted in rustdoc!\");\n \n     let krate = driver::assign_node_ids(&sess, krate);\n+    let dep_graph = DepGraph::new(false);\n+\n+    let defs = &RefCell::new(hir_map::collect_definitions(&krate));\n+    LocalCrateReader::new(&sess, &cstore, &defs, &krate, &name).read_crates(&dep_graph);\n+    let lcx = LoweringContext::new(&sess, Some(&krate), defs);\n+\n     // Lower ast -> hir.\n-    let lcx = LoweringContext::new(&sess, Some(&krate));\n-    let mut hir_forest = hir_map::Forest::new(lower_crate(&lcx, &krate), DepGraph::new(false));\n+    let mut hir_forest = hir_map::Forest::new(lower_crate(&lcx, &krate), dep_graph);\n     let arenas = ty::CtxtArenas::new();\n-    let hir_map = driver::make_map(&sess, &mut hir_forest);\n+    let hir_map = hir_map::map_crate(&mut hir_forest, defs);\n \n     abort_on_err(driver::phase_3_run_analysis_passes(&sess,\n-                                                     &cstore,\n                                                      hir_map,\n                                                      &arenas,\n                                                      &name,"}, {"sha": "34c83e1819df6f9d5026830554e118ba92bfe70c", "filename": "src/librustdoc/passes.rs", "status": "modified", "additions": 22, "deletions": 41, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/d81de4871fbaf15198857af06b4f15fd4e1bfb13/src%2Flibrustdoc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d81de4871fbaf15198857af06b4f15fd4e1bfb13/src%2Flibrustdoc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses.rs?ref=d81de4871fbaf15198857af06b4f15fd4e1bfb13", "patch": "@@ -24,62 +24,37 @@ use fold::FoldItem::Strip;\n \n /// Strip items marked `#[doc(hidden)]`\n pub fn strip_hidden(krate: clean::Crate) -> plugins::PluginResult {\n-    let mut stripped = DefIdSet();\n+    let mut retained = DefIdSet();\n \n     // strip all #[doc(hidden)] items\n     let krate = {\n         struct Stripper<'a> {\n-            stripped: &'a mut DefIdSet\n+            retained: &'a mut DefIdSet\n         }\n         impl<'a> fold::DocFolder for Stripper<'a> {\n             fn fold_item(&mut self, i: Item) -> Option<Item> {\n                 if i.attrs.list(\"doc\").has_word(\"hidden\") {\n                     debug!(\"found one in strip_hidden; removing\");\n-                    self.stripped.insert(i.def_id);\n-\n                     // use a dedicated hidden item for given item type if any\n                     match i.inner {\n                         clean::StructFieldItem(..) | clean::ModuleItem(..) => {\n                             return Strip(i).fold()\n                         }\n                         _ => return None,\n                     }\n+                } else {\n+                    self.retained.insert(i.def_id);\n                 }\n                 self.fold_item_recur(i)\n             }\n         }\n-        let mut stripper = Stripper{ stripped: &mut stripped };\n+        let mut stripper = Stripper{ retained: &mut retained };\n         stripper.fold_crate(krate)\n     };\n \n-    // strip any traits implemented on stripped items\n-    {\n-        struct ImplStripper<'a> {\n-            stripped: &'a mut DefIdSet\n-        }\n-        impl<'a> fold::DocFolder for ImplStripper<'a> {\n-            fn fold_item(&mut self, i: Item) -> Option<Item> {\n-                if let clean::ImplItem(clean::Impl{\n-                           for_: clean::ResolvedPath{ did, .. },\n-                           ref trait_, ..\n-                }) = i.inner {\n-                    // Impls for stripped types don't need to exist\n-                    if self.stripped.contains(&did) {\n-                        return None;\n-                    }\n-                    // Impls of stripped traits also don't need to exist\n-                    if let Some(did) = trait_.def_id() {\n-                        if self.stripped.contains(&did) {\n-                            return None;\n-                        }\n-                    }\n-                }\n-                self.fold_item_recur(i)\n-            }\n-        }\n-        let mut stripper = ImplStripper{ stripped: &mut stripped };\n-        stripper.fold_crate(krate)\n-    }\n+    // strip all impls referencing stripped items\n+    let mut stripper = ImplStripper { retained: &retained };\n+    stripper.fold_crate(krate)\n }\n \n /// Strip private items from the point of view of a crate or externally from a\n@@ -98,11 +73,9 @@ pub fn strip_private(mut krate: clean::Crate) -> plugins::PluginResult {\n         krate = ImportStripper.fold_crate(stripper.fold_crate(krate));\n     }\n \n-    // strip all private implementations of traits\n-    {\n-        let mut stripper = ImplStripper(&retained);\n-        stripper.fold_crate(krate)\n-    }\n+    // strip all impls referencing private items\n+    let mut stripper = ImplStripper { retained: &retained };\n+    stripper.fold_crate(krate)\n }\n \n struct Stripper<'a> {\n@@ -201,13 +174,21 @@ impl<'a> fold::DocFolder for Stripper<'a> {\n     }\n }\n \n-// This stripper discards all private impls of traits\n-struct ImplStripper<'a>(&'a DefIdSet);\n+// This stripper discards all impls which reference stripped items\n+struct ImplStripper<'a> {\n+    retained: &'a DefIdSet\n+}\n+\n impl<'a> fold::DocFolder for ImplStripper<'a> {\n     fn fold_item(&mut self, i: Item) -> Option<Item> {\n         if let clean::ImplItem(ref imp) = i.inner {\n+            if let Some(did) = imp.for_.def_id() {\n+                if did.is_local() && !self.retained.contains(&did) {\n+                    return None;\n+                }\n+            }\n             if let Some(did) = imp.trait_.def_id() {\n-                if did.is_local() && !self.0.contains(&did) {\n+                if did.is_local() && !self.retained.contains(&did) {\n                     return None;\n                 }\n             }"}, {"sha": "487aac1806ea7291e7e1e7122af1f4f604a4a1ed", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d81de4871fbaf15198857af06b4f15fd4e1bfb13/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d81de4871fbaf15198857af06b4f15fd4e1bfb13/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=d81de4871fbaf15198857af06b4f15fd4e1bfb13", "patch": "@@ -94,15 +94,17 @@ pub fn run(input: &str,\n                                                      \"rustdoc-test\", None)\n         .expect(\"phase_2_configure_and_expand aborted in rustdoc!\");\n     let krate = driver::assign_node_ids(&sess, krate);\n-    let lcx = LoweringContext::new(&sess, Some(&krate));\n+    let dep_graph = DepGraph::new(false);\n+    let defs = &RefCell::new(hir_map::collect_definitions(&krate));\n+\n+    let lcx = LoweringContext::new(&sess, Some(&krate), defs);\n     let krate = lower_crate(&lcx, &krate);\n \n     let opts = scrape_test_config(&krate);\n \n-    let dep_graph = DepGraph::new(false);\n     let _ignore = dep_graph.in_ignore();\n     let mut forest = hir_map::Forest::new(krate, dep_graph.clone());\n-    let map = hir_map::map_crate(&mut forest);\n+    let map = hir_map::map_crate(&mut forest, defs);\n \n     let ctx = core::DocContext {\n         map: &map,"}, {"sha": "b9a45c09626a79455484af90f1d6bcb886a04d4c", "filename": "src/test/run-make/execution-engine/test.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d81de4871fbaf15198857af06b4f15fd4e1bfb13/src%2Ftest%2Frun-make%2Fexecution-engine%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d81de4871fbaf15198857af06b4f15fd4e1bfb13/src%2Ftest%2Frun-make%2Fexecution-engine%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fexecution-engine%2Ftest.rs?ref=d81de4871fbaf15198857af06b4f15fd4e1bfb13", "patch": "@@ -20,6 +20,7 @@ extern crate rustc_metadata;\n extern crate rustc_resolve;\n #[macro_use] extern crate syntax;\n \n+use std::cell::RefCell;\n use std::ffi::{CStr, CString};\n use std::mem::transmute;\n use std::path::PathBuf;\n@@ -35,6 +36,7 @@ use rustc::session::build_session;\n use rustc_driver::{driver, abort_on_err};\n use rustc::hir::lowering::{lower_crate, LoweringContext};\n use rustc_resolve::MakeGlobMap;\n+use rustc_metadata::creader::LocalCrateReader;\n use rustc_metadata::cstore::CStore;\n use libc::c_void;\n \n@@ -237,15 +239,17 @@ fn compile_program(input: &str, sysroot: PathBuf)\n         let krate = driver::phase_2_configure_and_expand(&sess, &cstore, krate, &id, None)\n             .expect(\"phase_2 returned `None`\");\n \n-        let krate = driver::assign_node_ids(&sess, krate);\n-        let lcx = LoweringContext::new(&sess, Some(&krate));\n         let dep_graph = DepGraph::new(sess.opts.build_dep_graph());\n+        let krate = driver::assign_node_ids(&sess, krate);\n+        let defs = RefCell::new(ast_map::collect_definitions(&krate));\n+        LocalCrateReader::new(&sess, &cstore, &defs, &krate, &id).read_crates(&dep_graph);\n+        let lcx = LoweringContext::new(&sess, Some(&krate), &defs);\n         let mut hir_forest = ast_map::Forest::new(lower_crate(&lcx, &krate), dep_graph);\n         let arenas = ty::CtxtArenas::new();\n-        let ast_map = driver::make_map(&sess, &mut hir_forest);\n+        let ast_map = ast_map::map_crate(&mut hir_forest, &defs);\n \n         abort_on_err(driver::phase_3_run_analysis_passes(\n-            &sess, &cstore, ast_map, &arenas, &id,\n+            &sess, ast_map, &arenas, &id,\n             MakeGlobMap::No, |tcx, mir_map, analysis, _| {\n \n             let trans = driver::phase_4_translate_to_llvm(tcx, mir_map.unwrap(), analysis);"}, {"sha": "cd227fdef56dd0b886fe0ca0e2c8724b7f4d7936", "filename": "src/test/rustdoc/issue-33069.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d81de4871fbaf15198857af06b4f15fd4e1bfb13/src%2Ftest%2Frustdoc%2Fissue-33069.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d81de4871fbaf15198857af06b4f15fd4e1bfb13/src%2Ftest%2Frustdoc%2Fissue-33069.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fissue-33069.rs?ref=d81de4871fbaf15198857af06b4f15fd4e1bfb13", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub trait Bar {}\n+\n+#[doc(hidden)]\n+pub mod hidden {\n+    pub struct Foo;\n+}\n+\n+// @has issue_33069/trait.Bar.html\n+// @!has - '//code' 'impl Bar for Foo'\n+impl Bar for hidden::Foo {}"}]}