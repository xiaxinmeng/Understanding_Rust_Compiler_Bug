{"sha": "88f755f8a84df1d9e6b17cf10c96ae8b93481b2e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg4Zjc1NWY4YTg0ZGYxZDllNmIxN2NmMTBjOTZhZThiOTM0ODFiMmU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-03-07T00:27:07Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-03-07T00:27:07Z"}, "message": "Auto merge of #58583 - varkor:const-generics-ty, r=oli-obk\n\nAdd const generics to ty (and transitive dependencies)\n\nSplit out from #53645. This work is a collaborative effort with @yodaldevoid.\n\nThere are a number of stubs. Some I plan to leave for the next PRs (e.g. `infer` and `rustdoc`). Others I can either fix up in this PR, or as follow ups (which would avoid the time-consuming rebasing).\n\nIt was a little hard to split this up, as so much depends on ty and friends. Apologies for the large diff.\n\nr? @eddyb", "tree": {"sha": "140a26d5dd27f9cec68ddef6a41e3fade7d46bd7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/140a26d5dd27f9cec68ddef6a41e3fade7d46bd7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e", "html_url": "https://github.com/rust-lang/rust/commit/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f22dca0a1bef4141e75326caacc3cd59f3d5be8e", "url": "https://api.github.com/repos/rust-lang/rust/commits/f22dca0a1bef4141e75326caacc3cd59f3d5be8e", "html_url": "https://github.com/rust-lang/rust/commit/f22dca0a1bef4141e75326caacc3cd59f3d5be8e"}, {"sha": "de4478af91765999f51b2950bea16686ee4cd60a", "url": "https://api.github.com/repos/rust-lang/rust/commits/de4478af91765999f51b2950bea16686ee4cd60a", "html_url": "https://github.com/rust-lang/rust/commit/de4478af91765999f51b2950bea16686ee4cd60a"}], "stats": {"total": 1613, "additions": 1201, "deletions": 412}, "files": [{"sha": "21988de90183a0a9df91bd6d830f76e9941b6f28", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=88f755f8a84df1d9e6b17cf10c96ae8b93481b2e", "patch": "@@ -74,6 +74,7 @@ for ty::subst::UnpackedKind<'gcx> {\n         match self {\n             ty::subst::UnpackedKind::Lifetime(lt) => lt.hash_stable(hcx, hasher),\n             ty::subst::UnpackedKind::Type(ty) => ty.hash_stable(hcx, hasher),\n+            ty::subst::UnpackedKind::Const(ct) => ct.hash_stable(hcx, hasher),\n         }\n     }\n }\n@@ -134,6 +135,15 @@ impl<'a> HashStable<StableHashingContext<'a>> for ty::RegionVid {\n     }\n }\n \n+impl<'gcx, 'tcx> HashStable<StableHashingContext<'gcx>> for ty::ConstVid<'tcx> {\n+    #[inline]\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        self.index.hash_stable(hcx, hasher);\n+    }\n+}\n+\n impl<'gcx> HashStable<StableHashingContext<'gcx>> for ty::BoundVar {\n     #[inline]\n     fn hash_stable<W: StableHasherResult>(&self,\n@@ -297,6 +307,14 @@ impl<'a> HashStable<StableHashingContext<'a>> for ty::VariantFlags {\n     }\n }\n \n+impl_stable_hash_for!(\n+    impl<'tcx> for enum ty::InferConst<'tcx> [ ty::InferConst ] {\n+        Var(vid),\n+        Fresh(i),\n+        Canonical(debruijn, var),\n+    }\n+);\n+\n impl_stable_hash_for!(enum ty::VariantDiscr {\n     Explicit(def_id),\n     Relative(distance)\n@@ -310,11 +328,14 @@ impl_stable_hash_for!(struct ty::FieldDef {\n \n impl_stable_hash_for!(\n     impl<'tcx> for enum mir::interpret::ConstValue<'tcx> [ mir::interpret::ConstValue ] {\n+        Param(param),\n+        Infer(infer),\n         Scalar(val),\n         Slice(a, b),\n         ByRef(ptr, alloc),\n     }\n );\n+\n impl_stable_hash_for!(struct crate::mir::interpret::RawConst<'tcx> {\n     alloc_id,\n     ty,\n@@ -518,6 +539,7 @@ impl_stable_hash_for!(struct ty::GenericParamDef {\n impl_stable_hash_for!(enum ty::GenericParamDefKind {\n     Lifetime,\n     Type { has_default, object_lifetime_default, synthetic },\n+    Const,\n });\n \n impl_stable_hash_for!(\n@@ -736,6 +758,11 @@ for ty::FloatVid\n     }\n }\n \n+impl_stable_hash_for!(struct ty::ParamConst {\n+    index,\n+    name\n+});\n+\n impl_stable_hash_for!(struct ty::ParamTy {\n     idx,\n     name"}, {"sha": "0d067d1de856aa4572eb7411d4e1c5d1935a60ac", "filename": "src/librustc/infer/canonical/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e/src%2Flibrustc%2Finfer%2Fcanonical%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e/src%2Flibrustc%2Finfer%2Fcanonical%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fmod.rs?ref=88f755f8a84df1d9e6b17cf10c96ae8b93481b2e", "patch": "@@ -443,6 +443,9 @@ impl<'tcx> CanonicalVarValues<'tcx> {\n                     UnpackedKind::Lifetime(..) => tcx.mk_region(\n                         ty::ReLateBound(ty::INNERMOST, ty::BoundRegion::BrAnon(i))\n                     ).into(),\n+                    UnpackedKind::Const(..) => {\n+                        unimplemented!() // FIXME(const_generics)\n+                    }\n                 })\n                 .collect()\n         }"}, {"sha": "008882fd50036fc6c0df553fd73735c1dbd2d282", "filename": "src/librustc/infer/canonical/query_response.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_response.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_response.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_response.rs?ref=88f755f8a84df1d9e6b17cf10c96ae8b93481b2e", "patch": "@@ -315,6 +315,10 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n                     obligations.extend(ok.into_obligations());\n                 }\n \n+                (UnpackedKind::Const(..), UnpackedKind::Const(..)) => {\n+                    unimplemented!() // FIXME(const_generics)\n+                }\n+\n                 _ => {\n                     bug!(\n                         \"kind mismatch, cannot unify {:?} and {:?}\",\n@@ -473,6 +477,9 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n                         opt_values[br.assert_bound_var()] = Some(*original_value);\n                     }\n                 }\n+                UnpackedKind::Const(..) => {\n+                    unimplemented!() // FIXME(const_generics)\n+                }\n             }\n         }\n \n@@ -568,6 +575,11 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n                                 ty::OutlivesPredicate(t1, r2)\n                             )\n                         ),\n+                        UnpackedKind::Const(..) => {\n+                            // Consts cannot outlive one another, so we don't expect to\n+                            // ecounter this branch.\n+                            span_bug!(cause.span, \"unexpected const outlives {:?}\", constraint);\n+                        }\n                     }\n                 )\n             })\n@@ -602,6 +614,9 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n                         obligations\n                             .extend(self.at(cause, param_env).eq(v1, v2)?.into_obligations());\n                     }\n+                    (UnpackedKind::Const(..), UnpackedKind::Const(..)) => {\n+                        unimplemented!() // FIXME(const_generics)\n+                    }\n                     _ => {\n                         bug!(\"kind mismatch, cannot unify {:?} and {:?}\", value1, value2,);\n                     }"}, {"sha": "885b439ef1ca58c44c7eb4cfce5f05f438c7e327", "filename": "src/librustc/infer/combine.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e/src%2Flibrustc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e/src%2Flibrustc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcombine.rs?ref=88f755f8a84df1d9e6b17cf10c96ae8b93481b2e", "patch": "@@ -449,7 +449,7 @@ impl<'cx, 'gcx, 'tcx> TypeRelation<'cx, 'gcx, 'tcx> for Generalizer<'cx, 'gcx, '\n \n                             let origin = *variables.var_origin(vid);\n                             let new_var_id = variables.new_var(self.for_universe, false, origin);\n-                            let u = self.tcx().mk_var(new_var_id);\n+                            let u = self.tcx().mk_ty_var(new_var_id);\n                             debug!(\"generalize: replacing original vid={:?} with new={:?}\",\n                                    vid, u);\n                             return Ok(u);"}, {"sha": "c7936534aad2e00d0cc8689a97e5ec99b0cd1c95", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=88f755f8a84df1d9e6b17cf10c96ae8b93481b2e", "patch": "@@ -691,17 +691,11 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     ) -> SubstsRef<'tcx> {\n         let generics = self.tcx.generics_of(def_id);\n         let mut num_supplied_defaults = 0;\n-        let mut type_params = generics\n-            .params\n-            .iter()\n-            .rev()\n-            .filter_map(|param| match param.kind {\n-                ty::GenericParamDefKind::Lifetime => None,\n-                ty::GenericParamDefKind::Type { has_default, .. } => {\n-                    Some((param.def_id, has_default))\n-                }\n-            })\n-            .peekable();\n+        let mut type_params = generics.params.iter().rev().filter_map(|param| match param.kind {\n+            ty::GenericParamDefKind::Lifetime => None,\n+            ty::GenericParamDefKind::Type { has_default, .. } => Some((param.def_id, has_default)),\n+            ty::GenericParamDefKind::Const => None, // FIXME(const_generics:defaults)\n+        }).peekable();\n         let has_default = {\n             let has_default = type_params.peek().map(|(_, has_default)| has_default);\n             *has_default.unwrap_or(&false)"}, {"sha": "cc1c439f3bd94fbc7a4a4e65b146eaec8ab6c270", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=88f755f8a84df1d9e6b17cf10c96ae8b93481b2e", "patch": "@@ -656,7 +656,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         type_variables\n             .unsolved_variables()\n             .into_iter()\n-            .map(|t| self.tcx.mk_var(t))\n+            .map(|t| self.tcx.mk_ty_var(t))\n             .chain(\n                 (0..int_unification_table.len())\n                     .map(|i| ty::IntVid { index: i as u32 })\n@@ -981,7 +981,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn next_ty_var(&self, origin: TypeVariableOrigin) -> Ty<'tcx> {\n-        self.tcx.mk_var(self.next_ty_var_id(false, origin))\n+        self.tcx.mk_ty_var(self.next_ty_var_id(false, origin))\n     }\n \n     pub fn next_ty_var_in_universe(\n@@ -992,11 +992,11 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         let vid = self.type_variables\n             .borrow_mut()\n             .new_var(universe, false, origin);\n-        self.tcx.mk_var(vid)\n+        self.tcx.mk_ty_var(vid)\n     }\n \n     pub fn next_diverging_ty_var(&self, origin: TypeVariableOrigin) -> Ty<'tcx> {\n-        self.tcx.mk_var(self.next_ty_var_id(true, origin))\n+        self.tcx.mk_ty_var(self.next_ty_var_id(true, origin))\n     }\n \n     pub fn next_int_var_id(&self) -> IntVid {\n@@ -1081,7 +1081,10 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                     TypeVariableOrigin::TypeParameterDefinition(span, param.name),\n                 );\n \n-                self.tcx.mk_var(ty_var_id).into()\n+                self.tcx.mk_ty_var(ty_var_id).into()\n+            }\n+            GenericParamDefKind::Const { .. } => {\n+                unimplemented!() // FIXME(const_generics)\n             }\n         }\n     }"}, {"sha": "7140af36acbdc4191a0133b85f35f323b250b863", "filename": "src/librustc/infer/nll_relate/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e/src%2Flibrustc%2Finfer%2Fnll_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e/src%2Flibrustc%2Finfer%2Fnll_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fnll_relate%2Fmod.rs?ref=88f755f8a84df1d9e6b17cf10c96ae8b93481b2e", "patch": "@@ -310,7 +310,7 @@ where\n             ty::Projection(projection_ty)\n                 if D::normalization() == NormalizationStrategy::Lazy =>\n             {\n-                return Ok(self.relate_projection_ty(projection_ty, self.infcx.tcx.mk_var(vid)));\n+                return Ok(self.relate_projection_ty(projection_ty, self.infcx.tcx.mk_ty_var(vid)));\n             }\n \n             _ => (),\n@@ -764,7 +764,7 @@ where\n                             // the universe `_universe`.\n                             let new_var_id = variables.new_var(self.universe, false, origin);\n \n-                            let u = self.tcx().mk_var(new_var_id);\n+                            let u = self.tcx().mk_ty_var(new_var_id);\n                             debug!(\n                                 \"generalize: replacing original vid={:?} with new={:?}\",\n                                 vid,"}, {"sha": "1b7ecc7c3a67cedc41a125ecae7f34b2d77cc3b1", "filename": "src/librustc/infer/opaque_types/mod.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs?ref=88f755f8a84df1d9e6b17cf10c96ae8b93481b2e", "patch": "@@ -381,10 +381,15 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                         substs,\n                         item_def_id: _,\n                     }) => {\n-                        for r in substs.regions() {\n-                            bound_region(r);\n+                        for k in substs {\n+                            match k.unpack() {\n+                                UnpackedKind::Lifetime(lt) => bound_region(lt),\n+                                UnpackedKind::Type(ty) => types.push(ty),\n+                                UnpackedKind::Const(_) => {\n+                                    // Const parameters don't impose constraints.\n+                                }\n+                            }\n                         }\n-                        types.extend(substs.types());\n                     }\n \n                     Component::EscapingProjection(more_components) => {"}, {"sha": "ee66032848519887c0454b0290946d6fd872c398", "filename": "src/librustc/infer/outlives/obligations.rs", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs?ref=88f755f8a84df1d9e6b17cf10c96ae8b93481b2e", "patch": "@@ -67,6 +67,7 @@ use crate::hir;\n use crate::traits::ObligationCause;\n use crate::ty::outlives::Component;\n use crate::ty::{self, Region, Ty, TyCtxt, TypeFoldable};\n+use crate::ty::subst::UnpackedKind;\n \n impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n     /// Registers that the given region obligation must be resolved\n@@ -430,13 +431,18 @@ where\n         if approx_env_bounds.is_empty() && trait_bounds.is_empty() && needs_infer {\n             debug!(\"projection_must_outlive: no declared bounds\");\n \n-            for component_ty in projection_ty.substs.types() {\n-                self.type_must_outlive(origin.clone(), component_ty, region);\n-            }\n-\n-            for r in projection_ty.substs.regions() {\n-                self.delegate\n-                    .push_sub_region_constraint(origin.clone(), region, r);\n+            for k in projection_ty.substs {\n+                match k.unpack() {\n+                    UnpackedKind::Lifetime(lt) => {\n+                        self.delegate.push_sub_region_constraint(origin.clone(), region, lt);\n+                    }\n+                    UnpackedKind::Type(ty) => {\n+                        self.type_must_outlive(origin.clone(), ty, region);\n+                    }\n+                    UnpackedKind::Const(_) => {\n+                        // Const parameters don't impose constraints.\n+                    }\n+                }\n             }\n \n             return;"}, {"sha": "d2bec1070f9215e409a5269af8123d3fa86175a6", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=88f755f8a84df1d9e6b17cf10c96ae8b93481b2e", "patch": "@@ -1974,7 +1974,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                                     object_lifetime_default,\n                                     ..\n                                 } => Some(object_lifetime_default),\n-                                GenericParamDefKind::Lifetime => None,\n+                                GenericParamDefKind::Lifetime | GenericParamDefKind::Const => None,\n                             })\n                             .collect()\n                     })"}, {"sha": "dbbeda3e578e46af8851d698f88a589e954a8f74", "filename": "src/librustc/mir/interpret/value.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs?ref=88f755f8a84df1d9e6b17cf10c96ae8b93481b2e", "patch": "@@ -1,6 +1,6 @@\n use std::fmt;\n \n-use crate::ty::{Ty, layout::{HasDataLayout, Size}};\n+use crate::ty::{Ty, InferConst, ParamConst, layout::{HasDataLayout, Size}};\n \n use super::{EvalResult, Pointer, PointerArithmetic, Allocation, AllocId, sign_extend, truncate};\n \n@@ -17,6 +17,12 @@ pub struct RawConst<'tcx> {\n /// match the `LocalState` optimizations for easy conversions between `Value` and `ConstValue`.\n #[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord, RustcEncodable, RustcDecodable, Hash)]\n pub enum ConstValue<'tcx> {\n+    /// A const generic parameter.\n+    Param(ParamConst),\n+\n+    /// Infer the value of the const.\n+    Infer(InferConst<'tcx>),\n+\n     /// Used only for types with `layout::abi::Scalar` ABI and ZSTs.\n     ///\n     /// Not using the enum `Value` to encode that this must not be `Undef`.\n@@ -43,6 +49,8 @@ impl<'tcx> ConstValue<'tcx> {\n     #[inline]\n     pub fn try_to_scalar(&self) -> Option<Scalar> {\n         match *self {\n+            ConstValue::Param(_) |\n+            ConstValue::Infer(_) |\n             ConstValue::ByRef(..) |\n             ConstValue::Slice(..) => None,\n             ConstValue::Scalar(val) => Some(val),"}, {"sha": "322e384e13e205093ef39b72c75580b1c6becbe0", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=88f755f8a84df1d9e6b17cf10c96ae8b93481b2e", "patch": "@@ -389,7 +389,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n         for param in generics.params.iter() {\n             let value = match param.kind {\n-                GenericParamDefKind::Type {..} => {\n+                GenericParamDefKind::Type { .. } |\n+                GenericParamDefKind::Const => {\n                     trait_ref.substs[param.index as usize].to_string()\n                 },\n                 GenericParamDefKind::Lifetime => continue,"}, {"sha": "32bb7f186938a7ea7ccafba09f39ee1c34a8407d", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=88f755f8a84df1d9e6b17cf10c96ae8b93481b2e", "patch": "@@ -1010,7 +1010,8 @@ fn vtable_methods<'a, 'tcx>(\n                     InternalSubsts::for_item(tcx, def_id, |param, _|\n                         match param.kind {\n                             GenericParamDefKind::Lifetime => tcx.types.re_erased.into(),\n-                            GenericParamDefKind::Type {..} => {\n+                            GenericParamDefKind::Type { .. } |\n+                            GenericParamDefKind::Const => {\n                                 trait_ref.substs[param.index as usize]\n                             }\n                         }"}, {"sha": "e7a5138e6893c5384875dd00dfb263e40a528c06", "filename": "src/librustc/traits/object_safety.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fobject_safety.rs?ref=88f755f8a84df1d9e6b17cf10c96ae8b93481b2e", "patch": "@@ -310,7 +310,8 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n         }\n \n         // We can't monomorphize things like `fn foo<A>(...)`.\n-        if self.generics_of(method.def_id).own_counts().types != 0 {\n+        let own_counts = self.generics_of(method.def_id).own_counts();\n+        if own_counts.types + own_counts.consts != 0 {\n             return Some(MethodViolationCode::Generic);\n         }\n "}, {"sha": "c86fd0d52b901ce62fe3fb64dea452b8f73cb001", "filename": "src/librustc/traits/on_unimplemented.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs?ref=88f755f8a84df1d9e6b17cf10c96ae8b93481b2e", "patch": "@@ -280,7 +280,8 @@ impl<'a, 'gcx, 'tcx> OnUnimplementedFormatString {\n         let generics = tcx.generics_of(trait_ref.def_id);\n         let generic_map = generics.params.iter().filter_map(|param| {\n             let value = match param.kind {\n-                GenericParamDefKind::Type {..} => {\n+                GenericParamDefKind::Type { .. } |\n+                GenericParamDefKind::Const => {\n                     trait_ref.substs[param.index as usize].to_string()\n                 },\n                 GenericParamDefKind::Lifetime => return None"}, {"sha": "f6e6067bb6fc8ebf103049c98c2b2b994689ee41", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 74, "deletions": 26, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=88f755f8a84df1d9e6b17cf10c96ae8b93481b2e", "patch": "@@ -21,8 +21,8 @@ use crate::middle::lang_items;\n use crate::middle::resolve_lifetime::{self, ObjectLifetimeDefault};\n use crate::middle::stability;\n use crate::mir::{self, Mir, interpret, ProjectionKind};\n-use crate::mir::interpret::Allocation;\n-use crate::ty::subst::{Kind, InternalSubsts, Subst, SubstsRef};\n+use crate::mir::interpret::{ConstValue, Allocation};\n+use crate::ty::subst::{Kind, InternalSubsts, SubstsRef, Subst};\n use crate::ty::ReprOptions;\n use crate::traits;\n use crate::traits::{Clause, Clauses, GoalKind, Goal, Goals};\n@@ -31,8 +31,9 @@ use crate::ty::{TyS, TyKind, List};\n use crate::ty::{AdtKind, AdtDef, ClosureSubsts, GeneratorSubsts, Region, Const, LazyConst};\n use crate::ty::{PolyFnSig, InferTy, ParamTy, ProjectionTy, ExistentialPredicate, Predicate};\n use crate::ty::RegionKind;\n-use crate::ty::{TyVar, TyVid, IntVar, IntVid, FloatVar, FloatVid};\n+use crate::ty::{TyVar, TyVid, IntVar, IntVid, FloatVar, FloatVid, ConstVid};\n use crate::ty::TyKind::*;\n+use crate::ty::{InferConst, ParamConst};\n use crate::ty::GenericParamDefKind;\n use crate::ty::layout::{LayoutDetails, TargetDataLayout, VariantIdx};\n use crate::ty::query;\n@@ -872,6 +873,18 @@ impl CanonicalUserType<'gcx> {\n                             }\n                             _ => false,\n                         },\n+\n+                        UnpackedKind::Const(ct) => match ct {\n+                            ty::LazyConst::Evaluated(ty::Const {\n+                                val: ConstValue::Infer(InferConst::Canonical(debruijn, b)),\n+                                ..\n+                            }) => {\n+                                // We only allow a `ty::INNERMOST` index in substitutions.\n+                                assert_eq!(*debruijn, ty::INNERMOST);\n+                                cvar == *b\n+                            }\n+                            _ => false,\n+                        },\n                     }\n                 })\n             },\n@@ -2120,15 +2133,19 @@ macro_rules! sty_debug_print {\n             #[derive(Copy, Clone)]\n             struct DebugStat {\n                 total: usize,\n-                region_infer: usize,\n+                lt_infer: usize,\n                 ty_infer: usize,\n-                both_infer: usize,\n+                ct_infer: usize,\n+                all_infer: usize,\n             }\n \n             pub fn go(tcx: TyCtxt<'_, '_, '_>) {\n                 let mut total = DebugStat {\n                     total: 0,\n-                    region_infer: 0, ty_infer: 0, both_infer: 0,\n+                    lt_infer: 0,\n+                    ty_infer: 0,\n+                    ct_infer: 0,\n+                    all_infer: 0,\n                 };\n                 $(let mut $variant = total;)*\n \n@@ -2139,31 +2156,35 @@ macro_rules! sty_debug_print {\n                         ty::Error => /* unimportant */ continue,\n                         $(ty::$variant(..) => &mut $variant,)*\n                     };\n-                    let region = t.flags.intersects(ty::TypeFlags::HAS_RE_INFER);\n+                    let lt = t.flags.intersects(ty::TypeFlags::HAS_RE_INFER);\n                     let ty = t.flags.intersects(ty::TypeFlags::HAS_TY_INFER);\n+                    let ct = t.flags.intersects(ty::TypeFlags::HAS_CT_INFER);\n \n                     variant.total += 1;\n                     total.total += 1;\n-                    if region { total.region_infer += 1; variant.region_infer += 1 }\n+                    if lt { total.lt_infer += 1; variant.lt_infer += 1 }\n                     if ty { total.ty_infer += 1; variant.ty_infer += 1 }\n-                    if region && ty { total.both_infer += 1; variant.both_infer += 1 }\n+                    if ct { total.ct_infer += 1; variant.ct_infer += 1 }\n+                    if lt && ty && ct { total.all_infer += 1; variant.all_infer += 1 }\n                 }\n-                println!(\"Ty interner             total           ty region  both\");\n+                println!(\"Ty interner             total           ty lt ct all\");\n                 $(println!(\"    {:18}: {uses:6} {usespc:4.1}%, \\\n-                            {ty:4.1}% {region:5.1}% {both:4.1}%\",\n-                           stringify!($variant),\n-                           uses = $variant.total,\n-                           usespc = $variant.total as f64 * 100.0 / total.total as f64,\n-                           ty = $variant.ty_infer as f64 * 100.0  / total.total as f64,\n-                           region = $variant.region_infer as f64 * 100.0  / total.total as f64,\n-                           both = $variant.both_infer as f64 * 100.0  / total.total as f64);\n-                  )*\n+                            {ty:4.1}% {lt:5.1}% {ct:4.1}% {all:4.1}%\",\n+                    stringify!($variant),\n+                    uses = $variant.total,\n+                    usespc = $variant.total as f64 * 100.0 / total.total as f64,\n+                    ty = $variant.ty_infer as f64 * 100.0  / total.total as f64,\n+                    lt = $variant.lt_infer as f64 * 100.0  / total.total as f64,\n+                    ct = $variant.ct_infer as f64 * 100.0  / total.total as f64,\n+                    all = $variant.all_infer as f64 * 100.0  / total.total as f64);\n+                )*\n                 println!(\"                  total {uses:6}        \\\n-                          {ty:4.1}% {region:5.1}% {both:4.1}%\",\n-                         uses = total.total,\n-                         ty = total.ty_infer as f64 * 100.0  / total.total as f64,\n-                         region = total.region_infer as f64 * 100.0  / total.total as f64,\n-                         both = total.both_infer as f64 * 100.0  / total.total as f64)\n+                          {ty:4.1}% {lt:5.1}% {ct:4.1}% {all:4.1}%\",\n+                    uses = total.total,\n+                    ty = total.ty_infer as f64 * 100.0  / total.total as f64,\n+                    lt = total.lt_infer as f64 * 100.0  / total.total as f64,\n+                    ct = total.ct_infer as f64 * 100.0  / total.total as f64,\n+                    all = total.all_infer as f64 * 100.0  / total.total as f64)\n             }\n         }\n \n@@ -2518,7 +2539,10 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         let adt_def = self.adt_def(def_id);\n         let substs = InternalSubsts::for_item(self, def_id, |param, substs| {\n             match param.kind {\n-                GenericParamDefKind::Lifetime => bug!(),\n+                GenericParamDefKind::Lifetime |\n+                GenericParamDefKind::Const => {\n+                    bug!()\n+                }\n                 GenericParamDefKind::Type { has_default, .. } => {\n                     if param.index == 0 {\n                         ty.into()\n@@ -2659,10 +2683,18 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     #[inline]\n-    pub fn mk_var(self, v: TyVid) -> Ty<'tcx> {\n+    pub fn mk_ty_var(self, v: TyVid) -> Ty<'tcx> {\n         self.mk_infer(TyVar(v))\n     }\n \n+    #[inline]\n+    pub fn mk_const_var(self, v: ConstVid<'tcx>, ty: Ty<'tcx>) -> &'tcx LazyConst<'tcx> {\n+        self.mk_lazy_const(LazyConst::Evaluated(ty::Const {\n+            val: ConstValue::Infer(InferConst::Var(v)),\n+            ty,\n+        }))\n+    }\n+\n     #[inline]\n     pub fn mk_int_var(self, v: IntVid) -> Ty<'tcx> {\n         self.mk_infer(IntVar(v))\n@@ -2685,6 +2717,19 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self.mk_ty(Param(ParamTy { idx: index, name: name }))\n     }\n \n+    #[inline]\n+    pub fn mk_const_param(\n+        self,\n+        index: u32,\n+        name: InternedString,\n+        ty: Ty<'tcx>\n+    ) -> &'tcx LazyConst<'tcx> {\n+        self.mk_lazy_const(LazyConst::Evaluated(ty::Const {\n+            val: ConstValue::Param(ParamConst { index, name }),\n+            ty,\n+        }))\n+    }\n+\n     #[inline]\n     pub fn mk_self_type(self) -> Ty<'tcx> {\n         self.mk_ty_param(0, keywords::SelfUpper.name().as_interned_str())\n@@ -2695,7 +2740,10 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             GenericParamDefKind::Lifetime => {\n                 self.mk_region(ty::ReEarlyBound(param.to_early_bound_region_data())).into()\n             }\n-            GenericParamDefKind::Type {..} => self.mk_ty_param(param.index, param.name).into(),\n+            GenericParamDefKind::Type { .. } => self.mk_ty_param(param.index, param.name).into(),\n+            GenericParamDefKind::Const => {\n+                self.mk_const_param(param.index, param.name, self.type_of(param.def_id)).into()\n+            }\n         }\n     }\n "}, {"sha": "64ceb9729ed15374b47619090ece88830606c6be", "filename": "src/librustc/ty/flags.rs", "status": "modified", "additions": 24, "deletions": 8, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e/src%2Flibrustc%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e/src%2Flibrustc%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fflags.rs?ref=88f755f8a84df1d9e6b17cf10c96ae8b93481b2e", "patch": "@@ -1,5 +1,6 @@\n-use crate::ty::subst::SubstsRef;\n-use crate::ty::{self, Ty, TypeFlags, TypeFoldable};\n+use crate::ty::subst::{SubstsRef, UnpackedKind};\n+use crate::ty::{self, Ty, TypeFlags, TypeFoldable, InferConst};\n+use crate::mir::interpret::ConstValue;\n \n #[derive(Debug)]\n pub struct FlagComputation {\n@@ -232,6 +233,21 @@ impl FlagComputation {\n         }\n     }\n \n+    fn add_const(&mut self, c: &ty::LazyConst<'_>) {\n+        match c {\n+            ty::LazyConst::Unevaluated(_, substs) => self.add_substs(substs),\n+            // Only done to add the binder for the type. The type flags are\n+            // included in `Const::type_flags`.\n+            ty::LazyConst::Evaluated(ty::Const { ty, val }) => {\n+                self.add_ty(ty);\n+                if let ConstValue::Infer(InferConst::Canonical(debruijn, _)) = val {\n+                    self.add_binder(*debruijn)\n+                }\n+            }\n+        }\n+        self.add_flags(c.type_flags());\n+    }\n+\n     fn add_existential_projection(&mut self, projection: &ty::ExistentialProjection<'_>) {\n         self.add_substs(projection.substs);\n         self.add_ty(projection.ty);\n@@ -242,12 +258,12 @@ impl FlagComputation {\n     }\n \n     fn add_substs(&mut self, substs: SubstsRef<'_>) {\n-        for ty in substs.types() {\n-            self.add_ty(ty);\n-        }\n-\n-        for r in substs.regions() {\n-            self.add_region(r);\n+        for kind in substs {\n+            match kind.unpack() {\n+                UnpackedKind::Type(ty) => self.add_ty(ty),\n+                UnpackedKind::Lifetime(lt) => self.add_region(lt),\n+                UnpackedKind::Const(ct) => self.add_const(ct),\n+            }\n         }\n     }\n }"}, {"sha": "7f77d037bb6a1a715711d8f81e4979720adbd130", "filename": "src/librustc/ty/fold.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e/src%2Flibrustc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e/src%2Flibrustc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffold.rs?ref=88f755f8a84df1d9e6b17cf10c96ae8b93481b2e", "patch": "@@ -91,7 +91,9 @@ pub trait TypeFoldable<'tcx>: fmt::Debug + Clone {\n         self.has_type_flags(TypeFlags::HAS_TY_INFER)\n     }\n     fn needs_infer(&self) -> bool {\n-        self.has_type_flags(TypeFlags::HAS_TY_INFER | TypeFlags::HAS_RE_INFER)\n+        self.has_type_flags(\n+            TypeFlags::HAS_TY_INFER | TypeFlags::HAS_RE_INFER | TypeFlags::HAS_CT_INFER\n+        )\n     }\n     fn has_placeholders(&self) -> bool {\n         self.has_type_flags(TypeFlags::HAS_RE_PLACEHOLDER | TypeFlags::HAS_TY_PLACEHOLDER)\n@@ -117,7 +119,7 @@ pub trait TypeFoldable<'tcx>: fmt::Debug + Clone {\n     }\n \n     /// Indicates whether this value references only 'global'\n-    /// types/lifetimes that are the same regardless of what fn we are\n+    /// generic parameters that are the same regardless of what fn we are\n     /// in. This is used for caching.\n     fn is_global(&self) -> bool {\n         !self.has_type_flags(TypeFlags::HAS_FREE_LOCAL_NAMES)\n@@ -841,14 +843,13 @@ impl<'tcx> TypeVisitor<'tcx> for HasTypeFlagsVisitor {\n     }\n \n     fn visit_const(&mut self, c: &'tcx ty::LazyConst<'tcx>) -> bool {\n-        if let ty::LazyConst::Unevaluated(..) = c {\n-            let projection_flags = TypeFlags::HAS_NORMALIZABLE_PROJECTION |\n-                TypeFlags::HAS_PROJECTION;\n-            if projection_flags.intersects(self.flags) {\n-                return true;\n-            }\n+        let flags = c.type_flags();\n+        debug!(\"HasTypeFlagsVisitor: c={:?} c.flags={:?} self.flags={:?}\", c, flags, self.flags);\n+        if flags.intersects(self.flags) {\n+            true\n+        } else {\n+            c.super_visit_with(self)\n         }\n-        c.super_visit_with(self)\n     }\n }\n "}, {"sha": "a649e312b434590d22209264293939bbc2c32ec8", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 29, "deletions": 6, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=88f755f8a84df1d9e6b17cf10c96ae8b93481b2e", "patch": "@@ -54,14 +54,14 @@ use crate::hir;\n \n pub use self::sty::{Binder, BoundTy, BoundTyKind, BoundVar, DebruijnIndex, INNERMOST};\n pub use self::sty::{FnSig, GenSig, CanonicalPolyFnSig, PolyFnSig, PolyGenSig};\n-pub use self::sty::{InferTy, ParamTy, ProjectionTy, ExistentialPredicate};\n+pub use self::sty::{InferTy, ParamTy, ParamConst, InferConst, ProjectionTy, ExistentialPredicate};\n pub use self::sty::{ClosureSubsts, GeneratorSubsts, UpvarSubsts, TypeAndMut};\n pub use self::sty::{TraitRef, TyKind, PolyTraitRef};\n pub use self::sty::{ExistentialTraitRef, PolyExistentialTraitRef};\n pub use self::sty::{ExistentialProjection, PolyExistentialProjection, Const, LazyConst};\n pub use self::sty::{BoundRegion, EarlyBoundRegion, FreeRegion, Region};\n pub use self::sty::RegionKind;\n-pub use self::sty::{TyVid, IntVid, FloatVid, RegionVid};\n+pub use self::sty::{TyVid, IntVid, FloatVid, ConstVid, RegionVid};\n pub use self::sty::BoundRegion::*;\n pub use self::sty::InferTy::*;\n pub use self::sty::RegionKind::*;\n@@ -451,6 +451,8 @@ bitflags! {\n \n         const HAS_TY_PLACEHOLDER = 1 << 14;\n \n+        const HAS_CT_INFER = 1 << 15;\n+\n         const NEEDS_SUBST        = TypeFlags::HAS_PARAMS.bits |\n                                    TypeFlags::HAS_SELF.bits |\n                                    TypeFlags::HAS_RE_EARLY_BOUND.bits;\n@@ -462,6 +464,7 @@ bitflags! {\n                                   TypeFlags::HAS_SELF.bits |\n                                   TypeFlags::HAS_TY_INFER.bits |\n                                   TypeFlags::HAS_RE_INFER.bits |\n+                                  TypeFlags::HAS_CT_INFER.bits |\n                                   TypeFlags::HAS_RE_PLACEHOLDER.bits |\n                                   TypeFlags::HAS_RE_EARLY_BOUND.bits |\n                                   TypeFlags::HAS_FREE_REGIONS.bits |\n@@ -837,7 +840,8 @@ pub enum GenericParamDefKind {\n         has_default: bool,\n         object_lifetime_default: ObjectLifetimeDefault,\n         synthetic: Option<hir::SyntheticTyParamKind>,\n-    }\n+    },\n+    Const,\n }\n \n #[derive(Clone, RustcEncodable, RustcDecodable)]\n@@ -880,6 +884,7 @@ impl GenericParamDef {\n pub struct GenericParamCount {\n     pub lifetimes: usize,\n     pub types: usize,\n+    pub consts: usize,\n }\n \n /// Information about the formal type/lifetime parameters associated\n@@ -915,6 +920,7 @@ impl<'a, 'gcx, 'tcx> Generics {\n             match param.kind {\n                 GenericParamDefKind::Lifetime => own_counts.lifetimes += 1,\n                 GenericParamDefKind::Type { .. } => own_counts.types += 1,\n+                GenericParamDefKind::Const => own_counts.consts += 1,\n             };\n         }\n \n@@ -924,7 +930,7 @@ impl<'a, 'gcx, 'tcx> Generics {\n     pub fn requires_monomorphization(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> bool {\n         for param in &self.params {\n             match param.kind {\n-                GenericParamDefKind::Type { .. } => return true,\n+                GenericParamDefKind::Type { .. } | GenericParamDefKind::Const => return true,\n                 GenericParamDefKind::Lifetime => {}\n             }\n         }\n@@ -944,7 +950,7 @@ impl<'a, 'gcx, 'tcx> Generics {\n         if let Some(index) = param.index.checked_sub(self.parent_count as u32) {\n             let param = &self.params[index as usize];\n             match param.kind {\n-                ty::GenericParamDefKind::Lifetime => param,\n+                GenericParamDefKind::Lifetime => param,\n                 _ => bug!(\"expected lifetime parameter, but found another generic parameter\")\n             }\n         } else {\n@@ -961,14 +967,31 @@ impl<'a, 'gcx, 'tcx> Generics {\n         if let Some(index) = param.idx.checked_sub(self.parent_count as u32) {\n             let param = &self.params[index as usize];\n             match param.kind {\n-                ty::GenericParamDefKind::Type {..} => param,\n+                GenericParamDefKind::Type { .. } => param,\n                 _ => bug!(\"expected type parameter, but found another generic parameter\")\n             }\n         } else {\n             tcx.generics_of(self.parent.expect(\"parent_count > 0 but no parent?\"))\n                .type_param(param, tcx)\n         }\n     }\n+\n+    /// Returns the `ConstParameterDef` associated with this `ParamConst`.\n+    pub fn const_param(&'tcx self,\n+                       param: &ParamConst,\n+                       tcx: TyCtxt<'a, 'gcx, 'tcx>)\n+                       -> &GenericParamDef {\n+        if let Some(index) = param.index.checked_sub(self.parent_count as u32) {\n+            let param = &self.params[index as usize];\n+            match param.kind {\n+                GenericParamDefKind::Const => param,\n+                _ => bug!(\"expected const parameter, but found another generic parameter\")\n+            }\n+        } else {\n+            tcx.generics_of(self.parent.expect(\"parent_count>0 but no parent?\"))\n+                .const_param(param, tcx)\n+        }\n+    }\n }\n \n /// Bounds on generics."}, {"sha": "3a31801b3be39f2c0728007f0319d6e89d810317", "filename": "src/librustc/ty/relate.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e/src%2Flibrustc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e/src%2Flibrustc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Frelate.rs?ref=88f755f8a84df1d9e6b17cf10c96ae8b93481b2e", "patch": "@@ -705,6 +705,9 @@ impl<'tcx> Relate<'tcx> for Kind<'tcx> {\n             (UnpackedKind::Type(unpacked), x) => {\n                 bug!(\"impossible case reached: can't relate: {:?} with {:?}\", unpacked, x)\n             }\n+            (UnpackedKind::Const(_), _) => {\n+                unimplemented!() // FIXME(const_generics)\n+            }\n         }\n     }\n }"}, {"sha": "f9eb336a4a3e2def619c58c7678b937e3d7fcc23", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=88f755f8a84df1d9e6b17cf10c96ae8b93481b2e", "patch": "@@ -5,12 +5,13 @@\n \n use crate::mir::ProjectionKind;\n use crate::mir::interpret::ConstValue;\n-use crate::ty::{self, Lift, Ty, TyCtxt};\n+use crate::ty::{self, Lift, Ty, TyCtxt, ConstVid, InferConst};\n use crate::ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n use smallvec::SmallVec;\n use crate::mir::interpret;\n \n+use std::marker::PhantomData;\n use std::rc::Rc;\n \n ///////////////////////////////////////////////////////////////////////////\n@@ -49,6 +50,7 @@ CloneTypeFoldableAndLiftImpls! {\n     crate::ty::BoundRegion,\n     crate::ty::ClosureKind,\n     crate::ty::IntVarValue,\n+    crate::ty::ParamConst,\n     crate::ty::ParamTy,\n     crate::ty::UniverseIndex,\n     crate::ty::Variance,\n@@ -503,6 +505,14 @@ impl<'a, 'tcx> Lift<'tcx> for ConstValue<'a> {\n     type Lifted = ConstValue<'tcx>;\n     fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n         match *self {\n+            ConstValue::Param(param) => Some(ConstValue::Param(param)),\n+            ConstValue::Infer(infer) => {\n+                Some(ConstValue::Infer(match infer {\n+                    InferConst::Var(vid) => InferConst::Var(vid.lift_to_tcx(tcx)?),\n+                    InferConst::Fresh(i) => InferConst::Fresh(i),\n+                    InferConst::Canonical(debrujin, var) => InferConst::Canonical(debrujin, var),\n+                }))\n+            }\n             ConstValue::Scalar(x) => Some(ConstValue::Scalar(x)),\n             ConstValue::Slice(x, y) => Some(ConstValue::Slice(x, y)),\n             ConstValue::ByRef(ptr, alloc) => Some(ConstValue::ByRef(\n@@ -512,6 +522,16 @@ impl<'a, 'tcx> Lift<'tcx> for ConstValue<'a> {\n     }\n }\n \n+impl<'a, 'tcx> Lift<'tcx> for ConstVid<'a> {\n+    type Lifted = ConstVid<'tcx>;\n+    fn lift_to_tcx<'b, 'gcx>(&self, _: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+        Some(ConstVid {\n+            index: self.index,\n+            phantom: PhantomData,\n+        })\n+    }\n+}\n+\n ///////////////////////////////////////////////////////////////////////////\n // TypeFoldable implementations.\n //"}, {"sha": "1aa4ca7ff97abd3d34f36fd058e26b36972f7bbc", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=88f755f8a84df1d9e6b17cf10c96ae8b93481b2e", "patch": "@@ -16,6 +16,7 @@ use crate::mir::interpret::{Scalar, Pointer};\n use smallvec::SmallVec;\n use std::iter;\n use std::cmp::Ordering;\n+use std::marker::PhantomData;\n use rustc_target::spec::abi;\n use syntax::ast::{self, Ident};\n use syntax::symbol::{keywords, InternedString};\n@@ -1061,6 +1062,26 @@ impl<'a, 'gcx, 'tcx> ParamTy {\n     }\n }\n \n+#[derive(Copy, Clone, Hash, RustcEncodable, RustcDecodable, Eq, PartialEq, Ord, PartialOrd)]\n+pub struct ParamConst {\n+    pub index: u32,\n+    pub name: InternedString,\n+}\n+\n+impl<'a, 'gcx, 'tcx> ParamConst {\n+    pub fn new(index: u32, name: InternedString) -> ParamConst {\n+        ParamConst { index, name }\n+    }\n+\n+    pub fn for_def(def: &ty::GenericParamDef) -> ParamConst {\n+        ParamConst::new(def.index, def.name)\n+    }\n+\n+    pub fn to_const(self, tcx: TyCtxt<'a, 'gcx, 'tcx>, ty: Ty<'tcx>) -> &'tcx LazyConst<'tcx> {\n+        tcx.mk_const_param(self.index, self.name, ty)\n+    }\n+}\n+\n /// A [De Bruijn index][dbi] is a standard means of representing\n /// regions (and perhaps later types) in a higher-ranked setting. In\n /// particular, imagine a type like this:\n@@ -1229,6 +1250,12 @@ pub struct TyVid {\n     pub index: u32,\n }\n \n+#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n+pub struct ConstVid<'tcx> {\n+    pub index: u32,\n+    pub phantom: PhantomData<&'tcx ()>,\n+}\n+\n #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n pub struct IntVid {\n     pub index: u32,\n@@ -2083,6 +2110,22 @@ impl<'tcx> LazyConst<'tcx> {\n     pub fn unwrap_usize(&self, tcx: TyCtxt<'_, '_, '_>) -> u64 {\n         self.assert_usize(tcx).expect(\"expected `LazyConst` to contain a usize\")\n     }\n+\n+    pub fn type_flags(&self) -> TypeFlags {\n+        // FIXME(const_generics): incorporate substs flags.\n+        let flags = match self {\n+            LazyConst::Unevaluated(..) => {\n+                TypeFlags::HAS_NORMALIZABLE_PROJECTION | TypeFlags::HAS_PROJECTION\n+            }\n+            LazyConst::Evaluated(c) => {\n+                c.type_flags()\n+            }\n+        };\n+\n+        debug!(\"type_flags({:?}) = {:?}\", self, flags);\n+\n+        flags\n+    }\n }\n \n /// Typed constant value.\n@@ -2198,6 +2241,44 @@ impl<'tcx> Const<'tcx> {\n         self.assert_usize(tcx).unwrap_or_else(||\n             bug!(\"expected constant usize, got {:#?}\", self))\n     }\n+\n+    pub fn type_flags(&self) -> TypeFlags {\n+        let mut flags = self.ty.flags;\n+\n+        match self.val {\n+            ConstValue::Param(_) => {\n+                flags |= TypeFlags::HAS_FREE_LOCAL_NAMES;\n+                flags |= TypeFlags::HAS_PARAMS;\n+            }\n+            ConstValue::Infer(infer) => {\n+                flags |= TypeFlags::HAS_FREE_LOCAL_NAMES;\n+                flags |= TypeFlags::HAS_CT_INFER;\n+                match infer {\n+                    InferConst::Fresh(_) |\n+                    InferConst::Canonical(_, _) => {}\n+                    InferConst::Var(_) => {\n+                        flags |= TypeFlags::KEEP_IN_LOCAL_TCX;\n+                    }\n+                }\n+            }\n+            _ => {}\n+        }\n+\n+        debug!(\"type_flags({:?}) = {:?}\", self, flags);\n+\n+        flags\n+    }\n }\n \n impl<'tcx> serialize::UseSpecializedDecodable for &'tcx LazyConst<'tcx> {}\n+\n+/// An inference variable for a const, for use in const generics.\n+#[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord, RustcEncodable, RustcDecodable, Hash)]\n+pub enum InferConst<'tcx> {\n+    /// Infer the value of the const.\n+    Var(ConstVid<'tcx>),\n+    /// A fresh const variable. See `infer::freshen` for more details.\n+    Fresh(u32),\n+    /// Canonicalized const variable, used only when preparing a trait query.\n+    Canonical(DebruijnIndex, BoundVar),\n+}"}, {"sha": "35c6f980cd9342d77969dbf8f4603f2f8c86821f", "filename": "src/librustc/ty/subst.rs", "status": "modified", "additions": 110, "deletions": 6, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e/src%2Flibrustc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e/src%2Flibrustc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsubst.rs?ref=88f755f8a84df1d9e6b17cf10c96ae8b93481b2e", "patch": "@@ -2,8 +2,9 @@\n \n use crate::hir::def_id::DefId;\n use crate::infer::canonical::Canonical;\n-use crate::ty::{self, Lift, List, Ty, TyCtxt};\n+use crate::ty::{self, Lift, List, Ty, TyCtxt, InferConst, ParamConst};\n use crate::ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n+use crate::mir::interpret::ConstValue;\n \n use serialize::{self, Encodable, Encoder, Decodable, Decoder};\n use syntax_pos::{Span, DUMMY_SP};\n@@ -17,24 +18,26 @@ use std::mem;\n use std::num::NonZeroUsize;\n \n /// An entity in the Rust type system, which can be one of\n-/// several kinds (only types and lifetimes for now).\n+/// several kinds (types, lifetimes, and consts).\n /// To reduce memory usage, a `Kind` is a interned pointer,\n /// with the lowest 2 bits being reserved for a tag to\n-/// indicate the type (`Ty` or `Region`) it points to.\n+/// indicate the type (`Ty`, `Region`, or `Const`) it points to.\n #[derive(Copy, Clone, PartialEq, Eq, Hash)]\n pub struct Kind<'tcx> {\n     ptr: NonZeroUsize,\n-    marker: PhantomData<(Ty<'tcx>, ty::Region<'tcx>)>\n+    marker: PhantomData<(Ty<'tcx>, ty::Region<'tcx>, &'tcx ty::LazyConst<'tcx>)>\n }\n \n const TAG_MASK: usize = 0b11;\n const TYPE_TAG: usize = 0b00;\n const REGION_TAG: usize = 0b01;\n+const CONST_TAG: usize = 0b10;\n \n #[derive(Debug, RustcEncodable, RustcDecodable, PartialEq, Eq, PartialOrd, Ord)]\n pub enum UnpackedKind<'tcx> {\n     Lifetime(ty::Region<'tcx>),\n     Type(Ty<'tcx>),\n+    Const(&'tcx ty::LazyConst<'tcx>),\n }\n \n impl<'tcx> UnpackedKind<'tcx> {\n@@ -50,6 +53,11 @@ impl<'tcx> UnpackedKind<'tcx> {\n                 assert_eq!(mem::align_of_val(ty) & TAG_MASK, 0);\n                 (TYPE_TAG, ty as *const _ as usize)\n             }\n+            UnpackedKind::Const(ct) => {\n+                // Ensure we can use the tag bits.\n+                assert_eq!(mem::align_of_val(ct) & TAG_MASK, 0);\n+                (CONST_TAG, ct as *const _ as usize)\n+            }\n         };\n \n         Kind {\n@@ -85,6 +93,12 @@ impl<'tcx> From<Ty<'tcx>> for Kind<'tcx> {\n     }\n }\n \n+impl<'tcx> From<&'tcx ty::LazyConst<'tcx>> for Kind<'tcx> {\n+    fn from(c: &'tcx ty::LazyConst<'tcx>) -> Kind<'tcx> {\n+        UnpackedKind::Const(c).pack()\n+    }\n+}\n+\n impl<'tcx> Kind<'tcx> {\n     #[inline]\n     pub fn unpack(self) -> UnpackedKind<'tcx> {\n@@ -93,6 +107,7 @@ impl<'tcx> Kind<'tcx> {\n             match ptr & TAG_MASK {\n                 REGION_TAG => UnpackedKind::Lifetime(&*((ptr & !TAG_MASK) as *const _)),\n                 TYPE_TAG => UnpackedKind::Type(&*((ptr & !TAG_MASK) as *const _)),\n+                CONST_TAG => UnpackedKind::Const(&*((ptr & !TAG_MASK) as *const _)),\n                 _ => intrinsics::unreachable()\n             }\n         }\n@@ -104,6 +119,7 @@ impl<'tcx> fmt::Debug for Kind<'tcx> {\n         match self.unpack() {\n             UnpackedKind::Lifetime(lt) => write!(f, \"{:?}\", lt),\n             UnpackedKind::Type(ty) => write!(f, \"{:?}\", ty),\n+            UnpackedKind::Const(ct) => write!(f, \"{:?}\", ct),\n         }\n     }\n }\n@@ -113,6 +129,7 @@ impl<'tcx> fmt::Display for Kind<'tcx> {\n         match self.unpack() {\n             UnpackedKind::Lifetime(lt) => write!(f, \"{}\", lt),\n             UnpackedKind::Type(ty) => write!(f, \"{}\", ty),\n+            UnpackedKind::Const(ct) => write!(f, \"{}\", ct),\n         }\n     }\n }\n@@ -122,8 +139,9 @@ impl<'a, 'tcx> Lift<'tcx> for Kind<'a> {\n \n     fn lift_to_tcx<'cx, 'gcx>(&self, tcx: TyCtxt<'cx, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n         match self.unpack() {\n-            UnpackedKind::Lifetime(a) => a.lift_to_tcx(tcx).map(|a| a.into()),\n-            UnpackedKind::Type(a) => a.lift_to_tcx(tcx).map(|a| a.into()),\n+            UnpackedKind::Lifetime(lt) => lt.lift_to_tcx(tcx).map(|lt| lt.into()),\n+            UnpackedKind::Type(ty) => ty.lift_to_tcx(tcx).map(|ty| ty.into()),\n+            UnpackedKind::Const(ct) => ct.lift_to_tcx(tcx).map(|ct| ct.into()),\n         }\n     }\n }\n@@ -133,13 +151,15 @@ impl<'tcx> TypeFoldable<'tcx> for Kind<'tcx> {\n         match self.unpack() {\n             UnpackedKind::Lifetime(lt) => lt.fold_with(folder).into(),\n             UnpackedKind::Type(ty) => ty.fold_with(folder).into(),\n+            UnpackedKind::Const(ct) => ct.fold_with(folder).into(),\n         }\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n         match self.unpack() {\n             UnpackedKind::Lifetime(lt) => lt.visit_with(visitor),\n             UnpackedKind::Type(ty) => ty.visit_with(visitor),\n+            UnpackedKind::Const(ct) => ct.visit_with(visitor),\n         }\n     }\n }\n@@ -195,6 +215,15 @@ impl<'a, 'gcx, 'tcx> InternalSubsts<'tcx> {\n                         ty::BoundRegion::BrNamed(param.def_id, param.name)\n                     )).into()\n                 }\n+\n+                ty::GenericParamDefKind::Const => {\n+                    tcx.mk_lazy_const(ty::LazyConst::Evaluated(ty::Const {\n+                        val: ConstValue::Infer(\n+                            InferConst::Canonical(ty::INNERMOST, ty::BoundVar::from(param.index))\n+                        ),\n+                        ty: tcx.type_of(def_id),\n+                    })).into()\n+                }\n             }\n         })\n     }\n@@ -283,6 +312,29 @@ impl<'a, 'gcx, 'tcx> InternalSubsts<'tcx> {\n         })\n     }\n \n+    #[inline]\n+    pub fn consts(&'a self) -> impl DoubleEndedIterator<Item = &'tcx ty::LazyConst<'tcx>> + 'a {\n+        self.iter().filter_map(|k| {\n+            if let UnpackedKind::Const(ct) = k.unpack() {\n+                Some(ct)\n+            } else {\n+                None\n+            }\n+        })\n+    }\n+\n+    #[inline]\n+    pub fn non_erasable_generics(\n+        &'a self\n+    ) -> impl DoubleEndedIterator<Item = UnpackedKind<'tcx>> + 'a {\n+        self.iter().filter_map(|k| {\n+            match k.unpack() {\n+                UnpackedKind::Lifetime(_) => None,\n+                generic => Some(generic),\n+            }\n+        })\n+    }\n+\n     #[inline]\n     pub fn type_at(&self, i: usize) -> Ty<'tcx> {\n         if let UnpackedKind::Type(ty) = self[i].unpack() {\n@@ -301,6 +353,15 @@ impl<'a, 'gcx, 'tcx> InternalSubsts<'tcx> {\n         }\n     }\n \n+    #[inline]\n+    pub fn const_at(&self, i: usize) -> &'tcx ty::LazyConst<'tcx> {\n+        if let UnpackedKind::Const(ct) = self[i].unpack() {\n+            ct\n+        } else {\n+            bug!(\"expected const for param #{} in {:?}\", i, self);\n+        }\n+    }\n+\n     #[inline]\n     pub fn type_for_def(&self, def: &ty::GenericParamDef) -> Kind<'tcx> {\n         self.type_at(def.index as usize).into()\n@@ -469,6 +530,21 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for SubstFolder<'a, 'gcx, 'tcx> {\n \n         return t1;\n     }\n+\n+    fn fold_const(&mut self, c: &'tcx ty::LazyConst<'tcx>) -> &'tcx ty::LazyConst<'tcx> {\n+        if !c.needs_subst() {\n+            return c;\n+        }\n+\n+        if let ty::LazyConst::Evaluated(ty::Const {\n+            val: ConstValue::Param(p),\n+            ..\n+        }) = c {\n+            self.const_for_param(*p, c)\n+        } else {\n+            c.super_fold_with(self)\n+        }\n+    }\n }\n \n impl<'a, 'gcx, 'tcx> SubstFolder<'a, 'gcx, 'tcx> {\n@@ -494,6 +570,34 @@ impl<'a, 'gcx, 'tcx> SubstFolder<'a, 'gcx, 'tcx> {\n         self.shift_vars_through_binders(ty)\n     }\n \n+    fn const_for_param(\n+        &self,\n+        p: ParamConst,\n+        source_cn: &'tcx ty::LazyConst<'tcx>\n+    ) -> &'tcx ty::LazyConst<'tcx> {\n+        // Look up the const in the substitutions. It really should be in there.\n+        let opt_cn = self.substs.get(p.index as usize).map(|k| k.unpack());\n+        let cn = match opt_cn {\n+            Some(UnpackedKind::Const(cn)) => cn,\n+            _ => {\n+                let span = self.span.unwrap_or(DUMMY_SP);\n+                span_bug!(\n+                    span,\n+                    \"Const parameter `{:?}` ({:?}/{}) out of range \\\n+                     when substituting (root type={:?}) substs={:?}\",\n+                    p,\n+                    source_cn,\n+                    p.index,\n+                    self.root_ty,\n+                    self.substs,\n+                );\n+            }\n+        };\n+\n+        // FIXME(const_generics): shift const through binders\n+        cn\n+    }\n+\n     /// It is sometimes necessary to adjust the De Bruijn indices during substitution. This occurs\n     /// when we are substituting a type with escaping bound vars into a context where we have\n     /// passed through binders. That's quite a mouthful. Let's see an example:"}, {"sha": "fb0d1e2080b06483c7921722b38ff73a824ebdbb", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=88f755f8a84df1d9e6b17cf10c96ae8b93481b2e", "patch": "@@ -12,6 +12,7 @@ use crate::ty::subst::{Subst, InternalSubsts, SubstsRef, UnpackedKind};\n use crate::ty::query::TyCtxtAt;\n use crate::ty::TyKind::*;\n use crate::ty::layout::{Integer, IntegerExt};\n+use crate::mir::interpret::ConstValue;\n use crate::util::common::ErrorReported;\n use crate::middle::lang_items;\n \n@@ -495,8 +496,16 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                     }) => {\n                         !impl_generics.type_param(pt, self).pure_wrt_drop\n                     }\n-                    UnpackedKind::Lifetime(_) | UnpackedKind::Type(_) => {\n-                        // not a type or region param - this should be reported\n+                    UnpackedKind::Const(&ty::LazyConst::Evaluated(ty::Const {\n+                        val: ConstValue::Param(ref pc),\n+                        ..\n+                    })) => {\n+                        !impl_generics.const_param(pc, self).pure_wrt_drop\n+                    }\n+                    UnpackedKind::Lifetime(_) |\n+                    UnpackedKind::Type(_) |\n+                    UnpackedKind::Const(_) => {\n+                        // Not a type, const or region param: this should be reported\n                         // as an error.\n                         false\n                     }\n@@ -587,15 +596,18 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         Some(ty::Binder::bind(env_ty))\n     }\n \n-    /// Given the `DefId` of some item that has no type parameters, make\n+    /// Given the `DefId` of some item that has no type or const parameters, make\n     /// a suitable \"empty substs\" for it.\n     pub fn empty_substs_for_def_id(self, item_def_id: DefId) -> SubstsRef<'tcx> {\n         InternalSubsts::for_item(self, item_def_id, |param, _| {\n             match param.kind {\n                 GenericParamDefKind::Lifetime => self.types.re_erased.into(),\n-                GenericParamDefKind::Type {..} => {\n+                GenericParamDefKind::Type { .. } => {\n                     bug!(\"empty_substs_for_def_id: {:?} has type parameters\", item_def_id)\n                 }\n+                GenericParamDefKind::Const { .. } => {\n+                    bug!(\"empty_substs_for_def_id: {:?} has const parameters\", item_def_id)\n+                }\n             }\n         })\n     }"}, {"sha": "cdc0c3371ebcd9218e178c8cd3915b1a66c4c296", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 67, "deletions": 3, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=88f755f8a84df1d9e6b17cf10c96ae8b93481b2e", "patch": "@@ -8,7 +8,8 @@ use crate::ty::{Error, Str, Array, Slice, Float, FnDef, FnPtr};\n use crate::ty::{Param, Bound, RawPtr, Ref, Never, Tuple};\n use crate::ty::{Closure, Generator, GeneratorWitness, Foreign, Projection, Opaque};\n use crate::ty::{Placeholder, UnnormalizedProjection, Dynamic, Int, Uint, Infer};\n-use crate::ty::{self, Ty, TyCtxt, TypeFoldable, GenericParamCount, GenericParamDefKind};\n+use crate::ty::{self, Ty, TyCtxt, TypeFoldable, GenericParamCount, GenericParamDefKind, ParamConst};\n+use crate::mir::interpret::ConstValue;\n use crate::util::nodemap::FxHashSet;\n \n use std::cell::Cell;\n@@ -478,6 +479,7 @@ impl PrintContext {\n                         GenericParamDefKind::Type { has_default, .. } => {\n                             Some((param.def_id, has_default))\n                         }\n+                        GenericParamDefKind::Const => None, // FIXME(const_generics:defaults)\n                     }).peekable();\n                 let has_default = {\n                     let has_default = type_params.peek().map(|(_, has_default)| has_default);\n@@ -571,6 +573,14 @@ impl PrintContext {\n             )?;\n         }\n \n+        // FIXME(const_generics::defaults)\n+        let consts = substs.consts();\n+\n+        for ct in consts {\n+            start_or_continue(f, \"<\", \", \")?;\n+            ct.print_display(f, self)?;\n+        }\n+\n         start_or_continue(f, \"\", \">\")?;\n \n         // For values, also print their name and type parameters.\n@@ -763,7 +773,8 @@ impl fmt::Debug for ty::GenericParamDef {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         let type_name = match self.kind {\n             ty::GenericParamDefKind::Lifetime => \"Lifetime\",\n-            ty::GenericParamDefKind::Type {..} => \"Type\",\n+            ty::GenericParamDefKind::Type { .. } => \"Type\",\n+            ty::GenericParamDefKind::Const => \"Const\",\n         };\n         write!(f, \"{}({}, {:?}, {})\",\n                type_name,\n@@ -1088,6 +1099,12 @@ impl fmt::Debug for ty::TyVid {\n     }\n }\n \n+impl<'tcx> fmt::Debug for ty::ConstVid<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"_#{}f\", self.index)\n+    }\n+}\n+\n impl fmt::Debug for ty::IntVid {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         write!(f, \"_#{}i\", self.index)\n@@ -1448,7 +1465,12 @@ define_print! {\n                             write!(f, \"_\")?;\n                         }\n                         ty::LazyConst::Evaluated(c) => ty::tls::with(|tcx| {\n-                            write!(f, \"{}\", c.unwrap_usize(tcx))\n+                            match c.val {\n+                                ConstValue::Infer(..) => write!(f, \"_\"),\n+                                ConstValue::Param(ParamConst { name, .. }) =>\n+                                    write!(f, \"{}\", name),\n+                                _ => write!(f, \"{}\", c.unwrap_usize(tcx)),\n+                            }\n                         })?,\n                     }\n                     write!(f, \"]\")\n@@ -1472,6 +1494,37 @@ define_print! {\n     }\n }\n \n+define_print! {\n+    ('tcx) ConstValue<'tcx>, (self, f, cx) {\n+        display {\n+            match self {\n+                ConstValue::Infer(..) => write!(f, \"_\"),\n+                ConstValue::Param(ParamConst { name, .. }) => write!(f, \"{}\", name),\n+                _ => write!(f, \"{:?}\", self),\n+            }\n+        }\n+    }\n+}\n+\n+define_print! {\n+    ('tcx) ty::Const<'tcx>, (self, f, cx) {\n+        display {\n+            write!(f, \"{} : {}\", self.val, self.ty)\n+        }\n+    }\n+}\n+\n+define_print! {\n+    ('tcx) ty::LazyConst<'tcx>, (self, f, cx) {\n+        display {\n+            match self {\n+                ty::LazyConst::Unevaluated(..) => write!(f, \"_ : _\"),\n+                ty::LazyConst::Evaluated(c) => write!(f, \"{}\", c),\n+            }\n+        }\n+    }\n+}\n+\n define_print! {\n     () ty::ParamTy, (self, f, cx) {\n         display {\n@@ -1483,6 +1536,17 @@ define_print! {\n     }\n }\n \n+define_print! {\n+    () ty::ParamConst, (self, f, cx) {\n+        display {\n+            write!(f, \"{}\", self.name)\n+        }\n+        debug {\n+            write!(f, \"{}/#{}\", self.name, self.index)\n+        }\n+    }\n+}\n+\n define_print! {\n     ('tcx, T: Print + fmt::Debug, U: Print + fmt::Debug) ty::OutlivesPredicate<T, U>,\n     (self, f, cx) {"}, {"sha": "2d732adcb91381650d7114fd298098fb75e04cfb", "filename": "src/librustc_codegen_llvm/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e/src%2Flibrustc_codegen_llvm%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e/src%2Flibrustc_codegen_llvm%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcallee.rs?ref=88f755f8a84df1d9e6b17cf10c96ae8b93481b2e", "patch": "@@ -113,7 +113,7 @@ pub fn get_fn(\n         unsafe {\n             llvm::LLVMRustSetLinkage(llfn, llvm::Linkage::ExternalLinkage);\n \n-            let is_generic = instance.substs.types().next().is_some();\n+            let is_generic = instance.substs.non_erasable_generics().next().is_some();\n \n             if is_generic {\n                 // This is a monomorphization. Its expected visibility depends"}, {"sha": "336f41b784a81cf3793ec6c213e684e4bfaf35bc", "filename": "src/librustc_codegen_ssa/back/symbol_export.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs?ref=88f755f8a84df1d9e6b17cf10c96ae8b93481b2e", "patch": "@@ -263,7 +263,7 @@ fn exported_symbols_provider_local<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 def: InstanceDef::Item(def_id),\n                 substs,\n             }) = mono_item {\n-                if substs.types().next().is_some() {\n+                if substs.non_erasable_generics().next().is_some() {\n                     symbols.push((ExportedSymbol::Generic(def_id, substs),\n                                   SymbolExportLevel::Rust));\n                 }"}, {"sha": "55a1eb016e0d0db1224b41b5b068d5440b80dd14", "filename": "src/librustc_codegen_ssa/mir/operand.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs?ref=88f755f8a84df1d9e6b17cf10c96ae8b93481b2e", "patch": "@@ -76,6 +76,8 @@ impl<'a, 'tcx: 'a, V: CodegenObject> OperandRef<'tcx, V> {\n         }\n \n         let val = match val.val {\n+            ConstValue::Param(_) => bug!(\"encountered a ConstValue::Param in codegen\"),\n+            ConstValue::Infer(_) => bug!(\"encountered a ConstValue::Infer in codegen\"),\n             ConstValue::Scalar(x) => {\n                 let scalar = match layout.abi {\n                     layout::Abi::Scalar(ref x) => x,"}, {"sha": "76e74e9e2b4640f219e22172c7482697a58b469a", "filename": "src/librustc_codegen_utils/symbol_names.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs?ref=88f755f8a84df1d9e6b17cf10c96ae8b93481b2e", "patch": "@@ -172,7 +172,7 @@ fn get_symbol_hash<'a, 'tcx>(\n         assert!(!substs.needs_subst());\n         substs.hash_stable(&mut hcx, &mut hasher);\n \n-        let is_generic = substs.types().next().is_some();\n+        let is_generic = substs.non_erasable_generics().next().is_some();\n         let avoid_cross_crate_conflicts =\n             // If this is an instance of a generic function, we also hash in\n             // the ID of the instantiating crate. This avoids symbol conflicts"}, {"sha": "fdede054e15f304516dffe2c3c5d9f233c6363b7", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting/region_name.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs?ref=88f755f8a84df1d9e6b17cf10c96ae8b93481b2e", "patch": "@@ -604,7 +604,14 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                     search_stack.push((ty, hir_ty));\n                 }\n \n-                (UnpackedKind::Lifetime(_), _) | (UnpackedKind::Type(_), _) => {\n+                (UnpackedKind::Const(_ct), hir::GenericArg::Const(_hir_ct)) => {\n+                    // Lifetimes cannot be found in consts, so we don't need\n+                    // to search anything here.\n+                }\n+\n+                (UnpackedKind::Lifetime(_), _)\n+                | (UnpackedKind::Type(_), _)\n+                | (UnpackedKind::Const(_), _) => {\n                     // I *think* that HIR lowering should ensure this\n                     // doesn't happen, even in erroneous\n                     // programs. Else we should use delay-span-bug."}, {"sha": "bef159e996b8778a60902d2a71d7c7116a992f5c", "filename": "src/librustc_mir/borrow_check/nll/type_check/constraint_conversion.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fconstraint_conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fconstraint_conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fconstraint_conversion.rs?ref=88f755f8a84df1d9e6b17cf10c96ae8b93481b2e", "patch": "@@ -99,6 +99,11 @@ impl<'a, 'gcx, 'tcx> ConstraintConversion<'a, 'gcx, 'tcx> {\n                     param_env,\n                 ).type_must_outlive(origin, t1, r2);\n             }\n+\n+            UnpackedKind::Const(_) => {\n+                // Consts cannot outlive one another, so we\n+                // don't need to handle any relations here.\n+            }\n         }\n     }\n "}, {"sha": "5b444ab9690ca7dcb76be567974639aa7097b78f", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=88f755f8a84df1d9e6b17cf10c96ae8b93481b2e", "patch": "@@ -2533,7 +2533,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                                     ),\n                                 ))\n                             }\n-                            UnpackedKind::Type(_) => None,\n+                            UnpackedKind::Type(_) | UnpackedKind::Const(_) => None,\n                         }\n                     })\n                     .collect();"}, {"sha": "e70756ad2f251869d047f6f6ce5b959ffffa2269", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 24, "deletions": 5, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=88f755f8a84df1d9e6b17cf10c96ae8b93481b2e", "patch": "@@ -5,7 +5,7 @@ use crate::hair::cx::to_ref::ToRef;\n use crate::hair::util::UserAnnotatedTyHelpers;\n use rustc_data_structures::indexed_vec::Idx;\n use rustc::hir::def::{Def, CtorKind};\n-use rustc::mir::interpret::{GlobalId, ErrorHandled};\n+use rustc::mir::interpret::{GlobalId, ErrorHandled, ConstValue};\n use rustc::ty::{self, AdtKind, Ty};\n use rustc::ty::adjustment::{Adjustment, Adjust, AutoBorrow, AutoBorrowMutability};\n use rustc::ty::cast::CastKind as TyCastKind;\n@@ -699,7 +699,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                 };\n \n                 let source = if let Some((did, offset, var_ty)) = var {\n-                    let mk_const = |literal| Expr {\n+                    let mk_lazy_const = |literal| Expr {\n                         temp_lifetime,\n                         ty: var_ty,\n                         span: expr.span,\n@@ -708,7 +708,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                             user_ty: None\n                         },\n                     }.to_ref();\n-                    let offset = mk_const(ty::LazyConst::Evaluated(ty::Const::from_bits(\n+                    let offset = mk_lazy_const(ty::LazyConst::Evaluated(ty::Const::from_bits(\n                         cx.tcx,\n                         offset as u128,\n                         cx.param_env.and(var_ty),\n@@ -718,7 +718,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                             // in case we are offsetting from a computed discriminant\n                             // and not the beginning of discriminants (which is always `0`)\n                             let substs = InternalSubsts::identity_for_item(cx.tcx(), did);\n-                            let lhs = mk_const(ty::LazyConst::Unevaluated(did, substs));\n+                            let lhs = mk_lazy_const(ty::LazyConst::Unevaluated(did, substs));\n                             let bin = ExprKind::Binary {\n                                 op: BinOp::Add,\n                                 lhs,\n@@ -925,7 +925,26 @@ fn convert_path_expr<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                 ))),\n                 user_ty,\n             }\n-        },\n+        }\n+\n+        Def::ConstParam(def_id) => {\n+            let node_id = cx.tcx.hir().as_local_node_id(def_id).unwrap();\n+            let item_id = cx.tcx.hir().get_parent_node(node_id);\n+            let item_def_id = cx.tcx.hir().local_def_id(item_id);\n+            let generics = cx.tcx.generics_of(item_def_id);\n+            let index = generics.param_def_id_to_index[&cx.tcx.hir().local_def_id(node_id)];\n+            let name = cx.tcx.hir().name(node_id).as_interned_str();\n+            let val = ConstValue::Param(ty::ParamConst::new(index, name));\n+            ExprKind::Literal {\n+                literal: cx.tcx.mk_lazy_const(\n+                    ty::LazyConst::Evaluated(ty::Const {\n+                        val,\n+                        ty: cx.tables().node_type(expr.hir_id),\n+                    })\n+                ),\n+                user_ty: None,\n+            }\n+        }\n \n         Def::Const(def_id) |\n         Def::AssociatedConst(def_id) => {"}, {"sha": "206eaaf1787c5ad0fbfee138837a4970d72f3500", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=88f755f8a84df1d9e6b17cf10c96ae8b93481b2e", "patch": "@@ -589,11 +589,12 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n         val: ty::Const<'tcx>,\n         layout: Option<TyLayout<'tcx>>,\n     ) -> EvalResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n+        let val = self.monomorphize(val)?;\n         let layout = from_known_layout(layout, || {\n-            let ty = self.monomorphize(val.ty)?;\n-            self.layout_of(ty)\n+            self.layout_of(val.ty)\n         })?;\n         let op = match val.val {\n+            ConstValue::Param(_) | ConstValue::Infer(_) => bug!(),\n             ConstValue::ByRef(ptr, alloc) => {\n                 // We rely on mutability being set correctly in that allocation to prevent writes\n                 // where none should happen -- and for `static mut`, we copy on demand anyway."}, {"sha": "4350bfcdc7a96978af07ba2242aa83ba2bd1c13b", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 20, "deletions": 7, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=88f755f8a84df1d9e6b17cf10c96ae8b93481b2e", "patch": "@@ -466,7 +466,16 @@ fn check_type_length_limit<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                      instance: Instance<'tcx>)\n {\n     let type_length = instance.substs.types().flat_map(|ty| ty.walk()).count();\n-    debug!(\" => type length={}\", type_length);\n+    let const_length = instance.substs.consts()\n+        .flat_map(|ct| {\n+            let ty = match ct {\n+                ty::LazyConst::Evaluated(ct) => ct.ty,\n+                ty::LazyConst::Unevaluated(def_id, _) => tcx.type_of(*def_id),\n+            };\n+            ty.walk()\n+        })\n+        .count();\n+    debug!(\" => type length={}, const length={}\", type_length, const_length);\n \n     // Rust code can easily create exponentially-long types using only a\n     // polynomial recursion depth. Even with the default recursion\n@@ -475,7 +484,9 @@ fn check_type_length_limit<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     //\n     // Bail out in these cases to avoid that bad user experience.\n     let type_length_limit = *tcx.sess.type_length_limit.get();\n-    if type_length > type_length_limit {\n+    // We include the const length in the type length, as it's better\n+    // to be overly conservative.\n+    if type_length + const_length > type_length_limit {\n         // The instance name is already known to be too long for rustc. Use\n         // `{:.64}` to avoid blasting the user's terminal with thousands of\n         // lines of type-name.\n@@ -490,7 +501,7 @@ fn check_type_length_limit<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n         diag.note(&format!(\n             \"consider adding a `#![type_length_limit=\\\"{}\\\"]` attribute to your crate\",\n-            type_length_limit*2));\n+            type_length_limit * 2));\n         diag.emit();\n         tcx.sess.abort_if_errors();\n     }\n@@ -759,10 +770,10 @@ fn should_monomorphize_locally<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, instance:\n             return false\n         }\n \n-        // If this instance has no type parameters, it cannot be a shared\n+        // If this instance has non-erasable parameters, it cannot be a shared\n         // monomorphization. Non-generic instances are already handled above\n         // by `is_reachable_non_generic()`\n-        if substs.types().next().is_none() {\n+        if substs.non_erasable_generics().next().is_none() {\n             return false\n         }\n \n@@ -1113,14 +1124,16 @@ fn create_mono_items_for_default_impls<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                         continue;\n                     }\n \n-                    if tcx.generics_of(method.def_id).own_counts().types != 0 {\n+                    let counts = tcx.generics_of(method.def_id).own_counts();\n+                    if counts.types + counts.consts != 0 {\n                         continue;\n                     }\n \n                     let substs = InternalSubsts::for_item(tcx, method.def_id, |param, _| {\n                         match param.kind {\n                             GenericParamDefKind::Lifetime => tcx.types.re_erased.into(),\n-                            GenericParamDefKind::Type {..} => {\n+                            GenericParamDefKind::Type { .. } |\n+                            GenericParamDefKind::Const => {\n                                 trait_ref.substs[param.index as usize]\n                             }\n                         }"}, {"sha": "f0d19ec8bf2fa71ca70a7976b3d1c510b3897aca", "filename": "src/librustc_mir/monomorphize/item.rs", "status": "modified", "additions": 38, "deletions": 14, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs?ref=88f755f8a84df1d9e6b17cf10c96ae8b93481b2e", "patch": "@@ -1,8 +1,9 @@\n use crate::monomorphize::Instance;\n use rustc::hir;\n use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n+use rustc::mir::interpret::ConstValue;\n use rustc::session::config::OptLevel;\n-use rustc::ty::{self, Ty, TyCtxt, ClosureSubsts, GeneratorSubsts};\n+use rustc::ty::{self, Ty, TyCtxt, Const, ClosureSubsts, GeneratorSubsts, LazyConst, ParamConst};\n use rustc::ty::subst::{SubstsRef, InternalSubsts};\n use syntax::ast;\n use syntax::attr::InlineAttr;\n@@ -44,7 +45,7 @@ pub trait MonoItemExt<'a, 'tcx>: fmt::Debug {\n     fn is_generic_fn(&self) -> bool {\n         match *self.as_mono_item() {\n             MonoItem::Fn(ref instance) => {\n-                instance.substs.types().next().is_some()\n+                instance.substs.non_erasable_generics().next().is_some()\n             }\n             MonoItem::Static(..) |\n             MonoItem::GlobalAsm(..) => false,\n@@ -267,7 +268,7 @@ impl<'a, 'tcx> DefPathBasedNames<'a, 'tcx> {\n             ty::Float(ast::FloatTy::F64) => output.push_str(\"f64\"),\n             ty::Adt(adt_def, substs) => {\n                 self.push_def_path(adt_def.did, output);\n-                self.push_type_params(substs, iter::empty(), output, debug);\n+                self.push_generic_params(substs, iter::empty(), output, debug);\n             },\n             ty::Tuple(component_types) => {\n                 output.push('(');\n@@ -312,7 +313,7 @@ impl<'a, 'tcx> DefPathBasedNames<'a, 'tcx> {\n             ty::Dynamic(ref trait_data, ..) => {\n                 if let Some(principal) = trait_data.principal() {\n                     self.push_def_path(principal.def_id(), output);\n-                    self.push_type_params(\n+                    self.push_generic_params(\n                         principal.skip_binder().substs,\n                         trait_data.projection_bounds(),\n                         output,\n@@ -373,7 +374,7 @@ impl<'a, 'tcx> DefPathBasedNames<'a, 'tcx> {\n                 self.push_def_path(def_id, output);\n                 let generics = self.tcx.generics_of(self.tcx.closure_base_def_id(def_id));\n                 let substs = substs.truncate_to(self.tcx, generics);\n-                self.push_type_params(substs, iter::empty(), output, debug);\n+                self.push_generic_params(substs, iter::empty(), output, debug);\n             }\n             ty::Error |\n             ty::Bound(..) |\n@@ -394,6 +395,24 @@ impl<'a, 'tcx> DefPathBasedNames<'a, 'tcx> {\n         }\n     }\n \n+    // FIXME(const_generics): handle debug printing.\n+    pub fn push_const_name(&self, c: &LazyConst<'tcx>, output: &mut String, debug: bool) {\n+        match c {\n+            LazyConst::Unevaluated(..) => output.push_str(\"_: _\"),\n+            LazyConst::Evaluated(Const { ty, val }) => {\n+                match val {\n+                    ConstValue::Infer(..) => output.push_str(\"_\"),\n+                    ConstValue::Param(ParamConst { name, .. }) => {\n+                        write!(output, \"{}\", name).unwrap();\n+                    }\n+                    _ => write!(output, \"{:?}\", c).unwrap(),\n+                }\n+                output.push_str(\": \");\n+                self.push_type_name(ty, output, debug);\n+            }\n+        }\n+    }\n+\n     pub fn push_def_path(&self,\n                          def_id: DefId,\n                          output: &mut String) {\n@@ -421,15 +440,15 @@ impl<'a, 'tcx> DefPathBasedNames<'a, 'tcx> {\n         output.pop();\n     }\n \n-    fn push_type_params<I>(&self,\n-                            substs: SubstsRef<'tcx>,\n-                            projections: I,\n-                            output: &mut String,\n-                            debug: bool)\n-        where I: Iterator<Item=ty::PolyExistentialProjection<'tcx>>\n-    {\n+    fn push_generic_params<I>(\n+        &self,\n+        substs: SubstsRef<'tcx>,\n+        projections: I,\n+        output: &mut String,\n+        debug: bool,\n+    ) where I: Iterator<Item=ty::PolyExistentialProjection<'tcx>> {\n         let mut projections = projections.peekable();\n-        if substs.types().next().is_none() && projections.peek().is_none() {\n+        if substs.non_erasable_generics().next().is_none() && projections.peek().is_none() {\n             return;\n         }\n \n@@ -449,6 +468,11 @@ impl<'a, 'tcx> DefPathBasedNames<'a, 'tcx> {\n             output.push_str(\", \");\n         }\n \n+        for const_parameter in substs.consts() {\n+            self.push_const_name(const_parameter, output, debug);\n+            output.push_str(\", \");\n+        }\n+\n         output.pop();\n         output.pop();\n \n@@ -460,6 +484,6 @@ impl<'a, 'tcx> DefPathBasedNames<'a, 'tcx> {\n                                    output: &mut String,\n                                    debug: bool) {\n         self.push_def_path(instance.def_id(), output);\n-        self.push_type_params(instance.substs, iter::empty(), output, debug);\n+        self.push_generic_params(instance.substs, iter::empty(), output, debug);\n     }\n }"}, {"sha": "f98bc476aafec872d40e0c85e67d20e92b795cb7", "filename": "src/librustc_mir/monomorphize/partitioning.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs?ref=88f755f8a84df1d9e6b17cf10c96ae8b93481b2e", "patch": "@@ -448,7 +448,7 @@ fn mono_item_visibility(\n         return Visibility::Hidden\n     }\n \n-    let is_generic = instance.substs.types().next().is_some();\n+    let is_generic = instance.substs.non_erasable_generics().next().is_some();\n \n     // Upstream `DefId` instances get different handling than local ones\n     if !def_id.is_local() {"}, {"sha": "1c6b1450be86230e2b40507023a6063d1db740d0", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=88f755f8a84df1d9e6b17cf10c96ae8b93481b2e", "patch": "@@ -2,7 +2,7 @@ use rustc::hir;\n use rustc::hir::def_id::DefId;\n use rustc::infer;\n use rustc::mir::*;\n-use rustc::ty::{self, Ty, TyCtxt, GenericParamDefKind};\n+use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::layout::VariantIdx;\n use rustc::ty::subst::{Subst, InternalSubsts};\n use rustc::ty::query::Providers;\n@@ -450,12 +450,7 @@ impl<'a, 'tcx> CloneShimBuilder<'a, 'tcx> {\n     ) {\n         let tcx = self.tcx;\n \n-        let substs = InternalSubsts::for_item(tcx, self.def_id, |param, _| {\n-            match param.kind {\n-                GenericParamDefKind::Lifetime => tcx.types.re_erased.into(),\n-                GenericParamDefKind::Type {..} => ty.into(),\n-            }\n-        });\n+        let substs = tcx.mk_substs_trait(ty, &[]);\n \n         // `func == Clone::clone(&ty) -> ty`\n         let func_ty = tcx.mk_fn_def(self.def_id, substs);"}, {"sha": "047731e3fe6a7bea4bd04ba1c6e9af9de64352bb", "filename": "src/librustc_mir/transform/check_unsafety.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs?ref=88f755f8a84df1d9e6b17cf10c96ae8b93481b2e", "patch": "@@ -558,9 +558,10 @@ fn unsafe_derive_on_repr_packed<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: D\n \n     // FIXME: when we make this a hard error, this should have its\n     // own error code.\n-    let message = if tcx.generics_of(def_id).own_counts().types != 0 {\n+    let counts = tcx.generics_of(def_id).own_counts();\n+    let message = if counts.types + counts.consts != 0 {\n         \"#[derive] can't be used on a #[repr(packed)] struct with \\\n-         type parameters (error E0133)\".to_string()\n+         type or const parameters (error E0133)\".to_string()\n     } else {\n         \"#[derive] can't be used on a #[repr(packed)] struct that \\\n          does not derive Copy (error E0133)\".to_string()"}, {"sha": "918375e426b7df606f30588a8b64a972fdf6be63", "filename": "src/librustc_mir/transform/inline.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finline.rs?ref=88f755f8a84df1d9e6b17cf10c96ae8b93481b2e", "patch": "@@ -259,7 +259,7 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n         // inlining. This is to ensure that the final crate doesn't have MIR that\n         // reference unexported symbols\n         if callsite.callee.is_local() {\n-            if callsite.substs.types().count() == 0 && !hinted {\n+            if callsite.substs.non_erasable_generics().count() == 0 && !hinted {\n                 debug!(\"    callee is an exported function - not inlining\");\n                 return false;\n             }"}, {"sha": "a9f05eb60db18f17fa559454e9de97c368fbbfb2", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=88f755f8a84df1d9e6b17cf10c96ae8b93481b2e", "patch": "@@ -748,12 +748,15 @@ impl<'a, 'tcx> ReachEverythingInTheInterfaceVisitor<'_, 'a, 'tcx> {\n     fn generics(&mut self) -> &mut Self {\n         for param in &self.ev.tcx.generics_of(self.item_def_id).params {\n             match param.kind {\n+                GenericParamDefKind::Lifetime => {}\n                 GenericParamDefKind::Type { has_default, .. } => {\n                     if has_default {\n                         self.visit(self.ev.tcx.type_of(param.def_id));\n                     }\n                 }\n-                GenericParamDefKind::Lifetime => {}\n+                GenericParamDefKind::Const => {\n+                    self.visit(self.ev.tcx.type_of(param.def_id));\n+                }\n             }\n         }\n         self\n@@ -1517,12 +1520,15 @@ impl<'a, 'tcx: 'a> SearchInterfaceForPrivateItemsVisitor<'a, 'tcx> {\n     fn generics(&mut self) -> &mut Self {\n         for param in &self.tcx.generics_of(self.item_def_id).params {\n             match param.kind {\n+                GenericParamDefKind::Lifetime => {}\n                 GenericParamDefKind::Type { has_default, .. } => {\n                     if has_default {\n                         self.visit(self.tcx.type_of(param.def_id));\n                     }\n                 }\n-                GenericParamDefKind::Lifetime => {}\n+                GenericParamDefKind::Const => {\n+                    self.visit(self.tcx.type_of(param.def_id));\n+                }\n             }\n         }\n         self"}, {"sha": "6420f20a3ea2904d02ce0d73636f35539cf189f4", "filename": "src/librustc_traits/chalk_context/mod.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e/src%2Flibrustc_traits%2Fchalk_context%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e/src%2Flibrustc_traits%2Fchalk_context%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk_context%2Fmod.rs?ref=88f755f8a84df1d9e6b17cf10c96ae8b93481b2e", "patch": "@@ -32,11 +32,12 @@ use rustc::traits::{\n     InEnvironment,\n     ChalkCanonicalGoal,\n };\n-use rustc::ty::{self, TyCtxt};\n+use rustc::ty::{self, TyCtxt, InferConst};\n use rustc::ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n use rustc::ty::query::Providers;\n use rustc::ty::subst::{Kind, UnpackedKind};\n use rustc_data_structures::sync::Lrc;\n+use rustc::mir::interpret::ConstValue;\n use syntax_pos::DUMMY_SP;\n \n use std::fmt::{self, Debug};\n@@ -287,6 +288,16 @@ impl context::ContextOps<ChalkArenas<'gcx>> for ChalkContext<'cx, 'gcx> {\n                     }\n                     _ => false,\n                 },\n+                UnpackedKind::Const(ct) => match ct {\n+                    ty::LazyConst::Evaluated(ty::Const {\n+                        val: ConstValue::Infer(InferConst::Canonical(debruijn, bound_ct)),\n+                        ..\n+                    }) => {\n+                        debug_assert_eq!(*debruijn, ty::INNERMOST);\n+                        cvar == *bound_ct\n+                    }\n+                    _ => false,\n+                }\n             })\n     }\n "}, {"sha": "be708c78a0dd138b95e5cfd660eb9b6f2a41ebfc", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 74, "deletions": 11, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=88f755f8a84df1d9e6b17cf10c96ae8b93481b2e", "patch": "@@ -3,7 +3,7 @@\n //! instance of `AstConv`.\n \n use errors::{Applicability, DiagnosticId};\n-use crate::hir::{self, GenericArg, GenericArgs};\n+use crate::hir::{self, GenericArg, GenericArgs, ExprKind};\n use crate::hir::def::Def;\n use crate::hir::def_id::DefId;\n use crate::hir::HirVec;\n@@ -16,6 +16,7 @@ use rustc::ty::{self, Ty, TyCtxt, ToPredicate, TypeFoldable};\n use rustc::ty::{GenericParamDef, GenericParamDefKind};\n use rustc::ty::subst::{Kind, Subst, InternalSubsts, SubstsRef};\n use rustc::ty::wf::object_region_bounds;\n+use rustc::mir::interpret::ConstValue;\n use rustc_data_structures::sync::Lrc;\n use rustc_target::spec::abi;\n use crate::require_c_abi_if_c_variadic;\n@@ -273,6 +274,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n         let param_counts = def.own_counts();\n         let arg_counts = args.own_counts();\n         let infer_lifetimes = position != GenericArgPosition::Type && arg_counts.lifetimes == 0;\n+        let infer_consts = position != GenericArgPosition::Type && arg_counts.consts == 0;\n \n         let mut defaults: ty::GenericParamCount = Default::default();\n         for param in &def.params {\n@@ -281,6 +283,9 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n                 GenericParamDefKind::Type { has_default, .. } => {\n                     defaults.types += has_default as usize\n                 }\n+                GenericParamDefKind::Const => {\n+                    // FIXME(const_generics:defaults)\n+                }\n             };\n         }\n \n@@ -311,11 +316,15 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n             }\n         }\n \n-        let check_kind_count = |kind,\n-                                required,\n-                                permitted,\n-                                provided,\n-                                offset| {\n+        let check_kind_count = |kind, required, permitted, provided, offset| {\n+            debug!(\n+                \"check_kind_count: kind: {} required: {} permitted: {} provided: {} offset: {}\",\n+                kind,\n+                required,\n+                permitted,\n+                provided,\n+                offset\n+            );\n             // We enforce the following: `required` <= `provided` <= `permitted`.\n             // For kinds without defaults (i.e., lifetimes), `required == permitted`.\n             // For other kinds (i.e., types), `permitted` may be greater than `required`.\n@@ -384,6 +393,17 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n                 0,\n             );\n         }\n+        // FIXME(const_generics:defaults)\n+        if !infer_consts || arg_counts.consts > param_counts.consts {\n+            check_kind_count(\n+                \"const\",\n+                param_counts.consts,\n+                param_counts.consts,\n+                arg_counts.consts,\n+                arg_counts.lifetimes + arg_counts.types,\n+            );\n+        }\n+        // Note that type errors are currently be emitted *after* const errors.\n         if !infer_types\n             || arg_counts.types > param_counts.types - defaults.types - has_self as usize {\n             check_kind_count(\n@@ -495,7 +515,8 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n                     (Some(&arg), Some(&param)) => {\n                         match (arg, &param.kind) {\n                             (GenericArg::Lifetime(_), GenericParamDefKind::Lifetime)\n-                            | (GenericArg::Type(_), GenericParamDefKind::Type { .. }) => {\n+                            | (GenericArg::Type(_), GenericParamDefKind::Type { .. })\n+                            | (GenericArg::Const(_), GenericParamDefKind::Const) => {\n                                 substs.push(provided_kind(param, arg));\n                                 args.next();\n                                 params.next();\n@@ -606,6 +627,9 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n                     (GenericParamDefKind::Type { .. }, GenericArg::Type(ty)) => {\n                         self.ast_ty_to_ty(&ty).into()\n                     }\n+                    (GenericParamDefKind::Const, GenericArg::Const(ct)) => {\n+                        self.ast_const_to_const(&ct.value, tcx.type_of(param.def_id)).into()\n+                    }\n                     _ => unreachable!(),\n                 }\n             },\n@@ -654,6 +678,11 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n                             tcx.types.err.into()\n                         }\n                     }\n+                    GenericParamDefKind::Const => {\n+                        // FIXME(const_generics:defaults)\n+                        // We've already errored above about the mismatch.\n+                        tcx.types.err.into()\n+                    }\n                 }\n             },\n         );\n@@ -1609,6 +1638,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n             // Case 3. Reference to a top-level value.\n             Def::Fn(def_id) |\n             Def::Const(def_id) |\n+            Def::ConstParam(def_id) |\n             Def::Static(def_id, _) => {\n                 path_segs.push(PathSeg(def_id, last));\n             }\n@@ -1797,10 +1827,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n                 self.associated_path_to_ty(ast_ty.hir_id, ast_ty.span, ty, def, segment, false).0\n             }\n             hir::TyKind::Array(ref ty, ref length) => {\n-                let length_def_id = tcx.hir().local_def_id_from_hir_id(length.hir_id);\n-                let substs = InternalSubsts::identity_for_item(tcx, length_def_id);\n-                let length = ty::LazyConst::Unevaluated(length_def_id, substs);\n-                let length = tcx.mk_lazy_const(length);\n+                let length = self.ast_const_to_const(length, tcx.types.usize);\n                 let array_ty = tcx.mk_ty(ty::Array(self.ast_ty_to_ty(&ty), length));\n                 self.normalize_ty(ast_ty.span, array_ty)\n             }\n@@ -1837,6 +1864,42 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n         result_ty\n     }\n \n+    pub fn ast_const_to_const(\n+        &self,\n+        ast_const: &hir::AnonConst,\n+        ty: Ty<'tcx>\n+    ) -> &'tcx ty::LazyConst<'tcx> {\n+        debug!(\"ast_const_to_const(id={:?}, ast_const={:?})\", ast_const.hir_id, ast_const);\n+\n+        let tcx = self.tcx();\n+        let def_id = tcx.hir().local_def_id_from_hir_id(ast_const.hir_id);\n+\n+        let mut lazy_const = ty::LazyConst::Unevaluated(\n+            def_id,\n+            InternalSubsts::identity_for_item(tcx, def_id),\n+        );\n+\n+        let expr = &tcx.hir().body(ast_const.body).value;\n+        if let ExprKind::Path(ref qpath) = expr.node {\n+            if let hir::QPath::Resolved(_, ref path) = qpath {\n+                if let Def::ConstParam(def_id) = path.def {\n+                    let node_id = tcx.hir().as_local_node_id(def_id).unwrap();\n+                    let item_id = tcx.hir().get_parent_node(node_id);\n+                    let item_def_id = tcx.hir().local_def_id(item_id);\n+                    let generics = tcx.generics_of(item_def_id);\n+                    let index = generics.param_def_id_to_index[&tcx.hir().local_def_id(node_id)];\n+                    let name = tcx.hir().name(node_id).as_interned_str();\n+                    lazy_const = ty::LazyConst::Evaluated(ty::Const {\n+                        val: ConstValue::Param(ty::ParamConst::new(index, name)),\n+                        ty,\n+                    })\n+                }\n+            }\n+        };\n+\n+        tcx.mk_lazy_const(lazy_const)\n+    }\n+\n     pub fn impl_trait_ty_to_ty(\n         &self,\n         def_id: DefId,"}, {"sha": "f7396cbd42f2ff87ecc0e3a3b4a6f68f40ab3bef", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=88f755f8a84df1d9e6b17cf10c96ae8b93481b2e", "patch": "@@ -99,11 +99,13 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let substs = base_substs.extend_to(self.tcx,expr_def_id, |param, _| {\n             match param.kind {\n                 GenericParamDefKind::Lifetime => {\n-                    span_bug!(expr.span, \"closure has region param\")\n+                    span_bug!(expr.span, \"closure has lifetime param\")\n                 }\n-                GenericParamDefKind::Type {..} => {\n-                    self.infcx\n-                        .next_ty_var(TypeVariableOrigin::ClosureSynthetic(expr.span)).into()\n+                GenericParamDefKind::Type { .. } => {\n+                    self.infcx.next_ty_var(TypeVariableOrigin::ClosureSynthetic(expr.span)).into()\n+                }\n+                GenericParamDefKind::Const => {\n+                    span_bug!(expr.span, \"closure has const param\")\n                 }\n             }\n         });"}, {"sha": "32640d7d9a886dabcfe31af17dbf0cc6882a5907", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 68, "deletions": 45, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=88f755f8a84df1d9e6b17cf10c96ae8b93481b2e", "patch": "@@ -6,7 +6,7 @@ use rustc::traits::{self, ObligationCause, ObligationCauseCode, Reveal};\n use rustc::ty::error::{ExpectedFound, TypeError};\n use rustc::ty::subst::{Subst, InternalSubsts, SubstsRef};\n use rustc::util::common::ErrorReported;\n-use errors::Applicability;\n+use errors::{Applicability, DiagnosticId};\n \n use syntax_pos::Span;\n \n@@ -576,55 +576,78 @@ fn compare_self_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     Ok(())\n }\n \n-fn compare_number_of_generics<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                        impl_m: &ty::AssociatedItem,\n-                                        impl_m_span: Span,\n-                                        trait_m: &ty::AssociatedItem,\n-                                        trait_item_span: Option<Span>)\n-                                        -> Result<(), ErrorReported> {\n-    let impl_m_generics = tcx.generics_of(impl_m.def_id);\n-    let trait_m_generics = tcx.generics_of(trait_m.def_id);\n-    let num_impl_m_type_params = impl_m_generics.own_counts().types;\n-    let num_trait_m_type_params = trait_m_generics.own_counts().types;\n-\n-    if num_impl_m_type_params != num_trait_m_type_params {\n-        let impl_m_node_id = tcx.hir().as_local_node_id(impl_m.def_id).unwrap();\n-        let impl_m_item = tcx.hir().expect_impl_item(impl_m_node_id);\n-        let span = if impl_m_item.generics.params.is_empty()\n-            || impl_m_item.generics.span.is_dummy()  // impl Trait in argument position (#55374)\n-        {\n-            impl_m_span\n-        } else {\n-            impl_m_item.generics.span\n-        };\n+fn compare_number_of_generics<'a, 'tcx>(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    impl_: &ty::AssociatedItem,\n+    impl_span: Span,\n+    trait_: &ty::AssociatedItem,\n+    trait_span: Option<Span>,\n+) -> Result<(), ErrorReported> {\n+    let trait_own_counts = tcx.generics_of(trait_.def_id).own_counts();\n+    let impl_own_counts = tcx.generics_of(impl_.def_id).own_counts();\n+\n+    let matchings = [\n+        (\"type\", trait_own_counts.types, impl_own_counts.types),\n+        (\"const\", trait_own_counts.consts, impl_own_counts.consts),\n+    ];\n+\n+    let mut err_occurred = false;\n+    for &(kind, trait_count, impl_count) in &matchings {\n+        if impl_count != trait_count {\n+            err_occurred = true;\n+\n+            let impl_node_id = tcx.hir().as_local_node_id(impl_.def_id).unwrap();\n+            let impl_item = tcx.hir().expect_impl_item(impl_node_id);\n+            let span = if impl_item.generics.params.is_empty()\n+                || impl_item.generics.span.is_dummy() { // argument position impl Trait (#55374)\n+                impl_span\n+            } else {\n+                impl_item.generics.span\n+            };\n \n-        let mut err = struct_span_err!(tcx.sess, span, E0049,\n-            \"method `{}` has {} but its trait declaration has {}\",\n-            trait_m.ident,\n-            potentially_plural_count(num_impl_m_type_params, \"type parameter\"),\n-            potentially_plural_count(num_trait_m_type_params, \"type parameter\")\n-        );\n+            let mut err = tcx.sess.struct_span_err_with_code(\n+                span,\n+                &format!(\n+                    \"method `{}` has {} {kind} parameter{} but its trait \\\n+                     declaration has {} {kind} parameter{}\",\n+                    trait_.ident,\n+                    impl_count,\n+                    if impl_count != 1 { \"s\" } else { \"\" },\n+                    trait_count,\n+                    if trait_count != 1 { \"s\" } else { \"\" },\n+                    kind = kind,\n+                ),\n+                DiagnosticId::Error(\"E0049\".into()),\n+            );\n \n-        let mut suffix = None;\n+            let mut suffix = None;\n \n-        if let Some(span) = trait_item_span {\n-            err.span_label(span, format!(\"expected {}\",\n-                potentially_plural_count(num_trait_m_type_params, \"type parameter\")));\n-        } else {\n-            suffix = Some(format!(\", expected {}\", num_trait_m_type_params));\n-        }\n-\n-        err.span_label(span,\n-                       format!(\"found {}{}\",\n-                           potentially_plural_count(num_impl_m_type_params, \"type parameter\"),\n-                           suffix.as_ref().map(|s| &s[..]).unwrap_or(\"\")));\n+            if let Some(span) = trait_span {\n+                err.span_label(\n+                    span,\n+                    format!(\"expected {} {} parameter{}\", trait_count, kind,\n+                        if trait_count != 1 { \"s\" } else { \"\" })\n+                );\n+            } else {\n+                suffix = Some(format!(\", expected {}\", trait_count));\n+            }\n \n-        err.emit();\n+            err.span_label(\n+                span,\n+                format!(\"found {} {} parameter{}{}\", impl_count, kind,\n+                    if impl_count != 1 { \"s\" } else { \"\" },\n+                    suffix.unwrap_or_else(|| String::new())),\n+            );\n \n-        return Err(ErrorReported);\n+            err.emit();\n+        }\n     }\n \n-    Ok(())\n+    if err_occurred {\n+        Err(ErrorReported)\n+    } else {\n+        Ok(())\n+    }\n }\n \n fn compare_number_of_method_arguments<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n@@ -725,12 +748,12 @@ fn compare_synthetic_generics<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let trait_m_generics = tcx.generics_of(trait_m.def_id);\n     let impl_m_type_params = impl_m_generics.params.iter().filter_map(|param| match param.kind {\n         GenericParamDefKind::Type { synthetic, .. } => Some((param.def_id, synthetic)),\n-        GenericParamDefKind::Lifetime => None,\n+        GenericParamDefKind::Lifetime | GenericParamDefKind::Const => None,\n     });\n     let trait_m_type_params = trait_m_generics.params.iter().filter_map(|param| {\n         match param.kind {\n             GenericParamDefKind::Type { synthetic, .. } => Some((param.def_id, synthetic)),\n-            GenericParamDefKind::Lifetime => None,\n+            GenericParamDefKind::Lifetime | GenericParamDefKind::Const => None,\n         }\n     });\n     for ((impl_def_id, impl_synthetic), (trait_def_id, trait_synthetic))"}, {"sha": "2184555a07d34e19c7892f392ab32af1bc4de623", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=88f755f8a84df1d9e6b17cf10c96ae8b93481b2e", "patch": "@@ -313,6 +313,9 @@ pub fn check_safety_of_destructor_if_necessary<'a, 'gcx, 'tcx>(\n         match kind.unpack() {\n             UnpackedKind::Lifetime(r) => rcx.sub_regions(origin(), parent_scope, r),\n             UnpackedKind::Type(ty) => rcx.type_must_outlive(origin(), ty, parent_scope),\n+            UnpackedKind::Const(_) => {\n+                // Generic consts don't add constraints.\n+            }\n         }\n     }\n     Ok(())"}, {"sha": "e0b96ae884f3a7e7d2b496d8128ca4744c1191c2", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=88f755f8a84df1d9e6b17cf10c96ae8b93481b2e", "patch": "@@ -341,6 +341,9 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n                     (GenericParamDefKind::Type { .. }, GenericArg::Type(ty)) => {\n                         self.to_ty(ty).into()\n                     }\n+                    (GenericParamDefKind::Const, GenericArg::Const(ct)) => {\n+                        self.to_const(&ct.value, self.tcx.type_of(param.def_id)).into()\n+                    }\n                     _ => unreachable!(),\n                 }\n             },"}, {"sha": "8f27b5b7dc81f746f4048976ebcef9c66534464b", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=88f755f8a84df1d9e6b17cf10c96ae8b93481b2e", "patch": "@@ -283,8 +283,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // Construct a trait-reference `self_ty : Trait<input_tys>`\n         let substs = InternalSubsts::for_item(self.tcx, trait_def_id, |param, _| {\n             match param.kind {\n-                GenericParamDefKind::Lifetime => {}\n-                GenericParamDefKind::Type {..} => {\n+                GenericParamDefKind::Lifetime | GenericParamDefKind::Const => {}\n+                GenericParamDefKind::Type { .. } => {\n                     if param.index == 0 {\n                         return self_ty.into();\n                     } else if let Some(ref input_types) = opt_input_types {"}, {"sha": "efae870c3c3a9a8dc93ef663cee3f3026c05fe2a", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=88f755f8a84df1d9e6b17cf10c96ae8b93481b2e", "patch": "@@ -1528,7 +1528,10 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                             // `impl_self_ty()` for an explanation.\n                             self.tcx.types.re_erased.into()\n                         }\n-                        GenericParamDefKind::Type {..} => self.var_for_def(self.span, param),\n+                        GenericParamDefKind::Type { .. }\n+                        | GenericParamDefKind::Const => {\n+                            self.var_for_def(self.span, param)\n+                        }\n                     }\n                 }\n             });\n@@ -1545,10 +1548,13 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n         InternalSubsts::for_item(self.tcx, def_id, |param, _| {\n             match param.kind {\n                 GenericParamDefKind::Lifetime => self.tcx.types.re_erased.into(),\n-                GenericParamDefKind::Type {..} => {\n+                GenericParamDefKind::Type { .. } => {\n                     self.next_ty_var(TypeVariableOrigin::SubstitutionPlaceholder(\n                         self.tcx.def_span(def_id))).into()\n                 }\n+                GenericParamDefKind::Const { .. } => {\n+                    unimplemented!() // FIXME(const_generics)\n+                }\n             }\n         })\n     }"}, {"sha": "301d7d3ac5623f61cca545cf4bc920bb7ff171a5", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=88f755f8a84df1d9e6b17cf10c96ae8b93481b2e", "patch": "@@ -2437,6 +2437,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         ty\n     }\n \n+    pub fn to_const(&self, ast_c: &hir::AnonConst, ty: Ty<'tcx>) -> &'tcx ty::LazyConst<'tcx> {\n+        AstConv::ast_const_to_const(self, ast_c, ty)\n+    }\n+\n     // If the type given by the user has free regions, save it for later, since\n     // NLL would like to enforce those. Also pass in types that involve\n     // projections, since those can resolve to `'static` bounds (modulo #54940,\n@@ -5501,6 +5505,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     (GenericParamDefKind::Type { .. }, GenericArg::Type(ty)) => {\n                         self.to_ty(ty).into()\n                     }\n+                    (GenericParamDefKind::Const, GenericArg::Const(ct)) => {\n+                        self.to_const(&ct.value, self.tcx.type_of(param.def_id)).into()\n+                    }\n                     _ => unreachable!(),\n                 }\n             },\n@@ -5528,6 +5535,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                             self.var_for_def(span, param)\n                         }\n                     }\n+                    GenericParamDefKind::Const => {\n+                        // FIXME(const_generics:defaults)\n+                        // No const parameters were provided, we have to infer them.\n+                        self.var_for_def(span, param)\n+                    }\n                 }\n             },\n         );\n@@ -5685,11 +5697,19 @@ pub fn check_bounds_are_used<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                        generics: &ty::Generics,\n                                        ty: Ty<'tcx>) {\n     let own_counts = generics.own_counts();\n-    debug!(\"check_bounds_are_used(n_tps={}, ty={:?})\", own_counts.types, ty);\n+    debug!(\n+        \"check_bounds_are_used(n_tys={}, n_cts={}, ty={:?})\",\n+        own_counts.types,\n+        own_counts.consts,\n+        ty\n+    );\n+\n+    // FIXME(const_generics): we probably want to check the bounds for const parameters too.\n \n     if own_counts.types == 0 {\n         return;\n     }\n+\n     // Make a vector of booleans initially false, set to true when used.\n     let mut types_used = vec![false; own_counts.types];\n "}, {"sha": "a03d33a3ef5bc4842849e3ee8d4b0cecbf350167", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=88f755f8a84df1d9e6b17cf10c96ae8b93481b2e", "patch": "@@ -81,7 +81,7 @@ use rustc::hir::def_id::DefId;\n use rustc::infer::outlives::env::OutlivesEnvironment;\n use rustc::infer::{self, RegionObligation, SuppressRegionErrors};\n use rustc::ty::adjustment;\n-use rustc::ty::subst::SubstsRef;\n+use rustc::ty::subst::{SubstsRef, UnpackedKind};\n use rustc::ty::{self, Ty};\n \n use rustc::hir::intravisit::{self, NestedVisitorMap, Visitor};\n@@ -1407,13 +1407,19 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n \n         let origin = infer::ParameterInScope(origin, expr_span);\n \n-        for region in substs.regions() {\n-            self.sub_regions(origin.clone(), expr_region, region);\n-        }\n-\n-        for ty in substs.types() {\n-            let ty = self.resolve_type(ty);\n-            self.type_must_outlive(origin.clone(), ty, expr_region);\n+        for kind in substs {\n+            match kind.unpack() {\n+                UnpackedKind::Lifetime(lt) => {\n+                    self.sub_regions(origin.clone(), expr_region, lt);\n+                }\n+                UnpackedKind::Type(ty) => {\n+                    let ty = self.resolve_type(ty);\n+                    self.type_must_outlive(origin.clone(), ty, expr_region);\n+                }\n+                UnpackedKind::Const(_) => {\n+                    // Const parameters don't impose constraints.\n+                }\n+            }\n         }\n     }\n }"}, {"sha": "16cf25f0d4916e183e05384571dcba7063adc075", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 50, "deletions": 9, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=88f755f8a84df1d9e6b17cf10c96ae8b93481b2e", "patch": "@@ -6,6 +6,7 @@ use rustc::traits::{self, ObligationCauseCode};\n use rustc::ty::{self, Lift, Ty, TyCtxt, TyKind, GenericParamDefKind, TypeFoldable, ToPredicate};\n use rustc::ty::subst::{Subst, InternalSubsts};\n use rustc::util::nodemap::{FxHashSet, FxHashMap};\n+use rustc::mir::interpret::ConstValue;\n use rustc::middle::lang_items;\n use rustc::infer::opaque_types::may_define_existential_type;\n \n@@ -436,7 +437,7 @@ fn check_where_clauses<'a, 'gcx, 'fcx, 'tcx>(\n     // struct Foo<T = Vec<[u32]>> { .. }\n     // Here the default `Vec<[u32]>` is not WF because `[u32]: Sized` does not hold.\n     for param in &generics.params {\n-        if let GenericParamDefKind::Type {..} = param.kind {\n+        if let GenericParamDefKind::Type { .. } = param.kind {\n             if is_our_default(&param) {\n                 let ty = fcx.tcx.type_of(param.def_id);\n                 // ignore dependent defaults -- that is, where the default of one type\n@@ -464,7 +465,7 @@ fn check_where_clauses<'a, 'gcx, 'fcx, 'tcx>(\n                 // All regions are identity.\n                 fcx.tcx.mk_param_from_def(param)\n             }\n-            GenericParamDefKind::Type {..} => {\n+            GenericParamDefKind::Type { .. } => {\n                 // If the param has a default,\n                 if is_our_default(param) {\n                     let default_ty = fcx.tcx.type_of(param.def_id);\n@@ -477,6 +478,10 @@ fn check_where_clauses<'a, 'gcx, 'fcx, 'tcx>(\n                 // Mark unwanted params as err.\n                 fcx.tcx.types.err.into()\n             }\n+            GenericParamDefKind::Const => {\n+                // FIXME(const_generics:defaults)\n+                fcx.tcx.types.err.into()\n+            }\n         }\n     });\n     // Now we build the substituted predicates.\n@@ -497,6 +502,16 @@ fn check_where_clauses<'a, 'gcx, 'fcx, 'tcx>(\n             fn visit_region(&mut self, _: ty::Region<'tcx>) -> bool {\n                 true\n             }\n+\n+            fn visit_const(&mut self, c: &'tcx ty::LazyConst<'tcx>) -> bool {\n+                if let ty::LazyConst::Evaluated(ty::Const {\n+                    val: ConstValue::Param(param),\n+                    ..\n+                }) = c {\n+                    self.params.insert(param.index);\n+                }\n+                c.super_visit_with(self)\n+            }\n         }\n         let mut param_count = CountParams::default();\n         let has_region = pred.visit_with(&mut param_count);\n@@ -617,11 +632,10 @@ fn check_existential_types<'a, 'fcx, 'gcx, 'tcx>(\n                         for (subst, param) in substs.iter().zip(&generics.params) {\n                             match subst.unpack() {\n                                 ty::subst::UnpackedKind::Type(ty) => match ty.sty {\n-                                    ty::Param(..) => {},\n+                                    ty::Param(..) => {}\n                                     // prevent `fn foo() -> Foo<u32>` from being defining\n                                     _ => {\n-                                        tcx\n-                                            .sess\n+                                        tcx.sess\n                                             .struct_span_err(\n                                                 span,\n                                                 \"non-defining existential type use \\\n@@ -636,8 +650,9 @@ fn check_existential_types<'a, 'fcx, 'gcx, 'tcx>(\n                                                 ),\n                                             )\n                                             .emit();\n-                                    },\n-                                }, // match ty\n+                                    }\n+                                }\n+\n                                 ty::subst::UnpackedKind::Lifetime(region) => {\n                                     let param_span = tcx.def_span(param.def_id);\n                                     if let ty::ReStatic = region {\n@@ -658,7 +673,31 @@ fn check_existential_types<'a, 'fcx, 'gcx, 'tcx>(\n                                     } else {\n                                         seen.entry(region).or_default().push(param_span);\n                                     }\n-                                },\n+                                }\n+\n+                                ty::subst::UnpackedKind::Const(ct) => match ct {\n+                                    ty::LazyConst::Evaluated(ty::Const {\n+                                        val: ConstValue::Param(_),\n+                                        ..\n+                                    }) => {}\n+                                    _ => {\n+                                        tcx.sess\n+                                            .struct_span_err(\n+                                                span,\n+                                                \"non-defining existential type use \\\n+                                                in defining scope\",\n+                                            )\n+                                            .span_note(\n+                                                tcx.def_span(param.def_id),\n+                                                &format!(\n+                                                    \"used non-generic const {} for \\\n+                                                    generic parameter\",\n+                                                    ty,\n+                                                ),\n+                                            )\n+                                            .emit();\n+                                    }\n+                                }\n                             } // match subst\n                         } // for (subst, param)\n                         for (_, spans) in seen {\n@@ -942,7 +981,9 @@ fn reject_shadowing_parameters(tcx: TyCtxt<'_, '_, '_>, def_id: DefId) {\n     let parent = tcx.generics_of(generics.parent.unwrap());\n     let impl_params: FxHashMap<_, _> = parent.params.iter().flat_map(|param| match param.kind {\n         GenericParamDefKind::Lifetime => None,\n-        GenericParamDefKind::Type {..} => Some((param.name, param.def_id)),\n+        GenericParamDefKind::Type { .. } | GenericParamDefKind::Const => {\n+            Some((param.name, param.def_id))\n+        }\n     }).collect();\n \n     for method_param in &generics.params {"}, {"sha": "eb4bbe880693b77b50cfc5912f6656f0de2772de", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 150, "deletions": 85, "changes": 235, "blob_url": "https://github.com/rust-lang/rust/blob/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=88f755f8a84df1d9e6b17cf10c96ae8b93481b2e", "patch": "@@ -1004,67 +1004,65 @@ fn generics_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx ty\n         ast_generics\n             .params\n             .iter()\n-            .filter_map(|param| match param.kind {\n-                GenericParamKind::Type {\n-                    ref default,\n-                    synthetic,\n-                    ..\n-                } => {\n-                    if param.name.ident().name == keywords::SelfUpper.name() {\n-                        span_bug!(\n-                            param.span,\n-                            \"`Self` should not be the name of a regular parameter\"\n-                        );\n-                    }\n-\n-                    if !allow_defaults && default.is_some() {\n-                        if !tcx.features().default_type_parameter_fallback {\n-                            tcx.lint_hir(\n-                                lint::builtin::INVALID_TYPE_PARAM_DEFAULT,\n-                                param.hir_id,\n+            .filter_map(|param| {\n+                let kind = match param.kind {\n+                    GenericParamKind::Type {\n+                        ref default,\n+                        synthetic,\n+                        ..\n+                    } => {\n+                        if param.name.ident().name == keywords::SelfUpper.name() {\n+                            span_bug!(\n                                 param.span,\n-                                &format!(\n-                                    \"defaults for type parameters are only allowed in \\\n-                                     `struct`, `enum`, `type`, or `trait` definitions.\"\n-                                ),\n+                                \"`Self` should not be the name of a regular parameter\"\n                             );\n                         }\n-                    }\n \n-                    let ty_param = ty::GenericParamDef {\n-                        index: type_start + i as u32,\n-                        name: param.name.ident().as_interned_str(),\n-                        def_id: tcx.hir().local_def_id_from_hir_id(param.hir_id),\n-                        pure_wrt_drop: param.pure_wrt_drop,\n-                        kind: ty::GenericParamDefKind::Type {\n+                        if !allow_defaults && default.is_some() {\n+                            if !tcx.features().default_type_parameter_fallback {\n+                                tcx.lint_hir(\n+                                    lint::builtin::INVALID_TYPE_PARAM_DEFAULT,\n+                                    param.hir_id,\n+                                    param.span,\n+                                    &format!(\n+                                        \"defaults for type parameters are only allowed in \\\n+                                        `struct`, `enum`, `type`, or `trait` definitions.\"\n+                                    ),\n+                                );\n+                            }\n+                        }\n+\n+                        ty::GenericParamDefKind::Type {\n                             has_default: default.is_some(),\n                             object_lifetime_default: object_lifetime_defaults\n                                 .as_ref()\n                                 .map_or(rl::Set1::Empty, |o| o[i]),\n                             synthetic,\n-                        },\n-                    };\n-                    i += 1;\n-                    Some(ty_param)\n-                }\n-                GenericParamKind::Const { .. } => {\n-                    if param.name.ident().name == keywords::SelfUpper.name() {\n-                        span_bug!(\n-                            param.span,\n-                            \"`Self` should not be the name of a regular parameter\",\n-                        );\n+                        }\n                     }\n+                    GenericParamKind::Const { .. } => {\n+                        if param.name.ident().name == keywords::SelfUpper.name() {\n+                            span_bug!(\n+                                param.span,\n+                                \"`Self` should not be the name of a regular parameter\",\n+                            );\n+                        }\n \n-                    // Emit an error, but skip the parameter rather than aborting to\n-                    // continue to get other errors.\n-                    tcx.sess.struct_span_err(\n-                        param.span,\n-                        \"const generics in any position are currently unsupported\",\n-                    ).emit();\n-                    None\n-                }\n-                _ => None,\n-            }),\n+                        ty::GenericParamDefKind::Const\n+                    }\n+                    _ => return None,\n+                };\n+\n+                let param_def = ty::GenericParamDef {\n+                    index: type_start + i as u32,\n+                    name: param.name.ident().as_interned_str(),\n+                    def_id: tcx.hir().local_def_id_from_hir_id(param.hir_id),\n+                    pure_wrt_drop: param.pure_wrt_drop,\n+                    kind,\n+                };\n+                i += 1;\n+                Some(param_def)\n+            })\n     );\n \n     // provide junk type parameter defs - the only place that\n@@ -1284,44 +1282,111 @@ fn type_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Ty<'tcx> {\n             tcx.mk_closure(def_id, substs)\n         }\n \n-        Node::AnonConst(_) => match tcx.hir().get_by_hir_id(\n-            tcx.hir().get_parent_node_by_hir_id(hir_id))\n-        {\n-            Node::Ty(&hir::Ty {\n-                node: hir::TyKind::Array(_, ref constant),\n-                ..\n-            })\n-            | Node::Ty(&hir::Ty {\n-                node: hir::TyKind::Typeof(ref constant),\n-                ..\n-            })\n-            | Node::Expr(&hir::Expr {\n-                node: ExprKind::Repeat(_, ref constant),\n-                ..\n-            }) if constant.hir_id == hir_id =>\n-            {\n-                tcx.types.usize\n-            }\n+        Node::AnonConst(_) => {\n+            let parent_node = tcx.hir().get_by_hir_id(tcx.hir().get_parent_node_by_hir_id(hir_id));\n+            match parent_node {\n+                Node::Ty(&hir::Ty {\n+                    node: hir::TyKind::Array(_, ref constant),\n+                    ..\n+                })\n+                | Node::Ty(&hir::Ty {\n+                    node: hir::TyKind::Typeof(ref constant),\n+                    ..\n+                })\n+                | Node::Expr(&hir::Expr {\n+                    node: ExprKind::Repeat(_, ref constant),\n+                    ..\n+                }) if constant.hir_id == hir_id =>\n+                {\n+                    tcx.types.usize\n+                }\n \n-            Node::Variant(&Spanned {\n-                node:\n-                    VariantKind {\n-                        disr_expr: Some(ref e),\n-                        ..\n-                    },\n-                ..\n-            }) if e.hir_id == hir_id =>\n-            {\n-                tcx.adt_def(tcx.hir().get_parent_did_by_hir_id(hir_id))\n-                    .repr\n-                    .discr_type()\n-                    .to_ty(tcx)\n-            }\n+                Node::Variant(&Spanned {\n+                    node:\n+                        VariantKind {\n+                            disr_expr: Some(ref e),\n+                            ..\n+                        },\n+                    ..\n+                }) if e.hir_id == hir_id =>\n+                {\n+                    tcx.adt_def(tcx.hir().get_parent_did_by_hir_id(hir_id))\n+                        .repr\n+                        .discr_type()\n+                        .to_ty(tcx)\n+                }\n \n-            x => {\n-                bug!(\"unexpected const parent in type_of_def_id(): {:?}\", x);\n+                Node::Ty(&hir::Ty { node: hir::TyKind::Path(_), .. }) |\n+                Node::Expr(&hir::Expr { node: ExprKind::Struct(..), .. }) |\n+                Node::Expr(&hir::Expr { node: ExprKind::Path(_), .. }) => {\n+                    let path = match parent_node {\n+                        Node::Ty(&hir::Ty { node: hir::TyKind::Path(ref path), .. }) |\n+                        Node::Expr(&hir::Expr { node: ExprKind::Path(ref path), .. }) => {\n+                            path\n+                        }\n+                        Node::Expr(&hir::Expr { node: ExprKind::Struct(ref path, ..), .. }) => {\n+                            &*path\n+                        }\n+                        _ => unreachable!(),\n+                    };\n+\n+                    match path {\n+                        QPath::Resolved(_, ref path) => {\n+                            let mut arg_index = 0;\n+                            let mut found_const = false;\n+                            for seg in &path.segments {\n+                                if let Some(generic_args) = &seg.args {\n+                                    let args = &generic_args.args;\n+                                    for arg in args {\n+                                        if let GenericArg::Const(ct) = arg {\n+                                            if ct.value.hir_id == hir_id {\n+                                                found_const = true;\n+                                                break;\n+                                            }\n+                                            arg_index += 1;\n+                                        }\n+                                    }\n+                                }\n+                            }\n+                            // Sanity check to make sure everything is as expected.\n+                            if !found_const {\n+                                bug!(\"no arg matching AnonConst in path\")\n+                            }\n+                            match path.def {\n+                                // We've encountered an `AnonConst` in some path, so we need to\n+                                // figure out which generic parameter it corresponds to and return\n+                                // the relevant type.\n+                                Def::Struct(def_id)\n+                                | Def::Union(def_id)\n+                                | Def::Enum(def_id)\n+                                | Def::Fn(def_id) => {\n+                                    let generics = tcx.generics_of(def_id);\n+                                    let mut param_index = 0;\n+                                    for param in &generics.params {\n+                                        if let ty::GenericParamDefKind::Const = param.kind {\n+                                            if param_index == arg_index {\n+                                                return tcx.type_of(param.def_id);\n+                                            }\n+                                            param_index += 1;\n+                                        }\n+                                    }\n+                                    // This is no generic parameter associated with the arg. This is\n+                                    // probably from an extra arg where one is not needed.\n+                                    return tcx.types.err;\n+                                }\n+                                Def::Err => tcx.types.err,\n+                                x => bug!(\"unexpected const parent path def {:?}\", x),\n+                            }\n+                        }\n+                        x => bug!(\"unexpected const parent path {:?}\", x),\n+                    }\n+                }\n+\n+                x => {\n+                    bug!(\"unexpected const parent in type_of_def_id(): {:?}\", x);\n+                }\n             }\n-        },\n+        }\n \n         Node::GenericParam(param) => match &param.kind {\n             hir::GenericParamKind::Type { default: Some(ref ty), .. } |"}, {"sha": "4b922c3403886c5e851f144c44c5028e283cf350", "filename": "src/librustc_typeck/constrained_type_params.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e/src%2Flibrustc_typeck%2Fconstrained_type_params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e/src%2Flibrustc_typeck%2Fconstrained_type_params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fconstrained_type_params.rs?ref=88f755f8a84df1d9e6b17cf10c96ae8b93481b2e", "patch": "@@ -1,6 +1,7 @@\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::fold::{TypeFoldable, TypeVisitor};\n use rustc::util::nodemap::FxHashSet;\n+use rustc::mir::interpret::ConstValue;\n use syntax::source_map::Span;\n \n #[derive(Clone, PartialEq, Eq, Hash, Debug)]\n@@ -14,6 +15,10 @@ impl From<ty::EarlyBoundRegion> for Parameter {\n     fn from(param: ty::EarlyBoundRegion) -> Self { Parameter(param.index) }\n }\n \n+impl From<ty::ParamConst> for Parameter {\n+    fn from(param: ty::ParamConst) -> Self { Parameter(param.index) }\n+}\n+\n /// Returns the set of parameters constrained by the impl header.\n pub fn parameters_for_impl<'tcx>(impl_self_ty: Ty<'tcx>,\n                                  impl_trait_ref: Option<ty::TraitRef<'tcx>>)\n@@ -72,6 +77,16 @@ impl<'tcx> TypeVisitor<'tcx> for ParameterCollector {\n         }\n         false\n     }\n+\n+    fn visit_const(&mut self, c: &'tcx ty::LazyConst<'tcx>) -> bool {\n+        if let ty::LazyConst::Evaluated(ty::Const {\n+            val: ConstValue::Param(data),\n+            ..\n+        }) = c {\n+            self.parameters.push(Parameter::from(*data));\n+        }\n+        false\n+    }\n }\n \n pub fn identify_constrained_type_params<'tcx>(tcx: TyCtxt<'_, 'tcx, 'tcx>,"}, {"sha": "399cd6f890c25d171f086624852524615d67a967", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=88f755f8a84df1d9e6b17cf10c96ae8b93481b2e", "patch": "@@ -423,7 +423,7 @@ impl Foo for Bar {\n \n E0049: r##\"\n This error indicates that an attempted implementation of a trait method\n-has the wrong number of type parameters.\n+has the wrong number of type or const parameters.\n \n For example, the trait below has a method `foo` with a type parameter `T`,\n but the implementation of `foo` for the type `Bar` is missing this parameter:\n@@ -1032,6 +1032,7 @@ enum NightsWatch {}\n ```\n \"##,\n \n+// FIXME(const_generics:docs): example of inferring const parameter.\n E0087: r##\"\n #### Note: this error code is no longer emitted by the compiler.\n \n@@ -1152,16 +1153,16 @@ fn main() {\n \"##,\n \n E0091: r##\"\n-You gave an unnecessary type parameter in a type alias. Erroneous code\n-example:\n+You gave an unnecessary type or const parameter in a type alias. Erroneous\n+code example:\n \n ```compile_fail,E0091\n type Foo<T> = u32; // error: type parameter `T` is unused\n // or:\n type Foo<A,B> = Box<A>; // error: type parameter `B` is unused\n ```\n \n-Please check you didn't write too many type parameters. Example:\n+Please check you didn't write too many parameters. Example:\n \n ```\n type Foo = u32; // ok!"}, {"sha": "5677f2c94d8e26f6402a6cfbbd84fc06d02b22ce", "filename": "src/librustc_typeck/impl_wf_check.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e/src%2Flibrustc_typeck%2Fimpl_wf_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e/src%2Flibrustc_typeck%2Fimpl_wf_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fimpl_wf_check.rs?ref=88f755f8a84df1d9e6b17cf10c96ae8b93481b2e", "patch": "@@ -120,7 +120,7 @@ fn enforce_impl_params_are_constrained<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     for param in &impl_generics.params {\n         match param.kind {\n             // Disallow ANY unconstrained type parameters.\n-            ty::GenericParamDefKind::Type {..} => {\n+            ty::GenericParamDefKind::Type { .. } => {\n                 let param_ty = ty::ParamTy::for_def(param);\n                 if !input_parameters.contains(&ctp::Parameter::from(param_ty)) {\n                     report_unused_parameter(tcx,\n@@ -139,6 +139,15 @@ fn enforce_impl_params_are_constrained<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                             &param.name.to_string());\n                 }\n             }\n+            ty::GenericParamDefKind::Const => {\n+                let param_ct = ty::ParamConst::for_def(param);\n+                if !input_parameters.contains(&ctp::Parameter::from(param_ct)) {\n+                    report_unused_parameter(tcx,\n+                                           tcx.def_span(param.def_id),\n+                                           \"const\",\n+                                           &param_ct.to_string());\n+                }\n+            }\n         }\n     }\n "}, {"sha": "1ab414c1f015f292ae3a5172260713a7d3bca018", "filename": "src/librustc_typeck/outlives/mod.rs", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e/src%2Flibrustc_typeck%2Foutlives%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e/src%2Flibrustc_typeck%2Foutlives%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Foutlives%2Fmod.rs?ref=88f755f8a84df1d9e6b17cf10c96ae8b93481b2e", "patch": "@@ -98,14 +98,22 @@ fn inferred_outlives_crate<'tcx>(\n         .map(|(&def_id, set)| {\n             let vec: Vec<ty::Predicate<'tcx>> = set\n                 .iter()\n-                .map(\n+                .filter_map(\n                     |ty::OutlivesPredicate(kind1, region2)| match kind1.unpack() {\n-                        UnpackedKind::Type(ty1) => ty::Predicate::TypeOutlives(ty::Binder::bind(\n-                            ty::OutlivesPredicate(ty1, region2),\n-                        )),\n-                        UnpackedKind::Lifetime(region1) => ty::Predicate::RegionOutlives(\n-                            ty::Binder::bind(ty::OutlivesPredicate(region1, region2)),\n-                        ),\n+                        UnpackedKind::Type(ty1) => {\n+                            Some(ty::Predicate::TypeOutlives(ty::Binder::bind(\n+                                ty::OutlivesPredicate(ty1, region2)\n+                            )))\n+                        }\n+                        UnpackedKind::Lifetime(region1) => {\n+                            Some(ty::Predicate::RegionOutlives(\n+                                ty::Binder::bind(ty::OutlivesPredicate(region1, region2))\n+                            ))\n+                        }\n+                        UnpackedKind::Const(_) => {\n+                            // Generic consts don't impose any constraints.\n+                            None\n+                        }\n                     },\n                 ).collect();\n             (def_id, Lrc::new(vec))"}, {"sha": "ee552ca9cbb251c669eb5c518c528fcc2be44efb", "filename": "src/librustc_typeck/outlives/utils.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e/src%2Flibrustc_typeck%2Foutlives%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e/src%2Flibrustc_typeck%2Foutlives%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Foutlives%2Futils.rs?ref=88f755f8a84df1d9e6b17cf10c96ae8b93481b2e", "patch": "@@ -118,6 +118,10 @@ pub fn insert_outlives_predicate<'tcx>(\n             }\n             required_predicates.insert(ty::OutlivesPredicate(kind, outlived_region));\n         }\n+\n+        UnpackedKind::Const(_) => {\n+            // Generic consts don't impose any constraints.\n+        }\n     }\n }\n "}, {"sha": "49d11150689a99d078e106a74bcea4fb3c3edd89", "filename": "src/librustc_typeck/variance/constraints.rs", "status": "modified", "additions": 42, "deletions": 7, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs?ref=88f755f8a84df1d9e6b17cf10c96ae8b93481b2e", "patch": "@@ -4,7 +4,8 @@\n //! We walk the set of items and, for each member, generate new constraints.\n \n use hir::def_id::DefId;\n-use rustc::ty::subst::{UnpackedKind, SubstsRef};\n+use rustc::mir::interpret::ConstValue;\n+use rustc::ty::subst::{SubstsRef, UnpackedKind};\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::hir;\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n@@ -229,12 +230,19 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n \n         // Trait are always invariant so we can take advantage of that.\n         let variance_i = self.invariant(variance);\n-        for ty in substs.types() {\n-            self.add_constraints_from_ty(current, ty, variance_i);\n-        }\n \n-        for region in substs.regions() {\n-            self.add_constraints_from_region(current, region, variance_i);\n+        for k in substs {\n+            match k.unpack() {\n+                UnpackedKind::Lifetime(lt) => {\n+                    self.add_constraints_from_region(current, lt, variance_i)\n+                }\n+                UnpackedKind::Type(ty) => {\n+                    self.add_constraints_from_ty(current, ty, variance_i)\n+                }\n+                UnpackedKind::Const(ct) => {\n+                    self.add_constraints_from_const(current, ct, variance_i)\n+                }\n+            }\n         }\n     }\n \n@@ -267,7 +275,11 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                 self.add_constraints_from_mt(current, &ty::TypeAndMut { ty, mutbl }, variance);\n             }\n \n-            ty::Array(typ, _) |\n+            ty::Array(typ, len) => {\n+                self.add_constraints_from_ty(current, typ, variance);\n+                self.add_constraints_from_const(current, len, variance);\n+            }\n+\n             ty::Slice(typ) => {\n                 self.add_constraints_from_ty(current, typ, variance);\n             }\n@@ -383,6 +395,9 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                 UnpackedKind::Type(ty) => {\n                     self.add_constraints_from_ty(current, ty, variance_i)\n                 }\n+                UnpackedKind::Const(ct) => {\n+                    self.add_constraints_from_const(current, ct, variance_i)\n+                }\n             }\n         }\n     }\n@@ -434,6 +449,26 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n         }\n     }\n \n+    fn add_constraints_from_const(\n+        &mut self,\n+        current: &CurrentItem,\n+        ct: &ty::LazyConst<'tcx>,\n+        variance: VarianceTermPtr<'a>\n+    ) {\n+        debug!(\n+            \"add_constraints_from_const(ct={:?}, variance={:?})\",\n+            ct,\n+            variance\n+        );\n+\n+        if let ty::LazyConst::Evaluated(ct) = ct {\n+            self.add_constraints_from_ty(current, ct.ty, variance);\n+            if let ConstValue::Param(ref data) = ct.val {\n+                self.add_constraint(current, data.index, variance);\n+            }\n+        }\n+    }\n+\n     /// Adds constraints appropriate for a mutability-type pair\n     /// appearing in a context with ambient variance `variance`\n     fn add_constraints_from_mt(&mut self,"}, {"sha": "5d0d76507bd071eb3e7c0fb328f21c1af6ae4d4e", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=88f755f8a84df1d9e6b17cf10c96ae8b93481b2e", "patch": "@@ -1482,6 +1482,9 @@ impl<'tcx> Clean<GenericParamDef> for ty::GenericParamDef {\n                     synthetic: None,\n                 })\n             }\n+            ty::GenericParamDefKind::Const { .. } => {\n+                unimplemented!() // FIXME(const_generics)\n+            }\n         };\n \n         GenericParamDef {\n@@ -1629,6 +1632,9 @@ impl<'a, 'tcx> Clean<Generics> for (&'a ty::Generics,\n                 }\n                 Some(param.clean(cx))\n             }\n+            ty::GenericParamDefKind::Const { .. } => {\n+                unimplemented!() // FIXME(const_generics)\n+            }\n         }).collect::<Vec<GenericParamDef>>();\n \n         let mut where_predicates = preds.predicates.iter()\n@@ -1678,6 +1684,9 @@ impl<'a, 'tcx> Clean<Generics> for (&'a ty::Generics,\n                         .flat_map(|param| match param.kind {\n                             ty::GenericParamDefKind::Lifetime => Some(param.clean(cx)),\n                             ty::GenericParamDefKind::Type { .. } => None,\n+                            ty::GenericParamDefKind::Const { .. } => {\n+                                unimplemented!() // FIXME(const_generics)\n+                            }\n                         }).chain(simplify::ty_params(stripped_typarams).into_iter())\n                         .collect(),\n             where_predicates: simplify::where_clauses(cx, where_predicates),"}, {"sha": "07cfdde4a4e9d0ba83679105405d984ef57b2407", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=88f755f8a84df1d9e6b17cf10c96ae8b93481b2e", "patch": "@@ -221,6 +221,9 @@ impl<'a, 'tcx, 'rcx> DocContext<'a, 'tcx, 'rcx> {\n                 ty::GenericParamDefKind::Type { .. } => {\n                     args.push(hir::GenericArg::Type(self.ty_param_to_ty(param.clone())));\n                 }\n+                ty::GenericParamDefKind::Const { .. } => {\n+                    unimplemented!() // FIXME(const_generics)\n+                }\n             }\n         }\n "}, {"sha": "662c7b767bae06e550891842d1deac0e556947dc", "filename": "src/test/ui/const-generics/const-expression-parameter.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e/src%2Ftest%2Fui%2Fconst-generics%2Fconst-expression-parameter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e/src%2Ftest%2Fui%2Fconst-generics%2Fconst-expression-parameter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst-expression-parameter.rs?ref=88f755f8a84df1d9e6b17cf10c96ae8b93481b2e", "patch": "@@ -1,23 +1,22 @@\n #![feature(const_generics)]\n //~^ WARN the feature `const_generics` is incomplete and may cause the compiler to crash\n \n-fn u32_identity<const X: u32>() -> u32 {\n-    //~^ ERROR const generics in any position are currently unsupported\n+fn i32_identity<const X: i32>() -> i32 {\n     5\n }\n \n fn foo_a() {\n-    u32_identity::<-1>(); //~ ERROR expected identifier, found `<-`\n+    i32_identity::<-1>(); //~ ERROR expected identifier, found `<-`\n }\n \n fn foo_b() {\n-    u32_identity::<1 + 2>(); //~ ERROR expected one of `,` or `>`, found `+`\n+    i32_identity::<1 + 2>(); //~ ERROR expected one of `,` or `>`, found `+`\n }\n \n fn foo_c() {\n-    u32_identity::< -1 >(); // ok\n+    i32_identity::< -1 >(); // ok\n }\n \n fn main() {\n-    u32_identity::<5>(); // ok\n+    i32_identity::<5>(); // ok\n }"}, {"sha": "2741d621256220d1fc04646ecacd9b633830f979", "filename": "src/test/ui/const-generics/const-expression-parameter.stderr", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e/src%2Ftest%2Fui%2Fconst-generics%2Fconst-expression-parameter.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e/src%2Ftest%2Fui%2Fconst-generics%2Fconst-expression-parameter.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst-expression-parameter.stderr?ref=88f755f8a84df1d9e6b17cf10c96ae8b93481b2e", "patch": "@@ -1,13 +1,13 @@\n error: expected identifier, found `<-`\n-  --> $DIR/const-expression-parameter.rs:10:19\n+  --> $DIR/const-expression-parameter.rs:9:19\n    |\n-LL |     u32_identity::<-1>(); //~ ERROR expected identifier, found `<-`\n+LL |     i32_identity::<-1>(); //~ ERROR expected identifier, found `<-`\n    |                   ^^ expected identifier\n \n error: expected one of `,` or `>`, found `+`\n-  --> $DIR/const-expression-parameter.rs:14:22\n+  --> $DIR/const-expression-parameter.rs:13:22\n    |\n-LL |     u32_identity::<1 + 2>(); //~ ERROR expected one of `,` or `>`, found `+`\n+LL |     i32_identity::<1 + 2>(); //~ ERROR expected one of `,` or `>`, found `+`\n    |                      ^ expected one of `,` or `>` here\n \n warning: the feature `const_generics` is incomplete and may cause the compiler to crash\n@@ -16,11 +16,5 @@ warning: the feature `const_generics` is incomplete and may cause the compiler t\n LL | #![feature(const_generics)]\n    |            ^^^^^^^^^^^^^^\n \n-error: const generics in any position are currently unsupported\n-  --> $DIR/const-expression-parameter.rs:4:23\n-   |\n-LL | fn u32_identity<const X: u32>() -> u32 {\n-   |                       ^\n-\n-error: aborting due to 3 previous errors\n+error: aborting due to 2 previous errors\n "}, {"sha": "f36bf3875c34999bf57b84c5faf530c8a20d28e8", "filename": "src/test/ui/const-generics/const-fn-with-const-param.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e/src%2Ftest%2Fui%2Fconst-generics%2Fconst-fn-with-const-param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e/src%2Ftest%2Fui%2Fconst-generics%2Fconst-fn-with-const-param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst-fn-with-const-param.rs?ref=88f755f8a84df1d9e6b17cf10c96ae8b93481b2e", "patch": "@@ -3,7 +3,6 @@\n \n const fn const_u32_identity<const X: u32>() -> u32 {\n     //~^ ERROR const parameters are not permitted in `const fn`\n-    //~^^ ERROR const generics in any position are currently unsupported\n     X\n }\n "}, {"sha": "94d2afa25b4f0f79d7fd461dc79f67bd3bc76fa3", "filename": "src/test/ui/const-generics/const-fn-with-const-param.stderr", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e/src%2Ftest%2Fui%2Fconst-generics%2Fconst-fn-with-const-param.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e/src%2Ftest%2Fui%2Fconst-generics%2Fconst-fn-with-const-param.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst-fn-with-const-param.stderr?ref=88f755f8a84df1d9e6b17cf10c96ae8b93481b2e", "patch": "@@ -9,16 +9,9 @@ error: const parameters are not permitted in `const fn`\n    |\n LL | / const fn const_u32_identity<const X: u32>() -> u32 {\n LL | |     //~^ ERROR const parameters are not permitted in `const fn`\n-LL | |     //~^^ ERROR const generics in any position are currently unsupported\n LL | |     X\n LL | | }\n    | |_^\n \n-error: const generics in any position are currently unsupported\n-  --> $DIR/const-fn-with-const-param.rs:4:35\n-   |\n-LL | const fn const_u32_identity<const X: u32>() -> u32 {\n-   |                                   ^\n-\n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n "}, {"sha": "188b5dce31ea80e6211ae53b70d646c93ac73d6b", "filename": "src/test/ui/const-generics/const-param-before-other-params.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e/src%2Ftest%2Fui%2Fconst-generics%2Fconst-param-before-other-params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e/src%2Ftest%2Fui%2Fconst-generics%2Fconst-param-before-other-params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst-param-before-other-params.rs?ref=88f755f8a84df1d9e6b17cf10c96ae8b93481b2e", "patch": "@@ -1,14 +1,12 @@\n #![feature(const_generics)]\n //~^ WARN the feature `const_generics` is incomplete and may cause the compiler to crash\n \n-fn foo<const X: (), T>(_: T) {\n+fn foo<const X: (), T>(_: &T) {\n     //~^ ERROR type parameters must be declared prior to const parameters\n-    //~^^ ERROR const generics in any position are currently unsupported\n }\n \n fn bar<const X: (), 'a>(_: &'a ()) {\n     //~^ ERROR lifetime parameters must be declared prior to const parameters\n-    //~^^ ERROR const generics in any position are currently unsupported\n }\n \n fn main() {}"}, {"sha": "78f129e79ea24363b8123a97c23e0babd7772351", "filename": "src/test/ui/const-generics/const-param-before-other-params.stderr", "status": "modified", "additions": 3, "deletions": 15, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e/src%2Ftest%2Fui%2Fconst-generics%2Fconst-param-before-other-params.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e/src%2Ftest%2Fui%2Fconst-generics%2Fconst-param-before-other-params.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst-param-before-other-params.stderr?ref=88f755f8a84df1d9e6b17cf10c96ae8b93481b2e", "patch": "@@ -7,26 +7,14 @@ LL | #![feature(const_generics)]\n error: type parameters must be declared prior to const parameters\n   --> $DIR/const-param-before-other-params.rs:4:21\n    |\n-LL | fn foo<const X: (), T>(_: T) {\n+LL | fn foo<const X: (), T>(_: &T) {\n    |       --------------^- help: reorder the parameters: lifetimes, then types, then consts: `<T, const X: ()>`\n \n error: lifetime parameters must be declared prior to const parameters\n-  --> $DIR/const-param-before-other-params.rs:9:21\n+  --> $DIR/const-param-before-other-params.rs:8:21\n    |\n LL | fn bar<const X: (), 'a>(_: &'a ()) {\n    |       --------------^^- help: reorder the parameters: lifetimes, then types, then consts: `<'a, const X: ()>`\n \n-error: const generics in any position are currently unsupported\n-  --> $DIR/const-param-before-other-params.rs:4:14\n-   |\n-LL | fn foo<const X: (), T>(_: T) {\n-   |              ^\n-\n-error: const generics in any position are currently unsupported\n-  --> $DIR/const-param-before-other-params.rs:9:14\n-   |\n-LL | fn bar<const X: (), 'a>(_: &'a ()) {\n-   |              ^\n-\n-error: aborting due to 4 previous errors\n+error: aborting due to 2 previous errors\n "}, {"sha": "6534bcf5ce64c91bad8eb7c288860f9209e1f5fe", "filename": "src/test/ui/const-generics/const-param-from-outer-fn.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e/src%2Ftest%2Fui%2Fconst-generics%2Fconst-param-from-outer-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e/src%2Ftest%2Fui%2Fconst-generics%2Fconst-param-from-outer-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst-param-from-outer-fn.rs?ref=88f755f8a84df1d9e6b17cf10c96ae8b93481b2e", "patch": "@@ -2,7 +2,6 @@\n //~^ WARN the feature `const_generics` is incomplete and may cause the compiler to crash\n \n fn foo<const X: u32>() {\n-    //~^ ERROR const generics in any position are currently unsupported\n     fn bar() -> u32 {\n         X //~ ERROR can't use generic parameters from outer function\n     }"}, {"sha": "f40b527d716079d773f2a540321e32ccdb28216a", "filename": "src/test/ui/const-generics/const-param-from-outer-fn.stderr", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e/src%2Ftest%2Fui%2Fconst-generics%2Fconst-param-from-outer-fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e/src%2Ftest%2Fui%2Fconst-generics%2Fconst-param-from-outer-fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst-param-from-outer-fn.stderr?ref=88f755f8a84df1d9e6b17cf10c96ae8b93481b2e", "patch": "@@ -5,22 +5,15 @@ LL | #![feature(const_generics)]\n    |            ^^^^^^^^^^^^^^\n \n error[E0401]: can't use generic parameters from outer function\n-  --> $DIR/const-param-from-outer-fn.rs:7:9\n+  --> $DIR/const-param-from-outer-fn.rs:6:9\n    |\n LL | fn foo<const X: u32>() {\n    |              - const variable from outer function\n-LL |     //~^ ERROR const generics in any position are currently unsupported\n LL |     fn bar() -> u32 {\n    |        --- try adding a local generic parameter in this method instead\n LL |         X //~ ERROR can't use generic parameters from outer function\n    |         ^ use of generic parameter from outer function\n \n-error: const generics in any position are currently unsupported\n-  --> $DIR/const-param-from-outer-fn.rs:4:14\n-   |\n-LL | fn foo<const X: u32>() {\n-   |              ^\n-\n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n For more information about this error, try `rustc --explain E0401`."}, {"sha": "164205dd75cbc6749cc2af478e3b9a396ee06c59", "filename": "src/test/ui/const-generics/const-parameter-uppercase-lint.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e/src%2Ftest%2Fui%2Fconst-generics%2Fconst-parameter-uppercase-lint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e/src%2Ftest%2Fui%2Fconst-generics%2Fconst-parameter-uppercase-lint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst-parameter-uppercase-lint.rs?ref=88f755f8a84df1d9e6b17cf10c96ae8b93481b2e", "patch": "@@ -4,5 +4,7 @@\n #![deny(non_upper_case_globals)]\n \n fn noop<const x: u32>() {\n-    //~^ ERROR const generics in any position are currently unsupported\n+    //~^ ERROR const parameter `x` should have an upper case name\n }\n+\n+fn main() {}"}, {"sha": "190798d202bead803980e7d480304278ee235d52", "filename": "src/test/ui/const-generics/const-parameter-uppercase-lint.stderr", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e/src%2Ftest%2Fui%2Fconst-generics%2Fconst-parameter-uppercase-lint.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e/src%2Ftest%2Fui%2Fconst-generics%2Fconst-parameter-uppercase-lint.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst-parameter-uppercase-lint.stderr?ref=88f755f8a84df1d9e6b17cf10c96ae8b93481b2e", "patch": "@@ -4,16 +4,17 @@ warning: the feature `const_generics` is incomplete and may cause the compiler t\n LL | #![feature(const_generics)]\n    |            ^^^^^^^^^^^^^^\n \n-error[E0601]: `main` function not found in crate `const_parameter_uppercase_lint`\n-   |\n-   = note: consider adding a `main` function to `$DIR/const-parameter-uppercase-lint.rs`\n-\n-error: const generics in any position are currently unsupported\n+error: const parameter `x` should have an upper case name\n   --> $DIR/const-parameter-uppercase-lint.rs:6:15\n    |\n LL | fn noop<const x: u32>() {\n-   |               ^\n+   |               ^ help: convert the identifier to upper case: `X`\n+   |\n+note: lint level defined here\n+  --> $DIR/const-parameter-uppercase-lint.rs:4:9\n+   |\n+LL | #![deny(non_upper_case_globals)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^\n \n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0601`."}, {"sha": "9d96908a05620cb1a1a436618ae2d3be351019de", "filename": "src/test/ui/derives/deriving-with-repr-packed.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e/src%2Ftest%2Fui%2Fderives%2Fderiving-with-repr-packed.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e/src%2Ftest%2Fui%2Fderives%2Fderiving-with-repr-packed.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderives%2Fderiving-with-repr-packed.stderr?ref=88f755f8a84df1d9e6b17cf10c96ae8b93481b2e", "patch": "@@ -1,4 +1,4 @@\n-error: #[derive] can't be used on a #[repr(packed)] struct with type parameters (error E0133)\n+error: #[derive] can't be used on a #[repr(packed)] struct with type or const parameters (error E0133)\n   --> $DIR/deriving-with-repr-packed.rs:8:16\n    |\n LL | #[derive(Copy, Clone, PartialEq, Eq)]\n@@ -12,7 +12,7 @@ LL | #![deny(safe_packed_borrows)]\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #46043 <https://github.com/rust-lang/rust/issues/46043>\n \n-error: #[derive] can't be used on a #[repr(packed)] struct with type parameters (error E0133)\n+error: #[derive] can't be used on a #[repr(packed)] struct with type or const parameters (error E0133)\n   --> $DIR/deriving-with-repr-packed.rs:8:23\n    |\n LL | #[derive(Copy, Clone, PartialEq, Eq)]"}, {"sha": "fe1ded1c4bbc4bba7e8b86d954a113a51a1d59ad", "filename": "src/test/ui/feature-gates/feature-gate-const_generics.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-const_generics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-const_generics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-const_generics.rs?ref=88f755f8a84df1d9e6b17cf10c96ae8b93481b2e", "patch": "@@ -1,7 +1,5 @@\n fn foo<const X: ()>() {} //~ ERROR const generics are unstable\n-//~^ const generics in any position are currently unsupported\n \n struct Foo<const X: usize>([(); X]); //~ ERROR const generics are unstable\n-//~^ const generics in any position are currently unsupported\n \n fn main() {}"}, {"sha": "bd86a4197a76e7c46aa7d502d3bb474c06dbf90f", "filename": "src/test/ui/feature-gates/feature-gate-const_generics.stderr", "status": "modified", "additions": 2, "deletions": 14, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-const_generics.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/88f755f8a84df1d9e6b17cf10c96ae8b93481b2e/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-const_generics.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-const_generics.stderr?ref=88f755f8a84df1d9e6b17cf10c96ae8b93481b2e", "patch": "@@ -7,25 +7,13 @@ LL | fn foo<const X: ()>() {} //~ ERROR const generics are unstable\n    = help: add #![feature(const_generics)] to the crate attributes to enable\n \n error[E0658]: const generics are unstable (see issue #44580)\n-  --> $DIR/feature-gate-const_generics.rs:4:18\n+  --> $DIR/feature-gate-const_generics.rs:3:18\n    |\n LL | struct Foo<const X: usize>([(); X]); //~ ERROR const generics are unstable\n    |                  ^\n    |\n    = help: add #![feature(const_generics)] to the crate attributes to enable\n \n-error: const generics in any position are currently unsupported\n-  --> $DIR/feature-gate-const_generics.rs:1:14\n-   |\n-LL | fn foo<const X: ()>() {} //~ ERROR const generics are unstable\n-   |              ^\n-\n-error: const generics in any position are currently unsupported\n-  --> $DIR/feature-gate-const_generics.rs:4:18\n-   |\n-LL | struct Foo<const X: usize>([(); X]); //~ ERROR const generics are unstable\n-   |                  ^\n-\n-error: aborting due to 4 previous errors\n+error: aborting due to 2 previous errors\n \n For more information about this error, try `rustc --explain E0658`."}]}