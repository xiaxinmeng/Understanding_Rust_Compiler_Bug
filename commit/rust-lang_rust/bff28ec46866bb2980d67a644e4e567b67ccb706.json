{"sha": "bff28ec46866bb2980d67a644e4e567b67ccb706", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJmZjI4ZWM0Njg2NmJiMjk4MGQ2N2E2NDRlNGU1NjdiNjdjY2I3MDY=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2016-06-28T20:41:09Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2016-06-28T20:41:09Z"}, "message": "refactor rustc_metadata to use CamelCase names and IndexVec", "tree": {"sha": "bf1248030e0f2c5fb5f82d63d4c609dcaf313b2b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bf1248030e0f2c5fb5f82d63d4c609dcaf313b2b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bff28ec46866bb2980d67a644e4e567b67ccb706", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bff28ec46866bb2980d67a644e4e567b67ccb706", "html_url": "https://github.com/rust-lang/rust/commit/bff28ec46866bb2980d67a644e4e567b67ccb706", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bff28ec46866bb2980d67a644e4e567b67ccb706/comments", "author": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ea0dc9297283daff6486807f43e190b4eb561412", "url": "https://api.github.com/repos/rust-lang/rust/commits/ea0dc9297283daff6486807f43e190b4eb561412", "html_url": "https://github.com/rust-lang/rust/commit/ea0dc9297283daff6486807f43e190b4eb561412"}], "stats": {"total": 203, "additions": 106, "deletions": 97}, "files": [{"sha": "9123463149936da2b434d8e4c84c14288261f12f", "filename": "src/librustc_data_structures/indexed_vec.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bff28ec46866bb2980d67a644e4e567b67ccb706/src%2Flibrustc_data_structures%2Findexed_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bff28ec46866bb2980d67a644e4e567b67ccb706/src%2Flibrustc_data_structures%2Findexed_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Findexed_vec.rs?ref=bff28ec46866bb2980d67a644e4e567b67ccb706", "patch": "@@ -15,6 +15,7 @@ use std::marker::PhantomData;\n use std::ops::{Index, IndexMut, Range};\n use std::fmt;\n use std::vec;\n+use std::u32;\n \n use rustc_serialize as serialize;\n \n@@ -31,6 +32,11 @@ impl Idx for usize {\n     fn index(self) -> usize { self }\n }\n \n+impl Idx for u32 {\n+    fn new(idx: usize) -> Self { assert!(idx <= u32::MAX as usize); idx as u32 }\n+    fn index(self) -> usize { self as usize }\n+}\n+\n #[derive(Clone)]\n pub struct IndexVec<I: Idx, T> {\n     pub raw: Vec<T>,"}, {"sha": "2d3302c2eef3a8078a4c6683a94f546770ed19b0", "filename": "src/librustc_metadata/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bff28ec46866bb2980d67a644e4e567b67ccb706/src%2Flibrustc_metadata%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/bff28ec46866bb2980d67a644e4e567b67ccb706/src%2Flibrustc_metadata%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2FCargo.toml?ref=bff28ec46866bb2980d67a644e4e567b67ccb706", "patch": "@@ -16,6 +16,7 @@ rustc = { path = \"../librustc\" }\n rustc_back = { path = \"../librustc_back\" }\n rustc_bitflags = { path = \"../librustc_bitflags\" }\n rustc_const_math = { path = \"../librustc_const_math\" }\n+rustc_data_structures = { path = \"../librustc_data_structures\" }\n rustc_errors = { path = \"../librustc_errors\" }\n rustc_llvm = { path = \"../librustc_llvm\" }\n serialize = { path = \"../libserialize\" }"}, {"sha": "532c263139b250fd941fac4f83d7e4d687e86dc8", "filename": "src/librustc_metadata/astencode.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/bff28ec46866bb2980d67a644e4e567b67ccb706/src%2Flibrustc_metadata%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bff28ec46866bb2980d67a644e4e567b67ccb706/src%2Flibrustc_metadata%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fastencode.rs?ref=bff28ec46866bb2980d67a644e4e567b67ccb706", "patch": "@@ -62,7 +62,7 @@ use rustc_serialize::{Encodable, EncoderHelpers};\n \n struct DecodeContext<'a, 'b, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    cdata: &'b cstore::crate_metadata,\n+    cdata: &'b cstore::CrateMetadata,\n     from_id_range: IdRange,\n     to_id_range: IdRange,\n     // Cache the last used filemap for translating spans as an optimization.\n@@ -123,7 +123,7 @@ impl<'a, 'b, 'c, 'tcx> ast_map::FoldOps for &'a DecodeContext<'b, 'c, 'tcx> {\n \n /// Decodes an item from its AST in the cdata's metadata and adds it to the\n /// ast-map.\n-pub fn decode_inlined_item<'a, 'tcx>(cdata: &cstore::crate_metadata,\n+pub fn decode_inlined_item<'a, 'tcx>(cdata: &cstore::CrateMetadata,\n                                      tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                      parent_def_path: ast_map::DefPath,\n                                      parent_did: DefId,\n@@ -248,7 +248,7 @@ impl<S:serialize::Encoder> def_id_encoder_helpers for S\n trait def_id_decoder_helpers {\n     fn read_def_id(&mut self, dcx: &DecodeContext) -> DefId;\n     fn read_def_id_nodcx(&mut self,\n-                         cdata: &cstore::crate_metadata) -> DefId;\n+                         cdata: &cstore::CrateMetadata) -> DefId;\n }\n \n impl<D:serialize::Decoder> def_id_decoder_helpers for D\n@@ -260,7 +260,7 @@ impl<D:serialize::Decoder> def_id_decoder_helpers for D\n     }\n \n     fn read_def_id_nodcx(&mut self,\n-                         cdata: &cstore::crate_metadata)\n+                         cdata: &cstore::CrateMetadata)\n                          -> DefId {\n         let did: DefId = Decodable::decode(self).unwrap();\n         decoder::translate_def_id(cdata, did)\n@@ -860,17 +860,17 @@ trait rbml_decoder_decoder_helpers<'tcx> {\n     // Versions of the type reading functions that don't need the full\n     // DecodeContext.\n     fn read_ty_nodcx<'a>(&mut self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                         cdata: &cstore::crate_metadata) -> Ty<'tcx>;\n+                         cdata: &cstore::CrateMetadata) -> Ty<'tcx>;\n     fn read_tys_nodcx<'a>(&mut self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                          cdata: &cstore::crate_metadata) -> Vec<Ty<'tcx>>;\n+                          cdata: &cstore::CrateMetadata) -> Vec<Ty<'tcx>>;\n     fn read_substs_nodcx<'a>(&mut self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                             cdata: &cstore::crate_metadata)\n+                             cdata: &cstore::CrateMetadata)\n                              -> subst::Substs<'tcx>;\n }\n \n impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n     fn read_ty_nodcx<'b>(&mut self, tcx: TyCtxt<'b, 'tcx, 'tcx>,\n-                         cdata: &cstore::crate_metadata)\n+                         cdata: &cstore::CrateMetadata)\n                          -> Ty<'tcx> {\n         self.read_opaque(|_, doc| {\n             Ok(\n@@ -881,15 +881,15 @@ impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n     }\n \n     fn read_tys_nodcx<'b>(&mut self, tcx: TyCtxt<'b, 'tcx, 'tcx>,\n-                          cdata: &cstore::crate_metadata) -> Vec<Ty<'tcx>> {\n+                          cdata: &cstore::CrateMetadata) -> Vec<Ty<'tcx>> {\n         self.read_to_vec(|this| Ok(this.read_ty_nodcx(tcx, cdata)) )\n             .unwrap()\n             .into_iter()\n             .collect()\n     }\n \n     fn read_substs_nodcx<'b>(&mut self, tcx: TyCtxt<'b, 'tcx, 'tcx>,\n-                             cdata: &cstore::crate_metadata)\n+                             cdata: &cstore::CrateMetadata)\n                              -> subst::Substs<'tcx>\n     {\n         self.read_opaque(|_, doc| {"}, {"sha": "f97030a30f82a35deb1788328295f10dcf9d4b69", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 38, "deletions": 42, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/bff28ec46866bb2980d67a644e4e567b67ccb706/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bff28ec46866bb2980d67a644e4e567b67ccb706/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=bff28ec46866bb2980d67a644e4e567b67ccb706", "patch": "@@ -24,7 +24,7 @@ use rustc::session::{config, Session};\n use rustc::session::config::PanicStrategy;\n use rustc::session::search_paths::PathKind;\n use rustc::middle::cstore::{CrateStore, validate_crate_name, ExternCrate};\n-use rustc::util::nodemap::FnvHashMap;\n+use rustc::util::nodemap::{FnvHashMap, FnvHashSet};\n use rustc::hir::map as hir_map;\n \n use std::cell::{RefCell, Cell};\n@@ -132,7 +132,7 @@ struct ExtensionCrate {\n }\n \n enum PMDSource {\n-    Registered(Rc<cstore::crate_metadata>),\n+    Registered(Rc<cstore::CrateMetadata>),\n     Owned(MetadataBlob),\n }\n \n@@ -294,7 +294,7 @@ impl<'a> CrateReader<'a> {\n                       span: Span,\n                       lib: loader::Library,\n                       explicitly_linked: bool)\n-                      -> (ast::CrateNum, Rc<cstore::crate_metadata>,\n+                      -> (ast::CrateNum, Rc<cstore::CrateMetadata>,\n                           cstore::CrateSource) {\n         self.verify_rustc_version(name, span, &lib.metadata);\n         self.verify_no_symbol_conflicts(span, &lib.metadata);\n@@ -318,10 +318,10 @@ impl<'a> CrateReader<'a> {\n \n         let loader::Library { dylib, rlib, metadata } = lib;\n \n-        let cnum_map = self.resolve_crate_deps(root, metadata.as_slice(), span);\n+        let cnum_map = self.resolve_crate_deps(root, metadata.as_slice(), cnum, span);\n         let staged_api = self.is_staged_api(metadata.as_slice());\n \n-        let cmeta = Rc::new(cstore::crate_metadata {\n+        let cmeta = Rc::new(cstore::CrateMetadata {\n             name: name.to_string(),\n             extern_crate: Cell::new(None),\n             index: decoder::load_index(metadata.as_slice()),\n@@ -364,7 +364,7 @@ impl<'a> CrateReader<'a> {\n                      span: Span,\n                      kind: PathKind,\n                      explicitly_linked: bool)\n-                     -> (ast::CrateNum, Rc<cstore::crate_metadata>, cstore::CrateSource) {\n+                     -> (ast::CrateNum, Rc<cstore::CrateMetadata>, cstore::CrateSource) {\n         let result = match self.existing_match(name, hash, kind) {\n             Some(cnum) => LoadResult::Previous(cnum),\n             None => {\n@@ -438,8 +438,11 @@ impl<'a> CrateReader<'a> {\n \n     fn update_extern_crate(&mut self,\n                            cnum: ast::CrateNum,\n-                           mut extern_crate: ExternCrate)\n+                           mut extern_crate: ExternCrate,\n+                           visited: &mut FnvHashSet<(ast::CrateNum, bool)>)\n     {\n+        if !visited.insert((cnum, extern_crate.direct)) { return }\n+\n         let cmeta = self.cstore.get_crate_data(cnum);\n         let old_extern_crate = cmeta.extern_crate.get();\n \n@@ -458,24 +461,24 @@ impl<'a> CrateReader<'a> {\n         }\n \n         cmeta.extern_crate.set(Some(extern_crate));\n-\n         // Propagate the extern crate info to dependencies.\n         extern_crate.direct = false;\n-        for &dep_cnum in cmeta.cnum_map.borrow().values() {\n-            self.update_extern_crate(dep_cnum, extern_crate);\n+        for &dep_cnum in cmeta.cnum_map.borrow().iter() {\n+            self.update_extern_crate(dep_cnum, extern_crate, visited);\n         }\n     }\n \n     // Go through the crate metadata and load any crates that it references\n     fn resolve_crate_deps(&mut self,\n                           root: &Option<CratePaths>,\n                           cdata: &[u8],\n-                          span : Span)\n-                          -> cstore::cnum_map {\n+                          krate: ast::CrateNum,\n+                          span: Span)\n+                          -> cstore::CrateNumMap {\n         debug!(\"resolving deps of external crate\");\n         // The map from crate numbers in the crate we're resolving to local crate\n         // numbers\n-        decoder::get_crate_deps(cdata).iter().map(|dep| {\n+        let map: FnvHashMap<_, _> = decoder::get_crate_deps(cdata).iter().map(|dep| {\n             debug!(\"resolving dep crate {} hash: `{}`\", dep.name, dep.hash);\n             let (local_cnum, _, _) = self.resolve_crate(root,\n                                                         &dep.name,\n@@ -485,7 +488,13 @@ impl<'a> CrateReader<'a> {\n                                                         PathKind::Dependency,\n                                                         dep.explicitly_linked);\n             (dep.cnum, local_cnum)\n-        }).collect()\n+        }).collect();\n+\n+        let max_cnum = map.values().cloned().max().unwrap_or(0);\n+\n+        // we map 0 and all other holes in the map to our parent crate. The \"additional\"\n+        // self-dependencies should be harmless.\n+        (0..max_cnum+1).map(|cnum| map.get(&cnum).cloned().unwrap_or(krate)).collect()\n     }\n \n     fn read_extension_crate(&mut self, span: Span, info: &CrateInfo) -> ExtensionCrate {\n@@ -826,7 +835,7 @@ impl<'a> CrateReader<'a> {\n     fn inject_dependency_if(&self,\n                             krate: ast::CrateNum,\n                             what: &str,\n-                            needs_dep: &Fn(&cstore::crate_metadata) -> bool) {\n+                            needs_dep: &Fn(&cstore::CrateMetadata) -> bool) {\n         // don't perform this validation if the session has errors, as one of\n         // those errors may indicate a circular dependency which could cause\n         // this to stack overflow.\n@@ -837,7 +846,17 @@ impl<'a> CrateReader<'a> {\n         // Before we inject any dependencies, make sure we don't inject a\n         // circular dependency by validating that this crate doesn't\n         // transitively depend on any crates satisfying `needs_dep`.\n-        validate(self, krate, krate, what, needs_dep);\n+        for dep in self.cstore.crate_dependencies_in_rpo(krate) {\n+            let data = self.cstore.get_crate_data(dep);\n+            if needs_dep(&data) {\n+                self.sess.err(&format!(\"the crate `{}` cannot depend \\\n+                                        on a crate that needs {}, but \\\n+                                        it depends on `{}`\",\n+                                       self.cstore.get_crate_data(krate).name(),\n+                                       what,\n+                                       data.name()));\n+            }\n+        }\n \n         // All crates satisfying `needs_dep` do not explicitly depend on the\n         // crate provided for this compile, but in order for this compilation to\n@@ -849,32 +868,8 @@ impl<'a> CrateReader<'a> {\n             }\n \n             info!(\"injecting a dep from {} to {}\", cnum, krate);\n-            let mut cnum_map = data.cnum_map.borrow_mut();\n-            let remote_cnum = cnum_map.len() + 1;\n-            let prev = cnum_map.insert(remote_cnum as ast::CrateNum, krate);\n-            assert!(prev.is_none());\n+            data.cnum_map.borrow_mut().push(krate);\n         });\n-\n-        fn validate(me: &CrateReader,\n-                    krate: ast::CrateNum,\n-                    root: ast::CrateNum,\n-                    what: &str,\n-                    needs_dep: &Fn(&cstore::crate_metadata) -> bool) {\n-            let data = me.cstore.get_crate_data(krate);\n-            if needs_dep(&data) {\n-                let krate_name = data.name();\n-                let data = me.cstore.get_crate_data(root);\n-                let root_name = data.name();\n-                me.sess.err(&format!(\"the crate `{}` cannot depend \\\n-                                      on a crate that needs {}, but \\\n-                                      it depends on `{}`\", root_name, what,\n-                                      krate_name));\n-            }\n-\n-            for (_, &dep) in data.cnum_map.borrow().iter() {\n-                validate(me, dep, root, what, needs_dep);\n-            }\n-        }\n     }\n }\n \n@@ -948,7 +943,8 @@ impl<'a> LocalCrateReader<'a> {\n                                                          span: i.span,\n                                                          direct: true,\n                                                          path_len: len,\n-                                                     });\n+                                                     },\n+                                                     &mut FnvHashSet());\n                     self.cstore.add_extern_mod_stmt_cnum(info.id, cnum);\n                 }\n             }"}, {"sha": "7573929ab2c04f7ec918736726cede309ae9d490", "filename": "src/librustc_metadata/cstore.rs", "status": "modified", "additions": 35, "deletions": 19, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/bff28ec46866bb2980d67a644e4e567b67ccb706/src%2Flibrustc_metadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bff28ec46866bb2980d67a644e4e567b67ccb706/src%2Flibrustc_metadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore.rs?ref=bff28ec46866bb2980d67a644e4e567b67ccb706", "patch": "@@ -26,6 +26,7 @@ use rustc::hir::map::DefKey;\n use rustc::hir::svh::Svh;\n use rustc::middle::cstore::{ExternCrate};\n use rustc::session::config::PanicStrategy;\n+use rustc_data_structures::indexed_vec::IndexVec;\n use rustc::util::nodemap::{FnvHashMap, NodeMap, NodeSet, DefIdMap};\n \n use std::cell::{RefCell, Ref, Cell};\n@@ -46,7 +47,7 @@ pub use middle::cstore::{CrateSource, LinkMeta};\n // local crate numbers (as generated during this session). Each external\n // crate may refer to types in other external crates, and each has their\n // own crate numbers.\n-pub type cnum_map = FnvHashMap<ast::CrateNum, ast::CrateNum>;\n+pub type CrateNumMap = IndexVec<ast::CrateNum, ast::CrateNum>;\n \n pub enum MetadataBlob {\n     MetadataVec(Bytes),\n@@ -64,7 +65,7 @@ pub struct ImportedFileMap {\n     pub translated_filemap: Rc<syntax_pos::FileMap>\n }\n \n-pub struct crate_metadata {\n+pub struct CrateMetadata {\n     pub name: String,\n \n     /// Information about the extern crate that caused this crate to\n@@ -73,7 +74,7 @@ pub struct crate_metadata {\n     pub extern_crate: Cell<Option<ExternCrate>>,\n \n     pub data: MetadataBlob,\n-    pub cnum_map: RefCell<cnum_map>,\n+    pub cnum_map: RefCell<CrateNumMap>,\n     pub cnum: ast::CrateNum,\n     pub codemap_import_info: RefCell<Vec<ImportedFileMap>>,\n     pub staged_api: bool,\n@@ -97,7 +98,7 @@ pub struct crate_metadata {\n \n pub struct CStore {\n     pub dep_graph: DepGraph,\n-    metas: RefCell<FnvHashMap<ast::CrateNum, Rc<crate_metadata>>>,\n+    metas: RefCell<FnvHashMap<ast::CrateNum, Rc<CrateMetadata>>>,\n     /// Map from NodeId's of local extern crate statements to crate numbers\n     extern_mod_crate_map: RefCell<NodeMap<ast::CrateNum>>,\n     used_crate_sources: RefCell<Vec<CrateSource>>,\n@@ -128,7 +129,7 @@ impl CStore {\n         self.metas.borrow().len() as ast::CrateNum + 1\n     }\n \n-    pub fn get_crate_data(&self, cnum: ast::CrateNum) -> Rc<crate_metadata> {\n+    pub fn get_crate_data(&self, cnum: ast::CrateNum) -> Rc<CrateMetadata> {\n         self.metas.borrow().get(&cnum).unwrap().clone()\n     }\n \n@@ -137,12 +138,12 @@ impl CStore {\n         decoder::get_crate_hash(cdata.data())\n     }\n \n-    pub fn set_crate_data(&self, cnum: ast::CrateNum, data: Rc<crate_metadata>) {\n+    pub fn set_crate_data(&self, cnum: ast::CrateNum, data: Rc<CrateMetadata>) {\n         self.metas.borrow_mut().insert(cnum, data);\n     }\n \n     pub fn iter_crate_data<I>(&self, mut i: I) where\n-        I: FnMut(ast::CrateNum, &Rc<crate_metadata>),\n+        I: FnMut(ast::CrateNum, &Rc<CrateMetadata>),\n     {\n         for (&k, v) in self.metas.borrow().iter() {\n             i(k, v);\n@@ -151,7 +152,7 @@ impl CStore {\n \n     /// Like `iter_crate_data`, but passes source paths (if available) as well.\n     pub fn iter_crate_data_origins<I>(&self, mut i: I) where\n-        I: FnMut(ast::CrateNum, &crate_metadata, Option<CrateSource>),\n+        I: FnMut(ast::CrateNum, &CrateMetadata, Option<CrateSource>),\n     {\n         for (&k, v) in self.metas.borrow().iter() {\n             let origin = self.opt_used_crate_source(k);\n@@ -182,6 +183,30 @@ impl CStore {\n         self.statically_included_foreign_items.borrow_mut().clear();\n     }\n \n+    pub fn crate_dependencies_in_rpo(&self, krate: ast::CrateNum) -> Vec<ast::CrateNum>\n+    {\n+        let mut ordering = Vec::new();\n+        self.push_dependencies_in_postorder(&mut ordering, krate);\n+        ordering.reverse();\n+        ordering\n+    }\n+\n+    pub fn push_dependencies_in_postorder(&self,\n+                                          ordering: &mut Vec<ast::CrateNum>,\n+                                          krate: ast::CrateNum)\n+    {\n+        if ordering.contains(&krate) { return }\n+\n+        let data = self.get_crate_data(krate);\n+        for &dep in data.cnum_map.borrow().iter() {\n+            if dep != krate {\n+                self.push_dependencies_in_postorder(ordering, dep);\n+            }\n+        }\n+\n+        ordering.push(krate);\n+    }\n+\n     // This method is used when generating the command line to pass through to\n     // system linker. The linker expects undefined symbols on the left of the\n     // command line to be defined in libraries on the right, not the other way\n@@ -194,17 +219,8 @@ impl CStore {\n     pub fn do_get_used_crates(&self, prefer: LinkagePreference)\n                               -> Vec<(ast::CrateNum, Option<PathBuf>)> {\n         let mut ordering = Vec::new();\n-        fn visit(cstore: &CStore, cnum: ast::CrateNum,\n-                 ordering: &mut Vec<ast::CrateNum>) {\n-            if ordering.contains(&cnum) { return }\n-            let meta = cstore.get_crate_data(cnum);\n-            for (_, &dep) in meta.cnum_map.borrow().iter() {\n-                visit(cstore, dep, ordering);\n-            }\n-            ordering.push(cnum);\n-        }\n         for (&num, _) in self.metas.borrow().iter() {\n-            visit(self, num, &mut ordering);\n+            self.push_dependencies_in_postorder(&mut ordering, num);\n         }\n         info!(\"topological ordering: {:?}\", ordering);\n         ordering.reverse();\n@@ -264,7 +280,7 @@ impl CStore {\n     }\n }\n \n-impl crate_metadata {\n+impl CrateMetadata {\n     pub fn data<'a>(&'a self) -> &'a [u8] { self.data.as_slice() }\n     pub fn name(&self) -> &str { decoder::get_crate_name(self.data()) }\n     pub fn hash(&self) -> Svh { decoder::get_crate_hash(self.data()) }"}, {"sha": "0a59c152ca379273cd99d7b9e369b542abf97fcb", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 12, "deletions": 24, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/bff28ec46866bb2980d67a644e4e567b67ccb706/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bff28ec46866bb2980d67a644e4e567b67ccb706/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=bff28ec46866bb2980d67a644e4e567b67ccb706", "patch": "@@ -15,7 +15,7 @@\n use self::Family::*;\n \n use astencode::decode_inlined_item;\n-use cstore::{self, crate_metadata};\n+use cstore::{self, CrateMetadata};\n use common::*;\n use def_key;\n use encoder::def_to_u64;\n@@ -30,7 +30,7 @@ use rustc::util::nodemap::FnvHashMap;\n use rustc::hir;\n use rustc::session::config::PanicStrategy;\n \n-use middle::cstore::{LOCAL_CRATE, FoundAst, InlinedItem, LinkagePreference};\n+use middle::cstore::{FoundAst, InlinedItem, LinkagePreference};\n use middle::cstore::{DefLike, DlDef, DlField, DlImpl, tls};\n use rustc::hir::def::Def;\n use rustc::hir::def_id::{DefId, DefIndex};\n@@ -61,9 +61,9 @@ use syntax::print::pprust;\n use syntax::ptr::P;\n use syntax_pos::{self, Span, BytePos, NO_EXPANSION};\n \n-pub type Cmd<'a> = &'a crate_metadata;\n+pub type Cmd<'a> = &'a CrateMetadata;\n \n-impl crate_metadata {\n+impl CrateMetadata {\n     fn get_item(&self, item_id: DefIndex) -> Option<rbml::Doc> {\n         self.index.lookup_item(self.data(), item_id).map(|pos| {\n             reader::doc_at(self.data(), pos as usize).unwrap().doc\n@@ -663,7 +663,7 @@ fn each_child_of_item_or_crate<F, G>(intr: Rc<IdentInterner>,\n                                      mut get_crate_data: G,\n                                      mut callback: F) where\n     F: FnMut(DefLike, ast::Name, ty::Visibility),\n-    G: FnMut(ast::CrateNum) -> Rc<crate_metadata>,\n+    G: FnMut(ast::CrateNum) -> Rc<CrateMetadata>,\n {\n     // Iterate over all children.\n     for child_info_doc in reader::tagged_docs(item_doc, tag_mod_child) {\n@@ -758,7 +758,7 @@ pub fn each_child_of_item<F, G>(intr: Rc<IdentInterner>,\n                                get_crate_data: G,\n                                callback: F) where\n     F: FnMut(DefLike, ast::Name, ty::Visibility),\n-    G: FnMut(ast::CrateNum) -> Rc<crate_metadata>,\n+    G: FnMut(ast::CrateNum) -> Rc<CrateMetadata>,\n {\n     // Find the item.\n     let item_doc = match cdata.get_item(id) {\n@@ -779,7 +779,7 @@ pub fn each_top_level_item_of_crate<F, G>(intr: Rc<IdentInterner>,\n                                           get_crate_data: G,\n                                           callback: F) where\n     F: FnMut(DefLike, ast::Name, ty::Visibility),\n-    G: FnMut(ast::CrateNum) -> Rc<crate_metadata>,\n+    G: FnMut(ast::CrateNum) -> Rc<CrateMetadata>,\n {\n     let root_doc = rbml::Doc::new(cdata.data());\n     let misc_info_doc = reader::get_doc(root_doc, tag_misc_info);\n@@ -1348,25 +1348,16 @@ pub fn translate_def_id(cdata: Cmd, did: DefId) -> DefId {\n         return DefId { krate: cdata.cnum, index: did.index };\n     }\n \n-    match cdata.cnum_map.borrow().get(&did.krate) {\n-        Some(&n) => {\n-            DefId {\n-                krate: n,\n-                index: did.index,\n-            }\n-        }\n-        None => bug!(\"didn't find a crate in the cnum_map\")\n+    DefId {\n+        krate: cdata.cnum_map.borrow()[did.krate],\n+        index: did.index\n     }\n }\n \n // Translate a DefId from the current compilation environment to a DefId\n // for an external crate.\n fn reverse_translate_def_id(cdata: Cmd, did: DefId) -> Option<DefId> {\n-    if did.krate == cdata.cnum {\n-        return Some(DefId { krate: LOCAL_CRATE, index: did.index });\n-    }\n-\n-    for (&local, &global) in cdata.cnum_map.borrow().iter() {\n+    for (local, &global) in cdata.cnum_map.borrow().iter_enumerated() {\n         if global == did.krate {\n             return Some(DefId { krate: local, index: did.index });\n         }\n@@ -1545,10 +1536,7 @@ pub fn get_dylib_dependency_formats(cdata: Cmd)\n         let cnum = spec.split(':').nth(0).unwrap();\n         let link = spec.split(':').nth(1).unwrap();\n         let cnum: ast::CrateNum = cnum.parse().unwrap();\n-        let cnum = match cdata.cnum_map.borrow().get(&cnum) {\n-            Some(&n) => n,\n-            None => bug!(\"didn't find a crate in the cnum_map\")\n-        };\n+        let cnum = cdata.cnum_map.borrow()[cnum];\n         result.push((cnum, if link == \"d\" {\n             LinkagePreference::RequireDynamic\n         } else {"}, {"sha": "b2f52100da4c7a3baa096f5befcccb4fc7c386ce", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bff28ec46866bb2980d67a644e4e567b67ccb706/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bff28ec46866bb2980d67a644e4e567b67ccb706/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=bff28ec46866bb2980d67a644e4e567b67ccb706", "patch": "@@ -1505,7 +1505,7 @@ fn encode_polarity(rbml_w: &mut Encoder, polarity: hir::ImplPolarity) {\n \n fn encode_crate_deps(rbml_w: &mut Encoder, cstore: &cstore::CStore) {\n     fn get_ordered_deps(cstore: &cstore::CStore)\n-                        -> Vec<(CrateNum, Rc<cstore::crate_metadata>)> {\n+                        -> Vec<(CrateNum, Rc<cstore::CrateMetadata>)> {\n         // Pull the cnums and name,vers,hash out of cstore\n         let mut deps = Vec::new();\n         cstore.iter_crate_data(|cnum, val| {\n@@ -1736,7 +1736,7 @@ fn encode_reachable(ecx: &EncodeContext, rbml_w: &mut Encoder) {\n }\n \n fn encode_crate_dep(rbml_w: &mut Encoder,\n-                    dep: &cstore::crate_metadata) {\n+                    dep: &cstore::CrateMetadata) {\n     rbml_w.start_tag(tag_crate_dep);\n     rbml_w.wr_tagged_str(tag_crate_dep_crate_name, &dep.name());\n     let hash = decoder::get_crate_hash(dep.data());"}, {"sha": "cd92493e3db703adc8e7931d51357fbc6292406f", "filename": "src/librustc_metadata/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bff28ec46866bb2980d67a644e4e567b67ccb706/src%2Flibrustc_metadata%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bff28ec46866bb2980d67a644e4e567b67ccb706/src%2Flibrustc_metadata%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flib.rs?ref=bff28ec46866bb2980d67a644e4e567b67ccb706", "patch": "@@ -36,6 +36,7 @@ extern crate rustc_errors as errors;\n \n #[macro_use]\n extern crate rustc;\n+extern crate rustc_data_structures;\n extern crate rustc_back;\n extern crate rustc_llvm;\n extern crate rustc_const_math;"}, {"sha": "c9d1eb39f0a3de464f6028d192e6ad4737ceb1e0", "filename": "src/rustc/Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bff28ec46866bb2980d67a644e4e567b67ccb706/src%2Frustc%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/bff28ec46866bb2980d67a644e4e567b67ccb706/src%2Frustc%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2FCargo.lock?ref=bff28ec46866bb2980d67a644e4e567b67ccb706", "patch": "@@ -213,6 +213,7 @@ dependencies = [\n  \"rustc_back 0.0.0\",\n  \"rustc_bitflags 0.0.0\",\n  \"rustc_const_math 0.0.0\",\n+ \"rustc_data_structures 0.0.0\",\n  \"rustc_errors 0.0.0\",\n  \"rustc_llvm 0.0.0\",\n  \"serialize 0.0.0\","}]}