{"sha": "0b3b95755436da9f0fc78bd00f780c32bab92f7d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBiM2I5NTc1NTQzNmRhOWYwZmM3OGJkMDBmNzgwYzMyYmFiOTJmN2Q=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-01-06T23:29:09Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-01-06T23:29:09Z"}, "message": "rollup merge of #20645: nikomatsakis/rustbook-ice\n\nConflicts:\n\tsrc/librustc/middle/mem_categorization.rs\n\tsrc/librustc/middle/ty.rs\n\tsrc/librustc_trans/trans/base.rs\n\tsrc/librustc_trans/trans/expr.rs\n\tsrc/librustc_trans/trans/foreign.rs\n\tsrc/librustc_typeck/check/mod.rs", "tree": {"sha": "d4ae3c5c597ce405a6643c1a22516213dd7ef35d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d4ae3c5c597ce405a6643c1a22516213dd7ef35d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0b3b95755436da9f0fc78bd00f780c32bab92f7d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0b3b95755436da9f0fc78bd00f780c32bab92f7d", "html_url": "https://github.com/rust-lang/rust/commit/0b3b95755436da9f0fc78bd00f780c32bab92f7d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0b3b95755436da9f0fc78bd00f780c32bab92f7d/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e0f546a07e9bbbe58bcd851726025c51f40d36f6", "url": "https://api.github.com/repos/rust-lang/rust/commits/e0f546a07e9bbbe58bcd851726025c51f40d36f6", "html_url": "https://github.com/rust-lang/rust/commit/e0f546a07e9bbbe58bcd851726025c51f40d36f6"}, {"sha": "2486d93e5b8a3dd62fa6d257d4086e19c0e0edd6", "url": "https://api.github.com/repos/rust-lang/rust/commits/2486d93e5b8a3dd62fa6d257d4086e19c0e0edd6", "html_url": "https://github.com/rust-lang/rust/commit/2486d93e5b8a3dd62fa6d257d4086e19c0e0edd6"}], "stats": {"total": 563, "additions": 386, "deletions": 177}, "files": [{"sha": "f7fc90bcef6510c914a5a460f1ce62ad9dd2d5b3", "filename": "src/librustc/middle/cfg/construct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b3b95755436da9f0fc78bd00f780c32bab92f7d/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b3b95755436da9f0fc78bd00f780c32bab92f7d/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs?ref=0b3b95755436da9f0fc78bd00f780c32bab92f7d", "patch": "@@ -514,7 +514,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n \n         let func_or_rcvr_exit = self.expr(func_or_rcvr, pred);\n         let ret = self.straightline(call_expr, func_or_rcvr_exit, args);\n-        if return_ty == ty::FnDiverging {\n+        if return_ty.diverges() {\n             self.add_node(ast::DUMMY_NODE_ID, &[])\n         } else {\n             ret"}, {"sha": "d93b323ad071efd4375371ff62868bc60af10722", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0b3b95755436da9f0fc78bd00f780c32bab92f7d/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b3b95755436da9f0fc78bd00f780c32bab92f7d/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=0b3b95755436da9f0fc78bd00f780c32bab92f7d", "patch": "@@ -848,7 +848,12 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                 None => {}\n                 Some(method_ty) => {\n                     let cmt = return_if_err!(self.mc.cat_expr_autoderefd(expr, i));\n-                    let self_ty = ty::ty_fn_args(method_ty)[0];\n+\n+                    // the method call infrastructure should have\n+                    // replaced all late-bound regions with variables:\n+                    let self_ty = ty::ty_fn_sig(method_ty).input(0);\n+                    let self_ty = ty::assert_no_late_bound_regions(self.tcx(), &self_ty);\n+\n                     let (m, r) = match self_ty.sty {\n                         ty::ty_rptr(r, ref m) => (m.mutbl, r),\n                         _ => self.tcx().sess.span_bug(expr.span,"}, {"sha": "850033b3ed126a0c65d0db7cceaf020561a01b55", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/0b3b95755436da9f0fc78bd00f780c32bab92f7d/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b3b95755436da9f0fc78bd00f780c32bab92f7d/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=0b3b95755436da9f0fc78bd00f780c32bab92f7d", "patch": "@@ -112,6 +112,7 @@ use self::VarKind::*;\n use middle::def::*;\n use middle::mem_categorization::Typer;\n use middle::pat_util;\n+use middle::region::CodeExtent;\n use middle::ty;\n use middle::ty::UnboxedClosureTyper;\n use lint;\n@@ -1149,8 +1150,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n           ast::ExprCall(ref f, ref args) => {\n             let diverges = !self.ir.tcx.is_method_call(expr.id) && {\n-                let t_ret = ty::ty_fn_ret(ty::expr_ty_adjusted(self.ir.tcx, &**f));\n-                t_ret == ty::FnDiverging\n+                ty::ty_fn_ret(ty::expr_ty_adjusted(self.ir.tcx, &**f)).diverges()\n             };\n             let succ = if diverges {\n                 self.s.exit_ln\n@@ -1164,7 +1164,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n           ast::ExprMethodCall(_, _, ref args) => {\n             let method_call = ty::MethodCall::expr(expr.id);\n             let method_ty = self.ir.tcx.method_map.borrow().get(&method_call).unwrap().ty;\n-            let diverges = ty::ty_fn_ret(method_ty) == ty::FnDiverging;\n+            let diverges = ty::ty_fn_ret(method_ty).diverges();\n             let succ = if diverges {\n                 self.s.exit_ln\n             } else {\n@@ -1514,11 +1514,11 @@ fn check_fn(_v: &Liveness,\n }\n \n impl<'a, 'tcx> Liveness<'a, 'tcx> {\n-    fn fn_ret(&self, id: NodeId) -> ty::FnOutput<'tcx> {\n+    fn fn_ret(&self, id: NodeId) -> ty::PolyFnOutput<'tcx> {\n         let fn_ty = ty::node_id_to_type(self.ir.tcx, id);\n         match fn_ty.sty {\n             ty::ty_unboxed_closure(closure_def_id, _, substs) =>\n-                self.ir.tcx.unboxed_closure_type(closure_def_id, substs).sig.0.output,\n+                self.ir.tcx.unboxed_closure_type(closure_def_id, substs).sig.output(),\n             _ =>\n                 ty::ty_fn_ret(fn_ty),\n         }\n@@ -1529,8 +1529,16 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                  sp: Span,\n                  _fk: FnKind,\n                  entry_ln: LiveNode,\n-                 body: &ast::Block) {\n-        match self.fn_ret(id) {\n+                 body: &ast::Block)\n+    {\n+        // within the fn body, late-bound regions are liberated:\n+        let fn_ret =\n+            ty::liberate_late_bound_regions(\n+                self.ir.tcx,\n+                CodeExtent::from_node_id(body.id),\n+                &self.fn_ret(id));\n+\n+        match fn_ret {\n             ty::FnConverging(t_ret)\n                 if self.live_on_entry(entry_ln, self.s.no_ret_var).is_some() => {\n "}, {"sha": "b1afd30a13ae8d6ce99d503688eb945bd57b4e0c", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 21, "deletions": 3, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/0b3b95755436da9f0fc78bd00f780c32bab92f7d/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b3b95755436da9f0fc78bd00f780c32bab92f7d/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=0b3b95755436da9f0fc78bd00f780c32bab92f7d", "patch": "@@ -857,7 +857,9 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n \n         let base_cmt = match method_ty {\n             Some(method_ty) => {\n-                let ref_ty = ty::ty_fn_ret(method_ty).unwrap();\n+                let ref_ty =\n+                    ty::assert_no_late_bound_regions(\n+                        self.tcx(), &ty::ty_fn_ret(method_ty)).unwrap();\n                 self.cat_rvalue_node(node.id(), node.span(), ref_ty)\n             }\n             None => base_cmt\n@@ -937,9 +939,12 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n \n         let element_ty = match method_ty {\n             Some(method_ty) => {\n-                let ref_ty = ty::ty_fn_ret(method_ty).unwrap();\n+                let ref_ty = self.overloaded_method_return_ty(method_ty);\n                 base_cmt = self.cat_rvalue_node(elt.id(), elt.span(), ref_ty);\n-                ty::ty_fn_args(method_ty)[0]\n+\n+                // FIXME(#20649) -- why are we using the `self_ty` as the element type...?\n+                let self_ty = ty::ty_fn_sig(method_ty).input(0);\n+                ty::assert_no_late_bound_regions(self.tcx(), &self_ty)\n             }\n             None => {\n                 match ty::array_element_ty(self.tcx(), base_cmt.ty) {\n@@ -1261,6 +1266,19 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n \n         Ok(())\n     }\n+\n+    fn overloaded_method_return_ty(&self,\n+                                   method_ty: Ty<'tcx>)\n+                                   -> Ty<'tcx>\n+    {\n+        // When we process an overloaded `*` or `[]` etc, we often\n+        // need to extract the return type of the method. These method\n+        // types are generated by method resolution and always have\n+        // all late-bound regions fully instantiated, so we just want\n+        // to skip past the binder.\n+        ty::assert_no_late_bound_regions(self.tcx(), &ty::ty_fn_ret(method_ty))\n+            .unwrap() // overloaded ops do not diverge, either\n+    }\n }\n \n #[derive(Copy)]"}, {"sha": "9f44d02e07e98e1605f84e563d26827ac807e31a", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 55, "deletions": 48, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/0b3b95755436da9f0fc78bd00f780c32bab92f7d/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b3b95755436da9f0fc78bd00f780c32bab92f7d/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=0b3b95755436da9f0fc78bd00f780c32bab92f7d", "patch": "@@ -1054,6 +1054,10 @@ pub enum FnOutput<'tcx> {\n }\n \n impl<'tcx> FnOutput<'tcx> {\n+    pub fn diverges(&self) -> bool {\n+        *self == FnDiverging\n+    }\n+\n     pub fn unwrap(self) -> Ty<'tcx> {\n         match self {\n             ty::FnConverging(t) => t,\n@@ -1062,6 +1066,14 @@ impl<'tcx> FnOutput<'tcx> {\n     }\n }\n \n+pub type PolyFnOutput<'tcx> = Binder<FnOutput<'tcx>>;\n+\n+impl<'tcx> PolyFnOutput<'tcx> {\n+    pub fn diverges(&self) -> bool {\n+        self.0.diverges()\n+    }\n+}\n+\n /// Signature of a function type, which I have arbitrarily\n /// decided to use to refer to the input/output types.\n ///\n@@ -1077,6 +1089,21 @@ pub struct FnSig<'tcx> {\n \n pub type PolyFnSig<'tcx> = Binder<FnSig<'tcx>>;\n \n+impl<'tcx> PolyFnSig<'tcx> {\n+    pub fn inputs(&self) -> ty::Binder<Vec<Ty<'tcx>>> {\n+        ty::Binder(self.0.inputs.clone())\n+    }\n+    pub fn input(&self, index: uint) -> ty::Binder<Ty<'tcx>> {\n+        ty::Binder(self.0.inputs[index])\n+    }\n+    pub fn output(&self) -> ty::Binder<FnOutput<'tcx>> {\n+        ty::Binder(self.0.output.clone())\n+    }\n+    pub fn variadic(&self) -> bool {\n+        self.0.variadic\n+    }\n+}\n+\n #[derive(Clone, Copy, PartialEq, Eq, Hash, Show)]\n pub struct ParamTy {\n     pub space: subst::ParamSpace,\n@@ -4146,8 +4173,8 @@ pub fn ty_fn_abi(fty: Ty) -> abi::Abi {\n }\n \n // Type accessors for substructures of types\n-pub fn ty_fn_args<'tcx>(fty: Ty<'tcx>) -> &'tcx [Ty<'tcx>] {\n-    ty_fn_sig(fty).0.inputs.as_slice()\n+pub fn ty_fn_args<'tcx>(fty: Ty<'tcx>) -> ty::Binder<Vec<Ty<'tcx>>> {\n+    ty_fn_sig(fty).inputs()\n }\n \n pub fn ty_closure_store(fty: Ty) -> TraitStore {\n@@ -4163,9 +4190,9 @@ pub fn ty_closure_store(fty: Ty) -> TraitStore {\n     }\n }\n \n-pub fn ty_fn_ret<'tcx>(fty: Ty<'tcx>) -> FnOutput<'tcx> {\n+pub fn ty_fn_ret<'tcx>(fty: Ty<'tcx>) -> Binder<FnOutput<'tcx>> {\n     match fty.sty {\n-        ty_bare_fn(_, ref f) => f.sig.0.output,\n+        ty_bare_fn(_, ref f) => f.sig.output(),\n         ref s => {\n             panic!(\"ty_fn_ret() called on non-fn type: {:?}\", s)\n         }\n@@ -4320,9 +4347,12 @@ pub fn adjust_ty<'tcx, F>(cx: &ctxt<'tcx>,\n                             let method_call = MethodCall::autoderef(expr_id, i);\n                             match method_type(method_call) {\n                                 Some(method_ty) => {\n-                                    if let ty::FnConverging(result_type) = ty_fn_ret(method_ty) {\n-                                        adjusted_ty = result_type;\n-                                    }\n+                                    // overloaded deref operators have all late-bound\n+                                    // regions fully instantiated and coverge\n+                                    let fn_ret =\n+                                        ty::assert_no_late_bound_regions(cx,\n+                                                                         &ty_fn_ret(method_ty));\n+                                    adjusted_ty = fn_ret.unwrap();\n                                 }\n                                 None => {}\n                             }\n@@ -5144,7 +5174,9 @@ impl<'tcx> VariantInfo<'tcx> {\n         match ast_variant.node.kind {\n             ast::TupleVariantKind(ref args) => {\n                 let arg_tys = if args.len() > 0 {\n-                    ty_fn_args(ctor_ty).iter().map(|a| *a).collect()\n+                    // the regions in the argument types come from the\n+                    // enum def'n, and hence will all be early bound\n+                    ty::assert_no_late_bound_regions(cx, &ty_fn_args(ctor_ty))\n                 } else {\n                     Vec::new()\n                 };\n@@ -5160,7 +5192,6 @@ impl<'tcx> VariantInfo<'tcx> {\n                 };\n             },\n             ast::StructVariantKind(ref struct_def) => {\n-\n                 let fields: &[StructField] = struct_def.fields.index(&FullRange);\n \n                 assert!(fields.len() > 0);\n@@ -5792,40 +5823,6 @@ pub fn is_binopable<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>, op: ast::BinOp) -> bool\n     return tbl[tycat(cx, ty) as uint ][opcat(op) as uint];\n }\n \n-/// Returns an equivalent type with all the typedefs and self regions removed.\n-pub fn normalize_ty<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> Ty<'tcx> {\n-    let u = TypeNormalizer(cx).fold_ty(ty);\n-    return u;\n-\n-    struct TypeNormalizer<'a, 'tcx: 'a>(&'a ctxt<'tcx>);\n-\n-    impl<'a, 'tcx> TypeFolder<'tcx> for TypeNormalizer<'a, 'tcx> {\n-        fn tcx(&self) -> &ctxt<'tcx> { let TypeNormalizer(c) = *self; c }\n-\n-        fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n-            match self.tcx().normalized_cache.borrow().get(&ty).cloned() {\n-                None => {}\n-                Some(u) => return u\n-            }\n-\n-            let t_norm = ty_fold::super_fold_ty(self, ty);\n-            self.tcx().normalized_cache.borrow_mut().insert(ty, t_norm);\n-            return t_norm;\n-        }\n-\n-        fn fold_region(&mut self, _: ty::Region) -> ty::Region {\n-            ty::ReStatic\n-        }\n-\n-        fn fold_substs(&mut self,\n-                       substs: &subst::Substs<'tcx>)\n-                       -> subst::Substs<'tcx> {\n-            subst::Substs { regions: subst::ErasedRegions,\n-                            types: substs.types.fold_with(self) }\n-        }\n-    }\n-}\n-\n // Returns the repeat count for a repeating vector expression.\n pub fn eval_repeat_count(tcx: &ctxt, count_expr: &ast::Expr) -> uint {\n     match const_eval::eval_const_expr_partial(tcx, count_expr) {\n@@ -6205,7 +6202,7 @@ pub fn hash_crate_independent<'tcx>(tcx: &ctxt<'tcx>, ty: Ty<'tcx>, svh: &Svh) -\n             mt.mutbl.hash(state);\n         };\n         let fn_sig = |&: state: &mut sip::SipState, sig: &Binder<FnSig<'tcx>>| {\n-            let sig = anonymize_late_bound_regions(tcx, sig);\n+            let sig = anonymize_late_bound_regions(tcx, sig).0;\n             for a in sig.inputs.iter() { helper(tcx, *a, svh, state); }\n             if let ty::FnConverging(output) = sig.output {\n                 helper(tcx, output, svh, state);\n@@ -6266,7 +6263,7 @@ pub fn hash_crate_independent<'tcx>(tcx: &ctxt<'tcx>, ty: Ty<'tcx>, svh: &Svh) -\n                     did(state, data.principal_def_id());\n                     hash!(data.bounds);\n \n-                    let principal = anonymize_late_bound_regions(tcx, &data.principal);\n+                    let principal = anonymize_late_bound_regions(tcx, &data.principal).0;\n                     for subty in principal.substs.types.iter() {\n                         helper(tcx, *subty, svh, state);\n                     }\n@@ -6697,6 +6694,16 @@ pub fn binds_late_bound_regions<'tcx, T>(\n     count_late_bound_regions(tcx, value) > 0\n }\n \n+pub fn assert_no_late_bound_regions<'tcx, T>(\n+    tcx: &ty::ctxt<'tcx>,\n+    value: &Binder<T>)\n+    -> T\n+    where T : TypeFoldable<'tcx> + Repr<'tcx> + Clone\n+{\n+    assert!(!binds_late_bound_regions(tcx, value));\n+    value.0.clone()\n+}\n+\n /// Replace any late-bound regions bound in `value` with `'static`. Useful in trans but also\n /// method lookup and a few other places where precise region relationships are not required.\n pub fn erase_late_bound_regions<'tcx, T>(\n@@ -6719,14 +6726,14 @@ pub fn erase_late_bound_regions<'tcx, T>(\n pub fn anonymize_late_bound_regions<'tcx, T>(\n     tcx: &ctxt<'tcx>,\n     sig: &Binder<T>)\n-    -> T\n+    -> Binder<T>\n     where T : TypeFoldable<'tcx> + Repr<'tcx>,\n {\n     let mut counter = 0;\n-    replace_late_bound_regions(tcx, sig, |_, db| {\n+    ty::Binder(replace_late_bound_regions(tcx, sig, |_, db| {\n         counter += 1;\n         ReLateBound(db, BrAnon(counter))\n-    }).0\n+    }).0)\n }\n \n /// Replaces the late-bound-regions in `value` that are bound by `value`."}, {"sha": "dadbae9349fc352621b4dbedede72a3f623f96ba", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0b3b95755436da9f0fc78bd00f780c32bab92f7d/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b3b95755436da9f0fc78bd00f780c32bab92f7d/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=0b3b95755436da9f0fc78bd00f780c32bab92f7d", "patch": "@@ -868,6 +868,9 @@ impl<'a, 'tcx> TypeFolder<'tcx> for RegionEraser<'a, 'tcx> {\n     fn tcx(&self) -> &ty::ctxt<'tcx> { self.tcx }\n \n     fn fold_region(&mut self, r: ty::Region) -> ty::Region {\n+        // because whether or not a region is bound affects subtyping,\n+        // we can't erase the bound/free distinction, but we can\n+        // replace all free regions with 'static\n         match r {\n             ty::ReLateBound(..) | ty::ReEarlyBound(..) => r,\n             _ => ty::ReStatic"}, {"sha": "057d0f378e6f41cd37125b55aba7b0914b6530ab", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 38, "deletions": 24, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/0b3b95755436da9f0fc78bd00f780c32bab92f7d/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b3b95755436da9f0fc78bd00f780c32bab92f7d/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=0b3b95755436da9f0fc78bd00f780c32bab92f7d", "patch": "@@ -283,35 +283,40 @@ pub fn decl_rust_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                               fn_ty: Ty<'tcx>, name: &str) -> ValueRef {\n     let fn_ty = monomorphize::normalize_associated_type(ccx.tcx(), &fn_ty);\n \n-    let (inputs, output, abi, env) = match fn_ty.sty {\n+    let function_type; // placeholder so that the memory ownership works out ok\n+\n+    let (sig, abi, env) = match fn_ty.sty {\n         ty::ty_bare_fn(_, ref f) => {\n-            (f.sig.0.inputs.clone(), f.sig.0.output, f.abi, None)\n+            (&f.sig, f.abi, None)\n         }\n         ty::ty_unboxed_closure(closure_did, _, substs) => {\n             let typer = common::NormalizingUnboxedClosureTyper::new(ccx.tcx());\n-            let function_type = typer.unboxed_closure_type(closure_did, substs);\n+            function_type = typer.unboxed_closure_type(closure_did, substs);\n             let self_type = self_type_for_unboxed_closure(ccx, closure_did, fn_ty);\n             let llenvironment_type = type_of_explicit_arg(ccx, self_type);\n             debug!(\"decl_rust_fn: function_type={} self_type={}\",\n                    function_type.repr(ccx.tcx()),\n                    self_type.repr(ccx.tcx()));\n-            (function_type.sig.0.inputs,\n-             function_type.sig.0.output,\n-             RustCall,\n-             Some(llenvironment_type))\n+            (&function_type.sig, RustCall, Some(llenvironment_type))\n         }\n         _ => panic!(\"expected closure or fn\")\n     };\n \n-    let llfty = type_of_rust_fn(ccx, env, inputs.index(&FullRange), output, abi);\n-    debug!(\"decl_rust_fn(input count={},type={})\",\n-           inputs.len(),\n+    let sig = ty::erase_late_bound_regions(ccx.tcx(), sig);\n+    let sig = ty::Binder(sig);\n+\n+    let llfty = type_of_rust_fn(ccx, env, &sig, abi);\n+\n+    debug!(\"decl_rust_fn(sig={}, type={})\",\n+           sig.repr(ccx.tcx()),\n            ccx.tn().type_to_string(llfty));\n \n-    let llfn = decl_fn(ccx, name, llvm::CCallConv, llfty, output);\n+    let llfn = decl_fn(ccx, name, llvm::CCallConv, llfty, sig.0.output /* (1) */);\n     let attrs = get_fn_llvm_attributes(ccx, fn_ty);\n     attrs.apply_llfn(llfn);\n \n+    // (1) it's ok to directly access sig.0.output because we erased all late-bound-regions above\n+\n     llfn\n }\n \n@@ -1938,7 +1943,7 @@ pub fn trans_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     debug!(\"trans_fn(param_substs={})\", param_substs.repr(ccx.tcx()));\n     let _icx = push_ctxt(\"trans_fn\");\n     let fn_ty = ty::node_id_to_type(ccx.tcx(), id);\n-    let output_type = ty::ty_fn_ret(fn_ty);\n+    let output_type = ty::erase_late_bound_regions(ccx.tcx(), &ty::ty_fn_ret(fn_ty));\n     let abi = ty::ty_fn_abi(fn_ty);\n     trans_closure(ccx,\n                   decl,\n@@ -1981,7 +1986,9 @@ pub fn trans_named_tuple_constructor<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     let tcx = ccx.tcx();\n \n     let result_ty = match ctor_ty.sty {\n-        ty::ty_bare_fn(_, ref bft) => bft.sig.0.output.unwrap(),\n+        ty::ty_bare_fn(_, ref bft) => {\n+            ty::erase_late_bound_regions(bcx.tcx(), &bft.sig.output()).unwrap()\n+        }\n         _ => ccx.sess().bug(\n             format!(\"trans_enum_variant_constructor: \\\n                      unexpected ctor return type {}\",\n@@ -2053,7 +2060,9 @@ fn trans_enum_variant_or_tuple_like_struct<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx\n     let ctor_ty = monomorphize::apply_param_substs(ccx.tcx(), param_substs, &ctor_ty);\n \n     let result_ty = match ctor_ty.sty {\n-        ty::ty_bare_fn(_, ref bft) => bft.sig.0.output,\n+        ty::ty_bare_fn(_, ref bft) => {\n+            ty::erase_late_bound_regions(ccx.tcx(), &bft.sig.output())\n+        }\n         _ => ccx.sess().bug(\n             format!(\"trans_enum_variant_or_tuple_like_struct: \\\n                      unexpected ctor return type {}\",\n@@ -2067,7 +2076,9 @@ fn trans_enum_variant_or_tuple_like_struct<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx\n \n     assert!(!fcx.needs_ret_allocas);\n \n-    let arg_tys = ty::ty_fn_args(ctor_ty);\n+    let arg_tys =\n+        ty::erase_late_bound_regions(\n+            ccx.tcx(), &ty::ty_fn_args(ctor_ty));\n \n     let arg_datums = create_datums_for_fn_args(&fcx, arg_tys.index(&FullRange));\n \n@@ -2426,49 +2437,52 @@ fn register_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n }\n \n pub fn get_fn_llvm_attributes<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fn_ty: Ty<'tcx>)\n-                                        -> llvm::AttrBuilder {\n+                                        -> llvm::AttrBuilder\n+{\n     use middle::ty::{BrAnon, ReLateBound};\n \n+    let function_type;\n     let (fn_sig, abi, has_env) = match fn_ty.sty {\n-        ty::ty_bare_fn(_, ref f) => (f.sig.clone(), f.abi, false),\n+        ty::ty_bare_fn(_, ref f) => (&f.sig, f.abi, false),\n         ty::ty_unboxed_closure(closure_did, _, substs) => {\n             let typer = common::NormalizingUnboxedClosureTyper::new(ccx.tcx());\n-            let function_type = typer.unboxed_closure_type(closure_did, substs);\n-            (function_type.sig, RustCall, true)\n+            function_type = typer.unboxed_closure_type(closure_did, substs);\n+            (&function_type.sig, RustCall, true)\n         }\n         _ => ccx.sess().bug(\"expected closure or function.\")\n     };\n \n+    let fn_sig = ty::erase_late_bound_regions(ccx.tcx(), fn_sig);\n \n     // Since index 0 is the return value of the llvm func, we start\n     // at either 1 or 2 depending on whether there's an env slot or not\n     let mut first_arg_offset = if has_env { 2 } else { 1 };\n     let mut attrs = llvm::AttrBuilder::new();\n-    let ret_ty = fn_sig.0.output;\n+    let ret_ty = fn_sig.output;\n \n     // These have an odd calling convention, so we need to manually\n     // unpack the input ty's\n     let input_tys = match fn_ty.sty {\n         ty::ty_unboxed_closure(_, _, _) => {\n             assert!(abi == RustCall);\n \n-            match fn_sig.0.inputs[0].sty {\n+            match fn_sig.inputs[0].sty {\n                 ty::ty_tup(ref inputs) => inputs.clone(),\n                 _ => ccx.sess().bug(\"expected tuple'd inputs\")\n             }\n         },\n         ty::ty_bare_fn(..) if abi == RustCall => {\n-            let mut inputs = vec![fn_sig.0.inputs[0]];\n+            let mut inputs = vec![fn_sig.inputs[0]];\n \n-            match fn_sig.0.inputs[1].sty {\n+            match fn_sig.inputs[1].sty {\n                 ty::ty_tup(ref t_in) => {\n                     inputs.push_all(t_in.index(&FullRange));\n                     inputs\n                 }\n                 _ => ccx.sess().bug(\"expected tuple'd inputs\")\n             }\n         }\n-        _ => fn_sig.0.inputs.clone()\n+        _ => fn_sig.inputs.clone()\n     };\n \n     if let ty::FnConverging(ret_ty) = ret_ty {"}, {"sha": "b7b486f1d0a52239b329a29560259afd30f818c5", "filename": "src/librustc_trans/trans/callee.rs", "status": "modified", "additions": 26, "deletions": 20, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/0b3b95755436da9f0fc78bd00f780c32bab92f7d/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b3b95755436da9f0fc78bd00f780c32bab92f7d/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs?ref=0b3b95755436da9f0fc78bd00f780c32bab92f7d", "patch": "@@ -265,7 +265,7 @@ pub fn trans_fn_pointer_shim<'a, 'tcx>(\n     let _icx = push_ctxt(\"trans_fn_pointer_shim\");\n     let tcx = ccx.tcx();\n \n-    let bare_fn_ty = ty::normalize_ty(tcx, bare_fn_ty);\n+    let bare_fn_ty = normalize_ty(tcx, bare_fn_ty);\n     match ccx.fn_pointer_shims().borrow().get(&bare_fn_ty) {\n         Some(&llval) => { return llval; }\n         None => { }\n@@ -279,24 +279,22 @@ pub fn trans_fn_pointer_shim<'a, 'tcx>(\n \n     // Construct the \"tuply\" version of `bare_fn_ty`. It takes two arguments: `self`,\n     // which is the fn pointer, and `args`, which is the arguments tuple.\n-    let (opt_def_id, input_tys, output_ty) =\n+    let (opt_def_id, sig) =\n         match bare_fn_ty.sty {\n             ty::ty_bare_fn(opt_def_id,\n                            &ty::BareFnTy { unsafety: ast::Unsafety::Normal,\n-                                          abi: synabi::Rust,\n-                                          sig: ty::Binder(ty::FnSig { inputs: ref input_tys,\n-                                                                      output: output_ty,\n-                                                                      variadic: false })}) =>\n-            {\n-                (opt_def_id, input_tys, output_ty)\n+                                           abi: synabi::Rust,\n+                                           ref sig }) => {\n+                (opt_def_id, sig)\n             }\n \n             _ => {\n                 tcx.sess.bug(format!(\"trans_fn_pointer_shim invoked on invalid type: {}\",\n                                            bare_fn_ty.repr(tcx)).index(&FullRange));\n             }\n         };\n-    let tuple_input_ty = ty::mk_tup(tcx, input_tys.to_vec());\n+    let sig = ty::erase_late_bound_regions(tcx, sig);\n+    let tuple_input_ty = ty::mk_tup(tcx, sig.inputs.to_vec());\n     let tuple_fn_ty = ty::mk_bare_fn(tcx,\n                                      opt_def_id,\n                                      tcx.mk_bare_fn(ty::BareFnTy {\n@@ -305,7 +303,7 @@ pub fn trans_fn_pointer_shim<'a, 'tcx>(\n                                          sig: ty::Binder(ty::FnSig {\n                                              inputs: vec![bare_fn_ty_ref,\n                                                           tuple_input_ty],\n-                                             output: output_ty,\n+                                             output: sig.output,\n                                              variadic: false\n                                          })}));\n     debug!(\"tuple_fn_ty: {}\", tuple_fn_ty.repr(tcx));\n@@ -326,26 +324,26 @@ pub fn trans_fn_pointer_shim<'a, 'tcx>(\n                           llfn,\n                           ast::DUMMY_NODE_ID,\n                           false,\n-                          output_ty,\n+                          sig.output,\n                           &empty_substs,\n                           None,\n                           &block_arena);\n-    let mut bcx = init_function(&fcx, false, output_ty);\n+    let mut bcx = init_function(&fcx, false, sig.output);\n \n     // the first argument (`self`) will be ptr to the the fn pointer\n     let llfnpointer =\n         Load(bcx, get_param(fcx.llfn, fcx.arg_pos(0) as u32));\n \n     // the remaining arguments will be the untupled values\n     let llargs: Vec<_> =\n-        input_tys.iter()\n+        sig.inputs.iter()\n         .enumerate()\n         .map(|(i, _)| get_param(fcx.llfn, fcx.arg_pos(i+1) as u32))\n         .collect();\n     assert!(!fcx.needs_ret_allocas);\n \n     let dest = fcx.llretslotptr.get().map(|_|\n-        expr::SaveIn(fcx.get_ret_slot(bcx, output_ty, \"ret_slot\"))\n+        expr::SaveIn(fcx.get_ret_slot(bcx, sig.output, \"ret_slot\"))\n     );\n \n     bcx = trans_call_inner(bcx,\n@@ -355,7 +353,7 @@ pub fn trans_fn_pointer_shim<'a, 'tcx>(\n                            ArgVals(llargs.index(&FullRange)),\n                            dest).bcx;\n \n-    finish_fn(&fcx, bcx, output_ty);\n+    finish_fn(&fcx, bcx, sig.output);\n \n     ccx.fn_pointer_shims().borrow_mut().insert(bare_fn_ty, llfn);\n \n@@ -668,7 +666,10 @@ pub fn trans_call_inner<'a, 'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n     let mut bcx = callee.bcx;\n \n     let (abi, ret_ty) = match callee_ty.sty {\n-        ty::ty_bare_fn(_, ref f) => (f.abi, f.sig.0.output),\n+        ty::ty_bare_fn(_, ref f) => {\n+            let output = ty::erase_late_bound_regions(bcx.tcx(), &f.sig.output());\n+            (f.abi, output)\n+        }\n         _ => panic!(\"expected bare rust fn or closure in trans_call_inner\")\n     };\n \n@@ -865,13 +866,18 @@ fn trans_args_under_call_abi<'blk, 'tcx>(\n                              llargs: &mut Vec<ValueRef>,\n                              arg_cleanup_scope: cleanup::ScopeId,\n                              ignore_self: bool)\n-                             -> Block<'blk, 'tcx> {\n+                             -> Block<'blk, 'tcx>\n+{\n+    let args =\n+        ty::erase_late_bound_regions(\n+            bcx.tcx(), &ty::ty_fn_args(fn_ty));\n+\n     // Translate the `self` argument first.\n     if !ignore_self {\n         let arg_datum = unpack_datum!(bcx, expr::trans(bcx, &*arg_exprs[0]));\n         llargs.push(unpack_result!(bcx, {\n             trans_arg_datum(bcx,\n-                            ty::ty_fn_args(fn_ty)[0],\n+                            args[0],\n                             arg_datum,\n                             arg_cleanup_scope,\n                             DontAutorefArg)\n@@ -926,7 +932,7 @@ fn trans_overloaded_call_args<'blk, 'tcx>(\n                               ignore_self: bool)\n                               -> Block<'blk, 'tcx> {\n     // Translate the `self` argument first.\n-    let arg_tys = ty::ty_fn_args(fn_ty);\n+    let arg_tys = ty::erase_late_bound_regions(bcx.tcx(),  &ty::ty_fn_args(fn_ty));\n     if !ignore_self {\n         let arg_datum = unpack_datum!(bcx, expr::trans(bcx, arg_exprs[0]));\n         llargs.push(unpack_result!(bcx, {\n@@ -974,7 +980,7 @@ pub fn trans_args<'a, 'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n     debug!(\"trans_args(abi={})\", abi);\n \n     let _icx = push_ctxt(\"trans_args\");\n-    let arg_tys = ty::ty_fn_args(fn_ty);\n+    let arg_tys = ty::erase_late_bound_regions(cx.tcx(), &ty::ty_fn_args(fn_ty));\n     let variadic = ty::fn_is_variadic(fn_ty);\n \n     let mut bcx = cx;"}, {"sha": "ad2ed67b22c9a315bf4ed3be04e80ce014076da3", "filename": "src/librustc_trans/trans/closure.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0b3b95755436da9f0fc78bd00f780c32bab92f7d/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b3b95755436da9f0fc78bd00f780c32bab92f7d/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs?ref=0b3b95755436da9f0fc78bd00f780c32bab92f7d", "patch": "@@ -442,7 +442,7 @@ pub fn trans_expr_fn<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                   bcx.fcx.param_substs,\n                   id,\n                   &[],\n-                  ty::ty_fn_ret(fty),\n+                  ty::erase_late_bound_regions(ccx.tcx(), &ty::ty_fn_ret(fty)),\n                   ty::ty_fn_abi(fty),\n                   ClosureEnv::new(freevars.index(&FullRange),\n                                   BoxedClosure(cdata_ty, store)));\n@@ -466,7 +466,7 @@ pub fn get_or_create_declaration_if_unboxed_closure<'a, 'tcx>(ccx: &CrateContext\n \n     // Normalize type so differences in regions and typedefs don't cause\n     // duplicate declarations\n-    let function_type = ty::normalize_ty(ccx.tcx(), function_type);\n+    let function_type = normalize_ty(ccx.tcx(), function_type);\n     let params = match function_type.sty {\n         ty::ty_unboxed_closure(_, _, ref substs) => substs.types.clone(),\n         _ => unreachable!()\n@@ -533,14 +533,16 @@ pub fn trans_unboxed_closure<'blk, 'tcx>(\n         ty::with_freevars(bcx.tcx(), id, |fv| fv.iter().map(|&fv| fv).collect());\n     let freevar_mode = bcx.tcx().capture_mode(id);\n \n+    let sig = ty::erase_late_bound_regions(bcx.tcx(), &function_type.sig);\n+\n     trans_closure(bcx.ccx(),\n                   decl,\n                   body,\n                   llfn.val,\n                   bcx.fcx.param_substs,\n                   id,\n                   &[],\n-                  function_type.sig.0.output,\n+                  sig.output,\n                   function_type.abi,\n                   ClosureEnv::new(freevars.index(&FullRange),\n                                   UnboxedClosure(freevar_mode)));"}, {"sha": "237fc1856369b7306e025ce9a89ff83075918542", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/0b3b95755436da9f0fc78bd00f780c32bab92f7d/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b3b95755436da9f0fc78bd00f780c32bab92f7d/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=0b3b95755436da9f0fc78bd00f780c32bab92f7d", "patch": "@@ -58,6 +58,61 @@ use util::nodemap::FnvHashSet;\n \n pub use trans::context::CrateContext;\n \n+/// Returns an equivalent type with all the typedefs and self regions removed.\n+pub fn normalize_ty<'tcx>(cx: &ty::ctxt<'tcx>, ty: Ty<'tcx>) -> Ty<'tcx> {\n+    let u = TypeNormalizer(cx).fold_ty(ty);\n+    debug!(\"normalize_ty({}) = {}\",\n+           ty.repr(cx), u.repr(cx));\n+    return u;\n+\n+    struct TypeNormalizer<'a, 'tcx: 'a>(&'a ty::ctxt<'tcx>);\n+\n+    impl<'a, 'tcx> TypeFolder<'tcx> for TypeNormalizer<'a, 'tcx> {\n+        fn tcx(&self) -> &ty::ctxt<'tcx> { self.0 }\n+\n+        fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n+            match self.tcx().normalized_cache.borrow().get(&ty).cloned() {\n+                None => {}\n+                Some(u) => return u\n+            }\n+\n+            let t_norm = ty_fold::super_fold_ty(self, ty);\n+            self.tcx().normalized_cache.borrow_mut().insert(ty, t_norm);\n+            return t_norm;\n+        }\n+\n+        fn fold_binder<T>(&mut self, t: &ty::Binder<T>) -> ty::Binder<T>\n+            where T : TypeFoldable<'tcx> + Repr<'tcx>\n+        {\n+            // FIXME(#20526) this should replace `enter_region_binder`/`exit_region_binder`.\n+            let u = ty::anonymize_late_bound_regions(self.tcx(), t);\n+            ty_fold::super_fold_binder(self, &u)\n+        }\n+\n+        fn fold_region(&mut self, r: ty::Region) -> ty::Region {\n+            // because late-bound regions affect subtyping, we can't\n+            // erase the bound/free distinction, but we can replace\n+            // all free regions with 'static.\n+            //\n+            // Note that we *CAN* replace early-bound regions -- the\n+            // type system never \"sees\" those, they get substituted\n+            // away. In trans, they will always be erased to 'static\n+            // whenever a substitution occurs.\n+            match r {\n+                ty::ReLateBound(..) => r,\n+                _ => ty::ReStatic\n+            }\n+        }\n+\n+        fn fold_substs(&mut self,\n+                       substs: &subst::Substs<'tcx>)\n+                       -> subst::Substs<'tcx> {\n+            subst::Substs { regions: subst::ErasedRegions,\n+                            types: substs.types.fold_with(self) }\n+        }\n+    }\n+}\n+\n // Is the type's representation size known at compile time?\n pub fn type_is_sized<'tcx>(cx: &ty::ctxt<'tcx>, ty: Ty<'tcx>) -> bool {\n ty::type_contents(cx, ty).is_sized(cx)"}, {"sha": "38d40a8322f900ae728f9ebe899d08b310f63fe8", "filename": "src/librustc_trans/trans/controlflow.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0b3b95755436da9f0fc78bd00f780c32bab92f7d/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b3b95755436da9f0fc78bd00f780c32bab92f7d/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs?ref=0b3b95755436da9f0fc78bd00f780c32bab92f7d", "patch": "@@ -265,7 +265,8 @@ pub fn trans_for<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                              pat: &ast::Pat,\n                              head: &ast::Expr,\n                              body: &ast::Block)\n-                             -> Block<'blk, 'tcx> {\n+                             -> Block<'blk, 'tcx>\n+{\n     let _icx = push_ctxt(\"trans_for\");\n \n     //            bcx\n@@ -306,7 +307,9 @@ pub fn trans_for<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                                      .borrow())[method_call]\n                                      .ty;\n     let method_type = monomorphize_type(loopback_bcx_in, method_type);\n-    let method_result_type = ty::ty_fn_ret(method_type).unwrap();\n+    let method_result_type =\n+        ty::assert_no_late_bound_regions( // LB regions are instantiated in invoked methods\n+            loopback_bcx_in.tcx(), &ty::ty_fn_ret(method_type)).unwrap();\n     let option_cleanup_scope = body_bcx_in.fcx.push_custom_cleanup_scope();\n     let option_cleanup_scope_id = cleanup::CustomScope(option_cleanup_scope);\n "}, {"sha": "e2e1b3a799bfc82f0cbce46786b8dec5171291c7", "filename": "src/librustc_trans/trans/debuginfo.rs", "status": "modified", "additions": 32, "deletions": 19, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/0b3b95755436da9f0fc78bd00f780c32bab92f7d/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b3b95755436da9f0fc78bd00f780c32bab92f7d/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs?ref=0b3b95755436da9f0fc78bd00f780c32bab92f7d", "patch": "@@ -425,10 +425,14 @@ impl<'tcx> TypeMap<'tcx> {\n             ty::ty_trait(ref trait_data) => {\n                 unique_type_id.push_str(\"trait \");\n \n+                let principal =\n+                    ty::erase_late_bound_regions(cx.tcx(),\n+                                                 &trait_data.principal);\n+\n                 from_def_id_and_substs(self,\n                                        cx,\n-                                       trait_data.principal_def_id(),\n-                                       trait_data.principal.0.substs,\n+                                       principal.def_id,\n+                                       principal.substs,\n                                        &mut unique_type_id);\n             },\n             ty::ty_bare_fn(_, &ty::BareFnTy{ unsafety, abi, ref sig } ) => {\n@@ -440,7 +444,9 @@ impl<'tcx> TypeMap<'tcx> {\n \n                 unique_type_id.push_str(\" fn(\");\n \n-                for &parameter_type in sig.0.inputs.iter() {\n+                let sig = ty::erase_late_bound_regions(cx.tcx(), sig);\n+\n+                for &parameter_type in sig.inputs.iter() {\n                     let parameter_type_id =\n                         self.get_unique_type_id_of_type(cx, parameter_type);\n                     let parameter_type_id =\n@@ -449,12 +455,12 @@ impl<'tcx> TypeMap<'tcx> {\n                     unique_type_id.push(',');\n                 }\n \n-                if sig.0.variadic {\n+                if sig.variadic {\n                     unique_type_id.push_str(\"...\");\n                 }\n \n                 unique_type_id.push_str(\")->\");\n-                match sig.0.output {\n+                match sig.output {\n                     ty::FnConverging(ret_ty) => {\n                         let return_type_id = self.get_unique_type_id_of_type(cx, ret_ty);\n                         let return_type_id = self.get_unique_type_id_as_string(return_type_id);\n@@ -568,7 +574,9 @@ impl<'tcx> TypeMap<'tcx> {\n             }\n         };\n \n-        for &parameter_type in sig.0.inputs.iter() {\n+        let sig = ty::erase_late_bound_regions(cx.tcx(), sig);\n+\n+        for &parameter_type in sig.inputs.iter() {\n             let parameter_type_id =\n                 self.get_unique_type_id_of_type(cx, parameter_type);\n             let parameter_type_id =\n@@ -577,13 +585,13 @@ impl<'tcx> TypeMap<'tcx> {\n             unique_type_id.push(',');\n         }\n \n-        if sig.0.variadic {\n+        if sig.variadic {\n             unique_type_id.push_str(\"...\");\n         }\n \n         unique_type_id.push_str(\"|->\");\n \n-        match sig.0.output {\n+        match sig.output {\n             ty::FnConverging(ret_ty) => {\n                 let return_type_id = self.get_unique_type_id_of_type(cx, ret_ty);\n                 let return_type_id = self.get_unique_type_id_as_string(return_type_id);\n@@ -2822,11 +2830,14 @@ fn subroutine_type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                       unique_type_id: UniqueTypeId,\n                                       signature: &ty::PolyFnSig<'tcx>,\n                                       span: Span)\n-                                      -> MetadataCreationResult {\n-    let mut signature_metadata: Vec<DIType> = Vec::with_capacity(signature.0.inputs.len() + 1);\n+                                      -> MetadataCreationResult\n+{\n+    let signature = ty::erase_late_bound_regions(cx.tcx(), signature);\n+\n+    let mut signature_metadata: Vec<DIType> = Vec::with_capacity(signature.inputs.len() + 1);\n \n     // return type\n-    signature_metadata.push(match signature.0.output {\n+    signature_metadata.push(match signature.output {\n         ty::FnConverging(ret_ty) => match ret_ty.sty {\n             ty::ty_tup(ref tys) if tys.is_empty() => ptr::null_mut(),\n             _ => type_metadata(cx, ret_ty, span)\n@@ -2835,7 +2846,7 @@ fn subroutine_type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     });\n \n     // regular arguments\n-    for &argument_type in signature.0.inputs.iter() {\n+    for &argument_type in signature.inputs.iter() {\n         signature_metadata.push(type_metadata(cx, argument_type, span));\n     }\n \n@@ -3794,8 +3805,9 @@ fn push_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             output.push(']');\n         },\n         ty::ty_trait(ref trait_data) => {\n-            push_item_name(cx, trait_data.principal_def_id(), false, output);\n-            push_type_params(cx, trait_data.principal.0.substs, output);\n+            let principal = ty::erase_late_bound_regions(cx.tcx(), &trait_data.principal);\n+            push_item_name(cx, principal.def_id, false, output);\n+            push_type_params(cx, principal.substs, output);\n         },\n         ty::ty_bare_fn(_, &ty::BareFnTy{ unsafety, abi, ref sig } ) => {\n             if unsafety == ast::Unsafety::Unsafe {\n@@ -3810,17 +3822,18 @@ fn push_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n             output.push_str(\"fn(\");\n \n-            if sig.0.inputs.len() > 0 {\n-                for &parameter_type in sig.0.inputs.iter() {\n+            let sig = ty::erase_late_bound_regions(cx.tcx(), sig);\n+            if sig.inputs.len() > 0 {\n+                for &parameter_type in sig.inputs.iter() {\n                     push_debuginfo_type_name(cx, parameter_type, true, output);\n                     output.push_str(\", \");\n                 }\n                 output.pop();\n                 output.pop();\n             }\n \n-            if sig.0.variadic {\n-                if sig.0.inputs.len() > 0 {\n+            if sig.variadic {\n+                if sig.inputs.len() > 0 {\n                     output.push_str(\", ...\");\n                 } else {\n                     output.push_str(\"...\");\n@@ -3829,7 +3842,7 @@ fn push_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n             output.push(')');\n \n-            match sig.0.output {\n+            match sig.output {\n                 ty::FnConverging(result_type) if ty::type_is_nil(result_type) => {}\n                 ty::FnConverging(result_type) => {\n                     output.push_str(\" -> \");"}, {"sha": "120e2e955e4be5a000fa94542139935c762433ce", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0b3b95755436da9f0fc78bd00f780c32bab92f7d/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b3b95755436da9f0fc78bd00f780c32bab92f7d/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=0b3b95755436da9f0fc78bd00f780c32bab92f7d", "patch": "@@ -699,12 +699,16 @@ fn trans_index<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                        .map(|method| method.ty);\n     let elt_datum = match method_ty {\n         Some(method_ty) => {\n+            let method_ty = monomorphize_type(bcx, method_ty);\n+\n             let base_datum = unpack_datum!(bcx, trans(bcx, base));\n \n             // Translate index expression.\n             let ix_datum = unpack_datum!(bcx, trans(bcx, idx));\n \n-            let ref_ty = ty::ty_fn_ret(monomorphize_type(bcx, method_ty)).unwrap();\n+            let ref_ty = // invoked methods have LB regions instantiated:\n+                ty::assert_no_late_bound_regions(\n+                    bcx.tcx(), &ty::ty_fn_ret(method_ty)).unwrap();\n             let elt_ty = match ty::deref(ref_ty, true) {\n                 None => {\n                     bcx.tcx().sess.span_bug(index_expr.span,\n@@ -2149,6 +2153,8 @@ fn deref_once<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                        .get(&method_call).map(|method| method.ty);\n     let datum = match method_ty {\n         Some(method_ty) => {\n+            let method_ty = monomorphize_type(bcx, method_ty);\n+\n             // Overloaded. Evaluate `trans_overloaded_op`, which will\n             // invoke the user's deref() method, which basically\n             // converts from the `Smaht<T>` pointer that we have into\n@@ -2160,7 +2166,9 @@ fn deref_once<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 _ => datum\n             };\n \n-            let ref_ty = ty::ty_fn_ret(monomorphize_type(bcx, method_ty)).unwrap();\n+            let ref_ty = // invoked methods have their LB regions instantiated\n+                ty::assert_no_late_bound_regions(\n+                    ccx.tcx(), &ty::ty_fn_ret(method_ty)).unwrap();\n             let scratch = rvalue_scratch_datum(bcx, ref_ty, \"overloaded_deref\");\n \n             unpack_result!(bcx, trans_overloaded_op(bcx, expr, method_call,"}, {"sha": "25eb66ab2eb7311c3abf70880a0e00470b955ee2", "filename": "src/librustc_trans/trans/foreign.rs", "status": "modified", "additions": 18, "deletions": 14, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/0b3b95755436da9f0fc78bd00f780c32bab92f7d/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b3b95755436da9f0fc78bd00f780c32bab92f7d/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs?ref=0b3b95755436da9f0fc78bd00f780c32bab92f7d", "patch": "@@ -43,7 +43,7 @@ use util::ppaux::Repr;\n \n struct ForeignTypes<'tcx> {\n     /// Rust signature of the function\n-    fn_sig: ty::PolyFnSig<'tcx>,\n+    fn_sig: ty::FnSig<'tcx>,\n \n     /// Adapter object for handling native ABI rules (trust me, you\n     /// don't want to know)\n@@ -180,7 +180,7 @@ pub fn register_foreign_item_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n     // Make sure the calling convention is right for variadic functions\n     // (should've been caught if not in typeck)\n-    if tys.fn_sig.0.variadic {\n+    if tys.fn_sig.variadic {\n         assert!(cc == llvm::CCallConv);\n     }\n \n@@ -218,7 +218,8 @@ pub fn trans_native_call<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                      llretptr: ValueRef,\n                                      llargs_rust: &[ValueRef],\n                                      passed_arg_tys: Vec<Ty<'tcx>>)\n-                                     -> Block<'blk, 'tcx> {\n+                                     -> Block<'blk, 'tcx>\n+{\n     let ccx = bcx.ccx();\n     let tcx = bcx.tcx();\n \n@@ -230,9 +231,10 @@ pub fn trans_native_call<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n            ccx.tn().val_to_string(llretptr));\n \n     let (fn_abi, fn_sig) = match callee_ty.sty {\n-        ty::ty_bare_fn(_, ref fn_ty) => (fn_ty.abi, fn_ty.sig.clone()),\n+        ty::ty_bare_fn(_, ref fn_ty) => (fn_ty.abi, &fn_ty.sig),\n         _ => ccx.sess().bug(\"trans_native_call called on non-function type\")\n     };\n+    let fn_sig = ty::erase_late_bound_regions(ccx.tcx(), fn_sig);\n     let llsig = foreign_signature(ccx, &fn_sig, passed_arg_tys.index(&FullRange));\n     let fn_type = cabi::compute_abi_info(ccx,\n                                          llsig.llarg_tys.index(&FullRange),\n@@ -387,7 +389,7 @@ pub fn trans_native_call<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         debug!(\"llforeign_ret_ty={}\", ccx.tn().type_to_string(llforeign_ret_ty));\n \n         if llrust_ret_ty == llforeign_ret_ty {\n-            match fn_sig.0.output {\n+            match fn_sig.output {\n                 ty::FnConverging(result_ty) => {\n                     base::store_ty(bcx, llforeign_retval, llretptr, result_ty)\n                 }\n@@ -635,7 +637,7 @@ pub fn trans_rust_fn_with_foreign_abi<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         };\n \n         // Push Rust return pointer, using null if it will be unused.\n-        let rust_uses_outptr = match tys.fn_sig.0.output {\n+        let rust_uses_outptr = match tys.fn_sig.output {\n             ty::FnConverging(ret_ty) => type_of::return_uses_outptr(ccx, ret_ty),\n             ty::FnDiverging => false\n         };\n@@ -668,7 +670,7 @@ pub fn trans_rust_fn_with_foreign_abi<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                             return_ty={}\",\n                            ccx.tn().val_to_string(slot),\n                            ccx.tn().type_to_string(llrust_ret_ty),\n-                           tys.fn_sig.0.output.repr(tcx));\n+                           tys.fn_sig.output.repr(tcx));\n                     llrust_args.push(slot);\n                     return_alloca = Some(slot);\n                 }\n@@ -683,8 +685,8 @@ pub fn trans_rust_fn_with_foreign_abi<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         // Build up the arguments to the call to the rust function.\n         // Careful to adapt for cases where the native convention uses\n         // a pointer and Rust does not or vice versa.\n-        for i in range(0, tys.fn_sig.0.inputs.len()) {\n-            let rust_ty = tys.fn_sig.0.inputs[i];\n+        for i in range(0, tys.fn_sig.inputs.len()) {\n+            let rust_ty = tys.fn_sig.inputs[i];\n             let llrust_ty = tys.llsig.llarg_tys[i];\n             let rust_indirect = type_of::arg_is_indirect(ccx, rust_ty);\n             let llforeign_arg_ty = tys.fn_ty.arg_tys[i];\n@@ -829,10 +831,11 @@ pub fn link_name(i: &ast::ForeignItem) -> InternedString {\n /// because foreign functions just plain ignore modes. They also don't pass aggregate values by\n /// pointer like we do.\n fn foreign_signature<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                               fn_sig: &ty::PolyFnSig<'tcx>, arg_tys: &[Ty<'tcx>])\n+                               fn_sig: &ty::FnSig<'tcx>,\n+                               arg_tys: &[Ty<'tcx>])\n                                -> LlvmSignature {\n     let llarg_tys = arg_tys.iter().map(|&arg| arg_type_of(ccx, arg)).collect();\n-    let (llret_ty, ret_def) = match fn_sig.0.output {\n+    let (llret_ty, ret_def) = match fn_sig.output {\n         ty::FnConverging(ret_ty) =>\n             (type_of::arg_type_of(ccx, ret_ty), !return_type_is_void(ccx, ret_ty)),\n         ty::FnDiverging =>\n@@ -853,10 +856,11 @@ fn foreign_types_for_id<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n fn foreign_types_for_fn_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                      ty: Ty<'tcx>) -> ForeignTypes<'tcx> {\n     let fn_sig = match ty.sty {\n-        ty::ty_bare_fn(_, ref fn_ty) => fn_ty.sig.clone(),\n+        ty::ty_bare_fn(_, ref fn_ty) => &fn_ty.sig,\n         _ => ccx.sess().bug(\"foreign_types_for_fn_ty called on non-function type\")\n     };\n-    let llsig = foreign_signature(ccx, &fn_sig, fn_sig.0.inputs.as_slice());\n+    let fn_sig = ty::erase_late_bound_regions(ccx.tcx(), fn_sig);\n+    let llsig = foreign_signature(ccx, &fn_sig, fn_sig.inputs.as_slice());\n     let fn_ty = cabi::compute_abi_info(ccx,\n                                        llsig.llarg_tys.index(&FullRange),\n                                        llsig.llret_ty,\n@@ -916,7 +920,7 @@ fn lltype_for_fn_from_foreign_types(ccx: &CrateContext, tys: &ForeignTypes) -> T\n         llargument_tys.push(llarg_ty);\n     }\n \n-    if tys.fn_sig.0.variadic {\n+    if tys.fn_sig.variadic {\n         Type::variadic_func(llargument_tys.as_slice(), &llreturn_ty)\n     } else {\n         Type::func(llargument_tys.index(&FullRange), &llreturn_ty)"}, {"sha": "52e7a986d7e988a17222cecbad342ef59fe928c8", "filename": "src/librustc_trans/trans/glue.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0b3b95755436da9f0fc78bd00f780c32bab92f7d/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b3b95755436da9f0fc78bd00f780c32bab92f7d/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fglue.rs?ref=0b3b95755436da9f0fc78bd00f780c32bab92f7d", "patch": "@@ -212,7 +212,8 @@ fn trans_struct_drop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                  dtor_did: ast::DefId,\n                                  class_did: ast::DefId,\n                                  substs: &subst::Substs<'tcx>)\n-                                 -> Block<'blk, 'tcx> {\n+                                 -> Block<'blk, 'tcx>\n+{\n     let repr = adt::represent_type(bcx.ccx(), t);\n \n     // Find and call the actual destructor\n@@ -228,8 +229,9 @@ fn trans_struct_drop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let fty = ty::lookup_item_type(bcx.tcx(), dtor_did).ty.subst(bcx.tcx(), substs);\n     let self_ty = match fty.sty {\n         ty::ty_bare_fn(_, ref f) => {\n-            assert!(f.sig.0.inputs.len() == 1);\n-            f.sig.0.inputs[0]\n+            let sig = ty::erase_late_bound_regions(bcx.tcx(), &f.sig);\n+            assert!(sig.inputs.len() == 1);\n+            sig.inputs[0]\n         }\n         _ => bcx.sess().bug(format!(\"Expected function type, found {}\",\n                                     bcx.ty_to_string(fty)).index(&FullRange))"}, {"sha": "ed75445b9939be9b1266334364a9e229c827e244", "filename": "src/librustc_trans/trans/intrinsic.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0b3b95755436da9f0fc78bd00f780c32bab92f7d/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b3b95755436da9f0fc78bd00f780c32bab92f7d/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs?ref=0b3b95755436da9f0fc78bd00f780c32bab92f7d", "patch": "@@ -150,14 +150,16 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                                             dest: expr::Dest,\n                                             substs: subst::Substs<'tcx>,\n                                             call_info: NodeInfo)\n-                                            -> Result<'blk, 'tcx> {\n-\n+                                            -> Result<'blk, 'tcx>\n+{\n     let fcx = bcx.fcx;\n     let ccx = fcx.ccx;\n     let tcx = bcx.tcx();\n \n     let ret_ty = match callee_ty.sty {\n-        ty::ty_bare_fn(_, ref f) => f.sig.0.output,\n+        ty::ty_bare_fn(_, ref f) => {\n+            ty::erase_late_bound_regions(bcx.tcx(), &f.sig.output())\n+        }\n         _ => panic!(\"expected bare_fn in trans_intrinsic_call\")\n     };\n     let foreign_item = tcx.map.expect_foreign_item(node);"}, {"sha": "c618889f3f5dca438b951f744f003219d0200426", "filename": "src/librustc_trans/trans/meth.rs", "status": "modified", "additions": 22, "deletions": 10, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/0b3b95755436da9f0fc78bd00f780c32bab92f7d/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b3b95755436da9f0fc78bd00f780c32bab92f7d/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs?ref=0b3b95755436da9f0fc78bd00f780c32bab92f7d", "patch": "@@ -477,13 +477,19 @@ pub fn trans_trait_callee_from_llval<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     // Load the function from the vtable and cast it to the expected type.\n     debug!(\"(translating trait callee) loading method\");\n+\n     // Replace the self type (&Self or Box<Self>) with an opaque pointer.\n     let llcallee_ty = match callee_ty.sty {\n         ty::ty_bare_fn(_, ref f) if f.abi == Rust || f.abi == RustCall => {\n+            let fake_sig =\n+                ty::Binder(ty::FnSig {\n+                    inputs: f.sig.0.inputs.slice_from(1).to_vec(),\n+                    output: f.sig.0.output,\n+                    variadic: f.sig.0.variadic,\n+                });\n             type_of_rust_fn(ccx,\n                             Some(Type::i8p(ccx)),\n-                            f.sig.0.inputs.slice_from(1),\n-                            f.sig.0.output,\n+                            &fake_sig,\n                             f.abi)\n         }\n         _ => {\n@@ -557,7 +563,8 @@ pub fn trans_object_shim<'a, 'tcx>(\n \n     // Upcast to the trait in question and extract out the substitutions.\n     let upcast_trait_ref = traits::upcast(ccx.tcx(), object_trait_ref.clone(), trait_id).unwrap();\n-    let object_substs = upcast_trait_ref.substs().clone().erase_regions();\n+    let upcast_trait_ref = ty::erase_late_bound_regions(tcx, &upcast_trait_ref);\n+    let object_substs = upcast_trait_ref.substs.clone().erase_regions();\n     debug!(\"trans_object_shim: object_substs={}\", object_substs.repr(tcx));\n \n     // Lookup the type of this method as deeclared in the trait and apply substitutions.\n@@ -579,18 +586,20 @@ pub fn trans_object_shim<'a, 'tcx>(\n     let llfn =\n         decl_internal_rust_fn(ccx, method_bare_fn_ty, function_name.as_slice());\n \n+    let sig = ty::erase_late_bound_regions(ccx.tcx(), &fty.sig);\n+\n     //\n     let block_arena = TypedArena::new();\n     let empty_substs = Substs::trans_empty();\n     let fcx = new_fn_ctxt(ccx,\n                           llfn,\n                           ast::DUMMY_NODE_ID,\n                           false,\n-                          fty.sig.0.output,\n+                          sig.output,\n                           &empty_substs,\n                           None,\n                           &block_arena);\n-    let mut bcx = init_function(&fcx, false, fty.sig.0.output);\n+    let mut bcx = init_function(&fcx, false, sig.output);\n \n     // the first argument (`self`) will be a trait object\n     let llobject = get_param(fcx.llfn, fcx.arg_pos(0) as u32);\n@@ -603,18 +612,18 @@ pub fn trans_object_shim<'a, 'tcx>(\n         match fty.abi {\n             RustCall => {\n                 // unpack the tuple to extract the input type arguments:\n-                match fty.sig.0.inputs[1].sty {\n+                match sig.inputs[1].sty {\n                     ty::ty_tup(ref tys) => tys.as_slice(),\n                     _ => {\n                         bcx.sess().bug(\n                             format!(\"rust-call expects a tuple not {}\",\n-                                    fty.sig.0.inputs[1].repr(tcx)).as_slice());\n+                                    sig.inputs[1].repr(tcx)).as_slice());\n                     }\n                 }\n             }\n             _ => {\n                 // skip the self parameter:\n-                fty.sig.0.inputs.slice_from(1)\n+                sig.inputs.slice_from(1)\n             }\n         };\n \n@@ -631,9 +640,12 @@ pub fn trans_object_shim<'a, 'tcx>(\n \n     assert!(!fcx.needs_ret_allocas);\n \n+    let sig =\n+        ty::erase_late_bound_regions(bcx.tcx(), &fty.sig);\n+\n     let dest =\n         fcx.llretslotptr.get().map(\n-            |_| expr::SaveIn(fcx.get_ret_slot(bcx, fty.sig.0.output, \"ret_slot\")));\n+            |_| expr::SaveIn(fcx.get_ret_slot(bcx, sig.output, \"ret_slot\")));\n \n     let method_offset_in_vtable =\n         traits::get_vtable_index_of_object_method(bcx.tcx(),\n@@ -653,7 +665,7 @@ pub fn trans_object_shim<'a, 'tcx>(\n                            ArgVals(llargs.as_slice()),\n                            dest).bcx;\n \n-    finish_fn(&fcx, bcx, fty.sig.0.output);\n+    finish_fn(&fcx, bcx, sig.output);\n \n     llfn\n }"}, {"sha": "19d50cdd48320ab0b3c4d75967ad62bfa22d2051", "filename": "src/librustc_trans/trans/type_of.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/0b3b95755436da9f0fc78bd00f780c32bab92f7d/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b3b95755436da9f0fc78bd00f780c32bab92f7d/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs?ref=0b3b95755436da9f0fc78bd00f780c32bab92f7d", "patch": "@@ -17,7 +17,7 @@ use trans::adt;\n use trans::common::*;\n use trans::foreign;\n use trans::machine;\n-use middle::ty::{self, Ty};\n+use middle::ty::{self, RegionEscape, Ty};\n use util::ppaux;\n use util::ppaux::Repr;\n \n@@ -99,18 +99,21 @@ pub fn untuple_arguments_if_necessary<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n pub fn type_of_rust_fn<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                  llenvironment_type: Option<Type>,\n-                                 inputs: &[Ty<'tcx>],\n-                                 output: ty::FnOutput<'tcx>,\n+                                 sig: &ty::Binder<ty::FnSig<'tcx>>,\n                                  abi: abi::Abi)\n-                                 -> Type {\n+                                 -> Type\n+{\n+    let sig = ty::erase_late_bound_regions(cx.tcx(), sig);\n+    assert!(!sig.variadic); // rust fns are never variadic\n+\n     let mut atys: Vec<Type> = Vec::new();\n \n     // First, munge the inputs, if this has the `rust-call` ABI.\n-    let inputs = untuple_arguments_if_necessary(cx, inputs, abi);\n+    let inputs = untuple_arguments_if_necessary(cx, sig.inputs.as_slice(), abi);\n \n     // Arg 0: Output pointer.\n     // (if the output type is non-immediate)\n-    let lloutputtype = match output {\n+    let lloutputtype = match sig.output {\n         ty::FnConverging(output) => {\n             let use_out_pointer = return_uses_outptr(cx, output);\n             let lloutputtype = arg_type_of(cx, output);\n@@ -147,11 +150,7 @@ pub fn type_of_fn_from_ty<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, fty: Ty<'tcx>)\n             // FIXME(#19925) once fn item types are\n             // zero-sized, we'll need to do something here\n             if f.abi == abi::Rust || f.abi == abi::RustCall {\n-                type_of_rust_fn(cx,\n-                                None,\n-                                f.sig.0.inputs.as_slice(),\n-                                f.sig.0.output,\n-                                f.abi)\n+                type_of_rust_fn(cx, None, &f.sig, f.abi)\n             } else {\n                 foreign::lltype_for_foreign_fn(cx, fty)\n             }\n@@ -279,12 +278,14 @@ pub fn type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Type {\n \n     debug!(\"type_of {} {:?}\", t.repr(cx.tcx()), t.sty);\n \n+    assert!(!t.has_escaping_regions());\n+\n     // Replace any typedef'd types with their equivalent non-typedef\n     // type. This ensures that all LLVM nominal types that contain\n     // Rust types are defined as the same LLVM types.  If we don't do\n     // this then, e.g. `Option<{myfield: bool}>` would be a different\n     // type than `Option<myrec>`.\n-    let t_norm = ty::normalize_ty(cx.tcx(), t);\n+    let t_norm = normalize_ty(cx.tcx(), t);\n \n     if t != t_norm {\n         let llty = type_of(cx, t_norm);"}, {"sha": "8cd181c37747d76134932f666b0222bb4a4db16b", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0b3b95755436da9f0fc78bd00f780c32bab92f7d/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b3b95755436da9f0fc78bd00f780c32bab92f7d/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=0b3b95755436da9f0fc78bd00f780c32bab92f7d", "patch": "@@ -505,9 +505,10 @@ pub fn check_pat_enum<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>, pat: &ast::Pat,\n \n     let ctor_scheme = ty::lookup_item_type(tcx, enum_def);\n     let path_scheme = if ty::is_fn_ty(ctor_scheme.ty) {\n+        let fn_ret = ty::assert_no_late_bound_regions(tcx, &ty::ty_fn_ret(ctor_scheme.ty));\n         ty::TypeScheme {\n-            ty: ty::ty_fn_ret(ctor_scheme.ty).unwrap(),\n-            ..ctor_scheme\n+            ty: fn_ret.unwrap(),\n+            generics: ctor_scheme.generics,\n         }\n     } else {\n         ctor_scheme"}, {"sha": "05906c033286547d0bb2fdbbf70ab3c9fe53f7ad", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0b3b95755436da9f0fc78bd00f780c32bab92f7d/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b3b95755436da9f0fc78bd00f780c32bab92f7d/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=0b3b95755436da9f0fc78bd00f780c32bab92f7d", "patch": "@@ -2317,7 +2317,9 @@ fn make_overloaded_lvalue_return_type<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n {\n     match method {\n         Some(method) => {\n-            let ref_ty = ty::ty_fn_ret(method.ty);\n+            let ref_ty = // invoked methods have all LB regions instantiated\n+                ty::assert_no_late_bound_regions(\n+                    fcx.tcx(), &ty::ty_fn_ret(method.ty));\n             match method_call {\n                 Some(method_call) => {\n                     fcx.inh.method_map.borrow_mut().insert(method_call,"}, {"sha": "11ad7bcb0915927e9697eb1dc5156a39ef1b26a9", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0b3b95755436da9f0fc78bd00f780c32bab92f7d/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b3b95755436da9f0fc78bd00f780c32bab92f7d/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=0b3b95755436da9f0fc78bd00f780c32bab92f7d", "patch": "@@ -582,7 +582,9 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n                 Some(method) => {\n                     constrain_call(rcx, expr, Some(&**base),\n                                    None::<ast::Expr>.iter(), true);\n-                    ty::ty_fn_ret(method.ty).unwrap()\n+                    let fn_ret = // late-bound regions in overloaded method calls are instantiated\n+                        ty::assert_no_late_bound_regions(rcx.tcx(), &ty::ty_fn_ret(method.ty));\n+                    fn_ret.unwrap()\n                 }\n                 None => rcx.resolve_node_type(base.id)\n             };"}, {"sha": "84823b0fd57da9c2d4dd7d1f174c61a6793b4adb", "filename": "src/librustc_typeck/check/wf.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0b3b95755436da9f0fc78bd00f780c32bab92f7d/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b3b95755436da9f0fc78bd00f780c32bab92f7d/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs?ref=0b3b95755436da9f0fc78bd00f780c32bab92f7d", "patch": "@@ -449,7 +449,13 @@ fn enum_variants<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             match variant.node.kind {\n                 ast::TupleVariantKind(ref args) if args.len() > 0 => {\n                     let ctor_ty = ty::node_id_to_type(fcx.tcx(), variant.node.id);\n-                    let arg_tys = ty::ty_fn_args(ctor_ty);\n+\n+                    // the regions in the argument types come from the\n+                    // enum def'n, and hence will all be early bound\n+                    let arg_tys =\n+                        ty::assert_no_late_bound_regions(\n+                            fcx.tcx(), &ty::ty_fn_args(ctor_ty));\n+\n                     AdtVariant {\n                         fields: args.iter().enumerate().map(|(index, arg)| {\n                             let arg_ty = arg_tys[index];"}, {"sha": "4a57ed56594b1a04a1b81d73d3e5528f3c16c5f2", "filename": "src/test/run-pass/issue-20644.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/0b3b95755436da9f0fc78bd00f780c32bab92f7d/src%2Ftest%2Frun-pass%2Fissue-20644.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b3b95755436da9f0fc78bd00f780c32bab92f7d/src%2Ftest%2Frun-pass%2Fissue-20644.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-20644.rs?ref=0b3b95755436da9f0fc78bd00f780c32bab92f7d", "patch": "@@ -0,0 +1,35 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// A reduced version of the rustbook ice. The problem this encountered\n+// had to do with trans ignoring binders.\n+\n+#![feature(slicing_syntax)]\n+#![feature(associated_types)]\n+#![feature(macro_rules)]\n+\n+use std::iter;\n+use std::os;\n+use std::io::File;\n+\n+#[allow(unused)]\n+pub fn parse_summary<R: Reader>(_: R, _: &Path) {\n+     let path_from_root = Path::new(\"\");\n+     Path::new(iter::repeat(\"../\")\n+               .take(path_from_root.components().count() - 1)\n+               .collect::<String>());\n+ }\n+\n+fn main() {\n+    let cwd = os::getcwd().unwrap();\n+    let src = cwd.clone();\n+    let summary = File::open(&src.join(\"SUMMARY.md\"));\n+    let _ = parse_summary(summary, &src);\n+}"}]}