{"sha": "dc3eabd48700863075bd986a497fbe4f227aa33b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRjM2VhYmQ0ODcwMDg2MzA3NWJkOTg2YTQ5N2ZiZTRmMjI3YWEzM2I=", "commit": {"author": {"name": "LeSeulArtichaut", "email": "leseulartichaut@gmail.com", "date": "2021-04-03T17:58:46Z"}, "committer": {"name": "LeSeulArtichaut", "email": "leseulartichaut@gmail.com", "date": "2021-05-19T14:03:35Z"}, "message": "Store THIR in `IndexVec`s instead of an `Arena`", "tree": {"sha": "e22ae7664cc500b49027e13737314c8d91f6208d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e22ae7664cc500b49027e13737314c8d91f6208d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dc3eabd48700863075bd986a497fbe4f227aa33b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dc3eabd48700863075bd986a497fbe4f227aa33b", "html_url": "https://github.com/rust-lang/rust/commit/dc3eabd48700863075bd986a497fbe4f227aa33b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dc3eabd48700863075bd986a497fbe4f227aa33b/comments", "author": {"login": "LeSeulArtichaut", "id": 38361244, "node_id": "MDQ6VXNlcjM4MzYxMjQ0", "avatar_url": "https://avatars.githubusercontent.com/u/38361244?v=4", "gravatar_id": "", "url": "https://api.github.com/users/LeSeulArtichaut", "html_url": "https://github.com/LeSeulArtichaut", "followers_url": "https://api.github.com/users/LeSeulArtichaut/followers", "following_url": "https://api.github.com/users/LeSeulArtichaut/following{/other_user}", "gists_url": "https://api.github.com/users/LeSeulArtichaut/gists{/gist_id}", "starred_url": "https://api.github.com/users/LeSeulArtichaut/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/LeSeulArtichaut/subscriptions", "organizations_url": "https://api.github.com/users/LeSeulArtichaut/orgs", "repos_url": "https://api.github.com/users/LeSeulArtichaut/repos", "events_url": "https://api.github.com/users/LeSeulArtichaut/events{/privacy}", "received_events_url": "https://api.github.com/users/LeSeulArtichaut/received_events", "type": "User", "site_admin": false}, "committer": {"login": "LeSeulArtichaut", "id": 38361244, "node_id": "MDQ6VXNlcjM4MzYxMjQ0", "avatar_url": "https://avatars.githubusercontent.com/u/38361244?v=4", "gravatar_id": "", "url": "https://api.github.com/users/LeSeulArtichaut", "html_url": "https://github.com/LeSeulArtichaut", "followers_url": "https://api.github.com/users/LeSeulArtichaut/followers", "following_url": "https://api.github.com/users/LeSeulArtichaut/following{/other_user}", "gists_url": "https://api.github.com/users/LeSeulArtichaut/gists{/gist_id}", "starred_url": "https://api.github.com/users/LeSeulArtichaut/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/LeSeulArtichaut/subscriptions", "organizations_url": "https://api.github.com/users/LeSeulArtichaut/orgs", "repos_url": "https://api.github.com/users/LeSeulArtichaut/repos", "events_url": "https://api.github.com/users/LeSeulArtichaut/events{/privacy}", "received_events_url": "https://api.github.com/users/LeSeulArtichaut/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e78bccfbc01526808c4222ee49c1b6a2f7d8ab5b", "url": "https://api.github.com/repos/rust-lang/rust/commits/e78bccfbc01526808c4222ee49c1b6a2f7d8ab5b", "html_url": "https://github.com/rust-lang/rust/commit/e78bccfbc01526808c4222ee49c1b6a2f7d8ab5b"}], "stats": {"total": 1309, "additions": 681, "deletions": 628}, "files": [{"sha": "a8b6a16ed12f48f42c11320f4a9773ee042295c1", "filename": "compiler/rustc_driver/src/pretty.rs", "status": "modified", "additions": 2, "deletions": 14, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/dc3eabd48700863075bd986a497fbe4f227aa33b/compiler%2Frustc_driver%2Fsrc%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc3eabd48700863075bd986a497fbe4f227aa33b/compiler%2Frustc_driver%2Fsrc%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver%2Fsrc%2Fpretty.rs?ref=dc3eabd48700863075bd986a497fbe4f227aa33b", "patch": "@@ -9,14 +9,12 @@ use rustc_hir_pretty as pprust_hir;\n use rustc_middle::hir::map as hir_map;\n use rustc_middle::ty::{self, TyCtxt};\n use rustc_mir::util::{write_mir_graphviz, write_mir_pretty};\n-use rustc_mir_build::thir;\n use rustc_session::config::{Input, PpAstTreeMode, PpHirMode, PpMode, PpSourceMode};\n use rustc_session::Session;\n use rustc_span::symbol::Ident;\n use rustc_span::FileName;\n \n use std::cell::Cell;\n-use std::fmt::Write;\n use std::path::Path;\n \n pub use self::PpMode::*;\n@@ -491,18 +489,8 @@ fn print_with_analysis(\n         }\n \n         ThirTree => {\n-            let mut out = String::new();\n-            abort_on_err(rustc_typeck::check_crate(tcx), tcx.sess);\n-            debug!(\"pretty printing THIR tree\");\n-            for did in tcx.body_owners() {\n-                let hir = tcx.hir();\n-                let body = hir.body(hir.body_owned_by(hir.local_def_id_to_hir_id(did)));\n-                let arena = thir::Arena::default();\n-                let thir =\n-                    thir::build_thir(tcx, ty::WithOptConstParam::unknown(did), &arena, &body.value);\n-                let _ = writeln!(out, \"{:?}:\\n{:#?}\\n\", did, thir);\n-            }\n-            out\n+            // FIXME(rust-lang/project-thir-unsafeck#8)\n+            todo!()\n         }\n \n         _ => unreachable!(),"}, {"sha": "ea3a5174fd8bbf81da13d10ebf8313fc75f4056c", "filename": "compiler/rustc_mir_build/src/build/block.rs", "status": "modified", "additions": 21, "deletions": 12, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/dc3eabd48700863075bd986a497fbe4f227aa33b/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc3eabd48700863075bd986a497fbe4f227aa33b/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fblock.rs?ref=dc3eabd48700863075bd986a497fbe4f227aa33b", "patch": "@@ -12,18 +12,19 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         &mut self,\n         destination: Place<'tcx>,\n         block: BasicBlock,\n-        ast_block: &Block<'_, 'tcx>,\n+        ast_block: &Block,\n         source_info: SourceInfo,\n     ) -> BlockAnd<()> {\n         let Block {\n             region_scope,\n             opt_destruction_scope,\n             span,\n-            stmts,\n+            ref stmts,\n             expr,\n             targeted_by_break,\n             safety_mode,\n         } = *ast_block;\n+        let expr = expr.map(|expr| &self.thir[expr]);\n         self.in_opt_scope(opt_destruction_scope.map(|de| (de, source_info)), move |this| {\n             this.in_scope((region_scope, source_info), LintLevel::Inherited, move |this| {\n                 if targeted_by_break {\n@@ -32,13 +33,13 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                             destination,\n                             block,\n                             span,\n-                            stmts,\n+                            &stmts,\n                             expr,\n                             safety_mode,\n                         ))\n                     })\n                 } else {\n-                    this.ast_block_stmts(destination, block, span, stmts, expr, safety_mode)\n+                    this.ast_block_stmts(destination, block, span, &stmts, expr, safety_mode)\n                 }\n             })\n         })\n@@ -49,8 +50,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         destination: Place<'tcx>,\n         mut block: BasicBlock,\n         span: Span,\n-        stmts: &[Stmt<'_, 'tcx>],\n-        expr: Option<&Expr<'_, 'tcx>>,\n+        stmts: &[StmtId],\n+        expr: Option<&Expr<'tcx>>,\n         safety_mode: BlockSafety,\n     ) -> BlockAnd<()> {\n         let this = self;\n@@ -78,23 +79,30 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         this.update_source_scope_for_safety_mode(span, safety_mode);\n \n         let source_info = this.source_info(span);\n-        for Stmt { kind, opt_destruction_scope } in stmts {\n+        for stmt in stmts {\n+            let Stmt { ref kind, opt_destruction_scope } = this.thir[*stmt];\n             match kind {\n-                &StmtKind::Expr { scope, expr } => {\n+                StmtKind::Expr { scope, expr } => {\n                     this.block_context.push(BlockFrame::Statement { ignores_expr_result: true });\n                     unpack!(\n                         block = this.in_opt_scope(\n                             opt_destruction_scope.map(|de| (de, source_info)),\n                             |this| {\n-                                let si = (scope, source_info);\n+                                let si = (*scope, source_info);\n                                 this.in_scope(si, LintLevel::Inherited, |this| {\n-                                    this.stmt_expr(block, expr, Some(scope))\n+                                    this.stmt_expr(block, &this.thir[*expr], Some(*scope))\n                                 })\n                             }\n                         )\n                     );\n                 }\n-                StmtKind::Let { remainder_scope, init_scope, pattern, initializer, lint_level } => {\n+                StmtKind::Let {\n+                    remainder_scope,\n+                    init_scope,\n+                    ref pattern,\n+                    initializer,\n+                    lint_level,\n+                } => {\n                     let ignores_expr_result = matches!(*pattern.kind, PatKind::Wild);\n                     this.block_context.push(BlockFrame::Statement { ignores_expr_result });\n \n@@ -110,6 +118,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n                     // Evaluate the initializer, if present.\n                     if let Some(init) = initializer {\n+                        let init = &this.thir[*init];\n                         let initializer_span = init.span;\n \n                         unpack!(\n@@ -145,7 +154,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n                         debug!(\"ast_block_stmts: pattern={:?}\", pattern);\n                         this.visit_primary_bindings(\n-                            &pattern,\n+                            pattern,\n                             UserTypeProjections::none(),\n                             &mut |this, _, _, _, node, span, _, _| {\n                                 this.storage_live_binding(block, node, span, OutsideGuard, true);"}, {"sha": "796a90713ba07effac0d57831cdd1cec1561794e", "filename": "compiler/rustc_mir_build/src/build/expr/as_constant.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dc3eabd48700863075bd986a497fbe4f227aa33b/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_constant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc3eabd48700863075bd986a497fbe4f227aa33b/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_constant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_constant.rs?ref=dc3eabd48700863075bd986a497fbe4f227aa33b", "patch": "@@ -8,11 +8,13 @@ use rustc_middle::ty::CanonicalUserTypeAnnotation;\n impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// Compile `expr`, yielding a compile-time constant. Assumes that\n     /// `expr` is a valid compile-time constant!\n-    crate fn as_constant(&mut self, expr: &Expr<'_, 'tcx>) -> Constant<'tcx> {\n+    crate fn as_constant(&mut self, expr: &Expr<'tcx>) -> Constant<'tcx> {\n         let this = self;\n         let Expr { ty, temp_lifetime: _, span, ref kind } = *expr;\n         match *kind {\n-            ExprKind::Scope { region_scope: _, lint_level: _, value } => this.as_constant(value),\n+            ExprKind::Scope { region_scope: _, lint_level: _, value } => {\n+                this.as_constant(&this.thir[value])\n+            }\n             ExprKind::Literal { literal, user_ty, const_id: _ } => {\n                 let user_ty = user_ty.map(|user_ty| {\n                     this.canonical_user_type_annotations.push(CanonicalUserTypeAnnotation {"}, {"sha": "1c439aad394972ba0f8f1e5c9d038a1c92a389af", "filename": "compiler/rustc_mir_build/src/build/expr/as_operand.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/dc3eabd48700863075bd986a497fbe4f227aa33b/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_operand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc3eabd48700863075bd986a497fbe4f227aa33b/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_operand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_operand.rs?ref=dc3eabd48700863075bd986a497fbe4f227aa33b", "patch": "@@ -17,7 +17,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     crate fn as_local_operand(\n         &mut self,\n         block: BasicBlock,\n-        expr: &Expr<'_, 'tcx>,\n+        expr: &Expr<'tcx>,\n     ) -> BlockAnd<Operand<'tcx>> {\n         let local_scope = self.local_scope();\n         self.as_operand(block, Some(local_scope), expr)\n@@ -74,7 +74,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     crate fn as_local_call_operand(\n         &mut self,\n         block: BasicBlock,\n-        expr: &Expr<'_, 'tcx>,\n+        expr: &Expr<'tcx>,\n     ) -> BlockAnd<Operand<'tcx>> {\n         let local_scope = self.local_scope();\n         self.as_call_operand(block, Some(local_scope), expr)\n@@ -93,16 +93,17 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         &mut self,\n         mut block: BasicBlock,\n         scope: Option<region::Scope>,\n-        expr: &Expr<'_, 'tcx>,\n+        expr: &Expr<'tcx>,\n     ) -> BlockAnd<Operand<'tcx>> {\n         debug!(\"as_operand(block={:?}, expr={:?})\", block, expr);\n         let this = self;\n \n         if let ExprKind::Scope { region_scope, lint_level, value } = expr.kind {\n             let source_info = this.source_info(expr.span);\n             let region_scope = (region_scope, source_info);\n-            return this\n-                .in_scope(region_scope, lint_level, |this| this.as_operand(block, scope, value));\n+            return this.in_scope(region_scope, lint_level, |this| {\n+                this.as_operand(block, scope, &this.thir[value])\n+            });\n         }\n \n         let category = Category::of(&expr.kind).unwrap();\n@@ -123,7 +124,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         &mut self,\n         mut block: BasicBlock,\n         scope: Option<region::Scope>,\n-        expr: &Expr<'_, 'tcx>,\n+        expr: &Expr<'tcx>,\n     ) -> BlockAnd<Operand<'tcx>> {\n         debug!(\"as_call_operand(block={:?}, expr={:?})\", block, expr);\n         let this = self;\n@@ -132,7 +133,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             let source_info = this.source_info(expr.span);\n             let region_scope = (region_scope, source_info);\n             return this.in_scope(region_scope, lint_level, |this| {\n-                this.as_call_operand(block, scope, value)\n+                this.as_call_operand(block, scope, &this.thir[value])\n             });\n         }\n \n@@ -151,7 +152,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 // type, and that value is coming from the deref of a box.\n                 if let ExprKind::Deref { arg } = expr.kind {\n                     // Generate let tmp0 = arg0\n-                    let operand = unpack!(block = this.as_temp(block, scope, arg, Mutability::Mut));\n+                    let operand = unpack!(\n+                        block = this.as_temp(block, scope, &this.thir[arg], Mutability::Mut)\n+                    );\n \n                     // Return the operand *tmp0 to be used as the call argument\n                     let place = Place {"}, {"sha": "96df77a65da9e5637813e8b01a43969acc3ef604", "filename": "compiler/rustc_mir_build/src/build/expr/as_place.rs", "status": "modified", "additions": 25, "deletions": 15, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/dc3eabd48700863075bd986a497fbe4f227aa33b/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc3eabd48700863075bd986a497fbe4f227aa33b/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs?ref=dc3eabd48700863075bd986a497fbe4f227aa33b", "patch": "@@ -381,7 +381,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     crate fn as_place(\n         &mut self,\n         mut block: BasicBlock,\n-        expr: &Expr<'_, 'tcx>,\n+        expr: &Expr<'tcx>,\n     ) -> BlockAnd<Place<'tcx>> {\n         let place_builder = unpack!(block = self.as_place_builder(block, expr));\n         block.and(place_builder.into_place(self.tcx, self.typeck_results))\n@@ -392,7 +392,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     crate fn as_place_builder(\n         &mut self,\n         block: BasicBlock,\n-        expr: &Expr<'_, 'tcx>,\n+        expr: &Expr<'tcx>,\n     ) -> BlockAnd<PlaceBuilder<'tcx>> {\n         self.expr_as_place(block, expr, Mutability::Mut, None)\n     }\n@@ -405,7 +405,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     crate fn as_read_only_place(\n         &mut self,\n         mut block: BasicBlock,\n-        expr: &Expr<'_, 'tcx>,\n+        expr: &Expr<'tcx>,\n     ) -> BlockAnd<Place<'tcx>> {\n         let place_builder = unpack!(block = self.as_read_only_place_builder(block, expr));\n         block.and(place_builder.into_place(self.tcx, self.typeck_results))\n@@ -420,15 +420,15 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     fn as_read_only_place_builder(\n         &mut self,\n         block: BasicBlock,\n-        expr: &Expr<'_, 'tcx>,\n+        expr: &Expr<'tcx>,\n     ) -> BlockAnd<PlaceBuilder<'tcx>> {\n         self.expr_as_place(block, expr, Mutability::Not, None)\n     }\n \n     fn expr_as_place(\n         &mut self,\n         mut block: BasicBlock,\n-        expr: &Expr<'_, 'tcx>,\n+        expr: &Expr<'tcx>,\n         mutability: Mutability,\n         fake_borrow_temps: Option<&mut Vec<Local>>,\n     ) -> BlockAnd<PlaceBuilder<'tcx>> {\n@@ -440,23 +440,27 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         match expr.kind {\n             ExprKind::Scope { region_scope, lint_level, value } => {\n                 this.in_scope((region_scope, source_info), lint_level, |this| {\n-                    this.expr_as_place(block, value, mutability, fake_borrow_temps)\n+                    this.expr_as_place(block, &this.thir[value], mutability, fake_borrow_temps)\n                 })\n             }\n             ExprKind::Field { lhs, name } => {\n-                let place_builder =\n-                    unpack!(block = this.expr_as_place(block, lhs, mutability, fake_borrow_temps,));\n+                let place_builder = unpack!(\n+                    block =\n+                        this.expr_as_place(block, &this.thir[lhs], mutability, fake_borrow_temps,)\n+                );\n                 block.and(place_builder.field(name, expr.ty))\n             }\n             ExprKind::Deref { arg } => {\n-                let place_builder =\n-                    unpack!(block = this.expr_as_place(block, arg, mutability, fake_borrow_temps,));\n+                let place_builder = unpack!(\n+                    block =\n+                        this.expr_as_place(block, &this.thir[arg], mutability, fake_borrow_temps,)\n+                );\n                 block.and(place_builder.deref())\n             }\n             ExprKind::Index { lhs, index } => this.lower_index_expression(\n                 block,\n-                lhs,\n-                index,\n+                &this.thir[lhs],\n+                &this.thir[index],\n                 mutability,\n                 fake_borrow_temps,\n                 expr.temp_lifetime,\n@@ -481,7 +485,12 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n             ExprKind::PlaceTypeAscription { source, user_ty } => {\n                 let place_builder = unpack!(\n-                    block = this.expr_as_place(block, source, mutability, fake_borrow_temps,)\n+                    block = this.expr_as_place(\n+                        block,\n+                        &this.thir[source],\n+                        mutability,\n+                        fake_borrow_temps,\n+                    )\n                 );\n                 if let Some(user_ty) = user_ty {\n                     let annotation_index =\n@@ -509,6 +518,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 block.and(place_builder)\n             }\n             ExprKind::ValueTypeAscription { source, user_ty } => {\n+                let source = &this.thir[source];\n                 let temp =\n                     unpack!(block = this.as_temp(block, source.temp_lifetime, source, mutability));\n                 if let Some(user_ty) = user_ty {\n@@ -613,8 +623,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     fn lower_index_expression(\n         &mut self,\n         mut block: BasicBlock,\n-        base: &Expr<'_, 'tcx>,\n-        index: &Expr<'_, 'tcx>,\n+        base: &Expr<'tcx>,\n+        index: &Expr<'tcx>,\n         mutability: Mutability,\n         fake_borrow_temps: Option<&mut Vec<Local>>,\n         temp_lifetime: Option<region::Scope>,"}, {"sha": "92a2a7bc17a8b97ececa115e15ccc79c7221d451", "filename": "compiler/rustc_mir_build/src/build/expr/as_rvalue.rs", "status": "modified", "additions": 30, "deletions": 17, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/dc3eabd48700863075bd986a497fbe4f227aa33b/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc3eabd48700863075bd986a497fbe4f227aa33b/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=dc3eabd48700863075bd986a497fbe4f227aa33b", "patch": "@@ -23,7 +23,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     crate fn as_local_rvalue(\n         &mut self,\n         block: BasicBlock,\n-        expr: &Expr<'_, 'tcx>,\n+        expr: &Expr<'tcx>,\n     ) -> BlockAnd<Rvalue<'tcx>> {\n         let local_scope = self.local_scope();\n         self.as_rvalue(block, Some(local_scope), expr)\n@@ -34,7 +34,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         &mut self,\n         mut block: BasicBlock,\n         scope: Option<region::Scope>,\n-        expr: &Expr<'_, 'tcx>,\n+        expr: &Expr<'tcx>,\n     ) -> BlockAnd<Rvalue<'tcx>> {\n         debug!(\"expr_as_rvalue(block={:?}, scope={:?}, expr={:?})\", block, scope, expr);\n \n@@ -46,19 +46,22 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             ExprKind::ThreadLocalRef(did) => block.and(Rvalue::ThreadLocalRef(did)),\n             ExprKind::Scope { region_scope, lint_level, value } => {\n                 let region_scope = (region_scope, source_info);\n-                this.in_scope(region_scope, lint_level, |this| this.as_rvalue(block, scope, value))\n+                this.in_scope(region_scope, lint_level, |this| {\n+                    this.as_rvalue(block, scope, &this.thir[value])\n+                })\n             }\n             ExprKind::Repeat { value, count } => {\n-                let value_operand = unpack!(block = this.as_operand(block, scope, value));\n+                let value_operand =\n+                    unpack!(block = this.as_operand(block, scope, &this.thir[value]));\n                 block.and(Rvalue::Repeat(value_operand, count))\n             }\n             ExprKind::Binary { op, lhs, rhs } => {\n-                let lhs = unpack!(block = this.as_operand(block, scope, lhs));\n-                let rhs = unpack!(block = this.as_operand(block, scope, rhs));\n+                let lhs = unpack!(block = this.as_operand(block, scope, &this.thir[lhs]));\n+                let rhs = unpack!(block = this.as_operand(block, scope, &this.thir[rhs]));\n                 this.build_binary_op(block, op, expr_span, expr.ty, lhs, rhs)\n             }\n             ExprKind::Unary { op, arg } => {\n-                let arg = unpack!(block = this.as_operand(block, scope, arg));\n+                let arg = unpack!(block = this.as_operand(block, scope, &this.thir[arg]));\n                 // Check for -MIN on signed integers\n                 if this.check_overflow && op == UnOp::Neg && expr.ty.is_signed() {\n                     let bool_ty = this.tcx.types.bool;\n@@ -84,6 +87,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 block.and(Rvalue::UnaryOp(op, arg))\n             }\n             ExprKind::Box { value } => {\n+                let value = &this.thir[value];\n                 // The `Box<T>` temporary created here is not a part of the HIR,\n                 // and therefore is not considered during generator auto-trait\n                 // determination. See the comment about `box` at `yield_in_scope`.\n@@ -112,14 +116,14 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 block.and(Rvalue::Use(Operand::Move(Place::from(result))))\n             }\n             ExprKind::Cast { source } => {\n-                let source = unpack!(block = this.as_operand(block, scope, source));\n+                let source = unpack!(block = this.as_operand(block, scope, &this.thir[source]));\n                 block.and(Rvalue::Cast(CastKind::Misc, source, expr.ty))\n             }\n             ExprKind::Pointer { cast, source } => {\n-                let source = unpack!(block = this.as_operand(block, scope, source));\n+                let source = unpack!(block = this.as_operand(block, scope, &this.thir[source]));\n                 block.and(Rvalue::Cast(CastKind::Pointer(cast), source, expr.ty))\n             }\n-            ExprKind::Array { fields } => {\n+            ExprKind::Array { ref fields } => {\n                 // (*) We would (maybe) be closer to codegen if we\n                 // handled this and other aggregate cases via\n                 // `into()`, not `as_rvalue` -- in that case, instead\n@@ -150,22 +154,24 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 let el_ty = expr.ty.sequence_element_type(this.tcx);\n                 let fields: Vec<_> = fields\n                     .into_iter()\n-                    .map(|f| unpack!(block = this.as_operand(block, scope, f)))\n+                    .copied()\n+                    .map(|f| unpack!(block = this.as_operand(block, scope, &this.thir[f])))\n                     .collect();\n \n                 block.and(Rvalue::Aggregate(box AggregateKind::Array(el_ty), fields))\n             }\n-            ExprKind::Tuple { fields } => {\n+            ExprKind::Tuple { ref fields } => {\n                 // see (*) above\n                 // first process the set of fields\n                 let fields: Vec<_> = fields\n                     .into_iter()\n-                    .map(|f| unpack!(block = this.as_operand(block, scope, f)))\n+                    .copied()\n+                    .map(|f| unpack!(block = this.as_operand(block, scope, &this.thir[f])))\n                     .collect();\n \n                 block.and(Rvalue::Aggregate(box AggregateKind::Tuple, fields))\n             }\n-            ExprKind::Closure { closure_id, substs, upvars, movability, ref fake_reads } => {\n+            ExprKind::Closure { closure_id, substs, ref upvars, movability, ref fake_reads } => {\n                 // Convert the closure fake reads, if any, from `ExprRef` to mir `Place`\n                 // and push the fake reads.\n                 // This must come before creating the operands. This is required in case\n@@ -180,7 +186,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 // };\n                 // ```\n                 for (thir_place, cause, hir_id) in fake_reads.into_iter() {\n-                    let place_builder = unpack!(block = this.as_place_builder(block, thir_place));\n+                    let place_builder =\n+                        unpack!(block = this.as_place_builder(block, &this.thir[*thir_place]));\n \n                     if let Ok(place_builder_resolved) =\n                         place_builder.try_upvars_resolved(this.tcx, this.typeck_results)\n@@ -199,7 +206,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 // see (*) above\n                 let operands: Vec<_> = upvars\n                     .into_iter()\n+                    .copied()\n                     .map(|upvar| {\n+                        let upvar = &this.thir[upvar];\n                         match Category::of(&upvar.kind) {\n                             // Use as_place to avoid creating a temporary when\n                             // moving a variable into a closure, so that\n@@ -225,7 +234,11 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                                         arg,\n                                     } => unpack!(\n                                         block = this.limit_capture_mutability(\n-                                            upvar.span, upvar.ty, scope, block, arg,\n+                                            upvar.span,\n+                                            upvar.ty,\n+                                            scope,\n+                                            block,\n+                                            &this.thir[arg],\n                                         )\n                                     ),\n                                     _ => unpack!(block = this.as_operand(block, scope, upvar)),\n@@ -398,7 +411,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         upvar_ty: Ty<'tcx>,\n         temp_lifetime: Option<region::Scope>,\n         mut block: BasicBlock,\n-        arg: &Expr<'_, 'tcx>,\n+        arg: &Expr<'tcx>,\n     ) -> BlockAnd<Operand<'tcx>> {\n         let this = self;\n "}, {"sha": "96bf3e6d69d6d2d77b5e6d892e909d7a6d633ce3", "filename": "compiler/rustc_mir_build/src/build/expr/as_temp.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dc3eabd48700863075bd986a497fbe4f227aa33b/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_temp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc3eabd48700863075bd986a497fbe4f227aa33b/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_temp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_temp.rs?ref=dc3eabd48700863075bd986a497fbe4f227aa33b", "patch": "@@ -14,7 +14,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         &mut self,\n         block: BasicBlock,\n         temp_lifetime: Option<region::Scope>,\n-        expr: &Expr<'_, 'tcx>,\n+        expr: &Expr<'tcx>,\n         mutability: Mutability,\n     ) -> BlockAnd<Local> {\n         // this is the only place in mir building that we need to truly need to worry about\n@@ -27,7 +27,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         &mut self,\n         mut block: BasicBlock,\n         temp_lifetime: Option<region::Scope>,\n-        expr: &Expr<'_, 'tcx>,\n+        expr: &Expr<'tcx>,\n         mutability: Mutability,\n     ) -> BlockAnd<Local> {\n         debug!(\n@@ -40,7 +40,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         let source_info = this.source_info(expr_span);\n         if let ExprKind::Scope { region_scope, lint_level, value } = expr.kind {\n             return this.in_scope((region_scope, source_info), lint_level, |this| {\n-                this.as_temp(block, temp_lifetime, value, mutability)\n+                this.as_temp(block, temp_lifetime, &this.thir[value], mutability)\n             });\n         }\n "}, {"sha": "9320b5810e3964fa193ea88d37efd2a3105cdc9d", "filename": "compiler/rustc_mir_build/src/build/expr/category.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc3eabd48700863075bd986a497fbe4f227aa33b/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fcategory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc3eabd48700863075bd986a497fbe4f227aa33b/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fcategory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fcategory.rs?ref=dc3eabd48700863075bd986a497fbe4f227aa33b", "patch": "@@ -31,7 +31,7 @@ crate enum RvalueFunc {\n /// Determines the category for a given expression. Note that scope\n /// and paren expressions have no category.\n impl Category {\n-    crate fn of(ek: &ExprKind<'_, '_>) -> Option<Category> {\n+    crate fn of(ek: &ExprKind<'_>) -> Option<Category> {\n         match *ek {\n             ExprKind::Scope { .. } => None,\n "}, {"sha": "d7c8a07103e3ce35ae612a269da9ea2daafdbb70", "filename": "compiler/rustc_mir_build/src/build/expr/into.rs", "status": "modified", "additions": 53, "deletions": 31, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/dc3eabd48700863075bd986a497fbe4f227aa33b/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc3eabd48700863075bd986a497fbe4f227aa33b/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs?ref=dc3eabd48700863075bd986a497fbe4f227aa33b", "patch": "@@ -19,7 +19,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         &mut self,\n         destination: Place<'tcx>,\n         mut block: BasicBlock,\n-        expr: &Expr<'_, 'tcx>,\n+        expr: &Expr<'tcx>,\n     ) -> BlockAnd<()> {\n         debug!(\"expr_into_dest(destination={:?}, block={:?}, expr={:?})\", destination, block, expr);\n \n@@ -42,19 +42,24 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 let region_scope = (region_scope, source_info);\n                 ensure_sufficient_stack(|| {\n                     this.in_scope(region_scope, lint_level, |this| {\n-                        this.expr_into_dest(destination, block, value)\n+                        this.expr_into_dest(destination, block, &this.thir[value])\n                     })\n                 })\n             }\n             ExprKind::Block { body: ref ast_block } => {\n                 this.ast_block(destination, block, ast_block, source_info)\n             }\n-            ExprKind::Match { scrutinee, arms } => {\n-                this.match_expr(destination, expr_span, block, scrutinee, arms)\n+            ExprKind::Match { scrutinee, ref arms } => {\n+                this.match_expr(destination, expr_span, block, &this.thir[scrutinee], arms)\n             }\n             ExprKind::If { cond, then, else_opt } => {\n                 let place = unpack!(\n-                    block = this.as_temp(block, Some(this.local_scope()), cond, Mutability::Mut)\n+                    block = this.as_temp(\n+                        block,\n+                        Some(this.local_scope()),\n+                        &this.thir[cond],\n+                        Mutability::Mut\n+                    )\n                 );\n                 let operand = Operand::Move(Place::from(place));\n \n@@ -63,9 +68,11 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 let term = TerminatorKind::if_(this.tcx, operand, then_block, else_block);\n                 this.cfg.terminate(block, source_info, term);\n \n-                unpack!(then_block = this.expr_into_dest(destination, then_block, then));\n+                unpack!(\n+                    then_block = this.expr_into_dest(destination, then_block, &this.thir[then])\n+                );\n                 else_block = if let Some(else_opt) = else_opt {\n-                    unpack!(this.expr_into_dest(destination, else_block, else_opt))\n+                    unpack!(this.expr_into_dest(destination, else_block, &this.thir[else_opt]))\n                 } else {\n                     // Body of the `if` expression without an `else` clause must return `()`, thus\n                     // we implicitly generate a `else {}` if it is not specified.\n@@ -89,6 +96,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 join_block.unit()\n             }\n             ExprKind::NeverToAny { source } => {\n+                let source = &this.thir[source];\n                 let is_call =\n                     matches!(source.kind, ExprKind::Call { .. } | ExprKind::InlineAsm { .. });\n \n@@ -127,7 +135,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     this.cfg.start_new_block(),\n                 );\n \n-                let lhs = unpack!(block = this.as_local_operand(block, lhs));\n+                let lhs = unpack!(block = this.as_local_operand(block, &this.thir[lhs]));\n                 let blocks = match op {\n                     LogicalOp::And => (else_block, shortcircuit_block),\n                     LogicalOp::Or => (shortcircuit_block, else_block),\n@@ -150,7 +158,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 );\n                 this.cfg.goto(shortcircuit_block, source_info, join_block);\n \n-                let rhs = unpack!(else_block = this.as_local_operand(else_block, rhs));\n+                let rhs = unpack!(else_block = this.as_local_operand(else_block, &this.thir[rhs]));\n                 this.cfg.push_assign(else_block, source_info, destination, Rvalue::Use(rhs));\n                 this.cfg.goto(else_block, source_info, join_block);\n \n@@ -186,18 +194,20 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     // introduce a unit temporary as the destination for the loop body.\n                     let tmp = this.get_unit_temp();\n                     // Execute the body, branching back to the test.\n-                    let body_block_end = unpack!(this.expr_into_dest(tmp, body_block, body));\n+                    let body_block_end =\n+                        unpack!(this.expr_into_dest(tmp, body_block, &this.thir[body]));\n                     this.cfg.goto(body_block_end, source_info, loop_block);\n \n                     // Loops are only exited by `break` expressions.\n                     None\n                 })\n             }\n-            ExprKind::Call { ty: _, fun, args, from_hir_call, fn_span } => {\n-                let fun = unpack!(block = this.as_local_operand(block, fun));\n+            ExprKind::Call { ty: _, fun, ref args, from_hir_call, fn_span } => {\n+                let fun = unpack!(block = this.as_local_operand(block, &this.thir[fun]));\n                 let args: Vec<_> = args\n                     .into_iter()\n-                    .map(|arg| unpack!(block = this.as_local_call_operand(block, arg)))\n+                    .copied()\n+                    .map(|arg| unpack!(block = this.as_local_call_operand(block, &this.thir[arg])))\n                     .collect();\n \n                 let success = this.cfg.start_new_block();\n@@ -228,8 +238,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 this.diverge_from(block);\n                 success.unit()\n             }\n-            ExprKind::Use { source } => this.expr_into_dest(destination, block, source),\n+            ExprKind::Use { source } => this.expr_into_dest(destination, block, &this.thir[source]),\n             ExprKind::Borrow { arg, borrow_kind } => {\n+                let arg = &this.thir[arg];\n                 // We don't do this in `as_rvalue` because we use `as_place`\n                 // for borrow expressions, so we cannot create an `RValue` that\n                 // remains valid across user code. `as_rvalue` is usually called\n@@ -244,6 +255,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 block.unit()\n             }\n             ExprKind::AddressOf { mutability, arg } => {\n+                let arg = &this.thir[arg];\n                 let place = match mutability {\n                     hir::Mutability::Not => this.as_read_only_place(block, arg),\n                     hir::Mutability::Mut => this.as_place(block, arg),\n@@ -252,7 +264,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 this.cfg.push_assign(block, source_info, destination, address_of);\n                 block.unit()\n             }\n-            ExprKind::Adt { adt_def, variant_index, substs, user_ty, fields, ref base } => {\n+            ExprKind::Adt { adt_def, variant_index, substs, user_ty, ref fields, ref base } => {\n                 // See the notes for `ExprKind::Array` in `as_rvalue` and for\n                 // `ExprKind::Borrow` above.\n                 let is_union = adt_def.is_union();\n@@ -264,19 +276,27 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 // (evaluating them in order given by user)\n                 let fields_map: FxHashMap<_, _> = fields\n                     .into_iter()\n-                    .map(|f| (f.name, unpack!(block = this.as_operand(block, Some(scope), f.expr))))\n+                    .map(|f| {\n+                        (\n+                            f.name,\n+                            unpack!(\n+                                block = this.as_operand(block, Some(scope), &this.thir[f.expr])\n+                            ),\n+                        )\n+                    })\n                     .collect();\n \n                 let field_names: Vec<_> =\n                     (0..adt_def.variants[variant_index].fields.len()).map(Field::new).collect();\n \n                 let fields: Vec<_> = if let Some(FruInfo { base, field_types }) = base {\n-                    let place_builder = unpack!(block = this.as_place_builder(block, base));\n+                    let place_builder =\n+                        unpack!(block = this.as_place_builder(block, &this.thir[*base]));\n \n                     // MIR does not natively support FRU, so for each\n                     // base-supplied field, generate an operand that\n                     // reads it from the base.\n-                    iter::zip(field_names, *field_types)\n+                    iter::zip(field_names, &**field_types)\n                         .map(|(n, ty)| match fields_map.get(&n) {\n                             Some(v) => v.clone(),\n                             None => {\n@@ -316,27 +336,27 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 );\n                 block.unit()\n             }\n-            ExprKind::InlineAsm { template, operands, options, line_spans } => {\n+            ExprKind::InlineAsm { template, ref operands, options, line_spans } => {\n                 use crate::thir;\n                 use rustc_middle::mir;\n                 let operands = operands\n                     .into_iter()\n                     .map(|op| match *op {\n                         thir::InlineAsmOperand::In { reg, expr } => mir::InlineAsmOperand::In {\n                             reg,\n-                            value: unpack!(block = this.as_local_operand(block, expr)),\n+                            value: unpack!(block = this.as_local_operand(block, &this.thir[expr])),\n                         },\n                         thir::InlineAsmOperand::Out { reg, late, expr } => {\n                             mir::InlineAsmOperand::Out {\n                                 reg,\n                                 late,\n-                                place: expr\n-                                    .as_ref()\n-                                    .map(|expr| unpack!(block = this.as_place(block, expr))),\n+                                place: expr.map(|expr| {\n+                                    unpack!(block = this.as_place(block, &this.thir[expr]))\n+                                }),\n                             }\n                         }\n                         thir::InlineAsmOperand::InOut { reg, late, expr } => {\n-                            let place = unpack!(block = this.as_place(block, expr));\n+                            let place = unpack!(block = this.as_place(block, &this.thir[expr]));\n                             mir::InlineAsmOperand::InOut {\n                                 reg,\n                                 late,\n@@ -349,9 +369,11 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                             mir::InlineAsmOperand::InOut {\n                                 reg,\n                                 late,\n-                                in_value: unpack!(block = this.as_local_operand(block, in_expr)),\n-                                out_place: out_expr.as_ref().map(|out_expr| {\n-                                    unpack!(block = this.as_place(block, out_expr))\n+                                in_value: unpack!(\n+                                    block = this.as_local_operand(block, &this.thir[in_expr])\n+                                ),\n+                                out_place: out_expr.map(|out_expr| {\n+                                    unpack!(block = this.as_place(block, &this.thir[out_expr]))\n                                 }),\n                             }\n                         }\n@@ -360,9 +382,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                                 value: box Constant { span, user_ty: None, literal: value.into() },\n                             }\n                         }\n-                        thir::InlineAsmOperand::SymFn { expr } => {\n-                            mir::InlineAsmOperand::SymFn { value: box this.as_constant(expr) }\n-                        }\n+                        thir::InlineAsmOperand::SymFn { expr } => mir::InlineAsmOperand::SymFn {\n+                            value: box this.as_constant(&this.thir[expr]),\n+                        },\n                         thir::InlineAsmOperand::SymStatic { def_id } => {\n                             mir::InlineAsmOperand::SymStatic { def_id }\n                         }\n@@ -434,7 +456,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n             ExprKind::Yield { value } => {\n                 let scope = this.local_scope();\n-                let value = unpack!(block = this.as_operand(block, Some(scope), value));\n+                let value = unpack!(block = this.as_operand(block, Some(scope), &this.thir[value]));\n                 let resume = this.cfg.start_new_block();\n                 this.cfg.terminate(\n                     block,"}, {"sha": "d2442f33b0c6725c84dcb37c1a6012f4b74c931d", "filename": "compiler/rustc_mir_build/src/build/expr/stmt.rs", "status": "modified", "additions": 22, "deletions": 12, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/dc3eabd48700863075bd986a497fbe4f227aa33b/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc3eabd48700863075bd986a497fbe4f227aa33b/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fstmt.rs?ref=dc3eabd48700863075bd986a497fbe4f227aa33b", "patch": "@@ -13,7 +13,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     crate fn stmt_expr(\n         &mut self,\n         mut block: BasicBlock,\n-        expr: &Expr<'_, 'tcx>,\n+        expr: &Expr<'tcx>,\n         statement_scope: Option<region::Scope>,\n     ) -> BlockAnd<()> {\n         let this = self;\n@@ -24,10 +24,12 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         match expr.kind {\n             ExprKind::Scope { region_scope, lint_level, value } => {\n                 this.in_scope((region_scope, source_info), lint_level, |this| {\n-                    this.stmt_expr(block, value, statement_scope)\n+                    this.stmt_expr(block, &this.thir[value], statement_scope)\n                 })\n             }\n             ExprKind::Assign { lhs, rhs } => {\n+                let lhs = &this.thir[lhs];\n+                let rhs = &this.thir[rhs];\n                 let lhs_span = lhs.span;\n \n                 // Note: we evaluate assignments right-to-left. This\n@@ -61,6 +63,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 // only affects weird things like `x += {x += 1; x}`\n                 // -- is that equal to `x + (x + 1)` or `2*(x+1)`?\n \n+                let lhs = &this.thir[lhs];\n+                let rhs = &this.thir[rhs];\n                 let lhs_ty = lhs.ty;\n \n                 debug!(\"stmt_expr AssignOp block_context.push(SubExpr) : {:?}\", expr);\n@@ -87,24 +91,30 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             }\n             ExprKind::Break { label, value } => this.break_scope(\n                 block,\n-                value.as_deref(),\n+                value.map(|value| &this.thir[value]),\n                 BreakableTarget::Break(label),\n                 source_info,\n             ),\n-            ExprKind::Return { value } => {\n-                this.break_scope(block, value.as_deref(), BreakableTarget::Return, source_info)\n-            }\n-            ExprKind::LlvmInlineAsm { asm, outputs, inputs } => {\n+            ExprKind::Return { value } => this.break_scope(\n+                block,\n+                value.map(|value| &this.thir[value]),\n+                BreakableTarget::Return,\n+                source_info,\n+            ),\n+            ExprKind::LlvmInlineAsm { asm, ref outputs, ref inputs } => {\n                 debug!(\"stmt_expr LlvmInlineAsm block_context.push(SubExpr) : {:?}\", expr);\n                 this.block_context.push(BlockFrame::SubExpr);\n                 let outputs = outputs\n                     .into_iter()\n-                    .map(|output| unpack!(block = this.as_place(block, &output)))\n+                    .copied()\n+                    .map(|output| unpack!(block = this.as_place(block, &this.thir[output])))\n                     .collect::<Vec<_>>()\n                     .into_boxed_slice();\n                 let inputs = inputs\n                     .into_iter()\n+                    .copied()\n                     .map(|input| {\n+                        let input = &this.thir[input];\n                         (input.span, unpack!(block = this.as_local_operand(block, &input)))\n                     })\n                     .collect::<Vec<_>>()\n@@ -139,14 +149,14 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 // than the entirety of block(s) surrounding it.\n                 let adjusted_span = (|| {\n                     if let ExprKind::Block { body } = &expr.kind {\n-                        if let Some(tail_expr) = &body.expr {\n-                            let mut expr = &*tail_expr;\n+                        if let Some(tail_expr) = body.expr {\n+                            let mut expr = &this.thir[tail_expr];\n                             while let ExprKind::Block {\n                                 body: Block { expr: Some(nested_expr), .. },\n                             }\n-                            | ExprKind::Scope { value: nested_expr, .. } = &expr.kind\n+                            | ExprKind::Scope { value: nested_expr, .. } = expr.kind\n                             {\n-                                expr = nested_expr;\n+                                expr = &this.thir[nested_expr];\n                             }\n                             this.block_context.push(BlockFrame::TailExpr {\n                                 tail_result_is_ignored: true,"}, {"sha": "c30193b5a5a7f6ef8f632bd4ea1420f70adbf777", "filename": "compiler/rustc_mir_build/src/build/matches/mod.rs", "status": "modified", "additions": 21, "deletions": 14, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/dc3eabd48700863075bd986a497fbe4f227aa33b/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc3eabd48700863075bd986a497fbe4f227aa33b/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs?ref=dc3eabd48700863075bd986a497fbe4f227aa33b", "patch": "@@ -90,16 +90,16 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         destination: Place<'tcx>,\n         span: Span,\n         mut block: BasicBlock,\n-        scrutinee: &Expr<'_, 'tcx>,\n-        arms: &[Arm<'_, 'tcx>],\n+        scrutinee: &Expr<'tcx>,\n+        arms: &[ArmId],\n     ) -> BlockAnd<()> {\n         let scrutinee_span = scrutinee.span;\n         let scrutinee_place =\n             unpack!(block = self.lower_scrutinee(block, scrutinee, scrutinee_span,));\n \n         let mut arm_candidates = self.create_match_candidates(scrutinee_place.clone(), &arms);\n \n-        let match_has_guard = arms.iter().any(|arm| arm.guard.is_some());\n+        let match_has_guard = arms.iter().copied().any(|arm| self.thir[arm].guard.is_some());\n         let mut candidates =\n             arm_candidates.iter_mut().map(|(_, candidate)| candidate).collect::<Vec<_>>();\n \n@@ -120,7 +120,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     fn lower_scrutinee(\n         &mut self,\n         mut block: BasicBlock,\n-        scrutinee: &Expr<'_, 'tcx>,\n+        scrutinee: &Expr<'tcx>,\n         scrutinee_span: Span,\n     ) -> BlockAnd<PlaceBuilder<'tcx>> {\n         let scrutinee_place_builder = unpack!(block = self.as_place_builder(block, scrutinee));\n@@ -156,12 +156,17 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     fn create_match_candidates<'pat>(\n         &mut self,\n         scrutinee: PlaceBuilder<'tcx>,\n-        arms: &'pat [Arm<'pat, 'tcx>],\n-    ) -> Vec<(&'pat Arm<'pat, 'tcx>, Candidate<'pat, 'tcx>)> {\n+        arms: &'pat [ArmId],\n+    ) -> Vec<(&'pat Arm<'tcx>, Candidate<'pat, 'tcx>)>\n+    where\n+        'a: 'pat,\n+    {\n         // Assemble a list of candidates: there is one candidate per pattern,\n         // which means there may be more than one candidate *per arm*.\n         arms.iter()\n+            .copied()\n             .map(|arm| {\n+                let arm = &self.thir[arm];\n                 let arm_has_guard = arm.guard.is_some();\n                 let arm_candidate = Candidate::new(scrutinee.clone(), &arm.pattern, arm_has_guard);\n                 (arm, arm_candidate)\n@@ -231,7 +236,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         destination: Place<'tcx>,\n         scrutinee_place_builder: PlaceBuilder<'tcx>,\n         scrutinee_span: Span,\n-        arm_candidates: Vec<(&'_ Arm<'_, 'tcx>, Candidate<'_, 'tcx>)>,\n+        arm_candidates: Vec<(&'_ Arm<'tcx>, Candidate<'_, 'tcx>)>,\n         outer_source_info: SourceInfo,\n         fake_borrow_temps: Vec<(Place<'tcx>, Local)>,\n     ) -> BlockAnd<()> {\n@@ -286,7 +291,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                         this.source_scope = source_scope;\n                     }\n \n-                    this.expr_into_dest(destination, arm_block, &arm.body)\n+                    this.expr_into_dest(destination, arm_block, &&this.thir[arm.body])\n                 })\n             })\n             .collect();\n@@ -313,7 +318,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         &mut self,\n         outer_source_info: SourceInfo,\n         candidate: Candidate<'_, 'tcx>,\n-        guard: Option<&Guard<'_, 'tcx>>,\n+        guard: Option<&Guard<'tcx>>,\n         fake_borrow_temps: &Vec<(Place<'tcx>, Local)>,\n         scrutinee_span: Span,\n         arm_span: Option<Span>,\n@@ -389,7 +394,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         &mut self,\n         mut block: BasicBlock,\n         irrefutable_pat: Pat<'tcx>,\n-        initializer: &Expr<'_, 'tcx>,\n+        initializer: &Expr<'tcx>,\n     ) -> BlockAnd<()> {\n         match *irrefutable_pat.kind {\n             // Optimize the case of `let x = ...` to write directly into `x`\n@@ -1665,7 +1670,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         &mut self,\n         candidate: Candidate<'pat, 'tcx>,\n         parent_bindings: &[(Vec<Binding<'tcx>>, Vec<Ascription<'tcx>>)],\n-        guard: Option<&Guard<'_, 'tcx>>,\n+        guard: Option<&Guard<'tcx>>,\n         fake_borrows: &Vec<(Place<'tcx>, Local)>,\n         scrutinee_span: Span,\n         arm_span: Option<Span>,\n@@ -1799,12 +1804,14 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 self.cfg.push_assign(block, scrutinee_source_info, Place::from(temp), borrow);\n             }\n \n-            let (guard_span, (post_guard_block, otherwise_post_guard_block)) = match guard {\n+            let (guard_span, (post_guard_block, otherwise_post_guard_block)) = match *guard {\n                 Guard::If(e) => {\n+                    let e = &self.thir[e];\n                     let source_info = self.source_info(e.span);\n                     (e.span, self.test_bool(block, e, source_info))\n                 }\n-                Guard::IfLet(pat, scrutinee) => {\n+                Guard::IfLet(ref pat, scrutinee) => {\n+                    let scrutinee = &self.thir[scrutinee];\n                     let scrutinee_span = scrutinee.span;\n                     let scrutinee_place_builder =\n                         unpack!(block = self.lower_scrutinee(block, scrutinee, scrutinee_span));\n@@ -1840,7 +1847,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                         guard_candidate,\n                         None,\n                         &fake_borrow_temps,\n-                        scrutinee.span,\n+                        scrutinee_span,\n                         None,\n                         None,\n                     );"}, {"sha": "4f6c57be2daa2bdfbf56990bc801e2ae1dba3b00", "filename": "compiler/rustc_mir_build/src/build/mod.rs", "status": "modified", "additions": 60, "deletions": 19, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/dc3eabd48700863075bd986a497fbe4f227aa33b/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc3eabd48700863075bd986a497fbe4f227aa33b/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs?ref=dc3eabd48700863075bd986a497fbe4f227aa33b", "patch": "@@ -1,7 +1,7 @@\n use crate::build;\n use crate::build::expr::as_place::PlaceBuilder;\n use crate::build::scope::DropKind;\n-use crate::thir::{build_thir, Arena, BindingMode, Expr, LintLevel, Pat, PatKind};\n+use crate::thir::{build_thir, BindingMode, Expr, ExprId, LintLevel, Pat, PatKind, Thir};\n use rustc_attr::{self as attr, UnwindAttr};\n use rustc_errors::ErrorReported;\n use rustc_hir as hir;\n@@ -88,7 +88,6 @@ fn mir_build(tcx: TyCtxt<'_>, def: ty::WithOptConstParam<LocalDefId>) -> Body<'_\n     // If we don't have a specialized span for the body, just use the\n     // normal def span.\n     let span_with_body = span_with_body.unwrap_or_else(|| tcx.hir().span(id));\n-    let arena = Arena::default();\n \n     tcx.infer_ctxt().enter(|infcx| {\n         let body = if let Some(ErrorReported) = typeck_results.tainted_by_errors {\n@@ -105,7 +104,7 @@ fn mir_build(tcx: TyCtxt<'_>, def: ty::WithOptConstParam<LocalDefId>) -> Body<'_\n             };\n \n             let body = tcx.hir().body(body_id);\n-            let thir = build_thir(tcx, def, &arena, &body.value);\n+            let (thir, expr) = build_thir(tcx, def, &body.value);\n             let ty = tcx.type_of(fn_def_id);\n             let mut abi = fn_sig.abi;\n             let implicit_argument = match ty.kind() {\n@@ -181,6 +180,7 @@ fn mir_build(tcx: TyCtxt<'_>, def: ty::WithOptConstParam<LocalDefId>) -> Body<'_\n             };\n \n             let mut mir = build::construct_fn(\n+                &thir,\n                 &infcx,\n                 def,\n                 id,\n@@ -190,7 +190,7 @@ fn mir_build(tcx: TyCtxt<'_>, def: ty::WithOptConstParam<LocalDefId>) -> Body<'_\n                 return_ty,\n                 return_ty_span,\n                 body,\n-                thir,\n+                expr,\n                 span_with_body,\n             );\n             if yield_ty.is_some() {\n@@ -213,9 +213,9 @@ fn mir_build(tcx: TyCtxt<'_>, def: ty::WithOptConstParam<LocalDefId>) -> Body<'_\n             let return_ty = typeck_results.node_type(id);\n \n             let ast_expr = &tcx.hir().body(body_id).value;\n-            let thir = build_thir(tcx, def, &arena, ast_expr);\n+            let (thir, expr) = build_thir(tcx, def, ast_expr);\n \n-            build::construct_const(&infcx, thir, def, id, return_ty, return_ty_span)\n+            build::construct_const(&thir, &infcx, expr, def, id, return_ty, return_ty_span)\n         };\n \n         lints::check(tcx, &body);\n@@ -323,6 +323,7 @@ struct Builder<'a, 'tcx> {\n     region_scope_tree: &'tcx region::ScopeTree,\n     param_env: ty::ParamEnv<'tcx>,\n \n+    thir: &'a Thir<'tcx>,\n     cfg: CFG<'tcx>,\n \n     def_id: DefId,\n@@ -633,6 +634,7 @@ struct ArgInfo<'tcx>(\n );\n \n fn construct_fn<'tcx, A>(\n+    thir: &Thir<'tcx>,\n     infcx: &InferCtxt<'_, 'tcx>,\n     fn_def: ty::WithOptConstParam<LocalDefId>,\n     fn_id: hir::HirId,\n@@ -642,7 +644,7 @@ fn construct_fn<'tcx, A>(\n     return_ty: Ty<'tcx>,\n     return_ty_span: Span,\n     body: &'tcx hir::Body<'tcx>,\n-    expr: &Expr<'_, 'tcx>,\n+    expr: ExprId,\n     span_with_body: Span,\n ) -> Body<'tcx>\n where\n@@ -654,6 +656,7 @@ where\n     let span = tcx.hir().span(fn_id);\n \n     let mut builder = Builder::new(\n+        thir,\n         infcx,\n         fn_def,\n         fn_id,\n@@ -683,7 +686,7 @@ where\n                         fn_def.did.to_def_id(),\n                         &arguments,\n                         arg_scope,\n-                        expr,\n+                        &thir[expr],\n                     )\n                 }))\n             }));\n@@ -708,20 +711,31 @@ where\n }\n \n fn construct_const<'a, 'tcx>(\n+    thir: &'a Thir<'tcx>,\n     infcx: &'a InferCtxt<'a, 'tcx>,\n-    expr: &Expr<'_, 'tcx>,\n+    expr: ExprId,\n     def: ty::WithOptConstParam<LocalDefId>,\n     hir_id: hir::HirId,\n     const_ty: Ty<'tcx>,\n     const_ty_span: Span,\n ) -> Body<'tcx> {\n     let tcx = infcx.tcx;\n     let span = tcx.hir().span(hir_id);\n-    let mut builder =\n-        Builder::new(infcx, def, hir_id, span, 0, Safety::Safe, const_ty, const_ty_span, None);\n+    let mut builder = Builder::new(\n+        thir,\n+        infcx,\n+        def,\n+        hir_id,\n+        span,\n+        0,\n+        Safety::Safe,\n+        const_ty,\n+        const_ty_span,\n+        None,\n+    );\n \n     let mut block = START_BLOCK;\n-    unpack!(block = builder.expr_into_dest(Place::return_place(), block, &expr));\n+    unpack!(block = builder.expr_into_dest(Place::return_place(), block, &thir[expr]));\n \n     let source_info = builder.source_info(span);\n     builder.cfg.terminate(block, source_info, TerminatorKind::Return);\n@@ -761,22 +775,48 @@ fn construct_error<'a, 'tcx>(\n         hir::BodyOwnerKind::Const => 0,\n         hir::BodyOwnerKind::Static(_) => 0,\n     };\n-    let mut builder =\n-        Builder::new(infcx, def, hir_id, span, num_params, Safety::Safe, ty, span, generator_kind);\n-    let source_info = builder.source_info(span);\n+    let mut cfg = CFG { basic_blocks: IndexVec::new() };\n+    let mut source_scopes = IndexVec::new();\n+    let mut local_decls = IndexVec::from_elem_n(LocalDecl::new(ty, span), 1);\n+\n+    cfg.start_new_block();\n+    source_scopes.push(SourceScopeData {\n+        span,\n+        parent_scope: None,\n+        inlined: None,\n+        inlined_parent_scope: None,\n+        local_data: ClearCrossCrate::Set(SourceScopeLocalData {\n+            lint_root: hir_id,\n+            safety: Safety::Safe,\n+        }),\n+    });\n+    let source_info = SourceInfo { span, scope: OUTERMOST_SOURCE_SCOPE };\n+\n     // Some MIR passes will expect the number of parameters to match the\n     // function declaration.\n     for _ in 0..num_params {\n-        builder.local_decls.push(LocalDecl::with_source_info(ty, source_info));\n+        local_decls.push(LocalDecl::with_source_info(ty, source_info));\n     }\n-    builder.cfg.terminate(START_BLOCK, source_info, TerminatorKind::Unreachable);\n-    let mut body = builder.finish();\n+    cfg.terminate(START_BLOCK, source_info, TerminatorKind::Unreachable);\n+\n+    let mut body = Body::new(\n+        MirSource::item(def.did.to_def_id()),\n+        cfg.basic_blocks,\n+        source_scopes,\n+        local_decls,\n+        IndexVec::new(),\n+        num_params,\n+        vec![],\n+        span,\n+        generator_kind,\n+    );\n     body.generator.as_mut().map(|gen| gen.yield_ty = Some(ty));\n     body\n }\n \n impl<'a, 'tcx> Builder<'a, 'tcx> {\n     fn new(\n+        thir: &'a Thir<'tcx>,\n         infcx: &'a InferCtxt<'a, 'tcx>,\n         def: ty::WithOptConstParam<LocalDefId>,\n         hir_id: hir::HirId,\n@@ -803,6 +843,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n         let lint_level = LintLevel::Explicit(hir_id);\n         let mut builder = Builder {\n+            thir,\n             tcx,\n             infcx,\n             typeck_results: tcx.typeck_opt_const_arg(def),\n@@ -866,7 +907,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         fn_def_id: DefId,\n         arguments: &[ArgInfo<'tcx>],\n         argument_scope: region::Scope,\n-        expr: &Expr<'_, 'tcx>,\n+        expr: &Expr<'tcx>,\n     ) -> BlockAnd<()> {\n         // Allocate locals for the function arguments\n         for &ArgInfo(ty, _, arg_opt, _) in arguments.iter() {"}, {"sha": "e79a19d57ac10c47954b804f74b29e8151b38c2b", "filename": "compiler/rustc_mir_build/src/build/scope.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dc3eabd48700863075bd986a497fbe4f227aa33b/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc3eabd48700863075bd986a497fbe4f227aa33b/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fscope.rs?ref=dc3eabd48700863075bd986a497fbe4f227aa33b", "patch": "@@ -574,7 +574,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     crate fn break_scope(\n         &mut self,\n         mut block: BasicBlock,\n-        value: Option<&Expr<'_, 'tcx>>,\n+        value: Option<&Expr<'tcx>>,\n         target: BreakableTarget,\n         source_info: SourceInfo,\n     ) -> BlockAnd<()> {\n@@ -933,7 +933,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     crate fn test_bool(\n         &mut self,\n         mut block: BasicBlock,\n-        condition: &Expr<'_, 'tcx>,\n+        condition: &Expr<'tcx>,\n         source_info: SourceInfo,\n     ) -> (BasicBlock, BasicBlock) {\n         let cond = unpack!(block = self.as_local_operand(block, condition));"}, {"sha": "aacc7b12a42f94bf67caf19e88b80249b5f585db", "filename": "compiler/rustc_mir_build/src/thir/arena.rs", "status": "removed", "additions": 0, "deletions": 98, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/e78bccfbc01526808c4222ee49c1b6a2f7d8ab5b/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e78bccfbc01526808c4222ee49c1b6a2f7d8ab5b/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Farena.rs?ref=e78bccfbc01526808c4222ee49c1b6a2f7d8ab5b", "patch": "@@ -1,98 +0,0 @@\n-use crate::thir::*;\n-\n-macro_rules! declare_arena {\n-    ([], [$($a:tt $name:ident: $ty:ty,)*]) => {\n-        #[derive(Default)]\n-        pub struct Arena<'thir, 'tcx> {\n-            pub dropless: rustc_arena::DroplessArena,\n-            drop: rustc_arena::DropArena,\n-            $($name: rustc_arena::arena_for_type!($a[$ty]),)*\n-        }\n-\n-        pub trait ArenaAllocatable<'thir, 'tcx, T = Self>: Sized {\n-            fn allocate_on(self, arena: &'thir Arena<'thir, 'tcx>) -> &'thir mut Self;\n-            fn allocate_from_iter(\n-                arena: &'thir Arena<'thir, 'tcx>,\n-                iter: impl ::std::iter::IntoIterator<Item = Self>,\n-            ) -> &'thir mut [Self];\n-        }\n-\n-        impl<'thir, 'tcx, T: Copy> ArenaAllocatable<'thir, 'tcx, ()> for T {\n-            #[inline]\n-            fn allocate_on(self, arena: &'thir Arena<'thir, 'tcx>) -> &'thir mut Self {\n-                arena.dropless.alloc(self)\n-            }\n-            #[inline]\n-            fn allocate_from_iter(\n-                arena: &'thir Arena<'thir, 'tcx>,\n-                iter: impl ::std::iter::IntoIterator<Item = Self>,\n-            ) -> &'thir mut [Self] {\n-                arena.dropless.alloc_from_iter(iter)\n-            }\n-\n-        }\n-        $(\n-            impl<'thir, 'tcx> ArenaAllocatable<'thir, 'tcx, $ty> for $ty {\n-                #[inline]\n-                fn allocate_on(self, arena: &'thir Arena<'thir, 'tcx>) -> &'thir mut Self {\n-                    if !::std::mem::needs_drop::<Self>() {\n-                        return arena.dropless.alloc(self);\n-                    }\n-                    match rustc_arena::which_arena_for_type!($a[&arena.$name]) {\n-                        ::std::option::Option::<&rustc_arena::TypedArena<Self>>::Some(ty_arena) => {\n-                            ty_arena.alloc(self)\n-                        }\n-                        ::std::option::Option::None => unsafe { arena.drop.alloc(self) },\n-                    }\n-                }\n-\n-                #[inline]\n-                fn allocate_from_iter(\n-                    arena: &'thir Arena<'thir, 'tcx>,\n-                    iter: impl ::std::iter::IntoIterator<Item = Self>,\n-                ) -> &'thir mut [Self] {\n-                    if !::std::mem::needs_drop::<Self>() {\n-                        return arena.dropless.alloc_from_iter(iter);\n-                    }\n-                    match rustc_arena::which_arena_for_type!($a[&arena.$name]) {\n-                        ::std::option::Option::<&rustc_arena::TypedArena<Self>>::Some(ty_arena) => {\n-                            ty_arena.alloc_from_iter(iter)\n-                        }\n-                        ::std::option::Option::None => unsafe { arena.drop.alloc_from_iter(iter) },\n-                    }\n-                }\n-            }\n-        )*\n-\n-        impl<'thir, 'tcx> Arena<'thir, 'tcx> {\n-            #[inline]\n-            pub fn alloc<T: ArenaAllocatable<'thir, 'tcx, U>, U>(&'thir self, value: T) -> &'thir mut T {\n-                value.allocate_on(self)\n-            }\n-\n-            #[allow(dead_code)] // function is never used\n-            #[inline]\n-            pub fn alloc_slice<T: ::std::marker::Copy>(&'thir self, value: &[T]) -> &'thir mut [T] {\n-                if value.is_empty() {\n-                    return &mut [];\n-                }\n-                self.dropless.alloc_slice(value)\n-            }\n-\n-            pub fn alloc_from_iter<T: ArenaAllocatable<'thir, 'tcx, U>, U>(\n-                &'thir self,\n-                iter: impl ::std::iter::IntoIterator<Item = T>,\n-            ) -> &'thir mut [T] {\n-                T::allocate_from_iter(self, iter)\n-            }\n-        }\n-    }\n-}\n-\n-declare_arena!([], [\n-    [] arm: Arm<'thir, 'tcx>,\n-    [] expr: Expr<'thir, 'tcx>,\n-    [] field_expr: FieldExpr<'thir, 'tcx>,\n-    [few] inline_asm_operand: InlineAsmOperand<'thir, 'tcx>,\n-    [] stmt: Stmt<'thir, 'tcx>,\n-]);"}, {"sha": "b90f9abe33a3dd9c503650c981fcfa48ba27576b", "filename": "compiler/rustc_mir_build/src/thir/cx/block.rs", "status": "modified", "additions": 69, "deletions": 56, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/dc3eabd48700863075bd986a497fbe4f227aa33b/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc3eabd48700863075bd986a497fbe4f227aa33b/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fblock.rs?ref=dc3eabd48700863075bd986a497fbe4f227aa33b", "patch": "@@ -7,8 +7,8 @@ use rustc_middle::ty;\n \n use rustc_index::vec::Idx;\n \n-impl<'thir, 'tcx> Cx<'thir, 'tcx> {\n-    crate fn mirror_block(&mut self, block: &'tcx hir::Block<'tcx>) -> Block<'thir, 'tcx> {\n+impl<'tcx> Cx<'tcx> {\n+    crate fn mirror_block(&mut self, block: &'tcx hir::Block<'tcx>) -> Block {\n         // We have to eagerly lower the \"spine\" of the statements\n         // in order to get the lexical scoping correctly.\n         let stmts = self.mirror_stmts(block.hir_id.local_id, block.stmts);\n@@ -37,65 +37,78 @@ impl<'thir, 'tcx> Cx<'thir, 'tcx> {\n         &mut self,\n         block_id: hir::ItemLocalId,\n         stmts: &'tcx [hir::Stmt<'tcx>],\n-    ) -> &'thir [Stmt<'thir, 'tcx>] {\n-        self.arena.alloc_from_iter(stmts.iter().enumerate().filter_map(|(index, stmt)| {\n-            let hir_id = stmt.hir_id;\n-            let opt_dxn_ext = self.region_scope_tree.opt_destruction_scope(hir_id.local_id);\n-            match stmt.kind {\n-                hir::StmtKind::Expr(ref expr) | hir::StmtKind::Semi(ref expr) => Some(Stmt {\n-                    kind: StmtKind::Expr {\n-                        scope: region::Scope { id: hir_id.local_id, data: region::ScopeData::Node },\n-                        expr: self.mirror_expr(expr),\n-                    },\n-                    opt_destruction_scope: opt_dxn_ext,\n-                }),\n-                hir::StmtKind::Item(..) => {\n-                    // ignore for purposes of the MIR\n-                    None\n-                }\n-                hir::StmtKind::Local(ref local) => {\n-                    let remainder_scope = region::Scope {\n-                        id: block_id,\n-                        data: region::ScopeData::Remainder(region::FirstStatementIndex::new(index)),\n-                    };\n+    ) -> Box<[StmtId]> {\n+        stmts\n+            .iter()\n+            .enumerate()\n+            .filter_map(|(index, stmt)| {\n+                let hir_id = stmt.hir_id;\n+                let opt_dxn_ext = self.region_scope_tree.opt_destruction_scope(hir_id.local_id);\n+                match stmt.kind {\n+                    hir::StmtKind::Expr(ref expr) | hir::StmtKind::Semi(ref expr) => {\n+                        let stmt = Stmt {\n+                            kind: StmtKind::Expr {\n+                                scope: region::Scope {\n+                                    id: hir_id.local_id,\n+                                    data: region::ScopeData::Node,\n+                                },\n+                                expr: self.mirror_expr(expr),\n+                            },\n+                            opt_destruction_scope: opt_dxn_ext,\n+                        };\n+                        Some(self.thir.stmts.push(stmt))\n+                    }\n+                    hir::StmtKind::Item(..) => {\n+                        // ignore for purposes of the MIR\n+                        None\n+                    }\n+                    hir::StmtKind::Local(ref local) => {\n+                        let remainder_scope = region::Scope {\n+                            id: block_id,\n+                            data: region::ScopeData::Remainder(region::FirstStatementIndex::new(\n+                                index,\n+                            )),\n+                        };\n \n-                    let mut pattern = self.pattern_from_hir(local.pat);\n+                        let mut pattern = self.pattern_from_hir(local.pat);\n \n-                    if let Some(ty) = &local.ty {\n-                        if let Some(&user_ty) =\n-                            self.typeck_results.user_provided_types().get(ty.hir_id)\n-                        {\n-                            debug!(\"mirror_stmts: user_ty={:?}\", user_ty);\n-                            pattern = Pat {\n-                                ty: pattern.ty,\n-                                span: pattern.span,\n-                                kind: Box::new(PatKind::AscribeUserType {\n-                                    ascription: thir::pattern::Ascription {\n-                                        user_ty: PatTyProj::from_user_type(user_ty),\n-                                        user_ty_span: ty.span,\n-                                        variance: ty::Variance::Covariant,\n-                                    },\n-                                    subpattern: pattern,\n-                                }),\n-                            };\n+                        if let Some(ty) = &local.ty {\n+                            if let Some(&user_ty) =\n+                                self.typeck_results.user_provided_types().get(ty.hir_id)\n+                            {\n+                                debug!(\"mirror_stmts: user_ty={:?}\", user_ty);\n+                                pattern = Pat {\n+                                    ty: pattern.ty,\n+                                    span: pattern.span,\n+                                    kind: Box::new(PatKind::AscribeUserType {\n+                                        ascription: thir::pattern::Ascription {\n+                                            user_ty: PatTyProj::from_user_type(user_ty),\n+                                            user_ty_span: ty.span,\n+                                            variance: ty::Variance::Covariant,\n+                                        },\n+                                        subpattern: pattern,\n+                                    }),\n+                                };\n+                            }\n                         }\n-                    }\n \n-                    Some(Stmt {\n-                        kind: StmtKind::Let {\n-                            remainder_scope,\n-                            init_scope: region::Scope {\n-                                id: hir_id.local_id,\n-                                data: region::ScopeData::Node,\n+                        let stmt = Stmt {\n+                            kind: StmtKind::Let {\n+                                remainder_scope,\n+                                init_scope: region::Scope {\n+                                    id: hir_id.local_id,\n+                                    data: region::ScopeData::Node,\n+                                },\n+                                pattern,\n+                                initializer: local.init.map(|init| self.mirror_expr(init)),\n+                                lint_level: LintLevel::Explicit(local.hir_id),\n                             },\n-                            pattern,\n-                            initializer: local.init.map(|init| self.mirror_expr(init)),\n-                            lint_level: LintLevel::Explicit(local.hir_id),\n-                        },\n-                        opt_destruction_scope: opt_dxn_ext,\n-                    })\n+                            opt_destruction_scope: opt_dxn_ext,\n+                        };\n+                        Some(self.thir.stmts.push(stmt))\n+                    }\n                 }\n-            }\n-        }))\n+            })\n+            .collect()\n     }\n }"}, {"sha": "9cc7fbdf824d8f847cfb8436dc602b67103e922c", "filename": "compiler/rustc_mir_build/src/thir/cx/expr.rs", "status": "modified", "additions": 213, "deletions": 230, "changes": 443, "blob_url": "https://github.com/rust-lang/rust/blob/dc3eabd48700863075bd986a497fbe4f227aa33b/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc3eabd48700863075bd986a497fbe4f227aa33b/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs?ref=dc3eabd48700863075bd986a497fbe4f227aa33b", "patch": "@@ -17,34 +17,17 @@ use rustc_middle::ty::subst::{InternalSubsts, SubstsRef};\n use rustc_middle::ty::{self, AdtKind, Ty};\n use rustc_span::Span;\n \n-use std::iter;\n-\n-impl<'thir, 'tcx> Cx<'thir, 'tcx> {\n-    /// Mirrors and allocates a single [`hir::Expr`]. If you need to mirror a whole slice\n-    /// of expressions, prefer using [`mirror_exprs`].\n-    ///\n-    /// [`mirror_exprs`]: Self::mirror_exprs\n-    crate fn mirror_expr(&mut self, expr: &'tcx hir::Expr<'tcx>) -> &'thir Expr<'thir, 'tcx> {\n+impl<'tcx> Cx<'tcx> {\n+    crate fn mirror_expr(&mut self, expr: &'tcx hir::Expr<'tcx>) -> ExprId {\n         // `mirror_expr` is recursing very deep. Make sure the stack doesn't overflow.\n-        ensure_sufficient_stack(|| self.arena.alloc(self.mirror_expr_inner(expr)))\n+        ensure_sufficient_stack(|| self.mirror_expr_inner(expr))\n     }\n \n-    /// Mirrors and allocates a slice of [`hir::Expr`]s. They will be allocated as a\n-    /// contiguous sequence in memory.\n-    crate fn mirror_exprs(&mut self, exprs: &'tcx [hir::Expr<'tcx>]) -> &'thir [Expr<'thir, 'tcx>] {\n-        self.arena.alloc_from_iter(exprs.iter().map(|expr| self.mirror_expr_inner(expr)))\n+    crate fn mirror_exprs(&mut self, exprs: &'tcx [hir::Expr<'tcx>]) -> Box<[ExprId]> {\n+        exprs.iter().map(|expr| self.mirror_expr_inner(expr)).collect()\n     }\n \n-    /// Mirrors a [`hir::Expr`] without allocating it into the arena.\n-    /// This is a separate, private function so that [`mirror_expr`] and [`mirror_exprs`] can\n-    /// decide how to allocate this expression (alone or within a slice).\n-    ///\n-    /// [`mirror_expr`]: Self::mirror_expr\n-    /// [`mirror_exprs`]: Self::mirror_exprs\n-    pub(super) fn mirror_expr_inner(\n-        &mut self,\n-        hir_expr: &'tcx hir::Expr<'tcx>,\n-    ) -> Expr<'thir, 'tcx> {\n+    pub(super) fn mirror_expr_inner(&mut self, hir_expr: &'tcx hir::Expr<'tcx>) -> ExprId {\n         let temp_lifetime = self.region_scope_tree.temporary_scope(hir_expr.hir_id.local_id);\n         let expr_scope =\n             region::Scope { id: hir_expr.hir_id.local_id, data: region::ScopeData::Node };\n@@ -66,7 +49,7 @@ impl<'thir, 'tcx> Cx<'thir, 'tcx> {\n             span: hir_expr.span,\n             kind: ExprKind::Scope {\n                 region_scope: expr_scope,\n-                value: self.arena.alloc(expr),\n+                value: self.thir.exprs.push(expr),\n                 lint_level: LintLevel::Explicit(hir_expr.hir_id),\n             },\n         };\n@@ -81,22 +64,22 @@ impl<'thir, 'tcx> Cx<'thir, 'tcx> {\n                 span: hir_expr.span,\n                 kind: ExprKind::Scope {\n                     region_scope,\n-                    value: self.arena.alloc(expr),\n+                    value: self.thir.exprs.push(expr),\n                     lint_level: LintLevel::Inherited,\n                 },\n             };\n         }\n \n         // OK, all done!\n-        expr\n+        self.thir.exprs.push(expr)\n     }\n \n     fn apply_adjustment(\n         &mut self,\n         hir_expr: &'tcx hir::Expr<'tcx>,\n-        mut expr: Expr<'thir, 'tcx>,\n+        mut expr: Expr<'tcx>,\n         adjustment: &Adjustment<'tcx>,\n-    ) -> Expr<'thir, 'tcx> {\n+    ) -> Expr<'tcx> {\n         let Expr { temp_lifetime, mut span, .. } = expr;\n \n         // Adjust the span from the block, to the last expression of the\n@@ -109,10 +92,10 @@ impl<'thir, 'tcx> Cx<'thir, 'tcx> {\n         //      x\n         //   // ^ error message points at this expression.\n         // }\n-        let mut adjust_span = |expr: &mut Expr<'thir, 'tcx>| {\n+        let mut adjust_span = |expr: &mut Expr<'tcx>| {\n             if let ExprKind::Block { body } = &expr.kind {\n-                if let Some(ref last_expr) = body.expr {\n-                    span = last_expr.span;\n+                if let Some(last_expr) = body.expr {\n+                    span = self.thir[last_expr].span;\n                     expr.span = span;\n                 }\n             }\n@@ -121,13 +104,13 @@ impl<'thir, 'tcx> Cx<'thir, 'tcx> {\n         let kind = match adjustment.kind {\n             Adjust::Pointer(PointerCast::Unsize) => {\n                 adjust_span(&mut expr);\n-                ExprKind::Pointer { cast: PointerCast::Unsize, source: self.arena.alloc(expr) }\n+                ExprKind::Pointer { cast: PointerCast::Unsize, source: self.thir.exprs.push(expr) }\n             }\n-            Adjust::Pointer(cast) => ExprKind::Pointer { cast, source: self.arena.alloc(expr) },\n-            Adjust::NeverToAny => ExprKind::NeverToAny { source: self.arena.alloc(expr) },\n+            Adjust::Pointer(cast) => ExprKind::Pointer { cast, source: self.thir.exprs.push(expr) },\n+            Adjust::NeverToAny => ExprKind::NeverToAny { source: self.thir.exprs.push(expr) },\n             Adjust::Deref(None) => {\n                 adjust_span(&mut expr);\n-                ExprKind::Deref { arg: self.arena.alloc(expr) }\n+                ExprKind::Deref { arg: self.thir.exprs.push(expr) }\n             }\n             Adjust::Deref(Some(deref)) => {\n                 // We don't need to do call adjust_span here since\n@@ -142,30 +125,27 @@ impl<'thir, 'tcx> Cx<'thir, 'tcx> {\n                     span,\n                     kind: ExprKind::Borrow {\n                         borrow_kind: deref.mutbl.to_borrow_kind(),\n-                        arg: self.arena.alloc(expr),\n+                        arg: self.thir.exprs.push(expr),\n                     },\n                 };\n \n-                self.overloaded_place(\n-                    hir_expr,\n-                    adjustment.target,\n-                    Some(call),\n-                    self.arena.alloc_from_iter(iter::once(expr)),\n-                    deref.span,\n-                )\n-            }\n-            Adjust::Borrow(AutoBorrow::Ref(_, m)) => {\n-                ExprKind::Borrow { borrow_kind: m.to_borrow_kind(), arg: self.arena.alloc(expr) }\n+                let expr = box [self.thir.exprs.push(expr)];\n+\n+                self.overloaded_place(hir_expr, adjustment.target, Some(call), expr, deref.span)\n             }\n+            Adjust::Borrow(AutoBorrow::Ref(_, m)) => ExprKind::Borrow {\n+                borrow_kind: m.to_borrow_kind(),\n+                arg: self.thir.exprs.push(expr),\n+            },\n             Adjust::Borrow(AutoBorrow::RawPtr(mutability)) => {\n-                ExprKind::AddressOf { mutability, arg: self.arena.alloc(expr) }\n+                ExprKind::AddressOf { mutability, arg: self.thir.exprs.push(expr) }\n             }\n         };\n \n         Expr { temp_lifetime, ty: adjustment.target, span, kind }\n     }\n \n-    fn make_mirror_unadjusted(&mut self, expr: &'tcx hir::Expr<'tcx>) -> Expr<'thir, 'tcx> {\n+    fn make_mirror_unadjusted(&mut self, expr: &'tcx hir::Expr<'tcx>) -> Expr<'tcx> {\n         let expr_ty = self.typeck_results().expr_ty(expr);\n         let temp_lifetime = self.region_scope_tree.temporary_scope(expr.hir_id.local_id);\n \n@@ -177,7 +157,7 @@ impl<'thir, 'tcx> Cx<'thir, 'tcx> {\n                 let args = self.mirror_exprs(args);\n                 ExprKind::Call {\n                     ty: expr.ty,\n-                    fun: self.arena.alloc(expr),\n+                    fun: self.thir.exprs.push(expr),\n                     args,\n                     from_hir_call: true,\n                     fn_span,\n@@ -202,13 +182,12 @@ impl<'thir, 'tcx> Cx<'thir, 'tcx> {\n                         span: expr.span,\n                         kind: ExprKind::Tuple { fields: self.mirror_exprs(args) },\n                     };\n+                    let tupled_args = self.thir.exprs.push(tupled_args);\n \n                     ExprKind::Call {\n                         ty: method.ty,\n-                        fun: self.arena.alloc(method),\n-                        args: self\n-                            .arena\n-                            .alloc_from_iter(vec![self.mirror_expr_inner(fun), tupled_args]),\n+                        fun: self.thir.exprs.push(method),\n+                        args: box [self.mirror_expr(fun), tupled_args],\n                         from_hir_call: true,\n                         fn_span: expr.span,\n                     }\n@@ -238,10 +217,14 @@ impl<'thir, 'tcx> Cx<'thir, 'tcx> {\n                             });\n                         debug!(\"make_mirror_unadjusted: (call) user_ty={:?}\", user_ty);\n \n-                        let field_refs =\n-                            self.arena.alloc_from_iter(args.iter().enumerate().map(|(idx, e)| {\n-                                FieldExpr { name: Field::new(idx), expr: self.mirror_expr(e) }\n-                            }));\n+                        let field_refs = args\n+                            .iter()\n+                            .enumerate()\n+                            .map(|(idx, e)| FieldExpr {\n+                                name: Field::new(idx),\n+                                expr: self.mirror_expr(e),\n+                            })\n+                            .collect();\n                         ExprKind::Adt {\n                             adt_def,\n                             substs,\n@@ -278,9 +261,9 @@ impl<'thir, 'tcx> Cx<'thir, 'tcx> {\n \n             hir::ExprKind::AssignOp(op, ref lhs, ref rhs) => {\n                 if self.typeck_results().is_method_call(expr) {\n-                    let lhs = self.mirror_expr_inner(lhs);\n-                    let rhs = self.mirror_expr_inner(rhs);\n-                    self.overloaded_operator(expr, self.arena.alloc_from_iter(vec![lhs, rhs]))\n+                    let lhs = self.mirror_expr(lhs);\n+                    let rhs = self.mirror_expr(rhs);\n+                    self.overloaded_operator(expr, box [lhs, rhs])\n                 } else {\n                     ExprKind::AssignOp {\n                         op: bin_op(op.node),\n@@ -298,9 +281,9 @@ impl<'thir, 'tcx> Cx<'thir, 'tcx> {\n \n             hir::ExprKind::Binary(op, ref lhs, ref rhs) => {\n                 if self.typeck_results().is_method_call(expr) {\n-                    let lhs = self.mirror_expr_inner(lhs);\n-                    let rhs = self.mirror_expr_inner(rhs);\n-                    self.overloaded_operator(expr, self.arena.alloc_from_iter(vec![lhs, rhs]))\n+                    let lhs = self.mirror_expr(lhs);\n+                    let rhs = self.mirror_expr(rhs);\n+                    self.overloaded_operator(expr, box [lhs, rhs])\n                 } else {\n                     // FIXME overflow\n                     match op.node {\n@@ -329,48 +312,36 @@ impl<'thir, 'tcx> Cx<'thir, 'tcx> {\n \n             hir::ExprKind::Index(ref lhs, ref index) => {\n                 if self.typeck_results().is_method_call(expr) {\n-                    let lhs = self.mirror_expr_inner(lhs);\n-                    let index = self.mirror_expr_inner(index);\n-                    self.overloaded_place(\n-                        expr,\n-                        expr_ty,\n-                        None,\n-                        self.arena.alloc_from_iter(vec![lhs, index]),\n-                        expr.span,\n-                    )\n+                    let lhs = self.mirror_expr(lhs);\n+                    let index = self.mirror_expr(index);\n+                    self.overloaded_place(expr, expr_ty, None, box [lhs, index], expr.span)\n                 } else {\n                     ExprKind::Index { lhs: self.mirror_expr(lhs), index: self.mirror_expr(index) }\n                 }\n             }\n \n             hir::ExprKind::Unary(hir::UnOp::Deref, ref arg) => {\n                 if self.typeck_results().is_method_call(expr) {\n-                    let arg = self.mirror_expr_inner(arg);\n-                    self.overloaded_place(\n-                        expr,\n-                        expr_ty,\n-                        None,\n-                        self.arena.alloc_from_iter(iter::once(arg)),\n-                        expr.span,\n-                    )\n+                    let arg = self.mirror_expr(arg);\n+                    self.overloaded_place(expr, expr_ty, None, box [arg], expr.span)\n                 } else {\n                     ExprKind::Deref { arg: self.mirror_expr(arg) }\n                 }\n             }\n \n             hir::ExprKind::Unary(hir::UnOp::Not, ref arg) => {\n                 if self.typeck_results().is_method_call(expr) {\n-                    let arg = self.mirror_expr_inner(arg);\n-                    self.overloaded_operator(expr, self.arena.alloc_from_iter(iter::once(arg)))\n+                    let arg = self.mirror_expr(arg);\n+                    self.overloaded_operator(expr, box [arg])\n                 } else {\n                     ExprKind::Unary { op: UnOp::Not, arg: self.mirror_expr(arg) }\n                 }\n             }\n \n             hir::ExprKind::Unary(hir::UnOp::Neg, ref arg) => {\n                 if self.typeck_results().is_method_call(expr) {\n-                    let arg = self.mirror_expr_inner(arg);\n-                    self.overloaded_operator(expr, self.arena.alloc_from_iter(iter::once(arg)))\n+                    let arg = self.mirror_expr(arg);\n+                    self.overloaded_operator(expr, box [arg])\n                 } else if let hir::ExprKind::Lit(ref lit) = arg.kind {\n                     ExprKind::Literal {\n                         literal: self.const_eval_literal(&lit.node, expr_ty, lit.span, true),\n@@ -396,11 +367,10 @@ impl<'thir, 'tcx> Cx<'thir, 'tcx> {\n                             fields: self.field_refs(fields),\n                             base: base.as_ref().map(|base| FruInfo {\n                                 base: self.mirror_expr(base),\n-                                field_types: self.arena.alloc_from_iter(\n-                                    self.typeck_results().fru_field_types()[expr.hir_id]\n-                                        .iter()\n-                                        .cloned(),\n-                                ),\n+                                field_types: self.typeck_results().fru_field_types()[expr.hir_id]\n+                                    .iter()\n+                                    .copied()\n+                                    .collect(),\n                             }),\n                         }\n                     }\n@@ -447,21 +417,23 @@ impl<'thir, 'tcx> Cx<'thir, 'tcx> {\n                     }\n                 };\n \n-                let upvars = self.arena.alloc_from_iter(\n-                    self.typeck_results\n-                        .closure_min_captures_flattened(def_id)\n-                        .zip(substs.upvar_tys())\n-                        .map(|(captured_place, ty)| self.capture_upvar(expr, captured_place, ty)),\n-                );\n+                let upvars = self\n+                    .typeck_results\n+                    .closure_min_captures_flattened(def_id)\n+                    .zip(substs.upvar_tys())\n+                    .map(|(captured_place, ty)| {\n+                        let upvars = self.capture_upvar(expr, captured_place, ty);\n+                        self.thir.exprs.push(upvars)\n+                    })\n+                    .collect();\n \n                 // Convert the closure fake reads, if any, from hir `Place` to ExprRef\n                 let fake_reads = match self.typeck_results.closure_fake_reads.get(&def_id) {\n                     Some(fake_reads) => fake_reads\n                         .iter()\n                         .map(|(place, cause, hir_id)| {\n                             let expr = self.convert_captured_hir_place(expr, place.clone());\n-                            let expr_ref: &'thir Expr<'thir, 'tcx> = self.arena.alloc(expr);\n-                            (expr_ref, *cause, *hir_id)\n+                            (self.thir.exprs.push(expr), *cause, *hir_id)\n                         })\n                         .collect(),\n                     None => Vec::new(),\n@@ -477,99 +449,105 @@ impl<'thir, 'tcx> Cx<'thir, 'tcx> {\n \n             hir::ExprKind::InlineAsm(ref asm) => ExprKind::InlineAsm {\n                 template: asm.template,\n-                operands: self.arena.alloc_from_iter(asm.operands.iter().map(|(op, _op_sp)| {\n-                    match *op {\n-                        hir::InlineAsmOperand::In { reg, ref expr } => {\n-                            InlineAsmOperand::In { reg, expr: self.mirror_expr(expr) }\n-                        }\n-                        hir::InlineAsmOperand::Out { reg, late, ref expr } => {\n-                            InlineAsmOperand::Out {\n+                operands: asm\n+                    .operands\n+                    .iter()\n+                    .map(|(op, _op_sp)| {\n+                        match *op {\n+                            hir::InlineAsmOperand::In { reg, ref expr } => {\n+                                InlineAsmOperand::In { reg, expr: self.mirror_expr(expr) }\n+                            }\n+                            hir::InlineAsmOperand::Out { reg, late, ref expr } => {\n+                                InlineAsmOperand::Out {\n+                                    reg,\n+                                    late,\n+                                    expr: expr.as_ref().map(|expr| self.mirror_expr(expr)),\n+                                }\n+                            }\n+                            hir::InlineAsmOperand::InOut { reg, late, ref expr } => {\n+                                InlineAsmOperand::InOut { reg, late, expr: self.mirror_expr(expr) }\n+                            }\n+                            hir::InlineAsmOperand::SplitInOut {\n                                 reg,\n                                 late,\n-                                expr: expr.as_ref().map(|expr| self.mirror_expr(expr)),\n-                            }\n-                        }\n-                        hir::InlineAsmOperand::InOut { reg, late, ref expr } => {\n-                            InlineAsmOperand::InOut { reg, late, expr: self.mirror_expr(expr) }\n-                        }\n-                        hir::InlineAsmOperand::SplitInOut {\n-                            reg,\n-                            late,\n-                            ref in_expr,\n-                            ref out_expr,\n-                        } => InlineAsmOperand::SplitInOut {\n-                            reg,\n-                            late,\n-                            in_expr: self.mirror_expr(in_expr),\n-                            out_expr: out_expr.as_ref().map(|expr| self.mirror_expr(expr)),\n-                        },\n-                        hir::InlineAsmOperand::Const { ref anon_const } => {\n-                            let anon_const_def_id = self.tcx.hir().local_def_id(anon_const.hir_id);\n-                            let value = ty::Const::from_anon_const(self.tcx, anon_const_def_id);\n-                            let span = self.tcx.hir().span(anon_const.hir_id);\n+                                ref in_expr,\n+                                ref out_expr,\n+                            } => InlineAsmOperand::SplitInOut {\n+                                reg,\n+                                late,\n+                                in_expr: self.mirror_expr(in_expr),\n+                                out_expr: out_expr.as_ref().map(|expr| self.mirror_expr(expr)),\n+                            },\n+                            hir::InlineAsmOperand::Const { ref anon_const } => {\n+                                let anon_const_def_id =\n+                                    self.tcx.hir().local_def_id(anon_const.hir_id);\n+                                let value = ty::Const::from_anon_const(self.tcx, anon_const_def_id);\n+                                let span = self.tcx.hir().span(anon_const.hir_id);\n \n-                            InlineAsmOperand::Const { value, span }\n-                        }\n-                        hir::InlineAsmOperand::Sym { ref expr } => {\n-                            let qpath = match expr.kind {\n-                                hir::ExprKind::Path(ref qpath) => qpath,\n-                                _ => span_bug!(\n-                                    expr.span,\n-                                    \"asm `sym` operand should be a path, found {:?}\",\n-                                    expr.kind\n-                                ),\n-                            };\n-                            let temp_lifetime =\n-                                self.region_scope_tree.temporary_scope(expr.hir_id.local_id);\n-                            let res = self.typeck_results().qpath_res(qpath, expr.hir_id);\n-                            let ty;\n-                            match res {\n-                                Res::Def(DefKind::Fn, _) | Res::Def(DefKind::AssocFn, _) => {\n-                                    ty = self.typeck_results().node_type(expr.hir_id);\n-                                    let user_ty = self.user_substs_applied_to_res(expr.hir_id, res);\n-                                    InlineAsmOperand::SymFn {\n-                                        expr: self.arena.alloc(Expr {\n-                                            ty,\n-                                            temp_lifetime,\n-                                            span: expr.span,\n-                                            kind: ExprKind::Literal {\n-                                                literal: ty::Const::zero_sized(self.tcx, ty),\n-                                                user_ty,\n-                                                const_id: None,\n-                                            },\n-                                        }),\n+                                InlineAsmOperand::Const { value, span }\n+                            }\n+                            hir::InlineAsmOperand::Sym { ref expr } => {\n+                                let qpath = match expr.kind {\n+                                    hir::ExprKind::Path(ref qpath) => qpath,\n+                                    _ => span_bug!(\n+                                        expr.span,\n+                                        \"asm `sym` operand should be a path, found {:?}\",\n+                                        expr.kind\n+                                    ),\n+                                };\n+                                let temp_lifetime =\n+                                    self.region_scope_tree.temporary_scope(expr.hir_id.local_id);\n+                                let res = self.typeck_results().qpath_res(qpath, expr.hir_id);\n+                                let ty;\n+                                match res {\n+                                    Res::Def(DefKind::Fn, _) | Res::Def(DefKind::AssocFn, _) => {\n+                                        ty = self.typeck_results().node_type(expr.hir_id);\n+                                        let user_ty =\n+                                            self.user_substs_applied_to_res(expr.hir_id, res);\n+                                        InlineAsmOperand::SymFn {\n+                                            expr: self.thir.exprs.push(Expr {\n+                                                ty,\n+                                                temp_lifetime,\n+                                                span: expr.span,\n+                                                kind: ExprKind::Literal {\n+                                                    literal: ty::Const::zero_sized(self.tcx, ty),\n+                                                    user_ty,\n+                                                    const_id: None,\n+                                                },\n+                                            }),\n+                                        }\n                                     }\n-                                }\n \n-                                Res::Def(DefKind::Static, def_id) => {\n-                                    InlineAsmOperand::SymStatic { def_id }\n-                                }\n+                                    Res::Def(DefKind::Static, def_id) => {\n+                                        InlineAsmOperand::SymStatic { def_id }\n+                                    }\n \n-                                _ => {\n-                                    self.tcx.sess.span_err(\n-                                        expr.span,\n-                                        \"asm `sym` operand must point to a fn or static\",\n-                                    );\n-\n-                                    // Not a real fn, but we're not reaching codegen anyways...\n-                                    ty = self.tcx.ty_error();\n-                                    InlineAsmOperand::SymFn {\n-                                        expr: self.arena.alloc(Expr {\n-                                            ty,\n-                                            temp_lifetime,\n-                                            span: expr.span,\n-                                            kind: ExprKind::Literal {\n-                                                literal: ty::Const::zero_sized(self.tcx, ty),\n-                                                user_ty: None,\n-                                                const_id: None,\n-                                            },\n-                                        }),\n+                                    _ => {\n+                                        self.tcx.sess.span_err(\n+                                            expr.span,\n+                                            \"asm `sym` operand must point to a fn or static\",\n+                                        );\n+\n+                                        // Not a real fn, but we're not reaching codegen anyways...\n+                                        ty = self.tcx.ty_error();\n+                                        InlineAsmOperand::SymFn {\n+                                            expr: self.thir.exprs.push(Expr {\n+                                                ty,\n+                                                temp_lifetime,\n+                                                span: expr.span,\n+                                                kind: ExprKind::Literal {\n+                                                    literal: ty::Const::zero_sized(self.tcx, ty),\n+                                                    user_ty: None,\n+                                                    const_id: None,\n+                                                },\n+                                            }),\n+                                        }\n                                     }\n                                 }\n                             }\n                         }\n-                    }\n-                })),\n+                    })\n+                    .collect(),\n                 options: asm.options,\n                 line_spans: asm.line_spans,\n             },\n@@ -616,13 +594,13 @@ impl<'thir, 'tcx> Cx<'thir, 'tcx> {\n             },\n             hir::ExprKind::Match(ref discr, ref arms, _) => ExprKind::Match {\n                 scrutinee: self.mirror_expr(discr),\n-                arms: self.arena.alloc_from_iter(arms.iter().map(|a| self.convert_arm(a))),\n+                arms: arms.iter().map(|a| self.convert_arm(a)).collect(),\n             },\n             hir::ExprKind::Loop(ref body, ..) => {\n                 let block_ty = self.typeck_results().node_type(body.hir_id);\n                 let temp_lifetime = self.region_scope_tree.temporary_scope(body.hir_id.local_id);\n                 let block = self.mirror_block(body);\n-                let body = self.arena.alloc(Expr {\n+                let body = self.thir.exprs.push(Expr {\n                     ty: block_ty,\n                     temp_lifetime,\n                     span: block.span,\n@@ -692,35 +670,34 @@ impl<'thir, 'tcx> Cx<'thir, 'tcx> {\n                     };\n \n                     let source = if let Some((did, offset, var_ty)) = var {\n-                        let mk_const = |literal| {\n-                            self.arena.alloc(Expr {\n-                                temp_lifetime,\n-                                ty: var_ty,\n-                                span: expr.span,\n-                                kind: ExprKind::Literal { literal, user_ty: None, const_id: None },\n-                            })\n+                        let mk_const = |literal| Expr {\n+                            temp_lifetime,\n+                            ty: var_ty,\n+                            span: expr.span,\n+                            kind: ExprKind::Literal { literal, user_ty: None, const_id: None },\n                         };\n-                        let offset = mk_const(ty::Const::from_bits(\n+                        let offset = self.thir.exprs.push(mk_const(ty::Const::from_bits(\n                             self.tcx,\n                             offset as u128,\n                             self.param_env.and(var_ty),\n-                        ));\n+                        )));\n                         match did {\n                             Some(did) => {\n                                 // in case we are offsetting from a computed discriminant\n                                 // and not the beginning of discriminants (which is always `0`)\n                                 let substs = InternalSubsts::identity_for_item(self.tcx(), did);\n-                                let lhs = mk_const(self.tcx().mk_const(ty::Const {\n+                                let lhs = ty::Const {\n                                     val: ty::ConstKind::Unevaluated(ty::Unevaluated {\n                                         def: ty::WithOptConstParam::unknown(did),\n                                         substs,\n                                         promoted: None,\n                                     }),\n                                     ty: var_ty,\n-                                }));\n+                                };\n+                                let lhs = self.thir.exprs.push(mk_const(self.tcx().mk_const(lhs)));\n                                 let bin =\n                                     ExprKind::Binary { op: BinOp::Add, lhs: lhs, rhs: offset };\n-                                self.arena.alloc(Expr {\n+                                self.thir.exprs.push(Expr {\n                                     temp_lifetime,\n                                     ty: var_ty,\n                                     span: expr.span,\n@@ -739,7 +716,7 @@ impl<'thir, 'tcx> Cx<'thir, 'tcx> {\n                 if let Some(user_ty) = user_ty {\n                     // NOTE: Creating a new Expr and wrapping a Cast inside of it may be\n                     //       inefficient, revisit this when performance becomes an issue.\n-                    let cast_expr = self.arena.alloc(Expr {\n+                    let cast_expr = self.thir.exprs.push(Expr {\n                         temp_lifetime,\n                         ty: expr_ty,\n                         span: expr.span,\n@@ -819,7 +796,7 @@ impl<'thir, 'tcx> Cx<'thir, 'tcx> {\n         expr: &hir::Expr<'_>,\n         span: Span,\n         overloaded_callee: Option<(DefId, SubstsRef<'tcx>)>,\n-    ) -> Expr<'thir, 'tcx> {\n+    ) -> Expr<'tcx> {\n         let temp_lifetime = self.region_scope_tree.temporary_scope(expr.hir_id.local_id);\n         let (def_id, substs, user_ty) = match overloaded_callee {\n             Some((def_id, substs)) => (def_id, substs, None),\n@@ -846,8 +823,8 @@ impl<'thir, 'tcx> Cx<'thir, 'tcx> {\n         }\n     }\n \n-    fn convert_arm(&mut self, arm: &'tcx hir::Arm<'tcx>) -> Arm<'thir, 'tcx> {\n-        Arm {\n+    fn convert_arm(&mut self, arm: &'tcx hir::Arm<'tcx>) -> ArmId {\n+        let arm = Arm {\n             pattern: self.pattern_from_hir(&arm.pat),\n             guard: arm.guard.as_ref().map(|g| match g {\n                 hir::Guard::If(ref e) => Guard::If(self.mirror_expr(e)),\n@@ -859,14 +836,11 @@ impl<'thir, 'tcx> Cx<'thir, 'tcx> {\n             lint_level: LintLevel::Explicit(arm.hir_id),\n             scope: region::Scope { id: arm.hir_id.local_id, data: region::ScopeData::Node },\n             span: arm.span,\n-        }\n+        };\n+        self.thir.arms.push(arm)\n     }\n \n-    fn convert_path_expr(\n-        &mut self,\n-        expr: &'tcx hir::Expr<'tcx>,\n-        res: Res,\n-    ) -> ExprKind<'thir, 'tcx> {\n+    fn convert_path_expr(&mut self, expr: &'tcx hir::Expr<'tcx>, res: Res) -> ExprKind<'tcx> {\n         let substs = self.typeck_results().node_substs(expr.hir_id);\n         match res {\n             // A regular function, constructor function or a constant.\n@@ -934,7 +908,7 @@ impl<'thir, 'tcx> Cx<'thir, 'tcx> {\n                         variant_index: adt_def.variant_index_with_ctor_id(def_id),\n                         substs,\n                         user_ty: user_provided_type,\n-                        fields: self.arena.alloc_from_iter(iter::empty()),\n+                        fields: box [],\n                         base: None,\n                     },\n                     _ => bug!(\"unexpected ty: {:?}\", ty),\n@@ -956,7 +930,7 @@ impl<'thir, 'tcx> Cx<'thir, 'tcx> {\n                     }\n                 };\n                 ExprKind::Deref {\n-                    arg: self.arena.alloc(Expr { ty, temp_lifetime, span: expr.span, kind }),\n+                    arg: self.thir.exprs.push(Expr { ty, temp_lifetime, span: expr.span, kind }),\n                 }\n             }\n \n@@ -966,7 +940,7 @@ impl<'thir, 'tcx> Cx<'thir, 'tcx> {\n         }\n     }\n \n-    fn convert_var(&mut self, var_hir_id: hir::HirId) -> ExprKind<'thir, 'tcx> {\n+    fn convert_var(&mut self, var_hir_id: hir::HirId) -> ExprKind<'tcx> {\n         // We want upvars here not captures.\n         // Captures will be handled in MIR.\n         let is_upvar = self\n@@ -989,28 +963,35 @@ impl<'thir, 'tcx> Cx<'thir, 'tcx> {\n     fn overloaded_operator(\n         &mut self,\n         expr: &'tcx hir::Expr<'tcx>,\n-        args: &'thir [Expr<'thir, 'tcx>],\n-    ) -> ExprKind<'thir, 'tcx> {\n-        let fun = self.arena.alloc(self.method_callee(expr, expr.span, None));\n-        ExprKind::Call { ty: fun.ty, fun, args, from_hir_call: false, fn_span: expr.span }\n+        args: Box<[ExprId]>,\n+    ) -> ExprKind<'tcx> {\n+        let fun = self.method_callee(expr, expr.span, None);\n+        let fun = self.thir.exprs.push(fun);\n+        ExprKind::Call {\n+            ty: self.thir[fun].ty,\n+            fun,\n+            args,\n+            from_hir_call: false,\n+            fn_span: expr.span,\n+        }\n     }\n \n     fn overloaded_place(\n         &mut self,\n         expr: &'tcx hir::Expr<'tcx>,\n         place_ty: Ty<'tcx>,\n         overloaded_callee: Option<(DefId, SubstsRef<'tcx>)>,\n-        args: &'thir [Expr<'thir, 'tcx>],\n+        args: Box<[ExprId]>,\n         span: Span,\n-    ) -> ExprKind<'thir, 'tcx> {\n+    ) -> ExprKind<'tcx> {\n         // For an overloaded *x or x[y] expression of type T, the method\n         // call returns an &T and we must add the deref so that the types\n         // line up (this is because `*x` and `x[y]` represent places):\n \n         // Reconstruct the output assuming it's a reference with the\n         // same region and mutability as the receiver. This holds for\n         // `Deref(Mut)::Deref(_mut)` and `Index(Mut)::index(_mut)`.\n-        let (region, mutbl) = match *args[0].ty.kind() {\n+        let (region, mutbl) = match *self.thir[args[0]].ty.kind() {\n             ty::Ref(region, _, mutbl) => (region, mutbl),\n             _ => span_bug!(span, \"overloaded_place: receiver is not a reference\"),\n         };\n@@ -1019,12 +1000,14 @@ impl<'thir, 'tcx> Cx<'thir, 'tcx> {\n         // construct the complete expression `foo()` for the overloaded call,\n         // which will yield the &T type\n         let temp_lifetime = self.region_scope_tree.temporary_scope(expr.hir_id.local_id);\n-        let fun = self.arena.alloc(self.method_callee(expr, span, overloaded_callee));\n-        let ref_expr = self.arena.alloc(Expr {\n+        let fun = self.method_callee(expr, span, overloaded_callee);\n+        let fun = self.thir.exprs.push(fun);\n+        let fun_ty = self.thir[fun].ty;\n+        let ref_expr = self.thir.exprs.push(Expr {\n             temp_lifetime,\n             ty: ref_ty,\n             span,\n-            kind: ExprKind::Call { ty: fun.ty, fun, args, from_hir_call: false, fn_span: span },\n+            kind: ExprKind::Call { ty: fun_ty, fun, args, from_hir_call: false, fn_span: span },\n         });\n \n         // construct and return a deref wrapper `*foo()`\n@@ -1035,7 +1018,7 @@ impl<'thir, 'tcx> Cx<'thir, 'tcx> {\n         &mut self,\n         closure_expr: &'tcx hir::Expr<'tcx>,\n         place: HirPlace<'tcx>,\n-    ) -> Expr<'thir, 'tcx> {\n+    ) -> Expr<'tcx> {\n         let temp_lifetime = self.region_scope_tree.temporary_scope(closure_expr.hir_id.local_id);\n         let var_ty = place.base_ty;\n \n@@ -1059,13 +1042,13 @@ impl<'thir, 'tcx> Cx<'thir, 'tcx> {\n         for proj in place.projections.iter() {\n             let kind = match proj.kind {\n                 HirProjectionKind::Deref => {\n-                    ExprKind::Deref { arg: self.arena.alloc(captured_place_expr) }\n+                    ExprKind::Deref { arg: self.thir.exprs.push(captured_place_expr) }\n                 }\n                 HirProjectionKind::Field(field, ..) => {\n                     // Variant index will always be 0, because for multi-variant\n                     // enums, we capture the enum entirely.\n                     ExprKind::Field {\n-                        lhs: self.arena.alloc(captured_place_expr),\n+                        lhs: self.thir.exprs.push(captured_place_expr),\n                         name: Field::new(field as usize),\n                     }\n                 }\n@@ -1087,7 +1070,7 @@ impl<'thir, 'tcx> Cx<'thir, 'tcx> {\n         closure_expr: &'tcx hir::Expr<'tcx>,\n         captured_place: &'tcx ty::CapturedPlace<'tcx>,\n         upvar_ty: Ty<'tcx>,\n-    ) -> Expr<'thir, 'tcx> {\n+    ) -> Expr<'tcx> {\n         let upvar_capture = captured_place.info.capture_kind;\n         let captured_place_expr =\n             self.convert_captured_hir_place(closure_expr, captured_place.place.clone());\n@@ -1107,22 +1090,22 @@ impl<'thir, 'tcx> Cx<'thir, 'tcx> {\n                     span: closure_expr.span,\n                     kind: ExprKind::Borrow {\n                         borrow_kind,\n-                        arg: self.arena.alloc(captured_place_expr),\n+                        arg: self.thir.exprs.push(captured_place_expr),\n                     },\n                 }\n             }\n         }\n     }\n \n     /// Converts a list of named fields (i.e., for struct-like struct/enum ADTs) into FieldExpr.\n-    fn field_refs(\n-        &mut self,\n-        fields: &'tcx [hir::ExprField<'tcx>],\n-    ) -> &'thir [FieldExpr<'thir, 'tcx>] {\n-        self.arena.alloc_from_iter(fields.iter().map(|field| FieldExpr {\n-            name: Field::new(self.tcx.field_index(field.hir_id, self.typeck_results)),\n-            expr: self.mirror_expr(field.expr),\n-        }))\n+    fn field_refs(&mut self, fields: &'tcx [hir::ExprField<'tcx>]) -> Box<[FieldExpr]> {\n+        fields\n+            .iter()\n+            .map(|field| FieldExpr {\n+                name: Field::new(self.tcx.field_index(field.hir_id, self.typeck_results)),\n+                expr: self.mirror_expr(field.expr),\n+            })\n+            .collect()\n     }\n }\n "}, {"sha": "aad6319e404344bf98c0424cf5a6910d4a0a108d", "filename": "compiler/rustc_mir_build/src/thir/cx/mod.rs", "status": "modified", "additions": 11, "deletions": 15, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/dc3eabd48700863075bd986a497fbe4f227aa33b/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc3eabd48700863075bd986a497fbe4f227aa33b/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fmod.rs?ref=dc3eabd48700863075bd986a497fbe4f227aa33b", "patch": "@@ -2,7 +2,6 @@\n //! structures into the THIR. The `builder` is generally ignorant of the tcx,\n //! etc., and instead goes through the `Cx` for most of its work.\n \n-use crate::thir::arena::Arena;\n use crate::thir::util::UserAnnotatedTyHelpers;\n use crate::thir::*;\n \n@@ -14,18 +13,19 @@ use rustc_middle::middle::region;\n use rustc_middle::mir::interpret::{LitToConstError, LitToConstInput};\n use rustc_middle::ty::{self, Ty, TyCtxt};\n \n-pub fn build_thir<'thir, 'tcx>(\n+pub fn build_thir<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     owner_def: ty::WithOptConstParam<LocalDefId>,\n-    arena: &'thir Arena<'thir, 'tcx>,\n     expr: &'tcx hir::Expr<'tcx>,\n-) -> &'thir Expr<'thir, 'tcx> {\n-    Cx::new(tcx, owner_def, &arena).mirror_expr(expr)\n+) -> (Thir<'tcx>, ExprId) {\n+    let mut cx = Cx::new(tcx, owner_def);\n+    let expr = cx.mirror_expr(expr);\n+    (cx.thir, expr)\n }\n \n-struct Cx<'thir, 'tcx> {\n+struct Cx<'tcx> {\n     tcx: TyCtxt<'tcx>,\n-    arena: &'thir Arena<'thir, 'tcx>,\n+    thir: Thir<'tcx>,\n \n     crate param_env: ty::ParamEnv<'tcx>,\n \n@@ -36,16 +36,12 @@ struct Cx<'thir, 'tcx> {\n     body_owner: DefId,\n }\n \n-impl<'thir, 'tcx> Cx<'thir, 'tcx> {\n-    fn new(\n-        tcx: TyCtxt<'tcx>,\n-        def: ty::WithOptConstParam<LocalDefId>,\n-        arena: &'thir Arena<'thir, 'tcx>,\n-    ) -> Cx<'thir, 'tcx> {\n+impl<'tcx> Cx<'tcx> {\n+    fn new(tcx: TyCtxt<'tcx>, def: ty::WithOptConstParam<LocalDefId>) -> Cx<'tcx> {\n         let typeck_results = tcx.typeck_opt_const_arg(def);\n         Cx {\n             tcx,\n-            arena,\n+            thir: Thir::new(),\n             param_env: tcx.param_env(def.did),\n             region_scope_tree: tcx.region_scope_tree(def.did),\n             typeck_results,\n@@ -87,7 +83,7 @@ impl<'thir, 'tcx> Cx<'thir, 'tcx> {\n     }\n }\n \n-impl<'tcx> UserAnnotatedTyHelpers<'tcx> for Cx<'_, 'tcx> {\n+impl<'tcx> UserAnnotatedTyHelpers<'tcx> for Cx<'tcx> {\n     fn tcx(&self) -> TyCtxt<'tcx> {\n         self.tcx\n     }"}, {"sha": "d188d17dd56a5ce78559847c7882fc1365078a21", "filename": "compiler/rustc_mir_build/src/thir/mod.rs", "status": "modified", "additions": 133, "deletions": 79, "changes": 212, "blob_url": "https://github.com/rust-lang/rust/blob/dc3eabd48700863075bd986a497fbe4f227aa33b/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc3eabd48700863075bd986a497fbe4f227aa33b/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fmod.rs?ref=dc3eabd48700863075bd986a497fbe4f227aa33b", "patch": "@@ -7,6 +7,8 @@\n use rustc_ast::{InlineAsmOptions, InlineAsmTemplatePiece};\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n+use rustc_index::newtype_index;\n+use rustc_index::vec::IndexVec;\n use rustc_middle::infer::canonical::Canonical;\n use rustc_middle::middle::region;\n use rustc_middle::mir::{BinOp, BorrowKind, FakeReadCause, Field, UnOp};\n@@ -17,6 +19,8 @@ use rustc_span::Span;\n use rustc_target::abi::VariantIdx;\n use rustc_target::asm::InlineAsmRegOrRegClass;\n \n+use std::ops::Index;\n+\n crate mod constant;\n \n crate mod cx;\n@@ -25,26 +29,76 @@ pub use cx::build_thir;\n crate mod pattern;\n pub use self::pattern::{Ascription, BindingMode, FieldPat, Pat, PatKind, PatRange, PatTyProj};\n \n-mod arena;\n-pub use arena::Arena;\n-\n mod util;\n pub mod visit;\n \n+newtype_index! {\n+    pub struct ArmId {\n+        DEBUG_FORMAT = \"a{}\"\n+    }\n+}\n+\n+newtype_index! {\n+    pub struct ExprId {\n+        DEBUG_FORMAT = \"e{}\"\n+    }\n+}\n+\n+newtype_index! {\n+    pub struct StmtId {\n+        DEBUG_FORMAT = \"s{}\"\n+    }\n+}\n+\n+macro_rules! thir_with_elements {\n+    ($($name:ident: $id:ty => $value:ty,)*) => {\n+        pub struct Thir<'tcx> {\n+            $(\n+                $name: IndexVec<$id, $value>,\n+            )*\n+        }\n+\n+        impl<'tcx> Thir<'tcx> {\n+            fn new() -> Thir<'tcx> {\n+                Thir {\n+                    $(\n+                        $name: IndexVec::new(),\n+                    )*\n+                }\n+            }\n+        }\n+\n+        $(\n+            impl<'tcx> Index<$id> for Thir<'tcx> {\n+                type Output = $value;\n+                fn index(&self, index: $id) -> &Self::Output {\n+                    &self.$name[index]\n+                }\n+            }\n+        )*\n+    }\n+}\n+\n+thir_with_elements! {\n+    arms: ArmId => Arm<'tcx>,\n+    exprs: ExprId => Expr<'tcx>,\n+    stmts: StmtId => Stmt<'tcx>,\n+}\n+\n #[derive(Copy, Clone, Debug)]\n pub enum LintLevel {\n     Inherited,\n     Explicit(hir::HirId),\n }\n \n #[derive(Debug)]\n-pub struct Block<'thir, 'tcx> {\n+pub struct Block {\n     pub targeted_by_break: bool,\n     pub region_scope: region::Scope,\n     pub opt_destruction_scope: Option<region::Scope>,\n     pub span: Span,\n-    pub stmts: &'thir [Stmt<'thir, 'tcx>],\n-    pub expr: Option<&'thir Expr<'thir, 'tcx>>,\n+    pub stmts: Box<[StmtId]>,\n+    pub expr: Option<ExprId>,\n     pub safety_mode: BlockSafety,\n }\n \n@@ -57,19 +111,19 @@ pub enum BlockSafety {\n }\n \n #[derive(Debug)]\n-pub struct Stmt<'thir, 'tcx> {\n-    pub kind: StmtKind<'thir, 'tcx>,\n+pub struct Stmt<'tcx> {\n+    pub kind: StmtKind<'tcx>,\n     pub opt_destruction_scope: Option<region::Scope>,\n }\n \n #[derive(Debug)]\n-pub enum StmtKind<'thir, 'tcx> {\n+pub enum StmtKind<'tcx> {\n     Expr {\n         /// scope for this statement; may be used as lifetime of temporaries\n         scope: region::Scope,\n \n         /// expression being evaluated in this statement\n-        expr: &'thir Expr<'thir, 'tcx>,\n+        expr: ExprId,\n     },\n \n     Let {\n@@ -87,7 +141,7 @@ pub enum StmtKind<'thir, 'tcx> {\n         pattern: Pat<'tcx>,\n \n         /// let pat: ty = <INIT> ...\n-        initializer: Option<&'thir Expr<'thir, 'tcx>>,\n+        initializer: Option<ExprId>,\n \n         /// the lint level for this let-statement\n         lint_level: LintLevel,\n@@ -96,12 +150,12 @@ pub enum StmtKind<'thir, 'tcx> {\n \n // `Expr` is used a lot. Make sure it doesn't unintentionally get bigger.\n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n-rustc_data_structures::static_assert_size!(Expr<'_, '_>, 144);\n+rustc_data_structures::static_assert_size!(Expr<'_>, 144);\n \n /// The Thir trait implementor lowers their expressions (`&'tcx H::Expr`)\n /// into instances of this `Expr` enum. This lowering can be done\n /// basically as lazily or as eagerly as desired: every recursive\n-/// reference to an expression in this enum is an `&'thir Expr<'thir, 'tcx>`, which\n+/// reference to an expression in this enum is an `ExprId`, which\n /// may in turn be another instance of this enum (boxed), or else an\n /// unlowered `&'tcx H::Expr`. Note that instances of `Expr` are very\n /// short-lived. They are created by `Thir::to_expr`, analyzed and\n@@ -113,7 +167,7 @@ rustc_data_structures::static_assert_size!(Expr<'_, '_>, 144);\n /// example, method calls and overloaded operators are absent: they are\n /// expected to be converted into `Expr::Call` instances.\n #[derive(Debug)]\n-pub struct Expr<'thir, 'tcx> {\n+pub struct Expr<'tcx> {\n     /// type of this expression\n     pub ty: Ty<'tcx>,\n \n@@ -125,28 +179,28 @@ pub struct Expr<'thir, 'tcx> {\n     pub span: Span,\n \n     /// kind of expression\n-    pub kind: ExprKind<'thir, 'tcx>,\n+    pub kind: ExprKind<'tcx>,\n }\n \n #[derive(Debug)]\n-pub enum ExprKind<'thir, 'tcx> {\n+pub enum ExprKind<'tcx> {\n     Scope {\n         region_scope: region::Scope,\n         lint_level: LintLevel,\n-        value: &'thir Expr<'thir, 'tcx>,\n+        value: ExprId,\n     },\n     Box {\n-        value: &'thir Expr<'thir, 'tcx>,\n+        value: ExprId,\n     },\n     If {\n-        cond: &'thir Expr<'thir, 'tcx>,\n-        then: &'thir Expr<'thir, 'tcx>,\n-        else_opt: Option<&'thir Expr<'thir, 'tcx>>,\n+        cond: ExprId,\n+        then: ExprId,\n+        else_opt: Option<ExprId>,\n     },\n     Call {\n         ty: Ty<'tcx>,\n-        fun: &'thir Expr<'thir, 'tcx>,\n-        args: &'thir [Expr<'thir, 'tcx>],\n+        fun: ExprId,\n+        args: Box<[ExprId]>,\n         /// Whether this is from a call in HIR, rather than from an overloaded\n         /// operator. `true` for overloaded function call.\n         from_hir_call: bool,\n@@ -155,62 +209,62 @@ pub enum ExprKind<'thir, 'tcx> {\n         fn_span: Span,\n     },\n     Deref {\n-        arg: &'thir Expr<'thir, 'tcx>,\n+        arg: ExprId,\n     }, // NOT overloaded!\n     Binary {\n         op: BinOp,\n-        lhs: &'thir Expr<'thir, 'tcx>,\n-        rhs: &'thir Expr<'thir, 'tcx>,\n+        lhs: ExprId,\n+        rhs: ExprId,\n     }, // NOT overloaded!\n     LogicalOp {\n         op: LogicalOp,\n-        lhs: &'thir Expr<'thir, 'tcx>,\n-        rhs: &'thir Expr<'thir, 'tcx>,\n+        lhs: ExprId,\n+        rhs: ExprId,\n     }, // NOT overloaded!\n     // LogicalOp is distinct from BinaryOp because of lazy evaluation of the operands.\n     Unary {\n         op: UnOp,\n-        arg: &'thir Expr<'thir, 'tcx>,\n+        arg: ExprId,\n     }, // NOT overloaded!\n     Cast {\n-        source: &'thir Expr<'thir, 'tcx>,\n+        source: ExprId,\n     },\n     Use {\n-        source: &'thir Expr<'thir, 'tcx>,\n+        source: ExprId,\n     }, // Use a lexpr to get a vexpr.\n     NeverToAny {\n-        source: &'thir Expr<'thir, 'tcx>,\n+        source: ExprId,\n     },\n     Pointer {\n         cast: PointerCast,\n-        source: &'thir Expr<'thir, 'tcx>,\n+        source: ExprId,\n     },\n     Loop {\n-        body: &'thir Expr<'thir, 'tcx>,\n+        body: ExprId,\n     },\n     Match {\n-        scrutinee: &'thir Expr<'thir, 'tcx>,\n-        arms: &'thir [Arm<'thir, 'tcx>],\n+        scrutinee: ExprId,\n+        arms: Box<[ArmId]>,\n     },\n     Block {\n-        body: Block<'thir, 'tcx>,\n+        body: Block,\n     },\n     Assign {\n-        lhs: &'thir Expr<'thir, 'tcx>,\n-        rhs: &'thir Expr<'thir, 'tcx>,\n+        lhs: ExprId,\n+        rhs: ExprId,\n     },\n     AssignOp {\n         op: BinOp,\n-        lhs: &'thir Expr<'thir, 'tcx>,\n-        rhs: &'thir Expr<'thir, 'tcx>,\n+        lhs: ExprId,\n+        rhs: ExprId,\n     },\n     Field {\n-        lhs: &'thir Expr<'thir, 'tcx>,\n+        lhs: ExprId,\n         name: Field,\n     },\n     Index {\n-        lhs: &'thir Expr<'thir, 'tcx>,\n-        index: &'thir Expr<'thir, 'tcx>,\n+        lhs: ExprId,\n+        index: ExprId,\n     },\n     VarRef {\n         id: hir::HirId,\n@@ -225,35 +279,35 @@ pub enum ExprKind<'thir, 'tcx> {\n     },\n     Borrow {\n         borrow_kind: BorrowKind,\n-        arg: &'thir Expr<'thir, 'tcx>,\n+        arg: ExprId,\n     },\n     /// A `&raw [const|mut] $place_expr` raw borrow resulting in type `*[const|mut] T`.\n     AddressOf {\n         mutability: hir::Mutability,\n-        arg: &'thir Expr<'thir, 'tcx>,\n+        arg: ExprId,\n     },\n     Break {\n         label: region::Scope,\n-        value: Option<&'thir Expr<'thir, 'tcx>>,\n+        value: Option<ExprId>,\n     },\n     Continue {\n         label: region::Scope,\n     },\n     Return {\n-        value: Option<&'thir Expr<'thir, 'tcx>>,\n+        value: Option<ExprId>,\n     },\n     ConstBlock {\n         value: &'tcx Const<'tcx>,\n     },\n     Repeat {\n-        value: &'thir Expr<'thir, 'tcx>,\n+        value: ExprId,\n         count: &'tcx Const<'tcx>,\n     },\n     Array {\n-        fields: &'thir [Expr<'thir, 'tcx>],\n+        fields: Box<[ExprId]>,\n     },\n     Tuple {\n-        fields: &'thir [Expr<'thir, 'tcx>],\n+        fields: Box<[ExprId]>,\n     },\n     Adt {\n         adt_def: &'tcx AdtDef,\n@@ -264,25 +318,25 @@ pub enum ExprKind<'thir, 'tcx> {\n         /// Bar::<T> { ... }`.\n         user_ty: Option<Canonical<'tcx, UserType<'tcx>>>,\n \n-        fields: &'thir [FieldExpr<'thir, 'tcx>],\n-        base: Option<FruInfo<'thir, 'tcx>>,\n+        fields: Box<[FieldExpr]>,\n+        base: Option<FruInfo<'tcx>>,\n     },\n     PlaceTypeAscription {\n-        source: &'thir Expr<'thir, 'tcx>,\n+        source: ExprId,\n         /// Type that the user gave to this expression\n         user_ty: Option<Canonical<'tcx, UserType<'tcx>>>,\n     },\n     ValueTypeAscription {\n-        source: &'thir Expr<'thir, 'tcx>,\n+        source: ExprId,\n         /// Type that the user gave to this expression\n         user_ty: Option<Canonical<'tcx, UserType<'tcx>>>,\n     },\n     Closure {\n         closure_id: DefId,\n         substs: UpvarSubsts<'tcx>,\n-        upvars: &'thir [Expr<'thir, 'tcx>],\n+        upvars: Box<[ExprId]>,\n         movability: Option<hir::Movability>,\n-        fake_reads: Vec<(&'thir Expr<'thir, 'tcx>, FakeReadCause, hir::HirId)>,\n+        fake_reads: Vec<(ExprId, FakeReadCause, hir::HirId)>,\n     },\n     Literal {\n         literal: &'tcx Const<'tcx>,\n@@ -302,48 +356,48 @@ pub enum ExprKind<'thir, 'tcx> {\n     },\n     InlineAsm {\n         template: &'tcx [InlineAsmTemplatePiece],\n-        operands: &'thir [InlineAsmOperand<'thir, 'tcx>],\n+        operands: Box<[InlineAsmOperand<'tcx>]>,\n         options: InlineAsmOptions,\n         line_spans: &'tcx [Span],\n     },\n     /// An expression taking a reference to a thread local.\n     ThreadLocalRef(DefId),\n     LlvmInlineAsm {\n         asm: &'tcx hir::LlvmInlineAsmInner,\n-        outputs: &'thir [Expr<'thir, 'tcx>],\n-        inputs: &'thir [Expr<'thir, 'tcx>],\n+        outputs: Box<[ExprId]>,\n+        inputs: Box<[ExprId]>,\n     },\n     Yield {\n-        value: &'thir Expr<'thir, 'tcx>,\n+        value: ExprId,\n     },\n }\n \n #[derive(Debug)]\n-pub struct FieldExpr<'thir, 'tcx> {\n+pub struct FieldExpr {\n     pub name: Field,\n-    pub expr: &'thir Expr<'thir, 'tcx>,\n+    pub expr: ExprId,\n }\n \n #[derive(Debug)]\n-pub struct FruInfo<'thir, 'tcx> {\n-    pub base: &'thir Expr<'thir, 'tcx>,\n-    pub field_types: &'thir [Ty<'tcx>],\n+pub struct FruInfo<'tcx> {\n+    pub base: ExprId,\n+    pub field_types: Box<[Ty<'tcx>]>,\n }\n \n #[derive(Debug)]\n-pub struct Arm<'thir, 'tcx> {\n+pub struct Arm<'tcx> {\n     pub pattern: Pat<'tcx>,\n-    pub guard: Option<Guard<'thir, 'tcx>>,\n-    pub body: &'thir Expr<'thir, 'tcx>,\n+    pub guard: Option<Guard<'tcx>>,\n+    pub body: ExprId,\n     pub lint_level: LintLevel,\n     pub scope: region::Scope,\n     pub span: Span,\n }\n \n #[derive(Debug)]\n-pub enum Guard<'thir, 'tcx> {\n-    If(&'thir Expr<'thir, 'tcx>),\n-    IfLet(Pat<'tcx>, &'thir Expr<'thir, 'tcx>),\n+pub enum Guard<'tcx> {\n+    If(ExprId),\n+    IfLet(Pat<'tcx>, ExprId),\n }\n \n #[derive(Copy, Clone, Debug)]\n@@ -353,33 +407,33 @@ pub enum LogicalOp {\n }\n \n #[derive(Debug)]\n-pub enum InlineAsmOperand<'thir, 'tcx> {\n+pub enum InlineAsmOperand<'tcx> {\n     In {\n         reg: InlineAsmRegOrRegClass,\n-        expr: &'thir Expr<'thir, 'tcx>,\n+        expr: ExprId,\n     },\n     Out {\n         reg: InlineAsmRegOrRegClass,\n         late: bool,\n-        expr: Option<&'thir Expr<'thir, 'tcx>>,\n+        expr: Option<ExprId>,\n     },\n     InOut {\n         reg: InlineAsmRegOrRegClass,\n         late: bool,\n-        expr: &'thir Expr<'thir, 'tcx>,\n+        expr: ExprId,\n     },\n     SplitInOut {\n         reg: InlineAsmRegOrRegClass,\n         late: bool,\n-        in_expr: &'thir Expr<'thir, 'tcx>,\n-        out_expr: Option<&'thir Expr<'thir, 'tcx>>,\n+        in_expr: ExprId,\n+        out_expr: Option<ExprId>,\n     },\n     Const {\n         value: &'tcx Const<'tcx>,\n         span: Span,\n     },\n     SymFn {\n-        expr: &'thir Expr<'thir, 'tcx>,\n+        expr: ExprId,\n     },\n     SymStatic {\n         def_id: DefId,"}]}