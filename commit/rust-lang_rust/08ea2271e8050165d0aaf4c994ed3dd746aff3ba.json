{"sha": "08ea2271e8050165d0aaf4c994ed3dd746aff3ba", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA4ZWEyMjcxZTgwNTAxNjVkMGFhZjRjOTk0ZWQzZGQ3NDZhZmYzYmE=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-07-31T10:06:38Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-07-31T10:14:37Z"}, "message": "Rename TypeRef -> Type\n\nThe TypeRef name comes from IntelliJ days, where you often have both\ntype *syntax* as well as *semantical* representation of types in\nscope. And naming both Type is confusing.\n\nIn rust-analyzer however, we use ast types as `ast::Type`, and have\nmany more semantic counterparts to ast types, so avoiding name clash\nhere is just confusing.", "tree": {"sha": "1d5bb4ce799c6377b49ae73436d50a087db53392", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1d5bb4ce799c6377b49ae73436d50a087db53392"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/08ea2271e8050165d0aaf4c994ed3dd746aff3ba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/08ea2271e8050165d0aaf4c994ed3dd746aff3ba", "html_url": "https://github.com/rust-lang/rust/commit/08ea2271e8050165d0aaf4c994ed3dd746aff3ba", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/08ea2271e8050165d0aaf4c994ed3dd746aff3ba/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e0f21133cd03c6160fbc97b70bbd50ccde4fe6d9", "url": "https://api.github.com/repos/rust-lang/rust/commits/e0f21133cd03c6160fbc97b70bbd50ccde4fe6d9", "html_url": "https://github.com/rust-lang/rust/commit/e0f21133cd03c6160fbc97b70bbd50ccde4fe6d9"}], "stats": {"total": 412, "additions": 209, "deletions": 203}, "files": [{"sha": "3265bd4069b74134973d9c108cc7ee1937a1b4de", "filename": "crates/ra_assists/src/ast_transform.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/08ea2271e8050165d0aaf4c994ed3dd746aff3ba/crates%2Fra_assists%2Fsrc%2Fast_transform.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08ea2271e8050165d0aaf4c994ed3dd746aff3ba/crates%2Fra_assists%2Fsrc%2Fast_transform.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fast_transform.rs?ref=08ea2271e8050165d0aaf4c994ed3dd746aff3ba", "patch": "@@ -32,7 +32,7 @@ impl<'a> AstTransform<'a> for NullTransformer {\n \n pub struct SubstituteTypeParams<'a> {\n     source_scope: &'a SemanticsScope<'a>,\n-    substs: FxHashMap<hir::TypeParam, ast::TypeRef>,\n+    substs: FxHashMap<hir::TypeParam, ast::Type>,\n     previous: Box<dyn AstTransform<'a> + 'a>,\n }\n \n@@ -80,17 +80,17 @@ impl<'a> SubstituteTypeParams<'a> {\n \n         // FIXME: It would probably be nicer if we could get this via HIR (i.e. get the\n         // trait ref, and then go from the types in the substs back to the syntax)\n-        fn get_syntactic_substs(impl_def: ast::Impl) -> Option<Vec<ast::TypeRef>> {\n+        fn get_syntactic_substs(impl_def: ast::Impl) -> Option<Vec<ast::Type>> {\n             let target_trait = impl_def.target_trait()?;\n             let path_type = match target_trait {\n-                ast::TypeRef::PathType(path) => path,\n+                ast::Type::PathType(path) => path,\n                 _ => return None,\n             };\n             let type_arg_list = path_type.path()?.segment()?.type_arg_list()?;\n             let mut result = Vec::new();\n             for type_arg in type_arg_list.type_args() {\n                 let type_arg: ast::TypeArg = type_arg;\n-                result.push(type_arg.type_ref()?);\n+                result.push(type_arg.ty()?);\n             }\n             Some(result)\n         }\n@@ -99,9 +99,9 @@ impl<'a> SubstituteTypeParams<'a> {\n         &self,\n         node: &ra_syntax::SyntaxNode,\n     ) -> Option<ra_syntax::SyntaxNode> {\n-        let type_ref = ast::TypeRef::cast(node.clone())?;\n+        let type_ref = ast::Type::cast(node.clone())?;\n         let path = match &type_ref {\n-            ast::TypeRef::PathType(path_type) => path_type.path()?,\n+            ast::Type::PathType(path_type) => path_type.path()?,\n             _ => return None,\n         };\n         // FIXME: use `hir::Path::from_src` instead."}, {"sha": "4c1aef8a21f90543a6039e3399bf12f4b135e06d", "filename": "crates/ra_assists/src/handlers/generate_from_impl_for_enum.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08ea2271e8050165d0aaf4c994ed3dd746aff3ba/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fgenerate_from_impl_for_enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08ea2271e8050165d0aaf4c994ed3dd746aff3ba/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fgenerate_from_impl_for_enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fgenerate_from_impl_for_enum.rs?ref=08ea2271e8050165d0aaf4c994ed3dd746aff3ba", "patch": "@@ -34,7 +34,7 @@ pub(crate) fn generate_from_impl_for_enum(acc: &mut Assists, ctx: &AssistContext\n     }\n     let field_type = field_list.fields().next()?.ty()?;\n     let path = match field_type {\n-        ast::TypeRef::PathType(it) => it,\n+        ast::Type::PathType(it) => it,\n         _ => return None,\n     };\n "}, {"sha": "4537c73a191667f17e81c774ae55b9986df9328c", "filename": "crates/ra_assists/src/handlers/introduce_named_lifetime.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08ea2271e8050165d0aaf4c994ed3dd746aff3ba/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fintroduce_named_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08ea2271e8050165d0aaf4c994ed3dd746aff3ba/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fintroduce_named_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fintroduce_named_lifetime.rs?ref=08ea2271e8050165d0aaf4c994ed3dd746aff3ba", "patch": "@@ -68,7 +68,7 @@ fn generate_fn_def_assist(\n         let fn_params_without_lifetime: Vec<_> = param_list\n             .params()\n             .filter_map(|param| match param.ty() {\n-                Some(ast::TypeRef::ReferenceType(ascribed_type))\n+                Some(ast::Type::ReferenceType(ascribed_type))\n                     if ascribed_type.lifetime_token() == None =>\n                 {\n                     Some(ascribed_type.amp_token()?.text_range().end())"}, {"sha": "be0b45af35bcc15afeb1dc564676293a7a13d20a", "filename": "crates/ra_hir_def/src/generics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08ea2271e8050165d0aaf4c994ed3dd746aff3ba/crates%2Fra_hir_def%2Fsrc%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08ea2271e8050165d0aaf4c994ed3dd746aff3ba/crates%2Fra_hir_def%2Fsrc%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fgenerics.rs?ref=08ea2271e8050165d0aaf4c994ed3dd746aff3ba", "patch": "@@ -253,7 +253,7 @@ impl GenericParams {\n \n     fn fill_where_predicates(&mut self, lower_ctx: &LowerCtx, where_clause: ast::WhereClause) {\n         for pred in where_clause.predicates() {\n-            let type_ref = match pred.type_ref() {\n+            let type_ref = match pred.ty() {\n                 Some(type_ref) => type_ref,\n                 None => continue,\n             };"}, {"sha": "b5d416acbc815b901329c2f33af4eb4b9a80cf7e", "filename": "crates/ra_hir_def/src/item_tree/lower.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/08ea2271e8050165d0aaf4c994ed3dd746aff3ba/crates%2Fra_hir_def%2Fsrc%2Fitem_tree%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08ea2271e8050165d0aaf4c994ed3dd746aff3ba/crates%2Fra_hir_def%2Fsrc%2Fitem_tree%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fitem_tree%2Flower.rs?ref=08ea2271e8050165d0aaf4c994ed3dd746aff3ba", "patch": "@@ -648,10 +648,10 @@ impl Ctx {\n         self.data().vis.alloc(vis)\n     }\n \n-    fn lower_type_ref(&self, type_ref: &ast::TypeRef) -> TypeRef {\n+    fn lower_type_ref(&self, type_ref: &ast::Type) -> TypeRef {\n         TypeRef::from_ast(&self.body_ctx, type_ref.clone())\n     }\n-    fn lower_type_ref_opt(&self, type_ref: Option<ast::TypeRef>) -> TypeRef {\n+    fn lower_type_ref_opt(&self, type_ref: Option<ast::Type>) -> TypeRef {\n         type_ref.map(|ty| self.lower_type_ref(&ty)).unwrap_or(TypeRef::Error)\n     }\n "}, {"sha": "257f9a033cc3fb7d9947e9150df8a419fb8ad343", "filename": "crates/ra_hir_def/src/path/lower.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/08ea2271e8050165d0aaf4c994ed3dd746aff3ba/crates%2Fra_hir_def%2Fsrc%2Fpath%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08ea2271e8050165d0aaf4c994ed3dd746aff3ba/crates%2Fra_hir_def%2Fsrc%2Fpath%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fpath%2Flower.rs?ref=08ea2271e8050165d0aaf4c994ed3dd746aff3ba", "patch": "@@ -152,7 +152,7 @@ pub(super) fn lower_generic_args(\n ) -> Option<GenericArgs> {\n     let mut args = Vec::new();\n     for type_arg in node.type_args() {\n-        let type_ref = TypeRef::from_ast_opt(lower_ctx, type_arg.type_ref());\n+        let type_ref = TypeRef::from_ast_opt(lower_ctx, type_arg.ty());\n         args.push(GenericArg::Type(type_ref));\n     }\n     // lifetimes ignored for now\n@@ -161,7 +161,7 @@ pub(super) fn lower_generic_args(\n         let assoc_type_arg: ast::AssocTypeArg = assoc_type_arg;\n         if let Some(name_ref) = assoc_type_arg.name_ref() {\n             let name = name_ref.as_name();\n-            let type_ref = assoc_type_arg.type_ref().map(|it| TypeRef::from_ast(lower_ctx, it));\n+            let type_ref = assoc_type_arg.ty().map(|it| TypeRef::from_ast(lower_ctx, it));\n             let bounds = if let Some(l) = assoc_type_arg.type_bound_list() {\n                 l.bounds().map(|it| TypeBound::from_ast(lower_ctx, it)).collect()\n             } else {"}, {"sha": "9386b91cbd9d523f7560295433c7b0473d74c992", "filename": "crates/ra_hir_def/src/type_ref.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/08ea2271e8050165d0aaf4c994ed3dd746aff3ba/crates%2Fra_hir_def%2Fsrc%2Ftype_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08ea2271e8050165d0aaf4c994ed3dd746aff3ba/crates%2Fra_hir_def%2Fsrc%2Ftype_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Ftype_ref.rs?ref=08ea2271e8050165d0aaf4c994ed3dd746aff3ba", "patch": "@@ -80,39 +80,39 @@ pub enum TypeBound {\n \n impl TypeRef {\n     /// Converts an `ast::TypeRef` to a `hir::TypeRef`.\n-    pub(crate) fn from_ast(ctx: &LowerCtx, node: ast::TypeRef) -> Self {\n+    pub(crate) fn from_ast(ctx: &LowerCtx, node: ast::Type) -> Self {\n         match node {\n-            ast::TypeRef::ParenType(inner) => TypeRef::from_ast_opt(&ctx, inner.ty()),\n-            ast::TypeRef::TupleType(inner) => {\n+            ast::Type::ParenType(inner) => TypeRef::from_ast_opt(&ctx, inner.ty()),\n+            ast::Type::TupleType(inner) => {\n                 TypeRef::Tuple(inner.fields().map(|it| TypeRef::from_ast(ctx, it)).collect())\n             }\n-            ast::TypeRef::NeverType(..) => TypeRef::Never,\n-            ast::TypeRef::PathType(inner) => {\n+            ast::Type::NeverType(..) => TypeRef::Never,\n+            ast::Type::PathType(inner) => {\n                 // FIXME: Use `Path::from_src`\n                 inner\n                     .path()\n                     .and_then(|it| ctx.lower_path(it))\n                     .map(TypeRef::Path)\n                     .unwrap_or(TypeRef::Error)\n             }\n-            ast::TypeRef::PointerType(inner) => {\n+            ast::Type::PointerType(inner) => {\n                 let inner_ty = TypeRef::from_ast_opt(&ctx, inner.ty());\n                 let mutability = Mutability::from_mutable(inner.mut_token().is_some());\n                 TypeRef::RawPtr(Box::new(inner_ty), mutability)\n             }\n-            ast::TypeRef::ArrayType(inner) => {\n+            ast::Type::ArrayType(inner) => {\n                 TypeRef::Array(Box::new(TypeRef::from_ast_opt(&ctx, inner.ty())))\n             }\n-            ast::TypeRef::SliceType(inner) => {\n+            ast::Type::SliceType(inner) => {\n                 TypeRef::Slice(Box::new(TypeRef::from_ast_opt(&ctx, inner.ty())))\n             }\n-            ast::TypeRef::ReferenceType(inner) => {\n+            ast::Type::ReferenceType(inner) => {\n                 let inner_ty = TypeRef::from_ast_opt(&ctx, inner.ty());\n                 let mutability = Mutability::from_mutable(inner.mut_token().is_some());\n                 TypeRef::Reference(Box::new(inner_ty), mutability)\n             }\n-            ast::TypeRef::PlaceholderType(_inner) => TypeRef::Placeholder,\n-            ast::TypeRef::FnPointerType(inner) => {\n+            ast::Type::PlaceholderType(_inner) => TypeRef::Placeholder,\n+            ast::Type::FnPointerType(inner) => {\n                 let ret_ty = inner\n                     .ret_type()\n                     .and_then(|rt| rt.ty())\n@@ -132,17 +132,17 @@ impl TypeRef {\n                 TypeRef::Fn(params, is_varargs)\n             }\n             // for types are close enough for our purposes to the inner type for now...\n-            ast::TypeRef::ForType(inner) => TypeRef::from_ast_opt(&ctx, inner.ty()),\n-            ast::TypeRef::ImplTraitType(inner) => {\n+            ast::Type::ForType(inner) => TypeRef::from_ast_opt(&ctx, inner.ty()),\n+            ast::Type::ImplTraitType(inner) => {\n                 TypeRef::ImplTrait(type_bounds_from_ast(ctx, inner.type_bound_list()))\n             }\n-            ast::TypeRef::DynTraitType(inner) => {\n+            ast::Type::DynTraitType(inner) => {\n                 TypeRef::DynTrait(type_bounds_from_ast(ctx, inner.type_bound_list()))\n             }\n         }\n     }\n \n-    pub(crate) fn from_ast_opt(ctx: &LowerCtx, node: Option<ast::TypeRef>) -> Self {\n+    pub(crate) fn from_ast_opt(ctx: &LowerCtx, node: Option<ast::Type>) -> Self {\n         if let Some(node) = node {\n             TypeRef::from_ast(ctx, node)\n         } else {"}, {"sha": "0fdf8e9a58db9c24cc69252b386828c32cdc0680", "filename": "crates/ra_ide/src/display/short_label.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08ea2271e8050165d0aaf4c994ed3dd746aff3ba/crates%2Fra_ide%2Fsrc%2Fdisplay%2Fshort_label.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08ea2271e8050165d0aaf4c994ed3dd746aff3ba/crates%2Fra_ide%2Fsrc%2Fdisplay%2Fshort_label.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fdisplay%2Fshort_label.rs?ref=08ea2271e8050165d0aaf4c994ed3dd746aff3ba", "patch": "@@ -77,7 +77,7 @@ impl ShortLabel for ast::Variant {\n     }\n }\n \n-fn short_label_from_ty<T>(node: &T, ty: Option<ast::TypeRef>, prefix: &str) -> Option<String>\n+fn short_label_from_ty<T>(node: &T, ty: Option<ast::Type>, prefix: &str) -> Option<String>\n where\n     T: NameOwner + VisibilityOwner,\n {"}, {"sha": "ef368651aed93fe9c6be0bceaba54e40a7d777e1", "filename": "crates/ra_ide/src/file_structure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08ea2271e8050165d0aaf4c994ed3dd746aff3ba/crates%2Fra_ide%2Fsrc%2Ffile_structure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08ea2271e8050165d0aaf4c994ed3dd746aff3ba/crates%2Fra_ide%2Fsrc%2Ffile_structure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Ffile_structure.rs?ref=08ea2271e8050165d0aaf4c994ed3dd746aff3ba", "patch": "@@ -57,7 +57,7 @@ fn structure_node(node: &SyntaxNode) -> Option<StructureNode> {\n \n     fn decl_with_type_ref<N: NameOwner + AttrsOwner>(\n         node: &N,\n-        type_ref: Option<ast::TypeRef>,\n+        type_ref: Option<ast::Type>,\n     ) -> Option<StructureNode> {\n         let detail = type_ref.map(|type_ref| {\n             let mut detail = String::new();"}, {"sha": "96aed7cc73fd1fd529f7a089aa0def58c210b380", "filename": "crates/ra_ide/src/references/rename.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/08ea2271e8050165d0aaf4c994ed3dd746aff3ba/crates%2Fra_ide%2Fsrc%2Freferences%2Frename.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08ea2271e8050165d0aaf4c994ed3dd746aff3ba/crates%2Fra_ide%2Fsrc%2Freferences%2Frename.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Freferences%2Frename.rs?ref=08ea2271e8050165d0aaf4c994ed3dd746aff3ba", "patch": "@@ -157,7 +157,7 @@ fn rename_to_self(\n     }\n     let first_param = params.params().next()?;\n     let mutable = match first_param.ty() {\n-        Some(ast::TypeRef::ReferenceType(rt)) => rt.mut_token().is_some(),\n+        Some(ast::Type::ReferenceType(rt)) => rt.mut_token().is_some(),\n         _ => return None, // not renaming other types\n     };\n \n@@ -194,7 +194,7 @@ fn text_edit_from_self_param(\n     new_name: &str,\n ) -> Option<TextEdit> {\n     fn target_type_name(impl_def: &ast::Impl) -> Option<String> {\n-        if let Some(ast::TypeRef::PathType(p)) = impl_def.target_type() {\n+        if let Some(ast::Type::PathType(p)) = impl_def.target_type() {\n             return Some(p.path()?.segment()?.name_ref()?.text().to_string());\n         }\n         None"}, {"sha": "4e046910c5f94515b74118b7328b092c7795f8ef", "filename": "crates/ra_ssr/src/parsing.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08ea2271e8050165d0aaf4c994ed3dd746aff3ba/crates%2Fra_ssr%2Fsrc%2Fparsing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08ea2271e8050165d0aaf4c994ed3dd746aff3ba/crates%2Fra_ssr%2Fsrc%2Fparsing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ssr%2Fsrc%2Fparsing.rs?ref=08ea2271e8050165d0aaf4c994ed3dd746aff3ba", "patch": "@@ -70,7 +70,7 @@ impl ParsedRule {\n             rules: Vec::new(),\n         };\n         builder.try_add(ast::Expr::parse(&raw_pattern), raw_template.map(ast::Expr::parse));\n-        builder.try_add(ast::TypeRef::parse(&raw_pattern), raw_template.map(ast::TypeRef::parse));\n+        builder.try_add(ast::Type::parse(&raw_pattern), raw_template.map(ast::Type::parse));\n         builder.try_add(ast::Item::parse(&raw_pattern), raw_template.map(ast::Item::parse));\n         builder.try_add(ast::Path::parse(&raw_pattern), raw_template.map(ast::Path::parse));\n         builder.try_add(ast::Pat::parse(&raw_pattern), raw_template.map(ast::Pat::parse));"}, {"sha": "8a0e3d27b21ab6647ed0229cbafccf0c9717c05a", "filename": "crates/ra_syntax/src/ast.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/08ea2271e8050165d0aaf4c994ed3dd746aff3ba/crates%2Fra_syntax%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08ea2271e8050165d0aaf4c994ed3dd746aff3ba/crates%2Fra_syntax%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast.rs?ref=08ea2271e8050165d0aaf4c994ed3dd746aff3ba", "patch": "@@ -287,7 +287,7 @@ where\n \n     assert!(pred.for_token().is_none());\n     assert!(pred.generic_param_list().is_none());\n-    assert_eq!(\"T\", pred.type_ref().unwrap().syntax().text().to_string());\n+    assert_eq!(\"T\", pred.ty().unwrap().syntax().text().to_string());\n     assert_bound(\"Clone\", bounds.next());\n     assert_bound(\"Copy\", bounds.next());\n     assert_bound(\"Debug\", bounds.next());\n@@ -304,20 +304,20 @@ where\n     let pred = predicates.next().unwrap();\n     let mut bounds = pred.type_bound_list().unwrap().bounds();\n \n-    assert_eq!(\"Iterator::Item\", pred.type_ref().unwrap().syntax().text().to_string());\n+    assert_eq!(\"Iterator::Item\", pred.ty().unwrap().syntax().text().to_string());\n     assert_bound(\"'a\", bounds.next());\n \n     let pred = predicates.next().unwrap();\n     let mut bounds = pred.type_bound_list().unwrap().bounds();\n \n-    assert_eq!(\"Iterator::Item\", pred.type_ref().unwrap().syntax().text().to_string());\n+    assert_eq!(\"Iterator::Item\", pred.ty().unwrap().syntax().text().to_string());\n     assert_bound(\"Debug\", bounds.next());\n     assert_bound(\"'a\", bounds.next());\n \n     let pred = predicates.next().unwrap();\n     let mut bounds = pred.type_bound_list().unwrap().bounds();\n \n-    assert_eq!(\"<T as Iterator>::Item\", pred.type_ref().unwrap().syntax().text().to_string());\n+    assert_eq!(\"<T as Iterator>::Item\", pred.ty().unwrap().syntax().text().to_string());\n     assert_bound(\"Debug\", bounds.next());\n     assert_bound(\"'a\", bounds.next());\n \n@@ -326,6 +326,6 @@ where\n \n     assert!(pred.for_token().is_some());\n     assert_eq!(\"<'a>\", pred.generic_param_list().unwrap().syntax().text().to_string());\n-    assert_eq!(\"F\", pred.type_ref().unwrap().syntax().text().to_string());\n+    assert_eq!(\"F\", pred.ty().unwrap().syntax().text().to_string());\n     assert_bound(\"Fn(&'a str)\", bounds.next());\n }"}, {"sha": "9cfd5d017c24cb69a0decc5b11a914407f64e0c3", "filename": "crates/ra_syntax/src/ast/generated/nodes.rs", "status": "modified", "additions": 127, "deletions": 127, "changes": 254, "blob_url": "https://github.com/rust-lang/rust/blob/08ea2271e8050165d0aaf4c994ed3dd746aff3ba/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08ea2271e8050165d0aaf4c994ed3dd746aff3ba/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs?ref=08ea2271e8050165d0aaf4c994ed3dd746aff3ba", "patch": "@@ -40,7 +40,7 @@ impl Const {\n     pub fn const_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![const]) }\n     pub fn underscore_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![_]) }\n     pub fn colon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![:]) }\n-    pub fn ty(&self) -> Option<TypeRef> { support::child(&self.syntax) }\n+    pub fn ty(&self) -> Option<Type> { support::child(&self.syntax) }\n     pub fn eq_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![=]) }\n     pub fn body(&self) -> Option<Expr> { support::child(&self.syntax) }\n     pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![;]) }\n@@ -112,7 +112,7 @@ impl Impl {\n     pub fn unsafe_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![unsafe]) }\n     pub fn impl_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![impl]) }\n     pub fn const_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![const]) }\n-    pub fn type_ref(&self) -> Option<TypeRef> { support::child(&self.syntax) }\n+    pub fn ty(&self) -> Option<Type> { support::child(&self.syntax) }\n     pub fn excl_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![!]) }\n     pub fn for_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![for]) }\n     pub fn assoc_item_list(&self) -> Option<AssocItemList> { support::child(&self.syntax) }\n@@ -152,7 +152,7 @@ impl Static {\n     pub fn static_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![static]) }\n     pub fn mut_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![mut]) }\n     pub fn colon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![:]) }\n-    pub fn ty(&self) -> Option<TypeRef> { support::child(&self.syntax) }\n+    pub fn ty(&self) -> Option<Type> { support::child(&self.syntax) }\n     pub fn eq_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![=]) }\n     pub fn body(&self) -> Option<Expr> { support::child(&self.syntax) }\n     pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![;]) }\n@@ -198,7 +198,7 @@ impl TypeAlias {\n     pub fn default_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![default]) }\n     pub fn type_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![type]) }\n     pub fn eq_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![=]) }\n-    pub fn ty(&self) -> Option<TypeRef> { support::child(&self.syntax) }\n+    pub fn ty(&self) -> Option<Type> { support::child(&self.syntax) }\n     pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![;]) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -333,7 +333,7 @@ pub struct RetType {\n }\n impl RetType {\n     pub fn thin_arrow_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![->]) }\n-    pub fn ty(&self) -> Option<TypeRef> { support::child(&self.syntax) }\n+    pub fn ty(&self) -> Option<Type> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct WhereClause {\n@@ -369,7 +369,7 @@ impl SelfParam {\n     pub fn mut_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![mut]) }\n     pub fn self_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![self]) }\n     pub fn colon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![:]) }\n-    pub fn ty(&self) -> Option<TypeRef> { support::child(&self.syntax) }\n+    pub fn ty(&self) -> Option<Type> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct Param {\n@@ -379,7 +379,7 @@ impl ast::AttrsOwner for Param {}\n impl Param {\n     pub fn pat(&self) -> Option<Pat> { support::child(&self.syntax) }\n     pub fn colon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![:]) }\n-    pub fn ty(&self) -> Option<TypeRef> { support::child(&self.syntax) }\n+    pub fn ty(&self) -> Option<Type> { support::child(&self.syntax) }\n     pub fn dotdotdot_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![...]) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -416,7 +416,7 @@ impl ast::NameOwner for RecordField {}\n impl ast::VisibilityOwner for RecordField {}\n impl RecordField {\n     pub fn colon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![:]) }\n-    pub fn ty(&self) -> Option<TypeRef> { support::child(&self.syntax) }\n+    pub fn ty(&self) -> Option<Type> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct TupleField {\n@@ -425,7 +425,7 @@ pub struct TupleField {\n impl ast::AttrsOwner for TupleField {}\n impl ast::VisibilityOwner for TupleField {}\n impl TupleField {\n-    pub fn ty(&self) -> Option<TypeRef> { support::child(&self.syntax) }\n+    pub fn ty(&self) -> Option<Type> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct VariantList {\n@@ -487,7 +487,7 @@ impl ast::NameOwner for TypeParam {}\n impl ast::TypeBoundsOwner for TypeParam {}\n impl TypeParam {\n     pub fn eq_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![=]) }\n-    pub fn default_type(&self) -> Option<TypeRef> { support::child(&self.syntax) }\n+    pub fn default_type(&self) -> Option<Type> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct ConstParam {\n@@ -498,7 +498,7 @@ impl ast::NameOwner for ConstParam {}\n impl ConstParam {\n     pub fn const_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![const]) }\n     pub fn colon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![:]) }\n-    pub fn ty(&self) -> Option<TypeRef> { support::child(&self.syntax) }\n+    pub fn ty(&self) -> Option<Type> { support::child(&self.syntax) }\n     pub fn eq_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![=]) }\n     pub fn default_val(&self) -> Option<Expr> { support::child(&self.syntax) }\n }\n@@ -525,7 +525,7 @@ pub struct ParenType {\n }\n impl ParenType {\n     pub fn l_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['(']) }\n-    pub fn ty(&self) -> Option<TypeRef> { support::child(&self.syntax) }\n+    pub fn ty(&self) -> Option<Type> { support::child(&self.syntax) }\n     pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![')']) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -534,7 +534,7 @@ pub struct TupleType {\n }\n impl TupleType {\n     pub fn l_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['(']) }\n-    pub fn fields(&self) -> AstChildren<TypeRef> { support::children(&self.syntax) }\n+    pub fn fields(&self) -> AstChildren<Type> { support::children(&self.syntax) }\n     pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![')']) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -559,15 +559,15 @@ impl PointerType {\n     pub fn star_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![*]) }\n     pub fn const_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![const]) }\n     pub fn mut_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![mut]) }\n-    pub fn ty(&self) -> Option<TypeRef> { support::child(&self.syntax) }\n+    pub fn ty(&self) -> Option<Type> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct ArrayType {\n     pub(crate) syntax: SyntaxNode,\n }\n impl ArrayType {\n     pub fn l_brack_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['[']) }\n-    pub fn ty(&self) -> Option<TypeRef> { support::child(&self.syntax) }\n+    pub fn ty(&self) -> Option<Type> { support::child(&self.syntax) }\n     pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![;]) }\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n     pub fn r_brack_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![']']) }\n@@ -578,7 +578,7 @@ pub struct SliceType {\n }\n impl SliceType {\n     pub fn l_brack_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['[']) }\n-    pub fn ty(&self) -> Option<TypeRef> { support::child(&self.syntax) }\n+    pub fn ty(&self) -> Option<Type> { support::child(&self.syntax) }\n     pub fn r_brack_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![']']) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -591,7 +591,7 @@ impl ReferenceType {\n         support::token(&self.syntax, T![lifetime])\n     }\n     pub fn mut_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![mut]) }\n-    pub fn ty(&self) -> Option<TypeRef> { support::child(&self.syntax) }\n+    pub fn ty(&self) -> Option<Type> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct PlaceholderType {\n@@ -618,7 +618,7 @@ pub struct ForType {\n impl ForType {\n     pub fn for_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![for]) }\n     pub fn generic_param_list(&self) -> Option<GenericParamList> { support::child(&self.syntax) }\n-    pub fn ty(&self) -> Option<TypeRef> { support::child(&self.syntax) }\n+    pub fn ty(&self) -> Option<Type> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct ImplTraitType {\n@@ -882,7 +882,7 @@ impl ast::AttrsOwner for CastExpr {}\n impl CastExpr {\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n     pub fn as_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![as]) }\n-    pub fn ty(&self) -> Option<TypeRef> { support::child(&self.syntax) }\n+    pub fn ty(&self) -> Option<Type> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct RefExpr {\n@@ -1174,7 +1174,7 @@ impl TypeBound {\n         support::token(&self.syntax, T![lifetime])\n     }\n     pub fn const_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![const]) }\n-    pub fn type_ref(&self) -> Option<TypeRef> { support::child(&self.syntax) }\n+    pub fn ty(&self) -> Option<Type> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct WherePred {\n@@ -1187,7 +1187,7 @@ impl WherePred {\n     pub fn lifetime_token(&self) -> Option<SyntaxToken> {\n         support::token(&self.syntax, T![lifetime])\n     }\n-    pub fn type_ref(&self) -> Option<TypeRef> { support::child(&self.syntax) }\n+    pub fn ty(&self) -> Option<Type> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct ExprStmt {\n@@ -1207,7 +1207,7 @@ impl LetStmt {\n     pub fn let_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![let]) }\n     pub fn pat(&self) -> Option<Pat> { support::child(&self.syntax) }\n     pub fn colon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![:]) }\n-    pub fn ty(&self) -> Option<TypeRef> { support::child(&self.syntax) }\n+    pub fn ty(&self) -> Option<Type> { support::child(&self.syntax) }\n     pub fn eq_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![=]) }\n     pub fn initializer(&self) -> Option<Expr> { support::child(&self.syntax) }\n     pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![;]) }\n@@ -1234,7 +1234,7 @@ pub struct TypeArg {\n     pub(crate) syntax: SyntaxNode,\n }\n impl TypeArg {\n-    pub fn type_ref(&self) -> Option<TypeRef> { support::child(&self.syntax) }\n+    pub fn ty(&self) -> Option<Type> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct LifetimeArg {\n@@ -1253,7 +1253,7 @@ impl ast::TypeBoundsOwner for AssocTypeArg {}\n impl AssocTypeArg {\n     pub fn name_ref(&self) -> Option<NameRef> { support::child(&self.syntax) }\n     pub fn eq_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![=]) }\n-    pub fn type_ref(&self) -> Option<TypeRef> { support::child(&self.syntax) }\n+    pub fn ty(&self) -> Option<Type> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct ConstArg {\n@@ -1282,7 +1282,7 @@ pub enum Item {\n }\n impl ast::AttrsOwner for Item {}\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub enum TypeRef {\n+pub enum Type {\n     ParenType(ParenType),\n     TupleType(TupleType),\n     NeverType(NeverType),\n@@ -1355,6 +1355,16 @@ pub enum Expr {\n     BoxExpr(BoxExpr),\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub enum AdtDef {\n+    Struct(Struct),\n+    Enum(Enum),\n+    Union(Union),\n+}\n+impl ast::AttrsOwner for AdtDef {}\n+impl ast::GenericParamsOwner for AdtDef {}\n+impl ast::NameOwner for AdtDef {}\n+impl ast::VisibilityOwner for AdtDef {}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub enum AssocItem {\n     Fn(Fn),\n     TypeAlias(TypeAlias),\n@@ -1384,16 +1394,6 @@ pub enum Stmt {\n     ExprStmt(ExprStmt),\n }\n impl ast::AttrsOwner for Stmt {}\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub enum AdtDef {\n-    Struct(Struct),\n-    Enum(Enum),\n-    Union(Union),\n-}\n-impl ast::AttrsOwner for AdtDef {}\n-impl ast::GenericParamsOwner for AdtDef {}\n-impl ast::NameOwner for AdtDef {}\n-impl ast::VisibilityOwner for AdtDef {}\n impl AstNode for SourceFile {\n     fn can_cast(kind: SyntaxKind) -> bool { kind == SOURCE_FILE }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n@@ -2847,46 +2847,46 @@ impl AstNode for Item {\n         }\n     }\n }\n-impl From<ParenType> for TypeRef {\n-    fn from(node: ParenType) -> TypeRef { TypeRef::ParenType(node) }\n+impl From<ParenType> for Type {\n+    fn from(node: ParenType) -> Type { Type::ParenType(node) }\n }\n-impl From<TupleType> for TypeRef {\n-    fn from(node: TupleType) -> TypeRef { TypeRef::TupleType(node) }\n+impl From<TupleType> for Type {\n+    fn from(node: TupleType) -> Type { Type::TupleType(node) }\n }\n-impl From<NeverType> for TypeRef {\n-    fn from(node: NeverType) -> TypeRef { TypeRef::NeverType(node) }\n+impl From<NeverType> for Type {\n+    fn from(node: NeverType) -> Type { Type::NeverType(node) }\n }\n-impl From<PathType> for TypeRef {\n-    fn from(node: PathType) -> TypeRef { TypeRef::PathType(node) }\n+impl From<PathType> for Type {\n+    fn from(node: PathType) -> Type { Type::PathType(node) }\n }\n-impl From<PointerType> for TypeRef {\n-    fn from(node: PointerType) -> TypeRef { TypeRef::PointerType(node) }\n+impl From<PointerType> for Type {\n+    fn from(node: PointerType) -> Type { Type::PointerType(node) }\n }\n-impl From<ArrayType> for TypeRef {\n-    fn from(node: ArrayType) -> TypeRef { TypeRef::ArrayType(node) }\n+impl From<ArrayType> for Type {\n+    fn from(node: ArrayType) -> Type { Type::ArrayType(node) }\n }\n-impl From<SliceType> for TypeRef {\n-    fn from(node: SliceType) -> TypeRef { TypeRef::SliceType(node) }\n+impl From<SliceType> for Type {\n+    fn from(node: SliceType) -> Type { Type::SliceType(node) }\n }\n-impl From<ReferenceType> for TypeRef {\n-    fn from(node: ReferenceType) -> TypeRef { TypeRef::ReferenceType(node) }\n+impl From<ReferenceType> for Type {\n+    fn from(node: ReferenceType) -> Type { Type::ReferenceType(node) }\n }\n-impl From<PlaceholderType> for TypeRef {\n-    fn from(node: PlaceholderType) -> TypeRef { TypeRef::PlaceholderType(node) }\n+impl From<PlaceholderType> for Type {\n+    fn from(node: PlaceholderType) -> Type { Type::PlaceholderType(node) }\n }\n-impl From<FnPointerType> for TypeRef {\n-    fn from(node: FnPointerType) -> TypeRef { TypeRef::FnPointerType(node) }\n+impl From<FnPointerType> for Type {\n+    fn from(node: FnPointerType) -> Type { Type::FnPointerType(node) }\n }\n-impl From<ForType> for TypeRef {\n-    fn from(node: ForType) -> TypeRef { TypeRef::ForType(node) }\n+impl From<ForType> for Type {\n+    fn from(node: ForType) -> Type { Type::ForType(node) }\n }\n-impl From<ImplTraitType> for TypeRef {\n-    fn from(node: ImplTraitType) -> TypeRef { TypeRef::ImplTraitType(node) }\n+impl From<ImplTraitType> for Type {\n+    fn from(node: ImplTraitType) -> Type { Type::ImplTraitType(node) }\n }\n-impl From<DynTraitType> for TypeRef {\n-    fn from(node: DynTraitType) -> TypeRef { TypeRef::DynTraitType(node) }\n+impl From<DynTraitType> for Type {\n+    fn from(node: DynTraitType) -> Type { Type::DynTraitType(node) }\n }\n-impl AstNode for TypeRef {\n+impl AstNode for Type {\n     fn can_cast(kind: SyntaxKind) -> bool {\n         match kind {\n             PAREN_TYPE | TUPLE_TYPE | NEVER_TYPE | PATH_TYPE | POINTER_TYPE | ARRAY_TYPE\n@@ -2897,38 +2897,38 @@ impl AstNode for TypeRef {\n     }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         let res = match syntax.kind() {\n-            PAREN_TYPE => TypeRef::ParenType(ParenType { syntax }),\n-            TUPLE_TYPE => TypeRef::TupleType(TupleType { syntax }),\n-            NEVER_TYPE => TypeRef::NeverType(NeverType { syntax }),\n-            PATH_TYPE => TypeRef::PathType(PathType { syntax }),\n-            POINTER_TYPE => TypeRef::PointerType(PointerType { syntax }),\n-            ARRAY_TYPE => TypeRef::ArrayType(ArrayType { syntax }),\n-            SLICE_TYPE => TypeRef::SliceType(SliceType { syntax }),\n-            REFERENCE_TYPE => TypeRef::ReferenceType(ReferenceType { syntax }),\n-            PLACEHOLDER_TYPE => TypeRef::PlaceholderType(PlaceholderType { syntax }),\n-            FN_POINTER_TYPE => TypeRef::FnPointerType(FnPointerType { syntax }),\n-            FOR_TYPE => TypeRef::ForType(ForType { syntax }),\n-            IMPL_TRAIT_TYPE => TypeRef::ImplTraitType(ImplTraitType { syntax }),\n-            DYN_TRAIT_TYPE => TypeRef::DynTraitType(DynTraitType { syntax }),\n+            PAREN_TYPE => Type::ParenType(ParenType { syntax }),\n+            TUPLE_TYPE => Type::TupleType(TupleType { syntax }),\n+            NEVER_TYPE => Type::NeverType(NeverType { syntax }),\n+            PATH_TYPE => Type::PathType(PathType { syntax }),\n+            POINTER_TYPE => Type::PointerType(PointerType { syntax }),\n+            ARRAY_TYPE => Type::ArrayType(ArrayType { syntax }),\n+            SLICE_TYPE => Type::SliceType(SliceType { syntax }),\n+            REFERENCE_TYPE => Type::ReferenceType(ReferenceType { syntax }),\n+            PLACEHOLDER_TYPE => Type::PlaceholderType(PlaceholderType { syntax }),\n+            FN_POINTER_TYPE => Type::FnPointerType(FnPointerType { syntax }),\n+            FOR_TYPE => Type::ForType(ForType { syntax }),\n+            IMPL_TRAIT_TYPE => Type::ImplTraitType(ImplTraitType { syntax }),\n+            DYN_TRAIT_TYPE => Type::DynTraitType(DynTraitType { syntax }),\n             _ => return None,\n         };\n         Some(res)\n     }\n     fn syntax(&self) -> &SyntaxNode {\n         match self {\n-            TypeRef::ParenType(it) => &it.syntax,\n-            TypeRef::TupleType(it) => &it.syntax,\n-            TypeRef::NeverType(it) => &it.syntax,\n-            TypeRef::PathType(it) => &it.syntax,\n-            TypeRef::PointerType(it) => &it.syntax,\n-            TypeRef::ArrayType(it) => &it.syntax,\n-            TypeRef::SliceType(it) => &it.syntax,\n-            TypeRef::ReferenceType(it) => &it.syntax,\n-            TypeRef::PlaceholderType(it) => &it.syntax,\n-            TypeRef::FnPointerType(it) => &it.syntax,\n-            TypeRef::ForType(it) => &it.syntax,\n-            TypeRef::ImplTraitType(it) => &it.syntax,\n-            TypeRef::DynTraitType(it) => &it.syntax,\n+            Type::ParenType(it) => &it.syntax,\n+            Type::TupleType(it) => &it.syntax,\n+            Type::NeverType(it) => &it.syntax,\n+            Type::PathType(it) => &it.syntax,\n+            Type::PointerType(it) => &it.syntax,\n+            Type::ArrayType(it) => &it.syntax,\n+            Type::SliceType(it) => &it.syntax,\n+            Type::ReferenceType(it) => &it.syntax,\n+            Type::PlaceholderType(it) => &it.syntax,\n+            Type::FnPointerType(it) => &it.syntax,\n+            Type::ForType(it) => &it.syntax,\n+            Type::ImplTraitType(it) => &it.syntax,\n+            Type::DynTraitType(it) => &it.syntax,\n         }\n     }\n }\n@@ -3234,6 +3234,39 @@ impl AstNode for Expr {\n         }\n     }\n }\n+impl From<Struct> for AdtDef {\n+    fn from(node: Struct) -> AdtDef { AdtDef::Struct(node) }\n+}\n+impl From<Enum> for AdtDef {\n+    fn from(node: Enum) -> AdtDef { AdtDef::Enum(node) }\n+}\n+impl From<Union> for AdtDef {\n+    fn from(node: Union) -> AdtDef { AdtDef::Union(node) }\n+}\n+impl AstNode for AdtDef {\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            STRUCT | ENUM | UNION => true,\n+            _ => false,\n+        }\n+    }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        let res = match syntax.kind() {\n+            STRUCT => AdtDef::Struct(Struct { syntax }),\n+            ENUM => AdtDef::Enum(Enum { syntax }),\n+            UNION => AdtDef::Union(Union { syntax }),\n+            _ => return None,\n+        };\n+        Some(res)\n+    }\n+    fn syntax(&self) -> &SyntaxNode {\n+        match self {\n+            AdtDef::Struct(it) => &it.syntax,\n+            AdtDef::Enum(it) => &it.syntax,\n+            AdtDef::Union(it) => &it.syntax,\n+        }\n+    }\n+}\n impl From<Fn> for AssocItem {\n     fn from(node: Fn) -> AssocItem { AssocItem::Fn(node) }\n }\n@@ -3366,45 +3399,12 @@ impl AstNode for Stmt {\n         }\n     }\n }\n-impl From<Struct> for AdtDef {\n-    fn from(node: Struct) -> AdtDef { AdtDef::Struct(node) }\n-}\n-impl From<Enum> for AdtDef {\n-    fn from(node: Enum) -> AdtDef { AdtDef::Enum(node) }\n-}\n-impl From<Union> for AdtDef {\n-    fn from(node: Union) -> AdtDef { AdtDef::Union(node) }\n-}\n-impl AstNode for AdtDef {\n-    fn can_cast(kind: SyntaxKind) -> bool {\n-        match kind {\n-            STRUCT | ENUM | UNION => true,\n-            _ => false,\n-        }\n-    }\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        let res = match syntax.kind() {\n-            STRUCT => AdtDef::Struct(Struct { syntax }),\n-            ENUM => AdtDef::Enum(Enum { syntax }),\n-            UNION => AdtDef::Union(Union { syntax }),\n-            _ => return None,\n-        };\n-        Some(res)\n-    }\n-    fn syntax(&self) -> &SyntaxNode {\n-        match self {\n-            AdtDef::Struct(it) => &it.syntax,\n-            AdtDef::Enum(it) => &it.syntax,\n-            AdtDef::Union(it) => &it.syntax,\n-        }\n-    }\n-}\n impl std::fmt::Display for Item {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for TypeRef {\n+impl std::fmt::Display for Type {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n@@ -3424,27 +3424,27 @@ impl std::fmt::Display for Expr {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for AssocItem {\n+impl std::fmt::Display for AdtDef {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for ExternItem {\n+impl std::fmt::Display for AssocItem {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for GenericParam {\n+impl std::fmt::Display for ExternItem {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for Stmt {\n+impl std::fmt::Display for GenericParam {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for AdtDef {\n+impl std::fmt::Display for Stmt {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }"}, {"sha": "3d4fed64ca6b6370f3ebc8c76c40a51e7d3a1c1e", "filename": "crates/ra_syntax/src/ast/make.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/08ea2271e8050165d0aaf4c994ed3dd746aff3ba/crates%2Fra_syntax%2Fsrc%2Fast%2Fmake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08ea2271e8050165d0aaf4c994ed3dd746aff3ba/crates%2Fra_syntax%2Fsrc%2Fast%2Fmake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fmake.rs?ref=08ea2271e8050165d0aaf4c994ed3dd746aff3ba", "patch": "@@ -17,7 +17,7 @@ pub fn name_ref(text: &str) -> ast::NameRef {\n     ast_from_text(&format!(\"fn f() {{ {}; }}\", text))\n }\n \n-pub fn type_ref(text: &str) -> ast::TypeRef {\n+pub fn type_ref(text: &str) -> ast::Type {\n     ast_from_text(&format!(\"impl {} for D {{}};\", text))\n }\n \n@@ -75,7 +75,7 @@ pub fn record_field(name: ast::NameRef, expr: Option<ast::Expr>) -> ast::RecordE\n     }\n }\n \n-pub fn record_field_def(name: ast::NameRef, ty: ast::TypeRef) -> ast::RecordField {\n+pub fn record_field_def(name: ast::NameRef, ty: ast::Type) -> ast::RecordField {\n     ast_from_text(&format!(\"struct S {{ {}: {}, }}\", name, ty))\n }\n "}, {"sha": "30c2db56bc9faa53a1b4c4528cc450fdd9951162", "filename": "crates/ra_syntax/src/ast/node_ext.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/08ea2271e8050165d0aaf4c994ed3dd746aff3ba/crates%2Fra_syntax%2Fsrc%2Fast%2Fnode_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08ea2271e8050165d0aaf4c994ed3dd746aff3ba/crates%2Fra_syntax%2Fsrc%2Fast%2Fnode_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fnode_ext.rs?ref=08ea2271e8050165d0aaf4c994ed3dd746aff3ba", "patch": "@@ -82,7 +82,7 @@ impl ast::Attr {\n #[derive(Debug, Clone, PartialEq, Eq)]\n pub enum PathSegmentKind {\n     Name(ast::NameRef),\n-    Type { type_ref: Option<ast::TypeRef>, trait_ref: Option<ast::PathType> },\n+    Type { type_ref: Option<ast::Type>, trait_ref: Option<ast::PathType> },\n     SelfKw,\n     SuperKw,\n     CrateKw,\n@@ -108,8 +108,8 @@ impl ast::PathSegment {\n                     // <T> or <T as Trait>\n                     // T is any TypeRef, Trait has to be a PathType\n                     let mut type_refs =\n-                        self.syntax().children().filter(|node| ast::TypeRef::can_cast(node.kind()));\n-                    let type_ref = type_refs.next().and_then(ast::TypeRef::cast);\n+                        self.syntax().children().filter(|node| ast::Type::can_cast(node.kind()));\n+                    let type_ref = type_refs.next().and_then(ast::Type::cast);\n                     let trait_ref = type_refs.next().and_then(ast::PathType::cast);\n                     PathSegmentKind::Type { type_ref, trait_ref }\n                 }\n@@ -136,21 +136,21 @@ impl ast::UseTreeList {\n }\n \n impl ast::Impl {\n-    pub fn target_type(&self) -> Option<ast::TypeRef> {\n+    pub fn target_type(&self) -> Option<ast::Type> {\n         match self.target() {\n             (Some(t), None) | (_, Some(t)) => Some(t),\n             _ => None,\n         }\n     }\n \n-    pub fn target_trait(&self) -> Option<ast::TypeRef> {\n+    pub fn target_trait(&self) -> Option<ast::Type> {\n         match self.target() {\n             (Some(t), Some(_)) => Some(t),\n             _ => None,\n         }\n     }\n \n-    fn target(&self) -> (Option<ast::TypeRef>, Option<ast::TypeRef>) {\n+    fn target(&self) -> (Option<ast::Type>, Option<ast::Type>) {\n         let mut types = support::children(self.syntax());\n         let first = types.next();\n         let second = types.next();"}, {"sha": "8a4d4538622bf2db4664c4140cc5bd4eadeb0867", "filename": "crates/ra_syntax/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08ea2271e8050165d0aaf4c994ed3dd746aff3ba/crates%2Fra_syntax%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08ea2271e8050165d0aaf4c994ed3dd746aff3ba/crates%2Fra_syntax%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Flib.rs?ref=08ea2271e8050165d0aaf4c994ed3dd746aff3ba", "patch": "@@ -194,7 +194,7 @@ impl ast::Item {\n     }\n }\n \n-impl ast::TypeRef {\n+impl ast::Type {\n     /// Returns `text`, parsed as an type reference, but only if it has no errors.\n     pub fn parse(text: &str) -> Result<Self, ()> {\n         parsing::parse_text_fragment(text, ra_parser::FragmentKind::Type)"}, {"sha": "00b957f434772dea91a2520c585b10026ea63352", "filename": "crates/ra_syntax/src/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08ea2271e8050165d0aaf4c994ed3dd746aff3ba/crates%2Fra_syntax%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08ea2271e8050165d0aaf4c994ed3dd746aff3ba/crates%2Fra_syntax%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Ftests.rs?ref=08ea2271e8050165d0aaf4c994ed3dd746aff3ba", "patch": "@@ -98,7 +98,7 @@ fn type_parser_tests() {\n     fragment_parser_dir_test(\n         &[\"parser/fragments/type/ok\"],\n         &[\"parser/fragments/type/err\"],\n-        crate::ast::TypeRef::parse,\n+        crate::ast::Type::parse,\n     );\n }\n "}, {"sha": "d6a72ccc06c5cb9a8795c5f9657a26fa9f322364", "filename": "xtask/src/codegen/gen_syntax.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/08ea2271e8050165d0aaf4c994ed3dd746aff3ba/xtask%2Fsrc%2Fcodegen%2Fgen_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08ea2271e8050165d0aaf4c994ed3dd746aff3ba/xtask%2Fsrc%2Fcodegen%2Fgen_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Fcodegen%2Fgen_syntax.rs?ref=08ea2271e8050165d0aaf4c994ed3dd746aff3ba", "patch": "@@ -476,7 +476,13 @@ impl Field {\n                 };\n                 format_ident!(\"{}_token\", name)\n             }\n-            Field::Node { name, .. } => format_ident!(\"{}\", name),\n+            Field::Node { name, .. } => {\n+                if name == \"type\" {\n+                    format_ident!(\"ty\")\n+                } else {\n+                    format_ident!(\"{}\", name)\n+                }\n+            }\n         }\n     }\n     fn ty(&self) -> proc_macro2::Ident {"}, {"sha": "8f0e66278e939d81cde81fc6e6c4987272844cd8", "filename": "xtask/src/codegen/rust.ungram", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/08ea2271e8050165d0aaf4c994ed3dd746aff3ba/xtask%2Fsrc%2Fcodegen%2Frust.ungram", "raw_url": "https://github.com/rust-lang/rust/raw/08ea2271e8050165d0aaf4c994ed3dd746aff3ba/xtask%2Fsrc%2Fcodegen%2Frust.ungram", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Fcodegen%2Frust.ungram?ref=08ea2271e8050165d0aaf4c994ed3dd746aff3ba", "patch": "@@ -61,22 +61,22 @@ ParamList =\n SelfParam =\n   Attr* (\n     ('&' 'lifetime'?)? 'mut'? 'self'\n-  | 'mut'? 'self' ':' ty:TypeRef\n+  | 'mut'? 'self' ':' Type\n   )\n \n Param =\n   Attr* (\n-    Pat (':' ty:TypeRef)\n-  | ty:TypeRef\n+    Pat (':' Type)\n+  | Type\n   | '...'\n   )\n \n RetType =\n-  '->' ty:TypeRef\n+  '->' Type\n \n TypeAlias =\n   Attr* Visibility? 'default'? 'type' Name GenericParamList? (':' TypeBoundList?)? WhereClause?\n-  '=' ty:TypeRef ';'\n+  '=' Type ';'\n \n Struct =\n   Attr* Visibility? 'struct' Name GenericParamList? (\n@@ -88,13 +88,13 @@ RecordFieldList =\n  '{' fields:(RecordField (',' RecordField)* ','?)? '}'\n \n RecordField =\n-  Attr* Visibility? Name ':' ty:TypeRef\n+  Attr* Visibility? Name ':' Type\n \n TupleFieldList =\n   '(' fields:(TupleField (',' TupleField)* ','?)? ')'\n \n TupleField =\n-  Attr* Visibility? ty:TypeRef\n+  Attr* Visibility? Type\n \n FieldList =\n   RecordFieldList\n@@ -120,11 +120,11 @@ AdtDef =\n | Union\n \n Const =\n-  Attr* Visibility? 'default'? 'const' (Name | '_') ':' ty:TypeRef\n+  Attr* Visibility? 'default'? 'const' (Name | '_') ':' Type\n   '=' body:Expr ';'\n \n Static =\n-  Attr* Visibility? 'static'? 'mut'? Name ':' ty:TypeRef\n+  Attr* Visibility? 'static'? 'mut'? Name ':' Type\n   '=' body:Expr ';'\n \n Trait =\n@@ -144,8 +144,8 @@ AssocItem =\n Impl =\n  Attr* Visibility?\n  'default'? 'unsafe'? 'impl' 'const'? GenericParamList? (\n-   TypeRef\n- | '!'? TypeRef 'for' TypeRef\n+   Type\n+ | '!'? Type 'for' Type\n  ) WhereClause?\n  AssocItemList\n \n@@ -168,10 +168,10 @@ GenericParam =\n \n TypeParam =\n   Attr* Name (':' TypeBoundList?)?\n-  ('=' default_type:TypeRef)?\n+  ('=' default_type:Type)?\n \n ConstParam =\n-  Attr* 'const' Name ':' ty:TypeRef\n+  Attr* 'const' Name ':' Type\n   ('=' default_val:Expr)?\n \n LifetimeParam =\n@@ -188,7 +188,7 @@ Visibility =\n Attr =\n   '#' '!'? '[' Path ('=' Literal | TokenTree)? ']'\n \n-TypeRef =\n+Type =\n   ParenType\n | TupleType\n | NeverType\n@@ -204,10 +204,10 @@ TypeRef =\n | DynTraitType\n \n ParenType =\n-  '(' ty:TypeRef ')'\n+  '(' Type ')'\n \n TupleType =\n-  '(' fields:TypeRef* ')'\n+  '(' fields:Type* ')'\n \n NeverType =\n   '!'\n@@ -216,16 +216,16 @@ PathType =\n   Path\n \n PointerType =\n-  '*' ('const' | 'mut') ty:TypeRef\n+  '*' ('const' | 'mut') Type\n \n ArrayType =\n-  '[' ty:TypeRef ';' Expr ']'\n+  '[' Type ';' Expr ']'\n \n SliceType =\n-  '[' ty:TypeRef ']'\n+  '[' Type ']'\n \n ReferenceType =\n-  '&' 'lifetime'? 'mut'? ty:TypeRef\n+  '&' 'lifetime'? 'mut'? Type\n \n PlaceholderType =\n    '_'\n@@ -234,7 +234,7 @@ FnPointerType =\n    Abi 'unsafe'? 'fn' ParamList RetType?\n \n ForType =\n-   'for' GenericParamList ty:TypeRef\n+   'for' GenericParamList Type\n \n ImplTraitType =\n   'impl' TypeBoundList\n@@ -322,7 +322,7 @@ TryExpr =\n   Attr* Expr '?'\n \n CastExpr =\n-  Attr* Expr 'as' ty:TypeRef\n+  Attr* Expr 'as' Type\n \n RefExpr =\n   Attr* '&' ('raw' | 'mut' | 'const') Expr\n@@ -444,13 +444,13 @@ MacroStmts =\n   Expr?\n \n TypeBound =\n-  'lifetime' | 'const'? TypeRef\n+  'lifetime' | 'const'? Type\n \n TypeBoundList =\n    bounds:TypeBound*\n \n WherePred =\n-  ('for' GenericParamList)?  ('lifetime' | TypeRef) ':' TypeBoundList\n+  ('for' GenericParamList)?  ('lifetime' | Type) ':' TypeBoundList\n \n WhereClause =\n   'where' predicates:WherePred*\n@@ -459,7 +459,7 @@ ExprStmt =\n   Attr* Expr ';'\n \n LetStmt =\n-  Attr* 'let' Pat (':' ty:TypeRef)\n+  Attr* 'let' Pat (':' Type)\n   '=' initializer:Expr ';'\n \n Path =\n@@ -478,10 +478,10 @@ TypeArgList =\n   '>'\n \n TypeArg =\n-  TypeRef\n+  Type\n \n AssocTypeArg =\n-  NameRef (':' TypeBoundList | '=' TypeRef)\n+  NameRef (':' TypeBoundList | '=' Type)\n \n LifetimeArg =\n   'lifetime'"}]}