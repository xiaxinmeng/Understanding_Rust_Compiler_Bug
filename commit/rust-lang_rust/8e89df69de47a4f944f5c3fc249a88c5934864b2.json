{"sha": "8e89df69de47a4f944f5c3fc249a88c5934864b2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhlODlkZjY5ZGU0N2E0Zjk0NGY1YzNmYzI0OWE4OGM1OTM0ODY0YjI=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-01-06T00:19:12Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-01-07T06:40:31Z"}, "message": "rejigger impl to have an opaque closure ptr rather than\nopaque closure", "tree": {"sha": "61217ebb7e337936f42018c2950b67c7dc7a1d2b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/61217ebb7e337936f42018c2950b67c7dc7a1d2b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8e89df69de47a4f944f5c3fc249a88c5934864b2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8e89df69de47a4f944f5c3fc249a88c5934864b2", "html_url": "https://github.com/rust-lang/rust/commit/8e89df69de47a4f944f5c3fc249a88c5934864b2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8e89df69de47a4f944f5c3fc249a88c5934864b2/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7db640e63d36a1c812295e88a3d059ce5c70115d", "url": "https://api.github.com/repos/rust-lang/rust/commits/7db640e63d36a1c812295e88a3d059ce5c70115d", "html_url": "https://github.com/rust-lang/rust/commit/7db640e63d36a1c812295e88a3d059ce5c70115d"}], "stats": {"total": 706, "additions": 403, "deletions": 303}, "files": [{"sha": "8e317ce0e9e5c079904f2d1a5966fbc550db221b", "filename": "src/comp/back/abi.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8e89df69de47a4f944f5c3fc249a88c5934864b2/src%2Fcomp%2Fback%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e89df69de47a4f944f5c3fc249a88c5934864b2/src%2Fcomp%2Fback%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Fabi.rs?ref=8e89df69de47a4f944f5c3fc249a88c5934864b2", "patch": "@@ -26,8 +26,8 @@ const frame_glue_fns_field_drop: int = 1;\n \n const frame_glue_fns_field_reloc: int = 2;\n \n+// n.b. must be same as cbox_elt_refcnt\n const box_rc_field_refcnt: int = 0;\n-\n const box_rc_field_body: int = 1;\n \n const general_code_alignment: int = 16;\n@@ -72,9 +72,13 @@ const obj_body_elt_inner_obj: int = 3;\n const fn_field_code: int = 0;\n const fn_field_box: int = 1;\n \n-const closure_elt_tydesc: int = 0;\n-const closure_elt_ty_params: int = 1;\n-const closure_elt_bindings: int = 2;\n+// closure_box, see trans_closure.rs\n+//\n+// n.b. the refcnt must be compatible with a normal box\n+const cbox_elt_refcnt: int = 0;\n+const cbox_elt_tydesc: int = 1;\n+const cbox_elt_ty_params: int = 2;\n+const cbox_elt_bindings: int = 3;\n \n const vec_elt_fill: int = 0;\n "}, {"sha": "ae65c284fc2bebc5beb3da4f4f839dac8dabcc3b", "filename": "src/comp/metadata/tydecode.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8e89df69de47a4f944f5c3fc249a88c5934864b2/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e89df69de47a4f944f5c3fc249a88c5934864b2/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Ftydecode.rs?ref=8e89df69de47a4f944f5c3fc249a88c5934864b2", "patch": "@@ -277,7 +277,14 @@ fn parse_ty(st: @pstate, conv: conv_did) -> ty::t {\n       'E' { let def = parse_def(st, conv); ret ty::mk_native(st.tcx, def); }\n       'Y' { ret ty::mk_type(st.tcx); }\n       'y' { ret ty::mk_send_type(st.tcx); }\n-      'C' { ret ty::mk_opaque_closure(st.tcx); }\n+      'C' {\n+        let ck = alt next(st) as char {\n+          '&' { ty::closure_block }\n+          '@' { ty::closure_shared }\n+          '~' { ty::closure_send }\n+        };\n+        ret ty::mk_opaque_closure_ptr(st.tcx, ck);\n+      }\n       '#' {\n         let pos = parse_hex(st);\n         assert (next(st) as char == ':');"}, {"sha": "f5c4c91d0ac67d41826ffea318fba5ff44be81fe", "filename": "src/comp/metadata/tyencode.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8e89df69de47a4f944f5c3fc249a88c5934864b2/src%2Fcomp%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e89df69de47a4f944f5c3fc249a88c5934864b2/src%2Fcomp%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Ftyencode.rs?ref=8e89df69de47a4f944f5c3fc249a88c5934864b2", "patch": "@@ -189,7 +189,9 @@ fn enc_sty(w: io::writer, cx: @ctxt, st: ty::sty) {\n       }\n       ty::ty_type. { w.write_char('Y'); }\n       ty::ty_send_type. { w.write_char('y'); }\n-      ty::ty_opaque_closure. { w.write_char('C'); }\n+      ty::ty_opaque_closure_ptr(ty::closure_block.) { w.write_str(\"C&\"); }\n+      ty::ty_opaque_closure_ptr(ty::closure_shared.) { w.write_str(\"C@\"); }\n+      ty::ty_opaque_closure_ptr(ty::closure_send.) { w.write_str(\"C~\"); }\n       ty::ty_constr(ty, cs) {\n         w.write_str(\"A[\");\n         enc_ty(w, cx, ty);"}, {"sha": "43afb88361bc761dcab6f2787f8828cb77f65f81", "filename": "src/comp/middle/shape.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8e89df69de47a4f944f5c3fc249a88c5934864b2/src%2Fcomp%2Fmiddle%2Fshape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e89df69de47a4f944f5c3fc249a88c5934864b2/src%2Fcomp%2Fmiddle%2Fshape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fshape.rs?ref=8e89df69de47a4f944f5c3fc249a88c5934864b2", "patch": "@@ -51,7 +51,7 @@ const shape_obj: u8 = 19u8;\n const shape_res: u8 = 20u8;\n const shape_var: u8 = 21u8;\n const shape_uniq: u8 = 22u8;\n-const shape_opaque_closure: u8 = 23u8; // the closure itself.\n+const shape_opaque_closure_ptr: u8 = 23u8; // the closure itself.\n \n // FIXME: This is a bad API in trans_common.\n fn C_u8(n: u8) -> ValueRef { ret trans_common::C_u8(n as uint); }\n@@ -419,8 +419,8 @@ fn shape_of(ccx: @crate_ctxt, t: ty::t, ty_param_map: [uint],\n       ty::ty_fn(_) {\n         s += [shape_fn];\n       }\n-      ty::ty_opaque_closure. {\n-        s += [shape_opaque_closure];\n+      ty::ty_opaque_closure_ptr(_) {\n+        s += [shape_opaque_closure_ptr];\n       }\n     }\n "}, {"sha": "fa4a1a729693ec59d04fbd4807714e6424091e16", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 14, "deletions": 54, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/8e89df69de47a4f944f5c3fc249a88c5934864b2/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e89df69de47a4f944f5c3fc249a88c5934864b2/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=8e89df69de47a4f944f5c3fc249a88c5934864b2", "patch": "@@ -93,7 +93,7 @@ fn type_of_fn(cx: @crate_ctxt, sp: span, is_method: bool, inputs: [ty::arg],\n     if is_method {\n         atys += [T_ptr(cx.rust_object_type)];\n     } else {\n-        atys += [T_opaque_boxed_closure_ptr(cx)];\n+        atys += [T_opaque_cbox_ptr(cx)];\n     }\n \n     // Args >2: ty params, if not acquired via capture...\n@@ -202,8 +202,8 @@ fn type_of_inner(cx: @crate_ctxt, sp: span, t: ty::t)\n         }\n         T_struct(tys)\n       }\n-      ty::ty_opaque_closure. {\n-        T_opaque_closure(cx)\n+      ty::ty_opaque_closure_ptr(_) {\n+        T_opaque_cbox_ptr(cx)\n       }\n       ty::ty_constr(subt,_) {\n         // FIXME: could be a constraint on ty_fn\n@@ -415,25 +415,13 @@ fn llalign_of(cx: @crate_ctxt, t: TypeRef) -> ValueRef {\n }\n \n fn size_of(bcx: @block_ctxt, t: ty::t) -> result {\n-    assert !ty::type_has_opaque_size(bcx_tcx(bcx), t);\n     let {bcx, sz, align: _} = metrics(bcx, t, none);\n     rslt(bcx, sz)\n }\n \n fn align_of(bcx: @block_ctxt, t: ty::t) -> result {\n-    assert !ty::type_has_opaque_size(bcx_tcx(bcx), t);\n-    alt ty::struct(ccx.tcx, t) {\n-      ty::ty_opaque_closure. {\n-        // Hack: the alignment of an opaque closure is always defined as the\n-        // alignment of a pointer.  This is not, however, strictly correct,\n-        // depending on your point of view.  \n-        llalign_of(bcx, T_ptr(T_i8()));\n-      }\n-      _ {\n-        let {bcx, sz: _, align} = metrics(bcx, t, none);\n-        rslt(bcx, align)\n-      }\n-    }\n+    let {bcx, sz: _, align} = metrics(bcx, t, none);\n+    rslt(bcx, align)\n }\n \n // Computes the size/alignment of the type `t`.  `opt_v`, if provided, should\n@@ -443,8 +431,6 @@ fn align_of(bcx: @block_ctxt, t: ty::t) -> result {\n // instance is required.\n fn metrics(bcx: @block_ctxt, t: ty::t, opt_v: option<ValueRef>)\n     -> metrics_result {\n-    assert (option::is_some(opt_v) ||\n-            !ty::type_has_opaque_size(bcx_tcx(bcx), t));\n     let ccx = bcx_ccx(bcx);\n     if check type_has_static_size(ccx, t) {\n         let sp = bcx.sp;\n@@ -651,29 +637,6 @@ fn dynamic_metrics(bcx: @block_ctxt,\n         let total_align = C_int(bcx_ccx(bcx), 1); // FIXME: stub\n         ret {bcx: bcx, sz: total_size, align: total_align};\n       }\n-      ty::ty_opaque_closure. {\n-        // Unlike most other types, the type of an opaque closure does not\n-        // fully specify its size.  This is because the opaque closure type\n-        // only says that this is a closure over some data, but doesn't say\n-        // how much data there is (hence the word opaque).  This is an\n-        // unavoidable consequence of the way that closures encapsulate the\n-        // closed over data.  Therefore the only way to know the\n-        // size/alignment of a particular opaque closure instance is to load\n-        // the type descriptor from the instance and consult its\n-        // size/alignment fields.  Note that it is meaningless to say \"what is\n-        // the size of the type opaque closure?\" One can only ask \"what is the\n-        // size of this particular opaque closure?\"\n-        let v = alt opt_v {\n-          none. { fail \"Require value to compute metrics of opaque closures\"; }\n-          some(v) { v }\n-        };\n-        let v = PointerCast(bcx, v, T_ptr(T_opaque_closure(bcx_ccx(bcx))));\n-        let tdptrptr = GEPi(bcx, v, [0, abi::closure_elt_tydesc]);\n-        let tdptr = Load(bcx, tdptrptr);\n-        let sz = Load(bcx, GEPi(bcx, tdptr, [0, abi::tydesc_field_size]));\n-        let align = Load(bcx, GEPi(bcx, tdptr, [0, abi::tydesc_field_align]));\n-        ret { bcx: bcx, sz: sz, align: align };\n-      }\n     }\n }\n \n@@ -1354,9 +1317,8 @@ fn make_take_glue(cx: @block_ctxt, v: ValueRef, t: ty::t) {\n       ty::ty_native_fn(_, _) | ty::ty_fn(_) {\n         trans_closure::make_fn_glue(bcx, v, t, take_ty)\n       }\n-      ty::ty_opaque_closure. {\n-        trans_closure::call_opaque_closure_glue(\n-            bcx, v, abi::tydesc_field_take_glue)\n+      ty::ty_opaque_closure_ptr(ck) {\n+        trans_closure::make_opaque_cbox_take_glue(bcx, ck, v)\n       }\n       _ when ty::type_is_structural(bcx_tcx(bcx), t) {\n         iter_structural_ty(bcx, v, t, take_ty)\n@@ -1429,9 +1391,8 @@ fn make_free_glue(bcx: @block_ctxt, v: ValueRef, t: ty::t) {\n       ty::ty_native_fn(_, _) | ty::ty_fn(_) {\n         trans_closure::make_fn_glue(bcx, v, t, free_ty)\n       }\n-      ty::ty_opaque_closure. {\n-        trans_closure::call_opaque_closure_glue(\n-            bcx, v, abi::tydesc_field_free_glue)\n+      ty::ty_opaque_closure_ptr(ck) {\n+        trans_closure::make_opaque_cbox_free_glue(bcx, ck, v)\n       }\n       _ { bcx }\n     };\n@@ -1458,9 +1419,8 @@ fn make_drop_glue(bcx: @block_ctxt, v0: ValueRef, t: ty::t) {\n           ty::ty_native_fn(_, _) | ty::ty_fn(_) {\n             trans_closure::make_fn_glue(bcx, v0, t, drop_ty)\n           }\n-          ty::ty_opaque_closure. {\n-            trans_closure::call_opaque_closure_glue(\n-                bcx, v0, abi::tydesc_field_drop_glue)\n+          ty::ty_opaque_closure_ptr(ck) {\n+            trans_closure::make_opaque_cbox_drop_glue(bcx, ck, v0)\n           }\n           _ {\n             if ty::type_needs_drop(ccx.tcx, t) &&\n@@ -2617,7 +2577,7 @@ type lval_maybe_callee = {bcx: @block_ctxt,\n                           generic: option::t<generic_info>};\n \n fn null_env_ptr(bcx: @block_ctxt) -> ValueRef {\n-    C_null(T_opaque_boxed_closure_ptr(bcx_ccx(bcx)))\n+    C_null(T_opaque_cbox_ptr(bcx_ccx(bcx)))\n }\n \n fn lval_from_local_var(bcx: @block_ctxt, r: local_var_result) -> lval_result {\n@@ -3274,7 +3234,7 @@ fn trans_call(in_cx: @block_ctxt, f: @ast::expr,\n     let llenv, dict_param = none;\n     alt f_res.env {\n       null_env. {\n-        llenv = llvm::LLVMGetUndef(T_opaque_boxed_closure_ptr(bcx_ccx(cx)));\n+        llenv = llvm::LLVMGetUndef(T_opaque_cbox_ptr(bcx_ccx(cx)));\n       }\n       obj_env(e) { llenv = e; }\n       dict_env(dict, e) { llenv = e; dict_param = some(dict); }\n@@ -5257,7 +5217,7 @@ fn fill_fn_pair(bcx: @block_ctxt, pair: ValueRef, llfn: ValueRef,\n     Store(bcx, llfn, code_cell);\n     let env_cell = GEPi(bcx, pair, [0, abi::fn_field_box]);\n     let llenvblobptr =\n-        PointerCast(bcx, llenvptr, T_opaque_boxed_closure_ptr(ccx));\n+        PointerCast(bcx, llenvptr, T_opaque_cbox_ptr(ccx));\n     Store(bcx, llenvblobptr, env_cell);\n }\n "}, {"sha": "57791f17ee0f6e059b740f3246e60723d0e30930", "filename": "src/comp/middle/trans_closure.rs", "status": "modified", "additions": 335, "deletions": 183, "changes": 518, "blob_url": "https://github.com/rust-lang/rust/blob/8e89df69de47a4f944f5c3fc249a88c5934864b2/src%2Fcomp%2Fmiddle%2Ftrans_closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e89df69de47a4f944f5c3fc249a88c5934864b2/src%2Fcomp%2Fmiddle%2Ftrans_closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_closure.rs?ref=8e89df69de47a4f944f5c3fc249a88c5934864b2", "patch": "@@ -31,28 +31,22 @@ import trans::{\n // roughly as follows:\n //\n // struct closure_box {\n-//    unsigned ref_count; // only used for sharid environments\n-//    struct closure {\n-//      type_desc *tydesc;         // descriptor for the \"struct closure\" type\n-//      type_desc *bound_tdescs[]; // bound descriptors\n-//      struct {\n-//          upvar1_t upvar1;\n-//          ...\n-//          upvarN_t upvarN;\n-//      } bound_data;\n-//   };\n+//   unsigned ref_count; // only used for shared environments\n+//   type_desc *tydesc;  // descriptor for the \"struct closure_box\" type\n+//   type_desc *bound_tdescs[]; // bound descriptors\n+//   struct {\n+//     upvar1_t upvar1;\n+//     ...\n+//     upvarN_t upvarN;\n+//   } bound_data;\n // };\n //\n-// NB: this struct is defined in the code in trans_common::T_closure()\n-// and mk_closure_ty() below.  The former defines the LLVM version and\n-// the latter the Rust equivalent.  It occurs to me that these could\n-// perhaps be unified, but currently they are not.\n-//\n-// Note that the closure carries a type descriptor that describes\n-// itself.  Trippy.  This is needed because the precise types of the\n-// closed over data are lost in the closure type (`fn(T)->U`), so if\n-// we need to take/drop, we must know what data is in the upvars and\n-// so forth.\n+// Note that the closure carries a type descriptor that describes the\n+// closure itself.  Trippy.  This is needed because the precise types\n+// of the closed over data are lost in the closure type (`fn(T)->U`),\n+// so if we need to take/drop, we must know what data is in the upvars\n+// and so forth.  This struct is defined in the code in mk_closure_tys()\n+// below.\n //\n // The allocation strategy for this closure depends on the closure\n // type.  For a sendfn, the closure (and the referenced type\n@@ -63,6 +57,53 @@ import trans::{\n // easier when upcasting to block(T)->U, in the shape code, and so\n // forth.\n //\n+// ## Opaque Closures ##\n+//\n+// One interesting part of closures is that they encapsulate the data\n+// that they close over.  So when I have a ptr to a closure, I do not\n+// know how many type descriptors it contains nor what upvars are\n+// captured within.  That means I do not know precisely how big it is\n+// nor where its fields are located.  This is called an \"opaque\n+// closure\".\n+//\n+// Typically an opaque closure suffices because I only manipulate it\n+// by ptr.  The routine trans_common::T_opaque_cbox_ptr() returns an\n+// appropriate type for such an opaque closure; it allows access to the\n+// first two fields, but not the others.\n+//\n+// But sometimes, such as when cloning or freeing a closure, we need\n+// to know the full information.  That is where the type descriptor\n+// that defines the closure comes in handy.  We can use its take and\n+// drop glue functions to allocate/free data as needed.\n+//\n+// ## Subtleties concerning alignment ##\n+//\n+// You'll note that the closure_box structure is a flat structure with\n+// four fields.  In some ways, it would be more convenient to use a nested\n+// structure like so:\n+//\n+// struct {\n+//   int;\n+//   struct {\n+//     type_desc*;\n+//     type_desc*[];\n+//     bound_data;\n+// } }\n+//\n+// This would be more convenient because it would allow us to use more\n+// of the existing infrastructure: we could treat the inner struct as\n+// a type and then hvae a boxed variant (which would add the int) etc.\n+// However, there is one subtle problem with this: grouping the latter\n+// 3 fields into an inner struct causes the alignment of the entire\n+// struct to be the max alignment of the bound_data.  This will\n+// therefore vary from closure to closure.  That would mean that we\n+// cannot reliably locate the initial type_desc* in an opaque closure!\n+// That's definitely a bad thing.  Therefore, I have elected to create\n+// a flat structure, even though it means some mild amount of code\n+// duplication (however, we used to do it the other way, and we were\n+// jumping through about as many hoops just trying to wedge a ref\n+// count into a unique pointer, so it's kind of a wash in the end).\n+//\n // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n \n tag environment_value {\n@@ -79,43 +120,123 @@ tag environment_value {\n     env_ref(ValueRef, ty::t, lval_kind);\n }\n \n-// Given a closure ty, emits a corresponding tuple ty\n-fn mk_closure_ty(tcx: ty::ctxt,\n-                 ck: ty::closure_kind,\n-                 ty_params: [fn_ty_param],\n-                 bound_data_ty: ty::t)\n-    -> ty::t {\n-    let tydesc_ty = alt ck {\n+fn mk_tydesc_ty(tcx: ty::ctxt, ck: ty::closure_kind) -> ty::t {\n+    ret alt ck {\n       ty::closure_block. | ty::closure_shared. { ty::mk_type(tcx) }\n       ty::closure_send. { ty::mk_send_type(tcx) }\n     };\n+}\n+\n+// Given a closure ty, emits a corresponding tuple ty\n+fn mk_closure_tys(tcx: ty::ctxt,\n+                  ck: ty::closure_kind,\n+                  ty_params: [fn_ty_param],\n+                  bound_values: [environment_value]) -> (ty::t, [ty::t]) {\n+    let bound_tys = [];\n+\n+    let tydesc_ty =\n+        mk_tydesc_ty(tcx, ck);\n+\n+    // Compute the closed over tydescs\n     let param_ptrs = [];\n     for tp in ty_params {\n         param_ptrs += [tydesc_ty];\n         option::may(tp.dicts) {|dicts|\n             for dict in dicts { param_ptrs += [tydesc_ty]; }\n         }\n     }\n-    ty::mk_tup(tcx, [tydesc_ty, ty::mk_tup(tcx, param_ptrs), bound_data_ty])\n-}\n \n-fn shared_opaque_closure_box_ty(tcx: ty::ctxt) -> ty::t {\n-    let opaque_closure_ty = ty::mk_opaque_closure(tcx);\n-    ret ty::mk_imm_box(tcx, opaque_closure_ty);\n+    // Compute the closed over data\n+    for bv in bound_values {\n+        bound_tys += [alt bv {\n+            env_copy(_, t, _) { t }\n+            env_move(_, t, _) { t }\n+            env_ref(_, t, _) { t }\n+            env_expr(e) { ty::expr_ty(tcx, e) }\n+        }];\n+    }\n+    let bound_data_ty = ty::mk_tup(tcx, bound_tys);\n+\n+    // closure_ty == ref count, data tydesc, typarams, bound data\n+    let closure_ty =\n+        ty::mk_tup(tcx, [ty::mk_int(tcx), tydesc_ty,\n+                         ty::mk_tup(tcx, param_ptrs), bound_data_ty]);\n+\n+    ret (closure_ty, bound_tys);\n }\n \n-fn send_opaque_closure_box_ty(tcx: ty::ctxt) -> ty::t {\n-    let opaque_closure_ty = ty::mk_opaque_closure(tcx);\n-    let tup_ty = ty::mk_tup(tcx, [ty::mk_int(tcx), opaque_closure_ty]);\n-    ret ty::mk_uniq(tcx, {ty: tup_ty, mut: ast::imm});\n+fn allocate_cbox(bcx: @block_ctxt,\n+                 ck: ty::closure_kind,\n+                 cbox_ty: ty::t)\n+    -> (@block_ctxt, ValueRef, [ValueRef]) {\n+\n+    fn alloc_in_heap(bcx: @block_ctxt,\n+                     cbox_ty: ty::t,\n+                     shared: bool,\n+                     &temp_cleanups: [ValueRef])\n+        -> (@block_ctxt, ValueRef) {\n+\n+        // n.b. If you are wondering why we don't use\n+        // trans_malloc_boxed() or alloc_uniq(), see the section about\n+        // \"Subtleties concerning alignment\" in the big comment at the\n+        // top of the file.\n+\n+        let {bcx, val:llsz} = size_of(bcx, cbox_ty);\n+        let ti = none;\n+        let {bcx, val:lltydesc} =\n+            get_tydesc(bcx, cbox_ty, true, tps_normal, ti).result;\n+        let malloc =\n+            if shared { bcx_ccx(bcx).upcalls.shared_malloc }\n+            else { bcx_ccx(bcx).upcalls.malloc };\n+        let box = Call(bcx, malloc, [llsz, lltydesc]);\n+        add_clean_free(bcx, box, shared);\n+        temp_cleanups += [box];\n+        (bcx, box)\n+    }\n+\n+    let ccx = bcx_ccx(bcx);\n+\n+    // Allocate the box:\n+    let temp_cleanups = [];\n+    let (bcx, box, rc) = alt ck {\n+      ty::closure_shared. {\n+        let (bcx, box) = alloc_in_heap(bcx, cbox_ty, false, temp_cleanups);\n+        (bcx, box, 1)\n+      }\n+      ty::closure_send. {\n+        let (bcx, box) = alloc_in_heap(bcx, cbox_ty, true, temp_cleanups);\n+        (bcx, box, 0xdeadc0de) // use arbitrary value for debugging\n+      }\n+      ty::closure_block. {\n+        let {bcx, val: box} = trans::alloc_ty(bcx, cbox_ty);\n+        (bcx, box, 0xdeadc0df) // use arbitrary value for debugging\n+      }\n+    };\n+\n+    // Initialize ref count\n+    let box = PointerCast(bcx, box, T_opaque_cbox_ptr(ccx));\n+    let ref_cnt = GEPi(bcx, box, [0, abi::box_rc_field_refcnt]);\n+    Store(bcx, C_int(ccx, rc), ref_cnt);\n+\n+    ret (bcx, box, temp_cleanups);\n }\n \n type closure_result = {\n-    llbox: ValueRef,  // llvalue of boxed environment\n-    box_ty: ty::t,    // type of boxed environment\n-    bcx: @block_ctxt  // final bcx\n+    llbox: ValueRef,     // llvalue of ptr to closure\n+    cboxptr_ty: ty::t,   // type of ptr to closure\n+    bcx: @block_ctxt     // final bcx\n };\n \n+fn cast_if_we_can(bcx: @block_ctxt, llbox: ValueRef, t: ty::t) -> ValueRef {\n+    let ccx = bcx_ccx(bcx);\n+    if check type_has_static_size(ccx, t) {\n+        let llty = type_of(ccx, bcx.sp, t);\n+        ret PointerCast(bcx, llbox, llty);\n+    } else {\n+        ret llbox;\n+    }\n+}\n+\n // Given a block context and a list of tydescs and values to bind\n // construct a closure out of them. If copying is true, it is a\n // heap allocated closure that copies the upvars into environment.\n@@ -126,16 +247,6 @@ fn store_environment(\n     ck: ty::closure_kind)\n     -> closure_result {\n \n-    fn dummy_environment_box(bcx: @block_ctxt, r: result)\n-        -> (@block_ctxt, ValueRef, ValueRef) {\n-        // Prevent glue from trying to free this.\n-        let ccx = bcx_ccx(bcx);\n-        let ref_cnt = GEPi(bcx, r.val, [0, abi::box_rc_field_refcnt]);\n-        Store(r.bcx, C_int(ccx, 2), ref_cnt);\n-        let closure = GEPi(r.bcx, r.val, [0, abi::box_rc_field_body]);\n-        (r.bcx, closure, r.val)\n-    }\n-\n     fn maybe_clone_tydesc(bcx: @block_ctxt,\n                           ck: ty::closure_kind,\n                           td: ValueRef) -> ValueRef {\n@@ -152,61 +263,17 @@ fn store_environment(\n     //let ccx = bcx_ccx(bcx);\n     let tcx = bcx_tcx(bcx);\n \n-    // First, synthesize a tuple type containing the types of all the\n-    // bound expressions.\n-    // bindings_ty = [bound_ty1, bound_ty2, ...]\n-    let bound_tys = [];\n-    for bv in bound_values {\n-        bound_tys += [alt bv {\n-            env_copy(_, t, _) { t }\n-            env_move(_, t, _) { t }\n-            env_ref(_, t, _) { t }\n-            env_expr(e) { ty::expr_ty(tcx, e) }\n-        }];\n-    }\n-    let bound_data_ty = ty::mk_tup(tcx, bound_tys);\n-    let closure_ty =\n-        mk_closure_ty(tcx, ck, lltyparams, bound_data_ty);\n-\n-    let temp_cleanups = [];\n+    // compute the shape of the closure\n+    let (cbox_ty, bound_tys) =\n+        mk_closure_tys(tcx, ck, lltyparams, bound_values);\n \n-    // Allocate a box that can hold something closure-sized.\n-    //\n-    // For now, no matter what kind of closure we have, we always allocate\n-    // space for a ref cnt in the closure.  If the closure is a block or\n-    // unique closure, this ref count isn't really used: we initialize it to 2\n-    // so that it will never drop to zero.  This is a hack and could go away\n-    // but then we'd have to modify the code to do the right thing when\n-    // casting from a shared closure to a block.\n-    let (bcx, closure, box) = alt ck {\n-      ty::closure_shared. {\n-        let r = trans::trans_malloc_boxed(bcx, closure_ty);\n-        add_clean_free(bcx, r.box, false);\n-        temp_cleanups += [r.box];\n-        (r.bcx, r.body, r.box)\n-      }\n-      ty::closure_send. {\n-        // Dummy up a box in the exchange heap.\n-        let tup_ty = ty::mk_tup(tcx, [ty::mk_int(tcx), closure_ty]);\n-        let box_ty = ty::mk_uniq(tcx, {ty: tup_ty, mut: ast::imm});\n-        check trans_uniq::type_is_unique_box(bcx, box_ty);\n-        let r = trans_uniq::alloc_uniq(bcx, box_ty);\n-        add_clean_free(bcx, r.val, true);\n-        temp_cleanups += [r.val];\n-        dummy_environment_box(bcx, r)\n-      }\n-      ty::closure_block. {\n-        // Dummy up a box on the stack,\n-        let ty = ty::mk_tup(tcx, [ty::mk_int(tcx), closure_ty]);\n-        let r = trans::alloc_ty(bcx, ty);\n-        dummy_environment_box(bcx, r)\n-      }\n-    };\n+    // allocate closure in the heap\n+    let (bcx, llbox, temp_cleanups) = allocate_cbox(bcx, ck, cbox_ty);\n \n-    // Store bindings tydesc.\n+    // store data tydesc.\n     alt ck {\n       ty::closure_shared. | ty::closure_send. {\n-        let bound_tydesc = GEPi(bcx, closure, [0, abi::closure_elt_tydesc]);\n+        let bound_tydesc = GEPi(bcx, llbox, [0, abi::cbox_elt_tydesc]);\n         let ti = none;\n \n         // NDM I believe this is the correct value,\n@@ -218,7 +285,7 @@ fn store_environment(\n \n         let tps = tps_normal;\n         let {result:closure_td, _} =\n-            trans::get_tydesc(bcx, closure_ty, true, tps, ti);\n+            trans::get_tydesc(bcx, cbox_ty, true, tps, ti);\n         trans::lazily_emit_tydesc_glue(bcx, abi::tydesc_field_take_glue, ti);\n         trans::lazily_emit_tydesc_glue(bcx, abi::tydesc_field_drop_glue, ti);\n         trans::lazily_emit_tydesc_glue(bcx, abi::tydesc_field_free_glue, ti);\n@@ -229,16 +296,18 @@ fn store_environment(\n       ty::closure_block. { /* skip this for blocks, not really relevant */ }\n     }\n \n-    check type_is_tup_like(bcx, closure_ty);\n-    let box_ty = ty::mk_imm_box(bcx_tcx(bcx), closure_ty);\n+    // cbox_ty has the form of a tuple: (a, b, c) we want a ptr to a\n+    // tuple.  This could be a ptr in uniq or a box or on stack,\n+    // whatever.\n+    let cboxptr_ty = ty::mk_ptr(tcx, {ty:cbox_ty, mut:ast::imm});\n+    let llbox = cast_if_we_can(bcx, llbox, cboxptr_ty);\n+    check type_is_tup_like(bcx, cboxptr_ty);\n \n     // If necessary, copy tydescs describing type parameters into the\n     // appropriate slot in the closure.\n     let {bcx:bcx, val:ty_params_slot} =\n-        GEP_tup_like_1(bcx, closure_ty, closure,\n-                       [0, abi::closure_elt_ty_params]);\n+        GEP_tup_like_1(bcx, cboxptr_ty, llbox, [0, abi::cbox_elt_ty_params]);\n     let off = 0;\n-\n     for tp in lltyparams {\n         let cloned_td = maybe_clone_tydesc(bcx, ck, tp.desc);\n         Store(bcx, cloned_td, GEPi(bcx, ty_params_slot, [0, off]));\n@@ -254,38 +323,36 @@ fn store_environment(\n \n     // Copy expr values into boxed bindings.\n     // Silly check\n+    let {bcx: bcx, val:bindings_slot} =\n+        GEP_tup_like_1(bcx, cboxptr_ty, llbox, [0, abi::cbox_elt_bindings]);\n     vec::iteri(bound_values) { |i, bv|\n-        let bound = trans::GEP_tup_like_1(bcx, box_ty, box,\n-                                          [0, abi::box_rc_field_body,\n-                                           abi::closure_elt_bindings,\n-                                           i as int]);\n-        bcx = bound.bcx;\n+        let bound_data = GEPi(bcx, bindings_slot, [0, i as int]);\n         alt bv {\n           env_expr(e) {\n-            bcx = trans::trans_expr_save_in(bcx, e, bound.val);\n-            add_clean_temp_mem(bcx, bound.val, bound_tys[i]);\n-            temp_cleanups += [bound.val];\n+            bcx = trans::trans_expr_save_in(bcx, e, bound_data);\n+            add_clean_temp_mem(bcx, bound_data, bound_tys[i]);\n+            temp_cleanups += [bound_data];\n           }\n           env_copy(val, ty, owned.) {\n             let val1 = load_if_immediate(bcx, val, ty);\n-            bcx = trans::copy_val(bcx, INIT, bound.val, val1, ty);\n+            bcx = trans::copy_val(bcx, INIT, bound_data, val1, ty);\n           }\n           env_copy(val, ty, owned_imm.) {\n-            bcx = trans::copy_val(bcx, INIT, bound.val, val, ty);\n+            bcx = trans::copy_val(bcx, INIT, bound_data, val, ty);\n           }\n           env_copy(_, _, temporary.) {\n             fail \"Cannot capture temporary upvar\";\n           }\n           env_move(val, ty, kind) {\n             let src = {bcx:bcx, val:val, kind:kind};\n-            bcx = move_val(bcx, INIT, bound.val, src, ty);\n+            bcx = move_val(bcx, INIT, bound_data, src, ty);\n           }\n           env_ref(val, ty, owned.) {\n-            Store(bcx, val, bound.val);\n+            Store(bcx, val, bound_data);\n           }\n           env_ref(val, ty, owned_imm.) {\n             let addr = do_spill_noroot(bcx, val);\n-            Store(bcx, addr, bound.val);\n+            Store(bcx, addr, bound_data);\n           }\n           env_ref(_, _, temporary.) {\n             fail \"Cannot capture temporary upvar\";\n@@ -294,7 +361,7 @@ fn store_environment(\n     }\n     for cleanup in temp_cleanups { revoke_clean(bcx, cleanup); }\n \n-    ret {llbox: box, box_ty: box_ty, bcx: bcx};\n+    ret {llbox: llbox, cboxptr_ty: cboxptr_ty, bcx: bcx};\n }\n \n // Given a context and a list of upvars, build a closure. This just\n@@ -338,23 +405,21 @@ fn build_closure(bcx0: @block_ctxt,\n // with the upvars and type descriptors.\n fn load_environment(enclosing_cx: @block_ctxt,\n                     fcx: @fn_ctxt,\n-                    boxed_closure_ty: ty::t,\n+                    cboxptr_ty: ty::t,\n                     cap_vars: [capture::capture_var],\n                     ck: ty::closure_kind) {\n     let bcx = new_raw_block_ctxt(fcx, fcx.llloadenv);\n-\n     let ccx = bcx_ccx(bcx);\n+\n     let sp = bcx.sp;\n-    check (type_has_static_size(ccx, boxed_closure_ty));\n-    let llty = type_of(ccx, sp, boxed_closure_ty);\n+    check (type_has_static_size(ccx, cboxptr_ty));\n+    let llty = type_of(ccx, sp, cboxptr_ty);\n     let llclosure = PointerCast(bcx, fcx.llenv, llty);\n \n     // Populate the type parameters from the environment. We need to\n     // do this first because the tydescs are needed to index into\n     // the bindings if they are dynamically sized.\n-    let lltydescs = GEPi(bcx, llclosure,\n-                         [0, abi::box_rc_field_body,\n-                          abi::closure_elt_ty_params]);\n+    let lltydescs = GEPi(bcx, llclosure, [0, abi::cbox_elt_ty_params]);\n     let off = 0;\n     for tp in copy enclosing_cx.fcx.lltyparams {\n         let tydesc = Load(bcx, GEPi(bcx, lltydescs, [0, off]));\n@@ -372,15 +437,15 @@ fn load_environment(enclosing_cx: @block_ctxt,\n     }\n \n     // Populate the upvars from the environment.\n-    let path = [0, abi::box_rc_field_body, abi::closure_elt_bindings];\n+    let path = [0, abi::cbox_elt_bindings];\n     let i = 0u;\n     vec::iter(cap_vars) { |cap_var|\n         alt cap_var.mode {\n           capture::cap_drop. { /* ignore */ }\n           _ {\n-            check type_is_tup_like(bcx, boxed_closure_ty);\n+            check type_is_tup_like(bcx, cboxptr_ty);\n             let upvarptr = GEP_tup_like(\n-                bcx, boxed_closure_ty, llclosure, path + [i as int]);\n+                bcx, cboxptr_ty, llclosure, path + [i as int]);\n             bcx = upvarptr.bcx;\n             let llupvarptr = upvarptr.val;\n             alt ck {\n@@ -415,9 +480,9 @@ fn trans_expr_fn(bcx: @block_ctxt,\n     let trans_closure_env = lambda(ck: ty::closure_kind) -> ValueRef {\n         let cap_vars = capture::compute_capture_vars(\n             ccx.tcx, id, proto, cap_clause);\n-        let {llbox, box_ty, bcx} = build_closure(bcx, cap_vars, ck);\n+        let {llbox, cboxptr_ty, bcx} = build_closure(bcx, cap_vars, ck);\n         trans_closure(sub_cx, sp, decl, body, llfn, no_self, [], id, {|fcx|\n-            load_environment(bcx, fcx, box_ty, cap_vars, ck);\n+            load_environment(bcx, fcx, cboxptr_ty, cap_vars, ck);\n         });\n         llbox\n     };\n@@ -427,7 +492,7 @@ fn trans_expr_fn(bcx: @block_ctxt,\n       ast::proto_shared(_) { trans_closure_env(ty::closure_shared) }\n       ast::proto_send. { trans_closure_env(ty::closure_send) }\n       ast::proto_bare. {\n-        let closure = C_null(T_opaque_boxed_closure_ptr(ccx));\n+        let closure = C_null(T_opaque_cbox_ptr(ccx));\n         trans_closure(sub_cx, sp, decl, body, llfn, no_self, [],\n                       id, {|_fcx|});\n         closure\n@@ -514,21 +579,35 @@ fn trans_bind_1(cx: @block_ctxt, outgoing_fty: ty::t,\n     };\n \n     // Actually construct the closure\n-    let {llbox, box_ty, bcx} = store_environment(\n+    let {llbox, cboxptr_ty, bcx} = store_environment(\n         bcx, vec::map(lltydescs, {|d| {desc: d, dicts: none}}),\n         env_vals + vec::map(bound, {|x| env_expr(x)}),\n         ty::closure_shared);\n \n     // Make thunk\n     let llthunk =\n         trans_bind_thunk(cx.fcx.lcx, cx.sp, pair_ty, outgoing_fty_real, args,\n-                         box_ty, *param_bounds, target_res);\n+                         cboxptr_ty, *param_bounds, target_res);\n \n     // Fill the function pair\n     fill_fn_pair(bcx, get_dest_addr(dest), llthunk.val, llbox);\n     ret bcx;\n }\n \n+fn make_null_test(\n+    in_bcx: @block_ctxt,\n+    ptr: ValueRef,\n+    blk: block(@block_ctxt) -> @block_ctxt)\n+    -> @block_ctxt {\n+    let not_null_bcx = new_sub_block_ctxt(in_bcx, \"not null\");\n+    let next_bcx = new_sub_block_ctxt(in_bcx, \"next\");\n+    let null_test = IsNull(in_bcx, ptr);\n+    CondBr(in_bcx, null_test, next_bcx.llbb, not_null_bcx.llbb);\n+    let not_null_bcx = blk(not_null_bcx);\n+    Br(not_null_bcx, next_bcx.llbb);\n+    ret next_bcx;\n+}\n+\n fn make_fn_glue(\n     cx: @block_ctxt,\n     v: ValueRef,\n@@ -538,52 +617,128 @@ fn make_fn_glue(\n     let bcx = cx;\n     let tcx = bcx_tcx(cx);\n \n-    let fn_env = lambda(blk: block(@block_ctxt, ValueRef) -> @block_ctxt)\n-        -> @block_ctxt {\n+    let fn_env = lambda(ck: ty::closure_kind) -> @block_ctxt {\n         let box_cell_v = GEPi(cx, v, [0, abi::fn_field_box]);\n         let box_ptr_v = Load(cx, box_cell_v);\n-        let inner_cx = new_sub_block_ctxt(cx, \"iter box\");\n-        let next_cx = new_sub_block_ctxt(cx, \"next\");\n-        let null_test = IsNull(cx, box_ptr_v);\n-        CondBr(cx, null_test, next_cx.llbb, inner_cx.llbb);\n-        inner_cx = blk(inner_cx, box_cell_v);\n-        Br(inner_cx, next_cx.llbb);\n-        ret next_cx;\n+        make_null_test(cx, box_ptr_v) {|bcx|\n+            let closure_ty = ty::mk_opaque_closure_ptr(tcx, ck);\n+            glue_fn(bcx, box_cell_v, closure_ty)\n+        }\n     };\n \n     ret alt ty::struct(tcx, t) {\n-      ty::ty_native_fn(_, _) | ty::ty_fn({proto: ast::proto_bare., _}) {\n-        bcx\n-      }\n-      ty::ty_fn({proto: ast::proto_block., _}) {\n-        bcx\n-      }\n+      ty::ty_native_fn(_, _) | ty::ty_fn({proto: ast::proto_bare., _}) { bcx }\n+      ty::ty_fn({proto: ast::proto_block., _}) { bcx }\n       ty::ty_fn({proto: ast::proto_send., _}) {\n-        fn_env({ |bcx, box_cell_v|\n-            let box_ty = trans_closure::send_opaque_closure_box_ty(tcx);\n-            glue_fn(bcx, box_cell_v, box_ty)\n-        })\n+        fn_env(ty::closure_send)\n       }\n       ty::ty_fn({proto: ast::proto_shared(_), _}) {\n-        fn_env({ |bcx, box_cell_v|\n-            let box_ty = trans_closure::shared_opaque_closure_box_ty(tcx);\n-            glue_fn(bcx, box_cell_v, box_ty)\n-        })\n+        fn_env(ty::closure_shared)\n       }\n       _ { fail \"make_fn_glue invoked on non-function type\" }\n     };\n }\n \n-fn call_opaque_closure_glue(bcx: @block_ctxt,\n-                            v: ValueRef,     // ptr to an opaque closure\n-                            field: int) -> @block_ctxt {\n+fn make_opaque_cbox_take_glue(\n+    bcx: @block_ctxt,\n+    ck: ty::closure_kind,\n+    cboxptr: ValueRef)     // ptr to ptr to the opaque closure\n+    -> @block_ctxt {\n+    // Easy cases:\n+    alt ck {\n+      ty::closure_block. { ret bcx; }\n+      ty::closure_shared. { ret incr_refcnt_of_boxed(bcx, Load(bcx, cboxptr)); }\n+      ty::closure_send. { /* hard case: */ }\n+    }\n+\n+    // Hard case, a deep copy:\n+    let ccx = bcx_ccx(bcx);\n+    let llopaquecboxty = T_opaque_cbox_ptr(ccx);\n+    let cbox_in = Load(bcx, cboxptr);\n+    make_null_test(bcx, cbox_in) {|bcx|\n+        // Load the size from the type descr found in the cbox\n+        let cbox_in = PointerCast(bcx, cbox_in, llopaquecboxty);\n+        let tydescptr = GEPi(bcx, cbox_in, [0, abi::cbox_elt_tydesc]);\n+        let tydesc = Load(bcx, tydescptr);\n+        let tydesc = PointerCast(bcx, tydesc, T_ptr(ccx.tydesc_type));\n+        let sz = Load(bcx, GEPi(bcx, tydesc, [0, abi::tydesc_field_size]));\n+\n+        // Allocate memory, update original ptr, and copy existing data\n+        let malloc = ccx.upcalls.shared_malloc;\n+        let cbox_out = Call(bcx, malloc, [sz, tydesc]);\n+        let cbox_out = PointerCast(bcx, cbox_out, llopaquecboxty);\n+        let {bcx, val: _} = call_memmove(bcx, cbox_out, cbox_in, sz);\n+        Store(bcx, cbox_out, cboxptr);\n+\n+        // Take the data in the tuple\n+        let ti = none;\n+        call_tydesc_glue_full(bcx, cbox_out, tydesc,\n+                              abi::tydesc_field_take_glue, ti);\n+        bcx\n+    }\n+}\n+\n+fn make_opaque_cbox_drop_glue(\n+    bcx: @block_ctxt,\n+    ck: ty::closure_kind,\n+    cboxptr: ValueRef)     // ptr to the opaque closure\n+    -> @block_ctxt {\n+    alt ck {\n+      ty::closure_block. { bcx }\n+      ty::closure_shared. {\n+        decr_refcnt_maybe_free(bcx, Load(bcx, cboxptr),\n+                               ty::mk_opaque_closure_ptr(bcx_tcx(bcx), ck))\n+      }\n+      ty::closure_send. {\n+        free_ty(bcx, Load(bcx, cboxptr),\n+                ty::mk_opaque_closure_ptr(bcx_tcx(bcx), ck))\n+      }\n+    }\n+}\n+\n+fn make_opaque_cbox_free_glue(\n+    bcx: @block_ctxt,\n+    ck: ty::closure_kind,\n+    cbox: ValueRef)     // ptr to the opaque closure\n+    -> @block_ctxt {\n+    alt ck {\n+      ty::closure_block. { ret bcx; }\n+      ty::closure_shared. | ty::closure_send. { /* hard cases: */ }\n+    }\n+\n     let ccx = bcx_ccx(bcx);\n-    let v = PointerCast(bcx, v, T_ptr(T_opaque_closure(ccx)));\n-    let tydescptr = GEPi(bcx, v, [0, abi::closure_elt_tydesc]);\n-    let tydesc = Load(bcx, tydescptr);\n-    let ti = none;\n-    call_tydesc_glue_full(bcx, v, tydesc, field, ti);\n-    ret bcx;\n+    make_null_test(bcx, cbox) {|bcx|\n+        // Load the type descr found in the cbox\n+        let lltydescty = T_ptr(ccx.tydesc_type);\n+        let cbox = PointerCast(bcx, cbox, T_opaque_cbox_ptr(ccx));\n+        let tydescptr = GEPi(bcx, cbox, [0, abi::cbox_elt_tydesc]);\n+        let tydesc = Load(bcx, tydescptr);\n+        let tydesc = PointerCast(bcx, tydesc, lltydescty);\n+\n+        // Null out the type descr in the cbox.  This is subtle:\n+        // we will be freeing the data in the cbox, and we may need the\n+        // information in the type descr to guide the GEP_tup_like process\n+        // etc if generic types are involved.  So we null it out at first\n+        // then free it manually below.\n+        Store(bcx, C_null(lltydescty), tydescptr);\n+\n+        // Drop the tuple data then free the descriptor\n+        let ti = none;\n+        call_tydesc_glue_full(bcx, cbox, tydesc,\n+                              abi::tydesc_field_drop_glue, ti);\n+\n+        // Free the ty descr (if necc) and the box itself\n+        alt ck {\n+          ty::closure_block. { fail \"Impossible.\"; }\n+          ty::closure_shared. {\n+            trans_free_if_not_gc(bcx, cbox)\n+          }\n+          ty::closure_send. {\n+            let bcx = trans_shared_free(bcx, tydesc);\n+            trans_shared_free(bcx, cbox)\n+          }\n+        }\n+    }\n }\n \n // pth is cx.path\n@@ -592,7 +747,7 @@ fn trans_bind_thunk(cx: @local_ctxt,\n                     incoming_fty: ty::t,\n                     outgoing_fty: ty::t,\n                     args: [option::t<@ast::expr>],\n-                    boxed_closure_ty: ty::t,\n+                    cboxptr_ty: ty::t,\n                     param_bounds: [ty::param_bounds],\n                     target_fn: option::t<ValueRef>)\n     -> {val: ValueRef, ty: TypeRef} {\n@@ -648,9 +803,9 @@ fn trans_bind_thunk(cx: @local_ctxt,\n     // to the original function.  So, let's create one of those:\n \n     // The llenv pointer needs to be the correct size.  That size is\n-    // 'boxed_closure_ty', which was determined by trans_bind.\n-    check (type_has_static_size(ccx, boxed_closure_ty));\n-    let llclosure_ptr_ty = type_of(ccx, sp, boxed_closure_ty);\n+    // 'cboxptr_ty', which was determined by trans_bind.\n+    check type_has_static_size(ccx, cboxptr_ty);\n+    let llclosure_ptr_ty = type_of(ccx, sp, cboxptr_ty);\n     let llclosure = PointerCast(l_bcx, fcx.llenv, llclosure_ptr_ty);\n \n     // \"target\", in this context, means the function that's having some of its\n@@ -660,15 +815,14 @@ fn trans_bind_thunk(cx: @local_ctxt,\n     // target function lives in the first binding spot.\n     let (lltargetfn, lltargetenv, starting_idx) = alt target_fn {\n       some(fptr) {\n-        (fptr, llvm::LLVMGetUndef(T_opaque_boxed_closure_ptr(ccx)), 0)\n+        (fptr, llvm::LLVMGetUndef(T_opaque_cbox_ptr(ccx)), 0)\n       }\n       none. {\n         // Silly check\n-        check type_is_tup_like(bcx, boxed_closure_ty);\n+        check type_is_tup_like(bcx, cboxptr_ty);\n         let {bcx: cx, val: pair} =\n-            GEP_tup_like(bcx, boxed_closure_ty, llclosure,\n-                         [0, abi::box_rc_field_body,\n-                          abi::closure_elt_bindings, 0]);\n+            GEP_tup_like(bcx, cboxptr_ty, llclosure,\n+                         [0, abi::cbox_elt_bindings, 0]);\n         let lltargetenv =\n             Load(cx, GEPi(cx, pair, [0, abi::fn_field_box]));\n         let lltargetfn = Load\n@@ -702,10 +856,9 @@ fn trans_bind_thunk(cx: @local_ctxt,\n     let llargs: [ValueRef] = [llretptr, lltargetenv];\n \n     // Copy in the type parameters.\n-    check type_is_tup_like(l_bcx, boxed_closure_ty);\n+    check type_is_tup_like(l_bcx, cboxptr_ty);\n     let {bcx: l_bcx, val: param_record} =\n-        GEP_tup_like(l_bcx, boxed_closure_ty, llclosure,\n-                     [0, abi::box_rc_field_body, abi::closure_elt_ty_params]);\n+        GEP_tup_like(l_bcx, cboxptr_ty, llclosure, [0, abi::cbox_elt_ty_params]);\n     let off = 0;\n     for param in param_bounds {\n         let dsc = Load(l_bcx, GEPi(l_bcx, param_record, [0, off])),\n@@ -743,11 +896,10 @@ fn trans_bind_thunk(cx: @local_ctxt,\n           // closure.\n           some(e) {\n             // Silly check\n-            check type_is_tup_like(bcx, boxed_closure_ty);\n+            check type_is_tup_like(bcx, cboxptr_ty);\n             let bound_arg =\n-                GEP_tup_like(bcx, boxed_closure_ty, llclosure,\n-                             [0, abi::box_rc_field_body,\n-                              abi::closure_elt_bindings, b]);\n+                GEP_tup_like(bcx, cboxptr_ty, llclosure,\n+                             [0, abi::cbox_elt_bindings, b]);\n             bcx = bound_arg.bcx;\n             let val = bound_arg.val;\n             if out_arg.mode == ast::by_val { val = Load(bcx, val); }"}, {"sha": "8b99efc337b133e09fdbf67f1e33d9b738b83238", "filename": "src/comp/middle/trans_common.rs", "status": "modified", "additions": 8, "deletions": 28, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/8e89df69de47a4f944f5c3fc249a88c5934864b2/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e89df69de47a4f944f5c3fc249a88c5934864b2/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_common.rs?ref=8e89df69de47a4f944f5c3fc249a88c5934864b2", "patch": "@@ -542,7 +542,7 @@ fn T_fn(inputs: [TypeRef], output: TypeRef) -> TypeRef unsafe {\n }\n \n fn T_fn_pair(cx: @crate_ctxt, tfn: TypeRef) -> TypeRef {\n-    ret T_struct([T_ptr(tfn), T_opaque_boxed_closure_ptr(cx)]);\n+    ret T_struct([T_ptr(tfn), T_opaque_cbox_ptr(cx)]);\n }\n \n fn T_ptr(t: TypeRef) -> TypeRef { ret llvm::LLVMPointerType(t, 0u); }\n@@ -698,34 +698,14 @@ fn T_typaram(tn: type_names) -> TypeRef {\n \n fn T_typaram_ptr(tn: type_names) -> TypeRef { ret T_ptr(T_typaram(tn)); }\n \n-fn T_closure(cx: @crate_ctxt,\n-             llbindings_ty: TypeRef,\n-             n_ty_params: uint) -> TypeRef {\n-    ret T_struct([T_ptr(cx.tydesc_type),\n-                  T_captured_tydescs(cx, n_ty_params),\n-                  llbindings_ty])\n-}\n-\n-fn T_opaque_closure(cx: @crate_ctxt) -> TypeRef {\n-    let s = \"closure\";\n-    if cx.tn.name_has_type(s) { ret cx.tn.get_type(s); }\n-    let t = T_closure(cx, T_nil(), 0u);\n-    cx.tn.associate(s, t);\n-    ret t;\n-}\n-\n-fn T_boxed_closure_ptr(cx: @crate_ctxt, llbindings_ty: TypeRef,\n-                     n_ty_params: uint) -> TypeRef {\n-    // NB: keep this in sync with code in trans_bind; we're making\n-    // an LLVM typeref structure that has the same \"shape\" as the ty::t\n-    // it constructs.\n-    ret T_ptr(T_box(cx, T_closure(cx, llbindings_ty, n_ty_params)));\n-}\n-\n-fn T_opaque_boxed_closure_ptr(cx: @crate_ctxt) -> TypeRef {\n-    let s = \"*closure\";\n+fn T_opaque_cbox_ptr(cx: @crate_ctxt) -> TypeRef {\n+    let s = \"*cbox\";\n     if cx.tn.name_has_type(s) { ret cx.tn.get_type(s); }\n-    let t = T_boxed_closure_ptr(cx, T_nil(), 0u);\n+    let t = T_ptr(T_struct([cx.int_type,\n+                            T_ptr(cx.tydesc_type),\n+                            T_i8() /* represents closed over tydescs\n+                            and data go here; see trans_closure.rs*/\n+                           ]));\n     cx.tn.associate(s, t);\n     ret t;\n }"}, {"sha": "284cef0f289d33ef593f23fbf5c1eddce2327728", "filename": "src/comp/middle/trans_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8e89df69de47a4f944f5c3fc249a88c5934864b2/src%2Fcomp%2Fmiddle%2Ftrans_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e89df69de47a4f944f5c3fc249a88c5934864b2/src%2Fcomp%2Fmiddle%2Ftrans_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_impl.rs?ref=8e89df69de47a4f944f5c3fc249a88c5934864b2", "patch": "@@ -58,7 +58,7 @@ fn trans_self_arg(bcx: @block_ctxt, base: @ast::expr) -> result {\n     let {bcx, val} = trans_arg_expr(bcx, {mode: ast::by_ref, ty: basety},\n                                     T_ptr(type_of_or_i8(bcx, basety)), tz,\n                                     tr, base);\n-    rslt(bcx, PointerCast(bcx, val, T_opaque_boxed_closure_ptr(bcx_ccx(bcx))))\n+    rslt(bcx, PointerCast(bcx, val, T_opaque_cbox_ptr(bcx_ccx(bcx))))\n }\n \n fn trans_static_callee(bcx: @block_ctxt, e: @ast::expr, base: @ast::expr,"}, {"sha": "4c7c8942f289922b1ef5abcdad2ec1570ea2ae09", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 23, "deletions": 28, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/8e89df69de47a4f944f5c3fc249a88c5934864b2/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e89df69de47a4f944f5c3fc249a88c5934864b2/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=8e89df69de47a4f944f5c3fc249a88c5934864b2", "patch": "@@ -84,7 +84,7 @@ export mk_send_type;\n export mk_uint;\n export mk_uniq;\n export mk_var;\n-export mk_opaque_closure;\n+export mk_opaque_closure_ptr;\n export mk_named;\n export gen_ty;\n export mode;\n@@ -111,7 +111,7 @@ export ty_bool;\n export ty_bot;\n export ty_box;\n export ty_constr;\n-export ty_opaque_closure;\n+export ty_opaque_closure_ptr;\n export ty_constr_arg;\n export ty_float;\n export ty_fn, fn_ty;\n@@ -149,7 +149,6 @@ export kind_can_be_copied, kind_can_be_sent, proto_kind, kind_lteq, type_kind;\n export type_err;\n export type_err_to_str;\n export type_has_dynamic_size;\n-export type_has_opaque_size;\n export type_needs_drop;\n export type_is_bool;\n export type_is_bot;\n@@ -276,7 +275,7 @@ tag sty {\n     ty_send_type; // type_desc* that has been cloned into exchange heap\n     ty_native(def_id);\n     ty_constr(t, [@type_constr]);\n-    ty_opaque_closure; // type of a captured environment.\n+    ty_opaque_closure_ptr(closure_kind); // ptr to env for fn, fn@, fn~\n     ty_named(t, @str);\n }\n \n@@ -368,9 +367,7 @@ const idx_send_type: uint = 18u;\n \n const idx_bot: uint = 19u;\n \n-const idx_opaque_closure: uint = 20u;\n-\n-const idx_first_others: uint = 21u;\n+const idx_first_others: uint = 20u;\n \n type type_store = interner::interner<@raw_t>;\n \n@@ -400,7 +397,6 @@ fn populate_type_store(cx: ctxt) {\n     intern(cx, ty_type);\n     intern(cx, ty_send_type);\n     intern(cx, ty_bot);\n-    intern(cx, ty_opaque_closure);\n     assert (vec::len(cx.ts.vect) == idx_first_others);\n }\n \n@@ -471,7 +467,8 @@ fn mk_raw_ty(cx: ctxt, st: sty) -> @raw_t {\n     }\n     alt st {\n       ty_nil. | ty_bot. | ty_bool. | ty_int(_) | ty_float(_) | ty_uint(_) |\n-      ty_str. | ty_send_type. | ty_type. | ty_native(_) | ty_opaque_closure. {\n+      ty_str. | ty_send_type. | ty_type. | ty_native(_) |\n+      ty_opaque_closure_ptr(_) {\n         /* no-op */\n       }\n       ty_param(_, _) { has_params = true; }\n@@ -636,8 +633,8 @@ fn mk_send_type(_cx: ctxt) -> t { ret idx_send_type; }\n \n fn mk_native(cx: ctxt, did: def_id) -> t { ret gen_ty(cx, ty_native(did)); }\n \n-fn mk_opaque_closure(_cx: ctxt) -> t {\n-    ret idx_opaque_closure;\n+fn mk_opaque_closure_ptr(cx: ctxt, ck: closure_kind) -> t {\n+    ret gen_ty(cx, ty_opaque_closure_ptr(ck));\n }\n \n fn mk_named(cx: ctxt, base: t, name: @str) -> t {\n@@ -685,7 +682,8 @@ type ty_walk = fn@(t);\n fn walk_ty(cx: ctxt, walker: ty_walk, ty: t) {\n     alt struct(cx, ty) {\n       ty_nil. | ty_bot. | ty_bool. | ty_int(_) | ty_uint(_) | ty_float(_) |\n-      ty_str. | ty_send_type. | ty_type. | ty_native(_) | ty_opaque_closure. {\n+      ty_str. | ty_send_type. | ty_type. | ty_native(_) |\n+      ty_opaque_closure_ptr(_) {\n         /* no-op */\n       }\n       ty_box(tm) | ty_vec(tm) | ty_ptr(tm) { walk_ty(cx, walker, tm.ty); }\n@@ -739,7 +737,8 @@ fn fold_ty(cx: ctxt, fld: fold_mode, ty_0: t) -> t {\n     }\n     alt interner::get(*cx.ts, ty).struct {\n       ty_nil. | ty_bot. | ty_bool. | ty_int(_) | ty_uint(_) | ty_float(_) |\n-      ty_str. | ty_send_type. | ty_type. | ty_native(_) | ty_opaque_closure. {\n+      ty_str. | ty_send_type. | ty_type. | ty_native(_) |\n+      ty_opaque_closure_ptr(_) {\n         /* no-op */\n       }\n       ty_box(tm) {\n@@ -881,6 +880,7 @@ fn sequence_element_type(cx: ctxt, ty: t) -> t {\n pure fn type_is_tup_like(cx: ctxt, ty: t) -> bool {\n     let sty = struct(cx, ty);\n     alt sty {\n+      ty_ptr(_) | ty_uniq(_) |\n       ty_box(_) | ty_rec(_) | ty_tup(_) | ty_tag(_,_) { true }\n       _ { false }\n     }\n@@ -1058,7 +1058,9 @@ fn type_kind(cx: ctxt, ty: t) -> kind {\n       // anything about its fields.\n       ty_obj(_) { kind_copyable }\n       ty_fn(f) { proto_kind(f.proto) }\n-      ty_opaque_closure. { kind_noncopyable }\n+      ty_opaque_closure_ptr(closure_block.) { kind_noncopyable }\n+      ty_opaque_closure_ptr(closure_shared.) { kind_copyable }\n+      ty_opaque_closure_ptr(closure_send.) { kind_sendable }\n       // Those with refcounts-to-inner raise pinned to shared,\n       // lower unique to shared. Therefore just set result to shared.\n       ty_box(_) | ty_iface(_, _) { kind_copyable }\n@@ -1141,15 +1143,6 @@ fn type_structurally_contains(cx: ctxt, ty: t, test: fn(sty) -> bool) ->\n     }\n }\n \n-pure fn type_has_opaque_size(cx: ctxt, ty: t) -> bool unchecked {\n-    type_structurally_contains(cx, ty, fn (sty: sty) -> bool {\n-        alt sty {\n-          ty_opaque_closure. { true}\n-          _ { false }\n-        }\n-    })\n-}\n-\n pure fn type_has_dynamic_size(cx: ctxt, ty: t) -> bool unchecked {\n \n     /* type_structurally_contains can't be declared pure\n@@ -1162,7 +1155,7 @@ pure fn type_has_dynamic_size(cx: ctxt, ty: t) -> bool unchecked {\n     */\n     type_structurally_contains(cx, ty, fn (sty: sty) -> bool {\n         alt sty {\n-          ty_opaque_closure. | ty_param(_, _) { true }\n+          ty_param(_, _) { true }\n           _ { false }\n         }\n     })\n@@ -1424,13 +1417,15 @@ fn hash_type_structure(st: sty) -> uint {\n       }\n       ty_uniq(mt) { ret hash_subty(37u, mt.ty); }\n       ty_send_type. { ret 38u; }\n-      ty_opaque_closure. { ret 39u; }\n-      ty_named(t, name) { (str::hash(*name) << 5u) + hash_subty(40u, t) }\n+      ty_named(t, name) { (str::hash(*name) << 5u) + hash_subty(39u, t) }\n       ty_iface(did, tys) {\n-        let h = hash_def(41u, did);\n-        for typ: t in tys { h += (h << 5u) + typ; }\n+        let h = hash_def(40u, did);\n+        for typ: t in tys { h = hash_subty(h, typ); }\n         ret h;\n       }\n+      ty_opaque_closure_ptr(closure_block.) { ret 41u; }\n+      ty_opaque_closure_ptr(closure_shared.) { ret 42u; }\n+      ty_opaque_closure_ptr(closure_send.) { ret 43u; }\n     }\n }\n "}]}