{"sha": "177229bfde686bbfd66c0f6987f40b5ca282ab45", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE3NzIyOWJmZGU2ODZiYmZkNjZjMGY2OTg3ZjQwYjVjYTI4MmFiNDU=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-03-03T17:50:15Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-03-03T17:50:15Z"}, "message": "Move reference classification to ra_ide_db\n\nLost some marks along the way :-(", "tree": {"sha": "60220c642d71ea3dba2c526c7d880c28a14d261a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/60220c642d71ea3dba2c526c7d880c28a14d261a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/177229bfde686bbfd66c0f6987f40b5ca282ab45", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/177229bfde686bbfd66c0f6987f40b5ca282ab45", "html_url": "https://github.com/rust-lang/rust/commit/177229bfde686bbfd66c0f6987f40b5ca282ab45", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/177229bfde686bbfd66c0f6987f40b5ca282ab45/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "34d6e22fc12209417c15d215052857ddac79cdf4", "url": "https://api.github.com/repos/rust-lang/rust/commits/34d6e22fc12209417c15d215052857ddac79cdf4", "html_url": "https://github.com/rust-lang/rust/commit/34d6e22fc12209417c15d215052857ddac79cdf4"}], "stats": {"total": 181, "additions": 77, "deletions": 104}, "files": [{"sha": "6f0dbe065e9f0ce567c0b804f5d5d429fa69a323", "filename": "crates/ra_ide/src/goto_definition.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/177229bfde686bbfd66c0f6987f40b5ca282ab45/crates%2Fra_ide%2Fsrc%2Fgoto_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/177229bfde686bbfd66c0f6987f40b5ca282ab45/crates%2Fra_ide%2Fsrc%2Fgoto_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fgoto_definition.rs?ref=177229bfde686bbfd66c0f6987f40b5ca282ab45", "patch": "@@ -206,7 +206,6 @@ mod tests {\n \n     #[test]\n     fn goto_def_for_macros() {\n-        covers!(goto_def_for_macros);\n         check_goto(\n             \"\n             //- /lib.rs\n@@ -223,7 +222,6 @@ mod tests {\n \n     #[test]\n     fn goto_def_for_macros_from_other_crates() {\n-        covers!(goto_def_for_macros);\n         check_goto(\n             \"\n             //- /lib.rs\n@@ -335,7 +333,6 @@ mod tests {\n \n     #[test]\n     fn goto_def_for_methods() {\n-        covers!(goto_def_for_methods);\n         check_goto(\n             \"\n             //- /lib.rs\n@@ -355,7 +352,6 @@ mod tests {\n \n     #[test]\n     fn goto_def_for_fields() {\n-        covers!(goto_def_for_fields);\n         check_goto(\n             \"\n             //- /lib.rs\n@@ -374,7 +370,6 @@ mod tests {\n \n     #[test]\n     fn goto_def_for_record_fields() {\n-        covers!(goto_def_for_record_fields);\n         check_goto(\n             \"\n             //- /lib.rs\n@@ -787,7 +782,6 @@ mod tests {\n \n     #[test]\n     fn goto_def_for_field_init_shorthand() {\n-        covers!(goto_def_for_field_init_shorthand);\n         check_goto(\n             \"\n             //- /lib.rs"}, {"sha": "1236cb773c8b22fa839cf3a0319c095d5c40cee8", "filename": "crates/ra_ide/src/marks.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/177229bfde686bbfd66c0f6987f40b5ca282ab45/crates%2Fra_ide%2Fsrc%2Fmarks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/177229bfde686bbfd66c0f6987f40b5ca282ab45/crates%2Fra_ide%2Fsrc%2Fmarks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fmarks.rs?ref=177229bfde686bbfd66c0f6987f40b5ca282ab45", "patch": "@@ -3,11 +3,6 @@\n test_utils::marks!(\n     inserts_angle_brackets_for_generics\n     inserts_parens_for_function_calls\n-    goto_def_for_macros\n-    goto_def_for_methods\n-    goto_def_for_fields\n-    goto_def_for_record_fields\n-    goto_def_for_field_init_shorthand\n     call_info_bad_offset\n     dont_complete_current_use\n     test_resolve_parent_module_on_module_decl"}, {"sha": "bfc0c60474dbe973386f36ae7cc61e85a361216d", "filename": "crates/ra_ide/src/references.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/177229bfde686bbfd66c0f6987f40b5ca282ab45/crates%2Fra_ide%2Fsrc%2Freferences.rs", "raw_url": "https://github.com/rust-lang/rust/raw/177229bfde686bbfd66c0f6987f40b5ca282ab45/crates%2Fra_ide%2Fsrc%2Freferences.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Freferences.rs?ref=177229bfde686bbfd66c0f6987f40b5ca282ab45", "patch": "@@ -9,7 +9,6 @@\n //! at the index that the match starts at and its tree parent is\n //! resolved to the search element definition, we get a reference.\n \n-mod classify;\n mod rename;\n mod search_scope;\n \n@@ -27,11 +26,8 @@ use test_utils::tested_by;\n \n use crate::{display::TryToNav, FilePosition, FileRange, NavigationTarget, RangeInfo};\n \n-pub(crate) use self::{\n-    classify::{classify_name_ref, NameRefClass},\n-    rename::rename,\n-};\n-pub(crate) use ra_ide_db::defs::{classify_name, Definition};\n+pub(crate) use self::rename::rename;\n+pub(crate) use ra_ide_db::defs::{classify_name, classify_name_ref, Definition, NameRefClass};\n \n pub use self::search_scope::SearchScope;\n "}, {"sha": "0bbf893f876650a07dc4ad72dc0d705a026cdc1c", "filename": "crates/ra_ide/src/references/classify.rs", "status": "removed", "additions": 0, "deletions": 84, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/34d6e22fc12209417c15d215052857ddac79cdf4/crates%2Fra_ide%2Fsrc%2Freferences%2Fclassify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d6e22fc12209417c15d215052857ddac79cdf4/crates%2Fra_ide%2Fsrc%2Freferences%2Fclassify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Freferences%2Fclassify.rs?ref=34d6e22fc12209417c15d215052857ddac79cdf4", "patch": "@@ -1,84 +0,0 @@\n-//! Functions that are used to classify an element from its definition or reference.\n-\n-use hir::{Local, PathResolution, Semantics};\n-use ra_ide_db::defs::Definition;\n-use ra_ide_db::RootDatabase;\n-use ra_prof::profile;\n-use ra_syntax::{ast, AstNode};\n-use test_utils::tested_by;\n-\n-pub enum NameRefClass {\n-    Definition(Definition),\n-    FieldShorthand { local: Local, field: Definition },\n-}\n-\n-impl NameRefClass {\n-    pub fn definition(self) -> Definition {\n-        match self {\n-            NameRefClass::Definition(def) => def,\n-            NameRefClass::FieldShorthand { local, field: _ } => Definition::Local(local),\n-        }\n-    }\n-}\n-\n-pub(crate) fn classify_name_ref(\n-    sema: &Semantics<RootDatabase>,\n-    name_ref: &ast::NameRef,\n-) -> Option<NameRefClass> {\n-    let _p = profile(\"classify_name_ref\");\n-\n-    let parent = name_ref.syntax().parent()?;\n-\n-    if let Some(method_call) = ast::MethodCallExpr::cast(parent.clone()) {\n-        tested_by!(goto_def_for_methods);\n-        if let Some(func) = sema.resolve_method_call(&method_call) {\n-            return Some(NameRefClass::Definition(Definition::ModuleDef(func.into())));\n-        }\n-    }\n-\n-    if let Some(field_expr) = ast::FieldExpr::cast(parent.clone()) {\n-        tested_by!(goto_def_for_fields);\n-        if let Some(field) = sema.resolve_field(&field_expr) {\n-            return Some(NameRefClass::Definition(Definition::StructField(field)));\n-        }\n-    }\n-\n-    if let Some(record_field) = ast::RecordField::cast(parent.clone()) {\n-        tested_by!(goto_def_for_record_fields);\n-        tested_by!(goto_def_for_field_init_shorthand);\n-        if let Some((field, local)) = sema.resolve_record_field(&record_field) {\n-            let field = Definition::StructField(field);\n-            let res = match local {\n-                None => NameRefClass::Definition(field),\n-                Some(local) => NameRefClass::FieldShorthand { field, local },\n-            };\n-            return Some(res);\n-        }\n-    }\n-\n-    if let Some(macro_call) = parent.ancestors().find_map(ast::MacroCall::cast) {\n-        tested_by!(goto_def_for_macros);\n-        if let Some(macro_def) = sema.resolve_macro_call(&macro_call) {\n-            return Some(NameRefClass::Definition(Definition::Macro(macro_def)));\n-        }\n-    }\n-\n-    let path = name_ref.syntax().ancestors().find_map(ast::Path::cast)?;\n-    let resolved = sema.resolve_path(&path)?;\n-    let res = match resolved {\n-        PathResolution::Def(def) => Definition::ModuleDef(def),\n-        PathResolution::AssocItem(item) => {\n-            let def = match item {\n-                hir::AssocItem::Function(it) => it.into(),\n-                hir::AssocItem::Const(it) => it.into(),\n-                hir::AssocItem::TypeAlias(it) => it.into(),\n-            };\n-            Definition::ModuleDef(def)\n-        }\n-        PathResolution::Local(local) => Definition::Local(local),\n-        PathResolution::TypeParam(par) => Definition::TypeParam(par),\n-        PathResolution::Macro(def) => Definition::Macro(def),\n-        PathResolution::SelfType(impl_def) => Definition::SelfType(impl_def),\n-    };\n-    Some(NameRefClass::Definition(res))\n-}"}, {"sha": "f057435bf6fa07b949b63acbfff4762c639efa6b", "filename": "crates/ra_ide_db/src/defs.rs", "status": "modified", "additions": 75, "deletions": 3, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/177229bfde686bbfd66c0f6987f40b5ca282ab45/crates%2Fra_ide_db%2Fsrc%2Fdefs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/177229bfde686bbfd66c0f6987f40b5ca282ab45/crates%2Fra_ide_db%2Fsrc%2Fdefs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_db%2Fsrc%2Fdefs.rs?ref=177229bfde686bbfd66c0f6987f40b5ca282ab45", "patch": "@@ -6,8 +6,8 @@\n // FIXME: this badly needs rename/rewrite (matklad, 2020-02-06).\n \n use hir::{\n-    Adt, FieldSource, HasSource, ImplDef, Local, MacroDef, Module, ModuleDef, Name, Semantics,\n-    StructField, TypeParam,\n+    Adt, FieldSource, HasSource, ImplDef, Local, MacroDef, Module, ModuleDef, Name, PathResolution,\n+    Semantics, StructField, TypeParam,\n };\n use ra_prof::profile;\n use ra_syntax::{\n@@ -117,6 +117,8 @@ impl NameClass {\n }\n \n pub fn classify_name(sema: &Semantics<RootDatabase>, name: &ast::Name) -> Option<NameClass> {\n+    let _p = profile(\"classify_name\");\n+\n     if let Some(bind_pat) = name.syntax().parent().and_then(ast::BindPat::cast) {\n         if let Some(def) = sema.resolve_bind_pat_to_const(&bind_pat) {\n             return Some(NameClass::ConstReference(Definition::ModuleDef(def)));\n@@ -127,7 +129,6 @@ pub fn classify_name(sema: &Semantics<RootDatabase>, name: &ast::Name) -> Option\n }\n \n fn classify_name_inner(sema: &Semantics<RootDatabase>, name: &ast::Name) -> Option<Definition> {\n-    let _p = profile(\"classify_name\");\n     let parent = name.syntax().parent()?;\n \n     match_ast! {\n@@ -192,3 +193,74 @@ fn classify_name_inner(sema: &Semantics<RootDatabase>, name: &ast::Name) -> Opti\n         }\n     }\n }\n+\n+pub enum NameRefClass {\n+    Definition(Definition),\n+    FieldShorthand { local: Local, field: Definition },\n+}\n+\n+impl NameRefClass {\n+    pub fn definition(self) -> Definition {\n+        match self {\n+            NameRefClass::Definition(def) => def,\n+            NameRefClass::FieldShorthand { local, field: _ } => Definition::Local(local),\n+        }\n+    }\n+}\n+\n+pub fn classify_name_ref(\n+    sema: &Semantics<RootDatabase>,\n+    name_ref: &ast::NameRef,\n+) -> Option<NameRefClass> {\n+    let _p = profile(\"classify_name_ref\");\n+\n+    let parent = name_ref.syntax().parent()?;\n+\n+    if let Some(method_call) = ast::MethodCallExpr::cast(parent.clone()) {\n+        if let Some(func) = sema.resolve_method_call(&method_call) {\n+            return Some(NameRefClass::Definition(Definition::ModuleDef(func.into())));\n+        }\n+    }\n+\n+    if let Some(field_expr) = ast::FieldExpr::cast(parent.clone()) {\n+        if let Some(field) = sema.resolve_field(&field_expr) {\n+            return Some(NameRefClass::Definition(Definition::StructField(field)));\n+        }\n+    }\n+\n+    if let Some(record_field) = ast::RecordField::cast(parent.clone()) {\n+        if let Some((field, local)) = sema.resolve_record_field(&record_field) {\n+            let field = Definition::StructField(field);\n+            let res = match local {\n+                None => NameRefClass::Definition(field),\n+                Some(local) => NameRefClass::FieldShorthand { field, local },\n+            };\n+            return Some(res);\n+        }\n+    }\n+\n+    if let Some(macro_call) = parent.ancestors().find_map(ast::MacroCall::cast) {\n+        if let Some(macro_def) = sema.resolve_macro_call(&macro_call) {\n+            return Some(NameRefClass::Definition(Definition::Macro(macro_def)));\n+        }\n+    }\n+\n+    let path = name_ref.syntax().ancestors().find_map(ast::Path::cast)?;\n+    let resolved = sema.resolve_path(&path)?;\n+    let res = match resolved {\n+        PathResolution::Def(def) => Definition::ModuleDef(def),\n+        PathResolution::AssocItem(item) => {\n+            let def = match item {\n+                hir::AssocItem::Function(it) => it.into(),\n+                hir::AssocItem::Const(it) => it.into(),\n+                hir::AssocItem::TypeAlias(it) => it.into(),\n+            };\n+            Definition::ModuleDef(def)\n+        }\n+        PathResolution::Local(local) => Definition::Local(local),\n+        PathResolution::TypeParam(par) => Definition::TypeParam(par),\n+        PathResolution::Macro(def) => Definition::Macro(def),\n+        PathResolution::SelfType(impl_def) => Definition::SelfType(impl_def),\n+    };\n+    Some(NameRefClass::Definition(res))\n+}"}]}