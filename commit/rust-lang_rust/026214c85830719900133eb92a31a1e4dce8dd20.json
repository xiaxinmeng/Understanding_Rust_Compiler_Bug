{"sha": "026214c85830719900133eb92a31a1e4dce8dd20", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAyNjIxNGM4NTgzMDcxOTkwMDEzM2ViOTJhMzFhMWU0ZGNlOGRkMjA=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-09-20T22:56:20Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-11-19T00:14:32Z"}, "message": "rustc: collapse Layout::FatPointer into Layout::Univariant.", "tree": {"sha": "4aa4479248bbd8b5f659ca7928a983b3d66c050e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4aa4479248bbd8b5f659ca7928a983b3d66c050e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/026214c85830719900133eb92a31a1e4dce8dd20", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/026214c85830719900133eb92a31a1e4dce8dd20", "html_url": "https://github.com/rust-lang/rust/commit/026214c85830719900133eb92a31a1e4dce8dd20", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/026214c85830719900133eb92a31a1e4dce8dd20/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3fd6b00082c16369119c2f67981ceb8b47bc71a2", "url": "https://api.github.com/repos/rust-lang/rust/commits/3fd6b00082c16369119c2f67981ceb8b47bc71a2", "html_url": "https://github.com/rust-lang/rust/commit/3fd6b00082c16369119c2f67981ceb8b47bc71a2"}], "stats": {"total": 89, "additions": 47, "deletions": 42}, "files": [{"sha": "3e64a6a4c5d36ff20d7ec318d49ad9aba2343586", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 47, "deletions": 42, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/026214c85830719900133eb92a31a1e4dce8dd20/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/026214c85830719900133eb92a31a1e4dce8dd20/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=026214c85830719900133eb92a31a1e4dce8dd20", "patch": "@@ -849,9 +849,6 @@ pub enum Layout {\n     /// TyArray, TySlice or TyStr.\n     Array,\n \n-    /// TyRawPtr or TyRef with a !Sized pointee. The primitive is the metadata.\n-    FatPointer,\n-\n     // Remaining variants are all ADTs such as structs, enums or tuples.\n \n     /// Single-case enums, and structs/tuples.\n@@ -1132,7 +1129,7 @@ impl<'a, 'tcx> Layout {\n                 memory_index: vec![0, 1]\n             };\n             Ok(tcx.intern_layout(CachedLayout {\n-                layout: Layout::FatPointer,\n+                layout: Layout::Univariant,\n                 fields,\n                 abi: Abi::Aggregate {\n                     sized: true,\n@@ -1743,8 +1740,7 @@ impl<'a, 'tcx> Layout {\n             // via representation tweaks) size info beyond total size.\n             Layout::Scalar |\n             Layout::Vector |\n-            Layout::Array |\n-            Layout::FatPointer { .. } => {\n+            Layout::Array => {\n                 debug!(\"print-type-size t: `{:?}` adt other\", ty);\n                 record(adt_kind.into(), None, Vec::new())\n             }\n@@ -2047,17 +2043,37 @@ impl<'a, 'tcx> FullLayout<'tcx> {\n     fn field_type_unnormalized(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, i: usize) -> Ty<'tcx> {\n         let ptr_field_type = |pointee: Ty<'tcx>| {\n             assert!(i < 2);\n+            let mk_ptr = |ty: Ty<'tcx>| {\n+                match self.ty.sty {\n+                    ty::TyRef(r, ty::TypeAndMut { mutbl, .. }) => {\n+                        tcx.mk_ref(r, ty::TypeAndMut { ty, mutbl })\n+                    }\n+                    ty::TyRawPtr(ty::TypeAndMut { mutbl, .. }) => {\n+                        tcx.mk_ptr(ty::TypeAndMut { ty, mutbl })\n+                    }\n+                    ty::TyAdt(def, _) if def.is_box() => {\n+                        tcx.mk_box(ty)\n+                    }\n+                    _ => bug!()\n+                }\n+            };\n             let slice = |element: Ty<'tcx>| {\n                 if i == 0 {\n-                    tcx.mk_mut_ptr(element)\n+                    mk_ptr(element)\n                 } else {\n                     tcx.types.usize\n                 }\n             };\n             match tcx.struct_tail(pointee).sty {\n                 ty::TySlice(element) => slice(element),\n                 ty::TyStr => slice(tcx.types.u8),\n-                ty::TyDynamic(..) => Pointer.to_ty(tcx),\n+                ty::TyDynamic(..) => {\n+                    if i == 0 {\n+                        mk_ptr(tcx.mk_nil())\n+                    } else {\n+                        Pointer.to_ty(tcx)\n+                    }\n+                }\n                 _ => bug!(\"FullLayout::field_type({:?}): not applicable\", self)\n             }\n         };\n@@ -2187,9 +2203,16 @@ impl<'a, 'tcx> FullLayout<'tcx> {\n     {\n         let tcx = cx.tcx();\n         match (self.layout, self.abi, &self.ty.sty) {\n-            (&Layout::Scalar, Abi::Scalar(Pointer), _) if !self.ty.is_unsafe_ptr() => {\n+            // FIXME(eddyb) check this via value ranges on scalars.\n+            (&Layout::Scalar, Abi::Scalar(Pointer), &ty::TyRef(..)) |\n+            (&Layout::Scalar, Abi::Scalar(Pointer), &ty::TyFnPtr(..)) => {\n+                Ok(Some((Size::from_bytes(0), Pointer)))\n+            }\n+            (&Layout::Scalar, Abi::Scalar(Pointer), &ty::TyAdt(def, _)) if def.is_box() => {\n                 Ok(Some((Size::from_bytes(0), Pointer)))\n             }\n+\n+            // FIXME(eddyb) check this via value ranges on scalars.\n             (&Layout::General { discr, .. }, _, &ty::TyAdt(def, _)) => {\n                 if def.discriminants(tcx).all(|d| d.to_u128_unchecked() != 0) {\n                     Ok(Some((self.fields.offset(0), discr)))\n@@ -2198,28 +2221,28 @@ impl<'a, 'tcx> FullLayout<'tcx> {\n                 }\n             }\n \n-            (&Layout::FatPointer, _, _) if !self.ty.is_unsafe_ptr() => {\n-                Ok(Some((self.fields.offset(FAT_PTR_ADDR), Pointer)))\n-            }\n-\n             // Is this the NonZero lang item wrapping a pointer or integer type?\n             (_, _, &ty::TyAdt(def, _)) if Some(def.did) == tcx.lang_items().non_zero() => {\n                 let field = self.field(cx, 0)?;\n-                match (field.layout, field.abi) {\n-                    (&Layout::Scalar, Abi::Scalar(value)) => {\n-                        Ok(Some((self.fields.offset(0), value)))\n-                    }\n-                    (&Layout::FatPointer, _) => {\n-                        Ok(Some((self.fields.offset(0) +\n-                                 field.fields.offset(FAT_PTR_ADDR),\n-                                 Pointer)))\n-                    }\n-                    _ => Ok(None)\n+                let offset = self.fields.offset(0);\n+                if let Abi::Scalar(value) = field.abi {\n+                    Ok(Some((offset, value)))\n+                } else if let ty::TyRawPtr(_) = field.ty.sty {\n+                    // If `NonZero` contains a non-scalar `*T`, it's\n+                    // a fat pointer, which starts with a thin pointer.\n+                    Ok(Some((offset, Pointer)))\n+                } else {\n+                    Ok(None)\n                 }\n             }\n \n             // Perhaps one of the fields is non-zero, let's recurse and find out.\n-            (&Layout::Univariant, _, _) => {\n+            _ => {\n+                if let FieldPlacement::Array { count, .. } = *self.fields {\n+                    if count > 0 {\n+                        return self.field(cx, 0)?.non_zero_field(cx);\n+                    }\n+                }\n                 for i in 0..self.fields.count() {\n                     let r = self.field(cx, i)?.non_zero_field(cx)?;\n                     if let Some((offset, primitive)) = r {\n@@ -2228,23 +2251,6 @@ impl<'a, 'tcx> FullLayout<'tcx> {\n                 }\n                 Ok(None)\n             }\n-\n-            // Is this a fixed-size array of something non-zero\n-            // with at least one element?\n-            (_, _, &ty::TyArray(ety, _)) => {\n-                if self.fields.count() != 0 {\n-                    cx.layout_of(ety)?.non_zero_field(cx)\n-                } else {\n-                    Ok(None)\n-                }\n-            }\n-\n-            (_, _, &ty::TyProjection(_)) | (_, _, &ty::TyAnon(..)) => {\n-                bug!(\"FullLayout::non_zero_field: {:#?} not normalized\", self);\n-            }\n-\n-            // Anything else is not a non-zero type.\n-            _ => Ok(None)\n         }\n     }\n }\n@@ -2260,7 +2266,6 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for Layout {\n             Scalar => {}\n             Vector => {}\n             Array => {}\n-            FatPointer => {}\n             Univariant => {}\n             UntaggedUnion => {}\n             General {"}]}