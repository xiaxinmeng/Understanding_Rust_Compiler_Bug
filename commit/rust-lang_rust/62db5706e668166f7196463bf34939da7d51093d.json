{"sha": "62db5706e668166f7196463bf34939da7d51093d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYyZGI1NzA2ZTY2ODE2NmY3MTk2NDYzYmYzNDkzOWRhN2Q1MTA5M2Q=", "commit": {"author": {"name": "Paul Stansifer", "email": "paul.stansifer@gmail.com", "date": "2012-07-04T01:39:37Z"}, "committer": {"name": "Paul Stansifer", "email": "paul.stansifer@gmail.com", "date": "2012-07-06T01:09:31Z"}, "message": "Start letting the parser catch interpolated ASTs.", "tree": {"sha": "f75b731244e277afc1470cc53ed5fe5cd7a39965", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f75b731244e277afc1470cc53ed5fe5cd7a39965"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/62db5706e668166f7196463bf34939da7d51093d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/62db5706e668166f7196463bf34939da7d51093d", "html_url": "https://github.com/rust-lang/rust/commit/62db5706e668166f7196463bf34939da7d51093d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/62db5706e668166f7196463bf34939da7d51093d/comments", "author": {"login": "paulstansifer", "id": 1431, "node_id": "MDQ6VXNlcjE0MzE=", "avatar_url": "https://avatars.githubusercontent.com/u/1431?v=4", "gravatar_id": "", "url": "https://api.github.com/users/paulstansifer", "html_url": "https://github.com/paulstansifer", "followers_url": "https://api.github.com/users/paulstansifer/followers", "following_url": "https://api.github.com/users/paulstansifer/following{/other_user}", "gists_url": "https://api.github.com/users/paulstansifer/gists{/gist_id}", "starred_url": "https://api.github.com/users/paulstansifer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/paulstansifer/subscriptions", "organizations_url": "https://api.github.com/users/paulstansifer/orgs", "repos_url": "https://api.github.com/users/paulstansifer/repos", "events_url": "https://api.github.com/users/paulstansifer/events{/privacy}", "received_events_url": "https://api.github.com/users/paulstansifer/received_events", "type": "User", "site_admin": false}, "committer": {"login": "paulstansifer", "id": 1431, "node_id": "MDQ6VXNlcjE0MzE=", "avatar_url": "https://avatars.githubusercontent.com/u/1431?v=4", "gravatar_id": "", "url": "https://api.github.com/users/paulstansifer", "html_url": "https://github.com/paulstansifer", "followers_url": "https://api.github.com/users/paulstansifer/followers", "following_url": "https://api.github.com/users/paulstansifer/following{/other_user}", "gists_url": "https://api.github.com/users/paulstansifer/gists{/gist_id}", "starred_url": "https://api.github.com/users/paulstansifer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/paulstansifer/subscriptions", "organizations_url": "https://api.github.com/users/paulstansifer/orgs", "repos_url": "https://api.github.com/users/paulstansifer/repos", "events_url": "https://api.github.com/users/paulstansifer/events{/privacy}", "received_events_url": "https://api.github.com/users/paulstansifer/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f94065372001f5d34b4fde73f2e6dea8aba28212", "url": "https://api.github.com/repos/rust-lang/rust/commits/f94065372001f5d34b4fde73f2e6dea8aba28212", "html_url": "https://github.com/rust-lang/rust/commit/f94065372001f5d34b4fde73f2e6dea8aba28212"}], "stats": {"total": 101, "additions": 95, "deletions": 6}, "files": [{"sha": "df988cd1a734d77b71361f00d061e5109300c245", "filename": "src/libsyntax/ext/tt/earley_parser.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/62db5706e668166f7196463bf34939da7d51093d/src%2Flibsyntax%2Fext%2Ftt%2Fearley_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62db5706e668166f7196463bf34939da7d51093d/src%2Flibsyntax%2Fext%2Ftt%2Fearley_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fearley_parser.rs?ref=62db5706e668166f7196463bf34939da7d51093d", "patch": "@@ -259,7 +259,11 @@ fn parse_nt(p: parser, name: str) -> whole_nt {\n       \"expr\" { token::w_expr(p.parse_expr()) }\n       \"ty\" { token::w_ty(p.parse_ty(false /* no need to disambiguate*/)) }\n       // this could be handled like a token, since it is one\n-      \"ident\" { token::w_ident(p.parse_ident()) }\n+      \"ident\" { alt copy p.token {\n+          token::IDENT(sn,b) { p.bump(); token::w_ident(sn,b) }\n+          _ { p.fatal(\"expected ident, found \"\n+                      + token::to_str(*p.reader.interner(), copy p.token)) }\n+      } }\n       \"path\" { token::w_path(p.parse_path_with_tps(false)) }\n       _ { p.fatal(\"Unsupported builtin nonterminal parser: \" + name)}\n     }"}, {"sha": "2fd29fa28d02ff34dfcc62bfef2915d74ef0e68a", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/62db5706e668166f7196463bf34939da7d51093d/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62db5706e668166f7196463bf34939da7d51093d/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=62db5706e668166f7196463bf34939da7d51093d", "patch": "@@ -3,7 +3,7 @@ import diagnostic::span_handler;\n import ast::{token_tree,tt_delim,tt_flat,tt_dotdotdot,tt_interpolate,ident};\n import earley_parser::{arb_depth,seq,leaf};\n import codemap::span;\n-import parse::token::{EOF,ACTUALLY,token};\n+import parse::token::{EOF,ACTUALLY,IDENT,token,w_ident};\n import std::map::{hashmap,box_str_hash};\n \n export tt_reader,  new_tt_reader, dup_tt_reader, tt_next_token;\n@@ -193,8 +193,17 @@ fn tt_next_token(&&r: tt_reader) -> {tok: token, sp: span} {\n           // TODO: think about span stuff here\n           tt_interpolate(sp, ident) {\n             alt *lookup_cur_ad(r, ident) {\n+              /* sidestep the interpolation tricks for ident because\n+              (a) idents can be in lots of places, so it'd be a pain\n+              (b) we actually can, since it's a token. */\n+              leaf(w_ident(sn,b)) {\n+                r.cur_span = sp; r.cur_tok = IDENT(sn,b);\n+                r.cur.idx += 1u;\n+                ret ret_val;\n+              }\n               leaf(w_nt) {\n                 r.cur_span = sp; r.cur_tok = ACTUALLY(w_nt);\n+                r.cur.idx += 1u;\n                 ret ret_val;\n               }\n               seq(*) {"}, {"sha": "d4331ee766f8be99a134ffb268f88c428c404a0e", "filename": "src/libsyntax/parse/common.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/62db5706e668166f7196463bf34939da7d51093d/src%2Flibsyntax%2Fparse%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62db5706e668166f7196463bf34939da7d51093d/src%2Flibsyntax%2Fparse%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcommon.rs?ref=62db5706e668166f7196463bf34939da7d51093d", "patch": "@@ -50,6 +50,8 @@ impl parser_common for parser {\n     fn parse_ident() -> ast::ident {\n         alt copy self.token {\n           token::IDENT(i, _) { self.bump(); ret self.get_str(i); }\n+          token::ACTUALLY(token::w_ident(*)) { self.bug(\n+              \"ident interpolation not converted to real token\"); }\n           _ { self.fatal(\"expecting ident, found \"\n                       + token_to_str(self.reader, self.token)); }\n         }"}, {"sha": "467f18969794b20c144f453e6820557601f727b6", "filename": "src/libsyntax/parse/lexer.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/62db5706e668166f7196463bf34939da7d51093d/src%2Flibsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62db5706e668166f7196463bf34939da7d51093d/src%2Flibsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer.rs?ref=62db5706e668166f7196463bf34939da7d51093d", "patch": "@@ -459,8 +459,7 @@ fn next_token_inner(rdr: string_reader) -> token::token {\n         let is_mod_name = c == ':' && nextch(rdr) == ':';\n \n         // FIXME: perform NFKC normalization here. (Issue #2253)\n-        ret token::IDENT(intern(*rdr.interner,\n-                                          @accum_str), is_mod_name);\n+        ret token::IDENT(intern(*rdr.interner, @accum_str), is_mod_name);\n     }\n     if is_dec_digit(c) {\n         ret scan_number(c, rdr);"}, {"sha": "f6d59ccdb00471d6a0819e4a81b96f8a7e57c427", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 76, "deletions": 1, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/62db5706e668166f7196463bf34939da7d51093d/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62db5706e668166f7196463bf34939da7d51093d/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=62db5706e668166f7196463bf34939da7d51093d", "patch": "@@ -1,7 +1,7 @@\n import result::result;\n import either::{either, left, right};\n import std::map::{hashmap, str_hash};\n-import token::{can_begin_expr, is_ident, is_plain_ident};\n+import token::{can_begin_expr, is_ident, is_plain_ident, ACTUALLY};\n import codemap::{span,fss_none};\n import util::interner;\n import ast_util::{spanned, respan, mk_sp, ident_to_path, operator_prec};\n@@ -59,6 +59,78 @@ enum class_contents { ctor_decl(fn_decl, blk, codemap::span),\n type arg_or_capture_item = either<arg, capture_item>;\n type item_info = (ident, item_, option<~[attribute]>);\n \n+fn dummy() {\n+\n+/* We need to position the macros to capture the ACTUALLY tokens before they\n+get bumped away. So two bumps in a row is bad. (the first lookahead also\n+counts as a bump).\n+\n+Events happen L to R; 'B' indicates a bump before hand:\n+           ._____________________________.________________________.\n+           \u2193                            B|                        |\n+   parse_expr -> parse_expr_res -> parse_assign_expr              |\n+                                    \u2193                             |\n+                            parse_binops -> parse_more_binops     |\n+                             \u2193             B\u2193                    B|\n+                            parse_prefix_expr B-> parse_dot_or_call_expr\n+                             B|_\u2191                  \u2193\n+                                                  parse_bottom_expr\n+                                                  B\u2193\n+                                            \u22ef->parse_ident\n+...so we've hit parse_prefix_expr, parse_more_binops, and parse_bottom_expr.\n+*/\n+\n+    #macro[[#maybe_whole_item[p],\n+            alt copy p.token {\n+                ACTUALLY(token::w_item(i)) { p.bump(); ret i; }\n+                _ {} }]];\n+    #macro[[#maybe_whole_block[p],\n+            alt copy p.token {\n+                ACTUALLY(token::w_block(b)) { p.bump(); ret b; }\n+                _ {} }]];\n+    #macro[[#maybe_whole_stmt[p],\n+            alt copy p.token {\n+                ACTUALLY(token::w_stmt(s)) { p.bump(); ret s; }\n+                _ {} }]];\n+    #macro[[#maybe_whole_pat[p],\n+            alt copy p.token {\n+                ACTUALLY(token::w_pat(pt)) { p.bump(); ret pt; }\n+                _ {} }]];\n+    #macro[[#maybe_whole_expr[p],\n+            alt copy p.token {\n+                ACTUALLY(token::w_expr(e)) {\n+                    p.bump();\n+                    ret e;\n+                }\n+                ACTUALLY(token::w_path(pt)) {\n+                    p.bump();\n+                    ret p.mk_expr(p.span.lo, p.span.lo,\n+                                  expr_path(pt));\n+                }\n+                _ {} }]];\n+    #macro[[#maybe_whole_expr_pexpr[p], /* ack! */\n+            alt copy p.token {\n+                ACTUALLY(token::w_expr(e)) {\n+                    p.bump();\n+                    ret pexpr(e);\n+                }\n+                ACTUALLY(token::w_path(pt)) {\n+                    p.bump();\n+                    ret p.mk_pexpr(p.span.lo, p.span.lo,\n+                                   expr_path(pt));\n+                }\n+                _ {} }]];\n+    #macro[[#maybe_whole_ty[p],\n+            alt copy p.token {\n+                ACTUALLY(token::w_ty(t)) { p.bump(); ret t; }\n+                _ {} }]];\n+    /* ident is handled by common.rs */\n+    #macro[[#maybe_whole_path[p],\n+            alt p.token {\n+                ACTUALLY(token::w_path(pt)) { p.bump(); ret pt; }\n+                _ {} }]];\n+}\n+\n class parser {\n     let sess: parse_sess;\n     let cfg: crate_cfg;\n@@ -718,6 +790,7 @@ class parser {\n     }\n \n     fn parse_bottom_expr() -> pexpr {\n+        #maybe_whole_expr_pexpr[self];\n         let lo = self.span.lo;\n         let mut hi = self.span.hi;\n \n@@ -1181,6 +1254,7 @@ class parser {\n \n \n     fn parse_prefix_expr() -> pexpr {\n+        #maybe_whole_expr_pexpr[self];\n         let lo = self.span.lo;\n         let mut hi;\n \n@@ -1258,6 +1332,7 @@ class parser {\n \n     fn parse_more_binops(plhs: pexpr, min_prec: uint) ->\n         @expr {\n+        #maybe_whole_expr[self];\n         let lhs = self.to_expr(plhs);\n         if self.expr_is_complete(plhs) { ret lhs; }\n         let peeked = self.token;"}, {"sha": "1e7ac337954fd50b4625912a418ecca4b34367fd", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/62db5706e668166f7196463bf34939da7d51093d/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62db5706e668166f7196463bf34939da7d51093d/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=62db5706e668166f7196463bf34939da7d51093d", "patch": "@@ -94,7 +94,7 @@ enum whole_nt {\n     w_pat( @ast::pat),\n     w_expr(@ast::expr),\n     w_ty(  @ast::ty),\n-    w_ident(ast::ident),\n+    w_ident(str_num, bool),\n     w_path(@ast::path),\n }\n "}]}