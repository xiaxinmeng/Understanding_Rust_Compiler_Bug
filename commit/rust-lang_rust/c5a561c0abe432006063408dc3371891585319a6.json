{"sha": "c5a561c0abe432006063408dc3371891585319a6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM1YTU2MWMwYWJlNDMyMDA2MDYzNDA4ZGMzMzcxODkxNTg1MzE5YTY=", "commit": {"author": {"name": "David Tolnay", "email": "dtolnay@gmail.com", "date": "2018-09-02T13:59:02Z"}, "committer": {"name": "David Tolnay", "email": "dtolnay@gmail.com", "date": "2018-09-02T21:34:45Z"}, "message": "proc_macro::Group::span_open and span_close\n\nBefore this addition, every delimited group like (...) [...] {...} has\nonly a single Span that covers the full source location from opening\ndelimiter to closing delimiter. This makes it impossible for a\nprocedural macro to trigger an error pointing to just the opening or\nclosing delimiter. The Rust compiler does not seem to have the same\nlimitation:\n\n    mod m {\n        type T =\n    }\n\n    error: expected type, found `}`\n     --> src/main.rs:3:1\n      |\n    3 | }\n      | ^\n\nOn that same input, a procedural macro would be forced to trigger the\nerror on the last token inside the block, on the entire block, or on the\nnext token after the block, none of which is really what you want for an\nerror like above.\n\nThis commit adds group.span_open() and group.span_close() which access\nthe Span associated with just the opening delimiter and just the closing\ndelimiter of the group. Relevant to Syn as we implement real error\nmessages for when parsing fails in a procedural macro.", "tree": {"sha": "20d680284235efa0a4598baef109764d493f81f5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/20d680284235efa0a4598baef109764d493f81f5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c5a561c0abe432006063408dc3371891585319a6", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v1\n\niQIcBAABAgAGBQJbjFd1AAoJEPm6FDuV/22C9hYQAJwzZ0fEAKXxJNKh2sOCvU1i\nXDMwaOW5xvTx5HJHd5GFZPzYfABp6Q6Ccn57jDjJrxAr4TK3CDxfAcwJzeP1b4HU\nVYkw276sV3cN22qu/r7q7Lj7DO2UuDMUQZiOWrt0TDHhLCUSQlnV47sZWTx/xVKU\nyM1meFkVbNN3xR9KBvDRf0eMCS7C/kIo3ZoxitHygMSZX2GDmlAJ4GME+iXspb0V\n8Eq4OfmnFGDPMjhZRXjOrTZHk4K5H3KUbXhU9G4lgWRs3PSQiTH9QhF8LksE9cal\n/wXJw0OsGbeSbsRYgz3PBJ5i8CzrJo6N1VUthYtKGMOz/z/cF6AOqWKWnWGCmQTe\nU0ftfpXen/13nincVGCTkxlkzRUJDirSxD3PkyKb1eyKKZ0JRcqvTu8C7OiaqcXj\nzQ7a3+NVu6nOiGM9ULFO2UOYpWNjkVz/k6xGy0okFBCQkgPoo5NM5y98wcWidGMf\nJ3s+dh88+m6DtVMpG/Chns09jPYs/48yAEuNKd2BnPS4AoUXtycmA+zotyhOl+aE\n/qSTqHc9cwAMjQ4IfLleOd0g7FIdHjIAIREQbLpG33RNs3KQ6novmnKNJTxqeBjB\nxRJX+5I0BmPaY6RBWz9zfEAZW+DY/wsSj2Liazr8U08X50QmQOGNs3Zn/WHG0es1\nMZRPiZQw0nDrLTpIQVSY\n=hCL6\n-----END PGP SIGNATURE-----", "payload": "tree 20d680284235efa0a4598baef109764d493f81f5\nparent 3480ac2a805f8755f41dba2f081446df9d572986\nauthor David Tolnay <dtolnay@gmail.com> 1535896742 -0700\ncommitter David Tolnay <dtolnay@gmail.com> 1535924085 -0700\n\nproc_macro::Group::span_open and span_close\n\nBefore this addition, every delimited group like (...) [...] {...} has\nonly a single Span that covers the full source location from opening\ndelimiter to closing delimiter. This makes it impossible for a\nprocedural macro to trigger an error pointing to just the opening or\nclosing delimiter. The Rust compiler does not seem to have the same\nlimitation:\n\n    mod m {\n        type T =\n    }\n\n    error: expected type, found `}`\n     --> src/main.rs:3:1\n      |\n    3 | }\n      | ^\n\nOn that same input, a procedural macro would be forced to trigger the\nerror on the last token inside the block, on the entire block, or on the\nnext token after the block, none of which is really what you want for an\nerror like above.\n\nThis commit adds group.span_open() and group.span_close() which access\nthe Span associated with just the opening delimiter and just the closing\ndelimiter of the group. Relevant to Syn as we implement real error\nmessages for when parsing fails in a procedural macro.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c5a561c0abe432006063408dc3371891585319a6", "html_url": "https://github.com/rust-lang/rust/commit/c5a561c0abe432006063408dc3371891585319a6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c5a561c0abe432006063408dc3371891585319a6/comments", "author": {"login": "dtolnay", "id": 1940490, "node_id": "MDQ6VXNlcjE5NDA0OTA=", "avatar_url": "https://avatars.githubusercontent.com/u/1940490?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dtolnay", "html_url": "https://github.com/dtolnay", "followers_url": "https://api.github.com/users/dtolnay/followers", "following_url": "https://api.github.com/users/dtolnay/following{/other_user}", "gists_url": "https://api.github.com/users/dtolnay/gists{/gist_id}", "starred_url": "https://api.github.com/users/dtolnay/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dtolnay/subscriptions", "organizations_url": "https://api.github.com/users/dtolnay/orgs", "repos_url": "https://api.github.com/users/dtolnay/repos", "events_url": "https://api.github.com/users/dtolnay/events{/privacy}", "received_events_url": "https://api.github.com/users/dtolnay/received_events", "type": "User", "site_admin": false}, "committer": {"login": "dtolnay", "id": 1940490, "node_id": "MDQ6VXNlcjE5NDA0OTA=", "avatar_url": "https://avatars.githubusercontent.com/u/1940490?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dtolnay", "html_url": "https://github.com/dtolnay", "followers_url": "https://api.github.com/users/dtolnay/followers", "following_url": "https://api.github.com/users/dtolnay/following{/other_user}", "gists_url": "https://api.github.com/users/dtolnay/gists{/gist_id}", "starred_url": "https://api.github.com/users/dtolnay/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dtolnay/subscriptions", "organizations_url": "https://api.github.com/users/dtolnay/orgs", "repos_url": "https://api.github.com/users/dtolnay/repos", "events_url": "https://api.github.com/users/dtolnay/events{/privacy}", "received_events_url": "https://api.github.com/users/dtolnay/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3480ac2a805f8755f41dba2f081446df9d572986", "url": "https://api.github.com/repos/rust-lang/rust/commits/3480ac2a805f8755f41dba2f081446df9d572986", "html_url": "https://github.com/rust-lang/rust/commit/3480ac2a805f8755f41dba2f081446df9d572986"}], "stats": {"total": 43, "additions": 42, "deletions": 1}, "files": [{"sha": "8ed7b8f52babaceb603390b7a041d13e2b9929ea", "filename": "src/libproc_macro/lib.rs", "status": "modified", "additions": 42, "deletions": 1, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/c5a561c0abe432006063408dc3371891585319a6/src%2Flibproc_macro%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5a561c0abe432006063408dc3371891585319a6/src%2Flibproc_macro%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Flib.rs?ref=c5a561c0abe432006063408dc3371891585319a6", "patch": "@@ -64,7 +64,7 @@ use syntax::errors::DiagnosticBuilder;\n use syntax::parse::{self, token};\n use syntax::symbol::Symbol;\n use syntax::tokenstream;\n-use syntax_pos::{Pos, FileName};\n+use syntax_pos::{BytePos, Pos, FileName};\n \n /// The main type provided by this crate, representing an abstract stream of\n /// tokens, or, more specifically, a sequence of token trees.\n@@ -671,11 +671,52 @@ impl Group {\n \n     /// Returns the span for the delimiters of this token stream, spanning the\n     /// entire `Group`.\n+    ///\n+    /// ```text\n+    /// pub fn span(&self) -> Span {\n+    ///            ^^^^^^^\n+    /// ```\n     #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n     pub fn span(&self) -> Span {\n         self.span\n     }\n \n+    /// Returns the span pointing to the opening delimiter of this group, or the\n+    /// span of the entire group if this is a None-delimited group.\n+    ///\n+    /// ```text\n+    /// pub fn span_open(&self) -> Span {\n+    ///                 ^\n+    /// ```\n+    #[unstable(feature = \"proc_macro_span\", issue = \"38356\")]\n+    pub fn span_open(&self) -> Span {\n+        if self.delimiter == Delimiter::None {\n+            self.span\n+        } else {\n+            let lo = self.span.0.lo();\n+            let new_hi = BytePos::from_usize(lo.to_usize() + 1);\n+            Span(self.span.0.with_hi(new_hi))\n+        }\n+    }\n+\n+    /// Returns the span pointing to the closing delimiter of this group, or the\n+    /// span of the entire group if this is a None-delimited group.\n+    ///\n+    /// ```text\n+    /// pub fn span_close(&self) -> Span {\n+    ///                        ^\n+    /// ```\n+    #[unstable(feature = \"proc_macro_span\", issue = \"38356\")]\n+    pub fn span_close(&self) -> Span {\n+        let hi = self.span.0.hi();\n+        if self.delimiter == Delimiter::None || hi.to_usize() == 0 {\n+            self.span\n+        } else {\n+            let new_lo = BytePos::from_usize(hi.to_usize() - 1);\n+            Span(self.span.0.with_lo(new_lo))\n+        }\n+    }\n+\n     /// Configures the span for this `Group`'s delimiters, but not its internal\n     /// tokens.\n     ///"}]}