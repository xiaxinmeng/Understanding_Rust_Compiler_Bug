{"sha": "d04e6b8de5fe6bbf203c534c35e6f55e8960ab46", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQwNGU2YjhkZTVmZTZiYmYyMDNjNTM0YzM1ZTZmNTVlODk2MGFiNDY=", "commit": {"author": {"name": "dylni", "email": "46035563+dylni@users.noreply.github.com", "date": "2020-08-17T01:47:12Z"}, "committer": {"name": "dylni", "email": "46035563+dylni@users.noreply.github.com", "date": "2020-08-17T01:47:12Z"}, "message": "Replace ad hoc implementations with `slice::check_range`", "tree": {"sha": "c089016b8e43034b0809767b0787b8fa29076405", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c089016b8e43034b0809767b0787b8fa29076405"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d04e6b8de5fe6bbf203c534c35e6f55e8960ab46", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d04e6b8de5fe6bbf203c534c35e6f55e8960ab46", "html_url": "https://github.com/rust-lang/rust/commit/d04e6b8de5fe6bbf203c534c35e6f55e8960ab46", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d04e6b8de5fe6bbf203c534c35e6f55e8960ab46/comments", "author": {"login": "dylni", "id": 46035563, "node_id": "MDQ6VXNlcjQ2MDM1NTYz", "avatar_url": "https://avatars.githubusercontent.com/u/46035563?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dylni", "html_url": "https://github.com/dylni", "followers_url": "https://api.github.com/users/dylni/followers", "following_url": "https://api.github.com/users/dylni/following{/other_user}", "gists_url": "https://api.github.com/users/dylni/gists{/gist_id}", "starred_url": "https://api.github.com/users/dylni/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dylni/subscriptions", "organizations_url": "https://api.github.com/users/dylni/orgs", "repos_url": "https://api.github.com/users/dylni/repos", "events_url": "https://api.github.com/users/dylni/events{/privacy}", "received_events_url": "https://api.github.com/users/dylni/received_events", "type": "User", "site_admin": false}, "committer": {"login": "dylni", "id": 46035563, "node_id": "MDQ6VXNlcjQ2MDM1NTYz", "avatar_url": "https://avatars.githubusercontent.com/u/46035563?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dylni", "html_url": "https://github.com/dylni", "followers_url": "https://api.github.com/users/dylni/followers", "following_url": "https://api.github.com/users/dylni/following{/other_user}", "gists_url": "https://api.github.com/users/dylni/gists{/gist_id}", "starred_url": "https://api.github.com/users/dylni/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dylni/subscriptions", "organizations_url": "https://api.github.com/users/dylni/orgs", "repos_url": "https://api.github.com/users/dylni/repos", "events_url": "https://api.github.com/users/dylni/events{/privacy}", "received_events_url": "https://api.github.com/users/dylni/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ed02b90e9b76b9ce2e8e99a99dbadd96ab4dfb42", "url": "https://api.github.com/repos/rust-lang/rust/commits/ed02b90e9b76b9ce2e8e99a99dbadd96ab4dfb42", "html_url": "https://github.com/rust-lang/rust/commit/ed02b90e9b76b9ce2e8e99a99dbadd96ab4dfb42"}], "stats": {"total": 114, "additions": 24, "deletions": 90}, "files": [{"sha": "54cf548fac5214fec87c70cee7ea7a4521514e62", "filename": "library/alloc/src/collections/vec_deque.rs", "status": "modified", "additions": 11, "deletions": 26, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/d04e6b8de5fe6bbf203c534c35e6f55e8960ab46/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d04e6b8de5fe6bbf203c534c35e6f55e8960ab46/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque.rs?ref=d04e6b8de5fe6bbf203c534c35e6f55e8960ab46", "patch": "@@ -14,8 +14,7 @@ use core::fmt;\n use core::hash::{Hash, Hasher};\n use core::iter::{once, repeat_with, FromIterator, FusedIterator};\n use core::mem::{self, replace, ManuallyDrop};\n-use core::ops::Bound::{Excluded, Included, Unbounded};\n-use core::ops::{Index, IndexMut, RangeBounds, Try};\n+use core::ops::{Index, IndexMut, Range, RangeBounds, Try};\n use core::ptr::{self, NonNull};\n use core::slice;\n \n@@ -1083,24 +1082,16 @@ impl<T> VecDeque<T> {\n         self.tail == self.head\n     }\n \n-    fn range_start_end<R>(&self, range: R) -> (usize, usize)\n+    fn range_tail_head<R>(&self, range: R) -> (usize, usize)\n     where\n         R: RangeBounds<usize>,\n     {\n-        let len = self.len();\n-        let start = match range.start_bound() {\n-            Included(&n) => n,\n-            Excluded(&n) => n + 1,\n-            Unbounded => 0,\n-        };\n-        let end = match range.end_bound() {\n-            Included(&n) => n + 1,\n-            Excluded(&n) => n,\n-            Unbounded => len,\n-        };\n-        assert!(start <= end, \"lower bound was too large\");\n-        assert!(end <= len, \"upper bound was too large\");\n-        (start, end)\n+        // SAFETY: This buffer is only used to check the range.\n+        let buffer = unsafe { slice::from_raw_parts(self.ptr(), self.len()) };\n+        let Range { start, end } = buffer.check_range(range);\n+        let tail = self.wrap_add(self.tail, start);\n+        let head = self.wrap_add(self.tail, end);\n+        (tail, head)\n     }\n \n     /// Creates an iterator that covers the specified range in the `VecDeque`.\n@@ -1131,9 +1122,7 @@ impl<T> VecDeque<T> {\n     where\n         R: RangeBounds<usize>,\n     {\n-        let (start, end) = self.range_start_end(range);\n-        let tail = self.wrap_add(self.tail, start);\n-        let head = self.wrap_add(self.tail, end);\n+        let (tail, head) = self.range_tail_head(range);\n         Iter {\n             tail,\n             head,\n@@ -1174,9 +1163,7 @@ impl<T> VecDeque<T> {\n     where\n         R: RangeBounds<usize>,\n     {\n-        let (start, end) = self.range_start_end(range);\n-        let tail = self.wrap_add(self.tail, start);\n-        let head = self.wrap_add(self.tail, end);\n+        let (tail, head) = self.range_tail_head(range);\n         IterMut {\n             tail,\n             head,\n@@ -1230,7 +1217,7 @@ impl<T> VecDeque<T> {\n         // When finished, the remaining data will be copied back to cover the hole,\n         // and the head/tail values will be restored correctly.\n         //\n-        let (start, end) = self.range_start_end(range);\n+        let (drain_tail, drain_head) = self.range_tail_head(range);\n \n         // The deque's elements are parted into three segments:\n         // * self.tail  -> drain_tail\n@@ -1248,8 +1235,6 @@ impl<T> VecDeque<T> {\n         //        T   t   h   H\n         // [. . . o o x x o o . . .]\n         //\n-        let drain_tail = self.wrap_add(self.tail, start);\n-        let drain_head = self.wrap_add(self.tail, end);\n         let head = self.head;\n \n         // \"forget\" about the values after the start of the drain until after"}, {"sha": "514b0bf918ac5514f06055046736982946b5d6af", "filename": "library/alloc/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d04e6b8de5fe6bbf203c534c35e6f55e8960ab46/library%2Falloc%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d04e6b8de5fe6bbf203c534c35e6f55e8960ab46/library%2Falloc%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Flib.rs?ref=d04e6b8de5fe6bbf203c534c35e6f55e8960ab46", "patch": "@@ -114,6 +114,7 @@\n #![feature(rustc_attrs)]\n #![feature(receiver_trait)]\n #![feature(min_specialization)]\n+#![feature(slice_check_range)]\n #![feature(slice_ptr_get)]\n #![feature(slice_ptr_len)]\n #![feature(staged_api)]"}, {"sha": "b3ac4397f17ac0913a3495037308e766c414c547", "filename": "library/alloc/src/string.rs", "status": "modified", "additions": 6, "deletions": 14, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d04e6b8de5fe6bbf203c534c35e6f55e8960ab46/library%2Falloc%2Fsrc%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d04e6b8de5fe6bbf203c534c35e6f55e8960ab46/library%2Falloc%2Fsrc%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fstring.rs?ref=d04e6b8de5fe6bbf203c534c35e6f55e8960ab46", "patch": "@@ -47,7 +47,7 @@ use core::fmt;\n use core::hash;\n use core::iter::{FromIterator, FusedIterator};\n use core::ops::Bound::{Excluded, Included, Unbounded};\n-use core::ops::{self, Add, AddAssign, Index, IndexMut, RangeBounds};\n+use core::ops::{self, Add, AddAssign, Index, IndexMut, Range, RangeBounds};\n use core::ptr;\n use core::str::{lossy, pattern::Pattern};\n \n@@ -1506,23 +1506,15 @@ impl String {\n         // of the vector version. The data is just plain bytes.\n         // Because the range removal happens in Drop, if the Drain iterator is leaked,\n         // the removal will not happen.\n-        let len = self.len();\n-        let start = match range.start_bound() {\n-            Included(&n) => n,\n-            Excluded(&n) => n + 1,\n-            Unbounded => 0,\n-        };\n-        let end = match range.end_bound() {\n-            Included(&n) => n + 1,\n-            Excluded(&n) => n,\n-            Unbounded => len,\n-        };\n+        let Range { start, end } = self.as_bytes().check_range(range);\n+        assert!(self.is_char_boundary(start));\n+        assert!(self.is_char_boundary(end));\n \n         // Take out two simultaneous borrows. The &mut String won't be accessed\n         // until iteration is over, in Drop.\n         let self_ptr = self as *mut _;\n-        // slicing does the appropriate bounds checks\n-        let chars_iter = self[start..end].chars();\n+        // SAFETY: `check_range` and `is_char_boundary` do the appropriate bounds checks.\n+        let chars_iter = unsafe { self.get_unchecked(start..end) }.chars();\n \n         Drain { start, end, iter: chars_iter, string: self_ptr }\n     }"}, {"sha": "a29985256aae9569dc4a2dad256ec7bb8dce3561", "filename": "library/alloc/src/vec.rs", "status": "modified", "additions": 2, "deletions": 31, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/d04e6b8de5fe6bbf203c534c35e6f55e8960ab46/library%2Falloc%2Fsrc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d04e6b8de5fe6bbf203c534c35e6f55e8960ab46/library%2Falloc%2Fsrc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec.rs?ref=d04e6b8de5fe6bbf203c534c35e6f55e8960ab46", "patch": "@@ -66,8 +66,7 @@ use core::intrinsics::{arith_offset, assume};\n use core::iter::{FromIterator, FusedIterator, TrustedLen};\n use core::marker::PhantomData;\n use core::mem::{self, ManuallyDrop, MaybeUninit};\n-use core::ops::Bound::{Excluded, Included, Unbounded};\n-use core::ops::{self, Index, IndexMut, RangeBounds};\n+use core::ops::{self, Index, IndexMut, Range, RangeBounds};\n use core::ptr::{self, NonNull};\n use core::slice::{self, SliceIndex};\n \n@@ -1311,35 +1310,7 @@ impl<T> Vec<T> {\n         // the hole, and the vector length is restored to the new length.\n         //\n         let len = self.len();\n-        let start = match range.start_bound() {\n-            Included(&n) => n,\n-            Excluded(&n) => n + 1,\n-            Unbounded => 0,\n-        };\n-        let end = match range.end_bound() {\n-            Included(&n) => n + 1,\n-            Excluded(&n) => n,\n-            Unbounded => len,\n-        };\n-\n-        #[cold]\n-        #[inline(never)]\n-        fn start_assert_failed(start: usize, end: usize) -> ! {\n-            panic!(\"start drain index (is {}) should be <= end drain index (is {})\", start, end);\n-        }\n-\n-        #[cold]\n-        #[inline(never)]\n-        fn end_assert_failed(end: usize, len: usize) -> ! {\n-            panic!(\"end drain index (is {}) should be <= len (is {})\", end, len);\n-        }\n-\n-        if start > end {\n-            start_assert_failed(start, end);\n-        }\n-        if end > len {\n-            end_assert_failed(end, len);\n-        }\n+        let Range { start, end } = self.check_range(range);\n \n         unsafe {\n             // set self.vec length's to start, to be safe in case Drain is leaked"}, {"sha": "066368d5de56a8599c06fb8589b4a143b044fa7d", "filename": "library/core/src/slice/mod.rs", "status": "modified", "additions": 2, "deletions": 17, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/d04e6b8de5fe6bbf203c534c35e6f55e8960ab46/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d04e6b8de5fe6bbf203c534c35e6f55e8960ab46/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs?ref=d04e6b8de5fe6bbf203c534c35e6f55e8960ab46", "patch": "@@ -2511,26 +2511,11 @@ impl<T> [T] {\n     /// ```\n     #[stable(feature = \"copy_within\", since = \"1.37.0\")]\n     #[track_caller]\n-    pub fn copy_within<R: ops::RangeBounds<usize>>(&mut self, src: R, dest: usize)\n+    pub fn copy_within<R: RangeBounds<usize>>(&mut self, src: R, dest: usize)\n     where\n         T: Copy,\n     {\n-        let src_start = match src.start_bound() {\n-            ops::Bound::Included(&n) => n,\n-            ops::Bound::Excluded(&n) => {\n-                n.checked_add(1).unwrap_or_else(|| slice_start_index_overflow_fail())\n-            }\n-            ops::Bound::Unbounded => 0,\n-        };\n-        let src_end = match src.end_bound() {\n-            ops::Bound::Included(&n) => {\n-                n.checked_add(1).unwrap_or_else(|| slice_end_index_overflow_fail())\n-            }\n-            ops::Bound::Excluded(&n) => n,\n-            ops::Bound::Unbounded => self.len(),\n-        };\n-        assert!(src_start <= src_end, \"src end is before src start\");\n-        assert!(src_end <= self.len(), \"src is out of bounds\");\n+        let Range { start: src_start, end: src_end } = self.check_range(src);\n         let count = src_end - src_start;\n         assert!(dest <= self.len() - count, \"dest is out of bounds\");\n         unsafe {"}, {"sha": "abe321c9daae44da32c1e85c60c2422bce16488e", "filename": "library/core/tests/slice.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d04e6b8de5fe6bbf203c534c35e6f55e8960ab46/library%2Fcore%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d04e6b8de5fe6bbf203c534c35e6f55e8960ab46/library%2Fcore%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fslice.rs?ref=d04e6b8de5fe6bbf203c534c35e6f55e8960ab46", "patch": "@@ -1797,7 +1797,7 @@ fn test_copy_within() {\n }\n \n #[test]\n-#[should_panic(expected = \"src is out of bounds\")]\n+#[should_panic(expected = \"range end index 14 out of range for slice of length 13\")]\n fn test_copy_within_panics_src_too_long() {\n     let mut bytes = *b\"Hello, World!\";\n     // The length is only 13, so 14 is out of bounds.\n@@ -1812,7 +1812,7 @@ fn test_copy_within_panics_dest_too_long() {\n     bytes.copy_within(0..4, 10);\n }\n #[test]\n-#[should_panic(expected = \"src end is before src start\")]\n+#[should_panic(expected = \"slice index starts at 2 but ends at 1\")]\n fn test_copy_within_panics_src_inverted() {\n     let mut bytes = *b\"Hello, World!\";\n     // 2 is greater than 1, so this range is invalid."}]}