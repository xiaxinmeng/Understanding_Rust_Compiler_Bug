{"sha": "e5799a6af35f5c0a257ff375498c5237e4a5466b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU1Nzk5YTZhZjM1ZjVjMGEyNTdmZjM3NTQ5OGM1MjM3ZTRhNTQ2NmI=", "commit": {"author": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2017-07-28T07:52:19Z"}, "committer": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2017-08-01T07:56:21Z"}, "message": "Reduce the chance of accidentally calling functions in CTFE\n\npreviously miri had a check for const fn and other cases that\nCTFE requires. Instead the function call is completely\nprocessed inside the machine. This allows CTFE to have full\ncontrol over what is called and miri to not have useless\nCTFE-checks in normal mode.", "tree": {"sha": "e755fedbe343bde53aafaf5e0ca6882f226d42b1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e755fedbe343bde53aafaf5e0ca6882f226d42b1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e5799a6af35f5c0a257ff375498c5237e4a5466b", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEYFTdM4NKd7XQft77pp+NIls619kFAlmANCUACgkQpp+NIls6\n19lDtA//drIIedLgUgB85+xUPmPsg4KplbYRKmFngLMXTswlkxxHgHjA96MZmKdw\nMTAG18AOk1GTOrRbs5ctCXf9RYNzdPpfRlkiJdFf2llrenRU9JEOXqRU1WLsDBW4\nZ9fetf0ikklaS1EQKeuqaS09t8pHWNUlRKfybTv+e7TkmdtFH8tz2umaLSR++QLM\nOEjMSOoF1swlvGfm4pTE40z0zjIXz3Iyco0VLJuhNIdCdUxRb77bSXazVybFRaSl\nZF8Zmp4RkRyvhkGYu6tX4SFC1XUx9PPahjMF9ieLyuGif8xM8uYFvc0hVr3jMAZJ\nrgiWuS/Csjdq2kBGRIWHuHmg4SmDPnaf2lY1wAeZqeXQRkHa5oPHJOu4ekjV6HA0\nbGzda6FfB+C77q/02mPd13M3ceb0gAnRIwN3OIDyO71N+T0PAqsJDCDLnYAOfFa+\nDRiCdEfnvwAiMT0C5FARnd/GBwDyqt/5eC4KtG+KD6MSpmiVyRaYKyVuYRXiDEyX\nnFKteVyvZa8A+vOnJ7phKdqPNoTJLlM3UHZRqznoBccATmIHZww23rwZxGxZuk4s\nCkFf7jvscQU0ZLRDCFPDF2Kli5Rospxv/Dm8/RqbzFMDRuNSvCLwBkcKi2142ckL\nnlZxBsDy2K5XY0wBZt6LFRYTjv7ABK/BXooU6Her58hPAxvuabM=\n=FCeL\n-----END PGP SIGNATURE-----", "payload": "tree e755fedbe343bde53aafaf5e0ca6882f226d42b1\nparent 728bb878acb374d313482cac41a2aa3a60af2a84\nauthor Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1501228339 +0200\ncommitter Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1501574181 +0200\n\nReduce the chance of accidentally calling functions in CTFE\n\npreviously miri had a check for const fn and other cases that\nCTFE requires. Instead the function call is completely\nprocessed inside the machine. This allows CTFE to have full\ncontrol over what is called and miri to not have useless\nCTFE-checks in normal mode.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e5799a6af35f5c0a257ff375498c5237e4a5466b", "html_url": "https://github.com/rust-lang/rust/commit/e5799a6af35f5c0a257ff375498c5237e4a5466b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e5799a6af35f5c0a257ff375498c5237e4a5466b/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "728bb878acb374d313482cac41a2aa3a60af2a84", "url": "https://api.github.com/repos/rust-lang/rust/commits/728bb878acb374d313482cac41a2aa3a60af2a84", "html_url": "https://github.com/rust-lang/rust/commit/728bb878acb374d313482cac41a2aa3a60af2a84"}], "stats": {"total": 702, "additions": 624, "deletions": 78}, "files": [{"sha": "4ee9dc974bddff0c0e97077e8fee23948d8756b7", "filename": "Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e5799a6af35f5c0a257ff375498c5237e4a5466b/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/e5799a6af35f5c0a257ff375498c5237e4a5466b/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=e5799a6af35f5c0a257ff375498c5237e4a5466b", "patch": "@@ -35,3 +35,4 @@ compiletest_rs = \"0.2.6\"\n \n [workspace]\n members = [\"src/librustc_mir\"]\n+exclude = [\"xargo\"]"}, {"sha": "d8e92e7291fca0ea400b334d68879e1bbd0ebe76", "filename": "miri/fn_call.rs", "status": "added", "additions": 564, "deletions": 0, "changes": 564, "blob_url": "https://github.com/rust-lang/rust/blob/e5799a6af35f5c0a257ff375498c5237e4a5466b/miri%2Ffn_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5799a6af35f5c0a257ff375498c5237e4a5466b/miri%2Ffn_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/miri%2Ffn_call.rs?ref=e5799a6af35f5c0a257ff375498c5237e4a5466b", "patch": "@@ -0,0 +1,564 @@\n+use rustc::ty::{self, Ty};\n+use rustc::hir::def_id::{DefId, CRATE_DEF_INDEX};\n+use rustc::mir;\n+use syntax::attr;\n+use syntax::abi::Abi;\n+use syntax::codemap::Span;\n+\n+use std::mem;\n+\n+use rustc_miri::interpret::*;\n+\n+use super::{\n+    TlsKey,\n+    EvalContext,\n+    MemoryExt,\n+};\n+\n+pub trait EvalContextExt<'tcx> {\n+    fn call_c_abi(\n+        &mut self,\n+        def_id: DefId,\n+        arg_operands: &[mir::Operand<'tcx>],\n+        dest: Lvalue<'tcx>,\n+        dest_ty: Ty<'tcx>,\n+        dest_block: mir::BasicBlock,\n+    ) -> EvalResult<'tcx>;\n+\n+    fn resolve_path(&self, path: &[&str]) -> EvalResult<'tcx, ty::Instance<'tcx>>;\n+\n+    fn call_missing_fn(\n+        &mut self,\n+        instance: ty::Instance<'tcx>,\n+        destination: Option<(Lvalue<'tcx>, mir::BasicBlock)>,\n+        arg_operands: &[mir::Operand<'tcx>],\n+        sig: ty::FnSig<'tcx>,\n+        path: String,\n+    ) -> EvalResult<'tcx>;\n+\n+    fn eval_fn_call(\n+        &mut self,\n+        instance: ty::Instance<'tcx>,\n+        destination: Option<(Lvalue<'tcx>, mir::BasicBlock)>,\n+        arg_operands: &[mir::Operand<'tcx>],\n+        span: Span,\n+        sig: ty::FnSig<'tcx>,\n+    ) -> EvalResult<'tcx, bool>;\n+}\n+\n+impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator> {\n+    fn eval_fn_call(\n+        &mut self,\n+        instance: ty::Instance<'tcx>,\n+        destination: Option<(Lvalue<'tcx>, mir::BasicBlock)>,\n+        arg_operands: &[mir::Operand<'tcx>],\n+        span: Span,\n+        sig: ty::FnSig<'tcx>,\n+    ) -> EvalResult<'tcx, bool> {\n+        trace!(\"eval_fn_call: {:#?}, {:#?}\", instance, destination);\n+\n+        let mir = match self.load_mir(instance.def) {\n+            Ok(mir) => mir,\n+            Err(EvalError::NoMirFor(path)) => {\n+                self.call_missing_fn(instance, destination, arg_operands, sig, path)?;\n+                return Ok(true);\n+            },\n+            Err(other) => return Err(other),\n+        };\n+        \n+        let (return_lvalue, return_to_block) = match destination {\n+            Some((lvalue, block)) => (lvalue, StackPopCleanup::Goto(block)),\n+            None => (Lvalue::undef(), StackPopCleanup::None),\n+        };\n+\n+        self.push_stack_frame(\n+            instance,\n+            span,\n+            mir,\n+            return_lvalue,\n+            return_to_block,\n+        )?;\n+\n+        Ok(false)\n+    }\n+\n+    fn call_c_abi(\n+        &mut self,\n+        def_id: DefId,\n+        arg_operands: &[mir::Operand<'tcx>],\n+        dest: Lvalue<'tcx>,\n+        dest_ty: Ty<'tcx>,\n+        dest_block: mir::BasicBlock,\n+    ) -> EvalResult<'tcx> {\n+        let name = self.tcx.item_name(def_id);\n+        let attrs = self.tcx.get_attrs(def_id);\n+        let link_name = attr::first_attr_value_str_by_name(&attrs, \"link_name\")\n+            .unwrap_or(name)\n+            .as_str();\n+\n+        let args_res: EvalResult<Vec<Value>> = arg_operands.iter()\n+            .map(|arg| self.eval_operand(arg))\n+            .collect();\n+        let args = args_res?;\n+\n+        let usize = self.tcx.types.usize;\n+\n+        match &link_name[..] {\n+            \"malloc\" => {\n+                let size = self.value_to_primval(args[0], usize)?.to_u64()?;\n+                if size == 0 {\n+                    self.write_null(dest, dest_ty)?;\n+                } else {\n+                    let align = self.memory.pointer_size();\n+                    let ptr = self.memory.allocate(size, align, Kind::C)?;\n+                    self.write_primval(dest, PrimVal::Ptr(ptr), dest_ty)?;\n+                }\n+            }\n+\n+            \"free\" => {\n+                let ptr = args[0].into_ptr(&mut self.memory)?;\n+                if !ptr.is_null()? {\n+                    self.memory.deallocate(ptr.to_ptr()?, None, Kind::C)?;\n+                }\n+            }\n+\n+            \"syscall\" => {\n+                match self.value_to_primval(args[0], usize)?.to_u64()? {\n+                    511 => return Err(EvalError::Unimplemented(\"miri does not support random number generators\".to_owned())),\n+                    id => return Err(EvalError::Unimplemented(format!(\"miri does not support syscall id {}\", id))),\n+                }\n+            }\n+\n+            \"dlsym\" => {\n+                let _handle = args[0].into_ptr(&mut self.memory)?;\n+                let symbol = args[1].into_ptr(&mut self.memory)?.to_ptr()?;\n+                let symbol_name = self.memory.read_c_str(symbol)?;\n+                let err = format!(\"bad c unicode symbol: {:?}\", symbol_name);\n+                let symbol_name = ::std::str::from_utf8(symbol_name).unwrap_or(&err);\n+                return Err(EvalError::Unimplemented(format!(\"miri does not support dynamically loading libraries (requested symbol: {})\", symbol_name)));\n+            }\n+\n+            \"__rust_maybe_catch_panic\" => {\n+                // fn __rust_maybe_catch_panic(f: fn(*mut u8), data: *mut u8, data_ptr: *mut usize, vtable_ptr: *mut usize) -> u32\n+                // We abort on panic, so not much is going on here, but we still have to call the closure\n+                let u8_ptr_ty = self.tcx.mk_mut_ptr(self.tcx.types.u8);\n+                let f = args[0].into_ptr(&mut self.memory)?.to_ptr()?;\n+                let data = args[1].into_ptr(&mut self.memory)?;\n+                let f_instance = self.memory.get_fn(f)?;\n+                self.write_null(dest, dest_ty)?;\n+\n+                // Now we make a function call.  TODO: Consider making this re-usable?  EvalContext::step does sth. similar for the TLS dtors,\n+                // and of course eval_main.\n+                let mir = self.load_mir(f_instance.def)?;\n+                self.push_stack_frame(\n+                    f_instance,\n+                    mir.span,\n+                    mir,\n+                    Lvalue::undef(),\n+                    StackPopCleanup::Goto(dest_block),\n+                )?;\n+\n+                let arg_local = self.frame().mir.args_iter().next().ok_or(EvalError::AbiViolation(\"Argument to __rust_maybe_catch_panic does not take enough arguments.\".to_owned()))?;\n+                let arg_dest = self.eval_lvalue(&mir::Lvalue::Local(arg_local))?;\n+                self.write_ptr(arg_dest, data, u8_ptr_ty)?;\n+\n+                // We ourselves return 0\n+                self.write_null(dest, dest_ty)?;\n+\n+                // Don't fall through\n+                return Ok(());\n+            }\n+\n+            \"__rust_start_panic\" => {\n+                return Err(EvalError::Panic);\n+            }\n+\n+            \"memcmp\" => {\n+                let left = args[0].into_ptr(&mut self.memory)?;\n+                let right = args[1].into_ptr(&mut self.memory)?;\n+                let n = self.value_to_primval(args[2], usize)?.to_u64()?;\n+\n+                let result = {\n+                    let left_bytes = self.memory.read_bytes(left, n)?;\n+                    let right_bytes = self.memory.read_bytes(right, n)?;\n+\n+                    use std::cmp::Ordering::*;\n+                    match left_bytes.cmp(right_bytes) {\n+                        Less => -1i8,\n+                        Equal => 0,\n+                        Greater => 1,\n+                    }\n+                };\n+\n+                self.write_primval(dest, PrimVal::Bytes(result as u128), dest_ty)?;\n+            }\n+\n+            \"memrchr\" => {\n+                let ptr = args[0].into_ptr(&mut self.memory)?;\n+                let val = self.value_to_primval(args[1], usize)?.to_u64()? as u8;\n+                let num = self.value_to_primval(args[2], usize)?.to_u64()?;\n+                if let Some(idx) = self.memory.read_bytes(ptr, num)?.iter().rev().position(|&c| c == val) {\n+                    let new_ptr = ptr.offset(num - idx as u64 - 1, &self)?;\n+                    self.write_ptr(dest, new_ptr, dest_ty)?;\n+                } else {\n+                    self.write_null(dest, dest_ty)?;\n+                }\n+            }\n+\n+            \"memchr\" => {\n+                let ptr = args[0].into_ptr(&mut self.memory)?;\n+                let val = self.value_to_primval(args[1], usize)?.to_u64()? as u8;\n+                let num = self.value_to_primval(args[2], usize)?.to_u64()?;\n+                if let Some(idx) = self.memory.read_bytes(ptr, num)?.iter().position(|&c| c == val) {\n+                    let new_ptr = ptr.offset(idx as u64, &self)?;\n+                    self.write_ptr(dest, new_ptr, dest_ty)?;\n+                } else {\n+                    self.write_null(dest, dest_ty)?;\n+                }\n+            }\n+\n+            \"getenv\" => {\n+                let result = {\n+                    let name_ptr = args[0].into_ptr(&mut self.memory)?.to_ptr()?;\n+                    let name = self.memory.read_c_str(name_ptr)?;\n+                    match self.machine_data.env_vars.get(name) {\n+                        Some(&var) => PrimVal::Ptr(var),\n+                        None => PrimVal::Bytes(0),\n+                    }\n+                };\n+                self.write_primval(dest, result, dest_ty)?;\n+            }\n+\n+            \"unsetenv\" => {\n+                let mut success = None;\n+                {\n+                    let name_ptr = args[0].into_ptr(&mut self.memory)?;\n+                    if !name_ptr.is_null()? {\n+                        let name = self.memory.read_c_str(name_ptr.to_ptr()?)?;\n+                        if !name.is_empty() && !name.contains(&b'=') {\n+                            success = Some(self.machine_data.env_vars.remove(name));\n+                        }\n+                    }\n+                }\n+                if let Some(old) = success {\n+                    if let Some(var) = old {\n+                        self.memory.deallocate(var, None, Kind::Env)?;\n+                    }\n+                    self.write_null(dest, dest_ty)?;\n+                } else {\n+                    self.write_primval(dest, PrimVal::from_i128(-1), dest_ty)?;\n+                }\n+            }\n+\n+            \"setenv\" => {\n+                let mut new = None;\n+                {\n+                    let name_ptr = args[0].into_ptr(&mut self.memory)?;\n+                    let value_ptr = args[1].into_ptr(&mut self.memory)?.to_ptr()?;\n+                    let value = self.memory.read_c_str(value_ptr)?;\n+                    if !name_ptr.is_null()? {\n+                        let name = self.memory.read_c_str(name_ptr.to_ptr()?)?;\n+                        if !name.is_empty() && !name.contains(&b'=') {\n+                            new = Some((name.to_owned(), value.to_owned()));\n+                        }\n+                    }\n+                }\n+                if let Some((name, value)) = new {\n+                    // +1 for the null terminator\n+                    let value_copy = self.memory.allocate((value.len() + 1) as u64, 1, Kind::Env)?;\n+                    self.memory.write_bytes(value_copy.into(), &value)?;\n+                    let trailing_zero_ptr = value_copy.offset(value.len() as u64, &self)?.into();\n+                    self.memory.write_bytes(trailing_zero_ptr, &[0])?;\n+                    if let Some(var) = self.machine_data.env_vars.insert(name.to_owned(), value_copy) {\n+                        self.memory.deallocate(var, None, Kind::Env)?;\n+                    }\n+                    self.write_null(dest, dest_ty)?;\n+                } else {\n+                    self.write_primval(dest, PrimVal::from_i128(-1), dest_ty)?;\n+                }\n+            }\n+\n+            \"write\" => {\n+                let fd = self.value_to_primval(args[0], usize)?.to_u64()?;\n+                let buf = args[1].into_ptr(&mut self.memory)?;\n+                let n = self.value_to_primval(args[2], usize)?.to_u64()?;\n+                trace!(\"Called write({:?}, {:?}, {:?})\", fd, buf, n);\n+                let result = if fd == 1 || fd == 2 { // stdout/stderr\n+                    use std::io::{self, Write};\n+                \n+                    let buf_cont = self.memory.read_bytes(buf, n)?;\n+                    let res = if fd == 1 { io::stdout().write(buf_cont) } else { io::stderr().write(buf_cont) };\n+                    match res { Ok(n) => n as isize, Err(_) => -1 }\n+                } else {\n+                    info!(\"Ignored output to FD {}\", fd);\n+                    n as isize // pretend it all went well\n+                }; // now result is the value we return back to the program\n+                self.write_primval(dest, PrimVal::Bytes(result as u128), dest_ty)?;\n+            }\n+\n+            \"strlen\" => {\n+                let ptr = args[0].into_ptr(&mut self.memory)?.to_ptr()?;\n+                let n = self.memory.read_c_str(ptr)?.len();\n+                self.write_primval(dest, PrimVal::Bytes(n as u128), dest_ty)?;\n+            }\n+\n+            // Some things needed for sys::thread initialization to go through\n+            \"signal\" | \"sigaction\" | \"sigaltstack\" => {\n+                self.write_primval(dest, PrimVal::Bytes(0), dest_ty)?;\n+            }\n+\n+            \"sysconf\" => {\n+                let name = self.value_to_primval(args[0], usize)?.to_u64()?;\n+                trace!(\"sysconf() called with name {}\", name);\n+                // cache the sysconf integers via miri's global cache\n+                let paths = &[\n+                    (&[\"libc\", \"_SC_PAGESIZE\"], PrimVal::Bytes(4096)),\n+                    (&[\"libc\", \"_SC_GETPW_R_SIZE_MAX\"], PrimVal::from_i128(-1)),\n+                ];\n+                let mut result = None;\n+                for &(path, path_value) in paths {\n+                    if let Ok(instance) = self.resolve_path(path) {\n+                        let cid = GlobalId { instance, promoted: None };\n+                        // compute global if not cached\n+                        let val = match self.globals.get(&cid).map(|glob| glob.value) {\n+                            Some(value) => self.value_to_primval(value, usize)?.to_u64()?,\n+                            None => eval_body_as_primval(self.tcx, instance)?.0.to_u64()?,\n+                        };\n+                        if val == name {\n+                            result = Some(path_value);\n+                            break;\n+                        }\n+                    }\n+                }\n+                if let Some(result) = result {\n+                    self.write_primval(dest, result, dest_ty)?;\n+                } else {\n+                    return Err(EvalError::Unimplemented(format!(\"Unimplemented sysconf name: {}\", name)));\n+                }\n+            }\n+\n+            // Hook pthread calls that go to the thread-local storage memory subsystem\n+            \"pthread_key_create\" => {\n+                let key_ptr = args[0].into_ptr(&mut self.memory)?;\n+\n+                // Extract the function type out of the signature (that seems easier than constructing it ourselves...)\n+                let dtor = match args[1].into_ptr(&mut self.memory)?.into_inner_primval() {\n+                    PrimVal::Ptr(dtor_ptr) => Some(self.memory.get_fn(dtor_ptr)?),\n+                    PrimVal::Bytes(0) => None,\n+                    PrimVal::Bytes(_) => return Err(EvalError::ReadBytesAsPointer),\n+                    PrimVal::Undef => return Err(EvalError::ReadUndefBytes),\n+                };\n+\n+                // Figure out how large a pthread TLS key actually is. This is libc::pthread_key_t.\n+                let key_type = self.operand_ty(&arg_operands[0]).builtin_deref(true, ty::LvaluePreference::NoPreference)\n+                                   .ok_or(EvalError::AbiViolation(\"Wrong signature used for pthread_key_create: First argument must be a raw pointer.\".to_owned()))?.ty;\n+                let key_size = {\n+                    let layout = self.type_layout(key_type)?;\n+                    layout.size(&self.tcx.data_layout)\n+                };\n+\n+                // Create key and write it into the memory where key_ptr wants it\n+                let key = self.memory.create_tls_key(dtor) as u128;\n+                if key_size.bits() < 128 && key >= (1u128 << key_size.bits() as u128) {\n+                    return Err(EvalError::OutOfTls);\n+                }\n+                // TODO: Does this need checking for alignment?\n+                self.memory.write_uint(key_ptr.to_ptr()?, key, key_size.bytes())?;\n+\n+                // Return success (0)\n+                self.write_null(dest, dest_ty)?;\n+            }\n+            \"pthread_key_delete\" => {\n+                // The conversion into TlsKey here is a little fishy, but should work as long as usize >= libc::pthread_key_t\n+                let key = self.value_to_primval(args[0], usize)?.to_u64()? as TlsKey;\n+                self.memory.delete_tls_key(key)?;\n+                // Return success (0)\n+                self.write_null(dest, dest_ty)?;\n+            }\n+            \"pthread_getspecific\" => {\n+                // The conversion into TlsKey here is a little fishy, but should work as long as usize >= libc::pthread_key_t\n+                let key = self.value_to_primval(args[0], usize)?.to_u64()? as TlsKey;\n+                let ptr = self.memory.load_tls(key)?;\n+                self.write_ptr(dest, ptr, dest_ty)?;\n+            }\n+            \"pthread_setspecific\" => {\n+                // The conversion into TlsKey here is a little fishy, but should work as long as usize >= libc::pthread_key_t\n+                let key = self.value_to_primval(args[0], usize)?.to_u64()? as TlsKey;\n+                let new_ptr = args[1].into_ptr(&mut self.memory)?;\n+                self.memory.store_tls(key, new_ptr)?;\n+                \n+                // Return success (0)\n+                self.write_null(dest, dest_ty)?;\n+            }\n+\n+            // Stub out all the other pthread calls to just return 0\n+            link_name if link_name.starts_with(\"pthread_\") => {\n+                warn!(\"ignoring C ABI call: {}\", link_name);\n+                self.write_null(dest, dest_ty)?;\n+            },\n+\n+            _ => {\n+                return Err(EvalError::Unimplemented(format!(\"can't call C ABI function: {}\", link_name)));\n+            }\n+        }\n+\n+        // Since we pushed no stack frame, the main loop will act\n+        // as if the call just completed and it's returning to the\n+        // current frame.\n+        self.dump_local(dest);\n+        self.goto_block(dest_block);\n+        Ok(())\n+    }\n+\n+    /// Get an instance for a path.\n+    fn resolve_path(&self, path: &[&str]) -> EvalResult<'tcx, ty::Instance<'tcx>> {\n+        let cstore = &self.tcx.sess.cstore;\n+\n+        let crates = cstore.crates();\n+        crates.iter()\n+            .find(|&&krate| cstore.crate_name(krate) == path[0])\n+            .and_then(|krate| {\n+                let krate = DefId {\n+                    krate: *krate,\n+                    index: CRATE_DEF_INDEX,\n+                };\n+                let mut items = cstore.item_children(krate, self.tcx.sess);\n+                let mut path_it = path.iter().skip(1).peekable();\n+\n+                while let Some(segment) = path_it.next() {\n+                    for item in &mem::replace(&mut items, vec![]) {\n+                        if item.ident.name == *segment {\n+                            if path_it.peek().is_none() {\n+                                return Some(ty::Instance::mono(self.tcx, item.def.def_id()));\n+                            }\n+\n+                            items = cstore.item_children(item.def.def_id(), self.tcx.sess);\n+                            break;\n+                        }\n+                    }\n+                }\n+                None\n+            })\n+            .ok_or_else(|| {\n+                let path = path.iter()\n+                    .map(|&s| s.to_owned())\n+                    .collect();\n+                EvalError::PathNotFound(path)\n+            })\n+    }\n+\n+    fn call_missing_fn(\n+        &mut self,\n+        instance: ty::Instance<'tcx>,\n+        destination: Option<(Lvalue<'tcx>, mir::BasicBlock)>,\n+        arg_operands: &[mir::Operand<'tcx>],\n+        sig: ty::FnSig<'tcx>,\n+        path: String,\n+    ) -> EvalResult<'tcx> {\n+        // In some cases in non-MIR libstd-mode, not having a destination is legit.  Handle these early.\n+        match &path[..] {\n+            \"std::panicking::rust_panic_with_hook\" |\n+            \"std::rt::begin_panic_fmt\" => return Err(EvalError::Panic),\n+            _ => {},\n+        }\n+\n+        let dest_ty = sig.output();\n+        let (dest, dest_block) = destination.ok_or_else(|| EvalError::NoMirFor(path.clone()))?;\n+\n+        if sig.abi == Abi::C {\n+            // An external C function\n+            // TODO: That functions actually has a similar preamble to what follows here.  May make sense to\n+            // unify these two mechanisms for \"hooking into missing functions\".\n+            self.call_c_abi(instance.def_id(), arg_operands, dest, dest_ty, dest_block)?;\n+            return Ok(());\n+        }\n+\n+        let args_res: EvalResult<Vec<Value>> = arg_operands.iter()\n+            .map(|arg| self.eval_operand(arg))\n+            .collect();\n+        let args = args_res?;\n+\n+        let usize = self.tcx.types.usize;\n+    \n+        match &path[..] {\n+            // Allocators are magic.  They have no MIR, even when the rest of libstd does.\n+            \"alloc::heap::::__rust_alloc\" => {\n+                let size = self.value_to_primval(args[0], usize)?.to_u64()?;\n+                let align = self.value_to_primval(args[1], usize)?.to_u64()?;\n+                if size == 0 {\n+                    return Err(EvalError::HeapAllocZeroBytes);\n+                }\n+                if !align.is_power_of_two() {\n+                    return Err(EvalError::HeapAllocNonPowerOfTwoAlignment(align));\n+                }\n+                let ptr = self.memory.allocate(size, align, Kind::Rust)?;\n+                self.write_primval(dest, PrimVal::Ptr(ptr), dest_ty)?;\n+            }\n+            \"alloc::heap::::__rust_alloc_zeroed\" => {\n+                let size = self.value_to_primval(args[0], usize)?.to_u64()?;\n+                let align = self.value_to_primval(args[1], usize)?.to_u64()?;\n+                if size == 0 {\n+                    return Err(EvalError::HeapAllocZeroBytes);\n+                }\n+                if !align.is_power_of_two() {\n+                    return Err(EvalError::HeapAllocNonPowerOfTwoAlignment(align));\n+                }\n+                let ptr = self.memory.allocate(size, align, Kind::Rust)?;\n+                self.memory.write_repeat(ptr.into(), 0, size)?;\n+                self.write_primval(dest, PrimVal::Ptr(ptr), dest_ty)?;\n+            }\n+            \"alloc::heap::::__rust_dealloc\" => {\n+                let ptr = args[0].into_ptr(&mut self.memory)?.to_ptr()?;\n+                let old_size = self.value_to_primval(args[1], usize)?.to_u64()?;\n+                let align = self.value_to_primval(args[2], usize)?.to_u64()?;\n+                if old_size == 0 {\n+                    return Err(EvalError::HeapAllocZeroBytes);\n+                }\n+                if !align.is_power_of_two() {\n+                    return Err(EvalError::HeapAllocNonPowerOfTwoAlignment(align));\n+                }\n+                self.memory.deallocate(ptr, Some((old_size, align)), Kind::Rust)?;\n+            }\n+            \"alloc::heap::::__rust_realloc\" => {\n+                let ptr = args[0].into_ptr(&mut self.memory)?.to_ptr()?;\n+                let old_size = self.value_to_primval(args[1], usize)?.to_u64()?;\n+                let old_align = self.value_to_primval(args[2], usize)?.to_u64()?;\n+                let new_size = self.value_to_primval(args[3], usize)?.to_u64()?;\n+                let new_align = self.value_to_primval(args[4], usize)?.to_u64()?;\n+                if old_size == 0 || new_size == 0 {\n+                    return Err(EvalError::HeapAllocZeroBytes);\n+                }\n+                if !old_align.is_power_of_two() {\n+                    return Err(EvalError::HeapAllocNonPowerOfTwoAlignment(old_align));\n+                }\n+                if !new_align.is_power_of_two() {\n+                    return Err(EvalError::HeapAllocNonPowerOfTwoAlignment(new_align));\n+                }\n+                let new_ptr = self.memory.reallocate(ptr, old_size, old_align, new_size, new_align, Kind::Rust)?;\n+                self.write_primval(dest, PrimVal::Ptr(new_ptr), dest_ty)?;\n+            }\n+\n+            // A Rust function is missing, which means we are running with MIR missing for libstd (or other dependencies).\n+            // Still, we can make many things mostly work by \"emulating\" or ignoring some functions.\n+            \"std::io::_print\" => {\n+                trace!(\"Ignoring output.  To run programs that print, make sure you have a libstd with full MIR.\");\n+            }\n+            \"std::thread::Builder::new\" => return Err(EvalError::Unimplemented(\"miri does not support threading\".to_owned())),\n+            \"std::env::args\" => return Err(EvalError::Unimplemented(\"miri does not support program arguments\".to_owned())),\n+            \"std::panicking::panicking\" |\n+            \"std::rt::panicking\" => {\n+                // we abort on panic -> `std::rt::panicking` always returns false\n+                let bool = self.tcx.types.bool;\n+                self.write_primval(dest, PrimVal::from_bool(false), bool)?;\n+            }\n+            _ => return Err(EvalError::NoMirFor(path)),\n+        }\n+\n+        // Since we pushed no stack frame, the main loop will act\n+        // as if the call just completed and it's returning to the\n+        // current frame.\n+        self.dump_local(dest);\n+        self.goto_block(dest_block);\n+        return Ok(());\n+    }\n+}"}, {"sha": "bd17ab6f2cbf98c912616df0b9265c6536f00c42", "filename": "miri/lib.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e5799a6af35f5c0a257ff375498c5237e4a5466b/miri%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5799a6af35f5c0a257ff375498c5237e4a5466b/miri%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/miri%2Flib.rs?ref=e5799a6af35f5c0a257ff375498c5237e4a5466b", "patch": "@@ -17,6 +17,8 @@ use rustc::ty::{self, TyCtxt};\n use rustc::hir::def_id::DefId;\n use rustc::mir;\n \n+use syntax::codemap::Span;\n+\n use std::collections::{\n     HashMap,\n     BTreeMap,\n@@ -25,10 +27,10 @@ use std::collections::{\n extern crate rustc_miri;\n pub use rustc_miri::interpret::*;\n \n-mod missing_fns;\n+mod fn_call;\n mod operator;\n \n-use missing_fns::EvalContextExt as MissingFnsEvalContextExt;\n+use fn_call::EvalContextExt as MissingFnsEvalContextExt;\n use operator::EvalContextExt as OperatorEvalContextExt;\n \n pub fn eval_main<'a, 'tcx: 'a>(\n@@ -272,17 +274,19 @@ impl<'a, 'tcx: 'a> MemoryExt<'tcx> for Memory<'a, 'tcx, Evaluator> {\n impl<'tcx> Machine<'tcx> for Evaluator {\n     type Data = EvaluatorData;\n     type MemoryData = MemoryData<'tcx>;\n+\n     /// Returns Ok() when the function was handled, fail otherwise\n-    fn call_missing_fn<'a>(\n+    fn eval_fn_call<'a>(\n         ecx: &mut EvalContext<'a, 'tcx, Self>,\n         instance: ty::Instance<'tcx>,\n         destination: Option<(Lvalue<'tcx>, mir::BasicBlock)>,\n         arg_operands: &[mir::Operand<'tcx>],\n+        span: Span,\n         sig: ty::FnSig<'tcx>,\n-        path: String,\n-    ) -> EvalResult<'tcx> {\n-        ecx.call_missing_fn(instance, destination, arg_operands, sig, path)\n+    ) -> EvalResult<'tcx, bool> {\n+        ecx.eval_fn_call(instance, destination, arg_operands, span, sig)\n     }\n+\n     fn ptr_op<'a>(\n         ecx: &rustc_miri::interpret::EvalContext<'a, 'tcx, Self>,\n         bin_op: mir::BinOp,\n@@ -293,8 +297,4 @@ impl<'tcx> Machine<'tcx> for Evaluator {\n     ) -> EvalResult<'tcx, Option<(PrimVal, bool)>> {\n         ecx.ptr_op(bin_op, left, left_ty, right, right_ty)\n     }\n-\n-    fn check_non_const_fn_call(_instance: ty::Instance<'tcx>) -> EvalResult<'tcx> {\n-        Ok(())\n-    }\n }"}, {"sha": "32f5a0a183ef95926f61e0b769384ee3ecbe4462", "filename": "src/librustc_mir/interpret/const_eval.rs", "status": "modified", "additions": 32, "deletions": 12, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/e5799a6af35f5c0a257ff375498c5237e4a5466b/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5799a6af35f5c0a257ff375498c5237e4a5466b/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs?ref=e5799a6af35f5c0a257ff375498c5237e4a5466b", "patch": "@@ -3,6 +3,7 @@ use rustc::ty::{self, TyCtxt, Ty, Instance};\n use rustc::mir;\n \n use syntax::ast::Mutability;\n+use syntax::codemap::Span;\n \n use super::{\n     EvalResult, EvalError,\n@@ -127,16 +128,39 @@ impl Error for ConstEvalError {\n impl<'tcx> super::Machine<'tcx> for CompileTimeFunctionEvaluator {\n     type Data = ();\n     type MemoryData = ();\n-    fn call_missing_fn<'a>(\n-        _ecx: &mut EvalContext<'a, 'tcx, Self>,\n-        _instance: ty::Instance<'tcx>,\n-        _destination: Option<(Lvalue<'tcx>, mir::BasicBlock)>,\n+    fn eval_fn_call<'a>(\n+        ecx: &mut EvalContext<'a, 'tcx, Self>,\n+        instance: ty::Instance<'tcx>,\n+        destination: Option<(Lvalue<'tcx>, mir::BasicBlock)>,\n         _arg_operands: &[mir::Operand<'tcx>],\n+        span: Span,\n         _sig: ty::FnSig<'tcx>,\n-        path: String,\n-    ) -> EvalResult<'tcx> {\n-        // some simple things like `malloc` might get accepted in the future\n-        Err(ConstEvalError::NeedsRfc(format!(\"calling extern function `{}`\", path)).into())\n+    ) -> EvalResult<'tcx, bool> {\n+        if !ecx.tcx.is_const_fn(instance.def_id()) {\n+            return Err(ConstEvalError::NotConst(format!(\"calling non-const fn `{}`\", instance)).into());\n+        }\n+        let mir = match ecx.load_mir(instance.def) {\n+            Ok(mir) => mir,\n+            Err(EvalError::NoMirFor(path)) => {\n+                // some simple things like `malloc` might get accepted in the future\n+                return Err(ConstEvalError::NeedsRfc(format!(\"calling extern function `{}`\", path)).into());\n+            },\n+            Err(other) => return Err(other),\n+        };\n+        let (return_lvalue, return_to_block) = match destination {\n+            Some((lvalue, block)) => (lvalue, StackPopCleanup::Goto(block)),\n+            None => (Lvalue::undef(), StackPopCleanup::None),\n+        };\n+\n+        ecx.push_stack_frame(\n+            instance,\n+            span,\n+            mir,\n+            return_lvalue,\n+            return_to_block,\n+        )?;\n+\n+        Ok(false)\n     }\n \n     fn ptr_op<'a>(\n@@ -149,8 +173,4 @@ impl<'tcx> super::Machine<'tcx> for CompileTimeFunctionEvaluator {\n     ) -> EvalResult<'tcx, Option<(PrimVal, bool)>> {\n         Err(ConstEvalError::NeedsRfc(\"Pointer arithmetic or comparison\".to_string()).into())\n     }\n-\n-    fn check_non_const_fn_call(instance: ty::Instance<'tcx>) -> EvalResult<'tcx> {\n-        return Err(ConstEvalError::NotConst(format!(\"calling non-const fn `{}`\", instance)).into());\n-    }\n }"}, {"sha": "ebf15300e8cf7a0a78dc13917defa8358f6e7c69", "filename": "src/librustc_mir/interpret/machine.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e5799a6af35f5c0a257ff375498c5237e4a5466b/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5799a6af35f5c0a257ff375498c5237e4a5466b/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs?ref=e5799a6af35f5c0a257ff375498c5237e4a5466b", "patch": "@@ -10,6 +10,7 @@ use super::{\n };\n \n use rustc::{mir, ty};\n+use syntax::codemap::Span;\n \n /// Methods of this trait signifies a point where CTFE evaluation would fail\n /// and some use case dependent behaviour can instead be applied\n@@ -20,16 +21,20 @@ pub trait Machine<'tcx>: Sized {\n     /// Additional data that can be accessed via the Memory\n     type MemoryData;\n \n-    /// Called when a function's MIR is not found.\n-    /// This will happen for `extern \"C\"` functions.\n-    fn call_missing_fn<'a>(\n+    /// Entry point to all function calls.\n+    ///\n+    /// Returns Ok(true) when the function was handled completely\n+    /// e.g. due to missing mir or \n+    ///\n+    /// Returns Ok(false) if a new stack frame was pushed\n+    fn eval_fn_call<'a>(\n         ecx: &mut EvalContext<'a, 'tcx, Self>,\n         instance: ty::Instance<'tcx>,\n         destination: Option<(Lvalue<'tcx>, mir::BasicBlock)>,\n         arg_operands: &[mir::Operand<'tcx>],\n+        span: Span,\n         sig: ty::FnSig<'tcx>,\n-        path: String,\n-    ) -> EvalResult<'tcx>;\n+    ) -> EvalResult<'tcx, bool>;\n \n     /// Called when operating on the value of pointers.\n     ///\n@@ -45,10 +50,5 @@ pub trait Machine<'tcx>: Sized {\n         right: PrimVal,\n         right_ty: ty::Ty<'tcx>,\n     ) -> EvalResult<'tcx, Option<(PrimVal, bool)>>;\n-\n-    /// Called when adding a frame for a function that's not `const fn`\n-    ///\n-    /// Const eval returns `Err`, miri returns `Ok`\n-    fn check_non_const_fn_call(instance: ty::Instance<'tcx>) -> EvalResult<'tcx>;\n }\n "}, {"sha": "21e59e9d456f3f02790901efa5c8aed32e10dbb9", "filename": "src/librustc_mir/interpret/terminator/mod.rs", "status": "modified", "additions": 7, "deletions": 46, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/e5799a6af35f5c0a257ff375498c5237e4a5466b/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5799a6af35f5c0a257ff375498c5237e4a5466b/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs?ref=e5799a6af35f5c0a257ff375498c5237e4a5466b", "patch": "@@ -6,7 +6,7 @@ use syntax::abi::Abi;\n \n use super::{\n     EvalError, EvalResult,\n-    EvalContext, StackPopCleanup, eval_context, TyAndPacked,\n+    EvalContext, eval_context, TyAndPacked,\n     Lvalue,\n     MemoryPointer,\n     PrimVal, Value,\n@@ -233,7 +233,8 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                     let arg_ty = self.operand_ty(arg);\n                     args.push((arg_val, arg_ty));\n                 }\n-                if self.eval_fn_call_inner(\n+                if M::eval_fn_call(\n+                    self,\n                     instance,\n                     destination,\n                     arg_operands,\n@@ -276,7 +277,8 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                 }\n \n                 // Push the stack frame, and potentially be entirely done if the call got hooked\n-                if self.eval_fn_call_inner(\n+                if M::eval_fn_call(\n+                    self,\n                     instance,\n                     destination,\n                     arg_operands,\n@@ -369,7 +371,8 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                     let arg_ty = self.operand_ty(arg);\n                     args.push((arg_val, arg_ty));\n                 }\n-                if self.eval_fn_call_inner(\n+                if M::eval_fn_call(\n+                    self,\n                     instance,\n                     destination,\n                     arg_operands,\n@@ -416,48 +419,6 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         }\n     }\n \n-    /// Returns Ok(true) when the function was handled completely due to mir not being available\n-    fn eval_fn_call_inner(\n-        &mut self,\n-        instance: ty::Instance<'tcx>,\n-        destination: Option<(Lvalue<'tcx>, mir::BasicBlock)>,\n-        arg_operands: &[mir::Operand<'tcx>],\n-        span: Span,\n-        sig: ty::FnSig<'tcx>,\n-    ) -> EvalResult<'tcx, bool> {\n-        trace!(\"eval_fn_call_inner: {:#?}, {:#?}\", instance, destination);\n-\n-        // Only trait methods can have a Self parameter.\n-\n-        let mir = match self.load_mir(instance.def) {\n-            Ok(mir) => mir,\n-            Err(EvalError::NoMirFor(path)) => {\n-                M::call_missing_fn(self, instance, destination, arg_operands, sig, path)?;\n-                return Ok(true);\n-            },\n-            Err(other) => return Err(other),\n-        };\n-\n-        if !self.tcx.is_const_fn(instance.def_id()) {\n-            M::check_non_const_fn_call(instance)?;\n-        }\n-        \n-        let (return_lvalue, return_to_block) = match destination {\n-            Some((lvalue, block)) => (lvalue, StackPopCleanup::Goto(block)),\n-            None => (Lvalue::undef(), StackPopCleanup::None),\n-        };\n-\n-        self.push_stack_frame(\n-            instance,\n-            span,\n-            mir,\n-            return_lvalue,\n-            return_to_block,\n-        )?;\n-\n-        Ok(false)\n-    }\n-\n     pub fn read_discriminant_value(&self, adt_ptr: MemoryPointer, adt_ty: Ty<'tcx>) -> EvalResult<'tcx, u128> {\n         use rustc::ty::layout::Layout::*;\n         let adt_layout = self.type_layout(adt_ty)?;"}]}