{"sha": "327450797d460ae011eaaba68fae356117ab883d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMyNzQ1MDc5N2Q0NjBhZTAxMWVhYWJhNjhmYWUzNTYxMTdhYjg4M2Q=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-06-29T22:24:34Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-07-06T15:36:35Z"}, "message": "resolve: Reserve cfg/cfg_attr/derive only in attribute sub-namespace", "tree": {"sha": "e62c1ca85f91c9b25a062a8833f266a59474c447", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e62c1ca85f91c9b25a062a8833f266a59474c447"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/327450797d460ae011eaaba68fae356117ab883d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/327450797d460ae011eaaba68fae356117ab883d", "html_url": "https://github.com/rust-lang/rust/commit/327450797d460ae011eaaba68fae356117ab883d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/327450797d460ae011eaaba68fae356117ab883d/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "920a17a60c13101225a3a50e232c3e44017dab69", "url": "https://api.github.com/repos/rust-lang/rust/commits/920a17a60c13101225a3a50e232c3e44017dab69", "html_url": "https://github.com/rust-lang/rust/commit/920a17a60c13101225a3a50e232c3e44017dab69"}], "stats": {"total": 69, "additions": 38, "deletions": 31}, "files": [{"sha": "3921bd30df25ce5caae147597b52dfa13830dc83", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/327450797d460ae011eaaba68fae356117ab883d/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/327450797d460ae011eaaba68fae356117ab883d/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=327450797d460ae011eaaba68fae356117ab883d", "patch": "@@ -770,27 +770,33 @@ impl<'a> Resolver<'a> {\n     }\n \n     pub fn get_macro(&mut self, res: Res) -> Lrc<SyntaxExtension> {\n+        self.opt_get_macro(res).expect(\"expected `DefKind::Macro` or `Res::NonMacroAttr`\")\n+    }\n+\n+    crate fn opt_get_macro(&mut self, res: Res) -> Option<Lrc<SyntaxExtension>> {\n         let def_id = match res {\n+            Res::Def(DefKind::Macro(MacroKind::ProcMacroStub), _) =>\n+                return Some(self.non_macro_attr(true)), // some dummy extension\n             Res::Def(DefKind::Macro(..), def_id) => def_id,\n             Res::NonMacroAttr(attr_kind) =>\n-                return self.non_macro_attr(attr_kind == NonMacroAttrKind::Tool),\n-            _ => panic!(\"expected `DefKind::Macro` or `Res::NonMacroAttr`\"),\n+                return Some(self.non_macro_attr(attr_kind == NonMacroAttrKind::Tool)),\n+            _ => return None,\n         };\n         if let Some(ext) = self.macro_map.get(&def_id) {\n-            return ext.clone();\n+            return Some(ext.clone());\n         }\n \n         let macro_def = match self.cstore.load_macro_untracked(def_id, &self.session) {\n             LoadedMacro::MacroDef(macro_def) => macro_def,\n-            LoadedMacro::ProcMacro(ext) => return ext,\n+            LoadedMacro::ProcMacro(ext) => return Some(ext),\n         };\n \n         let ext = Lrc::new(macro_rules::compile(&self.session.parse_sess,\n                                                &self.session.features_untracked(),\n                                                &macro_def,\n                                                self.cstore.crate_edition_untracked(def_id.krate)));\n         self.macro_map.insert(def_id, ext.clone());\n-        ext\n+        Some(ext)\n     }\n \n     /// Ensures that the reduced graph rooted at the given external module"}, {"sha": "0955c425f2f7da821a0e37752c257702bbcc31a1", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 16, "deletions": 5, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/327450797d460ae011eaaba68fae356117ab883d/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/327450797d460ae011eaaba68fae356117ab883d/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=327450797d460ae011eaaba68fae356117ab883d", "patch": "@@ -1106,6 +1106,19 @@ impl<'a> Resolver<'a> {\n         });\n     }\n \n+    crate fn check_reserved_macro_name(&mut self, ident: Ident, res: Res) {\n+        // Reserve some names that are not quite covered by the general check\n+        // performed on `Resolver::builtin_attrs`.\n+        if ident.name == sym::cfg || ident.name == sym::cfg_attr || ident.name == sym::derive {\n+            let macro_kind = self.opt_get_macro(res).map(|ext| ext.macro_kind());\n+            if macro_kind.is_some() && sub_namespace_match(macro_kind, Some(MacroKind::Attr)) {\n+                self.session.span_err(\n+                    ident.span, &format!(\"name `{}` is reserved in attribute namespace\", ident)\n+                );\n+            }\n+        }\n+    }\n+\n     pub fn define_macro(&mut self,\n                         item: &ast::Item,\n                         expansion: Mark,\n@@ -1117,13 +1130,14 @@ impl<'a> Resolver<'a> {\n         let ext = Lrc::new(macro_rules::compile(&self.session.parse_sess,\n                                                &self.session.features_untracked(),\n                                                item, self.session.edition()));\n+        let macro_kind = ext.macro_kind();\n+        let res = Res::Def(DefKind::Macro(macro_kind), def_id);\n         self.macro_map.insert(def_id, ext);\n \n         let def = match item.node { ast::ItemKind::MacroDef(ref def) => def, _ => unreachable!() };\n         if def.legacy {\n             let ident = ident.modern();\n             self.macro_names.insert(ident);\n-            let res = Res::Def(DefKind::Macro(MacroKind::Bang), def_id);\n             let is_macro_export = attr::contains_name(&item.attrs, sym::macro_export);\n             let vis = if is_macro_export {\n                 ty::Visibility::Public\n@@ -1142,14 +1156,11 @@ impl<'a> Resolver<'a> {\n                 self.define(module, ident, MacroNS,\n                             (res, vis, item.span, expansion, IsMacroExport));\n             } else {\n-                if !attr::contains_name(&item.attrs, sym::rustc_builtin_macro) {\n-                    self.check_reserved_macro_name(ident, MacroNS);\n-                }\n+                self.check_reserved_macro_name(ident, res);\n                 self.unused_macros.insert(def_id);\n             }\n         } else {\n             let module = self.current_module;\n-            let res = Res::Def(DefKind::Macro(MacroKind::Bang), def_id);\n             let vis = self.resolve_visibility(&item.vis);\n             if vis != ty::Visibility::Public {\n                 self.unused_macros.insert(def_id);"}, {"sha": "7de1cd29a9ca84aea1a00764c0f4dc65baba8163", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 5, "deletions": 15, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/327450797d460ae011eaaba68fae356117ab883d/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/327450797d460ae011eaaba68fae356117ab883d/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=327450797d460ae011eaaba68fae356117ab883d", "patch": "@@ -29,7 +29,7 @@ use rustc::{bug, span_bug};\n use syntax::ast::{self, Ident, Name, NodeId, CRATE_NODE_ID};\n use syntax::ext::base::Determinacy::{self, Determined, Undetermined};\n use syntax::ext::hygiene::Mark;\n-use syntax::symbol::{kw, sym};\n+use syntax::symbol::kw;\n use syntax::util::lev_distance::find_best_match_for_name;\n use syntax::{struct_span_err, unwrap_or};\n use syntax_pos::{MultiSpan, Span};\n@@ -492,35 +492,25 @@ impl<'a> Resolver<'a> {\n         })\n     }\n \n-    crate fn check_reserved_macro_name(&self, ident: Ident, ns: Namespace) {\n-        // Reserve some names that are not quite covered by the general check\n-        // performed on `Resolver::builtin_attrs`.\n-        if ns == MacroNS &&\n-           (ident.name == sym::cfg || ident.name == sym::cfg_attr ||\n-            ident.name == sym::derive) {\n-            self.session.span_err(ident.span,\n-                                  &format!(\"name `{}` is reserved in macro namespace\", ident));\n-        }\n-    }\n-\n     // Define the name or return the existing binding if there is a collision.\n     pub fn try_define(&mut self,\n                       module: Module<'a>,\n                       ident: Ident,\n                       ns: Namespace,\n                       binding: &'a NameBinding<'a>)\n                       -> Result<(), &'a NameBinding<'a>> {\n-        self.check_reserved_macro_name(ident, ns);\n+        let res = binding.res();\n+        self.check_reserved_macro_name(ident, res);\n         self.set_binding_parent_module(binding, module);\n         self.update_resolution(module, ident, ns, |this, resolution| {\n             if let Some(old_binding) = resolution.binding {\n-                if binding.res() == Res::Err {\n+                if res == Res::Err {\n                     // Do not override real bindings with `Res::Err`s from error recovery.\n                     return Ok(());\n                 }\n                 match (old_binding.is_glob_import(), binding.is_glob_import()) {\n                     (true, true) => {\n-                        if binding.res() != old_binding.res() {\n+                        if res != old_binding.res() {\n                             resolution.binding = Some(this.ambiguity(AmbiguityKind::GlobVsGlob,\n                                                                      old_binding, binding));\n                         } else if !old_binding.vis.is_at_least(binding.vis, &*this) {"}, {"sha": "9f56eccb7a61c1f26d7ab059cf71f01796a1c781", "filename": "src/test/ui/proc-macro/reserved-macro-names.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/327450797d460ae011eaaba68fae356117ab883d/src%2Ftest%2Fui%2Fproc-macro%2Freserved-macro-names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/327450797d460ae011eaaba68fae356117ab883d/src%2Ftest%2Fui%2Fproc-macro%2Freserved-macro-names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Freserved-macro-names.rs?ref=327450797d460ae011eaaba68fae356117ab883d", "patch": "@@ -8,18 +8,18 @@ use proc_macro::*;\n \n #[proc_macro_attribute]\n pub fn cfg(_: TokenStream, input: TokenStream) -> TokenStream {\n-    //~^ ERROR name `cfg` is reserved in macro namespace\n+    //~^ ERROR name `cfg` is reserved in attribute namespace\n     input\n }\n \n #[proc_macro_attribute]\n pub fn cfg_attr(_: TokenStream, input: TokenStream) -> TokenStream {\n-    //~^ ERROR name `cfg_attr` is reserved in macro namespace\n+    //~^ ERROR name `cfg_attr` is reserved in attribute namespace\n     input\n }\n \n #[proc_macro_attribute]\n pub fn derive(_: TokenStream, input: TokenStream) -> TokenStream {\n-    //~^ ERROR name `derive` is reserved in macro namespace\n+    //~^ ERROR name `derive` is reserved in attribute namespace\n     input\n }"}, {"sha": "f871e43ce51df80b25eca0c6dfdd55bb54dfc10d", "filename": "src/test/ui/proc-macro/reserved-macro-names.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/327450797d460ae011eaaba68fae356117ab883d/src%2Ftest%2Fui%2Fproc-macro%2Freserved-macro-names.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/327450797d460ae011eaaba68fae356117ab883d/src%2Ftest%2Fui%2Fproc-macro%2Freserved-macro-names.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Freserved-macro-names.stderr?ref=327450797d460ae011eaaba68fae356117ab883d", "patch": "@@ -1,16 +1,16 @@\n-error: name `cfg` is reserved in macro namespace\n+error: name `cfg` is reserved in attribute namespace\n   --> $DIR/reserved-macro-names.rs:10:8\n    |\n LL | pub fn cfg(_: TokenStream, input: TokenStream) -> TokenStream {\n    |        ^^^\n \n-error: name `cfg_attr` is reserved in macro namespace\n+error: name `cfg_attr` is reserved in attribute namespace\n   --> $DIR/reserved-macro-names.rs:16:8\n    |\n LL | pub fn cfg_attr(_: TokenStream, input: TokenStream) -> TokenStream {\n    |        ^^^^^^^^\n \n-error: name `derive` is reserved in macro namespace\n+error: name `derive` is reserved in attribute namespace\n   --> $DIR/reserved-macro-names.rs:22:8\n    |\n LL | pub fn derive(_: TokenStream, input: TokenStream) -> TokenStream {"}]}