{"sha": "a2e9374048f1c04f025469dde88e13a5037d8db7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEyZTkzNzQwNDhmMWMwNGYwMjU0NjlkZGU4OGUxM2E1MDM3ZDhkYjc=", "commit": {"author": {"name": "Camelid", "email": "camelidcamel@gmail.com", "date": "2021-03-20T21:23:38Z"}, "committer": {"name": "Camelid", "email": "camelidcamel@gmail.com", "date": "2021-03-20T21:38:49Z"}, "message": "Move debuginfo docs from `doc.rs` module to `doc.md` file\n\nAnd use `#[doc = include_str!(\"doc.md\")]` in `mod.rs` so the docs are\nrendered as if they were inline in the root module.", "tree": {"sha": "cc88dbf3b98090012562886fc60015425394f266", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cc88dbf3b98090012562886fc60015425394f266"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a2e9374048f1c04f025469dde88e13a5037d8db7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a2e9374048f1c04f025469dde88e13a5037d8db7", "html_url": "https://github.com/rust-lang/rust/commit/a2e9374048f1c04f025469dde88e13a5037d8db7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a2e9374048f1c04f025469dde88e13a5037d8db7/comments", "author": {"login": "camelid", "id": 37223377, "node_id": "MDQ6VXNlcjM3MjIzMzc3", "avatar_url": "https://avatars.githubusercontent.com/u/37223377?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camelid", "html_url": "https://github.com/camelid", "followers_url": "https://api.github.com/users/camelid/followers", "following_url": "https://api.github.com/users/camelid/following{/other_user}", "gists_url": "https://api.github.com/users/camelid/gists{/gist_id}", "starred_url": "https://api.github.com/users/camelid/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camelid/subscriptions", "organizations_url": "https://api.github.com/users/camelid/orgs", "repos_url": "https://api.github.com/users/camelid/repos", "events_url": "https://api.github.com/users/camelid/events{/privacy}", "received_events_url": "https://api.github.com/users/camelid/received_events", "type": "User", "site_admin": false}, "committer": {"login": "camelid", "id": 37223377, "node_id": "MDQ6VXNlcjM3MjIzMzc3", "avatar_url": "https://avatars.githubusercontent.com/u/37223377?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camelid", "html_url": "https://github.com/camelid", "followers_url": "https://api.github.com/users/camelid/followers", "following_url": "https://api.github.com/users/camelid/following{/other_user}", "gists_url": "https://api.github.com/users/camelid/gists{/gist_id}", "starred_url": "https://api.github.com/users/camelid/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camelid/subscriptions", "organizations_url": "https://api.github.com/users/camelid/orgs", "repos_url": "https://api.github.com/users/camelid/repos", "events_url": "https://api.github.com/users/camelid/events{/privacy}", "received_events_url": "https://api.github.com/users/camelid/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "61edfd591cedff66fca639c02f66984f6271e5a6", "url": "https://api.github.com/repos/rust-lang/rust/commits/61edfd591cedff66fca639c02f66984f6271e5a6", "html_url": "https://github.com/rust-lang/rust/commit/61edfd591cedff66fca639c02f66984f6271e5a6"}], "stats": {"total": 362, "additions": 181, "deletions": 181}, "files": [{"sha": "485b124ab06bad59bd8b66afa14be866225cea85", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/doc.md", "status": "added", "additions": 179, "deletions": 0, "changes": 179, "blob_url": "https://github.com/rust-lang/rust/blob/a2e9374048f1c04f025469dde88e13a5037d8db7/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fdoc.md", "raw_url": "https://github.com/rust-lang/rust/raw/a2e9374048f1c04f025469dde88e13a5037d8db7/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fdoc.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fdoc.md?ref=a2e9374048f1c04f025469dde88e13a5037d8db7", "patch": "@@ -0,0 +1,179 @@\n+# Debug Info Module\n+\n+This module serves the purpose of generating debug symbols. We use LLVM's\n+[source level debugging](https://llvm.org/docs/SourceLevelDebugging.html)\n+features for generating the debug information. The general principle is\n+this:\n+\n+Given the right metadata in the LLVM IR, the LLVM code generator is able to\n+create DWARF debug symbols for the given code. The\n+[metadata](https://llvm.org/docs/LangRef.html#metadata-type) is structured\n+much like DWARF *debugging information entries* (DIE), representing type\n+information such as datatype layout, function signatures, block layout,\n+variable location and scope information, etc. It is the purpose of this\n+module to generate correct metadata and insert it into the LLVM IR.\n+\n+As the exact format of metadata trees may change between different LLVM\n+versions, we now use LLVM\n+[DIBuilder](https://llvm.org/docs/doxygen/html/classllvm_1_1DIBuilder.html)\n+to create metadata where possible. This will hopefully ease the adaption of\n+this module to future LLVM versions.\n+\n+The public API of the module is a set of functions that will insert the\n+correct metadata into the LLVM IR when called with the right parameters.\n+The module is thus driven from an outside client with functions like\n+`debuginfo::create_local_var_metadata(bx: block, local: &ast::local)`.\n+\n+Internally the module will try to reuse already created metadata by\n+utilizing a cache. The way to get a shared metadata node when needed is\n+thus to just call the corresponding function in this module:\n+\n+    let file_metadata = file_metadata(cx, file);\n+\n+The function will take care of probing the cache for an existing node for\n+that exact file path.\n+\n+All private state used by the module is stored within either the\n+CrateDebugContext struct (owned by the CodegenCx) or the\n+FunctionDebugContext (owned by the FunctionCx).\n+\n+This file consists of three conceptual sections:\n+1. The public interface of the module\n+2. Module-internal metadata creation functions\n+3. Minor utility functions\n+\n+\n+## Recursive Types\n+\n+Some kinds of types, such as structs and enums can be recursive. That means\n+that the type definition of some type X refers to some other type which in\n+turn (transitively) refers to X. This introduces cycles into the type\n+referral graph. A naive algorithm doing an on-demand, depth-first traversal\n+of this graph when describing types, can get trapped in an endless loop\n+when it reaches such a cycle.\n+\n+For example, the following simple type for a singly-linked list...\n+\n+```\n+struct List {\n+    value: i32,\n+    tail: Option<Box<List>>,\n+}\n+```\n+\n+will generate the following callstack with a naive DFS algorithm:\n+\n+```\n+describe(t = List)\n+  describe(t = i32)\n+  describe(t = Option<Box<List>>)\n+    describe(t = Box<List>)\n+      describe(t = List) // at the beginning again...\n+      ...\n+```\n+\n+To break cycles like these, we use \"forward declarations\". That is, when\n+the algorithm encounters a possibly recursive type (any struct or enum), it\n+immediately creates a type description node and inserts it into the cache\n+*before* describing the members of the type. This type description is just\n+a stub (as type members are not described and added to it yet) but it\n+allows the algorithm to already refer to the type. After the stub is\n+inserted into the cache, the algorithm continues as before. If it now\n+encounters a recursive reference, it will hit the cache and does not try to\n+describe the type anew.\n+\n+This behavior is encapsulated in the 'RecursiveTypeDescription' enum,\n+which represents a kind of continuation, storing all state needed to\n+continue traversal at the type members after the type has been registered\n+with the cache. (This implementation approach might be a tad over-\n+engineered and may change in the future)\n+\n+\n+## Source Locations and Line Information\n+\n+In addition to data type descriptions the debugging information must also\n+allow to map machine code locations back to source code locations in order\n+to be useful. This functionality is also handled in this module. The\n+following functions allow to control source mappings:\n+\n++ set_source_location()\n++ clear_source_location()\n++ start_emitting_source_locations()\n+\n+`set_source_location()` allows to set the current source location. All IR\n+instructions created after a call to this function will be linked to the\n+given source location, until another location is specified with\n+`set_source_location()` or the source location is cleared with\n+`clear_source_location()`. In the later case, subsequent IR instruction\n+will not be linked to any source location. As you can see, this is a\n+stateful API (mimicking the one in LLVM), so be careful with source\n+locations set by previous calls. It's probably best to not rely on any\n+specific state being present at a given point in code.\n+\n+One topic that deserves some extra attention is *function prologues*. At\n+the beginning of a function's machine code there are typically a few\n+instructions for loading argument values into allocas and checking if\n+there's enough stack space for the function to execute. This *prologue* is\n+not visible in the source code and LLVM puts a special PROLOGUE END marker\n+into the line table at the first non-prologue instruction of the function.\n+In order to find out where the prologue ends, LLVM looks for the first\n+instruction in the function body that is linked to a source location. So,\n+when generating prologue instructions we have to make sure that we don't\n+emit source location information until the 'real' function body begins. For\n+this reason, source location emission is disabled by default for any new\n+function being codegened and is only activated after a call to the third\n+function from the list above, `start_emitting_source_locations()`. This\n+function should be called right before regularly starting to codegen the\n+top-level block of the given function.\n+\n+There is one exception to the above rule: `llvm.dbg.declare` instruction\n+must be linked to the source location of the variable being declared. For\n+function parameters these `llvm.dbg.declare` instructions typically occur\n+in the middle of the prologue, however, they are ignored by LLVM's prologue\n+detection. The `create_argument_metadata()` and related functions take care\n+of linking the `llvm.dbg.declare` instructions to the correct source\n+locations even while source location emission is still disabled, so there\n+is no need to do anything special with source location handling here.\n+\n+## Unique Type Identification\n+\n+In order for link-time optimization to work properly, LLVM needs a unique\n+type identifier that tells it across compilation units which types are the\n+same as others. This type identifier is created by\n+`TypeMap::get_unique_type_id_of_type()` using the following algorithm:\n+\n+(1) Primitive types have their name as ID\n+(2) Structs, enums and traits have a multipart identifier\n+\n+    (1) The first part is the SVH (strict version hash) of the crate they\n+         were originally defined in\n+\n+    (2) The second part is the ast::NodeId of the definition in their\n+         original crate\n+\n+    (3) The final part is a concatenation of the type IDs of their concrete\n+         type arguments if they are generic types.\n+\n+(3) Tuple-, pointer and function types are structurally identified, which\n+    means that they are equivalent if their component types are equivalent\n+    (i.e., (i32, i32) is the same regardless in which crate it is used).\n+\n+This algorithm also provides a stable ID for types that are defined in one\n+crate but instantiated from metadata within another crate. We just have to\n+take care to always map crate and `NodeId`s back to the original crate\n+context.\n+\n+As a side-effect these unique type IDs also help to solve a problem arising\n+from lifetime parameters. Since lifetime parameters are completely omitted\n+in debuginfo, more than one `Ty` instance may map to the same debuginfo\n+type metadata, that is, some struct `Struct<'a>` may have N instantiations\n+with different concrete substitutions for `'a`, and thus there will be N\n+`Ty` instances for the type `Struct<'a>` even though it is not generic\n+otherwise. Unfortunately this means that we cannot use `ty::type_id()` as\n+cheap identifier for type metadata -- we have done this in the past, but it\n+led to unnecessary metadata duplication in the best case and LLVM\n+assertions in the worst. However, the unique type ID as described above\n+*can* be used as identifier. Since it is comparatively expensive to\n+construct, though, `ty::type_id()` is still used additionally as an\n+optimization for cases where the exact same type has been seen before\n+(which is most of the time)."}, {"sha": "10dd590652949a3e54d209ea0e23a8f1ac79a6d8", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/doc.rs", "status": "removed", "additions": 0, "deletions": 179, "changes": 179, "blob_url": "https://github.com/rust-lang/rust/blob/61edfd591cedff66fca639c02f66984f6271e5a6/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61edfd591cedff66fca639c02f66984f6271e5a6/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fdoc.rs?ref=61edfd591cedff66fca639c02f66984f6271e5a6", "patch": "@@ -1,179 +0,0 @@\n-//! # Debug Info Module\n-//!\n-//! This module serves the purpose of generating debug symbols. We use LLVM's\n-//! [source level debugging](https://llvm.org/docs/SourceLevelDebugging.html)\n-//! features for generating the debug information. The general principle is\n-//! this:\n-//!\n-//! Given the right metadata in the LLVM IR, the LLVM code generator is able to\n-//! create DWARF debug symbols for the given code. The\n-//! [metadata](https://llvm.org/docs/LangRef.html#metadata-type) is structured\n-//! much like DWARF *debugging information entries* (DIE), representing type\n-//! information such as datatype layout, function signatures, block layout,\n-//! variable location and scope information, etc. It is the purpose of this\n-//! module to generate correct metadata and insert it into the LLVM IR.\n-//!\n-//! As the exact format of metadata trees may change between different LLVM\n-//! versions, we now use LLVM\n-//! [DIBuilder](https://llvm.org/docs/doxygen/html/classllvm_1_1DIBuilder.html)\n-//! to create metadata where possible. This will hopefully ease the adaption of\n-//! this module to future LLVM versions.\n-//!\n-//! The public API of the module is a set of functions that will insert the\n-//! correct metadata into the LLVM IR when called with the right parameters.\n-//! The module is thus driven from an outside client with functions like\n-//! `debuginfo::create_local_var_metadata(bx: block, local: &ast::local)`.\n-//!\n-//! Internally the module will try to reuse already created metadata by\n-//! utilizing a cache. The way to get a shared metadata node when needed is\n-//! thus to just call the corresponding function in this module:\n-//!\n-//!     let file_metadata = file_metadata(cx, file);\n-//!\n-//! The function will take care of probing the cache for an existing node for\n-//! that exact file path.\n-//!\n-//! All private state used by the module is stored within either the\n-//! CrateDebugContext struct (owned by the CodegenCx) or the\n-//! FunctionDebugContext (owned by the FunctionCx).\n-//!\n-//! This file consists of three conceptual sections:\n-//! 1. The public interface of the module\n-//! 2. Module-internal metadata creation functions\n-//! 3. Minor utility functions\n-//!\n-//!\n-//! ## Recursive Types\n-//!\n-//! Some kinds of types, such as structs and enums can be recursive. That means\n-//! that the type definition of some type X refers to some other type which in\n-//! turn (transitively) refers to X. This introduces cycles into the type\n-//! referral graph. A naive algorithm doing an on-demand, depth-first traversal\n-//! of this graph when describing types, can get trapped in an endless loop\n-//! when it reaches such a cycle.\n-//!\n-//! For example, the following simple type for a singly-linked list...\n-//!\n-//! ```\n-//! struct List {\n-//!     value: i32,\n-//!     tail: Option<Box<List>>,\n-//! }\n-//! ```\n-//!\n-//! will generate the following callstack with a naive DFS algorithm:\n-//!\n-//! ```\n-//! describe(t = List)\n-//!   describe(t = i32)\n-//!   describe(t = Option<Box<List>>)\n-//!     describe(t = Box<List>)\n-//!       describe(t = List) // at the beginning again...\n-//!       ...\n-//! ```\n-//!\n-//! To break cycles like these, we use \"forward declarations\". That is, when\n-//! the algorithm encounters a possibly recursive type (any struct or enum), it\n-//! immediately creates a type description node and inserts it into the cache\n-//! *before* describing the members of the type. This type description is just\n-//! a stub (as type members are not described and added to it yet) but it\n-//! allows the algorithm to already refer to the type. After the stub is\n-//! inserted into the cache, the algorithm continues as before. If it now\n-//! encounters a recursive reference, it will hit the cache and does not try to\n-//! describe the type anew.\n-//!\n-//! This behavior is encapsulated in the 'RecursiveTypeDescription' enum,\n-//! which represents a kind of continuation, storing all state needed to\n-//! continue traversal at the type members after the type has been registered\n-//! with the cache. (This implementation approach might be a tad over-\n-//! engineered and may change in the future)\n-//!\n-//!\n-//! ## Source Locations and Line Information\n-//!\n-//! In addition to data type descriptions the debugging information must also\n-//! allow to map machine code locations back to source code locations in order\n-//! to be useful. This functionality is also handled in this module. The\n-//! following functions allow to control source mappings:\n-//!\n-//! + set_source_location()\n-//! + clear_source_location()\n-//! + start_emitting_source_locations()\n-//!\n-//! `set_source_location()` allows to set the current source location. All IR\n-//! instructions created after a call to this function will be linked to the\n-//! given source location, until another location is specified with\n-//! `set_source_location()` or the source location is cleared with\n-//! `clear_source_location()`. In the later case, subsequent IR instruction\n-//! will not be linked to any source location. As you can see, this is a\n-//! stateful API (mimicking the one in LLVM), so be careful with source\n-//! locations set by previous calls. It's probably best to not rely on any\n-//! specific state being present at a given point in code.\n-//!\n-//! One topic that deserves some extra attention is *function prologues*. At\n-//! the beginning of a function's machine code there are typically a few\n-//! instructions for loading argument values into allocas and checking if\n-//! there's enough stack space for the function to execute. This *prologue* is\n-//! not visible in the source code and LLVM puts a special PROLOGUE END marker\n-//! into the line table at the first non-prologue instruction of the function.\n-//! In order to find out where the prologue ends, LLVM looks for the first\n-//! instruction in the function body that is linked to a source location. So,\n-//! when generating prologue instructions we have to make sure that we don't\n-//! emit source location information until the 'real' function body begins. For\n-//! this reason, source location emission is disabled by default for any new\n-//! function being codegened and is only activated after a call to the third\n-//! function from the list above, `start_emitting_source_locations()`. This\n-//! function should be called right before regularly starting to codegen the\n-//! top-level block of the given function.\n-//!\n-//! There is one exception to the above rule: `llvm.dbg.declare` instruction\n-//! must be linked to the source location of the variable being declared. For\n-//! function parameters these `llvm.dbg.declare` instructions typically occur\n-//! in the middle of the prologue, however, they are ignored by LLVM's prologue\n-//! detection. The `create_argument_metadata()` and related functions take care\n-//! of linking the `llvm.dbg.declare` instructions to the correct source\n-//! locations even while source location emission is still disabled, so there\n-//! is no need to do anything special with source location handling here.\n-//!\n-//! ## Unique Type Identification\n-//!\n-//! In order for link-time optimization to work properly, LLVM needs a unique\n-//! type identifier that tells it across compilation units which types are the\n-//! same as others. This type identifier is created by\n-//! `TypeMap::get_unique_type_id_of_type()` using the following algorithm:\n-//!\n-//! (1) Primitive types have their name as ID\n-//! (2) Structs, enums and traits have a multipart identifier\n-//!\n-//!     (1) The first part is the SVH (strict version hash) of the crate they\n-//!          were originally defined in\n-//!\n-//!     (2) The second part is the ast::NodeId of the definition in their\n-//!          original crate\n-//!\n-//!     (3) The final part is a concatenation of the type IDs of their concrete\n-//!          type arguments if they are generic types.\n-//!\n-//! (3) Tuple-, pointer and function types are structurally identified, which\n-//!     means that they are equivalent if their component types are equivalent\n-//!     (i.e., (i32, i32) is the same regardless in which crate it is used).\n-//!\n-//! This algorithm also provides a stable ID for types that are defined in one\n-//! crate but instantiated from metadata within another crate. We just have to\n-//! take care to always map crate and `NodeId`s back to the original crate\n-//! context.\n-//!\n-//! As a side-effect these unique type IDs also help to solve a problem arising\n-//! from lifetime parameters. Since lifetime parameters are completely omitted\n-//! in debuginfo, more than one `Ty` instance may map to the same debuginfo\n-//! type metadata, that is, some struct `Struct<'a>` may have N instantiations\n-//! with different concrete substitutions for `'a`, and thus there will be N\n-//! `Ty` instances for the type `Struct<'a>` even though it is not generic\n-//! otherwise. Unfortunately this means that we cannot use `ty::type_id()` as\n-//! cheap identifier for type metadata -- we have done this in the past, but it\n-//! led to unnecessary metadata duplication in the best case and LLVM\n-//! assertions in the worst. However, the unique type ID as described above\n-//! *can* be used as identifier. Since it is comparatively expensive to\n-//! construct, though, `ty::type_id()` is still used additionally as an\n-//! optimization for cases where the exact same type has been seen before\n-//! (which is most of the time)."}, {"sha": "abb87cb36568eb01352c701ad0d82c809381a31b", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a2e9374048f1c04f025469dde88e13a5037d8db7/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2e9374048f1c04f025469dde88e13a5037d8db7/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmod.rs?ref=a2e9374048f1c04f025469dde88e13a5037d8db7", "patch": "@@ -1,5 +1,4 @@\n-// See doc.rs for documentation.\n-mod doc;\n+#![doc = include_str!(\"doc.md\")]\n \n use rustc_codegen_ssa::mir::debuginfo::VariableKind::*;\n "}, {"sha": "146c08337fc77998673ffe3843387c9c39e21171", "filename": "compiler/rustc_codegen_llvm/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a2e9374048f1c04f025469dde88e13a5037d8db7/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2e9374048f1c04f025469dde88e13a5037d8db7/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs?ref=a2e9374048f1c04f025469dde88e13a5037d8db7", "patch": "@@ -8,6 +8,7 @@\n #![feature(bool_to_option)]\n #![feature(const_cstr_unchecked)]\n #![feature(crate_visibility_modifier)]\n+#![feature(extended_key_value_attributes)]\n #![feature(extern_types)]\n #![feature(in_band_lifetimes)]\n #![feature(nll)]"}]}