{"sha": "d08d32fa5d47be5563247a706a8dd37e7aa15b3d", "node_id": "C_kwDOAAsO6NoAKGQwOGQzMmZhNWQ0N2JlNTU2MzI0N2E3MDZhOGRkMzdlN2FhMTViM2Q", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2022-03-15T18:11:05Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2022-03-15T18:25:42Z"}, "message": "Trim down alloc_system.rs\n\nIt is used only by a single test. Also remove the dependency on the libc\ncrate.", "tree": {"sha": "49eaf9c287a184342fa0f2ef37c624d7d1297c3d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/49eaf9c287a184342fa0f2ef37c624d7d1297c3d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d08d32fa5d47be5563247a706a8dd37e7aa15b3d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d08d32fa5d47be5563247a706a8dd37e7aa15b3d", "html_url": "https://github.com/rust-lang/rust/commit/d08d32fa5d47be5563247a706a8dd37e7aa15b3d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d08d32fa5d47be5563247a706a8dd37e7aa15b3d/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5c666ea7ec1de153297a9325a5c36f132087b6b7", "url": "https://api.github.com/repos/rust-lang/rust/commits/5c666ea7ec1de153297a9325a5c36f132087b6b7", "html_url": "https://github.com/rust-lang/rust/commit/5c666ea7ec1de153297a9325a5c36f132087b6b7"}], "stats": {"total": 142, "additions": 30, "deletions": 112}, "files": [{"sha": "cf95c89bc3156b24b36d2bc0728a90f6e36fbd89", "filename": "example/alloc_system.rs", "status": "modified", "additions": 30, "deletions": 112, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/d08d32fa5d47be5563247a706a8dd37e7aa15b3d/example%2Falloc_system.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08d32fa5d47be5563247a706a8dd37e7aa15b3d/example%2Falloc_system.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/example%2Falloc_system.rs?ref=d08d32fa5d47be5563247a706a8dd37e7aa15b3d", "patch": "@@ -8,33 +8,21 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n #![no_std]\n-#![feature(allocator_api, rustc_private)]\n-#![cfg_attr(any(unix, target_os = \"redox\"), feature(libc))]\n-\n-// The minimum alignment guaranteed by the architecture. This value is used to\n-// add fast paths for low alignment values.\n-#[cfg(all(any(target_arch = \"x86\",\n-              target_arch = \"arm\",\n-              target_arch = \"mips\",\n-              target_arch = \"powerpc\",\n-              target_arch = \"powerpc64\")))]\n-const MIN_ALIGN: usize = 8;\n-#[cfg(all(any(target_arch = \"x86_64\",\n-              target_arch = \"aarch64\",\n-              target_arch = \"mips64\",\n-              target_arch = \"s390x\",\n-              target_arch = \"sparc64\")))]\n-const MIN_ALIGN: usize = 16;\n \n pub struct System;\n+\n #[cfg(any(windows, unix, target_os = \"redox\"))]\n mod realloc_fallback {\n     use core::alloc::{GlobalAlloc, Layout};\n     use core::cmp;\n     use core::ptr;\n     impl super::System {\n-        pub(crate) unsafe fn realloc_fallback(&self, ptr: *mut u8, old_layout: Layout,\n-                                              new_size: usize) -> *mut u8 {\n+        pub(crate) unsafe fn realloc_fallback(\n+            &self,\n+            ptr: *mut u8,\n+            old_layout: Layout,\n+            new_size: usize,\n+        ) -> *mut u8 {\n             // Docs for GlobalAlloc::realloc require this to be valid:\n             let new_layout = Layout::from_size_align_unchecked(new_size, old_layout.align());\n             let new_ptr = GlobalAlloc::alloc(self, new_layout);\n@@ -49,97 +37,47 @@ mod realloc_fallback {\n }\n #[cfg(any(unix, target_os = \"redox\"))]\n mod platform {\n-    extern crate libc;\n+    use core::alloc::{GlobalAlloc, Layout};\n+    use core::ffi::c_void;\n     use core::ptr;\n-    use MIN_ALIGN;\n     use System;\n-    use core::alloc::{GlobalAlloc, Layout};\n+    extern \"C\" {\n+        fn posix_memalign(memptr: *mut *mut c_void, align: usize, size: usize) -> i32;\n+        fn free(p: *mut c_void);\n+    }\n     unsafe impl GlobalAlloc for System {\n         #[inline]\n         unsafe fn alloc(&self, layout: Layout) -> *mut u8 {\n-            if layout.align() <= MIN_ALIGN && layout.align() <= layout.size() {\n-                libc::malloc(layout.size()) as *mut u8\n-            } else {\n-                #[cfg(target_os = \"macos\")]\n-                {\n-                    if layout.align() > (1 << 31) {\n-                        return ptr::null_mut()\n-                    }\n-                }\n-                aligned_malloc(&layout)\n-            }\n+            aligned_malloc(&layout)\n         }\n         #[inline]\n         unsafe fn alloc_zeroed(&self, layout: Layout) -> *mut u8 {\n-            if layout.align() <= MIN_ALIGN && layout.align() <= layout.size() {\n-                libc::calloc(layout.size(), 1) as *mut u8\n-            } else {\n-                let ptr = self.alloc(layout.clone());\n-                if !ptr.is_null() {\n-                    ptr::write_bytes(ptr, 0, layout.size());\n-                }\n-                ptr\n+            let ptr = self.alloc(layout.clone());\n+            if !ptr.is_null() {\n+                ptr::write_bytes(ptr, 0, layout.size());\n             }\n+            ptr\n         }\n         #[inline]\n         unsafe fn dealloc(&self, ptr: *mut u8, _layout: Layout) {\n-            libc::free(ptr as *mut libc::c_void)\n+            free(ptr as *mut c_void)\n         }\n         #[inline]\n         unsafe fn realloc(&self, ptr: *mut u8, layout: Layout, new_size: usize) -> *mut u8 {\n-            if layout.align() <= MIN_ALIGN && layout.align() <= new_size {\n-                libc::realloc(ptr as *mut libc::c_void, new_size) as *mut u8\n-            } else {\n-                self.realloc_fallback(ptr, layout, new_size)\n-            }\n+            self.realloc_fallback(ptr, layout, new_size)\n         }\n     }\n-    #[cfg(any(target_os = \"android\",\n-              target_os = \"hermit\",\n-              target_os = \"redox\",\n-              target_os = \"solaris\"))]\n-    #[inline]\n-    unsafe fn aligned_malloc(layout: &Layout) -> *mut u8 {\n-        // On android we currently target API level 9 which unfortunately\n-        // doesn't have the `posix_memalign` API used below. Instead we use\n-        // `memalign`, but this unfortunately has the property on some systems\n-        // where the memory returned cannot be deallocated by `free`!\n-        //\n-        // Upon closer inspection, however, this appears to work just fine with\n-        // Android, so for this platform we should be fine to call `memalign`\n-        // (which is present in API level 9). Some helpful references could\n-        // possibly be chromium using memalign [1], attempts at documenting that\n-        // memalign + free is ok [2] [3], or the current source of chromium\n-        // which still uses memalign on android [4].\n-        //\n-        // [1]: https://codereview.chromium.org/10796020/\n-        // [2]: https://code.google.com/p/android/issues/detail?id=35391\n-        // [3]: https://bugs.chromium.org/p/chromium/issues/detail?id=138579\n-        // [4]: https://chromium.googlesource.com/chromium/src/base/+/master/\n-        //                                       /memory/aligned_memory.cc\n-        libc::memalign(layout.align(), layout.size()) as *mut u8\n-    }\n-    #[cfg(not(any(target_os = \"android\",\n-                  target_os = \"hermit\",\n-                  target_os = \"redox\",\n-                  target_os = \"solaris\")))]\n-    #[inline]\n     unsafe fn aligned_malloc(layout: &Layout) -> *mut u8 {\n         let mut out = ptr::null_mut();\n-        let ret = libc::posix_memalign(&mut out, layout.align(), layout.size());\n-        if ret != 0 {\n-            ptr::null_mut()\n-        } else {\n-            out as *mut u8\n-        }\n+        let ret = posix_memalign(&mut out, layout.align(), layout.size());\n+        if ret != 0 { ptr::null_mut() } else { out as *mut u8 }\n     }\n }\n #[cfg(windows)]\n #[allow(nonstandard_style)]\n mod platform {\n-    use MIN_ALIGN;\n-    use System;\n     use core::alloc::{GlobalAlloc, Layout};\n+    use System;\n     type LPVOID = *mut u8;\n     type HANDLE = LPVOID;\n     type SIZE_T = usize;\n@@ -165,18 +103,9 @@ mod platform {\n     }\n     #[inline]\n     unsafe fn allocate_with_flags(layout: Layout, flags: DWORD) -> *mut u8 {\n-        let ptr = if layout.align() <= MIN_ALIGN {\n-            HeapAlloc(GetProcessHeap(), flags, layout.size())\n-        } else {\n-            let size = layout.size() + layout.align();\n-            let ptr = HeapAlloc(GetProcessHeap(), flags, size);\n-            if ptr.is_null() {\n-                ptr\n-            } else {\n-                align_ptr(ptr, layout.align())\n-            }\n-        };\n-        ptr as *mut u8\n+        let size = layout.size() + layout.align();\n+        let ptr = HeapAlloc(GetProcessHeap(), flags, size);\n+        (if ptr.is_null() { ptr } else { align_ptr(ptr, layout.align()) }) as *mut u8\n     }\n     unsafe impl GlobalAlloc for System {\n         #[inline]\n@@ -189,24 +118,13 @@ mod platform {\n         }\n         #[inline]\n         unsafe fn dealloc(&self, ptr: *mut u8, layout: Layout) {\n-            if layout.align() <= MIN_ALIGN {\n-                let err = HeapFree(GetProcessHeap(), 0, ptr as LPVOID);\n-                debug_assert!(err != 0, \"Failed to free heap memory: {}\",\n-                              GetLastError());\n-            } else {\n-                let header = get_header(ptr);\n-                let err = HeapFree(GetProcessHeap(), 0, header.0 as LPVOID);\n-                debug_assert!(err != 0, \"Failed to free heap memory: {}\",\n-                              GetLastError());\n-            }\n+            let header = get_header(ptr);\n+            let err = HeapFree(GetProcessHeap(), 0, header.0 as LPVOID);\n+            debug_assert!(err != 0, \"Failed to free heap memory: {}\", GetLastError());\n         }\n         #[inline]\n         unsafe fn realloc(&self, ptr: *mut u8, layout: Layout, new_size: usize) -> *mut u8 {\n-            if layout.align() <= MIN_ALIGN {\n-                HeapReAlloc(GetProcessHeap(), 0, ptr as LPVOID, new_size) as *mut u8\n-            } else {\n-                self.realloc_fallback(ptr, layout, new_size)\n-            }\n+            self.realloc_fallback(ptr, layout, new_size)\n         }\n     }\n }"}]}