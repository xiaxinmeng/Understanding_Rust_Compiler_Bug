{"sha": "d19a359444295bab01de7ff44a9d72302e573bc9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQxOWEzNTk0NDQyOTViYWIwMWRlN2ZmNDRhOWQ3MjMwMmU1NzNiYzk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-08-10T06:14:13Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-08-10T06:14:13Z"}, "message": "Auto merge of #63428 - Centril:rollup-c2ru1z1, r=Centril\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #63056 (Give built-in macros stable addresses in the standard library)\n - #63337 (Tweak mismatched types error)\n - #63350 (Use associated_type_bounds where applicable - closes #61738)\n - #63394 (Add test for issue 36804)\n - #63399 (More explicit diagnostic when using a `vec![]` in a pattern)\n - #63419 (check against more collisions for TypeId of fn pointer)\n - #63423 (Mention that tuple structs are private if any of their fields are)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "c3765064c4bae63df68e165a6ca406e6a2eedd85", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c3765064c4bae63df68e165a6ca406e6a2eedd85"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d19a359444295bab01de7ff44a9d72302e573bc9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d19a359444295bab01de7ff44a9d72302e573bc9", "html_url": "https://github.com/rust-lang/rust/commit/d19a359444295bab01de7ff44a9d72302e573bc9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d19a359444295bab01de7ff44a9d72302e573bc9/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "be8bbb06976c8065425b18e9cbe24a6d1d4e7515", "url": "https://api.github.com/repos/rust-lang/rust/commits/be8bbb06976c8065425b18e9cbe24a6d1d4e7515", "html_url": "https://github.com/rust-lang/rust/commit/be8bbb06976c8065425b18e9cbe24a6d1d4e7515"}, {"sha": "019f6fed2855ff67adcf74176c16817c279e89de", "url": "https://api.github.com/repos/rust-lang/rust/commits/019f6fed2855ff67adcf74176c16817c279e89de", "html_url": "https://github.com/rust-lang/rust/commit/019f6fed2855ff67adcf74176c16817c279e89de"}], "stats": {"total": 1919, "additions": 1507, "deletions": 412}, "files": [{"sha": "a9c5bce4c25fc212a1b821b3b56bec87c736373a", "filename": "src/liballoc/borrow.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Fliballoc%2Fborrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Fliballoc%2Fborrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fborrow.rs?ref=d19a359444295bab01de7ff44a9d72302e573bc9", "patch": "@@ -329,8 +329,8 @@ impl<'a, B: ?Sized> PartialOrd for Cow<'a, B>\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<B: ?Sized> fmt::Debug for Cow<'_, B>\n-    where B: fmt::Debug + ToOwned,\n-          <B as ToOwned>::Owned: fmt::Debug\n+where\n+    B: fmt::Debug + ToOwned<Owned: fmt::Debug>,\n {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match *self {\n@@ -342,8 +342,8 @@ impl<B: ?Sized> fmt::Debug for Cow<'_, B>\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<B: ?Sized> fmt::Display for Cow<'_, B>\n-    where B: fmt::Display + ToOwned,\n-          <B as ToOwned>::Owned: fmt::Display\n+where\n+    B: fmt::Display + ToOwned<Owned: fmt::Display>,\n {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match *self {\n@@ -355,8 +355,8 @@ impl<B: ?Sized> fmt::Display for Cow<'_, B>\n \n #[stable(feature = \"default\", since = \"1.11.0\")]\n impl<B: ?Sized> Default for Cow<'_, B>\n-    where B: ToOwned,\n-          <B as ToOwned>::Owned: Default\n+where\n+    B: ToOwned<Owned: Default>,\n {\n     /// Creates an owned Cow<'a, B> with the default value for the contained owned value.\n     fn default() -> Self {"}, {"sha": "a1936b36ac6bf9b4f4c72d8b4dde734f81f09dfa", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=d19a359444295bab01de7ff44a9d72302e573bc9", "patch": "@@ -122,6 +122,7 @@\n #![feature(alloc_layout_extra)]\n #![feature(try_trait)]\n #![feature(mem_take)]\n+#![feature(associated_type_bounds)]\n \n // Allow testing this library\n "}, {"sha": "5723a30c0f34f62ec8829fde287e5877694ede5a", "filename": "src/liballoc/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Fliballoc%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Fliballoc%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Flib.rs?ref=d19a359444295bab01de7ff44a9d72302e573bc9", "patch": "@@ -8,6 +8,7 @@\n #![feature(trusted_len)]\n #![feature(try_reserve)]\n #![feature(unboxed_closures)]\n+#![feature(associated_type_bounds)]\n \n use std::hash::{Hash, Hasher};\n use std::collections::hash_map::DefaultHasher;"}, {"sha": "4332b2e90fdaf0493deb3f1489137632fa2ede6e", "filename": "src/liballoc/tests/str.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Fliballoc%2Ftests%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Fliballoc%2Ftests%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fstr.rs?ref=d19a359444295bab01de7ff44a9d72302e573bc9", "patch": "@@ -1638,10 +1638,12 @@ mod pattern {\n         }\n     }\n \n-    fn cmp_search_to_vec<'a, P: Pattern<'a>>(rev: bool, pat: P, haystack: &'a str,\n-                                             right: Vec<SearchStep>)\n-    where P::Searcher: ReverseSearcher<'a>\n-    {\n+    fn cmp_search_to_vec<'a>(\n+        rev: bool,\n+        pat: impl Pattern<'a, Searcher: ReverseSearcher<'a>>,\n+        haystack: &'a str,\n+        right: Vec<SearchStep>\n+    ) {\n         let mut searcher = pat.into_searcher(haystack);\n         let mut v = vec![];\n         loop {"}, {"sha": "0c99356390bdae251df33ee78f031d06e332c4b6", "filename": "src/libcore/clone.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Flibcore%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Flibcore%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fclone.rs?ref=d19a359444295bab01de7ff44a9d72302e573bc9", "patch": "@@ -133,6 +133,14 @@ pub trait Clone : Sized {\n     }\n }\n \n+/// Derive macro generating an impl of the trait `Clone`.\n+#[cfg(not(bootstrap))]\n+#[rustc_builtin_macro]\n+#[rustc_macro_transparency = \"semitransparent\"]\n+#[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n+#[allow_internal_unstable(core_intrinsics, derive_clone_copy)]\n+pub macro Clone($item:item) { /* compiler built-in */ }\n+\n // FIXME(aburka): these structs are used solely by #[derive] to\n // assert that every component of a type implements Clone or Copy.\n //"}, {"sha": "38a52d97da21286440ee1d8e396f814ecda95de2", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=d19a359444295bab01de7ff44a9d72302e573bc9", "patch": "@@ -200,6 +200,14 @@ pub trait PartialEq<Rhs: ?Sized = Self> {\n     fn ne(&self, other: &Rhs) -> bool { !self.eq(other) }\n }\n \n+/// Derive macro generating an impl of the trait `PartialEq`.\n+#[cfg(not(bootstrap))]\n+#[rustc_builtin_macro]\n+#[rustc_macro_transparency = \"semitransparent\"]\n+#[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n+#[allow_internal_unstable(core_intrinsics)]\n+pub macro PartialEq($item:item) { /* compiler built-in */ }\n+\n /// Trait for equality comparisons which are [equivalence relations](\n /// https://en.wikipedia.org/wiki/Equivalence_relation).\n ///\n@@ -256,6 +264,14 @@ pub trait Eq: PartialEq<Self> {\n     fn assert_receiver_is_total_eq(&self) {}\n }\n \n+/// Derive macro generating an impl of the trait `Eq`.\n+#[cfg(not(bootstrap))]\n+#[rustc_builtin_macro]\n+#[rustc_macro_transparency = \"semitransparent\"]\n+#[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n+#[allow_internal_unstable(core_intrinsics, derive_eq)]\n+pub macro Eq($item:item) { /* compiler built-in */ }\n+\n // FIXME: this struct is used solely by #[derive] to\n // assert that every component of a type implements Eq.\n //\n@@ -600,6 +616,14 @@ pub trait Ord: Eq + PartialOrd<Self> {\n     }\n }\n \n+/// Derive macro generating an impl of the trait `Ord`.\n+#[cfg(not(bootstrap))]\n+#[rustc_builtin_macro]\n+#[rustc_macro_transparency = \"semitransparent\"]\n+#[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n+#[allow_internal_unstable(core_intrinsics)]\n+pub macro Ord($item:item) { /* compiler built-in */ }\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Eq for Ordering {}\n \n@@ -842,6 +866,14 @@ pub trait PartialOrd<Rhs: ?Sized = Self>: PartialEq<Rhs> {\n     }\n }\n \n+/// Derive macro generating an impl of the trait `PartialOrd`.\n+#[cfg(not(bootstrap))]\n+#[rustc_builtin_macro]\n+#[rustc_macro_transparency = \"semitransparent\"]\n+#[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n+#[allow_internal_unstable(core_intrinsics)]\n+pub macro PartialOrd($item:item) { /* compiler built-in */ }\n+\n /// Compares and returns the minimum of two values.\n ///\n /// Returns the first argument if the comparison determines them to be equal."}, {"sha": "641621f492baf33bcc9cef66454ff352f065dca1", "filename": "src/libcore/convert.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Flibcore%2Fconvert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Flibcore%2Fconvert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fconvert.rs?ref=d19a359444295bab01de7ff44a9d72302e573bc9", "patch": "@@ -513,7 +513,7 @@ impl<T: ?Sized, U: ?Sized> AsRef<U> for &mut T where T: AsRef<U>\n \n // FIXME (#45742): replace the above impls for &/&mut with the following more general one:\n // // As lifts over Deref\n-// impl<D: ?Sized + Deref, U: ?Sized> AsRef<U> for D where D::Target: AsRef<U> {\n+// impl<D: ?Sized + Deref<Target: AsRef<U>>, U: ?Sized> AsRef<U> for D {\n //     fn as_ref(&self) -> &U {\n //         self.deref().as_ref()\n //     }\n@@ -530,7 +530,7 @@ impl<T: ?Sized, U: ?Sized> AsMut<U> for &mut T where T: AsMut<U>\n \n // FIXME (#45742): replace the above impl for &mut with the following more general one:\n // // AsMut lifts over DerefMut\n-// impl<D: ?Sized + Deref, U: ?Sized> AsMut<U> for D where D::Target: AsMut<U> {\n+// impl<D: ?Sized + Deref<Target: AsMut<U>>, U: ?Sized> AsMut<U> for D {\n //     fn as_mut(&mut self) -> &mut U {\n //         self.deref_mut().as_mut()\n //     }"}, {"sha": "8d95e9de15849347f9d7fffe901afaf70a86187e", "filename": "src/libcore/default.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Flibcore%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Flibcore%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fdefault.rs?ref=d19a359444295bab01de7ff44a9d72302e573bc9", "patch": "@@ -115,6 +115,14 @@ pub trait Default: Sized {\n     fn default() -> Self;\n }\n \n+/// Derive macro generating an impl of the trait `Default`.\n+#[cfg(not(bootstrap))]\n+#[rustc_builtin_macro]\n+#[rustc_macro_transparency = \"semitransparent\"]\n+#[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n+#[allow_internal_unstable(core_intrinsics)]\n+pub macro Default($item:item) { /* compiler built-in */ }\n+\n macro_rules! default_impl {\n     ($t:ty, $v:expr, $doc:tt) => {\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "0ea01d4b84a2c8d922ee4a6ae636224387a206f4", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=d19a359444295bab01de7ff44a9d72302e573bc9", "patch": "@@ -545,6 +545,21 @@ pub trait Debug {\n     fn fmt(&self, f: &mut Formatter<'_>) -> Result;\n }\n \n+// Separate module to reexport the macro `Debug` from prelude without the trait `Debug`.\n+#[cfg(not(bootstrap))]\n+pub(crate) mod macros {\n+    /// Derive macro generating an impl of the trait `Debug`.\n+    #[rustc_builtin_macro]\n+    #[rustc_macro_transparency = \"semitransparent\"]\n+    #[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n+    #[allow_internal_unstable(core_intrinsics)]\n+    pub macro Debug($item:item) { /* compiler built-in */ }\n+}\n+#[cfg(not(bootstrap))]\n+#[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n+#[doc(inline)]\n+pub use macros::Debug;\n+\n /// Format trait for an empty format, `{}`.\n ///\n /// `Display` is similar to [`Debug`][debug], but `Display` is for user-facing"}, {"sha": "f14ed38b9b0f27c4c5a39bd8450b466a4d07cc3d", "filename": "src/libcore/future/future.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Flibcore%2Ffuture%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Flibcore%2Ffuture%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffuture%2Ffuture.rs?ref=d19a359444295bab01de7ff44a9d72302e573bc9", "patch": "@@ -111,8 +111,7 @@ impl<F: ?Sized + Future + Unpin> Future for &mut F {\n #[stable(feature = \"futures_api\", since = \"1.36.0\")]\n impl<P> Future for Pin<P>\n where\n-    P: Unpin + ops::DerefMut,\n-    P::Target: Future,\n+    P: Unpin + ops::DerefMut<Target: Future>,\n {\n     type Output = <<P as ops::Deref>::Target as Future>::Output;\n "}, {"sha": "c4cbf40a93a151a6ff21108043c583d1d0603c20", "filename": "src/libcore/hash/mod.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Flibcore%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Flibcore%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fmod.rs?ref=d19a359444295bab01de7ff44a9d72302e573bc9", "patch": "@@ -198,6 +198,21 @@ pub trait Hash {\n     }\n }\n \n+// Separate module to reexport the macro `Hash` from prelude without the trait `Hash`.\n+#[cfg(not(bootstrap))]\n+pub(crate) mod macros {\n+    /// Derive macro generating an impl of the trait `Hash`.\n+    #[rustc_builtin_macro]\n+    #[rustc_macro_transparency = \"semitransparent\"]\n+    #[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n+    #[allow_internal_unstable(core_intrinsics)]\n+    pub macro Hash($item:item) { /* compiler built-in */ }\n+}\n+#[cfg(not(bootstrap))]\n+#[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n+#[doc(inline)]\n+pub use macros::Hash;\n+\n /// A trait for hashing an arbitrary stream of bytes.\n ///\n /// Instances of `Hasher` usually represent state that is changed while hashing"}, {"sha": "d8d41a2a31ef6e0b5904d6ce8e6d0625257461f5", "filename": "src/libcore/iter/adapters/flatten.rs", "status": "modified", "additions": 37, "deletions": 24, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Flibcore%2Fiter%2Fadapters%2Fflatten.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Flibcore%2Fiter%2Fadapters%2Fflatten.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fadapters%2Fflatten.rs?ref=d19a359444295bab01de7ff44a9d72302e573bc9", "patch": "@@ -24,15 +24,17 @@ impl<I: Iterator, U: IntoIterator, F: FnMut(I::Item) -> U> FlatMap<I, U, F> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I: Clone, U: Clone + IntoIterator, F: Clone> Clone for FlatMap<I, U, F>\n-    where <U as IntoIterator>::IntoIter: Clone\n+impl<I: Clone, U, F: Clone> Clone for FlatMap<I, U, F>\n+where\n+    U: Clone + IntoIterator<IntoIter: Clone>,\n {\n     fn clone(&self) -> Self { FlatMap { inner: self.inner.clone() } }\n }\n \n #[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n-impl<I: fmt::Debug, U: IntoIterator, F> fmt::Debug for FlatMap<I, U, F>\n-    where U::IntoIter: fmt::Debug\n+impl<I: fmt::Debug, U, F> fmt::Debug for FlatMap<I, U, F>\n+where\n+    U: IntoIterator<IntoIter: fmt::Debug>,\n {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         f.debug_struct(\"FlatMap\").field(\"inner\", &self.inner).finish()\n@@ -68,9 +70,10 @@ impl<I: Iterator, U: IntoIterator, F> Iterator for FlatMap<I, U, F>\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<I: DoubleEndedIterator, U, F> DoubleEndedIterator for FlatMap<I, U, F>\n-    where F: FnMut(I::Item) -> U,\n-          U: IntoIterator,\n-          U::IntoIter: DoubleEndedIterator\n+where\n+    F: FnMut(I::Item) -> U,\n+    U: IntoIterator,\n+    U::IntoIter: DoubleEndedIterator,\n {\n     #[inline]\n     fn next_back(&mut self) -> Option<U::Item> { self.inner.next_back() }\n@@ -105,20 +108,23 @@ impl<I, U, F> FusedIterator for FlatMap<I, U, F>\n #[must_use = \"iterators are lazy and do nothing unless consumed\"]\n #[stable(feature = \"iterator_flatten\", since = \"1.29.0\")]\n pub struct Flatten<I: Iterator>\n-where I::Item: IntoIterator {\n+where\n+    I::Item: IntoIterator,\n+{\n     inner: FlattenCompat<I, <I::Item as IntoIterator>::IntoIter>,\n }\n-impl<I: Iterator> Flatten<I>\n-where I::Item: IntoIterator {\n+\n+impl<I: Iterator<Item: IntoIterator>> Flatten<I> {\n     pub(in super::super) fn new(iter: I) -> Flatten<I> {\n         Flatten { inner: FlattenCompat::new(iter) }\n     }\n }\n \n #[stable(feature = \"iterator_flatten\", since = \"1.29.0\")]\n impl<I, U> fmt::Debug for Flatten<I>\n-    where I: Iterator + fmt::Debug, U: Iterator + fmt::Debug,\n-          I::Item: IntoIterator<IntoIter = U, Item = U::Item>,\n+where\n+    I: fmt::Debug + Iterator<Item: IntoIterator<IntoIter = U, Item = U::Item>>,\n+    U: fmt::Debug + Iterator,\n {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         f.debug_struct(\"Flatten\").field(\"inner\", &self.inner).finish()\n@@ -127,16 +133,18 @@ impl<I, U> fmt::Debug for Flatten<I>\n \n #[stable(feature = \"iterator_flatten\", since = \"1.29.0\")]\n impl<I, U> Clone for Flatten<I>\n-    where I: Iterator + Clone, U: Iterator + Clone,\n-          I::Item: IntoIterator<IntoIter = U, Item = U::Item>,\n+where\n+    I: Clone + Iterator<Item: IntoIterator<IntoIter = U, Item = U::Item>>,\n+    U: Clone + Iterator,\n {\n     fn clone(&self) -> Self { Flatten { inner: self.inner.clone() } }\n }\n \n #[stable(feature = \"iterator_flatten\", since = \"1.29.0\")]\n impl<I, U> Iterator for Flatten<I>\n-    where I: Iterator, U: Iterator,\n-          I::Item: IntoIterator<IntoIter = U, Item = U::Item>\n+where\n+    I: Iterator<Item: IntoIterator<IntoIter = U, Item = U::Item>>,\n+    U: Iterator,\n {\n     type Item = U::Item;\n \n@@ -163,8 +171,9 @@ impl<I, U> Iterator for Flatten<I>\n \n #[stable(feature = \"iterator_flatten\", since = \"1.29.0\")]\n impl<I, U> DoubleEndedIterator for Flatten<I>\n-    where I: DoubleEndedIterator, U: DoubleEndedIterator,\n-          I::Item: IntoIterator<IntoIter = U, Item = U::Item>\n+where\n+    I: DoubleEndedIterator<Item: IntoIterator<IntoIter = U, Item = U::Item>>,\n+    U: DoubleEndedIterator,\n {\n     #[inline]\n     fn next_back(&mut self) -> Option<U::Item> { self.inner.next_back() }\n@@ -186,8 +195,10 @@ impl<I, U> DoubleEndedIterator for Flatten<I>\n \n #[stable(feature = \"iterator_flatten\", since = \"1.29.0\")]\n impl<I, U> FusedIterator for Flatten<I>\n-    where I: FusedIterator, U: Iterator,\n-          I::Item: IntoIterator<IntoIter = U, Item = U::Item> {}\n+where\n+    I: FusedIterator<Item: IntoIterator<IntoIter = U, Item = U::Item>>,\n+    U: Iterator,\n+{}\n \n /// Real logic of both `Flatten` and `FlatMap` which simply delegate to\n /// this type.\n@@ -205,8 +216,9 @@ impl<I, U> FlattenCompat<I, U> {\n }\n \n impl<I, U> Iterator for FlattenCompat<I, U>\n-    where I: Iterator, U: Iterator,\n-          I::Item: IntoIterator<IntoIter = U, Item = U::Item>\n+where\n+    I: Iterator<Item: IntoIterator<IntoIter = U, Item = U::Item>>,\n+    U: Iterator,\n {\n     type Item = U::Item;\n \n@@ -274,8 +286,9 @@ impl<I, U> Iterator for FlattenCompat<I, U>\n }\n \n impl<I, U> DoubleEndedIterator for FlattenCompat<I, U>\n-    where I: DoubleEndedIterator, U: DoubleEndedIterator,\n-          I::Item: IntoIterator<IntoIter = U, Item = U::Item>\n+where\n+    I: DoubleEndedIterator<Item: IntoIterator<IntoIter = U, Item = U::Item>>,\n+    U: DoubleEndedIterator,\n {\n     #[inline]\n     fn next_back(&mut self) -> Option<U::Item> {"}, {"sha": "25439136b853839d83d4cf9df900b21676a9b4af", "filename": "src/libcore/iter/traits/collect.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Flibcore%2Fiter%2Ftraits%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Flibcore%2Fiter%2Ftraits%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits%2Fcollect.rs?ref=d19a359444295bab01de7ff44a9d72302e573bc9", "patch": "@@ -195,8 +195,9 @@ pub trait FromIterator<A>: Sized {\n ///\n /// ```rust\n /// fn collect_as_strings<T>(collection: T) -> Vec<String>\n-///     where T: IntoIterator,\n-///           T::Item: std::fmt::Debug,\n+/// where\n+///     T: IntoIterator,\n+///     T::Item: std::fmt::Debug,\n /// {\n ///     collection\n ///         .into_iter()"}, {"sha": "678ff7687921b804e1c334635f43b1e41c00ac80", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=d19a359444295bab01de7ff44a9d72302e573bc9", "patch": "@@ -132,6 +132,7 @@\n #![feature(maybe_uninit_slice, maybe_uninit_array)]\n #![feature(external_doc)]\n #![feature(mem_take)]\n+#![feature(associated_type_bounds)]\n \n #[prelude_import]\n #[allow(unused)]"}, {"sha": "f9dc53874acb1a415445ddbf8fb46d3be57acce9", "filename": "src/libcore/macros.rs", "status": "modified", "additions": 63, "deletions": 122, "changes": 185, "blob_url": "https://github.com/rust-lang/rust/blob/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=d19a359444295bab01de7ff44a9d72302e573bc9", "patch": "@@ -714,9 +714,9 @@ pub(crate) mod builtin {\n     /// [`panic!`]: ../std/macro.panic.html\n     #[stable(feature = \"compile_error_macro\", since = \"1.20.0\")]\n     #[rustc_builtin_macro]\n-    #[rustc_macro_transparency = \"semitransparent\"]\n-    pub macro compile_error {\n-        ($msg:expr) => ({ /* compiler built-in */ }),\n+    #[macro_export]\n+    macro_rules! compile_error {\n+        ($msg:expr) => ({ /* compiler built-in */ });\n         ($msg:expr,) => ({ /* compiler built-in */ })\n     }\n \n@@ -768,8 +768,10 @@ pub(crate) mod builtin {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[allow_internal_unstable(fmt_internals)]\n     #[rustc_builtin_macro]\n-    pub macro format_args {\n-        ($fmt:expr) => ({ /* compiler built-in */ }),\n+    #[macro_export]\n+    #[rustc_macro_transparency = \"opaque\"]\n+    macro_rules! format_args {\n+        ($fmt:expr) => ({ /* compiler built-in */ });\n         ($fmt:expr, $($args:tt)*) => ({ /* compiler built-in */ })\n     }\n \n@@ -779,8 +781,10 @@ pub(crate) mod builtin {\n                          language use and is subject to change\")]\n     #[allow_internal_unstable(fmt_internals)]\n     #[rustc_builtin_macro]\n-    pub macro format_args_nl {\n-        ($fmt:expr) => ({ /* compiler built-in */ }),\n+    #[macro_export]\n+    #[rustc_macro_transparency = \"opaque\"]\n+    macro_rules! format_args_nl {\n+        ($fmt:expr) => ({ /* compiler built-in */ });\n         ($fmt:expr, $($args:tt)*) => ({ /* compiler built-in */ })\n     }\n \n@@ -817,9 +821,9 @@ pub(crate) mod builtin {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[rustc_builtin_macro]\n-    #[rustc_macro_transparency = \"semitransparent\"]\n-    pub macro env {\n-        ($name:expr) => ({ /* compiler built-in */ }),\n+    #[macro_export]\n+    macro_rules! env {\n+        ($name:expr) => ({ /* compiler built-in */ });\n         ($name:expr,) => ({ /* compiler built-in */ })\n     }\n \n@@ -844,9 +848,9 @@ pub(crate) mod builtin {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[rustc_builtin_macro]\n-    #[rustc_macro_transparency = \"semitransparent\"]\n-    pub macro option_env {\n-        ($name:expr) => ({ /* compiler built-in */ }),\n+    #[macro_export]\n+    macro_rules! option_env {\n+        ($name:expr) => ({ /* compiler built-in */ });\n         ($name:expr,) => ({ /* compiler built-in */ })\n     }\n \n@@ -877,9 +881,9 @@ pub(crate) mod builtin {\n     #[unstable(feature = \"concat_idents\", issue = \"29599\",\n                reason = \"`concat_idents` is not stable enough for use and is subject to change\")]\n     #[rustc_builtin_macro]\n-    #[rustc_macro_transparency = \"semitransparent\"]\n-    pub macro concat_idents {\n-        ($($e:ident),+) => ({ /* compiler built-in */ }),\n+    #[macro_export]\n+    macro_rules! concat_idents {\n+        ($($e:ident),+) => ({ /* compiler built-in */ });\n         ($($e:ident,)+) => ({ /* compiler built-in */ })\n     }\n \n@@ -900,9 +904,9 @@ pub(crate) mod builtin {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[rustc_builtin_macro]\n-    #[rustc_macro_transparency = \"semitransparent\"]\n-    pub macro concat {\n-        ($($e:expr),*) => ({ /* compiler built-in */ }),\n+    #[macro_export]\n+    macro_rules! concat {\n+        ($($e:expr),*) => ({ /* compiler built-in */ });\n         ($($e:expr,)*) => ({ /* compiler built-in */ })\n     }\n \n@@ -929,8 +933,8 @@ pub(crate) mod builtin {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[rustc_builtin_macro]\n-    #[rustc_macro_transparency = \"semitransparent\"]\n-    pub macro line() { /* compiler built-in */ }\n+    #[macro_export]\n+    macro_rules! line { () => { /* compiler built-in */ } }\n \n     /// Expands to the column number at which it was invoked.\n     ///\n@@ -955,15 +959,15 @@ pub(crate) mod builtin {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[rustc_builtin_macro]\n-    #[rustc_macro_transparency = \"semitransparent\"]\n-    pub macro column() { /* compiler built-in */ }\n+    #[macro_export]\n+    macro_rules! column { () => { /* compiler built-in */ } }\n \n     /// Same as `column`, but less likely to be shadowed.\n     #[unstable(feature = \"__rust_unstable_column\", issue = \"0\",\n                reason = \"internal implementation detail of the `panic` macro\")]\n     #[rustc_builtin_macro]\n-    #[rustc_macro_transparency = \"semitransparent\"]\n-    pub macro __rust_unstable_column() { /* compiler built-in */ }\n+    #[macro_export]\n+    macro_rules! __rust_unstable_column { () => { /* compiler built-in */ } }\n \n     /// Expands to the file name in which it was invoked.\n     ///\n@@ -987,8 +991,8 @@ pub(crate) mod builtin {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[rustc_builtin_macro]\n-    #[rustc_macro_transparency = \"semitransparent\"]\n-    pub macro file() { /* compiler built-in */ }\n+    #[macro_export]\n+    macro_rules! file { () => { /* compiler built-in */ } }\n \n     /// Stringifies its arguments.\n     ///\n@@ -1007,8 +1011,8 @@ pub(crate) mod builtin {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[rustc_builtin_macro]\n-    #[rustc_macro_transparency = \"semitransparent\"]\n-    pub macro stringify($($t:tt)*) { /* compiler built-in */ }\n+    #[macro_export]\n+    macro_rules! stringify { ($($t:tt)*) => { /* compiler built-in */ } }\n \n     /// Includes a utf8-encoded file as a string.\n     ///\n@@ -1042,9 +1046,9 @@ pub(crate) mod builtin {\n     /// Compiling 'main.rs' and running the resulting binary will print \"adi\u00f3s\".\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[rustc_builtin_macro]\n-    #[rustc_macro_transparency = \"semitransparent\"]\n-    pub macro include_str {\n-        ($file:expr) => ({ /* compiler built-in */ }),\n+    #[macro_export]\n+    macro_rules! include_str {\n+        ($file:expr) => ({ /* compiler built-in */ });\n         ($file:expr,) => ({ /* compiler built-in */ })\n     }\n \n@@ -1080,9 +1084,9 @@ pub(crate) mod builtin {\n     /// Compiling 'main.rs' and running the resulting binary will print \"adi\u00f3s\".\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[rustc_builtin_macro]\n-    #[rustc_macro_transparency = \"semitransparent\"]\n-    pub macro include_bytes {\n-        ($file:expr) => ({ /* compiler built-in */ }),\n+    #[macro_export]\n+    macro_rules! include_bytes {\n+        ($file:expr) => ({ /* compiler built-in */ });\n         ($file:expr,) => ({ /* compiler built-in */ })\n     }\n \n@@ -1105,8 +1109,8 @@ pub(crate) mod builtin {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[rustc_builtin_macro]\n-    #[rustc_macro_transparency = \"semitransparent\"]\n-    pub macro module_path() { /* compiler built-in */ }\n+    #[macro_export]\n+    macro_rules! module_path { () => { /* compiler built-in */ } }\n \n     /// Evaluates boolean combinations of configuration flags at compile-time.\n     ///\n@@ -1130,8 +1134,8 @@ pub(crate) mod builtin {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[rustc_builtin_macro]\n-    #[rustc_macro_transparency = \"semitransparent\"]\n-    pub macro cfg($($cfg:tt)*) { /* compiler built-in */ }\n+    #[macro_export]\n+    macro_rules! cfg { ($($cfg:tt)*) => { /* compiler built-in */ } }\n \n     /// Parses a file as an expression or an item according to the context.\n     ///\n@@ -1174,9 +1178,9 @@ pub(crate) mod builtin {\n     /// \"\ud83d\ude48\ud83d\ude4a\ud83d\ude49\ud83d\ude48\ud83d\ude4a\ud83d\ude49\".\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[rustc_builtin_macro]\n-    #[rustc_macro_transparency = \"semitransparent\"]\n-    pub macro include {\n-        ($file:expr) => ({ /* compiler built-in */ }),\n+    #[macro_export]\n+    macro_rules! include {\n+        ($file:expr) => ({ /* compiler built-in */ });\n         ($file:expr,) => ({ /* compiler built-in */ })\n     }\n \n@@ -1227,45 +1231,45 @@ pub(crate) mod builtin {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[rustc_builtin_macro]\n-    #[rustc_macro_transparency = \"semitransparent\"]\n-    pub macro assert {\n-        ($cond:expr) => ({ /* compiler built-in */ }),\n-        ($cond:expr,) => ({ /* compiler built-in */ }),\n+    #[macro_export]\n+    macro_rules! assert {\n+        ($cond:expr) => ({ /* compiler built-in */ });\n+        ($cond:expr,) => ({ /* compiler built-in */ });\n         ($cond:expr, $($arg:tt)+) => ({ /* compiler built-in */ })\n     }\n \n     /// Inline assembly.\n     #[unstable(feature = \"asm\", issue = \"29722\",\n                reason = \"inline assembly is not stable enough for use and is subject to change\")]\n     #[rustc_builtin_macro]\n-    #[rustc_macro_transparency = \"semitransparent\"]\n-    pub macro asm(\"assembly template\"\n-                  : $(\"output\"(operand),)*\n-                  : $(\"input\"(operand),)*\n-                  : $(\"clobbers\",)*\n-                  : $(\"options\",)*) { /* compiler built-in */ }\n+    #[macro_export]\n+    macro_rules! asm { (\"assembly template\"\n+                        : $(\"output\"(operand),)*\n+                        : $(\"input\"(operand),)*\n+                        : $(\"clobbers\",)*\n+                        : $(\"options\",)*) => { /* compiler built-in */ } }\n \n     /// Module-level inline assembly.\n     #[unstable(feature = \"global_asm\", issue = \"35119\",\n                reason = \"`global_asm!` is not stable enough for use and is subject to change\")]\n     #[rustc_builtin_macro]\n-    #[rustc_macro_transparency = \"semitransparent\"]\n-    pub macro global_asm(\"assembly\") { /* compiler built-in */ }\n+    #[macro_export]\n+    macro_rules! global_asm { (\"assembly\") => { /* compiler built-in */ } }\n \n     /// Prints passed tokens into the standard output.\n     #[unstable(feature = \"log_syntax\", issue = \"29598\",\n                reason = \"`log_syntax!` is not stable enough for use and is subject to change\")]\n     #[rustc_builtin_macro]\n-    #[rustc_macro_transparency = \"semitransparent\"]\n-    pub macro log_syntax($($arg:tt)*) { /* compiler built-in */ }\n+    #[macro_export]\n+    macro_rules! log_syntax { ($($arg:tt)*) => { /* compiler built-in */ } }\n \n     /// Enables or disables tracing functionality used for debugging other macros.\n     #[unstable(feature = \"trace_macros\", issue = \"29598\",\n                reason = \"`trace_macros` is not stable enough for use and is subject to change\")]\n     #[rustc_builtin_macro]\n-    #[rustc_macro_transparency = \"semitransparent\"]\n-    pub macro trace_macros {\n-        (true) => ({ /* compiler built-in */ }),\n+    #[macro_export]\n+    macro_rules! trace_macros {\n+        (true) => ({ /* compiler built-in */ });\n         (false) => ({ /* compiler built-in */ })\n     }\n \n@@ -1299,69 +1303,6 @@ pub(crate) mod builtin {\n     #[rustc_macro_transparency = \"semitransparent\"]\n     pub macro global_allocator($item:item) { /* compiler built-in */ }\n \n-    /// Derive macro generating an impl of the trait `Clone`.\n-    #[rustc_builtin_macro]\n-    #[rustc_macro_transparency = \"semitransparent\"]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[allow_internal_unstable(core_intrinsics, derive_clone_copy)]\n-    pub macro Clone($item:item) { /* compiler built-in */ }\n-\n-    /// Derive macro generating an impl of the trait `Copy`.\n-    #[rustc_builtin_macro]\n-    #[rustc_macro_transparency = \"semitransparent\"]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[allow_internal_unstable(core_intrinsics, derive_clone_copy)]\n-    pub macro Copy($item:item) { /* compiler built-in */ }\n-\n-    /// Derive macro generating an impl of the trait `Debug`.\n-    #[rustc_builtin_macro]\n-    #[rustc_macro_transparency = \"semitransparent\"]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[allow_internal_unstable(core_intrinsics)]\n-    pub macro Debug($item:item) { /* compiler built-in */ }\n-\n-    /// Derive macro generating an impl of the trait `Default`.\n-    #[rustc_builtin_macro]\n-    #[rustc_macro_transparency = \"semitransparent\"]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[allow_internal_unstable(core_intrinsics)]\n-    pub macro Default($item:item) { /* compiler built-in */ }\n-\n-    /// Derive macro generating an impl of the trait `Eq`.\n-    #[rustc_builtin_macro]\n-    #[rustc_macro_transparency = \"semitransparent\"]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[allow_internal_unstable(core_intrinsics, derive_eq)]\n-    pub macro Eq($item:item) { /* compiler built-in */ }\n-\n-    /// Derive macro generating an impl of the trait `Hash`.\n-    #[rustc_builtin_macro]\n-    #[rustc_macro_transparency = \"semitransparent\"]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[allow_internal_unstable(core_intrinsics)]\n-    pub macro Hash($item:item) { /* compiler built-in */ }\n-\n-    /// Derive macro generating an impl of the trait `Ord`.\n-    #[rustc_builtin_macro]\n-    #[rustc_macro_transparency = \"semitransparent\"]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[allow_internal_unstable(core_intrinsics)]\n-    pub macro Ord($item:item) { /* compiler built-in */ }\n-\n-    /// Derive macro generating an impl of the trait `PartialEq`.\n-    #[rustc_builtin_macro]\n-    #[rustc_macro_transparency = \"semitransparent\"]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[allow_internal_unstable(core_intrinsics)]\n-    pub macro PartialEq($item:item) { /* compiler built-in */ }\n-\n-    /// Derive macro generating an impl of the trait `PartialOrd`.\n-    #[rustc_builtin_macro]\n-    #[rustc_macro_transparency = \"semitransparent\"]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[allow_internal_unstable(core_intrinsics)]\n-    pub macro PartialOrd($item:item) { /* compiler built-in */ }\n-\n     /// Unstable implementation detail of the `rustc` compiler, do not use.\n     #[rustc_builtin_macro]\n     #[rustc_macro_transparency = \"semitransparent\"]"}, {"sha": "78a273611650c3be6774649b815d3e28bf91a895", "filename": "src/libcore/marker.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Flibcore%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Flibcore%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmarker.rs?ref=d19a359444295bab01de7ff44a9d72302e573bc9", "patch": "@@ -288,6 +288,14 @@ pub trait Copy : Clone {\n     // Empty.\n }\n \n+/// Derive macro generating an impl of the trait `Copy`.\n+#[cfg(not(bootstrap))]\n+#[rustc_builtin_macro]\n+#[rustc_macro_transparency = \"semitransparent\"]\n+#[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n+#[allow_internal_unstable(core_intrinsics, derive_clone_copy)]\n+pub macro Copy($item:item) { /* compiler built-in */ }\n+\n /// Types for which it is safe to share references between threads.\n ///\n /// This trait is automatically implemented when the compiler determines"}, {"sha": "6efeaf9ee7d2eff9e1a08a0f077412f19c673153", "filename": "src/libcore/pin.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Flibcore%2Fpin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Flibcore%2Fpin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpin.rs?ref=d19a359444295bab01de7ff44a9d72302e573bc9", "patch": "@@ -440,10 +440,7 @@ where\n     }\n }\n \n-impl<P: Deref> Pin<P>\n-where\n-    P::Target: Unpin,\n-{\n+impl<P: Deref<Target: Unpin>> Pin<P> {\n     /// Construct a new `Pin<P>` around a pointer to some data of a type that\n     /// implements [`Unpin`].\n     ///\n@@ -731,10 +728,7 @@ impl<P: Deref> Deref for Pin<P> {\n }\n \n #[stable(feature = \"pin\", since = \"1.33.0\")]\n-impl<P: DerefMut> DerefMut for Pin<P>\n-where\n-    P::Target: Unpin\n-{\n+impl<P: DerefMut<Target: Unpin>> DerefMut for Pin<P> {\n     fn deref_mut(&mut self) -> &mut P::Target {\n         Pin::get_mut(Pin::as_mut(self))\n     }"}, {"sha": "84cf85f339c99bc30e44767d6a9380fc87a923da", "filename": "src/libcore/prelude/v1.rs", "status": "modified", "additions": 22, "deletions": 16, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Flibcore%2Fprelude%2Fv1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Flibcore%2Fprelude%2Fv1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprelude%2Fv1.rs?ref=d19a359444295bab01de7ff44a9d72302e573bc9", "patch": "@@ -48,24 +48,20 @@ pub use crate::result::Result::{self, Ok, Err};\n // Re-exported built-in macros\n #[cfg(not(bootstrap))]\n #[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n-#[allow(deprecated)]\n #[doc(no_inline)]\n-pub use crate::macros::builtin::{\n-    Clone,\n-    Copy,\n-    Debug,\n-    Default,\n-    Eq,\n-    Hash,\n-    Ord,\n-    PartialEq,\n-    PartialOrd,\n-    RustcDecodable,\n-    RustcEncodable,\n+pub use crate::fmt::macros::Debug;\n+#[cfg(not(bootstrap))]\n+#[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n+#[doc(no_inline)]\n+pub use crate::hash::macros::Hash;\n+\n+#[cfg(not(bootstrap))]\n+#[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n+#[doc(no_inline)]\n+pub use crate::{\n     __rust_unstable_column,\n     asm,\n     assert,\n-    bench,\n     cfg,\n     column,\n     compile_error,\n@@ -75,7 +71,6 @@ pub use crate::macros::builtin::{\n     file,\n     format_args,\n     format_args_nl,\n-    global_allocator,\n     global_asm,\n     include,\n     include_bytes,\n@@ -85,7 +80,18 @@ pub use crate::macros::builtin::{\n     module_path,\n     option_env,\n     stringify,\n+    trace_macros,\n+};\n+\n+#[cfg(not(bootstrap))]\n+#[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n+#[allow(deprecated)]\n+#[doc(no_inline)]\n+pub use crate::macros::builtin::{\n+    RustcDecodable,\n+    RustcEncodable,\n+    bench,\n+    global_allocator,\n     test,\n     test_case,\n-    trace_macros,\n };"}, {"sha": "f20cb7bfbc3bdd21305dd035f3d69678619ef1c2", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 74, "deletions": 42, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=d19a359444295bab01de7ff44a9d72302e573bc9", "patch": "@@ -851,8 +851,9 @@ unsafe impl TrustedRandomAccess for Bytes<'_> {\n /// wrapper types of the form X<'a, P>\n macro_rules! derive_pattern_clone {\n     (clone $t:ident with |$s:ident| $e:expr) => {\n-        impl<'a, P: Pattern<'a>> Clone for $t<'a, P>\n-            where P::Searcher: Clone\n+        impl<'a, P> Clone for $t<'a, P>\n+        where\n+            P: Pattern<'a, Searcher: Clone>,\n         {\n             fn clone(&self) -> Self {\n                 let $s = self;\n@@ -928,8 +929,9 @@ macro_rules! generate_pattern_iterators {\n         pub struct $forward_iterator<'a, P: Pattern<'a>>($internal_iterator<'a, P>);\n \n         $(#[$common_stability_attribute])*\n-        impl<'a, P: Pattern<'a>> fmt::Debug for $forward_iterator<'a, P>\n-            where P::Searcher: fmt::Debug\n+        impl<'a, P> fmt::Debug for $forward_iterator<'a, P>\n+        where\n+            P: Pattern<'a, Searcher: fmt::Debug>,\n         {\n             fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n                 f.debug_tuple(stringify!($forward_iterator))\n@@ -949,8 +951,9 @@ macro_rules! generate_pattern_iterators {\n         }\n \n         $(#[$common_stability_attribute])*\n-        impl<'a, P: Pattern<'a>> Clone for $forward_iterator<'a, P>\n-            where P::Searcher: Clone\n+        impl<'a, P> Clone for $forward_iterator<'a, P>\n+        where\n+            P: Pattern<'a, Searcher: Clone>,\n         {\n             fn clone(&self) -> Self {\n                 $forward_iterator(self.0.clone())\n@@ -962,8 +965,9 @@ macro_rules! generate_pattern_iterators {\n         pub struct $reverse_iterator<'a, P: Pattern<'a>>($internal_iterator<'a, P>);\n \n         $(#[$common_stability_attribute])*\n-        impl<'a, P: Pattern<'a>> fmt::Debug for $reverse_iterator<'a, P>\n-            where P::Searcher: fmt::Debug\n+        impl<'a, P> fmt::Debug for $reverse_iterator<'a, P>\n+        where\n+            P: Pattern<'a, Searcher: fmt::Debug>,\n         {\n             fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n                 f.debug_tuple(stringify!($reverse_iterator))\n@@ -973,8 +977,9 @@ macro_rules! generate_pattern_iterators {\n         }\n \n         $(#[$common_stability_attribute])*\n-        impl<'a, P: Pattern<'a>> Iterator for $reverse_iterator<'a, P>\n-            where P::Searcher: ReverseSearcher<'a>\n+        impl<'a, P> Iterator for $reverse_iterator<'a, P>\n+        where\n+            P: Pattern<'a, Searcher: ReverseSearcher<'a>>,\n         {\n             type Item = $iterty;\n \n@@ -985,8 +990,9 @@ macro_rules! generate_pattern_iterators {\n         }\n \n         $(#[$common_stability_attribute])*\n-        impl<'a, P: Pattern<'a>> Clone for $reverse_iterator<'a, P>\n-            where P::Searcher: Clone\n+        impl<'a, P> Clone for $reverse_iterator<'a, P>\n+        where\n+            P: Pattern<'a, Searcher: Clone>,\n         {\n             fn clone(&self) -> Self {\n                 $reverse_iterator(self.0.clone())\n@@ -997,8 +1003,10 @@ macro_rules! generate_pattern_iterators {\n         impl<'a, P: Pattern<'a>> FusedIterator for $forward_iterator<'a, P> {}\n \n         #[stable(feature = \"fused\", since = \"1.26.0\")]\n-        impl<'a, P: Pattern<'a>> FusedIterator for $reverse_iterator<'a, P>\n-            where P::Searcher: ReverseSearcher<'a> {}\n+        impl<'a, P> FusedIterator for $reverse_iterator<'a, P>\n+        where\n+            P: Pattern<'a, Searcher: ReverseSearcher<'a>>,\n+        {}\n \n         generate_pattern_iterators!($($t)* with $(#[$common_stability_attribute])*,\n                                                 $forward_iterator,\n@@ -1010,8 +1018,9 @@ macro_rules! generate_pattern_iterators {\n                            $reverse_iterator:ident, $iterty:ty\n     } => {\n         $(#[$common_stability_attribute])*\n-        impl<'a, P: Pattern<'a>> DoubleEndedIterator for $forward_iterator<'a, P>\n-            where P::Searcher: DoubleEndedSearcher<'a>\n+        impl<'a, P> DoubleEndedIterator for $forward_iterator<'a, P>\n+        where\n+            P: Pattern<'a, Searcher: DoubleEndedSearcher<'a>>,\n         {\n             #[inline]\n             fn next_back(&mut self) -> Option<$iterty> {\n@@ -1020,8 +1029,9 @@ macro_rules! generate_pattern_iterators {\n         }\n \n         $(#[$common_stability_attribute])*\n-        impl<'a, P: Pattern<'a>> DoubleEndedIterator for $reverse_iterator<'a, P>\n-            where P::Searcher: DoubleEndedSearcher<'a>\n+        impl<'a, P> DoubleEndedIterator for $reverse_iterator<'a, P>\n+        where\n+            P: Pattern<'a, Searcher: DoubleEndedSearcher<'a>>,\n         {\n             #[inline]\n             fn next_back(&mut self) -> Option<$iterty> {\n@@ -1049,7 +1059,10 @@ struct SplitInternal<'a, P: Pattern<'a>> {\n     finished: bool,\n }\n \n-impl<'a, P: Pattern<'a>> fmt::Debug for SplitInternal<'a, P> where P::Searcher: fmt::Debug {\n+impl<'a, P> fmt::Debug for SplitInternal<'a, P>\n+where\n+    P: Pattern<'a, Searcher: fmt::Debug>,\n+{\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         f.debug_struct(\"SplitInternal\")\n             .field(\"start\", &self.start)\n@@ -1166,7 +1179,10 @@ struct SplitNInternal<'a, P: Pattern<'a>> {\n     count: usize,\n }\n \n-impl<'a, P: Pattern<'a>> fmt::Debug for SplitNInternal<'a, P> where P::Searcher: fmt::Debug {\n+impl<'a, P> fmt::Debug for SplitNInternal<'a, P>\n+where\n+    P: Pattern<'a, Searcher: fmt::Debug>,\n+{\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         f.debug_struct(\"SplitNInternal\")\n             .field(\"iter\", &self.iter)\n@@ -1222,7 +1238,10 @@ derive_pattern_clone!{\n \n struct MatchIndicesInternal<'a, P: Pattern<'a>>(P::Searcher);\n \n-impl<'a, P: Pattern<'a>> fmt::Debug for MatchIndicesInternal<'a, P> where P::Searcher: fmt::Debug {\n+impl<'a, P> fmt::Debug for MatchIndicesInternal<'a, P>\n+where\n+    P: Pattern<'a, Searcher: fmt::Debug>,\n+{\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         f.debug_tuple(\"MatchIndicesInternal\")\n             .field(&self.0)\n@@ -1273,7 +1292,10 @@ derive_pattern_clone!{\n \n struct MatchesInternal<'a, P: Pattern<'a>>(P::Searcher);\n \n-impl<'a, P: Pattern<'a>> fmt::Debug for MatchesInternal<'a, P> where P::Searcher: fmt::Debug {\n+impl<'a, P> fmt::Debug for MatchesInternal<'a, P>\n+where\n+    P: Pattern<'a, Searcher: fmt::Debug>,\n+{\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         f.debug_tuple(\"MatchesInternal\")\n             .field(&self.0)\n@@ -2882,8 +2904,9 @@ impl str {\n     /// assert!(!bananas.ends_with(\"nana\"));\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn ends_with<'a, P: Pattern<'a>>(&'a self, pat: P) -> bool\n-        where P::Searcher: ReverseSearcher<'a>\n+    pub fn ends_with<'a, P>(&'a self, pat: P) -> bool\n+    where\n+        P: Pattern<'a, Searcher: ReverseSearcher<'a>>,\n     {\n         pat.is_suffix_of(self)\n     }\n@@ -2975,8 +2998,9 @@ impl str {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn rfind<'a, P: Pattern<'a>>(&'a self, pat: P) -> Option<usize>\n-        where P::Searcher: ReverseSearcher<'a>\n+    pub fn rfind<'a, P>(&'a self, pat: P) -> Option<usize>\n+    where\n+        P: Pattern<'a, Searcher: ReverseSearcher<'a>>,\n     {\n         pat.into_searcher(self).next_match_back().map(|(i, _)| i)\n     }\n@@ -3142,8 +3166,9 @@ impl str {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn rsplit<'a, P: Pattern<'a>>(&'a self, pat: P) -> RSplit<'a, P>\n-        where P::Searcher: ReverseSearcher<'a>\n+    pub fn rsplit<'a, P>(&'a self, pat: P) -> RSplit<'a, P>\n+    where\n+        P: Pattern<'a, Searcher: ReverseSearcher<'a>>,\n     {\n         RSplit(self.split(pat).0)\n     }\n@@ -3233,8 +3258,9 @@ impl str {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn rsplit_terminator<'a, P: Pattern<'a>>(&'a self, pat: P) -> RSplitTerminator<'a, P>\n-        where P::Searcher: ReverseSearcher<'a>\n+    pub fn rsplit_terminator<'a, P>(&'a self, pat: P) -> RSplitTerminator<'a, P>\n+    where\n+        P: Pattern<'a, Searcher: ReverseSearcher<'a>>,\n     {\n         RSplitTerminator(self.split_terminator(pat).0)\n     }\n@@ -3333,8 +3359,9 @@ impl str {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn rsplitn<'a, P: Pattern<'a>>(&'a self, n: usize, pat: P) -> RSplitN<'a, P>\n-        where P::Searcher: ReverseSearcher<'a>\n+    pub fn rsplitn<'a, P>(&'a self, n: usize, pat: P) -> RSplitN<'a, P>\n+    where\n+        P: Pattern<'a, Searcher: ReverseSearcher<'a>>,\n     {\n         RSplitN(self.splitn(n, pat).0)\n     }\n@@ -3406,8 +3433,9 @@ impl str {\n     /// ```\n     #[stable(feature = \"str_matches\", since = \"1.2.0\")]\n     #[inline]\n-    pub fn rmatches<'a, P: Pattern<'a>>(&'a self, pat: P) -> RMatches<'a, P>\n-        where P::Searcher: ReverseSearcher<'a>\n+    pub fn rmatches<'a, P>(&'a self, pat: P) -> RMatches<'a, P>\n+    where\n+        P: Pattern<'a, Searcher: ReverseSearcher<'a>>,\n     {\n         RMatches(self.matches(pat).0)\n     }\n@@ -3491,8 +3519,9 @@ impl str {\n     /// ```\n     #[stable(feature = \"str_match_indices\", since = \"1.5.0\")]\n     #[inline]\n-    pub fn rmatch_indices<'a, P: Pattern<'a>>(&'a self, pat: P) -> RMatchIndices<'a, P>\n-        where P::Searcher: ReverseSearcher<'a>\n+    pub fn rmatch_indices<'a, P>(&'a self, pat: P) -> RMatchIndices<'a, P>\n+    where\n+        P: Pattern<'a, Searcher: ReverseSearcher<'a>>,\n     {\n         RMatchIndices(self.match_indices(pat).0)\n     }\n@@ -3700,8 +3729,9 @@ impl str {\n     #[must_use = \"this returns the trimmed string as a new slice, \\\n                   without modifying the original\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn trim_matches<'a, P: Pattern<'a>>(&'a self, pat: P) -> &'a str\n-        where P::Searcher: DoubleEndedSearcher<'a>\n+    pub fn trim_matches<'a, P>(&'a self, pat: P) -> &'a str\n+    where\n+        P: Pattern<'a, Searcher: DoubleEndedSearcher<'a>>,\n     {\n         let mut i = 0;\n         let mut j = 0;\n@@ -3792,8 +3822,9 @@ impl str {\n     #[must_use = \"this returns the trimmed string as a new slice, \\\n                   without modifying the original\"]\n     #[stable(feature = \"trim_direction\", since = \"1.30.0\")]\n-    pub fn trim_end_matches<'a, P: Pattern<'a>>(&'a self, pat: P) -> &'a str\n-        where P::Searcher: ReverseSearcher<'a>\n+    pub fn trim_end_matches<'a, P>(&'a self, pat: P) -> &'a str\n+    where\n+        P: Pattern<'a, Searcher: ReverseSearcher<'a>>,\n     {\n         let mut j = 0;\n         let mut matcher = pat.into_searcher(self);\n@@ -3880,8 +3911,9 @@ impl str {\n         reason = \"superseded by `trim_end_matches`\",\n         suggestion = \"trim_end_matches\",\n     )]\n-    pub fn trim_right_matches<'a, P: Pattern<'a>>(&'a self, pat: P) -> &'a str\n-        where P::Searcher: ReverseSearcher<'a>\n+    pub fn trim_right_matches<'a, P>(&'a self, pat: P) -> &'a str\n+    where\n+        P: Pattern<'a, Searcher: ReverseSearcher<'a>>,\n     {\n         self.trim_end_matches(pat)\n     }"}, {"sha": "b85738dd29a6d835255235d06e60be19bbb6341f", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=d19a359444295bab01de7ff44a9d72302e573bc9", "patch": "@@ -287,7 +287,7 @@ impl<'hir> Map<'hir> {\n         self.definitions.def_index_to_hir_id(def_id.to_def_id().index)\n     }\n \n-    fn def_kind(&self, hir_id: HirId) -> Option<DefKind> {\n+    pub fn def_kind(&self, hir_id: HirId) -> Option<DefKind> {\n         let node = if let Some(node) = self.find(hir_id) {\n             node\n         } else {"}, {"sha": "2ffcd2c4ace7bc48d1533463bbf9cdee16239f0d", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 10, "deletions": 28, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=d19a359444295bab01de7ff44a9d72302e573bc9", "patch": "@@ -662,19 +662,22 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     }\n                 }\n                 _ => {\n+                    // `last_ty` can be `!`, `expected` will have better info when present.\n+                    let t = self.resolve_vars_if_possible(&match exp_found {\n+                        Some(ty::error::ExpectedFound { expected, .. }) => expected,\n+                        _ => last_ty,\n+                    });\n                     let msg = \"`match` arms have incompatible types\";\n                     err.span_label(cause.span, msg);\n                     if prior_arms.len() <= 4 {\n                         for sp in prior_arms {\n-                            err.span_label(*sp, format!(\n-                                \"this is found to be of type `{}`\",\n-                                self.resolve_vars_if_possible(&last_ty),\n-                            ));\n+                            err.span_label( *sp, format!(\"this is found to be of type `{}`\", t));\n                         }\n                     } else if let Some(sp) = prior_arms.last() {\n-                        err.span_label(*sp, format!(\n-                            \"this and all prior arms are found to be of type `{}`\", last_ty,\n-                        ));\n+                        err.span_label(\n+                            *sp,\n+                            format!(\"this and all prior arms are found to be of type `{}`\", t),\n+                        );\n                     }\n                 }\n             },\n@@ -1143,27 +1146,6 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 }\n                 (_, false, _) => {\n                     if let Some(exp_found) = exp_found {\n-                        let (def_id, ret_ty) = match exp_found.found.sty {\n-                            ty::FnDef(def, _) => {\n-                                (Some(def), Some(self.tcx.fn_sig(def).output()))\n-                            }\n-                            _ => (None, None),\n-                        };\n-\n-                        let exp_is_struct = match exp_found.expected.sty {\n-                            ty::Adt(def, _) => def.is_struct(),\n-                            _ => false,\n-                        };\n-\n-                        if let (Some(def_id), Some(ret_ty)) = (def_id, ret_ty) {\n-                            if exp_is_struct && &exp_found.expected == ret_ty.skip_binder() {\n-                                let message = format!(\n-                                    \"did you mean `{}(/* fields */)`?\",\n-                                    self.tcx.def_path_str(def_id)\n-                                );\n-                                diag.span_label(span, message);\n-                            }\n-                        }\n                         self.suggest_as_ref_where_appropriate(span, &exp_found, diag);\n                     }\n "}, {"sha": "8d4cd51e4608c3364c76e2f7a8ce527bb3310baf", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=d19a359444295bab01de7ff44a9d72302e573bc9", "patch": "@@ -61,6 +61,7 @@\n #![feature(proc_macro_hygiene)]\n #![feature(log_syntax)]\n #![feature(mem_take)]\n+#![feature(associated_type_bounds)]\n \n #![recursion_limit=\"512\"]\n "}, {"sha": "d4ae366262cbfa4d6dca2bc18b0911270c57fcba", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=d19a359444295bab01de7ff44a9d72302e573bc9", "patch": "@@ -3901,7 +3901,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // each predicate must be preceded by the obligations required\n         // to normalize it.\n         // for example, if we have:\n-        //    impl<U: Iterator, V: Iterator<Item=U>> Foo for V where U::Item: Copy\n+        //    impl<U: Iterator<Item: Copy>, V: Iterator<Item = U>> Foo for V\n         // the impl will have the following predicates:\n         //    <V as Iterator>::Item = U,\n         //    U: Iterator, U: Sized,"}, {"sha": "05b698eb4c4ea95547e56700a983dd21cfd2b58b", "filename": "src/librustc/traits/structural_impls.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs?ref=d19a359444295bab01de7ff44a9d72302e573bc9", "patch": "@@ -980,17 +980,15 @@ EnumTypeFoldableImpl! {\n         (chalk_engine::DelayedLiteral::Negative)(a),\n         (chalk_engine::DelayedLiteral::Positive)(a, b),\n     } where\n-        C: chalk_engine::context::Context + Clone,\n-        C::CanonicalConstrainedSubst: TypeFoldable<'tcx>,\n+        C: chalk_engine::context::Context<CanonicalConstrainedSubst: TypeFoldable<'tcx>> + Clone,\n }\n \n EnumTypeFoldableImpl! {\n     impl<'tcx, C> TypeFoldable<'tcx> for chalk_engine::Literal<C> {\n         (chalk_engine::Literal::Negative)(a),\n         (chalk_engine::Literal::Positive)(a),\n     } where\n-        C: chalk_engine::context::Context + Clone,\n-        C::GoalInEnvironment: Clone + TypeFoldable<'tcx>,\n+        C: chalk_engine::context::Context<GoalInEnvironment: Clone + TypeFoldable<'tcx>> + Clone,\n }\n \n CloneTypeFoldableAndLiftImpls! {"}, {"sha": "ef74d9e5b2899e7eca0af9d4a324aaf8417a3e23", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=d19a359444295bab01de7ff44a9d72302e573bc9", "patch": "@@ -2663,8 +2663,8 @@ impl<'tcx> TyCtxt<'tcx> {\n                         unsafety: hir::Unsafety,\n                         abi: abi::Abi)\n         -> <I::Item as InternIteratorElement<Ty<'tcx>, ty::FnSig<'tcx>>>::Output\n-        where I: Iterator,\n-              I::Item: InternIteratorElement<Ty<'tcx>, ty::FnSig<'tcx>>\n+    where\n+        I: Iterator<Item: InternIteratorElement<Ty<'tcx>, ty::FnSig<'tcx>>>,\n     {\n         inputs.chain(iter::once(output)).intern_with(|xs| ty::FnSig {\n             inputs_and_output: self.intern_type_list(xs),"}, {"sha": "a9d1fd1fffc92ab54ad558ed245a96f7d2551ee9", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=d19a359444295bab01de7ff44a9d72302e573bc9", "patch": "@@ -2027,9 +2027,9 @@ impl ty::query::TyCtxtAt<'tcx> {\n \n impl<'tcx, C> TyLayoutMethods<'tcx, C> for Ty<'tcx>\n where\n-    C: LayoutOf<Ty = Ty<'tcx>> + HasTyCtxt<'tcx>,\n-    C::TyLayout: MaybeResult<TyLayout<'tcx>>,\n-    C: HasParamEnv<'tcx>,\n+    C: LayoutOf<Ty = Ty<'tcx>, TyLayout: MaybeResult<TyLayout<'tcx>>>\n+        + HasTyCtxt<'tcx>\n+        + HasParamEnv<'tcx>,\n {\n     fn for_variant(this: TyLayout<'tcx>, cx: &C, variant_index: VariantIdx) -> TyLayout<'tcx> {\n         let details = match this.variants {"}, {"sha": "40bcd028db58d7dee925473916a904041387b14b", "filename": "src/librustc/ty/query/on_disk_cache.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs?ref=d19a359444295bab01de7ff44a9d72302e573bc9", "patch": "@@ -1055,9 +1055,8 @@ fn encode_query_results<'a, 'tcx, Q, E>(\n     query_result_index: &mut EncodedQueryResultIndex,\n ) -> Result<(), E::Error>\n where\n-    Q: super::config::QueryDescription<'tcx>,\n+    Q: super::config::QueryDescription<'tcx, Value: Encodable>,\n     E: 'a + TyEncoder,\n-    Q::Value: Encodable,\n {\n     let desc = &format!(\"encode_query_results for {}\",\n         ::std::any::type_name::<Q>());"}, {"sha": "340cc772e5f07a774fbf0fac914e5371ddcab704", "filename": "src/librustc_codegen_ssa/back/command.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Flibrustc_codegen_ssa%2Fback%2Fcommand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Flibrustc_codegen_ssa%2Fback%2Fcommand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fcommand.rs?ref=d19a359444295bab01de7ff44a9d72302e573bc9", "patch": "@@ -50,8 +50,8 @@ impl Command {\n     }\n \n     pub fn args<I>(&mut self, args: I) -> &mut Command\n-        where I: IntoIterator,\n-              I::Item: AsRef<OsStr>,\n+    where\n+        I: IntoIterator<Item: AsRef<OsStr>>,\n     {\n         for arg in args {\n             self._arg(arg.as_ref());"}, {"sha": "0e3c3a77b28f4009641ee3091dae815c9ad45ee1", "filename": "src/librustc_codegen_ssa/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Flibrustc_codegen_ssa%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Flibrustc_codegen_ssa%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Flib.rs?ref=d19a359444295bab01de7ff44a9d72302e573bc9", "patch": "@@ -11,6 +11,7 @@\n #![feature(nll)]\n #![feature(trusted_len)]\n #![feature(mem_take)]\n+#![feature(associated_type_bounds)]\n \n #![recursion_limit=\"256\"]\n "}, {"sha": "9f103437d368e0208d115719129eb0832a2decbc", "filename": "src/librustc_data_structures/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Flibrustc_data_structures%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Flibrustc_data_structures%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Flib.rs?ref=d19a359444295bab01de7ff44a9d72302e573bc9", "patch": "@@ -23,6 +23,7 @@\n #![feature(core_intrinsics)]\n #![feature(integer_atomics)]\n #![feature(test)]\n+#![feature(associated_type_bounds)]\n \n #![cfg_attr(unix, feature(libc))]\n "}, {"sha": "b835b1706b85f5cf3651a94bc6f4c489517d4a4e", "filename": "src/librustc_data_structures/owning_ref/mod.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Flibrustc_data_structures%2Fowning_ref%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Flibrustc_data_structures%2Fowning_ref%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fowning_ref%2Fmod.rs?ref=d19a359444295bab01de7ff44a9d72302e573bc9", "patch": "@@ -847,7 +847,9 @@ pub trait ToHandleMut {\n }\n \n impl<O, H> OwningHandle<O, H>\n-    where O: StableAddress, O::Target: ToHandle<Handle = H>, H: Deref,\n+where\n+    O: StableAddress<Target: ToHandle<Handle = H>>,\n+    H: Deref,\n {\n     /// Creates a new `OwningHandle` for a type that implements `ToHandle`. For types\n     /// that don't implement `ToHandle`, callers may invoke `new_with_fn`, which accepts\n@@ -858,7 +860,9 @@ impl<O, H> OwningHandle<O, H>\n }\n \n impl<O, H> OwningHandle<O, H>\n-    where O: StableAddress, O::Target: ToHandleMut<HandleMut = H>, H: DerefMut,\n+where\n+    O: StableAddress<Target: ToHandleMut<HandleMut = H>>,\n+    H: DerefMut,\n {\n     /// Creates a new mutable `OwningHandle` for a type that implements `ToHandleMut`.\n     pub fn new_mut(o: O) -> Self {"}, {"sha": "7fe2a890a5371da6f0598a9e9437515877e846f4", "filename": "src/librustc_mir/dataflow/mod.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs?ref=d19a359444295bab01de7ff44a9d72302e573bc9", "patch": "@@ -589,10 +589,8 @@ impl<E:Idx> GenKillSet<E> {\n         self.gen_set.insert(e);\n         self.kill_set.remove(e);\n     }\n-    fn gen_all<I>(&mut self, i: I)\n-        where I: IntoIterator,\n-              I::Item: Borrow<E>\n-    {\n+\n+    fn gen_all(&mut self, i: impl IntoIterator<Item: Borrow<E>>) {\n         for j in i {\n             self.gen(*j.borrow());\n         }\n@@ -603,10 +601,7 @@ impl<E:Idx> GenKillSet<E> {\n         self.kill_set.insert(e);\n     }\n \n-    fn kill_all<I>(&mut self, i: I)\n-        where I: IntoIterator,\n-              I::Item: Borrow<E>\n-    {\n+    fn kill_all(&mut self, i: impl IntoIterator<Item: Borrow<E>>) {\n         for j in i {\n             self.kill(*j.borrow());\n         }"}, {"sha": "cccf7b9545bdbda40ae08f6975a07e74b725d342", "filename": "src/librustc_mir/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Flibrustc_mir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Flibrustc_mir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flib.rs?ref=d19a359444295bab01de7ff44a9d72302e573bc9", "patch": "@@ -23,6 +23,7 @@ Rust MIR: a lowered representation of Rust. Also: an experiment!\n #![feature(trusted_len)]\n #![feature(try_blocks)]\n #![feature(mem_take)]\n+#![feature(associated_type_bounds)]\n \n #![recursion_limit=\"256\"]\n "}, {"sha": "ce2bc79ff603439ea5dcad8349e2fa1d7bd68bc3", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 28, "deletions": 3, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=d19a359444295bab01de7ff44a9d72302e573bc9", "patch": "@@ -50,7 +50,7 @@ use syntax::ast::{Item, ItemKind, ImplItem, ImplItemKind};\n use syntax::ast::{Label, Local, Mutability, Pat, PatKind, Path};\n use syntax::ast::{QSelf, TraitItem, TraitItemKind, TraitRef, Ty, TyKind};\n use syntax::ptr::P;\n-use syntax::{span_err, struct_span_err, unwrap_or, walk_list};\n+use syntax::{struct_span_err, unwrap_or, walk_list};\n \n use syntax_pos::{Span, DUMMY_SP, MultiSpan};\n use errors::{Applicability, DiagnosticBuilder, DiagnosticId};\n@@ -4789,8 +4789,33 @@ impl<'a> Resolver<'a> {\n         let mut reported_spans = FxHashSet::default();\n         for &PrivacyError(dedup_span, ident, binding) in &self.privacy_errors {\n             if reported_spans.insert(dedup_span) {\n-                span_err!(self.session, ident.span, E0603, \"{} `{}` is private\",\n-                          binding.descr(), ident.name);\n+                let mut err = struct_span_err!(\n+                    self.session,\n+                    ident.span,\n+                    E0603,\n+                    \"{} `{}` is private\",\n+                    binding.descr(),\n+                    ident.name,\n+                );\n+                // FIXME: use the ctor's `def_id` to check wether any of the fields is not visible\n+                match binding.kind {\n+                    NameBindingKind::Res(Res::Def(DefKind::Ctor(\n+                        CtorOf::Struct,\n+                        CtorKind::Fn,\n+                    ), _def_id), _) => {\n+                        err.note(\"a tuple struct constructor is private if any of its fields \\\n+                                  is private\");\n+                    }\n+                    NameBindingKind::Res(Res::Def(DefKind::Ctor(\n+                        CtorOf::Variant,\n+                        CtorKind::Fn,\n+                    ), _def_id), _) => {\n+                        err.note(\"a tuple variant constructor is private if any of its fields \\\n+                                  is private\");\n+                    }\n+                    _ => {}\n+                }\n+                err.emit();\n             }\n         }\n     }"}, {"sha": "9680f61d6990314f9a4424e80c0c543204931074", "filename": "src/librustc_typeck/check/expr.rs", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs?ref=d19a359444295bab01de7ff44a9d72302e573bc9", "patch": "@@ -548,7 +548,23 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     coerce.coerce(self, &cause, e, e_ty);\n                 } else {\n                     assert!(e_ty.is_unit());\n-                    coerce.coerce_forced_unit(self, &cause, &mut |_| (), true);\n+                    let ty = coerce.expected_ty();\n+                    coerce.coerce_forced_unit(self, &cause, &mut |err| {\n+                        let val = match ty.sty {\n+                            ty::Bool => \"true\",\n+                            ty::Char => \"'a'\",\n+                            ty::Int(_) | ty::Uint(_) => \"42\",\n+                            ty::Float(_) => \"3.14159\",\n+                            ty::Error | ty::Never => return,\n+                            _ => \"value\",\n+                        };\n+                        let msg = \"give it a value of the expected type\";\n+                        let label = destination.label\n+                            .map(|l| format!(\" {}\", l.ident))\n+                            .unwrap_or_else(String::new);\n+                        let sugg = format!(\"break{} {}\", label, val);\n+                        err.span_suggestion(expr.span, msg, sugg, Applicability::HasPlaceholders);\n+                    }, false);\n                 }\n             } else {\n                 // If `ctxt.coerce` is `None`, we can just ignore"}, {"sha": "4fb28db6e94fa09c29530badc86613449f445f7b", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 108, "deletions": 1, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=d19a359444295bab01de7ff44a9d72302e573bc9", "patch": "@@ -3709,7 +3709,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             self.consider_hint_about_removing_semicolon(blk, expected_ty, err);\n                         }\n                         if let Some(fn_span) = fn_span {\n-                            err.span_label(fn_span, \"this function's body doesn't return\");\n+                            err.span_label(\n+                                fn_span,\n+                                \"implicitly returns `()` as its body has no tail or `return` \\\n+                                 expression\",\n+                            );\n                         }\n                     }, false);\n                 }\n@@ -3819,6 +3823,101 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         pointing_at_return_type\n     }\n \n+    /// When encountering an fn-like ctor that needs to unify with a value, check whether calling\n+    /// the ctor would successfully solve the type mismatch and if so, suggest it:\n+    /// ```\n+    /// fn foo(x: usize) -> usize { x }\n+    /// let x: usize = foo;  // suggest calling the `foo` function: `foo(42)`\n+    /// ```\n+    fn suggest_fn_call(\n+        &self,\n+        err: &mut DiagnosticBuilder<'tcx>,\n+        expr: &hir::Expr,\n+        expected: Ty<'tcx>,\n+        found: Ty<'tcx>,\n+    ) -> bool {\n+        match found.sty {\n+            ty::FnDef(..) | ty::FnPtr(_) => {}\n+            _ => return false,\n+        }\n+        let hir = self.tcx.hir();\n+\n+        let sig = found.fn_sig(self.tcx);\n+        let sig = self\n+            .replace_bound_vars_with_fresh_vars(expr.span, infer::FnCall, &sig)\n+            .0;\n+        let sig = self.normalize_associated_types_in(expr.span, &sig);\n+        if let Ok(_) = self.try_coerce(expr, sig.output(), expected, AllowTwoPhase::No) {\n+            let (mut sugg_call, applicability) = if sig.inputs().is_empty() {\n+                (String::new(), Applicability::MachineApplicable)\n+            } else {\n+                (\"...\".to_string(), Applicability::HasPlaceholders)\n+            };\n+            let mut msg = \"call this function\";\n+            if let ty::FnDef(def_id, ..) = found.sty {\n+                match hir.get_if_local(def_id) {\n+                    Some(Node::Item(hir::Item {\n+                        node: ItemKind::Fn(.., body_id),\n+                        ..\n+                    })) |\n+                    Some(Node::ImplItem(hir::ImplItem {\n+                        node: hir::ImplItemKind::Method(_, body_id),\n+                        ..\n+                    })) |\n+                    Some(Node::TraitItem(hir::TraitItem {\n+                        node: hir::TraitItemKind::Method(.., hir::TraitMethod::Provided(body_id)),\n+                        ..\n+                    })) => {\n+                        let body = hir.body(*body_id);\n+                        sugg_call = body.arguments.iter()\n+                            .map(|arg| match &arg.pat.node {\n+                                hir::PatKind::Binding(_, _, ident, None)\n+                                if ident.name != kw::SelfLower => ident.to_string(),\n+                                _ => \"_\".to_string(),\n+                            }).collect::<Vec<_>>().join(\", \");\n+                    }\n+                    Some(Node::Ctor(hir::VariantData::Tuple(fields, _))) => {\n+                        sugg_call = fields.iter().map(|_| \"_\").collect::<Vec<_>>().join(\", \");\n+                        match hir.as_local_hir_id(def_id).and_then(|hir_id| hir.def_kind(hir_id)) {\n+                            Some(hir::def::DefKind::Ctor(hir::def::CtorOf::Variant, _)) => {\n+                                msg = \"instantiate this tuple variant\";\n+                            }\n+                            Some(hir::def::DefKind::Ctor(hir::def::CtorOf::Struct, _)) => {\n+                                msg = \"instantiate this tuple struct\";\n+                            }\n+                            _ => {}\n+                        }\n+                    }\n+                    Some(Node::ForeignItem(hir::ForeignItem {\n+                        node: hir::ForeignItemKind::Fn(_, idents, _),\n+                        ..\n+                    })) |\n+                    Some(Node::TraitItem(hir::TraitItem {\n+                        node: hir::TraitItemKind::Method(.., hir::TraitMethod::Required(idents)),\n+                        ..\n+                    })) => sugg_call = idents.iter()\n+                            .map(|ident| if ident.name != kw::SelfLower {\n+                                ident.to_string()\n+                            } else {\n+                                \"_\".to_string()\n+                            }).collect::<Vec<_>>()\n+                            .join(\", \"),\n+                    _ => {}\n+                }\n+            };\n+            if let Ok(code) = self.sess().source_map().span_to_snippet(expr.span) {\n+                err.span_suggestion(\n+                    expr.span,\n+                    &format!(\"use parentheses to {}\", msg),\n+                    format!(\"{}({})\", code, sugg_call),\n+                    applicability,\n+                );\n+                return true;\n+            }\n+        }\n+        false\n+    }\n+\n     pub fn suggest_ref_or_into(\n         &self,\n         err: &mut DiagnosticBuilder<'tcx>,\n@@ -3833,6 +3932,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 suggestion,\n                 Applicability::MachineApplicable,\n             );\n+        } else if let (ty::FnDef(def_id, ..), true) = (\n+            &found.sty,\n+            self.suggest_fn_call(err, expr, expected, found),\n+        ) {\n+            if let Some(sp) = self.tcx.hir().span_if_local(*def_id) {\n+                let sp = self.sess().source_map().def_span(sp);\n+                err.span_label(sp, &format!(\"{} defined here\", found));\n+            }\n         } else if !self.check_for_cast(err, expr, found, expected) {\n             let is_struct_pat_shorthand_field = self.is_hir_id_from_struct_pattern_shorthand_field(\n                 expr.hir_id,"}, {"sha": "d981740780e6f60efa21d3c89c8a6dcc9b3f00a2", "filename": "src/libserialize/collection_impls.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Flibserialize%2Fcollection_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Flibserialize%2Fcollection_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fcollection_impls.rs?ref=d19a359444295bab01de7ff44a9d72302e573bc9", "patch": "@@ -9,10 +9,7 @@ use std::sync::Arc;\n \n use smallvec::{Array, SmallVec};\n \n-impl<A> Encodable for SmallVec<A>\n-    where A: Array,\n-          A::Item: Encodable\n-{\n+impl<A: Array<Item: Encodable>> Encodable for SmallVec<A> {\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_seq(self.len(), |s| {\n             for (i, e) in self.iter().enumerate() {\n@@ -23,10 +20,7 @@ impl<A> Encodable for SmallVec<A>\n     }\n }\n \n-impl<A> Decodable for SmallVec<A>\n-    where A: Array,\n-          A::Item: Decodable\n-{\n+impl<A: Array<Item: Decodable>> Decodable for SmallVec<A> {\n     fn decode<D: Decoder>(d: &mut D) -> Result<SmallVec<A>, D::Error> {\n         d.read_seq(|d, len| {\n             let mut vec = SmallVec::with_capacity(len);"}, {"sha": "67a48ca4af9020faeaec9ce0e0ed617f6ef61fac", "filename": "src/libserialize/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Flibserialize%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Flibserialize%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Flib.rs?ref=d19a359444295bab01de7ff44a9d72302e573bc9", "patch": "@@ -13,6 +13,7 @@ Core encoding and decoding interfaces.\n #![feature(specialization)]\n #![feature(never_type)]\n #![feature(nll)]\n+#![feature(associated_type_bounds)]\n #![cfg_attr(test, feature(test))]\n \n pub use self::serialize::{Decoder, Encoder, Decodable, Encodable};"}, {"sha": "ba80d1b70049a11245c2bc0588b253524e7f7631", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 31, "deletions": 21, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=d19a359444295bab01de7ff44a9d72302e573bc9", "patch": "@@ -238,6 +238,7 @@\n #![feature(arbitrary_self_types)]\n #![feature(array_error_internals)]\n #![feature(asm)]\n+#![feature(associated_type_bounds)]\n #![feature(bind_by_move_pattern_guards)]\n #![feature(box_syntax)]\n #![feature(c_variadic)]\n@@ -326,16 +327,6 @@ use prelude::v1::*;\n // Access to Bencher, etc.\n #[cfg(test)] extern crate test;\n \n-// Re-export a few macros from core\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use core::{assert_eq, assert_ne, debug_assert, debug_assert_eq, debug_assert_ne};\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use core::{unreachable, unimplemented, write, writeln, todo};\n-// FIXME: change this to `#[allow(deprecated)]` when we update nightly compiler.\n-#[allow(deprecated_in_future)]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use core::r#try;\n-\n #[allow(unused_imports)] // macros from `alloc` are not used on all platforms\n #[macro_use]\n extern crate alloc as alloc_crate;\n@@ -520,33 +511,52 @@ mod std_detect;\n #[cfg(not(test))]\n pub use std_detect::detect;\n \n-// Document built-in macros in the crate root for consistency with libcore and existing tradition.\n-// FIXME: Attribute and derive macros are not reexported because rustdoc renders them\n-// as reexports rather than as macros, and that's not what we want.\n-#[cfg(rustdoc)]\n+// Re-export macros defined in libcore.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[allow(deprecated_in_future)]\n+pub use core::{\n+    // Stable\n+    assert_eq,\n+    assert_ne,\n+    debug_assert_eq,\n+    debug_assert_ne,\n+    debug_assert,\n+    r#try,\n+    unimplemented,\n+    unreachable,\n+    write,\n+    writeln,\n+    // Unstable\n+    todo,\n+};\n+\n+// Re-export built-in macros defined through libcore.\n+#[cfg(not(bootstrap))]\n #[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n-pub use crate::prelude::v1::{\n-    __rust_unstable_column,\n-    asm,\n+pub use core::{\n+    // Stable\n     assert,\n     cfg,\n     column,\n     compile_error,\n     concat,\n-    concat_idents,\n     env,\n     file,\n     format_args,\n-    format_args_nl,\n-    global_asm,\n     include,\n     include_bytes,\n     include_str,\n     line,\n-    log_syntax,\n     module_path,\n     option_env,\n     stringify,\n+    // Unstable\n+    __rust_unstable_column,\n+    asm,\n+    concat_idents,\n+    format_args_nl,\n+    global_asm,\n+    log_syntax,\n     trace_macros,\n };\n "}, {"sha": "75dd0d429c214ce927d13e90cb20bf1e34dc3c0a", "filename": "src/libstd/sys/sgx/abi/usercalls/alloc.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Falloc.rs?ref=d19a359444295bab01de7ff44a9d72302e573bc9", "patch": "@@ -522,7 +522,11 @@ impl<T: ?Sized> Drop for User<T> where T: UserSafe {\n impl<T: CoerceUnsized<U>, U> CoerceUnsized<UserRef<U>> for UserRef<T> {}\n \n #[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n-impl<T, I: SliceIndex<[T]>> Index<I> for UserRef<[T]> where [T]: UserSafe, I::Output: UserSafe {\n+impl<T, I> Index<I> for UserRef<[T]>\n+where\n+    [T]: UserSafe,\n+    I: SliceIndex<[T], Output: UserSafe>,\n+{\n     type Output = UserRef<I::Output>;\n \n     #[inline]\n@@ -538,7 +542,11 @@ impl<T, I: SliceIndex<[T]>> Index<I> for UserRef<[T]> where [T]: UserSafe, I::Ou\n }\n \n #[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n-impl<T, I: SliceIndex<[T]>> IndexMut<I> for UserRef<[T]> where [T]: UserSafe, I::Output: UserSafe {\n+impl<T, I> IndexMut<I> for UserRef<[T]>\n+where\n+    [T]: UserSafe,\n+    I: SliceIndex<[T], Output: UserSafe>,\n+{\n     #[inline]\n     fn index_mut(&mut self, index: I) -> &mut UserRef<I::Output> {\n         unsafe {"}, {"sha": "9a3195b1165b10d17798ae7f6f669aa56e7f0dc4", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=d19a359444295bab01de7ff44a9d72302e573bc9", "patch": "@@ -6,6 +6,7 @@ use crate::config::StripUnconfigured;\n use crate::ext::base::*;\n use crate::ext::proc_macro::collect_derives;\n use crate::ext::hygiene::{ExpnId, SyntaxContext, ExpnInfo, ExpnKind};\n+use crate::ext::tt::macro_rules::annotate_err_with_kind;\n use crate::ext::placeholders::{placeholder, PlaceholderExpander};\n use crate::feature_gate::{self, Features, GateIssue, is_builtin_attr, emit_feature_err};\n use crate::mut_visit::*;\n@@ -686,12 +687,13 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         );\n     }\n \n-    fn parse_ast_fragment(&mut self,\n-                          toks: TokenStream,\n-                          kind: AstFragmentKind,\n-                          path: &Path,\n-                          span: Span)\n-                          -> AstFragment {\n+    fn parse_ast_fragment(\n+        &mut self,\n+        toks: TokenStream,\n+        kind: AstFragmentKind,\n+        path: &Path,\n+        span: Span,\n+    ) -> AstFragment {\n         let mut parser = self.cx.new_parser_from_tts(&toks.into_trees().collect::<Vec<_>>());\n         match parser.parse_ast_fragment(kind, false) {\n             Ok(fragment) => {\n@@ -700,6 +702,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n             }\n             Err(mut err) => {\n                 err.set_span(span);\n+                annotate_err_with_kind(&mut err, kind, span);\n                 err.emit();\n                 self.cx.trace_macros_diag();\n                 kind.dummy(span)"}, {"sha": "b057a9ad44d0bd966a71ab5998211d9baf36ac7a", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 39, "deletions": 1, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=d19a359444295bab01de7ff44a9d72302e573bc9", "patch": "@@ -17,7 +17,7 @@ use crate::symbol::{kw, sym, Symbol};\n use crate::tokenstream::{DelimSpan, TokenStream, TokenTree};\n use crate::{ast, attr, attr::TransparencyError};\n \n-use errors::FatalError;\n+use errors::{DiagnosticBuilder, FatalError};\n use log::debug;\n use syntax_pos::Span;\n \n@@ -43,6 +43,18 @@ pub struct ParserAnyMacro<'a> {\n     arm_span: Span,\n }\n \n+pub fn annotate_err_with_kind(err: &mut DiagnosticBuilder<'_>, kind: AstFragmentKind, span: Span) {\n+    match kind {\n+        AstFragmentKind::Ty => {\n+            err.span_label(span, \"this macro call doesn't expand to a type\");\n+        }\n+        AstFragmentKind::Pat => {\n+            err.span_label(span, \"this macro call doesn't expand to a pattern\");\n+        }\n+        _ => {}\n+    };\n+}\n+\n impl<'a> ParserAnyMacro<'a> {\n     pub fn make(mut self: Box<ParserAnyMacro<'a>>, kind: AstFragmentKind) -> AstFragment {\n         let ParserAnyMacro { site_span, macro_ident, ref mut parser, arm_span } = *self;\n@@ -70,6 +82,32 @@ impl<'a> ParserAnyMacro<'a> {\n             } else if !parser.sess.source_map().span_to_filename(parser.token.span).is_real() {\n                 e.span_label(site_span, \"in this macro invocation\");\n             }\n+            match kind {\n+                AstFragmentKind::Pat if macro_ident.name == sym::vec => {\n+                    let mut suggestion = None;\n+                    if let Ok(code) = parser.sess.source_map().span_to_snippet(site_span) {\n+                        if let Some(bang) = code.find('!') {\n+                            suggestion = Some(code[bang + 1..].to_string());\n+                        }\n+                    }\n+                    if let Some(suggestion) = suggestion {\n+                        e.span_suggestion(\n+                            site_span,\n+                            \"use a slice pattern here instead\",\n+                            suggestion,\n+                            Applicability::MachineApplicable,\n+                        );\n+                    } else {\n+                        e.span_label(\n+                            site_span,\n+                            \"use a slice pattern here instead\",\n+                        );\n+                    }\n+                    e.help(\"for more information, see https://doc.rust-lang.org/edition-guide/\\\n+                            rust-2018/slice-patterns.html\");\n+                }\n+                _ => annotate_err_with_kind(&mut e, kind, site_span),\n+            };\n             e\n         }));\n "}, {"sha": "30e16592113b623a4b0d62d901b57b5234807979", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 50, "deletions": 20, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=d19a359444295bab01de7ff44a9d72302e573bc9", "patch": "@@ -2052,9 +2052,23 @@ impl<'a> Parser<'a> {\n                 while self.token != token::CloseDelim(token::Paren) {\n                     es.push(match self.parse_expr() {\n                         Ok(es) => es,\n-                        Err(err) => {\n+                        Err(mut err) => {\n                             // recover from parse error in tuple list\n-                            return Ok(self.recover_seq_parse_error(token::Paren, lo, Err(err)));\n+                            match self.token.kind {\n+                                token::Ident(name, false)\n+                                if name == kw::Underscore && self.look_ahead(1, |t| {\n+                                    t == &token::Comma\n+                                }) => {\n+                                    // Special-case handling of `Foo<(_, _, _)>`\n+                                    err.emit();\n+                                    let sp = self.token.span;\n+                                    self.bump();\n+                                    self.mk_expr(sp, ExprKind::Err, ThinVec::new())\n+                                }\n+                                _ => return Ok(\n+                                    self.recover_seq_parse_error(token::Paren, lo, Err(err)),\n+                                ),\n+                            }\n                         }\n                     });\n                     recovered = self.expect_one_of(\n@@ -2456,37 +2470,35 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parses `a.b` or `a(13)` or `a[4]` or just `a`.\n-    fn parse_dot_or_call_expr(&mut self,\n-                                  already_parsed_attrs: Option<ThinVec<Attribute>>)\n-                                  -> PResult<'a, P<Expr>> {\n+    fn parse_dot_or_call_expr(\n+        &mut self,\n+        already_parsed_attrs: Option<ThinVec<Attribute>>,\n+    ) -> PResult<'a, P<Expr>> {\n         let attrs = self.parse_or_use_outer_attributes(already_parsed_attrs)?;\n \n         let b = self.parse_bottom_expr();\n         let (span, b) = self.interpolated_or_expr_span(b)?;\n         self.parse_dot_or_call_expr_with(b, span, attrs)\n     }\n \n-    fn parse_dot_or_call_expr_with(&mut self,\n-                                       e0: P<Expr>,\n-                                       lo: Span,\n-                                       mut attrs: ThinVec<Attribute>)\n-                                       -> PResult<'a, P<Expr>> {\n+    fn parse_dot_or_call_expr_with(\n+        &mut self,\n+        e0: P<Expr>,\n+        lo: Span,\n+        mut attrs: ThinVec<Attribute>,\n+    ) -> PResult<'a, P<Expr>> {\n         // Stitch the list of outer attributes onto the return value.\n         // A little bit ugly, but the best way given the current code\n         // structure\n-        self.parse_dot_or_call_expr_with_(e0, lo)\n-        .map(|expr|\n+        self.parse_dot_or_call_expr_with_(e0, lo).map(|expr|\n             expr.map(|mut expr| {\n                 attrs.extend::<Vec<_>>(expr.attrs.into());\n                 expr.attrs = attrs;\n                 match expr.node {\n                     ExprKind::If(..) if !expr.attrs.is_empty() => {\n                         // Just point to the first attribute in there...\n                         let span = expr.attrs[0].span;\n-\n-                        self.span_err(span,\n-                            \"attributes are not yet allowed on `if` \\\n-                            expressions\");\n+                        self.span_err(span, \"attributes are not yet allowed on `if` expressions\");\n                     }\n                     _ => {}\n                 }\n@@ -2624,7 +2636,24 @@ impl<'a> Parser<'a> {\n     }\n \n     fn parse_paren_expr_seq(&mut self) -> PResult<'a, Vec<P<Expr>>> {\n-        self.parse_paren_comma_seq(|p| p.parse_expr()).map(|(r, _)| r)\n+        self.parse_paren_comma_seq(|p| {\n+            match p.parse_expr() {\n+                Ok(expr) => Ok(expr),\n+                Err(mut err) => match p.token.kind {\n+                    token::Ident(name, false)\n+                    if name == kw::Underscore && p.look_ahead(1, |t| {\n+                        t == &token::Comma\n+                    }) => {\n+                        // Special-case handling of `foo(_, _, _)`\n+                        err.emit();\n+                        let sp = p.token.span;\n+                        p.bump();\n+                        Ok(p.mk_expr(sp, ExprKind::Err, ThinVec::new()))\n+                    }\n+                    _ => Err(err),\n+                },\n+            }\n+        }).map(|(r, _)| r)\n     }\n \n     crate fn process_potential_macro_variable(&mut self) {\n@@ -2806,9 +2835,10 @@ impl<'a> Parser<'a> {\n     /// This parses an expression accounting for associativity and precedence of the operators in\n     /// the expression.\n     #[inline]\n-    fn parse_assoc_expr(&mut self,\n-                            already_parsed_attrs: Option<ThinVec<Attribute>>)\n-                            -> PResult<'a, P<Expr>> {\n+    fn parse_assoc_expr(\n+        &mut self,\n+        already_parsed_attrs: Option<ThinVec<Attribute>>,\n+    ) -> PResult<'a, P<Expr>> {\n         self.parse_assoc_expr_with(0, already_parsed_attrs.into())\n     }\n "}, {"sha": "f3f2d14584ef7c9d91ed0dff1eb4fb596f48f426", "filename": "src/test/ui/async-await/async-block-control-flow-static-semantics.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Ftest%2Fui%2Fasync-await%2Fasync-block-control-flow-static-semantics.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Ftest%2Fui%2Fasync-await%2Fasync-block-control-flow-static-semantics.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fasync-block-control-flow-static-semantics.stderr?ref=d19a359444295bab01de7ff44a9d72302e573bc9", "patch": "@@ -16,7 +16,7 @@ error[E0308]: mismatched types\n LL | fn return_targets_async_block_not_fn() -> u8 {\n    |    ---------------------------------      ^^ expected u8, found ()\n    |    |\n-   |    this function's body doesn't return\n+   |    implicitly returns `()` as its body has no tail or `return` expression\n    |\n    = note: expected type `u8`\n               found type `()`\n@@ -57,7 +57,7 @@ error[E0308]: mismatched types\n LL | fn rethrow_targets_async_block_not_fn() -> Result<u8, MyErr> {\n    |    ----------------------------------      ^^^^^^^^^^^^^^^^^ expected enum `std::result::Result`, found ()\n    |    |\n-   |    this function's body doesn't return\n+   |    implicitly returns `()` as its body has no tail or `return` expression\n    |\n    = note: expected type `std::result::Result<u8, MyErr>`\n               found type `()`\n@@ -68,7 +68,7 @@ error[E0308]: mismatched types\n LL | fn rethrow_targets_async_block_not_async_fn() -> Result<u8, MyErr> {\n    |    ----------------------------------------      ^^^^^^^^^^^^^^^^^ expected enum `std::result::Result`, found ()\n    |    |\n-   |    this function's body doesn't return\n+   |    implicitly returns `()` as its body has no tail or `return` expression\n    |\n    = note: expected type `std::result::Result<u8, MyErr>`\n               found type `()`"}, {"sha": "f4984ca446309d83d88ba24dd63387b1efa5afaf", "filename": "src/test/ui/block-result/consider-removing-last-semi.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Ftest%2Fui%2Fblock-result%2Fconsider-removing-last-semi.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Ftest%2Fui%2Fblock-result%2Fconsider-removing-last-semi.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fblock-result%2Fconsider-removing-last-semi.stderr?ref=d19a359444295bab01de7ff44a9d72302e573bc9", "patch": "@@ -4,7 +4,7 @@ error[E0308]: mismatched types\n LL | fn f() -> String {\n    |    -      ^^^^^^ expected struct `std::string::String`, found ()\n    |    |\n-   |    this function's body doesn't return\n+   |    implicitly returns `()` as its body has no tail or `return` expression\n LL |     0u8;\n LL |     \"bla\".to_string();\n    |                      - help: consider removing this semicolon\n@@ -18,7 +18,7 @@ error[E0308]: mismatched types\n LL | fn g() -> String {\n    |    -      ^^^^^^ expected struct `std::string::String`, found ()\n    |    |\n-   |    this function's body doesn't return\n+   |    implicitly returns `()` as its body has no tail or `return` expression\n LL |     \"this won't work\".to_string();\n LL |     \"removeme\".to_string();\n    |                           - help: consider removing this semicolon"}, {"sha": "cfb42c601279a9abdc5304b4a3a2fa8806310ffa", "filename": "src/test/ui/block-result/issue-11714.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Ftest%2Fui%2Fblock-result%2Fissue-11714.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Ftest%2Fui%2Fblock-result%2Fissue-11714.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fblock-result%2Fissue-11714.stderr?ref=d19a359444295bab01de7ff44a9d72302e573bc9", "patch": "@@ -4,7 +4,7 @@ error[E0308]: mismatched types\n LL | fn blah() -> i32 {\n    |    ----      ^^^ expected i32, found ()\n    |    |\n-   |    this function's body doesn't return\n+   |    implicitly returns `()` as its body has no tail or `return` expression\n ...\n LL |     ;\n    |     - help: consider removing this semicolon"}, {"sha": "f7cafab3d773bdc3250146dd61596ec369915721", "filename": "src/test/ui/block-result/issue-13428.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Ftest%2Fui%2Fblock-result%2Fissue-13428.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Ftest%2Fui%2Fblock-result%2Fissue-13428.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fblock-result%2Fissue-13428.stderr?ref=d19a359444295bab01de7ff44a9d72302e573bc9", "patch": "@@ -4,7 +4,7 @@ error[E0308]: mismatched types\n LL | fn foo() -> String {\n    |    ---      ^^^^^^ expected struct `std::string::String`, found ()\n    |    |\n-   |    this function's body doesn't return\n+   |    implicitly returns `()` as its body has no tail or `return` expression\n ...\n LL |     ;\n    |     - help: consider removing this semicolon\n@@ -18,7 +18,7 @@ error[E0308]: mismatched types\n LL | fn bar() -> String {\n    |    ---      ^^^^^^ expected struct `std::string::String`, found ()\n    |    |\n-   |    this function's body doesn't return\n+   |    implicitly returns `()` as its body has no tail or `return` expression\n LL |     \"foobar\".to_string()\n LL |     ;\n    |     - help: consider removing this semicolon"}, {"sha": "955793e8586e7d221e2253632019a8caa08088f6", "filename": "src/test/ui/coercion/coercion-missing-tail-expected-type.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Ftest%2Fui%2Fcoercion%2Fcoercion-missing-tail-expected-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Ftest%2Fui%2Fcoercion%2Fcoercion-missing-tail-expected-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoercion%2Fcoercion-missing-tail-expected-type.stderr?ref=d19a359444295bab01de7ff44a9d72302e573bc9", "patch": "@@ -4,7 +4,7 @@ error[E0308]: mismatched types\n LL | fn plus_one(x: i32) -> i32 {\n    |    --------            ^^^ expected i32, found ()\n    |    |\n-   |    this function's body doesn't return\n+   |    implicitly returns `()` as its body has no tail or `return` expression\n LL |     x + 1;\n    |          - help: consider removing this semicolon\n    |\n@@ -17,7 +17,7 @@ error[E0308]: mismatched types\n LL | fn foo() -> Result<u8, u64> {\n    |    ---      ^^^^^^^^^^^^^^^ expected enum `std::result::Result`, found ()\n    |    |\n-   |    this function's body doesn't return\n+   |    implicitly returns `()` as its body has no tail or `return` expression\n LL |     Ok(1);\n    |          - help: consider removing this semicolon\n    |"}, {"sha": "67470f854cedfcf572d11d3c8a2a9d7e581d196e", "filename": "src/test/ui/imports/issue-53512.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Ftest%2Fui%2Fimports%2Fissue-53512.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Ftest%2Fui%2Fimports%2Fissue-53512.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimports%2Fissue-53512.rs?ref=d19a359444295bab01de7ff44a9d72302e573bc9", "patch": "@@ -1,6 +1,7 @@\n // Macro from prelude is shadowed by non-existent import recovered as `Res::Err`.\n \n-use std::assert; //~ ERROR unresolved import `std::assert`\n+mod m {}\n+use m::assert; //~ ERROR unresolved import `m::assert`\n \n fn main() {\n     assert!(true);"}, {"sha": "05fe111b38bc6b7db5418cae5d027a2219daa0bd", "filename": "src/test/ui/imports/issue-53512.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Ftest%2Fui%2Fimports%2Fissue-53512.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Ftest%2Fui%2Fimports%2Fissue-53512.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimports%2Fissue-53512.stderr?ref=d19a359444295bab01de7ff44a9d72302e573bc9", "patch": "@@ -1,8 +1,8 @@\n-error[E0432]: unresolved import `std::assert`\n-  --> $DIR/issue-53512.rs:3:5\n+error[E0432]: unresolved import `m::assert`\n+  --> $DIR/issue-53512.rs:4:5\n    |\n-LL | use std::assert;\n-   |     ^^^^^^^^^^^ no `assert` in the root\n+LL | use m::assert;\n+   |     ^^^^^^^^^ no `assert` in `m`\n \n error: aborting due to previous error\n "}, {"sha": "7678984a518ba89bdc84ada86fef76bb10e00b41", "filename": "src/test/ui/issues/issue-27042.stderr", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Ftest%2Fui%2Fissues%2Fissue-27042.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Ftest%2Fui%2Fissues%2Fissue-27042.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-27042.stderr?ref=d19a359444295bab01de7ff44a9d72302e573bc9", "patch": "@@ -12,10 +12,13 @@ error[E0308]: mismatched types\n   --> $DIR/issue-27042.rs:6:16\n    |\n LL |         loop { break };\n-   |                ^^^^^ expected (), found i32\n+   |                ^^^^^\n+   |                |\n+   |                expected i32, found ()\n+   |                help: give it a value of the expected type: `break 42`\n    |\n-   = note: expected type `()`\n-              found type `i32`\n+   = note: expected type `i32`\n+              found type `()`\n \n error[E0308]: mismatched types\n   --> $DIR/issue-27042.rs:8:9"}, {"sha": "6256dc0c550226f3dfe774e26199cc437d02bc25", "filename": "src/test/ui/issues/issue-32323.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Ftest%2Fui%2Fissues%2Fissue-32323.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Ftest%2Fui%2Fissues%2Fissue-32323.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-32323.stderr?ref=d19a359444295bab01de7ff44a9d72302e573bc9", "patch": "@@ -4,7 +4,7 @@ error[E0308]: mismatched types\n LL | pub fn f<'a, T: Tr<'a>>() -> <T as Tr<'a>>::Out {}\n    |        -                     ^^^^^^^^^^^^^^^^^^ expected associated type, found ()\n    |        |\n-   |        this function's body doesn't return\n+   |        implicitly returns `()` as its body has no tail or `return` expression\n    |\n    = note: expected type `<T as Tr<'a>>::Out`\n               found type `()`"}, {"sha": "4457d71cbb4a7b132df872e73bf31f5ba56cecf7", "filename": "src/test/ui/issues/issue-34334.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Ftest%2Fui%2Fissues%2Fissue-34334.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Ftest%2Fui%2Fissues%2Fissue-34334.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-34334.rs?ref=d19a359444295bab01de7ff44a9d72302e573bc9", "patch": "@@ -5,6 +5,7 @@ fn main () {\n     //~| ERROR mismatched types\n     //~| ERROR invalid left-hand side expression\n     //~| ERROR expected expression, found reserved identifier `_`\n+    //~| ERROR expected expression, found reserved identifier `_`\n     let sr2: Vec<(u32, _, _)> = sr.iter().map(|(faction, th_sender, th_receiver)| {}).collect();\n     //~^ ERROR no method named `iter` found for type `()` in the current scope\n }"}, {"sha": "7f89caf92abe14a0ed945dbe611a50b7c7435328", "filename": "src/test/ui/issues/issue-34334.stderr", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Ftest%2Fui%2Fissues%2Fissue-34334.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Ftest%2Fui%2Fissues%2Fissue-34334.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-34334.stderr?ref=d19a359444295bab01de7ff44a9d72302e573bc9", "patch": "@@ -4,6 +4,12 @@ error: expected expression, found reserved identifier `_`\n LL |     let sr: Vec<(u32, _, _) = vec![];\n    |                       ^ expected expression\n \n+error: expected expression, found reserved identifier `_`\n+  --> $DIR/issue-34334.rs:2:26\n+   |\n+LL |     let sr: Vec<(u32, _, _) = vec![];\n+   |                          ^ expected expression\n+\n error: expected one of `,` or `>`, found `=`\n   --> $DIR/issue-34334.rs:2:29\n    |\n@@ -36,12 +42,12 @@ LL |     let sr: Vec<(u32, _, _) = vec![];\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^ left-hand of expression not valid\n \n error[E0599]: no method named `iter` found for type `()` in the current scope\n-  --> $DIR/issue-34334.rs:8:36\n+  --> $DIR/issue-34334.rs:9:36\n    |\n LL |     let sr2: Vec<(u32, _, _)> = sr.iter().map(|(faction, th_sender, th_receiver)| {}).collect();\n    |                                    ^^^^\n \n-error: aborting due to 6 previous errors\n+error: aborting due to 7 previous errors\n \n Some errors have detailed explanations: E0070, E0308, E0423, E0599.\n For more information about an error, try `rustc --explain E0070`."}, {"sha": "586146cbaa4ee9fc1eee9fce581fa7eaaa6a6616", "filename": "src/test/ui/issues/issue-35241.stderr", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Ftest%2Fui%2Fissues%2Fissue-35241.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Ftest%2Fui%2Fissues%2Fissue-35241.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-35241.stderr?ref=d19a359444295bab01de7ff44a9d72302e573bc9", "patch": "@@ -1,11 +1,14 @@\n error[E0308]: mismatched types\n   --> $DIR/issue-35241.rs:3:20\n    |\n+LL | struct Foo(u32);\n+   | ---------------- fn(u32) -> Foo {Foo} defined here\n+LL | \n LL | fn test() -> Foo { Foo }\n    |              ---   ^^^\n    |              |     |\n    |              |     expected struct `Foo`, found fn item\n-   |              |     did you mean `Foo(/* fields */)`?\n+   |              |     help: use parentheses to instantiate this tuple struct: `Foo(_)`\n    |              expected `Foo` because of return type\n    |\n    = note: expected type `Foo`"}, {"sha": "6d3e8b5ba2323a3c814be17ca77312c14107020d", "filename": "src/test/ui/issues/issue-43162.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Ftest%2Fui%2Fissues%2Fissue-43162.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Ftest%2Fui%2Fissues%2Fissue-43162.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-43162.stderr?ref=d19a359444295bab01de7ff44a9d72302e573bc9", "patch": "@@ -16,7 +16,7 @@ error[E0308]: mismatched types\n LL | fn foo() -> bool {\n    |    ---      ^^^^ expected bool, found ()\n    |    |\n-   |    this function's body doesn't return\n+   |    implicitly returns `()` as its body has no tail or `return` expression\n LL |\n LL |     break true;\n    |               - help: consider removing this semicolon"}, {"sha": "258ffe558e9ba283aef71e1330d709f3320ab936", "filename": "src/test/ui/issues/issue-44023.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Ftest%2Fui%2Fissues%2Fissue-44023.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Ftest%2Fui%2Fissues%2Fissue-44023.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-44023.stderr?ref=d19a359444295bab01de7ff44a9d72302e573bc9", "patch": "@@ -4,7 +4,7 @@ error[E0308]: mismatched types\n LL | fn \u10e1\u10d0\u10ed\u10db\u10d4\u10da\u10d0\u10d3_\u10d2\u10d4\u10db\u10e0\u10d8\u10d4\u10da\u10d8_\u10e1\u10d0\u10d3\u10d8\u10da\u10d8 ( ) -> isize {\n    |    ------------------------        ^^^^^ expected isize, found ()\n    |    |\n-   |    this function's body doesn't return\n+   |    implicitly returns `()` as its body has no tail or `return` expression\n    |\n    = note: expected type `isize`\n               found type `()`"}, {"sha": "ecf729e1032b15f63291a372b62e0264e35cbe57", "filename": "src/test/ui/issues/issue-6458-4.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Ftest%2Fui%2Fissues%2Fissue-6458-4.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Ftest%2Fui%2Fissues%2Fissue-6458-4.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-6458-4.stderr?ref=d19a359444295bab01de7ff44a9d72302e573bc9", "patch": "@@ -4,7 +4,7 @@ error[E0308]: mismatched types\n LL | fn foo(b: bool) -> Result<bool,String> {\n    |    ---             ^^^^^^^^^^^^^^^^^^^ expected enum `std::result::Result`, found ()\n    |    |\n-   |    this function's body doesn't return\n+   |    implicitly returns `()` as its body has no tail or `return` expression\n LL |     Err(\"bar\".to_string());\n    |                           - help: consider removing this semicolon\n    |"}, {"sha": "4baf351f7eb2d52c31bca83c3fc433780a706f1a", "filename": "src/test/ui/liveness/liveness-forgot-ret.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Ftest%2Fui%2Fliveness%2Fliveness-forgot-ret.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Ftest%2Fui%2Fliveness%2Fliveness-forgot-ret.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fliveness%2Fliveness-forgot-ret.stderr?ref=d19a359444295bab01de7ff44a9d72302e573bc9", "patch": "@@ -4,7 +4,7 @@ error[E0308]: mismatched types\n LL | fn f(a: isize) -> isize { if god_exists(a) { return 5; }; }\n    |    -              ^^^^^ expected isize, found ()\n    |    |\n-   |    this function's body doesn't return\n+   |    implicitly returns `()` as its body has no tail or `return` expression\n    |\n    = note: expected type `isize`\n               found type `()`"}, {"sha": "1f60560b45043928ddbd4cff2323fc71d2edcbeb", "filename": "src/test/ui/liveness/liveness-missing-ret2.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Ftest%2Fui%2Fliveness%2Fliveness-missing-ret2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Ftest%2Fui%2Fliveness%2Fliveness-missing-ret2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fliveness%2Fliveness-missing-ret2.stderr?ref=d19a359444295bab01de7ff44a9d72302e573bc9", "patch": "@@ -4,7 +4,7 @@ error[E0308]: mismatched types\n LL | fn f() -> isize {\n    |    -      ^^^^^ expected isize, found ()\n    |    |\n-   |    this function's body doesn't return\n+   |    implicitly returns `()` as its body has no tail or `return` expression\n    |\n    = note: expected type `isize`\n               found type `()`"}, {"sha": "2497d93daa494628cbd367d3247addec99c8ae49", "filename": "src/test/ui/liveness/liveness-return-last-stmt-semi.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Ftest%2Fui%2Fliveness%2Fliveness-return-last-stmt-semi.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Ftest%2Fui%2Fliveness%2Fliveness-return-last-stmt-semi.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fliveness%2Fliveness-return-last-stmt-semi.stderr?ref=d19a359444295bab01de7ff44a9d72302e573bc9", "patch": "@@ -5,7 +5,7 @@ LL | macro_rules! test { () => { fn foo() -> i32 { 1; } } }\n    |                                ---      ^^^    - help: consider removing this semicolon\n    |                                |        |\n    |                                |        expected i32, found ()\n-   |                                this function's body doesn't return\n+   |                                implicitly returns `()` as its body has no tail or `return` expression\n ...\n LL |     test!();\n    |     -------- in this macro invocation\n@@ -19,7 +19,7 @@ error[E0308]: mismatched types\n LL | fn no_return() -> i32 {}\n    |    ---------      ^^^ expected i32, found ()\n    |    |\n-   |    this function's body doesn't return\n+   |    implicitly returns `()` as its body has no tail or `return` expression\n    |\n    = note: expected type `i32`\n               found type `()`\n@@ -30,7 +30,7 @@ error[E0308]: mismatched types\n LL | fn bar(x: u32) -> u32 {\n    |    ---            ^^^ expected u32, found ()\n    |    |\n-   |    this function's body doesn't return\n+   |    implicitly returns `()` as its body has no tail or `return` expression\n LL |     x * 2;\n    |          - help: consider removing this semicolon\n    |\n@@ -43,7 +43,7 @@ error[E0308]: mismatched types\n LL | fn baz(x: u64) -> u32 {\n    |    ---            ^^^ expected u32, found ()\n    |    |\n-   |    this function's body doesn't return\n+   |    implicitly returns `()` as its body has no tail or `return` expression\n    |\n    = note: expected type `u32`\n               found type `()`"}, {"sha": "fef5b5873068f3cf8e19bd3d7b30b4813ee8dee3", "filename": "src/test/ui/loops/loop-break-value.stderr", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Ftest%2Fui%2Floops%2Floop-break-value.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Ftest%2Fui%2Floops%2Floop-break-value.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Floops%2Floop-break-value.stderr?ref=d19a359444295bab01de7ff44a9d72302e573bc9", "patch": "@@ -90,10 +90,10 @@ error[E0308]: mismatched types\n   --> $DIR/loop-break-value.rs:4:31\n    |\n LL |     let val: ! = loop { break break; };\n-   |                               ^^^^^ expected (), found !\n+   |                               ^^^^^ expected !, found ()\n    |\n-   = note: expected type `()`\n-              found type `!`\n+   = note: expected type `!`\n+              found type `()`\n \n error[E0308]: mismatched types\n   --> $DIR/loop-break-value.rs:11:19\n@@ -153,10 +153,13 @@ error[E0308]: mismatched types\n   --> $DIR/loop-break-value.rs:90:9\n    |\n LL |         break;\n-   |         ^^^^^ expected (), found integer\n+   |         ^^^^^\n+   |         |\n+   |         expected integer, found ()\n+   |         help: give it a value of the expected type: `break value`\n    |\n-   = note: expected type `()`\n-              found type `{integer}`\n+   = note: expected type `{integer}`\n+              found type `()`\n \n error: aborting due to 16 previous errors\n "}, {"sha": "8b9468cacc1f9d5a11a049bf20d86e7b253abf2d", "filename": "src/test/ui/loops/loop-labeled-break-value.stderr", "status": "modified", "additions": 18, "deletions": 9, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Ftest%2Fui%2Floops%2Floop-labeled-break-value.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Ftest%2Fui%2Floops%2Floop-labeled-break-value.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Floops%2Floop-labeled-break-value.stderr?ref=d19a359444295bab01de7ff44a9d72302e573bc9", "patch": "@@ -2,28 +2,37 @@ error[E0308]: mismatched types\n   --> $DIR/loop-labeled-break-value.rs:3:29\n    |\n LL |         let _: i32 = loop { break };\n-   |                             ^^^^^ expected (), found i32\n+   |                             ^^^^^\n+   |                             |\n+   |                             expected i32, found ()\n+   |                             help: give it a value of the expected type: `break 42`\n    |\n-   = note: expected type `()`\n-              found type `i32`\n+   = note: expected type `i32`\n+              found type `()`\n \n error[E0308]: mismatched types\n   --> $DIR/loop-labeled-break-value.rs:6:37\n    |\n LL |         let _: i32 = 'inner: loop { break 'inner };\n-   |                                     ^^^^^^^^^^^^ expected (), found i32\n+   |                                     ^^^^^^^^^^^^\n+   |                                     |\n+   |                                     expected i32, found ()\n+   |                                     help: give it a value of the expected type: `break 'inner 42`\n    |\n-   = note: expected type `()`\n-              found type `i32`\n+   = note: expected type `i32`\n+              found type `()`\n \n error[E0308]: mismatched types\n   --> $DIR/loop-labeled-break-value.rs:9:45\n    |\n LL |         let _: i32 = 'inner2: loop { loop { break 'inner2 } };\n-   |                                             ^^^^^^^^^^^^^ expected (), found i32\n+   |                                             ^^^^^^^^^^^^^\n+   |                                             |\n+   |                                             expected i32, found ()\n+   |                                             help: give it a value of the expected type: `break 'inner2 42`\n    |\n-   = note: expected type `()`\n-              found type `i32`\n+   = note: expected type `i32`\n+              found type `()`\n \n error: aborting due to 3 previous errors\n "}, {"sha": "3758bbf9f6f31c3be80d95f5dcf142e6671103d5", "filename": "src/test/ui/loops/loop-properly-diverging-2.stderr", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Ftest%2Fui%2Floops%2Floop-properly-diverging-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Ftest%2Fui%2Floops%2Floop-properly-diverging-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Floops%2Floop-properly-diverging-2.stderr?ref=d19a359444295bab01de7ff44a9d72302e573bc9", "patch": "@@ -2,10 +2,13 @@ error[E0308]: mismatched types\n   --> $DIR/loop-properly-diverging-2.rs:2:23\n    |\n LL |   let x: i32 = loop { break };\n-   |                       ^^^^^ expected (), found i32\n+   |                       ^^^^^\n+   |                       |\n+   |                       expected i32, found ()\n+   |                       help: give it a value of the expected type: `break 42`\n    |\n-   = note: expected type `()`\n-              found type `i32`\n+   = note: expected type `i32`\n+              found type `()`\n \n error: aborting due to previous error\n "}, {"sha": "ac82f343acc022de1be663c4237ec1636b2288cc", "filename": "src/test/ui/macros/builtin-prelude-no-accidents.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Ftest%2Fui%2Fmacros%2Fbuiltin-prelude-no-accidents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Ftest%2Fui%2Fmacros%2Fbuiltin-prelude-no-accidents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fbuiltin-prelude-no-accidents.rs?ref=d19a359444295bab01de7ff44a9d72302e573bc9", "patch": "@@ -0,0 +1,8 @@\n+// Names of public modules in libstd and libcore don't accidentally get into prelude\n+// because macros with the same names are in prelude.\n+\n+fn main() {\n+    env::current_dir; //~ ERROR use of undeclared type or module `env`\n+    type A = panic::PanicInfo; //~ ERROR use of undeclared type or module `panic`\n+    type B = vec::Vec<u8>; //~ ERROR use of undeclared type or module `vec`\n+}"}, {"sha": "914e906df58b3d41188361def1c3bd00fc8d81bb", "filename": "src/test/ui/macros/builtin-prelude-no-accidents.stderr", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Ftest%2Fui%2Fmacros%2Fbuiltin-prelude-no-accidents.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Ftest%2Fui%2Fmacros%2Fbuiltin-prelude-no-accidents.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fbuiltin-prelude-no-accidents.stderr?ref=d19a359444295bab01de7ff44a9d72302e573bc9", "patch": "@@ -0,0 +1,21 @@\n+error[E0433]: failed to resolve: use of undeclared type or module `env`\n+  --> $DIR/builtin-prelude-no-accidents.rs:5:5\n+   |\n+LL |     env::current_dir;\n+   |     ^^^ use of undeclared type or module `env`\n+\n+error[E0433]: failed to resolve: use of undeclared type or module `panic`\n+  --> $DIR/builtin-prelude-no-accidents.rs:6:14\n+   |\n+LL |     type A = panic::PanicInfo;\n+   |              ^^^^^ use of undeclared type or module `panic`\n+\n+error[E0433]: failed to resolve: use of undeclared type or module `vec`\n+  --> $DIR/builtin-prelude-no-accidents.rs:7:14\n+   |\n+LL |     type B = vec::Vec<u8>;\n+   |              ^^^ use of undeclared type or module `vec`\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0433`."}, {"sha": "33de3d5184b1fa20073abe15e269e9038b2bef61", "filename": "src/test/ui/macros/builtin-std-paths-fail.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Ftest%2Fui%2Fmacros%2Fbuiltin-std-paths-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Ftest%2Fui%2Fmacros%2Fbuiltin-std-paths-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fbuiltin-std-paths-fail.rs?ref=d19a359444295bab01de7ff44a9d72302e573bc9", "patch": "@@ -0,0 +1,21 @@\n+#[derive(\n+    core::RustcDecodable, //~ ERROR could not find `RustcDecodable` in `core`\n+    core::RustcDecodable, //~ ERROR could not find `RustcDecodable` in `core`\n+)]\n+#[core::bench] //~ ERROR could not find `bench` in `core`\n+#[core::global_allocator] //~ ERROR could not find `global_allocator` in `core`\n+#[core::test_case] //~ ERROR could not find `test_case` in `core`\n+#[core::test] //~ ERROR could not find `test` in `core`\n+struct Core;\n+\n+#[derive(\n+    std::RustcDecodable, //~ ERROR could not find `RustcDecodable` in `std`\n+    std::RustcDecodable, //~ ERROR could not find `RustcDecodable` in `std`\n+)]\n+#[std::bench] //~ ERROR could not find `bench` in `std`\n+#[std::global_allocator] //~ ERROR could not find `global_allocator` in `std`\n+#[std::test_case] //~ ERROR could not find `test_case` in `std`\n+#[std::test] //~ ERROR could not find `test` in `std`\n+struct Std;\n+\n+fn main() {}"}, {"sha": "6de689076b8490a99d3b8beb09c8d93dbd6442df", "filename": "src/test/ui/macros/builtin-std-paths-fail.stderr", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Ftest%2Fui%2Fmacros%2Fbuiltin-std-paths-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Ftest%2Fui%2Fmacros%2Fbuiltin-std-paths-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fbuiltin-std-paths-fail.stderr?ref=d19a359444295bab01de7ff44a9d72302e573bc9", "patch": "@@ -0,0 +1,75 @@\n+error[E0433]: failed to resolve: could not find `bench` in `core`\n+  --> $DIR/builtin-std-paths-fail.rs:5:9\n+   |\n+LL | #[core::bench]\n+   |         ^^^^^ could not find `bench` in `core`\n+\n+error[E0433]: failed to resolve: could not find `global_allocator` in `core`\n+  --> $DIR/builtin-std-paths-fail.rs:6:9\n+   |\n+LL | #[core::global_allocator]\n+   |         ^^^^^^^^^^^^^^^^ could not find `global_allocator` in `core`\n+\n+error[E0433]: failed to resolve: could not find `test_case` in `core`\n+  --> $DIR/builtin-std-paths-fail.rs:7:9\n+   |\n+LL | #[core::test_case]\n+   |         ^^^^^^^^^ could not find `test_case` in `core`\n+\n+error[E0433]: failed to resolve: could not find `test` in `core`\n+  --> $DIR/builtin-std-paths-fail.rs:8:9\n+   |\n+LL | #[core::test]\n+   |         ^^^^ could not find `test` in `core`\n+\n+error[E0433]: failed to resolve: could not find `RustcDecodable` in `core`\n+  --> $DIR/builtin-std-paths-fail.rs:2:11\n+   |\n+LL |     core::RustcDecodable,\n+   |           ^^^^^^^^^^^^^^ could not find `RustcDecodable` in `core`\n+\n+error[E0433]: failed to resolve: could not find `RustcDecodable` in `core`\n+  --> $DIR/builtin-std-paths-fail.rs:3:11\n+   |\n+LL |     core::RustcDecodable,\n+   |           ^^^^^^^^^^^^^^ could not find `RustcDecodable` in `core`\n+\n+error[E0433]: failed to resolve: could not find `bench` in `std`\n+  --> $DIR/builtin-std-paths-fail.rs:15:8\n+   |\n+LL | #[std::bench]\n+   |        ^^^^^ could not find `bench` in `std`\n+\n+error[E0433]: failed to resolve: could not find `global_allocator` in `std`\n+  --> $DIR/builtin-std-paths-fail.rs:16:8\n+   |\n+LL | #[std::global_allocator]\n+   |        ^^^^^^^^^^^^^^^^ could not find `global_allocator` in `std`\n+\n+error[E0433]: failed to resolve: could not find `test_case` in `std`\n+  --> $DIR/builtin-std-paths-fail.rs:17:8\n+   |\n+LL | #[std::test_case]\n+   |        ^^^^^^^^^ could not find `test_case` in `std`\n+\n+error[E0433]: failed to resolve: could not find `test` in `std`\n+  --> $DIR/builtin-std-paths-fail.rs:18:8\n+   |\n+LL | #[std::test]\n+   |        ^^^^ could not find `test` in `std`\n+\n+error[E0433]: failed to resolve: could not find `RustcDecodable` in `std`\n+  --> $DIR/builtin-std-paths-fail.rs:12:10\n+   |\n+LL |     std::RustcDecodable,\n+   |          ^^^^^^^^^^^^^^ could not find `RustcDecodable` in `std`\n+\n+error[E0433]: failed to resolve: could not find `RustcDecodable` in `std`\n+  --> $DIR/builtin-std-paths-fail.rs:13:10\n+   |\n+LL |     std::RustcDecodable,\n+   |          ^^^^^^^^^^^^^^ could not find `RustcDecodable` in `std`\n+\n+error: aborting due to 12 previous errors\n+\n+For more information about this error, try `rustc --explain E0433`."}, {"sha": "2083f9ba3dc34105edd05f548b9ef2dcc3565d25", "filename": "src/test/ui/macros/builtin-std-paths.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Ftest%2Fui%2Fmacros%2Fbuiltin-std-paths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Ftest%2Fui%2Fmacros%2Fbuiltin-std-paths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fbuiltin-std-paths.rs?ref=d19a359444295bab01de7ff44a9d72302e573bc9", "patch": "@@ -0,0 +1,32 @@\n+// check-pass\n+\n+#[derive(\n+    core::clone::Clone,\n+    core::marker::Copy,\n+    core::fmt::Debug,\n+    core::default::Default,\n+    core::cmp::Eq,\n+    core::hash::Hash,\n+    core::cmp::Ord,\n+    core::cmp::PartialEq,\n+    core::cmp::PartialOrd,\n+)]\n+struct Core;\n+\n+#[derive(\n+    std::clone::Clone,\n+    std::marker::Copy,\n+    std::fmt::Debug,\n+    std::default::Default,\n+    std::cmp::Eq,\n+    std::hash::Hash,\n+    std::cmp::Ord,\n+    std::cmp::PartialEq,\n+    std::cmp::PartialOrd,\n+)]\n+struct Std;\n+\n+fn main() {\n+    core::column!();\n+    std::column!();\n+}"}, {"sha": "8f54023305e839b76a847f21d5f28a1923fe024e", "filename": "src/test/ui/match/match-arm-resolving-to-never.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Ftest%2Fui%2Fmatch%2Fmatch-arm-resolving-to-never.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Ftest%2Fui%2Fmatch%2Fmatch-arm-resolving-to-never.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmatch%2Fmatch-arm-resolving-to-never.rs?ref=d19a359444295bab01de7ff44a9d72302e573bc9", "patch": "@@ -0,0 +1,19 @@\n+enum E {\n+    A,\n+    B,\n+    C,\n+    D,\n+    E,\n+    F,\n+}\n+\n+fn main() {\n+    match E::F {\n+        E::A => 1,\n+        E::B => 2,\n+        E::C => 3,\n+        E::D => 4,\n+        E::E => unimplemented!(\"\"),\n+        E::F => \"\", //~ ERROR match arms have incompatible types\n+    };\n+}"}, {"sha": "24ce97f86e76023476b602b1eb16b73c44e7f514", "filename": "src/test/ui/match/match-arm-resolving-to-never.stderr", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Ftest%2Fui%2Fmatch%2Fmatch-arm-resolving-to-never.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Ftest%2Fui%2Fmatch%2Fmatch-arm-resolving-to-never.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmatch%2Fmatch-arm-resolving-to-never.stderr?ref=d19a359444295bab01de7ff44a9d72302e573bc9", "patch": "@@ -0,0 +1,22 @@\n+error[E0308]: match arms have incompatible types\n+  --> $DIR/match-arm-resolving-to-never.rs:17:17\n+   |\n+LL | /     match E::F {\n+LL | |         E::A => 1,\n+LL | |         E::B => 2,\n+LL | |         E::C => 3,\n+LL | |         E::D => 4,\n+LL | |         E::E => unimplemented!(\"\"),\n+   | |                 ------------------ this and all prior arms are found to be of type `{integer}`\n+LL | |         E::F => \"\",\n+   | |                 ^^ expected integer, found reference\n+LL | |     };\n+   | |_____- `match` arms have incompatible types\n+   |\n+   = note: expected type `{integer}`\n+              found type `&'static str`\n+   = note: this error originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "3c8ecdcfbcbe4679a7cf259bfdefe18b5242692f", "filename": "src/test/ui/missing/missing-return.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Ftest%2Fui%2Fmissing%2Fmissing-return.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Ftest%2Fui%2Fmissing%2Fmissing-return.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmissing%2Fmissing-return.stderr?ref=d19a359444295bab01de7ff44a9d72302e573bc9", "patch": "@@ -4,7 +4,7 @@ error[E0308]: mismatched types\n LL | fn f() -> isize { }\n    |    -      ^^^^^ expected isize, found ()\n    |    |\n-   |    this function's body doesn't return\n+   |    implicitly returns `()` as its body has no tail or `return` expression\n    |\n    = note: expected type `isize`\n               found type `()`"}, {"sha": "3d58b6fba0bafae14fe9ec43880108574cff5f47", "filename": "src/test/ui/parser/issue-62881.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Ftest%2Fui%2Fparser%2Fissue-62881.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Ftest%2Fui%2Fparser%2Fissue-62881.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-62881.stderr?ref=d19a359444295bab01de7ff44a9d72302e573bc9", "patch": "@@ -19,7 +19,7 @@ error[E0308]: mismatched types\n LL | fn f() -> isize { fn f() -> isize {} pub f<\n    |                      -      ^^^^^ expected isize, found ()\n    |                      |\n-   |                      this function's body doesn't return\n+   |                      implicitly returns `()` as its body has no tail or `return` expression\n    |\n    = note: expected type `isize`\n               found type `()`"}, {"sha": "39ce980964b77f8b3349e8238222e459f2a657a4", "filename": "src/test/ui/parser/issue-62895.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Ftest%2Fui%2Fparser%2Fissue-62895.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Ftest%2Fui%2Fparser%2Fissue-62895.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-62895.stderr?ref=d19a359444295bab01de7ff44a9d72302e573bc9", "patch": "@@ -38,7 +38,7 @@ error[E0308]: mismatched types\n LL | fn v() -> isize {\n    |    -      ^^^^^ expected isize, found ()\n    |    |\n-   |    this function's body doesn't return\n+   |    implicitly returns `()` as its body has no tail or `return` expression\n    |\n    = note: expected type `isize`\n               found type `()`"}, {"sha": "532d1ac1e2fb8552c9a0ad1bc00eb625549af4e5", "filename": "src/test/ui/privacy/privacy5.stderr", "status": "modified", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Ftest%2Fui%2Fprivacy%2Fprivacy5.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Ftest%2Fui%2Fprivacy%2Fprivacy5.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Fprivacy5.stderr?ref=d19a359444295bab01de7ff44a9d72302e573bc9", "patch": "@@ -3,288 +3,384 @@ error[E0603]: tuple struct `A` is private\n    |\n LL |     let a = a::A(());\n    |                ^\n+   |\n+   = note: a tuple struct constructor is private if any of its fields is private\n \n error[E0603]: tuple struct `B` is private\n   --> $DIR/privacy5.rs:52:16\n    |\n LL |     let b = a::B(2);\n    |                ^\n+   |\n+   = note: a tuple struct constructor is private if any of its fields is private\n \n error[E0603]: tuple struct `C` is private\n   --> $DIR/privacy5.rs:53:16\n    |\n LL |     let c = a::C(2, 3);\n    |                ^\n+   |\n+   = note: a tuple struct constructor is private if any of its fields is private\n \n error[E0603]: tuple struct `A` is private\n   --> $DIR/privacy5.rs:56:12\n    |\n LL |     let a::A(()) = a;\n    |            ^\n+   |\n+   = note: a tuple struct constructor is private if any of its fields is private\n \n error[E0603]: tuple struct `A` is private\n   --> $DIR/privacy5.rs:57:12\n    |\n LL |     let a::A(_) = a;\n    |            ^\n+   |\n+   = note: a tuple struct constructor is private if any of its fields is private\n \n error[E0603]: tuple struct `A` is private\n   --> $DIR/privacy5.rs:58:18\n    |\n LL |     match a { a::A(()) => {} }\n    |                  ^\n+   |\n+   = note: a tuple struct constructor is private if any of its fields is private\n \n error[E0603]: tuple struct `A` is private\n   --> $DIR/privacy5.rs:59:18\n    |\n LL |     match a { a::A(_) => {} }\n    |                  ^\n+   |\n+   = note: a tuple struct constructor is private if any of its fields is private\n \n error[E0603]: tuple struct `B` is private\n   --> $DIR/privacy5.rs:61:12\n    |\n LL |     let a::B(_) = b;\n    |            ^\n+   |\n+   = note: a tuple struct constructor is private if any of its fields is private\n \n error[E0603]: tuple struct `B` is private\n   --> $DIR/privacy5.rs:62:12\n    |\n LL |     let a::B(_b) = b;\n    |            ^\n+   |\n+   = note: a tuple struct constructor is private if any of its fields is private\n \n error[E0603]: tuple struct `B` is private\n   --> $DIR/privacy5.rs:63:18\n    |\n LL |     match b { a::B(_) => {} }\n    |                  ^\n+   |\n+   = note: a tuple struct constructor is private if any of its fields is private\n \n error[E0603]: tuple struct `B` is private\n   --> $DIR/privacy5.rs:64:18\n    |\n LL |     match b { a::B(_b) => {} }\n    |                  ^\n+   |\n+   = note: a tuple struct constructor is private if any of its fields is private\n \n error[E0603]: tuple struct `B` is private\n   --> $DIR/privacy5.rs:65:18\n    |\n LL |     match b { a::B(1) => {} a::B(_) => {} }\n    |                  ^\n+   |\n+   = note: a tuple struct constructor is private if any of its fields is private\n \n error[E0603]: tuple struct `B` is private\n   --> $DIR/privacy5.rs:65:32\n    |\n LL |     match b { a::B(1) => {} a::B(_) => {} }\n    |                                ^\n+   |\n+   = note: a tuple struct constructor is private if any of its fields is private\n \n error[E0603]: tuple struct `C` is private\n   --> $DIR/privacy5.rs:68:12\n    |\n LL |     let a::C(_, _) = c;\n    |            ^\n+   |\n+   = note: a tuple struct constructor is private if any of its fields is private\n \n error[E0603]: tuple struct `C` is private\n   --> $DIR/privacy5.rs:69:12\n    |\n LL |     let a::C(_a, _) = c;\n    |            ^\n+   |\n+   = note: a tuple struct constructor is private if any of its fields is private\n \n error[E0603]: tuple struct `C` is private\n   --> $DIR/privacy5.rs:70:12\n    |\n LL |     let a::C(_, _b) = c;\n    |            ^\n+   |\n+   = note: a tuple struct constructor is private if any of its fields is private\n \n error[E0603]: tuple struct `C` is private\n   --> $DIR/privacy5.rs:71:12\n    |\n LL |     let a::C(_a, _b) = c;\n    |            ^\n+   |\n+   = note: a tuple struct constructor is private if any of its fields is private\n \n error[E0603]: tuple struct `C` is private\n   --> $DIR/privacy5.rs:72:18\n    |\n LL |     match c { a::C(_, _) => {} }\n    |                  ^\n+   |\n+   = note: a tuple struct constructor is private if any of its fields is private\n \n error[E0603]: tuple struct `C` is private\n   --> $DIR/privacy5.rs:73:18\n    |\n LL |     match c { a::C(_a, _) => {} }\n    |                  ^\n+   |\n+   = note: a tuple struct constructor is private if any of its fields is private\n \n error[E0603]: tuple struct `C` is private\n   --> $DIR/privacy5.rs:74:18\n    |\n LL |     match c { a::C(_, _b) => {} }\n    |                  ^\n+   |\n+   = note: a tuple struct constructor is private if any of its fields is private\n \n error[E0603]: tuple struct `C` is private\n   --> $DIR/privacy5.rs:75:18\n    |\n LL |     match c { a::C(_a, _b) => {} }\n    |                  ^\n+   |\n+   = note: a tuple struct constructor is private if any of its fields is private\n \n error[E0603]: tuple struct `A` is private\n   --> $DIR/privacy5.rs:83:17\n    |\n LL |     let a2 = a::A;\n    |                 ^\n+   |\n+   = note: a tuple struct constructor is private if any of its fields is private\n \n error[E0603]: tuple struct `B` is private\n   --> $DIR/privacy5.rs:84:17\n    |\n LL |     let b2 = a::B;\n    |                 ^\n+   |\n+   = note: a tuple struct constructor is private if any of its fields is private\n \n error[E0603]: tuple struct `C` is private\n   --> $DIR/privacy5.rs:85:17\n    |\n LL |     let c2 = a::C;\n    |                 ^\n+   |\n+   = note: a tuple struct constructor is private if any of its fields is private\n \n error[E0603]: tuple struct `A` is private\n   --> $DIR/privacy5.rs:90:20\n    |\n LL |     let a = other::A(());\n    |                    ^\n+   |\n+   = note: a tuple struct constructor is private if any of its fields is private\n \n error[E0603]: tuple struct `B` is private\n   --> $DIR/privacy5.rs:91:20\n    |\n LL |     let b = other::B(2);\n    |                    ^\n+   |\n+   = note: a tuple struct constructor is private if any of its fields is private\n \n error[E0603]: tuple struct `C` is private\n   --> $DIR/privacy5.rs:92:20\n    |\n LL |     let c = other::C(2, 3);\n    |                    ^\n+   |\n+   = note: a tuple struct constructor is private if any of its fields is private\n \n error[E0603]: tuple struct `A` is private\n   --> $DIR/privacy5.rs:95:16\n    |\n LL |     let other::A(()) = a;\n    |                ^\n+   |\n+   = note: a tuple struct constructor is private if any of its fields is private\n \n error[E0603]: tuple struct `A` is private\n   --> $DIR/privacy5.rs:96:16\n    |\n LL |     let other::A(_) = a;\n    |                ^\n+   |\n+   = note: a tuple struct constructor is private if any of its fields is private\n \n error[E0603]: tuple struct `A` is private\n   --> $DIR/privacy5.rs:97:22\n    |\n LL |     match a { other::A(()) => {} }\n    |                      ^\n+   |\n+   = note: a tuple struct constructor is private if any of its fields is private\n \n error[E0603]: tuple struct `A` is private\n   --> $DIR/privacy5.rs:98:22\n    |\n LL |     match a { other::A(_) => {} }\n    |                      ^\n+   |\n+   = note: a tuple struct constructor is private if any of its fields is private\n \n error[E0603]: tuple struct `B` is private\n   --> $DIR/privacy5.rs:100:16\n    |\n LL |     let other::B(_) = b;\n    |                ^\n+   |\n+   = note: a tuple struct constructor is private if any of its fields is private\n \n error[E0603]: tuple struct `B` is private\n   --> $DIR/privacy5.rs:101:16\n    |\n LL |     let other::B(_b) = b;\n    |                ^\n+   |\n+   = note: a tuple struct constructor is private if any of its fields is private\n \n error[E0603]: tuple struct `B` is private\n   --> $DIR/privacy5.rs:102:22\n    |\n LL |     match b { other::B(_) => {} }\n    |                      ^\n+   |\n+   = note: a tuple struct constructor is private if any of its fields is private\n \n error[E0603]: tuple struct `B` is private\n   --> $DIR/privacy5.rs:103:22\n    |\n LL |     match b { other::B(_b) => {} }\n    |                      ^\n+   |\n+   = note: a tuple struct constructor is private if any of its fields is private\n \n error[E0603]: tuple struct `B` is private\n   --> $DIR/privacy5.rs:104:22\n    |\n LL |     match b { other::B(1) => {} other::B(_) => {} }\n    |                      ^\n+   |\n+   = note: a tuple struct constructor is private if any of its fields is private\n \n error[E0603]: tuple struct `B` is private\n   --> $DIR/privacy5.rs:104:40\n    |\n LL |     match b { other::B(1) => {} other::B(_) => {} }\n    |                                        ^\n+   |\n+   = note: a tuple struct constructor is private if any of its fields is private\n \n error[E0603]: tuple struct `C` is private\n   --> $DIR/privacy5.rs:107:16\n    |\n LL |     let other::C(_, _) = c;\n    |                ^\n+   |\n+   = note: a tuple struct constructor is private if any of its fields is private\n \n error[E0603]: tuple struct `C` is private\n   --> $DIR/privacy5.rs:108:16\n    |\n LL |     let other::C(_a, _) = c;\n    |                ^\n+   |\n+   = note: a tuple struct constructor is private if any of its fields is private\n \n error[E0603]: tuple struct `C` is private\n   --> $DIR/privacy5.rs:109:16\n    |\n LL |     let other::C(_, _b) = c;\n    |                ^\n+   |\n+   = note: a tuple struct constructor is private if any of its fields is private\n \n error[E0603]: tuple struct `C` is private\n   --> $DIR/privacy5.rs:110:16\n    |\n LL |     let other::C(_a, _b) = c;\n    |                ^\n+   |\n+   = note: a tuple struct constructor is private if any of its fields is private\n \n error[E0603]: tuple struct `C` is private\n   --> $DIR/privacy5.rs:111:22\n    |\n LL |     match c { other::C(_, _) => {} }\n    |                      ^\n+   |\n+   = note: a tuple struct constructor is private if any of its fields is private\n \n error[E0603]: tuple struct `C` is private\n   --> $DIR/privacy5.rs:112:22\n    |\n LL |     match c { other::C(_a, _) => {} }\n    |                      ^\n+   |\n+   = note: a tuple struct constructor is private if any of its fields is private\n \n error[E0603]: tuple struct `C` is private\n   --> $DIR/privacy5.rs:113:22\n    |\n LL |     match c { other::C(_, _b) => {} }\n    |                      ^\n+   |\n+   = note: a tuple struct constructor is private if any of its fields is private\n \n error[E0603]: tuple struct `C` is private\n   --> $DIR/privacy5.rs:114:22\n    |\n LL |     match c { other::C(_a, _b) => {} }\n    |                      ^\n+   |\n+   = note: a tuple struct constructor is private if any of its fields is private\n \n error[E0603]: tuple struct `A` is private\n   --> $DIR/privacy5.rs:122:21\n    |\n LL |     let a2 = other::A;\n    |                     ^\n+   |\n+   = note: a tuple struct constructor is private if any of its fields is private\n \n error[E0603]: tuple struct `B` is private\n   --> $DIR/privacy5.rs:123:21\n    |\n LL |     let b2 = other::B;\n    |                     ^\n+   |\n+   = note: a tuple struct constructor is private if any of its fields is private\n \n error[E0603]: tuple struct `C` is private\n   --> $DIR/privacy5.rs:124:21\n    |\n LL |     let c2 = other::C;\n    |                     ^\n+   |\n+   = note: a tuple struct constructor is private if any of its fields is private\n \n error: aborting due to 48 previous errors\n "}, {"sha": "6e91201405cc69dbc989567ed08f25f02f1d2dd1", "filename": "src/test/ui/proc-macro/lifetimes.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Ftest%2Fui%2Fproc-macro%2Flifetimes.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Ftest%2Fui%2Fproc-macro%2Flifetimes.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Flifetimes.stderr?ref=d19a359444295bab01de7ff44a9d72302e573bc9", "patch": "@@ -2,7 +2,7 @@ error: expected type, found `'`\n   --> $DIR/lifetimes.rs:9:10\n    |\n LL | type A = single_quote_alone!();\n-   |          ^^^^^^^^^^^^^^^^^^^^^\n+   |          ^^^^^^^^^^^^^^^^^^^^^ this macro call doesn't expand to a type\n \n error: aborting due to previous error\n "}, {"sha": "2538bbbf8067f6c4c450f808476224356e2883d4", "filename": "src/test/ui/resolve/privacy-enum-ctor.stderr", "status": "modified", "additions": 21, "deletions": 3, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Ftest%2Fui%2Fresolve%2Fprivacy-enum-ctor.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Ftest%2Fui%2Fresolve%2Fprivacy-enum-ctor.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fprivacy-enum-ctor.stderr?ref=d19a359444295bab01de7ff44a9d72302e573bc9", "patch": "@@ -195,8 +195,14 @@ LL |     let _: Z = m::n::Z::Unit {};\n error[E0308]: mismatched types\n   --> $DIR/privacy-enum-ctor.rs:27:20\n    |\n+LL |             Fn(u8),\n+   |             ------ fn(u8) -> m::n::Z {m::n::Z::Fn} defined here\n+...\n LL |         let _: Z = Z::Fn;\n-   |                    ^^^^^ expected enum `m::n::Z`, found fn item\n+   |                    ^^^^^\n+   |                    |\n+   |                    expected enum `m::n::Z`, found fn item\n+   |                    help: use parentheses to instantiate this tuple variant: `Z::Fn(_)`\n    |\n    = note: expected type `m::n::Z`\n               found type `fn(u8) -> m::n::Z {m::n::Z::Fn}`\n@@ -219,8 +225,14 @@ LL |         let _ = Z::Unit;\n error[E0308]: mismatched types\n   --> $DIR/privacy-enum-ctor.rs:43:16\n    |\n+LL |         Fn(u8),\n+   |         ------ fn(u8) -> m::E {m::E::Fn} defined here\n+...\n LL |     let _: E = m::E::Fn;\n-   |                ^^^^^^^^ expected enum `m::E`, found fn item\n+   |                ^^^^^^^^\n+   |                |\n+   |                expected enum `m::E`, found fn item\n+   |                help: use parentheses to instantiate this tuple variant: `m::E::Fn(_)`\n    |\n    = note: expected type `m::E`\n               found type `fn(u8) -> m::E {m::E::Fn}`\n@@ -243,8 +255,14 @@ LL |     let _: E = m::E::Unit;\n error[E0308]: mismatched types\n   --> $DIR/privacy-enum-ctor.rs:51:16\n    |\n+LL |         Fn(u8),\n+   |         ------ fn(u8) -> m::E {m::E::Fn} defined here\n+...\n LL |     let _: E = E::Fn;\n-   |                ^^^^^ expected enum `m::E`, found fn item\n+   |                ^^^^^\n+   |                |\n+   |                expected enum `m::E`, found fn item\n+   |                help: use parentheses to instantiate this tuple variant: `E::Fn(_)`\n    |\n    = note: expected type `m::E`\n               found type `fn(u8) -> m::E {m::E::Fn}`"}, {"sha": "72d62fe45ce745a5340bc29f7e1d7d67b807b102", "filename": "src/test/ui/resolve/privacy-struct-ctor.stderr", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Ftest%2Fui%2Fresolve%2Fprivacy-struct-ctor.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Ftest%2Fui%2Fresolve%2Fprivacy-struct-ctor.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fprivacy-struct-ctor.stderr?ref=d19a359444295bab01de7ff44a9d72302e573bc9", "patch": "@@ -34,36 +34,48 @@ error[E0603]: tuple struct `Z` is private\n    |\n LL |         n::Z;\n    |            ^\n+   |\n+   = note: a tuple struct constructor is private if any of its fields is private\n \n error[E0603]: tuple struct `S` is private\n   --> $DIR/privacy-struct-ctor.rs:29:8\n    |\n LL |     m::S;\n    |        ^\n+   |\n+   = note: a tuple struct constructor is private if any of its fields is private\n \n error[E0603]: tuple struct `S` is private\n   --> $DIR/privacy-struct-ctor.rs:31:19\n    |\n LL |     let _: S = m::S(2);\n    |                   ^\n+   |\n+   = note: a tuple struct constructor is private if any of its fields is private\n \n error[E0603]: tuple struct `Z` is private\n   --> $DIR/privacy-struct-ctor.rs:35:11\n    |\n LL |     m::n::Z;\n    |           ^\n+   |\n+   = note: a tuple struct constructor is private if any of its fields is private\n \n error[E0603]: tuple struct `S` is private\n   --> $DIR/privacy-struct-ctor.rs:41:16\n    |\n LL |     xcrate::m::S;\n    |                ^\n+   |\n+   = note: a tuple struct constructor is private if any of its fields is private\n \n error[E0603]: tuple struct `Z` is private\n   --> $DIR/privacy-struct-ctor.rs:45:19\n    |\n LL |     xcrate::m::n::Z;\n    |                   ^\n+   |\n+   = note: a tuple struct constructor is private if any of its fields is private\n \n error: aborting due to 10 previous errors\n "}, {"sha": "d75a376286fcc946f1ff9f39273ac3ca33f8c128", "filename": "src/test/ui/rfc-2008-non-exhaustive/struct.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fstruct.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fstruct.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fstruct.stderr?ref=d19a359444295bab01de7ff44a9d72302e573bc9", "patch": "@@ -15,6 +15,8 @@ error[E0603]: tuple struct `TupleStruct` is private\n    |\n LL |     let ts_explicit = structs::TupleStruct(640, 480);\n    |                                ^^^^^^^^^^^\n+   |\n+   = note: a tuple struct constructor is private if any of its fields is private\n \n error[E0603]: unit struct `UnitStruct` is private\n   --> $DIR/struct.rs:32:32"}, {"sha": "ac0025ec758072fa3ddee48e88085c9b9055a067", "filename": "src/test/ui/rfc-2008-non-exhaustive/variant.stderr", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fvariant.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fvariant.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fvariant.stderr?ref=d19a359444295bab01de7ff44a9d72302e573bc9", "patch": "@@ -3,6 +3,8 @@ error[E0603]: tuple variant `Tuple` is private\n    |\n LL |     let variant_tuple = NonExhaustiveVariants::Tuple(640);\n    |                                                ^^^^^\n+   |\n+   = note: a tuple variant constructor is private if any of its fields is private\n \n error[E0603]: unit variant `Unit` is private\n   --> $DIR/variant.rs:14:47\n@@ -21,12 +23,16 @@ error[E0603]: tuple variant `Tuple` is private\n    |\n LL |         NonExhaustiveVariants::Tuple(fe_tpl) => \"\",\n    |                                ^^^^^\n+   |\n+   = note: a tuple variant constructor is private if any of its fields is private\n \n error[E0603]: tuple variant `Tuple` is private\n   --> $DIR/variant.rs:26:35\n    |\n LL |     if let NonExhaustiveVariants::Tuple(fe_tpl) = variant_struct {\n    |                                   ^^^^^\n+   |\n+   = note: a tuple variant constructor is private if any of its fields is private\n \n error[E0639]: cannot create non-exhaustive variant using struct expression\n   --> $DIR/variant.rs:8:26"}, {"sha": "36cb939bc48fbdb069d08c28b966c5fa67e50746", "filename": "src/test/ui/specialization/issue-36804.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Ftest%2Fui%2Fspecialization%2Fissue-36804.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Ftest%2Fui%2Fspecialization%2Fissue-36804.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspecialization%2Fissue-36804.rs?ref=d19a359444295bab01de7ff44a9d72302e573bc9", "patch": "@@ -0,0 +1,31 @@\n+// check-pass\n+#![feature(specialization)]\n+\n+pub struct Cloned<I>(I);\n+\n+impl<'a, I, T: 'a> Iterator for Cloned<I>\n+where\n+    I: Iterator<Item = &'a T>,\n+    T: Clone,\n+{\n+    type Item = T;\n+\n+    fn next(&mut self) -> Option<T> {\n+        unimplemented!()\n+    }\n+}\n+\n+impl<'a, I, T: 'a> Iterator for Cloned<I>\n+where\n+    I: Iterator<Item = &'a T>,\n+    T: Copy,\n+{\n+    fn count(self) -> usize {\n+        unimplemented!()\n+    }\n+}\n+\n+fn main() {\n+    let a = [1,2,3,4];\n+    Cloned(a.iter()).count();\n+}"}, {"sha": "b3b879ef9acbef79523669ae7a2b9cef2422480a", "filename": "src/test/ui/substs-ppaux.normal.stderr", "status": "modified", "additions": 28, "deletions": 4, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Ftest%2Fui%2Fsubsts-ppaux.normal.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Ftest%2Fui%2Fsubsts-ppaux.normal.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsubsts-ppaux.normal.stderr?ref=d19a359444295bab01de7ff44a9d72302e573bc9", "patch": "@@ -1,35 +1,59 @@\n error[E0308]: mismatched types\n   --> $DIR/substs-ppaux.rs:16:17\n    |\n+LL |     fn bar<'a, T>() where T: 'a {}\n+   |     --------------------------- fn() {<i8 as Foo<'static, 'static, u8>>::bar::<'static, char>} defined here\n+...\n LL |     let x: () = <i8 as Foo<'static, 'static,  u8>>::bar::<'static, char>;\n-   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected (), found fn item\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                 |\n+   |                 expected (), found fn item\n+   |                 help: use parentheses to call this function: `<i8 as Foo<'static, 'static,  u8>>::bar::<'static, char>()`\n    |\n    = note: expected type `()`\n               found type `fn() {<i8 as Foo<'static, 'static, u8>>::bar::<'static, char>}`\n \n error[E0308]: mismatched types\n   --> $DIR/substs-ppaux.rs:25:17\n    |\n+LL |     fn bar<'a, T>() where T: 'a {}\n+   |     --------------------------- fn() {<i8 as Foo<'static, 'static>>::bar::<'static, char>} defined here\n+...\n LL |     let x: () = <i8 as Foo<'static, 'static,  u32>>::bar::<'static, char>;\n-   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected (), found fn item\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                 |\n+   |                 expected (), found fn item\n+   |                 help: use parentheses to call this function: `<i8 as Foo<'static, 'static,  u32>>::bar::<'static, char>()`\n    |\n    = note: expected type `()`\n               found type `fn() {<i8 as Foo<'static, 'static>>::bar::<'static, char>}`\n \n error[E0308]: mismatched types\n   --> $DIR/substs-ppaux.rs:33:17\n    |\n+LL |     fn baz() {}\n+   |     -------- fn() {<i8 as Foo<'static, 'static, u8>>::baz} defined here\n+...\n LL |     let x: () = <i8 as Foo<'static, 'static,  u8>>::baz;\n-   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected (), found fn item\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                 |\n+   |                 expected (), found fn item\n+   |                 help: use parentheses to call this function: `<i8 as Foo<'static, 'static,  u8>>::baz()`\n    |\n    = note: expected type `()`\n               found type `fn() {<i8 as Foo<'static, 'static, u8>>::baz}`\n \n error[E0308]: mismatched types\n   --> $DIR/substs-ppaux.rs:41:17\n    |\n+LL | fn foo<'z>() where &'z (): Sized {\n+   | -------------------------------- fn() {foo::<'static>} defined here\n+...\n LL |     let x: () = foo::<'static>;\n-   |                 ^^^^^^^^^^^^^^ expected (), found fn item\n+   |                 ^^^^^^^^^^^^^^\n+   |                 |\n+   |                 expected (), found fn item\n+   |                 help: use parentheses to call this function: `foo::<'static>()`\n    |\n    = note: expected type `()`\n               found type `fn() {foo::<'static>}`"}, {"sha": "363018db232d88858766fc437c0e4d427b732071", "filename": "src/test/ui/substs-ppaux.verbose.stderr", "status": "modified", "additions": 28, "deletions": 4, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Ftest%2Fui%2Fsubsts-ppaux.verbose.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Ftest%2Fui%2Fsubsts-ppaux.verbose.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsubsts-ppaux.verbose.stderr?ref=d19a359444295bab01de7ff44a9d72302e573bc9", "patch": "@@ -1,35 +1,59 @@\n error[E0308]: mismatched types\n   --> $DIR/substs-ppaux.rs:16:17\n    |\n+LL |     fn bar<'a, T>() where T: 'a {}\n+   |     --------------------------- fn() {<i8 as Foo<ReStatic, ReStatic, u8>>::bar::<ReStatic, char>} defined here\n+...\n LL |     let x: () = <i8 as Foo<'static, 'static,  u8>>::bar::<'static, char>;\n-   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected (), found fn item\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                 |\n+   |                 expected (), found fn item\n+   |                 help: use parentheses to call this function: `<i8 as Foo<'static, 'static,  u8>>::bar::<'static, char>()`\n    |\n    = note: expected type `()`\n               found type `fn() {<i8 as Foo<ReStatic, ReStatic, u8>>::bar::<ReStatic, char>}`\n \n error[E0308]: mismatched types\n   --> $DIR/substs-ppaux.rs:25:17\n    |\n+LL |     fn bar<'a, T>() where T: 'a {}\n+   |     --------------------------- fn() {<i8 as Foo<ReStatic, ReStatic>>::bar::<ReStatic, char>} defined here\n+...\n LL |     let x: () = <i8 as Foo<'static, 'static,  u32>>::bar::<'static, char>;\n-   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected (), found fn item\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                 |\n+   |                 expected (), found fn item\n+   |                 help: use parentheses to call this function: `<i8 as Foo<'static, 'static,  u32>>::bar::<'static, char>()`\n    |\n    = note: expected type `()`\n               found type `fn() {<i8 as Foo<ReStatic, ReStatic>>::bar::<ReStatic, char>}`\n \n error[E0308]: mismatched types\n   --> $DIR/substs-ppaux.rs:33:17\n    |\n+LL |     fn baz() {}\n+   |     -------- fn() {<i8 as Foo<ReStatic, ReStatic, u8>>::baz} defined here\n+...\n LL |     let x: () = <i8 as Foo<'static, 'static,  u8>>::baz;\n-   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected (), found fn item\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                 |\n+   |                 expected (), found fn item\n+   |                 help: use parentheses to call this function: `<i8 as Foo<'static, 'static,  u8>>::baz()`\n    |\n    = note: expected type `()`\n               found type `fn() {<i8 as Foo<ReStatic, ReStatic, u8>>::baz}`\n \n error[E0308]: mismatched types\n   --> $DIR/substs-ppaux.rs:41:17\n    |\n+LL | fn foo<'z>() where &'z (): Sized {\n+   | -------------------------------- fn() {foo::<ReStatic>} defined here\n+...\n LL |     let x: () = foo::<'static>;\n-   |                 ^^^^^^^^^^^^^^ expected (), found fn item\n+   |                 ^^^^^^^^^^^^^^\n+   |                 |\n+   |                 expected (), found fn item\n+   |                 help: use parentheses to call this function: `foo::<'static>()`\n    |\n    = note: expected type `()`\n               found type `fn() {foo::<ReStatic>}`"}, {"sha": "a8ea3faefe876a12a5659691b5a542a58e9b5c4a", "filename": "src/test/ui/suggestions/fn-or-tuple-struct-with-underscore-args.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Ftest%2Fui%2Fsuggestions%2Ffn-or-tuple-struct-with-underscore-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Ftest%2Fui%2Fsuggestions%2Ffn-or-tuple-struct-with-underscore-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Ffn-or-tuple-struct-with-underscore-args.rs?ref=d19a359444295bab01de7ff44a9d72302e573bc9", "patch": "@@ -0,0 +1,19 @@\n+fn foo(a: usize, b: usize) -> usize { a }\n+\n+struct S(usize, usize);\n+\n+trait T {\n+    fn baz(x: usize, y: usize) -> usize { x }\n+}\n+\n+fn main() {\n+    let _: usize = foo(_, _);\n+    //~^ ERROR expected expression\n+    //~| ERROR expected expression\n+    let _: S = S(_, _);\n+    //~^ ERROR expected expression\n+    //~| ERROR expected expression\n+    let _: usize = T::baz(_, _);\n+    //~^ ERROR expected expression\n+    //~| ERROR expected expression\n+}"}, {"sha": "a6d1c4b859f2f73611763a074a60c07e72de991f", "filename": "src/test/ui/suggestions/fn-or-tuple-struct-with-underscore-args.stderr", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Ftest%2Fui%2Fsuggestions%2Ffn-or-tuple-struct-with-underscore-args.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Ftest%2Fui%2Fsuggestions%2Ffn-or-tuple-struct-with-underscore-args.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Ffn-or-tuple-struct-with-underscore-args.stderr?ref=d19a359444295bab01de7ff44a9d72302e573bc9", "patch": "@@ -0,0 +1,38 @@\n+error: expected expression, found reserved identifier `_`\n+  --> $DIR/fn-or-tuple-struct-with-underscore-args.rs:10:24\n+   |\n+LL |     let _: usize = foo(_, _);\n+   |                        ^ expected expression\n+\n+error: expected expression, found reserved identifier `_`\n+  --> $DIR/fn-or-tuple-struct-with-underscore-args.rs:10:27\n+   |\n+LL |     let _: usize = foo(_, _);\n+   |                           ^ expected expression\n+\n+error: expected expression, found reserved identifier `_`\n+  --> $DIR/fn-or-tuple-struct-with-underscore-args.rs:13:18\n+   |\n+LL |     let _: S = S(_, _);\n+   |                  ^ expected expression\n+\n+error: expected expression, found reserved identifier `_`\n+  --> $DIR/fn-or-tuple-struct-with-underscore-args.rs:13:21\n+   |\n+LL |     let _: S = S(_, _);\n+   |                     ^ expected expression\n+\n+error: expected expression, found reserved identifier `_`\n+  --> $DIR/fn-or-tuple-struct-with-underscore-args.rs:16:27\n+   |\n+LL |     let _: usize = T::baz(_, _);\n+   |                           ^ expected expression\n+\n+error: expected expression, found reserved identifier `_`\n+  --> $DIR/fn-or-tuple-struct-with-underscore-args.rs:16:30\n+   |\n+LL |     let _: usize = T::baz(_, _);\n+   |                              ^ expected expression\n+\n+error: aborting due to 6 previous errors\n+"}, {"sha": "9b6b10748172b6b3295ddd03b95b111a7f666b44", "filename": "src/test/ui/suggestions/fn-or-tuple-struct-without-args.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Ftest%2Fui%2Fsuggestions%2Ffn-or-tuple-struct-without-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Ftest%2Fui%2Fsuggestions%2Ffn-or-tuple-struct-without-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Ffn-or-tuple-struct-without-args.rs?ref=d19a359444295bab01de7ff44a9d72302e573bc9", "patch": "@@ -0,0 +1,45 @@\n+fn foo(a: usize, b: usize) -> usize { a }\n+\n+fn bar() -> usize { 42 }\n+\n+struct S(usize, usize);\n+enum E {\n+    A(usize),\n+    B { a: usize },\n+}\n+struct V();\n+\n+trait T {\n+    fn baz(x: usize, y: usize) -> usize { x }\n+    fn bat(x: usize) -> usize { 42 }\n+    fn bax(x: usize) -> usize { 42 }\n+    fn bach(x: usize) -> usize;\n+    fn ban(&self) -> usize { 42 }\n+    fn bal(&self) -> usize;\n+}\n+\n+struct X;\n+\n+impl T for X {\n+    fn bach(x: usize) -> usize { 42 }\n+    fn bal(&self) -> usize { 42 }\n+}\n+\n+fn main() {\n+    let _: usize = foo; //~ ERROR mismatched types\n+    let _: S = S; //~ ERROR mismatched types\n+    let _: usize = bar; //~ ERROR mismatched types\n+    let _: V = V; //~ ERROR mismatched types\n+    let _: usize = T::baz; //~ ERROR mismatched types\n+    let _: usize = T::bat; //~ ERROR mismatched types\n+    let _: E = E::A; //~ ERROR mismatched types\n+    let _: E = E::B; //~ ERROR expected value, found struct variant `E::B`\n+    let _: usize = X::baz; //~ ERROR mismatched types\n+    let _: usize = X::bat; //~ ERROR mismatched types\n+    let _: usize = X::bax; //~ ERROR mismatched types\n+    let _: usize = X::bach; //~ ERROR mismatched types\n+    let _: usize = X::ban; //~ ERROR mismatched types\n+    let _: usize = X::bal; //~ ERROR mismatched types\n+    let _: usize = X.ban; //~ ERROR attempted to take value of method\n+    let _: usize = X.bal; //~ ERROR attempted to take value of method\n+}"}, {"sha": "0686b56f97ded5d4a5a9f9707c388b771d6f5dc7", "filename": "src/test/ui/suggestions/fn-or-tuple-struct-without-args.stderr", "status": "added", "additions": 220, "deletions": 0, "changes": 220, "blob_url": "https://github.com/rust-lang/rust/blob/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Ftest%2Fui%2Fsuggestions%2Ffn-or-tuple-struct-without-args.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Ftest%2Fui%2Fsuggestions%2Ffn-or-tuple-struct-without-args.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Ffn-or-tuple-struct-without-args.stderr?ref=d19a359444295bab01de7ff44a9d72302e573bc9", "patch": "@@ -0,0 +1,220 @@\n+error[E0423]: expected value, found struct variant `E::B`\n+  --> $DIR/fn-or-tuple-struct-without-args.rs:36:16\n+   |\n+LL |     let _: E = E::B;\n+   |                ^^^-\n+   |                |  |\n+   |                |  help: a tuple variant with a similar name exists: `A`\n+   |                did you mean `E::B { /* fields */ }`?\n+\n+error[E0308]: mismatched types\n+  --> $DIR/fn-or-tuple-struct-without-args.rs:29:20\n+   |\n+LL | fn foo(a: usize, b: usize) -> usize { a }\n+   | ----------------------------------- fn(usize, usize) -> usize {foo} defined here\n+...\n+LL |     let _: usize = foo;\n+   |                    ^^^\n+   |                    |\n+   |                    expected usize, found fn item\n+   |                    help: use parentheses to call this function: `foo(a, b)`\n+   |\n+   = note: expected type `usize`\n+              found type `fn(usize, usize) -> usize {foo}`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/fn-or-tuple-struct-without-args.rs:30:16\n+   |\n+LL | struct S(usize, usize);\n+   | ----------------------- fn(usize, usize) -> S {S} defined here\n+...\n+LL |     let _: S = S;\n+   |                ^\n+   |                |\n+   |                expected struct `S`, found fn item\n+   |                help: use parentheses to instantiate this tuple struct: `S(_, _)`\n+   |\n+   = note: expected type `S`\n+              found type `fn(usize, usize) -> S {S}`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/fn-or-tuple-struct-without-args.rs:31:20\n+   |\n+LL | fn bar() -> usize { 42 }\n+   | ----------------- fn() -> usize {bar} defined here\n+...\n+LL |     let _: usize = bar;\n+   |                    ^^^\n+   |                    |\n+   |                    expected usize, found fn item\n+   |                    help: use parentheses to call this function: `bar()`\n+   |\n+   = note: expected type `usize`\n+              found type `fn() -> usize {bar}`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/fn-or-tuple-struct-without-args.rs:32:16\n+   |\n+LL | struct V();\n+   | ----------- fn() -> V {V} defined here\n+...\n+LL |     let _: V = V;\n+   |                ^\n+   |                |\n+   |                expected struct `V`, found fn item\n+   |                help: use parentheses to instantiate this tuple struct: `V()`\n+   |\n+   = note: expected type `V`\n+              found type `fn() -> V {V}`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/fn-or-tuple-struct-without-args.rs:33:20\n+   |\n+LL |     fn baz(x: usize, y: usize) -> usize { x }\n+   |     ----------------------------------- fn(usize, usize) -> usize {<_ as T>::baz} defined here\n+...\n+LL |     let _: usize = T::baz;\n+   |                    ^^^^^^\n+   |                    |\n+   |                    expected usize, found fn item\n+   |                    help: use parentheses to call this function: `T::baz(x, y)`\n+   |\n+   = note: expected type `usize`\n+              found type `fn(usize, usize) -> usize {<_ as T>::baz}`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/fn-or-tuple-struct-without-args.rs:34:20\n+   |\n+LL |     fn bat(x: usize) -> usize { 42 }\n+   |     ------------------------- fn(usize) -> usize {<_ as T>::bat} defined here\n+...\n+LL |     let _: usize = T::bat;\n+   |                    ^^^^^^\n+   |                    |\n+   |                    expected usize, found fn item\n+   |                    help: use parentheses to call this function: `T::bat(x)`\n+   |\n+   = note: expected type `usize`\n+              found type `fn(usize) -> usize {<_ as T>::bat}`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/fn-or-tuple-struct-without-args.rs:35:16\n+   |\n+LL |     A(usize),\n+   |     -------- fn(usize) -> E {E::A} defined here\n+...\n+LL |     let _: E = E::A;\n+   |                ^^^^\n+   |                |\n+   |                expected enum `E`, found fn item\n+   |                help: use parentheses to instantiate this tuple variant: `E::A(_)`\n+   |\n+   = note: expected type `E`\n+              found type `fn(usize) -> E {E::A}`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/fn-or-tuple-struct-without-args.rs:37:20\n+   |\n+LL |     fn baz(x: usize, y: usize) -> usize { x }\n+   |     ----------------------------------- fn(usize, usize) -> usize {<X as T>::baz} defined here\n+...\n+LL |     let _: usize = X::baz;\n+   |                    ^^^^^^\n+   |                    |\n+   |                    expected usize, found fn item\n+   |                    help: use parentheses to call this function: `X::baz(x, y)`\n+   |\n+   = note: expected type `usize`\n+              found type `fn(usize, usize) -> usize {<X as T>::baz}`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/fn-or-tuple-struct-without-args.rs:38:20\n+   |\n+LL |     fn bat(x: usize) -> usize { 42 }\n+   |     ------------------------- fn(usize) -> usize {<X as T>::bat} defined here\n+...\n+LL |     let _: usize = X::bat;\n+   |                    ^^^^^^\n+   |                    |\n+   |                    expected usize, found fn item\n+   |                    help: use parentheses to call this function: `X::bat(x)`\n+   |\n+   = note: expected type `usize`\n+              found type `fn(usize) -> usize {<X as T>::bat}`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/fn-or-tuple-struct-without-args.rs:39:20\n+   |\n+LL |     fn bax(x: usize) -> usize { 42 }\n+   |     ------------------------- fn(usize) -> usize {<X as T>::bax} defined here\n+...\n+LL |     let _: usize = X::bax;\n+   |                    ^^^^^^\n+   |                    |\n+   |                    expected usize, found fn item\n+   |                    help: use parentheses to call this function: `X::bax(x)`\n+   |\n+   = note: expected type `usize`\n+              found type `fn(usize) -> usize {<X as T>::bax}`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/fn-or-tuple-struct-without-args.rs:40:20\n+   |\n+LL |     fn bach(x: usize) -> usize;\n+   |     --------------------------- fn(usize) -> usize {<X as T>::bach} defined here\n+...\n+LL |     let _: usize = X::bach;\n+   |                    ^^^^^^^\n+   |                    |\n+   |                    expected usize, found fn item\n+   |                    help: use parentheses to call this function: `X::bach(x)`\n+   |\n+   = note: expected type `usize`\n+              found type `fn(usize) -> usize {<X as T>::bach}`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/fn-or-tuple-struct-without-args.rs:41:20\n+   |\n+LL |     fn ban(&self) -> usize { 42 }\n+   |     ---------------------- for<'r> fn(&'r X) -> usize {<X as T>::ban} defined here\n+...\n+LL |     let _: usize = X::ban;\n+   |                    ^^^^^^\n+   |                    |\n+   |                    expected usize, found fn item\n+   |                    help: use parentheses to call this function: `X::ban(_)`\n+   |\n+   = note: expected type `usize`\n+              found type `for<'r> fn(&'r X) -> usize {<X as T>::ban}`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/fn-or-tuple-struct-without-args.rs:42:20\n+   |\n+LL |     fn bal(&self) -> usize;\n+   |     ----------------------- for<'r> fn(&'r X) -> usize {<X as T>::bal} defined here\n+...\n+LL |     let _: usize = X::bal;\n+   |                    ^^^^^^\n+   |                    |\n+   |                    expected usize, found fn item\n+   |                    help: use parentheses to call this function: `X::bal(_)`\n+   |\n+   = note: expected type `usize`\n+              found type `for<'r> fn(&'r X) -> usize {<X as T>::bal}`\n+\n+error[E0615]: attempted to take value of method `ban` on type `X`\n+  --> $DIR/fn-or-tuple-struct-without-args.rs:43:22\n+   |\n+LL |     let _: usize = X.ban;\n+   |                      ^^^ help: use parentheses to call the method: `ban()`\n+\n+error[E0615]: attempted to take value of method `bal` on type `X`\n+  --> $DIR/fn-or-tuple-struct-without-args.rs:44:22\n+   |\n+LL |     let _: usize = X.bal;\n+   |                      ^^^ help: use parentheses to call the method: `bal()`\n+\n+error: aborting due to 16 previous errors\n+\n+Some errors have detailed explanations: E0308, E0423, E0615.\n+For more information about an error, try `rustc --explain E0308`."}, {"sha": "e1695d6820a817d3ba6d5e4501484872579886c6", "filename": "src/test/ui/suggestions/vec-macro-in-pattern.fixed", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Ftest%2Fui%2Fsuggestions%2Fvec-macro-in-pattern.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Ftest%2Fui%2Fsuggestions%2Fvec-macro-in-pattern.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fvec-macro-in-pattern.fixed?ref=d19a359444295bab01de7ff44a9d72302e573bc9", "patch": "@@ -0,0 +1,8 @@\n+// run-rustfix\n+fn main() {\n+    // everything after `.as_ref` should be suggested\n+    match Some(vec![3]).as_ref().map(|v| v.as_slice()) {\n+        Some([_x]) => (), //~ ERROR unexpected `(` after qualified path\n+        _ => (),\n+    }\n+}"}, {"sha": "4843629fbcf904788e0567d86717418ce7005794", "filename": "src/test/ui/suggestions/vec-macro-in-pattern.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Ftest%2Fui%2Fsuggestions%2Fvec-macro-in-pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Ftest%2Fui%2Fsuggestions%2Fvec-macro-in-pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fvec-macro-in-pattern.rs?ref=d19a359444295bab01de7ff44a9d72302e573bc9", "patch": "@@ -0,0 +1,8 @@\n+// run-rustfix\n+fn main() {\n+    // everything after `.as_ref` should be suggested\n+    match Some(vec![3]).as_ref().map(|v| v.as_slice()) {\n+        Some(vec![_x]) => (), //~ ERROR unexpected `(` after qualified path\n+        _ => (),\n+    }\n+}"}, {"sha": "59ca8ebbf63399eb34928b67a59563c6521c7f39", "filename": "src/test/ui/suggestions/vec-macro-in-pattern.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Ftest%2Fui%2Fsuggestions%2Fvec-macro-in-pattern.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Ftest%2Fui%2Fsuggestions%2Fvec-macro-in-pattern.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fvec-macro-in-pattern.stderr?ref=d19a359444295bab01de7ff44a9d72302e573bc9", "patch": "@@ -0,0 +1,15 @@\n+error: unexpected `(` after qualified path\n+  --> $DIR/vec-macro-in-pattern.rs:5:14\n+   |\n+LL |         Some(vec![_x]) => (),\n+   |              ^^^^^^^^\n+   |              |\n+   |              unexpected `(` after qualified path\n+   |              in this macro invocation\n+   |              help: use a slice pattern here instead: `[_x]`\n+   |\n+   = help: for more information, see https://doc.rust-lang.org/edition-guide/rust-2018/slice-patterns.html\n+   = note: this warning originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n+\n+error: aborting due to previous error\n+"}, {"sha": "2f052341faead87e832f4591e779b231ec92c646", "filename": "src/test/ui/type/ascription/issue-47666.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Ftest%2Fui%2Ftype%2Fascription%2Fissue-47666.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Ftest%2Fui%2Ftype%2Fascription%2Fissue-47666.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Fascription%2Fissue-47666.stderr?ref=d19a359444295bab01de7ff44a9d72302e573bc9", "patch": "@@ -6,6 +6,7 @@ LL |     let _ = Option:Some(vec![0, 1]);\n    |                   |     |\n    |                   |     expected type\n    |                   |     in this macro invocation\n+   |                   |     this macro call doesn't expand to a type\n    |                   help: maybe write a path separator here: `::`\n    |\n    = note: `#![feature(type_ascription)]` lets you annotate an expression with a type: `<expr>: <type>`"}, {"sha": "5bc4e0c217f40894c0d406cce38ceeb41cc95f8d", "filename": "src/test/ui/typeid-intrinsic.rs", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Ftest%2Fui%2Ftypeid-intrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d19a359444295bab01de7ff44a9d72302e573bc9/src%2Ftest%2Fui%2Ftypeid-intrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeid-intrinsic.rs?ref=d19a359444295bab01de7ff44a9d72302e573bc9", "patch": "@@ -78,10 +78,20 @@ pub fn main() {\n     assert_eq!(TypeId::of::<other1::U32Iterator>(), other1::id_u32_iterator());\n     assert_eq!(other1::id_i32_iterator(), other2::id_i32_iterator());\n     assert_eq!(other1::id_u32_iterator(), other2::id_u32_iterator());\n-    assert!(other1::id_i32_iterator() != other1::id_u32_iterator());\n-    assert!(TypeId::of::<other1::I32Iterator>() != TypeId::of::<other1::U32Iterator>());\n+    assert_ne!(other1::id_i32_iterator(), other1::id_u32_iterator());\n+    assert_ne!(TypeId::of::<other1::I32Iterator>(), TypeId::of::<other1::U32Iterator>());\n \n     // Check fn pointer against collisions\n-    assert!(TypeId::of::<fn(fn(A) -> A) -> A>() !=\n-            TypeId::of::<fn(fn() -> A, A) -> A>());\n+    assert_ne!(\n+        TypeId::of::<fn(fn(A) -> A) -> A>(),\n+        TypeId::of::<fn(fn() -> A, A) -> A>()\n+    );\n+    assert_ne!(\n+        TypeId::of::<for<'a> fn(&'a i32) -> &'a i32>(),\n+        TypeId::of::<for<'a> fn(&'a i32) -> &'static i32>()\n+    );\n+    assert_ne!(\n+        TypeId::of::<for<'a, 'b> fn(&'a i32, &'b i32) -> &'a i32>(),\n+        TypeId::of::<for<'a, 'b> fn(&'b i32, &'a i32) -> &'a i32>()\n+    );\n }"}]}