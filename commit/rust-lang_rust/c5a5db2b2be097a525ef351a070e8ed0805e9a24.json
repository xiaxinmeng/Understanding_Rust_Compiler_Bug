{"sha": "c5a5db2b2be097a525ef351a070e8ed0805e9a24", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM1YTVkYjJiMmJlMDk3YTUyNWVmMzUxYTA3MGU4ZWQwODA1ZTlhMjQ=", "commit": {"author": {"name": "Nick Cameron", "email": "nrc@ncameron.org", "date": "2017-08-31T05:15:42Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-08-31T05:15:42Z"}, "message": "Merge pull request #1930 from topecongiro/poor/item_brace_style\n\nAdd struct_remove_empty_body config option", "tree": {"sha": "ac370c47a670db2c9b7355c4c426b4adc9e12186", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ac370c47a670db2c9b7355c4c426b4adc9e12186"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c5a5db2b2be097a525ef351a070e8ed0805e9a24", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c5a5db2b2be097a525ef351a070e8ed0805e9a24", "html_url": "https://github.com/rust-lang/rust/commit/c5a5db2b2be097a525ef351a070e8ed0805e9a24", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c5a5db2b2be097a525ef351a070e8ed0805e9a24/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8122f0b083b1a8444a7653bd5d49818e3746284d", "url": "https://api.github.com/repos/rust-lang/rust/commits/8122f0b083b1a8444a7653bd5d49818e3746284d", "html_url": "https://github.com/rust-lang/rust/commit/8122f0b083b1a8444a7653bd5d49818e3746284d"}, {"sha": "4ad81d0bd9ac23eaa53335f03e12ef52e5fcb8d0", "url": "https://api.github.com/repos/rust-lang/rust/commits/4ad81d0bd9ac23eaa53335f03e12ef52e5fcb8d0", "html_url": "https://github.com/rust-lang/rust/commit/4ad81d0bd9ac23eaa53335f03e12ef52e5fcb8d0"}], "stats": {"total": 118, "additions": 31, "deletions": 87}, "files": [{"sha": "8c81aed87e6119a4ab2ff5f52ef33fb2e1796a74", "filename": "src/items.rs", "status": "modified", "additions": 23, "deletions": 87, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/c5a5db2b2be097a525ef351a070e8ed0805e9a24/src%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5a5db2b2be097a525ef351a070e8ed0805e9a24/src%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fitems.rs?ref=c5a5db2b2be097a525ef351a070e8ed0805e9a24", "patch": "@@ -387,8 +387,6 @@ impl<'a> FmtVisitor<'a> {\n             Some(ref body_str) => self.buffer.push_str(body_str),\n             None => if contains_comment(&enum_snippet[brace_pos..]) {\n                 self.format_missing_no_indent(span.hi() - BytePos(1))\n-            } else {\n-                self.format_missing(span.hi() - BytePos(1))\n             },\n         }\n         self.block_indent = self.block_indent.block_unindent(self.config);\n@@ -535,11 +533,7 @@ pub fn format_impl(\n         let where_budget = if result.contains('\\n') {\n             context.config.max_width()\n         } else {\n-            context\n-                .config\n-                .max_width()\n-                .checked_sub(last_line_width(&result))\n-                .unwrap_or(0)\n+            context.budget(last_line_width(&result))\n         };\n         let option = WhereClauseOption::snuggled(&ref_and_type);\n         let where_clause_str = try_opt!(rewrite_where_clause(\n@@ -758,11 +752,7 @@ fn format_impl_ref_and_type(\n         };\n         let used_space = last_line_width(&result) + trait_ref_overhead + curly_brace_overhead;\n         // 1 = space before the type.\n-        let budget = context\n-            .config\n-            .max_width()\n-            .checked_sub(used_space + 1)\n-            .unwrap_or(0);\n+        let budget = context.budget(used_space + 1);\n         if let Some(self_ty_str) = self_ty.rewrite(context, Shape::legacy(budget, offset)) {\n             if !self_ty_str.contains('\\n') {\n                 if trait_ref.is_some() {\n@@ -783,7 +773,7 @@ fn format_impl_ref_and_type(\n         if trait_ref.is_some() {\n             result.push_str(\"for \");\n         }\n-        let budget = context.config.max_width() - last_line_width(&result);\n+        let budget = context.budget(last_line_width(&result));\n         let type_offset = match context.config.where_style() {\n             Style::Legacy => new_line_offset + trait_ref_overhead,\n             Style::Rfc => new_line_offset,\n@@ -927,12 +917,7 @@ pub fn format_trait(context: &RewriteContext, item: &ast::Item, offset: Indent)\n             Density::Tall\n         };\n \n-        let where_budget = try_opt!(\n-            context\n-                .config\n-                .max_width()\n-                .checked_sub(last_line_width(&result))\n-        );\n+        let where_budget = context.budget(last_line_width(&result));\n         let pos_before_where = if type_param_bounds.is_empty() {\n             generics.where_clause.span.lo()\n         } else {\n@@ -1078,11 +1063,7 @@ pub fn format_struct_struct(\n             let overhead = if fields.is_empty() { 3 } else { 2 };\n             if (context.config.item_brace_style() == BraceStyle::AlwaysNextLine &&\n                 !fields.is_empty()) ||\n-                context\n-                    .config\n-                    .max_width()\n-                    .checked_sub(result.len())\n-                    .unwrap_or(0) < overhead\n+                context.config.max_width() < overhead + result.len()\n             {\n                 format!(\"\\n{}{{\", offset.block_only().to_string(context.config))\n             } else {\n@@ -1092,12 +1073,10 @@ pub fn format_struct_struct(\n     };\n     // 1 = `}`\n     let overhead = if fields.is_empty() { 1 } else { 0 };\n-    let max_len = context\n-        .config\n-        .max_width()\n-        .checked_sub(offset.width())\n-        .unwrap_or(0);\n-    if !generics_str.contains('\\n') && result.len() + generics_str.len() + overhead > max_len {\n+    let total_width = result.len() + generics_str.len() + overhead;\n+    if !generics_str.is_empty() && !generics_str.contains('\\n') &&\n+        total_width > context.config.max_width()\n+    {\n         result.push('\\n');\n         result.push_str(&offset.to_string(context.config));\n         result.push_str(&generics_str.trim_left());\n@@ -1122,11 +1101,7 @@ pub fn format_struct_struct(\n     }\n \n     // 3 = ` ` and ` }`\n-    let one_line_budget = context\n-        .config\n-        .max_width()\n-        .checked_sub(result.len() + 3 + offset.width())\n-        .unwrap_or(0);\n+    let one_line_budget = context.budget(result.len() + 3 + offset.width());\n     let one_line_budget =\n         one_line_width.map_or(0, |one_line_width| min(one_line_width, one_line_budget));\n \n@@ -1286,12 +1261,7 @@ pub fn rewrite_type_alias(\n     let generics_str = try_opt!(rewrite_generics(context, generics, shape, g_span));\n     result.push_str(&generics_str);\n \n-    let where_budget = try_opt!(\n-        context\n-            .config\n-            .max_width()\n-            .checked_sub(last_line_width(&result))\n-    );\n+    let where_budget = context.budget(last_line_width(&result));\n     let option = WhereClauseOption::snuggled(&result);\n     let where_clause_str = try_opt!(rewrite_where_clause(\n         context,\n@@ -1314,11 +1284,7 @@ pub fn rewrite_type_alias(\n     let line_width = last_line_width(&result);\n     // This checked_sub may fail as the extra space after '=' is not taken into account\n     // In that case the budget is set to 0 which will make ty.rewrite retry on a new line\n-    let budget = context\n-        .config\n-        .max_width()\n-        .checked_sub(indent.width() + line_width + \";\".len())\n-        .unwrap_or(0);\n+    let budget = context.budget(indent.width() + line_width + \";\".len());\n     let type_indent = indent + line_width;\n     // Try to fit the type on the same line\n     let ty_str = try_opt!(\n@@ -1331,12 +1297,7 @@ pub fn rewrite_type_alias(\n                 let type_indent = indent.block_indent(context.config);\n                 result.push('\\n');\n                 result.push_str(&type_indent.to_string(context.config));\n-                let budget = try_opt!(\n-                    context\n-                        .config\n-                        .max_width()\n-                        .checked_sub(type_indent.width() + \";\".len())\n-                );\n+                let budget = context.budget(type_indent.width() + \";\".len());\n                 ty.rewrite(context, Shape::legacy(budget, type_indent))\n             })\n     );\n@@ -1520,7 +1481,7 @@ pub fn rewrite_static(\n     if let Some(expr) = expr_opt {\n         let lhs = format!(\"{}{} =\", prefix, ty_str);\n         // 1 = ;\n-        let remaining_width = context.config.max_width() - offset.block_indent - 1;\n+        let remaining_width = context.budget(offset.block_indent + 1);\n         rewrite_assign_rhs(\n             context,\n             lhs,\n@@ -1567,7 +1528,7 @@ pub fn rewrite_associated_type(\n         let ty_str = try_opt!(ty.rewrite(\n             context,\n             Shape::legacy(\n-                context.config.max_width() - indent.block_indent - prefix.len() - 2,\n+                context.budget(indent.block_indent + prefix.len() + 2),\n                 indent.block_only(),\n             ),\n         ));\n@@ -1775,11 +1736,7 @@ fn rewrite_fn_base(\n         2\n     };\n     let used_width = last_line_used_width(&result, indent.width());\n-    let one_line_budget = context\n-        .config\n-        .max_width()\n-        .checked_sub(used_width + overhead)\n-        .unwrap_or(0);\n+    let one_line_budget = context.budget(used_width + overhead);\n     let shape = Shape {\n         width: one_line_budget,\n         indent: indent,\n@@ -2015,11 +1972,7 @@ fn rewrite_fn_base(\n     };\n \n     if where_clause.predicates.len() == 1 && should_compress_where {\n-        let budget = context\n-            .config\n-            .max_width()\n-            .checked_sub(last_line_used_width(&result, indent.width()))\n-            .unwrap_or(0);\n+        let budget = context.budget(last_line_used_width(&result, indent.width()));\n         if let Some(where_clause_str) = rewrite_where_clause(\n             context,\n             where_clause,\n@@ -2298,27 +2251,19 @@ fn compute_budgets_for_args(\n             // 1 = `;`\n             used_space += 1;\n         }\n-        let one_line_budget = context\n-            .config\n-            .max_width()\n-            .checked_sub(used_space)\n-            .unwrap_or(0);\n+        let one_line_budget = context.budget(used_space);\n \n         if one_line_budget > 0 {\n             // 4 = \"() {\".len()\n             let (indent, multi_line_budget) = match context.config.fn_args_layout() {\n                 IndentStyle::Block => {\n                     let indent = indent.block_indent(context.config);\n-                    let budget =\n-                        try_opt!(context.config.max_width().checked_sub(indent.width() + 1));\n-                    (indent, budget)\n+                    (indent, context.budget(indent.width() + 1))\n                 }\n                 IndentStyle::Visual => {\n                     let indent = indent + result.len() + 1;\n                     let multi_line_overhead = indent.width() + if newline_brace { 2 } else { 4 };\n-                    let budget =\n-                        try_opt!(context.config.max_width().checked_sub(multi_line_overhead));\n-                    (indent, budget)\n+                    (indent, context.budget(multi_line_overhead))\n                 }\n             };\n \n@@ -2334,8 +2279,7 @@ fn compute_budgets_for_args(\n         // Account for `)` and possibly ` {`.\n         IndentStyle::Visual => new_indent.width() + if ret_str_len == 0 { 1 } else { 3 },\n     };\n-    let max_space = try_opt!(context.config.max_width().checked_sub(used_space));\n-    Some((0, max_space, new_indent))\n+    Some((0, context.budget(used_space), new_indent))\n }\n \n fn newline_for_brace(config: &Config, where_clause: &ast::WhereClause, has_body: bool) -> bool {\n@@ -2748,11 +2692,7 @@ fn format_generics(\n     let mut result = try_opt!(rewrite_generics(context, generics, shape, span));\n \n     let same_line_brace = if !generics.where_clause.predicates.is_empty() || result.contains('\\n') {\n-        let budget = context\n-            .config\n-            .max_width()\n-            .checked_sub(last_line_used_width(&result, offset.width()))\n-            .unwrap_or(0);\n+        let budget = context.budget(last_line_used_width(&result, offset.width()));\n         let option = WhereClauseOption::snuggled(&result);\n         let where_clause_str = try_opt!(rewrite_where_clause(\n             context,\n@@ -2773,11 +2713,7 @@ fn format_generics(\n             brace_style != BraceStyle::AlwaysNextLine\n     };\n     let total_used_width = last_line_used_width(&result, used_width);\n-    let remaining_budget = context\n-        .config\n-        .max_width()\n-        .checked_sub(total_used_width)\n-        .unwrap_or(0);\n+    let remaining_budget = context.budget(total_used_width);\n     // If the same line brace if forced, it indicates that we are rewriting an item with empty body,\n     // and hence we take the closer into account as well for one line budget.\n     // We assume that the closer has the same length as the opener."}, {"sha": "b85d64b9e944a697a9f31dd70d8030391ce27df3", "filename": "tests/source/configs-item_brace_style-always_next_line.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c5a5db2b2be097a525ef351a070e8ed0805e9a24/tests%2Fsource%2Fconfigs-item_brace_style-always_next_line.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5a5db2b2be097a525ef351a070e8ed0805e9a24/tests%2Fsource%2Fconfigs-item_brace_style-always_next_line.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fconfigs-item_brace_style-always_next_line.rs?ref=c5a5db2b2be097a525ef351a070e8ed0805e9a24", "patch": "@@ -1,6 +1,10 @@\n // rustfmt-item_brace_style: AlwaysNextLine\n // Item brace style\n \n+enum Foo {}\n+\n+struct Bar {}\n+\n struct Lorem {\n     ipsum: bool,\n }"}, {"sha": "888d255859be46901908c12ac9fbb392d91838e2", "filename": "tests/target/configs-item_brace_style-always_next_line.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c5a5db2b2be097a525ef351a070e8ed0805e9a24/tests%2Ftarget%2Fconfigs-item_brace_style-always_next_line.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5a5db2b2be097a525ef351a070e8ed0805e9a24/tests%2Ftarget%2Fconfigs-item_brace_style-always_next_line.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fconfigs-item_brace_style-always_next_line.rs?ref=c5a5db2b2be097a525ef351a070e8ed0805e9a24", "patch": "@@ -1,6 +1,10 @@\n // rustfmt-item_brace_style: AlwaysNextLine\n // Item brace style\n \n+enum Foo {}\n+\n+struct Bar {}\n+\n struct Lorem\n {\n     ipsum: bool,"}]}