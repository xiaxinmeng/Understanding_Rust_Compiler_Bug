{"sha": "12c5f8cb75b0320f4ba9557417e5e554ffe2001b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEyYzVmOGNiNzViMDMyMGY0YmE5NTU3NDE3ZTVlNTU0ZmZlMjAwMWI=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2016-11-23T23:40:52Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2016-11-23T23:40:52Z"}, "message": "rustdoc: use libsyntax ast::Attribute instead of \"cleaning\" them.", "tree": {"sha": "5a0eabebe90b18134e49b77ac7ce2c70dca7b26d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5a0eabebe90b18134e49b77ac7ce2c70dca7b26d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/12c5f8cb75b0320f4ba9557417e5e554ffe2001b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/12c5f8cb75b0320f4ba9557417e5e554ffe2001b", "html_url": "https://github.com/rust-lang/rust/commit/12c5f8cb75b0320f4ba9557417e5e554ffe2001b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/12c5f8cb75b0320f4ba9557417e5e554ffe2001b/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "127a83df6615d09cda6ed9b53f7daba2d78c925d", "url": "https://api.github.com/repos/rust-lang/rust/commits/127a83df6615d09cda6ed9b53f7daba2d78c925d", "html_url": "https://github.com/rust-lang/rust/commit/127a83df6615d09cda6ed9b53f7daba2d78c925d"}], "stats": {"total": 528, "additions": 266, "deletions": 262}, "files": [{"sha": "e75754686402660d56fb22a22d52a8877cdf2625", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/12c5f8cb75b0320f4ba9557417e5e554ffe2001b/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c5f8cb75b0320f4ba9557417e5e554ffe2001b/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=12c5f8cb75b0320f4ba9557417e5e554ffe2001b", "patch": "@@ -135,8 +135,8 @@ fn try_inline_def<'a, 'tcx>(cx: &DocContext, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n }\n \n pub fn load_attrs<'a, 'tcx>(cx: &DocContext, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                            did: DefId) -> Vec<clean::Attribute> {\n-    tcx.get_attrs(did).iter().map(|a| a.clean(cx)).collect()\n+                            did: DefId) -> clean::Attributes {\n+    tcx.get_attrs(did).clean(cx)\n }\n \n /// Record an external fully qualified name in the external_paths cache.\n@@ -377,7 +377,7 @@ pub fn build_impl<'a, 'tcx>(cx: &DocContext,\n                         default,\n                     ),\n                     source: clean::Span::empty(),\n-                    attrs: vec![],\n+                    attrs: clean::Attributes::default(),\n                     visibility: None,\n                     stability: tcx.lookup_stability(item.def_id).clean(cx),\n                     deprecation: tcx.lookup_deprecation(item.def_id).clean(cx),\n@@ -424,7 +424,7 @@ pub fn build_impl<'a, 'tcx>(cx: &DocContext,\n                     name: Some(item.name.clean(cx)),\n                     inner: clean::TypedefItem(typedef, true),\n                     source: clean::Span::empty(),\n-                    attrs: vec![],\n+                    attrs: clean::Attributes::default(),\n                     visibility: None,\n                     stability: tcx.lookup_stability(item.def_id).clean(cx),\n                     deprecation: tcx.lookup_deprecation(item.def_id).clean(cx),"}, {"sha": "18cb9630f4938a77ee27b02f05b5eed46e6a5577", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 88, "deletions": 71, "changes": 159, "blob_url": "https://github.com/rust-lang/rust/blob/12c5f8cb75b0320f4ba9557417e5e554ffe2001b/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c5f8cb75b0320f4ba9557417e5e554ffe2001b/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=12c5f8cb75b0320f4ba9557417e5e554ffe2001b", "patch": "@@ -14,7 +14,6 @@\n pub use self::Type::*;\n pub use self::Mutability::*;\n pub use self::ItemEnum::*;\n-pub use self::Attribute::*;\n pub use self::TyParamBound::*;\n pub use self::SelfTy::*;\n pub use self::FunctionRetTy::*;\n@@ -25,7 +24,6 @@ use syntax::ast;\n use syntax::attr;\n use syntax::codemap::Spanned;\n use syntax::ptr::P;\n-use syntax::print::pprust as syntax_pprust;\n use syntax::symbol::keywords;\n use syntax_pos::{self, DUMMY_SP, Pos};\n \n@@ -44,6 +42,7 @@ use rustc::hir;\n \n use std::path::PathBuf;\n use std::rc::Rc;\n+use std::slice;\n use std::sync::Arc;\n use std::u32;\n use std::env::current_dir;\n@@ -227,7 +226,7 @@ impl<'a, 'tcx> Clean<Crate> for visit_ast::RustdocVisitor<'a, 'tcx> {\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct ExternalCrate {\n     pub name: String,\n-    pub attrs: Vec<Attribute>,\n+    pub attrs: Attributes,\n     pub primitives: Vec<PrimitiveType>,\n }\n \n@@ -258,7 +257,7 @@ pub struct Item {\n     pub source: Span,\n     /// Not everything has a name. E.g., impls\n     pub name: Option<String>,\n-    pub attrs: Vec<Attribute>,\n+    pub attrs: Attributes,\n     pub inner: ItemEnum,\n     pub visibility: Option<Visibility>,\n     pub def_id: DefId,\n@@ -270,7 +269,7 @@ impl Item {\n     /// Finds the `doc` attribute as a NameValue and returns the corresponding\n     /// value found.\n     pub fn doc_value<'a>(&'a self) -> Option<&'a str> {\n-        self.attrs.value(\"doc\")\n+        self.attrs.doc_value()\n     }\n     pub fn is_crate(&self) -> bool {\n         match self.inner {\n@@ -459,86 +458,104 @@ impl Clean<Item> for doctree::Module {\n     }\n }\n \n-pub trait Attributes {\n-    fn has_word(&self, &str) -> bool;\n-    fn value<'a>(&'a self, &str) -> Option<&'a str>;\n-    fn list<'a>(&'a self, &str) -> &'a [Attribute];\n+pub struct ListAttributesIter<'a> {\n+    attrs: slice::Iter<'a, ast::Attribute>,\n+    current_list: slice::Iter<'a, ast::NestedMetaItem>,\n+    name: &'a str\n }\n \n-impl Attributes for [Attribute] {\n-    /// Returns whether the attribute list contains a specific `Word`\n-    fn has_word(&self, word: &str) -> bool {\n-        for attr in self {\n-            if let Word(ref w) = *attr {\n-                if word == *w {\n-                    return true;\n-                }\n-            }\n+impl<'a> Iterator for ListAttributesIter<'a> {\n+    type Item = &'a ast::NestedMetaItem;\n+\n+    fn next(&mut self) -> Option<Self::Item> {\n+        if let Some(nested) = self.current_list.next() {\n+            return Some(nested);\n         }\n-        false\n-    }\n \n-    /// Finds an attribute as NameValue and returns the corresponding value found.\n-    fn value<'a>(&'a self, name: &str) -> Option<&'a str> {\n-        for attr in self {\n-            if let NameValue(ref x, ref v) = *attr {\n-                if name == *x {\n-                    return Some(v);\n+        for attr in &mut self.attrs {\n+            if let Some(ref list) = attr.meta_item_list() {\n+                if attr.check_name(self.name) {\n+                    self.current_list = list.iter();\n+                    if let Some(nested) = self.current_list.next() {\n+                        return Some(nested);\n+                    }\n                 }\n             }\n         }\n+\n         None\n     }\n+}\n \n+pub trait AttributesExt {\n     /// Finds an attribute as List and returns the list of attributes nested inside.\n-    fn list<'a>(&'a self, name: &str) -> &'a [Attribute] {\n-        for attr in self {\n-            if let List(ref x, ref list) = *attr {\n-                if name == *x {\n-                    return &list[..];\n-                }\n-            }\n+    fn lists<'a>(&'a self, &'a str) -> ListAttributesIter<'a>;\n+}\n+\n+impl AttributesExt for [ast::Attribute] {\n+    fn lists<'a>(&'a self, name: &'a str) -> ListAttributesIter<'a> {\n+        ListAttributesIter {\n+            attrs: self.iter(),\n+            current_list: [].iter(),\n+            name: name\n         }\n-        &[]\n     }\n }\n \n-/// This is a flattened version of the AST's Attribute + MetaItem.\n-#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Debug)]\n-pub enum Attribute {\n-    Word(String),\n-    List(String, Vec<Attribute>),\n-    NameValue(String, String),\n-    Literal(String),\n+pub trait NestedAttributesExt {\n+    /// Returns whether the attribute list contains a specific `Word`\n+    fn has_word(self, &str) -> bool;\n+}\n+\n+impl<'a, I: IntoIterator<Item=&'a ast::NestedMetaItem>> NestedAttributesExt for I {\n+    fn has_word(self, word: &str) -> bool {\n+        self.into_iter().any(|attr| attr.is_word() && attr.check_name(word))\n+    }\n }\n \n-impl Clean<Attribute> for ast::NestedMetaItem {\n-    fn clean(&self, cx: &DocContext) -> Attribute {\n-        if let Some(mi) = self.meta_item() {\n-            mi.clean(cx)\n-        } else { // must be a literal\n-            let lit = self.literal().unwrap();\n-            Literal(syntax_pprust::lit_to_string(lit))\n+#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Debug, Default)]\n+pub struct Attributes {\n+    pub doc_strings: Vec<String>,\n+    pub other_attrs: Vec<ast::Attribute>\n+}\n+\n+impl Attributes {\n+    pub fn from_ast(attrs: &[ast::Attribute]) -> Attributes {\n+        let mut doc_strings = vec![];\n+        let other_attrs = attrs.iter().filter_map(|attr| {\n+            attr.with_desugared_doc(|attr| {\n+                if let Some(value) = attr.value_str() {\n+                    if attr.check_name(\"doc\") {\n+                        doc_strings.push(value.to_string());\n+                        return None;\n+                    }\n+                }\n+\n+                Some(attr.clone())\n+            })\n+        }).collect();\n+        Attributes {\n+            doc_strings: doc_strings,\n+            other_attrs: other_attrs\n         }\n     }\n+\n+    /// Finds the `doc` attribute as a NameValue and returns the corresponding\n+    /// value found.\n+    pub fn doc_value<'a>(&'a self) -> Option<&'a str> {\n+        self.doc_strings.first().map(|s| &s[..])\n+    }\n }\n \n-impl Clean<Attribute> for ast::MetaItem {\n-    fn clean(&self, cx: &DocContext) -> Attribute {\n-        if self.is_word() {\n-            Word(self.name().to_string())\n-        } else if let Some(v) = self.value_str() {\n-            NameValue(self.name().to_string(), v.to_string())\n-        } else { // must be a list\n-            let l = self.meta_item_list().unwrap();\n-            List(self.name().to_string(), l.clean(cx))\n-       }\n+impl AttributesExt for Attributes {\n+    fn lists<'a>(&'a self, name: &'a str) -> ListAttributesIter<'a> {\n+        self.other_attrs.lists(name)\n     }\n }\n \n-impl Clean<Attribute> for ast::Attribute {\n-    fn clean(&self, cx: &DocContext) -> Attribute {\n-        self.with_desugared_doc(|a| a.meta().clean(cx))\n+impl Clean<Attributes> for [ast::Attribute] {\n+    fn clean(&self, _cx: &DocContext) -> Attributes {\n+        Attributes::from_ast(self)\n     }\n }\n \n@@ -1048,7 +1065,7 @@ impl Clean<Method> for hir::MethodSig {\n             },\n             output: self.decl.output.clean(cx),\n             variadic: false,\n-            attrs: Vec::new()\n+            attrs: Attributes::default()\n         };\n         Method {\n             generics: self.generics.clean(cx),\n@@ -1076,7 +1093,7 @@ impl Clean<TyMethod> for hir::MethodSig {\n             },\n             output: self.decl.output.clean(cx),\n             variadic: false,\n-            attrs: Vec::new()\n+            attrs: Attributes::default()\n         };\n         TyMethod {\n             unsafety: self.unsafety.clone(),\n@@ -1122,7 +1139,7 @@ pub struct FnDecl {\n     pub inputs: Arguments,\n     pub output: FunctionRetTy,\n     pub variadic: bool,\n-    pub attrs: Vec<Attribute>,\n+    pub attrs: Attributes,\n }\n \n impl FnDecl {\n@@ -1148,7 +1165,7 @@ impl Clean<FnDecl> for hir::FnDecl {\n             },\n             output: self.output.clean(cx),\n             variadic: self.variadic,\n-            attrs: Vec::new()\n+            attrs: Attributes::default()\n         }\n     }\n }\n@@ -1163,7 +1180,7 @@ impl<'a, 'tcx> Clean<FnDecl> for (DefId, &'a ty::PolyFnSig<'tcx>) {\n         }.peekable();\n         FnDecl {\n             output: Return(sig.0.output.clean(cx)),\n-            attrs: Vec::new(),\n+            attrs: Attributes::default(),\n             variadic: sig.0.variadic,\n             inputs: Arguments {\n                 values: sig.0.inputs.iter().map(|t| {\n@@ -1616,11 +1633,11 @@ impl PrimitiveType {\n         }\n     }\n \n-    fn find(attrs: &[Attribute]) -> Option<PrimitiveType> {\n-        for attr in attrs.list(\"doc\") {\n-            if let NameValue(ref k, ref v) = *attr {\n-                if \"primitive\" == *k {\n-                    if let ret@Some(..) = PrimitiveType::from_str(v) {\n+    fn find(attrs: &Attributes) -> Option<PrimitiveType> {\n+        for attr in attrs.lists(\"doc\") {\n+            if let Some(v) = attr.value_str() {\n+                if attr.check_name(\"primitive\") {\n+                    if let ret@Some(..) = PrimitiveType::from_str(&v.as_str()) {\n                         return ret;\n                     }\n                 }"}, {"sha": "757db81c4402196fc43e77a6547639117b591b0e", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 50, "deletions": 53, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/12c5f8cb75b0320f4ba9557417e5e554ffe2001b/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c5f8cb75b0320f4ba9557417e5e554ffe2001b/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=12c5f8cb75b0320f4ba9557417e5e554ffe2001b", "patch": "@@ -53,7 +53,7 @@ use std::sync::Arc;\n use externalfiles::ExternalHtml;\n \n use serialize::json::{ToJson, Json, as_json};\n-use syntax::abi;\n+use syntax::{abi, ast};\n use syntax::feature_gate::UnstableFeatures;\n use rustc::hir::def_id::{CrateNum, CRATE_DEF_INDEX, DefId, LOCAL_CRATE};\n use rustc::middle::privacy::AccessLevels;\n@@ -62,7 +62,7 @@ use rustc::hir;\n use rustc::util::nodemap::{FxHashMap, FxHashSet};\n use rustc_data_structures::flock;\n \n-use clean::{self, Attributes, GetDefId, SelfTy, Mutability};\n+use clean::{self, AttributesExt, GetDefId, SelfTy, Mutability};\n use doctree;\n use fold::DocFolder;\n use html::escape::Escape;\n@@ -453,30 +453,26 @@ pub fn run(mut krate: clean::Crate,\n \n     // Crawl the crate attributes looking for attributes which control how we're\n     // going to emit HTML\n-    if let Some(attrs) = krate.module.as_ref().map(|m| m.attrs.list(\"doc\")) {\n-        for attr in attrs {\n-            match *attr {\n-                clean::NameValue(ref x, ref s)\n-                        if \"html_favicon_url\" == *x => {\n+    if let Some(attrs) = krate.module.as_ref().map(|m| &m.attrs) {\n+        for attr in attrs.lists(\"doc\") {\n+            let name = attr.name().map(|s| s.as_str());\n+            match (name.as_ref().map(|s| &s[..]), attr.value_str()) {\n+                (Some(\"html_favicon_url\"), Some(s)) => {\n                     scx.layout.favicon = s.to_string();\n                 }\n-                clean::NameValue(ref x, ref s)\n-                        if \"html_logo_url\" == *x => {\n+                (Some(\"html_logo_url\"), Some(s)) => {\n                     scx.layout.logo = s.to_string();\n                 }\n-                clean::NameValue(ref x, ref s)\n-                        if \"html_playground_url\" == *x => {\n+                (Some(\"html_playground_url\"), Some(s)) => {\n                     markdown::PLAYGROUND.with(|slot| {\n                         let name = krate.name.clone();\n-                        *slot.borrow_mut() = Some((Some(name), s.clone()));\n+                        *slot.borrow_mut() = Some((Some(name), s.to_string()));\n                     });\n                 }\n-                clean::NameValue(ref x, ref s)\n-                        if \"issue_tracker_base_url\" == *x => {\n+                (Some(\"issue_tracker_base_url\"), Some(s)) => {\n                     scx.issue_tracker_base_url = Some(s.to_string());\n                 }\n-                clean::Word(ref x)\n-                        if \"html_no_source\" == *x => {\n+                (Some(\"html_no_source\"), None) if attr.is_word() => {\n                     scx.include_sources = false;\n                 }\n                 _ => {}\n@@ -860,13 +856,16 @@ fn extern_location(e: &clean::ExternalCrate, dst: &Path) -> ExternalLocation {\n \n     // Failing that, see if there's an attribute specifying where to find this\n     // external crate\n-    e.attrs.list(\"doc\").value(\"html_root_url\").map(|url| {\n-        let mut url = url.to_owned();\n+    e.attrs.lists(\"doc\")\n+     .filter(|a| a.check_name(\"html_root_url\"))\n+     .filter_map(|a| a.value_str())\n+     .map(|url| {\n+        let mut url = url.to_string();\n         if !url.ends_with(\"/\") {\n             url.push('/')\n         }\n         Remote(url)\n-    }).unwrap_or(Unknown) // Well, at least we tried.\n+    }).next().unwrap_or(Unknown) // Well, at least we tried.\n }\n \n impl<'a> DocFolder for SourceCollector<'a> {\n@@ -2511,49 +2510,47 @@ fn item_enum(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n     Ok(())\n }\n \n-fn attribute_without_value(s: &str) -> bool {\n-    [\"must_use\", \"no_mangle\", \"unsafe_destructor_blind_to_params\"].iter().any(|x| x == &s)\n-}\n-\n-fn attribute_with_value(s: &str) -> bool {\n-    [\"export_name\", \"lang\", \"link_section\", \"must_use\"].iter().any(|x| x == &s)\n-}\n-\n-fn attribute_with_values(s: &str) -> bool {\n-    [\"repr\"].iter().any(|x| x == &s)\n-}\n+fn render_attribute(attr: &ast::MetaItem) -> Option<String> {\n+    let name = attr.name();\n \n-fn render_attribute(attr: &clean::Attribute, recurse: bool) -> Option<String> {\n-    match *attr {\n-        clean::Word(ref s) if attribute_without_value(&*s) || recurse => {\n-            Some(format!(\"{}\", s))\n-        }\n-        clean::NameValue(ref k, ref v) if attribute_with_value(&*k) => {\n-            Some(format!(\"{} = \\\"{}\\\"\", k, v))\n-        }\n-        clean::List(ref k, ref values) if attribute_with_values(&*k) => {\n-            let display: Vec<_> = values.iter()\n-                                        .filter_map(|value| render_attribute(value, true))\n-                                        .map(|entry| format!(\"{}\", entry))\n-                                        .collect();\n+    if attr.is_word() {\n+        Some(format!(\"{}\", name))\n+    } else if let Some(v) = attr.value_str() {\n+        Some(format!(\"{} = {:?}\", name, &v.as_str()[..]))\n+    } else if let Some(values) = attr.meta_item_list() {\n+        let display: Vec<_> = values.iter().filter_map(|attr| {\n+            attr.meta_item().and_then(|mi| render_attribute(mi))\n+        }).collect();\n \n-            if display.len() > 0 {\n-                Some(format!(\"{}({})\", k, display.join(\", \")))\n-            } else {\n-                None\n-            }\n-        }\n-        _ => {\n+        if display.len() > 0 {\n+            Some(format!(\"{}({})\", name, display.join(\", \")))\n+        } else {\n             None\n         }\n+    } else {\n+        None\n     }\n }\n \n+const ATTRIBUTE_WHITELIST: &'static [&'static str] = &[\n+    \"export_name\",\n+    \"lang\",\n+    \"link_section\",\n+    \"must_use\",\n+    \"no_mangle\",\n+    \"repr\",\n+    \"unsafe_destructor_blind_to_params\"\n+];\n+\n fn render_attributes(w: &mut fmt::Formatter, it: &clean::Item) -> fmt::Result {\n     let mut attrs = String::new();\n \n-    for attr in &it.attrs {\n-        if let Some(s) = render_attribute(attr, false) {\n+    for attr in &it.attrs.other_attrs {\n+        let name = attr.name();\n+        if !ATTRIBUTE_WHITELIST.contains(&&name.as_str()[..]) {\n+            continue;\n+        }\n+        if let Some(s) = render_attribute(attr.meta()) {\n             attrs.push_str(&format!(\"#[{}]\\n\", s));\n         }\n     }\n@@ -2810,7 +2807,7 @@ fn render_impl(w: &mut fmt::Formatter, cx: &Context, i: &Impl, link: AssocItemLi\n         }\n         write!(w, \"</span>\")?;\n         write!(w, \"</h3>\\n\")?;\n-        if let Some(ref dox) = i.impl_item.attrs.value(\"doc\") {\n+        if let Some(ref dox) = i.impl_item.doc_value() {\n             write!(w, \"<div class='docblock'>{}</div>\", Markdown(dox))?;\n         }\n     }"}, {"sha": "60ce7ea53953a5c5dbdef176dd55d0b4d3408785", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 89, "deletions": 83, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/12c5f8cb75b0320f4ba9557417e5e554ffe2001b/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c5f8cb75b0320f4ba9557417e5e554ffe2001b/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=12c5f8cb75b0320f4ba9557417e5e554ffe2001b", "patch": "@@ -89,7 +89,7 @@ pub mod visit_ast;\n pub mod visit_lib;\n pub mod test;\n \n-use clean::Attributes;\n+use clean::AttributesExt;\n \n struct Output {\n     krate: clean::Crate,\n@@ -280,43 +280,45 @@ pub fn main_args(args: &[String]) -> isize {\n                                                  !matches.opt_present(\"markdown-no-toc\")),\n         (false, false) => {}\n     }\n-    let out = match acquire_input(input, externs, &matches) {\n-        Ok(out) => out,\n-        Err(s) => {\n-            println!(\"input error: {}\", s);\n-            return 1;\n-        }\n-    };\n-    let Output { krate, passes, renderinfo } = out;\n-    info!(\"going to format\");\n-    match matches.opt_str(\"w\").as_ref().map(|s| &**s) {\n-        Some(\"html\") | None => {\n-            html::render::run(krate, &external_html,\n-                              output.unwrap_or(PathBuf::from(\"doc\")),\n-                              passes.into_iter().collect(),\n-                              css_file_extension,\n-                              renderinfo)\n-                .expect(\"failed to generate documentation\");\n-            0\n-        }\n-        Some(s) => {\n-            println!(\"unknown output format: {}\", s);\n-            1\n+\n+    let output_format = matches.opt_str(\"w\");\n+    let res = acquire_input(input, externs, &matches, move |out| {\n+        let Output { krate, passes, renderinfo } = out;\n+        info!(\"going to format\");\n+        match output_format.as_ref().map(|s| &**s) {\n+            Some(\"html\") | None => {\n+                html::render::run(krate, &external_html,\n+                                  output.unwrap_or(PathBuf::from(\"doc\")),\n+                                  passes.into_iter().collect(),\n+                                  css_file_extension,\n+                                  renderinfo)\n+                    .expect(\"failed to generate documentation\");\n+                0\n+            }\n+            Some(s) => {\n+                println!(\"unknown output format: {}\", s);\n+                1\n+            }\n         }\n-    }\n+    });\n+    res.unwrap_or_else(|s| {\n+        println!(\"input error: {}\", s);\n+        1\n+    })\n }\n \n /// Looks inside the command line arguments to extract the relevant input format\n /// and files and then generates the necessary rustdoc output for formatting.\n-fn acquire_input(input: &str,\n-                 externs: Externs,\n-                 matches: &getopts::Matches) -> Result<Output, String> {\n+fn acquire_input<R, F>(input: &str,\n+                       externs: Externs,\n+                       matches: &getopts::Matches,\n+                       f: F)\n+                       -> Result<R, String>\n+where R: 'static + Send, F: 'static + Send + FnOnce(Output) -> R {\n     match matches.opt_str(\"r\").as_ref().map(|s| &**s) {\n-        Some(\"rust\") => Ok(rust_input(input, externs, matches)),\n+        Some(\"rust\") => Ok(rust_input(input, externs, matches, f)),\n         Some(s) => Err(format!(\"unknown input format: {}\", s)),\n-        None => {\n-            Ok(rust_input(input, externs, matches))\n-        }\n+        None => Ok(rust_input(input, externs, matches, f))\n     }\n }\n \n@@ -342,7 +344,8 @@ fn parse_externs(matches: &getopts::Matches) -> Result<Externs, String> {\n /// generated from the cleaned AST of the crate.\n ///\n /// This form of input will run all of the plug/cleaning passes\n-fn rust_input(cratefile: &str, externs: Externs, matches: &getopts::Matches) -> Output {\n+fn rust_input<R, F>(cratefile: &str, externs: Externs, matches: &getopts::Matches, f: F) -> R\n+where R: 'static + Send, F: 'static + Send + FnOnce(Output) -> R {\n     let mut default_passes = !matches.opt_present(\"no-defaults\");\n     let mut passes = matches.opt_strs(\"passes\");\n     let mut plugins = matches.opt_strs(\"plugins\");\n@@ -355,6 +358,8 @@ fn rust_input(cratefile: &str, externs: Externs, matches: &getopts::Matches) ->\n     let cfgs = matches.opt_strs(\"cfg\");\n     let triple = matches.opt_str(\"target\");\n     let maybe_sysroot = matches.opt_str(\"sysroot\").map(PathBuf::from);\n+    let crate_name = matches.opt_str(\"crate-name\");\n+    let plugin_path = matches.opt_str(\"plugin-path\");\n \n     let cr = PathBuf::from(cratefile);\n     info!(\"starting to run rustc\");\n@@ -363,67 +368,68 @@ fn rust_input(cratefile: &str, externs: Externs, matches: &getopts::Matches) ->\n     rustc_driver::monitor(move || {\n         use rustc::session::config::Input;\n \n-        tx.send(core::run_core(paths, cfgs, externs, Input::File(cr),\n-                               triple, maybe_sysroot)).unwrap();\n-    });\n-    let (mut krate, renderinfo) = rx.recv().unwrap();\n-    info!(\"finished with rustc\");\n+        let (mut krate, renderinfo) =\n+            core::run_core(paths, cfgs, externs, Input::File(cr), triple, maybe_sysroot);\n \n-    if let Some(name) = matches.opt_str(\"crate-name\") {\n-        krate.name = name\n-    }\n+        info!(\"finished with rustc\");\n \n-    // Process all of the crate attributes, extracting plugin metadata along\n-    // with the passes which we are supposed to run.\n-    for attr in krate.module.as_ref().unwrap().attrs.list(\"doc\") {\n-        match *attr {\n-            clean::Word(ref w) if \"no_default_passes\" == *w => {\n-                default_passes = false;\n-            },\n-            clean::NameValue(ref name, ref value) => {\n-                let sink = match &name[..] {\n-                    \"passes\" => &mut passes,\n-                    \"plugins\" => &mut plugins,\n+        if let Some(name) = crate_name {\n+            krate.name = name\n+        }\n+\n+        // Process all of the crate attributes, extracting plugin metadata along\n+        // with the passes which we are supposed to run.\n+        for attr in krate.module.as_ref().unwrap().attrs.lists(\"doc\") {\n+            let name = attr.name().map(|s| s.as_str());\n+            let name = name.as_ref().map(|s| &s[..]);\n+            if attr.is_word() {\n+                if name == Some(\"no_default_passes\") {\n+                    default_passes = false;\n+                }\n+            } else if let Some(value) = attr.value_str() {\n+                let sink = match name {\n+                    Some(\"passes\") => &mut passes,\n+                    Some(\"plugins\") => &mut plugins,\n                     _ => continue,\n                 };\n-                for p in value.split_whitespace() {\n+                for p in value.as_str().split_whitespace() {\n                     sink.push(p.to_string());\n                 }\n             }\n-            _ => (),\n         }\n-    }\n \n-    if default_passes {\n-        for name in passes::DEFAULT_PASSES.iter().rev() {\n-            passes.insert(0, name.to_string());\n+        if default_passes {\n+            for name in passes::DEFAULT_PASSES.iter().rev() {\n+                passes.insert(0, name.to_string());\n+            }\n         }\n-    }\n \n-    // Load all plugins/passes into a PluginManager\n-    let path = matches.opt_str(\"plugin-path\")\n-                      .unwrap_or(\"/tmp/rustdoc/plugins\".to_string());\n-    let mut pm = plugins::PluginManager::new(PathBuf::from(path));\n-    for pass in &passes {\n-        let plugin = match passes::PASSES.iter()\n-                                         .position(|&(p, ..)| {\n-                                             p == *pass\n-                                         }) {\n-            Some(i) => passes::PASSES[i].1,\n-            None => {\n-                error!(\"unknown pass {}, skipping\", *pass);\n-                continue\n-            },\n-        };\n-        pm.add_plugin(plugin);\n-    }\n-    info!(\"loading plugins...\");\n-    for pname in plugins {\n-        pm.load_plugin(pname);\n-    }\n+        // Load all plugins/passes into a PluginManager\n+        let path = plugin_path.unwrap_or(\"/tmp/rustdoc/plugins\".to_string());\n+        let mut pm = plugins::PluginManager::new(PathBuf::from(path));\n+        for pass in &passes {\n+            let plugin = match passes::PASSES.iter()\n+                                             .position(|&(p, ..)| {\n+                                                 p == *pass\n+                                             }) {\n+                Some(i) => passes::PASSES[i].1,\n+                None => {\n+                    error!(\"unknown pass {}, skipping\", *pass);\n+                    continue\n+                },\n+            };\n+            pm.add_plugin(plugin);\n+        }\n+        info!(\"loading plugins...\");\n+        for pname in plugins {\n+            pm.load_plugin(pname);\n+        }\n+\n+        // Run everything!\n+        info!(\"Executing passes/plugins\");\n+        let krate = pm.run_plugins(krate);\n \n-    // Run everything!\n-    info!(\"Executing passes/plugins\");\n-    let krate = pm.run_plugins(krate);\n-    Output { krate: krate, renderinfo: renderinfo, passes: passes }\n+        tx.send(f(Output { krate: krate, renderinfo: renderinfo, passes: passes })).unwrap();\n+    });\n+    rx.recv().unwrap()\n }"}, {"sha": "3c63302127c5eef17b7df6e4818d3851d1f9db0d", "filename": "src/librustdoc/passes/collapse_docs.rs", "status": "modified", "additions": 15, "deletions": 22, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/12c5f8cb75b0320f4ba9557417e5e554ffe2001b/src%2Flibrustdoc%2Fpasses%2Fcollapse_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c5f8cb75b0320f4ba9557417e5e554ffe2001b/src%2Flibrustdoc%2Fpasses%2Fcollapse_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollapse_docs.rs?ref=12c5f8cb75b0320f4ba9557417e5e554ffe2001b", "patch": "@@ -8,40 +8,33 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::string::String;\n-\n use clean::{self, Item};\n use plugins;\n use fold;\n use fold::DocFolder;\n \n pub fn collapse_docs(krate: clean::Crate) -> plugins::PluginResult {\n-    let mut collapser = Collapser;\n-    let krate = collapser.fold_crate(krate);\n-    krate\n+    Collapser.fold_crate(krate)\n }\n \n struct Collapser;\n \n impl fold::DocFolder for Collapser {\n     fn fold_item(&mut self, mut i: Item) -> Option<Item> {\n-        let mut docstr = String::new();\n-        for attr in &i.attrs {\n-            if let clean::NameValue(ref x, ref s) = *attr {\n-                if \"doc\" == *x {\n-                    docstr.push_str(s);\n-                    docstr.push('\\n');\n-                }\n-            }\n-        }\n-        let mut a: Vec<clean::Attribute> = i.attrs.iter().filter(|&a| match a {\n-            &clean::NameValue(ref x, _) if \"doc\" == *x => false,\n-            _ => true\n-        }).cloned().collect();\n-        if !docstr.is_empty() {\n-            a.push(clean::NameValue(\"doc\".to_string(), docstr));\n-        }\n-        i.attrs = a;\n+        i.attrs.collapse_doc_comments();\n         self.fold_item_recur(i)\n     }\n }\n+\n+impl clean::Attributes {\n+    pub fn collapse_doc_comments(&mut self) {\n+        let mut doc_string = self.doc_strings.join(\"\\n\");\n+        if doc_string.is_empty() {\n+            self.doc_strings = vec![];\n+        } else {\n+            // FIXME(eddyb) Is this still needed?\n+            doc_string.push('\\n');\n+            self.doc_strings = vec![doc_string];\n+        }\n+    }\n+}"}, {"sha": "68c1231fc6f7c58e7266ee3e3c52708fa36e7b68", "filename": "src/librustdoc/passes/strip_hidden.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/12c5f8cb75b0320f4ba9557417e5e554ffe2001b/src%2Flibrustdoc%2Fpasses%2Fstrip_hidden.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c5f8cb75b0320f4ba9557417e5e554ffe2001b/src%2Flibrustdoc%2Fpasses%2Fstrip_hidden.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fstrip_hidden.rs?ref=12c5f8cb75b0320f4ba9557417e5e554ffe2001b", "patch": "@@ -11,7 +11,7 @@\n use rustc::util::nodemap::DefIdSet;\n use std::mem;\n \n-use clean::{self, Attributes};\n+use clean::{self, AttributesExt, NestedAttributesExt};\n use clean::Item;\n use plugins;\n use fold;\n@@ -41,7 +41,7 @@ struct Stripper<'a> {\n \n impl<'a> fold::DocFolder for Stripper<'a> {\n     fn fold_item(&mut self, i: Item) -> Option<Item> {\n-        if i.attrs.list(\"doc\").has_word(\"hidden\") {\n+        if i.attrs.lists(\"doc\").has_word(\"hidden\") {\n             debug!(\"found one in strip_hidden; removing\");\n             // use a dedicated hidden item for given item type if any\n             match i.inner {"}, {"sha": "4d94c30847852f42ce5393049f4b3ee22d6cecea", "filename": "src/librustdoc/passes/unindent_comments.rs", "status": "modified", "additions": 10, "deletions": 15, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/12c5f8cb75b0320f4ba9557417e5e554ffe2001b/src%2Flibrustdoc%2Fpasses%2Funindent_comments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c5f8cb75b0320f4ba9557417e5e554ffe2001b/src%2Flibrustdoc%2Fpasses%2Funindent_comments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Funindent_comments.rs?ref=12c5f8cb75b0320f4ba9557417e5e554ffe2001b", "patch": "@@ -17,31 +17,26 @@ use plugins;\n use fold::{self, DocFolder};\n \n pub fn unindent_comments(krate: clean::Crate) -> plugins::PluginResult {\n-    let mut cleaner = CommentCleaner;\n-    let krate = cleaner.fold_crate(krate);\n-    krate\n+    CommentCleaner.fold_crate(krate)\n }\n \n struct CommentCleaner;\n \n impl fold::DocFolder for CommentCleaner {\n     fn fold_item(&mut self, mut i: Item) -> Option<Item> {\n-        let mut avec: Vec<clean::Attribute> = Vec::new();\n-        for attr in &i.attrs {\n-            match attr {\n-                &clean::NameValue(ref x, ref s)\n-                        if \"doc\" == *x => {\n-                    avec.push(clean::NameValue(\"doc\".to_string(),\n-                                               unindent(s)))\n-                }\n-                x => avec.push(x.clone())\n-            }\n-        }\n-        i.attrs = avec;\n+        i.attrs.unindent_doc_comments();\n         self.fold_item_recur(i)\n     }\n }\n \n+impl clean::Attributes {\n+    pub fn unindent_doc_comments(&mut self) {\n+        for doc_string in &mut self.doc_strings {\n+            *doc_string = unindent(doc_string);\n+        }\n+    }\n+}\n+\n fn unindent(s: &str) -> String {\n     let lines = s.lines().collect::<Vec<&str> >();\n     let mut saw_first_line = false;"}, {"sha": "f1eb65ee16ed02c5edefef057c939b456053fd3d", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/12c5f8cb75b0320f4ba9557417e5e554ffe2001b/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c5f8cb75b0320f4ba9557417e5e554ffe2001b/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=12c5f8cb75b0320f4ba9557417e5e554ffe2001b", "patch": "@@ -28,7 +28,7 @@ use rustc::util::nodemap::FxHashSet;\n use rustc::hir;\n \n use core;\n-use clean::{self, Clean, Attributes};\n+use clean::{self, AttributesExt, NestedAttributesExt};\n use doctree::*;\n \n // looks to me like the first two of these are actually\n@@ -281,8 +281,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         fn inherits_doc_hidden(cx: &core::DocContext, mut node: ast::NodeId) -> bool {\n             while let Some(id) = cx.map.get_enclosing_scope(node) {\n                 node = id;\n-                let attrs = cx.map.attrs(node).clean(cx);\n-                if attrs.list(\"doc\").has_word(\"hidden\") {\n+                if cx.map.attrs(node).lists(\"doc\").has_word(\"hidden\") {\n                     return true;\n                 }\n                 if node == ast::CRATE_NODE_ID {\n@@ -299,18 +298,18 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         let def = tcx.expect_def(id);\n         let def_did = def.def_id();\n \n-        let use_attrs = tcx.map.attrs(id).clean(self.cx);\n+        let use_attrs = tcx.map.attrs(id);\n         // Don't inline doc(hidden) imports so they can be stripped at a later stage.\n-        let is_no_inline = use_attrs.list(\"doc\").has_word(\"no_inline\") ||\n-                           use_attrs.list(\"doc\").has_word(\"hidden\");\n+        let is_no_inline = use_attrs.lists(\"doc\").has_word(\"no_inline\") ||\n+                           use_attrs.lists(\"doc\").has_word(\"hidden\");\n \n         // For cross-crate impl inlining we need to know whether items are\n         // reachable in documentation - a previously nonreachable item can be\n         // made reachable by cross-crate inlining which we're checking here.\n         // (this is done here because we need to know this upfront)\n         if !def_did.is_local() && !is_no_inline {\n             let attrs = clean::inline::load_attrs(self.cx, tcx, def_did);\n-            let self_is_hidden = attrs.list(\"doc\").has_word(\"hidden\");\n+            let self_is_hidden = attrs.lists(\"doc\").has_word(\"hidden\");\n             match def {\n                 Def::Trait(did) |\n                 Def::Struct(did) |"}, {"sha": "172d070c55d9dbca4849c8b6a9fb9e35e7a297dc", "filename": "src/librustdoc/visit_lib.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/12c5f8cb75b0320f4ba9557417e5e554ffe2001b/src%2Flibrustdoc%2Fvisit_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c5f8cb75b0320f4ba9557417e5e554ffe2001b/src%2Flibrustdoc%2Fvisit_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_lib.rs?ref=12c5f8cb75b0320f4ba9557417e5e554ffe2001b", "patch": "@@ -16,7 +16,7 @@ use rustc::ty::Visibility;\n \n use std::cell::RefMut;\n \n-use clean::{Attributes, Clean};\n+use clean::{AttributesExt, NestedAttributesExt};\n \n // FIXME: this may not be exhaustive, but is sufficient for rustdocs current uses\n \n@@ -49,10 +49,7 @@ impl<'a, 'b, 'tcx> LibEmbargoVisitor<'a, 'b, 'tcx> {\n \n     // Updates node level and returns the updated level\n     fn update(&mut self, did: DefId, level: Option<AccessLevel>) -> Option<AccessLevel> {\n-        let attrs: Vec<_> = self.cx.tcx().get_attrs(did).iter()\n-                                                        .map(|a| a.clean(self.cx))\n-                                                        .collect();\n-        let is_hidden = attrs.list(\"doc\").has_word(\"hidden\");\n+        let is_hidden = self.cx.tcx().get_attrs(did).lists(\"doc\").has_word(\"hidden\");\n \n         let old_level = self.access_levels.map.get(&did).cloned();\n         // Accessibility levels can only grow"}]}