{"sha": "312913a640760e9af0cff07cbb29950b810a643c", "node_id": "C_kwDOAAsO6NoAKDMxMjkxM2E2NDA3NjBlOWFmMGNmZjA3Y2JiMjk5NTBiODEwYTY0M2M", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-03T18:49:37Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-03T18:49:37Z"}, "message": "Auto merge of #12461 - Veykril:completions, r=Veykril\n\nMove trait_impl completion analysis into CompletionContext", "tree": {"sha": "214f9d9092cf83753a5e52b8af84e9370a491b1a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/214f9d9092cf83753a5e52b8af84e9370a491b1a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/312913a640760e9af0cff07cbb29950b810a643c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/312913a640760e9af0cff07cbb29950b810a643c", "html_url": "https://github.com/rust-lang/rust/commit/312913a640760e9af0cff07cbb29950b810a643c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/312913a640760e9af0cff07cbb29950b810a643c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d06d0f8774b3f07f9d269264f2f7eefaac459ca7", "url": "https://api.github.com/repos/rust-lang/rust/commits/d06d0f8774b3f07f9d269264f2f7eefaac459ca7", "html_url": "https://github.com/rust-lang/rust/commit/d06d0f8774b3f07f9d269264f2f7eefaac459ca7"}, {"sha": "a2a74bf27889d32a22fff6a0004e0bf471398c47", "url": "https://api.github.com/repos/rust-lang/rust/commits/a2a74bf27889d32a22fff6a0004e0bf471398c47", "html_url": "https://github.com/rust-lang/rust/commit/a2a74bf27889d32a22fff6a0004e0bf471398c47"}], "stats": {"total": 840, "additions": 403, "deletions": 437}, "files": [{"sha": "b0763584432b9bd60f7a9963e177c8999f13d0ba", "filename": "crates/ide-completion/src/completions.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/312913a640760e9af0cff07cbb29950b810a643c/crates%2Fide-completion%2Fsrc%2Fcompletions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/312913a640760e9af0cff07cbb29950b810a643c/crates%2Fide-completion%2Fsrc%2Fcompletions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions.rs?ref=312913a640760e9af0cff07cbb29950b810a643c", "patch": "@@ -16,7 +16,6 @@ pub(crate) mod pattern;\n pub(crate) mod postfix;\n pub(crate) mod record;\n pub(crate) mod snippet;\n-pub(crate) mod trait_impl;\n pub(crate) mod r#type;\n pub(crate) mod use_;\n pub(crate) mod vis;"}, {"sha": "a11652ca302fb78cd81ca0168e38d9c7c97bd4b4", "filename": "crates/ide-completion/src/completions/dot.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/312913a640760e9af0cff07cbb29950b810a643c/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fdot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/312913a640760e9af0cff07cbb29950b810a643c/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fdot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fdot.rs?ref=312913a640760e9af0cff07cbb29950b810a643c", "patch": "@@ -46,12 +46,14 @@ fn complete_undotted_self(acc: &mut Completions, ctx: &CompletionContext) {\n         return;\n     }\n     match ctx.path_context() {\n-        Some(PathCompletionCtx {\n-            is_absolute_path: false,\n-            qualifier: None,\n-            kind: PathKind::Expr { .. },\n-            ..\n-        }) if !ctx.is_path_disallowed() => {}\n+        Some(\n+            path_ctx @ PathCompletionCtx {\n+                is_absolute_path: false,\n+                qualifier: None,\n+                kind: PathKind::Expr { .. },\n+                ..\n+            },\n+        ) if path_ctx.is_trivial_path() && ctx.qualifier_ctx.none() => {}\n         _ => return,\n     }\n "}, {"sha": "7c3296a0b31b13c866f3ec26541afa44b8c5ca8a", "filename": "crates/ide-completion/src/completions/expr.rs", "status": "modified", "additions": 78, "deletions": 43, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/312913a640760e9af0cff07cbb29950b810a643c/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/312913a640760e9af0cff07cbb29950b810a643c/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fexpr.rs?ref=312913a640760e9af0cff07cbb29950b810a643c", "patch": "@@ -11,32 +11,38 @@ use crate::{\n \n pub(crate) fn complete_expr_path(acc: &mut Completions, ctx: &CompletionContext) {\n     let _p = profile::span(\"complete_expr_path\");\n-    if ctx.is_path_disallowed() {\n-        return;\n-    }\n \n-    let (is_absolute_path, qualifier, in_block_expr, in_loop_body, is_func_update, after_if_expr) =\n-        match ctx.nameref_ctx() {\n-            Some(NameRefContext {\n-                path_ctx:\n-                    Some(PathCompletionCtx {\n-                        kind: PathKind::Expr { in_block_expr, in_loop_body, after_if_expr },\n-                        is_absolute_path,\n-                        qualifier,\n-                        ..\n-                    }),\n-                record_expr,\n-                ..\n-            }) => (\n-                *is_absolute_path,\n-                qualifier,\n-                *in_block_expr,\n-                *in_loop_body,\n-                record_expr.as_ref().map_or(false, |&(_, it)| it),\n-                *after_if_expr,\n-            ),\n-            _ => return,\n-        };\n+    let (\n+        is_absolute_path,\n+        qualifier,\n+        in_block_expr,\n+        in_loop_body,\n+        is_func_update,\n+        after_if_expr,\n+        wants_mut_token,\n+    ) = match ctx.nameref_ctx() {\n+        Some(NameRefContext {\n+            path_ctx:\n+                Some(PathCompletionCtx {\n+                    kind:\n+                        PathKind::Expr { in_block_expr, in_loop_body, after_if_expr, ref_expr_parent },\n+                    is_absolute_path,\n+                    qualifier,\n+                    ..\n+                }),\n+            record_expr,\n+            ..\n+        }) if ctx.qualifier_ctx.none() => (\n+            *is_absolute_path,\n+            qualifier,\n+            *in_block_expr,\n+            *in_loop_body,\n+            record_expr.as_ref().map_or(false, |&(_, it)| it),\n+            *after_if_expr,\n+            ref_expr_parent.as_ref().map(|it| it.mut_token().is_none()).unwrap_or(false),\n+        ),\n+        _ => return,\n+    };\n \n     let scope_def_applicable = |def| {\n         use hir::{GenericParam::*, ModuleDef::*};\n@@ -164,12 +170,43 @@ pub(crate) fn complete_expr_path(acc: &mut Completions, ctx: &CompletionContext)\n         None if is_absolute_path => acc.add_crate_roots(ctx),\n         None => {\n             acc.add_nameref_keywords_with_colon(ctx);\n-            if let Some(hir::Adt::Enum(e)) =\n+            if let Some(adt) =\n                 ctx.expected_type.as_ref().and_then(|ty| ty.strip_references().as_adt())\n             {\n-                super::enum_variants_with_paths(acc, ctx, e, |acc, ctx, variant, path| {\n-                    acc.add_qualified_enum_variant(ctx, variant, path)\n-                });\n+                let self_ty =\n+                    (|| ctx.sema.to_def(ctx.impl_def.as_ref()?)?.self_ty(ctx.db).as_adt())();\n+                let complete_self = self_ty == Some(adt);\n+\n+                match adt {\n+                    hir::Adt::Struct(strukt) => {\n+                        let path = ctx\n+                            .module\n+                            .find_use_path(ctx.db, hir::ModuleDef::from(strukt))\n+                            .filter(|it| it.len() > 1);\n+\n+                        acc.add_struct_literal(ctx, strukt, path, None);\n+\n+                        if complete_self {\n+                            acc.add_struct_literal(ctx, strukt, None, Some(hir::known::SELF_TYPE));\n+                        }\n+                    }\n+                    hir::Adt::Union(un) => {\n+                        let path = ctx\n+                            .module\n+                            .find_use_path(ctx.db, hir::ModuleDef::from(un))\n+                            .filter(|it| it.len() > 1);\n+\n+                        acc.add_union_literal(ctx, un, path, None);\n+                        if complete_self {\n+                            acc.add_union_literal(ctx, un, None, Some(hir::known::SELF_TYPE));\n+                        }\n+                    }\n+                    hir::Adt::Enum(e) => {\n+                        super::enum_variants_with_paths(acc, ctx, e, |acc, ctx, variant, path| {\n+                            acc.add_qualified_enum_variant(ctx, variant, path)\n+                        });\n+                    }\n+                }\n             }\n             ctx.process_all_names(&mut |name, def| {\n                 if scope_def_applicable(def) {\n@@ -180,20 +217,18 @@ pub(crate) fn complete_expr_path(acc: &mut Completions, ctx: &CompletionContext)\n             if !is_func_update {\n                 let mut add_keyword = |kw, snippet| acc.add_keyword_snippet(ctx, kw, snippet);\n \n-                if ctx.expects_expression() {\n-                    if !in_block_expr {\n-                        add_keyword(\"unsafe\", \"unsafe {\\n    $0\\n}\");\n-                    }\n-                    add_keyword(\"match\", \"match $1 {\\n    $0\\n}\");\n-                    add_keyword(\"while\", \"while $1 {\\n    $0\\n}\");\n-                    add_keyword(\"while let\", \"while let $1 = $2 {\\n    $0\\n}\");\n-                    add_keyword(\"loop\", \"loop {\\n    $0\\n}\");\n-                    add_keyword(\"if\", \"if $1 {\\n    $0\\n}\");\n-                    add_keyword(\"if let\", \"if let $1 = $2 {\\n    $0\\n}\");\n-                    add_keyword(\"for\", \"for $1 in $2 {\\n    $0\\n}\");\n-                    add_keyword(\"true\", \"true\");\n-                    add_keyword(\"false\", \"false\");\n+                if !in_block_expr {\n+                    add_keyword(\"unsafe\", \"unsafe {\\n    $0\\n}\");\n                 }\n+                add_keyword(\"match\", \"match $1 {\\n    $0\\n}\");\n+                add_keyword(\"while\", \"while $1 {\\n    $0\\n}\");\n+                add_keyword(\"while let\", \"while let $1 = $2 {\\n    $0\\n}\");\n+                add_keyword(\"loop\", \"loop {\\n    $0\\n}\");\n+                add_keyword(\"if\", \"if $1 {\\n    $0\\n}\");\n+                add_keyword(\"if let\", \"if let $1 = $2 {\\n    $0\\n}\");\n+                add_keyword(\"for\", \"for $1 in $2 {\\n    $0\\n}\");\n+                add_keyword(\"true\", \"true\");\n+                add_keyword(\"false\", \"false\");\n \n                 if ctx.previous_token_is(T![if])\n                     || ctx.previous_token_is(T![while])\n@@ -207,7 +242,7 @@ pub(crate) fn complete_expr_path(acc: &mut Completions, ctx: &CompletionContext)\n                     add_keyword(\"else if\", \"else if $1 {\\n    $0\\n}\");\n                 }\n \n-                if ctx.expects_ident_ref_expr() {\n+                if wants_mut_token {\n                     add_keyword(\"mut\", \"mut \");\n                 }\n "}, {"sha": "901f7519d25cef78f09509f4215466336d921192", "filename": "crates/ide-completion/src/completions/flyimport.rs", "status": "modified", "additions": 23, "deletions": 21, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/312913a640760e9af0cff07cbb29950b810a643c/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fflyimport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/312913a640760e9af0cff07cbb29950b810a643c/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fflyimport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fflyimport.rs?ref=312913a640760e9af0cff07cbb29950b810a643c", "patch": "@@ -8,7 +8,7 @@ use itertools::Itertools;\n use syntax::{AstNode, SyntaxNode, T};\n \n use crate::{\n-    context::{CompletionContext, PathKind},\n+    context::{CompletionContext, NameRefContext, PathCompletionCtx, PathKind, PatternContext},\n     patterns::ImmediateLocation,\n     render::{render_resolution_with_import, RenderContext},\n };\n@@ -110,16 +110,26 @@ pub(crate) fn import_on_the_fly(acc: &mut Completions, ctx: &CompletionContext)\n     if !ctx.config.enable_imports_on_the_fly {\n         return None;\n     }\n-    if matches!(ctx.path_kind(), Some(PathKind::Vis { .. } | PathKind::Use | PathKind::Item { .. }))\n-        || ctx.is_path_disallowed()\n-    {\n-        return None;\n-    }\n-    // FIXME: This should be encoded in a different way\n-    if ctx.pattern_ctx.is_none() && ctx.path_context().is_none() && !ctx.has_dot_receiver() {\n-        // completion inside `ast::Name` of a item declaration\n-        return None;\n-    }\n+    let path_kind = match ctx.nameref_ctx() {\n+        Some(NameRefContext { path_ctx: Some(PathCompletionCtx { kind, .. }), .. })\n+            if matches!(\n+                kind,\n+                PathKind::Expr { .. }\n+                    | PathKind::Type { .. }\n+                    | PathKind::Attr { .. }\n+                    | PathKind::Derive\n+                    | PathKind::Pat\n+            ) =>\n+        {\n+            Some(kind)\n+        }\n+        Some(NameRefContext { dot_access: Some(_), .. }) => None,\n+        None if matches!(ctx.pattern_ctx, Some(PatternContext { record_pat: None, .. })) => {\n+            Some(&PathKind::Pat)\n+        }\n+        _ => return None,\n+    };\n+\n     let potential_import_name = {\n         let token_kind = ctx.token.kind();\n         if matches!(token_kind, T![.] | T![::]) {\n@@ -138,18 +148,10 @@ pub(crate) fn import_on_the_fly(acc: &mut Completions, ctx: &CompletionContext)\n         return None;\n     }\n \n-    let path_kind = match ctx.path_kind() {\n-        Some(kind) => Some(kind),\n-        None if ctx.pattern_ctx.is_some() => Some(PathKind::Pat),\n-        None => None,\n-    };\n     let ns_filter = |import: &LocatedImport| {\n         let path_kind = match path_kind {\n-            Some(path_kind) => path_kind,\n-            None => match import.original_item {\n-                ItemInNs::Macros(mac) => return mac.is_fn_like(ctx.db),\n-                _ => return true,\n-            },\n+            Some(it) => it,\n+            None => return true,\n         };\n         match (path_kind, import.original_item) {\n             // Aren't handled in flyimport"}, {"sha": "d44bf0a6ab743d68ef3e398e2a154820ab2fc4c4", "filename": "crates/ide-completion/src/completions/item_list.rs", "status": "modified", "additions": 91, "deletions": 75, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/312913a640760e9af0cff07cbb29950b810a643c/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fitem_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/312913a640760e9af0cff07cbb29950b810a643c/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fitem_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fitem_list.rs?ref=312913a640760e9af0cff07cbb29950b810a643c", "patch": "@@ -6,88 +6,42 @@ use crate::{\n     CompletionContext, Completions,\n };\n \n+mod trait_impl;\n+\n pub(crate) fn complete_item_list(acc: &mut Completions, ctx: &CompletionContext) {\n     let _p = profile::span(\"complete_item_list\");\n \n-    let (&is_absolute_path, path_qualifier, kind) = match ctx.path_context() {\n-        Some(PathCompletionCtx {\n-            kind: PathKind::Item { kind },\n-            is_absolute_path,\n-            qualifier,\n-            ..\n-        }) => (is_absolute_path, qualifier, Some(kind)),\n-        Some(PathCompletionCtx {\n-            kind: PathKind::Expr { in_block_expr: true, .. },\n-            is_absolute_path,\n-            qualifier,\n-            ..\n-        }) => (is_absolute_path, qualifier, None),\n+    if let Some(_) = ctx.name_ctx() {\n+        trait_impl::complete_trait_impl(acc, ctx);\n+        return;\n+    }\n+\n+    let (&is_absolute_path, path_qualifier, kind, is_trivial_path) = match ctx.path_context() {\n+        Some(\n+            ctx @ PathCompletionCtx {\n+                kind: PathKind::Item { kind },\n+                is_absolute_path,\n+                qualifier,\n+                ..\n+            },\n+        ) => (is_absolute_path, qualifier, Some(kind), ctx.is_trivial_path()),\n+        Some(\n+            ctx @ PathCompletionCtx {\n+                kind: PathKind::Expr { in_block_expr: true, .. },\n+                is_absolute_path,\n+                qualifier,\n+                ..\n+            },\n+        ) => (is_absolute_path, qualifier, None, ctx.is_trivial_path()),\n         _ => return,\n     };\n-    let mut add_keyword = |kw, snippet| acc.add_keyword_snippet(ctx, kw, snippet);\n-\n-    let in_item_list = matches!(kind, Some(ItemListKind::SourceFile | ItemListKind::Module) | None);\n-    let in_assoc_non_trait_impl = matches!(kind, Some(ItemListKind::Impl | ItemListKind::Trait));\n-    let in_extern_block = matches!(kind, Some(ItemListKind::ExternBlock));\n-    let in_trait = matches!(kind, Some(ItemListKind::Trait));\n-    let in_trait_impl = matches!(kind, Some(ItemListKind::TraitImpl));\n-    let in_inherent_impl = matches!(kind, Some(ItemListKind::Impl));\n-    let no_qualifiers = ctx.qualifier_ctx.vis_node.is_none();\n-    let in_block = matches!(kind, None);\n-\n-    'block: loop {\n-        if ctx.is_non_trivial_path() {\n-            break 'block;\n-        }\n-        if !in_trait_impl {\n-            if ctx.qualifier_ctx.unsafe_tok.is_some() {\n-                if in_item_list || in_assoc_non_trait_impl {\n-                    add_keyword(\"fn\", \"fn $1($2) {\\n    $0\\n}\");\n-                }\n-                if in_item_list {\n-                    add_keyword(\"trait\", \"trait $1 {\\n    $0\\n}\");\n-                    if no_qualifiers {\n-                        add_keyword(\"impl\", \"impl $1 {\\n    $0\\n}\");\n-                    }\n-                }\n-                break 'block;\n-            }\n \n-            if in_item_list {\n-                add_keyword(\"enum\", \"enum $1 {\\n    $0\\n}\");\n-                add_keyword(\"mod\", \"mod $0\");\n-                add_keyword(\"static\", \"static $0\");\n-                add_keyword(\"struct\", \"struct $0\");\n-                add_keyword(\"trait\", \"trait $1 {\\n    $0\\n}\");\n-                add_keyword(\"union\", \"union $1 {\\n    $0\\n}\");\n-                add_keyword(\"use\", \"use $0\");\n-                if no_qualifiers {\n-                    add_keyword(\"impl\", \"impl $1 {\\n    $0\\n}\");\n-                }\n-            }\n-\n-            if !in_trait && !in_block && no_qualifiers {\n-                add_keyword(\"pub(crate)\", \"pub(crate)\");\n-                add_keyword(\"pub(super)\", \"pub(super)\");\n-                add_keyword(\"pub\", \"pub\");\n-            }\n-\n-            if in_extern_block {\n-                add_keyword(\"fn\", \"fn $1($2);\");\n-            } else {\n-                if !in_inherent_impl {\n-                    if !in_trait {\n-                        add_keyword(\"extern\", \"extern $0\");\n-                    }\n-                    add_keyword(\"type\", \"type $0\");\n-                }\n+    if matches!(kind, Some(ItemListKind::TraitImpl)) {\n+        trait_impl::complete_trait_impl(acc, ctx);\n+    }\n \n-                add_keyword(\"fn\", \"fn $1($2) {\\n    $0\\n}\");\n-                add_keyword(\"unsafe\", \"unsafe\");\n-                add_keyword(\"const\", \"const $0\");\n-            }\n-        }\n-        break 'block;\n+    if is_trivial_path {\n+        add_keywords(acc, ctx, kind);\n     }\n \n     if kind.is_none() {\n@@ -121,3 +75,65 @@ pub(crate) fn complete_item_list(acc: &mut Completions, ctx: &CompletionContext)\n         None => {}\n     }\n }\n+\n+fn add_keywords(acc: &mut Completions, ctx: &CompletionContext, kind: Option<&ItemListKind>) {\n+    let mut add_keyword = |kw, snippet| acc.add_keyword_snippet(ctx, kw, snippet);\n+\n+    let in_item_list = matches!(kind, Some(ItemListKind::SourceFile | ItemListKind::Module) | None);\n+    let in_assoc_non_trait_impl = matches!(kind, Some(ItemListKind::Impl | ItemListKind::Trait));\n+    let in_extern_block = matches!(kind, Some(ItemListKind::ExternBlock));\n+    let in_trait = matches!(kind, Some(ItemListKind::Trait));\n+    let in_trait_impl = matches!(kind, Some(ItemListKind::TraitImpl));\n+    let in_inherent_impl = matches!(kind, Some(ItemListKind::Impl));\n+    let no_qualifiers = ctx.qualifier_ctx.vis_node.is_none();\n+    let in_block = matches!(kind, None);\n+\n+    if !in_trait_impl {\n+        if ctx.qualifier_ctx.unsafe_tok.is_some() {\n+            if in_item_list || in_assoc_non_trait_impl {\n+                add_keyword(\"fn\", \"fn $1($2) {\\n    $0\\n}\");\n+            }\n+            if in_item_list {\n+                add_keyword(\"trait\", \"trait $1 {\\n    $0\\n}\");\n+                if no_qualifiers {\n+                    add_keyword(\"impl\", \"impl $1 {\\n    $0\\n}\");\n+                }\n+            }\n+            return;\n+        }\n+\n+        if in_item_list {\n+            add_keyword(\"enum\", \"enum $1 {\\n    $0\\n}\");\n+            add_keyword(\"mod\", \"mod $0\");\n+            add_keyword(\"static\", \"static $0\");\n+            add_keyword(\"struct\", \"struct $0\");\n+            add_keyword(\"trait\", \"trait $1 {\\n    $0\\n}\");\n+            add_keyword(\"union\", \"union $1 {\\n    $0\\n}\");\n+            add_keyword(\"use\", \"use $0\");\n+            if no_qualifiers {\n+                add_keyword(\"impl\", \"impl $1 {\\n    $0\\n}\");\n+            }\n+        }\n+\n+        if !in_trait && !in_block && no_qualifiers {\n+            add_keyword(\"pub(crate)\", \"pub(crate)\");\n+            add_keyword(\"pub(super)\", \"pub(super)\");\n+            add_keyword(\"pub\", \"pub\");\n+        }\n+\n+        if in_extern_block {\n+            add_keyword(\"fn\", \"fn $1($2);\");\n+        } else {\n+            if !in_inherent_impl {\n+                if !in_trait {\n+                    add_keyword(\"extern\", \"extern $0\");\n+                }\n+                add_keyword(\"type\", \"type $0\");\n+            }\n+\n+            add_keyword(\"fn\", \"fn $1($2) {\\n    $0\\n}\");\n+            add_keyword(\"unsafe\", \"unsafe\");\n+            add_keyword(\"const\", \"const $0\");\n+        }\n+    }\n+}"}, {"sha": "8a2bbae73f4c42dddc6d798be0834fb5860c481f", "filename": "crates/ide-completion/src/completions/item_list/trait_impl.rs", "status": "renamed", "additions": 46, "deletions": 67, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/312913a640760e9af0cff07cbb29950b810a643c/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fitem_list%2Ftrait_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/312913a640760e9af0cff07cbb29950b810a643c/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fitem_list%2Ftrait_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fitem_list%2Ftrait_impl.rs?ref=312913a640760e9af0cff07cbb29950b810a643c", "patch": "@@ -43,6 +43,10 @@ use syntax::{\n use text_edit::TextEdit;\n \n use crate::{\n+    context::{\n+        IdentContext, ItemListKind, NameContext, NameKind, NameRefContext, PathCompletionCtx,\n+        PathKind,\n+    },\n     CompletionContext, CompletionItem, CompletionItemKind, CompletionRelevance, Completions,\n };\n \n@@ -54,7 +58,6 @@ enum ImplCompletionKind {\n     Const,\n }\n \n-// FIXME: Make this a submodule of [`item_list`]\n pub(crate) fn complete_trait_impl(acc: &mut Completions, ctx: &CompletionContext) {\n     if let Some((kind, replacement_range, impl_def)) = completion_match(ctx) {\n         if let Some(hir_impl) = ctx.sema.to_def(&impl_def) {\n@@ -77,73 +80,49 @@ pub(crate) fn complete_trait_impl(acc: &mut Completions, ctx: &CompletionContext\n     }\n }\n \n-// FIXME: This should be lifted out so that we can do proper smart item keyword completions\n fn completion_match(ctx: &CompletionContext) -> Option<(ImplCompletionKind, TextRange, ast::Impl)> {\n-    let token = ctx.token.clone();\n-\n-    // For keyword without name like `impl .. { fn $0 }`, the current position is inside\n-    // the whitespace token, which is outside `FN` syntax node.\n-    // We need to follow the previous token in this case.\n-    let mut token_before_ws = token.clone();\n-    if token.kind() == SyntaxKind::WHITESPACE {\n-        token_before_ws = token.prev_token()?;\n-    }\n-\n-    let parent_kind = token_before_ws.parent().map_or(SyntaxKind::EOF, |it| it.kind());\n-    if token.parent().map(|n| n.kind()) == Some(SyntaxKind::ASSOC_ITEM_LIST)\n-        && matches!(\n-            token_before_ws.kind(),\n-            SyntaxKind::SEMICOLON | SyntaxKind::R_CURLY | SyntaxKind::L_CURLY\n-        )\n-    {\n-        let impl_def = ast::Impl::cast(token.parent()?.parent()?)?;\n-        let kind = ImplCompletionKind::All;\n-        let replacement_range = TextRange::empty(ctx.position.offset);\n-        Some((kind, replacement_range, impl_def))\n-    } else {\n-        let impl_item_offset = match token_before_ws.kind() {\n-            // `impl .. { const $0 }`\n-            // ERROR      0\n-            //   CONST_KW <- *\n-            T![const] => 0,\n-            // `impl .. { fn/type $0 }`\n-            // FN/TYPE_ALIAS  0\n-            //   FN_KW        <- *\n-            T![fn] | T![type] => 0,\n-            // `impl .. { fn/type/const foo$0 }`\n-            // FN/TYPE_ALIAS/CONST  1\n-            //  NAME                0\n-            //    IDENT             <- *\n-            SyntaxKind::IDENT if parent_kind == SyntaxKind::NAME => 1,\n-            // `impl .. { foo$0 }`\n-            // MACRO_CALL       3\n-            //  PATH            2\n-            //    PATH_SEGMENT  1\n-            //      NAME_REF    0\n-            //        IDENT     <- *\n-            SyntaxKind::IDENT if parent_kind == SyntaxKind::NAME_REF => 3,\n-            _ => return None,\n-        };\n-\n-        let impl_item = token_before_ws.ancestors().nth(impl_item_offset)?;\n-        // Must directly belong to an impl block.\n-        // IMPL\n-        //   ASSOC_ITEM_LIST\n-        //     <item>\n-        let impl_def = ast::Impl::cast(impl_item.parent()?.parent()?)?;\n-        let kind = match impl_item.kind() {\n-            // `impl ... { const $0 fn/type/const }`\n-            _ if token_before_ws.kind() == T![const] => ImplCompletionKind::Const,\n-            SyntaxKind::CONST | SyntaxKind::ERROR => ImplCompletionKind::Const,\n-            SyntaxKind::TYPE_ALIAS => ImplCompletionKind::TypeAlias,\n-            SyntaxKind::FN => ImplCompletionKind::Fn,\n-            SyntaxKind::MACRO_CALL => ImplCompletionKind::All,\n-            _ => return None,\n-        };\n-\n-        let replacement_range = replacement_range(ctx, &impl_item);\n-\n-        Some((kind, replacement_range, impl_def))\n+    match &ctx.ident_ctx {\n+        IdentContext::Name(NameContext { name, kind, .. }) => {\n+            let kind = match kind {\n+                NameKind::Const => ImplCompletionKind::Const,\n+                NameKind::Function => ImplCompletionKind::Fn,\n+                NameKind::TypeAlias => ImplCompletionKind::TypeAlias,\n+                _ => return None,\n+            };\n+            let token = ctx.token.clone();\n+            let item = match name {\n+                Some(name) => name.syntax().parent(),\n+                None => {\n+                    if token.kind() == SyntaxKind::WHITESPACE { token.prev_token()? } else { token }\n+                        .parent()\n+                }\n+            }?;\n+            Some((\n+                kind,\n+                replacement_range(ctx, &item),\n+                // item -> ASSOC_ITEM_LIST -> IMPL\n+                ast::Impl::cast(item.parent()?.parent()?)?,\n+            ))\n+        }\n+        IdentContext::NameRef(NameRefContext {\n+            nameref,\n+            path_ctx:\n+                Some(\n+                    path_ctx @ PathCompletionCtx {\n+                        kind: PathKind::Item { kind: ItemListKind::TraitImpl },\n+                        ..\n+                    },\n+                ),\n+            ..\n+        }) if path_ctx.is_trivial_path() => Some((\n+            ImplCompletionKind::All,\n+            match nameref {\n+                Some(name) => name.syntax().text_range(),\n+                None => TextRange::empty(ctx.position.offset),\n+            },\n+            ctx.impl_def.clone()?,\n+        )),\n+        _ => None,\n     }\n }\n ", "previous_filename": "crates/ide-completion/src/completions/trait_impl.rs"}, {"sha": "65fa1191781e8e4e7e2575b302f6f951a2749aeb", "filename": "crates/ide-completion/src/completions/keyword.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/312913a640760e9af0cff07cbb29950b810a643c/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fkeyword.rs", "raw_url": "https://github.com/rust-lang/rust/raw/312913a640760e9af0cff07cbb29950b810a643c/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fkeyword.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fkeyword.rs?ref=312913a640760e9af0cff07cbb29950b810a643c", "patch": "@@ -8,11 +8,7 @@ use crate::{context::NameRefContext, CompletionContext, Completions};\n \n pub(crate) fn complete_expr_keyword(acc: &mut Completions, ctx: &CompletionContext) {\n     let item = match ctx.nameref_ctx() {\n-        Some(NameRefContext { keyword: Some(item), record_expr: None, .. })\n-            if !ctx.is_non_trivial_path() =>\n-        {\n-            item\n-        }\n+        Some(NameRefContext { keyword: Some(item), record_expr: None, .. }) => item,\n         _ => return,\n     };\n "}, {"sha": "65805dba1ce9f22919f503c92b9fa263772ddcef", "filename": "crates/ide-completion/src/completions/record.rs", "status": "modified", "additions": 0, "deletions": 37, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/312913a640760e9af0cff07cbb29950b810a643c/crates%2Fide-completion%2Fsrc%2Fcompletions%2Frecord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/312913a640760e9af0cff07cbb29950b810a643c/crates%2Fide-completion%2Fsrc%2Fcompletions%2Frecord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Frecord.rs?ref=312913a640760e9af0cff07cbb29950b810a643c", "patch": "@@ -71,43 +71,6 @@ pub(crate) fn complete_record(acc: &mut Completions, ctx: &CompletionContext) ->\n     Some(())\n }\n \n-pub(crate) fn complete_record_literal(\n-    acc: &mut Completions,\n-    ctx: &CompletionContext,\n-) -> Option<()> {\n-    if !ctx.expects_expression() {\n-        return None;\n-    }\n-\n-    match ctx.expected_type.as_ref()?.as_adt()? {\n-        hir::Adt::Struct(strukt) if ctx.path_qual().is_none() => {\n-            let path = ctx\n-                .module\n-                .find_use_path(ctx.db, hir::ModuleDef::from(strukt))\n-                .filter(|it| it.len() > 1);\n-\n-            acc.add_struct_literal(ctx, strukt, path, None);\n-\n-            let impl_ = ctx.impl_def.as_ref()?;\n-            let impl_adt = ctx.sema.to_def(impl_)?.self_ty(ctx.db).as_adt()?;\n-            if hir::Adt::Struct(strukt) == impl_adt {\n-                acc.add_struct_literal(ctx, strukt, None, Some(hir::known::SELF_TYPE));\n-            }\n-        }\n-        hir::Adt::Union(un) if ctx.path_qual().is_none() => {\n-            let path = ctx\n-                .module\n-                .find_use_path(ctx.db, hir::ModuleDef::from(un))\n-                .filter(|it| it.len() > 1);\n-\n-            acc.add_union_literal(ctx, un, path, None);\n-        }\n-        _ => {}\n-    };\n-\n-    Some(())\n-}\n-\n #[cfg(test)]\n mod tests {\n     use crate::tests::check_edit;"}, {"sha": "9cf0b87ad6f9b76664ae2514805d754d9bfbf77b", "filename": "crates/ide-completion/src/completions/type.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/312913a640760e9af0cff07cbb29950b810a643c/crates%2Fide-completion%2Fsrc%2Fcompletions%2Ftype.rs", "raw_url": "https://github.com/rust-lang/rust/raw/312913a640760e9af0cff07cbb29950b810a643c/crates%2Fide-completion%2Fsrc%2Fcompletions%2Ftype.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Ftype.rs?ref=312913a640760e9af0cff07cbb29950b810a643c", "patch": "@@ -13,9 +13,6 @@ use crate::{\n \n pub(crate) fn complete_type_path(acc: &mut Completions, ctx: &CompletionContext) {\n     let _p = profile::span(\"complete_type_path\");\n-    if ctx.is_path_disallowed() {\n-        return;\n-    }\n \n     let (&is_absolute_path, qualifier) = match ctx.path_context() {\n         Some(PathCompletionCtx {"}, {"sha": "02307def9e6e630b26da238969983ccb97bf1555", "filename": "crates/ide-completion/src/context.rs", "status": "modified", "additions": 144, "deletions": 146, "changes": 290, "blob_url": "https://github.com/rust-lang/rust/blob/312913a640760e9af0cff07cbb29950b810a643c/crates%2Fide-completion%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/312913a640760e9af0cff07cbb29950b810a643c/crates%2Fide-completion%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcontext.rs?ref=312913a640760e9af0cff07cbb29950b810a643c", "patch": "@@ -43,12 +43,13 @@ pub(crate) enum Visible {\n     No,\n }\n \n-#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+#[derive(Clone, Debug, PartialEq, Eq)]\n pub(super) enum PathKind {\n     Expr {\n         in_block_expr: bool,\n         in_loop_body: bool,\n         after_if_expr: bool,\n+        ref_expr_parent: Option<ast::RefExpr>,\n     },\n     Type {\n         in_tuple_struct: bool,\n@@ -101,15 +102,30 @@ pub(crate) struct PathCompletionCtx {\n     pub(super) is_absolute_path: bool,\n     /// The qualifier of the current path if it exists.\n     pub(super) qualifier: Option<PathQualifierCtx>,\n-    #[allow(dead_code)]\n-    // FIXME: use this\n     /// The parent of the path we are completing.\n     pub(super) parent: Option<ast::Path>,\n     pub(super) kind: PathKind,\n     /// Whether the path segment has type args or not.\n     pub(super) has_type_args: bool,\n }\n \n+impl PathCompletionCtx {\n+    pub(super) fn is_trivial_path(&self) -> bool {\n+        matches!(\n+            self,\n+            PathCompletionCtx {\n+                has_call_parens: false,\n+                has_macro_bang: false,\n+                is_absolute_path: false,\n+                qualifier: None,\n+                parent: None,\n+                has_type_args: false,\n+                ..\n+            }\n+        )\n+    }\n+}\n+\n #[derive(Debug)]\n pub(crate) struct PathQualifierCtx {\n     pub(crate) path: ast::Path,\n@@ -341,47 +357,14 @@ impl<'a> CompletionContext<'a> {\n         matches!(self.completion_location, Some(ImmediateLocation::GenericArgList(_)))\n     }\n \n-    pub(crate) fn expects_ident_ref_expr(&self) -> bool {\n-        matches!(self.completion_location, Some(ImmediateLocation::RefExpr))\n-    }\n-\n-    // FIXME: This shouldn't exist\n-    pub(crate) fn is_path_disallowed(&self) -> bool {\n-        !self.qualifier_ctx.none()\n-            || (matches!(self.name_ctx(), Some(NameContext { .. })) && self.pattern_ctx.is_none())\n-            || matches!(self.pattern_ctx, Some(PatternContext { record_pat: Some(_), .. }))\n-            || matches!(\n-                self.nameref_ctx(),\n-                Some(NameRefContext { record_expr: Some((_, false)), .. })\n-            )\n-    }\n-\n     pub(crate) fn path_context(&self) -> Option<&PathCompletionCtx> {\n         self.nameref_ctx().and_then(|ctx| ctx.path_ctx.as_ref())\n     }\n \n-    pub(crate) fn expects_expression(&self) -> bool {\n-        matches!(self.path_context(), Some(PathCompletionCtx { kind: PathKind::Expr { .. }, .. }))\n-    }\n-\n-    pub(crate) fn is_non_trivial_path(&self) -> bool {\n-        matches!(\n-            self.path_context(),\n-            Some(\n-                PathCompletionCtx { is_absolute_path: true, .. }\n-                    | PathCompletionCtx { qualifier: Some(_), .. }\n-            )\n-        )\n-    }\n-\n     pub(crate) fn path_qual(&self) -> Option<&ast::Path> {\n         self.path_context().and_then(|it| it.qualifier.as_ref().map(|it| &it.path))\n     }\n \n-    pub(crate) fn path_kind(&self) -> Option<PathKind> {\n-        self.path_context().map(|it| it.kind)\n-    }\n-\n     /// Checks if an item is visible and not `doc(hidden)` at the completion site.\n     pub(crate) fn is_visible<I>(&self, item: &I) -> Visible\n     where\n@@ -872,7 +855,7 @@ impl<'a> CompletionContext<'a> {\n                 find_node_at_offset(&file_with_fake_ident, offset)\n             {\n                 let parent = name_ref.syntax().parent()?;\n-                let (mut nameref_ctx, _) =\n+                let (mut nameref_ctx, _, _) =\n                     Self::classify_name_ref(&self.sema, &original_file, name_ref, parent);\n                 if let Some(path_ctx) = &mut nameref_ctx.path_ctx {\n                     path_ctx.kind = PathKind::Derive;\n@@ -920,13 +903,23 @@ impl<'a> CompletionContext<'a> {\n         self.impl_def = self\n             .sema\n             .token_ancestors_with_macros(self.token.clone())\n-            .take_while(|it| it.kind() != SOURCE_FILE && it.kind() != MODULE)\n-            .find_map(ast::Impl::cast);\n+            .take_while(|it| it.kind() != SOURCE_FILE)\n+            .filter_map(ast::Item::cast)\n+            .take(2)\n+            .find_map(|it| match it {\n+                ast::Item::Impl(impl_) => Some(impl_),\n+                _ => None,\n+            });\n         self.function_def = self\n             .sema\n             .token_ancestors_with_macros(self.token.clone())\n             .take_while(|it| it.kind() != SOURCE_FILE && it.kind() != MODULE)\n-            .find_map(ast::Fn::cast);\n+            .filter_map(ast::Item::cast)\n+            .take(2)\n+            .find_map(|it| match it {\n+                ast::Item::Fn(fn_) => Some(fn_),\n+                _ => None,\n+            });\n \n         match name_like {\n             ast::NameLike::Lifetime(lifetime) => {\n@@ -938,50 +931,10 @@ impl<'a> CompletionContext<'a> {\n             }\n             ast::NameLike::NameRef(name_ref) => {\n                 let parent = name_ref.syntax().parent()?;\n-                let (nameref_ctx, pat_ctx) =\n+                let (nameref_ctx, pat_ctx, qualifier_ctx) =\n                     Self::classify_name_ref(&self.sema, &original_file, name_ref, parent.clone());\n \n-                // Extract qualifiers\n-                if let Some(path_ctx) = &nameref_ctx.path_ctx {\n-                    if path_ctx.qualifier.is_none() {\n-                        let top = match path_ctx.kind {\n-                            PathKind::Expr { in_block_expr: true, .. } => parent\n-                                .ancestors()\n-                                .find(|it| ast::PathExpr::can_cast(it.kind()))\n-                                .and_then(|p| {\n-                                    let parent = p.parent()?;\n-                                    if ast::StmtList::can_cast(parent.kind()) {\n-                                        Some(p)\n-                                    } else if ast::ExprStmt::can_cast(parent.kind()) {\n-                                        Some(parent)\n-                                    } else {\n-                                        None\n-                                    }\n-                                }),\n-                            PathKind::Item { .. } => {\n-                                parent.ancestors().find(|it| ast::MacroCall::can_cast(it.kind()))\n-                            }\n-                            _ => None,\n-                        };\n-                        if let Some(top) = top {\n-                            if let Some(NodeOrToken::Node(error_node)) =\n-                                syntax::algo::non_trivia_sibling(\n-                                    top.into(),\n-                                    syntax::Direction::Prev,\n-                                )\n-                            {\n-                                if error_node.kind() == SyntaxKind::ERROR {\n-                                    self.qualifier_ctx.unsafe_tok = error_node\n-                                        .children_with_tokens()\n-                                        .filter_map(NodeOrToken::into_token)\n-                                        .find(|it| it.kind() == T![unsafe]);\n-                                    self.qualifier_ctx.vis_node =\n-                                        error_node.children().find_map(ast::Visibility::cast);\n-                                }\n-                            }\n-                        }\n-                    }\n-                }\n+                self.qualifier_ctx = qualifier_ctx;\n                 self.ident_ctx = IdentContext::NameRef(nameref_ctx);\n                 self.pattern_ctx = pat_ctx;\n             }\n@@ -1070,40 +1023,44 @@ impl<'a> CompletionContext<'a> {\n         original_file: &SyntaxNode,\n         name_ref: ast::NameRef,\n         parent: SyntaxNode,\n-    ) -> (NameRefContext, Option<PatternContext>) {\n+    ) -> (NameRefContext, Option<PatternContext>, QualifierCtx) {\n         let nameref = find_node_at_offset(&original_file, name_ref.syntax().text_range().start());\n \n-        let mut nameref_ctx = NameRefContext {\n-            dot_access: None,\n-            path_ctx: None,\n-            nameref,\n-            record_expr: None,\n-            keyword: None,\n-        };\n+        let mut res = (\n+            NameRefContext {\n+                dot_access: None,\n+                path_ctx: None,\n+                nameref,\n+                record_expr: None,\n+                keyword: None,\n+            },\n+            None,\n+            QualifierCtx::default(),\n+        );\n+        let (nameref_ctx, pattern_ctx, qualifier_ctx) = &mut res;\n \n         if let Some(record_field) = ast::RecordExprField::for_field_name(&name_ref) {\n             nameref_ctx.record_expr =\n                 find_node_in_file_compensated(original_file, &record_field.parent_record_lit())\n                     .zip(Some(false));\n-            return (nameref_ctx, None);\n+            return res;\n         }\n         if let Some(record_field) = ast::RecordPatField::for_field_name_ref(&name_ref) {\n-            let pat_ctx =\n-                pattern_context_for(original_file, record_field.parent_record_pat().clone().into());\n-            return (\n-                nameref_ctx,\n-                Some(PatternContext {\n-                    param_ctx: None,\n-                    has_type_ascription: false,\n-                    ref_token: None,\n-                    mut_token: None,\n-                    record_pat: find_node_in_file_compensated(\n-                        original_file,\n-                        &record_field.parent_record_pat(),\n-                    ),\n-                    ..pat_ctx\n-                }),\n-            );\n+            *pattern_ctx = Some(PatternContext {\n+                param_ctx: None,\n+                has_type_ascription: false,\n+                ref_token: None,\n+                mut_token: None,\n+                record_pat: find_node_in_file_compensated(\n+                    original_file,\n+                    &record_field.parent_record_pat(),\n+                ),\n+                ..pattern_context_for(\n+                    original_file,\n+                    record_field.parent_record_pat().clone().into(),\n+                )\n+            });\n+            return res;\n         }\n \n         let segment = match_ast! {\n@@ -1123,7 +1080,7 @@ impl<'a> CompletionContext<'a> {\n                         kind: DotAccessKind::Field { receiver_is_ambiguous_float_literal },\n                         receiver\n                     });\n-                    return (nameref_ctx, None);\n+                    return res;\n                 },\n                 ast::MethodCallExpr(method) => {\n                     let receiver = find_in_original_file(method.receiver(), original_file);\n@@ -1132,9 +1089,9 @@ impl<'a> CompletionContext<'a> {\n                         kind: DotAccessKind::Method { has_parens: method.arg_list().map_or(false, |it| it.l_paren_token().is_some()) },\n                         receiver\n                     });\n-                    return (nameref_ctx, None);\n+                    return res;\n                 },\n-                _ => return (nameref_ctx, None),\n+                _ => return res,\n             }\n         };\n \n@@ -1148,7 +1105,6 @@ impl<'a> CompletionContext<'a> {\n             kind: PathKind::Item { kind: ItemListKind::SourceFile },\n             has_type_args: false,\n         };\n-        let mut pat_ctx = None;\n \n         let is_in_block = |it: &SyntaxNode| {\n             it.parent()\n@@ -1205,9 +1161,9 @@ impl<'a> CompletionContext<'a> {\n             None\n         };\n \n-        let kind = path.syntax().ancestors().find_map(|it| {\n-            // using Option<Option<PathKind>> as extra controlflow\n-            let kind = match_ast! {\n+        // Infer the path kind\n+        let kind = path.syntax().parent().and_then(|it| {\n+            match_ast! {\n                 match it {\n                     ast::PathType(it) => Some(PathKind::Type {\n                         in_tuple_struct: it.syntax().parent().map_or(false, |it| ast::TupleField::can_cast(it.kind()))\n@@ -1217,7 +1173,7 @@ impl<'a> CompletionContext<'a> {\n                             if ast::ExprStmt::can_cast(p.kind()) {\n                                 if let Some(kind) = inbetween_body_and_decl_check(p) {\n                                     nameref_ctx.keyword = Some(kind);\n-                                    return Some(None);\n+                                    return None;\n                                 }\n                             }\n                         }\n@@ -1228,27 +1184,29 @@ impl<'a> CompletionContext<'a> {\n                         let in_block_expr = is_in_block(it.syntax());\n                         let in_loop_body = is_in_loop_body(it.syntax());\n                         let after_if_expr = after_if_expr(it.syntax().clone());\n+                        let ref_expr_parent = path.as_single_name_ref()\n+                            .and_then(|_| it.syntax().parent()).and_then(ast::RefExpr::cast);\n \n-                        Some(PathKind::Expr { in_block_expr, in_loop_body, after_if_expr })\n+                        Some(PathKind::Expr { in_block_expr, in_loop_body, after_if_expr, ref_expr_parent })\n                     },\n                     ast::TupleStructPat(it) => {\n                         path_ctx.has_call_parens = true;\n-                        pat_ctx = Some(pattern_context_for(original_file, it.into()));\n+                        *pattern_ctx = Some(pattern_context_for(original_file, it.into()));\n                         Some(PathKind::Pat)\n                     },\n                     ast::RecordPat(it) => {\n                         path_ctx.has_call_parens = true;\n-                        pat_ctx = Some(pattern_context_for(original_file, it.into()));\n+                        *pattern_ctx = Some(pattern_context_for(original_file, it.into()));\n                         Some(PathKind::Pat)\n                     },\n                     ast::PathPat(it) => {\n-                        pat_ctx = Some(pattern_context_for(original_file, it.into()));\n+                        *pattern_ctx = Some(pattern_context_for(original_file, it.into()));\n                         Some(PathKind::Pat)\n                     },\n                     ast::MacroCall(it) => {\n                         if let Some(kind) = inbetween_body_and_decl_check(it.syntax().clone()) {\n                             nameref_ctx.keyword = Some(kind);\n-                            return Some(None);\n+                            return None;\n                         }\n \n                         path_ctx.has_macro_bang = it.excl_token().is_some();\n@@ -1266,21 +1224,23 @@ impl<'a> CompletionContext<'a> {\n                                         } else {\n                                             ItemListKind::Impl\n                                         },\n-                                        _ => return Some(None)\n+                                        _ => return None\n                                     }\n                                 },\n-                                None => return Some(None),\n+                                None => return None,\n                             } }),\n                             Some(SyntaxKind::EXTERN_ITEM_LIST) => Some(PathKind::Item { kind: ItemListKind::ExternBlock }),\n                             Some(SyntaxKind::SOURCE_FILE) => Some(PathKind::Item { kind: ItemListKind::SourceFile }),\n                             _ => {\n-                               return Some(parent.and_then(ast::MacroExpr::cast).map(|it| {\n+                               return parent.and_then(ast::MacroExpr::cast).map(|it| {\n                                     let in_loop_body = is_in_loop_body(it.syntax());\n                                     let in_block_expr = is_in_block(it.syntax());\n                                     let after_if_expr = after_if_expr(it.syntax().clone());\n                                     fill_record_expr(it.syntax());\n-                                    PathKind::Expr { in_block_expr, in_loop_body, after_if_expr }\n-                                }));\n+                                    let ref_expr_parent = path.as_single_name_ref()\n+                                        .and_then(|_| it.syntax().parent()).and_then(ast::RefExpr::cast);\n+                                    PathKind::Expr { in_block_expr, in_loop_body, after_if_expr, ref_expr_parent }\n+                                });\n                             },\n                         }\n                     },\n@@ -1302,30 +1262,14 @@ impl<'a> CompletionContext<'a> {\n                     })(),\n                     ast::Visibility(it) => Some(PathKind::Vis { has_in_token: it.in_token().is_some() }),\n                     ast::UseTree(_) => Some(PathKind::Use),\n-                    ast::ItemList(_) => Some(PathKind::Item { kind: ItemListKind::Module }),\n-                    ast::AssocItemList(it) => Some(PathKind::Item { kind: {\n-                        match_ast! {\n-                            match (it.syntax().parent()?) {\n-                                ast::Trait(_) => ItemListKind::Trait,\n-                                ast::Impl(it) => if it.trait_().is_some() {\n-                                    ItemListKind::TraitImpl\n-                                } else {\n-                                    ItemListKind::Impl\n-                                },\n-                                _ => return None\n-                            }\n-                        }\n-                    }}),\n-                    ast::ExternItemList(_) => Some(PathKind::Item { kind: ItemListKind::ExternBlock }),\n-                    ast::SourceFile(_) => Some(PathKind::Item { kind: ItemListKind::SourceFile }),\n                     _ => return None,\n                 }\n-            };\n-            Some(kind)\n-        }).flatten();\n+            }\n+        });\n+\n         match kind {\n             Some(kind) => path_ctx.kind = kind,\n-            None => return (nameref_ctx, pat_ctx),\n+            None => return res,\n         }\n         path_ctx.has_type_args = segment.generic_arg_list().is_some();\n \n@@ -1367,8 +1311,62 @@ impl<'a> CompletionContext<'a> {\n                 path_ctx.is_absolute_path = true;\n             }\n         }\n+\n+        if path_ctx.is_trivial_path() {\n+            // fetch the full expression that may have qualifiers attached to it\n+            let top_node = match path_ctx.kind {\n+                PathKind::Expr { in_block_expr: true, .. } => {\n+                    parent.ancestors().find(|it| ast::PathExpr::can_cast(it.kind())).and_then(|p| {\n+                        let parent = p.parent()?;\n+                        if ast::StmtList::can_cast(parent.kind()) {\n+                            Some(p)\n+                        } else if ast::ExprStmt::can_cast(parent.kind()) {\n+                            Some(parent)\n+                        } else {\n+                            None\n+                        }\n+                    })\n+                }\n+                PathKind::Item { .. } => {\n+                    parent.ancestors().find(|it| ast::MacroCall::can_cast(it.kind()))\n+                }\n+                _ => None,\n+            };\n+            if let Some(top) = top_node {\n+                if let Some(NodeOrToken::Node(error_node)) =\n+                    syntax::algo::non_trivia_sibling(top.clone().into(), syntax::Direction::Prev)\n+                {\n+                    if error_node.kind() == SyntaxKind::ERROR {\n+                        qualifier_ctx.unsafe_tok = error_node\n+                            .children_with_tokens()\n+                            .filter_map(NodeOrToken::into_token)\n+                            .find(|it| it.kind() == T![unsafe]);\n+                        qualifier_ctx.vis_node =\n+                            error_node.children().find_map(ast::Visibility::cast);\n+                    }\n+                }\n+\n+                if let PathKind::Item { .. } = path_ctx.kind {\n+                    if qualifier_ctx.none() {\n+                        if let Some(t) = top.first_token() {\n+                            if let Some(prev) = t\n+                                .prev_token()\n+                                .and_then(|t| syntax::algo::skip_trivia_token(t, Direction::Prev))\n+                            {\n+                                if ![T![;], T!['}'], T!['{']].contains(&prev.kind()) {\n+                                    // This was inferred to be an item position path, but it seems\n+                                    // to be part of some other broken node which leaked into an item\n+                                    // list, so return without setting the path context\n+                                    return res;\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n         nameref_ctx.path_ctx = Some(path_ctx);\n-        (nameref_ctx, pat_ctx)\n+        res\n     }\n }\n "}, {"sha": "9dc367b0bcc4ca28a8249662dde65eb055ada4ac", "filename": "crates/ide-completion/src/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/312913a640760e9af0cff07cbb29950b810a643c/crates%2Fide-completion%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/312913a640760e9af0cff07cbb29950b810a643c/crates%2Fide-completion%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Flib.rs?ref=312913a640760e9af0cff07cbb29950b810a643c", "patch": "@@ -169,11 +169,9 @@ pub fn completions(\n             completions::mod_::complete_mod(acc, ctx);\n             completions::pattern::complete_pattern(acc, ctx);\n             completions::postfix::complete_postfix(acc, ctx);\n-            completions::record::complete_record_literal(acc, ctx);\n             completions::record::complete_record(acc, ctx);\n             completions::snippet::complete_expr_snippet(acc, ctx);\n             completions::snippet::complete_item_snippet(acc, ctx);\n-            completions::trait_impl::complete_trait_impl(acc, ctx);\n             completions::r#type::complete_type_path(acc, ctx);\n             completions::r#type::complete_inferred_type(acc, ctx);\n             completions::use_::complete_use_tree(acc, ctx);"}, {"sha": "761c97b9a962b8b35e56c5c4d61512f752c03bc9", "filename": "crates/ide-completion/src/patterns.rs", "status": "modified", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/312913a640760e9af0cff07cbb29950b810a643c/crates%2Fide-completion%2Fsrc%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/312913a640760e9af0cff07cbb29950b810a643c/crates%2Fide-completion%2Fsrc%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fpatterns.rs?ref=312913a640760e9af0cff07cbb29950b810a643c", "patch": "@@ -30,7 +30,6 @@ pub(crate) enum TypeAnnotation {\n /// from which file the nodes are.\n #[derive(Clone, Debug, PartialEq, Eq)]\n pub(crate) enum ImmediateLocation {\n-    RefExpr,\n     TypeBound,\n     /// Original file ast node\n     TypeAnnotation(TypeAnnotation),\n@@ -80,7 +79,6 @@ pub(crate) fn determine_location(\n \n     let res = match_ast! {\n         match parent {\n-            ast::RefExpr(_) => ImmediateLocation::RefExpr,\n             ast::TypeBound(_) => ImmediateLocation::TypeBound,\n             ast::TypeBoundList(_) => ImmediateLocation::TypeBound,\n             ast::GenericArgList(_) => sema\n@@ -248,30 +246,3 @@ fn next_non_trivia_sibling(ele: SyntaxElement) -> Option<SyntaxElement> {\n     }\n     None\n }\n-\n-#[cfg(test)]\n-mod tests {\n-    use syntax::algo::find_node_at_offset;\n-\n-    use crate::tests::position;\n-\n-    use super::*;\n-\n-    fn check_location(code: &str, loc: impl Into<Option<ImmediateLocation>>) {\n-        let (db, pos) = position(code);\n-\n-        let sema = Semantics::new(&db);\n-        let original_file = sema.parse(pos.file_id);\n-\n-        let name_like = find_node_at_offset(original_file.syntax(), pos.offset).unwrap();\n-        assert_eq!(\n-            determine_location(&sema, original_file.syntax(), pos.offset, &name_like),\n-            loc.into()\n-        );\n-    }\n-\n-    #[test]\n-    fn test_ref_expr_loc() {\n-        check_location(r\"fn my_fn() { let x = &m$0 foo; }\", ImmediateLocation::RefExpr);\n-    }\n-}"}, {"sha": "942dc033687b3a5d0e00110fe913690d5988ccb6", "filename": "crates/ide-completion/src/render.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/312913a640760e9af0cff07cbb29950b810a643c/crates%2Fide-completion%2Fsrc%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/312913a640760e9af0cff07cbb29950b810a643c/crates%2Fide-completion%2Fsrc%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Frender.rs?ref=312913a640760e9af0cff07cbb29950b810a643c", "patch": "@@ -1099,6 +1099,8 @@ fn go(world: &WorldSnapshot) { go(w$0) }\n \"#,\n             expect![[r#\"\n                 lc world [type+name+local]\n+                st WorldSnapshot {\u2026} []\n+                st &WorldSnapshot {\u2026} [type]\n                 st WorldSnapshot []\n                 fn go(\u2026) []\n             \"#]],\n@@ -1197,6 +1199,8 @@ fn main() {\n                 lc s [name+local]\n                 lc &mut s [type+name+local]\n                 st S []\n+                st &mut S [type]\n+                st S []\n                 fn main() []\n                 fn foo(\u2026) []\n             \"#]],\n@@ -1266,6 +1270,8 @@ fn main() {\n                 lc m [local]\n                 lc t [local]\n                 lc &t [type+local]\n+                st S []\n+                st &S [type]\n                 st T []\n                 st S []\n                 fn main() []\n@@ -1311,6 +1317,8 @@ fn main() {\n                 lc m [local]\n                 lc t [local]\n                 lc &mut t [type+local]\n+                st S []\n+                st &mut S [type]\n                 st T []\n                 st S []\n                 fn main() []\n@@ -1405,6 +1413,8 @@ fn main() {\n }\n \"#,\n             expect![[r#\"\n+                st S []\n+                st &S [type]\n                 st T []\n                 st S []\n                 fn main() []"}, {"sha": "de527860d8c3481a7403bcb48687edf7739f80de", "filename": "crates/ide-completion/src/render/macro_.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/312913a640760e9af0cff07cbb29950b810a643c/crates%2Fide-completion%2Fsrc%2Frender%2Fmacro_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/312913a640760e9af0cff07cbb29950b810a643c/crates%2Fide-completion%2Fsrc%2Frender%2Fmacro_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Frender%2Fmacro_.rs?ref=312913a640760e9af0cff07cbb29950b810a643c", "patch": "@@ -34,8 +34,8 @@ fn render(\n     let (bra, ket) = if is_fn_like { guess_macro_braces(&name, docs_str) } else { (\"\", \"\") };\n \n     let needs_bang = match completion.path_context() {\n-        Some(&PathCompletionCtx { kind, has_macro_bang, .. }) => {\n-            is_fn_like && kind != PathKind::Use && !has_macro_bang\n+        Some(PathCompletionCtx { kind, has_macro_bang, .. }) => {\n+            is_fn_like && *kind != PathKind::Use && !has_macro_bang\n         }\n         _ => is_fn_like,\n     };"}]}