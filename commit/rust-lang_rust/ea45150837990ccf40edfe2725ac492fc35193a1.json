{"sha": "ea45150837990ccf40edfe2725ac492fc35193a1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVhNDUxNTA4Mzc5OTBjY2Y0MGVkZmUyNzI1YWM0OTJmYzM1MTkzYTE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-10-17T10:45:09Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-10-17T10:45:09Z"}, "message": "Auto merge of #59953 - eddyb:soa-metadata, r=michaelwoerister\n\n rustc_metadata: replace Entry table with one table for each of its fields (AoS -> SoA).\n\nIn https://github.com/rust-lang/rust/pull/59789#issuecomment-481958212 I noticed that for many cross-crate queries (e.g. `predicates_of(def_id)`), we were deserializing the `rustc_metadata::schema::Entry` for `def_id` *only* to read one field (i.e. `predicates`).\n\nBut there are several such queries, and `Entry` is not particularly small (in terms of number of fields, the encoding itself is quite compact), so there is a large (and unnecessary) constant factor.\n\nThis PR replaces the (random-access) array\u00b9 of `Entry` structures (\"AoS\"), with many separate arrays\u00b9, one for each field that used to be in `Entry` (\"SoA\"), resulting in the ability to read individual fields separately, with negligible time overhead (in thoery), and some size overhead (as these arrays are not sparse).\n\nIn a way, the new approach is closer to incremental on-disk caches, which store each query's cached results separately, but it would take significantly more work to unify the two.\n\nFor stage1 `libcore`'s metadata blob, the size overhead is `8.44%`, and I have another commit (~~not initially included because I want to do perf runs with both~~ **EDIT**: added it now) that brings it down to `5.88%`.\n\n\u00b9(in the source, these arrays are called \"tables\", but perhaps they could use a better name)", "tree": {"sha": "17b0dd4e69fc651bb9166716911814581229b546", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/17b0dd4e69fc651bb9166716911814581229b546"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ea45150837990ccf40edfe2725ac492fc35193a1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ea45150837990ccf40edfe2725ac492fc35193a1", "html_url": "https://github.com/rust-lang/rust/commit/ea45150837990ccf40edfe2725ac492fc35193a1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ea45150837990ccf40edfe2725ac492fc35193a1/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a16dca337de610986252bb800953e57bf395863f", "url": "https://api.github.com/repos/rust-lang/rust/commits/a16dca337de610986252bb800953e57bf395863f", "html_url": "https://github.com/rust-lang/rust/commit/a16dca337de610986252bb800953e57bf395863f"}, {"sha": "d89dddc9204a540efcd7f86c36d60381020b2422", "url": "https://api.github.com/repos/rust-lang/rust/commits/d89dddc9204a540efcd7f86c36d60381020b2422", "html_url": "https://github.com/rust-lang/rust/commit/d89dddc9204a540efcd7f86c36d60381020b2422"}], "stats": {"total": 1733, "additions": 857, "deletions": 876}, "files": [{"sha": "962846b0475330c075b9402d20eb513caf258ff8", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 124, "deletions": 109, "changes": 233, "blob_url": "https://github.com/rust-lang/rust/blob/ea45150837990ccf40edfe2725ac492fc35193a1/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea45150837990ccf40edfe2725ac492fc35193a1/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=ea45150837990ccf40edfe2725ac492fc35193a1", "patch": "@@ -2,6 +2,7 @@\n \n use crate::cstore::{self, CrateMetadata, MetadataBlob};\n use crate::schema::*;\n+use crate::table::{FixedSizeEncoding, PerDefTable};\n \n use rustc_index::vec::IndexVec;\n use rustc_data_structures::sync::{Lrc, ReadGuard};\n@@ -25,9 +26,10 @@ use rustc::util::captures::Captures;\n \n use std::io;\n use std::mem;\n+use std::num::NonZeroUsize;\n use std::u32;\n \n-use rustc_serialize::{Decodable, Decoder, SpecializedDecoder, opaque};\n+use rustc_serialize::{Decodable, Decoder, Encodable, SpecializedDecoder, opaque};\n use syntax::attr;\n use syntax::ast::{self, Ident};\n use syntax::source_map::{self, respan, Spanned};\n@@ -129,20 +131,20 @@ impl<'a, 'tcx> Metadata<'a, 'tcx> for (&'a CrateMetadata, TyCtxt<'tcx>) {\n     }\n }\n \n-impl<'a, 'tcx, T: Decodable> Lazy<T> {\n-    crate fn decode<M: Metadata<'a, 'tcx>>(self, meta: M) -> T {\n-        let mut dcx = meta.decoder(self.position);\n+impl<'a, 'tcx, T: Encodable + Decodable> Lazy<T> {\n+    crate fn decode<M: Metadata<'a, 'tcx>>(self, metadata: M) -> T {\n+        let mut dcx = metadata.decoder(self.position.get());\n         dcx.lazy_state = LazyState::NodeStart(self.position);\n         T::decode(&mut dcx).unwrap()\n     }\n }\n \n-impl<'a: 'x, 'tcx: 'x, 'x, T: Decodable> Lazy<[T]> {\n+impl<'a: 'x, 'tcx: 'x, 'x, T: Encodable + Decodable> Lazy<[T]> {\n     crate fn decode<M: Metadata<'a, 'tcx>>(\n         self,\n-        meta: M,\n+        metadata: M,\n     ) -> impl ExactSizeIterator<Item = T> + Captures<'a> + Captures<'tcx> + 'x {\n-        let mut dcx = meta.decoder(self.position);\n+        let mut dcx = metadata.decoder(self.position.get());\n         dcx.lazy_state = LazyState::NodeStart(self.position);\n         (0..self.meta).map(move |_| T::decode(&mut dcx).unwrap())\n     }\n@@ -166,13 +168,14 @@ impl<'a, 'tcx> DecodeContext<'a, 'tcx> {\n         let position = match self.lazy_state {\n             LazyState::NoNode => bug!(\"read_lazy_with_meta: outside of a metadata node\"),\n             LazyState::NodeStart(start) => {\n+                let start = start.get();\n                 assert!(distance + min_size <= start);\n                 start - distance - min_size\n             }\n-            LazyState::Previous(last_min_end) => last_min_end + distance,\n+            LazyState::Previous(last_min_end) => last_min_end.get() + distance,\n         };\n-        self.lazy_state = LazyState::Previous(position + min_size);\n-        Ok(Lazy::from_position_and_meta(position, meta))\n+        self.lazy_state = LazyState::Previous(NonZeroUsize::new(position + min_size).unwrap());\n+        Ok(Lazy::from_position_and_meta(NonZeroUsize::new(position).unwrap(), meta))\n     }\n }\n \n@@ -235,13 +238,13 @@ impl<'a, 'tcx> TyDecoder<'tcx> for DecodeContext<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx, T> SpecializedDecoder<Lazy<T>> for DecodeContext<'a, 'tcx> {\n+impl<'a, 'tcx, T: Encodable> SpecializedDecoder<Lazy<T>> for DecodeContext<'a, 'tcx> {\n     fn specialized_decode(&mut self) -> Result<Lazy<T>, Self::Error> {\n         self.read_lazy_with_meta(())\n     }\n }\n \n-impl<'a, 'tcx, T> SpecializedDecoder<Lazy<[T]>> for DecodeContext<'a, 'tcx> {\n+impl<'a, 'tcx, T: Encodable> SpecializedDecoder<Lazy<[T]>> for DecodeContext<'a, 'tcx> {\n     fn specialized_decode(&mut self) -> Result<Lazy<[T]>, Self::Error> {\n         let len = self.read_usize()?;\n         if len == 0 {\n@@ -252,6 +255,14 @@ impl<'a, 'tcx, T> SpecializedDecoder<Lazy<[T]>> for DecodeContext<'a, 'tcx> {\n     }\n }\n \n+impl<'a, 'tcx, T> SpecializedDecoder<Lazy<PerDefTable<T>>> for DecodeContext<'a, 'tcx>\n+    where Option<T>: FixedSizeEncoding,\n+{\n+    fn specialized_decode(&mut self) -> Result<Lazy<PerDefTable<T>>, Self::Error> {\n+        let len = self.read_usize()?;\n+        self.read_lazy_with_meta(len)\n+    }\n+}\n \n impl<'a, 'tcx> SpecializedDecoder<DefId> for DecodeContext<'a, 'tcx> {\n     #[inline]\n@@ -384,7 +395,9 @@ impl<'tcx> MetadataBlob {\n     }\n \n     crate fn get_rustc_version(&self) -> String {\n-        Lazy::<String>::from_position(METADATA_HEADER.len() + 4).decode(self)\n+        Lazy::<String>::from_position(\n+            NonZeroUsize::new(METADATA_HEADER.len() + 4).unwrap(),\n+        ).decode(self)\n     }\n \n     crate fn get_root(&self) -> CrateRoot<'tcx> {\n@@ -393,7 +406,9 @@ impl<'tcx> MetadataBlob {\n         let pos = (((slice[offset + 0] as u32) << 24) | ((slice[offset + 1] as u32) << 16) |\n                    ((slice[offset + 2] as u32) << 8) |\n                    ((slice[offset + 3] as u32) << 0)) as usize;\n-        Lazy::<CrateRoot<'tcx>>::from_position(pos).decode(self)\n+        Lazy::<CrateRoot<'tcx>>::from_position(\n+            NonZeroUsize::new(pos).unwrap(),\n+        ).decode(self)\n     }\n \n     crate fn list_crate_metadata(&self,\n@@ -458,27 +473,20 @@ impl<'a, 'tcx> CrateMetadata {\n             self.root.proc_macro_data.unwrap().decode(self).find(|x| *x == id).is_some()\n     }\n \n-    fn entry_unless_proc_macro(&self, id: DefIndex) -> Option<Entry<'tcx>> {\n-        match self.is_proc_macro(id) {\n-            true => None,\n-            false => Some(self.entry(id)),\n-        }\n-    }\n-\n-    fn maybe_entry(&self, item_id: DefIndex) -> Option<Lazy<Entry<'tcx>>> {\n-        self.root.entries_index.lookup(self.blob.raw_bytes(), item_id)\n+    fn maybe_kind(&self, item_id: DefIndex) -> Option<EntryKind<'tcx>> {\n+        self.root.per_def.kind.get(self, item_id).map(|k| k.decode(self))\n     }\n \n-    fn entry(&self, item_id: DefIndex) -> Entry<'tcx> {\n-        match self.maybe_entry(item_id) {\n-            None => {\n-                bug!(\"entry: id not found: {:?} in crate {:?} with number {}\",\n-                     item_id,\n-                     self.root.name,\n-                     self.cnum)\n-            }\n-            Some(d) => d.decode(self),\n-        }\n+    fn kind(&self, item_id: DefIndex) -> EntryKind<'tcx> {\n+        assert!(!self.is_proc_macro(item_id));\n+        self.maybe_kind(item_id).unwrap_or_else(|| {\n+            bug!(\n+                \"CrateMetadata::kind({:?}): id not found, in crate {:?} with number {}\",\n+                item_id,\n+                self.root.name,\n+                self.cnum,\n+            )\n+        })\n     }\n \n     fn local_def_id(&self, index: DefIndex) -> DefId {\n@@ -514,7 +522,7 @@ impl<'a, 'tcx> CrateMetadata {\n \n     crate fn def_kind(&self, index: DefIndex) -> Option<DefKind> {\n         if !self.is_proc_macro(index) {\n-            self.entry(index).kind.def_kind()\n+            self.kind(index).def_kind()\n         } else {\n             Some(DefKind::Macro(\n                 macro_kind(self.raw_proc_macro(index))\n@@ -523,7 +531,7 @@ impl<'a, 'tcx> CrateMetadata {\n     }\n \n     crate fn get_span(&self, index: DefIndex, sess: &Session) -> Span {\n-        self.entry(index).span.decode((self, sess))\n+        self.root.per_def.span.get(self, index).unwrap().decode((self, sess))\n     }\n \n     crate fn load_proc_macro(&self, id: DefIndex, sess: &Session) -> SyntaxExtension {\n@@ -552,12 +560,12 @@ impl<'a, 'tcx> CrateMetadata {\n             helper_attrs,\n             self.root.edition,\n             Symbol::intern(name),\n-            &self.get_attributes(&self.entry(id), sess),\n+            &self.get_item_attrs(id, sess),\n         )\n     }\n \n     crate fn get_trait_def(&self, item_id: DefIndex, sess: &Session) -> ty::TraitDef {\n-        match self.entry(item_id).kind {\n+        match self.kind(item_id) {\n             EntryKind::Trait(data) => {\n                 let data = data.decode((self, sess));\n                 ty::TraitDef::new(self.local_def_id(item_id),\n@@ -582,18 +590,24 @@ impl<'a, 'tcx> CrateMetadata {\n     fn get_variant(\n         &self,\n         tcx: TyCtxt<'tcx>,\n-        item: &Entry<'_>,\n+        kind: &EntryKind<'_>,\n         index: DefIndex,\n         parent_did: DefId,\n-        adt_kind: ty::AdtKind,\n     ) -> ty::VariantDef {\n-        let data = match item.kind {\n+        let data = match kind {\n             EntryKind::Variant(data) |\n             EntryKind::Struct(data, _) |\n             EntryKind::Union(data, _) => data.decode(self),\n             _ => bug!(),\n         };\n \n+        let adt_kind = match kind {\n+            EntryKind::Variant(_) => ty::AdtKind::Enum,\n+            EntryKind::Struct(..) => ty::AdtKind::Struct,\n+            EntryKind::Union(..) => ty::AdtKind::Union,\n+            _ => bug!(),\n+        };\n+\n         let variant_did = if adt_kind == ty::AdtKind::Enum {\n             Some(self.local_def_id(index))\n         } else {\n@@ -607,14 +621,12 @@ impl<'a, 'tcx> CrateMetadata {\n             variant_did,\n             ctor_did,\n             data.discr,\n-            item.children.decode(self).map(|index| {\n-                let f = self.entry(index);\n-                ty::FieldDef {\n+            self.root.per_def.children.get(self, index).unwrap_or(Lazy::empty())\n+                .decode(self).map(|index| ty::FieldDef {\n                     did: self.local_def_id(index),\n                     ident: Ident::with_dummy_span(self.item_name(index)),\n-                    vis: f.visibility.decode(self)\n-                }\n-            }).collect(),\n+                    vis: self.get_visibility(index),\n+                }).collect(),\n             data.ctor_kind,\n             adt_kind,\n             parent_did,\n@@ -623,52 +635,52 @@ impl<'a, 'tcx> CrateMetadata {\n     }\n \n     crate fn get_adt_def(&self, item_id: DefIndex, tcx: TyCtxt<'tcx>) -> &'tcx ty::AdtDef {\n-        let item = self.entry(item_id);\n+        let kind = self.kind(item_id);\n         let did = self.local_def_id(item_id);\n \n-        let (kind, repr) = match item.kind {\n+        let (adt_kind, repr) = match kind {\n             EntryKind::Enum(repr) => (ty::AdtKind::Enum, repr),\n             EntryKind::Struct(_, repr) => (ty::AdtKind::Struct, repr),\n             EntryKind::Union(_, repr) => (ty::AdtKind::Union, repr),\n             _ => bug!(\"get_adt_def called on a non-ADT {:?}\", did),\n         };\n \n-        let variants = if let ty::AdtKind::Enum = kind {\n-            item.children\n+        let variants = if let ty::AdtKind::Enum = adt_kind {\n+            self.root.per_def.children.get(self, item_id).unwrap_or(Lazy::empty())\n                 .decode(self)\n                 .map(|index| {\n-                    self.get_variant(tcx, &self.entry(index), index, did, kind)\n+                    self.get_variant(tcx, &self.kind(index), index, did)\n                 })\n                 .collect()\n         } else {\n-            std::iter::once(self.get_variant(tcx, &item, item_id, did, kind)).collect()\n+            std::iter::once(self.get_variant(tcx, &kind, item_id, did)).collect()\n         };\n \n-        tcx.alloc_adt_def(did, kind, variants, repr)\n+        tcx.alloc_adt_def(did, adt_kind, variants, repr)\n     }\n \n     crate fn get_predicates(\n         &self,\n         item_id: DefIndex,\n         tcx: TyCtxt<'tcx>,\n     ) -> ty::GenericPredicates<'tcx> {\n-        self.entry(item_id).predicates.unwrap().decode((self, tcx))\n+        self.root.per_def.predicates.get(self, item_id).unwrap().decode((self, tcx))\n }\n \n     crate fn get_predicates_defined_on(\n         &self,\n         item_id: DefIndex,\n         tcx: TyCtxt<'tcx>,\n     ) -> ty::GenericPredicates<'tcx> {\n-        self.entry(item_id).predicates_defined_on.unwrap().decode((self, tcx))\n+        self.root.per_def.predicates_defined_on.get(self, item_id).unwrap().decode((self, tcx))\n     }\n \n     crate fn get_super_predicates(\n         &self,\n         item_id: DefIndex,\n         tcx: TyCtxt<'tcx>,\n     ) -> ty::GenericPredicates<'tcx> {\n-        let super_predicates = match self.entry(item_id).kind {\n+        let super_predicates = match self.kind(item_id) {\n             EntryKind::Trait(data) => data.decode(self).super_predicates,\n             EntryKind::TraitAlias(data) => data.decode(self).super_predicates,\n             _ => bug!(\"def-index does not refer to trait or trait alias\"),\n@@ -678,34 +690,35 @@ impl<'a, 'tcx> CrateMetadata {\n     }\n \n     crate fn get_generics(&self, item_id: DefIndex, sess: &Session) -> ty::Generics {\n-        self.entry(item_id).generics.unwrap().decode((self, sess))\n+        self.root.per_def.generics.get(self, item_id).unwrap().decode((self, sess))\n     }\n \n     crate fn get_type(&self, id: DefIndex, tcx: TyCtxt<'tcx>) -> Ty<'tcx> {\n-        self.entry(id).ty.unwrap().decode((self, tcx))\n+        self.root.per_def.ty.get(self, id).unwrap().decode((self, tcx))\n     }\n \n     crate fn get_stability(&self, id: DefIndex) -> Option<attr::Stability> {\n         match self.is_proc_macro(id) {\n             true => self.root.proc_macro_stability.clone(),\n-            false => self.entry(id).stability.map(|stab| stab.decode(self)),\n+            false => self.root.per_def.stability.get(self, id).map(|stab| stab.decode(self)),\n         }\n     }\n \n     crate fn get_deprecation(&self, id: DefIndex) -> Option<attr::Deprecation> {\n-        self.entry_unless_proc_macro(id)\n-            .and_then(|entry| entry.deprecation.map(|depr| depr.decode(self)))\n+        self.root.per_def.deprecation.get(self, id)\n+            .filter(|_| !self.is_proc_macro(id))\n+            .map(|depr| depr.decode(self))\n     }\n \n     crate fn get_visibility(&self, id: DefIndex) -> ty::Visibility {\n         match self.is_proc_macro(id) {\n             true => ty::Visibility::Public,\n-            false => self.entry(id).visibility.decode(self),\n+            false => self.root.per_def.visibility.get(self, id).unwrap().decode(self),\n         }\n     }\n \n     fn get_impl_data(&self, id: DefIndex) -> ImplData<'tcx> {\n-        match self.entry(id).kind {\n+        match self.kind(id) {\n             EntryKind::Impl(data) => data.decode(self),\n             _ => bug!(),\n         }\n@@ -801,38 +814,42 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n \n         // Find the item.\n-        let item = match self.maybe_entry(id) {\n+        let kind = match self.maybe_kind(id) {\n             None => return,\n-            Some(item) => item.decode((self, sess)),\n+            Some(kind) => kind,\n         };\n \n         // Iterate over all children.\n         let macros_only = self.dep_kind.lock().macros_only();\n-        for child_index in item.children.decode((self, sess)) {\n+        let children = self.root.per_def.children.get(self, id).unwrap_or(Lazy::empty());\n+        for child_index in children.decode((self, sess)) {\n             if macros_only {\n                 continue\n             }\n \n             // Get the item.\n-            if let Some(child) = self.maybe_entry(child_index) {\n-                let child = child.decode((self, sess));\n-                match child.kind {\n+            if let Some(child_kind) = self.maybe_kind(child_index) {\n+                match child_kind {\n                     EntryKind::MacroDef(..) => {}\n                     _ if macros_only => continue,\n                     _ => {}\n                 }\n \n                 // Hand off the item to the callback.\n-                match child.kind {\n+                match child_kind {\n                     // FIXME(eddyb) Don't encode these in children.\n                     EntryKind::ForeignMod => {\n-                        for child_index in child.children.decode((self, sess)) {\n+                        let child_children =\n+                            self.root.per_def.children.get(self, child_index)\n+                                .unwrap_or(Lazy::empty());\n+                        for child_index in child_children.decode((self, sess)) {\n                             if let Some(kind) = self.def_kind(child_index) {\n                                 callback(def::Export {\n                                     res: Res::Def(kind, self.local_def_id(child_index)),\n                                     ident: Ident::with_dummy_span(self.item_name(child_index)),\n                                     vis: self.get_visibility(child_index),\n-                                    span: self.entry(child_index).span.decode((self, sess)),\n+                                    span: self.root.per_def.span.get(self, child_index).unwrap()\n+                                        .decode((self, sess)),\n                                 });\n                             }\n                         }\n@@ -844,7 +861,7 @@ impl<'a, 'tcx> CrateMetadata {\n                 }\n \n                 let def_key = self.def_key(child_index);\n-                let span = child.span.decode((self, sess));\n+                let span = self.get_span(child_index, sess);\n                 if let (Some(kind), Some(name)) =\n                     (self.def_kind(child_index), def_key.disambiguated_data.data.get_opt_name()) {\n                     let ident = Ident::from_interned_str(name);\n@@ -897,7 +914,7 @@ impl<'a, 'tcx> CrateMetadata {\n             }\n         }\n \n-        if let EntryKind::Mod(data) = item.kind {\n+        if let EntryKind::Mod(data) = kind {\n             for exp in data.decode((self, sess)).reexports.decode((self, sess)) {\n                 match exp.res {\n                     Res::Def(DefKind::Macro(..), _) => {}\n@@ -911,31 +928,33 @@ impl<'a, 'tcx> CrateMetadata {\n \n     crate fn is_item_mir_available(&self, id: DefIndex) -> bool {\n         !self.is_proc_macro(id) &&\n-        self.maybe_entry(id).and_then(|item| item.decode(self).mir).is_some()\n+            self.root.per_def.mir.get(self, id).is_some()\n     }\n \n     crate fn get_optimized_mir(&self, tcx: TyCtxt<'tcx>, id: DefIndex) -> Body<'tcx> {\n-        self.entry_unless_proc_macro(id)\n-            .and_then(|entry| entry.mir.map(|mir| mir.decode((self, tcx))))\n+        self.root.per_def.mir.get(self, id)\n+            .filter(|_| !self.is_proc_macro(id))\n             .unwrap_or_else(|| {\n                 bug!(\"get_optimized_mir: missing MIR for `{:?}`\", self.local_def_id(id))\n             })\n+            .decode((self, tcx))\n     }\n \n     crate fn get_promoted_mir(\n         &self,\n         tcx: TyCtxt<'tcx>,\n         id: DefIndex,\n     ) -> IndexVec<Promoted, Body<'tcx>> {\n-        self.entry_unless_proc_macro(id)\n-            .and_then(|entry| entry.promoted_mir.map(|promoted| promoted.decode((self, tcx))))\n+        self.root.per_def.promoted_mir.get(self, id)\n+            .filter(|_| !self.is_proc_macro(id))\n             .unwrap_or_else(|| {\n                 bug!(\"get_promoted_mir: missing MIR for `{:?}`\", self.local_def_id(id))\n             })\n+            .decode((self, tcx))\n     }\n \n     crate fn mir_const_qualif(&self, id: DefIndex) -> u8 {\n-        match self.entry(id).kind {\n+        match self.kind(id) {\n             EntryKind::Const(qualif, _) |\n             EntryKind::AssocConst(AssocContainer::ImplDefault, qualif, _) |\n             EntryKind::AssocConst(AssocContainer::ImplFinal, qualif, _) => {\n@@ -946,12 +965,11 @@ impl<'a, 'tcx> CrateMetadata {\n     }\n \n     crate fn get_associated_item(&self, id: DefIndex) -> ty::AssocItem {\n-        let item = self.entry(id);\n         let def_key = self.def_key(id);\n         let parent = self.local_def_id(def_key.parent.unwrap());\n         let name = def_key.disambiguated_data.data.get_opt_name().unwrap();\n \n-        let (kind, container, has_self) = match item.kind {\n+        let (kind, container, has_self) = match self.kind(id) {\n             EntryKind::AssocConst(container, _, _) => {\n                 (ty::AssocKind::Const, container, false)\n             }\n@@ -971,7 +989,7 @@ impl<'a, 'tcx> CrateMetadata {\n         ty::AssocItem {\n             ident: Ident::from_interned_str(name),\n             kind,\n-            vis: item.visibility.decode(self),\n+            vis: self.get_visibility(id),\n             defaultness: container.defaultness(),\n             def_id: self.local_def_id(id),\n             container: container.with_def_id(parent),\n@@ -980,11 +998,12 @@ impl<'a, 'tcx> CrateMetadata {\n     }\n \n     crate fn get_item_variances(&self, id: DefIndex) -> Vec<ty::Variance> {\n-        self.entry(id).variances.decode(self).collect()\n+        self.root.per_def.variances.get(self, id).unwrap_or(Lazy::empty())\n+            .decode(self).collect()\n     }\n \n     crate fn get_ctor_kind(&self, node_id: DefIndex) -> CtorKind {\n-        match self.entry(node_id).kind {\n+        match self.kind(node_id) {\n             EntryKind::Struct(data, _) |\n             EntryKind::Union(data, _) |\n             EntryKind::Variant(data) => data.decode(self).ctor_kind,\n@@ -993,7 +1012,7 @@ impl<'a, 'tcx> CrateMetadata {\n     }\n \n     crate fn get_ctor_def_id(&self, node_id: DefIndex) -> Option<DefId> {\n-        match self.entry(node_id).kind {\n+        match self.kind(node_id) {\n             EntryKind::Struct(data, _) => {\n                 data.decode(self).ctor.map(|index| self.local_def_id(index))\n             }\n@@ -1015,26 +1034,22 @@ impl<'a, 'tcx> CrateMetadata {\n             node_id\n         };\n \n-        let item = self.entry(item_id);\n-        Lrc::from(self.get_attributes(&item, sess))\n+        Lrc::from(self.root.per_def.attributes.get(self, item_id).unwrap_or(Lazy::empty())\n+            .decode((self, sess))\n+            .collect::<Vec<_>>())\n     }\n \n     crate fn get_struct_field_names(\n         &self,\n         id: DefIndex,\n         sess: &Session,\n     ) -> Vec<Spanned<ast::Name>> {\n-        self.entry(id)\n-            .children\n+        self.root.per_def.children.get(self, id).unwrap_or(Lazy::empty())\n             .decode(self)\n             .map(|index| respan(self.get_span(index, sess), self.item_name(index)))\n             .collect()\n     }\n \n-    fn get_attributes(&self, item: &Entry<'tcx>, sess: &Session) -> Vec<ast::Attribute> {\n-        item.attributes.decode((self, sess)).collect()\n-    }\n-\n     // Translate a DefId from the current compilation environment to a DefId\n     // for an external crate.\n     fn reverse_translate_def_id(&self, did: DefId) -> Option<DefId> {\n@@ -1055,10 +1070,11 @@ impl<'a, 'tcx> CrateMetadata {\n         tcx: TyCtxt<'tcx>,\n         id: DefIndex,\n     ) -> &'tcx [DefId] {\n-        tcx.arena.alloc_from_iter(self.entry(id)\n-                                      .inherent_impls\n-                                      .decode(self)\n-                                      .map(|index| self.local_def_id(index)))\n+        tcx.arena.alloc_from_iter(\n+            self.root.per_def.inherent_impls.get(self, id).unwrap_or(Lazy::empty())\n+                .decode(self)\n+                .map(|index| self.local_def_id(index))\n+        )\n     }\n \n     crate fn get_implementations_for_trait(\n@@ -1100,7 +1116,7 @@ impl<'a, 'tcx> CrateMetadata {\n             _ => return None,\n         }\n         def_key.parent.and_then(|parent_index| {\n-            match self.entry(parent_index).kind {\n+            match self.kind(parent_index) {\n                 EntryKind::Trait(_) |\n                 EntryKind::TraitAlias(_) => Some(self.local_def_id(parent_index)),\n                 _ => None,\n@@ -1153,7 +1169,7 @@ impl<'a, 'tcx> CrateMetadata {\n     }\n \n     crate fn get_fn_param_names(&self, id: DefIndex) -> Vec<ast::Name> {\n-        let param_names = match self.entry(id).kind {\n+        let param_names = match self.kind(id) {\n             EntryKind::Fn(data) |\n             EntryKind::ForeignFn(data) => data.decode(self).param_names,\n             EntryKind::Method(data) => data.decode(self).fn_data.param_names,\n@@ -1176,23 +1192,22 @@ impl<'a, 'tcx> CrateMetadata {\n     }\n \n     crate fn get_rendered_const(&self, id: DefIndex) -> String {\n-        match self.entry(id).kind {\n+        match self.kind(id) {\n             EntryKind::Const(_, data) |\n             EntryKind::AssocConst(_, _, data) => data.decode(self).0,\n             _ => bug!(),\n         }\n     }\n \n     crate fn get_macro(&self, id: DefIndex) -> MacroDef {\n-        let entry = self.entry(id);\n-        match entry.kind {\n+        match self.kind(id) {\n             EntryKind::MacroDef(macro_def) => macro_def.decode(self),\n             _ => bug!(),\n         }\n     }\n \n     crate fn is_const_fn_raw(&self, id: DefIndex) -> bool {\n-        let constness = match self.entry(id).kind {\n+        let constness = match self.kind(id) {\n             EntryKind::Method(data) => data.decode(self).fn_data.constness,\n             EntryKind::Fn(data) => data.decode(self).constness,\n             EntryKind::Variant(..) | EntryKind::Struct(..) => hir::Constness::Const,\n@@ -1202,16 +1217,16 @@ impl<'a, 'tcx> CrateMetadata {\n     }\n \n     crate fn asyncness(&self, id: DefIndex) -> hir::IsAsync {\n-         match self.entry(id).kind {\n+         match self.kind(id) {\n             EntryKind::Fn(data) => data.decode(self).asyncness,\n             EntryKind::Method(data) => data.decode(self).fn_data.asyncness,\n             EntryKind::ForeignFn(data) => data.decode(self).asyncness,\n-            _ => bug!(\"asyncness: expect functions entry.\"),\n+            _ => bug!(\"asyncness: expected function kind\"),\n         }\n     }\n \n     crate fn is_foreign_item(&self, id: DefIndex) -> bool {\n-        match self.entry(id).kind {\n+        match self.kind(id) {\n             EntryKind::ForeignImmStatic |\n             EntryKind::ForeignMutStatic |\n             EntryKind::ForeignFn(_) => true,\n@@ -1220,7 +1235,7 @@ impl<'a, 'tcx> CrateMetadata {\n     }\n \n     crate fn static_mutability(&self, id: DefIndex) -> Option<hir::Mutability> {\n-        match self.entry(id).kind {\n+        match self.kind(id) {\n             EntryKind::ImmStatic |\n             EntryKind::ForeignImmStatic => Some(hir::MutImmutable),\n             EntryKind::MutStatic |\n@@ -1230,7 +1245,7 @@ impl<'a, 'tcx> CrateMetadata {\n     }\n \n     crate fn fn_sig(&self, id: DefIndex, tcx: TyCtxt<'tcx>) -> ty::PolyFnSig<'tcx> {\n-        let sig = match self.entry(id).kind {\n+        let sig = match self.kind(id) {\n             EntryKind::Fn(data) |\n             EntryKind::ForeignFn(data) => data.decode(self).sig,\n             EntryKind::Method(data) => data.decode(self).fn_data.sig,"}, {"sha": "f1436e4c09dffb722929437173ee4945f225588f", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 429, "deletions": 573, "changes": 1002, "blob_url": "https://github.com/rust-lang/rust/blob/ea45150837990ccf40edfe2725ac492fc35193a1/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea45150837990ccf40edfe2725ac492fc35193a1/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=ea45150837990ccf40edfe2725ac492fc35193a1", "patch": "@@ -1,5 +1,5 @@\n-use crate::index::Index;\n use crate::schema::*;\n+use crate::table::{FixedSizeEncoding, PerDefTable};\n \n use rustc::middle::cstore::{LinkagePreference, NativeLibrary,\n                             EncodedMetadata, ForeignModule};\n@@ -15,19 +15,20 @@ use rustc::middle::exported_symbols::{ExportedSymbol, SymbolExportLevel,\n use rustc::middle::lang_items;\n use rustc::mir::{self, interpret};\n use rustc::traits::specialization_graph;\n-use rustc::ty::{self, Ty, TyCtxt, ReprOptions, SymbolName};\n+use rustc::ty::{self, Ty, TyCtxt, SymbolName};\n use rustc::ty::codec::{self as ty_codec, TyEncoder};\n use rustc::ty::layout::VariantIdx;\n \n use rustc::session::config::{self, CrateType};\n use rustc::util::nodemap::FxHashMap;\n \n use rustc_data_structures::stable_hasher::StableHasher;\n+use rustc_data_structures::sync::Lrc;\n use rustc_serialize::{Encodable, Encoder, SpecializedEncoder, opaque};\n \n use std::hash::Hash;\n+use std::num::NonZeroUsize;\n use std::path::Path;\n-use rustc_data_structures::sync::Lrc;\n use std::u32;\n use syntax::ast;\n use syntax::attr;\n@@ -46,7 +47,7 @@ struct EncodeContext<'tcx> {\n     opaque: opaque::Encoder,\n     tcx: TyCtxt<'tcx>,\n \n-    entries_index: Index<'tcx>,\n+    per_def: PerDefTables<'tcx>,\n \n     lazy_state: LazyState,\n     type_shorthands: FxHashMap<Ty<'tcx>, usize>,\n@@ -59,6 +60,27 @@ struct EncodeContext<'tcx> {\n     source_file_cache: Lrc<SourceFile>,\n }\n \n+#[derive(Default)]\n+struct PerDefTables<'tcx> {\n+    kind: PerDefTable<Lazy<EntryKind<'tcx>>>,\n+    visibility: PerDefTable<Lazy<ty::Visibility>>,\n+    span: PerDefTable<Lazy<Span>>,\n+    attributes: PerDefTable<Lazy<[ast::Attribute]>>,\n+    children: PerDefTable<Lazy<[DefIndex]>>,\n+    stability: PerDefTable<Lazy<attr::Stability>>,\n+    deprecation: PerDefTable<Lazy<attr::Deprecation>>,\n+\n+    ty: PerDefTable<Lazy<Ty<'tcx>>>,\n+    inherent_impls: PerDefTable<Lazy<[DefIndex]>>,\n+    variances: PerDefTable<Lazy<[ty::Variance]>>,\n+    generics: PerDefTable<Lazy<ty::Generics>>,\n+    predicates: PerDefTable<Lazy<ty::GenericPredicates<'tcx>>>,\n+    predicates_defined_on: PerDefTable<Lazy<ty::GenericPredicates<'tcx>>>,\n+\n+    mir: PerDefTable<Lazy<mir::Body<'tcx>>>,\n+    promoted_mir: PerDefTable<Lazy<IndexVec<mir::Promoted, mir::Body<'tcx>>>>,\n+}\n+\n macro_rules! encoder_methods {\n     ($($name:ident($ty:ty);)*) => {\n         $(fn $name(&mut self, value: $ty) -> Result<(), Self::Error> {\n@@ -97,13 +119,13 @@ impl<'tcx> Encoder for EncodeContext<'tcx> {\n     }\n }\n \n-impl<'tcx, T> SpecializedEncoder<Lazy<T>> for EncodeContext<'tcx> {\n+impl<'tcx, T: Encodable> SpecializedEncoder<Lazy<T>> for EncodeContext<'tcx> {\n     fn specialized_encode(&mut self, lazy: &Lazy<T>) -> Result<(), Self::Error> {\n         self.emit_lazy_distance(*lazy)\n     }\n }\n \n-impl<'tcx, T> SpecializedEncoder<Lazy<[T]>> for EncodeContext<'tcx> {\n+impl<'tcx, T: Encodable> SpecializedEncoder<Lazy<[T]>> for EncodeContext<'tcx> {\n     fn specialized_encode(&mut self, lazy: &Lazy<[T]>) -> Result<(), Self::Error> {\n         self.emit_usize(lazy.meta)?;\n         if lazy.meta == 0 {\n@@ -113,6 +135,15 @@ impl<'tcx, T> SpecializedEncoder<Lazy<[T]>> for EncodeContext<'tcx> {\n     }\n }\n \n+impl<'tcx, T> SpecializedEncoder<Lazy<PerDefTable<T>>> for EncodeContext<'tcx>\n+    where Option<T>: FixedSizeEncoding,\n+{\n+    fn specialized_encode(&mut self, lazy: &Lazy<PerDefTable<T>>) -> Result<(), Self::Error> {\n+        self.emit_usize(lazy.meta)?;\n+        self.emit_lazy_distance(*lazy)\n+    }\n+}\n+\n impl<'tcx> SpecializedEncoder<CrateNum> for EncodeContext<'tcx> {\n     #[inline]\n     fn specialized_encode(&mut self, cnum: &CrateNum) -> Result<(), Self::Error> {\n@@ -257,7 +288,7 @@ impl<T: Encodable> EncodeContentsForLazy<T> for T {\n     }\n }\n \n-impl<I, T> EncodeContentsForLazy<[T]> for I\n+impl<I, T: Encodable> EncodeContentsForLazy<[T]> for I\n     where I: IntoIterator,\n           I::Item: EncodeContentsForLazy<T>,\n {\n@@ -266,15 +297,28 @@ impl<I, T> EncodeContentsForLazy<[T]> for I\n     }\n }\n \n+// Shorthand for `$self.$tables.$table.set($key, $self.lazy($value))`, which would\n+// normally need extra variables to avoid errors about multiple mutable borrows.\n+macro_rules! record {\n+    ($self:ident.$tables:ident.$table:ident[$key:expr] <- $value:expr) => {{\n+        {\n+            let value = $value;\n+            let lazy = $self.lazy(value);\n+            $self.$tables.$table.set($key, lazy);\n+        }\n+    }}\n+}\n+\n impl<'tcx> EncodeContext<'tcx> {\n     fn emit_lazy_distance<T: ?Sized + LazyMeta>(\n         &mut self,\n         lazy: Lazy<T>,\n     ) -> Result<(), <Self as Encoder>::Error> {\n-        let min_end = lazy.position + T::min_size(lazy.meta);\n+        let min_end = lazy.position.get() + T::min_size(lazy.meta);\n         let distance = match self.lazy_state {\n             LazyState::NoNode => bug!(\"emit_lazy_distance: outside of a metadata node\"),\n             LazyState::NodeStart(start) => {\n+                let start = start.get();\n                 assert!(min_end <= start);\n                 start - min_end\n             }\n@@ -284,54 +328,33 @@ impl<'tcx> EncodeContext<'tcx> {\n                     \"make sure that the calls to `lazy*` \\\n                     are in the same order as the metadata fields\",\n                 );\n-                lazy.position - last_min_end\n+                lazy.position.get() - last_min_end.get()\n             }\n         };\n-        self.lazy_state = LazyState::Previous(min_end);\n+        self.lazy_state = LazyState::Previous(NonZeroUsize::new(min_end).unwrap());\n         self.emit_usize(distance)\n     }\n \n     fn lazy<T: ?Sized + LazyMeta>(\n         &mut self,\n         value: impl EncodeContentsForLazy<T>,\n     ) -> Lazy<T> {\n-        let pos = self.position();\n+        let pos = NonZeroUsize::new(self.position()).unwrap();\n \n         assert_eq!(self.lazy_state, LazyState::NoNode);\n         self.lazy_state = LazyState::NodeStart(pos);\n         let meta = value.encode_contents_for_lazy(self);\n         self.lazy_state = LazyState::NoNode;\n \n-        assert!(pos + <T>::min_size(meta) <= self.position());\n+        assert!(pos.get() + <T>::min_size(meta) <= self.position());\n \n         Lazy::from_position_and_meta(pos, meta)\n     }\n \n-    /// Emit the data for a `DefId` to the metadata. The function to\n-    /// emit the data is `op`, and it will be given `data` as\n-    /// arguments. This `record` function will call `op` to generate\n-    /// the `Entry` (which may point to other encoded information)\n-    /// and will then record the `Lazy<Entry>` for use in the index.\n-    // FIXME(eddyb) remove this.\n-    fn record<DATA>(\n-        &mut self,\n-        id: DefId,\n-        op: impl FnOnce(&mut Self, DATA) -> Entry<'tcx>,\n-        data: DATA,\n-    ) {\n-        assert!(id.is_local());\n-\n-        let entry = op(self, data);\n-        let entry = self.lazy(entry);\n-        self.entries_index.record(id, entry);\n-    }\n-\n     fn encode_info_for_items(&mut self) {\n         let krate = self.tcx.hir().krate();\n         let vis = Spanned { span: syntax_pos::DUMMY_SP, node: hir::VisibilityKind::Public };\n-        self.record(DefId::local(CRATE_DEF_INDEX),\n-                     EncodeContext::encode_info_for_mod,\n-                     (hir::CRATE_HIR_ID, &krate.module, &krate.attrs, &vis));\n+        self.encode_info_for_mod(hir::CRATE_HIR_ID, &krate.module, &krate.attrs, &vis);\n         krate.visit_all_item_likes(&mut self.as_deep_visitor());\n         for macro_def in &krate.exported_macros {\n             self.visit_macro_def(macro_def);\n@@ -475,8 +498,26 @@ impl<'tcx> EncodeContext<'tcx> {\n \n \n         i = self.position();\n-        let entries_index = self.entries_index.write_index(&mut self.opaque);\n-        let entries_index_bytes = self.position() - i;\n+        let per_def = LazyPerDefTables {\n+            kind: self.per_def.kind.encode(&mut self.opaque),\n+            visibility: self.per_def.visibility.encode(&mut self.opaque),\n+            span: self.per_def.span.encode(&mut self.opaque),\n+            attributes: self.per_def.attributes.encode(&mut self.opaque),\n+            children: self.per_def.children.encode(&mut self.opaque),\n+            stability: self.per_def.stability.encode(&mut self.opaque),\n+            deprecation: self.per_def.deprecation.encode(&mut self.opaque),\n+\n+            ty: self.per_def.ty.encode(&mut self.opaque),\n+            inherent_impls: self.per_def.inherent_impls.encode(&mut self.opaque),\n+            variances: self.per_def.variances.encode(&mut self.opaque),\n+            generics: self.per_def.generics.encode(&mut self.opaque),\n+            predicates: self.per_def.predicates.encode(&mut self.opaque),\n+            predicates_defined_on: self.per_def.predicates_defined_on.encode(&mut self.opaque),\n+\n+            mir: self.per_def.mir.encode(&mut self.opaque),\n+            promoted_mir: self.per_def.promoted_mir.encode(&mut self.opaque),\n+        };\n+        let per_def_bytes = self.position() - i;\n \n         // Encode the proc macro data\n         i = self.position();\n@@ -535,7 +576,7 @@ impl<'tcx> EncodeContext<'tcx> {\n             impls,\n             exported_symbols,\n             interpret_alloc_index,\n-            entries_index,\n+            per_def,\n         });\n \n         let total_bytes = self.position();\n@@ -560,7 +601,7 @@ impl<'tcx> EncodeContext<'tcx> {\n             println!(\"  def-path table bytes: {}\", def_path_table_bytes);\n             println!(\" proc-macro-data-bytes: {}\", proc_macro_data_bytes);\n             println!(\"            item bytes: {}\", item_bytes);\n-            println!(\"   entries index bytes: {}\", entries_index_bytes);\n+            println!(\"   per-def table bytes: {}\", per_def_bytes);\n             println!(\"            zero bytes: {}\", zero_bytes);\n             println!(\"           total bytes: {}\", total_bytes);\n         }\n@@ -570,23 +611,21 @@ impl<'tcx> EncodeContext<'tcx> {\n }\n \n impl EncodeContext<'tcx> {\n-    fn encode_variances_of(&mut self, def_id: DefId) -> Lazy<[ty::Variance]> {\n+    fn encode_variances_of(&mut self, def_id: DefId) {\n         debug!(\"EncodeContext::encode_variances_of({:?})\", def_id);\n-        let tcx = self.tcx;\n-        self.lazy(&tcx.variances_of(def_id)[..])\n+        record!(self.per_def.variances[def_id] <- &self.tcx.variances_of(def_id)[..]);\n     }\n \n-    fn encode_item_type(&mut self, def_id: DefId) -> Lazy<Ty<'tcx>> {\n-        let tcx = self.tcx;\n-        let ty = tcx.type_of(def_id);\n-        debug!(\"EncodeContext::encode_item_type({:?}) => {:?}\", def_id, ty);\n-        self.lazy(ty)\n+    fn encode_item_type(&mut self, def_id: DefId) {\n+        debug!(\"EncodeContext::encode_item_type({:?})\", def_id);\n+        record!(self.per_def.ty[def_id] <- self.tcx.type_of(def_id));\n     }\n \n     fn encode_enum_variant_info(\n         &mut self,\n-        (enum_did, index): (DefId, VariantIdx),\n-    ) -> Entry<'tcx> {\n+        enum_did: DefId,\n+        index: VariantIdx,\n+    ) {\n         let tcx = self.tcx;\n         let def = tcx.adt_def(enum_did);\n         let variant = &def.variants[index];\n@@ -608,38 +647,32 @@ impl EncodeContext<'tcx> {\n         let enum_id = tcx.hir().as_local_hir_id(enum_did).unwrap();\n         let enum_vis = &tcx.hir().expect_item(enum_id).vis;\n \n-        Entry {\n-            kind: EntryKind::Variant(self.lazy(data)),\n-            visibility: self.lazy(ty::Visibility::from_hir(enum_vis, enum_id, tcx)),\n-            span: self.lazy(tcx.def_span(def_id)),\n-            attributes: self.encode_attributes(&tcx.get_attrs(def_id)),\n-            children: self.lazy(variant.fields.iter().map(|f| {\n-                assert!(f.did.is_local());\n-                f.did.index\n-            })),\n-            stability: self.encode_stability(def_id),\n-            deprecation: self.encode_deprecation(def_id),\n-\n-            ty: Some(self.encode_item_type(def_id)),\n-            inherent_impls: Lazy::empty(),\n-            variances: if variant.ctor_kind == CtorKind::Fn {\n-                self.encode_variances_of(def_id)\n-            } else {\n-                Lazy::empty()\n-            },\n-            generics: Some(self.encode_generics(def_id)),\n-            predicates: Some(self.encode_predicates(def_id)),\n-            predicates_defined_on: None,\n-\n-            mir: self.encode_optimized_mir(def_id),\n-            promoted_mir: self.encode_promoted_mir(def_id),\n+        record!(self.per_def.kind[def_id] <- EntryKind::Variant(self.lazy(data)));\n+        record!(self.per_def.visibility[def_id] <-\n+            ty::Visibility::from_hir(enum_vis, enum_id, self.tcx));\n+        record!(self.per_def.span[def_id] <- self.tcx.def_span(def_id));\n+        record!(self.per_def.attributes[def_id] <- &self.tcx.get_attrs(def_id)[..]);\n+        record!(self.per_def.children[def_id] <- variant.fields.iter().map(|f| {\n+            assert!(f.did.is_local());\n+            f.did.index\n+        }));\n+        self.encode_stability(def_id);\n+        self.encode_deprecation(def_id);\n+        self.encode_item_type(def_id);\n+        if variant.ctor_kind == CtorKind::Fn {\n+            self.encode_variances_of(def_id);\n         }\n+        self.encode_generics(def_id);\n+        self.encode_predicates(def_id);\n+        self.encode_optimized_mir(def_id);\n+        self.encode_promoted_mir(def_id);\n     }\n \n     fn encode_enum_variant_ctor(\n         &mut self,\n-        (enum_did, index): (DefId, VariantIdx),\n-    ) -> Entry<'tcx> {\n+        enum_did: DefId,\n+        index: VariantIdx,\n+    ) {\n         let tcx = self.tcx;\n         let def = tcx.adt_def(enum_did);\n         let variant = &def.variants[index];\n@@ -666,35 +699,28 @@ impl EncodeContext<'tcx> {\n             ctor_vis = ty::Visibility::Restricted(DefId::local(CRATE_DEF_INDEX));\n         }\n \n-        Entry {\n-            kind: EntryKind::Variant(self.lazy(data)),\n-            visibility: self.lazy(ctor_vis),\n-            span: self.lazy(tcx.def_span(def_id)),\n-            attributes: Lazy::empty(),\n-            children: Lazy::empty(),\n-            stability: self.encode_stability(def_id),\n-            deprecation: self.encode_deprecation(def_id),\n-\n-            ty: Some(self.encode_item_type(def_id)),\n-            inherent_impls: Lazy::empty(),\n-            variances: if variant.ctor_kind == CtorKind::Fn {\n-                self.encode_variances_of(def_id)\n-            } else {\n-                Lazy::empty()\n-            },\n-            generics: Some(self.encode_generics(def_id)),\n-            predicates: Some(self.encode_predicates(def_id)),\n-            predicates_defined_on: None,\n-\n-            mir: self.encode_optimized_mir(def_id),\n-            promoted_mir: self.encode_promoted_mir(def_id),\n+        record!(self.per_def.kind[def_id] <- EntryKind::Variant(self.lazy(data)));\n+        record!(self.per_def.visibility[def_id] <- ctor_vis);\n+        record!(self.per_def.span[def_id] <- self.tcx.def_span(def_id));\n+        self.encode_stability(def_id);\n+        self.encode_deprecation(def_id);\n+        self.encode_item_type(def_id);\n+        if variant.ctor_kind == CtorKind::Fn {\n+            self.encode_variances_of(def_id);\n         }\n+        self.encode_generics(def_id);\n+        self.encode_predicates(def_id);\n+        self.encode_optimized_mir(def_id);\n+        self.encode_promoted_mir(def_id);\n     }\n \n     fn encode_info_for_mod(\n         &mut self,\n-        (id, md, attrs, vis): (hir::HirId, &hir::Mod, &[ast::Attribute], &hir::Visibility),\n-    ) -> Entry<'tcx> {\n+        id: hir::HirId,\n+        md: &hir::Mod,\n+        attrs: &[ast::Attribute],\n+        vis: &hir::Visibility,\n+    ) {\n         let tcx = self.tcx;\n         let def_id = tcx.hir().local_def_id(id);\n         debug!(\"EncodeContext::encode_info_for_mod({:?})\", def_id);\n@@ -706,33 +732,23 @@ impl EncodeContext<'tcx> {\n             },\n         };\n \n-        Entry {\n-            kind: EntryKind::Mod(self.lazy(data)),\n-            visibility: self.lazy(ty::Visibility::from_hir(vis, id, tcx)),\n-            span: self.lazy(tcx.def_span(def_id)),\n-            attributes: self.encode_attributes(attrs),\n-            children: self.lazy(md.item_ids.iter().map(|item_id| {\n-                tcx.hir().local_def_id(item_id.id).index\n-            })),\n-            stability: self.encode_stability(def_id),\n-            deprecation: self.encode_deprecation(def_id),\n-\n-            ty: None,\n-            inherent_impls: Lazy::empty(),\n-            variances: Lazy::empty(),\n-            generics: None,\n-            predicates: None,\n-            predicates_defined_on: None,\n-\n-            mir: None,\n-            promoted_mir: None,\n-        }\n+        record!(self.per_def.kind[def_id] <- EntryKind::Mod(self.lazy(data)));\n+        record!(self.per_def.visibility[def_id] <- ty::Visibility::from_hir(vis, id, self.tcx));\n+        record!(self.per_def.span[def_id] <- self.tcx.def_span(def_id));\n+        record!(self.per_def.attributes[def_id] <- attrs);\n+        record!(self.per_def.children[def_id] <- md.item_ids.iter().map(|item_id| {\n+            tcx.hir().local_def_id(item_id.id).index\n+        }));\n+        self.encode_stability(def_id);\n+        self.encode_deprecation(def_id);\n     }\n \n     fn encode_field(\n         &mut self,\n-        (adt_def_id, variant_index, field_index): (DefId, VariantIdx, usize),\n-    ) -> Entry<'tcx> {\n+        adt_def_id: DefId,\n+        variant_index: VariantIdx,\n+        field_index: usize,\n+    ) {\n         let tcx = self.tcx;\n         let variant = &tcx.adt_def(adt_def_id).variants[variant_index];\n         let field = &variant.fields[field_index];\n@@ -743,28 +759,18 @@ impl EncodeContext<'tcx> {\n         let variant_id = tcx.hir().as_local_hir_id(variant.def_id).unwrap();\n         let variant_data = tcx.hir().expect_variant_data(variant_id);\n \n-        Entry {\n-            kind: EntryKind::Field,\n-            visibility: self.lazy(field.vis),\n-            span: self.lazy(tcx.def_span(def_id)),\n-            attributes: self.encode_attributes(&variant_data.fields()[field_index].attrs),\n-            children: Lazy::empty(),\n-            stability: self.encode_stability(def_id),\n-            deprecation: self.encode_deprecation(def_id),\n-\n-            ty: Some(self.encode_item_type(def_id)),\n-            inherent_impls: Lazy::empty(),\n-            variances: Lazy::empty(),\n-            generics: Some(self.encode_generics(def_id)),\n-            predicates: Some(self.encode_predicates(def_id)),\n-            predicates_defined_on: None,\n-\n-            mir: None,\n-            promoted_mir: None,\n-        }\n+        record!(self.per_def.kind[def_id] <- EntryKind::Field);\n+        record!(self.per_def.visibility[def_id] <- field.vis);\n+        record!(self.per_def.span[def_id] <- self.tcx.def_span(def_id));\n+        record!(self.per_def.attributes[def_id] <- &variant_data.fields()[field_index].attrs);\n+        self.encode_stability(def_id);\n+        self.encode_deprecation(def_id);\n+        self.encode_item_type(def_id);\n+        self.encode_generics(def_id);\n+        self.encode_predicates(def_id);\n     }\n \n-    fn encode_struct_ctor(&mut self, (adt_def_id, def_id): (DefId, DefId)) -> Entry<'tcx> {\n+    fn encode_struct_ctor(&mut self, adt_def_id: DefId, def_id: DefId) {\n         debug!(\"EncodeContext::encode_struct_ctor({:?})\", def_id);\n         let tcx = self.tcx;\n         let adt_def = tcx.adt_def(adt_def_id);\n@@ -798,52 +804,38 @@ impl EncodeContext<'tcx> {\n             ctor_vis = ty::Visibility::Restricted(DefId::local(CRATE_DEF_INDEX));\n         }\n \n-        let repr_options = get_repr_options(tcx, adt_def_id);\n-\n-        Entry {\n-            kind: EntryKind::Struct(self.lazy(data), repr_options),\n-            visibility: self.lazy(ctor_vis),\n-            span: self.lazy(tcx.def_span(def_id)),\n-            attributes: Lazy::empty(),\n-            children: Lazy::empty(),\n-            stability: self.encode_stability(def_id),\n-            deprecation: self.encode_deprecation(def_id),\n-\n-            ty: Some(self.encode_item_type(def_id)),\n-            inherent_impls: Lazy::empty(),\n-            variances: if variant.ctor_kind == CtorKind::Fn {\n-                self.encode_variances_of(def_id)\n-            } else {\n-                Lazy::empty()\n-            },\n-            generics: Some(self.encode_generics(def_id)),\n-            predicates: Some(self.encode_predicates(def_id)),\n-            predicates_defined_on: None,\n-\n-            mir: self.encode_optimized_mir(def_id),\n-            promoted_mir: self.encode_promoted_mir(def_id),\n+        record!(self.per_def.kind[def_id] <- EntryKind::Struct(self.lazy(data), adt_def.repr));\n+        record!(self.per_def.visibility[def_id] <- ctor_vis);\n+        record!(self.per_def.span[def_id] <- self.tcx.def_span(def_id));\n+        self.encode_stability(def_id);\n+        self.encode_deprecation(def_id);\n+        self.encode_item_type(def_id);\n+        if variant.ctor_kind == CtorKind::Fn {\n+            self.encode_variances_of(def_id);\n         }\n+        self.encode_generics(def_id);\n+        self.encode_predicates(def_id);\n+        self.encode_optimized_mir(def_id);\n+        self.encode_promoted_mir(def_id);\n     }\n \n-    fn encode_generics(&mut self, def_id: DefId) -> Lazy<ty::Generics> {\n+    fn encode_generics(&mut self, def_id: DefId) {\n         debug!(\"EncodeContext::encode_generics({:?})\", def_id);\n-        let tcx = self.tcx;\n-        self.lazy(tcx.generics_of(def_id))\n+        record!(self.per_def.generics[def_id] <- self.tcx.generics_of(def_id));\n     }\n \n-    fn encode_predicates(&mut self, def_id: DefId) -> Lazy<ty::GenericPredicates<'tcx>> {\n+    fn encode_predicates(&mut self, def_id: DefId) {\n         debug!(\"EncodeContext::encode_predicates({:?})\", def_id);\n-        let tcx = self.tcx;\n-        self.lazy(&*tcx.predicates_of(def_id))\n+        record!(self.per_def.predicates[def_id] <- &*self.tcx.predicates_of(def_id));\n     }\n \n-    fn encode_predicates_defined_on(&mut self, def_id: DefId) -> Lazy<ty::GenericPredicates<'tcx>> {\n+    fn encode_predicates_defined_on(&mut self, def_id: DefId) {\n         debug!(\"EncodeContext::encode_predicates_defined_on({:?})\", def_id);\n-        let tcx = self.tcx;\n-        self.lazy(&*tcx.predicates_defined_on(def_id))\n+        record!(self.per_def.predicates_defined_on[def_id] <-\n+            &*self.tcx.predicates_defined_on(def_id))\n     }\n \n-    fn encode_info_for_trait_item(&mut self, def_id: DefId) -> Entry<'tcx> {\n+    fn encode_info_for_trait_item(&mut self, def_id: DefId) {\n         debug!(\"EncodeContext::encode_info_for_trait_item({:?})\", def_id);\n         let tcx = self.tcx;\n \n@@ -860,7 +852,7 @@ impl EncodeContext<'tcx> {\n                 span_bug!(ast_item.span, \"traits cannot have final items\"),\n         };\n \n-        let kind = match trait_item.kind {\n+        record!(self.per_def.kind[def_id] <- match trait_item.kind {\n             ty::AssocKind::Const => {\n                 let rendered =\n                     hir::print::to_string(self.tcx.hir(), |s| s.print_trait_item(ast_item));\n@@ -869,7 +861,7 @@ impl EncodeContext<'tcx> {\n                 EntryKind::AssocConst(container, ConstQualif { mir: 0 }, rendered_const)\n             }\n             ty::AssocKind::Method => {\n-                let fn_data = if let hir::TraitItemKind::Method(method_sig, m) = &ast_item.kind {\n+                let fn_data = if let hir::TraitItemKind::Method(m_sig, m) = &ast_item.kind {\n                     let param_names = match *m {\n                         hir::TraitMethod::Required(ref names) => {\n                             self.encode_fn_param_names(names)\n@@ -879,10 +871,10 @@ impl EncodeContext<'tcx> {\n                         }\n                     };\n                     FnData {\n-                        asyncness: method_sig.header.asyncness,\n+                        asyncness: m_sig.header.asyncness,\n                         constness: hir::Constness::NotConst,\n                         param_names,\n-                        sig: self.lazy(&tcx.fn_sig(def_id)),\n+                        sig: self.lazy(tcx.fn_sig(def_id)),\n                     }\n                 } else {\n                     bug!()\n@@ -895,52 +887,39 @@ impl EncodeContext<'tcx> {\n             }\n             ty::AssocKind::Type => EntryKind::AssocType(container),\n             ty::AssocKind::OpaqueTy => span_bug!(ast_item.span, \"opaque type in trait\"),\n-        };\n-\n-        Entry {\n-            kind,\n-            visibility: self.lazy(trait_item.vis),\n-            span: self.lazy(ast_item.span),\n-            attributes: self.encode_attributes(&ast_item.attrs),\n-            children: Lazy::empty(),\n-            stability: self.encode_stability(def_id),\n-            deprecation: self.encode_deprecation(def_id),\n-\n-            ty: match trait_item.kind {\n-                ty::AssocKind::Const |\n-                ty::AssocKind::Method => {\n-                    Some(self.encode_item_type(def_id))\n-                }\n-                ty::AssocKind::Type => {\n-                    if trait_item.defaultness.has_value() {\n-                        Some(self.encode_item_type(def_id))\n-                    } else {\n-                        None\n-                    }\n+        });\n+        record!(self.per_def.visibility[def_id] <- trait_item.vis);\n+        record!(self.per_def.span[def_id] <- ast_item.span);\n+        record!(self.per_def.attributes[def_id] <- &ast_item.attrs);\n+        self.encode_stability(def_id);\n+        self.encode_deprecation(def_id);\n+        match trait_item.kind {\n+            ty::AssocKind::Const |\n+            ty::AssocKind::Method => {\n+                self.encode_item_type(def_id);\n+            }\n+            ty::AssocKind::Type => {\n+                if trait_item.defaultness.has_value() {\n+                    self.encode_item_type(def_id);\n                 }\n-                ty::AssocKind::OpaqueTy => unreachable!(),\n-            },\n-            inherent_impls: Lazy::empty(),\n-            variances: if trait_item.kind == ty::AssocKind::Method {\n-                self.encode_variances_of(def_id)\n-            } else {\n-                Lazy::empty()\n-            },\n-            generics: Some(self.encode_generics(def_id)),\n-            predicates: Some(self.encode_predicates(def_id)),\n-            predicates_defined_on: None,\n-\n-            mir: self.encode_optimized_mir(def_id),\n-            promoted_mir: self.encode_promoted_mir(def_id),\n+            }\n+            ty::AssocKind::OpaqueTy => unreachable!(),\n+        }\n+        if trait_item.kind == ty::AssocKind::Method {\n+            self.encode_variances_of(def_id);\n         }\n+        self.encode_generics(def_id);\n+        self.encode_predicates(def_id);\n+        self.encode_optimized_mir(def_id);\n+        self.encode_promoted_mir(def_id);\n     }\n \n     fn metadata_output_only(&self) -> bool {\n         // MIR optimisation can be skipped when we're just interested in the metadata.\n         !self.tcx.sess.opts.output_types.should_codegen()\n     }\n \n-    fn encode_info_for_impl_item(&mut self, def_id: DefId) -> Entry<'tcx> {\n+    fn encode_info_for_impl_item(&mut self, def_id: DefId) {\n         debug!(\"EncodeContext::encode_info_for_impl_item({:?})\", def_id);\n         let tcx = self.tcx;\n \n@@ -955,7 +934,7 @@ impl EncodeContext<'tcx> {\n                 span_bug!(ast_item.span, \"impl items always have values (currently)\"),\n         };\n \n-        let kind = match impl_item.kind {\n+        record!(self.per_def.kind[def_id] <- match impl_item.kind {\n             ty::AssocKind::Const => {\n                 if let hir::ImplItemKind::Const(_, body_id) = ast_item.kind {\n                     let mir = self.tcx.at(ast_item.span).mir_const_qualif(def_id).0;\n@@ -973,7 +952,7 @@ impl EncodeContext<'tcx> {\n                         asyncness: sig.header.asyncness,\n                         constness: sig.header.constness,\n                         param_names: self.encode_fn_param_names_for_body(body),\n-                        sig: self.lazy(&tcx.fn_sig(def_id)),\n+                        sig: self.lazy(tcx.fn_sig(def_id)),\n                     }\n                 } else {\n                     bug!()\n@@ -986,8 +965,18 @@ impl EncodeContext<'tcx> {\n             }\n             ty::AssocKind::OpaqueTy => EntryKind::AssocOpaqueTy(container),\n             ty::AssocKind::Type => EntryKind::AssocType(container)\n-        };\n-\n+        });\n+        record!(self.per_def.visibility[def_id] <- impl_item.vis);\n+        record!(self.per_def.span[def_id] <- ast_item.span);\n+        record!(self.per_def.attributes[def_id] <- &ast_item.attrs);\n+        self.encode_stability(def_id);\n+        self.encode_deprecation(def_id);\n+        self.encode_item_type(def_id);\n+        if impl_item.kind == ty::AssocKind::Method {\n+            self.encode_variances_of(def_id);\n+        }\n+        self.encode_generics(def_id);\n+        self.encode_predicates(def_id);\n         let mir = match ast_item.kind {\n             hir::ImplItemKind::Const(..) => true,\n             hir::ImplItemKind::Method(ref sig, _) => {\n@@ -1002,29 +991,9 @@ impl EncodeContext<'tcx> {\n             hir::ImplItemKind::OpaqueTy(..) |\n             hir::ImplItemKind::TyAlias(..) => false,\n         };\n-\n-        Entry {\n-            kind,\n-            visibility: self.lazy(impl_item.vis),\n-            span: self.lazy(ast_item.span),\n-            attributes: self.encode_attributes(&ast_item.attrs),\n-            children: Lazy::empty(),\n-            stability: self.encode_stability(def_id),\n-            deprecation: self.encode_deprecation(def_id),\n-\n-            ty: Some(self.encode_item_type(def_id)),\n-            inherent_impls: Lazy::empty(),\n-            variances: if impl_item.kind == ty::AssocKind::Method {\n-                self.encode_variances_of(def_id)\n-            } else {\n-                Lazy::empty()\n-            },\n-            generics: Some(self.encode_generics(def_id)),\n-            predicates: Some(self.encode_predicates(def_id)),\n-            predicates_defined_on: None,\n-\n-            mir: if mir { self.encode_optimized_mir(def_id) } else { None },\n-            promoted_mir: if mir { self.encode_promoted_mir(def_id) } else { None },\n+        if mir {\n+            self.encode_optimized_mir(def_id);\n+            self.encode_promoted_mir(def_id);\n         }\n     }\n \n@@ -1045,51 +1014,44 @@ impl EncodeContext<'tcx> {\n         self.lazy(param_names.iter().map(|ident| ident.name))\n     }\n \n-    fn encode_optimized_mir(&mut self, def_id: DefId) -> Option<Lazy<mir::Body<'tcx>>> {\n+    fn encode_optimized_mir(&mut self, def_id: DefId) {\n         debug!(\"EntryBuilder::encode_mir({:?})\", def_id);\n         if self.tcx.mir_keys(LOCAL_CRATE).contains(&def_id) {\n-            let mir = self.tcx.optimized_mir(def_id);\n-            Some(self.lazy(mir))\n-        } else {\n-            None\n+            record!(self.per_def.mir[def_id] <- self.tcx.optimized_mir(def_id));\n         }\n     }\n \n-    fn encode_promoted_mir(\n-        &mut self,\n-        def_id: DefId,\n-    ) -> Option<Lazy<IndexVec<mir::Promoted, mir::Body<'tcx>>>> {\n+    fn encode_promoted_mir(&mut self, def_id: DefId) {\n         debug!(\"EncodeContext::encode_promoted_mir({:?})\", def_id);\n         if self.tcx.mir_keys(LOCAL_CRATE).contains(&def_id) {\n-            let promoted = self.tcx.promoted_mir(def_id);\n-            Some(self.lazy(promoted))\n-        } else {\n-            None\n+            record!(self.per_def.promoted_mir[def_id] <- self.tcx.promoted_mir(def_id));\n         }\n     }\n \n     // Encodes the inherent implementations of a structure, enumeration, or trait.\n-    fn encode_inherent_implementations(&mut self, def_id: DefId) -> Lazy<[DefIndex]> {\n+    fn encode_inherent_implementations(&mut self, def_id: DefId) {\n         debug!(\"EncodeContext::encode_inherent_implementations({:?})\", def_id);\n         let implementations = self.tcx.inherent_impls(def_id);\n-        if implementations.is_empty() {\n-            Lazy::empty()\n-        } else {\n-            self.lazy(implementations.iter().map(|&def_id| {\n+        if !implementations.is_empty() {\n+            record!(self.per_def.inherent_impls[def_id] <- implementations.iter().map(|&def_id| {\n                 assert!(def_id.is_local());\n                 def_id.index\n-            }))\n+            }));\n         }\n     }\n \n-    fn encode_stability(&mut self, def_id: DefId) -> Option<Lazy<attr::Stability>> {\n+    fn encode_stability(&mut self, def_id: DefId) {\n         debug!(\"EncodeContext::encode_stability({:?})\", def_id);\n-        self.tcx.lookup_stability(def_id).map(|stab| self.lazy(stab))\n+        if let Some(stab) = self.tcx.lookup_stability(def_id) {\n+            record!(self.per_def.stability[def_id] <- stab)\n+        }\n     }\n \n-    fn encode_deprecation(&mut self, def_id: DefId) -> Option<Lazy<attr::Deprecation>> {\n+    fn encode_deprecation(&mut self, def_id: DefId) {\n         debug!(\"EncodeContext::encode_deprecation({:?})\", def_id);\n-        self.tcx.lookup_deprecation(def_id).map(|depr| self.lazy(depr))\n+        if let Some(depr) = self.tcx.lookup_deprecation(def_id) {\n+            record!(self.per_def.deprecation[def_id] <- depr);\n+        }\n     }\n \n     fn encode_rendered_const_for_body(&mut self, body_id: hir::BodyId) -> Lazy<RenderedConst> {\n@@ -1099,16 +1061,16 @@ impl EncodeContext<'tcx> {\n         self.lazy(rendered_const)\n     }\n \n-    fn encode_info_for_item(&mut self, (def_id, item): (DefId, &'tcx hir::Item)) -> Entry<'tcx> {\n+    fn encode_info_for_item(&mut self, def_id: DefId, item: &'tcx hir::Item) {\n         let tcx = self.tcx;\n \n         debug!(\"EncodeContext::encode_info_for_item({:?})\", def_id);\n \n-        let kind = match item.kind {\n+        record!(self.per_def.kind[def_id] <- match item.kind {\n             hir::ItemKind::Static(_, hir::MutMutable, _) => EntryKind::MutStatic,\n             hir::ItemKind::Static(_, hir::MutImmutable, _) => EntryKind::ImmStatic,\n             hir::ItemKind::Const(_, body_id) => {\n-                let mir = tcx.at(item.span).mir_const_qualif(def_id).0;\n+                let mir = self.tcx.at(item.span).mir_const_qualif(def_id).0;\n                 EntryKind::Const(\n                     ConstQualif { mir },\n                     self.encode_rendered_const_for_body(body_id)\n@@ -1125,48 +1087,48 @@ impl EncodeContext<'tcx> {\n                 EntryKind::Fn(self.lazy(data))\n             }\n             hir::ItemKind::Mod(ref m) => {\n-                return self.encode_info_for_mod((item.hir_id, m, &item.attrs, &item.vis));\n+                return self.encode_info_for_mod(item.hir_id, m, &item.attrs, &item.vis);\n             }\n             hir::ItemKind::ForeignMod(_) => EntryKind::ForeignMod,\n             hir::ItemKind::GlobalAsm(..) => EntryKind::GlobalAsm,\n             hir::ItemKind::TyAlias(..) => EntryKind::Type,\n             hir::ItemKind::OpaqueTy(..) => EntryKind::OpaqueTy,\n-            hir::ItemKind::Enum(..) => EntryKind::Enum(get_repr_options(tcx, def_id)),\n+            hir::ItemKind::Enum(..) => EntryKind::Enum(self.tcx.adt_def(def_id).repr),\n             hir::ItemKind::Struct(ref struct_def, _) => {\n-                let variant = tcx.adt_def(def_id).non_enum_variant();\n+                let adt_def = self.tcx.adt_def(def_id);\n+                let variant = adt_def.non_enum_variant();\n \n                 // Encode def_ids for each field and method\n                 // for methods, write all the stuff get_trait_method\n                 // needs to know\n-                let ctor = struct_def.ctor_hir_id()\n-                    .map(|ctor_hir_id| tcx.hir().local_def_id(ctor_hir_id).index);\n-\n-                let repr_options = get_repr_options(tcx, def_id);\n+                let ctor = struct_def.ctor_hir_id().map(|ctor_hir_id| {\n+                    self.tcx.hir().local_def_id(ctor_hir_id).index\n+                });\n \n                 EntryKind::Struct(self.lazy(VariantData {\n                     ctor_kind: variant.ctor_kind,\n                     discr: variant.discr,\n                     ctor,\n                     ctor_sig: None,\n-                }), repr_options)\n+                }), adt_def.repr)\n             }\n             hir::ItemKind::Union(..) => {\n-                let variant = tcx.adt_def(def_id).non_enum_variant();\n-                let repr_options = get_repr_options(tcx, def_id);\n+                let adt_def = self.tcx.adt_def(def_id);\n+                let variant = adt_def.non_enum_variant();\n \n                 EntryKind::Union(self.lazy(VariantData {\n                     ctor_kind: variant.ctor_kind,\n                     discr: variant.discr,\n                     ctor: None,\n                     ctor_sig: None,\n-                }), repr_options)\n+                }), adt_def.repr)\n             }\n             hir::ItemKind::Impl(_, _, defaultness, ..) => {\n-                let trait_ref = tcx.impl_trait_ref(def_id);\n-                let polarity = tcx.impl_polarity(def_id);\n+                let trait_ref = self.tcx.impl_trait_ref(def_id);\n+                let polarity = self.tcx.impl_polarity(def_id);\n                 let parent = if let Some(trait_ref) = trait_ref {\n-                    let trait_def = tcx.trait_def(trait_ref.def_id);\n-                    trait_def.ancestors(tcx, def_id).nth(1).and_then(|node| {\n+                    let trait_def = self.tcx.trait_def(trait_ref.def_id);\n+                    trait_def.ancestors(self.tcx, def_id).nth(1).and_then(|node| {\n                         match node {\n                             specialization_graph::Node::Impl(parent) => Some(parent),\n                             _ => None,\n@@ -1180,8 +1142,8 @@ impl EncodeContext<'tcx> {\n                 // \"unsized info\", else just store None\n                 let coerce_unsized_info =\n                     trait_ref.and_then(|t| {\n-                        if Some(t.def_id) == tcx.lang_items().coerce_unsized_trait() {\n-                            Some(tcx.at(item.span).coerce_unsized_info(def_id))\n+                        if Some(t.def_id) == self.tcx.lang_items().coerce_unsized_trait() {\n+                            Some(self.tcx.at(item.span).coerce_unsized_info(def_id))\n                         } else {\n                             None\n                         }\n@@ -1198,11 +1160,11 @@ impl EncodeContext<'tcx> {\n                 EntryKind::Impl(self.lazy(data))\n             }\n             hir::ItemKind::Trait(..) => {\n-                let trait_def = tcx.trait_def(def_id);\n+                let trait_def = self.tcx.trait_def(def_id);\n                 let data = TraitData {\n                     unsafety: trait_def.unsafety,\n                     paren_sugar: trait_def.paren_sugar,\n-                    has_auto_impl: tcx.trait_is_auto(def_id),\n+                    has_auto_impl: self.tcx.trait_is_auto(def_id),\n                     is_marker: trait_def.is_marker,\n                     super_predicates: self.lazy(&*tcx.super_predicates_of(def_id)),\n                 };\n@@ -1218,7 +1180,95 @@ impl EncodeContext<'tcx> {\n             }\n             hir::ItemKind::ExternCrate(_) |\n             hir::ItemKind::Use(..) => bug!(\"cannot encode info for item {:?}\", item),\n-        };\n+        });\n+        record!(self.per_def.visibility[def_id] <-\n+            ty::Visibility::from_hir(&item.vis, item.hir_id, tcx));\n+        record!(self.per_def.span[def_id] <- item.span);\n+        record!(self.per_def.attributes[def_id] <- &item.attrs);\n+        // FIXME(eddyb) there should be a nicer way to do this.\n+        match item.kind {\n+            hir::ItemKind::ForeignMod(ref fm) => record!(self.per_def.children[def_id] <-\n+                fm.items\n+                    .iter()\n+                    .map(|foreign_item| tcx.hir().local_def_id(\n+                        foreign_item.hir_id).index)\n+            ),\n+            hir::ItemKind::Enum(..) => record!(self.per_def.children[def_id] <-\n+                self.tcx.adt_def(def_id).variants.iter().map(|v| {\n+                    assert!(v.def_id.is_local());\n+                    v.def_id.index\n+                })\n+            ),\n+            hir::ItemKind::Struct(..) |\n+            hir::ItemKind::Union(..) => record!(self.per_def.children[def_id] <-\n+                self.tcx.adt_def(def_id).non_enum_variant().fields.iter().map(|f| {\n+                    assert!(f.did.is_local());\n+                    f.did.index\n+                })\n+            ),\n+            hir::ItemKind::Impl(..) |\n+            hir::ItemKind::Trait(..) => {\n+                let associated_item_def_ids = self.tcx.associated_item_def_ids(def_id);\n+                record!(self.per_def.children[def_id] <-\n+                    associated_item_def_ids.iter().map(|&def_id| {\n+                        assert!(def_id.is_local());\n+                        def_id.index\n+                    })\n+                );\n+            }\n+            _ => {}\n+        }\n+        self.encode_stability(def_id);\n+        self.encode_deprecation(def_id);\n+        match item.kind {\n+            hir::ItemKind::Static(..) |\n+            hir::ItemKind::Const(..) |\n+            hir::ItemKind::Fn(..) |\n+            hir::ItemKind::TyAlias(..) |\n+            hir::ItemKind::OpaqueTy(..) |\n+            hir::ItemKind::Enum(..) |\n+            hir::ItemKind::Struct(..) |\n+            hir::ItemKind::Union(..) |\n+            hir::ItemKind::Impl(..) => self.encode_item_type(def_id),\n+            _ => {}\n+        }\n+        self.encode_inherent_implementations(def_id);\n+        match item.kind {\n+            hir::ItemKind::Enum(..) |\n+            hir::ItemKind::Struct(..) |\n+            hir::ItemKind::Union(..) |\n+            hir::ItemKind::Fn(..) => self.encode_variances_of(def_id),\n+            _ => {}\n+        }\n+        match item.kind {\n+            hir::ItemKind::Static(..) |\n+            hir::ItemKind::Const(..) |\n+            hir::ItemKind::Fn(..) |\n+            hir::ItemKind::TyAlias(..) |\n+            hir::ItemKind::Enum(..) |\n+            hir::ItemKind::Struct(..) |\n+            hir::ItemKind::Union(..) |\n+            hir::ItemKind::Impl(..) |\n+            hir::ItemKind::OpaqueTy(..) |\n+            hir::ItemKind::Trait(..) |\n+            hir::ItemKind::TraitAlias(..) => {\n+                self.encode_generics(def_id);\n+                self.encode_predicates(def_id);\n+            }\n+            _ => {}\n+        }\n+        // The only time that `predicates_defined_on` is used (on\n+        // an external item) is for traits, during chalk lowering,\n+        // so only encode it in that case as an efficiency\n+        // hack. (No reason not to expand it in the future if\n+        // necessary.)\n+        match item.kind {\n+            hir::ItemKind::Trait(..) |\n+            hir::ItemKind::TraitAlias(..) => {\n+                self.encode_predicates_defined_on(def_id);\n+            }\n+            _ => {} // not *wrong* for other kinds of items, but not needed\n+        }\n \n         let mir = match item.kind {\n             hir::ItemKind::Static(..) | hir::ItemKind::Const(..) => true,\n@@ -1233,188 +1283,48 @@ impl EncodeContext<'tcx> {\n             }\n             _ => false,\n         };\n-\n-        Entry {\n-            kind,\n-            visibility: self.lazy(ty::Visibility::from_hir(&item.vis, item.hir_id, tcx)),\n-            span: self.lazy(item.span),\n-            attributes: self.encode_attributes(&item.attrs),\n-            children: match item.kind {\n-                hir::ItemKind::ForeignMod(ref fm) => {\n-                    self.lazy(fm.items\n-                        .iter()\n-                        .map(|foreign_item| tcx.hir().local_def_id(\n-                            foreign_item.hir_id).index))\n-                }\n-                hir::ItemKind::Enum(..) => {\n-                    let def = self.tcx.adt_def(def_id);\n-                    self.lazy(def.variants.iter().map(|v| {\n-                        assert!(v.def_id.is_local());\n-                        v.def_id.index\n-                    }))\n-                }\n-                hir::ItemKind::Struct(..) |\n-                hir::ItemKind::Union(..) => {\n-                    let def = self.tcx.adt_def(def_id);\n-                    self.lazy(def.non_enum_variant().fields.iter().map(|f| {\n-                        assert!(f.did.is_local());\n-                        f.did.index\n-                    }))\n-                }\n-                hir::ItemKind::Impl(..) |\n-                hir::ItemKind::Trait(..) => {\n-                    self.lazy(tcx.associated_item_def_ids(def_id).iter().map(|&def_id| {\n-                        assert!(def_id.is_local());\n-                        def_id.index\n-                    }))\n-                }\n-                _ => Lazy::empty(),\n-            },\n-            stability: self.encode_stability(def_id),\n-            deprecation: self.encode_deprecation(def_id),\n-\n-            ty: match item.kind {\n-                hir::ItemKind::Static(..) |\n-                hir::ItemKind::Const(..) |\n-                hir::ItemKind::Fn(..) |\n-                hir::ItemKind::TyAlias(..) |\n-                hir::ItemKind::OpaqueTy(..) |\n-                hir::ItemKind::Enum(..) |\n-                hir::ItemKind::Struct(..) |\n-                hir::ItemKind::Union(..) |\n-                hir::ItemKind::Impl(..) => Some(self.encode_item_type(def_id)),\n-                _ => None,\n-            },\n-            inherent_impls: self.encode_inherent_implementations(def_id),\n-            variances: match item.kind {\n-                hir::ItemKind::Enum(..) |\n-                hir::ItemKind::Struct(..) |\n-                hir::ItemKind::Union(..) |\n-                hir::ItemKind::Fn(..) => self.encode_variances_of(def_id),\n-                _ => Lazy::empty(),\n-            },\n-            generics: match item.kind {\n-                hir::ItemKind::Static(..) |\n-                hir::ItemKind::Const(..) |\n-                hir::ItemKind::Fn(..) |\n-                hir::ItemKind::TyAlias(..) |\n-                hir::ItemKind::Enum(..) |\n-                hir::ItemKind::Struct(..) |\n-                hir::ItemKind::Union(..) |\n-                hir::ItemKind::Impl(..) |\n-                hir::ItemKind::OpaqueTy(..) |\n-                hir::ItemKind::Trait(..) => Some(self.encode_generics(def_id)),\n-                hir::ItemKind::TraitAlias(..) => Some(self.encode_generics(def_id)),\n-                _ => None,\n-            },\n-            predicates: match item.kind {\n-                hir::ItemKind::Static(..) |\n-                hir::ItemKind::Const(..) |\n-                hir::ItemKind::Fn(..) |\n-                hir::ItemKind::TyAlias(..) |\n-                hir::ItemKind::Enum(..) |\n-                hir::ItemKind::Struct(..) |\n-                hir::ItemKind::Union(..) |\n-                hir::ItemKind::Impl(..) |\n-                hir::ItemKind::OpaqueTy(..) |\n-                hir::ItemKind::Trait(..) |\n-                hir::ItemKind::TraitAlias(..) => Some(self.encode_predicates(def_id)),\n-                _ => None,\n-            },\n-\n-            // The only time that `predicates_defined_on` is used (on\n-            // an external item) is for traits, during chalk lowering,\n-            // so only encode it in that case as an efficiency\n-            // hack. (No reason not to expand it in the future if\n-            // necessary.)\n-            predicates_defined_on: match item.kind {\n-                hir::ItemKind::Trait(..) |\n-                hir::ItemKind::TraitAlias(..) => Some(self.encode_predicates_defined_on(def_id)),\n-                _ => None, // not *wrong* for other kinds of items, but not needed\n-            },\n-\n-            mir: if mir { self.encode_optimized_mir(def_id) } else { None },\n-            promoted_mir: if mir { self.encode_promoted_mir(def_id) } else { None },\n+        if mir {\n+            self.encode_optimized_mir(def_id);\n+            self.encode_promoted_mir(def_id);\n         }\n     }\n \n     /// Serialize the text of exported macros\n-    fn encode_info_for_macro_def(&mut self, macro_def: &hir::MacroDef) -> Entry<'tcx> {\n+    fn encode_info_for_macro_def(&mut self, macro_def: &hir::MacroDef) {\n         use syntax::print::pprust;\n         let def_id = self.tcx.hir().local_def_id(macro_def.hir_id);\n-        Entry {\n-            kind: EntryKind::MacroDef(self.lazy(MacroDef {\n-                body: pprust::tts_to_string(macro_def.body.clone()),\n-                legacy: macro_def.legacy,\n-            })),\n-            visibility: self.lazy(ty::Visibility::Public),\n-            span: self.lazy(macro_def.span),\n-            attributes: self.encode_attributes(&macro_def.attrs),\n-            stability: self.encode_stability(def_id),\n-            deprecation: self.encode_deprecation(def_id),\n-\n-            children: Lazy::empty(),\n-            ty: None,\n-            inherent_impls: Lazy::empty(),\n-            variances: Lazy::empty(),\n-            generics: None,\n-            predicates: None,\n-            predicates_defined_on: None,\n-            mir: None,\n-            promoted_mir: None,\n-        }\n+        record!(self.per_def.kind[def_id] <- EntryKind::MacroDef(self.lazy(MacroDef {\n+            body: pprust::tts_to_string(macro_def.body.clone()),\n+            legacy: macro_def.legacy,\n+        })));\n+        record!(self.per_def.visibility[def_id] <- ty::Visibility::Public);\n+        record!(self.per_def.span[def_id] <- macro_def.span);\n+        record!(self.per_def.attributes[def_id] <- &macro_def.attrs);\n+        self.encode_stability(def_id);\n+        self.encode_deprecation(def_id);\n     }\n \n     fn encode_info_for_generic_param(\n         &mut self,\n         def_id: DefId,\n-        entry_kind: EntryKind<'tcx>,\n+        kind: EntryKind<'tcx>,\n         encode_type: bool,\n-    ) -> Entry<'tcx> {\n-        let tcx = self.tcx;\n-        Entry {\n-            kind: entry_kind,\n-            visibility: self.lazy(ty::Visibility::Public),\n-            span: self.lazy(tcx.def_span(def_id)),\n-            attributes: Lazy::empty(),\n-            children: Lazy::empty(),\n-            stability: None,\n-            deprecation: None,\n-            ty: if encode_type { Some(self.encode_item_type(def_id)) } else { None },\n-            inherent_impls: Lazy::empty(),\n-            variances: Lazy::empty(),\n-            generics: None,\n-            predicates: None,\n-            predicates_defined_on: None,\n-\n-            mir: None,\n-            promoted_mir: None,\n+    ) {\n+        record!(self.per_def.kind[def_id] <- kind);\n+        record!(self.per_def.visibility[def_id] <- ty::Visibility::Public);\n+        record!(self.per_def.span[def_id] <- self.tcx.def_span(def_id));\n+        if encode_type {\n+            self.encode_item_type(def_id);\n         }\n     }\n \n-    fn encode_info_for_ty_param(\n-        &mut self,\n-        (def_id, encode_type): (DefId, bool),\n-    ) -> Entry<'tcx> {\n-        debug!(\"EncodeContext::encode_info_for_ty_param({:?})\", def_id);\n-        self.encode_info_for_generic_param(def_id, EntryKind::TypeParam, encode_type)\n-    }\n-\n-    fn encode_info_for_const_param(\n-        &mut self,\n-        def_id: DefId,\n-    ) -> Entry<'tcx> {\n-        debug!(\"EncodeContext::encode_info_for_const_param({:?})\", def_id);\n-        self.encode_info_for_generic_param(def_id, EntryKind::ConstParam, true)\n-    }\n-\n-    fn encode_info_for_closure(&mut self, def_id: DefId) -> Entry<'tcx> {\n+    fn encode_info_for_closure(&mut self, def_id: DefId) {\n         debug!(\"EncodeContext::encode_info_for_closure({:?})\", def_id);\n-        let tcx = self.tcx;\n \n         let tables = self.tcx.typeck_tables_of(def_id);\n         let hir_id = self.tcx.hir().as_local_hir_id(def_id).unwrap();\n-        let kind = match tables.node_type(hir_id).kind {\n+\n+        record!(self.per_def.kind[def_id] <- match tables.node_type(hir_id).kind {\n             ty::Generator(def_id, ..) => {\n                 let layout = self.tcx.generator_layout(def_id);\n                 let data = GeneratorData {\n@@ -1429,61 +1339,32 @@ impl EncodeContext<'tcx> {\n                 EntryKind::Closure(self.lazy(data))\n             }\n \n-            _ => bug!(\"closure that is neither generator nor closure\")\n-        };\n-\n-        Entry {\n-            kind,\n-            visibility: self.lazy(ty::Visibility::Public),\n-            span: self.lazy(tcx.def_span(def_id)),\n-            attributes: self.encode_attributes(&tcx.get_attrs(def_id)),\n-            children: Lazy::empty(),\n-            stability: None,\n-            deprecation: None,\n-\n-            ty: Some(self.encode_item_type(def_id)),\n-            inherent_impls: Lazy::empty(),\n-            variances: Lazy::empty(),\n-            generics: Some(self.encode_generics(def_id)),\n-            predicates: None,\n-            predicates_defined_on: None,\n-\n-            mir: self.encode_optimized_mir(def_id),\n-            promoted_mir: self.encode_promoted_mir(def_id),\n-        }\n+            _ => bug!(\"closure that is neither generator nor closure\"),\n+        });\n+        record!(self.per_def.visibility[def_id] <- ty::Visibility::Public);\n+        record!(self.per_def.span[def_id] <- self.tcx.def_span(def_id));\n+        record!(self.per_def.attributes[def_id] <- &self.tcx.get_attrs(def_id)[..]);\n+        self.encode_item_type(def_id);\n+        self.encode_generics(def_id);\n+        self.encode_optimized_mir(def_id);\n+        self.encode_promoted_mir(def_id);\n     }\n \n-    fn encode_info_for_anon_const(&mut self, def_id: DefId) -> Entry<'tcx> {\n+    fn encode_info_for_anon_const(&mut self, def_id: DefId) {\n         debug!(\"EncodeContext::encode_info_for_anon_const({:?})\", def_id);\n-        let tcx = self.tcx;\n-        let id = tcx.hir().as_local_hir_id(def_id).unwrap();\n-        let body_id = tcx.hir().body_owned_by(id);\n+        let id = self.tcx.hir().as_local_hir_id(def_id).unwrap();\n+        let body_id = self.tcx.hir().body_owned_by(id);\n         let const_data = self.encode_rendered_const_for_body(body_id);\n-        let mir = tcx.mir_const_qualif(def_id).0;\n-\n-        Entry {\n-            kind: EntryKind::Const(ConstQualif { mir }, const_data),\n-            visibility: self.lazy(ty::Visibility::Public),\n-            span: self.lazy(tcx.def_span(def_id)),\n-            attributes: Lazy::empty(),\n-            children: Lazy::empty(),\n-            stability: None,\n-            deprecation: None,\n-\n-            ty: Some(self.encode_item_type(def_id)),\n-            inherent_impls: Lazy::empty(),\n-            variances: Lazy::empty(),\n-            generics: Some(self.encode_generics(def_id)),\n-            predicates: Some(self.encode_predicates(def_id)),\n-            predicates_defined_on: None,\n-\n-            mir: self.encode_optimized_mir(def_id),\n-            promoted_mir: self.encode_promoted_mir(def_id),\n-        }\n-    }\n+        let mir = self.tcx.mir_const_qualif(def_id).0;\n \n-    fn encode_attributes(&mut self, attrs: &[ast::Attribute]) -> Lazy<[ast::Attribute]> {\n-        self.lazy(attrs)\n+        record!(self.per_def.kind[def_id] <- EntryKind::Const(ConstQualif { mir }, const_data));\n+        record!(self.per_def.visibility[def_id] <- ty::Visibility::Public);\n+        record!(self.per_def.span[def_id] <- self.tcx.def_span(def_id));\n+        self.encode_item_type(def_id);\n+        self.encode_generics(def_id);\n+        self.encode_predicates(def_id);\n+        self.encode_optimized_mir(def_id);\n+        self.encode_promoted_mir(def_id);\n     }\n \n     fn encode_native_libraries(&mut self) -> Lazy<[NativeLibrary]> {\n@@ -1657,14 +1538,16 @@ impl EncodeContext<'tcx> {\n         Lazy::empty()\n     }\n \n-    fn encode_info_for_foreign_item(&mut self,\n-                                    (def_id, nitem): (DefId, &hir::ForeignItem))\n-                                    -> Entry<'tcx> {\n+    fn encode_info_for_foreign_item(\n+        &mut self,\n+        def_id: DefId,\n+        nitem: &hir::ForeignItem,\n+    )  {\n         let tcx = self.tcx;\n \n         debug!(\"EncodeContext::encode_info_for_foreign_item({:?})\", def_id);\n \n-        let kind = match nitem.kind {\n+        record!(self.per_def.kind[def_id] <- match nitem.kind {\n             hir::ForeignItemKind::Fn(_, ref names, _) => {\n                 let data = FnData {\n                     asyncness: hir::IsAsync::NotAsync,\n@@ -1677,33 +1560,23 @@ impl EncodeContext<'tcx> {\n             hir::ForeignItemKind::Static(_, hir::MutMutable) => EntryKind::ForeignMutStatic,\n             hir::ForeignItemKind::Static(_, hir::MutImmutable) => EntryKind::ForeignImmStatic,\n             hir::ForeignItemKind::Type => EntryKind::ForeignType,\n-        };\n-\n-        Entry {\n-            kind,\n-            visibility: self.lazy(ty::Visibility::from_hir(&nitem.vis, nitem.hir_id, tcx)),\n-            span: self.lazy(nitem.span),\n-            attributes: self.encode_attributes(&nitem.attrs),\n-            children: Lazy::empty(),\n-            stability: self.encode_stability(def_id),\n-            deprecation: self.encode_deprecation(def_id),\n-\n-            ty: Some(self.encode_item_type(def_id)),\n-            inherent_impls: Lazy::empty(),\n-            variances: match nitem.kind {\n-                hir::ForeignItemKind::Fn(..) => self.encode_variances_of(def_id),\n-                _ => Lazy::empty(),\n-            },\n-            generics: Some(self.encode_generics(def_id)),\n-            predicates: Some(self.encode_predicates(def_id)),\n-            predicates_defined_on: None,\n-\n-            mir: None,\n-            promoted_mir: None,\n+        });\n+        record!(self.per_def.visibility[def_id] <-\n+            ty::Visibility::from_hir(&nitem.vis, nitem.hir_id, self.tcx));\n+        record!(self.per_def.span[def_id] <- nitem.span);\n+        record!(self.per_def.attributes[def_id] <- &nitem.attrs);\n+        self.encode_stability(def_id);\n+        self.encode_deprecation(def_id);\n+        self.encode_item_type(def_id);\n+        if let hir::ForeignItemKind::Fn(..) = nitem.kind {\n+            self.encode_variances_of(def_id);\n         }\n+        self.encode_generics(def_id);\n+        self.encode_predicates(def_id);\n     }\n }\n \n+// FIXME(eddyb) make metadata encoding walk over all definitions, instead of HIR.\n impl Visitor<'tcx> for EncodeContext<'tcx> {\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n         NestedVisitorMap::OnlyBodies(&self.tcx.hir())\n@@ -1715,43 +1588,40 @@ impl Visitor<'tcx> for EncodeContext<'tcx> {\n     fn visit_anon_const(&mut self, c: &'tcx AnonConst) {\n         intravisit::walk_anon_const(self, c);\n         let def_id = self.tcx.hir().local_def_id(c.hir_id);\n-        self.record(def_id, EncodeContext::encode_info_for_anon_const, def_id);\n+        self.encode_info_for_anon_const(def_id);\n     }\n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n         intravisit::walk_item(self, item);\n         let def_id = self.tcx.hir().local_def_id(item.hir_id);\n         match item.kind {\n             hir::ItemKind::ExternCrate(_) |\n             hir::ItemKind::Use(..) => {} // ignore these\n-            _ => self.record(def_id, EncodeContext::encode_info_for_item, (def_id, item)),\n+            _ => self.encode_info_for_item(def_id, item),\n         }\n         self.encode_addl_info_for_item(item);\n     }\n     fn visit_foreign_item(&mut self, ni: &'tcx hir::ForeignItem) {\n         intravisit::walk_foreign_item(self, ni);\n         let def_id = self.tcx.hir().local_def_id(ni.hir_id);\n-        self.record(def_id,\n-                          EncodeContext::encode_info_for_foreign_item,\n-                          (def_id, ni));\n+        self.encode_info_for_foreign_item(def_id, ni);\n     }\n     fn visit_generics(&mut self, generics: &'tcx hir::Generics) {\n         intravisit::walk_generics(self, generics);\n         self.encode_info_for_generics(generics);\n     }\n     fn visit_macro_def(&mut self, macro_def: &'tcx hir::MacroDef) {\n-        let def_id = self.tcx.hir().local_def_id(macro_def.hir_id);\n-        self.record(def_id, EncodeContext::encode_info_for_macro_def, macro_def);\n+        self.encode_info_for_macro_def(macro_def);\n     }\n }\n \n impl EncodeContext<'tcx> {\n     fn encode_fields(&mut self, adt_def_id: DefId) {\n         let def = self.tcx.adt_def(adt_def_id);\n         for (variant_index, variant) in def.variants.iter_enumerated() {\n-            for (field_index, field) in variant.fields.iter().enumerate() {\n-                self.record(field.did,\n-                            EncodeContext::encode_field,\n-                            (adt_def_id, variant_index, field_index));\n+            for (field_index, _field) in variant.fields.iter().enumerate() {\n+                // FIXME(eddyb) `adt_def_id` is leftover from incremental isolation,\n+                // pass `def`, `variant` or `field` instead.\n+                self.encode_field(adt_def_id, variant_index, field_index);\n             }\n         }\n     }\n@@ -1762,14 +1632,14 @@ impl EncodeContext<'tcx> {\n             match param.kind {\n                 GenericParamKind::Lifetime { .. } => continue,\n                 GenericParamKind::Type { ref default, .. } => {\n-                    self.record(\n+                    self.encode_info_for_generic_param(\n                         def_id,\n-                        EncodeContext::encode_info_for_ty_param,\n-                        (def_id, default.is_some()),\n+                        EntryKind::TypeParam,\n+                        default.is_some(),\n                     );\n                 }\n                 GenericParamKind::Const { .. } => {\n-                    self.record(def_id, EncodeContext::encode_info_for_const_param, def_id);\n+                    self.encode_info_for_generic_param(def_id, EntryKind::ConstParam, true);\n                 }\n             }\n         }\n@@ -1779,7 +1649,7 @@ impl EncodeContext<'tcx> {\n         match expr.kind {\n             hir::ExprKind::Closure(..) => {\n                 let def_id = self.tcx.hir().local_def_id(expr.hir_id);\n-                self.record(def_id, EncodeContext::encode_info_for_closure, def_id);\n+                self.encode_info_for_closure(def_id);\n             }\n             _ => {}\n         }\n@@ -1810,14 +1680,14 @@ impl EncodeContext<'tcx> {\n \n                 let def = self.tcx.adt_def(def_id);\n                 for (i, variant) in def.variants.iter_enumerated() {\n-                    self.record(variant.def_id,\n-                                EncodeContext::encode_enum_variant_info,\n-                                (def_id, i));\n-\n-                    if let Some(ctor_def_id) = variant.ctor_def_id {\n-                        self.record(ctor_def_id,\n-                                    EncodeContext::encode_enum_variant_ctor,\n-                                    (def_id, i));\n+                    // FIXME(eddyb) `def_id` is leftover from incremental isolation,\n+                    // pass `def` or `variant` instead.\n+                    self.encode_enum_variant_info(def_id, i);\n+\n+                    // FIXME(eddyb) `def_id` is leftover from incremental isolation,\n+                    // pass `def`, `variant` or `ctor_def_id` instead.\n+                    if let Some(_ctor_def_id) = variant.ctor_def_id {\n+                        self.encode_enum_variant_ctor(def_id, i);\n                     }\n                 }\n             }\n@@ -1827,26 +1697,20 @@ impl EncodeContext<'tcx> {\n                 // If the struct has a constructor, encode it.\n                 if let Some(ctor_hir_id) = struct_def.ctor_hir_id() {\n                     let ctor_def_id = self.tcx.hir().local_def_id(ctor_hir_id);\n-                    self.record(ctor_def_id,\n-                                EncodeContext::encode_struct_ctor,\n-                                (def_id, ctor_def_id));\n+                    self.encode_struct_ctor(def_id, ctor_def_id);\n                 }\n             }\n             hir::ItemKind::Union(..) => {\n                 self.encode_fields(def_id);\n             }\n             hir::ItemKind::Impl(..) => {\n                 for &trait_item_def_id in self.tcx.associated_item_def_ids(def_id).iter() {\n-                    self.record(trait_item_def_id,\n-                                EncodeContext::encode_info_for_impl_item,\n-                                trait_item_def_id);\n+                    self.encode_info_for_impl_item(trait_item_def_id);\n                 }\n             }\n             hir::ItemKind::Trait(..) => {\n                 for &item_def_id in self.tcx.associated_item_def_ids(def_id).iter() {\n-                    self.record(item_def_id,\n-                                EncodeContext::encode_info_for_trait_item,\n-                                item_def_id);\n+                    self.encode_info_for_trait_item(item_def_id);\n                 }\n             }\n         }\n@@ -1914,7 +1778,7 @@ crate fn encode_metadata(tcx: TyCtxt<'_>) -> EncodedMetadata {\n         let mut ecx = EncodeContext {\n             opaque: encoder,\n             tcx,\n-            entries_index: Index::new(tcx.hir().definitions().def_index_count()),\n+            per_def: Default::default(),\n             lazy_state: LazyState::NoNode,\n             type_shorthands: Default::default(),\n             predicate_shorthands: Default::default(),\n@@ -1934,19 +1798,11 @@ crate fn encode_metadata(tcx: TyCtxt<'_>) -> EncodedMetadata {\n \n     // Encode the root position.\n     let header = METADATA_HEADER.len();\n-    let pos = root.position;\n+    let pos = root.position.get();\n     result[header + 0] = (pos >> 24) as u8;\n     result[header + 1] = (pos >> 16) as u8;\n     result[header + 2] = (pos >> 8) as u8;\n     result[header + 3] = (pos >> 0) as u8;\n \n     EncodedMetadata { raw_data: result }\n }\n-\n-fn get_repr_options(tcx: TyCtxt<'_>, did: DefId) -> ReprOptions {\n-    let ty = tcx.type_of(did);\n-    match ty.kind {\n-        ty::Adt(ref def, _) => return def.repr,\n-        _ => bug!(\"{} is not an ADT\", ty),\n-    }\n-}"}, {"sha": "037f9d35630833702ae7d8e31a2ec55bdf72e11e", "filename": "src/librustc_metadata/index.rs", "status": "removed", "additions": 0, "deletions": 141, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/a16dca337de610986252bb800953e57bf395863f/src%2Flibrustc_metadata%2Findex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a16dca337de610986252bb800953e57bf395863f/src%2Flibrustc_metadata%2Findex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Findex.rs?ref=a16dca337de610986252bb800953e57bf395863f", "patch": "@@ -1,141 +0,0 @@\n-use crate::schema::*;\n-\n-use rustc::hir::def_id::{DefId, DefIndex};\n-use rustc_serialize::opaque::Encoder;\n-use std::marker::PhantomData;\n-use std::u32;\n-use log::debug;\n-\n-/// Helper trait, for encoding to, and decoding from, a fixed number of bytes.\n-trait FixedSizeEncoding {\n-    const BYTE_LEN: usize;\n-\n-    // FIXME(eddyb) convert to and from `[u8; Self::BYTE_LEN]` instead,\n-    // once that starts being allowed by the compiler (i.e. lazy normalization).\n-    fn from_bytes(b: &[u8]) -> Self;\n-    fn write_to_bytes(self, b: &mut [u8]);\n-\n-    // FIXME(eddyb) make these generic functions, or at least defaults here.\n-    // (same problem as above, needs `[u8; Self::BYTE_LEN]`)\n-    // For now, a macro (`fixed_size_encoding_byte_len_and_defaults`) is used.\n-    fn read_from_bytes_at(b: &[u8], i: usize) -> Self;\n-    fn write_to_bytes_at(self, b: &mut [u8], i: usize);\n-}\n-\n-// HACK(eddyb) this shouldn't be needed (see comments on the methods above).\n-macro_rules! fixed_size_encoding_byte_len_and_defaults {\n-    ($byte_len:expr) => {\n-        const BYTE_LEN: usize = $byte_len;\n-        fn read_from_bytes_at(b: &[u8], i: usize) -> Self {\n-            const BYTE_LEN: usize = $byte_len;\n-            // HACK(eddyb) ideally this would be done with fully safe code,\n-            // but slicing `[u8]` with `i * N..` is optimized worse, due to the\n-            // possibility of `i * N` overflowing, than indexing `[[u8; N]]`.\n-            let b = unsafe {\n-                std::slice::from_raw_parts(\n-                    b.as_ptr() as *const [u8; BYTE_LEN],\n-                    b.len() / BYTE_LEN,\n-                )\n-            };\n-            Self::from_bytes(&b[i])\n-        }\n-        fn write_to_bytes_at(self, b: &mut [u8], i: usize) {\n-            const BYTE_LEN: usize = $byte_len;\n-            // HACK(eddyb) ideally this would be done with fully safe code,\n-            // see similar comment in `read_from_bytes_at` for why it can't yet.\n-            let b = unsafe {\n-                std::slice::from_raw_parts_mut(\n-                    b.as_mut_ptr() as *mut [u8; BYTE_LEN],\n-                    b.len() / BYTE_LEN,\n-                )\n-            };\n-            self.write_to_bytes(&mut b[i]);\n-        }\n-    }\n-}\n-\n-impl FixedSizeEncoding for u32 {\n-    fixed_size_encoding_byte_len_and_defaults!(4);\n-\n-    fn from_bytes(b: &[u8]) -> Self {\n-        let mut bytes = [0; Self::BYTE_LEN];\n-        bytes.copy_from_slice(&b[..Self::BYTE_LEN]);\n-        Self::from_le_bytes(bytes)\n-    }\n-\n-    fn write_to_bytes(self, b: &mut [u8]) {\n-        b[..Self::BYTE_LEN].copy_from_slice(&self.to_le_bytes());\n-    }\n-}\n-\n-/// While we are generating the metadata, we also track the position\n-/// of each DefIndex. It is not required that all definitions appear\n-/// in the metadata, nor that they are serialized in order, and\n-/// therefore we first allocate the vector here and fill it with\n-/// `u32::MAX`. Whenever an index is visited, we fill in the\n-/// appropriate spot by calling `record_position`. We should never\n-/// visit the same index twice.\n-crate struct Index<'tcx> {\n-    positions: Vec<u8>,\n-    _marker: PhantomData<&'tcx ()>,\n-}\n-\n-impl Index<'tcx> {\n-    crate fn new(max_index: usize) -> Self {\n-        Index {\n-            positions: vec![0xff; max_index * 4],\n-            _marker: PhantomData,\n-        }\n-    }\n-\n-    crate fn record(&mut self, def_id: DefId, entry: Lazy<Entry<'tcx>>) {\n-        assert!(def_id.is_local());\n-        self.record_index(def_id.index, entry);\n-    }\n-\n-    fn record_index(&mut self, item: DefIndex, entry: Lazy<Entry<'tcx>>) {\n-        assert!(entry.position < (u32::MAX as usize));\n-        let position = entry.position as u32;\n-        let array_index = item.index();\n-\n-        let positions = &mut self.positions;\n-        assert!(u32::read_from_bytes_at(positions, array_index) == u32::MAX,\n-                \"recorded position for item {:?} twice, first at {:?} and now at {:?}\",\n-                item,\n-                u32::read_from_bytes_at(positions, array_index),\n-                position);\n-\n-        position.write_to_bytes_at(positions, array_index)\n-    }\n-\n-    crate fn write_index(&self, buf: &mut Encoder) -> Lazy<[Self]> {\n-        let pos = buf.position();\n-\n-        // First we write the length of the lower range ...\n-        buf.emit_raw_bytes(&(self.positions.len() as u32 / 4).to_le_bytes());\n-        // ... then the values.\n-        buf.emit_raw_bytes(&self.positions);\n-        Lazy::from_position_and_meta(pos as usize, self.positions.len() / 4 + 1)\n-    }\n-}\n-\n-impl Lazy<[Index<'tcx>]> {\n-    /// Given the metadata, extract out the offset of a particular\n-    /// DefIndex (if any).\n-    #[inline(never)]\n-    crate fn lookup(&self, bytes: &[u8], def_index: DefIndex) -> Option<Lazy<Entry<'tcx>>> {\n-        let bytes = &bytes[self.position..];\n-        debug!(\"Index::lookup: index={:?} len={:?}\",\n-               def_index,\n-               self.meta);\n-\n-        let position = u32::read_from_bytes_at(bytes, 1 + def_index.index());\n-        if position == u32::MAX {\n-            debug!(\"Index::lookup: position=u32::MAX\");\n-            None\n-        } else {\n-            debug!(\"Index::lookup: position={:?}\", position);\n-            Some(Lazy::from_position(position as usize))\n-        }\n-    }\n-}"}, {"sha": "291ee23ff7262d73917adb7dffcf3714888d8cec", "filename": "src/librustc_metadata/lib.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ea45150837990ccf40edfe2725ac492fc35193a1/src%2Flibrustc_metadata%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea45150837990ccf40edfe2725ac492fc35193a1/src%2Flibrustc_metadata%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flib.rs?ref=ea45150837990ccf40edfe2725ac492fc35193a1", "patch": "@@ -26,15 +26,15 @@ extern crate rustc_data_structures;\n \n pub mod error_codes;\n \n-mod index;\n mod encoder;\n mod decoder;\n+mod dependency_format;\n mod cstore_impl;\n-mod schema;\n-mod native_libs;\n-mod link_args;\n mod foreign_modules;\n-mod dependency_format;\n+mod link_args;\n+mod native_libs;\n+mod schema;\n+mod table;\n \n pub mod creader;\n pub mod cstore;"}, {"sha": "96f35783278fa5784d21821ce3b949944cabb262", "filename": "src/librustc_metadata/schema.rs", "status": "modified", "additions": 60, "deletions": 48, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/ea45150837990ccf40edfe2725ac492fc35193a1/src%2Flibrustc_metadata%2Fschema.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea45150837990ccf40edfe2725ac492fc35193a1/src%2Flibrustc_metadata%2Fschema.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fschema.rs?ref=ea45150837990ccf40edfe2725ac492fc35193a1", "patch": "@@ -1,4 +1,4 @@\n-use crate::index;\n+use crate::table::PerDefTable;\n \n use rustc::hir;\n use rustc::hir::def::{self, CtorKind};\n@@ -14,12 +14,14 @@ use rustc_target::spec::{PanicStrategy, TargetTriple};\n use rustc_index::vec::IndexVec;\n use rustc_data_structures::svh::Svh;\n \n+use rustc_serialize::Encodable;\n use syntax::{ast, attr};\n use syntax::edition::Edition;\n use syntax::symbol::Symbol;\n use syntax_pos::{self, Span};\n \n use std::marker::PhantomData;\n+use std::num::NonZeroUsize;\n \n crate fn rustc_version() -> String {\n     format!(\"rustc {}\",\n@@ -52,7 +54,7 @@ crate trait LazyMeta {\n     fn min_size(meta: Self::Meta) -> usize;\n }\n \n-impl<T> LazyMeta for T {\n+impl<T: Encodable> LazyMeta for T {\n     type Meta = ();\n \n     fn min_size(_: ()) -> usize {\n@@ -61,7 +63,7 @@ impl<T> LazyMeta for T {\n     }\n }\n \n-impl<T> LazyMeta for [T] {\n+impl<T: Encodable> LazyMeta for [T] {\n     type Meta = usize;\n \n     fn min_size(len: usize) -> usize {\n@@ -102,13 +104,13 @@ crate struct Lazy<T, Meta = <T as LazyMeta>::Meta>\n     where T: ?Sized + LazyMeta<Meta = Meta>,\n           Meta: 'static + Copy,\n {\n-    pub position: usize,\n+    pub position: NonZeroUsize,\n     pub meta: Meta,\n     _marker: PhantomData<T>,\n }\n \n impl<T: ?Sized + LazyMeta> Lazy<T> {\n-    crate fn from_position_and_meta(position: usize, meta: T::Meta) -> Lazy<T> {\n+     crate fn from_position_and_meta(position: NonZeroUsize, meta: T::Meta) -> Lazy<T> {\n         Lazy {\n             position,\n             meta,\n@@ -117,15 +119,15 @@ impl<T: ?Sized + LazyMeta> Lazy<T> {\n     }\n }\n \n-impl<T> Lazy<T> {\n-    crate fn from_position(position: usize) -> Lazy<T> {\n+impl<T: Encodable> Lazy<T> {\n+    crate fn from_position(position: NonZeroUsize) -> Lazy<T> {\n         Lazy::from_position_and_meta(position, ())\n     }\n }\n \n-impl<T> Lazy<[T]> {\n+impl<T: Encodable> Lazy<[T]> {\n     crate fn empty() -> Lazy<[T]> {\n-        Lazy::from_position_and_meta(0, 0)\n+        Lazy::from_position_and_meta(NonZeroUsize::new(1).unwrap(), 0)\n     }\n }\n \n@@ -147,12 +149,22 @@ crate enum LazyState {\n \n     /// Inside a metadata node, and before any `Lazy`.\n     /// The position is that of the node itself.\n-    NodeStart(usize),\n+    NodeStart(NonZeroUsize),\n \n     /// Inside a metadata node, with a previous `Lazy`.\n     /// The position is a conservative estimate of where that\n     /// previous `Lazy` would end (see their comments).\n-    Previous(usize),\n+    Previous(NonZeroUsize),\n+}\n+\n+// FIXME(#59875) `Lazy!(T)` replaces `Lazy<T>`, passing the `Meta` parameter\n+// manually, instead of relying on the default, to get the correct variance.\n+// Only needed when `T` itself contains a parameter (e.g. `'tcx`).\n+macro_rules! Lazy {\n+    (Table<$T:ty>) => {Lazy<Table<$T>, usize>};\n+    (PerDefTable<$T:ty>) => {Lazy<PerDefTable<$T>, usize>};\n+    ([$T:ty]) => {Lazy<[$T], usize>};\n+    ($T:ty) => {Lazy<$T, ()>};\n }\n \n #[derive(RustcEncodable, RustcDecodable)]\n@@ -182,10 +194,10 @@ crate struct CrateRoot<'tcx> {\n     pub source_map: Lazy<[syntax_pos::SourceFile]>,\n     pub def_path_table: Lazy<hir::map::definitions::DefPathTable>,\n     pub impls: Lazy<[TraitImpls]>,\n-    pub exported_symbols: Lazy<[(ExportedSymbol<'tcx>, SymbolExportLevel)]>,\n+    pub exported_symbols: Lazy!([(ExportedSymbol<'tcx>, SymbolExportLevel)]),\n     pub interpret_alloc_index: Lazy<[u32]>,\n \n-    pub entries_index: Lazy<[index::Index<'tcx>]>,\n+    pub per_def: LazyPerDefTables<'tcx>,\n \n     /// The DefIndex's of any proc macros delcared by\n     /// this crate\n@@ -216,24 +228,24 @@ crate struct TraitImpls {\n }\n \n #[derive(RustcEncodable, RustcDecodable)]\n-crate struct Entry<'tcx> {\n-    pub kind: EntryKind<'tcx>,\n-    pub visibility: Lazy<ty::Visibility>,\n-    pub span: Lazy<Span>,\n-    pub attributes: Lazy<[ast::Attribute]>,\n-    pub children: Lazy<[DefIndex]>,\n-    pub stability: Option<Lazy<attr::Stability>>,\n-    pub deprecation: Option<Lazy<attr::Deprecation>>,\n-\n-    pub ty: Option<Lazy<Ty<'tcx>>>,\n-    pub inherent_impls: Lazy<[DefIndex]>,\n-    pub variances: Lazy<[ty::Variance]>,\n-    pub generics: Option<Lazy<ty::Generics>>,\n-    pub predicates: Option<Lazy<ty::GenericPredicates<'tcx>>>,\n-    pub predicates_defined_on: Option<Lazy<ty::GenericPredicates<'tcx>>>,\n-\n-    pub mir: Option<Lazy<mir::Body<'tcx>>>,\n-    pub promoted_mir: Option<Lazy<IndexVec<mir::Promoted, mir::Body<'tcx>>>>,\n+crate struct LazyPerDefTables<'tcx> {\n+    pub kind: Lazy!(PerDefTable<Lazy!(EntryKind<'tcx>)>),\n+    pub visibility: Lazy!(PerDefTable<Lazy<ty::Visibility>>),\n+    pub span: Lazy!(PerDefTable<Lazy<Span>>),\n+    pub attributes: Lazy!(PerDefTable<Lazy<[ast::Attribute]>>),\n+    pub children: Lazy!(PerDefTable<Lazy<[DefIndex]>>),\n+    pub stability: Lazy!(PerDefTable<Lazy<attr::Stability>>),\n+    pub deprecation: Lazy!(PerDefTable<Lazy<attr::Deprecation>>),\n+\n+    pub ty: Lazy!(PerDefTable<Lazy!(Ty<'tcx>)>),\n+    pub inherent_impls: Lazy!(PerDefTable<Lazy<[DefIndex]>>),\n+    pub variances: Lazy!(PerDefTable<Lazy<[ty::Variance]>>),\n+    pub generics: Lazy!(PerDefTable<Lazy<ty::Generics>>),\n+    pub predicates: Lazy!(PerDefTable<Lazy!(ty::GenericPredicates<'tcx>)>),\n+    pub predicates_defined_on: Lazy!(PerDefTable<Lazy!(ty::GenericPredicates<'tcx>)>),\n+\n+    pub mir: Lazy!(PerDefTable<Lazy!(mir::Body<'tcx>)>),\n+    pub promoted_mir: Lazy!(PerDefTable<Lazy!(IndexVec<mir::Promoted, mir::Body<'tcx>>)>),\n }\n \n #[derive(Copy, Clone, RustcEncodable, RustcDecodable)]\n@@ -252,22 +264,22 @@ crate enum EntryKind<'tcx> {\n     OpaqueTy,\n     Enum(ReprOptions),\n     Field,\n-    Variant(Lazy<VariantData<'tcx>>),\n-    Struct(Lazy<VariantData<'tcx>>, ReprOptions),\n-    Union(Lazy<VariantData<'tcx>>, ReprOptions),\n-    Fn(Lazy<FnData<'tcx>>),\n-    ForeignFn(Lazy<FnData<'tcx>>),\n+    Variant(Lazy!(VariantData<'tcx>)),\n+    Struct(Lazy!(VariantData<'tcx>), ReprOptions),\n+    Union(Lazy!(VariantData<'tcx>), ReprOptions),\n+    Fn(Lazy!(FnData<'tcx>)),\n+    ForeignFn(Lazy!(FnData<'tcx>)),\n     Mod(Lazy<ModData>),\n     MacroDef(Lazy<MacroDef>),\n-    Closure(Lazy<ClosureData<'tcx>>),\n-    Generator(Lazy<GeneratorData<'tcx>>),\n-    Trait(Lazy<TraitData<'tcx>>),\n-    Impl(Lazy<ImplData<'tcx>>),\n-    Method(Lazy<MethodData<'tcx>>),\n+    Closure(Lazy!(ClosureData<'tcx>)),\n+    Generator(Lazy!(GeneratorData<'tcx>)),\n+    Trait(Lazy!(TraitData<'tcx>)),\n+    Impl(Lazy!(ImplData<'tcx>)),\n+    Method(Lazy!(MethodData<'tcx>)),\n     AssocType(AssocContainer),\n     AssocOpaqueTy(AssocContainer),\n     AssocConst(AssocContainer, ConstQualif, Lazy<RenderedConst>),\n-    TraitAlias(Lazy<TraitAliasData<'tcx>>),\n+    TraitAlias(Lazy!(TraitAliasData<'tcx>)),\n }\n \n /// Additional data for EntryKind::Const and EntryKind::AssocConst\n@@ -297,7 +309,7 @@ crate struct FnData<'tcx> {\n     pub asyncness: hir::IsAsync,\n     pub constness: hir::Constness,\n     pub param_names: Lazy<[ast::Name]>,\n-    pub sig: Lazy<ty::PolyFnSig<'tcx>>,\n+    pub sig: Lazy!(ty::PolyFnSig<'tcx>),\n }\n \n #[derive(RustcEncodable, RustcDecodable)]\n@@ -308,7 +320,7 @@ crate struct VariantData<'tcx> {\n     pub ctor: Option<DefIndex>,\n     /// If this is a tuple struct or variant\n     /// ctor, this is its \"function\" signature.\n-    pub ctor_sig: Option<Lazy<ty::PolyFnSig<'tcx>>>,\n+    pub ctor_sig: Option<Lazy!(ty::PolyFnSig<'tcx>)>,\n }\n \n #[derive(RustcEncodable, RustcDecodable)]\n@@ -317,12 +329,12 @@ crate struct TraitData<'tcx> {\n     pub paren_sugar: bool,\n     pub has_auto_impl: bool,\n     pub is_marker: bool,\n-    pub super_predicates: Lazy<ty::GenericPredicates<'tcx>>,\n+    pub super_predicates: Lazy!(ty::GenericPredicates<'tcx>),\n }\n \n #[derive(RustcEncodable, RustcDecodable)]\n crate struct TraitAliasData<'tcx> {\n-    pub super_predicates: Lazy<ty::GenericPredicates<'tcx>>,\n+    pub super_predicates: Lazy!(ty::GenericPredicates<'tcx>),\n }\n \n #[derive(RustcEncodable, RustcDecodable)]\n@@ -333,7 +345,7 @@ crate struct ImplData<'tcx> {\n \n     /// This is `Some` only for impls of `CoerceUnsized`.\n     pub coerce_unsized_info: Option<ty::adjustment::CoerceUnsizedInfo>,\n-    pub trait_ref: Option<Lazy<ty::TraitRef<'tcx>>>,\n+    pub trait_ref: Option<Lazy!(ty::TraitRef<'tcx>)>,\n }\n \n \n@@ -384,7 +396,7 @@ crate struct MethodData<'tcx> {\n \n #[derive(RustcEncodable, RustcDecodable)]\n crate struct ClosureData<'tcx> {\n-    pub sig: Lazy<ty::PolyFnSig<'tcx>>,\n+    pub sig: Lazy!(ty::PolyFnSig<'tcx>),\n }\n \n #[derive(RustcEncodable, RustcDecodable)]"}, {"sha": "e164c28c953bc8b7d76f2fc46f44834a52404e65", "filename": "src/librustc_metadata/table.rs", "status": "added", "additions": 239, "deletions": 0, "changes": 239, "blob_url": "https://github.com/rust-lang/rust/blob/ea45150837990ccf40edfe2725ac492fc35193a1/src%2Flibrustc_metadata%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea45150837990ccf40edfe2725ac492fc35193a1/src%2Flibrustc_metadata%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Ftable.rs?ref=ea45150837990ccf40edfe2725ac492fc35193a1", "patch": "@@ -0,0 +1,239 @@\n+use crate::decoder::Metadata;\n+use crate::schema::*;\n+\n+use rustc::hir::def_id::{DefId, DefIndex};\n+use rustc_serialize::{Encodable, opaque::Encoder};\n+use std::convert::TryInto;\n+use std::marker::PhantomData;\n+use std::num::NonZeroUsize;\n+use log::debug;\n+\n+/// Helper trait, for encoding to, and decoding from, a fixed number of bytes.\n+/// Used mainly for Lazy positions and lengths.\n+/// Unchecked invariant: `Self::default()` should encode as `[0; BYTE_LEN]`,\n+/// but this has no impact on safety.\n+crate trait FixedSizeEncoding: Default {\n+    const BYTE_LEN: usize;\n+\n+    // FIXME(eddyb) convert to and from `[u8; Self::BYTE_LEN]` instead,\n+    // once that starts being allowed by the compiler (i.e. lazy normalization).\n+    fn from_bytes(b: &[u8]) -> Self;\n+    fn write_to_bytes(self, b: &mut [u8]);\n+\n+    // FIXME(eddyb) make these generic functions, or at least defaults here.\n+    // (same problem as above, needs `[u8; Self::BYTE_LEN]`)\n+    // For now, a macro (`fixed_size_encoding_byte_len_and_defaults`) is used.\n+\n+    /// Read a `Self` value (encoded as `Self::BYTE_LEN` bytes),\n+    /// from `&b[i * Self::BYTE_LEN..]`, returning `None` if `i`\n+    /// is not in bounds, or `Some(Self::from_bytes(...))` otherwise.\n+    fn maybe_read_from_bytes_at(b: &[u8], i: usize) -> Option<Self>;\n+    /// Write a `Self` value (encoded as `Self::BYTE_LEN` bytes),\n+    /// at `&mut b[i * Self::BYTE_LEN..]`, using `Self::write_to_bytes`.\n+    fn write_to_bytes_at(self, b: &mut [u8], i: usize);\n+}\n+\n+// HACK(eddyb) this shouldn't be needed (see comments on the methods above).\n+macro_rules! fixed_size_encoding_byte_len_and_defaults {\n+    ($byte_len:expr) => {\n+        const BYTE_LEN: usize = $byte_len;\n+        fn maybe_read_from_bytes_at(b: &[u8], i: usize) -> Option<Self> {\n+            const BYTE_LEN: usize = $byte_len;\n+            // HACK(eddyb) ideally this would be done with fully safe code,\n+            // but slicing `[u8]` with `i * N..` is optimized worse, due to the\n+            // possibility of `i * N` overflowing, than indexing `[[u8; N]]`.\n+            let b = unsafe {\n+                std::slice::from_raw_parts(\n+                    b.as_ptr() as *const [u8; BYTE_LEN],\n+                    b.len() / BYTE_LEN,\n+                )\n+            };\n+            b.get(i).map(|b| FixedSizeEncoding::from_bytes(b))\n+        }\n+        fn write_to_bytes_at(self, b: &mut [u8], i: usize) {\n+            const BYTE_LEN: usize = $byte_len;\n+            // HACK(eddyb) ideally this would be done with fully safe code,\n+            // see similar comment in `read_from_bytes_at` for why it can't yet.\n+            let b = unsafe {\n+                std::slice::from_raw_parts_mut(\n+                    b.as_mut_ptr() as *mut [u8; BYTE_LEN],\n+                    b.len() / BYTE_LEN,\n+                )\n+            };\n+            self.write_to_bytes(&mut b[i]);\n+        }\n+    }\n+}\n+\n+impl FixedSizeEncoding for u32 {\n+    fixed_size_encoding_byte_len_and_defaults!(4);\n+\n+    fn from_bytes(b: &[u8]) -> Self {\n+        let mut bytes = [0; Self::BYTE_LEN];\n+        bytes.copy_from_slice(&b[..Self::BYTE_LEN]);\n+        Self::from_le_bytes(bytes)\n+    }\n+\n+    fn write_to_bytes(self, b: &mut [u8]) {\n+        b[..Self::BYTE_LEN].copy_from_slice(&self.to_le_bytes());\n+    }\n+}\n+\n+// NOTE(eddyb) there could be an impl for `usize`, which would enable a more\n+// generic `Lazy<T>` impl, but in the general case we might not need / want to\n+// fit every `usize` in `u32`.\n+impl<T: Encodable> FixedSizeEncoding for Option<Lazy<T>> {\n+    fixed_size_encoding_byte_len_and_defaults!(u32::BYTE_LEN);\n+\n+    fn from_bytes(b: &[u8]) -> Self {\n+        Some(Lazy::from_position(NonZeroUsize::new(u32::from_bytes(b) as usize)?))\n+    }\n+\n+    fn write_to_bytes(self, b: &mut [u8]) {\n+        let position = self.map_or(0, |lazy| lazy.position.get());\n+        let position: u32 = position.try_into().unwrap();\n+\n+        position.write_to_bytes(b)\n+    }\n+}\n+\n+impl<T: Encodable> FixedSizeEncoding for Option<Lazy<[T]>> {\n+    fixed_size_encoding_byte_len_and_defaults!(u32::BYTE_LEN * 2);\n+\n+    fn from_bytes(b: &[u8]) -> Self {\n+        Some(Lazy::from_position_and_meta(\n+            <Option<Lazy<T>>>::from_bytes(b)?.position,\n+            u32::from_bytes(&b[u32::BYTE_LEN..]) as usize,\n+        ))\n+    }\n+\n+    fn write_to_bytes(self, b: &mut [u8]) {\n+        self.map(|lazy| Lazy::<T>::from_position(lazy.position))\n+            .write_to_bytes(b);\n+\n+        let len = self.map_or(0, |lazy| lazy.meta);\n+        let len: u32 = len.try_into().unwrap();\n+\n+        len.write_to_bytes(&mut b[u32::BYTE_LEN..]);\n+    }\n+}\n+\n+/// Random-access table (i.e. offeringconstant-time `get`/`set`), similar to\n+/// `Vec<Option<T>>`, but without requiring encoding or decoding all the values\n+/// eagerly and in-order.\n+/// A total of `(max_idx + 1) * <Option<T> as FixedSizeEncoding>::BYTE_LEN` bytes\n+/// are used for a table, where `max_idx` is the largest index passed to `set`.\n+// FIXME(eddyb) replace `Vec` with `[_]` here, such that `Box<Table<T>>` would be used\n+// when building it, and `Lazy<Table<T>>` or `&Table<T>` when reading it.\n+// (not sure if that is possible given that the `Vec` is being resized now)\n+crate struct Table<T> where Option<T>: FixedSizeEncoding {\n+    // FIXME(eddyb) store `[u8; <Option<T>>::BYTE_LEN]` instead of `u8` in `Vec`,\n+    // once that starts being allowed by the compiler (i.e. lazy normalization).\n+    bytes: Vec<u8>,\n+    _marker: PhantomData<T>,\n+}\n+\n+impl<T> Default for Table<T> where Option<T>: FixedSizeEncoding {\n+    fn default() -> Self {\n+        Table {\n+            bytes: vec![],\n+            _marker: PhantomData,\n+        }\n+    }\n+}\n+\n+impl<T> Table<T> where Option<T>: FixedSizeEncoding {\n+    crate fn set(&mut self, i: usize, value: T) {\n+        // FIXME(eddyb) investigate more compact encodings for sparse tables.\n+        // On the PR @michaelwoerister mentioned:\n+        // > Space requirements could perhaps be optimized by using the HAMT `popcnt`\n+        // > trick (i.e. divide things into buckets of 32 or 64 items and then\n+        // > store bit-masks of which item in each bucket is actually serialized).\n+        let needed = (i + 1) * <Option<T>>::BYTE_LEN;\n+        if self.bytes.len() < needed {\n+            self.bytes.resize(needed, 0);\n+        }\n+\n+        Some(value).write_to_bytes_at(&mut self.bytes, i);\n+    }\n+\n+    crate fn encode(&self, buf: &mut Encoder) -> Lazy<Self> {\n+        let pos = buf.position();\n+        buf.emit_raw_bytes(&self.bytes);\n+        Lazy::from_position_and_meta(\n+            NonZeroUsize::new(pos as usize).unwrap(),\n+            self.bytes.len(),\n+        )\n+    }\n+}\n+\n+impl<T> LazyMeta for Table<T> where Option<T>: FixedSizeEncoding {\n+    type Meta = usize;\n+\n+    fn min_size(len: usize) -> usize {\n+        len\n+    }\n+}\n+\n+impl<T> Lazy<Table<T>> where Option<T>: FixedSizeEncoding {\n+    /// Given the metadata, extract out the value at a particular index (if any).\n+    #[inline(never)]\n+    crate fn get<'a, 'tcx, M: Metadata<'a, 'tcx>>(\n+        &self,\n+        metadata: M,\n+        i: usize,\n+    ) -> Option<T> {\n+        debug!(\"Table::lookup: index={:?} len={:?}\", i, self.meta);\n+\n+        let start = self.position.get();\n+        let bytes = &metadata.raw_bytes()[start..start + self.meta];\n+        <Option<T>>::maybe_read_from_bytes_at(bytes, i)?\n+    }\n+}\n+\n+/// Like a `Table` but using `DefIndex` instead of `usize` as keys.\n+// FIXME(eddyb) replace by making `Table` behave like `IndexVec`,\n+// and by using `newtype_index!` to define `DefIndex`.\n+crate struct PerDefTable<T>(Table<T>) where Option<T>: FixedSizeEncoding;\n+\n+impl<T> Default for PerDefTable<T> where Option<T>: FixedSizeEncoding {\n+    fn default() -> Self {\n+        PerDefTable(Table::default())\n+    }\n+}\n+\n+impl<T> PerDefTable<T> where Option<T>: FixedSizeEncoding {\n+    crate fn set(&mut self, def_id: DefId, value: T) {\n+        assert!(def_id.is_local());\n+        self.0.set(def_id.index.index(), value);\n+    }\n+\n+    crate fn encode(&self, buf: &mut Encoder) -> Lazy<Self> {\n+        let lazy = self.0.encode(buf);\n+        Lazy::from_position_and_meta(lazy.position, lazy.meta)\n+    }\n+}\n+\n+impl<T> LazyMeta for PerDefTable<T> where Option<T>: FixedSizeEncoding {\n+    type Meta = <Table<T> as LazyMeta>::Meta;\n+\n+    fn min_size(meta: Self::Meta) -> usize {\n+        Table::<T>::min_size(meta)\n+    }\n+}\n+\n+impl<T> Lazy<PerDefTable<T>> where Option<T>: FixedSizeEncoding {\n+    fn as_table(&self) -> Lazy<Table<T>> {\n+        Lazy::from_position_and_meta(self.position, self.meta)\n+    }\n+\n+    /// Given the metadata, extract out the value at a particular DefIndex (if any).\n+    #[inline(never)]\n+    crate fn get<'a, 'tcx, M: Metadata<'a, 'tcx>>(\n+        &self,\n+        metadata: M,\n+        def_index: DefIndex,\n+    ) -> Option<T> {\n+        self.as_table().get(metadata, def_index.index())\n+    }\n+}"}]}