{"sha": "c019002d17185f4e8be54a978ab5d67bc632f518", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMwMTkwMDJkMTcxODVmNGU4YmU1NGE5NzhhYjVkNjdiYzYzMmY1MTg=", "commit": {"author": {"name": "Jonas Schievink", "email": "jonas.schievink@ferrous-systems.com", "date": "2020-06-23T17:42:19Z"}, "committer": {"name": "Jonas Schievink", "email": "jonas.schievink@ferrous-systems.com", "date": "2020-06-24T14:53:56Z"}, "message": "Slightly reduce ItemTree memory footprint", "tree": {"sha": "dcc7bbb30e35b179f53c8198835999d9166882b9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dcc7bbb30e35b179f53c8198835999d9166882b9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c019002d17185f4e8be54a978ab5d67bc632f518", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c019002d17185f4e8be54a978ab5d67bc632f518", "html_url": "https://github.com/rust-lang/rust/commit/c019002d17185f4e8be54a978ab5d67bc632f518", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c019002d17185f4e8be54a978ab5d67bc632f518/comments", "author": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f9a1a9cd3c7757ca3f8ba59287b5d36645008b9b", "url": "https://api.github.com/repos/rust-lang/rust/commits/f9a1a9cd3c7757ca3f8ba59287b5d36645008b9b", "html_url": "https://github.com/rust-lang/rust/commit/f9a1a9cd3c7757ca3f8ba59287b5d36645008b9b"}], "stats": {"total": 121, "additions": 68, "deletions": 53}, "files": [{"sha": "197737ffce287dd7d191a98759ff83ac22acd46b", "filename": "crates/ra_hir_def/src/attr.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c019002d17185f4e8be54a978ab5d67bc632f518/crates%2Fra_hir_def%2Fsrc%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c019002d17185f4e8be54a978ab5d67bc632f518/crates%2Fra_hir_def%2Fsrc%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fattr.rs?ref=c019002d17185f4e8be54a978ab5d67bc632f518", "patch": "@@ -38,6 +38,8 @@ impl ops::Deref for Attrs {\n }\n \n impl Attrs {\n+    pub const EMPTY: Attrs = Attrs { entries: None };\n+\n     pub(crate) fn attrs_query(db: &dyn DefDatabase, def: AttrDefId) -> Attrs {\n         match def {\n             AttrDefId::ModuleId(module) => {"}, {"sha": "d55b3f77726c2efb128d3abbb7d750df8090a652", "filename": "crates/ra_hir_def/src/item_tree.rs", "status": "modified", "additions": 39, "deletions": 34, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/c019002d17185f4e8be54a978ab5d67bc632f518/crates%2Fra_hir_def%2Fsrc%2Fitem_tree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c019002d17185f4e8be54a978ab5d67bc632f518/crates%2Fra_hir_def%2Fsrc%2Fitem_tree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fitem_tree.rs?ref=c019002d17185f4e8be54a978ab5d67bc632f518", "patch": "@@ -35,16 +35,8 @@ use crate::{\n };\n use smallvec::SmallVec;\n \n-/// The item tree of a source file.\n-#[derive(Debug, Eq, PartialEq)]\n-pub struct ItemTree {\n-    file_id: HirFileId,\n-    top_level: Vec<ModItem>,\n-    top_attrs: Attrs,\n-    attrs: FxHashMap<ModItem, Attrs>,\n-    empty_attrs: Attrs,\n-    inner_items: FxHashMap<FileAstId<ast::ModuleItem>, SmallVec<[ModItem; 1]>>,\n-\n+#[derive(Default, Debug, Eq, PartialEq)]\n+struct ItemTreeData {\n     imports: Arena<Import>,\n     extern_crates: Arena<ExternCrate>,\n     functions: Arena<Function>,\n@@ -63,6 +55,26 @@ pub struct ItemTree {\n     exprs: Arena<Expr>,\n }\n \n+#[derive(Debug, Eq, PartialEq, Hash)]\n+enum AttrOwner {\n+    /// Attributes on an item.\n+    ModItem(ModItem),\n+    /// Inner attributes of the source file.\n+    TopLevel,\n+    // FIXME: Store variant and field attrs, and stop reparsing them in `attrs_query`.\n+}\n+\n+/// The item tree of a source file.\n+#[derive(Debug, Eq, PartialEq)]\n+pub struct ItemTree {\n+    file_id: HirFileId,\n+    top_level: SmallVec<[ModItem; 1]>,\n+    attrs: FxHashMap<AttrOwner, Attrs>,\n+    inner_items: FxHashMap<FileAstId<ast::ModuleItem>, SmallVec<[ModItem; 1]>>,\n+\n+    data: Option<Box<ItemTreeData>>,\n+}\n+\n impl ItemTree {\n     pub fn item_tree_query(db: &dyn DefDatabase, file_id: HirFileId) -> Arc<ItemTree> {\n         let _p = ra_prof::profile(\"item_tree_query\").detail(|| format!(\"{:?}\", file_id));\n@@ -95,34 +107,19 @@ impl ItemTree {\n             }\n         };\n \n-        item_tree.top_attrs = top_attrs.unwrap_or_default();\n+        if let Some(attrs) = top_attrs {\n+            item_tree.attrs.insert(AttrOwner::TopLevel, attrs);\n+        }\n         Arc::new(item_tree)\n     }\n \n     fn empty(file_id: HirFileId) -> Self {\n         Self {\n             file_id,\n             top_level: Default::default(),\n-            top_attrs: Default::default(),\n             attrs: Default::default(),\n-            empty_attrs: Default::default(),\n             inner_items: Default::default(),\n-            imports: Default::default(),\n-            extern_crates: Default::default(),\n-            functions: Default::default(),\n-            structs: Default::default(),\n-            fields: Default::default(),\n-            unions: Default::default(),\n-            enums: Default::default(),\n-            variants: Default::default(),\n-            consts: Default::default(),\n-            statics: Default::default(),\n-            traits: Default::default(),\n-            impls: Default::default(),\n-            type_aliases: Default::default(),\n-            mods: Default::default(),\n-            macro_calls: Default::default(),\n-            exprs: Default::default(),\n+            data: Default::default(),\n         }\n     }\n \n@@ -134,11 +131,11 @@ impl ItemTree {\n \n     /// Returns the inner attributes of the source file.\n     pub fn top_level_attrs(&self) -> &Attrs {\n-        &self.top_attrs\n+        self.attrs.get(&AttrOwner::TopLevel).unwrap_or(&Attrs::EMPTY)\n     }\n \n     pub fn attrs(&self, of: ModItem) -> &Attrs {\n-        self.attrs.get(&of).unwrap_or(&self.empty_attrs)\n+        self.attrs.get(&AttrOwner::ModItem(of)).unwrap_or(&Attrs::EMPTY)\n     }\n \n     /// Returns the lowered inner items that `ast` corresponds to.\n@@ -169,6 +166,14 @@ impl ItemTree {\n         let ptr = map.get(id);\n         ptr.to_node(&root)\n     }\n+\n+    fn data(&self) -> &ItemTreeData {\n+        self.data.as_ref().expect(\"attempted to access data of empty ItemTree\")\n+    }\n+\n+    fn data_mut(&mut self) -> &mut ItemTreeData {\n+        self.data.get_or_insert_with(Box::default)\n+    }\n }\n \n /// Trait implemented by all nodes in the item tree.\n@@ -246,7 +251,7 @@ macro_rules! mod_items {\n                 }\n \n                 fn lookup(tree: &ItemTree, index: Idx<Self>) -> &Self {\n-                    &tree.$fld[index]\n+                    &tree.data().$fld[index]\n                 }\n \n                 fn id_from_mod_item(mod_item: ModItem) -> Option<FileItemTreeId<Self>> {\n@@ -266,7 +271,7 @@ macro_rules! mod_items {\n                 type Output = $typ;\n \n                 fn index(&self, index: Idx<$typ>) -> &Self::Output {\n-                    &self.$fld[index]\n+                    &self.data().$fld[index]\n                 }\n             }\n         )+\n@@ -296,7 +301,7 @@ macro_rules! impl_index {\n                 type Output = $t;\n \n                 fn index(&self, index: Idx<$t>) -> &Self::Output {\n-                    &self.$fld[index]\n+                    &self.data().$fld[index]\n                 }\n             }\n         )+"}, {"sha": "7d28fe7c6564182c1ffd096638c9185521777247", "filename": "crates/ra_hir_def/src/item_tree/lower.rs", "status": "modified", "additions": 27, "deletions": 19, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/c019002d17185f4e8be54a978ab5d67bc632f518/crates%2Fra_hir_def%2Fsrc%2Fitem_tree%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c019002d17185f4e8be54a978ab5d67bc632f518/crates%2Fra_hir_def%2Fsrc%2Fitem_tree%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fitem_tree%2Flower.rs?ref=c019002d17185f4e8be54a978ab5d67bc632f518", "patch": "@@ -66,6 +66,10 @@ impl Ctx {\n         self.tree\n     }\n \n+    fn data(&mut self) -> &mut ItemTreeData {\n+        self.tree.data_mut()\n+    }\n+\n     fn lower_mod_item(&mut self, item: &ast::ModuleItem, inner: bool) -> Option<ModItems> {\n         assert!(inner || self.inner_items.is_empty());\n \n@@ -124,7 +128,7 @@ impl Ctx {\n     }\n \n     fn add_attrs(&mut self, item: ModItem, attrs: Attrs) {\n-        match self.tree.attrs.entry(item) {\n+        match self.tree.attrs.entry(AttrOwner::ModItem(item)) {\n             Entry::Occupied(mut entry) => {\n                 *entry.get_mut() = entry.get().merge(attrs);\n             }\n@@ -169,7 +173,7 @@ impl Ctx {\n             ast::StructKind::Unit => StructDefKind::Unit,\n         };\n         let res = Struct { name, visibility, generic_params, fields, ast_id, kind };\n-        Some(id(self.tree.structs.alloc(res)))\n+        Some(id(self.data().structs.alloc(res)))\n     }\n \n     fn lower_fields(&mut self, strukt_kind: &ast::StructKind) -> Fields {\n@@ -190,7 +194,7 @@ impl Ctx {\n         let start = self.next_field_idx();\n         for field in fields.fields() {\n             if let Some(data) = self.lower_record_field(&field) {\n-                self.tree.fields.alloc(data);\n+                self.data().fields.alloc(data);\n             }\n         }\n         let end = self.next_field_idx();\n@@ -209,7 +213,7 @@ impl Ctx {\n         let start = self.next_field_idx();\n         for (i, field) in fields.fields().enumerate() {\n             if let Some(data) = self.lower_tuple_field(i, &field) {\n-                self.tree.fields.alloc(data);\n+                self.data().fields.alloc(data);\n             }\n         }\n         let end = self.next_field_idx();\n@@ -236,7 +240,7 @@ impl Ctx {\n         };\n         let ast_id = self.source_ast_id_map.ast_id(union);\n         let res = Union { name, visibility, generic_params, fields, ast_id };\n-        Some(id(self.tree.unions.alloc(res)))\n+        Some(id(self.data().unions.alloc(res)))\n     }\n \n     fn lower_enum(&mut self, enum_: &ast::EnumDef) -> Option<FileItemTreeId<Enum>> {\n@@ -249,14 +253,14 @@ impl Ctx {\n         };\n         let ast_id = self.source_ast_id_map.ast_id(enum_);\n         let res = Enum { name, visibility, generic_params, variants, ast_id };\n-        Some(id(self.tree.enums.alloc(res)))\n+        Some(id(self.data().enums.alloc(res)))\n     }\n \n     fn lower_variants(&mut self, variants: &ast::EnumVariantList) -> Range<Idx<Variant>> {\n         let start = self.next_variant_idx();\n         for variant in variants.variants() {\n             if let Some(data) = self.lower_variant(&variant) {\n-                self.tree.variants.alloc(data);\n+                self.data().variants.alloc(data);\n             }\n         }\n         let end = self.next_variant_idx();\n@@ -327,7 +331,7 @@ impl Ctx {\n         };\n         res.generic_params = self.lower_generic_params(GenericsOwner::Function(&res), func);\n \n-        Some(id(self.tree.functions.alloc(res)))\n+        Some(id(self.data().functions.alloc(res)))\n     }\n \n     fn lower_type_alias(\n@@ -341,7 +345,7 @@ impl Ctx {\n         let generic_params = self.lower_generic_params(GenericsOwner::TypeAlias, type_alias);\n         let ast_id = self.source_ast_id_map.ast_id(type_alias);\n         let res = TypeAlias { name, visibility, bounds, generic_params, type_ref, ast_id };\n-        Some(id(self.tree.type_aliases.alloc(res)))\n+        Some(id(self.data().type_aliases.alloc(res)))\n     }\n \n     fn lower_static(&mut self, static_: &ast::StaticDef) -> Option<FileItemTreeId<Static>> {\n@@ -351,7 +355,7 @@ impl Ctx {\n         let mutable = static_.mut_token().is_some();\n         let ast_id = self.source_ast_id_map.ast_id(static_);\n         let res = Static { name, visibility, mutable, type_ref, ast_id };\n-        Some(id(self.tree.statics.alloc(res)))\n+        Some(id(self.data().statics.alloc(res)))\n     }\n \n     fn lower_const(&mut self, konst: &ast::ConstDef) -> FileItemTreeId<Const> {\n@@ -360,7 +364,7 @@ impl Ctx {\n         let visibility = self.lower_visibility(konst);\n         let ast_id = self.source_ast_id_map.ast_id(konst);\n         let res = Const { name, visibility, type_ref, ast_id };\n-        id(self.tree.consts.alloc(res))\n+        id(self.data().consts.alloc(res))\n     }\n \n     fn lower_module(&mut self, module: &ast::Module) -> Option<FileItemTreeId<Mod>> {\n@@ -386,7 +390,7 @@ impl Ctx {\n         };\n         let ast_id = self.source_ast_id_map.ast_id(module);\n         let res = Mod { name, visibility, kind, ast_id };\n-        Some(id(self.tree.mods.alloc(res)))\n+        Some(id(self.data().mods.alloc(res)))\n     }\n \n     fn lower_trait(&mut self, trait_def: &ast::TraitDef) -> Option<FileItemTreeId<Trait>> {\n@@ -417,7 +421,7 @@ impl Ctx {\n             items: items.unwrap_or_default(),\n             ast_id,\n         };\n-        Some(id(self.tree.traits.alloc(res)))\n+        Some(id(self.data().traits.alloc(res)))\n     }\n \n     fn lower_impl(&mut self, impl_def: &ast::ImplDef) -> Option<FileItemTreeId<Impl>> {\n@@ -440,7 +444,7 @@ impl Ctx {\n             .collect();\n         let ast_id = self.source_ast_id_map.ast_id(impl_def);\n         let res = Impl { generic_params, target_trait, target_type, is_negative, items, ast_id };\n-        Some(id(self.tree.impls.alloc(res)))\n+        Some(id(self.data().impls.alloc(res)))\n     }\n \n     fn lower_use(&mut self, use_item: &ast::UseItem) -> Vec<FileItemTreeId<Import>> {\n@@ -451,7 +455,7 @@ impl Ctx {\n \n         // Every use item can expand to many `Import`s.\n         let mut imports = Vec::new();\n-        let tree = &mut self.tree;\n+        let tree = self.tree.data_mut();\n         ModPath::expand_use_item(\n             InFile::new(self.file, use_item.clone()),\n             &self.hygiene,\n@@ -484,7 +488,7 @@ impl Ctx {\n         let is_macro_use = extern_crate.has_atom_attr(\"macro_use\");\n \n         let res = ExternCrate { path, alias, visibility, is_macro_use, ast_id };\n-        Some(id(self.tree.extern_crates.alloc(res)))\n+        Some(id(self.data().extern_crates.alloc(res)))\n     }\n \n     fn lower_macro_call(&mut self, m: &ast::MacroCall) -> Option<FileItemTreeId<MacroCall>> {\n@@ -511,7 +515,7 @@ impl Ctx {\n \n         let is_builtin = attrs.by_key(\"rustc_builtin_macro\").exists();\n         let res = MacroCall { name, path, is_export, is_builtin, is_local_inner, ast_id };\n-        Some(id(self.tree.macro_calls.alloc(res)))\n+        Some(id(self.data().macro_calls.alloc(res)))\n     }\n \n     fn lower_extern_block(&mut self, block: &ast::ExternBlock) -> Vec<ModItem> {\n@@ -619,10 +623,14 @@ impl Ctx {\n     }\n \n     fn next_field_idx(&self) -> Idx<Field> {\n-        Idx::from_raw(RawId::from(self.tree.fields.len() as u32))\n+        Idx::from_raw(RawId::from(\n+            self.tree.data.as_ref().map_or(0, |data| data.fields.len() as u32),\n+        ))\n     }\n     fn next_variant_idx(&self) -> Idx<Variant> {\n-        Idx::from_raw(RawId::from(self.tree.variants.len() as u32))\n+        Idx::from_raw(RawId::from(\n+            self.tree.data.as_ref().map_or(0, |data| data.variants.len() as u32),\n+        ))\n     }\n }\n "}]}