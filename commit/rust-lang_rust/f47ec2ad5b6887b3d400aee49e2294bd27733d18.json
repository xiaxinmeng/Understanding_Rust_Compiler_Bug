{"sha": "f47ec2ad5b6887b3d400aee49e2294bd27733d18", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY0N2VjMmFkNWI2ODg3YjNkNDAwYWVlNDllMjI5NGJkMjc3MzNkMTg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-02-14T10:32:25Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-02-14T10:32:25Z"}, "message": "Auto merge of #58455 - Centril:rollup, r=Centril\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #58309 (Add more profiler events)\n - #58347 (Closure bounds fixes)\n - #58365 (Add an option to print the status of incremental tasks / dep nodes after running them)\n - #58371 (Check user type annotations for range patterns.)\n - #58378 (rustc: Implement incremental \"fat\" LTO)\n - #58407 (specify \"upper camel case\" in style lint)\n - #58449 (Notify @topecongiro when the state of rustfmt has changed)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "8888f8d17504ecad6033bd1992efeb9e04145f93", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8888f8d17504ecad6033bd1992efeb9e04145f93"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f47ec2ad5b6887b3d400aee49e2294bd27733d18", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f47ec2ad5b6887b3d400aee49e2294bd27733d18", "html_url": "https://github.com/rust-lang/rust/commit/f47ec2ad5b6887b3d400aee49e2294bd27733d18", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f47ec2ad5b6887b3d400aee49e2294bd27733d18/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c67d4749a547a0c937e257ad9e0248075178ddc4", "url": "https://api.github.com/repos/rust-lang/rust/commits/c67d4749a547a0c937e257ad9e0248075178ddc4", "html_url": "https://github.com/rust-lang/rust/commit/c67d4749a547a0c937e257ad9e0248075178ddc4"}, {"sha": "410b4456ca52b6e90259d4aaf04376d862ad36d3", "url": "https://api.github.com/repos/rust-lang/rust/commits/410b4456ca52b6e90259d4aaf04376d862ad36d3", "html_url": "https://github.com/rust-lang/rust/commit/410b4456ca52b6e90259d4aaf04376d862ad36d3"}], "stats": {"total": 1312, "additions": 885, "deletions": 427}, "files": [{"sha": "8a2f79e6793c0c8295385f6546fa72aefaba9ee7", "filename": "src/librustc/dep_graph/graph.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f47ec2ad5b6887b3d400aee49e2294bd27733d18/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f47ec2ad5b6887b3d400aee49e2294bd27733d18/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fgraph.rs?ref=f47ec2ad5b6887b3d400aee49e2294bd27733d18", "patch": "@@ -292,17 +292,28 @@ impl DepGraph {\n                 task_deps.map(|lock| lock.into_inner()),\n             );\n \n+            let print_status = cfg!(debug_assertions) && hcx.sess().opts.debugging_opts.dep_tasks;\n+\n             // Determine the color of the new DepNode.\n             if let Some(prev_index) = data.previous.node_to_index_opt(&key) {\n                 let prev_fingerprint = data.previous.fingerprint_by_index(prev_index);\n \n                 let color = if let Some(current_fingerprint) = current_fingerprint {\n                     if current_fingerprint == prev_fingerprint {\n+                        if print_status {\n+                            eprintln!(\"[task::green] {:?}\", key);\n+                        }\n                         DepNodeColor::Green(dep_node_index)\n                     } else {\n+                        if print_status {\n+                            eprintln!(\"[task::red] {:?}\", key);\n+                        }\n                         DepNodeColor::Red\n                     }\n                 } else {\n+                    if print_status {\n+                        eprintln!(\"[task::unknown] {:?}\", key);\n+                    }\n                     // Mark the node as Red if we can't hash the result\n                     DepNodeColor::Red\n                 };\n@@ -312,6 +323,10 @@ impl DepGraph {\n                             insertion for {:?}\", key);\n \n                 data.colors.insert(prev_index, color);\n+            } else {\n+                if print_status {\n+                    eprintln!(\"[task::new] {:?}\", key);\n+                }\n             }\n \n             (result, dep_node_index)"}, {"sha": "d995fe92337c4f66d398b0bedaaf14f7f8db817d", "filename": "src/librustc/infer/error_reporting/nice_region_error/mod.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f47ec2ad5b6887b3d400aee49e2294bd27733d18/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f47ec2ad5b6887b3d400aee49e2294bd27733d18/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmod.rs?ref=f47ec2ad5b6887b3d400aee49e2294bd27733d18", "patch": "@@ -1,9 +1,10 @@\n use crate::infer::InferCtxt;\n use crate::infer::lexical_region_resolve::RegionResolutionError;\n use crate::infer::lexical_region_resolve::RegionResolutionError::*;\n-use syntax::source_map::Span;\n use crate::ty::{self, TyCtxt};\n use crate::util::common::ErrorReported;\n+use errors::DiagnosticBuilder;\n+use syntax::source_map::Span;\n \n mod different_lifetimes;\n mod find_anon_type;\n@@ -59,7 +60,7 @@ impl<'cx, 'gcx, 'tcx> NiceRegionError<'cx, 'gcx, 'tcx> {\n         self.infcx.tcx\n     }\n \n-    pub fn try_report_from_nll(&self) -> Option<ErrorReported> {\n+    pub fn try_report_from_nll(&self) -> Option<DiagnosticBuilder<'cx>> {\n         // Due to the improved diagnostics returned by the MIR borrow checker, only a subset of\n         // the nice region errors are required when running under the MIR borrow checker.\n         self.try_report_named_anon_conflict()\n@@ -68,6 +69,7 @@ impl<'cx, 'gcx, 'tcx> NiceRegionError<'cx, 'gcx, 'tcx> {\n \n     pub fn try_report(&self) -> Option<ErrorReported> {\n         self.try_report_from_nll()\n+            .map(|mut diag| { diag.emit(); ErrorReported })\n             .or_else(|| self.try_report_anon_anon_conflict())\n             .or_else(|| self.try_report_outlives_closure())\n             .or_else(|| self.try_report_static_impl_trait())"}, {"sha": "3821484d38e5f9bd291d33d2f79bd6eaca568988", "filename": "src/librustc/infer/error_reporting/nice_region_error/named_anon_conflict.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/f47ec2ad5b6887b3d400aee49e2294bd27733d18/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f47ec2ad5b6887b3d400aee49e2294bd27733d18/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs?ref=f47ec2ad5b6887b3d400aee49e2294bd27733d18", "patch": "@@ -2,13 +2,12 @@\n //! where one region is named and the other is anonymous.\n use crate::infer::error_reporting::nice_region_error::NiceRegionError;\n use crate::ty;\n-use crate::util::common::ErrorReported;\n-use errors::Applicability;\n+use errors::{Applicability, DiagnosticBuilder};\n \n impl<'a, 'gcx, 'tcx> NiceRegionError<'a, 'gcx, 'tcx> {\n     /// When given a `ConcreteFailure` for a function with arguments containing a named region and\n     /// an anonymous region, emit an descriptive diagnostic error.\n-    pub(super) fn try_report_named_anon_conflict(&self) -> Option<ErrorReported> {\n+    pub(super) fn try_report_named_anon_conflict(&self) -> Option<DiagnosticBuilder<'a>> {\n         let (span, sub, sup) = self.get_regions();\n \n         debug!(\n@@ -96,21 +95,23 @@ impl<'a, 'gcx, 'tcx> NiceRegionError<'a, 'gcx, 'tcx> {\n             (\"parameter type\".to_owned(), \"type\".to_owned())\n         };\n \n-        struct_span_err!(\n+        let mut diag = struct_span_err!(\n             self.tcx().sess,\n             span,\n             E0621,\n             \"explicit lifetime required in {}\",\n             error_var\n-        ).span_suggestion(\n-            new_ty_span,\n-            &format!(\"add explicit lifetime `{}` to {}\", named, span_label_var),\n-            new_ty.to_string(),\n-            Applicability::Unspecified,\n-        )\n-        .span_label(span, format!(\"lifetime `{}` required\", named))\n-        .emit();\n-        return Some(ErrorReported);\n+        );\n+\n+        diag.span_suggestion(\n+                new_ty_span,\n+                &format!(\"add explicit lifetime `{}` to {}\", named, span_label_var),\n+                new_ty.to_string(),\n+                Applicability::Unspecified,\n+            )\n+            .span_label(span, format!(\"lifetime `{}` required\", named));\n+\n+        Some(diag)\n     }\n \n     // This method returns whether the given Region is Named"}, {"sha": "3b2fb7d41008e55ca2d3077876ffa6f87d13e5a6", "filename": "src/librustc/infer/error_reporting/nice_region_error/placeholder_error.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f47ec2ad5b6887b3d400aee49e2294bd27733d18/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f47ec2ad5b6887b3d400aee49e2294bd27733d18/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs?ref=f47ec2ad5b6887b3d400aee49e2294bd27733d18", "patch": "@@ -8,13 +8,12 @@ use crate::traits::{ObligationCause, ObligationCauseCode};\n use crate::ty;\n use crate::ty::error::ExpectedFound;\n use crate::ty::subst::Substs;\n-use crate::util::common::ErrorReported;\n use crate::util::ppaux::RegionHighlightMode;\n \n impl NiceRegionError<'me, 'gcx, 'tcx> {\n     /// When given a `ConcreteFailure` for a function with arguments containing a named region and\n     /// an anonymous region, emit a descriptive diagnostic error.\n-    pub(super) fn try_report_placeholder_conflict(&self) -> Option<ErrorReported> {\n+    pub(super) fn try_report_placeholder_conflict(&self) -> Option<DiagnosticBuilder<'me>> {\n         match &self.error {\n             ///////////////////////////////////////////////////////////////////////////\n             // NB. The ordering of cases in this match is very\n@@ -178,7 +177,7 @@ impl NiceRegionError<'me, 'gcx, 'tcx> {\n         trait_def_id: DefId,\n         expected_substs: &'tcx Substs<'tcx>,\n         actual_substs: &'tcx Substs<'tcx>,\n-    ) -> ErrorReported {\n+    ) -> DiagnosticBuilder<'me> {\n         debug!(\n             \"try_report_placeholders_trait(\\\n              vid={:?}, \\\n@@ -295,8 +294,7 @@ impl NiceRegionError<'me, 'gcx, 'tcx> {\n             any_self_ty_has_vid,\n         );\n \n-        err.emit();\n-        ErrorReported\n+        err\n     }\n \n     /// Add notes with details about the expected and actual trait refs, with attention to cases"}, {"sha": "65da458efbfff3ee3249caa9f735c129dfe4e758", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f47ec2ad5b6887b3d400aee49e2294bd27733d18/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f47ec2ad5b6887b3d400aee49e2294bd27733d18/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=f47ec2ad5b6887b3d400aee49e2294bd27733d18", "patch": "@@ -1237,6 +1237,8 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n         \"show extended diagnostic help\"),\n     continue_parse_after_error: bool = (false, parse_bool, [TRACKED],\n         \"attempt to recover from parse errors (experimental)\"),\n+    dep_tasks: bool = (false, parse_bool, [UNTRACKED],\n+        \"print tasks that execute and the color their dep node gets (requires debug build)\"),\n     incremental: Option<String> = (None, parse_opt_string, [UNTRACKED],\n         \"enable incremental compilation (experimental)\"),\n     incremental_queries: bool = (true, parse_bool, [UNTRACKED],"}, {"sha": "833785f04076cb8c142ef4eedc28bbef7d32531a", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 1, "deletions": 15, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f47ec2ad5b6887b3d400aee49e2294bd27733d18/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f47ec2ad5b6887b3d400aee49e2294bd27733d18/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=f47ec2ad5b6887b3d400aee49e2294bd27733d18", "patch": "@@ -9,7 +9,7 @@ use crate::lint;\n use crate::lint::builtin::BuiltinLintDiagnostics;\n use crate::middle::allocator::AllocatorKind;\n use crate::middle::dependency_format;\n-use crate::session::config::{OutputType, Lto};\n+use crate::session::config::OutputType;\n use crate::session::search_paths::{PathKind, SearchPath};\n use crate::util::nodemap::{FxHashMap, FxHashSet};\n use crate::util::common::{duration_to_secs_str, ErrorReported};\n@@ -1246,20 +1246,6 @@ pub fn build_session_(\n // If it is useful to have a Session available already for validating a\n // commandline argument, you can do so here.\n fn validate_commandline_args_with_session_available(sess: &Session) {\n-\n-    if sess.opts.incremental.is_some() {\n-        match sess.lto() {\n-            Lto::Thin |\n-            Lto::Fat => {\n-                sess.err(\"can't perform LTO when compiling incrementally\");\n-            }\n-            Lto::ThinLocal |\n-            Lto::No => {\n-                // This is fine\n-            }\n-        }\n-    }\n-\n     // Since we don't know if code in an rlib will be linked to statically or\n     // dynamically downstream, rustc generates `__imp_` symbols that help the\n     // MSVC linker deal with this lack of knowledge (#27438). Unfortunately,"}, {"sha": "19b39be8a4ddff0c1404ab9fd63ee52de58cb941", "filename": "src/librustc/ty/query/plumbing.rs", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/f47ec2ad5b6887b3d400aee49e2294bd27733d18/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f47ec2ad5b6887b3d400aee49e2294bd27733d18/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs?ref=f47ec2ad5b6887b3d400aee49e2294bd27733d18", "patch": "@@ -124,7 +124,15 @@ impl<'a, 'tcx, Q: QueryDescription<'tcx>> JobOwner<'a, 'tcx, Q> {\n             let job = match lock.active.entry((*key).clone()) {\n                 Entry::Occupied(entry) => {\n                     match *entry.get() {\n-                        QueryResult::Started(ref job) => job.clone(),\n+                        QueryResult::Started(ref job) => {\n+                            //For parallel queries, we'll block and wait until the query running\n+                            //in another thread has completed. Record how long we wait in the\n+                            //self-profiler\n+                            #[cfg(parallel_compiler)]\n+                            tcx.sess.profiler(|p| p.query_blocked_start(Q::NAME, Q::CATEGORY));\n+\n+                            job.clone()\n+                        },\n                         QueryResult::Poisoned => FatalError.raise(),\n                     }\n                 }\n@@ -160,7 +168,10 @@ impl<'a, 'tcx, Q: QueryDescription<'tcx>> JobOwner<'a, 'tcx, Q> {\n             // thread\n             #[cfg(parallel_compiler)]\n             {\n-                if let Err(cycle) = job.r#await(tcx, span) {\n+                let result = job.r#await(tcx, span);\n+                tcx.sess.profiler(|p| p.query_blocked_end(Q::NAME, Q::CATEGORY));\n+\n+                if let Err(cycle) = result {\n                     return TryGetJob::JobCompleted(Err(cycle));\n                 }\n             }\n@@ -441,7 +452,9 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         // First we try to load the result from the on-disk cache\n         let result = if Q::cache_on_disk(self.global_tcx(), key.clone()) &&\n                         self.sess.opts.debugging_opts.incremental_queries {\n+            self.sess.profiler(|p| p.incremental_load_result_start(Q::NAME));\n             let result = Q::try_load_from_disk(self.global_tcx(), prev_dep_node_index);\n+            self.sess.profiler(|p| p.incremental_load_result_end(Q::NAME));\n \n             // We always expect to find a cached result for things that\n             // can be forced from DepNode."}, {"sha": "c90bd12a3100f27ed3dffc933297c24cc35d39ba", "filename": "src/librustc/util/profiling.rs", "status": "modified", "additions": 57, "deletions": 18, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/f47ec2ad5b6887b3d400aee49e2294bd27733d18/src%2Flibrustc%2Futil%2Fprofiling.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f47ec2ad5b6887b3d400aee49e2294bd27733d18/src%2Flibrustc%2Futil%2Fprofiling.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fprofiling.rs?ref=f47ec2ad5b6887b3d400aee49e2294bd27733d18", "patch": "@@ -25,16 +25,28 @@ pub enum ProfilerEvent {\n     GenericActivityEnd { category: ProfileCategory, time: Instant },\n     QueryCacheHit { query_name: &'static str, category: ProfileCategory },\n     QueryCount { query_name: &'static str, category: ProfileCategory, count: usize },\n+    IncrementalLoadResultStart { query_name: &'static str, time: Instant },\n+    IncrementalLoadResultEnd { query_name: &'static str, time: Instant },\n+    QueryBlockedStart { query_name: &'static str, category: ProfileCategory, time: Instant },\n+    QueryBlockedEnd { query_name: &'static str, category: ProfileCategory, time: Instant },\n }\n \n impl ProfilerEvent {\n     fn is_start_event(&self) -> bool {\n         use self::ProfilerEvent::*;\n \n         match self {\n-            QueryStart { .. } | GenericActivityStart { .. } => true,\n-            QueryEnd { .. } | GenericActivityEnd { .. } |\n-            QueryCacheHit { .. } | QueryCount { .. } => false,\n+            QueryStart { .. } |\n+            GenericActivityStart { .. } |\n+            IncrementalLoadResultStart { .. } |\n+            QueryBlockedStart { .. } => true,\n+\n+            QueryEnd { .. } |\n+            GenericActivityEnd { .. } |\n+            QueryCacheHit { .. } |\n+            QueryCount { .. } |\n+            IncrementalLoadResultEnd { .. } |\n+            QueryBlockedEnd { .. } => false,\n         }\n     }\n }\n@@ -57,12 +69,7 @@ impl CategoryResultData {\n     }\n \n     fn total_time(&self) -> u64 {\n-        let mut total = 0;\n-        for (_, time) in &self.query_times {\n-            total += time;\n-        }\n-\n-        total\n+        self.query_times.iter().map(|(_, time)| time).sum()\n     }\n \n     fn total_cache_data(&self) -> (u64, u64) {\n@@ -121,13 +128,7 @@ impl CalculatedResults {\n     }\n \n     fn total_time(&self) -> u64 {\n-        let mut total = 0;\n-\n-        for (_, data) in &self.categories {\n-            total += data.total_time();\n-        }\n-\n-        total\n+        self.categories.iter().map(|(_, data)| data.total_time()).sum()\n     }\n \n     fn with_options(mut self, opts: &Options) -> CalculatedResults {\n@@ -225,6 +226,40 @@ impl SelfProfiler {\n         })\n     }\n \n+    #[inline]\n+    pub fn incremental_load_result_start(&mut self, query_name: &'static str) {\n+        self.record(ProfilerEvent::IncrementalLoadResultStart {\n+            query_name,\n+            time: Instant::now(),\n+        })\n+    }\n+\n+    #[inline]\n+    pub fn incremental_load_result_end(&mut self, query_name: &'static str) {\n+        self.record(ProfilerEvent::IncrementalLoadResultEnd {\n+            query_name,\n+            time: Instant::now(),\n+        })\n+    }\n+\n+    #[inline]\n+    pub fn query_blocked_start(&mut self, query_name: &'static str, category: ProfileCategory) {\n+        self.record(ProfilerEvent::QueryBlockedStart {\n+            query_name,\n+            category,\n+            time: Instant::now(),\n+        })\n+    }\n+\n+    #[inline]\n+    pub fn query_blocked_end(&mut self, query_name: &'static str, category: ProfileCategory) {\n+        self.record(ProfilerEvent::QueryBlockedEnd {\n+            query_name,\n+            category,\n+            time: Instant::now(),\n+        })\n+    }\n+\n     #[inline]\n     fn record(&mut self, event: ProfilerEvent) {\n         let thread_id = std::thread::current().id();\n@@ -317,6 +352,10 @@ impl SelfProfiler {\n                         result_data.query_cache_stats.entry(query_name).or_insert((0, 0));\n                     *totals += *count as u64;\n                 },\n+                //we don't summarize incremental load result events in the simple output mode\n+                IncrementalLoadResultStart { .. } | IncrementalLoadResultEnd { .. } => { },\n+                //we don't summarize parallel query blocking in the simple output mode\n+                QueryBlockedStart { .. } | QueryBlockedEnd { .. } => { },\n             }\n         }\n \n@@ -361,9 +400,9 @@ impl SelfProfiler {\n             .unwrap();\n \n         let mut categories: Vec<_> = results.categories.iter().collect();\n-        categories.sort_by(|(_, data1), (_, data2)| data2.total_time().cmp(&data1.total_time()));\n+        categories.sort_by_cached_key(|(_, d)| d.total_time());\n \n-        for (category, data) in categories {\n+        for (category, data) in categories.iter().rev() {\n             let (category_hits, category_total) = data.total_cache_data();\n             let category_hit_percent = calculate_percent(category_hits, category_total);\n "}, {"sha": "fc3ab7f734a794b04d85b25e1804b6172b043597", "filename": "src/librustc_codegen_llvm/back/lto.rs", "status": "modified", "additions": 101, "deletions": 38, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/f47ec2ad5b6887b3d400aee49e2294bd27733d18/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f47ec2ad5b6887b3d400aee49e2294bd27733d18/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs?ref=f47ec2ad5b6887b3d400aee49e2294bd27733d18", "patch": "@@ -1,6 +1,6 @@\n use back::bytecode::{DecodedBytecode, RLIB_BYTECODE_EXTENSION};\n use rustc_codegen_ssa::back::symbol_export;\n-use rustc_codegen_ssa::back::write::{ModuleConfig, CodegenContext, pre_lto_bitcode_filename};\n+use rustc_codegen_ssa::back::write::{ModuleConfig, CodegenContext, FatLTOInput};\n use rustc_codegen_ssa::back::lto::{SerializedModule, LtoModuleCodegen, ThinShared, ThinModule};\n use rustc_codegen_ssa::traits::*;\n use back::write::{self, DiagnosticHandlers, with_llvm_pmb, save_temp_bitcode, to_llvm_opt_settings};\n@@ -21,7 +21,6 @@ use rustc_codegen_ssa::{ModuleCodegen, ModuleKind};\n use libc;\n \n use std::ffi::{CStr, CString};\n-use std::fs;\n use std::ptr;\n use std::slice;\n use std::sync::Arc;\n@@ -133,7 +132,8 @@ fn prepare_lto(cgcx: &CodegenContext<LlvmCodegenBackend>,\n /// Performs fat LTO by merging all modules into a single one and returning it\n /// for further optimization.\n pub(crate) fn run_fat(cgcx: &CodegenContext<LlvmCodegenBackend>,\n-                      modules: Vec<ModuleCodegen<ModuleLlvm>>,\n+                      modules: Vec<FatLTOInput<LlvmCodegenBackend>>,\n+                      cached_modules: Vec<(SerializedModule<ModuleBuffer>, WorkProduct)>,\n                       timeline: &mut Timeline)\n     -> Result<LtoModuleCodegen<LlvmCodegenBackend>, FatalError>\n {\n@@ -142,7 +142,15 @@ pub(crate) fn run_fat(cgcx: &CodegenContext<LlvmCodegenBackend>,\n     let symbol_white_list = symbol_white_list.iter()\n                                              .map(|c| c.as_ptr())\n                                              .collect::<Vec<_>>();\n-    fat_lto(cgcx, &diag_handler, modules, upstream_modules, &symbol_white_list, timeline)\n+    fat_lto(\n+        cgcx,\n+        &diag_handler,\n+        modules,\n+        cached_modules,\n+        upstream_modules,\n+        &symbol_white_list,\n+        timeline,\n+    )\n }\n \n /// Performs thin LTO by performing necessary global analysis and returning two\n@@ -173,33 +181,17 @@ pub(crate) fn run_thin(cgcx: &CodegenContext<LlvmCodegenBackend>,\n }\n \n pub(crate) fn prepare_thin(\n-    cgcx: &CodegenContext<LlvmCodegenBackend>,\n     module: ModuleCodegen<ModuleLlvm>\n ) -> (String, ThinBuffer) {\n     let name = module.name.clone();\n     let buffer = ThinBuffer::new(module.module_llvm.llmod());\n-\n-    // We emit the module after having serialized it into a ThinBuffer\n-    // because only then it will contain the ThinLTO module summary.\n-    if let Some(ref incr_comp_session_dir) = cgcx.incr_comp_session_dir {\n-        if cgcx.config(module.kind).emit_pre_thin_lto_bc {\n-            let path = incr_comp_session_dir\n-                .join(pre_lto_bitcode_filename(&name));\n-\n-            fs::write(&path, buffer.data()).unwrap_or_else(|e| {\n-                panic!(\"Error writing pre-lto-bitcode file `{}`: {}\",\n-                       path.display(),\n-                       e);\n-            });\n-        }\n-    }\n-\n     (name, buffer)\n }\n \n fn fat_lto(cgcx: &CodegenContext<LlvmCodegenBackend>,\n            diag_handler: &Handler,\n-           mut modules: Vec<ModuleCodegen<ModuleLlvm>>,\n+           mut modules: Vec<FatLTOInput<LlvmCodegenBackend>>,\n+           cached_modules: Vec<(SerializedModule<ModuleBuffer>, WorkProduct)>,\n            mut serialized_modules: Vec<(SerializedModule<ModuleBuffer>, CString)>,\n            symbol_white_list: &[*const libc::c_char],\n            timeline: &mut Timeline)\n@@ -216,18 +208,53 @@ fn fat_lto(cgcx: &CodegenContext<LlvmCodegenBackend>,\n     // file copy operations in the backend work correctly. The only other kind\n     // of module here should be an allocator one, and if your crate is smaller\n     // than the allocator module then the size doesn't really matter anyway.\n-    let (_, costliest_module) = modules.iter()\n+    let costliest_module = modules.iter()\n         .enumerate()\n+        .filter_map(|(i, module)| {\n+            match module {\n+                FatLTOInput::InMemory(m) => Some((i, m)),\n+                FatLTOInput::Serialized { .. } => None,\n+            }\n+        })\n         .filter(|&(_, module)| module.kind == ModuleKind::Regular)\n         .map(|(i, module)| {\n             let cost = unsafe {\n                 llvm::LLVMRustModuleCost(module.module_llvm.llmod())\n             };\n             (cost, i)\n         })\n-        .max()\n-        .expect(\"must be codegen'ing at least one module\");\n-    let module = modules.remove(costliest_module);\n+        .max();\n+\n+    // If we found a costliest module, we're good to go. Otherwise all our\n+    // inputs were serialized which could happen in the case, for example, that\n+    // all our inputs were incrementally reread from the cache and we're just\n+    // re-executing the LTO passes. If that's the case deserialize the first\n+    // module and create a linker with it.\n+    let module: ModuleCodegen<ModuleLlvm> = match costliest_module {\n+        Some((_cost, i)) => {\n+            match modules.remove(i) {\n+                FatLTOInput::InMemory(m) => m,\n+                FatLTOInput::Serialized { .. } => unreachable!(),\n+            }\n+        }\n+        None => {\n+            let pos = modules.iter().position(|m| {\n+                match m {\n+                    FatLTOInput::InMemory(_) => false,\n+                    FatLTOInput::Serialized { .. } => true,\n+                }\n+            }).expect(\"must have at least one serialized module\");\n+            let (name, buffer) = match modules.remove(pos) {\n+                FatLTOInput::Serialized { name, buffer } => (name, buffer),\n+                FatLTOInput::InMemory(_) => unreachable!(),\n+            };\n+            ModuleCodegen {\n+                module_llvm: ModuleLlvm::parse(cgcx, &name, &buffer, diag_handler)?,\n+                name,\n+                kind: ModuleKind::Regular,\n+            }\n+        }\n+    };\n     let mut serialized_bitcode = Vec::new();\n     {\n         let (llcx, llmod) = {\n@@ -247,10 +274,20 @@ fn fat_lto(cgcx: &CodegenContext<LlvmCodegenBackend>,\n         // way we know of to do that is to serialize them to a string and them parse\n         // them later. Not great but hey, that's why it's \"fat\" LTO, right?\n         serialized_modules.extend(modules.into_iter().map(|module| {\n-            let buffer = ModuleBuffer::new(module.module_llvm.llmod());\n-            let llmod_id = CString::new(&module.name[..]).unwrap();\n-\n-            (SerializedModule::Local(buffer), llmod_id)\n+            match module {\n+                FatLTOInput::InMemory(module) => {\n+                    let buffer = ModuleBuffer::new(module.module_llvm.llmod());\n+                    let llmod_id = CString::new(&module.name[..]).unwrap();\n+                    (SerializedModule::Local(buffer), llmod_id)\n+                }\n+                FatLTOInput::Serialized { name, buffer } => {\n+                    let llmod_id = CString::new(name).unwrap();\n+                    (SerializedModule::Local(buffer), llmod_id)\n+                }\n+            }\n+        }));\n+        serialized_modules.extend(cached_modules.into_iter().map(|(buffer, wp)| {\n+            (buffer, CString::new(wp.cgu_name.clone()).unwrap())\n         }));\n \n         // For all serialized bitcode files we parse them and link them in as we did\n@@ -579,6 +616,16 @@ impl ModuleBuffer {\n             llvm::LLVMRustModuleBufferCreate(m)\n         })\n     }\n+\n+    pub fn parse<'a>(\n+        &self,\n+        name: &str,\n+        cx: &'a llvm::Context,\n+        handler: &Handler,\n+    ) -> Result<&'a llvm::Module, FatalError> {\n+        let name = CString::new(name).unwrap();\n+        parse_module(cx, &name, self.data(), handler)\n+    }\n }\n \n impl ModuleBufferMethods for ModuleBuffer {\n@@ -658,15 +705,12 @@ pub unsafe fn optimize_thin_module(\n     // crates but for locally codegened modules we may be able to reuse\n     // that LLVM Context and Module.\n     let llcx = llvm::LLVMRustContextCreate(cgcx.fewer_names);\n-    let llmod_raw = llvm::LLVMRustParseBitcodeForThinLTO(\n+    let llmod_raw = parse_module(\n         llcx,\n-        thin_module.data().as_ptr(),\n-        thin_module.data().len(),\n-        thin_module.shared.module_names[thin_module.idx].as_ptr(),\n-    ).ok_or_else(|| {\n-        let msg = \"failed to parse bitcode for thin LTO module\";\n-        write::llvm_err(&diag_handler, msg)\n-    })? as *const _;\n+        &thin_module.shared.module_names[thin_module.idx],\n+        thin_module.data(),\n+        &diag_handler,\n+    )? as *const _;\n     let module = ModuleCodegen {\n         module_llvm: ModuleLlvm {\n             llmod_raw,\n@@ -823,3 +867,22 @@ fn module_name_to_str(c_str: &CStr) -> &str {\n     c_str.to_str().unwrap_or_else(|e|\n         bug!(\"Encountered non-utf8 LLVM module name `{}`: {}\", c_str.to_string_lossy(), e))\n }\n+\n+fn parse_module<'a>(\n+    cx: &'a llvm::Context,\n+    name: &CStr,\n+    data: &[u8],\n+    diag_handler: &Handler,\n+) -> Result<&'a llvm::Module, FatalError> {\n+    unsafe {\n+        llvm::LLVMRustParseBitcodeForLTO(\n+            cx,\n+            data.as_ptr(),\n+            data.len(),\n+            name.as_ptr(),\n+        ).ok_or_else(|| {\n+            let msg = \"failed to parse bitcode for LTO module\";\n+            write::llvm_err(&diag_handler, msg)\n+        })\n+    }\n+}"}, {"sha": "b605badc153f0e27acb016aee6ac0b72f88e678b", "filename": "src/librustc_codegen_llvm/lib.rs", "status": "modified", "additions": 35, "deletions": 5, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/f47ec2ad5b6887b3d400aee49e2294bd27733d18/src%2Flibrustc_codegen_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f47ec2ad5b6887b3d400aee49e2294bd27733d18/src%2Flibrustc_codegen_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Flib.rs?ref=f47ec2ad5b6887b3d400aee49e2294bd27733d18", "patch": "@@ -54,7 +54,7 @@ extern crate tempfile;\n extern crate memmap;\n \n use rustc_codegen_ssa::traits::*;\n-use rustc_codegen_ssa::back::write::{CodegenContext, ModuleConfig};\n+use rustc_codegen_ssa::back::write::{CodegenContext, ModuleConfig, FatLTOInput};\n use rustc_codegen_ssa::back::lto::{SerializedModule, LtoModuleCodegen, ThinModule};\n use rustc_codegen_ssa::CompiledModule;\n use errors::{FatalError, Handler};\n@@ -165,10 +165,11 @@ impl WriteBackendMethods for LlvmCodegenBackend {\n     }\n     fn run_fat_lto(\n         cgcx: &CodegenContext<Self>,\n-        modules: Vec<ModuleCodegen<Self::Module>>,\n+        modules: Vec<FatLTOInput<Self>>,\n+        cached_modules: Vec<(SerializedModule<Self::ModuleBuffer>, WorkProduct)>,\n         timeline: &mut Timeline\n     ) -> Result<LtoModuleCodegen<Self>, FatalError> {\n-        back::lto::run_fat(cgcx, modules, timeline)\n+        back::lto::run_fat(cgcx, modules, cached_modules, timeline)\n     }\n     fn run_thin_lto(\n         cgcx: &CodegenContext<Self>,\n@@ -204,10 +205,14 @@ impl WriteBackendMethods for LlvmCodegenBackend {\n         back::write::codegen(cgcx, diag_handler, module, config, timeline)\n     }\n     fn prepare_thin(\n-        cgcx: &CodegenContext<Self>,\n         module: ModuleCodegen<Self::Module>\n     ) -> (String, Self::ThinBuffer) {\n-        back::lto::prepare_thin(cgcx, module)\n+        back::lto::prepare_thin(module)\n+    }\n+    fn serialize_module(\n+        module: ModuleCodegen<Self::Module>\n+    ) -> (String, Self::ModuleBuffer) {\n+        (module.name, back::lto::ModuleBuffer::new(module.module_llvm.llmod()))\n     }\n     fn run_lto_pass_manager(\n         cgcx: &CodegenContext<Self>,\n@@ -375,6 +380,31 @@ impl ModuleLlvm {\n         }\n     }\n \n+    fn parse(\n+        cgcx: &CodegenContext<LlvmCodegenBackend>,\n+        name: &str,\n+        buffer: &back::lto::ModuleBuffer,\n+        handler: &Handler,\n+    ) -> Result<Self, FatalError> {\n+        unsafe {\n+            let llcx = llvm::LLVMRustContextCreate(cgcx.fewer_names);\n+            let llmod_raw = buffer.parse(name, llcx, handler)?;\n+            let tm = match (cgcx.tm_factory.0)() {\n+                Ok(m) => m,\n+                Err(e) => {\n+                    handler.struct_err(&e).emit();\n+                    return Err(FatalError)\n+                }\n+            };\n+\n+            Ok(ModuleLlvm {\n+                llmod_raw,\n+                llcx,\n+                tm,\n+            })\n+        }\n+    }\n+\n     fn llmod(&self) -> &llvm::Module {\n         unsafe {\n             &*self.llmod_raw"}, {"sha": "52292f67b331dbe932f3fd1c93224714a35d829b", "filename": "src/librustc_codegen_llvm/llvm/ffi.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f47ec2ad5b6887b3d400aee49e2294bd27733d18/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f47ec2ad5b6887b3d400aee49e2294bd27733d18/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs?ref=f47ec2ad5b6887b3d400aee49e2294bd27733d18", "patch": "@@ -1804,7 +1804,7 @@ extern \"C\" {\n         CallbackPayload: *mut c_void,\n     );\n     pub fn LLVMRustFreeThinLTOData(Data: &'static mut ThinLTOData);\n-    pub fn LLVMRustParseBitcodeForThinLTO(\n+    pub fn LLVMRustParseBitcodeForLTO(\n         Context: &Context,\n         Data: *const u8,\n         len: usize,"}, {"sha": "20842553c266643de747763aa1da4d8fab528a79", "filename": "src/librustc_codegen_ssa/back/write.rs", "status": "modified", "additions": 58, "deletions": 17, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/f47ec2ad5b6887b3d400aee49e2294bd27733d18/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f47ec2ad5b6887b3d400aee49e2294bd27733d18/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs?ref=f47ec2ad5b6887b3d400aee49e2294bd27733d18", "patch": "@@ -41,7 +41,7 @@ use std::sync::mpsc::{channel, Sender, Receiver};\n use std::time::Instant;\n use std::thread;\n \n-const PRE_THIN_LTO_BC_EXT: &str = \"pre-thin-lto.bc\";\n+const PRE_LTO_BC_EXT: &str = \"pre-lto.bc\";\n \n /// Module-specific configuration for `optimize_and_codegen`.\n pub struct ModuleConfig {\n@@ -58,7 +58,7 @@ pub struct ModuleConfig {\n     pub pgo_use: String,\n \n     // Flags indicating which outputs to produce.\n-    pub emit_pre_thin_lto_bc: bool,\n+    pub emit_pre_lto_bc: bool,\n     pub emit_no_opt_bc: bool,\n     pub emit_bc: bool,\n     pub emit_bc_compressed: bool,\n@@ -96,7 +96,7 @@ impl ModuleConfig {\n             pgo_use: String::new(),\n \n             emit_no_opt_bc: false,\n-            emit_pre_thin_lto_bc: false,\n+            emit_pre_lto_bc: false,\n             emit_bc: false,\n             emit_bc_compressed: false,\n             emit_lto_bc: false,\n@@ -258,7 +258,7 @@ impl<B: WriteBackendMethods> CodegenContext<B> {\n \n fn generate_lto_work<B: ExtraBackendMethods>(\n     cgcx: &CodegenContext<B>,\n-    needs_fat_lto: Vec<ModuleCodegen<B::Module>>,\n+    needs_fat_lto: Vec<FatLTOInput<B>>,\n     needs_thin_lto: Vec<(String, B::ThinBuffer)>,\n     import_only_modules: Vec<(SerializedModule<B::ModuleBuffer>, WorkProduct)>\n ) -> Vec<(WorkItem<B>, u64)> {\n@@ -270,9 +270,13 @@ fn generate_lto_work<B: ExtraBackendMethods>(\n \n     let (lto_modules, copy_jobs) = if !needs_fat_lto.is_empty() {\n         assert!(needs_thin_lto.is_empty());\n-        assert!(import_only_modules.is_empty());\n-        let lto_module = B::run_fat_lto(cgcx, needs_fat_lto, &mut timeline)\n-            .unwrap_or_else(|e| e.raise());\n+        let lto_module = B::run_fat_lto(\n+            cgcx,\n+            needs_fat_lto,\n+            import_only_modules,\n+            &mut timeline,\n+        )\n+        .unwrap_or_else(|e| e.raise());\n         (vec![lto_module], vec![])\n     } else {\n         assert!(needs_fat_lto.is_empty());\n@@ -302,14 +306,14 @@ fn need_crate_bitcode_for_rlib(sess: &Session) -> bool {\n     sess.opts.output_types.contains_key(&OutputType::Exe)\n }\n \n-fn need_pre_thin_lto_bitcode_for_incr_comp(sess: &Session) -> bool {\n+fn need_pre_lto_bitcode_for_incr_comp(sess: &Session) -> bool {\n     if sess.opts.incremental.is_none() {\n         return false\n     }\n \n     match sess.lto() {\n-        Lto::Fat |\n         Lto::No => false,\n+        Lto::Fat |\n         Lto::Thin |\n         Lto::ThinLocal => true,\n     }\n@@ -375,7 +379,7 @@ pub fn start_async_codegen<B: ExtraBackendMethods>(\n     // Save all versions of the bytecode if we're saving our temporaries.\n     if sess.opts.cg.save_temps {\n         modules_config.emit_no_opt_bc = true;\n-        modules_config.emit_pre_thin_lto_bc = true;\n+        modules_config.emit_pre_lto_bc = true;\n         modules_config.emit_bc = true;\n         modules_config.emit_lto_bc = true;\n         metadata_config.emit_bc = true;\n@@ -390,8 +394,8 @@ pub fn start_async_codegen<B: ExtraBackendMethods>(\n         allocator_config.emit_bc_compressed = true;\n     }\n \n-    modules_config.emit_pre_thin_lto_bc =\n-        need_pre_thin_lto_bitcode_for_incr_comp(sess);\n+    modules_config.emit_pre_lto_bc =\n+        need_pre_lto_bitcode_for_incr_comp(sess);\n \n     modules_config.no_integrated_as = tcx.sess.opts.cg.no_integrated_as ||\n         tcx.sess.target.target.options.no_integrated_as;\n@@ -686,10 +690,18 @@ impl<B: WriteBackendMethods> WorkItem<B> {\n \n enum WorkItemResult<B: WriteBackendMethods> {\n     Compiled(CompiledModule),\n-    NeedsFatLTO(ModuleCodegen<B::Module>),\n+    NeedsFatLTO(FatLTOInput<B>),\n     NeedsThinLTO(String, B::ThinBuffer),\n }\n \n+pub enum FatLTOInput<B: WriteBackendMethods> {\n+    Serialized {\n+        name: String,\n+        buffer: B::ModuleBuffer,\n+    },\n+    InMemory(ModuleCodegen<B::Module>),\n+}\n+\n fn execute_work_item<B: ExtraBackendMethods>(\n     cgcx: &CodegenContext<B>,\n     work_item: WorkItem<B>,\n@@ -771,6 +783,15 @@ fn execute_optimize_work_item<B: ExtraBackendMethods>(\n         }\n     };\n \n+    // If we're doing some form of incremental LTO then we need to be sure to\n+    // save our module to disk first.\n+    let bitcode = if cgcx.config(module.kind).emit_pre_lto_bc {\n+        let filename = pre_lto_bitcode_filename(&module.name);\n+        cgcx.incr_comp_session_dir.as_ref().map(|path| path.join(&filename))\n+    } else {\n+        None\n+    };\n+\n     Ok(match lto_type {\n         ComputedLtoType::No => {\n             let module = unsafe {\n@@ -779,10 +800,30 @@ fn execute_optimize_work_item<B: ExtraBackendMethods>(\n             WorkItemResult::Compiled(module)\n         }\n         ComputedLtoType::Thin => {\n-            let (name, thin_buffer) = B::prepare_thin(cgcx, module);\n+            let (name, thin_buffer) = B::prepare_thin(module);\n+            if let Some(path) = bitcode {\n+                fs::write(&path, thin_buffer.data()).unwrap_or_else(|e| {\n+                    panic!(\"Error writing pre-lto-bitcode file `{}`: {}\",\n+                           path.display(),\n+                           e);\n+                });\n+            }\n             WorkItemResult::NeedsThinLTO(name, thin_buffer)\n         }\n-        ComputedLtoType::Fat => WorkItemResult::NeedsFatLTO(module),\n+        ComputedLtoType::Fat => {\n+            match bitcode {\n+                Some(path) => {\n+                    let (name, buffer) = B::serialize_module(module);\n+                    fs::write(&path, buffer.data()).unwrap_or_else(|e| {\n+                        panic!(\"Error writing pre-lto-bitcode file `{}`: {}\",\n+                               path.display(),\n+                               e);\n+                    });\n+                    WorkItemResult::NeedsFatLTO(FatLTOInput::Serialized { name, buffer })\n+                }\n+                None => WorkItemResult::NeedsFatLTO(FatLTOInput::InMemory(module)),\n+            }\n+        }\n     })\n }\n \n@@ -866,7 +907,7 @@ fn execute_lto_work_item<B: ExtraBackendMethods>(\n pub enum Message<B: WriteBackendMethods> {\n     Token(io::Result<Acquired>),\n     NeedsFatLTO {\n-        result: ModuleCodegen<B::Module>,\n+        result: FatLTOInput<B>,\n         worker_id: usize,\n     },\n     NeedsThinLTO {\n@@ -1877,7 +1918,7 @@ pub fn submit_pre_lto_module_to_llvm<B: ExtraBackendMethods>(\n }\n \n pub fn pre_lto_bitcode_filename(module_name: &str) -> String {\n-    format!(\"{}.{}\", module_name, PRE_THIN_LTO_BC_EXT)\n+    format!(\"{}.{}\", module_name, PRE_LTO_BC_EXT)\n }\n \n fn msvc_imps_needed(tcx: TyCtxt) -> bool {"}, {"sha": "d8fb7c608c8afb72890d0219217034c5a56f8bbd", "filename": "src/librustc_codegen_ssa/traits/write.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f47ec2ad5b6887b3d400aee49e2294bd27733d18/src%2Flibrustc_codegen_ssa%2Ftraits%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f47ec2ad5b6887b3d400aee49e2294bd27733d18/src%2Flibrustc_codegen_ssa%2Ftraits%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fwrite.rs?ref=f47ec2ad5b6887b3d400aee49e2294bd27733d18", "patch": "@@ -1,5 +1,5 @@\n use crate::back::lto::{LtoModuleCodegen, SerializedModule, ThinModule};\n-use crate::back::write::{CodegenContext, ModuleConfig};\n+use crate::back::write::{CodegenContext, ModuleConfig, FatLTOInput};\n use crate::{CompiledModule, ModuleCodegen};\n \n use rustc::dep_graph::WorkProduct;\n@@ -18,7 +18,8 @@ pub trait WriteBackendMethods: 'static + Sized + Clone {\n     /// for further optimization.\n     fn run_fat_lto(\n         cgcx: &CodegenContext<Self>,\n-        modules: Vec<ModuleCodegen<Self::Module>>,\n+        modules: Vec<FatLTOInput<Self>>,\n+        cached_modules: Vec<(SerializedModule<Self::ModuleBuffer>, WorkProduct)>,\n         timeline: &mut Timeline,\n     ) -> Result<LtoModuleCodegen<Self>, FatalError>;\n     /// Performs thin LTO by performing necessary global analysis and returning two\n@@ -51,9 +52,11 @@ pub trait WriteBackendMethods: 'static + Sized + Clone {\n         timeline: &mut Timeline,\n     ) -> Result<CompiledModule, FatalError>;\n     fn prepare_thin(\n-        cgcx: &CodegenContext<Self>,\n         module: ModuleCodegen<Self::Module>\n     ) -> (String, Self::ThinBuffer);\n+    fn serialize_module(\n+        module: ModuleCodegen<Self::Module>\n+    ) -> (String, Self::ModuleBuffer);\n     fn run_lto_pass_manager(\n         cgcx: &CodegenContext<Self>,\n         llmod: &ModuleCodegen<Self::Module>,"}, {"sha": "fd2b635faefb406d85b78b39db156fc1a85d3e22", "filename": "src/librustc_lint/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f47ec2ad5b6887b3d400aee49e2294bd27733d18/src%2Flibrustc_lint%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f47ec2ad5b6887b3d400aee49e2294bd27733d18/src%2Flibrustc_lint%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2FCargo.toml?ref=f47ec2ad5b6887b3d400aee49e2294bd27733d18", "patch": "@@ -8,7 +8,6 @@ edition = \"2018\"\n name = \"rustc_lint\"\n path = \"lib.rs\"\n crate-type = [\"dylib\"]\n-test = false\n \n [dependencies]\n log = \"0.4\""}, {"sha": "c2dd9a3d1b84f0aa2d7bdb1b543c124c9a9bfef4", "filename": "src/librustc_lint/nonstandard_style.rs", "status": "modified", "additions": 95, "deletions": 53, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/f47ec2ad5b6887b3d400aee49e2294bd27733d18/src%2Flibrustc_lint%2Fnonstandard_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f47ec2ad5b6887b3d400aee49e2294bd27733d18/src%2Flibrustc_lint%2Fnonstandard_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fnonstandard_style.rs?ref=f47ec2ad5b6887b3d400aee49e2294bd27733d18", "patch": "@@ -38,66 +38,87 @@ declare_lint! {\n     \"types, variants, traits and type parameters should have camel case names\"\n }\n \n-#[derive(Copy, Clone)]\n-pub struct NonCamelCaseTypes;\n+fn char_has_case(c: char) -> bool {\n+    c.is_lowercase() || c.is_uppercase()\n+}\n \n-impl NonCamelCaseTypes {\n-    fn check_case(&self, cx: &EarlyContext<'_>, sort: &str, ident: &Ident) {\n-        fn char_has_case(c: char) -> bool {\n-            c.is_lowercase() || c.is_uppercase()\n-        }\n+fn is_camel_case(name: &str) -> bool {\n+    let name = name.trim_matches('_');\n+    if name.is_empty() {\n+        return true;\n+    }\n \n-        fn is_camel_case(name: &str) -> bool {\n-            let name = name.trim_matches('_');\n-            if name.is_empty() {\n-                return true;\n+    // start with a non-lowercase letter rather than non-uppercase\n+    // ones (some scripts don't have a concept of upper/lowercase)\n+    !name.chars().next().unwrap().is_lowercase()\n+        && !name.contains(\"__\")\n+        && !name.chars().collect::<Vec<_>>().windows(2).any(|pair| {\n+            // contains a capitalisable character followed by, or preceded by, an underscore\n+            char_has_case(pair[0]) && pair[1] == '_' || char_has_case(pair[1]) && pair[0] == '_'\n+        })\n+}\n+\n+fn to_camel_case(s: &str) -> String {\n+    s.trim_matches('_')\n+        .split('_')\n+        .filter(|component| !component.is_empty())\n+        .map(|component| {\n+            let mut camel_cased_component = String::new();\n+\n+            let mut new_word = true;\n+            let mut prev_is_lower_case = true;\n+\n+            for c in component.chars() {\n+                // Preserve the case if an uppercase letter follows a lowercase letter, so that\n+                // `camelCase` is converted to `CamelCase`.\n+                if prev_is_lower_case && c.is_uppercase() {\n+                    new_word = true;\n+                }\n+\n+                if new_word {\n+                    camel_cased_component.push_str(&c.to_uppercase().to_string());\n+                } else {\n+                    camel_cased_component.push_str(&c.to_lowercase().to_string());\n+                }\n+\n+                prev_is_lower_case = c.is_lowercase();\n+                new_word = false;\n             }\n \n-            // start with a non-lowercase letter rather than non-uppercase\n-            // ones (some scripts don't have a concept of upper/lowercase)\n-            !name.is_empty() && !name.chars().next().unwrap().is_lowercase() &&\n-                !name.contains(\"__\") && !name.chars().collect::<Vec<_>>().windows(2).any(|pair| {\n-                    // contains a capitalisable character followed by, or preceded by, an underscore\n-                    char_has_case(pair[0]) && pair[1] == '_' ||\n-                    char_has_case(pair[1]) && pair[0] == '_'\n-                })\n-        }\n+            camel_cased_component\n+        })\n+        .fold(\n+            (String::new(), None),\n+            |(acc, prev): (String, Option<String>), next| {\n+                // separate two components with an underscore if their boundary cannot\n+                // be distinguished using a uppercase/lowercase case distinction\n+                let join = if let Some(prev) = prev {\n+                    let l = prev.chars().last().unwrap();\n+                    let f = next.chars().next().unwrap();\n+                    !char_has_case(l) && !char_has_case(f)\n+                } else {\n+                    false\n+                };\n+                (acc + if join { \"_\" } else { \"\" } + &next, Some(next))\n+            },\n+        )\n+        .0\n+}\n \n-        fn to_camel_case(s: &str) -> String {\n-            s.trim_matches('_')\n-                .split('_')\n-                .map(|word| {\n-                    word.chars().enumerate().map(|(i, c)| if i == 0 {\n-                        c.to_uppercase().collect::<String>()\n-                    } else {\n-                        c.to_lowercase().collect()\n-                    })\n-                    .collect::<String>()\n-                })\n-                .filter(|x| !x.is_empty())\n-                .fold((String::new(), None), |(acc, prev): (String, Option<String>), next| {\n-                    // separate two components with an underscore if their boundary cannot\n-                    // be distinguished using a uppercase/lowercase case distinction\n-                    let join = if let Some(prev) = prev {\n-                                    let l = prev.chars().last().unwrap();\n-                                    let f = next.chars().next().unwrap();\n-                                    !char_has_case(l) && !char_has_case(f)\n-                                } else { false };\n-                    (acc + if join { \"_\" } else { \"\" } + &next, Some(next))\n-                }).0\n-        }\n+#[derive(Copy, Clone)]\n+pub struct NonCamelCaseTypes;\n \n+impl NonCamelCaseTypes {\n+    fn check_case(&self, cx: &EarlyContext<'_>, sort: &str, ident: &Ident) {\n         let name = &ident.name.as_str();\n \n         if !is_camel_case(name) {\n-            let c = to_camel_case(name);\n-\n-            let msg = format!(\"{} `{}` should have a camel case name\", sort, name);\n+            let msg = format!(\"{} `{}` should have an upper camel case name\", sort, name);\n             cx.struct_span_lint(NON_CAMEL_CASE_TYPES, ident.span, &msg)\n                 .span_suggestion(\n                     ident.span,\n-                    \"convert the identifier to camel case\",\n-                    c,\n+                    \"convert the identifier to upper camel case\",\n+                    to_camel_case(name),\n                     Applicability::MaybeIncorrect,\n                 )\n                 .emit();\n@@ -119,11 +140,7 @@ impl EarlyLintPass for NonCamelCaseTypes {\n     fn check_item(&mut self, cx: &EarlyContext<'_>, it: &ast::Item) {\n         let has_repr_c = it.attrs\n             .iter()\n-            .any(|attr| {\n-                attr::find_repr_attrs(&cx.sess.parse_sess, attr)\n-                    .iter()\n-                    .any(|r| r == &attr::ReprC)\n-            });\n+            .any(|attr| attr::find_repr_attrs(&cx.sess.parse_sess, attr).contains(&attr::ReprC));\n \n         if has_repr_c {\n             return;\n@@ -439,3 +456,28 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonUpperCaseGlobals {\n         }\n     }\n }\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::{is_camel_case, to_camel_case};\n+\n+    #[test]\n+    fn camel_case() {\n+        assert!(!is_camel_case(\"userData\"));\n+        assert_eq!(to_camel_case(\"userData\"), \"UserData\");\n+\n+        assert!(is_camel_case(\"X86_64\"));\n+\n+        assert!(!is_camel_case(\"X86__64\"));\n+        assert_eq!(to_camel_case(\"X86__64\"), \"X86_64\");\n+\n+        assert!(!is_camel_case(\"Abc_123\"));\n+        assert_eq!(to_camel_case(\"Abc_123\"), \"Abc123\");\n+\n+        assert!(!is_camel_case(\"A1_b2_c3\"));\n+        assert_eq!(to_camel_case(\"A1_b2_c3\"), \"A1B2C3\");\n+\n+        assert!(!is_camel_case(\"ONE_TWO_THREE\"));\n+        assert_eq!(to_camel_case(\"ONE_TWO_THREE\"), \"OneTwoThree\");\n+    }\n+}"}, {"sha": "081c458bfc17a37d821b7f544e8d7316fe85f9f1", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f47ec2ad5b6887b3d400aee49e2294bd27733d18/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f47ec2ad5b6887b3d400aee49e2294bd27733d18/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs?ref=f47ec2ad5b6887b3d400aee49e2294bd27733d18", "patch": "@@ -244,7 +244,8 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         if let (Some(f), Some(o)) = (self.to_error_region(fr), self.to_error_region(outlived_fr)) {\n             let tables = infcx.tcx.typeck_tables_of(mir_def_id);\n             let nice = NiceRegionError::new_from_span(infcx, span, o, f, Some(tables));\n-            if let Some(_error_reported) = nice.try_report_from_nll() {\n+            if let Some(diag) = nice.try_report_from_nll() {\n+                diag.buffer(errors_buffer);\n                 return;\n             }\n         }"}, {"sha": "cbeb5dc206ee68d5754cbbe1f96e62c4f9f85fe9", "filename": "src/librustc_mir/borrow_check/nll/region_infer/mod.rs", "status": "modified", "additions": 106, "deletions": 54, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/f47ec2ad5b6887b3d400aee49e2294bd27733d18/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f47ec2ad5b6887b3d400aee49e2294bd27733d18/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs?ref=f47ec2ad5b6887b3d400aee49e2294bd27733d18", "patch": "@@ -15,7 +15,7 @@ use rustc::mir::{\n     ConstraintCategory, Local, Location, Mir,\n };\n use rustc::ty::{self, RegionVid, Ty, TyCtxt, TypeFoldable};\n-use rustc::util::common;\n+use rustc::util::common::{self, ErrorReported};\n use rustc_data_structures::bit_set::BitSet;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::graph::scc::Sccs;\n@@ -763,20 +763,26 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n             debug!(\"try_promote_type_test: ur={:?}\", ur);\n \n-            let non_local_ub = self.universal_region_relations.non_local_upper_bound(ur);\n+            let non_local_ub = self.universal_region_relations.non_local_upper_bounds(&ur);\n             debug!(\"try_promote_type_test: non_local_ub={:?}\", non_local_ub);\n \n-            assert!(self.universal_regions.is_universal_region(non_local_ub));\n-            assert!(!self.universal_regions.is_local_free_region(non_local_ub));\n-\n-            let requirement = ClosureOutlivesRequirement {\n-                subject,\n-                outlived_free_region: non_local_ub,\n-                blame_span: locations.span(mir),\n-                category: ConstraintCategory::Boring,\n-            };\n-            debug!(\"try_promote_type_test: pushing {:#?}\", requirement);\n-            propagated_outlives_requirements.push(requirement);\n+            // This is slightly too conservative. To show T: '1, given `'2: '1`\n+            // and `'3: '1` we only need to prove that T: '2 *or* T: '3, but to\n+            // avoid potential non-determinism we approximate this by requiring\n+            // T: '1 and T: '2.\n+            for &upper_bound in non_local_ub {\n+                debug_assert!(self.universal_regions.is_universal_region(upper_bound));\n+                debug_assert!(!self.universal_regions.is_local_free_region(upper_bound));\n+\n+                let requirement = ClosureOutlivesRequirement {\n+                    subject,\n+                    outlived_free_region: upper_bound,\n+                    blame_span: locations.span(mir),\n+                    category: ConstraintCategory::Boring,\n+                };\n+                debug!(\"try_promote_type_test: pushing {:#?}\", requirement);\n+                propagated_outlives_requirements.push(requirement);\n+            }\n         }\n         true\n     }\n@@ -1157,63 +1163,109 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 .is_none()\n         );\n \n+        // Only check all of the relations for the main representative of each\n+        // SCC, otherwise just check that we outlive said representative. This\n+        // reduces the number of redundant relations propagated out of\n+        // closures.\n+        // Note that the representative will be a universal region if there is\n+        // one in this SCC, so we will always check the representative here.\n+        let representative = self.scc_representatives[longer_fr_scc];\n+        if representative != longer_fr {\n+            self.check_universal_region_relation(\n+                longer_fr,\n+                representative,\n+                infcx,\n+                mir,\n+                mir_def_id,\n+                propagated_outlives_requirements,\n+                errors_buffer,\n+            );\n+            return;\n+        }\n+\n         // Find every region `o` such that `fr: o`\n         // (because `fr` includes `end(o)`).\n         for shorter_fr in self.scc_values.universal_regions_outlived_by(longer_fr_scc) {\n-            // If it is known that `fr: o`, carry on.\n-            if self.universal_region_relations\n-                .outlives(longer_fr, shorter_fr)\n-            {\n-                continue;\n+            if let Some(ErrorReported) = self.check_universal_region_relation(\n+                longer_fr,\n+                shorter_fr,\n+                infcx,\n+                mir,\n+                mir_def_id,\n+                propagated_outlives_requirements,\n+                errors_buffer,\n+            ) {\n+                // continuing to iterate just reports more errors than necessary\n+                return;\n             }\n+        }\n+    }\n \n-            debug!(\n-                \"check_universal_region: fr={:?} does not outlive shorter_fr={:?}\",\n-                longer_fr, shorter_fr,\n-            );\n+    fn check_universal_region_relation(\n+        &self,\n+        longer_fr: RegionVid,\n+        shorter_fr: RegionVid,\n+        infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n+        mir: &Mir<'tcx>,\n+        mir_def_id: DefId,\n+        propagated_outlives_requirements: &mut Option<&mut Vec<ClosureOutlivesRequirement<'gcx>>>,\n+        errors_buffer: &mut Vec<Diagnostic>,\n+    ) -> Option<ErrorReported> {\n+        // If it is known that `fr: o`, carry on.\n+        if self.universal_region_relations\n+            .outlives(longer_fr, shorter_fr)\n+        {\n+            return None;\n+        }\n \n-            let blame_span_category = self.find_outlives_blame_span(mir, longer_fr, shorter_fr);\n-\n-            if let Some(propagated_outlives_requirements) = propagated_outlives_requirements {\n-                // Shrink `fr` until we find a non-local region (if we do).\n-                // We'll call that `fr-` -- it's ever so slightly smaller than `fr`.\n-                if let Some(fr_minus) = self.universal_region_relations\n-                    .non_local_lower_bound(longer_fr)\n-                {\n-                    debug!(\"check_universal_region: fr_minus={:?}\", fr_minus);\n-\n-                    // Grow `shorter_fr` until we find a non-local\n-                    // region. (We always will.)  We'll call that\n-                    // `shorter_fr+` -- it's ever so slightly larger than\n-                    // `fr`.\n-                    let shorter_fr_plus = self.universal_region_relations\n-                        .non_local_upper_bound(shorter_fr);\n-                    debug!(\n-                        \"check_universal_region: shorter_fr_plus={:?}\",\n-                        shorter_fr_plus\n-                    );\n+        debug!(\n+            \"check_universal_region_relation: fr={:?} does not outlive shorter_fr={:?}\",\n+            longer_fr, shorter_fr,\n+        );\n \n+        if let Some(propagated_outlives_requirements) = propagated_outlives_requirements {\n+            // Shrink `longer_fr` until we find a non-local region (if we do).\n+            // We'll call it `fr-` -- it's ever so slightly smaller than\n+            // `longer_fr`.\n+\n+            if let Some(fr_minus) = self\n+                .universal_region_relations\n+                .non_local_lower_bound(longer_fr)\n+            {\n+                debug!(\"check_universal_region: fr_minus={:?}\", fr_minus);\n+\n+                let blame_span_category = self.find_outlives_blame_span(mir, longer_fr, shorter_fr);\n+\n+                // Grow `shorter_fr` until we find some non-local regions. (We\n+                // always will.)  We'll call them `shorter_fr+` -- they're ever\n+                // so slightly larger than `shorter_fr`.\n+                let shorter_fr_plus = self.universal_region_relations\n+                    .non_local_upper_bounds(&shorter_fr);\n+                debug!(\n+                    \"check_universal_region: shorter_fr_plus={:?}\",\n+                    shorter_fr_plus\n+                );\n+                for &&fr in &shorter_fr_plus {\n                     // Push the constraint `fr-: shorter_fr+`\n                     propagated_outlives_requirements.push(ClosureOutlivesRequirement {\n                         subject: ClosureOutlivesSubject::Region(fr_minus),\n-                        outlived_free_region: shorter_fr_plus,\n+                        outlived_free_region: fr,\n                         blame_span: blame_span_category.1,\n                         category: blame_span_category.0,\n                     });\n-                    continue;\n                 }\n+                return None;\n             }\n-\n-            // If we are not in a context where we can propagate\n-            // errors, or we could not shrink `fr` to something\n-            // smaller, then just report an error.\n-            //\n-            // Note: in this case, we use the unapproximated regions\n-            // to report the error. This gives better error messages\n-            // in some cases.\n-            self.report_error(mir, infcx, mir_def_id, longer_fr, shorter_fr, errors_buffer);\n-            return; // continuing to iterate just reports more errors than necessary\n         }\n+\n+        // If we are not in a context where we can't propagate errors, or we\n+        // could not shrink `fr` to something smaller, then just report an\n+        // error.\n+        //\n+        // Note: in this case, we use the unapproximated regions to report the\n+        // error. This gives better error messages in some cases.\n+        self.report_error(mir, infcx, mir_def_id, longer_fr, shorter_fr, errors_buffer);\n+        Some(ErrorReported)\n     }\n \n     fn check_bound_universal_region<'gcx>("}, {"sha": "3b663ef6dad61f44477edd99774b77e53bd99cce", "filename": "src/librustc_mir/borrow_check/nll/type_check/free_region_relations.rs", "status": "modified", "additions": 65, "deletions": 37, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/f47ec2ad5b6887b3d400aee49e2294bd27733d18/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Ffree_region_relations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f47ec2ad5b6887b3d400aee49e2294bd27733d18/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Ffree_region_relations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Ffree_region_relations.rs?ref=f47ec2ad5b6887b3d400aee49e2294bd27733d18", "patch": "@@ -105,44 +105,89 @@ impl UniversalRegionRelations<'tcx> {\n \n     /// Finds an \"upper bound\" for `fr` that is not local. In other\n     /// words, returns the smallest (*) known region `fr1` that (a)\n-    /// outlives `fr` and (b) is not local. This cannot fail, because\n-    /// we will always find `'static` at worst.\n+    /// outlives `fr` and (b) is not local.\n     ///\n-    /// (*) If there are multiple competing choices, we pick the \"postdominating\"\n-    /// one. See `TransitiveRelation::postdom_upper_bound` for details.\n-    crate fn non_local_upper_bound(&self, fr: RegionVid) -> RegionVid {\n+    /// (*) If there are multiple competing choices, we return all of them.\n+    crate fn non_local_upper_bounds(&'a self, fr: &'a RegionVid) -> Vec<&'a RegionVid> {\n         debug!(\"non_local_upper_bound(fr={:?})\", fr);\n-        self.non_local_bound(&self.inverse_outlives, fr)\n+        let res = self.non_local_bounds(&self.inverse_outlives, fr);\n+        assert!(!res.is_empty(), \"can't find an upper bound!?\");\n+        res\n+    }\n+\n+    /// Returns the \"postdominating\" bound of the set of\n+    /// `non_local_upper_bounds` for the given region.\n+    crate fn non_local_upper_bound(&self, fr: RegionVid) -> RegionVid {\n+        let upper_bounds = self.non_local_upper_bounds(&fr);\n+\n+        // In case we find more than one, reduce to one for\n+        // convenience.  This is to prevent us from generating more\n+        // complex constraints, but it will cause spurious errors.\n+        let post_dom = self\n+            .inverse_outlives\n+            .mutual_immediate_postdominator(upper_bounds);\n+\n+        debug!(\"non_local_bound: post_dom={:?}\", post_dom);\n+\n+        post_dom\n+            .and_then(|&post_dom| {\n+                // If the mutual immediate postdom is not local, then\n+                // there is no non-local result we can return.\n+                if !self.universal_regions.is_local_free_region(post_dom) {\n+                    Some(post_dom)\n+                } else {\n+                    None\n+                }\n+            })\n             .unwrap_or(self.universal_regions.fr_static)\n     }\n \n+\n     /// Finds a \"lower bound\" for `fr` that is not local. In other\n     /// words, returns the largest (*) known region `fr1` that (a) is\n-    /// outlived by `fr` and (b) is not local. This cannot fail,\n-    /// because we will always find `'static` at worst.\n+    /// outlived by `fr` and (b) is not local.\n     ///\n     /// (*) If there are multiple competing choices, we pick the \"postdominating\"\n     /// one. See `TransitiveRelation::postdom_upper_bound` for details.\n     crate fn non_local_lower_bound(&self, fr: RegionVid) -> Option<RegionVid> {\n         debug!(\"non_local_lower_bound(fr={:?})\", fr);\n-        self.non_local_bound(&self.outlives, fr)\n+        let lower_bounds = self.non_local_bounds(&self.outlives, &fr);\n+\n+        // In case we find more than one, reduce to one for\n+        // convenience.  This is to prevent us from generating more\n+        // complex constraints, but it will cause spurious errors.\n+        let post_dom = self\n+            .outlives\n+            .mutual_immediate_postdominator(lower_bounds);\n+\n+        debug!(\"non_local_bound: post_dom={:?}\", post_dom);\n+\n+        post_dom\n+            .and_then(|&post_dom| {\n+                // If the mutual immediate postdom is not local, then\n+                // there is no non-local result we can return.\n+                if !self.universal_regions.is_local_free_region(post_dom) {\n+                    Some(post_dom)\n+                } else {\n+                    None\n+                }\n+            })\n     }\n \n-    /// Helper for `non_local_upper_bound` and\n-    /// `non_local_lower_bound`. Repeatedly invokes `postdom_parent`\n-    /// until we find something that is not local. Returns `None` if we\n-    /// never do so.\n-    fn non_local_bound(\n+    /// Helper for `non_local_upper_bounds` and `non_local_lower_bounds`.\n+    /// Repeatedly invokes `postdom_parent` until we find something that is not\n+    /// local. Returns `None` if we never do so.\n+    fn non_local_bounds<'a>(\n         &self,\n-        relation: &TransitiveRelation<RegionVid>,\n-        fr0: RegionVid,\n-    ) -> Option<RegionVid> {\n+        relation: &'a TransitiveRelation<RegionVid>,\n+        fr0: &'a RegionVid,\n+    ) -> Vec<&'a RegionVid> {\n         // This method assumes that `fr0` is one of the universally\n         // quantified region variables.\n-        assert!(self.universal_regions.is_universal_region(fr0));\n+        assert!(self.universal_regions.is_universal_region(*fr0));\n \n         let mut external_parents = vec![];\n-        let mut queue = vec![&fr0];\n+        let mut queue = vec![fr0];\n \n         // Keep expanding `fr` into its parents until we reach\n         // non-local regions.\n@@ -157,24 +202,7 @@ impl UniversalRegionRelations<'tcx> {\n \n         debug!(\"non_local_bound: external_parents={:?}\", external_parents);\n \n-        // In case we find more than one, reduce to one for\n-        // convenience.  This is to prevent us from generating more\n-        // complex constraints, but it will cause spurious errors.\n-        let post_dom = relation\n-            .mutual_immediate_postdominator(external_parents)\n-            .cloned();\n-\n-        debug!(\"non_local_bound: post_dom={:?}\", post_dom);\n-\n-        post_dom.and_then(|post_dom| {\n-            // If the mutual immediate postdom is not local, then\n-            // there is no non-local result we can return.\n-            if !self.universal_regions.is_local_free_region(post_dom) {\n-                Some(post_dom)\n-            } else {\n-                None\n-            }\n-        })\n+        external_parents\n     }\n \n     /// Returns `true` if fr1 is known to outlive fr2."}, {"sha": "28d2a397f3ed61bc9b15811e7b5f34210612d97a", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f47ec2ad5b6887b3d400aee49e2294bd27733d18/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f47ec2ad5b6887b3d400aee49e2294bd27733d18/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=f47ec2ad5b6887b3d400aee49e2294bd27733d18", "patch": "@@ -7,7 +7,7 @@ use crate::build::scope::{CachedBlock, DropKind};\n use crate::build::ForGuard::{self, OutsideGuard, RefWithinGuard, ValWithinGuard};\n use crate::build::{BlockAnd, BlockAndExtension, Builder};\n use crate::build::{GuardFrame, GuardFrameLocal, LocalsForNode};\n-use crate::hair::*;\n+use crate::hair::{self, *};\n use rustc::mir::*;\n use rustc::ty::{self, CanonicalUserTypeAnnotation, Ty};\n use rustc::ty::layout::VariantIdx;\n@@ -283,9 +283,11 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     },\n                     ..\n                 },\n-                user_ty: pat_ascription_ty,\n-                variance: _,\n-                user_ty_span,\n+                ascription: hair::pattern::Ascription {\n+                    user_ty: pat_ascription_ty,\n+                    variance: _,\n+                    user_ty_span,\n+                },\n             } => {\n                 let place =\n                     self.storage_live_binding(block, var, irrefutable_pat.span, OutsideGuard);\n@@ -560,9 +562,11 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             }\n             PatternKind::AscribeUserType {\n                 ref subpattern,\n-                ref user_ty,\n-                user_ty_span,\n-                variance: _,\n+                ascription: hair::pattern::Ascription {\n+                    ref user_ty,\n+                    user_ty_span,\n+                    variance: _,\n+                },\n             } => {\n                 // This corresponds to something like\n                 //"}, {"sha": "b8e38e40b63474f479024aa3cc7e650a85c117c7", "filename": "src/librustc_mir/build/matches/simplify.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f47ec2ad5b6887b3d400aee49e2294bd27733d18/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f47ec2ad5b6887b3d400aee49e2294bd27733d18/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs?ref=f47ec2ad5b6887b3d400aee49e2294bd27733d18", "patch": "@@ -14,7 +14,7 @@\n \n use crate::build::Builder;\n use crate::build::matches::{Ascription, Binding, MatchPair, Candidate};\n-use crate::hair::*;\n+use crate::hair::{self, *};\n use rustc::ty;\n use rustc::ty::layout::{Integer, IntegerExt, Size};\n use syntax::attr::{SignedInt, UnsignedInt};\n@@ -58,9 +58,11 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         match *match_pair.pattern.kind {\n             PatternKind::AscribeUserType {\n                 ref subpattern,\n-                variance,\n-                ref user_ty,\n-                user_ty_span\n+                ascription: hair::pattern::Ascription {\n+                    variance,\n+                    ref user_ty,\n+                    user_ty_span,\n+                },\n             } => {\n                 // Apply the type ascription to the value at `match_pair.place`, which is the\n                 // value being matched, taking the variance field into account."}, {"sha": "4a64ddb73fc2ee8fe81a5f23264c890c38ba1d5b", "filename": "src/librustc_mir/hair/cx/block.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f47ec2ad5b6887b3d400aee49e2294bd27733d18/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f47ec2ad5b6887b3d400aee49e2294bd27733d18/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs?ref=f47ec2ad5b6887b3d400aee49e2294bd27733d18", "patch": "@@ -1,4 +1,4 @@\n-use crate::hair::*;\n+use crate::hair::{self, *};\n use crate::hair::cx::Cx;\n use crate::hair::cx::to_ref::ToRef;\n use rustc::middle::region;\n@@ -83,10 +83,12 @@ fn mirror_stmts<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                             ty: pattern.ty,\n                             span: pattern.span,\n                             kind: Box::new(PatternKind::AscribeUserType {\n-                                user_ty: PatternTypeProjection::from_user_type(user_ty),\n-                                user_ty_span: ty.span,\n+                                ascription: hair::pattern::Ascription {\n+                                    user_ty: PatternTypeProjection::from_user_type(user_ty),\n+                                    user_ty_span: ty.span,\n+                                    variance: ty::Variance::Covariant,\n+                                },\n                                 subpattern: pattern,\n-                                variance: ty::Variance::Covariant,\n                             })\n                         };\n                     }"}, {"sha": "1c7e1aa4d71e0a5bdca22031e3bd56ee9ff16055", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/f47ec2ad5b6887b3d400aee49e2294bd27733d18/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f47ec2ad5b6887b3d400aee49e2294bd27733d18/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=f47ec2ad5b6887b3d400aee49e2294bd27733d18", "patch": "@@ -871,18 +871,24 @@ impl<'tcx> IntRange<'tcx> {\n     }\n \n     fn from_pat(tcx: TyCtxt<'_, 'tcx, 'tcx>,\n-                pat: &Pattern<'tcx>)\n+                mut pat: &Pattern<'tcx>)\n                 -> Option<IntRange<'tcx>> {\n-        Self::from_ctor(tcx, &match pat.kind {\n-            box PatternKind::Constant { value } => ConstantValue(value),\n-            box PatternKind::Range(PatternRange { lo, hi, ty, end }) => ConstantRange(\n-                lo.to_bits(tcx, ty::ParamEnv::empty().and(ty)).unwrap(),\n-                hi.to_bits(tcx, ty::ParamEnv::empty().and(ty)).unwrap(),\n-                ty,\n-                end,\n-            ),\n-            _ => return None,\n-        })\n+        let range = loop {\n+            match pat.kind {\n+                box PatternKind::Constant { value } => break ConstantValue(value),\n+                box PatternKind::Range(PatternRange { lo, hi, ty, end }) => break ConstantRange(\n+                    lo.to_bits(tcx, ty::ParamEnv::empty().and(ty)).unwrap(),\n+                    hi.to_bits(tcx, ty::ParamEnv::empty().and(ty)).unwrap(),\n+                    ty,\n+                    end,\n+                ),\n+                box PatternKind::AscribeUserType { ref subpattern, .. } => {\n+                    pat = subpattern;\n+                },\n+                _ => return None,\n+            }\n+        };\n+        Self::from_ctor(tcx, &range)\n     }\n \n     // The return value of `signed_bias` should be XORed with an endpoint to encode/decode it."}, {"sha": "2012086ea664937584234cc38ad07eec82418467", "filename": "src/librustc_mir/hair/pattern/mod.rs", "status": "modified", "additions": 86, "deletions": 59, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/f47ec2ad5b6887b3d400aee49e2294bd27733d18/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f47ec2ad5b6887b3d400aee49e2294bd27733d18/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs?ref=f47ec2ad5b6887b3d400aee49e2294bd27733d18", "patch": "@@ -58,7 +58,7 @@ pub struct Pattern<'tcx> {\n }\n \n \n-#[derive(Clone, Debug)]\n+#[derive(Copy, Clone, Debug, PartialEq)]\n pub struct PatternTypeProjection<'tcx> {\n     pub user_ty: CanonicalUserType<'tcx>,\n }\n@@ -87,33 +87,38 @@ impl<'tcx> PatternTypeProjection<'tcx> {\n     }\n }\n \n+#[derive(Copy, Clone, Debug, PartialEq)]\n+pub struct Ascription<'tcx> {\n+    pub user_ty: PatternTypeProjection<'tcx>,\n+    /// Variance to use when relating the type `user_ty` to the **type of the value being\n+    /// matched**. Typically, this is `Variance::Covariant`, since the value being matched must\n+    /// have a type that is some subtype of the ascribed type.\n+    ///\n+    /// Note that this variance does not apply for any bindings within subpatterns. The type\n+    /// assigned to those bindings must be exactly equal to the `user_ty` given here.\n+    ///\n+    /// The only place where this field is not `Covariant` is when matching constants, where\n+    /// we currently use `Contravariant` -- this is because the constant type just needs to\n+    /// be \"comparable\" to the type of the input value. So, for example:\n+    ///\n+    /// ```text\n+    /// match x { \"foo\" => .. }\n+    /// ```\n+    ///\n+    /// requires that `&'static str <: T_x`, where `T_x` is the type of `x`. Really, we should\n+    /// probably be checking for a `PartialEq` impl instead, but this preserves the behavior\n+    /// of the old type-check for now. See #57280 for details.\n+    pub variance: ty::Variance,\n+    pub user_ty_span: Span,\n+}\n+\n #[derive(Clone, Debug)]\n pub enum PatternKind<'tcx> {\n     Wild,\n \n     AscribeUserType {\n-        user_ty: PatternTypeProjection<'tcx>,\n+        ascription: Ascription<'tcx>,\n         subpattern: Pattern<'tcx>,\n-        /// Variance to use when relating the type `user_ty` to the **type of the value being\n-        /// matched**. Typically, this is `Variance::Covariant`, since the value being matched must\n-        /// have a type that is some subtype of the ascribed type.\n-        ///\n-        /// Note that this variance does not apply for any bindings within subpatterns. The type\n-        /// assigned to those bindings must be exactly equal to the `user_ty` given here.\n-        ///\n-        /// The only place where this field is not `Covariant` is when matching constants, where\n-        /// we currently use `Contravariant` -- this is because the constant type just needs to\n-        /// be \"comparable\" to the type of the input value. So, for example:\n-        ///\n-        /// ```text\n-        /// match x { \"foo\" => .. }\n-        /// ```\n-        ///\n-        /// requires that `&'static str <: T_x`, where `T_x` is the type of `x`. Really, we should\n-        /// probably be checking for a `PartialEq` impl instead, but this preserves the behavior\n-        /// of the old type-check for now. See #57280 for details.\n-        variance: ty::Variance,\n-        user_ty_span: Span,\n     },\n \n     /// `x`, `ref x`, `x @ P`, etc.\n@@ -169,18 +174,7 @@ pub enum PatternKind<'tcx> {\n     },\n }\n \n-impl<'tcx> PatternKind<'tcx> {\n-    /// If this is a `PatternKind::AscribeUserType` then return the subpattern kind, otherwise\n-    /// return this pattern kind.\n-    fn with_user_type_ascription_subpattern(self) -> Self {\n-        match self {\n-            PatternKind::AscribeUserType { subpattern: Pattern { box kind, ..  }, ..  } => kind,\n-            kind => kind,\n-        }\n-    }\n-}\n-\n-#[derive(Clone, Copy, Debug, PartialEq)]\n+#[derive(Copy, Clone, Debug, PartialEq)]\n pub struct PatternRange<'tcx> {\n     pub lo: ty::Const<'tcx>,\n     pub hi: ty::Const<'tcx>,\n@@ -407,6 +401,19 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n             )\n     }\n \n+    fn lower_range_expr(\n+        &mut self,\n+        expr: &'tcx hir::Expr,\n+    ) -> (PatternKind<'tcx>, Option<Ascription<'tcx>>) {\n+        match self.lower_lit(expr) {\n+            PatternKind::AscribeUserType {\n+                ascription: lo_ascription,\n+                subpattern: Pattern { kind: box kind, .. },\n+            } => (kind, Some(lo_ascription)),\n+            kind => (kind, None),\n+        }\n+    }\n+\n     fn lower_pattern_unadjusted(&mut self, pat: &'tcx hir::Pat) -> Pattern<'tcx> {\n         let mut ty = self.tables.node_type(pat.hir_id);\n \n@@ -416,14 +423,10 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n             PatKind::Lit(ref value) => self.lower_lit(value),\n \n             PatKind::Range(ref lo_expr, ref hi_expr, end) => {\n-                match (\n-                    // Look for `PatternKind::Constant` patterns inside of any\n-                    // `PatternKind::AscribeUserType` patterns. Type ascriptions can be safely\n-                    // ignored for the purposes of lowering a range correctly - these are checked\n-                    // elsewhere for well-formedness.\n-                    self.lower_lit(lo_expr).with_user_type_ascription_subpattern(),\n-                    self.lower_lit(hi_expr).with_user_type_ascription_subpattern(),\n-                ) {\n+                let (lo, lo_ascription) = self.lower_range_expr(lo_expr);\n+                let (hi, hi_ascription) = self.lower_range_expr(hi_expr);\n+\n+                let mut kind = match (lo, hi) {\n                     (PatternKind::Constant { value: lo }, PatternKind::Constant { value: hi }) => {\n                         use std::cmp::Ordering;\n                         let cmp = compare_const_vals(\n@@ -472,17 +475,33 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                                 PatternKind::Wild\n                             }\n                         }\n-                    }\n+                    },\n                     ref pats => {\n                         self.tcx.sess.delay_span_bug(\n                             pat.span,\n-                            &format!(\"found bad range pattern `{:?}` outside of error recovery\",\n-                                     pats),\n+                            &format!(\n+                                \"found bad range pattern `{:?}` outside of error recovery\",\n+                                pats,\n+                            ),\n                         );\n \n                         PatternKind::Wild\n+                    },\n+                };\n+\n+                // If we are handling a range with associated constants (e.g.\n+                // `Foo::<'a>::A..=Foo::B`), we need to put the ascriptions for the associated\n+                // constants somewhere. Have them on the range pattern.\n+                for ascription in &[lo_ascription, hi_ascription] {\n+                    if let Some(ascription) = ascription {\n+                        kind = PatternKind::AscribeUserType {\n+                            ascription: *ascription,\n+                            subpattern: Pattern { span: pat.span, ty, kind: Box::new(kind), },\n+                        };\n                     }\n                 }\n+\n+                kind\n             }\n \n             PatKind::Path(ref qpath) => {\n@@ -758,9 +777,11 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                     ty,\n                     kind: Box::new(kind),\n                 },\n-                user_ty: PatternTypeProjection::from_user_type(user_ty),\n-                user_ty_span: span,\n-                variance: ty::Variance::Covariant,\n+                ascription: Ascription {\n+                    user_ty: PatternTypeProjection::from_user_type(user_ty),\n+                    user_ty_span: span,\n+                    variance: ty::Variance::Covariant,\n+                },\n             };\n         }\n \n@@ -810,11 +831,13 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                                         kind: Box::new(\n                                             PatternKind::AscribeUserType {\n                                                 subpattern: pattern,\n-                                                /// Note that use `Contravariant` here. See the\n-                                                /// `variance` field documentation for details.\n-                                                variance: ty::Variance::Contravariant,\n-                                                user_ty,\n-                                                user_ty_span: span,\n+                                                ascription: Ascription {\n+                                                    /// Note that use `Contravariant` here. See the\n+                                                    /// `variance` field documentation for details.\n+                                                    variance: ty::Variance::Contravariant,\n+                                                    user_ty,\n+                                                    user_ty_span: span,\n+                                                },\n                                             }\n                                         ),\n                                         ty: value.ty,\n@@ -1107,14 +1130,18 @@ impl<'tcx> PatternFoldable<'tcx> for PatternKind<'tcx> {\n             PatternKind::Wild => PatternKind::Wild,\n             PatternKind::AscribeUserType {\n                 ref subpattern,\n-                variance,\n-                ref user_ty,\n-                user_ty_span,\n+                ascription: Ascription {\n+                    variance,\n+                    ref user_ty,\n+                    user_ty_span,\n+                },\n             } => PatternKind::AscribeUserType {\n                 subpattern: subpattern.fold_with(folder),\n-                user_ty: user_ty.fold_with(folder),\n-                variance,\n-                user_ty_span,\n+                ascription: Ascription {\n+                    user_ty: user_ty.fold_with(folder),\n+                    variance,\n+                    user_ty_span,\n+                },\n             },\n             PatternKind::Binding {\n                 mutability,"}, {"sha": "25595e14982aee0ec6f721ecc2beabcf2c4fd842", "filename": "src/rustllvm/PassWrapper.cpp", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f47ec2ad5b6887b3d400aee49e2294bd27733d18/src%2Frustllvm%2FPassWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/f47ec2ad5b6887b3d400aee49e2294bd27733d18/src%2Frustllvm%2FPassWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FPassWrapper.cpp?ref=f47ec2ad5b6887b3d400aee49e2294bd27733d18", "patch": "@@ -1092,10 +1092,10 @@ LLVMRustThinLTOBufferLen(const LLVMRustThinLTOBuffer *Buffer) {\n // processing.  We'll call this once per module optimized through ThinLTO, and\n // it'll be called concurrently on many threads.\n extern \"C\" LLVMModuleRef\n-LLVMRustParseBitcodeForThinLTO(LLVMContextRef Context,\n-                               const char *data,\n-                               size_t len,\n-                               const char *identifier) {\n+LLVMRustParseBitcodeForLTO(LLVMContextRef Context,\n+                           const char *data,\n+                           size_t len,\n+                           const char *identifier) {\n   StringRef Data(data, len);\n   MemoryBufferRef Buffer(Data, identifier);\n   unwrap(Context)->enableDebugTypeODRUniquing();"}, {"sha": "2a3e3c2467cdc00e2d74f3652d2987549f043805", "filename": "src/test/incremental/lto.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/f47ec2ad5b6887b3d400aee49e2294bd27733d18/src%2Ftest%2Fincremental%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f47ec2ad5b6887b3d400aee49e2294bd27733d18/src%2Ftest%2Fincremental%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Flto.rs?ref=f47ec2ad5b6887b3d400aee49e2294bd27733d18", "patch": "@@ -0,0 +1,40 @@\n+// no-prefer-dynamic\n+// revisions:rpass1 rpass2\n+// compile-flags: -C lto\n+\n+mod x {\n+    pub struct X {\n+        x: u32, y: u32,\n+    }\n+\n+    #[cfg(rpass1)]\n+    fn make() -> X {\n+        X { x: 22, y: 0 }\n+    }\n+\n+    #[cfg(rpass2)]\n+    fn make() -> X {\n+        X { x: 11, y: 11 }\n+    }\n+\n+    pub fn new() -> X {\n+        make()\n+    }\n+\n+    pub fn sum(x: &X) -> u32 {\n+        x.x + x.y\n+    }\n+}\n+\n+mod y {\n+    use x;\n+\n+    pub fn assert_sum() -> bool {\n+        let x = x::new();\n+        x::sum(&x) == 22\n+    }\n+}\n+\n+pub fn main() {\n+    y::assert_sum();\n+}"}, {"sha": "bd7f327bc0f63de1e840f8e35995f77ccc1dd6bd", "filename": "src/test/ui/lint/lint-group-nonstandard-style.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f47ec2ad5b6887b3d400aee49e2294bd27733d18/src%2Ftest%2Fui%2Flint%2Flint-group-nonstandard-style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f47ec2ad5b6887b3d400aee49e2294bd27733d18/src%2Ftest%2Fui%2Flint%2Flint-group-nonstandard-style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-group-nonstandard-style.rs?ref=f47ec2ad5b6887b3d400aee49e2294bd27733d18", "patch": "@@ -19,7 +19,7 @@ mod test {\n \n         fn CamelCase() {} //~ WARN should have a snake\n \n-        struct snake_case; //~ WARN should have a camel\n+        struct snake_case; //~ WARN should have an upper camel\n     }\n }\n "}, {"sha": "ab36cda57ec80527374c5fcbc358c78971c6ec36", "filename": "src/test/ui/lint/lint-group-nonstandard-style.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f47ec2ad5b6887b3d400aee49e2294bd27733d18/src%2Ftest%2Fui%2Flint%2Flint-group-nonstandard-style.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f47ec2ad5b6887b3d400aee49e2294bd27733d18/src%2Ftest%2Fui%2Flint%2Flint-group-nonstandard-style.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-group-nonstandard-style.stderr?ref=f47ec2ad5b6887b3d400aee49e2294bd27733d18", "patch": "@@ -1,8 +1,8 @@\n-warning: type `snake_case` should have a camel case name\n+warning: type `snake_case` should have an upper camel case name\n   --> $DIR/lint-group-nonstandard-style.rs:22:16\n    |\n-LL |         struct snake_case; //~ WARN should have a camel\n-   |                ^^^^^^^^^^ help: convert the identifier to camel case: `SnakeCase`\n+LL |         struct snake_case; //~ WARN should have an upper camel\n+   |                ^^^^^^^^^^ help: convert the identifier to upper camel case: `SnakeCase`\n    |\n note: lint level defined here\n   --> $DIR/lint-group-nonstandard-style.rs:18:17"}, {"sha": "d3b119a944109d59a56178ab38cc635b72bffe0b", "filename": "src/test/ui/lint/lint-non-camel-case-types.rs", "status": "modified", "additions": 8, "deletions": 16, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/f47ec2ad5b6887b3d400aee49e2294bd27733d18/src%2Ftest%2Fui%2Flint%2Flint-non-camel-case-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f47ec2ad5b6887b3d400aee49e2294bd27733d18/src%2Ftest%2Fui%2Flint%2Flint-non-camel-case-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-non-camel-case-types.rs?ref=f47ec2ad5b6887b3d400aee49e2294bd27733d18", "patch": "@@ -2,43 +2,35 @@\n #![allow(dead_code)]\n \n struct ONE_TWO_THREE;\n-//~^ ERROR type `ONE_TWO_THREE` should have a camel case name\n+//~^ ERROR type `ONE_TWO_THREE` should have an upper camel case name\n \n-struct foo { //~ ERROR type `foo` should have a camel case name\n+struct foo { //~ ERROR type `foo` should have an upper camel case name\n     bar: isize,\n }\n \n-enum foo2 { //~ ERROR type `foo2` should have a camel case name\n+enum foo2 { //~ ERROR type `foo2` should have an upper camel case name\n     Bar\n }\n \n-struct foo3 { //~ ERROR type `foo3` should have a camel case name\n+struct foo3 { //~ ERROR type `foo3` should have an upper camel case name\n     bar: isize\n }\n \n-type foo4 = isize; //~ ERROR type `foo4` should have a camel case name\n+type foo4 = isize; //~ ERROR type `foo4` should have an upper camel case name\n \n enum Foo5 {\n-    bar //~ ERROR variant `bar` should have a camel case name\n+    bar //~ ERROR variant `bar` should have an upper camel case name\n }\n \n-trait foo6 { //~ ERROR trait `foo6` should have a camel case name\n+trait foo6 { //~ ERROR trait `foo6` should have an upper camel case name\n     fn dummy(&self) { }\n }\n \n-fn f<ty>(_: ty) {} //~ ERROR type parameter `ty` should have a camel case name\n+fn f<ty>(_: ty) {} //~ ERROR type parameter `ty` should have an upper camel case name\n \n #[repr(C)]\n struct foo7 {\n     bar: isize,\n }\n \n-struct X86_64;\n-\n-struct X86__64; //~ ERROR type `X86__64` should have a camel case name\n-\n-struct Abc_123; //~ ERROR type `Abc_123` should have a camel case name\n-\n-struct A1_b2_c3; //~ ERROR type `A1_b2_c3` should have a camel case name\n-\n fn main() { }"}, {"sha": "7afacf64d8778589e654f664d89b49d1ac3c39f7", "filename": "src/test/ui/lint/lint-non-camel-case-types.stderr", "status": "modified", "additions": 24, "deletions": 42, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/f47ec2ad5b6887b3d400aee49e2294bd27733d18/src%2Ftest%2Fui%2Flint%2Flint-non-camel-case-types.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f47ec2ad5b6887b3d400aee49e2294bd27733d18/src%2Ftest%2Fui%2Flint%2Flint-non-camel-case-types.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-non-camel-case-types.stderr?ref=f47ec2ad5b6887b3d400aee49e2294bd27733d18", "patch": "@@ -1,74 +1,56 @@\n-error: type `ONE_TWO_THREE` should have a camel case name\n+error: type `ONE_TWO_THREE` should have an upper camel case name\n   --> $DIR/lint-non-camel-case-types.rs:4:8\n    |\n LL | struct ONE_TWO_THREE;\n-   |        ^^^^^^^^^^^^^ help: convert the identifier to camel case: `OneTwoThree`\n+   |        ^^^^^^^^^^^^^ help: convert the identifier to upper camel case: `OneTwoThree`\n    |\n note: lint level defined here\n   --> $DIR/lint-non-camel-case-types.rs:1:11\n    |\n LL | #![forbid(non_camel_case_types)]\n    |           ^^^^^^^^^^^^^^^^^^^^\n \n-error: type `foo` should have a camel case name\n+error: type `foo` should have an upper camel case name\n   --> $DIR/lint-non-camel-case-types.rs:7:8\n    |\n-LL | struct foo { //~ ERROR type `foo` should have a camel case name\n-   |        ^^^ help: convert the identifier to camel case: `Foo`\n+LL | struct foo { //~ ERROR type `foo` should have an upper camel case name\n+   |        ^^^ help: convert the identifier to upper camel case: `Foo`\n \n-error: type `foo2` should have a camel case name\n+error: type `foo2` should have an upper camel case name\n   --> $DIR/lint-non-camel-case-types.rs:11:6\n    |\n-LL | enum foo2 { //~ ERROR type `foo2` should have a camel case name\n-   |      ^^^^ help: convert the identifier to camel case: `Foo2`\n+LL | enum foo2 { //~ ERROR type `foo2` should have an upper camel case name\n+   |      ^^^^ help: convert the identifier to upper camel case: `Foo2`\n \n-error: type `foo3` should have a camel case name\n+error: type `foo3` should have an upper camel case name\n   --> $DIR/lint-non-camel-case-types.rs:15:8\n    |\n-LL | struct foo3 { //~ ERROR type `foo3` should have a camel case name\n-   |        ^^^^ help: convert the identifier to camel case: `Foo3`\n+LL | struct foo3 { //~ ERROR type `foo3` should have an upper camel case name\n+   |        ^^^^ help: convert the identifier to upper camel case: `Foo3`\n \n-error: type `foo4` should have a camel case name\n+error: type `foo4` should have an upper camel case name\n   --> $DIR/lint-non-camel-case-types.rs:19:6\n    |\n-LL | type foo4 = isize; //~ ERROR type `foo4` should have a camel case name\n-   |      ^^^^ help: convert the identifier to camel case: `Foo4`\n+LL | type foo4 = isize; //~ ERROR type `foo4` should have an upper camel case name\n+   |      ^^^^ help: convert the identifier to upper camel case: `Foo4`\n \n-error: variant `bar` should have a camel case name\n+error: variant `bar` should have an upper camel case name\n   --> $DIR/lint-non-camel-case-types.rs:22:5\n    |\n-LL |     bar //~ ERROR variant `bar` should have a camel case name\n-   |     ^^^ help: convert the identifier to camel case: `Bar`\n+LL |     bar //~ ERROR variant `bar` should have an upper camel case name\n+   |     ^^^ help: convert the identifier to upper camel case: `Bar`\n \n-error: trait `foo6` should have a camel case name\n+error: trait `foo6` should have an upper camel case name\n   --> $DIR/lint-non-camel-case-types.rs:25:7\n    |\n-LL | trait foo6 { //~ ERROR trait `foo6` should have a camel case name\n-   |       ^^^^ help: convert the identifier to camel case: `Foo6`\n+LL | trait foo6 { //~ ERROR trait `foo6` should have an upper camel case name\n+   |       ^^^^ help: convert the identifier to upper camel case: `Foo6`\n \n-error: type parameter `ty` should have a camel case name\n+error: type parameter `ty` should have an upper camel case name\n   --> $DIR/lint-non-camel-case-types.rs:29:6\n    |\n-LL | fn f<ty>(_: ty) {} //~ ERROR type parameter `ty` should have a camel case name\n-   |      ^^ help: convert the identifier to camel case: `Ty`\n+LL | fn f<ty>(_: ty) {} //~ ERROR type parameter `ty` should have an upper camel case name\n+   |      ^^ help: convert the identifier to upper camel case: `Ty`\n \n-error: type `X86__64` should have a camel case name\n-  --> $DIR/lint-non-camel-case-types.rs:38:8\n-   |\n-LL | struct X86__64; //~ ERROR type `X86__64` should have a camel case name\n-   |        ^^^^^^^ help: convert the identifier to camel case: `X86_64`\n-\n-error: type `Abc_123` should have a camel case name\n-  --> $DIR/lint-non-camel-case-types.rs:40:8\n-   |\n-LL | struct Abc_123; //~ ERROR type `Abc_123` should have a camel case name\n-   |        ^^^^^^^ help: convert the identifier to camel case: `Abc123`\n-\n-error: type `A1_b2_c3` should have a camel case name\n-  --> $DIR/lint-non-camel-case-types.rs:42:8\n-   |\n-LL | struct A1_b2_c3; //~ ERROR type `A1_b2_c3` should have a camel case name\n-   |        ^^^^^^^^ help: convert the identifier to camel case: `A1B2C3`\n-\n-error: aborting due to 11 previous errors\n+error: aborting due to 8 previous errors\n "}, {"sha": "71d5d4053ee252cbb89de224860fef2a146cdfc6", "filename": "src/test/ui/nll/closure-requirements/issue-58127-mutliple-requirements.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/f47ec2ad5b6887b3d400aee49e2294bd27733d18/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fissue-58127-mutliple-requirements.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f47ec2ad5b6887b3d400aee49e2294bd27733d18/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fissue-58127-mutliple-requirements.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fissue-58127-mutliple-requirements.rs?ref=f47ec2ad5b6887b3d400aee49e2294bd27733d18", "patch": "@@ -0,0 +1,40 @@\n+// revisions: migrate nll\n+//[migrate]compile-flags: -Z borrowck=migrate\n+#![cfg_attr(nll, feature(nll))]\n+\n+// compile-pass\n+\n+// Test that we propagate region relations from closures precisely when there is\n+// more than one non-local lower bound.\n+\n+// In this case the closure has signature\n+// |x: &'4 mut (&'5 (&'1 str, &'2 str), &'3 str)| -> ..\n+// We end up with a `'3: '5` constraint that we can propagate as\n+// `'3: '1`, `'3: '2`, but previously we approximated it as `'3: 'static`.\n+\n+// As an optimization, we primarily propagate bounds for the \"representative\"\n+// of each SCC. As such we have these two similar cases where hopefully one\n+// of them will test the case we want (case2, when this test was added).\n+mod case1 {\n+    fn f(s: &str) {\n+        g(s, |x| h(x));\n+    }\n+\n+    fn g<T, F>(_: T, _: F)\n+    where F: Fn(&mut (&(T, T), T)) {}\n+\n+    fn h<T>(_: &mut (&(T, T), T)) {}\n+}\n+\n+mod case2 {\n+    fn f(s: &str) {\n+        g(s, |x| h(x));\n+    }\n+\n+    fn g<T, F>(_: T, _: F)\n+    where F: Fn(&mut (T, &(T, T))) {}\n+\n+    fn h<T>(_: &mut (T, &(T, T))) {}\n+}\n+\n+fn main() {}"}, {"sha": "9267cac5dd3d75c559ee6d3c8beb45ce15259452", "filename": "src/test/ui/nll/issue-58299.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/f47ec2ad5b6887b3d400aee49e2294bd27733d18/src%2Ftest%2Fui%2Fnll%2Fissue-58299.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f47ec2ad5b6887b3d400aee49e2294bd27733d18/src%2Ftest%2Fui%2Fnll%2Fissue-58299.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-58299.rs?ref=f47ec2ad5b6887b3d400aee49e2294bd27733d18", "patch": "@@ -0,0 +1,30 @@\n+#![allow(dead_code)]\n+#![feature(nll)]\n+\n+struct A<'a>(&'a ());\n+\n+trait Y {\n+    const X: i32;\n+}\n+\n+impl Y for A<'static> {\n+    const X: i32 = 10;\n+}\n+\n+fn foo<'a>(x: i32) {\n+    match x {\n+        // This uses <A<'a> as Y>::X, but `A<'a>` does not implement `Y`.\n+        A::<'a>::X..=A::<'static>::X => (), //~ ERROR lifetime may not live long enough\n+        _ => (),\n+    }\n+}\n+\n+fn bar<'a>(x: i32) {\n+    match x {\n+        // This uses <A<'a> as Y>::X, but `A<'a>` does not implement `Y`.\n+        A::<'static>::X..=A::<'a>::X => (), //~ ERROR lifetime may not live long enough\n+        _ => (),\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "b87d0de51a37e216ad5a8a2edc7991cdd31a456e", "filename": "src/test/ui/nll/issue-58299.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f47ec2ad5b6887b3d400aee49e2294bd27733d18/src%2Ftest%2Fui%2Fnll%2Fissue-58299.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f47ec2ad5b6887b3d400aee49e2294bd27733d18/src%2Ftest%2Fui%2Fnll%2Fissue-58299.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-58299.stderr?ref=f47ec2ad5b6887b3d400aee49e2294bd27733d18", "patch": "@@ -0,0 +1,20 @@\n+error: lifetime may not live long enough\n+  --> $DIR/issue-58299.rs:17:9\n+   |\n+LL | fn foo<'a>(x: i32) {\n+   |        -- lifetime `'a` defined here\n+...\n+LL |         A::<'a>::X..=A::<'static>::X => (), //~ ERROR lifetime may not live long enough\n+   |         ^^^^^^^^^^ requires that `'a` must outlive `'static`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/issue-58299.rs:25:27\n+   |\n+LL | fn bar<'a>(x: i32) {\n+   |        -- lifetime `'a` defined here\n+...\n+LL |         A::<'static>::X..=A::<'a>::X => (), //~ ERROR lifetime may not live long enough\n+   |                           ^^^^^^^^^^ requires that `'a` must outlive `'static`\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "f59d5502aae30b3c98053b2e371ae910b87651a9", "filename": "src/test/ui/utf8_idents.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f47ec2ad5b6887b3d400aee49e2294bd27733d18/src%2Ftest%2Fui%2Futf8_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f47ec2ad5b6887b3d400aee49e2294bd27733d18/src%2Ftest%2Fui%2Futf8_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Futf8_idents.rs?ref=f47ec2ad5b6887b3d400aee49e2294bd27733d18", "patch": "@@ -1,9 +1,7 @@\n-//\n-\n fn foo<\n     '\u03b2, //~ ERROR non-ascii idents are not fully supported\n     \u03b3  //~ ERROR non-ascii idents are not fully supported\n-       //~^ WARN type parameter `\u03b3` should have a camel case name\n+       //~^ WARN type parameter `\u03b3` should have an upper camel case name\n >() {}\n \n struct X {"}, {"sha": "52fb607af5b2573359ca9bb0e76a1168811a56ce", "filename": "src/test/ui/utf8_idents.stderr", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f47ec2ad5b6887b3d400aee49e2294bd27733d18/src%2Ftest%2Fui%2Futf8_idents.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f47ec2ad5b6887b3d400aee49e2294bd27733d18/src%2Ftest%2Fui%2Futf8_idents.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Futf8_idents.stderr?ref=f47ec2ad5b6887b3d400aee49e2294bd27733d18", "patch": "@@ -1,40 +1,40 @@\n error[E0658]: non-ascii idents are not fully supported. (see issue #55467)\n-  --> $DIR/utf8_idents.rs:4:5\n+  --> $DIR/utf8_idents.rs:2:5\n    |\n LL |     '\u03b2, //~ ERROR non-ascii idents are not fully supported\n    |     ^^\n    |\n    = help: add #![feature(non_ascii_idents)] to the crate attributes to enable\n \n error[E0658]: non-ascii idents are not fully supported. (see issue #55467)\n-  --> $DIR/utf8_idents.rs:5:5\n+  --> $DIR/utf8_idents.rs:3:5\n    |\n LL |     \u03b3  //~ ERROR non-ascii idents are not fully supported\n    |     ^\n    |\n    = help: add #![feature(non_ascii_idents)] to the crate attributes to enable\n \n error[E0658]: non-ascii idents are not fully supported. (see issue #55467)\n-  --> $DIR/utf8_idents.rs:10:5\n+  --> $DIR/utf8_idents.rs:8:5\n    |\n LL |     \u03b4: usize //~ ERROR non-ascii idents are not fully supported\n    |     ^\n    |\n    = help: add #![feature(non_ascii_idents)] to the crate attributes to enable\n \n error[E0658]: non-ascii idents are not fully supported. (see issue #55467)\n-  --> $DIR/utf8_idents.rs:14:9\n+  --> $DIR/utf8_idents.rs:12:9\n    |\n LL |     let \u03b1 = 0.00001f64; //~ ERROR non-ascii idents are not fully supported\n    |         ^\n    |\n    = help: add #![feature(non_ascii_idents)] to the crate attributes to enable\n \n-warning: type parameter `\u03b3` should have a camel case name\n-  --> $DIR/utf8_idents.rs:5:5\n+warning: type parameter `\u03b3` should have an upper camel case name\n+  --> $DIR/utf8_idents.rs:3:5\n    |\n LL |     \u03b3  //~ ERROR non-ascii idents are not fully supported\n-   |     ^ help: convert the identifier to camel case: `\u0393`\n+   |     ^ help: convert the identifier to upper camel case: `\u0393`\n    |\n    = note: #[warn(non_camel_case_types)] on by default\n "}, {"sha": "24d6fd5b19ba9b87f34506c7489f611c8fc11a03", "filename": "src/tools/publish_toolstate.py", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f47ec2ad5b6887b3d400aee49e2294bd27733d18/src%2Ftools%2Fpublish_toolstate.py", "raw_url": "https://github.com/rust-lang/rust/raw/f47ec2ad5b6887b3d400aee49e2294bd27733d18/src%2Ftools%2Fpublish_toolstate.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fpublish_toolstate.py?ref=f47ec2ad5b6887b3d400aee49e2294bd27733d18", "patch": "@@ -17,7 +17,7 @@\n     'miri': '@oli-obk @RalfJung @eddyb',\n     'clippy-driver': '@Manishearth @llogiq @mcarton @oli-obk',\n     'rls': '@nrc @Xanewok',\n-    'rustfmt': '@nrc',\n+    'rustfmt': '@nrc @topecongiro',\n     'book': '@carols10cents @steveklabnik',\n     'nomicon': '@frewsxcv @Gankro',\n     'reference': '@steveklabnik @Havvy @matthewjasper @alercah',"}]}