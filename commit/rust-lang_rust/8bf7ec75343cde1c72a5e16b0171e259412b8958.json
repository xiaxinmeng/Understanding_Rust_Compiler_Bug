{"sha": "8bf7ec75343cde1c72a5e16b0171e259412b8958", "node_id": "C_kwDOAAsO6NoAKDhiZjdlYzc1MzQzY2RlMWM3MmE1ZTE2YjAxNzFlMjU5NDEyYjg5NTg", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-12-27T02:40:56Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-12-27T03:12:31Z"}, "message": "Deduplicate more op-flavored methods", "tree": {"sha": "d3e3afa529bce7c1437db187e6d719328092823d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d3e3afa529bce7c1437db187e6d719328092823d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8bf7ec75343cde1c72a5e16b0171e259412b8958", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8bf7ec75343cde1c72a5e16b0171e259412b8958", "html_url": "https://github.com/rust-lang/rust/commit/8bf7ec75343cde1c72a5e16b0171e259412b8958", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8bf7ec75343cde1c72a5e16b0171e259412b8958/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "43b2486a9589380fd10698c2169351641a142f2e", "url": "https://api.github.com/repos/rust-lang/rust/commits/43b2486a9589380fd10698c2169351641a142f2e", "html_url": "https://github.com/rust-lang/rust/commit/43b2486a9589380fd10698c2169351641a142f2e"}], "stats": {"total": 121, "additions": 37, "deletions": 84}, "files": [{"sha": "829913d278d06233d4c6997da67f003b2f586fb0", "filename": "compiler/rustc_hir_typeck/src/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8bf7ec75343cde1c72a5e16b0171e259412b8958/compiler%2Frustc_hir_typeck%2Fsrc%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bf7ec75343cde1c72a5e16b0171e259412b8958/compiler%2Frustc_hir_typeck%2Fsrc%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fcallee.rs?ref=8bf7ec75343cde1c72a5e16b0171e259412b8958", "patch": "@@ -241,7 +241,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             });\n \n             if let Some(ok) = self.lookup_method_in_trait(\n-                call_expr.span,\n+                self.misc(call_expr.span),\n                 method_name,\n                 trait_def_id,\n                 adjusted_ty,"}, {"sha": "b9b27e8627aff7024bd75538500b368ee1e93280", "filename": "compiler/rustc_hir_typeck/src/method/mod.rs", "status": "modified", "additions": 12, "deletions": 77, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/8bf7ec75343cde1c72a5e16b0171e259412b8958/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bf7ec75343cde1c72a5e16b0171e259412b8958/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fmod.rs?ref=8bf7ec75343cde1c72a5e16b0171e259412b8958", "patch": "@@ -11,7 +11,7 @@ pub use self::suggest::SelfSource;\n pub use self::MethodError::*;\n \n use crate::errors::OpMethodGenericParams;\n-use crate::{Expectation, FnCtxt};\n+use crate::FnCtxt;\n use rustc_data_structures::sync::Lrc;\n use rustc_errors::{Applicability, Diagnostic};\n use rustc_hir as hir;\n@@ -264,7 +264,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     pub(super) fn obligation_for_method(\n         &self,\n-        span: Span,\n+        cause: ObligationCause<'tcx>,\n         trait_def_id: DefId,\n         self_ty: Ty<'tcx>,\n         opt_input_types: Option<&[Ty<'tcx>]>,\n@@ -282,70 +282,19 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     }\n                 }\n             }\n-            self.var_for_def(span, param)\n-        });\n-\n-        let trait_ref = self.tcx.mk_trait_ref(trait_def_id, substs);\n-\n-        // Construct an obligation\n-        let poly_trait_ref = ty::Binder::dummy(trait_ref);\n-        (\n-            traits::Obligation::misc(\n-                self.tcx,\n-                span,\n-                self.body_id,\n-                self.param_env,\n-                poly_trait_ref.without_const(),\n-            ),\n-            substs,\n-        )\n-    }\n-\n-    pub(super) fn obligation_for_op_method(\n-        &self,\n-        span: Span,\n-        trait_def_id: DefId,\n-        self_ty: Ty<'tcx>,\n-        opt_rhs: Option<(&'tcx hir::Expr<'tcx>, Ty<'tcx>)>,\n-        expected: Expectation<'tcx>,\n-    ) -> (traits::Obligation<'tcx, ty::Predicate<'tcx>>, &'tcx ty::List<ty::subst::GenericArg<'tcx>>)\n-    {\n-        // Construct a trait-reference `self_ty : Trait<input_tys>`\n-        let substs = InternalSubsts::for_item(self.tcx, trait_def_id, |param, _| {\n-            match param.kind {\n-                GenericParamDefKind::Lifetime | GenericParamDefKind::Const { .. } => {}\n-                GenericParamDefKind::Type { .. } => {\n-                    if param.index == 0 {\n-                        return self_ty.into();\n-                    } else if let Some((_, input_type)) = opt_rhs {\n-                        return input_type.into();\n-                    }\n-                }\n-            }\n-            self.var_for_def(span, param)\n+            self.var_for_def(cause.span, param)\n         });\n \n         let trait_ref = self.tcx.mk_trait_ref(trait_def_id, substs);\n \n         // Construct an obligation\n         let poly_trait_ref = ty::Binder::dummy(trait_ref);\n-        let output_ty = expected.only_has_type(self).and_then(|ty| (!ty.needs_infer()).then(|| ty));\n-\n         (\n             traits::Obligation::new(\n                 self.tcx,\n-                traits::ObligationCause::new(\n-                    span,\n-                    self.body_id,\n-                    traits::BinOp {\n-                        rhs_span: opt_rhs.map(|(expr, _)| expr.span),\n-                        is_lit: opt_rhs\n-                            .map_or(false, |(expr, _)| matches!(expr.kind, hir::ExprKind::Lit(_))),\n-                        output_ty,\n-                    },\n-                ),\n+                cause,\n                 self.param_env,\n-                poly_trait_ref,\n+                poly_trait_ref.without_const(),\n             ),\n             substs,\n         )\n@@ -356,40 +305,25 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// In particular, it doesn't really do any probing: it simply constructs\n     /// an obligation for a particular trait with the given self type and checks\n     /// whether that trait is implemented.\n-    #[instrument(level = \"debug\", skip(self, span))]\n+    #[instrument(level = \"debug\", skip(self))]\n     pub(super) fn lookup_method_in_trait(\n         &self,\n-        span: Span,\n+        cause: ObligationCause<'tcx>,\n         m_name: Ident,\n         trait_def_id: DefId,\n         self_ty: Ty<'tcx>,\n         opt_input_types: Option<&[Ty<'tcx>]>,\n     ) -> Option<InferOk<'tcx, MethodCallee<'tcx>>> {\n         let (obligation, substs) =\n-            self.obligation_for_method(span, trait_def_id, self_ty, opt_input_types);\n-        self.construct_obligation_for_trait(span, m_name, trait_def_id, obligation, substs)\n-    }\n-\n-    pub(super) fn lookup_op_method_in_trait(\n-        &self,\n-        span: Span,\n-        m_name: Ident,\n-        trait_def_id: DefId,\n-        self_ty: Ty<'tcx>,\n-        opt_rhs: Option<(&'tcx hir::Expr<'tcx>, Ty<'tcx>)>,\n-        expected: Expectation<'tcx>,\n-    ) -> Option<InferOk<'tcx, MethodCallee<'tcx>>> {\n-        let (obligation, substs) =\n-            self.obligation_for_op_method(span, trait_def_id, self_ty, opt_rhs, expected);\n-        self.construct_obligation_for_trait(span, m_name, trait_def_id, obligation, substs)\n+            self.obligation_for_method(cause, trait_def_id, self_ty, opt_input_types);\n+        self.construct_obligation_for_trait(m_name, trait_def_id, obligation, substs)\n     }\n \n     // FIXME(#18741): it seems likely that we can consolidate some of this\n     // code with the other method-lookup code. In particular, the second half\n     // of this method is basically the same as confirmation.\n     fn construct_obligation_for_trait(\n         &self,\n-        span: Span,\n         m_name: Ident,\n         trait_def_id: DefId,\n         obligation: traits::PredicateObligation<'tcx>,\n@@ -409,7 +343,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let tcx = self.tcx;\n         let Some(method_item) = self.associated_value(trait_def_id, m_name) else {\n             tcx.sess.delay_span_bug(\n-                span,\n+                obligation.cause.span,\n                 \"operator trait does not have corresponding operator method\",\n             );\n             return None;\n@@ -435,7 +369,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // with bound regions.\n         let fn_sig = tcx.bound_fn_sig(def_id);\n         let fn_sig = fn_sig.subst(self.tcx, substs);\n-        let fn_sig = self.replace_bound_vars_with_fresh_vars(span, infer::FnCall, fn_sig);\n+        let fn_sig =\n+            self.replace_bound_vars_with_fresh_vars(obligation.cause.span, infer::FnCall, fn_sig);\n \n         let InferOk { value, obligations: o } =\n             self.at(&obligation.cause, self.param_env).normalize(fn_sig);"}, {"sha": "34140f3e1fe3e535a0d4d82e5090e9e4e0511821", "filename": "compiler/rustc_hir_typeck/src/op.rs", "status": "modified", "additions": 22, "deletions": 4, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/8bf7ec75343cde1c72a5e16b0171e259412b8958/compiler%2Frustc_hir_typeck%2Fsrc%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bf7ec75343cde1c72a5e16b0171e259412b8958/compiler%2Frustc_hir_typeck%2Fsrc%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fop.rs?ref=8bf7ec75343cde1c72a5e16b0171e259412b8958", "patch": "@@ -12,14 +12,16 @@ use rustc_middle::ty::adjustment::{\n     Adjust, Adjustment, AllowTwoPhase, AutoBorrow, AutoBorrowMutability,\n };\n use rustc_middle::ty::print::with_no_trimmed_paths;\n-use rustc_middle::ty::{self, DefIdTree, Ty, TyCtxt, TypeFolder, TypeSuperFoldable, TypeVisitable};\n+use rustc_middle::ty::{\n+    self, DefIdTree, IsSuggestable, Ty, TyCtxt, TypeFolder, TypeSuperFoldable, TypeVisitable,\n+};\n use rustc_session::errors::ExprParenthesesNeeded;\n use rustc_span::source_map::Spanned;\n use rustc_span::symbol::{sym, Ident};\n use rustc_span::Span;\n use rustc_trait_selection::infer::InferCtxtExt;\n use rustc_trait_selection::traits::error_reporting::suggestions::TypeErrCtxtExt as _;\n-use rustc_trait_selection::traits::FulfillmentError;\n+use rustc_trait_selection::traits::{self, FulfillmentError};\n use rustc_type_ir::sty::TyKind::*;\n \n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n@@ -486,6 +488,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                             if let Some(output_def_id) = output_def_id\n                                                 && let Some(trait_def_id) = trait_def_id\n                                                 && self.tcx.parent(output_def_id) == trait_def_id\n+                                                && output_ty.is_suggestable(self.tcx, false)\n                                             {\n                                                 Some((\"Output\", *output_ty))\n                                             } else {\n@@ -735,12 +738,27 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 Op::Unary(..) => 0,\n             },\n         ) {\n+            self.tcx\n+                .sess\n+                .delay_span_bug(span, \"operator didn't have the right number of generic args\");\n             return Err(vec![]);\n         }\n \n         let opname = Ident::with_dummy_span(opname);\n+        let input_types =\n+            opt_rhs.as_ref().map(|(_, ty)| std::slice::from_ref(ty)).unwrap_or_default();\n+        let cause = self.cause(\n+            span,\n+            traits::BinOp {\n+                rhs_span: opt_rhs.map(|(expr, _)| expr.span),\n+                is_lit: opt_rhs\n+                    .map_or(false, |(expr, _)| matches!(expr.kind, hir::ExprKind::Lit(_))),\n+                output_ty: expected.only_has_type(self),\n+            },\n+        );\n+\n         let method = trait_did.and_then(|trait_did| {\n-            self.lookup_op_method_in_trait(span, opname, trait_did, lhs_ty, opt_rhs, expected)\n+            self.lookup_method_in_trait(cause.clone(), opname, trait_did, lhs_ty, Some(input_types))\n         });\n \n         match (method, trait_did) {\n@@ -752,7 +770,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             (None, None) => Err(vec![]),\n             (None, Some(trait_did)) => {\n                 let (obligation, _) =\n-                    self.obligation_for_op_method(span, trait_did, lhs_ty, opt_rhs, expected);\n+                    self.obligation_for_method(cause, trait_did, lhs_ty, Some(input_types));\n                 Err(rustc_trait_selection::traits::fully_solve_obligation(self, obligation))\n             }\n         }"}, {"sha": "a0f048fc09b9b017101fb4f59f7602f2ec4bd09d", "filename": "compiler/rustc_hir_typeck/src/place_op.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8bf7ec75343cde1c72a5e16b0171e259412b8958/compiler%2Frustc_hir_typeck%2Fsrc%2Fplace_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bf7ec75343cde1c72a5e16b0171e259412b8958/compiler%2Frustc_hir_typeck%2Fsrc%2Fplace_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fplace_op.rs?ref=8bf7ec75343cde1c72a5e16b0171e259412b8958", "patch": "@@ -225,7 +225,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         imm_tr.and_then(|trait_did| {\n             self.lookup_method_in_trait(\n-                span,\n+                self.misc(span),\n                 Ident::with_dummy_span(imm_op),\n                 trait_did,\n                 base_ty,\n@@ -264,7 +264,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         mut_tr.and_then(|trait_did| {\n             self.lookup_method_in_trait(\n-                span,\n+                self.misc(span),\n                 Ident::with_dummy_span(mut_op),\n                 trait_did,\n                 base_ty,"}]}