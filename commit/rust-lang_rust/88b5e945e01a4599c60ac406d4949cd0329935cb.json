{"sha": "88b5e945e01a4599c60ac406d4949cd0329935cb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg4YjVlOTQ1ZTAxYTQ1OTljNjBhYzQwNmQ0OTQ5Y2QwMzI5OTM1Y2I=", "commit": {"author": {"name": "Oliver Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2019-08-20T15:51:54Z"}, "committer": {"name": "Oliver Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2019-10-11T08:40:49Z"}, "message": "Make <*const/mut T>::offset_from `const fn`", "tree": {"sha": "fe68a964848372eaa5027086e23b2e88a52600f8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fe68a964848372eaa5027086e23b2e88a52600f8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/88b5e945e01a4599c60ac406d4949cd0329935cb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/88b5e945e01a4599c60ac406d4949cd0329935cb", "html_url": "https://github.com/rust-lang/rust/commit/88b5e945e01a4599c60ac406d4949cd0329935cb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/88b5e945e01a4599c60ac406d4949cd0329935cb/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e0436d912df090b0c3cba9a8b818aab408756e49", "url": "https://api.github.com/repos/rust-lang/rust/commits/e0436d912df090b0c3cba9a8b818aab408756e49", "html_url": "https://github.com/rust-lang/rust/commit/e0436d912df090b0c3cba9a8b818aab408756e49"}], "stats": {"total": 279, "additions": 276, "deletions": 3}, "files": [{"sha": "bae7ae2884f90beed387484bf53793b15ee90246", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/88b5e945e01a4599c60ac406d4949cd0329935cb/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88b5e945e01a4599c60ac406d4949cd0329935cb/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=88b5e945e01a4599c60ac406d4949cd0329935cb", "patch": "@@ -1339,6 +1339,10 @@ extern \"rust-intrinsic\" {\n     /// Emits a `!nontemporal` store according to LLVM (see their docs).\n     /// Probably will never become stable.\n     pub fn nontemporal_store<T>(ptr: *mut T, val: T);\n+\n+    /// See documentation of `<*const T>::offset_from` for details.\n+    #[cfg(not(bootstrap))]\n+    pub fn ptr_offset_from<T>(ptr: *const T, base: *const T) -> isize;\n }\n \n // Some functions are defined here because they accidentally got made"}, {"sha": "a7adaa6a5097a3c46c0c812bb76f3e10e8bcbbfa", "filename": "src/libcore/ptr/mod.rs", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/88b5e945e01a4599c60ac406d4949cd0329935cb/src%2Flibcore%2Fptr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88b5e945e01a4599c60ac406d4949cd0329935cb/src%2Flibcore%2Fptr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr%2Fmod.rs?ref=88b5e945e01a4599c60ac406d4949cd0329935cb", "patch": "@@ -1286,7 +1286,22 @@ impl<T: ?Sized> *const T {\n     /// }\n     /// ```\n     #[unstable(feature = \"ptr_offset_from\", issue = \"41079\")]\n+    #[cfg(not(bootstrap))]\n+    #[rustc_const_unstable(feature = \"const_ptr_offset_from\")]\n     #[inline]\n+    pub const unsafe fn offset_from(self, origin: *const T) -> isize where T: Sized {\n+        let pointee_size = mem::size_of::<T>();\n+        let ok = 0 < pointee_size && pointee_size <= isize::max_value() as usize;\n+        // assert that the pointee size is valid in a const eval compatible way\n+        // FIXME: do this with a real assert at some point\n+        [()][(!ok) as usize];\n+        intrinsics::ptr_offset_from(self, origin)\n+    }\n+\n+    #[unstable(feature = \"ptr_offset_from\", issue = \"41079\")]\n+    #[inline]\n+    #[cfg(bootstrap)]\n+    /// bootstrap\n     pub unsafe fn offset_from(self, origin: *const T) -> isize where T: Sized {\n         let pointee_size = mem::size_of::<T>();\n         assert!(0 < pointee_size && pointee_size <= isize::max_value() as usize);\n@@ -2013,8 +2028,9 @@ impl<T: ?Sized> *mut T {\n     /// }\n     /// ```\n     #[unstable(feature = \"ptr_offset_from\", issue = \"41079\")]\n+    #[rustc_const_unstable(feature = \"const_ptr_offset_from\")]\n     #[inline]\n-    pub unsafe fn offset_from(self, origin: *const T) -> isize where T: Sized {\n+    pub const unsafe fn offset_from(self, origin: *const T) -> isize where T: Sized {\n         (self as *const T).offset_from(origin)\n     }\n "}, {"sha": "e940a42be7deaa788176eeb70d29d37cee973d99", "filename": "src/librustc_codegen_llvm/intrinsic.rs", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/88b5e945e01a4599c60ac406d4949cd0329935cb/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88b5e945e01a4599c60ac406d4949cd0329935cb/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs?ref=88b5e945e01a4599c60ac406d4949cd0329935cb", "patch": "@@ -19,6 +19,7 @@ use rustc::mir::interpret::GlobalId;\n use rustc_codegen_ssa::common::{IntPredicate, TypeKind};\n use rustc::hir;\n use syntax::ast::{self, FloatTy};\n+use rustc_target::abi::HasDataLayout;\n \n use rustc_codegen_ssa::traits::*;\n \n@@ -694,6 +695,23 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n                 return;\n             }\n \n+            \"ptr_offset_from\" => {\n+                let ty = substs.type_at(0);\n+                let pointee_size = self.layout_of(ty).size;\n+\n+                // This is the same sequence that Clang emits for pointer subtraction.\n+                // It can be neither `nsw` nor `nuw` because the input is treated as\n+                // unsigned but then the output is treated as signed, so neither works.\n+                let a = args[0].immediate();\n+                let b = args[1].immediate();\n+                let a = self.ptrtoint(a, self.type_isize());\n+                let b = self.ptrtoint(b, self.type_isize());\n+                let d = self.sub(a, b);\n+                let pointee_size = self.const_usize(pointee_size.bytes());\n+                // this is where the signed magic happens (notice the `s` in `exactsdiv`)\n+                self.exactsdiv(d, pointee_size)\n+            }\n+\n             _ => bug!(\"unknown intrinsic '{}'\", name),\n         };\n \n@@ -1218,7 +1236,6 @@ fn generic_simd_intrinsic(\n         // The `fn simd_bitmask(vector) -> unsigned integer` intrinsic takes a\n         // vector mask and returns an unsigned integer containing the most\n         // significant bit (MSB) of each lane.\n-        use rustc_target::abi::HasDataLayout;\n \n         // If the vector has less than 8 lanes, an u8 is returned with zeroed\n         // trailing bits."}, {"sha": "a04bf7c0f1a1858e20c8eefc6f639464afb54f0e", "filename": "src/librustc_mir/interpret/intrinsics.rs", "status": "modified", "additions": 55, "deletions": 1, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/88b5e945e01a4599c60ac406d4949cd0329935cb/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88b5e945e01a4599c60ac406d4949cd0329935cb/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs?ref=88b5e945e01a4599c60ac406d4949cd0329935cb", "patch": "@@ -12,7 +12,7 @@ use rustc::mir::BinOp;\n use rustc::mir::interpret::{InterpResult, Scalar, GlobalId, ConstValue};\n \n use super::{\n-    Machine, PlaceTy, OpTy, InterpCx,\n+    Machine, PlaceTy, OpTy, InterpCx, ImmTy,\n };\n \n mod type_name;\n@@ -236,6 +236,34 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 let result = Scalar::from_uint(truncated_bits, layout.size);\n                 self.write_scalar(result, dest)?;\n             }\n+\n+            \"ptr_offset_from\" => {\n+                let a = self.read_immediate(args[0])?.to_scalar()?.to_ptr()?;\n+                let b = self.read_immediate(args[1])?.to_scalar()?.to_ptr()?;\n+                if a.alloc_id != b.alloc_id {\n+                    throw_ub_format!(\n+                        \"ptr_offset_from cannot compute offset of pointers into different \\\n+                        allocations.\",\n+                    );\n+                }\n+                let usize_layout = self.layout_of(self.tcx.types.usize)?;\n+                let a_offset = ImmTy::from_uint(a.offset.bytes(), usize_layout);\n+                let b_offset = ImmTy::from_uint(b.offset.bytes(), usize_layout);\n+                let (val, overflowed, _) = self.overflowing_binary_op(\n+                    BinOp::Sub, a_offset, b_offset,\n+                )?;\n+                if overflowed {\n+                    throw_ub_format!(\n+                        \"second argument to `ptr_offset_from` must be smaller than first\",\n+                    );\n+                }\n+                let pointee_layout = self.layout_of(substs.type_at(0))?;\n+                let isize_layout = self.layout_of(self.tcx.types.isize)?;\n+                let val = ImmTy::from_scalar(val, isize_layout);\n+                let size = ImmTy::from_int(pointee_layout.size.bytes(), isize_layout);\n+                self.exact_div(val, size, dest)?;\n+            }\n+\n             \"transmute\" => {\n                 self.copy_op_transmute(args[0], dest)?;\n             }\n@@ -340,4 +368,30 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             return Ok(false);\n         }\n     }\n+\n+    pub fn exact_div(\n+        &mut self,\n+        a: ImmTy<'tcx, M::PointerTag>,\n+        b: ImmTy<'tcx, M::PointerTag>,\n+        dest: PlaceTy<'tcx, M::PointerTag>,\n+    ) -> InterpResult<'tcx> {\n+        // Performs an exact division, resulting in undefined behavior where\n+        // `x % y != 0` or `y == 0` or `x == T::min_value() && y == -1`.\n+        // First, check x % y != 0.\n+        if self.binary_op(BinOp::Rem, a, b)?.to_bits()? != 0 {\n+            // Then, check if `b` is -1, which is the \"min_value / -1\" case.\n+            let minus1 = Scalar::from_int(-1, dest.layout.size);\n+            let b = b.to_scalar().unwrap();\n+            if b == minus1 {\n+                throw_ub_format!(\"exact_div: result of dividing MIN by -1 cannot be represented\")\n+            } else {\n+                throw_ub_format!(\n+                    \"exact_div: {} cannot be divided by {} without remainder\",\n+                    a.to_scalar().unwrap(),\n+                    b,\n+                )\n+            }\n+        }\n+        self.binop_ignore_overflow(BinOp::Div, a, b, dest)\n+    }\n }"}, {"sha": "ec9c7a73de735bb014e1f59ad1ff63a2a8756adc", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/88b5e945e01a4599c60ac406d4949cd0329935cb/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88b5e945e01a4599c60ac406d4949cd0329935cb/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=88b5e945e01a4599c60ac406d4949cd0329935cb", "patch": "@@ -560,6 +560,7 @@ impl Qualif for IsNotPromotable {\n                             | \"transmute\"\n                             | \"simd_insert\"\n                             | \"simd_extract\"\n+                            | \"ptr_offset_from\"\n                             => return true,\n \n                             _ => {}"}, {"sha": "0ebdc0672fcb17db8a90bbce6e7278f296f89327", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/88b5e945e01a4599c60ac406d4949cd0329935cb/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88b5e945e01a4599c60ac406d4949cd0329935cb/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=88b5e945e01a4599c60ac406d4949cd0329935cb", "patch": "@@ -307,6 +307,8 @@ pub fn check_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem) {\n                 (1, vec![param(0), param(0)],\n                 tcx.intern_tup(&[param(0), tcx.types.bool])),\n \n+            \"ptr_offset_from\" =>\n+                (1, vec![ tcx.mk_imm_ptr(param(0)), tcx.mk_imm_ptr(param(0)) ], tcx.types.isize),\n             \"unchecked_div\" | \"unchecked_rem\" | \"exact_div\" =>\n                 (1, vec![param(0), param(0)], param(0)),\n             \"unchecked_shl\" | \"unchecked_shr\" |"}, {"sha": "07e1be0480cde0e6126cca71f19bed68f4b73523", "filename": "src/test/ui/consts/offset_from_ub.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/88b5e945e01a4599c60ac406d4949cd0329935cb/src%2Ftest%2Fui%2Fconsts%2Foffset_from_ub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88b5e945e01a4599c60ac406d4949cd0329935cb/src%2Ftest%2Fui%2Fconsts%2Foffset_from_ub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Foffset_from_ub.rs?ref=88b5e945e01a4599c60ac406d4949cd0329935cb", "patch": "@@ -0,0 +1,44 @@\n+#![feature(const_raw_ptr_deref)]\n+#![feature(const_ptr_offset_from)]\n+#![feature(ptr_offset_from)]\n+\n+#[repr(C)]\n+struct Struct {\n+    data: u8,\n+    field: u8,\n+}\n+\n+pub const DIFFERENT_ALLOC: usize = {\n+    //~^ NOTE\n+    let uninit = std::mem::MaybeUninit::<Struct>::uninit();\n+    let base_ptr: *const Struct = &uninit as *const _ as *const Struct;\n+    let uninit2 = std::mem::MaybeUninit::<Struct>::uninit();\n+    let field_ptr: *const Struct = &uninit2 as *const _ as *const Struct;\n+    let offset = unsafe { field_ptr.offset_from(base_ptr) };\n+    offset as usize\n+};\n+\n+pub const NOT_PTR: usize = {\n+    //~^ NOTE\n+    unsafe { (42 as *const u8).offset_from(&5u8) as usize }\n+};\n+\n+pub const NOT_MULTIPLE_OF_SIZE: usize = {\n+    //~^ NOTE\n+    let data = [5u8, 6, 7];\n+    let base_ptr = data.as_ptr();\n+    let field_ptr = &data[1] as *const u8 as *const u16;\n+    let offset = unsafe { field_ptr.offset_from(base_ptr as *const u16) };\n+    offset as usize\n+};\n+\n+pub const OVERFLOW: usize = {\n+    //~^ NOTE\n+    let uninit = std::mem::MaybeUninit::<Struct>::uninit();\n+    let base_ptr: *const Struct = &uninit as *const _ as *const Struct;\n+    let field_ptr = unsafe { &(*base_ptr).field as *const u8 };\n+    let offset = unsafe { (base_ptr as *const u8).offset_from(field_ptr) };\n+    offset as usize\n+};\n+\n+fn main() {}"}, {"sha": "12185ab5ccda9df87ef873f9ee95cc1e1019ea0e", "filename": "src/test/ui/consts/offset_from_ub.stderr", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/88b5e945e01a4599c60ac406d4949cd0329935cb/src%2Ftest%2Fui%2Fconsts%2Foffset_from_ub.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/88b5e945e01a4599c60ac406d4949cd0329935cb/src%2Ftest%2Fui%2Fconsts%2Foffset_from_ub.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Foffset_from_ub.stderr?ref=88b5e945e01a4599c60ac406d4949cd0329935cb", "patch": "@@ -0,0 +1,81 @@\n+error: any use of this value will cause an error\n+  --> $SRC_DIR/libcore/ptr/mod.rs:LL:COL\n+   |\n+LL |           intrinsics::ptr_offset_from(self, origin)\n+   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |           |\n+   |           ptr_offset_from cannot compute offset of pointers into different allocations.\n+   |           inside call to `std::ptr::<impl *const Struct>::offset_from` at $DIR/offset_from_ub.rs:17:27\n+   | \n+  ::: $DIR/offset_from_ub.rs:11:1\n+   |\n+LL | / pub const DIFFERENT_ALLOC: usize = {\n+LL | |\n+LL | |     let uninit = std::mem::MaybeUninit::<Struct>::uninit();\n+LL | |     let base_ptr: *const Struct = &uninit as *const _ as *const Struct;\n+...  |\n+LL | |     offset as usize\n+LL | | };\n+   | |__-\n+   |\n+   = note: `#[deny(const_err)]` on by default\n+\n+error: any use of this value will cause an error\n+  --> $SRC_DIR/libcore/ptr/mod.rs:LL:COL\n+   |\n+LL |           intrinsics::ptr_offset_from(self, origin)\n+   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |           |\n+   |           a memory access tried to interpret some bytes as a pointer\n+   |           inside call to `std::ptr::<impl *const u8>::offset_from` at $DIR/offset_from_ub.rs:23:14\n+   | \n+  ::: $DIR/offset_from_ub.rs:21:1\n+   |\n+LL | / pub const NOT_PTR: usize = {\n+LL | |\n+LL | |     unsafe { (42 as *const u8).offset_from(&5u8) as usize }\n+LL | | };\n+   | |__-\n+\n+error: any use of this value will cause an error\n+  --> $SRC_DIR/libcore/ptr/mod.rs:LL:COL\n+   |\n+LL |           intrinsics::ptr_offset_from(self, origin)\n+   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |           |\n+   |           exact_div: 1 cannot be divided by 2 without remainder\n+   |           inside call to `std::ptr::<impl *const u16>::offset_from` at $DIR/offset_from_ub.rs:31:27\n+   | \n+  ::: $DIR/offset_from_ub.rs:26:1\n+   |\n+LL | / pub const NOT_MULTIPLE_OF_SIZE: usize = {\n+LL | |\n+LL | |     let data = [5u8, 6, 7];\n+LL | |     let base_ptr = data.as_ptr();\n+...  |\n+LL | |     offset as usize\n+LL | | };\n+   | |__-\n+\n+error: any use of this value will cause an error\n+  --> $SRC_DIR/libcore/ptr/mod.rs:LL:COL\n+   |\n+LL |           intrinsics::ptr_offset_from(self, origin)\n+   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |           |\n+   |           second argument to `ptr_offset_from` must be smaller than first\n+   |           inside call to `std::ptr::<impl *const u8>::offset_from` at $DIR/offset_from_ub.rs:40:27\n+   | \n+  ::: $DIR/offset_from_ub.rs:35:1\n+   |\n+LL | / pub const OVERFLOW: usize = {\n+LL | |\n+LL | |     let uninit = std::mem::MaybeUninit::<Struct>::uninit();\n+LL | |     let base_ptr: *const Struct = &uninit as *const _ as *const Struct;\n+...  |\n+LL | |     offset as usize\n+LL | | };\n+   | |__-\n+\n+error: aborting due to 4 previous errors\n+"}, {"sha": "7b5b4a77d9ae3fec1ea80df99c125364a4b65f27", "filename": "src/test/ui/consts/offset_of.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/88b5e945e01a4599c60ac406d4949cd0329935cb/src%2Ftest%2Fui%2Fconsts%2Foffset_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88b5e945e01a4599c60ac406d4949cd0329935cb/src%2Ftest%2Fui%2Fconsts%2Foffset_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Foffset_of.rs?ref=88b5e945e01a4599c60ac406d4949cd0329935cb", "patch": "@@ -0,0 +1,39 @@\n+// run-pass\n+\n+#![feature(const_raw_ptr_deref)]\n+#![feature(const_ptr_offset_from)]\n+#![feature(ptr_offset_from)]\n+\n+struct Struct {\n+    field: (),\n+}\n+\n+#[repr(C)]\n+struct Struct2 {\n+    data: u8,\n+    field: u8,\n+}\n+\n+pub const OFFSET: usize = {\n+    let uninit = std::mem::MaybeUninit::<Struct>::uninit();\n+    let base_ptr: *const Struct = &uninit as *const _ as *const Struct;\n+    // The following statement is UB (taking the address of an uninitialized field).\n+    // Const eval doesn't detect this right now, but it may stop compiling at some point\n+    // in the future.\n+    let field_ptr = unsafe { &(*base_ptr).field as *const () as *const u8 };\n+    let offset = unsafe { field_ptr.offset_from(base_ptr as *const u8) };\n+    offset as usize\n+};\n+\n+pub const OFFSET_2: usize = {\n+    let uninit = std::mem::MaybeUninit::<Struct2>::uninit();\n+    let base_ptr: *const Struct2 = &uninit as *const _ as *const Struct2;\n+    let field_ptr = unsafe { &(*base_ptr).field as *const u8 };\n+    let offset = unsafe { field_ptr.offset_from(base_ptr as *const u8) };\n+    offset as usize\n+};\n+\n+fn main() {\n+    assert_eq!(OFFSET, 0);\n+    assert_eq!(OFFSET_2, 1);\n+}"}, {"sha": "cbbb2adf15f91acc80b398a281e3eac4c5704eaf", "filename": "src/test/ui/offset_from.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/88b5e945e01a4599c60ac406d4949cd0329935cb/src%2Ftest%2Fui%2Foffset_from.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88b5e945e01a4599c60ac406d4949cd0329935cb/src%2Ftest%2Fui%2Foffset_from.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Foffset_from.rs?ref=88b5e945e01a4599c60ac406d4949cd0329935cb", "patch": "@@ -0,0 +1,15 @@\n+// run-pass\n+\n+#![feature(ptr_offset_from)]\n+\n+fn main() {\n+    let mut a = [0; 5];\n+    let ptr1: *mut i32 = &mut a[1];\n+    let ptr2: *mut i32 = &mut a[3];\n+    unsafe {\n+        assert_eq!(ptr2.offset_from(ptr1), 2);\n+        assert_eq!(ptr1.offset_from(ptr2), -2);\n+        assert_eq!(ptr1.offset(2), ptr2);\n+        assert_eq!(ptr2.offset(-2), ptr1);\n+    }\n+}"}]}