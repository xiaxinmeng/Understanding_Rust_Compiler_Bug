{"sha": "698db04a8d44df3d2805b25b9b461a886b9933cd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY5OGRiMDRhOGQ0NGRmM2QyODA1YjI1YjliNDYxYTg4NmI5OTMzY2Q=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-11-20T17:12:38Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-12-14T09:21:56Z"}, "message": "Purge the hack that allows `FnOnce` to be used with a by-value self method.  Besides being yucky, it will cause problems if we try to make all traits implement themselves, which would make a lot of things in life easier. Also, it was inextricably linked to `Box`, which was not the intention.  We can work around its absence, so better to reimplement it later in a more thorough fashion.", "tree": {"sha": "1baefd7e47d994010720d65046651997f5b0895b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1baefd7e47d994010720d65046651997f5b0895b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/698db04a8d44df3d2805b25b9b461a886b9933cd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/698db04a8d44df3d2805b25b9b461a886b9933cd", "html_url": "https://github.com/rust-lang/rust/commit/698db04a8d44df3d2805b25b9b461a886b9933cd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/698db04a8d44df3d2805b25b9b461a886b9933cd/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d61338172fa110fcf9e5f2df0e1e83635d0fde3f", "url": "https://api.github.com/repos/rust-lang/rust/commits/d61338172fa110fcf9e5f2df0e1e83635d0fde3f", "html_url": "https://github.com/rust-lang/rust/commit/d61338172fa110fcf9e5f2df0e1e83635d0fde3f"}], "stats": {"total": 345, "additions": 42, "deletions": 303}, "files": [{"sha": "67e1735d9a3b72d064b30ab329c3a8976d710248", "filename": "src/librustc_trans/trans/callee.rs", "status": "modified", "additions": 1, "deletions": 149, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/698db04a8d44df3d2805b25b9b461a886b9933cd/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/698db04a8d44df3d2805b25b9b461a886b9933cd/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs?ref=698db04a8d44df3d2805b25b9b461a886b9933cd", "patch": "@@ -19,8 +19,7 @@ pub use self::CalleeData::*;\n pub use self::CallArgs::*;\n \n use arena::TypedArena;\n-use back::abi;\n-use back::link;\n+use back::{abi,link};\n use session;\n use llvm::{ValueRef, get_param};\n use llvm;\n@@ -357,153 +356,6 @@ pub fn trans_fn_pointer_shim<'a, 'tcx>(\n     llfn\n }\n \n-/// Translates the adapter that deconstructs a `Box<Trait>` object into\n-/// `Trait` so that a by-value self method can be called.\n-pub fn trans_unboxing_shim<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                       llshimmedfn: ValueRef,\n-                                       fty: &ty::BareFnTy<'tcx>,\n-                                       method_id: ast::DefId,\n-                                       substs: &subst::Substs<'tcx>)\n-                                       -> ValueRef {\n-    let _icx = push_ctxt(\"trans_unboxing_shim\");\n-    let ccx = bcx.ccx();\n-    let tcx = bcx.tcx();\n-\n-    let fty = fty.subst(tcx, substs);\n-\n-    // Transform the self type to `Box<self_type>`.\n-    let self_type = fty.sig.inputs[0];\n-    let boxed_self_type = ty::mk_uniq(tcx, self_type);\n-    let boxed_function_type = ty::FnSig {\n-        inputs: fty.sig.inputs.iter().enumerate().map(|(i, typ)| {\n-            if i == 0 {\n-                boxed_self_type\n-            } else {\n-                *typ\n-            }\n-        }).collect(),\n-        output: fty.sig.output,\n-        variadic: false,\n-    };\n-    let boxed_function_type = ty::BareFnTy {\n-        fn_style: fty.fn_style,\n-        abi: fty.abi,\n-        sig: boxed_function_type,\n-    };\n-    let boxed_function_type = ty::mk_bare_fn(tcx, boxed_function_type);\n-    let function_type = match fty.abi {\n-        synabi::RustCall => {\n-            // We're passing through to a RustCall ABI function, but\n-            // because the shim will already perform untupling, we\n-            // need to pretend the shimmed function does not use\n-            // RustCall so the untupled arguments can be passed\n-            // through verbatim.  This is kind of ugly.\n-            let fake_ty = ty::FnSig {\n-                inputs: type_of::untuple_arguments_if_necessary(ccx,\n-                                                                fty.sig.inputs.as_slice(),\n-                                                                fty.abi),\n-                output: fty.sig.output,\n-                variadic: false,\n-            };\n-            let fake_ty = ty::BareFnTy {\n-                fn_style: fty.fn_style,\n-                abi: synabi::Rust,\n-                sig: fake_ty,\n-            };\n-            ty::mk_bare_fn(tcx, fake_ty)\n-        }\n-        _ => {\n-            ty::mk_bare_fn(tcx, fty)\n-        }\n-    };\n-\n-    let function_name = ty::with_path(tcx, method_id, |path| {\n-        link::mangle_internal_name_by_path_and_seq(path, \"unboxing_shim\")\n-    });\n-    let llfn = decl_internal_rust_fn(ccx,\n-                                     boxed_function_type,\n-                                     function_name.as_slice());\n-\n-    let block_arena = TypedArena::new();\n-    let empty_param_substs = Substs::trans_empty();\n-    let return_type = ty::ty_fn_ret(boxed_function_type);\n-    let fcx = new_fn_ctxt(ccx,\n-                          llfn,\n-                          ast::DUMMY_NODE_ID,\n-                          false,\n-                          return_type,\n-                          &empty_param_substs,\n-                          None,\n-                          &block_arena);\n-    let mut bcx = init_function(&fcx, false, return_type);\n-\n-    // Create the substituted versions of the self type.\n-    let arg_scope = fcx.push_custom_cleanup_scope();\n-    let arg_scope_id = cleanup::CustomScope(arg_scope);\n-    let boxed_self_type = ty::ty_fn_args(boxed_function_type)[0];\n-    let arg_types = ty::ty_fn_args(function_type);\n-    let self_type = arg_types[0];\n-    let boxed_self_kind = arg_kind(&fcx, boxed_self_type);\n-\n-    // Create a datum for self.\n-    let llboxedself = get_param(fcx.llfn, fcx.arg_pos(0) as u32);\n-    let llboxedself = Datum::new(llboxedself,\n-                                 boxed_self_type,\n-                                 boxed_self_kind);\n-    let boxed_self =\n-        unpack_datum!(bcx,\n-                      llboxedself.to_lvalue_datum_in_scope(bcx,\n-                                                           \"boxedself\",\n-                                                           arg_scope_id));\n-\n-    // This `Load` is needed because lvalue data are always by-ref.\n-    let llboxedself = Load(bcx, boxed_self.val);\n-\n-    let llself = if type_is_immediate(ccx, self_type) {\n-        let llboxedself = Load(bcx, llboxedself);\n-        immediate_rvalue(llboxedself, self_type)\n-    } else {\n-        let llself = rvalue_scratch_datum(bcx, self_type, \"self\");\n-        memcpy_ty(bcx, llself.val, llboxedself, self_type);\n-        llself\n-    };\n-\n-    // Make sure we don't free the box twice!\n-    boxed_self.kind.post_store(bcx, boxed_self.val, boxed_self_type);\n-\n-    // Schedule a cleanup to free the box.\n-    fcx.schedule_free_value(arg_scope_id,\n-                            llboxedself,\n-                            cleanup::HeapExchange,\n-                            self_type);\n-\n-    // Now call the function.\n-    let mut llshimmedargs = vec!(llself.val);\n-    for i in range(1, arg_types.len()) {\n-        llshimmedargs.push(get_param(fcx.llfn, fcx.arg_pos(i) as u32));\n-    }\n-    assert!(!fcx.needs_ret_allocas);\n-    let dest = fcx.llretslotptr.get().map(|_|\n-        expr::SaveIn(fcx.get_ret_slot(bcx, return_type, \"ret_slot\"))\n-    );\n-    bcx = trans_call_inner(bcx,\n-                           None,\n-                           function_type,\n-                           |bcx, _| {\n-                               Callee {\n-                                   bcx: bcx,\n-                                   data: Fn(llshimmedfn),\n-                               }\n-                           },\n-                           ArgVals(llshimmedargs.as_slice()),\n-                           dest).bcx;\n-\n-    bcx = fcx.pop_and_trans_custom_cleanup_scope(bcx, arg_scope);\n-    finish_fn(&fcx, bcx, return_type);\n-\n-    llfn\n-}\n-\n /// Translates a reference to a fn/method item, monomorphizing and\n /// inlining as it goes.\n ///"}, {"sha": "9a2bc38acdfdcb9841a3baeb9ba0825755df2603", "filename": "src/librustc_trans/trans/meth.rs", "status": "modified", "additions": 6, "deletions": 65, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/698db04a8d44df3d2805b25b9b461a886b9933cd/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/698db04a8d44df3d2805b25b9b461a886b9933cd/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs?ref=698db04a8d44df3d2805b25b9b461a886b9933cd", "patch": "@@ -550,68 +550,12 @@ pub fn get_vtable<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 emit_vtable_methods(bcx, id, substs).into_iter()\n             }\n             traits::VtableUnboxedClosure(closure_def_id, substs) => {\n-                // Look up closure type\n-                let self_ty = ty::node_id_to_type(bcx.tcx(), closure_def_id.node);\n-                // Apply substitutions from closure param environment.\n-                // The substitutions should have no type parameters\n-                // remaining after passing through fulfill_obligation\n-                let self_ty = self_ty.subst(bcx.tcx(), &substs);\n-\n-                let mut llfn = trans_fn_ref_with_substs(\n+                let llfn = trans_fn_ref_with_substs(\n                     bcx,\n                     closure_def_id,\n                     ExprId(0),\n                     substs.clone());\n \n-                {\n-                    let unboxed_closures = bcx.tcx()\n-                                              .unboxed_closures\n-                                              .borrow();\n-                    let closure_info =\n-                        unboxed_closures.get(&closure_def_id)\n-                                        .expect(\"get_vtable(): didn't find \\\n-                                                 unboxed closure\");\n-                    if closure_info.kind == ty::FnOnceUnboxedClosureKind {\n-                        // Untuple the arguments and create an unboxing shim.\n-                        let (new_inputs, new_output) = match self_ty.sty {\n-                            ty::ty_unboxed_closure(_, _, ref substs) => {\n-                                let mut new_inputs = vec![self_ty.clone()];\n-                                match closure_info.closure_type.sig.inputs[0].sty {\n-                                    ty::ty_tup(ref elements) => {\n-                                        for element in elements.iter() {\n-                                            new_inputs.push(element.subst(bcx.tcx(), substs));\n-                                        }\n-                                    }\n-                                    _ => {\n-                                        bcx.tcx().sess.bug(\"get_vtable(): closure \\\n-                                                            type wasn't a tuple\")\n-                                    }\n-                                }\n-                                (new_inputs,\n-                                 closure_info.closure_type.sig.output.subst(bcx.tcx(), substs))\n-                            },\n-                            _ => bcx.tcx().sess.bug(\"get_vtable(): def wasn't an unboxed closure\")\n-                        };\n-\n-                        let closure_type = ty::BareFnTy {\n-                            fn_style: closure_info.closure_type.fn_style,\n-                            abi: Rust,\n-                            sig: ty::FnSig {\n-                                inputs: new_inputs,\n-                                output: new_output,\n-                                variadic: false,\n-                            },\n-                        };\n-                        debug!(\"get_vtable(): closure type is {}\",\n-                               closure_type.repr(bcx.tcx()));\n-                        llfn = trans_unboxing_shim(bcx,\n-                                                   llfn,\n-                                                   &closure_type,\n-                                                   closure_def_id,\n-                                                   &substs);\n-                    }\n-                }\n-\n                 (vec!(llfn)).into_iter()\n             }\n             traits::VtableFnPointer(bare_fn_ty) => {\n@@ -701,18 +645,15 @@ fn emit_vtable_methods<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                            token::get_name(name));\n                     Some(C_null(Type::nil(ccx).ptr_to())).into_iter()\n                 } else {\n-                    let mut fn_ref = trans_fn_ref_with_substs(\n+                    let fn_ref = trans_fn_ref_with_substs(\n                         bcx,\n                         m_id,\n                         ExprId(0),\n                         substs.clone());\n-                    if m.explicit_self == ty::ByValueExplicitSelfCategory {\n-                        fn_ref = trans_unboxing_shim(bcx,\n-                                                     fn_ref,\n-                                                     &m.fty,\n-                                                     m_id,\n-                                                     &substs);\n-                    }\n+\n+                    // currently, at least, by-value self is not object safe\n+                    assert!(m.explicit_self != ty::ByValueExplicitSelfCategory);\n+\n                     Some(fn_ref).into_iter()\n                 }\n             }"}, {"sha": "d3879e49034b19df674b54cf13aa161b7135fa4b", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/698db04a8d44df3d2805b25b9b461a886b9933cd/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/698db04a8d44df3d2805b25b9b461a886b9933cd/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=698db04a8d44df3d2805b25b9b461a886b9933cd", "patch": "@@ -315,23 +315,6 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n                 get_method_index(tcx, &*new_trait_ref,\n                                  trait_ref.clone(), method_num);\n \n-            // FIXME Hacky. By-value `self` methods in objects ought to be\n-            // just a special case of passing ownership of a DST value\n-            // as a parameter. *But* we currently hack them in and tie them to\n-            // the particulars of the `Box` type. So basically for a `fn foo(self,...)`\n-            // method invoked on an object, we don't want the receiver type to be\n-            // `TheTrait`, but rather `Box<TheTrait>`. Yuck.\n-            let mut m = m;\n-            match m.explicit_self {\n-                ty::ByValueExplicitSelfCategory => {\n-                    let mut n = (*m).clone();\n-                    let self_ty = n.fty.sig.inputs[0];\n-                    n.fty.sig.inputs[0] = ty::mk_uniq(tcx, self_ty);\n-                    m = Rc::new(n);\n-                }\n-                _ => { }\n-            }\n-\n             let xform_self_ty =\n                 this.xform_self_ty(&m, &new_trait_ref.substs);\n "}, {"sha": "415a3d53fb28448c8a5f08fb2814b6fa67a98d70", "filename": "src/librustc_typeck/check/vtable.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/698db04a8d44df3d2805b25b9b461a886b9933cd/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/698db04a8d44df3d2805b25b9b461a886b9933cd/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs?ref=698db04a8d44df3d2805b25b9b461a886b9933cd", "patch": "@@ -149,14 +149,6 @@ pub fn check_object_safety<'tcx>(tcx: &ty::ctxt<'tcx>,\n fn check_object_safety_inner<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                  object_trait: &ty::TraitRef<'tcx>,\n                                  span: Span) {\n-    // Skip the fn_once lang item trait since only the compiler should call\n-    // `call_once` which is the method which takes self by value. What could go\n-    // wrong?\n-    match tcx.lang_items.fn_once_trait() {\n-        Some(def_id) if def_id == object_trait.def_id => return,\n-        _ => {}\n-    }\n-\n     let trait_items = ty::trait_items(tcx, object_trait.def_id);\n \n     let mut errors = Vec::new();"}, {"sha": "552ce565f6b173f748544e25d951c274b54dee03", "filename": "src/test/run-pass/issue-16739.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/698db04a8d44df3d2805b25b9b461a886b9933cd/src%2Ftest%2Frun-pass%2Fissue-16739.rs", "raw_url": "https://github.com/rust-lang/rust/raw/698db04a8d44df3d2805b25b9b461a886b9933cd/src%2Ftest%2Frun-pass%2Fissue-16739.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-16739.rs?ref=698db04a8d44df3d2805b25b9b461a886b9933cd", "patch": "@@ -11,29 +11,29 @@\n #![feature(unboxed_closures)]\n \n // Test that unboxing shim for calling rust-call ABI methods through a\n-// trait box works and does not cause an ICE\n+// trait box works and does not cause an ICE.\n \n struct Foo { foo: uint }\n \n-impl FnOnce<(), uint> for Foo {\n-    extern \"rust-call\" fn call_once(self, _: ()) -> uint { self.foo }\n+impl FnMut<(), uint> for Foo {\n+    extern \"rust-call\" fn call_mut(&mut self, _: ()) -> uint { self.foo }\n }\n \n-impl FnOnce<(uint,), uint> for Foo {\n-    extern \"rust-call\" fn call_once(self, (x,): (uint,)) -> uint { self.foo + x }\n+impl FnMut<(uint,), uint> for Foo {\n+    extern \"rust-call\" fn call_mut(&mut self, (x,): (uint,)) -> uint { self.foo + x }\n }\n \n-impl FnOnce<(uint, uint), uint> for Foo {\n-    extern \"rust-call\" fn call_once(self, (x, y): (uint, uint)) -> uint { self.foo + x + y }\n+impl FnMut<(uint, uint), uint> for Foo {\n+    extern \"rust-call\" fn call_mut(&mut self, (x, y): (uint, uint)) -> uint { self.foo + x + y }\n }\n \n fn main() {\n-    let f = box Foo { foo: 42 } as Box<FnOnce<(), uint>>;\n-    assert_eq!(f.call_once(()), 42);\n+    let mut f = box Foo { foo: 42 } as Box<FnMut<(), uint>>;\n+    assert_eq!(f.call_mut(()), 42);\n \n-    let f = box Foo { foo: 40 } as Box<FnOnce<(uint,), uint>>;\n-    assert_eq!(f.call_once((2,)), 42);\n+    let mut f = box Foo { foo: 40 } as Box<FnMut<(uint,), uint>>;\n+    assert_eq!(f.call_mut((2,)), 42);\n \n-    let f = box Foo { foo: 40 } as Box<FnOnce<(uint, uint), uint>>;\n-    assert_eq!(f.call_once((1, 1)), 42);\n+    let mut f = box Foo { foo: 40 } as Box<FnMut<(uint, uint), uint>>;\n+    assert_eq!(f.call_mut((1, 1)), 42);\n }"}, {"sha": "c54844f570b9df21e5949c06a035a2bf3acc8426", "filename": "src/test/run-pass/issue-18883.rs", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/d61338172fa110fcf9e5f2df0e1e83635d0fde3f/src%2Ftest%2Frun-pass%2Fissue-18883.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61338172fa110fcf9e5f2df0e1e83635d0fde3f/src%2Ftest%2Frun-pass%2Fissue-18883.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-18883.rs?ref=d61338172fa110fcf9e5f2df0e1e83635d0fde3f", "patch": "@@ -1,19 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Test that we don't ICE due to encountering unsubstituted type\n-// parameters when untupling FnOnce parameters during translation of\n-// an unboxing shim.\n-\n-#![feature(unboxed_closures)]\n-\n-fn main() {\n-    let _: Box<FnOnce<(),()>> = box move |&mut:| {};\n-}"}, {"sha": "dfc234e87cda1853b5b957a22252910c8d4f995c", "filename": "src/test/run-pass/unboxed-closures-monomorphization.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/698db04a8d44df3d2805b25b9b461a886b9933cd/src%2Ftest%2Frun-pass%2Funboxed-closures-monomorphization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/698db04a8d44df3d2805b25b9b461a886b9933cd/src%2Ftest%2Frun-pass%2Funboxed-closures-monomorphization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funboxed-closures-monomorphization.rs?ref=698db04a8d44df3d2805b25b9b461a886b9933cd", "patch": "@@ -14,26 +14,26 @@\n #![feature(unboxed_closures)]\n \n fn main(){\n-    fn bar<'a, T:'a> (t: T) -> Box<FnOnce<(),T> + 'a> {\n-        box move |:| t\n+    fn bar<'a, T:Clone+'a> (t: T) -> Box<FnMut<(),T> + 'a> {\n+        box move |&mut:| t.clone()\n     }\n \n-    let f = bar(42u);\n-    assert_eq!(f.call_once(()), 42);\n+    let mut f = bar(42u);\n+    assert_eq!(f.call_mut(()), 42);\n \n-    let f = bar(\"forty-two\");\n-    assert_eq!(f.call_once(()), \"forty-two\");\n+    let mut f = bar(\"forty-two\");\n+    assert_eq!(f.call_mut(()), \"forty-two\");\n \n     let x = 42u;\n-    let f = bar(&x);\n-    assert_eq!(f.call_once(()), &x);\n+    let mut f = bar(&x);\n+    assert_eq!(f.call_mut(()), &x);\n \n-    #[deriving(Show, PartialEq)]\n+    #[deriving(Clone, Show, PartialEq)]\n     struct Foo(uint, &'static str);\n \n     impl Copy for Foo {}\n \n     let x = Foo(42, \"forty-two\");\n-    let f = bar(x);\n-    assert_eq!(f.call_once(()), x);\n+    let mut f = bar(x);\n+    assert_eq!(f.call_mut(()), x);\n }"}, {"sha": "e31ef169e16eb2ff5ee5b3e8b83f33605be13f04", "filename": "src/test/run-pass/unboxed-closures-prelude.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/698db04a8d44df3d2805b25b9b461a886b9933cd/src%2Ftest%2Frun-pass%2Funboxed-closures-prelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/698db04a8d44df3d2805b25b9b461a886b9933cd/src%2Ftest%2Frun-pass%2Funboxed-closures-prelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funboxed-closures-prelude.rs?ref=698db04a8d44df3d2805b25b9b461a886b9933cd", "patch": "@@ -13,7 +13,16 @@\n #![feature(unboxed_closures)]\n \n fn main() {\n-    let task: Box<FnOnce(int) -> int> = box |: x| x;\n-    task.call_once((0i, ));\n+    let task: Box<Fn(int) -> int> = box |&: x| x;\n+    task.call((0i, ));\n+\n+    let mut task: Box<FnMut(int) -> int> = box |&mut: x| x;\n+    task.call_mut((0i, ));\n+\n+    call(|:x| x, 22);\n+}\n+\n+fn call<F:FnOnce(int) -> int>(f: F, x: int) -> int {\n+    f.call_once((x,))\n }\n "}, {"sha": "c41aeaa673f80cb87a230e63d85e8cfd3eadc376", "filename": "src/test/run-pass/unboxed-closures-unboxing-shim.rs", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/d61338172fa110fcf9e5f2df0e1e83635d0fde3f/src%2Ftest%2Frun-pass%2Funboxed-closures-unboxing-shim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61338172fa110fcf9e5f2df0e1e83635d0fde3f/src%2Ftest%2Frun-pass%2Funboxed-closures-unboxing-shim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funboxed-closures-unboxing-shim.rs?ref=d61338172fa110fcf9e5f2df0e1e83635d0fde3f", "patch": "@@ -1,19 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![feature(unboxed_closures)]\n-\n-use std::ops::FnOnce;\n-\n-fn main() {\n-    let task: Box<FnOnce(int) -> int> = box |: x| x;\n-    assert!(task.call_once((1234i,)) == 1234i);\n-}\n-"}]}