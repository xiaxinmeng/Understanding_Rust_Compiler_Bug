{"sha": "524327ace2bf03e4919d32c2191ba831385afa4d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUyNDMyN2FjZTJiZjAzZTQ5MTlkMzJjMjE5MWJhODMxMzg1YWZhNGQ=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-03-02T08:08:36Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-03-02T20:16:27Z"}, "message": "Rollup merge of #22689 - tshepang:thread-doc-improvements, r=steveklabnik", "tree": {"sha": "5bdb2f388ec54b4b279e7880aa4c77db02284687", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5bdb2f388ec54b4b279e7880aa4c77db02284687"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/524327ace2bf03e4919d32c2191ba831385afa4d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/524327ace2bf03e4919d32c2191ba831385afa4d", "html_url": "https://github.com/rust-lang/rust/commit/524327ace2bf03e4919d32c2191ba831385afa4d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/524327ace2bf03e4919d32c2191ba831385afa4d/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1cc8b6ec664f30b43f75551e95299d943c8a4e6a", "url": "https://api.github.com/repos/rust-lang/rust/commits/1cc8b6ec664f30b43f75551e95299d943c8a4e6a", "html_url": "https://github.com/rust-lang/rust/commit/1cc8b6ec664f30b43f75551e95299d943c8a4e6a"}, {"sha": "fa4cb49b0475232d7e7eed2b77cdd017b762db8c", "url": "https://api.github.com/repos/rust-lang/rust/commits/fa4cb49b0475232d7e7eed2b77cdd017b762db8c", "html_url": "https://github.com/rust-lang/rust/commit/fa4cb49b0475232d7e7eed2b77cdd017b762db8c"}], "stats": {"total": 38, "additions": 16, "deletions": 22}, "files": [{"sha": "883c1bbbbe5853e4d31ef903e387488dc129b719", "filename": "src/libstd/thread.rs", "status": "modified", "additions": 16, "deletions": 22, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/524327ace2bf03e4919d32c2191ba831385afa4d/src%2Flibstd%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/524327ace2bf03e4919d32c2191ba831385afa4d/src%2Flibstd%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread.rs?ref=524327ace2bf03e4919d32c2191ba831385afa4d", "patch": "@@ -28,25 +28,25 @@\n //! a thread will unwind the stack, running destructors and freeing\n //! owned resources. Thread panic is unrecoverable from within\n //! the panicking thread (i.e. there is no 'try/catch' in Rust), but\n-//! panic may optionally be detected from a different thread. If\n-//! the main thread panics the application will exit with a non-zero\n+//! the panic may optionally be detected from a different thread. If\n+//! the main thread panics, the application will exit with a non-zero\n //! exit code.\n //!\n //! When the main thread of a Rust program terminates, the entire program shuts\n //! down, even if other threads are still running. However, this module provides\n //! convenient facilities for automatically waiting for the termination of a\n-//! child thread (i.e., join), described below.\n+//! child thread (i.e., join).\n //!\n //! ## The `Thread` type\n //!\n-//! Already-running threads are represented via the `Thread` type, which you can\n+//! Threads are represented via the `Thread` type, which you can\n //! get in one of two ways:\n //!\n-//! * By spawning a new thread, e.g. using the `thread::spawn` constructor;\n+//! * By spawning a new thread, e.g. using the `thread::spawn` function.\n //! * By requesting the current thread, using the `thread::current` function.\n //!\n //! Threads can be named, and provide some built-in support for low-level\n-//! synchronization described below.\n+//! synchronization (described below).\n //!\n //! The `thread::current()` function is available even for threads not spawned\n //! by the APIs of this module.\n@@ -59,29 +59,27 @@\n //! use std::thread;\n //!\n //! thread::spawn(move || {\n-//!     println!(\"Hello, World!\");\n-//!     // some computation here\n+//!     // some work here\n //! });\n //! ```\n //!\n //! In this example, the spawned thread is \"detached\" from the current\n-//! thread, meaning that it can outlive the thread that spawned\n-//! it. (Note, however, that when the main thread terminates all\n-//! detached threads are terminated as well.)\n+//! thread. This means that it can outlive its parent (the thread that spawned\n+//! it), unless this parent is the main thread.\n //!\n //! ## Scoped threads\n //!\n //! Often a parent thread uses a child thread to perform some particular task,\n //! and at some point must wait for the child to complete before continuing.\n-//! For this scenario, use the `scoped` constructor:\n+//! For this scenario, use the `thread::scoped` function:\n //!\n //! ```rust\n //! use std::thread;\n //!\n //! let guard = thread::scoped(move || {\n-//!     println!(\"Hello, World!\");\n-//!     // some computation here\n+//!     // some work here\n //! });\n+//!\n //! // do some other work in the meantime\n //! let output = guard.join();\n //! ```\n@@ -92,11 +90,7 @@\n //! terminates) when it is dropped. You can join the child thread in\n //! advance by calling the `join` method on the guard, which will also\n //! return the result produced by the thread.  A handle to the thread\n-//! itself is available via the `thread` method on the join guard.\n-//!\n-//! (Note: eventually, the `scoped` constructor will allow the parent and child\n-//! threads to data that lives on the parent thread's stack, but some language\n-//! changes are needed before this is possible.)\n+//! itself is available via the `thread` method of the join guard.\n //!\n //! ## Configuring threads\n //!\n@@ -108,7 +102,7 @@\n //! use std::thread;\n //!\n //! thread::Builder::new().name(\"child1\".to_string()).spawn(move || {\n-//!     println!(\"Hello, world!\")\n+//!     println!(\"Hello, world!\");\n //! });\n //! ```\n //!\n@@ -121,7 +115,7 @@\n //! initially not present:\n //!\n //! * The `thread::park()` function blocks the current thread unless or until\n-//!   the token is available for its thread handle, at which point It atomically\n+//!   the token is available for its thread handle, at which point it atomically\n //!   consumes the token. It may also return *spuriously*, without consuming the\n //!   token. `thread::park_timeout()` does the same, but allows specifying a\n //!   maximum time to block the thread for.\n@@ -143,7 +137,7 @@\n //! * It avoids the need to allocate mutexes and condvars when building new\n //!   synchronization primitives; the threads already provide basic blocking/signaling.\n //!\n-//! * It can be implemented highly efficiently on many platforms.\n+//! * It can be implemented very efficiently on many platforms.\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n "}]}