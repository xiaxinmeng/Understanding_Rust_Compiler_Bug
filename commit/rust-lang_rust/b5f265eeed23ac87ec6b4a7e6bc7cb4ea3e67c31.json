{"sha": "b5f265eeed23ac87ec6b4a7e6bc7cb4ea3e67c31", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI1ZjI2NWVlZWQyM2FjODdlYzZiNGE3ZTZiYzdjYjRlYTNlNjdjMzE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-11-27T04:51:31Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-11-27T04:51:31Z"}, "message": "Auto merge of #66675 - GuillaumeGomez:support-anchors-intra-doc-links, r=kinnison\n\nSupport anchors intra doc links\n\nFixes #62833\nPart of #43466.\n\ncc @ollie27\nr? @kinnison", "tree": {"sha": "4eb21ae4fe7ba42f31aa57a5d232e529d6a2b777", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4eb21ae4fe7ba42f31aa57a5d232e529d6a2b777"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b5f265eeed23ac87ec6b4a7e6bc7cb4ea3e67c31", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b5f265eeed23ac87ec6b4a7e6bc7cb4ea3e67c31", "html_url": "https://github.com/rust-lang/rust/commit/b5f265eeed23ac87ec6b4a7e6bc7cb4ea3e67c31", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b5f265eeed23ac87ec6b4a7e6bc7cb4ea3e67c31/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "809e180a76ce97340bf4354ff357bc59e3ca40b2", "url": "https://api.github.com/repos/rust-lang/rust/commits/809e180a76ce97340bf4354ff357bc59e3ca40b2", "html_url": "https://github.com/rust-lang/rust/commit/809e180a76ce97340bf4354ff357bc59e3ca40b2"}, {"sha": "c1ea1fd2b03b16bfeab01cbcd7bae976ab596923", "url": "https://api.github.com/repos/rust-lang/rust/commits/c1ea1fd2b03b16bfeab01cbcd7bae976ab596923", "html_url": "https://github.com/rust-lang/rust/commit/c1ea1fd2b03b16bfeab01cbcd7bae976ab596923"}], "stats": {"total": 434, "additions": 328, "deletions": 106}, "files": [{"sha": "783168d7bd6ecccad0b71174d52bd1f63cccffa2", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 211, "deletions": 78, "changes": 289, "blob_url": "https://github.com/rust-lang/rust/blob/b5f265eeed23ac87ec6b4a7e6bc7cb4ea3e67c31/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5f265eeed23ac87ec6b4a7e6bc7cb4ea3e67c31/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=b5f265eeed23ac87ec6b4a7e6bc7cb4ea3e67c31", "patch": "@@ -38,6 +38,11 @@ pub fn collect_intra_doc_links(krate: Crate, cx: &DocContext<'_>) -> Crate {\n     }\n }\n \n+enum ErrorKind {\n+    ResolutionFailure,\n+    AnchorFailure(&'static str),\n+}\n+\n struct LinkCollector<'a, 'tcx> {\n     cx: &'a DocContext<'tcx>,\n     mod_ids: Vec<hir::HirId>,\n@@ -53,13 +58,14 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n \n     /// Resolves a string as a path within a particular namespace. Also returns an optional\n     /// URL fragment in the case of variants and methods.\n-    fn resolve(&self,\n-               path_str: &str,\n-               ns: Namespace,\n-               current_item: &Option<String>,\n-               parent_id: Option<hir::HirId>)\n-        -> Result<(Res, Option<String>), ()>\n-    {\n+    fn resolve(\n+        &self,\n+        path_str: &str,\n+        ns: Namespace,\n+        current_item: &Option<String>,\n+        parent_id: Option<hir::HirId>,\n+        extra_fragment: &Option<String>,\n+    ) -> Result<(Res, Option<String>), ErrorKind> {\n         let cx = self.cx;\n \n         // In case we're in a module, try to resolve the relative path.\n@@ -69,8 +75,8 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                 resolver.resolve_str_path_error(DUMMY_SP, &path_str, ns, module_id)\n             });\n             let result = match result {\n-                Ok((_, Res::Err)) => Err(()),\n-                _ => result,\n+                Ok((_, Res::Err)) => Err(ErrorKind::ResolutionFailure),\n+                _ => result.map_err(|_| ErrorKind::ResolutionFailure),\n             };\n \n             if let Ok((_, res)) = result {\n@@ -80,23 +86,36 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                 let value = match res {\n                     Res::Def(DefKind::Method, _) | Res::Def(DefKind::AssocConst, _) => true,\n                     Res::Def(DefKind::AssocTy, _) => false,\n-                    Res::Def(DefKind::Variant, _) => return handle_variant(cx, res),\n+                    Res::Def(DefKind::Variant, _) => {\n+                        return handle_variant(cx, res, extra_fragment);\n+                    }\n                     // Not a trait item; just return what we found.\n-                    Res::PrimTy(..) => return Ok((res, Some(path_str.to_owned()))),\n-                    _ => return Ok((res, None))\n+                    Res::PrimTy(..) => {\n+                        if extra_fragment.is_some() {\n+                            return Err(\n+                                ErrorKind::AnchorFailure(\n+                                    \"primitive types cannot be followed by anchors\"));\n+                        }\n+                        return Ok((res, Some(path_str.to_owned())));\n+                    }\n+                    _ => return Ok((res, extra_fragment.clone()))\n                 };\n \n                 if value != (ns == ValueNS) {\n-                    return Err(())\n+                    return Err(ErrorKind::ResolutionFailure)\n                 }\n             } else if let Some(prim) = is_primitive(path_str, ns) {\n+                if extra_fragment.is_some() {\n+                    return Err(\n+                        ErrorKind::AnchorFailure(\"primitive types cannot be followed by anchors\"));\n+                }\n                 return Ok((prim, Some(path_str.to_owned())))\n             } else {\n                 // If resolution failed, it may still be a method\n                 // because methods are not handled by the resolver\n                 // If so, bail when we're not looking for a value.\n                 if ns != ValueNS {\n-                    return Err(())\n+                    return Err(ErrorKind::ResolutionFailure)\n                 }\n             }\n \n@@ -105,13 +124,13 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n             let item_name = if let Some(first) = split.next() {\n                 Symbol::intern(first)\n             } else {\n-                return Err(())\n+                return Err(ErrorKind::ResolutionFailure)\n             };\n \n             let mut path = if let Some(second) = split.next() {\n                 second.to_owned()\n             } else {\n-                return Err(())\n+                return Err(ErrorKind::ResolutionFailure)\n             };\n \n             if path == \"self\" || path == \"Self\" {\n@@ -120,22 +139,22 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                 }\n             }\n             if let Some(prim) = is_primitive(&path, TypeNS) {\n-                let did = primitive_impl(cx, &path).ok_or(())?;\n+                let did = primitive_impl(cx, &path).ok_or(ErrorKind::ResolutionFailure)?;\n                 return cx.tcx.associated_items(did)\n                     .find(|item| item.ident.name == item_name)\n                     .and_then(|item| match item.kind {\n                         ty::AssocKind::Method => Some(\"method\"),\n                         _ => None,\n                     })\n                     .map(|out| (prim, Some(format!(\"{}#{}.{}\", path, out, item_name))))\n-                    .ok_or(());\n+                    .ok_or(ErrorKind::ResolutionFailure);\n             }\n \n             let (_, ty_res) = cx.enter_resolver(|resolver| {\n                 resolver.resolve_str_path_error(DUMMY_SP, &path, TypeNS, module_id)\n-            })?;\n+            }).map_err(|_| ErrorKind::ResolutionFailure)?;\n             if let Res::Err = ty_res {\n-                return Err(());\n+                return Err(ErrorKind::ResolutionFailure);\n             }\n             let ty_res = ty_res.map_id(|_| panic!(\"unexpected node_id\"));\n             match ty_res {\n@@ -151,9 +170,18 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                         let out = match item.kind {\n                             ty::AssocKind::Method if ns == ValueNS => \"method\",\n                             ty::AssocKind::Const if ns == ValueNS => \"associatedconstant\",\n-                            _ => return Err(())\n+                            _ => return Err(ErrorKind::ResolutionFailure)\n                         };\n-                        Ok((ty_res, Some(format!(\"{}.{}\", out, item_name))))\n+                        if extra_fragment.is_some() {\n+                            Err(ErrorKind::AnchorFailure(\n+                                if item.kind == ty::AssocKind::Method {\n+                                    \"methods cannot be followed by anchors\"\n+                                } else {\n+                                    \"associated constants cannot be followed by anchors\"\n+                                }))\n+                        } else {\n+                            Ok((ty_res, Some(format!(\"{}.{}\", out, item_name))))\n+                        }\n                     } else {\n                         match cx.tcx.type_of(did).kind {\n                             ty::Adt(def, _) => {\n@@ -165,19 +193,28 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                                        .iter()\n                                        .find(|item| item.ident.name == item_name)\n                                 } {\n-                                    Ok((ty_res,\n-                                        Some(format!(\"{}.{}\",\n-                                                     if def.is_enum() {\n-                                                         \"variant\"\n-                                                     } else {\n-                                                         \"structfield\"\n-                                                     },\n-                                                     item.ident))))\n+                                    if extra_fragment.is_some() {\n+                                        Err(ErrorKind::AnchorFailure(\n+                                            if def.is_enum() {\n+                                                \"enum variants cannot be followed by anchors\"\n+                                            } else {\n+                                                \"struct fields cannot be followed by anchors\"\n+                                            }))\n+                                    } else {\n+                                        Ok((ty_res,\n+                                            Some(format!(\"{}.{}\",\n+                                                         if def.is_enum() {\n+                                                             \"variant\"\n+                                                         } else {\n+                                                             \"structfield\"\n+                                                         },\n+                                                         item.ident))))\n+                                    }\n                                 } else {\n-                                    Err(())\n+                                    Err(ErrorKind::ResolutionFailure)\n                                 }\n                             }\n-                            _ => Err(()),\n+                            _ => Err(ErrorKind::ResolutionFailure),\n                         }\n                     }\n                 }\n@@ -196,19 +233,30 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                                     \"tymethod\"\n                                 }\n                             }\n-                            _ => return Err(())\n+                            _ => return Err(ErrorKind::ResolutionFailure)\n                         };\n \n-                        Ok((ty_res, Some(format!(\"{}.{}\", kind, item_name))))\n+                        if extra_fragment.is_some() {\n+                            Err(ErrorKind::AnchorFailure(\n+                                if item.kind == ty::AssocKind::Const {\n+                                    \"associated constants cannot be followed by anchors\"\n+                                } else if item.kind == ty::AssocKind::Type {\n+                                    \"associated types cannot be followed by anchors\"\n+                                } else {\n+                                    \"methods cannot be followed by anchors\"\n+                                }))\n+                        } else {\n+                            Ok((ty_res, Some(format!(\"{}.{}\", kind, item_name))))\n+                        }\n                     } else {\n-                        Err(())\n+                        Err(ErrorKind::ResolutionFailure)\n                     }\n                 }\n-                _ => Err(())\n+                _ => Err(ErrorKind::ResolutionFailure)\n             }\n         } else {\n             debug!(\"attempting to resolve item without parent module: {}\", path_str);\n-            Err(())\n+            Err(ErrorKind::ResolutionFailure)\n         }\n     }\n }\n@@ -289,6 +337,22 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n             }\n \n             let link = ori_link.replace(\"`\", \"\");\n+            let parts = link.split('#').collect::<Vec<_>>();\n+            let (link, extra_fragment) = if parts.len() > 2 {\n+                build_diagnostic(cx, &item, &link, &dox, link_range,\n+                                 \"has an issue with the link anchor.\",\n+                                 \"only one `#` is allowed in a link\",\n+                                 None);\n+                continue;\n+            } else if parts.len() == 2 {\n+                if parts[0].trim().is_empty() {\n+                    // This is an anchor to an element of the current page, nothing to do in here!\n+                    continue;\n+                }\n+                (parts[0].to_owned(), Some(parts[1].to_owned()))\n+            } else {\n+                (parts[0].to_owned(), None)\n+            };\n             let (res, fragment) = {\n                 let mut kind = None;\n                 let path_str = if let Some(prefix) =\n@@ -341,42 +405,73 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n \n                 match kind {\n                     Some(ns @ ValueNS) => {\n-                        if let Ok(res) = self.resolve(path_str, ns, &current_item, base_node) {\n-                            res\n-                        } else {\n-                            resolution_failure(cx, &item, path_str, &dox, link_range);\n-                            // This could just be a normal link or a broken link\n-                            // we could potentially check if something is\n-                            // \"intra-doc-link-like\" and warn in that case.\n-                            continue;\n+                        match self.resolve(path_str, ns, &current_item, base_node,\n+                                           &extra_fragment) {\n+                            Ok(res) => res,\n+                            Err(ErrorKind::ResolutionFailure) => {\n+                                resolution_failure(cx, &item, path_str, &dox, link_range);\n+                                // This could just be a normal link or a broken link\n+                                // we could potentially check if something is\n+                                // \"intra-doc-link-like\" and warn in that case.\n+                                continue;\n+                            }\n+                            Err(ErrorKind::AnchorFailure(msg)) => {\n+                                anchor_failure(cx, &item, &ori_link, &dox, link_range, msg);\n+                                continue\n+                            }\n                         }\n                     }\n                     Some(ns @ TypeNS) => {\n-                        if let Ok(res) = self.resolve(path_str, ns, &current_item, base_node) {\n-                            res\n-                        } else {\n-                            resolution_failure(cx, &item, path_str, &dox, link_range);\n-                            // This could just be a normal link.\n-                            continue;\n+                        match self.resolve(path_str, ns, &current_item, base_node,\n+                                           &extra_fragment) {\n+                            Ok(res) => res,\n+                            Err(ErrorKind::ResolutionFailure) => {\n+                                resolution_failure(cx, &item, path_str, &dox, link_range);\n+                                // This could just be a normal link.\n+                                continue;\n+                            }\n+                            Err(ErrorKind::AnchorFailure(msg)) => {\n+                                anchor_failure(cx, &item, &ori_link, &dox, link_range, msg);\n+                                continue\n+                            }\n                         }\n                     }\n                     None => {\n                         // Try everything!\n                         let candidates = PerNS {\n-                            macro_ns: macro_resolve(cx, path_str).map(|res| (res, None)),\n-                            type_ns: self\n-                                .resolve(path_str, TypeNS, &current_item, base_node)\n-                                .ok(),\n-                            value_ns: self\n-                                .resolve(path_str, ValueNS, &current_item, base_node)\n-                                .ok()\n-                                .and_then(|(res, fragment)| {\n-                                    // Constructors are picked up in the type namespace.\n-                                    match res {\n-                                        Res::Def(DefKind::Ctor(..), _) | Res::SelfCtor(..) => None,\n-                                        _ => Some((res, fragment))\n-                                    }\n-                                }),\n+                            macro_ns: macro_resolve(cx, path_str)\n+                                        .map(|res| (res, extra_fragment.clone())),\n+                            type_ns: match self.resolve(path_str, TypeNS, &current_item, base_node,\n+                                                        &extra_fragment) {\n+                                Err(ErrorKind::AnchorFailure(msg)) => {\n+                                    anchor_failure(cx, &item, &ori_link, &dox, link_range, msg);\n+                                    continue;\n+                                }\n+                                x => x.ok(),\n+                            },\n+                            value_ns: match self.resolve(path_str, ValueNS, &current_item,\n+                                                         base_node, &extra_fragment) {\n+                                Err(ErrorKind::AnchorFailure(msg)) => {\n+                                    anchor_failure(cx, &item, &ori_link, &dox, link_range, msg);\n+                                    continue;\n+                                }\n+                                x => x.ok(),\n+                            }\n+                            .and_then(|(res, fragment)| {\n+                                // Constructors are picked up in the type namespace.\n+                                match res {\n+                                    Res::Def(DefKind::Ctor(..), _) | Res::SelfCtor(..) => None,\n+                                    _ => match (fragment, extra_fragment) {\n+                                        (Some(fragment), Some(_)) => {\n+                                            // Shouldn't happen but who knows?\n+                                            Some((res, Some(fragment)))\n+                                        }\n+                                        (fragment, None) | (None, fragment) => {\n+                                            Some((res, fragment))\n+                                        }\n+                                    },\n+                                }\n+                            }),\n                         };\n \n                         if candidates.is_empty() {\n@@ -402,7 +497,7 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n                     }\n                     Some(MacroNS) => {\n                         if let Some(res) = macro_resolve(cx, path_str) {\n-                            (res, None)\n+                            (res, extra_fragment)\n                         } else {\n                             resolution_failure(cx, &item, path_str, &dox, link_range);\n                             continue\n@@ -462,17 +557,15 @@ fn macro_resolve(cx: &DocContext<'_>, path_str: &str) -> Option<Res> {\n     })\n }\n \n-/// Reports a resolution failure diagnostic.\n-///\n-/// If we cannot find the exact source span of the resolution failure, we use the span of the\n-/// documentation attributes themselves. This is a little heavy-handed, so we display the markdown\n-/// line containing the failure as a note as well.\n-fn resolution_failure(\n+fn build_diagnostic(\n     cx: &DocContext<'_>,\n     item: &Item,\n     path_str: &str,\n     dox: &str,\n     link_range: Option<Range<usize>>,\n+    err_msg: &str,\n+    short_err_msg: &str,\n+    help_msg: Option<&str>,\n ) {\n     let hir_id = match cx.as_local_hir_id(item.def_id) {\n         Some(hir_id) => hir_id,\n@@ -488,12 +581,12 @@ fn resolution_failure(\n         lint::builtin::INTRA_DOC_LINK_RESOLUTION_FAILURE,\n         hir_id,\n         sp,\n-        &format!(\"`[{}]` cannot be resolved, ignoring it...\", path_str),\n+        &format!(\"`[{}]` {}\", path_str, err_msg),\n     );\n     if let Some(link_range) = link_range {\n         if let Some(sp) = super::source_span_for_markdown_range(cx, dox, &link_range, attrs) {\n             diag.set_span(sp);\n-            diag.span_label(sp, \"cannot be resolved, ignoring\");\n+            diag.span_label(sp, short_err_msg);\n         } else {\n             // blah blah blah\\nblah\\nblah [blah] blah blah\\nblah blah\n             //                       ^     ~~~~\n@@ -513,11 +606,44 @@ fn resolution_failure(\n             ));\n         }\n     };\n-    diag.help(\"to escape `[` and `]` characters, just add '\\\\' before them like \\\n-               `\\\\[` or `\\\\]`\");\n+    if let Some(help_msg) = help_msg {\n+        diag.help(help_msg);\n+    }\n     diag.emit();\n }\n \n+/// Reports a resolution failure diagnostic.\n+///\n+/// If we cannot find the exact source span of the resolution failure, we use the span of the\n+/// documentation attributes themselves. This is a little heavy-handed, so we display the markdown\n+/// line containing the failure as a note as well.\n+fn resolution_failure(\n+    cx: &DocContext<'_>,\n+    item: &Item,\n+    path_str: &str,\n+    dox: &str,\n+    link_range: Option<Range<usize>>,\n+) {\n+    build_diagnostic(cx, item, path_str, dox, link_range,\n+         \"cannot be resolved, ignoring it.\",\n+         \"cannot be resolved, ignoring\",\n+         Some(\"to escape `[` and `]` characters, just add '\\\\' before them like `\\\\[` or `\\\\]`\"));\n+}\n+\n+fn anchor_failure(\n+    cx: &DocContext<'_>,\n+    item: &Item,\n+    path_str: &str,\n+    dox: &str,\n+    link_range: Option<Range<usize>>,\n+    msg: &str,\n+) {\n+    build_diagnostic(cx, item, path_str, dox, link_range,\n+         \"has an issue with the link anchor.\",\n+         msg,\n+         None);\n+}\n+\n fn ambiguity_error(\n     cx: &DocContext<'_>,\n     item: &Item,\n@@ -637,13 +763,20 @@ fn ambiguity_error(\n }\n \n /// Given an enum variant's res, return the res of its enum and the associated fragment.\n-fn handle_variant(cx: &DocContext<'_>, res: Res) -> Result<(Res, Option<String>), ()> {\n+fn handle_variant(\n+    cx: &DocContext<'_>,\n+    res: Res,\n+    extra_fragment: &Option<String>,\n+) -> Result<(Res, Option<String>), ErrorKind> {\n     use rustc::ty::DefIdTree;\n \n+    if extra_fragment.is_some() {\n+        return Err(ErrorKind::AnchorFailure(\"variants cannot be followed by anchors\"));\n+    }\n     let parent = if let Some(parent) = cx.tcx.parent(res.def_id()) {\n         parent\n     } else {\n-        return Err(())\n+        return Err(ErrorKind::ResolutionFailure)\n     };\n     let parent_def = Res::Def(DefKind::Enum, parent);\n     let variant = cx.tcx.expect_variant_res(res);"}, {"sha": "b432bfbf20f5daefc28f82ce934fbef27bba6a0f", "filename": "src/test/rustdoc-ui/deny-intra-link-resolution-failure.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b5f265eeed23ac87ec6b4a7e6bc7cb4ea3e67c31/src%2Ftest%2Frustdoc-ui%2Fdeny-intra-link-resolution-failure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b5f265eeed23ac87ec6b4a7e6bc7cb4ea3e67c31/src%2Ftest%2Frustdoc-ui%2Fdeny-intra-link-resolution-failure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fdeny-intra-link-resolution-failure.stderr?ref=b5f265eeed23ac87ec6b4a7e6bc7cb4ea3e67c31", "patch": "@@ -1,4 +1,4 @@\n-error: `[v2]` cannot be resolved, ignoring it...\n+error: `[v2]` cannot be resolved, ignoring it.\n   --> $DIR/deny-intra-link-resolution-failure.rs:3:6\n    |\n LL | /// [v2]"}, {"sha": "d4d3e5fea3e1aea009d2c2ce3f28424e8bfcd293", "filename": "src/test/rustdoc-ui/intra-doc-alias-ice.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b5f265eeed23ac87ec6b4a7e6bc7cb4ea3e67c31/src%2Ftest%2Frustdoc-ui%2Fintra-doc-alias-ice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b5f265eeed23ac87ec6b4a7e6bc7cb4ea3e67c31/src%2Ftest%2Frustdoc-ui%2Fintra-doc-alias-ice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fintra-doc-alias-ice.stderr?ref=b5f265eeed23ac87ec6b4a7e6bc7cb4ea3e67c31", "patch": "@@ -1,4 +1,4 @@\n-error: `[TypeAlias::hoge]` cannot be resolved, ignoring it...\n+error: `[TypeAlias::hoge]` cannot be resolved, ignoring it.\n   --> $DIR/intra-doc-alias-ice.rs:5:30\n    |\n LL | /// [broken cross-reference](TypeAlias::hoge)"}, {"sha": "44997c90f59320465bbc7a6b063886aca329afe1", "filename": "src/test/rustdoc-ui/intra-link-span-ice-55723.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b5f265eeed23ac87ec6b4a7e6bc7cb4ea3e67c31/src%2Ftest%2Frustdoc-ui%2Fintra-link-span-ice-55723.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5f265eeed23ac87ec6b4a7e6bc7cb4ea3e67c31/src%2Ftest%2Frustdoc-ui%2Fintra-link-span-ice-55723.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fintra-link-span-ice-55723.rs?ref=b5f265eeed23ac87ec6b4a7e6bc7cb4ea3e67c31", "patch": "@@ -7,7 +7,7 @@\n /// ## For example:\n ///\n /// \uff08arr[i]\uff09\n-//~^ ERROR `[i]` cannot be resolved, ignoring it...\n+//~^ ERROR `[i]` cannot be resolved, ignoring it.\n pub fn test_ice() {\n     unimplemented!();\n }"}, {"sha": "edd5b8b92f2302c441b9be03a3404dbee89d630c", "filename": "src/test/rustdoc-ui/intra-link-span-ice-55723.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b5f265eeed23ac87ec6b4a7e6bc7cb4ea3e67c31/src%2Ftest%2Frustdoc-ui%2Fintra-link-span-ice-55723.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b5f265eeed23ac87ec6b4a7e6bc7cb4ea3e67c31/src%2Ftest%2Frustdoc-ui%2Fintra-link-span-ice-55723.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fintra-link-span-ice-55723.stderr?ref=b5f265eeed23ac87ec6b4a7e6bc7cb4ea3e67c31", "patch": "@@ -1,4 +1,4 @@\n-error: `[i]` cannot be resolved, ignoring it...\n+error: `[i]` cannot be resolved, ignoring it.\n   --> $DIR/intra-link-span-ice-55723.rs:9:10\n    |\n LL | /// \uff08arr[i]\uff09"}, {"sha": "7f8a8dd3c45e03e7a396cfbaad84e0dd060b4e9e", "filename": "src/test/rustdoc-ui/intra-links-anchors.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/b5f265eeed23ac87ec6b4a7e6bc7cb4ea3e67c31/src%2Ftest%2Frustdoc-ui%2Fintra-links-anchors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5f265eeed23ac87ec6b4a7e6bc7cb4ea3e67c31/src%2Ftest%2Frustdoc-ui%2Fintra-links-anchors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fintra-links-anchors.rs?ref=b5f265eeed23ac87ec6b4a7e6bc7cb4ea3e67c31", "patch": "@@ -0,0 +1,45 @@\n+#![deny(intra_doc_link_resolution_failure)]\n+\n+// A few tests on anchors.\n+\n+/// Hello people.\n+///\n+/// You can anchors? Here's one!\n+///\n+/// # hola\n+///\n+/// Isn't it amazing?\n+pub struct Foo {\n+    pub f: u8,\n+}\n+\n+pub enum Enum {\n+    A,\n+    B,\n+}\n+\n+/// Have you heard about stuff?\n+///\n+/// Like [Foo#hola].\n+///\n+/// Or maybe [Foo::f#hola].\n+//~^ ERROR `[Foo::f#hola]` has an issue with the link anchor.\n+pub fn foo() {}\n+\n+/// Empty.\n+///\n+/// Another anchor error: [hello#people#!].\n+//~^ ERROR `[hello#people#!]` has an issue with the link anchor.\n+pub fn bar() {}\n+\n+/// Empty?\n+///\n+/// Damn enum's variants: [Enum::A#whatever].\n+//~^ ERROR `[Enum::A#whatever]` has an issue with the link anchor.\n+pub fn enum_link() {}\n+\n+/// Primitives?\n+///\n+/// [u32#hello]\n+//~^ ERROR `[u32#hello]` has an issue with the link anchor.\n+pub fn x() {}"}, {"sha": "5fead8e4c358e8713099f491b09b8533eef447d4", "filename": "src/test/rustdoc-ui/intra-links-anchors.stderr", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/b5f265eeed23ac87ec6b4a7e6bc7cb4ea3e67c31/src%2Ftest%2Frustdoc-ui%2Fintra-links-anchors.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b5f265eeed23ac87ec6b4a7e6bc7cb4ea3e67c31/src%2Ftest%2Frustdoc-ui%2Fintra-links-anchors.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fintra-links-anchors.stderr?ref=b5f265eeed23ac87ec6b4a7e6bc7cb4ea3e67c31", "patch": "@@ -0,0 +1,32 @@\n+error: `[Foo::f#hola]` has an issue with the link anchor.\n+  --> $DIR/intra-links-anchors.rs:25:15\n+   |\n+LL | /// Or maybe [Foo::f#hola].\n+   |               ^^^^^^^^^^^ struct fields cannot be followed by anchors\n+   |\n+note: lint level defined here\n+  --> $DIR/intra-links-anchors.rs:1:9\n+   |\n+LL | #![deny(intra_doc_link_resolution_failure)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: `[hello#people#!]` has an issue with the link anchor.\n+  --> $DIR/intra-links-anchors.rs:31:28\n+   |\n+LL | /// Another anchor error: [hello#people#!].\n+   |                            ^^^^^^^^^^^^^^ only one `#` is allowed in a link\n+\n+error: `[Enum::A#whatever]` has an issue with the link anchor.\n+  --> $DIR/intra-links-anchors.rs:37:28\n+   |\n+LL | /// Damn enum's variants: [Enum::A#whatever].\n+   |                            ^^^^^^^^^^^^^^^^ variants cannot be followed by anchors\n+\n+error: `[u32#hello]` has an issue with the link anchor.\n+  --> $DIR/intra-links-anchors.rs:43:6\n+   |\n+LL | /// [u32#hello]\n+   |      ^^^^^^^^^ primitive types cannot be followed by anchors\n+\n+error: aborting due to 4 previous errors\n+"}, {"sha": "e4dd13cfa0195d0fd2c18e94981bbc44fb9970f0", "filename": "src/test/rustdoc-ui/intra-links-warning-crlf.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b5f265eeed23ac87ec6b4a7e6bc7cb4ea3e67c31/src%2Ftest%2Frustdoc-ui%2Fintra-links-warning-crlf.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b5f265eeed23ac87ec6b4a7e6bc7cb4ea3e67c31/src%2Ftest%2Frustdoc-ui%2Fintra-links-warning-crlf.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fintra-links-warning-crlf.stderr?ref=b5f265eeed23ac87ec6b4a7e6bc7cb4ea3e67c31", "patch": "@@ -1,4 +1,4 @@\n-warning: `[error]` cannot be resolved, ignoring it...\n+warning: `[error]` cannot be resolved, ignoring it.\n   --> $DIR/intra-links-warning-crlf.rs:7:6\n    |\n LL | /// [error]\n@@ -7,23 +7,23 @@ LL | /// [error]\n    = note: `#[warn(intra_doc_link_resolution_failure)]` on by default\n    = help: to escape `[` and `]` characters, just add '\\' before them like `\\[` or `\\]`\n \n-warning: `[error1]` cannot be resolved, ignoring it...\n+warning: `[error1]` cannot be resolved, ignoring it.\n   --> $DIR/intra-links-warning-crlf.rs:12:11\n    |\n LL | /// docs [error1]\n    |           ^^^^^^ cannot be resolved, ignoring\n    |\n    = help: to escape `[` and `]` characters, just add '\\' before them like `\\[` or `\\]`\n \n-warning: `[error2]` cannot be resolved, ignoring it...\n+warning: `[error2]` cannot be resolved, ignoring it.\n   --> $DIR/intra-links-warning-crlf.rs:15:11\n    |\n LL | /// docs [error2]\n    |           ^^^^^^ cannot be resolved, ignoring\n    |\n    = help: to escape `[` and `]` characters, just add '\\' before them like `\\[` or `\\]`\n \n-warning: `[error]` cannot be resolved, ignoring it...\n+warning: `[error]` cannot be resolved, ignoring it.\n   --> $DIR/intra-links-warning-crlf.rs:23:20\n    |\n LL |  * It also has an [error]."}, {"sha": "5f1c9cfbc367a752b5c9242449a1d17357a209bb", "filename": "src/test/rustdoc-ui/intra-links-warning.stderr", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/b5f265eeed23ac87ec6b4a7e6bc7cb4ea3e67c31/src%2Ftest%2Frustdoc-ui%2Fintra-links-warning.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b5f265eeed23ac87ec6b4a7e6bc7cb4ea3e67c31/src%2Ftest%2Frustdoc-ui%2Fintra-links-warning.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fintra-links-warning.stderr?ref=b5f265eeed23ac87ec6b4a7e6bc7cb4ea3e67c31", "patch": "@@ -1,4 +1,4 @@\n-warning: `[Foo::baz]` cannot be resolved, ignoring it...\n+warning: `[Foo::baz]` cannot be resolved, ignoring it.\n   --> $DIR/intra-links-warning.rs:3:23\n    |\n LL |        //! Test with [Foo::baz], [Bar::foo], ...\n@@ -7,71 +7,71 @@ LL |        //! Test with [Foo::baz], [Bar::foo], ...\n    = note: `#[warn(intra_doc_link_resolution_failure)]` on by default\n    = help: to escape `[` and `]` characters, just add '\\' before them like `\\[` or `\\]`\n \n-warning: `[Bar::foo]` cannot be resolved, ignoring it...\n+warning: `[Bar::foo]` cannot be resolved, ignoring it.\n   --> $DIR/intra-links-warning.rs:3:35\n    |\n LL |        //! Test with [Foo::baz], [Bar::foo], ...\n    |                                   ^^^^^^^^ cannot be resolved, ignoring\n    |\n    = help: to escape `[` and `]` characters, just add '\\' before them like `\\[` or `\\]`\n \n-warning: `[Uniooon::X]` cannot be resolved, ignoring it...\n+warning: `[Uniooon::X]` cannot be resolved, ignoring it.\n   --> $DIR/intra-links-warning.rs:6:13\n    |\n LL |      //! , [Uniooon::X] and [Qux::Z].\n    |             ^^^^^^^^^^ cannot be resolved, ignoring\n    |\n    = help: to escape `[` and `]` characters, just add '\\' before them like `\\[` or `\\]`\n \n-warning: `[Qux::Z]` cannot be resolved, ignoring it...\n+warning: `[Qux::Z]` cannot be resolved, ignoring it.\n   --> $DIR/intra-links-warning.rs:6:30\n    |\n LL |      //! , [Uniooon::X] and [Qux::Z].\n    |                              ^^^^^^ cannot be resolved, ignoring\n    |\n    = help: to escape `[` and `]` characters, just add '\\' before them like `\\[` or `\\]`\n \n-warning: `[Uniooon::X]` cannot be resolved, ignoring it...\n+warning: `[Uniooon::X]` cannot be resolved, ignoring it.\n   --> $DIR/intra-links-warning.rs:10:14\n    |\n LL |       //! , [Uniooon::X] and [Qux::Z].\n    |              ^^^^^^^^^^ cannot be resolved, ignoring\n    |\n    = help: to escape `[` and `]` characters, just add '\\' before them like `\\[` or `\\]`\n \n-warning: `[Qux::Z]` cannot be resolved, ignoring it...\n+warning: `[Qux::Z]` cannot be resolved, ignoring it.\n   --> $DIR/intra-links-warning.rs:10:31\n    |\n LL |       //! , [Uniooon::X] and [Qux::Z].\n    |                               ^^^^^^ cannot be resolved, ignoring\n    |\n    = help: to escape `[` and `]` characters, just add '\\' before them like `\\[` or `\\]`\n \n-warning: `[Qux:Y]` cannot be resolved, ignoring it...\n+warning: `[Qux:Y]` cannot be resolved, ignoring it.\n   --> $DIR/intra-links-warning.rs:14:13\n    |\n LL |        /// [Qux:Y]\n    |             ^^^^^ cannot be resolved, ignoring\n    |\n    = help: to escape `[` and `]` characters, just add '\\' before them like `\\[` or `\\]`\n \n-warning: `[error]` cannot be resolved, ignoring it...\n+warning: `[error]` cannot be resolved, ignoring it.\n   --> $DIR/intra-links-warning.rs:58:30\n    |\n LL |  * time to introduce a link [error]*/\n    |                              ^^^^^ cannot be resolved, ignoring\n    |\n    = help: to escape `[` and `]` characters, just add '\\' before them like `\\[` or `\\]`\n \n-warning: `[error]` cannot be resolved, ignoring it...\n+warning: `[error]` cannot be resolved, ignoring it.\n   --> $DIR/intra-links-warning.rs:64:30\n    |\n LL |  * time to introduce a link [error]\n    |                              ^^^^^ cannot be resolved, ignoring\n    |\n    = help: to escape `[` and `]` characters, just add '\\' before them like `\\[` or `\\]`\n \n-warning: `[error]` cannot be resolved, ignoring it...\n+warning: `[error]` cannot be resolved, ignoring it.\n   --> $DIR/intra-links-warning.rs:68:1\n    |\n LL | #[doc = \"single line [error]\"]\n@@ -83,7 +83,7 @@ LL | #[doc = \"single line [error]\"]\n                         ^^^^^\n    = help: to escape `[` and `]` characters, just add '\\' before them like `\\[` or `\\]`\n \n-warning: `[error]` cannot be resolved, ignoring it...\n+warning: `[error]` cannot be resolved, ignoring it.\n   --> $DIR/intra-links-warning.rs:71:1\n    |\n LL | #[doc = \"single line with \\\"escaping\\\" [error]\"]\n@@ -95,7 +95,7 @@ LL | #[doc = \"single line with \\\"escaping\\\" [error]\"]\n                                         ^^^^^\n    = help: to escape `[` and `]` characters, just add '\\' before them like `\\[` or `\\]`\n \n-warning: `[error]` cannot be resolved, ignoring it...\n+warning: `[error]` cannot be resolved, ignoring it.\n   --> $DIR/intra-links-warning.rs:74:1\n    |\n LL | / /// Item docs.\n@@ -109,47 +109,47 @@ LL | | /// [error]\n             ^^^^^\n    = help: to escape `[` and `]` characters, just add '\\' before them like `\\[` or `\\]`\n \n-warning: `[error1]` cannot be resolved, ignoring it...\n+warning: `[error1]` cannot be resolved, ignoring it.\n   --> $DIR/intra-links-warning.rs:80:11\n    |\n LL | /// docs [error1]\n    |           ^^^^^^ cannot be resolved, ignoring\n    |\n    = help: to escape `[` and `]` characters, just add '\\' before them like `\\[` or `\\]`\n \n-warning: `[error2]` cannot be resolved, ignoring it...\n+warning: `[error2]` cannot be resolved, ignoring it.\n   --> $DIR/intra-links-warning.rs:82:11\n    |\n LL | /// docs [error2]\n    |           ^^^^^^ cannot be resolved, ignoring\n    |\n    = help: to escape `[` and `]` characters, just add '\\' before them like `\\[` or `\\]`\n \n-warning: `[BarA]` cannot be resolved, ignoring it...\n+warning: `[BarA]` cannot be resolved, ignoring it.\n   --> $DIR/intra-links-warning.rs:21:10\n    |\n LL | /// bar [BarA] bar\n    |          ^^^^ cannot be resolved, ignoring\n    |\n    = help: to escape `[` and `]` characters, just add '\\' before them like `\\[` or `\\]`\n \n-warning: `[BarB]` cannot be resolved, ignoring it...\n+warning: `[BarB]` cannot be resolved, ignoring it.\n   --> $DIR/intra-links-warning.rs:27:9\n    |\n LL |  * bar [BarB] bar\n    |         ^^^^ cannot be resolved, ignoring\n    |\n    = help: to escape `[` and `]` characters, just add '\\' before them like `\\[` or `\\]`\n \n-warning: `[BarC]` cannot be resolved, ignoring it...\n+warning: `[BarC]` cannot be resolved, ignoring it.\n   --> $DIR/intra-links-warning.rs:34:6\n    |\n LL | bar [BarC] bar\n    |      ^^^^ cannot be resolved, ignoring\n    |\n    = help: to escape `[` and `]` characters, just add '\\' before them like `\\[` or `\\]`\n \n-warning: `[BarD]` cannot be resolved, ignoring it...\n+warning: `[BarD]` cannot be resolved, ignoring it.\n   --> $DIR/intra-links-warning.rs:45:1\n    |\n LL | #[doc = \"Foo\\nbar [BarD] bar\\nbaz\"]\n@@ -161,7 +161,7 @@ LL | #[doc = \"Foo\\nbar [BarD] bar\\nbaz\"]\n                 ^^^^\n    = help: to escape `[` and `]` characters, just add '\\' before them like `\\[` or `\\]`\n \n-warning: `[BarF]` cannot be resolved, ignoring it...\n+warning: `[BarF]` cannot be resolved, ignoring it.\n   --> $DIR/intra-links-warning.rs:50:9\n    |\n LL |         #[doc = $f]"}, {"sha": "dca98cf58df317702bf4ebcb1f8cab4f02d27749", "filename": "src/test/rustdoc-ui/lint-group.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b5f265eeed23ac87ec6b4a7e6bc7cb4ea3e67c31/src%2Ftest%2Frustdoc-ui%2Flint-group.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b5f265eeed23ac87ec6b4a7e6bc7cb4ea3e67c31/src%2Ftest%2Frustdoc-ui%2Flint-group.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Flint-group.stderr?ref=b5f265eeed23ac87ec6b4a7e6bc7cb4ea3e67c31", "patch": "@@ -15,7 +15,7 @@ LL | #![deny(rustdoc)]\n    |         ^^^^^^^\n    = note: `#[deny(private_doc_tests)]` implied by `#[deny(rustdoc)]`\n \n-error: `[error]` cannot be resolved, ignoring it...\n+error: `[error]` cannot be resolved, ignoring it.\n   --> $DIR/lint-group.rs:9:29\n    |\n LL | /// what up, let's make an [error]"}, {"sha": "f554e16b4f475452b81396897b5ca6b48a44ec1e", "filename": "src/test/rustdoc/intra-links-anchors.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b5f265eeed23ac87ec6b4a7e6bc7cb4ea3e67c31/src%2Ftest%2Frustdoc%2Fintra-links-anchors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5f265eeed23ac87ec6b4a7e6bc7cb4ea3e67c31/src%2Ftest%2Frustdoc%2Fintra-links-anchors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fintra-links-anchors.rs?ref=b5f265eeed23ac87ec6b4a7e6bc7cb4ea3e67c31", "patch": "@@ -0,0 +1,12 @@\n+/// I want...\n+///\n+/// # Anchor!\n+pub struct Something;\n+\n+// @has intra_links_anchors/struct.SomeOtherType.html\n+// @has - '//a/@href' '../intra_links_anchors/struct.Something.html#Anchor!'\n+\n+/// I want...\n+///\n+/// To link to [Something#Anchor!]\n+pub struct SomeOtherType;"}]}