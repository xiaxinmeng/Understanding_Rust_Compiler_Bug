{"sha": "f93aaf84cb50dfaaba44b08c05bd51320263f592", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY5M2FhZjg0Y2I1MGRmYWFiYTQ0YjA4YzA1YmQ1MTMyMDI2M2Y1OTI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-07-09T22:16:21Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-07-09T22:16:21Z"}, "message": "Auto merge of #34365 - petrochenkov:deferr, r=eddyb\n\nSome more pattern cleanup and bugfixing\n\nThe next part of https://github.com/rust-lang/rust/pull/34095\n\nThe most significant fixed mistake is definitions for partially resolved associated types not being updated after full resolution.\n```\nfn f<T: Fn()>(arg: T::Output) { .... } // <- the definition of T::Output was not updated in def_map\n```\nFor this reason unstable associated types of stable traits, like `FnOnce::Output`, could be used in stable code when written in unqualified form. Now they are properly checked, this is a **[breaking-change]** (pretty minor one, but a crater run would be nice). The fix is not to use unstable library features in stable code, alternatively `FnOnce::Output` can be stabilized.\n\nBesides that, paths in struct patterns and expressions `S::A { .. }` are now fully resolved as associated types. Such types cannot be identified as structs at the moment, i.e. the change doesn't make previously invalid code valid, but it improves error diagnostics.\n\nOther changes: `Def::Err` is supported better (less chances for ICEs for erroneous code), some incorrect error messages are corrected, some duplicated error messages are not reported, ADT definitions are now available through constructor IDs, everything else is cleanup and code audit.\n\nFixes https://github.com/rust-lang/rust/issues/34209\nCloses https://github.com/rust-lang/rust/issues/22933 (adds tests)\n\nr? @eddyb", "tree": {"sha": "c3c591b8c329f811807e4d2f85d1155282679fd4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c3c591b8c329f811807e4d2f85d1155282679fd4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f93aaf84cb50dfaaba44b08c05bd51320263f592", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f93aaf84cb50dfaaba44b08c05bd51320263f592", "html_url": "https://github.com/rust-lang/rust/commit/f93aaf84cb50dfaaba44b08c05bd51320263f592", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f93aaf84cb50dfaaba44b08c05bd51320263f592/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d40c593f42fafbac1ff3d827f6df96338b5b7d8b", "url": "https://api.github.com/repos/rust-lang/rust/commits/d40c593f42fafbac1ff3d827f6df96338b5b7d8b", "html_url": "https://github.com/rust-lang/rust/commit/d40c593f42fafbac1ff3d827f6df96338b5b7d8b"}, {"sha": "d27e55c5d81eaee11ff2d414793cb7278d58d578", "url": "https://api.github.com/repos/rust-lang/rust/commits/d27e55c5d81eaee11ff2d414793cb7278d58d578", "html_url": "https://github.com/rust-lang/rust/commit/d27e55c5d81eaee11ff2d414793cb7278d58d578"}], "stats": {"total": 1464, "additions": 646, "deletions": 818}, "files": [{"sha": "9347ac2a8c82f0eb40d953f9318c39018ee72fa7", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f93aaf84cb50dfaaba44b08c05bd51320263f592/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f93aaf84cb50dfaaba44b08c05bd51320263f592/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=f93aaf84cb50dfaaba44b08c05bd51320263f592", "patch": "@@ -1929,7 +1929,7 @@ pub trait FnMut<Args> : FnOnce<Args> {\n #[fundamental] // so that regex can rely that `&str: !FnMut`\n pub trait FnOnce<Args> {\n     /// The returned type after the call operator is used.\n-    #[unstable(feature = \"fn_traits\", issue = \"29625\")]\n+    #[stable(feature = \"fn_once_output\", since = \"1.12.0\")]\n     type Output;\n \n     /// This is called when the call operator is used."}, {"sha": "601d3866b02d452be8808bcb3db6c936fa03d771", "filename": "src/librustc/cfg/construct.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f93aaf84cb50dfaaba44b08c05bd51320263f592/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f93aaf84cb50dfaaba44b08c05bd51320263f592/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fcfg%2Fconstruct.rs?ref=f93aaf84cb50dfaaba44b08c05bd51320263f592", "patch": "@@ -101,7 +101,6 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n         match pat.node {\n             PatKind::Binding(_, _, None) |\n             PatKind::Path(..) |\n-            PatKind::QPath(..) |\n             PatKind::Lit(..) |\n             PatKind::Range(..) |\n             PatKind::Wild => {"}, {"sha": "218681efb7dc167d033b1da220acc94b901bd215", "filename": "src/librustc/hir/def.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f93aaf84cb50dfaaba44b08c05bd51320263f592/src%2Flibrustc%2Fhir%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f93aaf84cb50dfaaba44b08c05bd51320263f592/src%2Flibrustc%2Fhir%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fdef.rs?ref=f93aaf84cb50dfaaba44b08c05bd51320263f592", "patch": "@@ -137,15 +137,6 @@ impl Def {\n         }\n     }\n \n-    pub fn variant_def_ids(&self) -> Option<(DefId, DefId)> {\n-        match *self {\n-            Def::Variant(enum_id, var_id) => {\n-                Some((enum_id, var_id))\n-            }\n-            _ => None\n-        }\n-    }\n-\n     pub fn kind_name(&self) -> &'static str {\n         match *self {\n             Def::Fn(..) => \"function\","}, {"sha": "5e0e6622185f8b50336cc4409b033a5be0f4793b", "filename": "src/librustc/hir/fold.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f93aaf84cb50dfaaba44b08c05bd51320263f592/src%2Flibrustc%2Fhir%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f93aaf84cb50dfaaba44b08c05bd51320263f592/src%2Flibrustc%2Fhir%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Ffold.rs?ref=f93aaf84cb50dfaaba44b08c05bd51320263f592", "patch": "@@ -930,12 +930,11 @@ pub fn noop_fold_pat<T: Folder>(p: P<Pat>, folder: &mut T) -> P<Pat> {\n                     PatKind::TupleStruct(folder.fold_path(pth),\n                             pats.move_map(|x| folder.fold_pat(x)), ddpos)\n                 }\n-                PatKind::Path(pth) => {\n-                    PatKind::Path(folder.fold_path(pth))\n-                }\n-                PatKind::QPath(qself, pth) => {\n-                    let qself = QSelf { ty: folder.fold_ty(qself.ty), ..qself };\n-                    PatKind::QPath(qself, folder.fold_path(pth))\n+                PatKind::Path(opt_qself, pth) => {\n+                    let opt_qself = opt_qself.map(|qself| {\n+                        QSelf { ty: folder.fold_ty(qself.ty), position: qself.position }\n+                    });\n+                    PatKind::Path(opt_qself, folder.fold_path(pth))\n                 }\n                 PatKind::Struct(pth, fields, etc) => {\n                     let pth = folder.fold_path(pth);"}, {"sha": "442c85af22a262967f707484de232e8b06c443ef", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f93aaf84cb50dfaaba44b08c05bd51320263f592/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f93aaf84cb50dfaaba44b08c05bd51320263f592/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=f93aaf84cb50dfaaba44b08c05bd51320263f592", "patch": "@@ -460,11 +460,10 @@ pub fn walk_pat<'v, V: Visitor<'v>>(visitor: &mut V, pattern: &'v Pat) {\n             visitor.visit_path(path, pattern.id);\n             walk_list!(visitor, visit_pat, children);\n         }\n-        PatKind::Path(ref path) => {\n-            visitor.visit_path(path, pattern.id);\n-        }\n-        PatKind::QPath(ref qself, ref path) => {\n-            visitor.visit_ty(&qself.ty);\n+        PatKind::Path(ref opt_qself, ref path) => {\n+            if let Some(ref qself) = *opt_qself {\n+                visitor.visit_ty(&qself.ty);\n+            }\n             visitor.visit_path(path, pattern.id)\n         }\n         PatKind::Struct(ref path, ref fields, _) => {"}, {"sha": "9d124dadb766adb911324f8a5cdc78f1eed57e38", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/f93aaf84cb50dfaaba44b08c05bd51320263f592/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f93aaf84cb50dfaaba44b08c05bd51320263f592/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=f93aaf84cb50dfaaba44b08c05bd51320263f592", "patch": "@@ -862,7 +862,8 @@ impl<'a> LoweringContext<'a> {\n                                                       respan(pth1.span, pth1.node.name),\n                                                       sub.as_ref().map(|x| this.lower_pat(x)))\n                             }\n-                            _ => hir::PatKind::Path(hir::Path::from_name(pth1.span, pth1.node.name))\n+                            _ => hir::PatKind::Path(None, hir::Path::from_name(pth1.span,\n+                                                                               pth1.node.name))\n                         }\n                     })\n                 }\n@@ -872,15 +873,11 @@ impl<'a> LoweringContext<'a> {\n                                               pats.iter().map(|x| self.lower_pat(x)).collect(),\n                                               ddpos)\n                 }\n-                PatKind::Path(None, ref pth) => {\n-                    hir::PatKind::Path(self.lower_path(pth))\n-                }\n-                PatKind::Path(Some(ref qself), ref pth) => {\n-                    let qself = hir::QSelf {\n-                        ty: self.lower_ty(&qself.ty),\n-                        position: qself.position,\n-                    };\n-                    hir::PatKind::QPath(qself, self.lower_path(pth))\n+                PatKind::Path(ref opt_qself, ref path) => {\n+                    let opt_qself = opt_qself.as_ref().map(|qself| {\n+                        hir::QSelf { ty: self.lower_ty(&qself.ty), position: qself.position }\n+                    });\n+                    hir::PatKind::Path(opt_qself, self.lower_path(path))\n                 }\n                 PatKind::Struct(ref pth, ref fields, etc) => {\n                     let pth = self.lower_path(pth);\n@@ -1831,7 +1828,7 @@ impl<'a> LoweringContext<'a> {\n                 -> P<hir::Pat> {\n         let def = self.resolver.resolve_generated_global_path(&path, true);\n         let pt = if subpats.is_empty() {\n-            hir::PatKind::Path(path)\n+            hir::PatKind::Path(None, path)\n         } else {\n             hir::PatKind::TupleStruct(path, subpats, None)\n         };"}, {"sha": "655f80ec07238ff9ba97fdb99057415fd6dec35b", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f93aaf84cb50dfaaba44b08c05bd51320263f592/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f93aaf84cb50dfaaba44b08c05bd51320263f592/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=f93aaf84cb50dfaaba44b08c05bd51320263f592", "patch": "@@ -487,8 +487,7 @@ impl Pat {\n             PatKind::Lit(_) |\n             PatKind::Range(_, _) |\n             PatKind::Binding(..) |\n-            PatKind::Path(..) |\n-            PatKind::QPath(_, _) => {\n+            PatKind::Path(..) => {\n                 true\n             }\n         }\n@@ -538,15 +537,9 @@ pub enum PatKind {\n     /// 0 <= position <= subpats.len()\n     TupleStruct(Path, HirVec<P<Pat>>, Option<usize>),\n \n-    /// A path pattern.\n+    /// A possibly qualified path pattern.\n     /// Such pattern can be resolved to a unit struct/variant or a constant.\n-    Path(Path),\n-\n-    /// An associated const named using the qualified path `<T>::CONST` or\n-    /// `<T as Trait>::CONST`. Associated consts from inherent impls can be\n-    /// referred to as simply `T::CONST`, in which case they will end up as\n-    /// PatKind::Path, and the resolver will have to sort that out.\n-    QPath(QSelf, Path),\n+    Path(Option<QSelf>, Path),\n \n     /// A tuple pattern `(a, b)`.\n     /// If the `..` pattern fragment is present, then `Option<usize>` denotes its position."}, {"sha": "593d10ef4f7c4a9910c020b9a4218dc5f345fbba", "filename": "src/librustc/hir/pat_util.rs", "status": "modified", "additions": 2, "deletions": 35, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/f93aaf84cb50dfaaba44b08c05bd51320263f592/src%2Flibrustc%2Fhir%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f93aaf84cb50dfaaba44b08c05bd51320263f592/src%2Flibrustc%2Fhir%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fpat_util.rs?ref=f93aaf84cb50dfaaba44b08c05bd51320263f592", "patch": "@@ -12,15 +12,12 @@ use hir::def::*;\n use hir::def_id::DefId;\n use hir::{self, PatKind};\n use ty::TyCtxt;\n-use util::nodemap::FnvHashMap;\n use syntax::ast;\n use syntax::codemap::Spanned;\n use syntax_pos::{Span, DUMMY_SP};\n \n use std::iter::{Enumerate, ExactSizeIterator};\n \n-pub type PatIdMap = FnvHashMap<ast::Name, ast::NodeId>;\n-\n pub struct EnumerateAndAdjust<I> {\n     enumerate: Enumerate<I>,\n     gap_pos: usize,\n@@ -56,7 +53,7 @@ impl<T: ExactSizeIterator> EnumerateAndAdjustIterator for T {\n \n pub fn pat_is_refutable(dm: &DefMap, pat: &hir::Pat) -> bool {\n     match pat.node {\n-        PatKind::Lit(_) | PatKind::Range(_, _) | PatKind::QPath(..) => true,\n+        PatKind::Lit(_) | PatKind::Range(_, _) | PatKind::Path(Some(..), _) => true,\n         PatKind::TupleStruct(..) |\n         PatKind::Path(..) |\n         PatKind::Struct(..) => {\n@@ -70,23 +67,9 @@ pub fn pat_is_refutable(dm: &DefMap, pat: &hir::Pat) -> bool {\n     }\n }\n \n-pub fn pat_is_variant_or_struct(dm: &DefMap, pat: &hir::Pat) -> bool {\n-    match pat.node {\n-        PatKind::TupleStruct(..) |\n-        PatKind::Path(..) |\n-        PatKind::Struct(..) => {\n-            match dm.get(&pat.id).map(|d| d.full_def()) {\n-                Some(Def::Variant(..)) | Some(Def::Struct(..)) | Some(Def::TyAlias(..)) => true,\n-                _ => false\n-            }\n-        }\n-        _ => false\n-    }\n-}\n-\n pub fn pat_is_const(dm: &DefMap, pat: &hir::Pat) -> bool {\n     match pat.node {\n-        PatKind::Path(..) | PatKind::QPath(..) => {\n+        PatKind::Path(..) => {\n             match dm.get(&pat.id).map(|d| d.full_def()) {\n                 Some(Def::Const(..)) | Some(Def::AssociatedConst(..)) => true,\n                 _ => false\n@@ -96,22 +79,6 @@ pub fn pat_is_const(dm: &DefMap, pat: &hir::Pat) -> bool {\n     }\n }\n \n-// Same as above, except that partially-resolved defs cause `false` to be\n-// returned instead of a panic.\n-pub fn pat_is_resolved_const(dm: &DefMap, pat: &hir::Pat) -> bool {\n-    match pat.node {\n-        PatKind::Path(..) | PatKind::QPath(..) => {\n-            match dm.get(&pat.id)\n-                    .and_then(|d| if d.depth == 0 { Some(d.base_def) }\n-                                  else { None } ) {\n-                Some(Def::Const(..)) | Some(Def::AssociatedConst(..)) => true,\n-                _ => false\n-            }\n-        }\n-        _ => false\n-    }\n-}\n-\n /// Call `f` on every \"binding\" in a pattern, e.g., on `a` in\n /// `match foo() { Some(a) => (), None => () }`\n pub fn pat_bindings<F>(pat: &hir::Pat, mut f: F)"}, {"sha": "5f2fac5c01b30df8b719ef301e13cafde1a1cbbd", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f93aaf84cb50dfaaba44b08c05bd51320263f592/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f93aaf84cb50dfaaba44b08c05bd51320263f592/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=f93aaf84cb50dfaaba44b08c05bd51320263f592", "patch": "@@ -1750,10 +1750,10 @@ impl<'a> State<'a> {\n                 }\n                 try!(self.pclose());\n             }\n-            PatKind::Path(ref path) => {\n+            PatKind::Path(None, ref path) => {\n                 self.print_path(path, true, 0)?;\n             }\n-            PatKind::QPath(ref qself, ref path) => {\n+            PatKind::Path(Some(ref qself), ref path) => {\n                 self.print_qpath(path, qself, false)?;\n             }\n             PatKind::Struct(ref path, ref fields, etc) => {"}, {"sha": "6551e0129f88493dacffff9044ca34b10ea112db", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 39, "deletions": 99, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/f93aaf84cb50dfaaba44b08c05bd51320263f592/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f93aaf84cb50dfaaba44b08c05bd51320263f592/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=f93aaf84cb50dfaaba44b08c05bd51320263f592", "patch": "@@ -945,52 +945,41 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n     /// The core driver for walking a pattern; `match_mode` must be\n     /// established up front, e.g. via `determine_pat_move_mode` (see\n     /// also `walk_irrefutable_pat` for patterns that stand alone).\n-    fn walk_pat(&mut self,\n-                cmt_discr: mc::cmt<'tcx>,\n-                pat: &hir::Pat,\n-                match_mode: MatchMode) {\n-        debug!(\"walk_pat cmt_discr={:?} pat={:?}\", cmt_discr,\n-               pat);\n+    fn walk_pat(&mut self, cmt_discr: mc::cmt<'tcx>, pat: &hir::Pat, match_mode: MatchMode) {\n+        debug!(\"walk_pat cmt_discr={:?} pat={:?}\", cmt_discr, pat);\n \n         let tcx = &self.tcx();\n         let mc = &self.mc;\n         let infcx = self.mc.infcx;\n         let delegate = &mut self.delegate;\n         return_if_err!(mc.cat_pattern(cmt_discr.clone(), pat, |mc, cmt_pat, pat| {\n-            match pat.node {\n-                PatKind::Binding(bmode, _, _) => {\n-                    debug!(\"binding cmt_pat={:?} pat={:?} match_mode={:?}\",\n-                           cmt_pat,\n-                           pat,\n-                           match_mode);\n-\n-                    // pat_ty: the type of the binding being produced.\n-                    let pat_ty = return_if_err!(infcx.node_ty(pat.id));\n-\n-                    // Each match binding is effectively an assignment to the\n-                    // binding being produced.\n-                    if let Ok(binding_cmt) = mc.cat_def(pat.id, pat.span, pat_ty,\n-                                                        tcx.expect_def(pat.id)) {\n-                        delegate.mutate(pat.id, pat.span, binding_cmt, MutateMode::Init);\n-                    }\n+            if let PatKind::Binding(bmode, _, _) = pat.node {\n+                debug!(\"binding cmt_pat={:?} pat={:?} match_mode={:?}\", cmt_pat, pat, match_mode);\n \n-                    // It is also a borrow or copy/move of the value being matched.\n-                    match bmode {\n-                        hir::BindByRef(m) => {\n-                            if let ty::TyRef(&r, _) = pat_ty.sty {\n-                                let bk = ty::BorrowKind::from_mutbl(m);\n-                                delegate.borrow(pat.id, pat.span, cmt_pat,\n-                                                r, bk, RefBinding);\n-                            }\n-                        }\n-                        hir::BindByValue(..) => {\n-                            let mode = copy_or_move(infcx, &cmt_pat, PatBindingMove);\n-                            debug!(\"walk_pat binding consuming pat\");\n-                            delegate.consume_pat(pat, cmt_pat, mode);\n+                // pat_ty: the type of the binding being produced.\n+                let pat_ty = return_if_err!(infcx.node_ty(pat.id));\n+\n+                // Each match binding is effectively an assignment to the\n+                // binding being produced.\n+                if let Ok(binding_cmt) = mc.cat_def(pat.id, pat.span, pat_ty,\n+                                                    tcx.expect_def(pat.id)) {\n+                    delegate.mutate(pat.id, pat.span, binding_cmt, MutateMode::Init);\n+                }\n+\n+                // It is also a borrow or copy/move of the value being matched.\n+                match bmode {\n+                    hir::BindByRef(m) => {\n+                        if let ty::TyRef(&r, _) = pat_ty.sty {\n+                            let bk = ty::BorrowKind::from_mutbl(m);\n+                            delegate.borrow(pat.id, pat.span, cmt_pat, r, bk, RefBinding);\n                         }\n                     }\n+                    hir::BindByValue(..) => {\n+                        let mode = copy_or_move(infcx, &cmt_pat, PatBindingMove);\n+                        debug!(\"walk_pat binding consuming pat\");\n+                        delegate.consume_pat(pat, cmt_pat, mode);\n+                    }\n                 }\n-                _ => {}\n             }\n         }));\n \n@@ -999,72 +988,23 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n         // to the above loop's visit of than the bindings that form\n         // the leaves of the pattern tree structure.\n         return_if_err!(mc.cat_pattern(cmt_discr, pat, |mc, cmt_pat, pat| {\n-            match pat.node {\n-                PatKind::Struct(..) | PatKind::TupleStruct(..) |\n-                PatKind::Path(..) | PatKind::QPath(..) => {\n-                    match tcx.expect_def(pat.id) {\n-                        Def::Variant(enum_did, variant_did) => {\n-                            let downcast_cmt =\n-                                if tcx.lookup_adt_def(enum_did).is_univariant() {\n-                                    cmt_pat\n-                                } else {\n-                                    let cmt_pat_ty = cmt_pat.ty;\n-                                    mc.cat_downcast(pat, cmt_pat, cmt_pat_ty, variant_did)\n-                                };\n-\n-                            debug!(\"variant downcast_cmt={:?} pat={:?}\",\n-                                   downcast_cmt,\n-                                   pat);\n-\n-                            delegate.matched_pat(pat, downcast_cmt, match_mode);\n-                        }\n-\n-                        Def::Struct(..) | Def::TyAlias(..) => {\n-                            // A struct (in either the value or type\n-                            // namespace; we encounter the former on\n-                            // e.g. patterns for unit structs).\n-\n-                            debug!(\"struct cmt_pat={:?} pat={:?}\",\n-                                   cmt_pat,\n-                                   pat);\n-\n-                            delegate.matched_pat(pat, cmt_pat, match_mode);\n-                        }\n-\n-                        Def::Const(..) | Def::AssociatedConst(..) => {\n-                            // This is a leaf (i.e. identifier binding\n-                            // or constant value to match); thus no\n-                            // `matched_pat` call.\n-                        }\n+            match tcx.expect_def_or_none(pat.id) {\n+                Some(Def::Variant(enum_did, variant_did)) => {\n+                    let downcast_cmt = if tcx.lookup_adt_def(enum_did).is_univariant() {\n+                        cmt_pat\n+                    } else {\n+                        let cmt_pat_ty = cmt_pat.ty;\n+                        mc.cat_downcast(pat, cmt_pat, cmt_pat_ty, variant_did)\n+                    };\n \n-                        def => {\n-                            // An enum type should never be in a pattern.\n-                            // Remaining cases are e.g. Def::Fn, to\n-                            // which identifiers within patterns\n-                            // should not resolve. However, we do\n-                            // encouter this when using the\n-                            // expr-use-visitor during typeck. So just\n-                            // ignore it, an error should have been\n-                            // reported.\n-\n-                            if !tcx.sess.has_errors() {\n-                                span_bug!(pat.span,\n-                                          \"Pattern has unexpected def: {:?} and type {:?}\",\n-                                          def,\n-                                          cmt_pat.ty);\n-                            }\n-                        }\n-                    }\n+                    debug!(\"variant downcast_cmt={:?} pat={:?}\", downcast_cmt, pat);\n+                    delegate.matched_pat(pat, downcast_cmt, match_mode);\n                 }\n-\n-                PatKind::Wild | PatKind::Tuple(..) | PatKind::Box(..) |\n-                PatKind::Ref(..) | PatKind::Lit(..) | PatKind::Range(..) |\n-                PatKind::Vec(..) | PatKind::Binding(..) => {\n-                    // Each of these cases does not\n-                    // correspond to an enum variant or struct, so we\n-                    // do not do any `matched_pat` calls for these\n-                    // cases either.\n+                Some(Def::Struct(..)) | Some(Def::TyAlias(..)) | Some(Def::AssociatedTy(..)) => {\n+                    debug!(\"struct cmt_pat={:?} pat={:?}\", cmt_pat, pat);\n+                    delegate.matched_pat(pat, cmt_pat, match_mode);\n                 }\n+                _ => {}\n             }\n         }));\n     }"}, {"sha": "28bfb460a14faf75c9fdbbe10fb5a195cfc3e600", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 43, "deletions": 81, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/f93aaf84cb50dfaaba44b08c05bd51320263f592/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f93aaf84cb50dfaaba44b08c05bd51320263f592/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=f93aaf84cb50dfaaba44b08c05bd51320263f592", "patch": "@@ -1050,9 +1050,8 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n     }\n \n     // FIXME(#19596) This is a workaround, but there should be a better way to do this\n-    fn cat_pattern_<F>(&self, cmt: cmt<'tcx>, pat: &hir::Pat, op: &mut F)\n-                       -> McResult<()>\n-        where F : FnMut(&MemCategorizationContext<'a, 'gcx, 'tcx>, cmt<'tcx>, &hir::Pat),\n+    fn cat_pattern_<F>(&self, cmt: cmt<'tcx>, pat: &hir::Pat, op: &mut F) -> McResult<()>\n+        where F : FnMut(&MemCategorizationContext<'a, 'gcx, 'tcx>, cmt<'tcx>, &hir::Pat)\n     {\n         // Here, `cmt` is the categorization for the value being\n         // matched and pat is the pattern it is being matched against.\n@@ -1099,21 +1098,14 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n         // step out of sync again. So you'll see below that we always\n         // get the type of the *subpattern* and use that.\n \n-        debug!(\"cat_pattern: {:?} cmt={:?}\",\n-               pat,\n-               cmt);\n-\n-        (*op)(self, cmt.clone(), pat);\n+        debug!(\"cat_pattern: {:?} cmt={:?}\", pat, cmt);\n \n-        let opt_def = self.tcx().expect_def_or_none(pat.id);\n-        if opt_def == Some(Def::Err) {\n-            return Err(());\n-        }\n+        op(self, cmt.clone(), pat);\n \n         // Note: This goes up here (rather than within the PatKind::TupleStruct arm\n-        // alone) because struct patterns can refer to struct types or\n-        // to struct variants within enums.\n-        let cmt = match opt_def {\n+        // alone) because PatKind::Struct can also refer to variants.\n+        let cmt = match self.tcx().expect_def_or_none(pat.id) {\n+            Some(Def::Err) => return Err(()),\n             Some(Def::Variant(enum_did, variant_did))\n                 // univariant enums do not need downcasts\n                 if !self.tcx().lookup_adt_def(enum_did).is_univariant() => {\n@@ -1123,66 +1115,33 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n         };\n \n         match pat.node {\n-          PatKind::Wild => {\n-            // _\n-          }\n-\n           PatKind::TupleStruct(_, ref subpats, ddpos) => {\n-            match opt_def {\n-                Some(Def::Variant(enum_def, def_id)) => {\n-                    // variant(x, y, z)\n-                    let expected_len = self.tcx().lookup_adt_def(enum_def)\n-                                                 .variant_with_id(def_id).fields.len();\n-                    for (i, subpat) in subpats.iter().enumerate_and_adjust(expected_len, ddpos) {\n-                        let subpat_ty = self.pat_ty(&subpat)?; // see (*2)\n-\n-                        let subcmt =\n-                            self.cat_imm_interior(\n-                                pat, cmt.clone(), subpat_ty,\n-                                InteriorField(PositionalField(i)));\n-\n-                        self.cat_pattern_(subcmt, &subpat, op)?;\n-                    }\n+            let expected_len = match self.tcx().expect_def(pat.id) {\n+                Def::Variant(enum_def, def_id) => {\n+                    self.tcx().lookup_adt_def(enum_def).variant_with_id(def_id).fields.len()\n                 }\n-                Some(Def::Struct(..)) => {\n-                    let expected_len = match self.pat_ty(&pat)?.sty {\n+                Def::Struct(..) => {\n+                    match self.pat_ty(&pat)?.sty {\n                         ty::TyStruct(adt_def, _) => {\n                             adt_def.struct_variant().fields.len()\n                         }\n                         ref ty => {\n                             span_bug!(pat.span, \"tuple struct pattern unexpected type {:?}\", ty);\n                         }\n-                    };\n-\n-                    for (i, subpat) in subpats.iter().enumerate_and_adjust(expected_len, ddpos) {\n-                        let subpat_ty = self.pat_ty(&subpat)?; // see (*2)\n-                        let cmt_field =\n-                            self.cat_imm_interior(\n-                                pat, cmt.clone(), subpat_ty,\n-                                InteriorField(PositionalField(i)));\n-                        self.cat_pattern_(cmt_field, &subpat, op)?;\n                     }\n                 }\n-                Some(Def::Const(..)) | Some(Def::AssociatedConst(..)) => {\n-                    for subpat in subpats {\n-                        self.cat_pattern_(cmt.clone(), &subpat, op)?;\n-                    }\n-                }\n-                _ => {\n-                    span_bug!(\n-                        pat.span,\n-                        \"enum pattern didn't resolve to enum or struct {:?}\",\n-                        opt_def);\n+                def => {\n+                    span_bug!(pat.span, \"tuple struct pattern didn't resolve \\\n+                                         to variant or struct {:?}\", def);\n                 }\n-            }\n-          }\n-\n-          PatKind::Path(..) | PatKind::QPath(..) | PatKind::Binding(_, _, None) => {\n-              // Lone constant, or unit variant or identifier: ignore\n-          }\n+            };\n \n-          PatKind::Binding(_, _, Some(ref subpat)) => {\n-              self.cat_pattern_(cmt, &subpat, op)?;\n+            for (i, subpat) in subpats.iter().enumerate_and_adjust(expected_len, ddpos) {\n+                let subpat_ty = self.pat_ty(&subpat)?; // see (*2)\n+                let subcmt = self.cat_imm_interior(pat, cmt.clone(), subpat_ty,\n+                                                   InteriorField(PositionalField(i)));\n+                self.cat_pattern_(subcmt, &subpat, op)?;\n+            }\n           }\n \n           PatKind::Struct(_, ref field_pats, _) => {\n@@ -1194,6 +1153,10 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n             }\n           }\n \n+          PatKind::Binding(_, _, Some(ref subpat)) => {\n+              self.cat_pattern_(cmt, &subpat, op)?;\n+          }\n+\n           PatKind::Tuple(ref subpats, ddpos) => {\n             // (p1, ..., pN)\n             let expected_len = match self.pat_ty(&pat)?.sty {\n@@ -1202,10 +1165,8 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n             };\n             for (i, subpat) in subpats.iter().enumerate_and_adjust(expected_len, ddpos) {\n                 let subpat_ty = self.pat_ty(&subpat)?; // see (*2)\n-                let subcmt =\n-                    self.cat_imm_interior(\n-                        pat, cmt.clone(), subpat_ty,\n-                        InteriorField(PositionalField(i)));\n+                let subcmt = self.cat_imm_interior(pat, cmt.clone(), subpat_ty,\n+                                                   InteriorField(PositionalField(i)));\n                 self.cat_pattern_(subcmt, &subpat, op)?;\n             }\n           }\n@@ -1215,25 +1176,26 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n             // PatKind::Ref since that information is already contained\n             // in the type.\n             let subcmt = self.cat_deref(pat, cmt, 0, None)?;\n-              self.cat_pattern_(subcmt, &subpat, op)?;\n+            self.cat_pattern_(subcmt, &subpat, op)?;\n           }\n \n           PatKind::Vec(ref before, ref slice, ref after) => {\n-              let context = InteriorOffsetKind::Pattern;\n-              let elt_cmt = self.cat_index(pat, cmt, context)?;\n-              for before_pat in before {\n-                  self.cat_pattern_(elt_cmt.clone(), &before_pat, op)?;\n-              }\n-              if let Some(ref slice_pat) = *slice {\n-                  self.cat_pattern_(elt_cmt.clone(), &slice_pat, op)?;\n-              }\n-              for after_pat in after {\n-                  self.cat_pattern_(elt_cmt.clone(), &after_pat, op)?;\n-              }\n+            let context = InteriorOffsetKind::Pattern;\n+            let elt_cmt = self.cat_index(pat, cmt, context)?;\n+            for before_pat in before {\n+                self.cat_pattern_(elt_cmt.clone(), &before_pat, op)?;\n+            }\n+            if let Some(ref slice_pat) = *slice {\n+                self.cat_pattern_(elt_cmt.clone(), &slice_pat, op)?;\n+            }\n+            for after_pat in after {\n+                self.cat_pattern_(elt_cmt.clone(), &after_pat, op)?;\n+            }\n           }\n \n-          PatKind::Lit(_) | PatKind::Range(_, _) => {\n-              /*always ok*/\n+          PatKind::Path(..) | PatKind::Binding(_, _, None) |\n+          PatKind::Lit(..) | PatKind::Range(..) | PatKind::Wild => {\n+            // always ok\n           }\n         }\n "}, {"sha": "93507246241de62bde905a68e9fde7acc47e7c47", "filename": "src/librustc/mir/repr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f93aaf84cb50dfaaba44b08c05bd51320263f592/src%2Flibrustc%2Fmir%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f93aaf84cb50dfaaba44b08c05bd51320263f592/src%2Flibrustc%2Fmir%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Frepr.rs?ref=f93aaf84cb50dfaaba44b08c05bd51320263f592", "patch": "@@ -1063,7 +1063,7 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n                             Some(tcx.lookup_item_type(variant_def.did).generics)\n                         })?;\n \n-                        match variant_def.kind() {\n+                        match variant_def.kind {\n                             ty::VariantKind::Unit => Ok(()),\n                             ty::VariantKind::Tuple => fmt_tuple(fmt, lvs),\n                             ty::VariantKind::Struct => {"}, {"sha": "4c8fa80dd0b9669acff4ea2d9c13422681943b10", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f93aaf84cb50dfaaba44b08c05bd51320263f592/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f93aaf84cb50dfaaba44b08c05bd51320263f592/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=f93aaf84cb50dfaaba44b08c05bd51320263f592", "patch": "@@ -591,17 +591,21 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self.global_interners.arenas.trait_defs.alloc(def)\n     }\n \n+    pub fn insert_adt_def(self, did: DefId, adt_def: ty::AdtDefMaster<'gcx>) {\n+        // this will need a transmute when reverse-variance is removed\n+        if let Some(prev) = self.adt_defs.borrow_mut().insert(did, adt_def) {\n+            bug!(\"Tried to overwrite interned AdtDef: {:?}\", prev)\n+        }\n+    }\n+\n     pub fn intern_adt_def(self,\n                           did: DefId,\n                           kind: ty::AdtKind,\n                           variants: Vec<ty::VariantDefData<'gcx, 'gcx>>)\n                           -> ty::AdtDefMaster<'gcx> {\n         let def = ty::AdtDefData::new(self, did, kind, variants);\n         let interned = self.global_interners.arenas.adt_defs.alloc(def);\n-        // this will need a transmute when reverse-variance is removed\n-        if let Some(prev) = self.adt_defs.borrow_mut().insert(did, interned) {\n-            bug!(\"Tried to overwrite interned AdtDef: {:?}\", prev)\n-        }\n+        self.insert_adt_def(did, interned);\n         interned\n     }\n "}, {"sha": "03e893727d1b58c7d88142ee72bb336dfe509cfd", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/f93aaf84cb50dfaaba44b08c05bd51320263f592/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f93aaf84cb50dfaaba44b08c05bd51320263f592/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=f93aaf84cb50dfaaba44b08c05bd51320263f592", "patch": "@@ -1715,7 +1715,7 @@ impl<'a, 'gcx, 'tcx, 'container> AdtDefData<'gcx, 'container> {\n     pub fn variant_of_def(&self, def: Def) -> &VariantDefData<'gcx, 'container> {\n         match def {\n             Def::Variant(_, vid) => self.variant_with_id(vid),\n-            Def::Struct(..) | Def::TyAlias(..) => self.struct_variant(),\n+            Def::Struct(..) | Def::TyAlias(..) | Def::AssociatedTy(..) => self.struct_variant(),\n             _ => bug!(\"unexpected def {:?} in variant_of_def\", def)\n         }\n     }\n@@ -1925,14 +1925,6 @@ impl<'tcx, 'container> VariantDefData<'tcx, 'container> {\n         self.fields.iter()\n     }\n \n-    pub fn kind(&self) -> VariantKind {\n-        self.kind\n-    }\n-\n-    pub fn is_tuple_struct(&self) -> bool {\n-        self.kind() == VariantKind::Tuple\n-    }\n-\n     #[inline]\n     pub fn find_field_named(&self,\n                             name: ast::Name)\n@@ -2454,6 +2446,20 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self.def_map.borrow().get(&id).map(|resolution| resolution.full_def())\n     }\n \n+    // Returns `ty::VariantDef` if `def` refers to a struct,\n+    // or variant or their constructors, panics otherwise.\n+    pub fn expect_variant_def(self, def: Def) -> VariantDef<'tcx> {\n+        match def {\n+            Def::Variant(enum_did, did) => {\n+                self.lookup_adt_def(enum_did).variant_with_id(did)\n+            }\n+            Def::Struct(did) => {\n+                self.lookup_adt_def(did).struct_variant()\n+            }\n+            _ => bug!(\"expect_variant_def used with unexpected def {:?}\", def)\n+        }\n+    }\n+\n     pub fn def_key(self, id: DefId) -> ast_map::DefKey {\n         if id.is_local() {\n             self.map.def_key(id)"}, {"sha": "866a91b4d95100d81bbee6b850795114db49d77d", "filename": "src/librustc_const_eval/check_match.rs", "status": "modified", "additions": 10, "deletions": 18, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/f93aaf84cb50dfaaba44b08c05bd51320263f592/src%2Flibrustc_const_eval%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f93aaf84cb50dfaaba44b08c05bd51320263f592/src%2Flibrustc_const_eval%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fcheck_match.rs?ref=f93aaf84cb50dfaaba44b08c05bd51320263f592", "patch": "@@ -246,9 +246,9 @@ fn check_for_bindings_named_the_same_as_variants(cx: &MatchCheckCtxt, pat: &Pat)\n             let pat_ty = cx.tcx.pat_ty(p);\n             if let ty::TyEnum(edef, _) = pat_ty.sty {\n                 if let Def::Local(..) = cx.tcx.expect_def(p.id) {\n-                    if edef.variants.iter().any(|variant|\n-                        variant.name == name.node && variant.kind() == VariantKind::Unit\n-                    ) {\n+                    if edef.variants.iter().any(|variant| {\n+                        variant.name == name.node && variant.kind == VariantKind::Unit\n+                    }) {\n                         let ty_path = cx.tcx.item_path_str(edef.did);\n                         let mut err = struct_span_warn!(cx.tcx.sess, p.span, E0170,\n                             \"pattern binding `{}` is named the same as one \\\n@@ -489,7 +489,7 @@ impl<'map> IdVisitingOperation for RenamingRecorder<'map> {\n impl<'a, 'tcx> Folder for StaticInliner<'a, 'tcx> {\n     fn fold_pat(&mut self, pat: P<Pat>) -> P<Pat> {\n         return match pat.node {\n-            PatKind::Path(..) | PatKind::QPath(..) => {\n+            PatKind::Path(..) => {\n                 match self.tcx.expect_def(pat.id) {\n                     Def::AssociatedConst(did) | Def::Const(did) => {\n                         let substs = Some(self.tcx.node_id_item_substs(pat.id).substs);\n@@ -563,7 +563,7 @@ fn construct_witness<'a,'tcx>(cx: &MatchCheckCtxt<'a,'tcx>, ctor: &Constructor,\n \n         ty::TyEnum(adt, _) | ty::TyStruct(adt, _)  => {\n             let v = ctor.variant_for_adt(adt);\n-            match v.kind() {\n+            match v.kind {\n                 VariantKind::Struct => {\n                     let field_pats: hir::HirVec<_> = v.fields.iter()\n                         .zip(pats)\n@@ -583,7 +583,7 @@ fn construct_witness<'a,'tcx>(cx: &MatchCheckCtxt<'a,'tcx>, ctor: &Constructor,\n                     PatKind::TupleStruct(def_to_path(cx.tcx, v.did), pats.collect(), None)\n                 }\n                 VariantKind::Unit => {\n-                    PatKind::Path(def_to_path(cx.tcx, v.did))\n+                    PatKind::Path(None, def_to_path(cx.tcx, v.did))\n                 }\n             }\n         }\n@@ -786,16 +786,12 @@ fn pat_constructors(cx: &MatchCheckCtxt, p: &Pat,\n     match pat.node {\n         PatKind::Struct(..) | PatKind::TupleStruct(..) | PatKind::Path(..) =>\n             match cx.tcx.expect_def(pat.id) {\n-                Def::Const(..) | Def::AssociatedConst(..) =>\n-                    span_bug!(pat.span, \"const pattern should've \\\n-                                         been rewritten\"),\n-                Def::Struct(..) | Def::TyAlias(..) => vec![Single],\n                 Def::Variant(_, id) => vec![Variant(id)],\n-                def => span_bug!(pat.span, \"pat_constructors: unexpected \\\n-                                            definition {:?}\", def),\n+                Def::Struct(..) | Def::TyAlias(..) | Def::AssociatedTy(..) => vec![Single],\n+                Def::Const(..) | Def::AssociatedConst(..) =>\n+                    span_bug!(pat.span, \"const pattern should've been rewritten\"),\n+                def => span_bug!(pat.span, \"pat_constructors: unexpected definition {:?}\", def),\n             },\n-        PatKind::QPath(..) =>\n-            span_bug!(pat.span, \"const pattern should've been rewritten\"),\n         PatKind::Lit(ref expr) =>\n             vec![ConstantValue(eval_const_expr(cx.tcx, &expr))],\n         PatKind::Range(ref lo, ref hi) =>\n@@ -934,10 +930,6 @@ pub fn specialize<'a, 'b, 'tcx>(\n             }\n         }\n \n-        PatKind::QPath(_, _) => {\n-            span_bug!(pat_span, \"const pattern should've been rewritten\")\n-        }\n-\n         PatKind::Struct(_, ref pattern_fields, _) => {\n             let adt = cx.tcx.node_id_to_type(pat_id).ty_adt_def().unwrap();\n             let variant = constructor.variant_for_adt(adt);"}, {"sha": "a3c707e82a0ff45e45be5c74e951c184296f8cb5", "filename": "src/librustc_const_eval/eval.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f93aaf84cb50dfaaba44b08c05bd51320263f592/src%2Flibrustc_const_eval%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f93aaf84cb50dfaaba44b08c05bd51320263f592/src%2Flibrustc_const_eval%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Feval.rs?ref=f93aaf84cb50dfaaba44b08c05bd51320263f592", "patch": "@@ -323,7 +323,7 @@ pub fn const_expr_to_pat<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n         hir::ExprPath(_, ref path) => {\n             match tcx.expect_def(expr.id) {\n-                Def::Struct(..) | Def::Variant(..) => PatKind::Path(path.clone()),\n+                Def::Struct(..) | Def::Variant(..) => PatKind::Path(None, path.clone()),\n                 Def::Const(def_id) | Def::AssociatedConst(def_id) => {\n                     let substs = Some(tcx.node_id_item_substs(expr.id).substs);\n                     let (expr, _ty) = lookup_const_by_id(tcx, def_id, substs).unwrap();"}, {"sha": "15914838acf0db85289b97ececd3fa5c90696a4b", "filename": "src/librustc_lint/bad_style.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f93aaf84cb50dfaaba44b08c05bd51320263f592/src%2Flibrustc_lint%2Fbad_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f93aaf84cb50dfaaba44b08c05bd51320263f592/src%2Flibrustc_lint%2Fbad_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbad_style.rs?ref=f93aaf84cb50dfaaba44b08c05bd51320263f592", "patch": "@@ -360,7 +360,7 @@ impl LateLintPass for NonUpperCaseGlobals {\n \n     fn check_pat(&mut self, cx: &LateContext, p: &hir::Pat) {\n         // Lint for constants that look like binding identifiers (#7526)\n-        if let PatKind::Path(ref path) = p.node {\n+        if let PatKind::Path(None, ref path) = p.node {\n             if !path.global && path.segments.len() == 1 && path.segments[0].parameters.is_empty() {\n                 if let Def::Const(..) = cx.tcx.expect_def(p.id) {\n                     NonUpperCaseGlobals::check_upper_case(cx, \"constant in pattern\","}, {"sha": "6d3699e978794f8e3bd4ddb078382d2135e177c4", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f93aaf84cb50dfaaba44b08c05bd51320263f592/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f93aaf84cb50dfaaba44b08c05bd51320263f592/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=f93aaf84cb50dfaaba44b08c05bd51320263f592", "patch": "@@ -471,28 +471,34 @@ pub fn get_adt_def<'a, 'tcx>(intr: &IdentInterner,\n \n     let doc = cdata.lookup_item(item_id);\n     let did = DefId { krate: cdata.cnum, index: item_id };\n+    let mut ctor_did = None;\n     let (kind, variants) = match item_family(doc) {\n         Enum => {\n             (ty::AdtKind::Enum,\n              get_enum_variants(intr, cdata, doc))\n         }\n         Struct(..) => {\n-            let ctor_did =\n-                reader::maybe_get_doc(doc, tag_items_data_item_struct_ctor).\n-                map_or(did, |ctor_doc| translated_def_id(cdata, ctor_doc));\n+            // Use separate constructor id for unit/tuple structs and reuse did for braced structs.\n+            ctor_did = reader::maybe_get_doc(doc, tag_items_data_item_struct_ctor).map(|ctor_doc| {\n+                translated_def_id(cdata, ctor_doc)\n+            });\n             (ty::AdtKind::Struct,\n-             vec![get_struct_variant(intr, cdata, doc, ctor_did)])\n+             vec![get_struct_variant(intr, cdata, doc, ctor_did.unwrap_or(did))])\n         }\n         _ => bug!(\"get_adt_def called on a non-ADT {:?} - {:?}\",\n                   item_family(doc), did)\n     };\n \n     let adt = tcx.intern_adt_def(did, kind, variants);\n+    if let Some(ctor_did) = ctor_did {\n+        // Make adt definition available through constructor id as well.\n+        tcx.insert_adt_def(ctor_did, adt);\n+    }\n \n     // this needs to be done *after* the variant is interned,\n     // to support recursive structures\n     for variant in &adt.variants {\n-        if variant.kind() == ty::VariantKind::Tuple &&\n+        if variant.kind == ty::VariantKind::Tuple &&\n             adt.adt_kind() == ty::AdtKind::Enum {\n             // tuple-like enum variant fields aren't real items - get the types\n             // from the ctor."}, {"sha": "7314259423592985f68cd4cd512a17247d7d2fd5", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f93aaf84cb50dfaaba44b08c05bd51320263f592/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f93aaf84cb50dfaaba44b08c05bd51320263f592/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=f93aaf84cb50dfaaba44b08c05bd51320263f592", "patch": "@@ -217,7 +217,7 @@ fn encode_parent_item(rbml_w: &mut Encoder, id: DefId) {\n fn encode_struct_fields(rbml_w: &mut Encoder,\n                         variant: ty::VariantDef) {\n     for f in &variant.fields {\n-        if variant.is_tuple_struct() {\n+        if variant.kind == ty::VariantKind::Tuple {\n             rbml_w.start_tag(tag_item_unnamed_field);\n         } else {\n             rbml_w.start_tag(tag_item_field);\n@@ -250,7 +250,7 @@ fn encode_enum_variant_info<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n         let _task = index.record(vid, rbml_w);\n         rbml_w.start_tag(tag_items_data_item);\n         encode_def_id_and_key(ecx, rbml_w, vid);\n-        encode_family(rbml_w, match variant.kind() {\n+        encode_family(rbml_w, match variant.kind {\n             ty::VariantKind::Struct => 'V',\n             ty::VariantKind::Tuple => 'v',\n             ty::VariantKind::Unit => 'w',"}, {"sha": "c54c8bfb5981ed6d8469510cc76c47a212992f36", "filename": "src/librustc_mir/hair/cx/pattern.rs", "status": "modified", "additions": 6, "deletions": 18, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/f93aaf84cb50dfaaba44b08c05bd51320263f592/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f93aaf84cb50dfaaba44b08c05bd51320263f592/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs?ref=f93aaf84cb50dfaaba44b08c05bd51320263f592", "patch": "@@ -13,7 +13,7 @@ use hair::cx::Cx;\n use rustc_data_structures::indexed_vec::Idx;\n use rustc_const_eval as const_eval;\n use rustc::hir::def::Def;\n-use rustc::hir::pat_util::{EnumerateAndAdjustIterator, pat_is_resolved_const};\n+use rustc::hir::pat_util::EnumerateAndAdjustIterator;\n use rustc::ty::{self, Ty};\n use rustc::mir::repr::*;\n use rustc::hir::{self, PatKind};\n@@ -76,9 +76,7 @@ impl<'patcx, 'cx, 'gcx, 'tcx> PatCx<'patcx, 'cx, 'gcx, 'tcx> {\n                 PatternKind::Range { lo: lo, hi: hi }\n             },\n \n-            PatKind::Path(..) | PatKind::QPath(..)\n-                if pat_is_resolved_const(&self.cx.tcx.def_map.borrow(), pat) =>\n-            {\n+            PatKind::Path(..) => {\n                 match self.cx.tcx.expect_def(pat.id) {\n                     Def::Const(def_id) | Def::AssociatedConst(def_id) => {\n                         let tcx = self.cx.tcx.global_tcx();\n@@ -104,11 +102,9 @@ impl<'patcx, 'cx, 'gcx, 'tcx> PatCx<'patcx, 'cx, 'gcx, 'tcx> {\n                             }\n                         }\n                     }\n-                    def =>\n-                        span_bug!(\n-                            pat.span,\n-                            \"def not a constant: {:?}\",\n-                            def),\n+                    _ => {\n+                        self.variant_or_leaf(pat, vec![])\n+                    }\n                 }\n             }\n \n@@ -199,10 +195,6 @@ impl<'patcx, 'cx, 'gcx, 'tcx> PatCx<'patcx, 'cx, 'gcx, 'tcx> {\n                 }\n             }\n \n-            PatKind::Path(..) => {\n-                self.variant_or_leaf(pat, vec![])\n-            }\n-\n             PatKind::TupleStruct(_, ref subpatterns, ddpos) => {\n                 let pat_ty = self.cx.tcx.node_id_to_type(pat.id);\n                 let adt_def = match pat_ty.sty {\n@@ -253,10 +245,6 @@ impl<'patcx, 'cx, 'gcx, 'tcx> PatCx<'patcx, 'cx, 'gcx, 'tcx> {\n \n                 self.variant_or_leaf(pat, subpatterns)\n             }\n-\n-            PatKind::QPath(..) => {\n-                span_bug!(pat.span, \"unexpanded macro or bad constant etc\");\n-            }\n         };\n \n         Pattern {\n@@ -325,7 +313,7 @@ impl<'patcx, 'cx, 'gcx, 'tcx> PatCx<'patcx, 'cx, 'gcx, 'tcx> {\n                 }\n             }\n \n-            Def::Struct(..) | Def::TyAlias(..) => {\n+            Def::Struct(..) | Def::TyAlias(..) | Def::AssociatedTy(..) => {\n                 PatternKind::Leaf { subpatterns: subpatterns }\n             }\n "}, {"sha": "acaf9b9b2faeed9d57b1b4da9a0cccd4b3b26238", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f93aaf84cb50dfaaba44b08c05bd51320263f592/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f93aaf84cb50dfaaba44b08c05bd51320263f592/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=f93aaf84cb50dfaaba44b08c05bd51320263f592", "patch": "@@ -436,7 +436,6 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n                 }\n             }\n             hir::ExprPath(..) => {\n-\n                 if let Def::Struct(..) = self.tcx.expect_def(expr.id) {\n                     let expr_ty = self.tcx.expr_ty(expr);\n                     let def = match expr_ty.sty {"}, {"sha": "9079cc8ccb122b86ecf41654a760b6c0e595ef08", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 20, "deletions": 27, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/f93aaf84cb50dfaaba44b08c05bd51320263f592/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f93aaf84cb50dfaaba44b08c05bd51320263f592/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=f93aaf84cb50dfaaba44b08c05bd51320263f592", "patch": "@@ -2180,7 +2180,8 @@ impl<'a> Resolver<'a> {\n         // because that breaks the assumptions later\n         // passes make about or-patterns.)\n         let renamed = mtwt::resolve(ident.node);\n-        let def = match bindings.get(&renamed).cloned() {\n+        let mut def = Def::Local(self.definitions.local_def_id(pat_id), pat_id);\n+        match bindings.get(&renamed).cloned() {\n             Some(id) if id == outer_pat_id => {\n                 // `Variant(a, a)`, error\n                 resolve_error(\n@@ -2189,7 +2190,6 @@ impl<'a> Resolver<'a> {\n                     ResolutionError::IdentifierBoundMoreThanOnceInSamePattern(\n                         &ident.node.name.as_str())\n                 );\n-                Def::Err\n             }\n             Some(..) if pat_src == PatternSource::FnParam => {\n                 // `fn f(a: u8, a: u8)`, error\n@@ -2199,29 +2199,24 @@ impl<'a> Resolver<'a> {\n                     ResolutionError::IdentifierBoundMoreThanOnceInParameterList(\n                         &ident.node.name.as_str())\n                 );\n-                Def::Err\n             }\n             Some(..) if pat_src == PatternSource::Match => {\n                 // `Variant1(a) | Variant2(a)`, ok\n                 // Reuse definition from the first `a`.\n-                self.value_ribs.last_mut().unwrap().bindings[&renamed]\n+                def = self.value_ribs.last_mut().unwrap().bindings[&renamed];\n             }\n             Some(..) => {\n                 span_bug!(ident.span, \"two bindings with the same name from \\\n                                        unexpected pattern source {:?}\", pat_src);\n             }\n             None => {\n-                // A completely fresh binding, add to the lists.\n-                // FIXME: Later stages are not ready to deal with `Def::Err` here yet, so\n-                // define `Invalid` bindings as `Def::Local`, just don't add them to the lists.\n-                let def = Def::Local(self.definitions.local_def_id(pat_id), pat_id);\n+                // A completely fresh binding, add to the lists if it's valid.\n                 if ident.node.name != keywords::Invalid.name() {\n                     bindings.insert(renamed, outer_pat_id);\n                     self.value_ribs.last_mut().unwrap().bindings.insert(renamed, def);\n                 }\n-                def\n             }\n-        };\n+        }\n \n         PathResolution::new(def)\n     }\n@@ -2287,51 +2282,49 @@ impl<'a> Resolver<'a> {\n                 PatKind::Ident(bmode, ref ident, ref opt_pat) => {\n                     // First try to resolve the identifier as some existing\n                     // entity, then fall back to a fresh binding.\n-                    let local_def = self.resolve_identifier(ident.node, ValueNS, true);\n-                    let resolution = if let Some(LocalDef { def, .. }) = local_def {\n+                    let resolution = self.resolve_identifier(ident.node, ValueNS, true)\n+                                         .map(|local_def| PathResolution::new(local_def.def))\n+                                         .and_then(|resolution| {\n                         let always_binding = !pat_src.is_refutable() || opt_pat.is_some() ||\n                                              bmode != BindingMode::ByValue(Mutability::Immutable);\n-                        match def {\n+                        match resolution.base_def {\n                             Def::Struct(..) | Def::Variant(..) |\n                             Def::Const(..) | Def::AssociatedConst(..) if !always_binding => {\n                                 // A constant, unit variant, etc pattern.\n-                                PathResolution::new(def)\n+                                Some(resolution)\n                             }\n                             Def::Struct(..) | Def::Variant(..) |\n                             Def::Const(..) | Def::AssociatedConst(..) | Def::Static(..) => {\n                                 // A fresh binding that shadows something unacceptable.\n-                                let kind_name = PathResolution::new(def).kind_name();\n                                 resolve_error(\n                                     self,\n                                     ident.span,\n                                     ResolutionError::BindingShadowsSomethingUnacceptable(\n-                                        pat_src.descr(), kind_name, ident.node.name)\n+                                        pat_src.descr(), resolution.kind_name(), ident.node.name)\n                                 );\n-                                err_path_resolution()\n+                                None\n                             }\n-                            Def::Local(..) | Def::Upvar(..) | Def::Fn(..) | Def::Err => {\n+                            Def::Local(..) | Def::Upvar(..) | Def::Fn(..) => {\n                                 // These entities are explicitly allowed\n                                 // to be shadowed by fresh bindings.\n-                                self.fresh_binding(ident, pat.id, outer_pat_id,\n-                                                   pat_src, bindings)\n+                                None\n                             }\n                             def => {\n                                 span_bug!(ident.span, \"unexpected definition for an \\\n                                                        identifier in pattern {:?}\", def);\n                             }\n                         }\n-                    } else {\n-                        // Fall back to a fresh binding.\n+                    }).unwrap_or_else(|| {\n                         self.fresh_binding(ident, pat.id, outer_pat_id, pat_src, bindings)\n-                    };\n+                    });\n \n                     self.record_def(pat.id, resolution);\n                 }\n \n                 PatKind::TupleStruct(ref path, _, _) => {\n                     self.resolve_pattern_path(pat.id, None, path, ValueNS, |def| {\n                         match def {\n-                            Def::Struct(..) | Def::Variant(..) | Def::Err => true,\n+                            Def::Struct(..) | Def::Variant(..) => true,\n                             _ => false,\n                         }\n                     }, \"variant or struct\");\n@@ -2341,7 +2334,7 @@ impl<'a> Resolver<'a> {\n                     self.resolve_pattern_path(pat.id, qself.as_ref(), path, ValueNS, |def| {\n                         match def {\n                             Def::Struct(..) | Def::Variant(..) |\n-                            Def::Const(..) | Def::AssociatedConst(..) | Def::Err => true,\n+                            Def::Const(..) | Def::AssociatedConst(..) => true,\n                             _ => false,\n                         }\n                     }, \"variant, struct or constant\");\n@@ -2351,7 +2344,7 @@ impl<'a> Resolver<'a> {\n                     self.resolve_pattern_path(pat.id, None, path, TypeNS, |def| {\n                         match def {\n                             Def::Struct(..) | Def::Variant(..) |\n-                            Def::TyAlias(..) | Def::AssociatedTy(..) | Def::Err => true,\n+                            Def::TyAlias(..) | Def::AssociatedTy(..) => true,\n                             _ => false,\n                         }\n                     }, \"variant, struct or type alias\");\n@@ -2482,7 +2475,7 @@ impl<'a> Resolver<'a> {\n                           record_used: bool)\n                           -> Option<LocalDef> {\n         if identifier.name == keywords::Invalid.name() {\n-            return Some(LocalDef::from_def(Def::Err));\n+            return None;\n         }\n \n         self.resolve_ident_in_lexical_scope(identifier, namespace, record_used)"}, {"sha": "08e894ffbcfd48c4e37fde4d75f6565713c79f80", "filename": "src/librustc_trans/_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f93aaf84cb50dfaaba44b08c05bd51320263f592/src%2Flibrustc_trans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f93aaf84cb50dfaaba44b08c05bd51320263f592/src%2Flibrustc_trans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2F_match.rs?ref=f93aaf84cb50dfaaba44b08c05bd51320263f592", "patch": "@@ -796,7 +796,7 @@ fn any_irrefutable_adt_pat(tcx: TyCtxt, m: &[Match], col: usize) -> bool {\n             PatKind::Tuple(..) => true,\n             PatKind::Struct(..) | PatKind::TupleStruct(..) | PatKind::Path(..) => {\n                 match tcx.expect_def(pat.id) {\n-                    Def::Struct(..) | Def::TyAlias(..) => true,\n+                    Def::Struct(..) | Def::TyAlias(..) | Def::AssociatedTy(..) => true,\n                     _ => false,\n                 }\n             }\n@@ -2003,7 +2003,7 @@ pub fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                         cleanup_scope)\n                 });\n         }\n-        PatKind::Path(..) | PatKind::QPath(..) | PatKind::Wild |\n+        PatKind::Path(..) | PatKind::Wild |\n         PatKind::Lit(..) | PatKind::Range(..) => ()\n     }\n     return bcx;"}, {"sha": "00feb2cd1de0961f5ec1e97965ea1480d3ee3543", "filename": "src/librustc_trans/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f93aaf84cb50dfaaba44b08c05bd51320263f592/src%2Flibrustc_trans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f93aaf84cb50dfaaba44b08c05bd51320263f592/src%2Flibrustc_trans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fconsts.rs?ref=f93aaf84cb50dfaaba44b08c05bd51320263f592", "patch": "@@ -900,7 +900,7 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 }\n                 Def::Variant(enum_did, variant_did) => {\n                     let vinfo = cx.tcx().lookup_adt_def(enum_did).variant_with_id(variant_did);\n-                    match vinfo.kind() {\n+                    match vinfo.kind {\n                         ty::VariantKind::Unit => {\n                             let repr = adt::represent_type(cx, ety);\n                             adt::trans_const(cx, &repr, Disr::from(vinfo.disr_val), &[])"}, {"sha": "0b75402486812b4706706c1363a284cdd2341ffd", "filename": "src/librustc_trans/debuginfo/create_scope_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f93aaf84cb50dfaaba44b08c05bd51320263f592/src%2Flibrustc_trans%2Fdebuginfo%2Fcreate_scope_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f93aaf84cb50dfaaba44b08c05bd51320263f592/src%2Flibrustc_trans%2Fdebuginfo%2Fcreate_scope_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fcreate_scope_map.rs?ref=f93aaf84cb50dfaaba44b08c05bd51320263f592", "patch": "@@ -313,7 +313,7 @@ fn walk_pattern(cx: &CrateContext,\n             }\n         }\n \n-        PatKind::Path(..) | PatKind::QPath(..) => {\n+        PatKind::Path(..) => {\n             scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n         }\n "}, {"sha": "b84cc028d0ced97d4166f805aefba6ec8acd2a3d", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f93aaf84cb50dfaaba44b08c05bd51320263f592/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f93aaf84cb50dfaaba44b08c05bd51320263f592/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=f93aaf84cb50dfaaba44b08c05bd51320263f592", "patch": "@@ -1109,7 +1109,7 @@ struct StructMemberDescriptionFactory<'tcx> {\n impl<'tcx> StructMemberDescriptionFactory<'tcx> {\n     fn create_member_descriptions<'a>(&self, cx: &CrateContext<'a, 'tcx>)\n                                       -> Vec<MemberDescription> {\n-        if let ty::VariantKind::Unit = self.variant.kind() {\n+        if self.variant.kind == ty::VariantKind::Unit {\n             return Vec::new();\n         }\n \n@@ -1126,7 +1126,7 @@ impl<'tcx> StructMemberDescriptionFactory<'tcx> {\n         };\n \n         self.variant.fields.iter().enumerate().map(|(i, f)| {\n-            let name = if let ty::VariantKind::Tuple = self.variant.kind() {\n+            let name = if self.variant.kind == ty::VariantKind::Tuple {\n                 format!(\"__{}\", i)\n             } else {\n                 f.name.to_string()\n@@ -1356,7 +1356,7 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n                 // For the metadata of the wrapper struct, we need to create a\n                 // MemberDescription of the struct's single field.\n                 let sole_struct_member_description = MemberDescription {\n-                    name: match non_null_variant.kind() {\n+                    name: match non_null_variant.kind {\n                         ty::VariantKind::Tuple => \"__0\".to_string(),\n                         ty::VariantKind::Struct => {\n                             non_null_variant.fields[0].name.to_string()\n@@ -1524,7 +1524,7 @@ fn describe_enum_variant<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                            containing_scope);\n \n     // Get the argument names from the enum variant info\n-    let mut arg_names: Vec<_> = match variant.kind() {\n+    let mut arg_names: Vec<_> = match variant.kind {\n         ty::VariantKind::Unit => vec![],\n         ty::VariantKind::Tuple => {\n             variant.fields"}, {"sha": "9ff30f9ede26295d85f4e94c853d817ce3bf3d84", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 40, "deletions": 40, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/f93aaf84cb50dfaaba44b08c05bd51320263f592/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f93aaf84cb50dfaaba44b08c05bd51320263f592/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=f93aaf84cb50dfaaba44b08c05bd51320263f592", "patch": "@@ -53,7 +53,7 @@ use rustc_const_eval::{eval_const_expr_partial, ConstEvalErr};\n use rustc_const_eval::EvalHint::UncheckedExprHint;\n use rustc_const_eval::ErrKind::ErroneousReferencedConstant;\n use hir::{self, SelfKind};\n-use hir::def::{self, Def};\n+use hir::def::{Def, PathResolution};\n use hir::def_id::DefId;\n use hir::print as pprust;\n use middle::resolve_lifetime as rl;\n@@ -1327,7 +1327,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                 };\n \n                 if self.ensure_super_predicates(span, trait_did).is_err() {\n-                    return (tcx.types.err, ty_path_def);\n+                    return (tcx.types.err, Def::Err);\n                 }\n \n                 let candidates: Vec<ty::PolyTraitRef> =\n@@ -1341,7 +1341,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                                                     &assoc_name.as_str(),\n                                                     span) {\n                     Ok(bound) => bound,\n-                    Err(ErrorReported) => return (tcx.types.err, ty_path_def),\n+                    Err(ErrorReported) => return (tcx.types.err, Def::Err),\n                 }\n             }\n             (&ty::TyParam(_), Def::SelfTy(Some(trait_did), None)) => {\n@@ -1351,7 +1351,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                                                      assoc_name,\n                                                      span) {\n                     Ok(bound) => bound,\n-                    Err(ErrorReported) => return (tcx.types.err, ty_path_def),\n+                    Err(ErrorReported) => return (tcx.types.err, Def::Err),\n                 }\n             }\n             (&ty::TyParam(_), Def::TyParam(_, _, param_did, param_name)) => {\n@@ -1361,15 +1361,15 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                                                      assoc_name,\n                                                      span) {\n                     Ok(bound) => bound,\n-                    Err(ErrorReported) => return (tcx.types.err, ty_path_def),\n+                    Err(ErrorReported) => return (tcx.types.err, Def::Err),\n                 }\n             }\n             _ => {\n                 self.report_ambiguous_associated_type(span,\n                                                       &ty.to_string(),\n                                                       \"Trait\",\n                                                       &assoc_name.as_str());\n-                return (tcx.types.err, ty_path_def);\n+                return (tcx.types.err, Def::Err);\n             }\n         };\n \n@@ -1574,45 +1574,46 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         }\n     }\n \n-    // Note that both base_segments and assoc_segments may be empty, although not at\n-    // the same time.\n+    // Resolve possibly associated type path into a type and final definition.\n+    // Note that both base_segments and assoc_segments may be empty, although not at same time.\n     pub fn finish_resolving_def_to_ty(&self,\n                                       rscope: &RegionScope,\n                                       span: Span,\n                                       param_mode: PathParamMode,\n-                                      mut def: Def,\n+                                      base_def: Def,\n                                       opt_self_ty: Option<Ty<'tcx>>,\n                                       base_path_ref_id: ast::NodeId,\n                                       base_segments: &[hir::PathSegment],\n                                       assoc_segments: &[hir::PathSegment])\n                                       -> (Ty<'tcx>, Def) {\n-        debug!(\"finish_resolving_def_to_ty(def={:?}, \\\n+        // Convert the base type.\n+        debug!(\"finish_resolving_def_to_ty(base_def={:?}, \\\n                 base_segments={:?}, \\\n                 assoc_segments={:?})\",\n-               def,\n+               base_def,\n                base_segments,\n                assoc_segments);\n-        let mut ty = self.base_def_to_ty(rscope,\n-                                         span,\n-                                         param_mode,\n-                                         def,\n-                                         opt_self_ty,\n-                                         base_path_ref_id,\n-                                         base_segments);\n-        debug!(\"finish_resolving_def_to_ty: base_def_to_ty returned {:?}\", ty);\n+        let base_ty = self.base_def_to_ty(rscope,\n+                                          span,\n+                                          param_mode,\n+                                          base_def,\n+                                          opt_self_ty,\n+                                          base_path_ref_id,\n+                                          base_segments);\n+        debug!(\"finish_resolving_def_to_ty: base_def_to_ty returned {:?}\", base_ty);\n+\n         // If any associated type segments remain, attempt to resolve them.\n+        let (mut ty, mut def) = (base_ty, base_def);\n         for segment in assoc_segments {\n             debug!(\"finish_resolving_def_to_ty: segment={:?}\", segment);\n-            if ty.sty == ty::TyError {\n+            // This is pretty bad (it will fail except for T::A and Self::A).\n+            let (new_ty, new_def) = self.associated_path_def_to_ty(span, ty, def, segment);\n+            ty = new_ty;\n+            def = new_def;\n+\n+            if def == Def::Err {\n                 break;\n             }\n-            // This is pretty bad (it will fail except for T::A and Self::A).\n-            let (a_ty, a_def) = self.associated_path_def_to_ty(span,\n-                                                               ty,\n-                                                               def,\n-                                                               segment);\n-            ty = a_ty;\n-            def = a_def;\n         }\n         (ty, def)\n     }\n@@ -1719,23 +1720,22 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             hir::TyPath(ref maybe_qself, ref path) => {\n                 debug!(\"ast_ty_to_ty: maybe_qself={:?} path={:?}\", maybe_qself, path);\n                 let path_res = tcx.expect_resolution(ast_ty.id);\n-                let def = path_res.base_def;\n                 let base_ty_end = path.segments.len() - path_res.depth;\n                 let opt_self_ty = maybe_qself.as_ref().map(|qself| {\n                     self.ast_ty_to_ty(rscope, &qself.ty)\n                 });\n-                let (ty, _def) = self.finish_resolving_def_to_ty(rscope,\n-                                                                 ast_ty.span,\n-                                                                 PathParamMode::Explicit,\n-                                                                 def,\n-                                                                 opt_self_ty,\n-                                                                 ast_ty.id,\n-                                                                 &path.segments[..base_ty_end],\n-                                                                 &path.segments[base_ty_end..]);\n-\n-                if path_res.depth != 0 && ty.sty != ty::TyError {\n-                    // Write back the new resolution.\n-                    tcx.def_map.borrow_mut().insert(ast_ty.id, def::PathResolution::new(def));\n+                let (ty, def) = self.finish_resolving_def_to_ty(rscope,\n+                                                                ast_ty.span,\n+                                                                PathParamMode::Explicit,\n+                                                                path_res.base_def,\n+                                                                opt_self_ty,\n+                                                                ast_ty.id,\n+                                                                &path.segments[..base_ty_end],\n+                                                                &path.segments[base_ty_end..]);\n+\n+                // Write back the new resolution.\n+                if path_res.depth != 0 {\n+                    tcx.def_map.borrow_mut().insert(ast_ty.id, PathResolution::new(def));\n                 }\n \n                 ty"}, {"sha": "e90b32cd5dfc0192c5001b46a8dc2795acab7f39", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 127, "deletions": 195, "changes": 322, "blob_url": "https://github.com/rust-lang/rust/blob/f93aaf84cb50dfaaba44b08c05bd51320263f592/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f93aaf84cb50dfaaba44b08c05bd51320263f592/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=f93aaf84cb50dfaaba44b08c05bd51320263f592", "patch": "@@ -10,13 +10,12 @@\n \n use hir::def::Def;\n use rustc::infer::{self, InferOk, TypeOrigin};\n-use hir::pat_util::{EnumerateAndAdjustIterator, pat_is_resolved_const};\n+use hir::pat_util::EnumerateAndAdjustIterator;\n use rustc::ty::subst::Substs;\n-use rustc::ty::{self, Ty, TypeFoldable, LvaluePreference};\n+use rustc::ty::{self, Ty, TypeFoldable, LvaluePreference, VariantKind};\n use check::{FnCtxt, Expectation};\n use lint;\n use util::nodemap::FnvHashMap;\n-use session::Session;\n \n use std::collections::hash_map::Entry::{Occupied, Vacant};\n use std::cmp;\n@@ -28,20 +27,6 @@ use syntax_pos::Span;\n use rustc::hir::{self, PatKind};\n use rustc::hir::print as pprust;\n \n-// This function exists due to the warning \"diagnostic code E0164 already used\"\n-fn bad_struct_kind_err(sess: &Session, pat: &hir::Pat, path: &hir::Path, lint: bool) {\n-    let name = pprust::path_to_string(path);\n-    let msg = format!(\"`{}` does not name a tuple variant or a tuple struct\", name);\n-    if lint {\n-        sess.add_lint(lint::builtin::MATCH_OF_UNIT_VARIANT_VIA_PAREN_DOTDOT,\n-                      pat.id,\n-                      pat.span,\n-                      msg);\n-    } else {\n-        span_err!(sess, pat.span, E0164, \"{}\", msg);\n-    }\n-}\n-\n impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     pub fn check_pat(&self, pat: &'gcx hir::Pat, expected: Ty<'tcx>) {\n         let tcx = self.tcx;\n@@ -136,22 +121,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 // subtyping doesn't matter here, as the value is some kind of scalar\n                 self.demand_eqtype(pat.span, expected, lhs_ty);\n             }\n-            PatKind::Path(..) if pat_is_resolved_const(&tcx.def_map.borrow(), pat) => {\n-                let const_did = tcx.expect_def(pat.id).def_id();\n-                let const_scheme = tcx.lookup_item_type(const_did);\n-                assert!(const_scheme.generics.is_empty());\n-                let const_ty = self.instantiate_type_scheme(pat.span,\n-                                                            &Substs::empty(),\n-                                                            &const_scheme.ty);\n-                self.write_ty(pat.id, const_ty);\n-\n-                // FIXME(#20489) -- we should limit the types here to scalars or something!\n-\n-                // As with PatKind::Lit, what we really want here is that there\n-                // exist a LUB, but for the cases that can occur, subtype\n-                // is good enough.\n-                self.demand_suptype(pat.span, expected, const_ty);\n-            }\n             PatKind::Binding(bm, _, ref sub) => {\n                 let typ = self.local_ty(pat.span, pat.id);\n                 match bm {\n@@ -197,33 +166,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 }\n             }\n             PatKind::TupleStruct(ref path, ref subpats, ddpos) => {\n-                self.check_pat_enum(pat, path, &subpats, ddpos, expected, true);\n-            }\n-            PatKind::Path(ref path) => {\n-                self.check_pat_enum(pat, path, &[], None, expected, false);\n+                self.check_pat_tuple_struct(pat, path, &subpats, ddpos, expected);\n             }\n-            PatKind::QPath(ref qself, ref path) => {\n-                let self_ty = self.to_ty(&qself.ty);\n-                let path_res = tcx.expect_resolution(pat.id);\n-                if path_res.base_def == Def::Err {\n-                    self.set_tainted_by_errors();\n-                    self.write_error(pat.id);\n-                    return;\n-                }\n-                if let Some((opt_ty, segments, def)) =\n-                        self.resolve_ty_and_def_ufcs(path_res, Some(self_ty),\n-                                                     path, pat.span, pat.id) {\n-                    if self.check_assoc_item_is_const(def, pat.span) {\n-                        let scheme = tcx.lookup_item_type(def.def_id());\n-                        let predicates = tcx.lookup_predicates(def.def_id());\n-                        self.instantiate_path(segments, scheme, &predicates,\n-                                              opt_ty, def, pat.span, pat.id);\n-                        let const_ty = self.node_ty(pat.id);\n-                        self.demand_suptype(pat.span, expected, const_ty);\n-                    } else {\n-                        self.write_error(pat.id)\n-                    }\n-                }\n+            PatKind::Path(ref opt_qself, ref path) => {\n+                let opt_qself_ty = opt_qself.as_ref().map(|qself| self.to_ty(&qself.ty));\n+                self.check_pat_path(pat, opt_qself_ty, path, expected);\n             }\n             PatKind::Struct(ref path, ref fields, etc) => {\n                 self.check_pat_struct(pat, path, fields, etc, expected);\n@@ -403,20 +350,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // subtyping.\n     }\n \n-    fn check_assoc_item_is_const(&self, def: Def, span: Span) -> bool {\n-        match def {\n-            Def::AssociatedConst(..) => true,\n-            Def::Method(..) => {\n-                span_err!(self.tcx.sess, span, E0327,\n-                          \"associated items in match patterns must be constants\");\n-                false\n-            }\n-            _ => {\n-                span_bug!(span, \"non-associated item in check_assoc_item_is_const\");\n-            }\n-        }\n-    }\n-\n     pub fn check_dereferencable(&self, span: Span, expected: Ty<'tcx>, inner: &hir::Pat) -> bool {\n         if let PatKind::Binding(..) = inner.node {\n             if let Some(mt) = self.shallow_resolve(expected).builtin_deref(true, ty::NoPreference) {\n@@ -554,167 +487,166 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n }\n \n impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n-    pub fn check_pat_struct(&self, pat: &'gcx hir::Pat,\n-                            path: &hir::Path, fields: &'gcx [Spanned<hir::FieldPat>],\n-                            etc: bool, expected: Ty<'tcx>) {\n-        let tcx = self.tcx;\n-\n-        let def = tcx.expect_def(pat.id);\n-        let variant = match self.def_struct_variant(def, path.span) {\n-            Some((_, variant)) => variant,\n-            None => {\n-                let name = pprust::path_to_string(path);\n-                span_err!(tcx.sess, pat.span, E0163,\n-                          \"`{}` does not name a struct or a struct variant\", name);\n-                self.write_error(pat.id);\n-\n-                for field in fields {\n-                    self.check_pat(&field.node.pat, tcx.types.err);\n-                }\n-                return;\n+    fn check_pat_struct(&self,\n+                        pat: &'gcx hir::Pat,\n+                        path: &hir::Path,\n+                        fields: &'gcx [Spanned<hir::FieldPat>],\n+                        etc: bool,\n+                        expected: Ty<'tcx>)\n+    {\n+        // Resolve the path and check the definition for errors.\n+        let (variant, pat_ty) = if let Some(variant_ty) = self.check_struct_path(path, pat.id,\n+                                                                                 pat.span) {\n+            variant_ty\n+        } else {\n+            self.write_error(pat.id);\n+            for field in fields {\n+                self.check_pat(&field.node.pat, self.tcx.types.err);\n             }\n+            return;\n         };\n \n-        let pat_ty = self.instantiate_type(def.def_id(), path);\n-        let item_substs = match pat_ty.sty {\n+        // Type check the path.\n+        self.demand_eqtype(pat.span, expected, pat_ty);\n+\n+        // Type check subpatterns.\n+        let substs = match pat_ty.sty {\n             ty::TyStruct(_, substs) | ty::TyEnum(_, substs) => substs,\n             _ => span_bug!(pat.span, \"struct variant is not an ADT\")\n         };\n-        self.demand_eqtype(pat.span, expected, pat_ty);\n-        self.check_struct_pat_fields(pat.span, fields, variant, &item_substs, etc);\n-\n-        self.write_ty(pat.id, pat_ty);\n-        self.write_substs(pat.id, ty::ItemSubsts {\n-            substs: item_substs\n-        });\n+        self.check_struct_pat_fields(pat.span, fields, variant, substs, etc);\n     }\n \n-    fn check_pat_enum(&self,\n+    fn check_pat_path(&self,\n                       pat: &hir::Pat,\n+                      opt_self_ty: Option<Ty<'tcx>>,\n                       path: &hir::Path,\n-                      subpats: &'gcx [P<hir::Pat>],\n-                      ddpos: Option<usize>,\n-                      expected: Ty<'tcx>,\n-                      is_tuple_struct_pat: bool)\n+                      expected: Ty<'tcx>)\n     {\n-        // Typecheck the path.\n         let tcx = self.tcx;\n-\n-        let path_res = tcx.expect_resolution(pat.id);\n-        if path_res.base_def == Def::Err {\n-            self.set_tainted_by_errors();\n+        let report_unexpected_def = || {\n+            span_err!(tcx.sess, pat.span, E0533,\n+                      \"`{}` does not name a unit variant, unit struct or a constant\",\n+                      pprust::path_to_string(path));\n             self.write_error(pat.id);\n-\n-            for pat in subpats {\n-                self.check_pat(&pat, tcx.types.err);\n-            }\n-            return;\n-        }\n-\n-        let (opt_ty, segments, def) = match self.resolve_ty_and_def_ufcs(path_res,\n-                                                                         None, path,\n-                                                                         pat.span, pat.id) {\n-            Some(resolution) => resolution,\n-            // Error handling done inside resolve_ty_and_def_ufcs, so if\n-            // resolution fails just return.\n-            None => {return;}\n         };\n \n-        // Items that were partially resolved before should have been resolved to\n-        // associated constants (i.e. not methods).\n-        if path_res.depth != 0 && !self.check_assoc_item_is_const(def, pat.span) {\n-            self.write_error(pat.id);\n-            return;\n+        // Resolve the path and check the definition for errors.\n+        let (def, opt_ty, segments) = self.resolve_ty_and_def_ufcs(opt_self_ty, path,\n+                                                                   pat.id, pat.span);\n+        match def {\n+            Def::Err => {\n+                self.set_tainted_by_errors();\n+                self.write_error(pat.id);\n+                return;\n+            }\n+            Def::Method(..) => {\n+                report_unexpected_def();\n+                return;\n+            }\n+            Def::Variant(..) | Def::Struct(..) => {\n+                let variant = tcx.expect_variant_def(def);\n+                if variant.kind != VariantKind::Unit {\n+                    report_unexpected_def();\n+                    return;\n+                }\n+            }\n+            Def::Const(..) | Def::AssociatedConst(..) => {} // OK\n+            _ => bug!(\"unexpected pattern definition {:?}\", def)\n         }\n \n-        let enum_def = def.variant_def_ids()\n-            .map_or_else(|| def.def_id(), |(enum_def, _)| enum_def);\n+        // Type check the path.\n+        let scheme = tcx.lookup_item_type(def.def_id());\n+        let predicates = tcx.lookup_predicates(def.def_id());\n+        let pat_ty = self.instantiate_value_path(segments, scheme, &predicates,\n+                                                 opt_ty, def, pat.span, pat.id);\n+        self.demand_suptype(pat.span, expected, pat_ty);\n+    }\n \n-        let ctor_scheme = tcx.lookup_item_type(enum_def);\n-        let ctor_predicates = tcx.lookup_predicates(enum_def);\n-        let path_scheme = if ctor_scheme.ty.is_fn() {\n-            let fn_ret = tcx.no_late_bound_regions(&ctor_scheme.ty.fn_ret()).unwrap();\n-            ty::TypeScheme {\n-                ty: fn_ret.unwrap(),\n-                generics: ctor_scheme.generics,\n-            }\n-        } else {\n-            ctor_scheme\n-        };\n-        self.instantiate_path(segments, path_scheme, &ctor_predicates,\n-                              opt_ty, def, pat.span, pat.id);\n-        let report_bad_struct_kind = |is_warning| {\n-            bad_struct_kind_err(tcx.sess, pat, path, is_warning);\n-            if is_warning { return; }\n+    fn check_pat_tuple_struct(&self,\n+                              pat: &hir::Pat,\n+                              path: &hir::Path,\n+                              subpats: &'gcx [P<hir::Pat>],\n+                              ddpos: Option<usize>,\n+                              expected: Ty<'tcx>)\n+    {\n+        let tcx = self.tcx;\n+        let on_error = || {\n             self.write_error(pat.id);\n             for pat in subpats {\n                 self.check_pat(&pat, tcx.types.err);\n             }\n         };\n-\n-        // If we didn't have a fully resolved path to start with, we had an\n-        // associated const, and we should quit now, since the rest of this\n-        // function uses checks specific to structs and enums.\n-        if path_res.depth != 0 {\n-            if is_tuple_struct_pat {\n-                report_bad_struct_kind(false);\n+        let report_unexpected_def = |is_lint| {\n+            let msg = format!(\"`{}` does not name a tuple variant or a tuple struct\",\n+                              pprust::path_to_string(path));\n+            if is_lint {\n+                tcx.sess.add_lint(lint::builtin::MATCH_OF_UNIT_VARIANT_VIA_PAREN_DOTDOT,\n+                                  pat.id, pat.span, msg);\n             } else {\n-                let pat_ty = self.node_ty(pat.id);\n-                self.demand_suptype(pat.span, expected, pat_ty);\n+                span_err!(tcx.sess, pat.span, E0164, \"{}\", msg);\n+                on_error();\n             }\n-            return;\n-        }\n-\n-        let pat_ty = self.node_ty(pat.id);\n-        self.demand_eqtype(pat.span, expected, pat_ty);\n+        };\n \n-        let real_path_ty = self.node_ty(pat.id);\n-        let (kind_name, variant, expected_substs) = match real_path_ty.sty {\n-            ty::TyEnum(enum_def, expected_substs) => {\n-                let variant = enum_def.variant_of_def(def);\n-                (\"variant\", variant, expected_substs)\n-            }\n-            ty::TyStruct(struct_def, expected_substs) => {\n-                let variant = struct_def.struct_variant();\n-                (\"struct\", variant, expected_substs)\n-            }\n-            _ => {\n-                report_bad_struct_kind(false);\n+        // Resolve the path and check the definition for errors.\n+        let (def, opt_ty, segments) = self.resolve_ty_and_def_ufcs(None, path, pat.id, pat.span);\n+        let variant = match def {\n+            Def::Err => {\n+                self.set_tainted_by_errors();\n+                on_error();\n                 return;\n             }\n-        };\n-\n-        match (is_tuple_struct_pat, variant.kind()) {\n-            (true, ty::VariantKind::Unit) if subpats.is_empty() && ddpos.is_some() => {\n-                // Matching unit structs with tuple variant patterns (`UnitVariant(..)`)\n-                // is allowed for backward compatibility.\n-                report_bad_struct_kind(true);\n+            Def::Const(..) | Def::AssociatedConst(..) | Def::Method(..) => {\n+                report_unexpected_def(false);\n+                return;\n             }\n-            (true, ty::VariantKind::Unit) |\n-            (false, ty::VariantKind::Tuple) |\n-            (_, ty::VariantKind::Struct) => {\n-                report_bad_struct_kind(false);\n-                return\n+            Def::Variant(..) | Def::Struct(..) => {\n+                tcx.expect_variant_def(def)\n             }\n-            _ => {}\n+            _ => bug!(\"unexpected pattern definition {:?}\", def)\n+        };\n+        if variant.kind == VariantKind::Unit && subpats.is_empty() && ddpos.is_some() {\n+            // Matching unit structs with tuple variant patterns (`UnitVariant(..)`)\n+            // is allowed for backward compatibility.\n+            report_unexpected_def(true);\n+        } else if variant.kind != VariantKind::Tuple {\n+            report_unexpected_def(false);\n+            return;\n         }\n \n+        // Type check the path.\n+        let scheme = tcx.lookup_item_type(def.def_id());\n+        let scheme = if scheme.ty.is_fn() {\n+            // Replace constructor type with constructed type for tuple struct patterns.\n+            let fn_ret = tcx.no_late_bound_regions(&scheme.ty.fn_ret()).unwrap().unwrap();\n+            ty::TypeScheme { ty: fn_ret, generics: scheme.generics }\n+        } else {\n+            // Leave the type as is for unit structs (backward compatibility).\n+            scheme\n+        };\n+        let predicates = tcx.lookup_predicates(def.def_id());\n+        let pat_ty = self.instantiate_value_path(segments, scheme, &predicates,\n+                                                 opt_ty, def, pat.span, pat.id);\n+        self.demand_eqtype(pat.span, expected, pat_ty);\n+\n+        // Type check subpatterns.\n         if subpats.len() == variant.fields.len() ||\n                 subpats.len() < variant.fields.len() && ddpos.is_some() {\n+            let substs = match pat_ty.sty {\n+                ty::TyStruct(_, substs) | ty::TyEnum(_, substs) => substs,\n+                ref ty => bug!(\"unexpected pattern type {:?}\", ty),\n+            };\n             for (i, subpat) in subpats.iter().enumerate_and_adjust(variant.fields.len(), ddpos) {\n-                let field_ty = self.field_ty(subpat.span, &variant.fields[i], expected_substs);\n+                let field_ty = self.field_ty(subpat.span, &variant.fields[i], substs);\n                 self.check_pat(&subpat, field_ty);\n             }\n         } else {\n             span_err!(tcx.sess, pat.span, E0023,\n-                      \"this pattern has {} field{}, but the corresponding {} has {} field{}\",\n-                      subpats.len(), if subpats.len() == 1 {\"\"} else {\"s\"},\n-                      kind_name,\n-                      variant.fields.len(), if variant.fields.len() == 1 {\"\"} else {\"s\"});\n-\n-            for pat in subpats {\n-                self.check_pat(&pat, tcx.types.err);\n-            }\n+                      \"this pattern has {} field{s}, but the corresponding {} has {} field{s}\",\n+                      subpats.len(), def.kind_name(), variant.fields.len(),\n+                      s = if variant.fields.len() == 1 {\"\"} else {\"s\"});\n+            on_error();\n         }\n     }\n "}, {"sha": "8daa16180a90515883f2b76516569e62503bb7fa", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 135, "deletions": 124, "changes": 259, "blob_url": "https://github.com/rust-lang/rust/blob/f93aaf84cb50dfaaba44b08c05bd51320263f592/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f93aaf84cb50dfaaba44b08c05bd51320263f592/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=f93aaf84cb50dfaaba44b08c05bd51320263f592", "patch": "@@ -84,7 +84,7 @@ use astconv::{AstConv, ast_region_to_region, PathParamMode};\n use dep_graph::DepNode;\n use fmt_macros::{Parser, Piece, Position};\n use middle::cstore::LOCAL_CRATE;\n-use hir::def::{self, Def};\n+use hir::def::{Def, PathResolution};\n use hir::def_id::DefId;\n use hir::pat_util;\n use rustc::infer::{self, InferCtxt, InferOk, TypeOrigin, TypeTrace, type_variable};\n@@ -1621,64 +1621,32 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     ///\n     /// Note that this function is only intended to be used with type-paths,\n     /// not with value-paths.\n-    pub fn instantiate_type(&self,\n-                            did: DefId,\n-                            path: &hir::Path)\n-                            -> Ty<'tcx>\n-    {\n-        debug!(\"instantiate_type(did={:?}, path={:?})\", did, path);\n-        let type_scheme =\n-            self.tcx.lookup_item_type(did);\n-        let type_predicates =\n-            self.tcx.lookup_predicates(did);\n+    pub fn instantiate_type_path(&self,\n+                                 did: DefId,\n+                                 path: &hir::Path,\n+                                 node_id: ast::NodeId)\n+                                 -> Ty<'tcx> {\n+        debug!(\"instantiate_type_path(did={:?}, path={:?})\", did, path);\n+        let type_scheme = self.tcx.lookup_item_type(did);\n+        let type_predicates = self.tcx.lookup_predicates(did);\n         let substs = AstConv::ast_path_substs_for_ty(self, self,\n                                                      path.span,\n                                                      PathParamMode::Optional,\n                                                      &type_scheme.generics,\n                                                      path.segments.last().unwrap());\n-        debug!(\"instantiate_type: ty={:?} substs={:?}\", &type_scheme.ty, &substs);\n-        let bounds =\n-            self.instantiate_bounds(path.span, &substs, &type_predicates);\n-        self.add_obligations_for_parameters(\n-            traits::ObligationCause::new(\n-                path.span,\n-                self.body_id,\n-                traits::ItemObligation(did)),\n-            &bounds);\n-\n-        self.instantiate_type_scheme(path.span, &substs, &type_scheme.ty)\n-    }\n-\n-    /// Return the dict-like variant corresponding to a given `Def`.\n-    pub fn def_struct_variant(&self,\n-                              def: Def,\n-                              _span: Span)\n-                              -> Option<(ty::AdtDef<'tcx>, ty::VariantDef<'tcx>)>\n-    {\n-        let (adt, variant) = match def {\n-            Def::Variant(enum_id, variant_id) => {\n-                let adt = self.tcx.lookup_adt_def(enum_id);\n-                (adt, adt.variant_with_id(variant_id))\n-            }\n-            Def::Struct(did) | Def::TyAlias(did) => {\n-                let typ = self.tcx.lookup_item_type(did);\n-                if let ty::TyStruct(adt, _) = typ.ty.sty {\n-                    (adt, adt.struct_variant())\n-                } else {\n-                    return None;\n-                }\n-            }\n-            _ => return None\n-        };\n+        let substs = self.tcx.mk_substs(substs);\n+        debug!(\"instantiate_type_path: ty={:?} substs={:?}\", &type_scheme.ty, substs);\n+        let bounds = self.instantiate_bounds(path.span, substs, &type_predicates);\n+        let cause = traits::ObligationCause::new(path.span, self.body_id,\n+                                                 traits::ItemObligation(did));\n+        self.add_obligations_for_parameters(cause, &bounds);\n \n-        let var_kind = variant.kind();\n-        if var_kind == ty::VariantKind::Struct {\n-            Some((adt, variant))\n-        } else if var_kind == ty::VariantKind::Unit {\n-             Some((adt, variant))\n-         } else {\n-             None\n-         }\n+        let ty_substituted = self.instantiate_type_scheme(path.span, substs, &type_scheme.ty);\n+        self.write_ty(node_id, ty_substituted);\n+        self.write_substs(node_id, ty::ItemSubsts {\n+            substs: substs\n+        });\n+        ty_substituted\n     }\n \n     pub fn write_nil(&self, node_id: ast::NodeId) {\n@@ -2998,7 +2966,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         while let Some((base_t, autoderefs)) = autoderef.next() {\n             let field = match base_t.sty {\n                 ty::TyStruct(base_def, substs) => {\n-                    tuple_like = base_def.struct_variant().is_tuple_struct();\n+                    tuple_like = base_def.struct_variant().kind == ty::VariantKind::Tuple;\n                     if !tuple_like { continue }\n \n                     debug!(\"tuple struct named {:?}\",  base_t);\n@@ -3153,35 +3121,57 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n+    pub fn check_struct_path(&self,\n+                         path: &hir::Path,\n+                         node_id: ast::NodeId,\n+                         span: Span)\n+                         -> Option<(ty::VariantDef<'tcx>,  Ty<'tcx>)> {\n+        let def = self.finish_resolving_struct_path(path, node_id, span);\n+        let variant = match def {\n+            Def::Err => {\n+                self.set_tainted_by_errors();\n+                return None;\n+            }\n+            Def::Variant(..) | Def::Struct(..) => {\n+                Some(self.tcx.expect_variant_def(def))\n+            }\n+            Def::TyAlias(did) | Def::AssociatedTy(_, did) => {\n+                if let Some(&ty::TyStruct(adt, _)) = self.tcx.opt_lookup_item_type(did)\n+                                                             .map(|scheme| &scheme.ty.sty) {\n+                    Some(adt.struct_variant())\n+                } else {\n+                    None\n+                }\n+            }\n+            _ => None\n+        };\n+        if variant.is_none() || variant.unwrap().kind == ty::VariantKind::Tuple {\n+            // Reject tuple structs for now, braced and unit structs are allowed.\n+            span_err!(self.tcx.sess, span, E0071,\n+                      \"`{}` does not name a struct or a struct variant\",\n+                      pprust::path_to_string(path));\n+            return None;\n+        }\n+\n+        let ty = self.instantiate_type_path(def.def_id(), path, node_id);\n+        Some((variant.unwrap(), ty))\n+    }\n+\n     fn check_expr_struct(&self,\n                          expr: &hir::Expr,\n                          path: &hir::Path,\n                          fields: &'gcx [hir::Field],\n                          base_expr: &'gcx Option<P<hir::Expr>>)\n     {\n-        let tcx = self.tcx;\n-\n         // Find the relevant variant\n-        let def = tcx.expect_def(expr.id);\n-        if def == Def::Err {\n-            self.set_tainted_by_errors();\n+        let (variant, expr_ty) = if let Some(variant_ty) = self.check_struct_path(path, expr.id,\n+                                                                                  expr.span) {\n+            variant_ty\n+        } else {\n             self.check_struct_fields_on_error(expr.id, fields, base_expr);\n             return;\n-        }\n-        let variant = match self.def_struct_variant(def, path.span) {\n-            Some((_, variant)) => variant,\n-            None => {\n-                span_err!(self.tcx.sess, path.span, E0071,\n-                          \"`{}` does not name a structure\",\n-                          pprust::path_to_string(path));\n-                self.check_struct_fields_on_error(expr.id, fields, base_expr);\n-                return;\n-            }\n         };\n \n-        let expr_ty = self.instantiate_type(def.def_id(), path);\n-        self.write_ty(expr.id, expr_ty);\n-\n         self.check_expr_struct_fields(expr_ty, path.span, variant, fields,\n                                       base_expr.is_none());\n         if let &Some(ref base_expr) = base_expr {\n@@ -3192,13 +3182,13 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         expr.id,\n                         adt.struct_variant().fields.iter().map(|f| {\n                             self.normalize_associated_types_in(\n-                                expr.span, &f.ty(tcx, substs)\n+                                expr.span, &f.ty(self.tcx, substs)\n                             )\n                         }).collect()\n                     );\n                 }\n                 _ => {\n-                    span_err!(tcx.sess, base_expr.span, E0436,\n+                    span_err!(self.tcx.sess, base_expr.span, E0436,\n                               \"functional record update syntax requires a struct\");\n                 }\n             }\n@@ -3349,24 +3339,18 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             };\n             self.write_ty(id, oprnd_t);\n           }\n-          hir::ExprPath(ref maybe_qself, ref path) => {\n-              let opt_self_ty = maybe_qself.as_ref().map(|qself| {\n-                  self.to_ty(&qself.ty)\n-              });\n-\n-              let path_res = tcx.expect_resolution(id);\n-              if let Some((opt_ty, segments, def)) =\n-                      self.resolve_ty_and_def_ufcs(path_res, opt_self_ty, path,\n-                                                   expr.span, expr.id) {\n-                  if def != Def::Err {\n-                      let (scheme, predicates) = self.type_scheme_and_predicates_for_def(expr.span,\n-                                                                                         def);\n-                      self.instantiate_path(segments, scheme, &predicates,\n-                                            opt_ty, def, expr.span, id);\n-                  } else {\n-                      self.set_tainted_by_errors();\n-                      self.write_ty(id, self.tcx.types.err);\n-                  }\n+          hir::ExprPath(ref opt_qself, ref path) => {\n+              let opt_self_ty = opt_qself.as_ref().map(|qself| self.to_ty(&qself.ty));\n+              let (def, opt_ty, segments) = self.resolve_ty_and_def_ufcs(opt_self_ty, path,\n+                                                                         expr.id, expr.span);\n+              if def != Def::Err {\n+                  let (scheme, predicates) = self.type_scheme_and_predicates_for_def(expr.span,\n+                                                                                     def);\n+                  self.instantiate_value_path(segments, scheme, &predicates,\n+                                              opt_ty, def, expr.span, id);\n+              } else {\n+                  self.set_tainted_by_errors();\n+                  self.write_error(id);\n               }\n \n               // We always require that the type provided as the value for\n@@ -3704,37 +3688,67 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                expected);\n     }\n \n+    // Finish resolving a path in a struct expression or pattern `S::A { .. }` if necessary.\n+    // The newly resolved definition is written into `def_map`.\n+    pub fn finish_resolving_struct_path(&self,\n+                                        path: &hir::Path,\n+                                        node_id: ast::NodeId,\n+                                        span: Span)\n+                                        -> Def\n+    {\n+        let path_res = self.tcx().expect_resolution(node_id);\n+        if path_res.depth == 0 {\n+            // If fully resolved already, we don't have to do anything.\n+            path_res.base_def\n+        } else {\n+            let base_ty_end = path.segments.len() - path_res.depth;\n+            let (_ty, def) = AstConv::finish_resolving_def_to_ty(self, self, span,\n+                                                                 PathParamMode::Optional,\n+                                                                 path_res.base_def,\n+                                                                 None,\n+                                                                 node_id,\n+                                                                 &path.segments[..base_ty_end],\n+                                                                 &path.segments[base_ty_end..]);\n+            // Write back the new resolution.\n+            self.tcx().def_map.borrow_mut().insert(node_id, PathResolution::new(def));\n+            def\n+        }\n+    }\n+\n+    // Resolve associated value path into a base type and associated constant or method definition.\n+    // The newly resolved definition is written into `def_map`.\n     pub fn resolve_ty_and_def_ufcs<'b>(&self,\n-                                       path_res: def::PathResolution,\n                                        opt_self_ty: Option<Ty<'tcx>>,\n                                        path: &'b hir::Path,\n-                                       span: Span,\n-                                       node_id: ast::NodeId)\n-                                       -> Option<(Option<Ty<'tcx>>, &'b [hir::PathSegment], Def)>\n+                                       node_id: ast::NodeId,\n+                                       span: Span)\n+                                       -> (Def, Option<Ty<'tcx>>, &'b [hir::PathSegment])\n     {\n-\n-        // If fully resolved already, we don't have to do anything.\n+        let path_res = self.tcx().expect_resolution(node_id);\n         if path_res.depth == 0 {\n-            Some((opt_self_ty, &path.segments, path_res.base_def))\n+            // If fully resolved already, we don't have to do anything.\n+            (path_res.base_def, opt_self_ty, &path.segments)\n         } else {\n-            let def = path_res.base_def;\n+            // Try to resolve everything except for the last segment as a type.\n             let ty_segments = path.segments.split_last().unwrap().1;\n             let base_ty_end = path.segments.len() - path_res.depth;\n             let (ty, _def) = AstConv::finish_resolving_def_to_ty(self, self, span,\n                                                                  PathParamMode::Optional,\n-                                                                 def,\n+                                                                 path_res.base_def,\n                                                                  opt_self_ty,\n                                                                  node_id,\n                                                                  &ty_segments[..base_ty_end],\n                                                                  &ty_segments[base_ty_end..]);\n+\n+            // Resolve an associated constant or method on the previously resolved type.\n             let item_segment = path.segments.last().unwrap();\n             let item_name = item_segment.name;\n             let def = match self.resolve_ufcs(span, item_name, ty, node_id) {\n-                Ok(def) => Some(def),\n+                Ok(def) => def,\n                 Err(error) => {\n                     let def = match error {\n-                        method::MethodError::PrivateMatch(def) => Some(def),\n-                        _ => None,\n+                        method::MethodError::PrivateMatch(def) => def,\n+                        _ => Def::Err,\n                     };\n                     if item_name != keywords::Invalid.name() {\n                         self.report_method_error(span, ty, item_name, None, error);\n@@ -3743,14 +3757,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 }\n             };\n \n-            if let Some(def) = def {\n-                // Write back the new resolution.\n-                self.tcx().def_map.borrow_mut().insert(node_id, def::PathResolution::new(def));\n-                Some((Some(ty), slice::ref_slice(item_segment), def))\n-            } else {\n-                self.write_error(node_id);\n-                None\n-            }\n+            // Write back the new resolution.\n+            self.tcx().def_map.borrow_mut().insert(node_id, PathResolution::new(def));\n+            (def, Some(ty), slice::ref_slice(item_segment))\n         }\n     }\n \n@@ -3986,15 +3995,16 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n     // Instantiates the given path, which must refer to an item with the given\n     // number of type parameters and type.\n-    pub fn instantiate_path(&self,\n-                            segments: &[hir::PathSegment],\n-                            type_scheme: TypeScheme<'tcx>,\n-                            type_predicates: &ty::GenericPredicates<'tcx>,\n-                            opt_self_ty: Option<Ty<'tcx>>,\n-                            def: Def,\n-                            span: Span,\n-                            node_id: ast::NodeId) {\n-        debug!(\"instantiate_path(path={:?}, def={:?}, node_id={}, type_scheme={:?})\",\n+    pub fn instantiate_value_path(&self,\n+                                  segments: &[hir::PathSegment],\n+                                  type_scheme: TypeScheme<'tcx>,\n+                                  type_predicates: &ty::GenericPredicates<'tcx>,\n+                                  opt_self_ty: Option<Ty<'tcx>>,\n+                                  def: Def,\n+                                  span: Span,\n+                                  node_id: ast::NodeId)\n+                                  -> Ty<'tcx> {\n+        debug!(\"instantiate_value_path(path={:?}, def={:?}, node_id={}, type_scheme={:?})\",\n                segments,\n                def,\n                node_id,\n@@ -4023,7 +4033,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         //    actually pass through this function, but rather the\n         //    `ast_ty_to_ty` function in `astconv`. However, in the case\n         //    of struct patterns (and maybe literals) we do invoke\n-        //    `instantiate_path` to get the general type of an instance of\n+        //    `instantiate_value_path` to get the general type of an instance of\n         //    a struct. (In these cases, there are actually no type\n         //    parameters permitted at present, but perhaps we will allow\n         //    them in the future.)\n@@ -4246,20 +4256,21 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 }\n                 Err(_) => {\n                     span_bug!(span,\n-                        \"instantiate_path: (UFCS) {:?} was a subtype of {:?} but now is not?\",\n+                        \"instantiate_value_path: (UFCS) {:?} was a subtype of {:?} but now is not?\",\n                         self_ty,\n                         impl_ty);\n                 }\n             }\n         }\n \n-        debug!(\"instantiate_path: type of {:?} is {:?}\",\n+        debug!(\"instantiate_value_path: type of {:?} is {:?}\",\n                node_id,\n                ty_substituted);\n         self.write_ty(node_id, ty_substituted);\n         self.write_substs(node_id, ty::ItemSubsts {\n             substs: substs\n         });\n+        ty_substituted\n     }\n \n     /// Finds the parameters that the user provided and adds them to `substs`. If too many"}, {"sha": "41e7a467fa33a89ff80aa890306ccdaf63d1b511", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f93aaf84cb50dfaaba44b08c05bd51320263f592/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f93aaf84cb50dfaaba44b08c05bd51320263f592/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=f93aaf84cb50dfaaba44b08c05bd51320263f592", "patch": "@@ -949,7 +949,7 @@ fn convert_variant_ctor<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                   scheme: ty::TypeScheme<'tcx>,\n                                   predicates: ty::GenericPredicates<'tcx>) {\n     let tcx = ccx.tcx;\n-    let ctor_ty = match variant.kind() {\n+    let ctor_ty = match variant.kind {\n         VariantKind::Unit | VariantKind::Struct => scheme.ty,\n         VariantKind::Tuple => {\n             let inputs: Vec<_> =\n@@ -1040,15 +1040,17 @@ fn convert_struct_def<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                 def: &hir::VariantData)\n                                 -> ty::AdtDefMaster<'tcx>\n {\n-\n     let did = ccx.tcx.map.local_def_id(it.id);\n-    let ctor_id = if !def.is_struct() {\n-        ccx.tcx.map.local_def_id(def.id())\n-    } else {\n-        did\n-    };\n-    ccx.tcx.intern_adt_def(did, ty::AdtKind::Struct,\n-        vec![convert_struct_variant(ccx, ctor_id, it.name, ConstInt::Infer(0), def)])\n+    // Use separate constructor id for unit/tuple structs and reuse did for braced structs.\n+    let ctor_id = if !def.is_struct() { Some(ccx.tcx.map.local_def_id(def.id())) } else { None };\n+    let variants = vec![convert_struct_variant(ccx, ctor_id.unwrap_or(did), it.name,\n+                                               ConstInt::Infer(0), def)];\n+    let adt = ccx.tcx.intern_adt_def(did, ty::AdtKind::Struct, variants);\n+    if let Some(ctor_id) = ctor_id {\n+        // Make adt definition available through constructor id as well.\n+        ccx.tcx.insert_adt_def(ctor_id, adt);\n+    }\n+    adt\n }\n \n     fn evaluate_disr_expr(ccx: &CrateCtxt, repr_ty: attr::IntType, e: &hir::Expr)"}, {"sha": "8769bc1a32b5080856297c7f7928c14e8b3eeb32", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 63, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/f93aaf84cb50dfaaba44b08c05bd51320263f592/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f93aaf84cb50dfaaba44b08c05bd51320263f592/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=f93aaf84cb50dfaaba44b08c05bd51320263f592", "patch": "@@ -1895,33 +1895,6 @@ fn my_start(argc: isize, argv: *const *const u8) -> isize {\n ```\n \"##,\n \n-E0163: r##\"\n-This error means that an attempt was made to match an enum variant as a\n-struct type when the variant isn't a struct type:\n-\n-```compile_fail\n-enum Foo { B(u32) }\n-\n-fn bar(foo: Foo) -> u32 {\n-    match foo {\n-        B{i} => i, // error E0163\n-    }\n-}\n-```\n-\n-Try using `()` instead:\n-\n-```\n-enum Foo { B(u32) }\n-\n-fn bar(foo: Foo) -> u32 {\n-    match foo {\n-        Foo::B(i) => i,\n-    }\n-}\n-```\n-\"##,\n-\n E0164: r##\"\n This error means that an attempt was made to match a struct type enum\n variant as a non-struct type:\n@@ -3225,42 +3198,6 @@ impl Foo for Bar {\n ```\n \"##,\n \n-E0327: r##\"\n-You cannot use associated items other than constant items as patterns. This\n-includes method items. Example of erroneous code:\n-\n-```compile_fail\n-enum B {}\n-\n-impl B {\n-    fn bb() -> i32 { 0 }\n-}\n-\n-fn main() {\n-    match 0 {\n-        B::bb => {} // error: associated items in match patterns must\n-                    // be constants\n-    }\n-}\n-```\n-\n-Please check that you're not using a method as a pattern. Example:\n-\n-```\n-enum B {\n-    ba,\n-    bb\n-}\n-\n-fn main() {\n-    match B::ba {\n-        B::bb => {} // ok!\n-        _ => {}\n-    }\n-}\n-```\n-\"##,\n-\n E0329: r##\"\n An attempt was made to access an associated constant through either a generic\n type parameter or `Self`. This is not supported yet. An example causing this\n@@ -4106,6 +4043,7 @@ register_diagnostics! {\n //  E0129,\n //  E0141,\n //  E0159, // use of trait `{}` as struct constructor\n+//  E0163, // merged into E0071\n     E0167,\n //  E0168,\n //  E0173, // manual implementations of unboxed closure traits are experimental\n@@ -4162,4 +4100,5 @@ register_diagnostics! {\n     E0527, // expected {} elements, found {}\n     E0528, // expected at least {} elements, found {}\n     E0529, // slice pattern expects array or slice, not `{}`\n+    E0533, // `{}` does not name a unit variant, unit struct or a constant\n }"}, {"sha": "7da17b3749104ecff45962ead1407cb111076556", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f93aaf84cb50dfaaba44b08c05bd51320263f592/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f93aaf84cb50dfaaba44b08c05bd51320263f592/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=f93aaf84cb50dfaaba44b08c05bd51320263f592", "patch": "@@ -1904,7 +1904,7 @@ impl Clean<Item> for doctree::Variant {\n \n impl<'tcx> Clean<Item> for ty::VariantDefData<'tcx, 'static> {\n     fn clean(&self, cx: &DocContext) -> Item {\n-        let kind = match self.kind() {\n+        let kind = match self.kind {\n             ty::VariantKind::Unit => CLikeVariant,\n             ty::VariantKind::Tuple => {\n                 TupleVariant(\n@@ -2578,9 +2578,9 @@ fn name_from_pat(p: &hir::Pat) -> String {\n     match p.node {\n         PatKind::Wild => \"_\".to_string(),\n         PatKind::Binding(_, ref p, _) => p.node.to_string(),\n-        PatKind::TupleStruct(ref p, _, _) | PatKind::Path(ref p) => path_to_string(p),\n-        PatKind::QPath(..) => panic!(\"tried to get argument name from PatKind::QPath, \\\n-                                which is not allowed in function arguments\"),\n+        PatKind::TupleStruct(ref p, _, _) | PatKind::Path(None, ref p) => path_to_string(p),\n+        PatKind::Path(..) => panic!(\"tried to get argument name from qualified PatKind::Path, \\\n+                                     which is not allowed in function arguments\"),\n         PatKind::Struct(ref name, ref fields, etc) => {\n             format!(\"{} {{ {}{} }}\", path_to_string(name),\n                 fields.iter().map(|&Spanned { node: ref fp, .. }|\n@@ -2653,7 +2653,7 @@ fn resolve_type(cx: &DocContext,\n         Def::SelfTy(..) if path.segments.len() == 1 => {\n             return Generic(keywords::SelfType.name().to_string());\n         }\n-        Def::SelfTy(..) | Def::TyParam(..) => true,\n+        Def::SelfTy(..) | Def::TyParam(..) | Def::AssociatedTy(..) => true,\n         _ => false,\n     };\n     let did = register_def(&*cx, def);"}, {"sha": "3c32cb947b382f1107473fd6d81d0437c0ca927e", "filename": "src/test/compile-fail-fulldeps/issue-18986.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f93aaf84cb50dfaaba44b08c05bd51320263f592/src%2Ftest%2Fcompile-fail-fulldeps%2Fissue-18986.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f93aaf84cb50dfaaba44b08c05bd51320263f592/src%2Ftest%2Fcompile-fail-fulldeps%2Fissue-18986.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fissue-18986.rs?ref=f93aaf84cb50dfaaba44b08c05bd51320263f592", "patch": "@@ -16,6 +16,5 @@ pub use use_from_trait_xc::Trait;\n fn main() {\n     match () {\n         Trait { x: 42 } => () //~ ERROR expected variant, struct or type alias, found trait `Trait`\n-        //~^ ERROR `Trait` does not name a struct or a struct variant\n     }\n }"}, {"sha": "1049bcd15644fcdd87d25ddec4475fb05263f94f", "filename": "src/test/compile-fail/auxiliary/lint_stability.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f93aaf84cb50dfaaba44b08c05bd51320263f592/src%2Ftest%2Fcompile-fail%2Fauxiliary%2Flint_stability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f93aaf84cb50dfaaba44b08c05bd51320263f592/src%2Ftest%2Fcompile-fail%2Fauxiliary%2Flint_stability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fauxiliary%2Flint_stability.rs?ref=f93aaf84cb50dfaaba44b08c05bd51320263f592", "patch": "@@ -10,6 +10,7 @@\n #![crate_name=\"lint_stability\"]\n #![crate_type = \"lib\"]\n #![feature(staged_api)]\n+#![feature(associated_type_defaults)]\n #![stable(feature = \"lint_stability\", since = \"1.0.0\")]\n \n #[stable(feature = \"test_feature\", since = \"1.0.0\")]\n@@ -92,6 +93,15 @@ pub trait Trait {\n     fn trait_stable_text(&self) {}\n }\n \n+#[stable(feature = \"test_feature\", since = \"1.0.0\")]\n+pub trait TraitWithAssociatedTypes {\n+    #[unstable(feature = \"test_feature\", issue = \"0\")]\n+    type TypeUnstable = u8;\n+    #[stable(feature = \"test_feature\", since = \"1.0.0\")]\n+    #[rustc_deprecated(since = \"1.0.0\", reason = \"text\")]\n+    type TypeDeprecated = u8;\n+}\n+\n #[stable(feature = \"test_feature\", since = \"1.0.0\")]\n impl Trait for MethodTester {}\n "}, {"sha": "74546152ca90fcf77b85c1742cd89768820c8e27", "filename": "src/test/compile-fail/empty-struct-braces-pat-1.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f93aaf84cb50dfaaba44b08c05bd51320263f592/src%2Ftest%2Fcompile-fail%2Fempty-struct-braces-pat-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f93aaf84cb50dfaaba44b08c05bd51320263f592/src%2Ftest%2Fcompile-fail%2Fempty-struct-braces-pat-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fempty-struct-braces-pat-1.rs?ref=f93aaf84cb50dfaaba44b08c05bd51320263f592", "patch": "@@ -31,12 +31,14 @@ fn main() {\n         Empty1 => () // Not an error, `Empty1` is interpreted as a new binding\n     }\n     match e3 {\n-        E::Empty3 => () //~ ERROR `E::Empty3` does not name a tuple variant or a tuple struct\n+        E::Empty3 => ()\n+        //~^ ERROR `E::Empty3` does not name a unit variant, unit struct or a constant\n     }\n     match xe1 {\n         XEmpty1 => () // Not an error, `XEmpty1` is interpreted as a new binding\n     }\n     match xe3 {\n-        XE::XEmpty3 => () //~ ERROR `XE::XEmpty3` does not name a tuple variant or a tuple struct\n+        XE::XEmpty3 => ()\n+        //~^ ERROR `XE::XEmpty3` does not name a unit variant, unit struct or a constant\n     }\n }"}, {"sha": "671232e701f872b33721803aba16349e5ca33ed1", "filename": "src/test/compile-fail/issue-16058.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f93aaf84cb50dfaaba44b08c05bd51320263f592/src%2Ftest%2Fcompile-fail%2Fissue-16058.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f93aaf84cb50dfaaba44b08c05bd51320263f592/src%2Ftest%2Fcompile-fail%2Fissue-16058.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-16058.rs?ref=f93aaf84cb50dfaaba44b08c05bd51320263f592", "patch": "@@ -16,7 +16,7 @@ pub struct GslResult {\n \n impl GslResult {\n     pub fn new() -> GslResult {\n-        Result { //~ ERROR: `Result` does not name a structure\n+        Result { //~ ERROR: `Result` does not name a struct or a struct variant\n             val: 0f64,\n             err: 0f64\n         }"}, {"sha": "218f68714ff929821d1f9b5a975fa7ea0634afd8", "filename": "src/test/compile-fail/issue-17001.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f93aaf84cb50dfaaba44b08c05bd51320263f592/src%2Ftest%2Fcompile-fail%2Fissue-17001.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f93aaf84cb50dfaaba44b08c05bd51320263f592/src%2Ftest%2Fcompile-fail%2Fissue-17001.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17001.rs?ref=f93aaf84cb50dfaaba44b08c05bd51320263f592", "patch": "@@ -11,5 +11,5 @@\n mod foo {}\n \n fn main() {\n-    let p = foo { x: () }; //~ ERROR `foo` does not name a structure\n+    let p = foo { x: () }; //~ ERROR `foo` does not name a struct or a struct variant\n }"}, {"sha": "2f2c252b947c90f38994c142985e6ae3fdd8cdb1", "filename": "src/test/compile-fail/issue-17405.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f93aaf84cb50dfaaba44b08c05bd51320263f592/src%2Ftest%2Fcompile-fail%2Fissue-17405.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f93aaf84cb50dfaaba44b08c05bd51320263f592/src%2Ftest%2Fcompile-fail%2Fissue-17405.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17405.rs?ref=f93aaf84cb50dfaaba44b08c05bd51320263f592", "patch": "@@ -15,6 +15,5 @@ enum Foo {\n fn main() {\n     match Foo::Bar(1) {\n         Foo { i } => () //~ ERROR expected variant, struct or type alias, found enum `Foo`\n-        //~^ ERROR `Foo` does not name a struct or a struct variant\n     }\n }"}, {"sha": "090b8a0d16e64ca9a890fde406512ce8d22c82bb", "filename": "src/test/compile-fail/issue-21449.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f93aaf84cb50dfaaba44b08c05bd51320263f592/src%2Ftest%2Fcompile-fail%2Fissue-21449.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f93aaf84cb50dfaaba44b08c05bd51320263f592/src%2Ftest%2Fcompile-fail%2Fissue-21449.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-21449.rs?ref=f93aaf84cb50dfaaba44b08c05bd51320263f592", "patch": "@@ -11,5 +11,5 @@\n mod MyMod {}\n \n fn main() {\n-    let myVar = MyMod { T: 0 }; //~ ERROR `MyMod` does not name a structure\n+    let myVar = MyMod { T: 0 }; //~ ERROR `MyMod` does not name a struct or a struct variant\n }"}, {"sha": "afb972faaca0ef71c24ad9d3dfab828e16da98ca", "filename": "src/test/compile-fail/issue-22933-1.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/f93aaf84cb50dfaaba44b08c05bd51320263f592/src%2Ftest%2Fcompile-fail%2Fissue-22933-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f93aaf84cb50dfaaba44b08c05bd51320263f592/src%2Ftest%2Fcompile-fail%2Fissue-22933-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-22933-1.rs?ref=f93aaf84cb50dfaaba44b08c05bd51320263f592", "patch": "@@ -0,0 +1,35 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(rustc_attrs)]\n+#![allow(warnings)]\n+\n+struct CNFParser {\n+    token: char,\n+}\n+\n+impl CNFParser {\n+    fn is_whitespace(c: char) -> bool {\n+        c == ' ' || c == '\\n'\n+    }\n+\n+    fn consume_whitespace(&mut self) {\n+        self.consume_while(&(CNFParser::is_whitespace))\n+    }\n+\n+    fn consume_while(&mut self, p: &Fn(char) -> bool) {\n+        while p(self.token) {\n+            return\n+        }\n+    }\n+}\n+\n+#[rustc_error]\n+fn main() {} //~ ERROR compilation successful"}, {"sha": "7d619c270d32b962913e7999a206a1c0fa38762a", "filename": "src/test/compile-fail/issue-22933-2.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/f93aaf84cb50dfaaba44b08c05bd51320263f592/src%2Ftest%2Fcompile-fail%2Fissue-22933-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f93aaf84cb50dfaaba44b08c05bd51320263f592/src%2Ftest%2Fcompile-fail%2Fissue-22933-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-22933-2.rs?ref=f93aaf84cb50dfaaba44b08c05bd51320263f592", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+enum Delicious {\n+    Pie      = 0x1,\n+    Apple    = 0x2,\n+    ApplePie = Delicious::Apple as isize | Delicious::PIE as isize,\n+    //~^ ERROR constant evaluation error: unresolved path in constant expression\n+}\n+\n+const FOO: [u32; u8::MIN as usize] = [];\n+//~^ ERROR array length constant evaluation error: unresolved path in constant expression\n+\n+fn main() {}"}, {"sha": "24b39eeff0f791c0e3508e77c6e99e82d11ec383", "filename": "src/test/compile-fail/issue-26459.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f93aaf84cb50dfaaba44b08c05bd51320263f592/src%2Ftest%2Fcompile-fail%2Fissue-26459.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f93aaf84cb50dfaaba44b08c05bd51320263f592/src%2Ftest%2Fcompile-fail%2Fissue-26459.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-26459.rs?ref=f93aaf84cb50dfaaba44b08c05bd51320263f592", "patch": "@@ -12,6 +12,5 @@ fn main() {\n     match 'a' {\n         char{ch} => true\n         //~^ ERROR expected variant, struct or type alias, found builtin type `char`\n-        //~| ERROR `char` does not name a struct or a struct variant\n     };\n }"}, {"sha": "7a329bac61b22f64a0fa2eee6b1c512423005833", "filename": "src/test/compile-fail/issue-27815.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f93aaf84cb50dfaaba44b08c05bd51320263f592/src%2Ftest%2Fcompile-fail%2Fissue-27815.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f93aaf84cb50dfaaba44b08c05bd51320263f592/src%2Ftest%2Fcompile-fail%2Fissue-27815.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-27815.rs?ref=f93aaf84cb50dfaaba44b08c05bd51320263f592", "patch": "@@ -11,12 +11,10 @@\n mod A {}\n \n fn main() {\n-    let u = A { x: 1 }; //~ ERROR `A` does not name a structure\n-    let v = u32 { x: 1 }; //~ ERROR `u32` does not name a structure\n+    let u = A { x: 1 }; //~ ERROR `A` does not name a struct or a struct variant\n+    let v = u32 { x: 1 }; //~ ERROR `u32` does not name a struct or a struct variant\n     match () {\n         A { x: 1 } => {} //~ ERROR expected variant, struct or type alias, found module `A`\n-        //~^ ERROR `A` does not name a struct or a struct variant\n         u32 { x: 1 } => {} //~ ERROR expected variant, struct or type alias, found builtin type `u32\n-        //~^ ERROR `u32` does not name a struct or a struct variant\n     }\n }"}, {"sha": "e20e6ea23198cd3c885fa4bea2d8d90ec4a94567", "filename": "src/test/compile-fail/issue-27831.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f93aaf84cb50dfaaba44b08c05bd51320263f592/src%2Ftest%2Fcompile-fail%2Fissue-27831.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f93aaf84cb50dfaaba44b08c05bd51320263f592/src%2Ftest%2Fcompile-fail%2Fissue-27831.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-27831.rs?ref=f93aaf84cb50dfaaba44b08c05bd51320263f592", "patch": "@@ -18,7 +18,7 @@ enum Enum {\n \n fn main() {\n     let x = Foo(1);\n-    Foo { ..x }; //~ ERROR `Foo` does not name a structure\n+    Foo { ..x }; //~ ERROR `Foo` does not name a struct or a struct variant\n     let Foo { .. } = x; //~ ERROR `Foo` does not name a struct\n \n     let x = Bar;"}, {"sha": "576451f7292a894c1b8606e94401e5893849723b", "filename": "src/test/compile-fail/issue-32004.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f93aaf84cb50dfaaba44b08c05bd51320263f592/src%2Ftest%2Fcompile-fail%2Fissue-32004.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f93aaf84cb50dfaaba44b08c05bd51320263f592/src%2Ftest%2Fcompile-fail%2Fissue-32004.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-32004.rs?ref=f93aaf84cb50dfaaba44b08c05bd51320263f592", "patch": "@@ -18,7 +18,7 @@ struct S;\n fn main() {\n     match Foo::Baz {\n         Foo::Bar => {}\n-        //~^ ERROR `Foo::Bar` does not name a tuple variant or a tuple struct\n+        //~^ ERROR `Foo::Bar` does not name a unit variant, unit struct or a constant\n         _ => {}\n     }\n "}, {"sha": "6fae18dec10a67e602338a3f15de815a623b1589", "filename": "src/test/compile-fail/issue-34209.rs", "status": "renamed", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f93aaf84cb50dfaaba44b08c05bd51320263f592/src%2Ftest%2Fcompile-fail%2Fissue-34209.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f93aaf84cb50dfaaba44b08c05bd51320263f592/src%2Ftest%2Fcompile-fail%2Fissue-34209.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-34209.rs?ref=f93aaf84cb50dfaaba44b08c05bd51320263f592", "patch": "@@ -8,13 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-enum Foo { B(u32) }\n+enum S {\n+    A,\n+}\n \n-fn bar(foo: Foo) -> u32 {\n-    match foo {\n-        Foo::B { i } => i, //~ ERROR E0163\n+fn bug(l: S) {\n+    match l {\n+        S::B{ } => { },\n+        //~^ ERROR ambiguous associated type; specify the type using the syntax `<S as Trait>::B`\n     }\n }\n \n-fn main() {\n-}\n+fn main () {}", "previous_filename": "src/test/compile-fail/E0163.rs"}, {"sha": "55983c672aa08a8553ce28932d2db5202f277b63", "filename": "src/test/compile-fail/issue-4736.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f93aaf84cb50dfaaba44b08c05bd51320263f592/src%2Ftest%2Fcompile-fail%2Fissue-4736.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f93aaf84cb50dfaaba44b08c05bd51320263f592/src%2Ftest%2Fcompile-fail%2Fissue-4736.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-4736.rs?ref=f93aaf84cb50dfaaba44b08c05bd51320263f592", "patch": "@@ -11,5 +11,5 @@\n struct NonCopyable(());\n \n fn main() {\n-    let z = NonCopyable{ p: () }; //~ ERROR `NonCopyable` does not name a structure\n+    let z = NonCopyable{ p: () }; //~ ERROR `NonCopyable` does not name a struct or a struct variant\n }"}, {"sha": "505a91f223cc6ceb99afb37edf5540b923105301", "filename": "src/test/compile-fail/lexical-scopes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f93aaf84cb50dfaaba44b08c05bd51320263f592/src%2Ftest%2Fcompile-fail%2Flexical-scopes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f93aaf84cb50dfaaba44b08c05bd51320263f592/src%2Ftest%2Fcompile-fail%2Flexical-scopes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flexical-scopes.rs?ref=f93aaf84cb50dfaaba44b08c05bd51320263f592", "patch": "@@ -10,7 +10,7 @@\n \n struct T { i: i32 }\n fn f<T>() {\n-    let t = T { i: 0 }; //~ ERROR `T` does not name a structure\n+    let t = T { i: 0 }; //~ ERROR `T` does not name a struct or a struct variant\n }\n \n mod Foo {"}, {"sha": "953cd4a2ff5eac744efb08592f9c7b13f58da167", "filename": "src/test/compile-fail/lint-stability.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f93aaf84cb50dfaaba44b08c05bd51320263f592/src%2Ftest%2Fcompile-fail%2Flint-stability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f93aaf84cb50dfaaba44b08c05bd51320263f592/src%2Ftest%2Fcompile-fail%2Flint-stability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-stability.rs?ref=f93aaf84cb50dfaaba44b08c05bd51320263f592", "patch": "@@ -128,6 +128,11 @@ mod cross_crate {\n         <Foo>::trait_stable_text(&foo);\n         <Foo as Trait>::trait_stable_text(&foo);\n \n+        struct S1<T: TraitWithAssociatedTypes>(T::TypeUnstable);\n+        //~^ ERROR use of unstable library feature\n+        struct S2<T: TraitWithAssociatedTypes>(T::TypeDeprecated);\n+        //~^ ERROR use of deprecated item\n+\n         let _ = DeprecatedStruct { //~ ERROR use of deprecated item\n             i: 0 //~ ERROR use of deprecated item\n         };"}, {"sha": "ef011c89c622ba184eb6e986834946681cb8165e", "filename": "src/test/compile-fail/method-path-in-pattern.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f93aaf84cb50dfaaba44b08c05bd51320263f592/src%2Ftest%2Fcompile-fail%2Fmethod-path-in-pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f93aaf84cb50dfaaba44b08c05bd51320263f592/src%2Ftest%2Fcompile-fail%2Fmethod-path-in-pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmethod-path-in-pattern.rs?ref=f93aaf84cb50dfaaba44b08c05bd51320263f592", "patch": "@@ -22,12 +22,13 @@ impl MyTrait for Foo {}\n \n fn main() {\n     match 0u32 {\n-        Foo::bar => {} //~ ERROR E0327\n+        Foo::bar => {} //~ ERROR `Foo::bar` does not name a unit variant, unit struct or a constant\n     }\n     match 0u32 {\n-        <Foo>::bar => {} //~ ERROR E0327\n+        <Foo>::bar => {} //~ ERROR `bar` does not name a unit variant, unit struct or a constant\n     }\n     match 0u32 {\n-        <Foo>::trait_bar => {} //~ ERROR E0327\n+        <Foo>::trait_bar => {}\n+        //~^ ERROR `trait_bar` does not name a unit variant, unit struct or a constant\n     }\n }"}, {"sha": "9034e24a6fee03fab57aa7f722658c8a72b806f5", "filename": "src/test/compile-fail/qualified-path-params.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f93aaf84cb50dfaaba44b08c05bd51320263f592/src%2Ftest%2Fcompile-fail%2Fqualified-path-params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f93aaf84cb50dfaaba44b08c05bd51320263f592/src%2Ftest%2Fcompile-fail%2Fqualified-path-params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fqualified-path-params.rs?ref=f93aaf84cb50dfaaba44b08c05bd51320263f592", "patch": "@@ -27,7 +27,8 @@ impl S {\n \n fn main() {\n     match 10 {\n-        <S as Tr>::A::f::<u8> => {} //~ ERROR associated items in match patterns must be constants\n+        <S as Tr>::A::f::<u8> => {}\n+        //~^ ERROR `Tr::A::f<u8>` does not name a unit variant, unit struct or a constant\n         0 ... <S as Tr>::A::f::<u8> => {} //~ ERROR only char and numeric types are allowed in range\n     }\n }"}, {"sha": "d3f840f4fe9763eb651926233624cab49be00b25", "filename": "src/test/compile-fail/struct-pat-associated-path.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/f93aaf84cb50dfaaba44b08c05bd51320263f592/src%2Ftest%2Fcompile-fail%2Fstruct-pat-associated-path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f93aaf84cb50dfaaba44b08c05bd51320263f592/src%2Ftest%2Fcompile-fail%2Fstruct-pat-associated-path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstruct-pat-associated-path.rs?ref=f93aaf84cb50dfaaba44b08c05bd51320263f592", "patch": "@@ -0,0 +1,37 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct S;\n+\n+trait Tr {\n+    type A;\n+}\n+\n+impl Tr for S {\n+    type A = S;\n+}\n+\n+fn f<T: Tr>() {\n+    match S {\n+        T::A {} => {} //~ ERROR `T::A` does not name a struct or a struct variant\n+    }\n+}\n+\n+fn g<T: Tr<A = S>>() {\n+    match S {\n+        T::A {} => {} //~ ERROR `T::A` does not name a struct or a struct variant\n+    }\n+}\n+\n+fn main() {\n+    match S {\n+        S::A {} => {} //~ ERROR ambiguous associated type\n+    }\n+}"}, {"sha": "13fdaa302f70a72ee0a800f21b42a93de4c9050d", "filename": "src/test/compile-fail/trait-as-struct-constructor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f93aaf84cb50dfaaba44b08c05bd51320263f592/src%2Ftest%2Fcompile-fail%2Ftrait-as-struct-constructor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f93aaf84cb50dfaaba44b08c05bd51320263f592/src%2Ftest%2Fcompile-fail%2Ftrait-as-struct-constructor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-as-struct-constructor.rs?ref=f93aaf84cb50dfaaba44b08c05bd51320263f592", "patch": "@@ -12,5 +12,5 @@ trait TraitNotAStruct {}\n \n fn main() {\n     TraitNotAStruct{ value: 0 };\n-    //~^ ERROR: `TraitNotAStruct` does not name a structure [E0071]\n+    //~^ ERROR: `TraitNotAStruct` does not name a struct or a struct variant [E0071]\n }"}]}