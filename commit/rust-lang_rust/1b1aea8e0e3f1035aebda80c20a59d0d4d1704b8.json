{"sha": "1b1aea8e0e3f1035aebda80c20a59d0d4d1704b8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFiMWFlYThlMGUzZjEwMzVhZWJkYTgwYzIwYTU5ZDBkNGQxNzA0Yjg=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-09-24T04:07:01Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-09-24T04:09:44Z"}, "message": "tutorial: Begin trying to improve the generics section", "tree": {"sha": "c3bd283353cc0c442499b17b8a1f9bff4be1e854", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c3bd283353cc0c442499b17b8a1f9bff4be1e854"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1b1aea8e0e3f1035aebda80c20a59d0d4d1704b8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1b1aea8e0e3f1035aebda80c20a59d0d4d1704b8", "html_url": "https://github.com/rust-lang/rust/commit/1b1aea8e0e3f1035aebda80c20a59d0d4d1704b8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1b1aea8e0e3f1035aebda80c20a59d0d4d1704b8/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8baed1f25f5fcec221dfd93e0c29b723725bcabe", "url": "https://api.github.com/repos/rust-lang/rust/commits/8baed1f25f5fcec221dfd93e0c29b723725bcabe", "html_url": "https://github.com/rust-lang/rust/commit/8baed1f25f5fcec221dfd93e0c29b723725bcabe"}], "stats": {"total": 130, "additions": 76, "deletions": 54}, "files": [{"sha": "fd19e7ef004dcfae731180d238e02272c2ceab26", "filename": "doc/tutorial.md", "status": "modified", "additions": 76, "deletions": 54, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/1b1aea8e0e3f1035aebda80c20a59d0d4d1704b8/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/1b1aea8e0e3f1035aebda80c20a59d0d4d1704b8/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=1b1aea8e0e3f1035aebda80c20a59d0d4d1704b8", "patch": "@@ -1528,12 +1528,9 @@ fn contains(v: &[int], elt: int) -> bool {\n \n # Generics\n \n-## Generic functions\n-\n Throughout this tutorial, we've been defining functions that act only on\n-single data types. It's a burden to define such functions again and again for\n-every type they apply to. Thus, Rust allows functions and datatypes to have\n-type parameters.\n+single data types. With type parameters we can also define functions that\n+may be invoked on multiple types.\n \n ~~~~\n fn map<T, U>(vector: &[T], function: fn(v: &T) -> U) -> ~[U] {\n@@ -1545,9 +1542,10 @@ fn map<T, U>(vector: &[T], function: fn(v: &T) -> U) -> ~[U] {\n }\n ~~~~\n \n-When defined with type parameters, this function can be applied to any\n-type of vector, as long as the type of `function`'s argument and the\n-type of the vector's content agree with each other.\n+When defined with type parameters, as denoted by `<T, U>`, this\n+function can be applied to any type of vector, as long as the type of\n+`function`'s argument and the type of the vector's content agree with\n+each other.\n \n Inside a generic function, the names of the type parameters\n (capitalized by convention) stand for opaque types. You can't look\n@@ -1558,11 +1556,12 @@ parameter `function()` is supplied with a pointer to a value of type\n function works with the broadest set of types possible, since some\n types are expensive or illegal to copy and pass by value.\n \n-## Generic datatypes\n-\n Generic `type`, `struct`, and `enum` declarations follow the same pattern:\n \n ~~~~\n+# use std::map::HashMap;\n+type Set<T> = HashMap<T, ()>;\n+\n struct Stack<T> {\n     elements: ~[mut T]\n }\n@@ -1573,89 +1572,112 @@ enum Maybe<T> {\n }\n ~~~~\n \n-These declarations produce valid types like `Stack<u8>` and `Maybe<int>`.\n+These declarations produce valid types like `Set<int>`, `Stack<int>`\n+and `Maybe<int>`.\n \n-## Kinds\n+## Traits\n \n Perhaps surprisingly, the 'copy' (duplicate) operation is not defined\n-for all Rust types. Resource types (classes with destructors) cannot be\n-copied, and neither can any type whose copying would require copying a\n-resource (such as records or unique boxes containing a resource).\n+for all Rust types. Types with user-defined destructors cannot be\n+copied, and neither can types that own other types containing\n+destructors.\n+\n+~~~\n+// Instances of this struct can't be copied, either implicitly\n+// or with the `copy` keyword\n+struct NotCopyable {\n+    foo: int,\n+\n+    drop { }\n+}\n+\n+// This owned box containing a NotCopyable is also not copyable\n+let not_copyable_box = ~NotCopyable { foo: 0 };\n+~~~\n \n This complicates handling of generic functions. If you have a type\n parameter `T`, can you copy values of that type? In Rust, you can't,\n-unless you explicitly declare that type parameter to have copyable\n-'kind'. A kind is a type of type.\n+unless you explicitly declare that type parameter to have the\n+_trait_ for copying, called `Copy`.\n \n ~~~~ {.ignore}\n // This does not compile\n-fn head_bad<T>(v: ~[T]) -> T { v[0] }\n+fn head_bad<T>(v: ~[T]) -> T {\n+    copy v[0] // Elements of type T aren't copyable\n+}\n+~~~~\n+\n+~~~~\n // This does\n-fn head<T: Copy>(v: ~[T]) -> T { v[0] }\n+fn head<T: Copy>(v: ~[T]) -> T {\n+   copy v[0]\n+}\n ~~~~\n \n When instantiating a generic function, you can only instantiate it\n-with types that fit its kinds. So you could not apply `head` to a\n-resource type. Rust has several kinds that can be used as type bounds:\n-\n-* `Copy` - Copyable types. All types are copyable unless they\n-  are classes with destructors or otherwise contain\n-  classes with destructors.\n-* `Send` - Sendable types. All types are sendable unless they\n-  contain shared boxes, closures, or other local-heap-allocated\n-  types.\n-* `Const` - Constant types. These are types that do not contain\n-  mutable fields nor shared boxes.\n-\n-> ***Note:*** Rust type kinds are syntactically very similar to\n-> [traits](#traits) when used as type bounds, and can be\n-> conveniently thought of as built-in traits. In the future type\n-> kinds will actually be traits that the compiler has special\n-> knowledge about.\n-\n-# Traits\n+with types that implement the correct traits. So you could not apply\n+`head` to a type with a destructor.\n+\n+While most traits can be defined and implemented by user code, three\n+traits are derived for all applicable types by the compiler, and may\n+not be overridden:\n+\n+* `Copy` - Types that can be copied, either implicitly, or using the\n+  `copy` expression. All types are copyable unless they are classes\n+  with destructors or otherwise contain classes with destructors.\n+\n+* `Send` - Sendable (owned) types. All types are sendable unless they\n+  contain managed boxes, managed closures, or otherwise managed\n+  types. Sendable types may or may not be copyable.\n+\n+* `Const` - Constant (immutable) types. These are types that do not contain\n+  mutable fields.\n+\n+> ***Note:*** These three traits were referred to as 'kinds' in earlier\n+> iterations of the language, and often still are.\n \n Traits are Rust's take on value polymorphism\u2014the thing that\n object-oriented languages tend to solve with methods and inheritance.\n For example, writing a function that can operate on multiple types of\n collections.\n \n-> ***Note:*** This feature is very new, and will need a few extensions to be\n-> applicable to more advanced use cases.\n-\n-## Declaration\n+## Declaring and implementing traits\n \n-A trait consists of a set of methods. A method is a function that\n+A trait consists of a set of methods, or may be empty, as is the case\n+with `Copy`, `Send`, and `Const`. A method is a function that\n can be applied to a `self` value and a number of arguments, using the\n dot notation: `self.foo(arg1, arg2)`.\n \n-For example, we could declare the trait `to_str` for things that\n-can be converted to a string, with a single method of the same name:\n+For example, we could declare the trait `Stringable` for things that\n+can be converted to a string, with a single method:\n \n ~~~~\n trait ToStr {\n-    fn to_str() -> ~str;\n+    fn to_str(self) -> ~str;\n }\n ~~~~\n \n-## Implementation\n-\n To actually implement a trait for a given type, the `impl` form\n-is used. This defines implementations of `to_str` for the `int` and\n+is used. This defines implementations of `ToStr` for the `int` and\n `~str` types.\n \n ~~~~\n-# trait ToStr { fn to_str() -> ~str; }\n+# // FIXME: This example is no good because you can't actually\n+# // implement your own .to_str for int and ~str\n+# trait ToStr { fn to_str(self) -> ~str; }\n impl int: ToStr {\n-    fn to_str() -> ~str { int::to_str(self, 10u) }\n+    fn to_str(self) -> ~str { int::to_str(self, 10u) }\n }\n impl ~str: ToStr {\n-    fn to_str() -> ~str { self }\n+    fn to_str(self) -> ~str { self }\n }\n+\n+# //1.to_str();\n+# //(~\"foo\").to_str();\n ~~~~\n \n-Given these, we may call `1.to_str()` to get `~\"1\"`, or\n-`(~\"foo\").to_str()` to get `~\"foo\"` again. This is basically a form of\n+Given these, we may call `1.to_str()` to get `\"1\"`, or\n+`(~\"foo\").to_str()` to get `\"foo\"` again. This is basically a form of\n static overloading\u2014when the Rust compiler sees the `to_str` method\n call, it looks for an implementation that matches the type with a\n method that matches the name, and simply calls that."}]}