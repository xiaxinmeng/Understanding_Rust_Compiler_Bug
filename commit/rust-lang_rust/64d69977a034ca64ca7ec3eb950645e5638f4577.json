{"sha": "64d69977a034ca64ca7ec3eb950645e5638f4577", "node_id": "C_kwDOAAsO6NoAKDY0ZDY5OTc3YTAzNGNhNjRjYTdlYzNlYjk1MDY0NWU1NjM4ZjQ1Nzc", "commit": {"author": {"name": "Noah Lev", "email": "camelidcamel@gmail.com", "date": "2021-11-13T04:19:10Z"}, "committer": {"name": "Noah Lev", "email": "camelidcamel@gmail.com", "date": "2021-11-17T15:53:01Z"}, "message": "rustdoc: Cleanup visibility cleaning some more\n\n* Remove outdated comment\n* Remove duplicated code\n* Extract helper function", "tree": {"sha": "11d5ba65a3672563d3f0f470c7a9c2ddc3034a72", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/11d5ba65a3672563d3f0f470c7a9c2ddc3034a72"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/64d69977a034ca64ca7ec3eb950645e5638f4577", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/64d69977a034ca64ca7ec3eb950645e5638f4577", "html_url": "https://github.com/rust-lang/rust/commit/64d69977a034ca64ca7ec3eb950645e5638f4577", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/64d69977a034ca64ca7ec3eb950645e5638f4577/comments", "author": {"login": "camelid", "id": 37223377, "node_id": "MDQ6VXNlcjM3MjIzMzc3", "avatar_url": "https://avatars.githubusercontent.com/u/37223377?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camelid", "html_url": "https://github.com/camelid", "followers_url": "https://api.github.com/users/camelid/followers", "following_url": "https://api.github.com/users/camelid/following{/other_user}", "gists_url": "https://api.github.com/users/camelid/gists{/gist_id}", "starred_url": "https://api.github.com/users/camelid/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camelid/subscriptions", "organizations_url": "https://api.github.com/users/camelid/orgs", "repos_url": "https://api.github.com/users/camelid/repos", "events_url": "https://api.github.com/users/camelid/events{/privacy}", "received_events_url": "https://api.github.com/users/camelid/received_events", "type": "User", "site_admin": false}, "committer": {"login": "camelid", "id": 37223377, "node_id": "MDQ6VXNlcjM3MjIzMzc3", "avatar_url": "https://avatars.githubusercontent.com/u/37223377?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camelid", "html_url": "https://github.com/camelid", "followers_url": "https://api.github.com/users/camelid/followers", "following_url": "https://api.github.com/users/camelid/following{/other_user}", "gists_url": "https://api.github.com/users/camelid/gists{/gist_id}", "starred_url": "https://api.github.com/users/camelid/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camelid/subscriptions", "organizations_url": "https://api.github.com/users/camelid/orgs", "repos_url": "https://api.github.com/users/camelid/repos", "events_url": "https://api.github.com/users/camelid/events{/privacy}", "received_events_url": "https://api.github.com/users/camelid/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "94ae60a2a381a143b926450ae5a8cc945c42efc0", "url": "https://api.github.com/repos/rust-lang/rust/commits/94ae60a2a381a143b926450ae5a8cc945c42efc0", "html_url": "https://github.com/rust-lang/rust/commit/94ae60a2a381a143b926450ae5a8cc945c42efc0"}], "stats": {"total": 83, "additions": 31, "deletions": 52}, "files": [{"sha": "9786c2a5e3d66929c0795ffe580d4f62d7d85225", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 31, "deletions": 52, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/64d69977a034ca64ca7ec3eb950645e5638f4577/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64d69977a034ca64ca7ec3eb950645e5638f4577/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=64d69977a034ca64ca7ec3eb950645e5638f4577", "patch": "@@ -1561,35 +1561,36 @@ impl<'tcx> Clean<Constant> for ty::Const<'tcx> {\n impl Clean<Item> for hir::FieldDef<'_> {\n     fn clean(&self, cx: &mut DocContext<'_>) -> Item {\n         let def_id = cx.tcx.hir().local_def_id(self.hir_id).to_def_id();\n-        let what_rustc_thinks = Item::from_def_id_and_parts(\n-            def_id,\n-            Some(self.ident.name),\n-            StructFieldItem(self.ty.clean(cx)),\n-            cx,\n-        );\n-        let parent = cx.tcx.parent(def_id).unwrap();\n-        match cx.tcx.def_kind(parent) {\n-            DefKind::Struct | DefKind::Union => what_rustc_thinks,\n-            DefKind::Variant => {\n-                // Variant fields inherit their enum's visibility.\n-                Item { visibility: Visibility::Inherited, ..what_rustc_thinks }\n-            }\n-            // FIXME: what about DefKind::Ctor?\n-            parent_kind => panic!(\"unexpected parent kind: {:?}\", parent_kind),\n-        }\n+        clean_field(def_id, self.ident.name, self.ty.clean(cx), cx)\n     }\n }\n \n impl Clean<Item> for ty::FieldDef {\n     fn clean(&self, cx: &mut DocContext<'_>) -> Item {\n-        let what_rustc_thinks = Item::from_def_id_and_parts(\n-            self.did,\n-            Some(self.ident.name),\n-            StructFieldItem(cx.tcx.type_of(self.did).clean(cx)),\n-            cx,\n-        );\n-        // Don't show `pub` for fields on enum variants; they are always public\n-        Item { visibility: self.vis.clean(cx), ..what_rustc_thinks }\n+        clean_field(self.did, self.ident.name, cx.tcx.type_of(self.did).clean(cx), cx)\n+    }\n+}\n+\n+fn clean_field(def_id: DefId, name: Symbol, ty: Type, cx: &mut DocContext<'_>) -> Item {\n+    let what_rustc_thinks =\n+        Item::from_def_id_and_parts(def_id, Some(name), StructFieldItem(ty), cx);\n+    if is_field_vis_inherited(cx.tcx, def_id) {\n+        // Variant fields inherit their enum's visibility.\n+        Item { visibility: Visibility::Inherited, ..what_rustc_thinks }\n+    } else {\n+        what_rustc_thinks\n+    }\n+}\n+\n+fn is_field_vis_inherited(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n+    let parent = tcx\n+        .parent(def_id)\n+        .expect(\"is_field_vis_inherited can only be called on struct or variant fields\");\n+    match tcx.def_kind(parent) {\n+        DefKind::Struct | DefKind::Union => false,\n+        DefKind::Variant => true,\n+        // FIXME: what about DefKind::Ctor?\n+        parent_kind => panic!(\"unexpected parent kind: {:?}\", parent_kind),\n     }\n }\n \n@@ -1600,8 +1601,7 @@ impl Clean<Visibility> for ty::Visibility {\n             // NOTE: this is not quite right: `ty` uses `Invisible` to mean 'private',\n             // while rustdoc really does mean inherited. That means that for enum variants, such as\n             // `pub enum E { V }`, `V` will be marked as `Public` by `ty`, but as `Inherited` by rustdoc.\n-            // This is the main reason `impl Clean for hir::Visibility` still exists; various parts of clean\n-            // override `tcx.visibility` explicitly to make sure this distinction is captured.\n+            // Various parts of clean override `tcx.visibility` explicitly to make sure this distinction is captured.\n             ty::Visibility::Invisible => Visibility::Inherited,\n             ty::Visibility::Restricted(module) => Visibility::Restricted(module),\n         }\n@@ -1628,39 +1628,18 @@ impl Clean<Item> for ty::VariantDef {\n     fn clean(&self, cx: &mut DocContext<'_>) -> Item {\n         let kind = match self.ctor_kind {\n             CtorKind::Const => Variant::CLike,\n-            CtorKind::Fn => Variant::Tuple(\n-                self.fields\n-                    .iter()\n-                    .map(|field| {\n-                        let name = Some(field.ident.name);\n-                        let kind = StructFieldItem(cx.tcx.type_of(field.did).clean(cx));\n-                        let what_rustc_thinks =\n-                            Item::from_def_id_and_parts(field.did, name, kind, cx);\n-                        // don't show `pub` for fields, which are always public\n-                        Item { visibility: Visibility::Inherited, ..what_rustc_thinks }\n-                    })\n-                    .collect(),\n-            ),\n+            CtorKind::Fn => {\n+                Variant::Tuple(self.fields.iter().map(|field| field.clean(cx)).collect())\n+            }\n             CtorKind::Fictive => Variant::Struct(VariantStruct {\n                 struct_type: CtorKind::Fictive,\n                 fields_stripped: false,\n-                fields: self\n-                    .fields\n-                    .iter()\n-                    .map(|field| {\n-                        let name = Some(field.ident.name);\n-                        let kind = StructFieldItem(cx.tcx.type_of(field.did).clean(cx));\n-                        let what_rustc_thinks =\n-                            Item::from_def_id_and_parts(field.did, name, kind, cx);\n-                        // don't show `pub` for fields, which are always public\n-                        Item { visibility: Visibility::Inherited, ..what_rustc_thinks }\n-                    })\n-                    .collect(),\n+                fields: self.fields.iter().map(|field| field.clean(cx)).collect(),\n             }),\n         };\n         let what_rustc_thinks =\n             Item::from_def_id_and_parts(self.def_id, Some(self.ident.name), VariantItem(kind), cx);\n-        // don't show `pub` for fields, which are always public\n+        // don't show `pub` for variants, which always inherit visibility\n         Item { visibility: Inherited, ..what_rustc_thinks }\n     }\n }"}]}