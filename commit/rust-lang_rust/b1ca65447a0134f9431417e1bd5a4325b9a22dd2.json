{"sha": "b1ca65447a0134f9431417e1bd5a4325b9a22dd2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIxY2E2NTQ0N2EwMTM0Zjk0MzE0MTdlMWJkNWE0MzI1YjlhMjJkZDI=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2017-08-25T16:25:05Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2017-08-25T17:08:04Z"}, "message": "refactor memory write API to match read API", "tree": {"sha": "20dbd2c719f9330b493cd440127fd9464f8d15a6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/20dbd2c719f9330b493cd440127fd9464f8d15a6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b1ca65447a0134f9431417e1bd5a4325b9a22dd2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b1ca65447a0134f9431417e1bd5a4325b9a22dd2", "html_url": "https://github.com/rust-lang/rust/commit/b1ca65447a0134f9431417e1bd5a4325b9a22dd2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b1ca65447a0134f9431417e1bd5a4325b9a22dd2/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f036fe0d32a077a8d69f20c876389779e88e3ea5", "url": "https://api.github.com/repos/rust-lang/rust/commits/f036fe0d32a077a8d69f20c876389779e88e3ea5", "html_url": "https://github.com/rust-lang/rust/commit/f036fe0d32a077a8d69f20c876389779e88e3ea5"}], "stats": {"total": 133, "additions": 76, "deletions": 57}, "files": [{"sha": "7dc8f54849f0af0d359882f6bb7f3aabd5e9d45b", "filename": "miri/fn_call.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b1ca65447a0134f9431417e1bd5a4325b9a22dd2/miri%2Ffn_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1ca65447a0134f9431417e1bd5a4325b9a22dd2/miri%2Ffn_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/miri%2Ffn_call.rs?ref=b1ca65447a0134f9431417e1bd5a4325b9a22dd2", "patch": "@@ -421,11 +421,11 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n                 if key_size.bits() < 128 && key >= (1u128 << key_size.bits() as u128) {\n                     return err!(OutOfTls);\n                 }\n-                // TODO: Does this need checking for alignment?\n-                self.memory.write_uint(\n+                self.memory.write_primval(\n                     key_ptr.to_ptr()?,\n-                    key,\n+                    PrimVal::Bytes(key),\n                     key_size.bytes(),\n+                    false,\n                 )?;\n \n                 // Return success (0)"}, {"sha": "19dc2bdf847d3246199f4ba4bbc9b072fe8bfba5", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 22, "deletions": 5, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/b1ca65447a0134f9431417e1bd5a4325b9a22dd2/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1ca65447a0134f9431417e1bd5a4325b9a22dd2/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=b1ca65447a0134f9431417e1bd5a4325b9a22dd2", "patch": "@@ -579,12 +579,13 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         discr_val: u128,\n         variant_idx: usize,\n         discr_size: u64,\n+        discr_signed: bool,\n     ) -> EvalResult<'tcx> {\n         // FIXME(solson)\n         let dest_ptr = self.force_allocation(dest)?.to_ptr()?;\n \n         let discr_dest = dest_ptr.offset(discr_offset, &self)?;\n-        self.memory.write_uint(discr_dest, discr_val, discr_size)?;\n+        self.memory.write_primval(discr_dest, PrimVal::Bytes(discr_val), discr_size, discr_signed)?;\n \n         let dest = Lvalue::Ptr {\n             ptr: PtrAndAlign {\n@@ -724,6 +725,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                                 discr_val,\n                                 variant,\n                                 discr_size,\n+                                false,\n                             )?;\n                         } else {\n                             bug!(\"tried to assign {:?} to Layout::General\", kind);\n@@ -783,7 +785,8 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                                 );\n                                 self.memory.write_maybe_aligned_mut(\n                                     !nonnull.packed,\n-                                    |mem| mem.write_int(dest, 0, dest_size),\n+                                    // The sign does not matter for 0\n+                                    |mem| mem.write_primval(dest, PrimVal::Bytes(0), dest_size, false),\n                                 )?;\n                             }\n                         } else {\n@@ -1607,7 +1610,20 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n             }\n             Value::ByVal(primval) => {\n                 let size = self.type_size(dest_ty)?.expect(\"dest type must be sized\");\n-                self.memory.write_primval(dest, primval, size)\n+                // TODO: This fn gets called with sizes like 6, which cannot be a primitive type\n+                // and hence is not supported by write_primval.\n+                // (E.g. in the arrays.rs testcase.)  That seems to only happen for Undef though,\n+                // so we special-case that here.\n+                match primval {\n+                    PrimVal::Undef => {\n+                        self.memory.mark_definedness(dest, size, false)?;\n+                    }\n+                    _ => {\n+                        // TODO: Do we need signedness?\n+                        self.memory.write_primval(dest.to_ptr()?, primval, size, false)?;\n+                    }\n+                }\n+                Ok(())\n             }\n             Value::ByValPair(a, b) => self.write_pair_to_ptr(a, b, dest.to_ptr()?, dest_ty),\n         }\n@@ -1645,11 +1661,12 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         );\n         let field_0_ptr = ptr.offset(field_0.bytes(), &self)?.into();\n         let field_1_ptr = ptr.offset(field_1.bytes(), &self)?.into();\n+        // TODO: What about signedess?\n         self.write_maybe_aligned_mut(!packed, |ectx| {\n-            ectx.memory.write_primval(field_0_ptr, a, field_0_size)\n+            ectx.memory.write_primval(field_0_ptr, a, field_0_size, false)\n         })?;\n         self.write_maybe_aligned_mut(!packed, |ectx| {\n-            ectx.memory.write_primval(field_1_ptr, b, field_1_size)\n+            ectx.memory.write_primval(field_1_ptr, b, field_1_size, false)\n         })?;\n         Ok(())\n     }"}, {"sha": "d8a4ae66cf6792a1c793ab23e76257b9d4a7a965", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 39, "deletions": 40, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/b1ca65447a0134f9431417e1bd5a4325b9a22dd2/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1ca65447a0134f9431417e1bd5a4325b9a22dd2/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=b1ca65447a0134f9431417e1bd5a4325b9a22dd2", "patch": "@@ -1206,20 +1206,15 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n         self.read_primval(ptr, self.pointer_size(), false)\n     }\n \n-    pub fn write_ptr(&mut self, dest: MemoryPointer, ptr: MemoryPointer) -> EvalResult<'tcx> {\n-        self.write_usize(dest, ptr.offset as u64)?;\n-        self.get_mut(dest.alloc_id)?.relocations.insert(\n-            dest.offset,\n-            ptr.alloc_id,\n-        );\n-        Ok(())\n-    }\n+    pub fn write_primval(&mut self, ptr: MemoryPointer, val: PrimVal, size: u64, signed: bool) -> EvalResult<'tcx> {\n+        trace!(\"Writing {:?}, size {}\", val, size);\n+        let align = self.int_align(size)?;\n+        let endianess = self.endianess();\n \n-    pub fn write_primval(&mut self, dest: Pointer, val: PrimVal, size: u64) -> EvalResult<'tcx> {\n-        match val {\n-            PrimVal::Ptr(ptr) => {\n+        let bytes = match val {\n+            PrimVal::Ptr(val) => {\n                 assert_eq!(size, self.pointer_size());\n-                self.write_ptr(dest.to_ptr()?, ptr)\n+                val.offset as u128\n             }\n \n             PrimVal::Bytes(bytes) => {\n@@ -1233,11 +1228,41 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n                     16 => !0,\n                     n => bug!(\"unexpected PrimVal::Bytes size: {}\", n),\n                 };\n-                self.write_uint(dest.to_ptr()?, bytes & mask, size)\n+                bytes & mask\n             }\n \n-            PrimVal::Undef => self.mark_definedness(dest, size, false),\n+            PrimVal::Undef => {\n+                self.mark_definedness(PrimVal::Ptr(ptr).into(), size, false)?;\n+                return Ok(());\n+            }\n+        };\n+\n+        {\n+            let dst = self.get_bytes_mut(ptr, size, align)?;\n+            if signed {\n+                write_target_int(endianess, dst, bytes as i128).unwrap();\n+            } else {\n+                write_target_uint(endianess, dst, bytes).unwrap();\n+            }\n+        }\n+\n+        // See if we have to also write a relocation\n+        match val {\n+            PrimVal::Ptr(val) => {\n+                self.get_mut(ptr.alloc_id)?.relocations.insert(\n+                    ptr.offset,\n+                    val.alloc_id,\n+                );\n+            }\n+            _ => {}\n         }\n+\n+        Ok(())\n+    }\n+\n+    pub fn write_ptr_sized_unsigned(&mut self, ptr: MemoryPointer, val: PrimVal) -> EvalResult<'tcx> {\n+        let ptr_size = self.pointer_size();\n+        self.write_primval(ptr, val, ptr_size, false)\n     }\n \n     pub fn read_bool(&self, ptr: MemoryPointer) -> EvalResult<'tcx, bool> {\n@@ -1269,32 +1294,6 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n         }\n     }\n \n-    pub fn write_int(&mut self, ptr: MemoryPointer, n: i128, size: u64) -> EvalResult<'tcx> {\n-        let align = self.int_align(size)?;\n-        let endianess = self.endianess();\n-        let b = self.get_bytes_mut(ptr, size, align)?;\n-        write_target_int(endianess, b, n).unwrap();\n-        Ok(())\n-    }\n-\n-    pub fn write_uint(&mut self, ptr: MemoryPointer, n: u128, size: u64) -> EvalResult<'tcx> {\n-        let align = self.int_align(size)?;\n-        let endianess = self.endianess();\n-        let b = self.get_bytes_mut(ptr, size, align)?;\n-        write_target_uint(endianess, b, n).unwrap();\n-        Ok(())\n-    }\n-\n-    pub fn write_isize(&mut self, ptr: MemoryPointer, n: i64) -> EvalResult<'tcx> {\n-        let size = self.pointer_size();\n-        self.write_int(ptr, n as i128, size)\n-    }\n-\n-    pub fn write_usize(&mut self, ptr: MemoryPointer, n: u64) -> EvalResult<'tcx> {\n-        let size = self.pointer_size();\n-        self.write_uint(ptr, n as u128, size)\n-    }\n-\n     pub fn write_f32(&mut self, ptr: MemoryPointer, f: f32) -> EvalResult<'tcx> {\n         let endianess = self.endianess();\n         let align = self.layout.f32_align.abi();"}, {"sha": "9a6f72c7bfde02d1770ba18588127cb4e6609304", "filename": "src/librustc_mir/interpret/step.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b1ca65447a0134f9431417e1bd5a4325b9a22dd2/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1ca65447a0134f9431417e1bd5a4325b9a22dd2/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fstep.rs?ref=b1ca65447a0134f9431417e1bd5a4325b9a22dd2", "patch": "@@ -12,7 +12,7 @@ use rustc::ty::layout::Layout;\n use rustc::ty::subst::Substs;\n \n use super::{EvalResult, EvalContext, StackPopCleanup, TyAndPacked, PtrAndAlign, GlobalId, Lvalue,\n-            HasMemory, MemoryKind, Machine};\n+            HasMemory, MemoryKind, Machine, PrimVal};\n \n use syntax::codemap::Span;\n use syntax::ast::Mutability;\n@@ -106,10 +106,11 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                     Layout::General { discr, .. } => {\n                         let discr_size = discr.size().bytes();\n                         let dest_ptr = self.force_allocation(dest)?.to_ptr()?;\n-                        self.memory.write_uint(\n+                        self.memory.write_primval(\n                             dest_ptr,\n-                            variant_index as u128,\n+                            PrimVal::Bytes(variant_index as u128),\n                             discr_size,\n+                            false\n                         )?\n                     }\n \n@@ -124,6 +125,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                         ref discrfield_source,\n                         ..\n                     } => {\n+                        // TODO: There's some duplication between here and eval_rvalue_into_lvalue\n                         if variant_index as u64 != nndiscr {\n                             let (offset, TyAndPacked { ty, packed }) = self.nonnull_offset_and_ty(\n                                 dest_ty,\n@@ -140,7 +142,8 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                                 \"bad StructWrappedNullablePointer discrfield\",\n                             );\n                             self.write_maybe_aligned_mut(!packed, |ectx| {\n-                                ectx.memory.write_uint(nonnull, 0, discr_size)\n+                                // We're writing 0, signedness does not matter\n+                                ectx.memory.write_primval(nonnull, PrimVal::Bytes(0), discr_size, false)\n                             })?;\n                         }\n                     }\n@@ -229,7 +232,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                 ptr_size,\n                 MemoryKind::UninitializedStatic,\n             )?;\n-            self.memory.write_usize(ptr, 0)?;\n+            self.memory.write_ptr_sized_unsigned(ptr, PrimVal::Bytes(0))?;\n             self.memory.mark_static_initalized(ptr.alloc_id, mutability)?;\n             self.globals.insert(\n                 cid,"}, {"sha": "3f7e10a9eaff0bd929247141b34c3f4690300bfb", "filename": "src/librustc_mir/interpret/traits.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b1ca65447a0134f9431417e1bd5a4325b9a22dd2/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1ca65447a0134f9431417e1bd5a4325b9a22dd2/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs?ref=b1ca65447a0134f9431417e1bd5a4325b9a22dd2", "patch": "@@ -63,19 +63,19 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n \n         let drop = eval_context::resolve_drop_in_place(self.tcx, ty);\n         let drop = self.memory.create_fn_alloc(drop);\n-        self.memory.write_ptr(vtable, drop)?;\n+        self.memory.write_ptr_sized_unsigned(vtable, PrimVal::Ptr(drop))?;\n \n         let size_ptr = vtable.offset(ptr_size, &self)?;\n-        self.memory.write_usize(size_ptr, size)?;\n+        self.memory.write_ptr_sized_unsigned(size_ptr, PrimVal::Bytes(size as u128))?;\n         let align_ptr = vtable.offset(ptr_size * 2, &self)?;\n-        self.memory.write_usize(align_ptr, align)?;\n+        self.memory.write_ptr_sized_unsigned(align_ptr, PrimVal::Bytes(align as u128))?;\n \n         for (i, method) in ::rustc::traits::get_vtable_methods(self.tcx, trait_ref).enumerate() {\n             if let Some((def_id, substs)) = method {\n                 let instance = eval_context::resolve(self.tcx, def_id, substs);\n                 let fn_ptr = self.memory.create_fn_alloc(instance);\n                 let method_ptr = vtable.offset(ptr_size * (3 + i as u64), &self)?;\n-                self.memory.write_ptr(method_ptr, fn_ptr)?;\n+                self.memory.write_ptr_sized_unsigned(method_ptr, PrimVal::Ptr(fn_ptr))?;\n             }\n         }\n "}]}