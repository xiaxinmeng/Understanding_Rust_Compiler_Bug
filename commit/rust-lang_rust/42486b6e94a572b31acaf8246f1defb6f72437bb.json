{"sha": "42486b6e94a572b31acaf8246f1defb6f72437bb", "node_id": "C_kwDOAAsO6NoAKDQyNDg2YjZlOTRhNTcyYjMxYWNhZjgyNDZmMWRlZmI2ZjcyNDM3YmI", "commit": {"author": {"name": "austaras", "email": "austaras@outlook.com", "date": "2022-08-27T01:12:19Z"}, "committer": {"name": "austaras", "email": "austaras@outlook.com", "date": "2022-08-28T16:24:56Z"}, "message": "change as requested", "tree": {"sha": "823a3aca2926e865f9df41287fafaf2b81302cc6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/823a3aca2926e865f9df41287fafaf2b81302cc6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/42486b6e94a572b31acaf8246f1defb6f72437bb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/42486b6e94a572b31acaf8246f1defb6f72437bb", "html_url": "https://github.com/rust-lang/rust/commit/42486b6e94a572b31acaf8246f1defb6f72437bb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/42486b6e94a572b31acaf8246f1defb6f72437bb/comments", "author": {"login": "Austaras", "id": 15013925, "node_id": "MDQ6VXNlcjE1MDEzOTI1", "avatar_url": "https://avatars.githubusercontent.com/u/15013925?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Austaras", "html_url": "https://github.com/Austaras", "followers_url": "https://api.github.com/users/Austaras/followers", "following_url": "https://api.github.com/users/Austaras/following{/other_user}", "gists_url": "https://api.github.com/users/Austaras/gists{/gist_id}", "starred_url": "https://api.github.com/users/Austaras/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Austaras/subscriptions", "organizations_url": "https://api.github.com/users/Austaras/orgs", "repos_url": "https://api.github.com/users/Austaras/repos", "events_url": "https://api.github.com/users/Austaras/events{/privacy}", "received_events_url": "https://api.github.com/users/Austaras/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Austaras", "id": 15013925, "node_id": "MDQ6VXNlcjE1MDEzOTI1", "avatar_url": "https://avatars.githubusercontent.com/u/15013925?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Austaras", "html_url": "https://github.com/Austaras", "followers_url": "https://api.github.com/users/Austaras/followers", "following_url": "https://api.github.com/users/Austaras/following{/other_user}", "gists_url": "https://api.github.com/users/Austaras/gists{/gist_id}", "starred_url": "https://api.github.com/users/Austaras/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Austaras/subscriptions", "organizations_url": "https://api.github.com/users/Austaras/orgs", "repos_url": "https://api.github.com/users/Austaras/repos", "events_url": "https://api.github.com/users/Austaras/events{/privacy}", "received_events_url": "https://api.github.com/users/Austaras/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f9c180ffd1702dfded1e0cd6c6d3e12a40e14d0a", "url": "https://api.github.com/repos/rust-lang/rust/commits/f9c180ffd1702dfded1e0cd6c6d3e12a40e14d0a", "html_url": "https://github.com/rust-lang/rust/commit/f9c180ffd1702dfded1e0cd6c6d3e12a40e14d0a"}], "stats": {"total": 117, "additions": 86, "deletions": 31}, "files": [{"sha": "bee52a0d7fae264335281f3f9fed2ae35c4b583e", "filename": "crates/ide-assists/src/handlers/replace_or_with_or_else.rs", "status": "modified", "additions": 86, "deletions": 31, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/42486b6e94a572b31acaf8246f1defb6f72437bb/crates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_or_with_or_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42486b6e94a572b31acaf8246f1defb6f72437bb/crates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_or_with_or_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_or_with_or_else.rs?ref=42486b6e94a572b31acaf8246f1defb6f72437bb", "patch": "@@ -30,33 +30,33 @@ use crate::{AssistContext, Assists};\n pub(crate) fn replace_or_with_or_else(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n     let call: ast::MethodCallExpr = ctx.find_node_at_offset()?;\n \n-    is_option_or_result(call.receiver()?, ctx)?;\n+    let kind = is_option_or_result(call.receiver()?, ctx)?;\n \n     let (name, arg_list) = (call.name_ref()?, call.arg_list()?);\n \n+    let mut map_or = false;\n+\n     let replace = match &*name.text() {\n         \"unwrap_or\" => \"unwrap_or_else\".to_string(),\n-        \"ok_or\" => \"ok_or_else\".to_string(),\n+        \"or\" => \"or_else\".to_string(),\n+        \"ok_or\" if kind == Kind::Option => \"ok_or_else\".to_string(),\n+        \"map_or\" => {\n+            map_or = true;\n+            \"map_or_else\".to_string()\n+        }\n         _ => return None,\n     };\n \n     let arg = match arg_list.args().collect::<Vec<_>>().as_slice() {\n         [] => make::arg_list(Vec::new()),\n         [first] => {\n-            let param = (|| {\n-                if let ast::Expr::CallExpr(call) = first {\n-                    if call.arg_list()?.args().count() == 0 {\n-                        Some(call.expr()?.clone())\n-                    } else {\n-                        None\n-                    }\n-                } else {\n-                    None\n-                }\n-            })()\n-            .unwrap_or_else(|| make::expr_closure(None, first.clone()));\n+            let param = into_closure(first);\n             make::arg_list(vec![param])\n         }\n+        [first, second] if map_or => {\n+            let param = into_closure(first);\n+            make::arg_list(vec![param, second.clone()])\n+        }\n         _ => return None,\n     };\n \n@@ -71,6 +71,21 @@ pub(crate) fn replace_or_with_or_else(acc: &mut Assists, ctx: &AssistContext<'_>\n     )\n }\n \n+fn into_closure(param: &Expr) -> Expr {\n+    (|| {\n+        if let ast::Expr::CallExpr(call) = param {\n+            if call.arg_list()?.args().count() == 0 {\n+                Some(call.expr()?.clone())\n+            } else {\n+                None\n+            }\n+        } else {\n+            None\n+        }\n+    })()\n+    .unwrap_or_else(|| make::expr_closure(None, param.clone()))\n+}\n+\n // Assist: replace_or_else_with_or\n //\n // Replace `unwrap_or_else` with `unwrap_or` and `ok_or_else` with `ok_or`.\n@@ -92,33 +107,32 @@ pub(crate) fn replace_or_with_or_else(acc: &mut Assists, ctx: &AssistContext<'_>\n pub(crate) fn replace_or_else_with_or(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n     let call: ast::MethodCallExpr = ctx.find_node_at_offset()?;\n \n-    is_option_or_result(call.receiver()?, ctx)?;\n+    let kind = is_option_or_result(call.receiver()?, ctx)?;\n \n     let (name, arg_list) = (call.name_ref()?, call.arg_list()?);\n \n+    let mut map_or = false;\n     let replace = match &*name.text() {\n         \"unwrap_or_else\" => \"unwrap_or\".to_string(),\n-        \"ok_or_else\" => \"ok_or\".to_string(),\n+        \"or_else\" => \"or\".to_string(),\n+        \"ok_or_else\" if kind == Kind::Option => \"ok_or\".to_string(),\n+        \"map_or_else\" => {\n+            map_or = true;\n+            \"map_or\".to_string()\n+        }\n         _ => return None,\n     };\n \n     let arg = match arg_list.args().collect::<Vec<_>>().as_slice() {\n         [] => make::arg_list(Vec::new()),\n         [first] => {\n-            let param = (|| {\n-                if let ast::Expr::ClosureExpr(closure) = first {\n-                    if closure.param_list()?.params().count() == 0 {\n-                        Some(closure.body()?.clone())\n-                    } else {\n-                        None\n-                    }\n-                } else {\n-                    None\n-                }\n-            })()\n-            .unwrap_or_else(|| make::expr_call(first.clone(), make::arg_list(Vec::new())));\n+            let param = into_call(first);\n             make::arg_list(vec![param])\n         }\n+        [first, second] if map_or => {\n+            let param = into_call(first);\n+            make::arg_list(vec![param, second.clone()])\n+        }\n         _ => return None,\n     };\n \n@@ -133,14 +147,35 @@ pub(crate) fn replace_or_else_with_or(acc: &mut Assists, ctx: &AssistContext<'_>\n     )\n }\n \n-fn is_option_or_result(receiver: Expr, ctx: &AssistContext<'_>) -> Option<()> {\n+fn into_call(param: &Expr) -> Expr {\n+    (|| {\n+        if let ast::Expr::ClosureExpr(closure) = param {\n+            if closure.param_list()?.params().count() == 0 {\n+                Some(closure.body()?.clone())\n+            } else {\n+                None\n+            }\n+        } else {\n+            None\n+        }\n+    })()\n+    .unwrap_or_else(|| make::expr_call(param.clone(), make::arg_list(Vec::new())))\n+}\n+\n+#[derive(PartialEq, Eq)]\n+enum Kind {\n+    Option,\n+    Result,\n+}\n+\n+fn is_option_or_result(receiver: Expr, ctx: &AssistContext<'_>) -> Option<Kind> {\n     let ty = ctx.sema.type_of_expr(&receiver)?.adjusted().as_adt()?.as_enum()?;\n     let option_enum =\n         FamousDefs(&ctx.sema, ctx.sema.scope(receiver.syntax())?.krate()).core_option_Option();\n \n     if let Some(option_enum) = option_enum {\n         if ty == option_enum {\n-            return Some(());\n+            return Some(Kind::Option);\n         }\n     }\n \n@@ -149,7 +184,7 @@ fn is_option_or_result(receiver: Expr, ctx: &AssistContext<'_>) -> Option<()> {\n \n     if let Some(result_enum) = result_enum {\n         if ty == result_enum {\n-            return Some(());\n+            return Some(Kind::Result);\n         }\n     }\n \n@@ -294,6 +329,26 @@ fn foo() {\n         )\n     }\n \n+    #[test]\n+    fn replace_or_else_with_or_map() {\n+        check_assist(\n+            replace_or_else_with_or,\n+            r#\"\n+//- minicore: result\n+fn foo() {\n+    let foo = Ok(\"foo\");\n+    return foo.map$0_or_else(|| 42, |v| v.len());\n+}\n+\"#,\n+            r#\"\n+fn foo() {\n+    let foo = Ok(\"foo\");\n+    return foo.map_or(42, |v| v.len());\n+}\n+\"#,\n+        )\n+    }\n+\n     #[test]\n     fn replace_or_else_with_or_not_applicable() {\n         check_assist_not_applicable("}]}