{"sha": "d95f078f0af28203c379365574a433ca5b79e9d8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ5NWYwNzhmMGFmMjgyMDNjMzc5MzY1NTc0YTQzM2NhNWI3OWU5ZDg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-08-24T22:42:00Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-08-24T22:42:00Z"}, "message": "Auto merge of #53225 - nikomatsakis:nll-type-annot, r=pnkfelix\n\nMIR: support user-given type annotations on fns, structs, and enums\n\nThis branch adds tooling to track user-given type annotations on functions, structs, and enum variant expressions. The user-given types are passed onto NLL which then enforces them.\n\ncc #47184 \u2014 not a complete fix, as there are more cases to cover\n\nr? @eddyb\ncc @rust-lang/wg-compiler-nll", "tree": {"sha": "edc38cee7233726cedd15b68fc01cf8874116d36", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/edc38cee7233726cedd15b68fc01cf8874116d36"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d95f078f0af28203c379365574a433ca5b79e9d8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d95f078f0af28203c379365574a433ca5b79e9d8", "html_url": "https://github.com/rust-lang/rust/commit/d95f078f0af28203c379365574a433ca5b79e9d8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d95f078f0af28203c379365574a433ca5b79e9d8/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d41f21f11a249ad78990eb9a1ec899ec123c7136", "url": "https://api.github.com/repos/rust-lang/rust/commits/d41f21f11a249ad78990eb9a1ec899ec123c7136", "html_url": "https://github.com/rust-lang/rust/commit/d41f21f11a249ad78990eb9a1ec899ec123c7136"}, {"sha": "ed73a3267a648cffb92f60e50aa75a6547d9955d", "url": "https://api.github.com/repos/rust-lang/rust/commits/ed73a3267a648cffb92f60e50aa75a6547d9955d", "html_url": "https://github.com/rust-lang/rust/commit/ed73a3267a648cffb92f60e50aa75a6547d9955d"}], "stats": {"total": 1836, "additions": 1757, "deletions": 79}, "files": [{"sha": "b10f4785f16377d3e08cef3fdd7d12928e845048", "filename": "src/librustc/hir/def.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d95f078f0af28203c379365574a433ca5b79e9d8/src%2Flibrustc%2Fhir%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d95f078f0af28203c379365574a433ca5b79e9d8/src%2Flibrustc%2Fhir%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fdef.rs?ref=d95f078f0af28203c379365574a433ca5b79e9d8", "patch": "@@ -68,7 +68,7 @@ pub enum Def {\n     Const(DefId),\n     Static(DefId, bool /* is_mutbl */),\n     StructCtor(DefId, CtorKind), // DefId refers to NodeId of the struct's constructor\n-    VariantCtor(DefId, CtorKind),\n+    VariantCtor(DefId, CtorKind), // DefId refers to the enum variant\n     Method(DefId),\n     AssociatedConst(DefId),\n "}, {"sha": "1c9387d02d5a34ffbc3de811e20e9e365b7c8cca", "filename": "src/librustc/ich/impls_mir.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d95f078f0af28203c379365574a433ca5b79e9d8/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d95f078f0af28203c379365574a433ca5b79e9d8/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_mir.rs?ref=d95f078f0af28203c379365574a433ca5b79e9d8", "patch": "@@ -479,10 +479,11 @@ for mir::AggregateKind<'gcx> {\n             mir::AggregateKind::Array(t) => {\n                 t.hash_stable(hcx, hasher);\n             }\n-            mir::AggregateKind::Adt(adt_def, idx, substs, active_field) => {\n+            mir::AggregateKind::Adt(adt_def, idx, substs, user_substs, active_field) => {\n                 adt_def.hash_stable(hcx, hasher);\n                 idx.hash_stable(hcx, hasher);\n                 substs.hash_stable(hcx, hasher);\n+                user_substs.hash_stable(hcx, hasher);\n                 active_field.hash_stable(hcx, hasher);\n             }\n             mir::AggregateKind::Closure(def_id, ref substs) => {\n@@ -528,7 +529,7 @@ impl_stable_hash_for!(enum mir::NullOp {\n     SizeOf\n });\n \n-impl_stable_hash_for!(struct mir::Constant<'tcx> { span, ty, literal });\n+impl_stable_hash_for!(struct mir::Constant<'tcx> { span, ty, user_ty, literal });\n \n impl_stable_hash_for!(struct mir::Location { block, statement_index });\n "}, {"sha": "85aa4f62f214c24f6e477c4d021586fc0beca513", "filename": "src/librustc/infer/canonical/mod.rs", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/d95f078f0af28203c379365574a433ca5b79e9d8/src%2Flibrustc%2Finfer%2Fcanonical%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d95f078f0af28203c379365574a433ca5b79e9d8/src%2Flibrustc%2Finfer%2Fcanonical%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fmod.rs?ref=d95f078f0af28203c379365574a433ca5b79e9d8", "patch": "@@ -188,6 +188,36 @@ impl<'tcx, R> Canonical<'tcx, QueryResult<'tcx, R>> {\n     }\n }\n \n+impl<'gcx, V> Canonical<'gcx, V> {\n+    /// Allows you to map the `value` of a canonical while keeping the\n+    /// same set of bound variables.\n+    ///\n+    /// **WARNING:** This function is very easy to mis-use, hence the\n+    /// name!  In particular, the new value `W` must use all **the\n+    /// same type/region variables** in **precisely the same order**\n+    /// as the original! (The ordering is defined by the\n+    /// `TypeFoldable` implementation of the type in question.)\n+    ///\n+    /// An example of a **correct** use of this:\n+    ///\n+    /// ```rust,ignore (not real code)\n+    /// let a: Canonical<'_, T> = ...;\n+    /// let b: Canonical<'_, (T,)> = a.unchecked_map(|v| (v, ));\n+    /// ```\n+    ///\n+    /// An example of an **incorrect** use of this:\n+    ///\n+    /// ```rust,ignore (not real code)\n+    /// let a: Canonical<'tcx, T> = ...;\n+    /// let ty: Ty<'tcx> = ...;\n+    /// let b: Canonical<'tcx, (T, Ty<'tcx>)> = a.unchecked_map(|v| (v, ty));\n+    /// ```\n+    pub fn unchecked_map<W>(self, map_op: impl FnOnce(V) -> W) -> Canonical<'gcx, W> {\n+        let Canonical { variables, value } = self;\n+        Canonical { variables, value: map_op(value) }\n+    }\n+}\n+\n pub type QueryRegionConstraint<'tcx> = ty::Binder<ty::OutlivesPredicate<Kind<'tcx>, Region<'tcx>>>;\n \n impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {"}, {"sha": "86e521727c53c699d49896d1116e900e269da859", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 28, "deletions": 5, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/d95f078f0af28203c379365574a433ca5b79e9d8/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d95f078f0af28203c379365574a433ca5b79e9d8/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=d95f078f0af28203c379365574a433ca5b79e9d8", "patch": "@@ -1888,12 +1888,15 @@ pub enum Operand<'tcx> {\n     /// This implies that the type of the place must be `Copy`; this is true\n     /// by construction during build, but also checked by the MIR type checker.\n     Copy(Place<'tcx>),\n+\n     /// Move: The value (including old borrows of it) will not be used again.\n     ///\n     /// Safe for values of all types (modulo future developments towards `?Move`).\n     /// Correct usage patterns are enforced by the borrow checker for safe code.\n     /// `Copy` may be converted to `Move` to enable \"last-use\" optimizations.\n     Move(Place<'tcx>),\n+\n+    /// Synthesizes a constant value.\n     Constant(Box<Constant<'tcx>>),\n }\n \n@@ -1909,6 +1912,9 @@ impl<'tcx> Debug for Operand<'tcx> {\n }\n \n impl<'tcx> Operand<'tcx> {\n+    /// Convenience helper to make a constant that refers to the fn\n+    /// with given def-id and substs. Since this is used to synthesize\n+    /// MIR, assumes `user_ty` is None.\n     pub fn function_handle<'a>(\n         tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         def_id: DefId,\n@@ -1919,6 +1925,7 @@ impl<'tcx> Operand<'tcx> {\n         Operand::Constant(box Constant {\n             span,\n             ty,\n+            user_ty: None,\n             literal: ty::Const::zero_sized(tcx, ty),\n         })\n     }\n@@ -2002,7 +2009,7 @@ pub enum AggregateKind<'tcx> {\n     /// active field number and is present only for union expressions\n     /// -- e.g. for a union expression `SomeUnion { c: .. }`, the\n     /// active field index would identity the field `c`\n-    Adt(&'tcx AdtDef, usize, &'tcx Substs<'tcx>, Option<usize>),\n+    Adt(&'tcx AdtDef, usize, &'tcx Substs<'tcx>, Option<CanonicalTy<'tcx>>, Option<usize>),\n \n     Closure(DefId, ClosureSubsts<'tcx>),\n     Generator(DefId, GeneratorSubsts<'tcx>, hir::GeneratorMovability),\n@@ -2128,7 +2135,7 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n                         _ => fmt_tuple(fmt, places),\n                     },\n \n-                    AggregateKind::Adt(adt_def, variant, substs, _) => {\n+                    AggregateKind::Adt(adt_def, variant, substs, _user_ty, _) => {\n                         let variant_def = &adt_def.variants[variant];\n \n                         ppaux::parameterized(fmt, substs, variant_def.did, &[])?;\n@@ -2207,6 +2214,14 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n pub struct Constant<'tcx> {\n     pub span: Span,\n     pub ty: Ty<'tcx>,\n+\n+    /// Optional user-given type: for something like\n+    /// `collect::<Vec<_>>`, this would be present and would\n+    /// indicate that `Vec<_>` was explicitly specified.\n+    ///\n+    /// Needed for NLL to impose user-given type constraints.\n+    pub user_ty: Option<CanonicalTy<'tcx>>,\n+\n     pub literal: &'tcx ty::Const<'tcx>,\n }\n \n@@ -2798,8 +2813,14 @@ impl<'tcx> TypeFoldable<'tcx> for Rvalue<'tcx> {\n                 let kind = box match **kind {\n                     AggregateKind::Array(ty) => AggregateKind::Array(ty.fold_with(folder)),\n                     AggregateKind::Tuple => AggregateKind::Tuple,\n-                    AggregateKind::Adt(def, v, substs, n) => {\n-                        AggregateKind::Adt(def, v, substs.fold_with(folder), n)\n+                    AggregateKind::Adt(def, v, substs, user_ty, n) => {\n+                        AggregateKind::Adt(\n+                            def,\n+                            v,\n+                            substs.fold_with(folder),\n+                            user_ty.fold_with(folder),\n+                            n,\n+                        )\n                     }\n                     AggregateKind::Closure(id, substs) => {\n                         AggregateKind::Closure(id, substs.fold_with(folder))\n@@ -2831,7 +2852,8 @@ impl<'tcx> TypeFoldable<'tcx> for Rvalue<'tcx> {\n                 (match **kind {\n                     AggregateKind::Array(ty) => ty.visit_with(visitor),\n                     AggregateKind::Tuple => false,\n-                    AggregateKind::Adt(_, _, substs, _) => substs.visit_with(visitor),\n+                    AggregateKind::Adt(_, _, substs, user_ty, _) =>\n+                        substs.visit_with(visitor) || user_ty.visit_with(visitor),\n                     AggregateKind::Closure(_, substs) => substs.visit_with(visitor),\n                     AggregateKind::Generator(_, substs, _) => substs.visit_with(visitor),\n                 }) || fields.visit_with(visitor)\n@@ -2902,6 +2924,7 @@ impl<'tcx> TypeFoldable<'tcx> for Constant<'tcx> {\n         Constant {\n             span: self.span.clone(),\n             ty: self.ty.fold_with(folder),\n+            user_ty: self.user_ty.fold_with(folder),\n             literal: self.literal.fold_with(folder),\n         }\n     }"}, {"sha": "c928be4f9df78aa351698ece504e7a22b40b9a80", "filename": "src/librustc/mir/tcx.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d95f078f0af28203c379365574a433ca5b79e9d8/src%2Flibrustc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d95f078f0af28203c379365574a433ca5b79e9d8/src%2Flibrustc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftcx.rs?ref=d95f078f0af28203c379365574a433ca5b79e9d8", "patch": "@@ -216,7 +216,7 @@ impl<'tcx> Rvalue<'tcx> {\n                     AggregateKind::Tuple => {\n                         tcx.mk_tup(ops.iter().map(|op| op.ty(local_decls, tcx)))\n                     }\n-                    AggregateKind::Adt(def, _, substs, _) => {\n+                    AggregateKind::Adt(def, _, substs, _, _) => {\n                         tcx.type_of(def.did).subst(tcx, substs)\n                     }\n                     AggregateKind::Closure(did, substs) => {"}, {"sha": "c7723fdf1913710de4b8f742fa93dd756f92e681", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d95f078f0af28203c379365574a433ca5b79e9d8/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d95f078f0af28203c379365574a433ca5b79e9d8/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=d95f078f0af28203c379365574a433ca5b79e9d8", "patch": "@@ -213,6 +213,10 @@ macro_rules! make_mir_visitor {\n                 self.super_ty(ty);\n             }\n \n+            fn visit_canonical_ty(&mut self, ty: & $($mutability)* CanonicalTy<'tcx>) {\n+                self.super_canonical_ty(ty);\n+            }\n+\n             fn visit_region(&mut self,\n                             region: & $($mutability)* ty::Region<'tcx>,\n                             _: Location) {\n@@ -585,6 +589,7 @@ macro_rules! make_mir_visitor {\n                             AggregateKind::Adt(_adt_def,\n                                                _variant_index,\n                                                ref $($mutability)* substs,\n+                                               _user_substs,\n                                                _active_field_index) => {\n                                 self.visit_substs(substs, location);\n                             }\n@@ -625,9 +630,10 @@ macro_rules! make_mir_visitor {\n             }\n \n             fn super_user_assert_ty(&mut self,\n-                                    _c_ty: & $($mutability)* CanonicalTy<'tcx>,\n+                                    c_ty: & $($mutability)* CanonicalTy<'tcx>,\n                                     local: & $($mutability)* Local,\n                                     location: Location) {\n+                self.visit_canonical_ty(c_ty);\n                 self.visit_local(local, PlaceContext::Validate, location);\n             }\n \n@@ -740,11 +746,13 @@ macro_rules! make_mir_visitor {\n                 let Constant {\n                     ref $($mutability)* span,\n                     ref $($mutability)* ty,\n+                    ref $($mutability)* user_ty,\n                     ref $($mutability)* literal,\n                 } = *constant;\n \n                 self.visit_span(span);\n                 self.visit_ty(ty, TyContext::Location(location));\n+                drop(user_ty); // no visit method for this\n                 self.visit_const(literal, location);\n             }\n \n@@ -764,6 +772,9 @@ macro_rules! make_mir_visitor {\n                 self.visit_source_scope(scope);\n             }\n \n+            fn super_canonical_ty(&mut self, _ty: & $($mutability)* CanonicalTy<'tcx>) {\n+            }\n+\n             fn super_ty(&mut self, _ty: & $($mutability)* Ty<'tcx>) {\n             }\n "}, {"sha": "424139e752736eff0efdd5c1ff17c7025db1c6f8", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 28, "deletions": 1, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/d95f078f0af28203c379365574a433ca5b79e9d8/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d95f078f0af28203c379365574a433ca5b79e9d8/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=d95f078f0af28203c379365574a433ca5b79e9d8", "patch": "@@ -33,7 +33,7 @@ use middle::resolve_lifetime::{self, ObjectLifetimeDefault};\n use middle::stability;\n use mir::{self, Mir, interpret};\n use mir::interpret::Allocation;\n-use ty::subst::{Kind, Substs, Subst};\n+use ty::subst::{CanonicalSubsts, Kind, Substs, Subst};\n use ty::ReprOptions;\n use traits;\n use traits::{Clause, Clauses, Goal, Goals};\n@@ -371,6 +371,18 @@ pub struct TypeckTables<'tcx> {\n     /// other items.\n     node_substs: ItemLocalMap<&'tcx Substs<'tcx>>,\n \n+    /// Stores the substitutions that the user explicitly gave (if any)\n+    /// attached to `id`. These will not include any inferred\n+    /// values. The canonical form is used to capture things like `_`\n+    /// or other unspecified values.\n+    ///\n+    /// Example:\n+    ///\n+    /// If the user wrote `foo.collect::<Vec<_>>()`, then the\n+    /// canonical substitutions would include only `for<X> { Vec<X>\n+    /// }`.\n+    user_substs: ItemLocalMap<CanonicalSubsts<'tcx>>,\n+\n     adjustments: ItemLocalMap<Vec<ty::adjustment::Adjustment<'tcx>>>,\n \n     /// Stores the actual binding mode for all instances of hir::BindingAnnotation.\n@@ -444,6 +456,7 @@ impl<'tcx> TypeckTables<'tcx> {\n             user_provided_tys: ItemLocalMap(),\n             node_types: ItemLocalMap(),\n             node_substs: ItemLocalMap(),\n+            user_substs: ItemLocalMap(),\n             adjustments: ItemLocalMap(),\n             pat_binding_modes: ItemLocalMap(),\n             pat_adjustments: ItemLocalMap(),\n@@ -561,6 +574,18 @@ impl<'tcx> TypeckTables<'tcx> {\n         self.node_substs.get(&id.local_id).cloned()\n     }\n \n+    pub fn user_substs_mut(&mut self) -> LocalTableInContextMut<CanonicalSubsts<'tcx>> {\n+        LocalTableInContextMut {\n+            local_id_root: self.local_id_root,\n+            data: &mut self.user_substs\n+        }\n+    }\n+\n+    pub fn user_substs(&self, id: hir::HirId) -> Option<CanonicalSubsts<'tcx>> {\n+        validate_hir_id_for_typeck_tables(self.local_id_root, id, false);\n+        self.user_substs.get(&id.local_id).cloned()\n+    }\n+\n     // Returns the type of a pattern as a monotype. Like @expr_ty, this function\n     // doesn't provide type parameter substitutions.\n     pub fn pat_ty(&self, pat: &hir::Pat) -> Ty<'tcx> {\n@@ -740,6 +765,7 @@ impl<'a, 'gcx> HashStable<StableHashingContext<'a>> for TypeckTables<'gcx> {\n             ref user_provided_tys,\n             ref node_types,\n             ref node_substs,\n+            ref user_substs,\n             ref adjustments,\n             ref pat_binding_modes,\n             ref pat_adjustments,\n@@ -762,6 +788,7 @@ impl<'a, 'gcx> HashStable<StableHashingContext<'a>> for TypeckTables<'gcx> {\n             user_provided_tys.hash_stable(hcx, hasher);\n             node_types.hash_stable(hcx, hasher);\n             node_substs.hash_stable(hcx, hasher);\n+            user_substs.hash_stable(hcx, hasher);\n             adjustments.hash_stable(hcx, hasher);\n             pat_binding_modes.hash_stable(hcx, hasher);\n             pat_adjustments.hash_stable(hcx, hasher);"}, {"sha": "6dadc5070368b3c4eb77d64c20243b6318b1771e", "filename": "src/librustc/ty/subst.rs", "status": "modified", "additions": 30, "deletions": 1, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/d95f078f0af28203c379365574a433ca5b79e9d8/src%2Flibrustc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d95f078f0af28203c379365574a433ca5b79e9d8/src%2Flibrustc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsubst.rs?ref=d95f078f0af28203c379365574a433ca5b79e9d8", "patch": "@@ -11,13 +11,15 @@\n // Type substitutions.\n \n use hir::def_id::DefId;\n-use ty::{self, Lift, List, Ty, TyCtxt};\n+use infer::canonical::Canonical;\n+use ty::{self, CanonicalVar, Lift, List, Ty, TyCtxt};\n use ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n \n use serialize::{self, Encodable, Encoder, Decodable, Decoder};\n use syntax_pos::{Span, DUMMY_SP};\n use rustc_data_structures::accumulate_vec::AccumulateVec;\n use rustc_data_structures::array_vec::ArrayVec;\n+use rustc_data_structures::indexed_vec::Idx;\n \n use core::intrinsics;\n use std::cmp::Ordering;\n@@ -339,6 +341,33 @@ impl<'tcx> TypeFoldable<'tcx> for &'tcx Substs<'tcx> {\n     }\n }\n \n+pub type CanonicalSubsts<'gcx> = Canonical<'gcx, &'gcx Substs<'gcx>>;\n+\n+impl<'gcx> CanonicalSubsts<'gcx> {\n+    /// True if this represents a substitution like\n+    ///\n+    /// ```text\n+    /// [?0, ?1, ?2]\n+    /// ```\n+    ///\n+    /// i.e., each thing is mapped to a canonical variable with the same index.\n+    pub fn is_identity(&self) -> bool {\n+        self.value.iter().zip(CanonicalVar::new(0)..).all(|(kind, cvar)| {\n+            match kind.unpack() {\n+                UnpackedKind::Type(ty) => match ty.sty {\n+                    ty::Infer(ty::CanonicalTy(cvar1)) => cvar == cvar1,\n+                    _ => false,\n+                },\n+\n+                UnpackedKind::Lifetime(r) => match r {\n+                    ty::ReCanonical(cvar1) => cvar == *cvar1,\n+                    _ => false,\n+                },\n+            }\n+        })\n+    }\n+}\n+\n impl<'tcx> serialize::UseSpecializedDecodable for &'tcx Substs<'tcx> {}\n \n ///////////////////////////////////////////////////////////////////////////"}, {"sha": "e301e5ae70be8a9723634bf56220f1d88badc838", "filename": "src/librustc_codegen_llvm/mir/rvalue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d95f078f0af28203c379365574a433ca5b79e9d8/src%2Flibrustc_codegen_llvm%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d95f078f0af28203c379365574a433ca5b79e9d8/src%2Flibrustc_codegen_llvm%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Frvalue.rs?ref=d95f078f0af28203c379365574a433ca5b79e9d8", "patch": "@@ -148,7 +148,7 @@ impl FunctionCx<'a, 'll, 'tcx> {\n \n             mir::Rvalue::Aggregate(ref kind, ref operands) => {\n                 let (dest, active_field_index) = match **kind {\n-                    mir::AggregateKind::Adt(adt_def, variant_index, _, active_field_index) => {\n+                    mir::AggregateKind::Adt(adt_def, variant_index, _, _, active_field_index) => {\n                         dest.codegen_set_discr(&bx, variant_index);\n                         if adt_def.is_enum() {\n                             (dest.project_downcast(&bx, variant_index), active_field_index)"}, {"sha": "5c14e552cfd37e6c19ba21ba0743f17e0b65ab22", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 68, "deletions": 5, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/d95f078f0af28203c379365574a433ca5b79e9d8/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d95f078f0af28203c379365574a433ca5b79e9d8/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=d95f078f0af28203c379365574a433ca5b79e9d8", "patch": "@@ -15,7 +15,7 @@ use borrow_check::borrow_set::BorrowSet;\n use borrow_check::location::LocationTable;\n use borrow_check::nll::constraints::{ConstraintSet, OutlivesConstraint};\n use borrow_check::nll::facts::AllFacts;\n-use borrow_check::nll::region_infer::values::{RegionValueElements, LivenessValues};\n+use borrow_check::nll::region_infer::values::{LivenessValues, RegionValueElements};\n use borrow_check::nll::region_infer::{ClosureRegionRequirementsExt, TypeTest};\n use borrow_check::nll::type_check::free_region_relations::{CreateResult, UniversalRegionRelations};\n use borrow_check::nll::type_check::liveness::liveness_map::NllLivenessMap;\n@@ -256,6 +256,22 @@ impl<'a, 'b, 'gcx, 'tcx> Visitor<'tcx> for TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n         self.super_constant(constant, location);\n         self.sanitize_constant(constant, location);\n         self.sanitize_type(constant, constant.ty);\n+\n+        if let Some(user_ty) = constant.user_ty {\n+            if let Err(terr) =\n+                self.cx\n+                    .eq_canonical_type_and_type(user_ty, constant.ty, location.boring())\n+            {\n+                span_mirbug!(\n+                    self,\n+                    constant,\n+                    \"bad constant user type {:?} vs {:?}: {:?}\",\n+                    user_ty,\n+                    constant.ty,\n+                    terr,\n+                );\n+            }\n+        }\n     }\n \n     fn visit_rvalue(&mut self, rvalue: &Rvalue<'tcx>, location: Location) {\n@@ -343,8 +359,7 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n \n         debug!(\"sanitize_constant: expected_ty={:?}\", constant.literal.ty);\n \n-        if let Err(terr) = self\n-            .cx\n+        if let Err(terr) = self.cx\n             .eq_types(constant.literal.ty, constant.ty, location.boring())\n         {\n             span_mirbug!(\n@@ -902,6 +917,24 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                         terr\n                     );\n                 }\n+\n+                if let Some(user_ty) = self.rvalue_user_ty(rv) {\n+                    if let Err(terr) = self.eq_canonical_type_and_type(\n+                        user_ty,\n+                        rv_ty,\n+                        location.boring(),\n+                    ) {\n+                        span_mirbug!(\n+                            self,\n+                            stmt,\n+                            \"bad user type on rvalue ({:?} = {:?}): {:?}\",\n+                            user_ty,\n+                            rv_ty,\n+                            terr\n+                        );\n+                    }\n+                }\n+\n                 self.check_rvalue(mir, rv, location);\n                 if !self.tcx().features().unsized_locals {\n                     let trait_ref = ty::TraitRef {\n@@ -1376,7 +1409,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         let tcx = self.tcx();\n \n         match *ak {\n-            AggregateKind::Adt(def, variant_index, substs, active_field_index) => {\n+            AggregateKind::Adt(def, variant_index, substs, _, active_field_index) => {\n                 let variant = &def.variants[variant_index];\n                 let adj_field_index = active_field_index.unwrap_or(field_index);\n                 if let Some(field) = variant.fields.get(adj_field_index) {\n@@ -1542,6 +1575,36 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         }\n     }\n \n+    /// If this rvalue supports a user-given type annotation, then\n+    /// extract and return it. This represents the final type of the\n+    /// rvalue and will be unified with the inferred type.\n+    fn rvalue_user_ty(\n+        &self,\n+        rvalue: &Rvalue<'tcx>,\n+    ) -> Option<CanonicalTy<'tcx>> {\n+        match rvalue {\n+            Rvalue::Use(_) |\n+            Rvalue::Repeat(..) |\n+            Rvalue::Ref(..) |\n+            Rvalue::Len(..) |\n+            Rvalue::Cast(..) |\n+            Rvalue::BinaryOp(..) |\n+            Rvalue::CheckedBinaryOp(..) |\n+            Rvalue::NullaryOp(..) |\n+            Rvalue::UnaryOp(..) |\n+            Rvalue::Discriminant(..) =>\n+                None,\n+\n+            Rvalue::Aggregate(aggregate, _) => match **aggregate {\n+                AggregateKind::Adt(_, _, _, user_ty, _) => user_ty,\n+                AggregateKind::Array(_) => None,\n+                AggregateKind::Tuple => None,\n+                AggregateKind::Closure(_, _) => None,\n+                AggregateKind::Generator(_, _, _) => None,\n+            }\n+        }\n+    }\n+\n     fn check_aggregate_rvalue(\n         &mut self,\n         mir: &Mir<'tcx>,\n@@ -1735,7 +1798,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         );\n \n         let instantiated_predicates = match aggregate_kind {\n-            AggregateKind::Adt(def, _, substs, _) => {\n+            AggregateKind::Adt(def, _, substs, _, _) => {\n                 tcx.predicates_of(def.did).instantiate(tcx, substs)\n             }\n "}, {"sha": "1106f750d6d24b4c0722f955defbcdf25a77318e", "filename": "src/librustc_mir/build/expr/as_constant.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d95f078f0af28203c379365574a433ca5b79e9d8/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_constant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d95f078f0af28203c379365574a433ca5b79e9d8/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_constant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_constant.rs?ref=d95f078f0af28203c379365574a433ca5b79e9d8", "patch": "@@ -31,8 +31,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         match kind {\n             ExprKind::Scope { region_scope: _, lint_level: _, value } =>\n                 this.as_constant(value),\n-            ExprKind::Literal { literal } =>\n-                Constant { span: span, ty: ty, literal: literal },\n+            ExprKind::Literal { literal, user_ty } =>\n+                Constant { span, ty, user_ty, literal },\n             _ =>\n                 span_bug!(\n                     span,"}, {"sha": "b90a58f2a7ec040f8c48cd102d657805fcd45f5c", "filename": "src/librustc_mir/build/expr/as_rvalue.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d95f078f0af28203c379365574a433ca5b79e9d8/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d95f078f0af28203c379365574a433ca5b79e9d8/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=d95f078f0af28203c379365574a433ca5b79e9d8", "patch": "@@ -239,6 +239,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                         operands.push(Operand::Constant(box Constant {\n                             span: expr_span,\n                             ty: this.hir.tcx().types.u32,\n+                            user_ty: None,\n                             literal: ty::Const::from_bits(\n                                 this.hir.tcx(),\n                                 0,\n@@ -254,7 +255,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 block.and(Rvalue::Aggregate(result, operands))\n             }\n             ExprKind::Adt {\n-                adt_def, variant_index, substs, fields, base\n+                adt_def, variant_index, substs, user_ty, fields, base\n             } => { // see (*) above\n                 let is_union = adt_def.is_union();\n                 let active_field_index = if is_union { Some(fields[0].name.index()) } else { None };\n@@ -284,8 +285,13 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     field_names.iter().filter_map(|n| fields_map.get(n).cloned()).collect()\n                 };\n \n-                let adt =\n-                    box AggregateKind::Adt(adt_def, variant_index, substs, active_field_index);\n+                let adt = box AggregateKind::Adt(\n+                    adt_def,\n+                    variant_index,\n+                    substs,\n+                    user_ty,\n+                    active_field_index,\n+                );\n                 block.and(Rvalue::Aggregate(adt, fields))\n             }\n             ExprKind::Assign { .. } |"}, {"sha": "3cd1270d7ef11698baa93a71938559d1b549ab05", "filename": "src/librustc_mir/build/expr/into.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d95f078f0af28203c379365574a433ca5b79e9d8/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d95f078f0af28203c379365574a433ca5b79e9d8/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs?ref=d95f078f0af28203c379365574a433ca5b79e9d8", "patch": "@@ -128,6 +128,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     Constant {\n                         span: expr_span,\n                         ty: this.hir.bool_ty(),\n+                        user_ty: None,\n                         literal: this.hir.true_literal(),\n                     });\n \n@@ -136,6 +137,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     Constant {\n                         span: expr_span,\n                         ty: this.hir.bool_ty(),\n+                        user_ty: None,\n                         literal: this.hir.false_literal(),\n                     });\n "}, {"sha": "4a0b4b0c88580ffcd8f822333acdd72f788c8ed8", "filename": "src/librustc_mir/build/matches/test.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d95f078f0af28203c379365574a433ca5b79e9d8/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d95f078f0af28203c379365574a433ca5b79e9d8/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs?ref=d95f078f0af28203c379365574a433ca5b79e9d8", "patch": "@@ -344,7 +344,16 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                         func: Operand::Constant(box Constant {\n                             span: test.span,\n                             ty: mty,\n-                            literal: method\n+\n+                            // FIXME(#47184): This constant comes from user\n+                            // input (a constant in a pattern).  Are\n+                            // there forms where users can add type\n+                            // annotations here?  For example, an\n+                            // associated constant? Need to\n+                            // experiment.\n+                            user_ty: None,\n+\n+                            literal: method,\n                         }),\n                         args: vec![val, expect],\n                         destination: Some((eq_result.clone(), eq_block)),"}, {"sha": "9405f43c056b7a6e72352d89e47b192825c4456d", "filename": "src/librustc_mir/build/misc.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d95f078f0af28203c379365574a433ca5b79e9d8/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d95f078f0af28203c379365574a433ca5b79e9d8/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs?ref=d95f078f0af28203c379365574a433ca5b79e9d8", "patch": "@@ -32,6 +32,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         place\n     }\n \n+    /// Convenience function for creating a literal operand, one\n+    /// without any user type annotation.\n     pub fn literal_operand(&mut self,\n                            span: Span,\n                            ty: Ty<'tcx>,\n@@ -40,6 +42,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         let constant = box Constant {\n             span,\n             ty,\n+            user_ty: None,\n             literal,\n         };\n         Operand::Constant(constant)\n@@ -69,6 +72,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             Constant {\n                 span: source_info.span,\n                 ty: self.hir.usize_ty(),\n+                user_ty: None,\n                 literal: self.hir.usize_literal(value),\n             });\n         temp"}, {"sha": "7153a388467a245b621de722c226588defe01bf7", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 105, "deletions": 23, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/d95f078f0af28203c379365574a433ca5b79e9d8/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d95f078f0af28203c379365574a433ca5b79e9d8/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=d95f078f0af28203c379365574a433ca5b79e9d8", "patch": "@@ -256,6 +256,16 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                 };\n                 if let Some((adt_def, index)) = adt_data {\n                     let substs = cx.tables().node_substs(fun.hir_id);\n+\n+                    let user_ty = cx.tables().user_substs(fun.hir_id)\n+                        .map(|user_substs| {\n+                            user_substs.unchecked_map(|user_substs| {\n+                                // Here, we just pair an `AdtDef` with the\n+                                // `user_substs`, so no new types etc are introduced.\n+                                cx.tcx().mk_adt(adt_def, user_substs)\n+                            })\n+                        });\n+\n                     let field_refs = args.iter()\n                         .enumerate()\n                         .map(|(idx, e)| {\n@@ -270,6 +280,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                         substs,\n                         variant_index: index,\n                         fields: field_refs,\n+                        user_ty,\n                         base: None,\n                     }\n                 } else {\n@@ -317,6 +328,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n \n         hir::ExprKind::Lit(ref lit) => ExprKind::Literal {\n             literal: cx.const_eval_literal(&lit.node, expr_ty, lit.span, false),\n+            user_ty: None,\n         },\n \n         hir::ExprKind::Binary(op, ref lhs, ref rhs) => {\n@@ -406,6 +418,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                 if let hir::ExprKind::Lit(ref lit) = arg.node {\n                     ExprKind::Literal {\n                         literal: cx.const_eval_literal(&lit.node, expr_ty, lit.span, true),\n+                        user_ty: None,\n                     }\n                 } else {\n                     ExprKind::Unary {\n@@ -425,6 +438,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                 adt_def: adt,\n                                 variant_index: 0,\n                                 substs,\n+                                user_ty: user_annotated_ty_for_adt(cx, expr.hir_id, adt),\n                                 fields: field_refs(cx, fields),\n                                 base: base.as_ref().map(|base| {\n                                     FruInfo {\n@@ -450,6 +464,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                         adt_def: adt,\n                                         variant_index: index,\n                                         substs,\n+                                        user_ty: user_annotated_ty_for_adt(cx, expr.hir_id, adt),\n                                         fields: field_refs(cx, fields),\n                                         base: None,\n                                     }\n@@ -631,7 +646,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                         temp_lifetime,\n                         ty,\n                         span: expr.span,\n-                        kind: ExprKind::Literal { literal },\n+                        kind: ExprKind::Literal { literal, user_ty: None },\n                     }.to_ref();\n                     let offset = mk_const(ty::Const::from_bits(\n                         cx.tcx,\n@@ -684,25 +699,85 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n     }\n }\n \n-fn method_callee<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n-                                 expr: &hir::Expr,\n-                                 custom_callee: Option<(DefId, &'tcx Substs<'tcx>)>)\n-                                 -> Expr<'tcx> {\n+fn user_annotated_ty_for_def(\n+    cx: &mut Cx<'a, 'gcx, 'tcx>,\n+    hir_id: hir::HirId,\n+    def: &Def,\n+) -> Option<CanonicalTy<'tcx>> {\n+    match def {\n+        // A reference to something callable -- e.g., a fn, method, or\n+        // a tuple-struct or tuple-variant. This has the type of a\n+        // `Fn` but with the user-given substitutions.\n+        Def::Fn(_) |\n+        Def::Method(_) |\n+        Def::StructCtor(_, CtorKind::Fn) |\n+        Def::VariantCtor(_, CtorKind::Fn) =>\n+            Some(cx.tables().user_substs(hir_id)?.unchecked_map(|user_substs| {\n+                // Here, we just pair a `DefId` with the\n+                // `user_substs`, so no new types etc are introduced.\n+                cx.tcx().mk_fn_def(def.def_id(), user_substs)\n+            })),\n+\n+        Def::Const(_def_id) |\n+        Def::AssociatedConst(_def_id) =>\n+            bug!(\"unimplemented\"),\n+\n+        // A unit struct/variant which is used as a value (e.g.,\n+        // `None`). This has the type of the enum/struct that defines\n+        // this variant -- but with the substitutions given by the\n+        // user.\n+        Def::StructCtor(_def_id, CtorKind::Const) |\n+        Def::VariantCtor(_def_id, CtorKind::Const) =>\n+            match &cx.tables().node_id_to_type(hir_id).sty {\n+                ty::Adt(adt_def, _) => user_annotated_ty_for_adt(cx, hir_id, adt_def),\n+                sty => bug!(\"unexpected sty: {:?}\", sty),\n+            },\n+\n+        _ =>\n+            bug!(\"user_annotated_ty_for_def: unexpected def {:?} at {:?}\", def, hir_id)\n+    }\n+}\n+\n+fn user_annotated_ty_for_adt(\n+    cx: &mut Cx<'a, 'gcx, 'tcx>,\n+    hir_id: hir::HirId,\n+    adt_def: &'tcx AdtDef,\n+) -> Option<CanonicalTy<'tcx>> {\n+    let user_substs = cx.tables().user_substs(hir_id)?;\n+    Some(user_substs.unchecked_map(|user_substs| {\n+        // Here, we just pair an `AdtDef` with the\n+        // `user_substs`, so no new types etc are introduced.\n+        cx.tcx().mk_adt(adt_def, user_substs)\n+    }))\n+}\n+\n+fn method_callee<'a, 'gcx, 'tcx>(\n+    cx: &mut Cx<'a, 'gcx, 'tcx>,\n+    expr: &hir::Expr,\n+    overloaded_callee: Option<(DefId, &'tcx Substs<'tcx>)>,\n+) -> Expr<'tcx> {\n     let temp_lifetime = cx.region_scope_tree.temporary_scope(expr.hir_id.local_id);\n-    let (def_id, substs) = custom_callee.unwrap_or_else(|| {\n-        if let Some(def) = cx.tables().type_dependent_defs().get(expr.hir_id) {\n-            (def.def_id(), cx.tables().node_substs(expr.hir_id))\n-        } else {\n-            span_bug!(expr.span, \"no type-dependent def for method callee\")\n+    let (def_id, substs, user_ty) = match overloaded_callee {\n+        Some((def_id, substs)) => (def_id, substs, None),\n+        None => {\n+            let type_dependent_defs = cx.tables().type_dependent_defs();\n+            let def = type_dependent_defs\n+                .get(expr.hir_id)\n+                .unwrap_or_else(|| {\n+                    span_bug!(expr.span, \"no type-dependent def for method callee\")\n+                });\n+            let user_ty = user_annotated_ty_for_def(cx, expr.hir_id, def);\n+            (def.def_id(), cx.tables().node_substs(expr.hir_id), user_ty)\n         }\n-    });\n+    };\n     let ty = cx.tcx().mk_fn_def(def_id, substs);\n     Expr {\n         temp_lifetime,\n         ty,\n         span: expr.span,\n         kind: ExprKind::Literal {\n             literal: ty::Const::zero_sized(cx.tcx(), ty),\n+            user_ty,\n         },\n     }\n }\n@@ -753,11 +828,15 @@ fn convert_path_expr<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         Def::Fn(_) |\n         Def::Method(_) |\n         Def::StructCtor(_, CtorKind::Fn) |\n-        Def::VariantCtor(_, CtorKind::Fn) => ExprKind::Literal {\n-            literal: ty::Const::zero_sized(\n-                cx.tcx,\n-                cx.tables().node_id_to_type(expr.hir_id),\n-            ),\n+        Def::VariantCtor(_, CtorKind::Fn) => {\n+            let user_ty = user_annotated_ty_for_def(cx, expr.hir_id, &def);\n+            ExprKind::Literal {\n+                literal: ty::Const::zero_sized(\n+                    cx.tcx,\n+                    cx.tables().node_id_to_type(expr.hir_id),\n+                ),\n+                user_ty,\n+            }\n         },\n \n         Def::Const(def_id) |\n@@ -768,6 +847,7 @@ fn convert_path_expr<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                 substs,\n                 cx.tables().node_id_to_type(expr.hir_id),\n             ),\n+            user_ty: None, // FIXME(#47184) -- user given type annot on constants\n         },\n \n         Def::StructCtor(def_id, CtorKind::Const) |\n@@ -780,6 +860,7 @@ fn convert_path_expr<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                         adt_def,\n                         variant_index: adt_def.variant_index_with_id(def_id),\n                         substs,\n+                        user_ty: user_annotated_ty_for_adt(cx, expr.hir_id, adt_def),\n                         fields: vec![],\n                         base: None,\n                     }\n@@ -958,12 +1039,13 @@ fn overloaded_operator<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n     }\n }\n \n-fn overloaded_place<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n-                                     expr: &'tcx hir::Expr,\n-                                     place_ty: Ty<'tcx>,\n-                                     custom_callee: Option<(DefId, &'tcx Substs<'tcx>)>,\n-                                     args: Vec<ExprRef<'tcx>>)\n-                                     -> ExprKind<'tcx> {\n+fn overloaded_place<'a, 'gcx, 'tcx>(\n+    cx: &mut Cx<'a, 'gcx, 'tcx>,\n+    expr: &'tcx hir::Expr,\n+    place_ty: Ty<'tcx>,\n+    overloaded_callee: Option<(DefId, &'tcx Substs<'tcx>)>,\n+    args: Vec<ExprRef<'tcx>>,\n+) -> ExprKind<'tcx> {\n     // For an overloaded *x or x[y] expression of type T, the method\n     // call returns an &T and we must add the deref so that the types\n     // line up (this is because `*x` and `x[y]` represent places):\n@@ -988,7 +1070,7 @@ fn overloaded_place<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n     // construct the complete expression `foo()` for the overloaded call,\n     // which will yield the &T type\n     let temp_lifetime = cx.region_scope_tree.temporary_scope(expr.hir_id.local_id);\n-    let fun = method_callee(cx, expr, custom_callee);\n+    let fun = method_callee(cx, expr, overloaded_callee);\n     let ref_expr = Expr {\n         temp_lifetime,\n         ty: ref_ty,"}, {"sha": "d6037adb53bb7a8a5161e626846df7491b38cde0", "filename": "src/librustc_mir/hair/mod.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d95f078f0af28203c379365574a433ca5b79e9d8/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d95f078f0af28203c379365574a433ca5b79e9d8/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fmod.rs?ref=d95f078f0af28203c379365574a433ca5b79e9d8", "patch": "@@ -18,7 +18,7 @@ use rustc::mir::{BinOp, BorrowKind, Field, UnOp};\n use rustc::hir::def_id::DefId;\n use rustc::middle::region;\n use rustc::ty::subst::Substs;\n-use rustc::ty::{AdtDef, UpvarSubsts, Region, Ty, Const};\n+use rustc::ty::{AdtDef, CanonicalTy, UpvarSubsts, Region, Ty, Const};\n use rustc::hir;\n use syntax::ast;\n use syntax_pos::Span;\n@@ -261,6 +261,11 @@ pub enum ExprKind<'tcx> {\n         adt_def: &'tcx AdtDef,\n         variant_index: usize,\n         substs: &'tcx Substs<'tcx>,\n+\n+        /// Optional user-given substs: for something like `let x =\n+        /// Bar::<T> { ... }`.\n+        user_ty: Option<CanonicalTy<'tcx>>,\n+\n         fields: Vec<FieldExprRef<'tcx>>,\n         base: Option<FruInfo<'tcx>>\n     },\n@@ -272,6 +277,13 @@ pub enum ExprKind<'tcx> {\n     },\n     Literal {\n         literal: &'tcx Const<'tcx>,\n+\n+        /// Optional user-given type: for something like\n+        /// `collect::<Vec<_>>`, this would be present and would\n+        /// indicate that `Vec<_>` was explicitly specified.\n+        ///\n+        /// Needed for NLL to impose user-given type constraints.\n+        user_ty: Option<CanonicalTy<'tcx>>,\n     },\n     InlineAsm {\n         asm: &'tcx hir::InlineAsm,"}, {"sha": "db556db241773beff77a2cac748d13034af835bb", "filename": "src/librustc_mir/interpret/step.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d95f078f0af28203c379365574a433ca5b79e9d8/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d95f078f0af28203c379365574a433ca5b79e9d8/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fstep.rs?ref=d95f078f0af28203c379365574a433ca5b79e9d8", "patch": "@@ -208,7 +208,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n \n             Aggregate(ref kind, ref operands) => {\n                 let (dest, active_field_index) = match **kind {\n-                    mir::AggregateKind::Adt(adt_def, variant_index, _, active_field_index) => {\n+                    mir::AggregateKind::Adt(adt_def, variant_index, _, _, active_field_index) => {\n                         self.write_discriminant_value(variant_index, dest)?;\n                         if adt_def.is_enum() {\n                             (self.place_downcast(dest, variant_index)?, active_field_index)"}, {"sha": "7e7e7cfade6238f2e12100e6e06b4c7ddfdb0db6", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d95f078f0af28203c379365574a433ca5b79e9d8/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d95f078f0af28203c379365574a433ca5b79e9d8/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=d95f078f0af28203c379365574a433ca5b79e9d8", "patch": "@@ -440,6 +440,7 @@ impl<'a, 'tcx> CloneShimBuilder<'a, 'tcx> {\n         let func = Operand::Constant(box Constant {\n             span: self.span,\n             ty: func_ty,\n+            user_ty: None,\n             literal: ty::Const::zero_sized(self.tcx, func_ty),\n         });\n \n@@ -498,6 +499,7 @@ impl<'a, 'tcx> CloneShimBuilder<'a, 'tcx> {\n         box Constant {\n             span: self.span,\n             ty: self.tcx.types.usize,\n+            user_ty: None,\n             literal: ty::Const::from_usize(self.tcx, value),\n         }\n     }\n@@ -725,6 +727,7 @@ fn build_call_shim<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             (Operand::Constant(box Constant {\n                 span,\n                 ty,\n+                user_ty: None,\n                 literal: ty::Const::zero_sized(tcx, ty),\n              }),\n              vec![rcvr])\n@@ -847,7 +850,7 @@ pub fn build_adt_ctor<'a, 'gcx, 'tcx>(infcx: &infer::InferCtxt<'a, 'gcx, 'tcx>,\n             kind: StatementKind::Assign(\n                 Place::Local(RETURN_PLACE),\n                 Rvalue::Aggregate(\n-                    box AggregateKind::Adt(adt_def, variant_no, substs, None),\n+                    box AggregateKind::Adt(adt_def, variant_no, substs, None, None),\n                     (1..sig.inputs().len()+1).map(|i| {\n                         Operand::Move(Place::Local(Local::new(i)))\n                     }).collect()"}, {"sha": "cff098c7b73d594e6a8dd9f1e2dc5e9fc83a1ad1", "filename": "src/librustc_mir/transform/deaggregator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d95f078f0af28203c379365574a433ca5b79e9d8/src%2Flibrustc_mir%2Ftransform%2Fdeaggregator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d95f078f0af28203c379365574a433ca5b79e9d8/src%2Flibrustc_mir%2Ftransform%2Fdeaggregator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fdeaggregator.rs?ref=d95f078f0af28203c379365574a433ca5b79e9d8", "patch": "@@ -48,7 +48,7 @@ impl MirPass for Deaggregator {\n \n                 let mut set_discriminant = None;\n                 let active_field_index = match *kind {\n-                    AggregateKind::Adt(adt_def, variant_index, _, active_field_index) => {\n+                    AggregateKind::Adt(adt_def, variant_index, _, _, active_field_index) => {\n                         if adt_def.is_enum() {\n                             set_discriminant = Some(Statement {\n                                 kind: StatementKind::SetDiscriminant {"}, {"sha": "225de03a329651d252e4bc7ee32aeaf2479bbc78", "filename": "src/librustc_mir/transform/elaborate_drops.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d95f078f0af28203c379365574a433ca5b79e9d8/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d95f078f0af28203c379365574a433ca5b79e9d8/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs?ref=d95f078f0af28203c379365574a433ca5b79e9d8", "patch": "@@ -543,6 +543,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n         Rvalue::Use(Operand::Constant(Box::new(Constant {\n             span,\n             ty: self.tcx.types.bool,\n+            user_ty: None,\n             literal: ty::Const::from_bool(self.tcx, val),\n         })))\n     }"}, {"sha": "db588884d8e6183e056230e7ce4a24accbc4fcd2", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d95f078f0af28203c379365574a433ca5b79e9d8/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d95f078f0af28203c379365574a433ca5b79e9d8/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=d95f078f0af28203c379365574a433ca5b79e9d8", "patch": "@@ -157,7 +157,7 @@ struct TransformVisitor<'a, 'tcx: 'a> {\n impl<'a, 'tcx> TransformVisitor<'a, 'tcx> {\n     // Make a GeneratorState rvalue\n     fn make_state(&self, idx: usize, val: Operand<'tcx>) -> Rvalue<'tcx> {\n-        let adt = AggregateKind::Adt(self.state_adt_ref, idx, self.state_substs, None);\n+        let adt = AggregateKind::Adt(self.state_adt_ref, idx, self.state_substs, None, None);\n         Rvalue::Aggregate(box adt, vec![val])\n     }\n \n@@ -177,6 +177,7 @@ impl<'a, 'tcx> TransformVisitor<'a, 'tcx> {\n         let val = Operand::Constant(box Constant {\n             span: source_info.span,\n             ty: self.tcx.types.u32,\n+            user_ty: None,\n             literal: ty::Const::from_bits(\n                 self.tcx,\n                 state_disc.into(),\n@@ -710,6 +711,7 @@ fn insert_panic_block<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         cond: Operand::Constant(box Constant {\n             span: mir.span,\n             ty: tcx.types.bool,\n+            user_ty: None,\n             literal: ty::Const::from_bool(tcx, false),\n         }),\n         expected: true,"}, {"sha": "12780ef8be945483416abc4cce8611c3df56ec7c", "filename": "src/librustc_mir/transform/instcombine.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d95f078f0af28203c379365574a433ca5b79e9d8/src%2Flibrustc_mir%2Ftransform%2Finstcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d95f078f0af28203c379365574a433ca5b79e9d8/src%2Flibrustc_mir%2Ftransform%2Finstcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finstcombine.rs?ref=d95f078f0af28203c379365574a433ca5b79e9d8", "patch": "@@ -103,7 +103,7 @@ impl<'b, 'a, 'tcx> Visitor<'tcx> for OptimizationFinder<'b, 'a, 'tcx> {\n             if let TyKind::Array(_, len) = place_ty.sty {\n                 let span = self.mir.source_info(location).span;\n                 let ty = self.tcx.types.usize;\n-                let constant = Constant { span, ty, literal: len };\n+                let constant = Constant { span, ty, literal: len, user_ty: None };\n                 self.optimizations.arrays_lengths.insert(location, constant);\n             }\n         }"}, {"sha": "1c0c98d621c83325a97b53ded27c6d31d9cb5afa", "filename": "src/librustc_mir/util/elaborate_drops.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d95f078f0af28203c379365574a433ca5b79e9d8/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d95f078f0af28203c379365574a433ca5b79e9d8/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs?ref=d95f078f0af28203c379365574a433ca5b79e9d8", "patch": "@@ -969,6 +969,7 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n         Operand::Constant(box Constant {\n             span: self.source_info.span,\n             ty: self.tcx().types.usize,\n+            user_ty: None,\n             literal: ty::Const::from_usize(self.tcx(), val.into()),\n         })\n     }"}, {"sha": "e0643d8f978103a1a3a91dc707e6011ca44bc3ab", "filename": "src/librustc_mir/util/pretty.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d95f078f0af28203c379365574a433ca5b79e9d8/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d95f078f0af28203c379365574a433ca5b79e9d8/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fpretty.rs?ref=d95f078f0af28203c379365574a433ca5b79e9d8", "patch": "@@ -397,10 +397,13 @@ impl<'cx, 'gcx, 'tcx> ExtraComments<'cx, 'gcx, 'tcx> {\n impl<'cx, 'gcx, 'tcx> Visitor<'tcx> for ExtraComments<'cx, 'gcx, 'tcx> {\n     fn visit_constant(&mut self, constant: &Constant<'tcx>, location: Location) {\n         self.super_constant(constant, location);\n-        let Constant { span, ty, literal } = constant;\n+        let Constant { span, ty, user_ty, literal } = constant;\n         self.push(\"mir::Constant\");\n         self.push(&format!(\"+ span: {:?}\", span));\n         self.push(&format!(\"+ ty: {:?}\", ty));\n+        if let Some(user_ty) = user_ty {\n+            self.push(&format!(\"+ user_ty: {:?}\", user_ty));\n+        }\n         self.push(&format!(\"+ literal: {:?}\", literal));\n     }\n \n@@ -429,6 +432,11 @@ impl<'cx, 'gcx, 'tcx> Visitor<'tcx> for ExtraComments<'cx, 'gcx, 'tcx> {\n                     self.push(&format!(\"+ movability: {:?}\", movability));\n                 }\n \n+                AggregateKind::Adt(_, _, _, Some(user_ty), _) => {\n+                    self.push(\"adt\");\n+                    self.push(&format!(\"+ user_ty: {:?}\", user_ty));\n+                }\n+\n                 _ => {}\n             },\n "}, {"sha": "9d4481ce6d4144d8c9e7579b3318c0366191533b", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d95f078f0af28203c379365574a433ca5b79e9d8/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d95f078f0af28203c379365574a433ca5b79e9d8/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=d95f078f0af28203c379365574a433ca5b79e9d8", "patch": "@@ -1367,7 +1367,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n                      -> Ty<'tcx> {\n         let tcx = self.tcx();\n \n-        debug!(\"base_def_to_ty(def={:?}, opt_self_ty={:?}, path_segments={:?})\",\n+        debug!(\"def_to_ty(def={:?}, opt_self_ty={:?}, path_segments={:?})\",\n                path.def, opt_self_ty, path.segments);\n \n         let span = path.span;"}, {"sha": "819827abd05a1caf6dff3db619dd5f0c64c5e825", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 77, "deletions": 2, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/d95f078f0af28203c379365574a433ca5b79e9d8/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d95f078f0af28203c379365574a433ca5b79e9d8/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=d95f078f0af28203c379365574a433ca5b79e9d8", "patch": "@@ -95,7 +95,7 @@ use rustc::infer::anon_types::AnonTypeDecl;\n use rustc::infer::type_variable::{TypeVariableOrigin};\n use rustc::middle::region;\n use rustc::mir::interpret::{GlobalId};\n-use rustc::ty::subst::{UnpackedKind, Subst, Substs};\n+use rustc::ty::subst::{CanonicalSubsts, UnpackedKind, Subst, Substs};\n use rustc::traits::{self, ObligationCause, ObligationCauseCode, TraitEngine};\n use rustc::ty::{self, Ty, TyCtxt, GenericParamDefKind, Visibility, ToPredicate, RegionKind};\n use rustc::ty::adjustment::{Adjust, Adjustment, AllowTwoPhase, AutoBorrow, AutoBorrowMutability};\n@@ -122,6 +122,7 @@ use std::ops::{self, Deref};\n use rustc_target::spec::abi::Abi;\n use syntax::ast;\n use syntax::attr;\n+use syntax::source_map::DUMMY_SP;\n use syntax::source_map::original_sp;\n use syntax::feature_gate::{GateIssue, emit_feature_err};\n use syntax::ptr::P;\n@@ -2058,11 +2059,47 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     pub fn write_method_call(&self,\n                              hir_id: hir::HirId,\n                              method: MethodCallee<'tcx>) {\n+        debug!(\"write_method_call(hir_id={:?}, method={:?})\", hir_id, method);\n         self.tables\n             .borrow_mut()\n             .type_dependent_defs_mut()\n             .insert(hir_id, Def::Method(method.def_id));\n+\n         self.write_substs(hir_id, method.substs);\n+\n+        // When the method is confirmed, the `method.substs` includes\n+        // parameters from not just the method, but also the impl of\n+        // the method -- in particular, the `Self` type will be fully\n+        // resolved. However, those are not something that the \"user\n+        // specified\" -- i.e., those types come from the inferred type\n+        // of the receiver, not something the user wrote. So when we\n+        // create the user-substs, we want to replace those earlier\n+        // types with just the types that the user actually wrote --\n+        // that is, those that appear on the *method itself*.\n+        //\n+        // As an example, if the user wrote something like\n+        // `foo.bar::<u32>(...)` -- the `Self` type here will be the\n+        // type of `foo` (possibly adjusted), but we don't want to\n+        // include that. We want just the `[_, u32]` part.\n+        if !method.substs.is_noop() {\n+            let method_generics = self.tcx.generics_of(method.def_id);\n+            if !method_generics.params.is_empty() {\n+                let user_substs = self.infcx.probe(|_| {\n+                    let just_method_substs = Substs::for_item(self.tcx, method.def_id, |param, _| {\n+                        let i = param.index as usize;\n+                        if i < method_generics.parent_count {\n+                            self.infcx.var_for_def(DUMMY_SP, param)\n+                        } else {\n+                            method.substs[i]\n+                        }\n+                    });\n+                    self.infcx.canonicalize_response(&just_method_substs)\n+                });\n+\n+                debug!(\"write_method_call: user_substs = {:?}\", user_substs);\n+                self.write_user_substs(hir_id, user_substs);\n+            }\n+        }\n     }\n \n     pub fn write_substs(&self, node_id: hir::HirId, substs: &'tcx Substs<'tcx>) {\n@@ -2076,6 +2113,36 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n+    /// Given the substs that we just converted from the HIR, try to\n+    /// canonicalize them and store them as user-given substitutions\n+    /// (i.e., substitutions that must be respected by the NLL check).\n+    ///\n+    /// This should be invoked **before any unifications have\n+    /// occurred**, so that annotations like `Vec<_>` are preserved\n+    /// properly.\n+    pub fn write_user_substs_from_substs(&self, hir_id: hir::HirId, substs: &'tcx Substs<'tcx>) {\n+        if !substs.is_noop() {\n+            let user_substs = self.infcx.canonicalize_response(&substs);\n+            debug!(\"instantiate_value_path: user_substs = {:?}\", user_substs);\n+            self.write_user_substs(hir_id, user_substs);\n+        }\n+    }\n+\n+    pub fn write_user_substs(&self, hir_id: hir::HirId, substs: CanonicalSubsts<'tcx>) {\n+        debug!(\n+            \"write_user_substs({:?}, {:?}) in fcx {}\",\n+            hir_id,\n+            substs,\n+            self.tag(),\n+        );\n+\n+        if !substs.is_identity() {\n+            self.tables.borrow_mut().user_substs_mut().insert(hir_id, substs);\n+        } else {\n+            debug!(\"write_user_substs: skipping identity substs\");\n+        }\n+    }\n+\n     pub fn apply_adjustments(&self, expr: &hir::Expr, adj: Vec<Adjustment<'tcx>>) {\n         debug!(\"apply_adjustments(expr={:?}, adj={:?})\", expr, adj);\n \n@@ -3544,6 +3611,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         };\n \n         if let Some((variant, did, substs)) = variant {\n+            debug!(\"check_struct_path: did={:?} substs={:?}\", did, substs);\n+            let hir_id = self.tcx.hir.node_to_hir_id(node_id);\n+            self.write_user_substs_from_substs(hir_id, substs);\n+\n             // Check bounds on type arguments used in the path.\n             let bounds = self.instantiate_bounds(path_span, did, substs);\n             let cause = traits::ObligationCause::new(path_span, self.body_id,\n@@ -5083,7 +5154,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         debug!(\"instantiate_value_path: type of {:?} is {:?}\",\n                node_id,\n                ty_substituted);\n-        self.write_substs(self.tcx.hir.node_to_hir_id(node_id), substs);\n+        let hir_id = self.tcx.hir.node_to_hir_id(node_id);\n+        self.write_substs(hir_id, substs);\n+\n+        self.write_user_substs_from_substs(hir_id, substs);\n+\n         ty_substituted\n     }\n "}, {"sha": "0d8401c1c86efafd66ea4c4606283f795fc21b09", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 25, "deletions": 1, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/d95f078f0af28203c379365574a433ca5b79e9d8/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d95f078f0af28203c379365574a433ca5b79e9d8/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=d95f078f0af28203c379365574a433ca5b79e9d8", "patch": "@@ -35,7 +35,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let item_id = self.tcx.hir.body_owner(body.id());\n         let item_def_id = self.tcx.hir.local_def_id(item_id);\n \n-        let mut wbcx = WritebackCx::new(self, body);\n+        // This attribute causes us to dump some writeback information\n+        // in the form of errors, which is used for unit tests.\n+        let rustc_dump_user_substs = self.tcx.has_attr(item_def_id, \"rustc_dump_user_substs\");\n+\n+        let mut wbcx = WritebackCx::new(self, body, rustc_dump_user_substs);\n         for arg in &body.arguments {\n             wbcx.visit_node_id(arg.pat.span, arg.hir_id);\n         }\n@@ -84,19 +88,23 @@ struct WritebackCx<'cx, 'gcx: 'cx + 'tcx, 'tcx: 'cx> {\n     tables: ty::TypeckTables<'gcx>,\n \n     body: &'gcx hir::Body,\n+\n+    rustc_dump_user_substs: bool,\n }\n \n impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n     fn new(\n         fcx: &'cx FnCtxt<'cx, 'gcx, 'tcx>,\n         body: &'gcx hir::Body,\n+        rustc_dump_user_substs: bool,\n     ) -> WritebackCx<'cx, 'gcx, 'tcx> {\n         let owner = fcx.tcx.hir.definitions().node_to_hir_id(body.id().node_id);\n \n         WritebackCx {\n             fcx,\n             tables: ty::TypeckTables::empty(Some(DefId::local(owner.owner))),\n             body,\n+            rustc_dump_user_substs,\n         }\n     }\n \n@@ -558,6 +566,22 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n             assert!(!substs.needs_infer() && !substs.has_skol());\n             self.tables.node_substs_mut().insert(hir_id, substs);\n         }\n+\n+        // Copy over any user-substs\n+        if let Some(user_substs) = self.fcx.tables.borrow().user_substs(hir_id) {\n+            let user_substs = self.tcx().lift_to_global(&user_substs).unwrap();\n+            self.tables.user_substs_mut().insert(hir_id, user_substs);\n+\n+            // Unit-testing mechanism:\n+            if self.rustc_dump_user_substs {\n+                let node_id = self.tcx().hir.hir_to_node_id(hir_id);\n+                let span = self.tcx().hir.span(node_id);\n+                self.tcx().sess.span_err(\n+                    span,\n+                    &format!(\"user substs: {:?}\", user_substs),\n+                );\n+            }\n+        }\n     }\n \n     fn visit_adjustments(&mut self, span: Span, hir_id: hir::HirId) {"}, {"sha": "e2a22167b7e45627a9e562de61b50a46d1b64e43", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d95f078f0af28203c379365574a433ca5b79e9d8/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d95f078f0af28203c379365574a433ca5b79e9d8/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=d95f078f0af28203c379365574a433ca5b79e9d8", "patch": "@@ -865,6 +865,12 @@ pub const BUILTIN_ATTRIBUTES: &'static [(&'static str, AttributeType, AttributeG\n                                         is just used for rustc unit tests \\\n                                         and will never be stable\",\n                                        cfg_fn!(rustc_attrs))),\n+    (\"rustc_dump_user_substs\", Whitelisted, Gated(Stability::Unstable,\n+                                       \"rustc_attrs\",\n+                                       \"this attribute \\\n+                                        is just used for rustc unit tests \\\n+                                        and will never be stable\",\n+                                       cfg_fn!(rustc_attrs))),\n     (\"rustc_if_this_changed\", Whitelisted, Gated(Stability::Unstable,\n                                                  \"rustc_attrs\",\n                                                  \"the `#[rustc_if_this_changed]` attribute \\"}, {"sha": "bb4e922fdc0d23cebb585281ecbebdd1583d839e", "filename": "src/test/ui/hr-subtype/hr-subtype.free_inv_x_vs_free_inv_y.nll.stderr", "status": "modified", "additions": 27, "deletions": 11, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/d95f078f0af28203c379365574a433ca5b79e9d8/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.free_inv_x_vs_free_inv_y.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d95f078f0af28203c379365574a433ca5b79e9d8/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.free_inv_x_vs_free_inv_y.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.free_inv_x_vs_free_inv_y.nll.stderr?ref=d95f078f0af28203c379365574a433ca5b79e9d8", "patch": "@@ -18,17 +18,33 @@ LL | / check! { free_inv_x_vs_free_inv_y: (fn(Inv<'x>),\n LL | |                                     fn(Inv<'y>)) }\n    | |__________________________________________________- in this macro invocation\n \n-error: compilation successful\n-  --> $DIR/hr-subtype.rs:110:1\n+error: unsatisfied lifetime constraints\n+  --> $DIR/hr-subtype.rs:43:13\n    |\n-LL | / fn main() {\n-LL | | //[bound_a_vs_bound_a]~^ ERROR compilation successful\n-LL | | //[bound_a_vs_bound_b]~^^ ERROR compilation successful\n-LL | | //[bound_inv_a_vs_bound_inv_b]~^^^ ERROR compilation successful\n-LL | | //[bound_co_a_vs_bound_co_b]~^^^^ ERROR compilation successful\n-LL | | //[free_x_vs_free_x]~^^^^^ ERROR compilation successful\n-LL | | }\n-   | |_^\n+LL |           fn subtype<'x,'y:'x,'z:'y>() {\n+   |                      -- -- lifetime `'y` defined here\n+   |                      |\n+   |                      lifetime `'x` defined here\n+LL |               gimme::<$t2>(None::<$t1>);\n+   |               ^^^^^^^^^^^^^^^^^^^^^^^^^ argument requires that `'x` must outlive `'y`\n+...\n+LL | / check! { free_inv_x_vs_free_inv_y: (fn(Inv<'x>),\n+LL | |                                     fn(Inv<'y>)) }\n+   | |__________________________________________________- in this macro invocation\n+\n+error: unsatisfied lifetime constraints\n+  --> $DIR/hr-subtype.rs:49:13\n+   |\n+LL |           fn supertype<'x,'y:'x,'z:'y>() {\n+   |                        -- -- lifetime `'y` defined here\n+   |                        |\n+   |                        lifetime `'x` defined here\n+LL |               gimme::<$t1>(None::<$t2>);\n+   |               ^^^^^^^^^^^^^^^^^^^^^^^^^ argument requires that `'x` must outlive `'y`\n+...\n+LL | / check! { free_inv_x_vs_free_inv_y: (fn(Inv<'x>),\n+LL | |                                     fn(Inv<'y>)) }\n+   | |__________________________________________________- in this macro invocation\n \n-error: aborting due to previous error\n+error: aborting due to 2 previous errors\n "}, {"sha": "c33e6fbfde72ca9bd87f752b655f7f284ba3b333", "filename": "src/test/ui/hr-subtype/hr-subtype.free_x_vs_free_y.nll.stderr", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d95f078f0af28203c379365574a433ca5b79e9d8/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.free_x_vs_free_y.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d95f078f0af28203c379365574a433ca5b79e9d8/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.free_x_vs_free_y.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.free_x_vs_free_y.nll.stderr?ref=d95f078f0af28203c379365574a433ca5b79e9d8", "patch": "@@ -8,17 +8,19 @@ LL | / check! { free_x_vs_free_y: (fn(&'x u32),\n LL | |                             fn(&'y u32)) }\n    | |__________________________________________- in this macro invocation\n \n-error: compilation successful\n-  --> $DIR/hr-subtype.rs:110:1\n+error: unsatisfied lifetime constraints\n+  --> $DIR/hr-subtype.rs:49:13\n    |\n-LL | / fn main() {\n-LL | | //[bound_a_vs_bound_a]~^ ERROR compilation successful\n-LL | | //[bound_a_vs_bound_b]~^^ ERROR compilation successful\n-LL | | //[bound_inv_a_vs_bound_inv_b]~^^^ ERROR compilation successful\n-LL | | //[bound_co_a_vs_bound_co_b]~^^^^ ERROR compilation successful\n-LL | | //[free_x_vs_free_x]~^^^^^ ERROR compilation successful\n-LL | | }\n-   | |_^\n+LL |           fn supertype<'x,'y:'x,'z:'y>() {\n+   |                        -- -- lifetime `'y` defined here\n+   |                        |\n+   |                        lifetime `'x` defined here\n+LL |               gimme::<$t1>(None::<$t2>);\n+   |               ^^^^^^^^^^^^^^^^^^^^^^^^^ argument requires that `'x` must outlive `'y`\n+...\n+LL | / check! { free_x_vs_free_y: (fn(&'x u32),\n+LL | |                             fn(&'y u32)) }\n+   | |__________________________________________- in this macro invocation\n \n error: aborting due to previous error\n "}, {"sha": "4465be414bc2ce01f51a3bed435e3ea5a71c3d87", "filename": "src/test/ui/nll/user-annotations/adt-brace-enums.rs", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/d95f078f0af28203c379365574a433ca5b79e9d8/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fadt-brace-enums.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d95f078f0af28203c379365574a433ca5b79e9d8/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fadt-brace-enums.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fadt-brace-enums.rs?ref=d95f078f0af28203c379365574a433ca5b79e9d8", "patch": "@@ -0,0 +1,62 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Unit test for the \"user substitutions\" that are annotated on each\n+// node.\n+\n+#![feature(nll)]\n+\n+enum SomeEnum<T> {\n+    SomeVariant { t: T }\n+}\n+\n+fn no_annot() {\n+    let c = 66;\n+    SomeEnum::SomeVariant { t: &c };\n+}\n+\n+fn annot_underscore() {\n+    let c = 66;\n+    SomeEnum::SomeVariant::<_> { t: &c };\n+}\n+\n+fn annot_reference_any_lifetime() {\n+    let c = 66;\n+    SomeEnum::SomeVariant::<&u32> { t: &c };\n+}\n+\n+fn annot_reference_static_lifetime() {\n+    let c = 66;\n+    SomeEnum::SomeVariant::<&'static u32> { t: &c }; //~ ERROR\n+}\n+\n+fn annot_reference_named_lifetime<'a>(_d: &'a u32) {\n+    let c = 66;\n+    SomeEnum::SomeVariant::<&'a u32> { t: &c }; //~ ERROR\n+}\n+\n+fn annot_reference_named_lifetime_ok<'a>(c: &'a u32) {\n+    SomeEnum::SomeVariant::<&'a u32> { t: c };\n+}\n+\n+fn annot_reference_named_lifetime_in_closure<'a>(_: &'a u32) {\n+    let _closure = || {\n+        let c = 66;\n+        SomeEnum::SomeVariant::<&'a u32> { t: &c }; //~ ERROR\n+    };\n+}\n+\n+fn annot_reference_named_lifetime_in_closure_ok<'a>(c: &'a u32) {\n+    let _closure = || {\n+        SomeEnum::SomeVariant::<&'a u32> { t: c };\n+    };\n+}\n+\n+fn main() { }"}, {"sha": "842bb622bc323b360563eb0d02deedb2dd7fd562", "filename": "src/test/ui/nll/user-annotations/adt-brace-enums.stderr", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/d95f078f0af28203c379365574a433ca5b79e9d8/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fadt-brace-enums.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d95f078f0af28203c379365574a433ca5b79e9d8/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fadt-brace-enums.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fadt-brace-enums.stderr?ref=d95f078f0af28203c379365574a433ca5b79e9d8", "patch": "@@ -0,0 +1,41 @@\n+error[E0597]: `c` does not live long enough\n+  --> $DIR/adt-brace-enums.rs:37:48\n+   |\n+LL |     SomeEnum::SomeVariant::<&'static u32> { t: &c }; //~ ERROR\n+   |                                                ^^ borrowed value does not live long enough\n+LL | }\n+   | - `c` dropped here while still borrowed\n+   |\n+   = note: borrowed value must be valid for the static lifetime...\n+\n+error[E0597]: `c` does not live long enough\n+  --> $DIR/adt-brace-enums.rs:42:43\n+   |\n+LL |     SomeEnum::SomeVariant::<&'a u32> { t: &c }; //~ ERROR\n+   |                                           ^^ borrowed value does not live long enough\n+LL | }\n+   | - `c` dropped here while still borrowed\n+   |\n+note: borrowed value must be valid for the lifetime 'a as defined on the function body at 40:35...\n+  --> $DIR/adt-brace-enums.rs:40:35\n+   |\n+LL | fn annot_reference_named_lifetime<'a>(_d: &'a u32) {\n+   |                                   ^^\n+\n+error[E0597]: `c` does not live long enough\n+  --> $DIR/adt-brace-enums.rs:52:47\n+   |\n+LL |         SomeEnum::SomeVariant::<&'a u32> { t: &c }; //~ ERROR\n+   |                                               ^^ borrowed value does not live long enough\n+LL |     };\n+   |     - `c` dropped here while still borrowed\n+   |\n+note: borrowed value must be valid for the lifetime 'a as defined on the function body at 49:46...\n+  --> $DIR/adt-brace-enums.rs:49:46\n+   |\n+LL | fn annot_reference_named_lifetime_in_closure<'a>(_: &'a u32) {\n+   |                                              ^^\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0597`."}, {"sha": "c479e05056447a3bb0c8fd9feea6633df7001cb2", "filename": "src/test/ui/nll/user-annotations/adt-brace-structs.rs", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/d95f078f0af28203c379365574a433ca5b79e9d8/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fadt-brace-structs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d95f078f0af28203c379365574a433ca5b79e9d8/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fadt-brace-structs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fadt-brace-structs.rs?ref=d95f078f0af28203c379365574a433ca5b79e9d8", "patch": "@@ -0,0 +1,60 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Unit test for the \"user substitutions\" that are annotated on each\n+// node.\n+\n+#![feature(nll)]\n+\n+struct SomeStruct<T> { t: T }\n+\n+fn no_annot() {\n+    let c = 66;\n+    SomeStruct { t: &c };\n+}\n+\n+fn annot_underscore() {\n+    let c = 66;\n+    SomeStruct::<_> { t: &c };\n+}\n+\n+fn annot_reference_any_lifetime() {\n+    let c = 66;\n+    SomeStruct::<&u32> { t: &c };\n+}\n+\n+fn annot_reference_static_lifetime() {\n+    let c = 66;\n+    SomeStruct::<&'static u32> { t: &c }; //~ ERROR\n+}\n+\n+fn annot_reference_named_lifetime<'a>(_d: &'a u32) {\n+    let c = 66;\n+    SomeStruct::<&'a u32> { t: &c }; //~ ERROR\n+}\n+\n+fn annot_reference_named_lifetime_ok<'a>(c: &'a u32) {\n+    SomeStruct::<&'a u32> { t: c };\n+}\n+\n+fn annot_reference_named_lifetime_in_closure<'a>(_: &'a u32) {\n+    let _closure = || {\n+        let c = 66;\n+        SomeStruct::<&'a u32> { t: &c }; //~ ERROR\n+    };\n+}\n+\n+fn annot_reference_named_lifetime_in_closure_ok<'a>(c: &'a u32) {\n+    let _closure = || {\n+        SomeStruct::<&'a u32> { t: c };\n+    };\n+}\n+\n+fn main() { }"}, {"sha": "7ba76212dc5204b058904235c83dba9183deba9d", "filename": "src/test/ui/nll/user-annotations/adt-brace-structs.stderr", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/d95f078f0af28203c379365574a433ca5b79e9d8/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fadt-brace-structs.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d95f078f0af28203c379365574a433ca5b79e9d8/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fadt-brace-structs.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fadt-brace-structs.stderr?ref=d95f078f0af28203c379365574a433ca5b79e9d8", "patch": "@@ -0,0 +1,41 @@\n+error[E0597]: `c` does not live long enough\n+  --> $DIR/adt-brace-structs.rs:35:37\n+   |\n+LL |     SomeStruct::<&'static u32> { t: &c }; //~ ERROR\n+   |                                     ^^ borrowed value does not live long enough\n+LL | }\n+   | - `c` dropped here while still borrowed\n+   |\n+   = note: borrowed value must be valid for the static lifetime...\n+\n+error[E0597]: `c` does not live long enough\n+  --> $DIR/adt-brace-structs.rs:40:32\n+   |\n+LL |     SomeStruct::<&'a u32> { t: &c }; //~ ERROR\n+   |                                ^^ borrowed value does not live long enough\n+LL | }\n+   | - `c` dropped here while still borrowed\n+   |\n+note: borrowed value must be valid for the lifetime 'a as defined on the function body at 38:35...\n+  --> $DIR/adt-brace-structs.rs:38:35\n+   |\n+LL | fn annot_reference_named_lifetime<'a>(_d: &'a u32) {\n+   |                                   ^^\n+\n+error[E0597]: `c` does not live long enough\n+  --> $DIR/adt-brace-structs.rs:50:36\n+   |\n+LL |         SomeStruct::<&'a u32> { t: &c }; //~ ERROR\n+   |                                    ^^ borrowed value does not live long enough\n+LL |     };\n+   |     - `c` dropped here while still borrowed\n+   |\n+note: borrowed value must be valid for the lifetime 'a as defined on the function body at 47:46...\n+  --> $DIR/adt-brace-structs.rs:47:46\n+   |\n+LL | fn annot_reference_named_lifetime_in_closure<'a>(_: &'a u32) {\n+   |                                              ^^\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0597`."}, {"sha": "df62b67a4598f59f4ee3ccb5d49abf339fea8141", "filename": "src/test/ui/nll/user-annotations/adt-nullary-enums.rs", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/d95f078f0af28203c379365574a433ca5b79e9d8/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fadt-nullary-enums.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d95f078f0af28203c379365574a433ca5b79e9d8/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fadt-nullary-enums.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fadt-nullary-enums.rs?ref=d95f078f0af28203c379365574a433ca5b79e9d8", "patch": "@@ -0,0 +1,80 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Unit test for the \"user substitutions\" that are annotated on each\n+// node.\n+\n+#![feature(nll)]\n+#![allow(warnings)]\n+\n+use std::cell::Cell;\n+\n+enum SomeEnum<T> {\n+    SomeVariant(T),\n+    SomeOtherVariant,\n+}\n+\n+fn combine<T>(_: T, _: T) { }\n+\n+fn no_annot() {\n+    let c = 66;\n+    combine(SomeEnum::SomeVariant(Cell::new(&c)), SomeEnum::SomeOtherVariant);\n+}\n+\n+fn annot_underscore() {\n+    let c = 66;\n+    combine(SomeEnum::SomeVariant(Cell::new(&c)), SomeEnum::SomeOtherVariant::<Cell<_>>);\n+}\n+\n+fn annot_reference_any_lifetime() {\n+    let c = 66;\n+    combine(SomeEnum::SomeVariant(Cell::new(&c)), SomeEnum::SomeOtherVariant::<Cell<&u32>>);\n+}\n+\n+fn annot_reference_static_lifetime() {\n+    let c = 66;\n+    combine(\n+        SomeEnum::SomeVariant(Cell::new(&c)), //~ ERROR\n+        SomeEnum::SomeOtherVariant::<Cell<&'static u32>>,\n+    );\n+}\n+\n+fn annot_reference_named_lifetime<'a>(_d: &'a u32) {\n+    let c = 66;\n+    combine(\n+        SomeEnum::SomeVariant(Cell::new(&c)), //~ ERROR\n+        SomeEnum::SomeOtherVariant::<Cell<&'a u32>>,\n+    );\n+}\n+\n+fn annot_reference_named_lifetime_ok<'a>(c: &'a u32) {\n+    combine(SomeEnum::SomeVariant(Cell::new(c)), SomeEnum::SomeOtherVariant::<Cell<&'a u32>>);\n+}\n+\n+fn annot_reference_named_lifetime_in_closure<'a>(_: &'a u32) {\n+    let _closure = || {\n+        let c = 66;\n+        combine(\n+            SomeEnum::SomeVariant(Cell::new(&c)), //~ ERROR\n+            SomeEnum::SomeOtherVariant::<Cell<&'a u32>>,\n+        );\n+    };\n+}\n+\n+fn annot_reference_named_lifetime_in_closure_ok<'a>(c: &'a u32) {\n+    let _closure = || {\n+        combine(\n+            SomeEnum::SomeVariant(Cell::new(c)),\n+            SomeEnum::SomeOtherVariant::<Cell<&'a u32>>,\n+        );\n+    };\n+}\n+\n+fn main() { }"}, {"sha": "fa251f3df17b9765c43736cc1082a4d00d974ed7", "filename": "src/test/ui/nll/user-annotations/adt-nullary-enums.stderr", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/d95f078f0af28203c379365574a433ca5b79e9d8/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fadt-nullary-enums.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d95f078f0af28203c379365574a433ca5b79e9d8/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fadt-nullary-enums.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fadt-nullary-enums.stderr?ref=d95f078f0af28203c379365574a433ca5b79e9d8", "patch": "@@ -0,0 +1,44 @@\n+error[E0597]: `c` does not live long enough\n+  --> $DIR/adt-nullary-enums.rs:44:41\n+   |\n+LL |         SomeEnum::SomeVariant(Cell::new(&c)), //~ ERROR\n+   |                                         ^^ borrowed value does not live long enough\n+...\n+LL | }\n+   | - `c` dropped here while still borrowed\n+   |\n+   = note: borrowed value must be valid for the static lifetime...\n+\n+error[E0597]: `c` does not live long enough\n+  --> $DIR/adt-nullary-enums.rs:52:41\n+   |\n+LL |         SomeEnum::SomeVariant(Cell::new(&c)), //~ ERROR\n+   |                                         ^^ borrowed value does not live long enough\n+...\n+LL | }\n+   | - `c` dropped here while still borrowed\n+   |\n+note: borrowed value must be valid for the lifetime 'a as defined on the function body at 49:35...\n+  --> $DIR/adt-nullary-enums.rs:49:35\n+   |\n+LL | fn annot_reference_named_lifetime<'a>(_d: &'a u32) {\n+   |                                   ^^\n+\n+error[E0597]: `c` does not live long enough\n+  --> $DIR/adt-nullary-enums.rs:65:45\n+   |\n+LL |             SomeEnum::SomeVariant(Cell::new(&c)), //~ ERROR\n+   |                                             ^^ borrowed value does not live long enough\n+...\n+LL |     };\n+   |     - `c` dropped here while still borrowed\n+   |\n+note: borrowed value must be valid for the lifetime 'a as defined on the function body at 61:46...\n+  --> $DIR/adt-nullary-enums.rs:61:46\n+   |\n+LL | fn annot_reference_named_lifetime_in_closure<'a>(_: &'a u32) {\n+   |                                              ^^\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0597`."}, {"sha": "ae75a54f649900ba3d5ed73cdf7539117ffb02d8", "filename": "src/test/ui/nll/user-annotations/adt-tuple-enums.rs", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/d95f078f0af28203c379365574a433ca5b79e9d8/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fadt-tuple-enums.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d95f078f0af28203c379365574a433ca5b79e9d8/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fadt-tuple-enums.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fadt-tuple-enums.rs?ref=d95f078f0af28203c379365574a433ca5b79e9d8", "patch": "@@ -0,0 +1,64 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Unit test for the \"user substitutions\" that are annotated on each\n+// node.\n+\n+#![feature(nll)]\n+#![allow(warnings)]\n+\n+enum SomeEnum<T> {\n+    SomeVariant(T),\n+    SomeOtherVariant,\n+}\n+\n+fn no_annot() {\n+    let c = 66;\n+    SomeEnum::SomeVariant(&c);\n+}\n+\n+fn annot_underscore() {\n+    let c = 66;\n+    SomeEnum::SomeVariant::<_>(&c);\n+}\n+\n+fn annot_reference_any_lifetime() {\n+    let c = 66;\n+    SomeEnum::SomeVariant::<&u32>(&c);\n+}\n+\n+fn annot_reference_static_lifetime() {\n+    let c = 66;\n+    SomeEnum::SomeVariant::<&'static u32>(&c); //~ ERROR\n+}\n+\n+fn annot_reference_named_lifetime<'a>(_d: &'a u32) {\n+    let c = 66;\n+    SomeEnum::SomeVariant::<&'a u32>(&c); //~ ERROR\n+}\n+\n+fn annot_reference_named_lifetime_ok<'a>(c: &'a u32) {\n+    SomeEnum::SomeVariant::<&'a u32>(c);\n+}\n+\n+fn annot_reference_named_lifetime_in_closure<'a>(_: &'a u32) {\n+    let _closure = || {\n+        let c = 66;\n+        SomeEnum::SomeVariant::<&'a u32>(&c); //~ ERROR\n+    };\n+}\n+\n+fn annot_reference_named_lifetime_in_closure_ok<'a>(c: &'a u32) {\n+    let _closure = || {\n+        SomeEnum::SomeVariant::<&'a u32>(c);\n+    };\n+}\n+\n+fn main() { }"}, {"sha": "18d1cc7e087937290196f3ab111cf227308145f1", "filename": "src/test/ui/nll/user-annotations/adt-tuple-enums.stderr", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/d95f078f0af28203c379365574a433ca5b79e9d8/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fadt-tuple-enums.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d95f078f0af28203c379365574a433ca5b79e9d8/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fadt-tuple-enums.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fadt-tuple-enums.stderr?ref=d95f078f0af28203c379365574a433ca5b79e9d8", "patch": "@@ -0,0 +1,41 @@\n+error[E0597]: `c` does not live long enough\n+  --> $DIR/adt-tuple-enums.rs:39:43\n+   |\n+LL |     SomeEnum::SomeVariant::<&'static u32>(&c); //~ ERROR\n+   |                                           ^^ borrowed value does not live long enough\n+LL | }\n+   | - `c` dropped here while still borrowed\n+   |\n+   = note: borrowed value must be valid for the static lifetime...\n+\n+error[E0597]: `c` does not live long enough\n+  --> $DIR/adt-tuple-enums.rs:44:38\n+   |\n+LL |     SomeEnum::SomeVariant::<&'a u32>(&c); //~ ERROR\n+   |                                      ^^ borrowed value does not live long enough\n+LL | }\n+   | - `c` dropped here while still borrowed\n+   |\n+note: borrowed value must be valid for the lifetime 'a as defined on the function body at 42:35...\n+  --> $DIR/adt-tuple-enums.rs:42:35\n+   |\n+LL | fn annot_reference_named_lifetime<'a>(_d: &'a u32) {\n+   |                                   ^^\n+\n+error[E0597]: `c` does not live long enough\n+  --> $DIR/adt-tuple-enums.rs:54:42\n+   |\n+LL |         SomeEnum::SomeVariant::<&'a u32>(&c); //~ ERROR\n+   |                                          ^^ borrowed value does not live long enough\n+LL |     };\n+   |     - `c` dropped here while still borrowed\n+   |\n+note: borrowed value must be valid for the lifetime 'a as defined on the function body at 51:46...\n+  --> $DIR/adt-tuple-enums.rs:51:46\n+   |\n+LL | fn annot_reference_named_lifetime_in_closure<'a>(_: &'a u32) {\n+   |                                              ^^\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0597`."}, {"sha": "401a71c1fe5aabe675c2a768f359d850d56bc9c8", "filename": "src/test/ui/nll/user-annotations/adt-tuple-struct.rs", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/d95f078f0af28203c379365574a433ca5b79e9d8/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fadt-tuple-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d95f078f0af28203c379365574a433ca5b79e9d8/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fadt-tuple-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fadt-tuple-struct.rs?ref=d95f078f0af28203c379365574a433ca5b79e9d8", "patch": "@@ -0,0 +1,60 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Unit test for the \"user substitutions\" that are annotated on each\n+// node.\n+\n+#![feature(nll)]\n+\n+struct SomeStruct<T>(T);\n+\n+fn no_annot() {\n+    let c = 66;\n+    SomeStruct(&c);\n+}\n+\n+fn annot_underscore() {\n+    let c = 66;\n+    SomeStruct::<_>(&c);\n+}\n+\n+fn annot_reference_any_lifetime() {\n+    let c = 66;\n+    SomeStruct::<&u32>(&c);\n+}\n+\n+fn annot_reference_static_lifetime() {\n+    let c = 66;\n+    SomeStruct::<&'static u32>(&c); //~ ERROR\n+}\n+\n+fn annot_reference_named_lifetime<'a>(_d: &'a u32) {\n+    let c = 66;\n+    SomeStruct::<&'a u32>(&c); //~ ERROR\n+}\n+\n+fn annot_reference_named_lifetime_ok<'a>(c: &'a u32) {\n+    SomeStruct::<&'a u32>(c);\n+}\n+\n+fn annot_reference_named_lifetime_in_closure<'a>(_: &'a u32) {\n+    let _closure = || {\n+        let c = 66;\n+        SomeStruct::<&'a u32>(&c); //~ ERROR\n+    };\n+}\n+\n+fn annot_reference_named_lifetime_in_closure_ok<'a>(c: &'a u32) {\n+    let _closure = || {\n+        SomeStruct::<&'a u32>(c);\n+    };\n+}\n+\n+fn main() { }"}, {"sha": "397016e52d0f7e72f854c637a66d0a3e675b8883", "filename": "src/test/ui/nll/user-annotations/adt-tuple-struct.stderr", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/d95f078f0af28203c379365574a433ca5b79e9d8/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fadt-tuple-struct.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d95f078f0af28203c379365574a433ca5b79e9d8/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fadt-tuple-struct.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fadt-tuple-struct.stderr?ref=d95f078f0af28203c379365574a433ca5b79e9d8", "patch": "@@ -0,0 +1,41 @@\n+error[E0597]: `c` does not live long enough\n+  --> $DIR/adt-tuple-struct.rs:35:32\n+   |\n+LL |     SomeStruct::<&'static u32>(&c); //~ ERROR\n+   |                                ^^ borrowed value does not live long enough\n+LL | }\n+   | - `c` dropped here while still borrowed\n+   |\n+   = note: borrowed value must be valid for the static lifetime...\n+\n+error[E0597]: `c` does not live long enough\n+  --> $DIR/adt-tuple-struct.rs:40:27\n+   |\n+LL |     SomeStruct::<&'a u32>(&c); //~ ERROR\n+   |                           ^^ borrowed value does not live long enough\n+LL | }\n+   | - `c` dropped here while still borrowed\n+   |\n+note: borrowed value must be valid for the lifetime 'a as defined on the function body at 38:35...\n+  --> $DIR/adt-tuple-struct.rs:38:35\n+   |\n+LL | fn annot_reference_named_lifetime<'a>(_d: &'a u32) {\n+   |                                   ^^\n+\n+error[E0597]: `c` does not live long enough\n+  --> $DIR/adt-tuple-struct.rs:50:31\n+   |\n+LL |         SomeStruct::<&'a u32>(&c); //~ ERROR\n+   |                               ^^ borrowed value does not live long enough\n+LL |     };\n+   |     - `c` dropped here while still borrowed\n+   |\n+note: borrowed value must be valid for the lifetime 'a as defined on the function body at 47:46...\n+  --> $DIR/adt-tuple-struct.rs:47:46\n+   |\n+LL | fn annot_reference_named_lifetime_in_closure<'a>(_: &'a u32) {\n+   |                                              ^^\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0597`."}, {"sha": "970fbf98af4ac4d8f1676dc32b883144266a87f7", "filename": "src/test/ui/nll/user-annotations/dump-adt-brace-struct.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/d95f078f0af28203c379365574a433ca5b79e9d8/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fdump-adt-brace-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d95f078f0af28203c379365574a433ca5b79e9d8/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fdump-adt-brace-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fdump-adt-brace-struct.rs?ref=d95f078f0af28203c379365574a433ca5b79e9d8", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Unit test for the \"user substitutions\" that are annotated on each\n+// node.\n+\n+// compile-flags:-Zverbose\n+\n+#![allow(warnings)]\n+#![feature(nll)]\n+#![feature(rustc_attrs)]\n+\n+struct SomeStruct<T> { t: T }\n+\n+#[rustc_dump_user_substs]\n+fn main() {\n+    SomeStruct { t: 22 }; // Nothing given, no annotation.\n+\n+    SomeStruct::<_> { t: 22 }; // Nothing interesting given, no annotation.\n+\n+    SomeStruct::<u32> { t: 22 }; //~ ERROR [u32]\n+}"}, {"sha": "2b0e5039d8d4ed4bdb1c71d7376939676c4f0318", "filename": "src/test/ui/nll/user-annotations/dump-adt-brace-struct.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d95f078f0af28203c379365574a433ca5b79e9d8/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fdump-adt-brace-struct.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d95f078f0af28203c379365574a433ca5b79e9d8/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fdump-adt-brace-struct.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fdump-adt-brace-struct.stderr?ref=d95f078f0af28203c379365574a433ca5b79e9d8", "patch": "@@ -0,0 +1,8 @@\n+error: user substs: Canonical { variables: [], value: [u32] }\n+  --> $DIR/dump-adt-brace-struct.rs:28:5\n+   |\n+LL |     SomeStruct::<u32> { t: 22 }; //~ ERROR [u32]\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "7f726d13a33ed4a53e1846c027c007379bb6a35f", "filename": "src/test/ui/nll/user-annotations/dump-fn-method.rs", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/d95f078f0af28203c379365574a433ca5b79e9d8/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fdump-fn-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d95f078f0af28203c379365574a433ca5b79e9d8/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fdump-fn-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fdump-fn-method.rs?ref=d95f078f0af28203c379365574a433ca5b79e9d8", "patch": "@@ -0,0 +1,59 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Unit test for the \"user substitutions\" that are annotated on each\n+// node.\n+\n+// compile-flags:-Zverbose\n+\n+#![feature(nll)]\n+#![feature(rustc_attrs)]\n+\n+// Note: we reference the names T and U in the comments below.\n+trait Bazoom<T> {\n+    fn method<U>(&self, arg: T, arg2: U) { }\n+}\n+\n+impl<T, U> Bazoom<U> for T {\n+}\n+\n+fn foo<'a, T>(_: T) { }\n+\n+#[rustc_dump_user_substs]\n+fn main() {\n+    // Here: nothing is given, so we don't have any annotation.\n+    let x = foo;\n+    x(22);\n+\n+    // Here: `u32` is given.\n+    let x = foo::<u32>; //~ ERROR [u32]\n+    x(22);\n+\n+    // Here: we only want the `T` to be given, the rest should be variables.\n+    //\n+    // (`T` refers to the declaration of `Bazoom`)\n+    let x = <_ as Bazoom<u32>>::method::<_>; //~ ERROR [?0, u32, ?1]\n+    x(&22, 44, 66);\n+\n+    // Here: all are given\n+    let x = <u8 as Bazoom<u16>>::method::<u32>; //~ ERROR [u8, u16, u32]\n+    x(&22, 44, 66);\n+\n+    // Here: we want in particular that *only* the method `U`\n+    // annotation is given, the rest are variables.\n+    //\n+    // (`U` refers to the declaration of `Bazoom`)\n+    let y = 22_u32;\n+    y.method::<u32>(44, 66); //~ ERROR [?0, ?1, u32]\n+\n+    // Here: nothing is given, so we don't have any annotation.\n+    let y = 22_u32;\n+    y.method(44, 66);\n+}"}, {"sha": "6531f87dd9878377e86357220548120e643ac5ed", "filename": "src/test/ui/nll/user-annotations/dump-fn-method.stderr", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/d95f078f0af28203c379365574a433ca5b79e9d8/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fdump-fn-method.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d95f078f0af28203c379365574a433ca5b79e9d8/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fdump-fn-method.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fdump-fn-method.stderr?ref=d95f078f0af28203c379365574a433ca5b79e9d8", "patch": "@@ -0,0 +1,26 @@\n+error: user substs: Canonical { variables: [], value: [u32] }\n+  --> $DIR/dump-fn-method.rs:36:13\n+   |\n+LL |     let x = foo::<u32>; //~ ERROR [u32]\n+   |             ^^^^^^^^^^\n+\n+error: user substs: Canonical { variables: [CanonicalVarInfo { kind: Ty(General) }, CanonicalVarInfo { kind: Ty(General) }], value: [?0, u32, ?1] }\n+  --> $DIR/dump-fn-method.rs:42:13\n+   |\n+LL |     let x = <_ as Bazoom<u32>>::method::<_>; //~ ERROR [?0, u32, ?1]\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: user substs: Canonical { variables: [], value: [u8, u16, u32] }\n+  --> $DIR/dump-fn-method.rs:46:13\n+   |\n+LL |     let x = <u8 as Bazoom<u16>>::method::<u32>; //~ ERROR [u8, u16, u32]\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: user substs: Canonical { variables: [CanonicalVarInfo { kind: Ty(General) }, CanonicalVarInfo { kind: Ty(General) }], value: [?0, ?1, u32] }\n+  --> $DIR/dump-fn-method.rs:54:5\n+   |\n+LL |     y.method::<u32>(44, 66); //~ ERROR [?0, ?1, u32]\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 4 previous errors\n+"}, {"sha": "4f26d5422b0a439e26f9590ef0985abe886fc38a", "filename": "src/test/ui/nll/user-annotations/fns.rs", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/d95f078f0af28203c379365574a433ca5b79e9d8/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Ffns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d95f078f0af28203c379365574a433ca5b79e9d8/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Ffns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Ffns.rs?ref=d95f078f0af28203c379365574a433ca5b79e9d8", "patch": "@@ -0,0 +1,60 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Unit test for the \"user substitutions\" that are annotated on each\n+// node.\n+\n+#![feature(nll)]\n+\n+fn some_fn<T>(arg: T) { }\n+\n+fn no_annot() {\n+    let c = 66;\n+    some_fn(&c); // OK\n+}\n+\n+fn annot_underscore() {\n+    let c = 66;\n+    some_fn::<_>(&c); // OK\n+}\n+\n+fn annot_reference_any_lifetime() {\n+    let c = 66;\n+    some_fn::<&u32>(&c); // OK\n+}\n+\n+fn annot_reference_static_lifetime() {\n+    let c = 66;\n+    some_fn::<&'static u32>(&c); //~ ERROR\n+}\n+\n+fn annot_reference_named_lifetime<'a>(_d: &'a u32) {\n+    let c = 66;\n+    some_fn::<&'a u32>(&c); //~ ERROR\n+}\n+\n+fn annot_reference_named_lifetime_ok<'a>(c: &'a u32) {\n+    some_fn::<&'a u32>(c);\n+}\n+\n+fn annot_reference_named_lifetime_in_closure<'a>(_: &'a u32) {\n+    let _closure = || {\n+        let c = 66;\n+        some_fn::<&'a u32>(&c); //~ ERROR\n+    };\n+}\n+\n+fn annot_reference_named_lifetime_in_closure_ok<'a>(c: &'a u32) {\n+    let _closure = || {\n+        some_fn::<&'a u32>(c);\n+    };\n+}\n+\n+fn main() { }"}, {"sha": "b6ef336567ca0da7b4cfed90140031314b992fe1", "filename": "src/test/ui/nll/user-annotations/fns.stderr", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/d95f078f0af28203c379365574a433ca5b79e9d8/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Ffns.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d95f078f0af28203c379365574a433ca5b79e9d8/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Ffns.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Ffns.stderr?ref=d95f078f0af28203c379365574a433ca5b79e9d8", "patch": "@@ -0,0 +1,41 @@\n+error[E0597]: `c` does not live long enough\n+  --> $DIR/fns.rs:35:29\n+   |\n+LL |     some_fn::<&'static u32>(&c); //~ ERROR\n+   |                             ^^ borrowed value does not live long enough\n+LL | }\n+   | - `c` dropped here while still borrowed\n+   |\n+   = note: borrowed value must be valid for the static lifetime...\n+\n+error[E0597]: `c` does not live long enough\n+  --> $DIR/fns.rs:40:24\n+   |\n+LL |     some_fn::<&'a u32>(&c); //~ ERROR\n+   |                        ^^ borrowed value does not live long enough\n+LL | }\n+   | - `c` dropped here while still borrowed\n+   |\n+note: borrowed value must be valid for the lifetime 'a as defined on the function body at 38:35...\n+  --> $DIR/fns.rs:38:35\n+   |\n+LL | fn annot_reference_named_lifetime<'a>(_d: &'a u32) {\n+   |                                   ^^\n+\n+error[E0597]: `c` does not live long enough\n+  --> $DIR/fns.rs:50:28\n+   |\n+LL |         some_fn::<&'a u32>(&c); //~ ERROR\n+   |                            ^^ borrowed value does not live long enough\n+LL |     };\n+   |     - `c` dropped here while still borrowed\n+   |\n+note: borrowed value must be valid for the lifetime 'a as defined on the function body at 47:46...\n+  --> $DIR/fns.rs:47:46\n+   |\n+LL | fn annot_reference_named_lifetime_in_closure<'a>(_: &'a u32) {\n+   |                                              ^^\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0597`."}, {"sha": "9a03679bef0a11411411dc2a9c6ce8f90021d35b", "filename": "src/test/ui/nll/user-annotations/method-call.rs", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/d95f078f0af28203c379365574a433ca5b79e9d8/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fmethod-call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d95f078f0af28203c379365574a433ca5b79e9d8/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fmethod-call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fmethod-call.rs?ref=d95f078f0af28203c379365574a433ca5b79e9d8", "patch": "@@ -0,0 +1,81 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Unit test for the \"user substitutions\" that are annotated on each\n+// node.\n+\n+#![feature(nll)]\n+\n+trait Bazoom<T> {\n+    fn method<U>(&self, arg: T, arg2: U) { }\n+}\n+\n+impl<T, U> Bazoom<U> for T {\n+}\n+\n+fn no_annot() {\n+    let a = 22;\n+    let b = 44;\n+    let c = 66;\n+    a.method(b,  &c); // OK\n+}\n+\n+fn annot_underscore() {\n+    let a = 22;\n+    let b = 44;\n+    let c = 66;\n+    a.method::<_>(b,  &c); // OK\n+}\n+\n+fn annot_reference_any_lifetime() {\n+    let a = 22;\n+    let b = 44;\n+    let c = 66;\n+    a.method::<&u32>(b,  &c); // OK\n+}\n+\n+fn annot_reference_static_lifetime() {\n+    let a = 22;\n+    let b = 44;\n+    let c = 66;\n+    a.method::<&'static u32>(b,  &c); //~ ERROR\n+}\n+\n+fn annot_reference_named_lifetime<'a>(_d: &'a u32) {\n+    let a = 22;\n+    let b = 44;\n+    let c = 66;\n+    a.method::<&'a u32>(b,  &c); //~ ERROR\n+}\n+\n+fn annot_reference_named_lifetime_ok<'a>(c: &'a u32) {\n+    let a = 22;\n+    let b = 44;\n+    a.method::<&'a u32>(b,  c);\n+}\n+\n+fn annot_reference_named_lifetime_in_closure<'a>(_: &'a u32) {\n+    let a = 22;\n+    let b = 44;\n+    let _closure = || {\n+        let c = 66;\n+        a.method::<&'a u32>(b,  &c); //~ ERROR\n+    };\n+}\n+\n+fn annot_reference_named_lifetime_in_closure_ok<'a>(c: &'a u32) {\n+    let a = 22;\n+    let b = 44;\n+    let _closure = || {\n+        a.method::<&'a u32>(b,  c);\n+    };\n+}\n+\n+fn main() { }"}, {"sha": "f1c7ff1e0fb19e98f1b844134a298da70ea9c591", "filename": "src/test/ui/nll/user-annotations/method-call.stderr", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/d95f078f0af28203c379365574a433ca5b79e9d8/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fmethod-call.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d95f078f0af28203c379365574a433ca5b79e9d8/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fmethod-call.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fmethod-call.stderr?ref=d95f078f0af28203c379365574a433ca5b79e9d8", "patch": "@@ -0,0 +1,41 @@\n+error[E0597]: `c` does not live long enough\n+  --> $DIR/method-call.rs:48:34\n+   |\n+LL |     a.method::<&'static u32>(b,  &c); //~ ERROR\n+   |                                  ^^ borrowed value does not live long enough\n+LL | }\n+   | - `c` dropped here while still borrowed\n+   |\n+   = note: borrowed value must be valid for the static lifetime...\n+\n+error[E0597]: `c` does not live long enough\n+  --> $DIR/method-call.rs:55:29\n+   |\n+LL |     a.method::<&'a u32>(b,  &c); //~ ERROR\n+   |                             ^^ borrowed value does not live long enough\n+LL | }\n+   | - `c` dropped here while still borrowed\n+   |\n+note: borrowed value must be valid for the lifetime 'a as defined on the function body at 51:35...\n+  --> $DIR/method-call.rs:51:35\n+   |\n+LL | fn annot_reference_named_lifetime<'a>(_d: &'a u32) {\n+   |                                   ^^\n+\n+error[E0597]: `c` does not live long enough\n+  --> $DIR/method-call.rs:69:33\n+   |\n+LL |         a.method::<&'a u32>(b,  &c); //~ ERROR\n+   |                                 ^^ borrowed value does not live long enough\n+LL |     };\n+   |     - `c` dropped here while still borrowed\n+   |\n+note: borrowed value must be valid for the lifetime 'a as defined on the function body at 64:46...\n+  --> $DIR/method-call.rs:64:46\n+   |\n+LL | fn annot_reference_named_lifetime_in_closure<'a>(_: &'a u32) {\n+   |                                              ^^\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0597`."}, {"sha": "5ac2ba5fa480a564076f15e535836021c24d4e12", "filename": "src/test/ui/nll/user-annotations/method-ufcs-1.rs", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/d95f078f0af28203c379365574a433ca5b79e9d8/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fmethod-ufcs-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d95f078f0af28203c379365574a433ca5b79e9d8/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fmethod-ufcs-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fmethod-ufcs-1.rs?ref=d95f078f0af28203c379365574a433ca5b79e9d8", "patch": "@@ -0,0 +1,75 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Unit test for the \"user substitutions\" that are annotated on each\n+// node.\n+\n+#![feature(nll)]\n+\n+trait Bazoom<T>: Sized {\n+    fn method<U>(self, arg: T, arg2: U) { }\n+}\n+\n+impl<T, U> Bazoom<U> for T {\n+}\n+\n+fn annot_underscore() {\n+    let a = 22;\n+    let b = 44;\n+    let c = 66;\n+    <_ as Bazoom<_>>::method::<_>(&a, b, c); // OK\n+}\n+\n+fn annot_reference_any_lifetime() {\n+    let a = 22;\n+    let b = 44;\n+    let c = 66;\n+    <&u32 as Bazoom<_>>::method(&a, b, c); // OK\n+}\n+\n+fn annot_reference_static_lifetime() {\n+    let a = 22;\n+    let b = 44;\n+    let c = 66;\n+    let x = <&'static u32 as Bazoom<_>>::method;\n+    x(&a, b, c); //~ ERROR\n+}\n+\n+fn annot_reference_named_lifetime<'a>(_d: &'a u32) {\n+    let a = 22;\n+    let b = 44;\n+    let c = 66;\n+    <&'a u32 as Bazoom<_>>::method(&a, b, c); //~ ERROR\n+}\n+\n+fn annot_reference_named_lifetime_ok<'a>(a: &'a u32) {\n+    let b = 44;\n+    let c = 66;\n+    <&'a u32 as Bazoom<_>>::method(&a, b, c);\n+}\n+\n+fn annot_reference_named_lifetime_in_closure<'a>(_: &'a u32) {\n+    let a = 22;\n+    let b = 44;\n+    let _closure = || {\n+        let c = 66;\n+        <&'a u32 as Bazoom<_>>::method(&a, b, c); //~ ERROR\n+    };\n+}\n+\n+fn annot_reference_named_lifetime_in_closure_ok<'a>(a: &'a u32) {\n+    let b = 44;\n+    let c = 66;\n+    let _closure = || {\n+        <&'a u32 as Bazoom<_>>::method(&a, b, c);\n+    };\n+}\n+\n+fn main() { }"}, {"sha": "f439748ef97b970ccecb7d6c1c082dc747049c16", "filename": "src/test/ui/nll/user-annotations/method-ufcs-1.stderr", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/d95f078f0af28203c379365574a433ca5b79e9d8/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fmethod-ufcs-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d95f078f0af28203c379365574a433ca5b79e9d8/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fmethod-ufcs-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fmethod-ufcs-1.stderr?ref=d95f078f0af28203c379365574a433ca5b79e9d8", "patch": "@@ -0,0 +1,45 @@\n+error[E0597]: `a` does not live long enough\n+  --> $DIR/method-ufcs-1.rs:42:7\n+   |\n+LL |     x(&a, b, c); //~ ERROR\n+   |       ^^ borrowed value does not live long enough\n+LL | }\n+   | - `a` dropped here while still borrowed\n+   |\n+   = note: borrowed value must be valid for the static lifetime...\n+\n+error[E0597]: `a` does not live long enough\n+  --> $DIR/method-ufcs-1.rs:49:36\n+   |\n+LL |     <&'a u32 as Bazoom<_>>::method(&a, b, c); //~ ERROR\n+   |                                    ^^ borrowed value does not live long enough\n+LL | }\n+   | - `a` dropped here while still borrowed\n+   |\n+note: borrowed value must be valid for the lifetime 'a as defined on the function body at 45:35...\n+  --> $DIR/method-ufcs-1.rs:45:35\n+   |\n+LL | fn annot_reference_named_lifetime<'a>(_d: &'a u32) {\n+   |                                   ^^\n+\n+error[E0597]: `a` does not live long enough\n+  --> $DIR/method-ufcs-1.rs:63:41\n+   |\n+LL |     let _closure = || {\n+   |                    -- value captured here\n+LL |         let c = 66;\n+LL |         <&'a u32 as Bazoom<_>>::method(&a, b, c); //~ ERROR\n+   |                                         ^ borrowed value does not live long enough\n+LL |     };\n+LL | }\n+   | - `a` dropped here while still borrowed\n+   |\n+note: borrowed value must be valid for the lifetime 'a as defined on the function body at 58:46...\n+  --> $DIR/method-ufcs-1.rs:58:46\n+   |\n+LL | fn annot_reference_named_lifetime_in_closure<'a>(_: &'a u32) {\n+   |                                              ^^\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0597`."}, {"sha": "082cc561ae78f1266aaa1531ccfafb7d9f5c031f", "filename": "src/test/ui/nll/user-annotations/method-ufcs-2.rs", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/d95f078f0af28203c379365574a433ca5b79e9d8/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fmethod-ufcs-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d95f078f0af28203c379365574a433ca5b79e9d8/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fmethod-ufcs-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fmethod-ufcs-2.rs?ref=d95f078f0af28203c379365574a433ca5b79e9d8", "patch": "@@ -0,0 +1,75 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Unit test for the \"user substitutions\" that are annotated on each\n+// node.\n+\n+#![feature(nll)]\n+\n+trait Bazoom<T>: Sized {\n+    fn method<U>(self, arg: T, arg2: U) { }\n+}\n+\n+impl<T, U> Bazoom<U> for T {\n+}\n+\n+fn annot_underscore() {\n+    let a = 22;\n+    let b = 44;\n+    let c = 66;\n+    <_ as Bazoom<_>>::method(a, &b, c); // OK\n+}\n+\n+fn annot_reference_any_lifetime() {\n+    let a = 22;\n+    let b = 44;\n+    let c = 66;\n+    <_ as Bazoom<&u32>>::method(a, &b, c); // OK\n+}\n+\n+fn annot_reference_static_lifetime() {\n+    let a = 22;\n+    let b = 44;\n+    let c = 66;\n+    let x = <&'static u32 as Bazoom<_>>::method;\n+    x(&a, b, c); //~ ERROR\n+}\n+\n+fn annot_reference_named_lifetime<'a>(_d: &'a u32) {\n+    let a = 22;\n+    let b = 44;\n+    let c = 66;\n+    <_ as Bazoom<&'a u32>>::method(a, &b, c); //~ ERROR\n+}\n+\n+fn annot_reference_named_lifetime_ok<'a>(b: &'a u32) {\n+    let a = 44;\n+    let c = 66;\n+    <_ as Bazoom<&'a u32>>::method(a, &b, c);\n+}\n+\n+fn annot_reference_named_lifetime_in_closure<'a>(_: &'a u32) {\n+    let a = 22;\n+    let b = 44;\n+    let _closure = || {\n+        let c = 66;\n+        <_ as Bazoom<&'a u32>>::method(a, &b, c); //~ ERROR\n+    };\n+}\n+\n+fn annot_reference_named_lifetime_in_closure_ok<'a>(b: &'a u32) {\n+    let a = 44;\n+    let c = 66;\n+    let _closure = || {\n+        <_ as Bazoom<&'a u32>>::method(a, &b, c);\n+    };\n+}\n+\n+fn main() { }"}, {"sha": "dc0f559659001fa97da7d1cb799572dcb7baa097", "filename": "src/test/ui/nll/user-annotations/method-ufcs-2.stderr", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/d95f078f0af28203c379365574a433ca5b79e9d8/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fmethod-ufcs-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d95f078f0af28203c379365574a433ca5b79e9d8/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fmethod-ufcs-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fmethod-ufcs-2.stderr?ref=d95f078f0af28203c379365574a433ca5b79e9d8", "patch": "@@ -0,0 +1,45 @@\n+error[E0597]: `a` does not live long enough\n+  --> $DIR/method-ufcs-2.rs:42:7\n+   |\n+LL |     x(&a, b, c); //~ ERROR\n+   |       ^^ borrowed value does not live long enough\n+LL | }\n+   | - `a` dropped here while still borrowed\n+   |\n+   = note: borrowed value must be valid for the static lifetime...\n+\n+error[E0597]: `b` does not live long enough\n+  --> $DIR/method-ufcs-2.rs:49:39\n+   |\n+LL |     <_ as Bazoom<&'a u32>>::method(a, &b, c); //~ ERROR\n+   |                                       ^^ borrowed value does not live long enough\n+LL | }\n+   | - `b` dropped here while still borrowed\n+   |\n+note: borrowed value must be valid for the lifetime 'a as defined on the function body at 45:35...\n+  --> $DIR/method-ufcs-2.rs:45:35\n+   |\n+LL | fn annot_reference_named_lifetime<'a>(_d: &'a u32) {\n+   |                                   ^^\n+\n+error[E0597]: `b` does not live long enough\n+  --> $DIR/method-ufcs-2.rs:63:44\n+   |\n+LL |     let _closure = || {\n+   |                    -- value captured here\n+LL |         let c = 66;\n+LL |         <_ as Bazoom<&'a u32>>::method(a, &b, c); //~ ERROR\n+   |                                            ^ borrowed value does not live long enough\n+LL |     };\n+LL | }\n+   | - `b` dropped here while still borrowed\n+   |\n+note: borrowed value must be valid for the lifetime 'a as defined on the function body at 58:46...\n+  --> $DIR/method-ufcs-2.rs:58:46\n+   |\n+LL | fn annot_reference_named_lifetime_in_closure<'a>(_: &'a u32) {\n+   |                                              ^^\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0597`."}, {"sha": "f4fdb3ee57236f6cf7b30026a62e8fb63bad244f", "filename": "src/test/ui/nll/user-annotations/method-ufcs-3.rs", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/d95f078f0af28203c379365574a433ca5b79e9d8/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fmethod-ufcs-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d95f078f0af28203c379365574a433ca5b79e9d8/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fmethod-ufcs-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fmethod-ufcs-3.rs?ref=d95f078f0af28203c379365574a433ca5b79e9d8", "patch": "@@ -0,0 +1,81 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Unit test for the \"user substitutions\" that are annotated on each\n+// node.\n+\n+#![feature(nll)]\n+\n+trait Bazoom<T> {\n+    fn method<U>(&self, arg: T, arg2: U) { }\n+}\n+\n+impl<T, U> Bazoom<U> for T {\n+}\n+\n+fn no_annot() {\n+    let a = 22;\n+    let b = 44;\n+    let c = 66;\n+    <_ as Bazoom<_>>::method(&a, b, &c); // OK\n+}\n+\n+fn annot_underscore() {\n+    let a = 22;\n+    let b = 44;\n+    let c = 66;\n+    <_ as Bazoom<_>>::method::<_>(&a, b, &c); // OK\n+}\n+\n+fn annot_reference_any_lifetime() {\n+    let a = 22;\n+    let b = 44;\n+    let c = 66;\n+    <_ as Bazoom<_>>::method::<&u32>(&a, b, &c); // OK\n+}\n+\n+fn annot_reference_static_lifetime() {\n+    let a = 22;\n+    let b = 44;\n+    let c = 66;\n+    <_ as Bazoom<_>>::method::<&'static u32>(&a, b, &c); //~ ERROR\n+}\n+\n+fn annot_reference_named_lifetime<'a>(_d: &'a u32) {\n+    let a = 22;\n+    let b = 44;\n+    let c = 66;\n+    <_ as Bazoom<_>>::method::<&'a u32>(&a, b, &c); //~ ERROR\n+}\n+\n+fn annot_reference_named_lifetime_ok<'a>(c: &'a u32) {\n+    let a = 22;\n+    let b = 44;\n+    <_ as Bazoom<_>>::method::<&'a u32>(&a, b, c);\n+}\n+\n+fn annot_reference_named_lifetime_in_closure<'a>(_: &'a u32) {\n+    let a = 22;\n+    let b = 44;\n+    let _closure = || {\n+        let c = 66;\n+        <_ as Bazoom<_>>::method::<&'a u32>(&a, b, &c); //~ ERROR\n+    };\n+}\n+\n+fn annot_reference_named_lifetime_in_closure_ok<'a>(c: &'a u32) {\n+    let a = 22;\n+    let b = 44;\n+    let _closure = || {\n+        <_ as Bazoom<_>>::method::<&'a u32>(&a, b, c);\n+    };\n+}\n+\n+fn main() { }"}, {"sha": "7ddea3eb2c62fb5f227281836e8b1bd49fc33564", "filename": "src/test/ui/nll/user-annotations/method-ufcs-3.stderr", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/d95f078f0af28203c379365574a433ca5b79e9d8/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fmethod-ufcs-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d95f078f0af28203c379365574a433ca5b79e9d8/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fmethod-ufcs-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fmethod-ufcs-3.stderr?ref=d95f078f0af28203c379365574a433ca5b79e9d8", "patch": "@@ -0,0 +1,41 @@\n+error[E0597]: `c` does not live long enough\n+  --> $DIR/method-ufcs-3.rs:48:53\n+   |\n+LL |     <_ as Bazoom<_>>::method::<&'static u32>(&a, b, &c); //~ ERROR\n+   |                                                     ^^ borrowed value does not live long enough\n+LL | }\n+   | - `c` dropped here while still borrowed\n+   |\n+   = note: borrowed value must be valid for the static lifetime...\n+\n+error[E0597]: `c` does not live long enough\n+  --> $DIR/method-ufcs-3.rs:55:48\n+   |\n+LL |     <_ as Bazoom<_>>::method::<&'a u32>(&a, b, &c); //~ ERROR\n+   |                                                ^^ borrowed value does not live long enough\n+LL | }\n+   | - `c` dropped here while still borrowed\n+   |\n+note: borrowed value must be valid for the lifetime 'a as defined on the function body at 51:35...\n+  --> $DIR/method-ufcs-3.rs:51:35\n+   |\n+LL | fn annot_reference_named_lifetime<'a>(_d: &'a u32) {\n+   |                                   ^^\n+\n+error[E0597]: `c` does not live long enough\n+  --> $DIR/method-ufcs-3.rs:69:52\n+   |\n+LL |         <_ as Bazoom<_>>::method::<&'a u32>(&a, b, &c); //~ ERROR\n+   |                                                    ^^ borrowed value does not live long enough\n+LL |     };\n+   |     - `c` dropped here while still borrowed\n+   |\n+note: borrowed value must be valid for the lifetime 'a as defined on the function body at 64:46...\n+  --> $DIR/method-ufcs-3.rs:64:46\n+   |\n+LL | fn annot_reference_named_lifetime_in_closure<'a>(_: &'a u32) {\n+   |                                              ^^\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0597`."}]}