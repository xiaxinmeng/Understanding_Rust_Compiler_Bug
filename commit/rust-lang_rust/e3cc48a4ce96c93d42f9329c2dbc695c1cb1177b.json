{"sha": "e3cc48a4ce96c93d42f9329c2dbc695c1cb1177b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUzY2M0OGE0Y2U5NmM5M2Q0MmY5MzI5YzJkYmM2OTVjMWNiMTE3N2I=", "commit": {"author": {"name": "Pietro Albini", "email": "pietro@pietroalbini.org", "date": "2018-09-22T07:56:28Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-09-22T07:56:28Z"}, "message": "Rollup merge of #54280 - japaric:no-cas-for-thumbv6, r=alexcrichton\n\nremove (more) CAS API from Atomic* types where not natively supported\n\ncloses #54276\n\nIn PR #51953 I made the Atomic* types available on targets like thumbv6m and\nmsp430 with the intention of *only* exposing the load and store API on those\ntypes -- the rest of the API doesn't work on those targets because the are no\nnative instructions to implement CAS loops.\n\nUnfortunately, it seems I didn't properly cfg away all the CAS API on those\ntargets, as evidenced in #54276. This PR amends the issue by removing the rest\nof the CAS API.\n\nThis is technically a breaking change because *libraries* that were using this\nAPI and were being compiled for e.g. thumbv6m-none-eabi will stop compiling.\nHowever, using those libraries (before this change) in programs (binaries) would\nlead to linking errors when compiled for e.g. thumbv6m so this change\neffectively shifts a linker error in binaries to a compiler error in libraries.\n\nOn a side note: extending the Atomic API is a bit error prone because of these\nnon-cas targets. Unless the author of the change is aware of these targets and\nproperly uses `#[cfg(atomic = \"cas\")]` they could end up exposing new CAS API on\nthese targets. I can't think of a test to check that an API is not present on\nsome target, but we could extend the `tidy` tool to check that *all* newly added\natomic API has the `#[cfg(atomic = \"cas\")]` attribute unless it's whitelisted in\n`tidy` then the author of the change would have to verify if the API can be used\non non-cas targets.\n\nIn any case, I'd like to plug this hole ASAP. We can revisit testing in a\nfollow-up issue / PR.\n\nr? @alexcrichton\ncc @mvirkkunen", "tree": {"sha": "de43d0b2112df1b1c2d8e2e6937a7c5cfcb2f3ef", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/de43d0b2112df1b1c2d8e2e6937a7c5cfcb2f3ef"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e3cc48a4ce96c93d42f9329c2dbc695c1cb1177b", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJbpfWsCRBK7hj4Ov3rIwAAdHIIAJ+/7rUue+yuE6xIkzyHjmyO\niP1y4xKBcJ5nGtj7qNhiuNbPnb6yVCFWXZAHNwMNndGJwSpuN+ObVArH72CE3rcS\nVEpAoU7ThRKGV7DbVhAKv8L26A4Nc8Mg8IqtmnDeh0AqQalKrdqSP2vFbj/0W7wX\nyi4S9vrlEr8WEuesGJIvr6OrpEpDUPFSovBl6mfv4LTNufzu4GZ0n1DSKnF6pf3+\nyx6Sf52SnrNH4uTokm6G++Ilqbp1722PiP6JH/YrzBKwbBqxD4oVMbLq6+ny14KJ\nBvjn+0cFk5lr3IqfkABHjmbxoNHyFQQoLWOo18MJXlnvlcHm062izwK9shcC2Ws=\n=qB8U\n-----END PGP SIGNATURE-----\n", "payload": "tree de43d0b2112df1b1c2d8e2e6937a7c5cfcb2f3ef\nparent 822c51121e7379ad72c2a2ccfed3443ecc40fbf4\nparent 828289610bece3d2208d34147ae2a419a9c524c4\nauthor Pietro Albini <pietro@pietroalbini.org> 1537602988 +0200\ncommitter GitHub <noreply@github.com> 1537602988 +0200\n\nRollup merge of #54280 - japaric:no-cas-for-thumbv6, r=alexcrichton\n\nremove (more) CAS API from Atomic* types where not natively supported\n\ncloses #54276\n\nIn PR #51953 I made the Atomic* types available on targets like thumbv6m and\nmsp430 with the intention of *only* exposing the load and store API on those\ntypes -- the rest of the API doesn't work on those targets because the are no\nnative instructions to implement CAS loops.\n\nUnfortunately, it seems I didn't properly cfg away all the CAS API on those\ntargets, as evidenced in #54276. This PR amends the issue by removing the rest\nof the CAS API.\n\nThis is technically a breaking change because *libraries* that were using this\nAPI and were being compiled for e.g. thumbv6m-none-eabi will stop compiling.\nHowever, using those libraries (before this change) in programs (binaries) would\nlead to linking errors when compiled for e.g. thumbv6m so this change\neffectively shifts a linker error in binaries to a compiler error in libraries.\n\nOn a side note: extending the Atomic API is a bit error prone because of these\nnon-cas targets. Unless the author of the change is aware of these targets and\nproperly uses `#[cfg(atomic = \"cas\")]` they could end up exposing new CAS API on\nthese targets. I can't think of a test to check that an API is not present on\nsome target, but we could extend the `tidy` tool to check that *all* newly added\natomic API has the `#[cfg(atomic = \"cas\")]` attribute unless it's whitelisted in\n`tidy` then the author of the change would have to verify if the API can be used\non non-cas targets.\n\nIn any case, I'd like to plug this hole ASAP. We can revisit testing in a\nfollow-up issue / PR.\n\nr? @alexcrichton\ncc @mvirkkunen\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e3cc48a4ce96c93d42f9329c2dbc695c1cb1177b", "html_url": "https://github.com/rust-lang/rust/commit/e3cc48a4ce96c93d42f9329c2dbc695c1cb1177b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e3cc48a4ce96c93d42f9329c2dbc695c1cb1177b/comments", "author": {"login": "pietroalbini", "id": 2299951, "node_id": "MDQ6VXNlcjIyOTk5NTE=", "avatar_url": "https://avatars.githubusercontent.com/u/2299951?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pietroalbini", "html_url": "https://github.com/pietroalbini", "followers_url": "https://api.github.com/users/pietroalbini/followers", "following_url": "https://api.github.com/users/pietroalbini/following{/other_user}", "gists_url": "https://api.github.com/users/pietroalbini/gists{/gist_id}", "starred_url": "https://api.github.com/users/pietroalbini/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pietroalbini/subscriptions", "organizations_url": "https://api.github.com/users/pietroalbini/orgs", "repos_url": "https://api.github.com/users/pietroalbini/repos", "events_url": "https://api.github.com/users/pietroalbini/events{/privacy}", "received_events_url": "https://api.github.com/users/pietroalbini/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "822c51121e7379ad72c2a2ccfed3443ecc40fbf4", "url": "https://api.github.com/repos/rust-lang/rust/commits/822c51121e7379ad72c2a2ccfed3443ecc40fbf4", "html_url": "https://github.com/rust-lang/rust/commit/822c51121e7379ad72c2a2ccfed3443ecc40fbf4"}, {"sha": "828289610bece3d2208d34147ae2a419a9c524c4", "url": "https://api.github.com/repos/rust-lang/rust/commits/828289610bece3d2208d34147ae2a419a9c524c4", "html_url": "https://github.com/rust-lang/rust/commit/828289610bece3d2208d34147ae2a419a9c524c4"}], "stats": {"total": 23, "additions": 23, "deletions": 0}, "files": [{"sha": "69c524925fc546e9d82f9f1a9aab80cba7e504bc", "filename": "src/libcore/sync/atomic.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/e3cc48a4ce96c93d42f9329c2dbc695c1cb1177b/src%2Flibcore%2Fsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3cc48a4ce96c93d42f9329c2dbc695c1cb1177b/src%2Flibcore%2Fsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsync%2Fatomic.rs?ref=e3cc48a4ce96c93d42f9329c2dbc695c1cb1177b", "patch": "@@ -558,6 +558,7 @@ impl AtomicBool {\n     /// ```\n     #[inline]\n     #[stable(feature = \"extended_compare_and_swap\", since = \"1.10.0\")]\n+    #[cfg(target_has_atomic = \"cas\")]\n     pub fn compare_exchange_weak(&self,\n                                  current: bool,\n                                  new: bool,\n@@ -1041,6 +1042,7 @@ impl<T> AtomicPtr<T> {\n     /// ```\n     #[inline]\n     #[stable(feature = \"extended_compare_and_swap\", since = \"1.10.0\")]\n+    #[cfg(target_has_atomic = \"cas\")]\n     pub fn compare_exchange_weak(&self,\n                                  current: *mut T,\n                                  new: *mut T,\n@@ -1434,6 +1436,7 @@ loop {\n ```\"),\n                 #[inline]\n                 #[$stable_cxchg]\n+                #[cfg(target_has_atomic = \"cas\")]\n                 pub fn compare_exchange_weak(&self,\n                                              current: $int_type,\n                                              new: $int_type,\n@@ -1471,6 +1474,7 @@ assert_eq!(foo.load(Ordering::SeqCst), 10);\n ```\"),\n                 #[inline]\n                 #[$stable]\n+                #[cfg(target_has_atomic = \"cas\")]\n                 pub fn fetch_add(&self, val: $int_type, order: Ordering) -> $int_type {\n                     unsafe { atomic_add(self.v.get(), val, order) }\n                 }\n@@ -1502,6 +1506,7 @@ assert_eq!(foo.load(Ordering::SeqCst), 10);\n ```\"),\n                 #[inline]\n                 #[$stable]\n+                #[cfg(target_has_atomic = \"cas\")]\n                 pub fn fetch_sub(&self, val: $int_type, order: Ordering) -> $int_type {\n                     unsafe { atomic_sub(self.v.get(), val, order) }\n                 }\n@@ -1536,6 +1541,7 @@ assert_eq!(foo.load(Ordering::SeqCst), 0b100001);\n ```\"),\n                 #[inline]\n                 #[$stable]\n+                #[cfg(target_has_atomic = \"cas\")]\n                 pub fn fetch_and(&self, val: $int_type, order: Ordering) -> $int_type {\n                     unsafe { atomic_and(self.v.get(), val, order) }\n                 }\n@@ -1571,6 +1577,7 @@ assert_eq!(foo.load(Ordering::SeqCst), !(0x13 & 0x31));\n ```\"),\n                 #[inline]\n                 #[$stable_nand]\n+                #[cfg(target_has_atomic = \"cas\")]\n                 pub fn fetch_nand(&self, val: $int_type, order: Ordering) -> $int_type {\n                     unsafe { atomic_nand(self.v.get(), val, order) }\n                 }\n@@ -1605,6 +1612,7 @@ assert_eq!(foo.load(Ordering::SeqCst), 0b111111);\n ```\"),\n                 #[inline]\n                 #[$stable]\n+                #[cfg(target_has_atomic = \"cas\")]\n                 pub fn fetch_or(&self, val: $int_type, order: Ordering) -> $int_type {\n                     unsafe { atomic_or(self.v.get(), val, order) }\n                 }\n@@ -1639,6 +1647,7 @@ assert_eq!(foo.load(Ordering::SeqCst), 0b011110);\n ```\"),\n                 #[inline]\n                 #[$stable]\n+                #[cfg(target_has_atomic = \"cas\")]\n                 pub fn fetch_xor(&self, val: $int_type, order: Ordering) -> $int_type {\n                     unsafe { atomic_xor(self.v.get(), val, order) }\n                 }\n@@ -1688,6 +1697,7 @@ assert_eq!(x.load(Ordering::SeqCst), 9);\n                 #[unstable(feature = \"no_more_cas\",\n                        reason = \"no more CAS loops in user code\",\n                        issue = \"48655\")]\n+                #[cfg(target_has_atomic = \"cas\")]\n                 pub fn fetch_update<F>(&self,\n                                        mut f: F,\n                                        fetch_order: Ordering,\n@@ -1748,6 +1758,7 @@ assert!(max_foo == 42);\n                 #[unstable(feature = \"atomic_min_max\",\n                        reason = \"easier and faster min/max than writing manual CAS loop\",\n                        issue = \"48655\")]\n+                #[cfg(target_has_atomic = \"cas\")]\n                 pub fn fetch_max(&self, val: $int_type, order: Ordering) -> $int_type {\n                     unsafe { $max_fn(self.v.get(), val, order) }\n                 }\n@@ -1799,6 +1810,7 @@ assert_eq!(min_foo, 12);\n                 #[unstable(feature = \"atomic_min_max\",\n                        reason = \"easier and faster min/max than writing manual CAS loop\",\n                        issue = \"48655\")]\n+                #[cfg(target_has_atomic = \"cas\")]\n                 pub fn fetch_min(&self, val: $int_type, order: Ordering) -> $int_type {\n                     unsafe { $min_fn(self.v.get(), val, order) }\n                 }\n@@ -1987,6 +1999,7 @@ unsafe fn atomic_swap<T>(dst: *mut T, val: T, order: Ordering) -> T {\n \n /// Returns the previous value (like __sync_fetch_and_add).\n #[inline]\n+#[cfg(target_has_atomic = \"cas\")]\n unsafe fn atomic_add<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_xadd_acq(dst, val),\n@@ -1999,6 +2012,7 @@ unsafe fn atomic_add<T>(dst: *mut T, val: T, order: Ordering) -> T {\n \n /// Returns the previous value (like __sync_fetch_and_sub).\n #[inline]\n+#[cfg(target_has_atomic = \"cas\")]\n unsafe fn atomic_sub<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_xsub_acq(dst, val),\n@@ -2035,6 +2049,7 @@ unsafe fn atomic_compare_exchange<T>(dst: *mut T,\n }\n \n #[inline]\n+#[cfg(target_has_atomic = \"cas\")]\n unsafe fn atomic_compare_exchange_weak<T>(dst: *mut T,\n                                           old: T,\n                                           new: T,\n@@ -2059,6 +2074,7 @@ unsafe fn atomic_compare_exchange_weak<T>(dst: *mut T,\n }\n \n #[inline]\n+#[cfg(target_has_atomic = \"cas\")]\n unsafe fn atomic_and<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_and_acq(dst, val),\n@@ -2070,6 +2086,7 @@ unsafe fn atomic_and<T>(dst: *mut T, val: T, order: Ordering) -> T {\n }\n \n #[inline]\n+#[cfg(target_has_atomic = \"cas\")]\n unsafe fn atomic_nand<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_nand_acq(dst, val),\n@@ -2081,6 +2098,7 @@ unsafe fn atomic_nand<T>(dst: *mut T, val: T, order: Ordering) -> T {\n }\n \n #[inline]\n+#[cfg(target_has_atomic = \"cas\")]\n unsafe fn atomic_or<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_or_acq(dst, val),\n@@ -2092,6 +2110,7 @@ unsafe fn atomic_or<T>(dst: *mut T, val: T, order: Ordering) -> T {\n }\n \n #[inline]\n+#[cfg(target_has_atomic = \"cas\")]\n unsafe fn atomic_xor<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_xor_acq(dst, val),\n@@ -2104,6 +2123,7 @@ unsafe fn atomic_xor<T>(dst: *mut T, val: T, order: Ordering) -> T {\n \n /// returns the max value (signed comparison)\n #[inline]\n+#[cfg(target_has_atomic = \"cas\")]\n unsafe fn atomic_max<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_max_acq(dst, val),\n@@ -2116,6 +2136,7 @@ unsafe fn atomic_max<T>(dst: *mut T, val: T, order: Ordering) -> T {\n \n /// returns the min value (signed comparison)\n #[inline]\n+#[cfg(target_has_atomic = \"cas\")]\n unsafe fn atomic_min<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_min_acq(dst, val),\n@@ -2128,6 +2149,7 @@ unsafe fn atomic_min<T>(dst: *mut T, val: T, order: Ordering) -> T {\n \n /// returns the max value (signed comparison)\n #[inline]\n+#[cfg(target_has_atomic = \"cas\")]\n unsafe fn atomic_umax<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_umax_acq(dst, val),\n@@ -2140,6 +2162,7 @@ unsafe fn atomic_umax<T>(dst: *mut T, val: T, order: Ordering) -> T {\n \n /// returns the min value (signed comparison)\n #[inline]\n+#[cfg(target_has_atomic = \"cas\")]\n unsafe fn atomic_umin<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_umin_acq(dst, val),"}]}