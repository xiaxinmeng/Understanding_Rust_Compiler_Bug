{"sha": "83c890b4542abf60f833df3da1924ed3ce559862", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgzYzg5MGI0NTQyYWJmNjBmODMzZGYzZGExOTI0ZWQzY2U1NTk4NjI=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-01-06T02:41:55Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-01-06T02:41:55Z"}, "message": "rollup merge of #20565: alexcrichton/missing-stability\n\nConflicts:\n\tsrc/libstd/sync/mpsc/mod.rs", "tree": {"sha": "8279e3e96d461a35255f861a48026c4cce38528e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8279e3e96d461a35255f861a48026c4cce38528e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/83c890b4542abf60f833df3da1924ed3ce559862", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/83c890b4542abf60f833df3da1924ed3ce559862", "html_url": "https://github.com/rust-lang/rust/commit/83c890b4542abf60f833df3da1924ed3ce559862", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/83c890b4542abf60f833df3da1924ed3ce559862/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "59bbf56d4917d2776d8acd6ef1a44088486d71bd", "url": "https://api.github.com/repos/rust-lang/rust/commits/59bbf56d4917d2776d8acd6ef1a44088486d71bd", "html_url": "https://github.com/rust-lang/rust/commit/59bbf56d4917d2776d8acd6ef1a44088486d71bd"}, {"sha": "4236c52e34cd005af86ea9e5f199daeea9bb8fcb", "url": "https://api.github.com/repos/rust-lang/rust/commits/4236c52e34cd005af86ea9e5f199daeea9bb8fcb", "html_url": "https://github.com/rust-lang/rust/commit/4236c52e34cd005af86ea9e5f199daeea9bb8fcb"}], "stats": {"total": 70, "additions": 24, "deletions": 46}, "files": [{"sha": "4a5dcb51322d4c485ebc372ee11c1d7a9b62b86c", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/83c890b4542abf60f833df3da1924ed3ce559862/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83c890b4542abf60f833df3da1924ed3ce559862/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=83c890b4542abf60f833df3da1924ed3ce559862", "patch": "@@ -50,6 +50,7 @@\n //! is the same as `&[u8]`.\n \n #![doc(primitive = \"str\")]\n+#![stable]\n \n use self::RecompositionState::*;\n use self::DecompositionType::*;\n@@ -407,6 +408,7 @@ Section: Trait implementations\n */\n \n /// Any string that can be represented as a slice.\n+#[stable]\n pub trait StrExt for Sized?: ops::Slice<uint, str> {\n     /// Escapes each char in `s` with `char::escape_default`.\n     #[unstable = \"return type may change to be an iterator\"]\n@@ -1346,6 +1348,7 @@ pub trait StrExt for Sized?: ops::Slice<uint, str> {\n     }\n }\n \n+#[stable]\n impl StrExt for str {}\n \n #[cfg(test)]"}, {"sha": "0f326aac052e3584b56d51fbc84a5e9e7ba22bbd", "filename": "src/libcore/atomic.rs", "status": "modified", "additions": 7, "deletions": 35, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/83c890b4542abf60f833df3da1924ed3ce559862/src%2Flibcore%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83c890b4542abf60f833df3da1924ed3ce559862/src%2Flibcore%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fatomic.rs?ref=83c890b4542abf60f833df3da1924ed3ce559862", "patch": "@@ -86,15 +86,15 @@ pub struct AtomicBool {\n unsafe impl Sync for AtomicBool {}\n \n /// A signed integer type which can be safely shared between threads.\n-#[stable]\n+#[unstable = \"awaiting int/uint conventions, may be renamed\"]\n pub struct AtomicInt {\n     v: UnsafeCell<int>,\n }\n \n unsafe impl Sync for AtomicInt {}\n \n /// An unsigned integer type which can be safely shared between threads.\n-#[stable]\n+#[unstable = \"awaiting int/uint conventions, may be renamed\"]\n pub struct AtomicUint {\n     v: UnsafeCell<uint>,\n }\n@@ -146,28 +146,18 @@ pub enum Ordering {\n }\n \n /// An `AtomicBool` initialized to `false`.\n-#[unstable = \"may be renamed, pending conventions for static initalizers\"]\n+#[stable]\n pub const ATOMIC_BOOL_INIT: AtomicBool =\n         AtomicBool { v: UnsafeCell { value: 0 } };\n /// An `AtomicInt` initialized to `0`.\n-#[unstable = \"may be renamed, pending conventions for static initalizers\"]\n+#[unstable = \"awaiting int/uint conventions, may be renamed\"]\n pub const ATOMIC_INT_INIT: AtomicInt =\n         AtomicInt { v: UnsafeCell { value: 0 } };\n /// An `AtomicUint` initialized to `0`.\n-#[unstable = \"may be renamed, pending conventions for static initalizers\"]\n+#[unstable = \"awaiting int/uint conventions, may be renamed\"]\n pub const ATOMIC_UINT_INIT: AtomicUint =\n         AtomicUint { v: UnsafeCell { value: 0, } };\n \n-/// Deprecated\n-#[deprecated = \"renamed to ATOMIC_BOOL_INIT\"]\n-pub const INIT_ATOMIC_BOOL: AtomicBool = ATOMIC_BOOL_INIT;\n-/// Deprecated\n-#[deprecated = \"renamed to ATOMIC_INT_INIT\"]\n-pub const INIT_ATOMIC_INT: AtomicInt = ATOMIC_INT_INIT;\n-/// Deprecated\n-#[deprecated = \"renamed to ATOMIC_UINT_INIT\"]\n-pub const INIT_ATOMIC_UINT: AtomicUint = ATOMIC_UINT_INIT;\n-\n // NB: Needs to be -1 (0b11111111...) to make fetch_nand work correctly\n const UINT_TRUE: uint = -1;\n \n@@ -413,6 +403,7 @@ impl AtomicBool {\n     }\n }\n \n+#[unstable = \"awaiting int/uint conventions, types may change\"]\n impl AtomicInt {\n     /// Creates a new `AtomicInt`.\n     ///\n@@ -424,7 +415,6 @@ impl AtomicInt {\n     /// let atomic_forty_two  = AtomicInt::new(42);\n     /// ```\n     #[inline]\n-    #[stable]\n     pub fn new(v: int) -> AtomicInt {\n         AtomicInt {v: UnsafeCell::new(v)}\n     }\n@@ -447,7 +437,6 @@ impl AtomicInt {\n     /// let value = some_int.load(Ordering::Relaxed);\n     /// ```\n     #[inline]\n-    #[stable]\n     pub fn load(&self, order: Ordering) -> int {\n         unsafe { atomic_load(self.v.get() as *const int, order) }\n     }\n@@ -470,7 +459,6 @@ impl AtomicInt {\n     ///\n     /// Panics if `order` is `Acquire` or `AcqRel`.\n     #[inline]\n-    #[stable]\n     pub fn store(&self, val: int, order: Ordering) {\n         unsafe { atomic_store(self.v.get(), val, order); }\n     }\n@@ -489,7 +477,6 @@ impl AtomicInt {\n     /// let value = some_int.swap(10, Ordering::Relaxed);\n     /// ```\n     #[inline]\n-    #[stable]\n     pub fn swap(&self, val: int, order: Ordering) -> int {\n         unsafe { atomic_swap(self.v.get(), val, order) }\n     }\n@@ -511,7 +498,6 @@ impl AtomicInt {\n     /// let value = some_int.compare_and_swap(5, 10, Ordering::Relaxed);\n     /// ```\n     #[inline]\n-    #[stable]\n     pub fn compare_and_swap(&self, old: int, new: int, order: Ordering) -> int {\n         unsafe { atomic_compare_and_swap(self.v.get(), old, new, order) }\n     }\n@@ -528,7 +514,6 @@ impl AtomicInt {\n     /// assert_eq!(10, foo.load(Ordering::SeqCst));\n     /// ```\n     #[inline]\n-    #[stable]\n     pub fn fetch_add(&self, val: int, order: Ordering) -> int {\n         unsafe { atomic_add(self.v.get(), val, order) }\n     }\n@@ -545,7 +530,6 @@ impl AtomicInt {\n     /// assert_eq!(-10, foo.load(Ordering::SeqCst));\n     /// ```\n     #[inline]\n-    #[stable]\n     pub fn fetch_sub(&self, val: int, order: Ordering) -> int {\n         unsafe { atomic_sub(self.v.get(), val, order) }\n     }\n@@ -561,7 +545,6 @@ impl AtomicInt {\n     /// assert_eq!(0b101101, foo.fetch_and(0b110011, Ordering::SeqCst));\n     /// assert_eq!(0b100001, foo.load(Ordering::SeqCst));\n     #[inline]\n-    #[stable]\n     pub fn fetch_and(&self, val: int, order: Ordering) -> int {\n         unsafe { atomic_and(self.v.get(), val, order) }\n     }\n@@ -577,7 +560,6 @@ impl AtomicInt {\n     /// assert_eq!(0b101101, foo.fetch_or(0b110011, Ordering::SeqCst));\n     /// assert_eq!(0b111111, foo.load(Ordering::SeqCst));\n     #[inline]\n-    #[stable]\n     pub fn fetch_or(&self, val: int, order: Ordering) -> int {\n         unsafe { atomic_or(self.v.get(), val, order) }\n     }\n@@ -593,12 +575,12 @@ impl AtomicInt {\n     /// assert_eq!(0b101101, foo.fetch_xor(0b110011, Ordering::SeqCst));\n     /// assert_eq!(0b011110, foo.load(Ordering::SeqCst));\n     #[inline]\n-    #[stable]\n     pub fn fetch_xor(&self, val: int, order: Ordering) -> int {\n         unsafe { atomic_xor(self.v.get(), val, order) }\n     }\n }\n \n+#[unstable = \"awaiting int/uint conventions, types may change\"]\n impl AtomicUint {\n     /// Creates a new `AtomicUint`.\n     ///\n@@ -610,7 +592,6 @@ impl AtomicUint {\n     /// let atomic_forty_two = AtomicUint::new(42u);\n     /// ```\n     #[inline]\n-    #[stable]\n     pub fn new(v: uint) -> AtomicUint {\n         AtomicUint { v: UnsafeCell::new(v) }\n     }\n@@ -633,7 +614,6 @@ impl AtomicUint {\n     /// let value = some_uint.load(Ordering::Relaxed);\n     /// ```\n     #[inline]\n-    #[stable]\n     pub fn load(&self, order: Ordering) -> uint {\n         unsafe { atomic_load(self.v.get() as *const uint, order) }\n     }\n@@ -656,7 +636,6 @@ impl AtomicUint {\n     ///\n     /// Panics if `order` is `Acquire` or `AcqRel`.\n     #[inline]\n-    #[stable]\n     pub fn store(&self, val: uint, order: Ordering) {\n         unsafe { atomic_store(self.v.get(), val, order); }\n     }\n@@ -675,7 +654,6 @@ impl AtomicUint {\n     /// let value = some_uint.swap(10, Ordering::Relaxed);\n     /// ```\n     #[inline]\n-    #[stable]\n     pub fn swap(&self, val: uint, order: Ordering) -> uint {\n         unsafe { atomic_swap(self.v.get(), val, order) }\n     }\n@@ -697,7 +675,6 @@ impl AtomicUint {\n     /// let value = some_uint.compare_and_swap(5, 10, Ordering::Relaxed);\n     /// ```\n     #[inline]\n-    #[stable]\n     pub fn compare_and_swap(&self, old: uint, new: uint, order: Ordering) -> uint {\n         unsafe { atomic_compare_and_swap(self.v.get(), old, new, order) }\n     }\n@@ -714,7 +691,6 @@ impl AtomicUint {\n     /// assert_eq!(10, foo.load(Ordering::SeqCst));\n     /// ```\n     #[inline]\n-    #[stable]\n     pub fn fetch_add(&self, val: uint, order: Ordering) -> uint {\n         unsafe { atomic_add(self.v.get(), val, order) }\n     }\n@@ -731,7 +707,6 @@ impl AtomicUint {\n     /// assert_eq!(0, foo.load(Ordering::SeqCst));\n     /// ```\n     #[inline]\n-    #[stable]\n     pub fn fetch_sub(&self, val: uint, order: Ordering) -> uint {\n         unsafe { atomic_sub(self.v.get(), val, order) }\n     }\n@@ -747,7 +722,6 @@ impl AtomicUint {\n     /// assert_eq!(0b101101, foo.fetch_and(0b110011, Ordering::SeqCst));\n     /// assert_eq!(0b100001, foo.load(Ordering::SeqCst));\n     #[inline]\n-    #[stable]\n     pub fn fetch_and(&self, val: uint, order: Ordering) -> uint {\n         unsafe { atomic_and(self.v.get(), val, order) }\n     }\n@@ -763,7 +737,6 @@ impl AtomicUint {\n     /// assert_eq!(0b101101, foo.fetch_or(0b110011, Ordering::SeqCst));\n     /// assert_eq!(0b111111, foo.load(Ordering::SeqCst));\n     #[inline]\n-    #[stable]\n     pub fn fetch_or(&self, val: uint, order: Ordering) -> uint {\n         unsafe { atomic_or(self.v.get(), val, order) }\n     }\n@@ -779,7 +752,6 @@ impl AtomicUint {\n     /// assert_eq!(0b101101, foo.fetch_xor(0b110011, Ordering::SeqCst));\n     /// assert_eq!(0b011110, foo.load(Ordering::SeqCst));\n     #[inline]\n-    #[stable]\n     pub fn fetch_xor(&self, val: uint, order: Ordering) -> uint {\n         unsafe { atomic_xor(self.v.get(), val, order) }\n     }"}, {"sha": "2fe8f35a9ab0966bdfffdb97991e18cf38734ff7", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/83c890b4542abf60f833df3da1924ed3ce559862/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83c890b4542abf60f833df3da1924ed3ce559862/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=83c890b4542abf60f833df3da1924ed3ce559862", "patch": "@@ -144,6 +144,7 @@ Section: Creating a string\n \n /// Errors which can occur when attempting to interpret a byte slice as a `str`.\n #[derive(Copy, Eq, PartialEq, Clone)]\n+#[unstable = \"error enumeration recently added and definitions may be refined\"]\n pub enum Utf8Error {\n     /// An invalid byte was detected at the byte offset given.\n     ///\n@@ -167,6 +168,7 @@ pub enum Utf8Error {\n ///\n /// Returns `Err` if the slice is not utf-8 with a description as to why the\n /// provided slice is not utf-8.\n+#[stable]\n pub fn from_utf8(v: &[u8]) -> Result<&str, Utf8Error> {\n     try!(run_utf8_validation_iterator(&mut v.iter()));\n     Ok(unsafe { from_utf8_unchecked(v) })\n@@ -249,6 +251,7 @@ Section: Iterators\n ///\n /// Created with the method `.chars()`.\n #[derive(Clone, Copy)]\n+#[stable]\n pub struct Chars<'a> {\n     iter: slice::Iter<'a, u8>\n }\n@@ -858,6 +861,7 @@ impl Searcher {\n /// An iterator over the start and end indices of the matches of a\n /// substring within a larger string\n #[derive(Clone)]\n+#[unstable = \"type may be removed\"]\n pub struct MatchIndices<'a> {\n     // constants\n     haystack: &'a str,\n@@ -868,7 +872,7 @@ pub struct MatchIndices<'a> {\n /// An iterator over the substrings of a string separated by a given\n /// search string\n #[derive(Clone)]\n-#[unstable = \"Type might get removed\"]\n+#[unstable = \"type may be removed\"]\n pub struct SplitStr<'a> {\n     it: MatchIndices<'a>,\n     last_end: uint,\n@@ -1068,8 +1072,7 @@ const TAG_CONT_U8: u8 = 0b1000_0000u8;\n Section: Trait implementations\n */\n \n-#[allow(missing_docs)]\n-pub mod traits {\n+mod traits {\n     use cmp::{Ordering, Ord, PartialEq, PartialOrd, Eq};\n     use cmp::Ordering::{Less, Equal, Greater};\n     use iter::IteratorExt;"}, {"sha": "a1c529186371deec5747a7402f371431b9281c88", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/83c890b4542abf60f833df3da1924ed3ce559862/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83c890b4542abf60f833df3da1924ed3ce559862/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=83c890b4542abf60f833df3da1924ed3ce559862", "patch": "@@ -95,7 +95,7 @@\n //! and `format!`, also available to all Rust code.\n \n #![crate_name = \"std\"]\n-#![unstable]\n+#![stable]\n #![crate_type = \"rlib\"]\n #![crate_type = \"dylib\"]\n #![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\","}, {"sha": "0496944dbaf88e081424a09fe7514099bcca4381", "filename": "src/libstd/prelude/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/83c890b4542abf60f833df3da1924ed3ce559862/src%2Flibstd%2Fprelude%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83c890b4542abf60f833df3da1924ed3ce559862/src%2Flibstd%2Fprelude%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude%2Fmod.rs?ref=83c890b4542abf60f833df3da1924ed3ce559862", "patch": "@@ -35,5 +35,7 @@\n //! pervasive that it would be obnoxious to import for every use, particularly\n //! those that define methods on primitive types.\n \n+#![stable]\n+\n #[stable]\n pub mod v1;"}, {"sha": "6fff6765bd34879c3e9d246de2b00c034fe6fec9", "filename": "src/libstd/sync/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/83c890b4542abf60f833df3da1924ed3ce559862/src%2Flibstd%2Fsync%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83c890b4542abf60f833df3da1924ed3ce559862/src%2Flibstd%2Fsync%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmod.rs?ref=83c890b4542abf60f833df3da1924ed3ce559862", "patch": "@@ -15,7 +15,7 @@\n //! and/or blocking at all, but rather provide the necessary tools to build\n //! other types of concurrent primitives.\n \n-#![experimental]\n+#![stable]\n \n pub use alloc::arc::{Arc, Weak};\n pub use core::atomic;"}, {"sha": "bcfd61582a31dfdeed2235611e5dcccc4eb81130", "filename": "src/libstd/sync/mpsc/mod.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/83c890b4542abf60f833df3da1924ed3ce559862/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83c890b4542abf60f833df3da1924ed3ce559862/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs?ref=83c890b4542abf60f833df3da1924ed3ce559862", "patch": "@@ -162,6 +162,8 @@\n //! }\n //! ```\n \n+#![stable]\n+\n // A description of how Rust's channel implementation works\n //\n // Channels are supposed to be the basic building block for all other\n@@ -589,8 +591,8 @@ impl<T: Send> Sender<T> {\n     /// drop(rx);\n     /// assert_eq!(tx.send_opt(1), Err(1));\n     /// ```\n-    #[unstable = \"this function may be renamed to send() in the future\"]\n-    pub fn send_opt(&self, t: T) -> Result<(), T> {\n+    #[stable]\n+    pub fn send(&self, t: T) -> Result<(), SendError<T>> {\n         let (new_inner, ret) = match *unsafe { self.inner() } {\n             Flavor::Oneshot(ref p) => {\n                 unsafe {"}, {"sha": "aa2d957a3eb5e14bb3268b2e539fcc51e31ff939", "filename": "src/libstd/sync/once.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/83c890b4542abf60f833df3da1924ed3ce559862/src%2Flibstd%2Fsync%2Fonce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83c890b4542abf60f833df3da1924ed3ce559862/src%2Flibstd%2Fsync%2Fonce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fonce.rs?ref=83c890b4542abf60f833df3da1924ed3ce559862", "patch": "@@ -121,10 +121,6 @@ impl Once {\n             unsafe { self.mutex.destroy() }\n         }\n     }\n-\n-    /// Deprecated\n-    #[deprecated = \"renamed to `call_once`\"]\n-    pub fn doit<F>(&'static self, f: F) where F: FnOnce() { self.call_once(f) }\n }\n \n #[cfg(test)]"}]}