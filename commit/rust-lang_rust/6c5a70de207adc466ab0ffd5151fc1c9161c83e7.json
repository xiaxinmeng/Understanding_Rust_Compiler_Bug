{"sha": "6c5a70de207adc466ab0ffd5151fc1c9161c83e7", "node_id": "C_kwDOAAsO6NoAKDZjNWE3MGRlMjA3YWRjNDY2YWIwZmZkNTE1MWZjMWM5MTYxYzgzZTc", "commit": {"author": {"name": "antoyo", "email": "antoyo@users.noreply.github.com", "date": "2023-01-11T05:24:47Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-01-11T05:24:47Z"}, "message": "Merge pull request #244 from rust-lang/feature/unwinding\n\nImplement unwinding", "tree": {"sha": "fdaf58073400f55fb4b784b4857b688cc53730f8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fdaf58073400f55fb4b784b4857b688cc53730f8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6c5a70de207adc466ab0ffd5151fc1c9161c83e7", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjvkgfCRBK7hj4Ov3rIwAA6rUIAKgijOfEgYBb/816j9Q94cG1\nLt6ToyGOSrZ/CMBbGQqJhElIZR++Bnk50aJe61QR4Kq4XJISLs+PKZ6VDViKg//2\nl4HCadCjcJLMq4c4x0sy+DJGbc01ELGaKjkwC4JGcQcxjMGzVaAJjehSkcmZ8zdX\no5CTh47rbPobng+nRuUdROwc4LcLZiPNBkbhLlOJro2SQUiAWPXDii/IYjRmyM/e\nqM3HnkOKoztBgs1NVINUuGhPLh03+jqcemY/cJOin5WT55/Oet69ZPLN6A+fKRD+\nKo5lX2LOD/5PTmVn3CcJ1jPu+1b1GaHjs8oiSiZ2Tl1rI2UnxhvRK30Kki3zaLM=\n=/L1W\n-----END PGP SIGNATURE-----\n", "payload": "tree fdaf58073400f55fb4b784b4857b688cc53730f8\nparent 7c1d21c3b91e33d5185228e98ec0eb01ed3f1cd5\nparent 8e77fbf0cce0fbbc780819ad81459bba2e0ba0c0\nauthor antoyo <antoyo@users.noreply.github.com> 1673414687 -0500\ncommitter GitHub <noreply@github.com> 1673414687 -0500\n\nMerge pull request #244 from rust-lang/feature/unwinding\n\nImplement unwinding"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6c5a70de207adc466ab0ffd5151fc1c9161c83e7", "html_url": "https://github.com/rust-lang/rust/commit/6c5a70de207adc466ab0ffd5151fc1c9161c83e7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6c5a70de207adc466ab0ffd5151fc1c9161c83e7/comments", "author": {"login": "antoyo", "id": 584972, "node_id": "MDQ6VXNlcjU4NDk3Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/584972?v=4", "gravatar_id": "", "url": "https://api.github.com/users/antoyo", "html_url": "https://github.com/antoyo", "followers_url": "https://api.github.com/users/antoyo/followers", "following_url": "https://api.github.com/users/antoyo/following{/other_user}", "gists_url": "https://api.github.com/users/antoyo/gists{/gist_id}", "starred_url": "https://api.github.com/users/antoyo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/antoyo/subscriptions", "organizations_url": "https://api.github.com/users/antoyo/orgs", "repos_url": "https://api.github.com/users/antoyo/repos", "events_url": "https://api.github.com/users/antoyo/events{/privacy}", "received_events_url": "https://api.github.com/users/antoyo/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7c1d21c3b91e33d5185228e98ec0eb01ed3f1cd5", "url": "https://api.github.com/repos/rust-lang/rust/commits/7c1d21c3b91e33d5185228e98ec0eb01ed3f1cd5", "html_url": "https://github.com/rust-lang/rust/commit/7c1d21c3b91e33d5185228e98ec0eb01ed3f1cd5"}, {"sha": "8e77fbf0cce0fbbc780819ad81459bba2e0ba0c0", "url": "https://api.github.com/repos/rust-lang/rust/commits/8e77fbf0cce0fbbc780819ad81459bba2e0ba0c0", "html_url": "https://github.com/rust-lang/rust/commit/8e77fbf0cce0fbbc780819ad81459bba2e0ba0c0"}], "stats": {"total": 485, "additions": 388, "deletions": 97}, "files": [{"sha": "927eb3077616ad222f39e8db6a2a82071d6e2440", "filename": ".github/workflows/ci.yml", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6c5a70de207adc466ab0ffd5151fc1c9161c83e7/.github%2Fworkflows%2Fci.yml", "raw_url": "https://github.com/rust-lang/rust/raw/6c5a70de207adc466ab0ffd5151fc1c9161c83e7/.github%2Fworkflows%2Fci.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2Fworkflows%2Fci.yml?ref=6c5a70de207adc466ab0ffd5151fc1c9161c83e7", "patch": "@@ -19,9 +19,9 @@ jobs:\n       fail-fast: false\n       matrix:\n         libgccjit_version:\n-          - { gcc: \"libgccjit.so\", extra: \"\", artifacts_branch: \"master\" }\n-          - { gcc: \"libgccjit_without_int128.so\", extra: \"\", artifacts_branch: \"master-without-128bit-integers\" }\n-          - { gcc: \"libgccjit12.so\", extra: \"--no-default-features\", artifacts_branch: \"gcc12\" }\n+          - { gcc: \"libgccjit.so\", extra: \"\", env_extra: \"\", artifacts_branch: \"master\" }\n+          - { gcc: \"libgccjit_without_int128.so\", extra: \"\", env_extra: \"\", artifacts_branch: \"master-without-128bit-integers\" }\n+          - { gcc: \"libgccjit12.so\", extra: \"--no-default-features\", env_extra: \"TEST_FLAGS='-Cpanic=abort -Zpanic-abort-tests'\", artifacts_branch: \"gcc12\" }\n         commands: [\n           \"--mini-tests\",\n           \"--std-tests\",\n@@ -120,8 +120,8 @@ jobs:\n     - name: Build\n       run: |\n         ./prepare_build.sh\n-        ./build.sh ${{ matrix.libgccjit_version.extra }}\n-        cargo test ${{ matrix.libgccjit_version.extra }}\n+        ${{ matrix.libgccjit_version.env_extra }} ./build.sh ${{ matrix.libgccjit_version.extra }}\n+        ${{ matrix.libgccjit_version.env_extra }} cargo test ${{ matrix.libgccjit_version.extra }}\n         ./clean_all.sh\n \n     - name: Prepare dependencies\n@@ -143,7 +143,7 @@ jobs:\n \n     - name: Run tests\n       run: |\n-        ./test.sh --release --clean --build-sysroot ${{ matrix.commands }} ${{ matrix.libgccjit_version.extra }}\n+        ${{ matrix.libgccjit_version.env_extra }} ./test.sh --release --clean --build-sysroot ${{ matrix.commands }} ${{ matrix.libgccjit_version.extra }}\n \n   duplicates:\n     runs-on: ubuntu-latest"}, {"sha": "e20980caee16cc9fb6704343869ff7f3ad59ea2a", "filename": "Cargo.lock", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c5a70de207adc466ab0ffd5151fc1c9161c83e7/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/6c5a70de207adc466ab0ffd5151fc1c9161c83e7/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=6c5a70de207adc466ab0ffd5151fc1c9161c83e7", "patch": "@@ -41,15 +41,15 @@ dependencies = [\n [[package]]\n name = \"gccjit\"\n version = \"1.0.0\"\n-source = \"git+https://github.com/antoyo/gccjit.rs#f30cc2bd330f4fda3d625f305bdfd7e523e2d8f8\"\n+source = \"git+https://github.com/antoyo/gccjit.rs#1e6ecc67fe73ac995e511516eacf4fe3aec8974e\"\n dependencies = [\n  \"gccjit_sys\",\n ]\n \n [[package]]\n name = \"gccjit_sys\"\n version = \"0.0.1\"\n-source = \"git+https://github.com/antoyo/gccjit.rs#f30cc2bd330f4fda3d625f305bdfd7e523e2d8f8\"\n+source = \"git+https://github.com/antoyo/gccjit.rs#1e6ecc67fe73ac995e511516eacf4fe3aec8974e\"\n dependencies = [\n  \"libc 0.1.12\",\n ]"}, {"sha": "3201afbd78201ef80db580d6042f586b2f385150", "filename": "Readme.md", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/6c5a70de207adc466ab0ffd5151fc1c9161c83e7/Readme.md", "raw_url": "https://github.com/rust-lang/rust/raw/6c5a70de207adc466ab0ffd5151fc1c9161c83e7/Readme.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Readme.md?ref=6c5a70de207adc466ab0ffd5151fc1c9161c83e7", "patch": "@@ -162,8 +162,26 @@ To print a debug representation of a tree:\n debug_tree(expr);\n ```\n \n+(defined in print-tree.h)\n+\n+To print a debug reprensentation of a gimple struct:\n+\n+```c\n+debug_gimple_stmt(gimple_struct)\n+```\n+\n To get the `rustc` command to run in `gdb`, add the `--verbose` flag to `cargo build`.\n \n+To have the correct file paths in `gdb` instead of `/usr/src/debug/gcc/libstdc++-v3/libsupc++/eh_personality.cc`, TODO\n+\n+Maybe by calling the following at the beginning of gdb:\n+\n+```\n+set substitute-path /usr/src/debug/gcc /path/to/gcc-repo/gcc\n+```\n+\n+TODO: but that's not what I remember I was doing.\n+\n ### How to use a custom-build rustc\n \n  * Build the stage2 compiler (`rustup toolchain link debug-current build/x86_64-unknown-linux-gnu/stage2`)."}, {"sha": "9d692d599f6bef19852222ea918d3d942856f48c", "filename": "build_sysroot/build_sysroot.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c5a70de207adc466ab0ffd5151fc1c9161c83e7/build_sysroot%2Fbuild_sysroot.sh", "raw_url": "https://github.com/rust-lang/rust/raw/6c5a70de207adc466ab0ffd5151fc1c9161c83e7/build_sysroot%2Fbuild_sysroot.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/build_sysroot%2Fbuild_sysroot.sh?ref=6c5a70de207adc466ab0ffd5151fc1c9161c83e7", "patch": "@@ -16,7 +16,7 @@ rm Cargo.lock test_target/Cargo.lock 2>/dev/null || true\n rm -r sysroot/ 2>/dev/null || true\n \n # Build libs\n-export RUSTFLAGS=\"$RUSTFLAGS -Z force-unstable-if-unmarked -Cpanic=abort\"\n+export RUSTFLAGS=\"$RUSTFLAGS -Z force-unstable-if-unmarked\"\n if [[ \"$1\" == \"--release\" ]]; then\n     sysroot_channel='release'\n     RUSTFLAGS=\"$RUSTFLAGS -Zmir-opt-level=3\" cargo build --target $TARGET_TRIPLE --release"}, {"sha": "166e83901c4f956b1d89762126eaa3291a8a936b", "filename": "config.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c5a70de207adc466ab0ffd5151fc1c9161c83e7/config.sh", "raw_url": "https://github.com/rust-lang/rust/raw/6c5a70de207adc466ab0ffd5151fc1c9161c83e7/config.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/config.sh?ref=6c5a70de207adc466ab0ffd5151fc1c9161c83e7", "patch": "@@ -38,7 +38,7 @@ if [[ \"$HOST_TRIPLE\" != \"$TARGET_TRIPLE\" ]]; then\n    fi\n fi\n \n-export RUSTFLAGS=\"$CG_RUSTFLAGS $linker -Cpanic=abort -Csymbol-mangling-version=v0 -Cdebuginfo=2 -Clto=off -Zpanic-abort-tests -Zcodegen-backend=$(pwd)/target/${CHANNEL:-debug}/librustc_codegen_gcc.$dylib_ext --sysroot $(pwd)/build_sysroot/sysroot\"\n+export RUSTFLAGS=\"$CG_RUSTFLAGS $linker -Csymbol-mangling-version=v0 -Cdebuginfo=2 -Clto=off -Zcodegen-backend=$(pwd)/target/${CHANNEL:-debug}/librustc_codegen_gcc.$dylib_ext --sysroot $(pwd)/build_sysroot/sysroot $TEST_FLAGS\"\n \n # FIXME(antoyo): remove once the atomic shim is gone\n if [[ `uname` == 'Darwin' ]]; then"}, {"sha": "c80348ca549707570b3da827f1209ce65e673bc8", "filename": "example/alloc_example.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6c5a70de207adc466ab0ffd5151fc1c9161c83e7/example%2Falloc_example.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c5a70de207adc466ab0ffd5151fc1c9161c83e7/example%2Falloc_example.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/example%2Falloc_example.rs?ref=6c5a70de207adc466ab0ffd5151fc1c9161c83e7", "patch": "@@ -1,4 +1,4 @@\n-#![feature(start, box_syntax, core_intrinsics, alloc_error_handler)]\n+#![feature(start, box_syntax, core_intrinsics, alloc_error_handler, lang_items)]\n #![no_std]\n \n extern crate alloc;\n@@ -26,6 +26,16 @@ fn alloc_error_handler(_: alloc::alloc::Layout) -> ! {\n     core::intrinsics::abort();\n }\n \n+#[lang = \"eh_personality\"]\n+fn eh_personality() -> ! {\n+    loop {}\n+}\n+\n+#[no_mangle]\n+unsafe extern \"C\" fn _Unwind_Resume() {\n+    core::intrinsics::unreachable();\n+}\n+\n #[start]\n fn main(_argc: isize, _argv: *const *const u8) -> isize {\n     let world: Box<&str> = box \"Hello World!\\0\";"}, {"sha": "2629144f16749a5c85652c86e9842484303c6f9a", "filename": "failing-ui-tests.txt", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/6c5a70de207adc466ab0ffd5151fc1c9161c83e7/failing-ui-tests.txt", "raw_url": "https://github.com/rust-lang/rust/raw/6c5a70de207adc466ab0ffd5151fc1c9161c83e7/failing-ui-tests.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/failing-ui-tests.txt?ref=6c5a70de207adc466ab0ffd5151fc1c9161c83e7", "patch": "@@ -41,3 +41,29 @@ src/test/ui/sse2.rs\n src/test/ui/statics/issue-91050-1.rs\n src/test/ui/statics/issue-91050-2.rs\n src/test/ui/target-feature/missing-plusminus.rs\n+src/test/ui/asm/x86_64/may_unwind.rs\n+src/test/ui/backtrace.rs\n+src/test/ui/catch-unwind-bang.rs\n+src/test/ui/cfg/cfg-panic-abort.rs\n+src/test/ui/drop/dynamic-drop-async.rs\n+src/test/ui/drop/repeat-drop.rs\n+src/test/ui/fmt/format-args-capture.rs\n+src/test/ui/generator/panic-drops-resume.rs\n+src/test/ui/generator/panic-drops.rs\n+src/test/ui/generator/panic-safe.rs\n+src/test/ui/intrinsics/panic-uninitialized-zeroed.rs\n+src/test/ui/issues/issue-14875.rs\n+src/test/ui/issues/issue-29948.rs\n+src/test/ui/issues/issue-43853.rs\n+src/test/ui/iterators/iter-sum-overflow-debug.rs\n+src/test/ui/iterators/iter-sum-overflow-overflow-checks.rs\n+src/test/ui/mir/mir_calls_to_shims.rs\n+src/test/ui/mir/mir_drop_order.rs\n+src/test/ui/mir/mir_let_chains_drop_order.rs\n+src/test/ui/oom_unwind.rs\n+src/test/ui/panic-runtime/abort-link-to-unwinding-crates.rs\n+src/test/ui/panic-runtime/abort.rs\n+src/test/ui/panic-runtime/link-to-abort.rs\n+src/test/ui/rfc-2091-track-caller/std-panic-locations.rs\n+src/test/ui/rfcs/rfc1857-drop-order.rs\n+src/test/ui/unwind-no-uwtable.rs"}, {"sha": "e52248b1d0b707c9b85a2bce059fa7fd2920deaa", "filename": "failing-ui-tests12.txt", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6c5a70de207adc466ab0ffd5151fc1c9161c83e7/failing-ui-tests12.txt", "raw_url": "https://github.com/rust-lang/rust/raw/6c5a70de207adc466ab0ffd5151fc1c9161c83e7/failing-ui-tests12.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/failing-ui-tests12.txt?ref=6c5a70de207adc466ab0ffd5151fc1c9161c83e7", "patch": "@@ -22,3 +22,12 @@ src/test/ui/simd/intrinsic/inlining-issue67557.rs\n src/test/ui/simd/monomorphize-shuffle-index.rs\n src/test/ui/simd/shuffle.rs\n src/test/ui/simd/simd-bitmask.rs\n+src/test/ui/binding/fn-arg-incomplete-pattern-drop-order.rs\n+src/test/ui/drop/dynamic-drop.rs\n+src/test/ui/generator/resume-after-return.rs\n+src/test/ui/iterators/iter-step-overflow-debug.rs\n+src/test/ui/macros/rfc-2011-nicer-assert-messages/all-expr-kinds.rs\n+src/test/ui/numbers-arithmetic/next-power-of-two-overflow-debug.rs\n+src/test/ui/panic-while-printing.rs\n+src/test/ui/privacy/reachable-unnameable-items.rs\n+src/test/ui/rfc-1937-termination-trait/termination-trait-in-test.rs"}, {"sha": "19cd44f28193f711ac000719df1c6965c97c6beb", "filename": "src/asm.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6c5a70de207adc466ab0ffd5151fc1c9161c83e7/src%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c5a70de207adc466ab0ffd5151fc1c9161c83e7/src%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fasm.rs?ref=6c5a70de207adc466ab0ffd5151fc1c9161c83e7", "patch": "@@ -352,8 +352,7 @@ impl<'a, 'gcc, 'tcx> AsmBuilderMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n                     inputs.push(AsmInOperand {\n                         constraint: \"X\".into(),\n                         rust_idx,\n-                        val: self.cx.rvalue_as_function(get_fn(self.cx, instance))\n-                            .get_address(None),\n+                        val: get_fn(self.cx, instance).get_address(None),\n                     });\n                 }\n \n@@ -739,7 +738,7 @@ impl<'gcc, 'tcx> AsmMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n                         }\n \n                         GlobalAsmOperandRef::SymFn { instance } => {\n-                            let function = self.rvalue_as_function(get_fn(self, instance));\n+                            let function = get_fn(self, instance);\n                             self.add_used_function(function);\n                             // TODO(@Amanieu): Additional mangling is needed on\n                             // some targets to add a leading underscore (Mach-O)"}, {"sha": "ea933c25b2f3978307474e87b9761192f8f9463c", "filename": "src/base.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6c5a70de207adc466ab0ffd5151fc1c9161c83e7/src%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c5a70de207adc466ab0ffd5151fc1c9161c83e7/src%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbase.rs?ref=6c5a70de207adc466ab0ffd5151fc1c9161c83e7", "patch": "@@ -87,6 +87,10 @@ pub fn compile_codegen_unit<'tcx>(tcx: TyCtxt<'tcx>, cgu_name: Symbol, supports_\n         // Instantiate monomorphizations without filling out definitions yet...\n         //let llvm_module = ModuleLlvm::new(tcx, &cgu_name.as_str());\n         let context = Context::default();\n+\n+        context.add_command_line_option(\"-fexceptions\");\n+        context.add_driver_option(\"-fexceptions\");\n+\n         // TODO(antoyo): only set on x86 platforms.\n         context.add_command_line_option(\"-masm=intel\");\n         // TODO(antoyo): only add the following cli argument if the feature is supported.\n@@ -146,7 +150,7 @@ pub fn compile_codegen_unit<'tcx>(tcx: TyCtxt<'tcx>, cgu_name: Symbol, supports_\n             context.set_keep_intermediates(true);\n         }\n \n-        // TODO(bjorn3): Remove once unwinding is properly implemented\n+        // NOTE: The codegen generates unrechable blocks.\n         context.set_allow_unreachable_blocks(true);\n \n         {"}, {"sha": "0150f5ba8c1462ab7f4b397111deb48191b30c8f", "filename": "src/builder.rs", "status": "modified", "additions": 77, "deletions": 9, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/6c5a70de207adc466ab0ffd5151fc1c9161c83e7/src%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c5a70de207adc466ab0ffd5151fc1c9161c83e7/src%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbuilder.rs?ref=6c5a70de207adc466ab0ffd5151fc1c9161c83e7", "patch": "@@ -372,10 +372,11 @@ impl<'tcx> FnAbiOfHelpers<'tcx> for Builder<'_, '_, 'tcx> {\n     }\n }\n \n-impl<'gcc, 'tcx> Deref for Builder<'_, 'gcc, 'tcx> {\n+impl<'a, 'gcc, 'tcx> Deref for Builder<'a, 'gcc, 'tcx> {\n     type Target = CodegenCx<'gcc, 'tcx>;\n \n-    fn deref(&self) -> &Self::Target {\n+    fn deref<'b>(&'b self) -> &'a Self::Target\n+    {\n         self.cx\n     }\n }\n@@ -393,7 +394,7 @@ impl<'gcc, 'tcx> BackendTypes for Builder<'_, 'gcc, 'tcx> {\n }\n \n impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n-    fn build(cx: &'a CodegenCx<'gcc, 'tcx>, block: Block<'gcc>) -> Self {\n+    fn build(cx: &'a CodegenCx<'gcc, 'tcx>, block: Block<'gcc>) -> Builder<'a, 'gcc, 'tcx> {\n         Builder::with_cx(cx, block)\n     }\n \n@@ -450,8 +451,36 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n         self.block.end_with_switch(None, value, default_block, &gcc_cases);\n     }\n \n+    #[cfg(feature=\"master\")]\n+    fn invoke(&mut self, typ: Type<'gcc>, func: RValue<'gcc>, args: &[RValue<'gcc>], then: Block<'gcc>, catch: Block<'gcc>, _funclet: Option<&Funclet>) -> RValue<'gcc> {\n+        let try_block = self.current_func().new_block(\"try\");\n+\n+        let current_block = self.block.clone();\n+        self.block = try_block;\n+        let call = self.call(typ, func, args, None); // TODO(antoyo): use funclet here?\n+        self.block = current_block;\n+\n+        let return_value = self.current_func()\n+            .new_local(None, call.get_type(), \"invokeResult\");\n+\n+        try_block.add_assignment(None, return_value, call);\n+\n+        try_block.end_with_jump(None, then);\n+\n+        if self.cleanup_blocks.borrow().contains(&catch) {\n+            self.block.add_try_finally(None, try_block, catch);\n+        }\n+        else {\n+            self.block.add_try_catch(None, try_block, catch);\n+        }\n+\n+        self.block.end_with_jump(None, then);\n+\n+        return_value.to_rvalue()\n+    }\n+\n+    #[cfg(not(feature=\"master\"))]\n     fn invoke(&mut self, typ: Type<'gcc>, func: RValue<'gcc>, args: &[RValue<'gcc>], then: Block<'gcc>, catch: Block<'gcc>, _funclet: Option<&Funclet>) -> RValue<'gcc> {\n-        // TODO(bjorn3): Properly implement unwinding.\n         let call_site = self.call(typ, func, args, None);\n         let condition = self.context.new_rvalue_from_int(self.bool_type, 1);\n         self.llbb().end_with_conditional(None, condition, then, catch);\n@@ -1161,22 +1190,61 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n     }\n \n     fn set_personality_fn(&mut self, _personality: RValue<'gcc>) {\n-        // TODO(antoyo)\n+        #[cfg(feature=\"master\")]\n+        {\n+            let personality = self.rvalue_as_function(_personality);\n+            self.current_func().set_personality_function(personality);\n+        }\n     }\n \n+    #[cfg(feature=\"master\")]\n+    fn cleanup_landing_pad(&mut self, _ty: Type<'gcc>, pers_fn: RValue<'gcc>) -> RValue<'gcc> {\n+        self.set_personality_fn(pers_fn);\n+\n+        // NOTE: insert the current block in a variable so that a later call to invoke knows to\n+        // generate a try/finally instead of a try/catch for this block.\n+        self.cleanup_blocks.borrow_mut().insert(self.block);\n+\n+        let eh_pointer_builtin = self.cx.context.get_target_builtin_function(\"__builtin_eh_pointer\");\n+        let zero = self.cx.context.new_rvalue_zero(self.int_type);\n+        let ptr = self.cx.context.new_call(None, eh_pointer_builtin, &[zero]);\n+\n+        let field1_type = self.u8_type.make_pointer();\n+        let field1 = self.context.new_field(None, field1_type, \"landing_pad_field_1\");\n+        let field2 = self.context.new_field(None, self.i32_type, \"landing_pad_field_2\");\n+        let struct_type = self.context.new_struct_type(None, \"landing_pad\", &[field1, field2]);\n+        let value = self.current_func().new_local(None, struct_type.as_type(), \"landing_pad\");\n+        let ptr = self.cx.context.new_cast(None, ptr, field1_type);\n+        self.block.add_assignment(None, value.access_field(None, field1), ptr);\n+        self.block.add_assignment(None, value.access_field(None, field2), zero); // TODO: set the proper value here (the type of exception?).\n+\n+        value.to_rvalue()\n+    }\n+\n+    #[cfg(not(feature=\"master\"))]\n     fn cleanup_landing_pad(&mut self, _ty: Type<'gcc>, _pers_fn: RValue<'gcc>) -> RValue<'gcc> {\n         let field1 = self.context.new_field(None, self.u8_type.make_pointer(), \"landing_pad_field_1\");\n         let field2 = self.context.new_field(None, self.i32_type, \"landing_pad_field_1\");\n         let struct_type = self.context.new_struct_type(None, \"landing_pad\", &[field1, field2]);\n         self.current_func().new_local(None, struct_type.as_type(), \"landing_pad\")\n             .to_rvalue()\n-        // TODO(antoyo): Properly implement unwinding.\n-        // the above is just to make the compilation work as it seems\n-        // rustc_codegen_ssa now calls the unwinding builder methods even on panic=abort.\n     }\n \n+    #[cfg(feature=\"master\")]\n+    fn resume(&mut self, exn: RValue<'gcc>) {\n+        // TODO: check if this is normal that we need to dereference the value.\n+        // NOTE: the type is wrong, so in order to get a pointer for parameter, cast it to a\n+        // pointer of pointer that is later dereferenced.\n+        let exn_type = exn.get_type().make_pointer();\n+        let exn = self.context.new_cast(None, exn, exn_type);\n+        let exn = exn.dereference(None).to_rvalue();\n+        let unwind_resume = self.context.get_target_builtin_function(\"__builtin_unwind_resume\");\n+        self.llbb().add_eval(None, self.context.new_call(None, unwind_resume, &[exn]));\n+        self.unreachable();\n+    }\n+\n+    #[cfg(not(feature=\"master\"))]\n     fn resume(&mut self, _exn: RValue<'gcc>) {\n-        // TODO(bjorn3): Properly implement unwinding.\n         self.unreachable();\n     }\n "}, {"sha": "70cdece7f0afeaaa16351ceee2510ff4cd935b40", "filename": "src/callee.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/6c5a70de207adc466ab0ffd5151fc1c9161c83e7/src%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c5a70de207adc466ab0ffd5151fc1c9161c83e7/src%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcallee.rs?ref=6c5a70de207adc466ab0ffd5151fc1c9161c83e7", "patch": "@@ -1,11 +1,9 @@\n #[cfg(feature=\"master\")]\n use gccjit::{FnAttribute, Visibility};\n-use gccjit::{FunctionType, RValue};\n-use rustc_codegen_ssa::traits::BaseTypeMethods;\n+use gccjit::{FunctionType, Function};\n use rustc_middle::ty::{self, Instance, TypeVisitable};\n use rustc_middle::ty::layout::{FnAbiOf, HasTyCtxt};\n \n-use crate::abi::FnAbiGccExt;\n use crate::attributes;\n use crate::context::CodegenCx;\n \n@@ -16,22 +14,26 @@ use crate::context::CodegenCx;\n ///\n /// - `cx`: the crate context\n /// - `instance`: the instance to be instantiated\n-pub fn get_fn<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, instance: Instance<'tcx>) -> RValue<'gcc> {\n+pub fn get_fn<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, instance: Instance<'tcx>) -> Function<'gcc> {\n     let tcx = cx.tcx();\n \n     assert!(!instance.substs.needs_infer());\n     assert!(!instance.substs.has_escaping_bound_vars());\n \n+    let sym = tcx.symbol_name(instance).name;\n+\n     if let Some(&func) = cx.function_instances.borrow().get(&instance) {\n         return func;\n     }\n \n-    let sym = tcx.symbol_name(instance).name;\n-\n     let fn_abi = cx.fn_abi_of_instance(instance, ty::List::empty());\n \n     let func =\n-        if let Some(func) = cx.get_declared_value(&sym) {\n+        if let Some(_func) = cx.get_declared_value(&sym) {\n+            // FIXME: we never reach this because get_declared_value only returns global variables\n+            // and here we try to get a function.\n+            unreachable!();\n+            /*\n             // Create a fn pointer with the new signature.\n             let ptrty = fn_abi.ptr_to_gcc_type(cx);\n \n@@ -64,7 +66,7 @@ pub fn get_fn<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, instance: Instance<'tcx>)\n             }\n             else {\n                 func\n-            }\n+            }*/\n         }\n         else {\n             cx.linkage.set(FunctionType::Extern);\n@@ -163,8 +165,7 @@ pub fn get_fn<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, instance: Instance<'tcx>)\n                 }\n             }\n \n-            // FIXME(antoyo): this is a wrong cast. That requires changing the compiler API.\n-            unsafe { std::mem::transmute(func) }\n+            func\n         };\n \n     cx.function_instances.borrow_mut().insert(instance, func);"}, {"sha": "a66e13b6008a57c82c6398ac4a2096b585adf5dc", "filename": "src/context.rs", "status": "modified", "additions": 46, "deletions": 31, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/6c5a70de207adc466ab0ffd5151fc1c9161c83e7/src%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c5a70de207adc466ab0ffd5151fc1c9161c83e7/src%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcontext.rs?ref=6c5a70de207adc466ab0ffd5151fc1c9161c83e7", "patch": "@@ -4,14 +4,15 @@ use gccjit::{Block, CType, Context, Function, FunctionPtrType, FunctionType, LVa\n use rustc_codegen_ssa::base::wants_msvc_seh;\n use rustc_codegen_ssa::traits::{\n     BackendTypes,\n+    BaseTypeMethods,\n     MiscMethods,\n };\n use rustc_data_structures::base_n;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_middle::span_bug;\n use rustc_middle::mir::mono::CodegenUnit;\n use rustc_middle::ty::{self, Instance, ParamEnv, PolyExistentialTraitRef, Ty, TyCtxt};\n-use rustc_middle::ty::layout::{FnAbiError, FnAbiOfHelpers, FnAbiRequest, HasParamEnv, HasTyCtxt, LayoutError, TyAndLayout, LayoutOfHelpers};\n+use rustc_middle::ty::layout::{FnAbiError, FnAbiOf, FnAbiOfHelpers, FnAbiRequest, HasParamEnv, HasTyCtxt, LayoutError, TyAndLayout, LayoutOfHelpers};\n use rustc_session::Session;\n use rustc_span::Span;\n use rustc_target::abi::{call::FnAbi, HasDataLayout, PointeeInfo, Size, TargetDataLayout, VariantIdx};\n@@ -82,7 +83,7 @@ pub struct CodegenCx<'gcc, 'tcx> {\n     /// Cache instances of monomorphic and polymorphic items\n     pub instances: RefCell<FxHashMap<Instance<'tcx>, LValue<'gcc>>>,\n     /// Cache function instances of monomorphic and polymorphic items\n-    pub function_instances: RefCell<FxHashMap<Instance<'tcx>, RValue<'gcc>>>,\n+    pub function_instances: RefCell<FxHashMap<Instance<'tcx>, Function<'gcc>>>,\n     /// Cache generated vtables\n     pub vtables: RefCell<FxHashMap<(Ty<'tcx>, Option<ty::PolyExistentialTraitRef<'tcx>>), RValue<'gcc>>>,\n \n@@ -109,6 +110,7 @@ pub struct CodegenCx<'gcc, 'tcx> {\n     local_gen_sym_counter: Cell<usize>,\n \n     eh_personality: Cell<Option<RValue<'gcc>>>,\n+    pub rust_try_fn: Cell<Option<(Type<'gcc>, Function<'gcc>)>>,\n \n     pub pointee_infos: RefCell<FxHashMap<(Ty<'tcx>, Size), Option<PointeeInfo>>>,\n \n@@ -118,6 +120,8 @@ pub struct CodegenCx<'gcc, 'tcx> {\n     /// they can be dereferenced later.\n     /// FIXME(antoyo): fix the rustc API to avoid having this hack.\n     pub structs_as_pointer: RefCell<FxHashSet<RValue<'gcc>>>,\n+\n+    pub cleanup_blocks: RefCell<FxHashSet<Block<'gcc>>>,\n }\n \n impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n@@ -245,15 +249,18 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n             struct_types: Default::default(),\n             local_gen_sym_counter: Cell::new(0),\n             eh_personality: Cell::new(None),\n+            rust_try_fn: Cell::new(None),\n             pointee_infos: Default::default(),\n             structs_as_pointer: Default::default(),\n+            cleanup_blocks: Default::default(),\n         }\n     }\n \n     pub fn rvalue_as_function(&self, value: RValue<'gcc>) -> Function<'gcc> {\n         let function: Function<'gcc> = unsafe { std::mem::transmute(value) };\n+        // FIXME: seems like self.functions get overwritten for rust_eh_personality.\n         debug_assert!(self.functions.borrow().values().find(|value| **value == function).is_some(),\n-            \"{:?} ({:?}) is not a function\", value, value.get_type());\n+            \"{:?} is not a function\", function);\n         function\n     }\n \n@@ -326,8 +333,8 @@ impl<'gcc, 'tcx> MiscMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n \n     fn get_fn(&self, instance: Instance<'tcx>) -> RValue<'gcc> {\n         let func = get_fn(self, instance);\n-        *self.current_func.borrow_mut() = Some(self.rvalue_as_function(func));\n-        func\n+        *self.current_func.borrow_mut() = Some(func);\n+        unsafe { std::mem::transmute(func) }\n     }\n \n     fn get_fn_addr(&self, instance: Instance<'tcx>) -> RValue<'gcc> {\n@@ -338,8 +345,7 @@ impl<'gcc, 'tcx> MiscMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n                 self.intrinsics.borrow()[func_name].clone()\n             }\n             else {\n-                let func = get_fn(self, instance);\n-                self.rvalue_as_function(func)\n+                get_fn(self, instance)\n             };\n         let ptr = func.get_address(None);\n \n@@ -377,31 +383,40 @@ impl<'gcc, 'tcx> MiscMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n             return llpersonality;\n         }\n         let tcx = self.tcx;\n-        let llfn = match tcx.lang_items().eh_personality() {\n-            Some(def_id) if !wants_msvc_seh(self.sess()) => self.get_fn_addr(\n-                ty::Instance::resolve(\n-                    tcx,\n-                    ty::ParamEnv::reveal_all(),\n-                    def_id,\n-                    tcx.intern_substs(&[]),\n-                )\n-                .unwrap().unwrap(),\n-            ),\n-            _ => {\n-                let _name = if wants_msvc_seh(self.sess()) {\n-                    \"__CxxFrameHandler3\"\n-                } else {\n-                    \"rust_eh_personality\"\n-                };\n-                //let func = self.declare_func(name, self.type_i32(), &[], true);\n-                // FIXME(antoyo): this hack should not be needed. That will probably be removed when\n-                // unwinding support is added.\n-                self.context.new_rvalue_from_int(self.int_type, 0)\n-            }\n-        };\n+        let func =\n+            match tcx.lang_items().eh_personality() {\n+                Some(def_id) if !wants_msvc_seh(self.sess()) => {\n+                    let instance =\n+                        ty::Instance::resolve(\n+                            tcx,\n+                            ty::ParamEnv::reveal_all(),\n+                            def_id,\n+                            tcx.intern_substs(&[]),\n+                        )\n+                        .unwrap().unwrap();\n+\n+                    let symbol_name = tcx.symbol_name(instance).name;\n+                    let fn_abi = self.fn_abi_of_instance(instance, ty::List::empty());\n+                    self.linkage.set(FunctionType::Extern);\n+                    let func = self.declare_fn(symbol_name, &fn_abi);\n+                    let func: RValue<'gcc> = unsafe { std::mem::transmute(func) };\n+                    func\n+                },\n+                _ => {\n+                    let name =\n+                        if wants_msvc_seh(self.sess()) {\n+                            \"__CxxFrameHandler3\"\n+                        }\n+                        else {\n+                            \"rust_eh_personality\"\n+                        };\n+                    let func = self.declare_func(name, self.type_i32(), &[], true);\n+                    unsafe { std::mem::transmute(func) }\n+                }\n+            };\n         // TODO(antoyo): apply target cpu attributes.\n-        self.eh_personality.set(Some(llfn));\n-        llfn\n+        self.eh_personality.set(Some(func));\n+        func\n     }\n \n     fn sess(&self) -> &Session {"}, {"sha": "b4b7d1b011ea4059b3c133fcc60fef89132cff66", "filename": "src/declare.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6c5a70de207adc466ab0ffd5151fc1c9161c83e7/src%2Fdeclare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c5a70de207adc466ab0ffd5151fc1c9161c83e7/src%2Fdeclare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdeclare.rs?ref=6c5a70de207adc466ab0ffd5151fc1c9161c83e7", "patch": "@@ -38,12 +38,10 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n         global\n     }\n \n-    /*pub fn declare_func(&self, name: &str, return_type: Type<'gcc>, params: &[Type<'gcc>], variadic: bool) -> RValue<'gcc> {\n-        self.linkage.set(FunctionType::Exported);\n-        let func = declare_raw_fn(self, name, () /*llvm::CCallConv*/, return_type, params, variadic);\n-        // FIXME(antoyo): this is a wrong cast. That requires changing the compiler API.\n-        unsafe { std::mem::transmute(func) }\n-    }*/\n+    pub fn declare_func(&self, name: &str, return_type: Type<'gcc>, params: &[Type<'gcc>], variadic: bool) -> Function<'gcc> {\n+        self.linkage.set(FunctionType::Extern);\n+        declare_raw_fn(self, name, () /*llvm::CCallConv*/, return_type, params, variadic)\n+    }\n \n     pub fn declare_global(&self, name: &str, ty: Type<'gcc>, global_kind: GlobalKind, is_tls: bool, link_section: Option<Symbol>) -> LValue<'gcc> {\n         let global = self.context.new_global(None, global_kind, ty, name);"}, {"sha": "ee0ea6e993f9a5a7d72764ebe6578e774e3c4d18", "filename": "src/intrinsic/llvm.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6c5a70de207adc466ab0ffd5151fc1c9161c83e7/src%2Fintrinsic%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c5a70de207adc466ab0ffd5151fc1c9161c83e7/src%2Fintrinsic%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsic%2Fllvm.rs?ref=6c5a70de207adc466ab0ffd5151fc1c9161c83e7", "patch": "@@ -705,9 +705,9 @@ pub fn intrinsic<'gcc, 'tcx>(name: &str, cx: &CodegenCx<'gcc, 'tcx>) -> Function\n         \"llvm.x86.aesni.aesenclast.512\" => \"__builtin_ia32_vaesenclast_v64qi\",\n         \"llvm.x86.aesni.aesdec.512\" => \"__builtin_ia32_vaesdec_v64qi\",\n         \"llvm.x86.aesni.aesdeclast.512\" => \"__builtin_ia32_vaesdeclast_v64qi\",\n-        \"llvm.x86.avx512bf16.cvtne2ps2bf16.128\" => \"__builtin_ia32_cvtne2ps2bf16_v8hi\",\n-        \"llvm.x86.avx512bf16.cvtne2ps2bf16.256\" => \"__builtin_ia32_cvtne2ps2bf16_v16hi\",\n-        \"llvm.x86.avx512bf16.cvtne2ps2bf16.512\" => \"__builtin_ia32_cvtne2ps2bf16_v32hi\",\n+        \"llvm.x86.avx512bf16.cvtne2ps2bf16.128\" => \"__builtin_ia32_cvtne2ps2bf16_v8bf\",\n+        \"llvm.x86.avx512bf16.cvtne2ps2bf16.256\" => \"__builtin_ia32_cvtne2ps2bf16_v16bf\",\n+        \"llvm.x86.avx512bf16.cvtne2ps2bf16.512\" => \"__builtin_ia32_cvtne2ps2bf16_v32bf\",\n         \"llvm.x86.avx512bf16.cvtneps2bf16.256\" => \"__builtin_ia32_cvtneps2bf16_v8sf\",\n         \"llvm.x86.avx512bf16.cvtneps2bf16.512\" => \"__builtin_ia32_cvtneps2bf16_v16sf\",\n         \"llvm.x86.avx512bf16.dpbf16ps.128\" => \"__builtin_ia32_dpbf16ps_v4sf\","}, {"sha": "46471096e9105bbbb47aec468aeb087beca94fff", "filename": "src/intrinsic/mod.rs", "status": "modified", "additions": 150, "deletions": 4, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/6c5a70de207adc466ab0ffd5151fc1c9161c83e7/src%2Fintrinsic%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c5a70de207adc466ab0ffd5151fc1c9161c83e7/src%2Fintrinsic%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsic%2Fmod.rs?ref=6c5a70de207adc466ab0ffd5151fc1c9161c83e7", "patch": "@@ -1,22 +1,33 @@\n pub mod llvm;\n mod simd;\n \n+#[cfg(feature=\"master\")]\n+use std::iter;\n+\n use gccjit::{ComparisonOp, Function, RValue, ToRValue, Type, UnaryOp, FunctionType};\n use rustc_codegen_ssa::MemFlags;\n use rustc_codegen_ssa::base::wants_msvc_seh;\n use rustc_codegen_ssa::common::{IntPredicate, span_invalid_monomorphization_error};\n use rustc_codegen_ssa::mir::operand::{OperandRef, OperandValue};\n use rustc_codegen_ssa::mir::place::PlaceRef;\n use rustc_codegen_ssa::traits::{ArgAbiMethods, BaseTypeMethods, BuilderMethods, ConstMethods, IntrinsicCallMethods};\n+#[cfg(feature=\"master\")]\n+use rustc_codegen_ssa::traits::{DerivedTypeMethods, MiscMethods};\n use rustc_middle::bug;\n use rustc_middle::ty::{self, Instance, Ty};\n use rustc_middle::ty::layout::LayoutOf;\n+#[cfg(feature=\"master\")]\n+use rustc_middle::ty::layout::{FnAbiOf, HasTyCtxt};\n use rustc_span::{Span, Symbol, symbol::kw, sym};\n use rustc_target::abi::HasDataLayout;\n use rustc_target::abi::call::{ArgAbi, FnAbi, PassMode};\n use rustc_target::spec::PanicStrategy;\n+#[cfg(feature=\"master\")]\n+use rustc_target::spec::abi::Abi;\n \n use crate::abi::GccType;\n+#[cfg(feature=\"master\")]\n+use crate::abi::FnAbiGccExt;\n use crate::builder::Builder;\n use crate::common::{SignType, TypeReflection};\n use crate::context::CodegenCx;\n@@ -1115,10 +1126,8 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n     }\n }\n \n-fn try_intrinsic<'gcc, 'tcx>(bx: &mut Builder<'_, 'gcc, 'tcx>, try_func: RValue<'gcc>, data: RValue<'gcc>, _catch_func: RValue<'gcc>, dest: RValue<'gcc>) {\n-    // NOTE: the `|| true` here is to use the panic=abort strategy with panic=unwind too\n-    if bx.sess().panic_strategy() == PanicStrategy::Abort || true {\n-        // TODO(bjorn3): Properly implement unwinding and remove the `|| true` once this is done.\n+fn try_intrinsic<'a, 'b, 'gcc, 'tcx>(bx: &'b mut Builder<'a, 'gcc, 'tcx>, try_func: RValue<'gcc>, data: RValue<'gcc>, _catch_func: RValue<'gcc>, dest: RValue<'gcc>) {\n+    if bx.sess().panic_strategy() == PanicStrategy::Abort {\n         bx.call(bx.type_void(), try_func, &[data], None);\n         // Return 0 unconditionally from the intrinsic call;\n         // we can never unwind.\n@@ -1129,6 +1138,143 @@ fn try_intrinsic<'gcc, 'tcx>(bx: &mut Builder<'_, 'gcc, 'tcx>, try_func: RValue<\n         unimplemented!();\n     }\n     else {\n+        #[cfg(feature=\"master\")]\n+        codegen_gnu_try(bx, try_func, data, _catch_func, dest);\n+        #[cfg(not(feature=\"master\"))]\n         unimplemented!();\n     }\n }\n+\n+// Definition of the standard `try` function for Rust using the GNU-like model\n+// of exceptions (e.g., the normal semantics of LLVM's `landingpad` and `invoke`\n+// instructions).\n+//\n+// This codegen is a little surprising because we always call a shim\n+// function instead of inlining the call to `invoke` manually here. This is done\n+// because in LLVM we're only allowed to have one personality per function\n+// definition. The call to the `try` intrinsic is being inlined into the\n+// function calling it, and that function may already have other personality\n+// functions in play. By calling a shim we're guaranteed that our shim will have\n+// the right personality function.\n+#[cfg(feature=\"master\")]\n+fn codegen_gnu_try<'gcc>(bx: &mut Builder<'_, 'gcc, '_>, try_func: RValue<'gcc>, data: RValue<'gcc>, catch_func: RValue<'gcc>, dest: RValue<'gcc>) {\n+    //use std::ops::Deref;\n+    //let cx: &CodegenCx<'gcc, '_> = bx.deref();\n+    let cx: &CodegenCx<'gcc, '_> = bx.cx;\n+    let (llty, func) = get_rust_try_fn(cx, &mut |mut bx| {\n+        // Codegens the shims described above:\n+        //\n+        //   bx:\n+        //      invoke %try_func(%data) normal %normal unwind %catch\n+        //\n+        //   normal:\n+        //      ret 0\n+        //\n+        //   catch:\n+        //      (%ptr, _) = landingpad\n+        //      call %catch_func(%data, %ptr)\n+        //      ret 1\n+        let then = bx.append_sibling_block(\"then\");\n+        let catch = bx.append_sibling_block(\"catch\");\n+\n+        let func = bx.current_func();\n+        let try_func = func.get_param(0).to_rvalue();\n+        let data = func.get_param(1).to_rvalue();\n+        let catch_func = func.get_param(2).to_rvalue();\n+        let try_func_ty = bx.type_func(&[bx.type_i8p()], bx.type_void());\n+\n+        let current_block = bx.block.clone();\n+\n+        bx.switch_to_block(then);\n+        bx.ret(bx.const_i32(0));\n+\n+        // Type indicator for the exception being thrown.\n+        //\n+        // The value is a pointer to the exception object\n+        // being thrown.\n+        bx.switch_to_block(catch);\n+        bx.set_personality_fn(bx.eh_personality());\n+\n+        let eh_pointer_builtin = bx.cx.context.get_target_builtin_function(\"__builtin_eh_pointer\");\n+        let zero = bx.cx.context.new_rvalue_zero(bx.int_type);\n+        let ptr = bx.cx.context.new_call(None, eh_pointer_builtin, &[zero]);\n+        let catch_ty = bx.type_func(&[bx.type_i8p(), bx.type_i8p()], bx.type_void());\n+        bx.call(catch_ty, catch_func, &[data, ptr], None);\n+        bx.ret(bx.const_i32(1));\n+\n+        // NOTE: the blocks must be filled before adding the try/catch, otherwise gcc will not\n+        // generate a try/catch.\n+        // FIXME: add a check in the libgccjit API to prevent this.\n+        bx.switch_to_block(current_block);\n+        bx.invoke(try_func_ty, try_func, &[data], then, catch, None);\n+    });\n+\n+    let func = unsafe { std::mem::transmute(func) };\n+\n+    // Note that no invoke is used here because by definition this function\n+    // can't panic (that's what it's catching).\n+    let ret = bx.call(llty, func, &[try_func, data, catch_func], None);\n+    let i32_align = bx.tcx().data_layout.i32_align.abi;\n+    bx.store(ret, dest, i32_align);\n+}\n+\n+\n+// Helper function used to get a handle to the `__rust_try` function used to\n+// catch exceptions.\n+//\n+// This function is only generated once and is then cached.\n+#[cfg(feature=\"master\")]\n+fn get_rust_try_fn<'a, 'gcc, 'tcx>(cx: &'a CodegenCx<'gcc, 'tcx>, codegen: &mut dyn FnMut(Builder<'a, 'gcc, 'tcx>)) -> (Type<'gcc>, Function<'gcc>) {\n+    if let Some(llfn) = cx.rust_try_fn.get() {\n+        return llfn;\n+    }\n+\n+    // Define the type up front for the signature of the rust_try function.\n+    let tcx = cx.tcx;\n+    let i8p = tcx.mk_mut_ptr(tcx.types.i8);\n+    // `unsafe fn(*mut i8) -> ()`\n+    let try_fn_ty = tcx.mk_fn_ptr(ty::Binder::dummy(tcx.mk_fn_sig(\n+        iter::once(i8p),\n+        tcx.mk_unit(),\n+        false,\n+        rustc_hir::Unsafety::Unsafe,\n+        Abi::Rust,\n+    )));\n+    // `unsafe fn(*mut i8, *mut i8) -> ()`\n+    let catch_fn_ty = tcx.mk_fn_ptr(ty::Binder::dummy(tcx.mk_fn_sig(\n+        [i8p, i8p].iter().cloned(),\n+        tcx.mk_unit(),\n+        false,\n+        rustc_hir::Unsafety::Unsafe,\n+        Abi::Rust,\n+    )));\n+    // `unsafe fn(unsafe fn(*mut i8) -> (), *mut i8, unsafe fn(*mut i8, *mut i8) -> ()) -> i32`\n+    let rust_fn_sig = ty::Binder::dummy(cx.tcx.mk_fn_sig(\n+        [try_fn_ty, i8p, catch_fn_ty].iter(),\n+        &tcx.types.i32,\n+        false,\n+        rustc_hir::Unsafety::Unsafe,\n+        Abi::Rust,\n+    ));\n+    let rust_try = gen_fn(cx, \"__rust_try\", rust_fn_sig, codegen);\n+    cx.rust_try_fn.set(Some(rust_try));\n+    rust_try\n+}\n+\n+// Helper function to give a Block to a closure to codegen a shim function.\n+// This is currently primarily used for the `try` intrinsic functions above.\n+#[cfg(feature=\"master\")]\n+fn gen_fn<'a, 'gcc, 'tcx>(cx: &'a CodegenCx<'gcc, 'tcx>, name: &str, rust_fn_sig: ty::PolyFnSig<'tcx>, codegen: &mut dyn FnMut(Builder<'a, 'gcc, 'tcx>)) -> (Type<'gcc>, Function<'gcc>) {\n+    let fn_abi = cx.fn_abi_of_fn_ptr(rust_fn_sig, ty::List::empty());\n+    let (typ, _, _, _) = fn_abi.gcc_type(cx);\n+    // FIXME(eddyb) find a nicer way to do this.\n+    cx.linkage.set(FunctionType::Internal);\n+    let func = cx.declare_fn(name, fn_abi);\n+    let func_val = unsafe { std::mem::transmute(func) };\n+    cx.set_frame_pointer_type(func_val);\n+    cx.apply_target_cpu_attr(func_val);\n+    let block = Builder::append_block(cx, func_val, \"entry-block\");\n+    let bx = Builder::build(cx, block);\n+    codegen(bx);\n+    (typ, func)\n+}"}, {"sha": "0491fffc8abf1581120cdade3323dab74bf8f6f6", "filename": "src/mono_item.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6c5a70de207adc466ab0ffd5151fc1c9161c83e7/src%2Fmono_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c5a70de207adc466ab0ffd5151fc1c9161c83e7/src%2Fmono_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmono_item.rs?ref=6c5a70de207adc466ab0ffd5151fc1c9161c83e7", "patch": "@@ -59,5 +59,8 @@ impl<'gcc, 'tcx> PreDefineMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n         // TODO(antoyo): call set_link_section() to allow initializing argc/argv.\n         // TODO(antoyo): set unique comdat.\n         // TODO(antoyo): use inline attribute from there in linkage.set() above.\n+\n+        self.functions.borrow_mut().insert(symbol_name.to_string(), decl);\n+        self.function_instances.borrow_mut().insert(instance, unsafe { std::mem::transmute(decl) });\n     }\n }"}, {"sha": "4c490f04ae9d95efcc79a2eb6deb5d52f91414cd", "filename": "test.sh", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6c5a70de207adc466ab0ffd5151fc1c9161c83e7/test.sh", "raw_url": "https://github.com/rust-lang/rust/raw/6c5a70de207adc466ab0ffd5151fc1c9161c83e7/test.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/test.sh?ref=6c5a70de207adc466ab0ffd5151fc1c9161c83e7", "patch": "@@ -191,11 +191,11 @@ function std_tests() {\n     $RUN_WRAPPER ./target/out/std_example --target $TARGET_TRIPLE\n \n     echo \"[AOT] subslice-patterns-const-eval\"\n-    $RUSTC example/subslice-patterns-const-eval.rs --crate-type bin -Cpanic=abort --target $TARGET_TRIPLE\n+    $RUSTC example/subslice-patterns-const-eval.rs --crate-type bin $TEST_FLAGS --target $TARGET_TRIPLE\n     $RUN_WRAPPER ./target/out/subslice-patterns-const-eval\n \n     echo \"[AOT] track-caller-attribute\"\n-    $RUSTC example/track-caller-attribute.rs --crate-type bin -Cpanic=abort --target $TARGET_TRIPLE\n+    $RUSTC example/track-caller-attribute.rs --crate-type bin $TEST_FLAGS --target $TARGET_TRIPLE\n     $RUN_WRAPPER ./target/out/track-caller-attribute\n \n     echo \"[BUILD] mod_bench\"\n@@ -338,17 +338,17 @@ function test_rustc() {\n \n     git checkout -- src/test/ui/issues/auxiliary/issue-3136-a.rs # contains //~ERROR, but shouldn't be removed\n \n-    rm -r src/test/ui/{abi*,extern/,panic-runtime/,panics/,unsized-locals/,proc-macro/,threads-sendsync/,thinlto/,borrowck/,chalkify/bugs/,test*,*lto*.rs,consts/const-float-bits-reject-conv.rs,consts/issue-miri-1910.rs} || true\n+    rm -r src/test/ui/{abi*,extern/,unsized-locals/,proc-macro/,threads-sendsync/,thinlto/,borrowck/,chalkify/bugs/,test*,*lto*.rs,consts/const-float-bits-reject-conv.rs,consts/issue-miri-1910.rs} || true\n     rm src/test/ui/mir/mir_heavy_promoted.rs # this tests is oom-killed in the CI.\n-    for test in $(rg --files-with-matches \"catch_unwind|should_panic|thread|lto\" src/test/ui); do\n+    for test in $(rg --files-with-matches \"thread|lto\" src/test/ui); do\n       rm $test\n     done\n     git checkout src/test/ui/lto/auxiliary/dylib.rs\n     git checkout src/test/ui/type-alias-impl-trait/auxiliary/cross_crate_ice.rs\n     git checkout src/test/ui/type-alias-impl-trait/auxiliary/cross_crate_ice2.rs\n     git checkout src/test/ui/macros/rfc-2011-nicer-assert-messages/auxiliary/common.rs\n \n-    RUSTC_ARGS=\"-Zpanic-abort-tests -Csymbol-mangling-version=v0 -Zcodegen-backend=\"$(pwd)\"/../target/\"$CHANNEL\"/librustc_codegen_gcc.\"$dylib_ext\" --sysroot \"$(pwd)\"/../build_sysroot/sysroot -Cpanic=abort\"\n+    RUSTC_ARGS=\"$TEST_FLAGS -Csymbol-mangling-version=v0 -Zcodegen-backend=\"$(pwd)\"/../target/\"$CHANNEL\"/librustc_codegen_gcc.\"$dylib_ext\" --sysroot \"$(pwd)\"/../build_sysroot/sysroot\"\n \n     if [ $# -eq 0 ]; then\n         # No argument supplied to the function. Doing nothing."}, {"sha": "06de26f7efc9f8c8497e79e4d24e911ed6dbe80c", "filename": "tests/lang_tests_common.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6c5a70de207adc466ab0ffd5151fc1c9161c83e7/tests%2Flang_tests_common.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c5a70de207adc466ab0ffd5151fc1c9161c83e7/tests%2Flang_tests_common.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Flang_tests_common.rs?ref=6c5a70de207adc466ab0ffd5151fc1c9161c83e7", "patch": "@@ -46,11 +46,15 @@ pub fn main_inner(profile: Profile) {\n                 &format!(\"-Zcodegen-backend={}/target/debug/librustc_codegen_gcc.so\", current_dir),\n                 \"--sysroot\", &format!(\"{}/build_sysroot/sysroot/\", current_dir),\n                 \"-Zno-parallel-llvm\",\n-                \"-C\", \"panic=abort\",\n                 \"-C\", \"link-arg=-lc\",\n                 \"-o\", exe.to_str().expect(\"to_str\"),\n                 path.to_str().expect(\"to_str\"),\n             ]);\n+            if let Some(flags) = option_env!(\"TEST_FLAGS\") {\n+                for flag in flags.split_whitespace() {\n+                    compiler.arg(&flag);\n+                }\n+            }\n             match profile {\n                 Profile::Debug => {}\n                 Profile::Release => {"}, {"sha": "5693b6a215a648cd1cf833b8dccd835b79a1dde3", "filename": "tests/run/int.rs", "status": "modified", "additions": 3, "deletions": 13, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6c5a70de207adc466ab0ffd5151fc1c9161c83e7/tests%2Frun%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c5a70de207adc466ab0ffd5151fc1c9161c83e7/tests%2Frun%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun%2Fint.rs?ref=6c5a70de207adc466ab0ffd5151fc1c9161c83e7", "patch": "@@ -3,22 +3,14 @@\n // Run-time:\n //   status: 0\n \n-#![feature(bench_black_box, const_black_box, core_intrinsics, start)]\n-\n-#![no_std]\n-\n-#[panic_handler]\n-fn panic_handler(_: &core::panic::PanicInfo) -> ! {\n-    core::intrinsics::abort();\n-}\n+#![feature(bench_black_box, const_black_box)]\n \n /*\n  * Code\n  */\n \n-#[start]\n-fn main(_argc: isize, _argv: *const *const u8) -> isize {\n-    use core::hint::black_box;\n+fn main() {\n+    use std::hint::black_box;\n \n     macro_rules! check {\n         ($ty:ty, $expr:expr) => {\n@@ -335,6 +327,4 @@ fn main(_argc: isize, _argv: *const *const u8) -> isize {\n         const VAL5: T = 73236519889708027473620326106273939584_i128;\n         check_ops128!();\n     }\n-\n-    0\n }"}]}