{"sha": "02f78b089cd77404daf5ec4879a48a2b8a4c0760", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAyZjc4YjA4OWNkNzc0MDRkYWY1ZWM0ODc5YTQ4YTJiOGE0YzA3NjA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-07-27T12:23:56Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-07-27T12:23:56Z"}, "message": "Auto merge of #1858 - RalfJung:thread-leaks, r=oli-obk\n\nalso ignore 'thread leaks' with -Zmiri-ignore-leaks\n\nThis is a step towards https://github.com/rust-lang/miri/issues/1371. The remaining hard part would be supporting checking for memory leaks when there are threads still running. For now we elegantly avoid this problem by using the same flag to control both of these checks. :)", "tree": {"sha": "9e37a17f7d16fa9459d36eab7dddc6179034bad6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9e37a17f7d16fa9459d36eab7dddc6179034bad6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/02f78b089cd77404daf5ec4879a48a2b8a4c0760", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/02f78b089cd77404daf5ec4879a48a2b8a4c0760", "html_url": "https://github.com/rust-lang/rust/commit/02f78b089cd77404daf5ec4879a48a2b8a4c0760", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/02f78b089cd77404daf5ec4879a48a2b8a4c0760/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e445f789512763ed00b74af76c6f01140d64d50e", "url": "https://api.github.com/repos/rust-lang/rust/commits/e445f789512763ed00b74af76c6f01140d64d50e", "html_url": "https://github.com/rust-lang/rust/commit/e445f789512763ed00b74af76c6f01140d64d50e"}, {"sha": "78bcd12b17ae32fb74815cb2908a5149d5713415", "url": "https://api.github.com/repos/rust-lang/rust/commits/78bcd12b17ae32fb74815cb2908a5149d5713415", "html_url": "https://github.com/rust-lang/rust/commit/78bcd12b17ae32fb74815cb2908a5149d5713415"}], "stats": {"total": 78, "additions": 66, "deletions": 12}, "files": [{"sha": "7cd802762bff27c153d354ee529bab48834ff825", "filename": "README.md", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/02f78b089cd77404daf5ec4879a48a2b8a4c0760/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/02f78b089cd77404daf5ec4879a48a2b8a4c0760/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=02f78b089cd77404daf5ec4879a48a2b8a4c0760", "patch": "@@ -230,7 +230,8 @@ environment variable:\n   the host so that it cannot be accessed by the program.  Can be used multiple\n   times to exclude several variables.  On Windows, the `TERM` environment\n   variable is excluded by default.\n-* `-Zmiri-ignore-leaks` disables the memory leak checker.\n+* `-Zmiri-ignore-leaks` disables the memory leak checker, and also allows some\n+  remaining threads to exist when the main thread exits.\n * `-Zmiri-measureme=<name>` enables `measureme` profiling for the interpreted program.\n    This can be used to find which parts of your program are executing slowly under Miri.\n    The profile is written out to a file with the prefix `<name>`, and can be processed"}, {"sha": "2b8fc0f5adee2ec733339dd20c3f360540ffd41a", "filename": "src/eval.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/02f78b089cd77404daf5ec4879a48a2b8a4c0760/src%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02f78b089cd77404daf5ec4879a48a2b8a4c0760/src%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feval.rs?ref=02f78b089cd77404daf5ec4879a48a2b8a4c0760", "patch": "@@ -306,10 +306,20 @@ pub fn eval_main<'tcx>(tcx: TyCtxt<'tcx>, main_id: DefId, config: MiriConfig) ->\n     match res {\n         Ok(return_code) => {\n             if !ignore_leaks {\n+                // Check for thread leaks.\n+                if !ecx.have_all_terminated() {\n+                    tcx.sess.err(\n+                        \"the main thread terminated without waiting for all remaining threads\",\n+                    );\n+                    tcx.sess.note_without_error(\"pass `-Zmiri-ignore-leaks` to disable this check\");\n+                    return None;\n+                }\n+                // Check for memory leaks.\n                 info!(\"Additonal static roots: {:?}\", ecx.machine.static_roots);\n                 let leaks = ecx.memory.leak_report(&ecx.machine.static_roots);\n                 if leaks != 0 {\n                     tcx.sess.err(\"the evaluated program leaked memory\");\n+                    tcx.sess.note_without_error(\"pass `-Zmiri-ignore-leaks` to disable this check\");\n                     // Ignore the provided return code - let the reported error\n                     // determine the return code.\n                     return None;"}, {"sha": "a5deceb6e71dce95588a2540eea28136e1d38ce5", "filename": "src/thread.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/02f78b089cd77404daf5ec4879a48a2b8a4c0760/src%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02f78b089cd77404daf5ec4879a48a2b8a4c0760/src%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fthread.rs?ref=02f78b089cd77404daf5ec4879a48a2b8a4c0760", "patch": "@@ -302,6 +302,11 @@ impl<'mir, 'tcx: 'mir> ThreadManager<'mir, 'tcx> {\n         self.threads[thread_id].state == ThreadState::Terminated\n     }\n \n+    /// Have all threads terminated?\n+    fn have_all_terminated(&self) -> bool {\n+        self.threads.iter().all(|thread| thread.state == ThreadState::Terminated)\n+    }\n+\n     /// Enable the thread for execution. The thread must be terminated.\n     fn enable_thread(&mut self, thread_id: ThreadId) {\n         assert!(self.has_terminated(thread_id));\n@@ -491,15 +496,7 @@ impl<'mir, 'tcx: 'mir> ThreadManager<'mir, 'tcx> {\n         // If we get here again and the thread is *still* terminated, there are no more dtors to run.\n         if self.threads[MAIN_THREAD].state == ThreadState::Terminated {\n             // The main thread terminated; stop the program.\n-            if self.threads.iter().any(|thread| thread.state != ThreadState::Terminated) {\n-                // FIXME: This check should be either configurable or just emit\n-                // a warning. For example, it seems normal for a program to\n-                // terminate without waiting for its detached threads to\n-                // terminate. However, this case is not trivial to support\n-                // because we also probably do not want to consider the memory\n-                // owned by these threads as leaked.\n-                throw_unsup_format!(\"the main thread terminated without waiting for other threads\");\n-            }\n+            // We do *not* run TLS dtors of remaining threads, which seems to match rustc behavior.\n             return Ok(SchedulingAction::Stop);\n         }\n         // This thread and the program can keep going.\n@@ -645,6 +642,12 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         this.machine.threads.has_terminated(thread_id)\n     }\n \n+    #[inline]\n+    fn have_all_terminated(&self) -> bool {\n+        let this = self.eval_context_ref();\n+        this.machine.threads.have_all_terminated()\n+    }\n+\n     #[inline]\n     fn enable_thread(&mut self, thread_id: ThreadId) {\n         let this = self.eval_context_mut();"}, {"sha": "9b576bbb0868d2b2d8eb59072de5744cd05e591e", "filename": "tests/compile-fail/concurrency/libc_pthread_create_main_terminate.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/02f78b089cd77404daf5ec4879a48a2b8a4c0760/tests%2Fcompile-fail%2Fconcurrency%2Flibc_pthread_create_main_terminate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02f78b089cd77404daf5ec4879a48a2b8a4c0760/tests%2Fcompile-fail%2Fconcurrency%2Flibc_pthread_create_main_terminate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fconcurrency%2Flibc_pthread_create_main_terminate.rs?ref=02f78b089cd77404daf5ec4879a48a2b8a4c0760", "patch": "@@ -1,5 +1,5 @@\n // ignore-windows: No libc on Windows\n-// error-pattern: unsupported operation: the main thread terminated without waiting for other threads\n+// error-pattern: the main thread terminated without waiting for all remaining threads\n \n // Check that we terminate the program when the main thread terminates.\n \n@@ -10,7 +10,7 @@ extern crate libc;\n use std::{mem, ptr};\n \n extern \"C\" fn thread_start(_null: *mut libc::c_void) -> *mut libc::c_void {\n-    ptr::null_mut()\n+    loop {}\n }\n \n fn main() {"}, {"sha": "7bb51d2dea61f9a9901f986a638ee6838f438324", "filename": "tests/run-pass/threadleak_ignored.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/02f78b089cd77404daf5ec4879a48a2b8a4c0760/tests%2Frun-pass%2Fthreadleak_ignored.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02f78b089cd77404daf5ec4879a48a2b8a4c0760/tests%2Frun-pass%2Fthreadleak_ignored.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fthreadleak_ignored.rs?ref=02f78b089cd77404daf5ec4879a48a2b8a4c0760", "patch": "@@ -0,0 +1,37 @@\n+// ignore-windows: Concurrency on Windows is not supported yet.\n+// compile-flags: -Zmiri-ignore-leaks\n+\n+//! Test that leaking threads works, and that their destructors are not executed.\n+\n+use std::cell::RefCell;\n+\n+struct LoudDrop(i32);\n+impl Drop for LoudDrop {\n+    fn drop(&mut self) {\n+        eprintln!(\"Dropping {}\", self.0);\n+    }\n+}\n+\n+thread_local! {\n+    static X: RefCell<Option<LoudDrop>> = RefCell::new(None);\n+}\n+\n+fn main() {\n+    X.with(|x| *x.borrow_mut() = Some(LoudDrop(0)));\n+\n+    // Set up a channel so that we can learn when the other thread initialized `X`\n+    // (so that we are sure there is something to drop).\n+    let (send, recv) = std::sync::mpsc::channel::<()>();\n+    \n+    let _detached = std::thread::spawn(move || {\n+        X.with(|x| *x.borrow_mut() = Some(LoudDrop(1)));\n+        send.send(()).unwrap();\n+        std::thread::yield_now();\n+        loop {}\n+    });\n+\n+    std::thread::yield_now();\n+\n+    // Wait until child thread has initialized its `X`.\n+    let () = recv.recv().unwrap();\n+}"}, {"sha": "aa037511853b28feca5b8b942a1f47832fb81610", "filename": "tests/run-pass/threadleak_ignored.stderr", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/02f78b089cd77404daf5ec4879a48a2b8a4c0760/tests%2Frun-pass%2Fthreadleak_ignored.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/02f78b089cd77404daf5ec4879a48a2b8a4c0760/tests%2Frun-pass%2Fthreadleak_ignored.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fthreadleak_ignored.stderr?ref=02f78b089cd77404daf5ec4879a48a2b8a4c0760", "patch": "@@ -0,0 +1,3 @@\n+warning: thread support is experimental and incomplete: weak memory effects are not emulated.\n+\n+Dropping 0"}]}