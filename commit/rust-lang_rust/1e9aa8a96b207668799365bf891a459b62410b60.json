{"sha": "1e9aa8a96b207668799365bf891a459b62410b60", "node_id": "C_kwDOAAsO6NoAKDFlOWFhOGE5NmIyMDc2Njg3OTkzNjViZjg5MWE0NTliNjI0MTBiNjA", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-04-23T13:00:54Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-04-23T13:00:54Z"}, "message": "Auto merge of #95971 - workingjubilee:no-weird-fp-in-const, r=oli-obk\n\nNo \"weird\" floats in const fn {from,to}_bits\n\nI suspect this code is subtly incorrect and that we don't even e.g. use x87-style floats in CTFE, so I don't have to guard against that case. A future PR will be hopefully removing them from concern entirely, anyways. But at the moment I wanted to get this rolling because small questions like that one seem best answered by review.\n\nr? `@oli-obk`\ncc `@eddyb` `@thomcc`", "tree": {"sha": "221b8162ef609297c34c5b56c3acff39506d4869", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/221b8162ef609297c34c5b56c3acff39506d4869"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1e9aa8a96b207668799365bf891a459b62410b60", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1e9aa8a96b207668799365bf891a459b62410b60", "html_url": "https://github.com/rust-lang/rust/commit/1e9aa8a96b207668799365bf891a459b62410b60", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1e9aa8a96b207668799365bf891a459b62410b60/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c212fc4aa7719613e5254e9051ea03a93558fef4", "url": "https://api.github.com/repos/rust-lang/rust/commits/c212fc4aa7719613e5254e9051ea03a93558fef4", "html_url": "https://github.com/rust-lang/rust/commit/c212fc4aa7719613e5254e9051ea03a93558fef4"}, {"sha": "4da8682523ed8527046790f288ee55dd394be52a", "url": "https://api.github.com/repos/rust-lang/rust/commits/4da8682523ed8527046790f288ee55dd394be52a", "html_url": "https://github.com/rust-lang/rust/commit/4da8682523ed8527046790f288ee55dd394be52a"}], "stats": {"total": 527, "additions": 479, "deletions": 48}, "files": [{"sha": "e1a46086af060407134011f5bacce82997acd4d4", "filename": "library/core/src/num/f32.rs", "status": "modified", "additions": 158, "deletions": 9, "changes": 167, "blob_url": "https://github.com/rust-lang/rust/blob/1e9aa8a96b207668799365bf891a459b62410b60/library%2Fcore%2Fsrc%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e9aa8a96b207668799365bf891a459b62410b60/library%2Fcore%2Fsrc%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Ff32.rs?ref=1e9aa8a96b207668799365bf891a459b62410b60", "patch": "@@ -449,7 +449,8 @@ impl f32 {\n     #[inline]\n     #[rustc_const_unstable(feature = \"const_float_classify\", issue = \"72505\")]\n     pub(crate) const fn abs_private(self) -> f32 {\n-        f32::from_bits(self.to_bits() & 0x7fff_ffff)\n+        // SAFETY: This transmutation is fine. Probably. For the reasons std is using it.\n+        unsafe { mem::transmute::<u32, f32>(mem::transmute::<f32, u32>(self) & 0x7fff_ffff) }\n     }\n \n     /// Returns `true` if this value is positive infinity or negative infinity, and\n@@ -472,7 +473,10 @@ impl f32 {\n     #[rustc_const_unstable(feature = \"const_float_classify\", issue = \"72505\")]\n     #[inline]\n     pub const fn is_infinite(self) -> bool {\n-        self.abs_private() == Self::INFINITY\n+        // Getting clever with transmutation can result in incorrect answers on some FPUs\n+        // FIXME: alter the Rust <-> Rust calling convention to prevent this problem.\n+        // See https://github.com/rust-lang/rust/issues/72327\n+        (self == f32::INFINITY) | (self == f32::NEG_INFINITY)\n     }\n \n     /// Returns `true` if this number is neither infinite nor `NaN`.\n@@ -568,15 +572,76 @@ impl f32 {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[rustc_const_unstable(feature = \"const_float_classify\", issue = \"72505\")]\n     pub const fn classify(self) -> FpCategory {\n+        // A previous implementation tried to only use bitmask-based checks,\n+        // using f32::to_bits to transmute the float to its bit repr and match on that.\n+        // Unfortunately, floating point numbers can be much worse than that.\n+        // This also needs to not result in recursive evaluations of f64::to_bits.\n+        //\n+        // On some processors, in some cases, LLVM will \"helpfully\" lower floating point ops,\n+        // in spite of a request for them using f32 and f64, to things like x87 operations.\n+        // These have an f64's mantissa, but can have a larger than normal exponent.\n+        // FIXME(jubilee): Using x87 operations is never necessary in order to function\n+        // on x86 processors for Rust-to-Rust calls, so this issue should not happen.\n+        // Code generation should be adjusted to use non-C calling conventions, avoiding this.\n+        //\n+        if self.is_infinite() {\n+            // Thus, a value may compare unequal to infinity, despite having a \"full\" exponent mask.\n+            FpCategory::Infinite\n+        } else if self.is_nan() {\n+            // And it may not be NaN, as it can simply be an \"overextended\" finite value.\n+            FpCategory::Nan\n+        } else {\n+            // However, std can't simply compare to zero to check for zero, either,\n+            // as correctness requires avoiding equality tests that may be Subnormal == -0.0\n+            // because it may be wrong under \"denormals are zero\" and \"flush to zero\" modes.\n+            // Most of std's targets don't use those, but they are used for thumbv7neon.\n+            // So, this does use bitpattern matching for the rest.\n+\n+            // SAFETY: f32 to u32 is fine. Usually.\n+            // If classify has gotten this far, the value is definitely in one of these categories.\n+            unsafe { f32::partial_classify(self) }\n+        }\n+    }\n+\n+    // This doesn't actually return a right answer for NaN on purpose,\n+    // seeing as how it cannot correctly discern between a floating point NaN,\n+    // and some normal floating point numbers truncated from an x87 FPU.\n+    // FIXME(jubilee): This probably could at least answer things correctly for Infinity,\n+    // like the f64 version does, but I need to run more checks on how things go on x86.\n+    // I fear losing mantissa data that would have answered that differently.\n+    //\n+    // # Safety\n+    // This requires making sure you call this function for values it answers correctly on,\n+    // otherwise it returns a wrong answer. This is not important for memory safety per se,\n+    // but getting floats correct is important for not accidentally leaking const eval\n+    // runtime-deviating logic which may or may not be acceptable.\n+    #[rustc_const_unstable(feature = \"const_float_classify\", issue = \"72505\")]\n+    const unsafe fn partial_classify(self) -> FpCategory {\n         const EXP_MASK: u32 = 0x7f800000;\n         const MAN_MASK: u32 = 0x007fffff;\n \n-        let bits = self.to_bits();\n-        match (bits & MAN_MASK, bits & EXP_MASK) {\n+        // SAFETY: The caller is not asking questions for which this will tell lies.\n+        let b = unsafe { mem::transmute::<f32, u32>(self) };\n+        match (b & MAN_MASK, b & EXP_MASK) {\n             (0, 0) => FpCategory::Zero,\n             (_, 0) => FpCategory::Subnormal,\n+            _ => FpCategory::Normal,\n+        }\n+    }\n+\n+    // This operates on bits, and only bits, so it can ignore concerns about weird FPUs.\n+    // FIXME(jubilee): In a just world, this would be the entire impl for classify,\n+    // plus a transmute. We do not live in a just world, but we can make it more so.\n+    #[rustc_const_unstable(feature = \"const_float_classify\", issue = \"72505\")]\n+    const fn classify_bits(b: u32) -> FpCategory {\n+        const EXP_MASK: u32 = 0x7f800000;\n+        const MAN_MASK: u32 = 0x007fffff;\n+\n+        match (b & MAN_MASK, b & EXP_MASK) {\n             (0, EXP_MASK) => FpCategory::Infinite,\n             (_, EXP_MASK) => FpCategory::Nan,\n+            (0, 0) => FpCategory::Zero,\n+            (_, 0) => FpCategory::Subnormal,\n             _ => FpCategory::Normal,\n         }\n     }\n@@ -616,7 +681,8 @@ impl f32 {\n     pub const fn is_sign_negative(self) -> bool {\n         // IEEE754 says: isSignMinus(x) is true if and only if x has negative sign. isSignMinus\n         // applies to zeros and NaNs as well.\n-        self.to_bits() & 0x8000_0000 != 0\n+        // SAFETY: This is just transmuting to get the sign bit, it's fine.\n+        unsafe { mem::transmute::<f32, u32>(self) & 0x8000_0000 != 0 }\n     }\n \n     /// Takes the reciprocal (inverse) of a number, `1/x`.\n@@ -831,8 +897,49 @@ impl f32 {\n     #[rustc_const_unstable(feature = \"const_float_bits_conv\", issue = \"72447\")]\n     #[inline]\n     pub const fn to_bits(self) -> u32 {\n-        // SAFETY: `u32` is a plain old datatype so we can always transmute to it\n-        unsafe { mem::transmute(self) }\n+        // SAFETY: `u32` is a plain old datatype so we can always transmute to it.\n+        // ...sorta.\n+        //\n+        // It turns out that at runtime, it is possible for a floating point number\n+        // to be subject to a floating point mode that alters nonzero subnormal numbers\n+        // to zero on reads and writes, aka \"denormals are zero\" and \"flush to zero\".\n+        // This is not a problem per se, but at least one tier2 platform for Rust\n+        // actually exhibits this behavior by default.\n+        //\n+        // In addition, on x86 targets with SSE or SSE2 disabled and the x87 FPU enabled,\n+        // i.e. not soft-float, the way Rust does parameter passing can actually alter\n+        // a number that is \"not infinity\" to have the same exponent as infinity,\n+        // in a slightly unpredictable manner.\n+        //\n+        // And, of course evaluating to a NaN value is fairly nondeterministic.\n+        // More precisely: when NaN should be returned is knowable, but which NaN?\n+        // So far that's defined by a combination of LLVM and the CPU, not Rust.\n+        // This function, however, allows observing the bitstring of a NaN,\n+        // thus introspection on CTFE.\n+        //\n+        // In order to preserve, at least for the moment, const-to-runtime equivalence,\n+        // we reject any of these possible situations from happening.\n+        #[rustc_const_unstable(feature = \"const_float_bits_conv\", issue = \"72447\")]\n+        const fn ct_f32_to_u32(ct: f32) -> u32 {\n+            match ct.classify() {\n+                FpCategory::Nan => {\n+                    panic!(\"const-eval error: cannot use f32::to_bits on a NaN\")\n+                }\n+                FpCategory::Subnormal => {\n+                    panic!(\"const-eval error: cannot use f32::to_bits on a subnormal number\")\n+                }\n+                FpCategory::Infinite | FpCategory::Normal | FpCategory::Zero => {\n+                    // SAFETY: We have a normal floating point number. Now we transmute, i.e. do a bitcopy.\n+                    unsafe { mem::transmute::<f32, u32>(ct) }\n+                }\n+            }\n+        }\n+        // SAFETY: `u32` is a plain old datatype so we can always... uh...\n+        // ...look, just pretend you forgot what you just read.\n+        // Stability concerns.\n+        let rt_f32_to_u32 = |rt| unsafe { mem::transmute::<f32, u32>(rt) };\n+        // SAFETY: We use internal implementations that either always work or fail at compile time.\n+        unsafe { intrinsics::const_eval_select((self,), ct_f32_to_u32, rt_f32_to_u32) }\n     }\n \n     /// Raw transmutation from `u32`.\n@@ -876,9 +983,51 @@ impl f32 {\n     #[must_use]\n     #[inline]\n     pub const fn from_bits(v: u32) -> Self {\n-        // SAFETY: `u32` is a plain old datatype so we can always transmute from it\n         // It turns out the safety issues with sNaN were overblown! Hooray!\n-        unsafe { mem::transmute(v) }\n+        // SAFETY: `u32` is a plain old datatype so we can always transmute from it\n+        // ...sorta.\n+        //\n+        // It turns out that at runtime, it is possible for a floating point number\n+        // to be subject to floating point modes that alter nonzero subnormal numbers\n+        // to zero on reads and writes, aka \"denormals are zero\" and \"flush to zero\".\n+        // This is not a problem usually, but at least one tier2 platform for Rust\n+        // actually exhibits this behavior by default: thumbv7neon\n+        // aka \"the Neon FPU in AArch32 state\"\n+        //\n+        // In addition, on x86 targets with SSE or SSE2 disabled and the x87 FPU enabled,\n+        // i.e. not soft-float, the way Rust does parameter passing can actually alter\n+        // a number that is \"not infinity\" to have the same exponent as infinity,\n+        // in a slightly unpredictable manner.\n+        //\n+        // And, of course evaluating to a NaN value is fairly nondeterministic.\n+        // More precisely: when NaN should be returned is knowable, but which NaN?\n+        // So far that's defined by a combination of LLVM and the CPU, not Rust.\n+        // This function, however, allows observing the bitstring of a NaN,\n+        // thus introspection on CTFE.\n+        //\n+        // In order to preserve, at least for the moment, const-to-runtime equivalence,\n+        // reject any of these possible situations from happening.\n+        #[rustc_const_unstable(feature = \"const_float_bits_conv\", issue = \"72447\")]\n+        const fn ct_u32_to_f32(ct: u32) -> f32 {\n+            match f32::classify_bits(ct) {\n+                FpCategory::Subnormal => {\n+                    panic!(\"const-eval error: cannot use f32::from_bits on a subnormal number\")\n+                }\n+                FpCategory::Nan => {\n+                    panic!(\"const-eval error: cannot use f32::from_bits on NaN\")\n+                }\n+                FpCategory::Infinite | FpCategory::Normal | FpCategory::Zero => {\n+                    // SAFETY: It's not a frumious number\n+                    unsafe { mem::transmute::<u32, f32>(ct) }\n+                }\n+            }\n+        }\n+        // SAFETY: `u32` is a plain old datatype so we can always... uh...\n+        // ...look, just pretend you forgot what you just read.\n+        // Stability concerns.\n+        let rt_u32_to_f32 = |rt| unsafe { mem::transmute::<u32, f32>(rt) };\n+        // SAFETY: We use internal implementations that either always work or fail at compile time.\n+        unsafe { intrinsics::const_eval_select((v,), ct_u32_to_f32, rt_u32_to_f32) }\n     }\n \n     /// Return the memory representation of this floating point number as a byte array in"}, {"sha": "b07f201ca4ad282aa08069d21ed06e25586fc761", "filename": "library/core/src/num/f64.rs", "status": "modified", "additions": 140, "deletions": 9, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/1e9aa8a96b207668799365bf891a459b62410b60/library%2Fcore%2Fsrc%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e9aa8a96b207668799365bf891a459b62410b60/library%2Fcore%2Fsrc%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Ff64.rs?ref=1e9aa8a96b207668799365bf891a459b62410b60", "patch": "@@ -448,7 +448,10 @@ impl f64 {\n     #[inline]\n     #[rustc_const_unstable(feature = \"const_float_classify\", issue = \"72505\")]\n     pub(crate) const fn abs_private(self) -> f64 {\n-        f64::from_bits(self.to_bits() & 0x7fff_ffff_ffff_ffff)\n+        // SAFETY: This transmutation is fine. Probably. For the reasons std is using it.\n+        unsafe {\n+            mem::transmute::<u64, f64>(mem::transmute::<f64, u64>(self) & 0x7fff_ffff_ffff_ffff)\n+        }\n     }\n \n     /// Returns `true` if this value is positive infinity or negative infinity, and\n@@ -471,7 +474,10 @@ impl f64 {\n     #[rustc_const_unstable(feature = \"const_float_classify\", issue = \"72505\")]\n     #[inline]\n     pub const fn is_infinite(self) -> bool {\n-        self.abs_private() == Self::INFINITY\n+        // Getting clever with transmutation can result in incorrect answers on some FPUs\n+        // FIXME: alter the Rust <-> Rust calling convention to prevent this problem.\n+        // See https://github.com/rust-lang/rust/issues/72327\n+        (self == f64::INFINITY) | (self == f64::NEG_INFINITY)\n     }\n \n     /// Returns `true` if this number is neither infinite nor `NaN`.\n@@ -567,15 +573,67 @@ impl f64 {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[rustc_const_unstable(feature = \"const_float_classify\", issue = \"72505\")]\n     pub const fn classify(self) -> FpCategory {\n+        // A previous implementation tried to only use bitmask-based checks,\n+        // using f64::to_bits to transmute the float to its bit repr and match on that.\n+        // Unfortunately, floating point numbers can be much worse than that.\n+        // This also needs to not result in recursive evaluations of f64::to_bits.\n+        //\n+        // On some processors, in some cases, LLVM will \"helpfully\" lower floating point ops,\n+        // in spite of a request for them using f32 and f64, to things like x87 operations.\n+        // These have an f64's mantissa, but can have a larger than normal exponent.\n+        // FIXME(jubilee): Using x87 operations is never necessary in order to function\n+        // on x86 processors for Rust-to-Rust calls, so this issue should not happen.\n+        // Code generation should be adjusted to use non-C calling conventions, avoiding this.\n+        //\n+        // Thus, a value may compare unequal to infinity, despite having a \"full\" exponent mask.\n+        // And it may not be NaN, as it can simply be an \"overextended\" finite value.\n+        if self.is_nan() {\n+            FpCategory::Nan\n+        } else {\n+            // However, std can't simply compare to zero to check for zero, either,\n+            // as correctness requires avoiding equality tests that may be Subnormal == -0.0\n+            // because it may be wrong under \"denormals are zero\" and \"flush to zero\" modes.\n+            // Most of std's targets don't use those, but they are used for thumbv7neon.\n+            // So, this does use bitpattern matching for the rest.\n+\n+            // SAFETY: f64 to u64 is fine. Usually.\n+            // If control flow has gotten this far, the value is definitely in one of the categories\n+            // that f64::partial_classify can correctly analyze.\n+            unsafe { f64::partial_classify(self) }\n+        }\n+    }\n+\n+    // This doesn't actually return a right answer for NaN on purpose,\n+    // seeing as how it cannot correctly discern between a floating point NaN,\n+    // and some normal floating point numbers truncated from an x87 FPU.\n+    #[rustc_const_unstable(feature = \"const_float_classify\", issue = \"72505\")]\n+    const unsafe fn partial_classify(self) -> FpCategory {\n         const EXP_MASK: u64 = 0x7ff0000000000000;\n         const MAN_MASK: u64 = 0x000fffffffffffff;\n \n-        let bits = self.to_bits();\n-        match (bits & MAN_MASK, bits & EXP_MASK) {\n+        // SAFETY: The caller is not asking questions for which this will tell lies.\n+        let b = unsafe { mem::transmute::<f64, u64>(self) };\n+        match (b & MAN_MASK, b & EXP_MASK) {\n+            (0, EXP_MASK) => FpCategory::Infinite,\n             (0, 0) => FpCategory::Zero,\n             (_, 0) => FpCategory::Subnormal,\n+            _ => FpCategory::Normal,\n+        }\n+    }\n+\n+    // This operates on bits, and only bits, so it can ignore concerns about weird FPUs.\n+    // FIXME(jubilee): In a just world, this would be the entire impl for classify,\n+    // plus a transmute. We do not live in a just world, but we can make it more so.\n+    #[rustc_const_unstable(feature = \"const_float_classify\", issue = \"72505\")]\n+    const fn classify_bits(b: u64) -> FpCategory {\n+        const EXP_MASK: u64 = 0x7ff0000000000000;\n+        const MAN_MASK: u64 = 0x000fffffffffffff;\n+\n+        match (b & MAN_MASK, b & EXP_MASK) {\n             (0, EXP_MASK) => FpCategory::Infinite,\n             (_, EXP_MASK) => FpCategory::Nan,\n+            (0, 0) => FpCategory::Zero,\n+            (_, 0) => FpCategory::Subnormal,\n             _ => FpCategory::Normal,\n         }\n     }\n@@ -622,7 +680,10 @@ impl f64 {\n     #[rustc_const_unstable(feature = \"const_float_classify\", issue = \"72505\")]\n     #[inline]\n     pub const fn is_sign_negative(self) -> bool {\n-        self.to_bits() & 0x8000_0000_0000_0000 != 0\n+        // IEEE754 says: isSignMinus(x) is true if and only if x has negative sign. isSignMinus\n+        // applies to zeros and NaNs as well.\n+        // SAFETY: This is just transmuting to get the sign bit, it's fine.\n+        unsafe { mem::transmute::<f64, u64>(self) & 0x8000_0000_0000_0000 != 0 }\n     }\n \n     #[must_use]\n@@ -847,8 +908,31 @@ impl f64 {\n     #[rustc_const_unstable(feature = \"const_float_bits_conv\", issue = \"72447\")]\n     #[inline]\n     pub const fn to_bits(self) -> u64 {\n-        // SAFETY: `u64` is a plain old datatype so we can always transmute to it\n-        unsafe { mem::transmute(self) }\n+        // SAFETY: `u64` is a plain old datatype so we can always transmute to it.\n+        // ...sorta.\n+        //\n+        // See the SAFETY comment in f64::from_bits for more.\n+        #[rustc_const_unstable(feature = \"const_float_bits_conv\", issue = \"72447\")]\n+        const fn ct_f64_to_u64(ct: f64) -> u64 {\n+            match ct.classify() {\n+                FpCategory::Nan => {\n+                    panic!(\"const-eval error: cannot use f64::to_bits on a NaN\")\n+                }\n+                FpCategory::Subnormal => {\n+                    panic!(\"const-eval error: cannot use f64::to_bits on a subnormal number\")\n+                }\n+                FpCategory::Infinite | FpCategory::Normal | FpCategory::Zero => {\n+                    // SAFETY: We have a normal floating point number. Now we transmute, i.e. do a bitcopy.\n+                    unsafe { mem::transmute::<f64, u64>(ct) }\n+                }\n+            }\n+        }\n+        // SAFETY: `u64` is a plain old datatype so we can always... uh...\n+        // ...look, just pretend you forgot what you just read.\n+        // Stability concerns.\n+        let rt_f64_to_u64 = |rt| unsafe { mem::transmute::<f64, u64>(rt) };\n+        // SAFETY: We use internal implementations that either always work or fail at compile time.\n+        unsafe { intrinsics::const_eval_select((self,), ct_f64_to_u64, rt_f64_to_u64) }\n     }\n \n     /// Raw transmutation from `u64`.\n@@ -892,9 +976,56 @@ impl f64 {\n     #[must_use]\n     #[inline]\n     pub const fn from_bits(v: u64) -> Self {\n-        // SAFETY: `u64` is a plain old datatype so we can always transmute from it\n         // It turns out the safety issues with sNaN were overblown! Hooray!\n-        unsafe { mem::transmute(v) }\n+        // SAFETY: `u64` is a plain old datatype so we can always transmute from it\n+        // ...sorta.\n+        //\n+        // It turns out that at runtime, it is possible for a floating point number\n+        // to be subject to floating point modes that alter nonzero subnormal numbers\n+        // to zero on reads and writes, aka \"denormals are zero\" and \"flush to zero\".\n+        // This is not a problem usually, but at least one tier2 platform for Rust\n+        // actually exhibits an FTZ behavior by default: thumbv7neon\n+        // aka \"the Neon FPU in AArch32 state\"\n+        //\n+        // Even with this, not all instructions exhibit the FTZ behaviors on thumbv7neon,\n+        // so this should load the same bits if LLVM emits the \"correct\" instructions,\n+        // but LLVM sometimes makes interesting choices about float optimization,\n+        // and other FPUs may do similar. Thus, it is wise to indulge luxuriously in caution.\n+        //\n+        // In addition, on x86 targets with SSE or SSE2 disabled and the x87 FPU enabled,\n+        // i.e. not soft-float, the way Rust does parameter passing can actually alter\n+        // a number that is \"not infinity\" to have the same exponent as infinity,\n+        // in a slightly unpredictable manner.\n+        //\n+        // And, of course evaluating to a NaN value is fairly nondeterministic.\n+        // More precisely: when NaN should be returned is knowable, but which NaN?\n+        // So far that's defined by a combination of LLVM and the CPU, not Rust.\n+        // This function, however, allows observing the bitstring of a NaN,\n+        // thus introspection on CTFE.\n+        //\n+        // In order to preserve, at least for the moment, const-to-runtime equivalence,\n+        // reject any of these possible situations from happening.\n+        #[rustc_const_unstable(feature = \"const_float_bits_conv\", issue = \"72447\")]\n+        const fn ct_u64_to_f64(ct: u64) -> f64 {\n+            match f64::classify_bits(ct) {\n+                FpCategory::Subnormal => {\n+                    panic!(\"const-eval error: cannot use f64::from_bits on a subnormal number\")\n+                }\n+                FpCategory::Nan => {\n+                    panic!(\"const-eval error: cannot use f64::from_bits on NaN\")\n+                }\n+                FpCategory::Infinite | FpCategory::Normal | FpCategory::Zero => {\n+                    // SAFETY: It's not a frumious number\n+                    unsafe { mem::transmute::<u64, f64>(ct) }\n+                }\n+            }\n+        }\n+        // SAFETY: `u64` is a plain old datatype so we can always... uh...\n+        // ...look, just pretend you forgot what you just read.\n+        // Stability concerns.\n+        let rt_u64_to_f64 = |rt| unsafe { mem::transmute::<u64, f64>(rt) };\n+        // SAFETY: We use internal implementations that either always work or fail at compile time.\n+        unsafe { intrinsics::const_eval_select((v,), ct_u64_to_f64, rt_u64_to_f64) }\n     }\n \n     /// Return the memory representation of this floating point number as a byte array in"}, {"sha": "310db2174aafa34627b53fea6852346e56af4301", "filename": "src/test/ui/consts/const-float-bits-conv.rs", "status": "modified", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/1e9aa8a96b207668799365bf891a459b62410b60/src%2Ftest%2Fui%2Fconsts%2Fconst-float-bits-conv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e9aa8a96b207668799365bf891a459b62410b60/src%2Ftest%2Fui%2Fconsts%2Fconst-float-bits-conv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-float-bits-conv.rs?ref=1e9aa8a96b207668799365bf891a459b62410b60", "patch": "@@ -37,22 +37,6 @@ fn f32() {\n     const_assert!(f32::from_bits(0x44a72000), 1337.0);\n     const_assert!(f32::from_ne_bytes(0x44a72000u32.to_ne_bytes()), 1337.0);\n     const_assert!(f32::from_bits(0xc1640000), -14.25);\n-\n-    // Check that NaNs roundtrip their bits regardless of signalingness\n-    // 0xA is 0b1010; 0x5 is 0b0101 -- so these two together clobbers all the mantissa bits\n-    const MASKED_NAN1: u32 = f32::NAN.to_bits() ^ 0x002A_AAAA;\n-    const MASKED_NAN2: u32 = f32::NAN.to_bits() ^ 0x0055_5555;\n-\n-    const_assert!(f32::from_bits(MASKED_NAN1).is_nan());\n-    const_assert!(f32::from_bits(MASKED_NAN1).is_nan());\n-\n-    // LLVM does not guarantee that loads and stores of NaNs preserve their exact bit pattern.\n-    // In practice, this seems to only cause a problem on x86, since the most widely used calling\n-    // convention mandates that floating point values are returned on the x87 FPU stack. See #73328.\n-    if !cfg!(target_arch = \"x86\") {\n-        const_assert!(f32::from_bits(MASKED_NAN1).to_bits(), MASKED_NAN1);\n-        const_assert!(f32::from_bits(MASKED_NAN2).to_bits(), MASKED_NAN2);\n-    }\n }\n \n fn f64() {\n@@ -70,20 +54,6 @@ fn f64() {\n     const_assert!(f64::from_bits(0x4094e40000000000), 1337.0);\n     const_assert!(f64::from_ne_bytes(0x4094e40000000000u64.to_ne_bytes()), 1337.0);\n     const_assert!(f64::from_bits(0xc02c800000000000), -14.25);\n-\n-    // Check that NaNs roundtrip their bits regardless of signalingness\n-    // 0xA is 0b1010; 0x5 is 0b0101 -- so these two together clobbers all the mantissa bits\n-    const MASKED_NAN1: u64 = f64::NAN.to_bits() ^ 0x000A_AAAA_AAAA_AAAA;\n-    const MASKED_NAN2: u64 = f64::NAN.to_bits() ^ 0x0005_5555_5555_5555;\n-\n-    const_assert!(f64::from_bits(MASKED_NAN1).is_nan());\n-    const_assert!(f64::from_bits(MASKED_NAN1).is_nan());\n-\n-    // See comment above.\n-    if !cfg!(target_arch = \"x86\") {\n-        const_assert!(f64::from_bits(MASKED_NAN1).to_bits(), MASKED_NAN1);\n-        const_assert!(f64::from_bits(MASKED_NAN2).to_bits(), MASKED_NAN2);\n-    }\n }\n \n fn main() {"}, {"sha": "122f5b97eee06ed6df5797ac96be77bb27884d02", "filename": "src/test/ui/consts/const-float-bits-reject-conv.rs", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/1e9aa8a96b207668799365bf891a459b62410b60/src%2Ftest%2Fui%2Fconsts%2Fconst-float-bits-reject-conv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e9aa8a96b207668799365bf891a459b62410b60/src%2Ftest%2Fui%2Fconsts%2Fconst-float-bits-reject-conv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-float-bits-reject-conv.rs?ref=1e9aa8a96b207668799365bf891a459b62410b60", "patch": "@@ -0,0 +1,62 @@\n+// compile-flags: -Zmir-opt-level=0\n+#![feature(const_float_bits_conv)]\n+#![feature(const_float_classify)]\n+\n+// Don't promote\n+const fn nop<T>(x: T) -> T { x }\n+\n+macro_rules! const_assert {\n+    ($a:expr) => {\n+        {\n+            const _: () = assert!($a);\n+            assert!(nop($a));\n+        }\n+    };\n+    ($a:expr, $b:expr) => {\n+        {\n+            const _: () = assert!($a == $b);\n+            assert_eq!(nop($a), nop($b));\n+        }\n+    };\n+}\n+\n+fn f32() {\n+    // Check that NaNs roundtrip their bits regardless of signalingness\n+    // 0xA is 0b1010; 0x5 is 0b0101 -- so these two together clobbers all the mantissa bits\n+    // ...actually, let's just check that these break. :D\n+    const MASKED_NAN1: u32 = f32::NAN.to_bits() ^ 0x002A_AAAA;\n+    const MASKED_NAN2: u32 = f32::NAN.to_bits() ^ 0x0055_5555;\n+\n+    const_assert!(f32::from_bits(MASKED_NAN1).is_nan());\n+    const_assert!(f32::from_bits(MASKED_NAN1).is_nan());\n+\n+    // LLVM does not guarantee that loads and stores of NaNs preserve their exact bit pattern.\n+    // In practice, this seems to only cause a problem on x86, since the most widely used calling\n+    // convention mandates that floating point values are returned on the x87 FPU stack. See #73328.\n+    if !cfg!(target_arch = \"x86\") {\n+        const_assert!(f32::from_bits(MASKED_NAN1).to_bits(), MASKED_NAN1);\n+        const_assert!(f32::from_bits(MASKED_NAN2).to_bits(), MASKED_NAN2);\n+    }\n+}\n+\n+fn f64() {\n+    // Check that NaNs roundtrip their bits regardless of signalingness\n+    // 0xA is 0b1010; 0x5 is 0b0101 -- so these two together clobbers all the mantissa bits\n+    // ...actually, let's just check that these break. :D\n+    const MASKED_NAN1: u64 = f64::NAN.to_bits() ^ 0x000A_AAAA_AAAA_AAAA;\n+    const MASKED_NAN2: u64 = f64::NAN.to_bits() ^ 0x0005_5555_5555_5555;\n+\n+    const_assert!(f64::from_bits(MASKED_NAN1).is_nan());\n+    const_assert!(f64::from_bits(MASKED_NAN1).is_nan());\n+\n+    // See comment above.\n+    if !cfg!(target_arch = \"x86\") {\n+        const_assert!(f64::from_bits(MASKED_NAN1).to_bits(), MASKED_NAN1);\n+        const_assert!(f64::from_bits(MASKED_NAN2).to_bits(), MASKED_NAN2);\n+    }\n+}\n+\n+fn main() {\n+    f32();\n+    f64();\n+}"}, {"sha": "b39e881970176d54e9b9b2cc8ab18c12849a756d", "filename": "src/test/ui/consts/const-float-bits-reject-conv.stderr", "status": "added", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/1e9aa8a96b207668799365bf891a459b62410b60/src%2Ftest%2Fui%2Fconsts%2Fconst-float-bits-reject-conv.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1e9aa8a96b207668799365bf891a459b62410b60/src%2Ftest%2Fui%2Fconsts%2Fconst-float-bits-reject-conv.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-float-bits-reject-conv.stderr?ref=1e9aa8a96b207668799365bf891a459b62410b60", "patch": "@@ -0,0 +1,119 @@\n+error[E0080]: evaluation of constant value failed\n+  --> $SRC_DIR/core/src/num/f32.rs:LL:COL\n+   |\n+LL |                     panic!(\"const-eval error: cannot use f32::to_bits on a NaN\")\n+   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                     |\n+   |                     the evaluated program panicked at 'const-eval error: cannot use f32::to_bits on a NaN', $SRC_DIR/core/src/num/f32.rs:LL:COL\n+   |                     inside `core::f32::<impl f32>::to_bits::ct_f32_to_u32` at $SRC_DIR/core/src/panic.rs:LL:COL\n+...\n+LL |         unsafe { intrinsics::const_eval_select((self,), ct_f32_to_u32, rt_f32_to_u32) }\n+   |                  -------------------------------------------------------------------- inside `core::f32::<impl f32>::to_bits` at $SRC_DIR/core/src/num/f32.rs:LL:COL\n+   |\n+  ::: $SRC_DIR/core/src/ops/function.rs:LL:COL\n+   |\n+LL |     extern \"rust-call\" fn call_once(self, args: Args) -> Self::Output;\n+   |     ------------------------------------------------------------------ inside `<fn(f32) -> u32 {core::f32::<impl f32>::to_bits::ct_f32_to_u32} as FnOnce<(f32,)>>::call_once - shim(fn(f32) -> u32 {core::f32::<impl f32>::to_bits::ct_f32_to_u32})` at $SRC_DIR/core/src/ops/function.rs:LL:COL\n+   |\n+  ::: $SRC_DIR/core/src/intrinsics.rs:LL:COL\n+   |\n+LL |     called_in_const.call_once(arg)\n+   |     ------------------------------ inside `const_eval_select::<(f32,), fn(f32) -> u32 {core::f32::<impl f32>::to_bits::ct_f32_to_u32}, [closure@core::f32::<impl f32>::to_bits::{closure#0}], u32>` at $SRC_DIR/core/src/intrinsics.rs:LL:COL\n+   |\n+  ::: $DIR/const-float-bits-reject-conv.rs:27:30\n+   |\n+LL |     const MASKED_NAN1: u32 = f32::NAN.to_bits() ^ 0x002A_AAAA;\n+   |                              ------------------ inside `f32::MASKED_NAN1` at $DIR/const-float-bits-reject-conv.rs:27:30\n+   |\n+   = note: this error originates in the macro `$crate::panic::panic_2021` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0080]: evaluation of constant value failed\n+  --> $SRC_DIR/core/src/num/f32.rs:LL:COL\n+   |\n+LL |                     panic!(\"const-eval error: cannot use f32::to_bits on a NaN\")\n+   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                     |\n+   |                     the evaluated program panicked at 'const-eval error: cannot use f32::to_bits on a NaN', $SRC_DIR/core/src/num/f32.rs:LL:COL\n+   |                     inside `core::f32::<impl f32>::to_bits::ct_f32_to_u32` at $SRC_DIR/core/src/panic.rs:LL:COL\n+...\n+LL |         unsafe { intrinsics::const_eval_select((self,), ct_f32_to_u32, rt_f32_to_u32) }\n+   |                  -------------------------------------------------------------------- inside `core::f32::<impl f32>::to_bits` at $SRC_DIR/core/src/num/f32.rs:LL:COL\n+   |\n+  ::: $SRC_DIR/core/src/ops/function.rs:LL:COL\n+   |\n+LL |     extern \"rust-call\" fn call_once(self, args: Args) -> Self::Output;\n+   |     ------------------------------------------------------------------ inside `<fn(f32) -> u32 {core::f32::<impl f32>::to_bits::ct_f32_to_u32} as FnOnce<(f32,)>>::call_once - shim(fn(f32) -> u32 {core::f32::<impl f32>::to_bits::ct_f32_to_u32})` at $SRC_DIR/core/src/ops/function.rs:LL:COL\n+   |\n+  ::: $SRC_DIR/core/src/intrinsics.rs:LL:COL\n+   |\n+LL |     called_in_const.call_once(arg)\n+   |     ------------------------------ inside `const_eval_select::<(f32,), fn(f32) -> u32 {core::f32::<impl f32>::to_bits::ct_f32_to_u32}, [closure@core::f32::<impl f32>::to_bits::{closure#0}], u32>` at $SRC_DIR/core/src/intrinsics.rs:LL:COL\n+   |\n+  ::: $DIR/const-float-bits-reject-conv.rs:28:30\n+   |\n+LL |     const MASKED_NAN2: u32 = f32::NAN.to_bits() ^ 0x0055_5555;\n+   |                              ------------------ inside `f32::MASKED_NAN2` at $DIR/const-float-bits-reject-conv.rs:28:30\n+   |\n+   = note: this error originates in the macro `$crate::panic::panic_2021` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0080]: evaluation of constant value failed\n+  --> $SRC_DIR/core/src/num/f64.rs:LL:COL\n+   |\n+LL |                     panic!(\"const-eval error: cannot use f64::to_bits on a NaN\")\n+   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                     |\n+   |                     the evaluated program panicked at 'const-eval error: cannot use f64::to_bits on a NaN', $SRC_DIR/core/src/num/f64.rs:LL:COL\n+   |                     inside `core::f64::<impl f64>::to_bits::ct_f64_to_u64` at $SRC_DIR/core/src/panic.rs:LL:COL\n+...\n+LL |         unsafe { intrinsics::const_eval_select((self,), ct_f64_to_u64, rt_f64_to_u64) }\n+   |                  -------------------------------------------------------------------- inside `core::f64::<impl f64>::to_bits` at $SRC_DIR/core/src/num/f64.rs:LL:COL\n+   |\n+  ::: $SRC_DIR/core/src/ops/function.rs:LL:COL\n+   |\n+LL |     extern \"rust-call\" fn call_once(self, args: Args) -> Self::Output;\n+   |     ------------------------------------------------------------------ inside `<fn(f64) -> u64 {core::f64::<impl f64>::to_bits::ct_f64_to_u64} as FnOnce<(f64,)>>::call_once - shim(fn(f64) -> u64 {core::f64::<impl f64>::to_bits::ct_f64_to_u64})` at $SRC_DIR/core/src/ops/function.rs:LL:COL\n+   |\n+  ::: $SRC_DIR/core/src/intrinsics.rs:LL:COL\n+   |\n+LL |     called_in_const.call_once(arg)\n+   |     ------------------------------ inside `const_eval_select::<(f64,), fn(f64) -> u64 {core::f64::<impl f64>::to_bits::ct_f64_to_u64}, [closure@core::f64::<impl f64>::to_bits::{closure#0}], u64>` at $SRC_DIR/core/src/intrinsics.rs:LL:COL\n+   |\n+  ::: $DIR/const-float-bits-reject-conv.rs:46:30\n+   |\n+LL |     const MASKED_NAN1: u64 = f64::NAN.to_bits() ^ 0x000A_AAAA_AAAA_AAAA;\n+   |                              ------------------ inside `f64::MASKED_NAN1` at $DIR/const-float-bits-reject-conv.rs:46:30\n+   |\n+   = note: this error originates in the macro `$crate::panic::panic_2021` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0080]: evaluation of constant value failed\n+  --> $SRC_DIR/core/src/num/f64.rs:LL:COL\n+   |\n+LL |                     panic!(\"const-eval error: cannot use f64::to_bits on a NaN\")\n+   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                     |\n+   |                     the evaluated program panicked at 'const-eval error: cannot use f64::to_bits on a NaN', $SRC_DIR/core/src/num/f64.rs:LL:COL\n+   |                     inside `core::f64::<impl f64>::to_bits::ct_f64_to_u64` at $SRC_DIR/core/src/panic.rs:LL:COL\n+...\n+LL |         unsafe { intrinsics::const_eval_select((self,), ct_f64_to_u64, rt_f64_to_u64) }\n+   |                  -------------------------------------------------------------------- inside `core::f64::<impl f64>::to_bits` at $SRC_DIR/core/src/num/f64.rs:LL:COL\n+   |\n+  ::: $SRC_DIR/core/src/ops/function.rs:LL:COL\n+   |\n+LL |     extern \"rust-call\" fn call_once(self, args: Args) -> Self::Output;\n+   |     ------------------------------------------------------------------ inside `<fn(f64) -> u64 {core::f64::<impl f64>::to_bits::ct_f64_to_u64} as FnOnce<(f64,)>>::call_once - shim(fn(f64) -> u64 {core::f64::<impl f64>::to_bits::ct_f64_to_u64})` at $SRC_DIR/core/src/ops/function.rs:LL:COL\n+   |\n+  ::: $SRC_DIR/core/src/intrinsics.rs:LL:COL\n+   |\n+LL |     called_in_const.call_once(arg)\n+   |     ------------------------------ inside `const_eval_select::<(f64,), fn(f64) -> u64 {core::f64::<impl f64>::to_bits::ct_f64_to_u64}, [closure@core::f64::<impl f64>::to_bits::{closure#0}], u64>` at $SRC_DIR/core/src/intrinsics.rs:LL:COL\n+   |\n+  ::: $DIR/const-float-bits-reject-conv.rs:47:30\n+   |\n+LL |     const MASKED_NAN2: u64 = f64::NAN.to_bits() ^ 0x0005_5555_5555_5555;\n+   |                              ------------------ inside `f64::MASKED_NAN2` at $DIR/const-float-bits-reject-conv.rs:47:30\n+   |\n+   = note: this error originates in the macro `$crate::panic::panic_2021` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: aborting due to 4 previous errors\n+\n+For more information about this error, try `rustc --explain E0080`."}]}