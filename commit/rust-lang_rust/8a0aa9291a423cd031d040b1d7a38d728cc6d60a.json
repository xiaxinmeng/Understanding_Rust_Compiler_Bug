{"sha": "8a0aa9291a423cd031d040b1d7a38d728cc6d60a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhhMGFhOTI5MWE0MjNjZDAzMWQwNDBiMWQ3YTM4ZDcyOGNjNmQ2MGE=", "commit": {"author": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-04-06T09:45:06Z"}, "committer": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-04-06T09:45:06Z"}, "message": "Switch to bitmask-based undef mask.", "tree": {"sha": "758bf970f39c99d8a2961830ba5da2ff3c212c9c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/758bf970f39c99d8a2961830ba5da2ff3c212c9c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8a0aa9291a423cd031d040b1d7a38d728cc6d60a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8a0aa9291a423cd031d040b1d7a38d728cc6d60a", "html_url": "https://github.com/rust-lang/rust/commit/8a0aa9291a423cd031d040b1d7a38d728cc6d60a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8a0aa9291a423cd031d040b1d7a38d728cc6d60a/comments", "author": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bdba4641ccc113a865759cc52c643a65adfd371d", "url": "https://api.github.com/repos/rust-lang/rust/commits/bdba4641ccc113a865759cc52c643a65adfd371d", "html_url": "https://github.com/rust-lang/rust/commit/bdba4641ccc113a865759cc52c643a65adfd371d"}], "stats": {"total": 368, "additions": 117, "deletions": 251}, "files": [{"sha": "b050e042f711db24219617c91e217a1cde4a634f", "filename": "src/interpreter.rs", "status": "modified", "additions": 13, "deletions": 22, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/8a0aa9291a423cd031d040b1d7a38d728cc6d60a/src%2Finterpreter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a0aa9291a423cd031d040b1d7a38d728cc6d60a/src%2Finterpreter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter.rs?ref=8a0aa9291a423cd031d040b1d7a38d728cc6d60a", "patch": "@@ -19,7 +19,7 @@ use syntax::attr;\n use syntax::codemap::{self, DUMMY_SP};\n \n use error::{EvalError, EvalResult};\n-use memory::{self, FieldRepr, Memory, Pointer, Repr};\n+use memory::{FieldRepr, Memory, Pointer, Repr};\n use primval::{self, PrimVal};\n \n const TRACE_EXECUTION: bool = false;\n@@ -150,31 +150,32 @@ impl<'a, 'tcx: 'a, 'arena> Interpreter<'a, 'tcx, 'arena> {\n         r\n     }\n \n-    fn run(&mut self) -> EvalResult<()> {\n-        use std::fmt::Debug;\n-        fn print_trace<T: Debug>(t: &T, suffix: &'static str, indent: usize) {\n-            if !TRACE_EXECUTION { return; }\n-            for _ in 0..indent { print!(\"  \"); }\n-            println!(\"{:?}{}\", t, suffix);\n-        }\n+    fn log<F>(&self, extra_indent: usize, f: F) where F: FnOnce() {\n+        let indent = self.stack.len() - 1 + extra_indent;\n+        if !TRACE_EXECUTION { return; }\n+        for _ in 0..indent { print!(\"  \"); }\n+        f();\n+        println!(\"\");\n+    }\n \n+    fn run(&mut self) -> EvalResult<()> {\n         'outer: while !self.stack.is_empty() {\n             let mut current_block = self.frame().next_block;\n \n             loop {\n-                print_trace(&current_block, \":\", self.stack.len());\n+                self.log(0, || print!(\"{:?}\", current_block));\n                 let current_mir = self.mir().clone(); // Cloning a reference.\n                 let block_data = current_mir.basic_block_data(current_block);\n \n                 for stmt in &block_data.statements {\n-                    print_trace(stmt, \"\", self.stack.len() + 1);\n+                    self.log(1, || print!(\"{:?}\", stmt));\n                     let mir::StatementKind::Assign(ref lvalue, ref rvalue) = stmt.kind;\n                     let result = self.eval_assignment(lvalue, rvalue);\n                     try!(self.maybe_report(stmt.span, result));\n                 }\n \n                 let terminator = block_data.terminator();\n-                print_trace(&terminator.kind, \"\", self.stack.len() + 1);\n+                self.log(1, || print!(\"{:?}\", terminator.kind));\n \n                 let result = self.eval_terminator(terminator);\n                 match try!(self.maybe_report(terminator.span, result)) {\n@@ -1154,15 +1155,6 @@ pub fn get_impl_method<'tcx>(\n }\n \n pub fn interpret_start_points<'tcx>(tcx: &TyCtxt<'tcx>, mir_map: &MirMap<'tcx>) {\n-    /// Print the given allocation and all allocations it depends on.\n-    fn print_allocation_tree(memory: &Memory, alloc_id: memory::AllocId) {\n-        let alloc = memory.get(alloc_id).unwrap();\n-        println!(\"  {:?}: {:?}\", alloc_id, alloc);\n-        for &target_alloc in alloc.relocations.values() {\n-            print_allocation_tree(memory, target_alloc);\n-        }\n-    }\n-\n     for (&id, mir) in &mir_map.map {\n         for attr in tcx.map.attrs(id) {\n             use syntax::attr::AttrMetaMethods;\n@@ -1188,8 +1180,7 @@ pub fn interpret_start_points<'tcx>(tcx: &TyCtxt<'tcx>, mir_map: &MirMap<'tcx>)\n                 tcx.sess.abort_if_errors();\n \n                 if let Some(ret) = return_ptr {\n-                    println!(\"Result:\");\n-                    print_allocation_tree(&miri.memory, ret.alloc_id);\n+                    miri.memory.dump(ret.alloc_id);\n                     println!(\"\");\n                 }\n             }"}, {"sha": "113930f986d2c25b427d86d1f86206e71459858d", "filename": "src/memory.rs", "status": "modified", "additions": 101, "deletions": 226, "changes": 327, "blob_url": "https://github.com/rust-lang/rust/blob/8a0aa9291a423cd031d040b1d7a38d728cc6d60a/src%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a0aa9291a423cd031d040b1d7a38d728cc6d60a/src%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmemory.rs?ref=8a0aa9291a423cd031d040b1d7a38d728cc6d60a", "patch": "@@ -1,8 +1,7 @@\n use byteorder::{ByteOrder, NativeEndian, ReadBytesExt, WriteBytesExt};\n-use std::collections::{btree_map, BTreeMap, HashMap};\n use std::collections::Bound::{Included, Excluded};\n-use std::mem;\n-use std::ptr;\n+use std::collections::{btree_map, BTreeMap, HashMap, HashSet, VecDeque};\n+use std::{iter, mem, ptr};\n \n use error::{EvalError, EvalResult};\n use primval::PrimVal;\n@@ -66,7 +65,7 @@ pub struct AllocId(u64);\n pub struct Allocation {\n     pub bytes: Box<[u8]>,\n     pub relocations: BTreeMap<usize, AllocId>,\n-    pub undef_mask: Option<Vec<usize>>,\n+    pub undef_mask: UndefMask,\n }\n \n #[derive(Copy, Clone, Debug, Eq, PartialEq)]\n@@ -107,7 +106,7 @@ impl Memory {\n         let alloc = Allocation {\n             bytes: vec![0; size].into_boxed_slice(),\n             relocations: BTreeMap::new(),\n-            undef_mask: None,\n+            undef_mask: UndefMask::new(),\n         };\n         self.alloc_map.insert(self.next_id, alloc);\n         self.next_id += 1;\n@@ -129,6 +128,48 @@ impl Memory {\n         self.alloc_map.get_mut(&id.0).ok_or(EvalError::DanglingPointerDeref)\n     }\n \n+    /// Print an allocation and all allocations it points to, recursively.\n+    pub fn dump(&self, id: AllocId) {\n+        let mut allocs_seen = HashSet::new();\n+        let mut allocs_to_print = VecDeque::new();\n+        allocs_to_print.push_back(id);\n+\n+        while let Some(id) = allocs_to_print.pop_front() {\n+            allocs_seen.insert(id.0);\n+            let alloc = self.get(id).unwrap();\n+            let prefix = format!(\"Alloc {:<5} \", format!(\"{}:\", id.0));\n+            print!(\"{}\", prefix);\n+            let mut relocations = vec![];\n+\n+            for i in 0..alloc.bytes.len() {\n+                if let Some(&target_id) = alloc.relocations.get(&i) {\n+                    if !allocs_seen.contains(&target_id.0) {\n+                        allocs_to_print.push_back(target_id);\n+                    }\n+                    relocations.push((i, target_id.0));\n+                }\n+                if alloc.undef_mask.is_range_defined(i, i+1) {\n+                    print!(\"{:02x} \", alloc.bytes[i]);\n+                } else {\n+                    print!(\"__ \");\n+                }\n+            }\n+            println!(\"\");\n+\n+            if !relocations.is_empty() {\n+                print!(\"{:1$}\", \"\", prefix.len()); // Print spaces.\n+                let mut pos = 0;\n+                let relocation_width = (self.pointer_size - 1) * 3;\n+                for (i, target_id) in relocations {\n+                    print!(\"{:1$}\", \"\", (i - pos) * 3);\n+                    print!(\"\u2514{0:\u2500^1$}\u2518 \", format!(\"({})\", target_id), relocation_width);\n+                    pos = i + self.pointer_size;\n+                }\n+                println!(\"\");\n+            }\n+        }\n+    }\n+\n     ////////////////////////////////////////////////////////////////////////////////\n     // Byte accessors\n     ////////////////////////////////////////////////////////////////////////////////\n@@ -305,8 +346,8 @@ impl Memory {\n \n         // Mark parts of the outermost relocations as undefined if they partially fall outside the\n         // given range.\n-        if first < start { alloc.mark_definedness(first, start, false); }\n-        if last > end { alloc.mark_definedness(end, last, false); }\n+        if first < start { alloc.undef_mask.set_range(first, start, false); }\n+        if last > end { alloc.undef_mask.set_range(end, last, false); }\n \n         // Forget all the relocations.\n         for k in keys { alloc.relocations.remove(&k); }\n@@ -340,7 +381,7 @@ impl Memory {\n \n     fn check_defined(&self, ptr: Pointer, size: usize) -> EvalResult<()> {\n         let alloc = try!(self.get(ptr.alloc_id));\n-        if !alloc.is_range_defined(ptr.offset, ptr.offset + size) {\n+        if !alloc.undef_mask.is_range_defined(ptr.offset, ptr.offset + size) {\n             return Err(EvalError::ReadUndefBytes);\n         }\n         Ok(())\n@@ -350,7 +391,7 @@ impl Memory {\n         -> EvalResult<()>\n     {\n         let mut alloc = try!(self.get_mut(ptr.alloc_id));\n-        alloc.mark_definedness(ptr.offset, ptr.offset + size, new_state);\n+        alloc.undef_mask.set_range(ptr.offset, ptr.offset + size, new_state);\n         Ok(())\n     }\n }\n@@ -359,238 +400,72 @@ impl Memory {\n // Undefined byte tracking\n ////////////////////////////////////////////////////////////////////////////////\n \n-impl Allocation {\n-    /// Check whether the range `start..end` (end-exclusive) in this allocation is entirely\n-    /// defined.\n-    fn is_range_defined(&self, start: usize, end: usize) -> bool {\n-        debug_assert!(start <= end);\n-        debug_assert!(end <= self.bytes.len());\n-\n-        // An empty range is always fully defined.\n-        if start == end {\n-            return true;\n-        }\n+type Block = u64;\n+const BLOCK_SIZE: usize = 64;\n \n-        match self.undef_mask {\n-            Some(ref undef_mask) => {\n-                // If `start` lands directly on a boundary, it belongs to the range after the\n-                // boundary, hence the increment in the `Ok` arm.\n-                let i = match undef_mask.binary_search(&start) { Ok(j) => j + 1, Err(j) => j };\n+#[derive(Clone, Debug)]\n+pub struct UndefMask {\n+    blocks: Vec<Block>,\n+    len: usize,\n+}\n \n-                // The range is fully defined if and only if both:\n-                //   1. The start value falls into a defined range (with even parity).\n-                //   2. The end value is in the same range as the start value.\n-                i % 2 == 0 && undef_mask.get(i).map(|&x| end <= x).unwrap_or(true)\n-            }\n-            None => false,\n+impl UndefMask {\n+    fn new() -> Self {\n+        UndefMask {\n+            blocks: vec![],\n+            len: 0,\n         }\n     }\n \n-    /// Mark the range `start..end` (end-exclusive) as defined or undefined, depending on\n-    /// `new_state`.\n-    fn mark_definedness(&mut self, start: usize, end: usize, new_state: bool) {\n-        debug_assert!(start <= end);\n-        debug_assert!(end <= self.bytes.len());\n-\n-        // There is no need to track undef masks for zero-sized allocations.\n-        let len = self.bytes.len();\n-        if len == 0 {\n-            return;\n-        }\n-\n-        // Returns whether the new state matches the state of a given undef mask index. The way\n-        // undef masks are represented, boundaries at even indices are undefined and those at odd\n-        // indices are defined.\n-        let index_matches_new_state = |i| i % 2 == new_state as usize;\n-\n-        // Lookup the undef mask index where the given endpoint `i` is or should be inserted.\n-        let lookup_endpoint = |undef_mask: &[usize], i: usize| -> (usize, bool) {\n-            let (index, should_insert);\n-            match undef_mask.binary_search(&i) {\n-                // Region endpoint is on an undef mask boundary.\n-                Ok(j) => {\n-                    // This endpoint's index must be incremented if the boundary's state matches\n-                    // the region's new state so that the boundary is:\n-                    //   1. Excluded from deletion when handling the inclusive left-hand endpoint.\n-                    //   2. Included for deletion when handling the exclusive right-hand endpoint.\n-                    index = j + index_matches_new_state(j) as usize;\n-\n-                    // Don't insert a new mask boundary; simply reuse or delete the matched one.\n-                    should_insert = false;\n-                }\n-\n-                // Region endpoint is not on a mask boundary.\n-                Err(j) => {\n-                    // This is the index after the nearest mask boundary which has the same state.\n-                    index = j;\n-\n-                    // Insert a new boundary if this endpoint's state doesn't match the state of\n-                    // this position.\n-                    should_insert = index_matches_new_state(j);\n-                }\n-            }\n-            (index, should_insert)\n-        };\n-\n-        match self.undef_mask {\n-            // There is an existing undef mask, with arbitrary existing boundaries.\n-            Some(ref mut undef_mask) => {\n-                // Determine where the new range's endpoints fall within the current undef mask.\n-                let (start_index, insert_start) = lookup_endpoint(undef_mask, start);\n-                let (end_index, insert_end) = lookup_endpoint(undef_mask, end);\n-\n-                // Delete all the undef mask boundaries overwritten by the new range.\n-                undef_mask.drain(start_index..end_index);\n-\n-                // Insert any new boundaries deemed necessary with two exceptions:\n-                //   1. Never insert an endpoint equal to the allocation length; it's implicit.\n-                //   2. Never insert a start boundary equal to the end boundary.\n-                if insert_end && end != len {\n-                    undef_mask.insert(start_index, end);\n-                }\n-                if insert_start && start != end {\n-                    undef_mask.insert(start_index, start);\n-                }\n-            }\n-\n-            // There is no existing undef mask. This is taken as meaning the entire allocation is\n-            // currently undefined. If the new state is false, meaning undefined, do nothing.\n-            None => if new_state {\n-                let mut mask = if start == 0 {\n-                    // 0..end is defined.\n-                    Vec::new()\n-                } else {\n-                    // 0..0 is defined, 0..start is undefined, start..end is defined.\n-                    vec![0, start]\n-                };\n-\n-                // Don't insert the end boundary if it's equal to the allocation length; that\n-                // boundary is implicit.\n-                if end != len {\n-                    mask.push(end);\n-                }\n-                self.undef_mask = Some(mask);\n-            },\n+    /// Check whether the range `start..end` (end-exclusive) is entirely defined.\n+    fn is_range_defined(&self, start: usize, end: usize) -> bool {\n+        if end > self.len { return false; }\n+        for i in start..end {\n+            if !self.get(i) { return false; }\n         }\n+        true\n     }\n-}\n \n-#[cfg(test)]\n-mod test {\n-    use memory::Allocation;\n-    use std::collections::BTreeMap;\n-\n-    fn alloc_with_mask(len: usize, undef_mask: Option<Vec<usize>>) -> Allocation {\n-        Allocation {\n-            bytes: vec![0; len].into_boxed_slice(),\n-            relocations: BTreeMap::new(),\n-            undef_mask: undef_mask,\n-        }\n+    fn set_range(&mut self, start: usize, end: usize, new_state: bool) {\n+        let len = self.len;\n+        if end > len { self.grow(end - len, new_state); }\n+        self.set_range_inbounds(start, end, new_state);\n     }\n \n-    #[test]\n-    fn large_undef_mask() {\n-        let mut alloc = alloc_with_mask(20, Some(vec![4, 8, 12, 16]));\n-\n-        assert!(alloc.is_range_defined(0, 0));\n-        assert!(alloc.is_range_defined(0, 3));\n-        assert!(alloc.is_range_defined(0, 4));\n-        assert!(alloc.is_range_defined(1, 3));\n-        assert!(alloc.is_range_defined(1, 4));\n-        assert!(alloc.is_range_defined(4, 4));\n-        assert!(!alloc.is_range_defined(0, 5));\n-        assert!(!alloc.is_range_defined(1, 5));\n-        assert!(!alloc.is_range_defined(4, 5));\n-        assert!(!alloc.is_range_defined(4, 8));\n-        assert!(alloc.is_range_defined(8, 12));\n-        assert!(!alloc.is_range_defined(12, 16));\n-        assert!(alloc.is_range_defined(16, 20));\n-        assert!(!alloc.is_range_defined(15, 20));\n-        assert!(!alloc.is_range_defined(0, 20));\n-\n-        alloc.mark_definedness(8, 11, false);\n-        assert_eq!(alloc.undef_mask, Some(vec![4, 11, 12, 16]));\n-\n-        alloc.mark_definedness(8, 11, true);\n-        assert_eq!(alloc.undef_mask, Some(vec![4, 8, 12, 16]));\n-\n-        alloc.mark_definedness(8, 12, false);\n-        assert_eq!(alloc.undef_mask, Some(vec![4, 16]));\n-\n-        alloc.mark_definedness(8, 12, true);\n-        assert_eq!(alloc.undef_mask, Some(vec![4, 8, 12, 16]));\n-\n-        alloc.mark_definedness(9, 11, true);\n-        assert_eq!(alloc.undef_mask, Some(vec![4, 8, 12, 16]));\n-\n-        alloc.mark_definedness(9, 11, false);\n-        assert_eq!(alloc.undef_mask, Some(vec![4, 8, 9, 11, 12, 16]));\n-\n-        alloc.mark_definedness(9, 10, true);\n-        assert_eq!(alloc.undef_mask, Some(vec![4, 8, 10, 11, 12, 16]));\n-\n-        alloc.mark_definedness(8, 12, true);\n-        assert_eq!(alloc.undef_mask, Some(vec![4, 8, 12, 16]));\n+    fn set_range_inbounds(&mut self, start: usize, end: usize, new_state: bool) {\n+        for i in start..end { self.set(i, new_state); }\n     }\n \n-    #[test]\n-    fn empty_undef_mask() {\n-        let mut alloc = alloc_with_mask(0, None);\n-        assert!(alloc.is_range_defined(0, 0));\n-\n-        alloc.mark_definedness(0, 0, false);\n-        assert_eq!(alloc.undef_mask, None);\n-        assert!(alloc.is_range_defined(0, 0));\n-\n-        alloc.mark_definedness(0, 0, true);\n-        assert_eq!(alloc.undef_mask, None);\n-        assert!(alloc.is_range_defined(0, 0));\n+    fn get(&self, i: usize) -> bool {\n+        let (block, bit) = bit_index(i);\n+        (self.blocks[block] & 1 << bit) != 0\n     }\n \n-    #[test]\n-    fn small_undef_mask() {\n-        let mut alloc = alloc_with_mask(8, None);\n-\n-        alloc.mark_definedness(0, 4, false);\n-        assert_eq!(alloc.undef_mask, None);\n-\n-        alloc.mark_definedness(0, 4, true);\n-        assert_eq!(alloc.undef_mask, Some(vec![4]));\n-\n-        alloc.mark_definedness(4, 8, false);\n-        assert_eq!(alloc.undef_mask, Some(vec![4]));\n-\n-        alloc.mark_definedness(4, 8, true);\n-        assert_eq!(alloc.undef_mask, Some(vec![]));\n-\n-        alloc.mark_definedness(0, 8, true);\n-        assert_eq!(alloc.undef_mask, Some(vec![]));\n-\n-        alloc.mark_definedness(0, 8, false);\n-        assert_eq!(alloc.undef_mask, Some(vec![0]));\n-\n-        alloc.mark_definedness(0, 8, true);\n-        assert_eq!(alloc.undef_mask, Some(vec![]));\n-\n-        alloc.mark_definedness(4, 8, false);\n-        assert_eq!(alloc.undef_mask, Some(vec![4]));\n-\n-        alloc.mark_definedness(0, 8, false);\n-        assert_eq!(alloc.undef_mask, Some(vec![0]));\n-\n-        alloc.mark_definedness(2, 5, true);\n-        assert_eq!(alloc.undef_mask, Some(vec![0, 2, 5]));\n-\n-        alloc.mark_definedness(4, 6, false);\n-        assert_eq!(alloc.undef_mask, Some(vec![0, 2, 4]));\n+    fn set(&mut self, i: usize, new_state: bool) {\n+        let (block, bit) = bit_index(i);\n+        if new_state {\n+            self.blocks[block] |= 1 << bit;\n+        } else {\n+            self.blocks[block] &= !(1 << bit);\n+        }\n+    }\n \n-        alloc.mark_definedness(0, 3, true);\n-        assert_eq!(alloc.undef_mask, Some(vec![4]));\n+    fn grow(&mut self, amount: usize, new_state: bool) {\n+        let unused_trailing_bits = self.blocks.len() * BLOCK_SIZE - self.len;\n+        if amount > unused_trailing_bits {\n+            let additional_blocks = amount / BLOCK_SIZE + 1;\n+            self.blocks.extend(iter::repeat(0).take(additional_blocks));\n+        }\n+        let start = self.len;\n+        self.len += amount;\n+        self.set_range_inbounds(start, start + amount, new_state);\n+    }\n+}\n \n-        alloc.mark_definedness(2, 6, true);\n-        assert_eq!(alloc.undef_mask, Some(vec![6]));\n+// fn uniform_block(state: bool) -> Block {\n+//     if state { !0 } else { 0 }\n+// }\n \n-        alloc.mark_definedness(3, 7, false);\n-        assert_eq!(alloc.undef_mask, Some(vec![3]));\n-    }\n+fn bit_index(bits: usize) -> (usize, usize) {\n+    (bits / BLOCK_SIZE, bits % BLOCK_SIZE)\n }"}, {"sha": "ba72bfb52a70403c92274b41934271cefabde213", "filename": "test/products.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8a0aa9291a423cd031d040b1d7a38d728cc6d60a/test%2Fproducts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a0aa9291a423cd031d040b1d7a38d728cc6d60a/test%2Fproducts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/test%2Fproducts.rs?ref=8a0aa9291a423cd031d040b1d7a38d728cc6d60a", "patch": "@@ -2,17 +2,17 @@\n #![allow(dead_code, unused_attributes)]\n \n #[miri_run]\n-fn tuple() -> (i64,) {\n+fn tuple() -> (i16,) {\n     (1,)\n }\n \n #[miri_run]\n-fn tuple_2() -> (i64, i64) {\n+fn tuple_2() -> (i16, i16) {\n     (1, 2)\n }\n \n #[miri_run]\n-fn tuple_5() -> (i64, i64, i64, i64, i64) {\n+fn tuple_5() -> (i16, i16, i16, i16, i16) {\n     (1, 2, 3, 4, 5)\n }\n "}]}