{"sha": "79ee267ef4c6ecca3dd52a294cc8555a99751c11", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc5ZWUyNjdlZjRjNmVjY2EzZGQ1MmEyOTRjYzg1NTVhOTk3NTFjMTE=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-07-13T01:41:27Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-07-13T01:41:27Z"}, "message": "rustc: Remove the last few exterior vectors from typeck", "tree": {"sha": "d0342c1c5217782177275f209598a59cecfe1b7a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d0342c1c5217782177275f209598a59cecfe1b7a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/79ee267ef4c6ecca3dd52a294cc8555a99751c11", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/79ee267ef4c6ecca3dd52a294cc8555a99751c11", "html_url": "https://github.com/rust-lang/rust/commit/79ee267ef4c6ecca3dd52a294cc8555a99751c11", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/79ee267ef4c6ecca3dd52a294cc8555a99751c11/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f7ba28573f24e69a12c3276e1963d8aa143b3460", "url": "https://api.github.com/repos/rust-lang/rust/commits/f7ba28573f24e69a12c3276e1963d8aa143b3460", "html_url": "https://github.com/rust-lang/rust/commit/f7ba28573f24e69a12c3276e1963d8aa143b3460"}], "stats": {"total": 67, "additions": 25, "deletions": 42}, "files": [{"sha": "7e0b2f3db5526a87a71adcc26d7426b834622bac", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 25, "deletions": 42, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/79ee267ef4c6ecca3dd52a294cc8555a99751c11/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79ee267ef4c6ecca3dd52a294cc8555a99751c11/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=79ee267ef4c6ecca3dd52a294cc8555a99751c11", "patch": "@@ -37,7 +37,6 @@ import std::int;\n import std::ivec;\n import std::str;\n import std::uint;\n-import std::vec;\n import std::map;\n import std::map::hashmap;\n import std::option;\n@@ -53,9 +52,7 @@ type ty_table = hashmap[ast::def_id, ty::t];\n \n type obj_info = rec(ast::obj_field[] obj_fields, ast::node_id this_obj);\n \n-type crate_ctxt =\n-    rec(mutable vec[obj_info] obj_infos,\n-        ty::ctxt tcx);\n+type crate_ctxt = rec(mutable obj_info[] obj_infos, ty::ctxt tcx);\n \n type fn_ctxt =\n     rec(ty::t ret_ty,\n@@ -64,7 +61,7 @@ type fn_ctxt =\n         hashmap[ast::node_id, int] locals,\n         hashmap[ast::node_id, ast::ident] local_names,\n         mutable int next_var_id,\n-        mutable vec[ast::node_id] fixups,\n+        mutable ast::node_id[] fixups,\n         @crate_ctxt ccx);\n \n \n@@ -433,7 +430,7 @@ mod write {\n                 &ty_param_substs_opt_and_ty tpot) {\n         inner(fcx.ccx.tcx.node_types, node_id, tpot);\n         if (ty::type_contains_vars(fcx.ccx.tcx, tpot._1)) {\n-            fcx.fixups += [node_id];\n+            fcx.fixups += ~[node_id];\n         }\n     }\n \n@@ -870,11 +867,7 @@ fn do_autoderef(&@fn_ctxt fcx, &span sp, &ty::t t) -> ty::t {\n         alt (structure_of(fcx, sp, t1)) {\n             case (ty::ty_box(?inner)) { t1 = inner.ty; }\n             case (ty::ty_res(_, ?inner, ?tps)) {\n-                // FIXME: Remove this vec->ivec conversion.\n-                auto tps_ivec = ~[];\n-                for (ty::t tp in tps) { tps_ivec += ~[tp]; }\n-\n-                t1 = ty::substitute_type_params(fcx.ccx.tcx, tps_ivec, inner);\n+                t1 = ty::substitute_type_params(fcx.ccx.tcx, tps, inner);\n             }\n             case (ty::ty_tag(?did, ?tps)) {\n                 auto variants = ty::tag_variants(fcx.ccx.tcx, did);\n@@ -944,20 +937,20 @@ mod demand {\n             actual_1 = do_autoderef(fcx, sp, actual_1);\n             implicit_boxes = count_boxes(fcx, sp, actual);\n         }\n-        let vec[mutable ty::t] ty_param_substs = [mutable ];\n-        let vec[int] ty_param_subst_var_ids = [];\n+        let ty::t[mutable] ty_param_substs = ~[mutable];\n+        let int[] ty_param_subst_var_ids = ~[];\n         for (ty::t ty_param_subst in ty_param_substs_0) {\n             // Generate a type variable and unify it with the type parameter\n             // substitution. We will then pull out these type variables.\n \n             auto t_0 = next_ty_var(fcx);\n-            ty_param_substs += [mutable t_0];\n-            ty_param_subst_var_ids += [ty::ty_var_id(fcx.ccx.tcx, t_0)];\n+            ty_param_substs += ~[mutable t_0];\n+            ty_param_subst_var_ids += ~[ty::ty_var_id(fcx.ccx.tcx, t_0)];\n             simple(fcx, sp, ty_param_subst, t_0);\n         }\n \n         fn mk_result(&@fn_ctxt fcx, &ty::t result_ty,\n-                     &vec[int] ty_param_subst_var_ids,\n+                     &int[] ty_param_subst_var_ids,\n                      uint implicit_boxes) -> ty_param_substs_and_ty {\n             let ty::t[] result_ty_param_substs = ~[];\n             for (int var_id in ty_param_subst_var_ids) {\n@@ -1340,13 +1333,9 @@ fn check_pat(&@fn_ctxt fcx, &ast::pat_id_map map, &@ast::pat pat,\n                     ty::ty_param_substs_opt_and_ty_to_monotype(fcx.ccx.tcx,\n                                                                path_tpot);\n \n-                // FIXME: Remove this ivec->vec conversion.\n-                auto tps_vec = ~[];\n-                for (ty::t tp in expected_tps) { tps_vec += ~[tp]; }\n-\n                 auto path_tpt =\n-                    demand::full(fcx, pat.span, expected, ctor_ty, tps_vec,\n-                                 NO_AUTODEREF);\n+                    demand::full(fcx, pat.span, expected, ctor_ty,\n+                                 expected_tps, NO_AUTODEREF);\n                 path_tpot = tup(some[ty::t[]](path_tpt._0), path_tpt._1);\n                 // Get the number of arguments in this tag variant.\n \n@@ -1373,6 +1362,7 @@ fn check_pat(&@fn_ctxt fcx, &ast::pat_id_map map, &@ast::pat pat,\n                                       } else { \"s\" });\n                         fcx.ccx.tcx.sess.span_fatal(pat.span, s);\n                     }\n+\n                     // TODO: vec::iter2\n \n                     auto i = 0u;\n@@ -2347,11 +2337,10 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n                 ret rec(mut=f.mut, ty=f.ty, ident=f.ident, id=f.id);\n             }\n \n-            vec::push[obj_info](fcx.ccx.obj_infos,\n-                                rec(obj_fields=\n-                                    ivec::map(anon_obj_field_to_obj_field, \n-                                              fields),\n-                                    this_obj=id));\n+            fcx.ccx.obj_infos +=\n+                ~[rec(obj_fields=ivec::map(anon_obj_field_to_obj_field,\n+                                           fields),\n+                      this_obj=id)];\n \n             // FIXME: These next three functions are largely ripped off from\n             // similar ones in collect::.  Is there a better way to do this?\n@@ -2441,7 +2430,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n             next_ty_var(fcx);\n             // Now remove the info from the stack.\n \n-            vec::pop[obj_info](fcx.ccx.obj_infos);\n+            ivec::pop[obj_info](fcx.ccx.obj_infos);\n         }\n         case (_) {\n             fcx.ccx.tcx.sess.unimpl(\"expr type in typeck::check_expr\");\n@@ -2460,20 +2449,14 @@ fn next_ty_var(&@fn_ctxt fcx) -> ty::t {\n }\n \n fn get_obj_info(&@crate_ctxt ccx) -> option::t[obj_info] {\n-    ret vec::last[obj_info](ccx.obj_infos);\n+    ret ivec::last[obj_info](ccx.obj_infos);\n }\n \n fn ast_constr_to_constr(ty::ctxt tcx, &@ast::constr c)\n     -> @ty::constr_def {\n     alt (tcx.def_map.find(c.node.id)) {\n         case (some(ast::def_fn(?pred_id, ast::pure_fn))) {\n-            // FIXME: Remove this vec->ivec conversion.\n-            let (@ast::constr_arg_general[uint])[] cag_ivec = ~[];\n-            for (@ast::constr_arg_general[uint] cag in c.node.args) {\n-                cag_ivec += ~[cag];\n-            }\n-\n-            ret @respan(c.span, rec(path=c.node.path, args=cag_ivec,\n+            ret @respan(c.span, rec(path=c.node.path, args=c.node.args,\n                                     id=pred_id));\n         }\n         case (_) {\n@@ -2562,7 +2545,7 @@ fn check_const(&@crate_ctxt ccx, &span sp, &@ast::expr e, &ast::node_id id) {\n     // and statement context for checking the initializer expression.\n \n     auto rty = node_id_to_type(ccx.tcx, id);\n-    let vec[ast::node_id] fixups = [];\n+    let ast::node_id[] fixups = ~[];\n     let @fn_ctxt fcx =\n         @rec(ret_ty=rty,\n              purity=ast::pure_fn,\n@@ -2578,7 +2561,7 @@ fn check_const(&@crate_ctxt ccx, &span sp, &@ast::expr e, &ast::node_id id) {\n fn check_fn(&@crate_ctxt ccx, &ast::fn_decl decl, ast::proto proto,\n             &ast::block body, &ast::node_id id) {\n     auto gather_result = gather_locals(ccx, decl, body, id);\n-    let vec[ast::node_id] fixups = [];\n+    let ast::node_id[] fixups = ~[];\n     let @fn_ctxt fcx =\n         @rec(ret_ty=ast_ty_to_ty_crate(ccx, decl.output),\n              purity=decl.purity,\n@@ -2637,8 +2620,7 @@ fn check_item(@crate_ctxt ccx, &@ast::item it) {\n         case (ast::item_obj(?ob, _, _)) {\n             // We're entering an object, so gather up the info we need.\n \n-            vec::push[obj_info](ccx.obj_infos,\n-                                rec(obj_fields=ob.fields, this_obj=it.id));\n+            ccx.obj_infos += ~[rec(obj_fields=ob.fields, this_obj=it.id)];\n             // Typecheck the methods.\n \n             for (@ast::method method in ob.methods) {\n@@ -2647,15 +2629,16 @@ fn check_item(@crate_ctxt ccx, &@ast::item it) {\n             option::may[@ast::method](bind check_method(ccx, _), ob.dtor);\n             // Now remove the info from the stack.\n \n-            vec::pop[obj_info](ccx.obj_infos);\n+            ivec::pop[obj_info](ccx.obj_infos);\n         }\n         case (_) {/* nothing to do */ }\n     }\n }\n \n fn check_crate(&ty::ctxt tcx, &@ast::crate crate) {\n     collect::collect_item_types(tcx, crate);\n-    let vec[obj_info] obj_infos = [];\n+\n+    let obj_info[] obj_infos = ~[];\n \n     auto ccx =\n         @rec(mutable obj_infos=obj_infos, tcx=tcx);"}]}