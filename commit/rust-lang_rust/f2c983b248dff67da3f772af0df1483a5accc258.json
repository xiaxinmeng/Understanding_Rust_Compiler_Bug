{"sha": "f2c983b248dff67da3f772af0df1483a5accc258", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYyYzk4M2IyNDhkZmY2N2RhM2Y3NzJhZjBkZjE0ODNhNWFjY2MyNTg=", "commit": {"author": {"name": "James Miller", "email": "james@aatch.net", "date": "2016-04-28T12:04:45Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-06-05T11:02:24Z"}, "message": "Add a `with_cond` method\n\nFactors out the common pattern across the several places that do\narithmetic checks", "tree": {"sha": "1000842cea7f7d2d1eb98dc63a3262b75df45f68", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1000842cea7f7d2d1eb98dc63a3262b75df45f68"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f2c983b248dff67da3f772af0df1483a5accc258", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f2c983b248dff67da3f772af0df1483a5accc258", "html_url": "https://github.com/rust-lang/rust/commit/f2c983b248dff67da3f772af0df1483a5accc258", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f2c983b248dff67da3f772af0df1483a5accc258/comments", "author": {"login": "Aatch", "id": 342416, "node_id": "MDQ6VXNlcjM0MjQxNg==", "avatar_url": "https://avatars.githubusercontent.com/u/342416?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aatch", "html_url": "https://github.com/Aatch", "followers_url": "https://api.github.com/users/Aatch/followers", "following_url": "https://api.github.com/users/Aatch/following{/other_user}", "gists_url": "https://api.github.com/users/Aatch/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aatch/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aatch/subscriptions", "organizations_url": "https://api.github.com/users/Aatch/orgs", "repos_url": "https://api.github.com/users/Aatch/repos", "events_url": "https://api.github.com/users/Aatch/events{/privacy}", "received_events_url": "https://api.github.com/users/Aatch/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "73f3054288ee34b50c1f72404b24fdeb12a38f66", "url": "https://api.github.com/repos/rust-lang/rust/commits/73f3054288ee34b50c1f72404b24fdeb12a38f66", "html_url": "https://github.com/rust-lang/rust/commit/73f3054288ee34b50c1f72404b24fdeb12a38f66"}], "stats": {"total": 100, "additions": 54, "deletions": 46}, "files": [{"sha": "01930d0ddc09822538223e7787a3293b5fc1df23", "filename": "src/librustc_mir/build/block.rs", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/f2c983b248dff67da3f772af0df1483a5accc258/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2c983b248dff67da3f772af0df1483a5accc258/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fblock.rs?ref=f2c983b248dff67da3f772af0df1483a5accc258", "patch": "@@ -12,6 +12,7 @@ use build::{BlockAnd, BlockAndExtension, Builder};\n use hair::*;\n use rustc::mir::repr::*;\n use rustc::hir;\n+use syntax::codemap::Span;\n \n impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     pub fn ast_block(&mut self,\n@@ -81,4 +82,31 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             block.unit()\n         })\n     }\n+\n+    // Helper method for generating MIR inside a conditional block.\n+    pub fn with_cond<F>(&mut self, block: BasicBlock, span: Span,\n+                        cond: Operand<'tcx>, f: F) -> BasicBlock\n+    where F: FnOnce(&mut Builder<'a, 'gcx, 'tcx>, BasicBlock) -> BasicBlock {\n+        let scope_id = self.innermost_scope_id();\n+\n+        let then_block = self.cfg.start_new_block();\n+        let else_block = self.cfg.start_new_block();\n+\n+        self.cfg.terminate(block, scope_id, span,\n+                           TerminatorKind::If {\n+                               cond: cond,\n+                               targets: (then_block, else_block)\n+                           });\n+\n+        let after = f(self, then_block);\n+\n+        // If the returned block isn't terminated, add a branch to the \"else\"\n+        // block\n+        if !self.cfg.terminated(after) {\n+            self.cfg.terminate(after, scope_id, span,\n+                               TerminatorKind::Goto { target: else_block });\n+        }\n+\n+        else_block\n+    }\n }"}, {"sha": "7ffef989e2f00e0b0442a5c35442ebbc5e810509", "filename": "src/librustc_mir/build/cfg.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f2c983b248dff67da3f772af0df1483a5accc258/src%2Flibrustc_mir%2Fbuild%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2c983b248dff67da3f772af0df1483a5accc258/src%2Flibrustc_mir%2Fbuild%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fcfg.rs?ref=f2c983b248dff67da3f772af0df1483a5accc258", "patch": "@@ -86,12 +86,17 @@ impl<'tcx> CFG<'tcx> {\n                      scope: ScopeId,\n                      span: Span,\n                      kind: TerminatorKind<'tcx>) {\n-        debug_assert!(self.block_data(block).terminator.is_none(),\n+        debug_assert!(!self.terminated(block),\n                       \"terminate: block {:?} already has a terminator set\", block);\n         self.block_data_mut(block).terminator = Some(Terminator {\n             span: span,\n             scope: scope,\n             kind: kind,\n         });\n     }\n+\n+    /// Returns whether or not the given block has been terminated or not\n+    pub fn terminated(&self, block: BasicBlock) -> bool {\n+        self.block_data(block).terminator.is_some()\n+    }\n }"}, {"sha": "04609e7f8dd3115a55dbf21f631f402b2b6e60e7", "filename": "src/librustc_mir/build/expr/as_rvalue.rs", "status": "modified", "additions": 20, "deletions": 45, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/f2c983b248dff67da3f772af0df1483a5accc258/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2c983b248dff67da3f772af0df1483a5accc258/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=f2c983b248dff67da3f772af0df1483a5accc258", "patch": "@@ -88,18 +88,11 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     this.cfg.push_assign(block, scope_id, expr_span, &is_min,\n                                          Rvalue::BinaryOp(BinOp::Eq, arg.clone(), minval));\n \n-                    let of_block = this.cfg.start_new_block();\n-                    let ok_block = this.cfg.start_new_block();\n-\n-                    this.cfg.terminate(block, scope_id, expr_span,\n-                                       TerminatorKind::If {\n-                                           cond: Operand::Consume(is_min),\n-                                           targets: (of_block, ok_block)\n-                                       });\n-\n-                    this.panic(of_block, \"attempted to negate with overflow\", expr_span);\n-\n-                    block = ok_block;\n+                    block = this.with_cond(\n+                        block, expr_span, Operand::Consume(is_min), |this, block| {\n+                            this.panic(block, \"attempted to negate with overflow\", expr_span);\n+                            block\n+                        });\n                 }\n                 block.and(Rvalue::UnaryOp(op, arg))\n             }\n@@ -268,21 +261,18 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             let val = result_value.clone().field(val_fld, ty);\n             let of = result_value.field(of_fld, bool_ty);\n \n-            let success = self.cfg.start_new_block();\n-            let failure = self.cfg.start_new_block();\n-\n-            self.cfg.terminate(block, scope_id, span,\n-                               TerminatorKind::If {\n-                                   cond: Operand::Consume(of),\n-                                   targets: (failure, success)\n-                               });\n             let msg = if op == BinOp::Shl || op == BinOp::Shr {\n                 \"shift operation overflowed\"\n             } else {\n                 \"arithmetic operation overflowed\"\n             };\n-            self.panic(failure, msg, span);\n-            success.and(Rvalue::Use(Operand::Consume(val)))\n+\n+            block = self.with_cond(block, span, Operand::Consume(of), |this, block| {\n+                this.panic(block, msg, span);\n+                block\n+            });\n+\n+            block.and(Rvalue::Use(Operand::Consume(val)))\n         } else {\n             if ty.is_integral() && (op == BinOp::Div || op == BinOp::Rem) {\n                 // Checking division and remainder is more complex, since we 1. always check\n@@ -302,17 +292,10 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 self.cfg.push_assign(block, scope_id, span, &is_zero,\n                                      Rvalue::BinaryOp(BinOp::Eq, rhs.clone(), zero));\n \n-                let zero_block = self.cfg.start_new_block();\n-                let ok_block   = self.cfg.start_new_block();\n-\n-                self.cfg.terminate(block, scope_id, span,\n-                                   TerminatorKind::If {\n-                                       cond: Operand::Consume(is_zero),\n-                                       targets: (zero_block, ok_block)\n-                                   });\n-\n-                self.panic(zero_block, zero_msg, span);\n-                block = ok_block;\n+                block = self.with_cond(block, span, Operand::Consume(is_zero), |this, block| {\n+                    this.panic(block, zero_msg, span);\n+                    block\n+                });\n \n                 // We only need to check for the overflow in one case:\n                 // MIN / -1, and only for signed values.\n@@ -336,18 +319,10 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     self.cfg.push_assign(block, scope_id, span, &of,\n                                          Rvalue::BinaryOp(BinOp::BitAnd, is_neg_1, is_min));\n \n-                    let of_block = self.cfg.start_new_block();\n-                    let ok_block = self.cfg.start_new_block();\n-\n-                    self.cfg.terminate(block, scope_id, span,\n-                                       TerminatorKind::If {\n-                                           cond: Operand::Consume(of),\n-                                           targets: (of_block, ok_block)\n-                                       });\n-\n-                    self.panic(of_block, overflow_msg, span);\n-\n-                    block = ok_block;\n+                    block = self.with_cond(block, span, Operand::Consume(of), |this, block| {\n+                        this.panic(block, overflow_msg, span);\n+                        block\n+                    });\n                 }\n             }\n "}]}