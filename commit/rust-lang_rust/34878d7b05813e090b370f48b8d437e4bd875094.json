{"sha": "34878d7b05813e090b370f48b8d437e4bd875094", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM0ODc4ZDdiMDU4MTNlMDkwYjM3MGY0OGI4ZDQzN2U0YmQ4NzUwOTQ=", "commit": {"author": {"name": "Vita Batrla", "email": "vita.batrla@gmail.com", "date": "2020-01-17T13:43:36Z"}, "committer": {"name": "Vita Batrla", "email": "vita.batrla@gmail.com", "date": "2020-01-17T15:01:42Z"}, "message": "Options IP_MULTICAST_TTL and IP_MULTICAST_LOOP are 1 byte on BSD and Solaris\n\nSee ip(4P) man page:\n IP_MULTICAST_TTL     Time  to live for multicast datagrams. This option\n                      takes an unsigned character as  an  argument.  Its\n                      value  is  the TTL that IP uses on outgoing multi-\n                      cast datagrams. The default is 1.\n\n IP_MULTICAST_LOOP    Loopback for multicast datagrams. Normally  multi-\n                      cast  datagrams  are  delivered  to members on the\n                      sending  host  (or  sending  zone).  Setting   the\n                      unsigned  character argument to 0 causes the oppo-\n                      site behavior, meaning that  when  multiple  zones\n                      are  present,  the  datagrams are delivered to all\n                      zones except the sending zone.\n\nhttps://docs.oracle.com/cd/E88353_01/html/E37851/ip-4p.html\nhttps://man.openbsd.org/ip.4", "tree": {"sha": "9eee91b32c7b708a97a639f892c119330c08b621", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9eee91b32c7b708a97a639f892c119330c08b621"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/34878d7b05813e090b370f48b8d437e4bd875094", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/34878d7b05813e090b370f48b8d437e4bd875094", "html_url": "https://github.com/rust-lang/rust/commit/34878d7b05813e090b370f48b8d437e4bd875094", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/34878d7b05813e090b370f48b8d437e4bd875094/comments", "author": null, "committer": null, "parents": [{"sha": "2480c9eac15608591f58730aed27caac9c30b4c2", "url": "https://api.github.com/repos/rust-lang/rust/commits/2480c9eac15608591f58730aed27caac9c30b4c2", "html_url": "https://github.com/rust-lang/rust/commit/2480c9eac15608591f58730aed27caac9c30b4c2"}], "stats": {"total": 68, "additions": 50, "deletions": 18}, "files": [{"sha": "32e392f1efc86024ed56e9df9ce8b4939dae6dfb", "filename": "src/libstd/sys_common/net.rs", "status": "modified", "additions": 50, "deletions": 18, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/34878d7b05813e090b370f48b8d437e4bd875094/src%2Flibstd%2Fsys_common%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34878d7b05813e090b370f48b8d437e4bd875094/src%2Flibstd%2Fsys_common%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fnet.rs?ref=34878d7b05813e090b370f48b8d437e4bd875094", "patch": "@@ -12,6 +12,10 @@ use crate::sys_common::{AsInner, FromInner, IntoInner};\n use crate::time::Duration;\n \n use libc::{c_int, c_void};\n+#[cfg(any(target_os = \"dragonfly\", target_os = \"freebsd\",\n+          target_os = \"openbsd\", target_os = \"netbsd\",\n+          target_os = \"solaris\"))]\n+use libc::{c_uchar};\n \n #[cfg(not(any(\n     target_os = \"dragonfly\",\n@@ -565,24 +569,6 @@ impl UdpSocket {\n         Ok(raw != 0)\n     }\n \n-    pub fn set_multicast_loop_v4(&self, multicast_loop_v4: bool) -> io::Result<()> {\n-        setsockopt(&self.inner, c::IPPROTO_IP, c::IP_MULTICAST_LOOP, multicast_loop_v4 as c_int)\n-    }\n-\n-    pub fn multicast_loop_v4(&self) -> io::Result<bool> {\n-        let raw: c_int = getsockopt(&self.inner, c::IPPROTO_IP, c::IP_MULTICAST_LOOP)?;\n-        Ok(raw != 0)\n-    }\n-\n-    pub fn set_multicast_ttl_v4(&self, multicast_ttl_v4: u32) -> io::Result<()> {\n-        setsockopt(&self.inner, c::IPPROTO_IP, c::IP_MULTICAST_TTL, multicast_ttl_v4 as c_int)\n-    }\n-\n-    pub fn multicast_ttl_v4(&self) -> io::Result<u32> {\n-        let raw: c_int = getsockopt(&self.inner, c::IPPROTO_IP, c::IP_MULTICAST_TTL)?;\n-        Ok(raw as u32)\n-    }\n-\n     pub fn set_multicast_loop_v6(&self, multicast_loop_v6: bool) -> io::Result<()> {\n         setsockopt(&self.inner, c::IPPROTO_IPV6, c::IPV6_MULTICAST_LOOP, multicast_loop_v6 as c_int)\n     }\n@@ -663,6 +649,52 @@ impl UdpSocket {\n     }\n }\n \n+#[cfg(not(any(target_os = \"dragonfly\", target_os = \"freebsd\",\n+              target_os = \"openbsd\", target_os = \"netbsd\",\n+              target_os = \"solaris\")))]\n+impl UdpSocket {\n+    pub fn set_multicast_loop_v4(&self, multicast_loop_v4: bool) -> io::Result<()> {\n+        setsockopt(&self.inner, c::IPPROTO_IP, c::IP_MULTICAST_LOOP, multicast_loop_v4 as c_int)\n+    }\n+\n+    pub fn multicast_loop_v4(&self) -> io::Result<bool> {\n+        let raw: c_int = getsockopt(&self.inner, c::IPPROTO_IP, c::IP_MULTICAST_LOOP)?;\n+        Ok(raw != 0)\n+    }\n+\n+    pub fn set_multicast_ttl_v4(&self, multicast_ttl_v4: u32) -> io::Result<()> {\n+        setsockopt(&self.inner, c::IPPROTO_IP, c::IP_MULTICAST_TTL, multicast_ttl_v4 as c_int)\n+    }\n+\n+    pub fn multicast_ttl_v4(&self) -> io::Result<u32> {\n+        let raw: c_int = getsockopt(&self.inner, c::IPPROTO_IP, c::IP_MULTICAST_TTL)?;\n+        Ok(raw as u32)\n+    }\n+}\n+\n+#[cfg(any(target_os = \"dragonfly\", target_os = \"freebsd\",\n+          target_os = \"openbsd\", target_os = \"netbsd\",\n+          target_os = \"solaris\"))]\n+impl UdpSocket {\n+    pub fn set_multicast_loop_v4(&self, multicast_loop_v4: bool) -> io::Result<()> {\n+        setsockopt(&self.inner, c::IPPROTO_IP, c::IP_MULTICAST_LOOP, multicast_loop_v4 as c_uchar)\n+    }\n+\n+    pub fn multicast_loop_v4(&self) -> io::Result<bool> {\n+        let raw: c_uchar = getsockopt(&self.inner, c::IPPROTO_IP, c::IP_MULTICAST_LOOP)?;\n+        Ok(raw != 0)\n+    }\n+\n+    pub fn set_multicast_ttl_v4(&self, multicast_ttl_v4: u32) -> io::Result<()> {\n+        setsockopt(&self.inner, c::IPPROTO_IP, c::IP_MULTICAST_TTL, multicast_ttl_v4 as c_uchar)\n+    }\n+\n+    pub fn multicast_ttl_v4(&self) -> io::Result<u32> {\n+        let raw: c_uchar = getsockopt(&self.inner, c::IPPROTO_IP, c::IP_MULTICAST_TTL)?;\n+        Ok(raw as u32)\n+    }\n+}\n+\n impl FromInner<Socket> for UdpSocket {\n     fn from_inner(socket: Socket) -> UdpSocket {\n         UdpSocket { inner: socket }"}]}