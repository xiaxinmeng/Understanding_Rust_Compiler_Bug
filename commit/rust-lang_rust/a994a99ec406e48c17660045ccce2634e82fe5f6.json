{"sha": "a994a99ec406e48c17660045ccce2634e82fe5f6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE5OTRhOTllYzQwNmU0OGMxNzY2MDA0NWNjY2UyNjM0ZTgyZmU1ZjY=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-02-16T11:57:38Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-02-18T20:23:34Z"}, "message": "Always prefer where-clauses over impls in trait selection. Fixes #22110.", "tree": {"sha": "9315a6210fab0ac89e6bba3ffc7de56d61aaa207", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9315a6210fab0ac89e6bba3ffc7de56d61aaa207"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a994a99ec406e48c17660045ccce2634e82fe5f6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a994a99ec406e48c17660045ccce2634e82fe5f6", "html_url": "https://github.com/rust-lang/rust/commit/a994a99ec406e48c17660045ccce2634e82fe5f6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a994a99ec406e48c17660045ccce2634e82fe5f6/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2939e483fd8a32d330c837725513b493fd457dc3", "url": "https://api.github.com/repos/rust-lang/rust/commits/2939e483fd8a32d330c837725513b493fd457dc3", "html_url": "https://github.com/rust-lang/rust/commit/2939e483fd8a32d330c837725513b493fd457dc3"}], "stats": {"total": 105, "additions": 48, "deletions": 57}, "files": [{"sha": "027415de998dfbae2049fe51b8d1f83fed696955", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 14, "deletions": 57, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/a994a99ec406e48c17660045ccce2634e82fe5f6/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a994a99ec406e48c17660045ccce2634e82fe5f6/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=a994a99ec406e48c17660045ccce2634e82fe5f6", "patch": "@@ -652,8 +652,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 let is_dup =\n                     (0..candidates.len())\n                     .filter(|&j| i != j)\n-                    .any(|j| self.candidate_should_be_dropped_in_favor_of(stack,\n-                                                                          &candidates[i],\n+                    .any(|j| self.candidate_should_be_dropped_in_favor_of(&candidates[i],\n                                                                           &candidates[j]));\n                 if is_dup {\n                     debug!(\"Dropping candidate #{}/{}: {}\",\n@@ -1235,31 +1234,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         self.evaluate_predicates_recursively(stack, selection.iter_nested())\n     }\n \n-    /// Returns true if `candidate_i` should be dropped in favor of `candidate_j`.\n-    ///\n-    /// This is generally true if either:\n-    /// - candidate i and candidate j are equivalent; or,\n-    /// - candidate i is a concrete impl and candidate j is a where clause bound,\n-    ///   and the concrete impl is applicable to the types in the where clause bound.\n-    ///\n-    /// The last case refers to cases where there are blanket impls (often conditional\n-    /// blanket impls) as well as a where clause. This can come down to one of two cases:\n-    ///\n-    /// - The impl is truly unconditional (it has no where clauses\n-    ///   of its own), in which case the where clause is\n-    ///   unnecessary, because coherence requires that we would\n-    ///   pick that particular impl anyhow (at least so long as we\n-    ///   don't have specialization).\n-    ///\n-    /// - The impl is conditional, in which case we may not have winnowed it out\n-    ///   because we don't know if the conditions apply, but the where clause is basically\n-    ///   telling us that there is some impl, though not necessarily the one we see.\n-    ///\n-    /// In both cases we prefer to take the where clause, which is\n-    /// essentially harmless.  See issue #18453 for more details of\n-    /// a case where doing the opposite caused us harm.\n+    /// Returns true if `candidate_i` should be dropped in favor of\n+    /// `candidate_j`.  Generally speaking we will drop duplicate\n+    /// candidates and prefer where-clause candidates.\n     fn candidate_should_be_dropped_in_favor_of<'o>(&mut self,\n-                                                   stack: &TraitObligationStack<'o, 'tcx>,\n                                                    candidate_i: &SelectionCandidate<'tcx>,\n                                                    candidate_j: &SelectionCandidate<'tcx>)\n                                                    -> bool\n@@ -1269,37 +1247,16 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         }\n \n         match (candidate_i, candidate_j) {\n-            (&ImplCandidate(impl_def_id), &ParamCandidate(ref bound)) => {\n-                debug!(\"Considering whether to drop param {} in favor of impl {}\",\n-                       candidate_i.repr(self.tcx()),\n-                       candidate_j.repr(self.tcx()));\n-\n-                self.infcx.probe(|snapshot| {\n-                    let (skol_obligation_trait_ref, skol_map) =\n-                        self.infcx().skolemize_late_bound_regions(\n-                            &stack.obligation.predicate, snapshot);\n-                    let impl_substs =\n-                        self.rematch_impl(impl_def_id, stack.obligation, snapshot,\n-                                          &skol_map, skol_obligation_trait_ref.trait_ref.clone());\n-                    let impl_trait_ref =\n-                        ty::impl_trait_ref(self.tcx(), impl_def_id).unwrap();\n-                    let impl_trait_ref =\n-                        impl_trait_ref.subst(self.tcx(), &impl_substs.value);\n-                    let poly_impl_trait_ref =\n-                        ty::Binder(impl_trait_ref);\n-                    let origin =\n-                        infer::RelateOutputImplTypes(stack.obligation.cause.span);\n-                    self.infcx\n-                        .sub_poly_trait_refs(false, origin, poly_impl_trait_ref, bound.clone())\n-                        .is_ok()\n-                })\n-            }\n-            (&BuiltinCandidate(_), &ParamCandidate(_)) => {\n-                // If we have a where-clause like `Option<K> : Send`,\n-                // then we wind up in a situation where there is a\n-                // default rule (`Option<K>:Send if K:Send) and the\n-                // where-clause that both seem applicable. Just take\n-                // the where-clause in that case.\n+            (&ImplCandidate(..), &ParamCandidate(..)) |\n+            (&ClosureCandidate(..), &ParamCandidate(..)) |\n+            (&FnPointerCandidate(..), &ParamCandidate(..)) |\n+            (&BuiltinCandidate(..), &ParamCandidate(..)) => {\n+                // We basically prefer always prefer to use a\n+                // where-clause over another option. Where clauses\n+                // impose the burden of finding the exact match onto\n+                // the caller. Using an impl in preference of a where\n+                // clause can also lead us to \"overspecialize\", as in\n+                // #18453.\n                 true\n             }\n             (&ProjectionCandidate, &ParamCandidate(_)) => {"}, {"sha": "9cdcf4945d8ba6d52af24171c1bfb7ba26ff89f1", "filename": "src/test/run-pass/traits-issue-22110.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/a994a99ec406e48c17660045ccce2634e82fe5f6/src%2Ftest%2Frun-pass%2Ftraits-issue-22110.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a994a99ec406e48c17660045ccce2634e82fe5f6/src%2Ftest%2Frun-pass%2Ftraits-issue-22110.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftraits-issue-22110.rs?ref=a994a99ec406e48c17660045ccce2634e82fe5f6", "patch": "@@ -0,0 +1,34 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test an issue where we reported ambiguity between the where-clause\n+// and the blanket impl. The only important thing is that compilation\n+// succeeds here. Issue #22110.\n+\n+#![allow(dead_code)]\n+\n+trait Foo<A> {\n+    fn foo(&self, a: A);\n+}\n+\n+impl<A,F:Fn(A)> Foo<A> for F {\n+    fn foo(&self, _: A) { }\n+}\n+\n+fn baz<A,F:for<'a> Foo<(&'a A,)>>(_: F) { }\n+\n+fn components<T,A>(t: fn(&A))\n+    where fn(&A) : for<'a> Foo<(&'a A,)>,\n+{\n+    baz(t)\n+}\n+\n+fn main() {\n+}"}]}