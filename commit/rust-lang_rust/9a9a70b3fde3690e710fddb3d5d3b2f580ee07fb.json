{"sha": "9a9a70b3fde3690e710fddb3d5d3b2f580ee07fb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlhOWE3MGIzZmRlMzY5MGU3MTBmZGRiM2Q1ZDNiMmY1ODBlZTA3ZmI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-02-06T11:11:39Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-02-06T11:11:39Z"}, "message": "auto merge of #12047 : huonw/rust/cyclic-rc, r=thestinger\n\nA weak pointer inside itself will have its destructor run when the last\r\nstrong pointer to that data disappears, so we need to make sure that the\r\nWeak and Rc destructors don't duplicate work (i.e. freeing).\r\n\r\nBy making the Rcs effectively take a weak pointer, we ensure that no\r\nWeak destructor will free the pointer while still ensuring that Weak\r\npointers can't be upgraded to strong ones as the destructors run.\r\n\r\nThis approach of starting weak at 1 is what libstdc++ does.\r\n\r\nFixes #12046.", "tree": {"sha": "97f0a3b33b17e5107670293581db0b77cb46daee", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/97f0a3b33b17e5107670293581db0b77cb46daee"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9a9a70b3fde3690e710fddb3d5d3b2f580ee07fb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9a9a70b3fde3690e710fddb3d5d3b2f580ee07fb", "html_url": "https://github.com/rust-lang/rust/commit/9a9a70b3fde3690e710fddb3d5d3b2f580ee07fb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9a9a70b3fde3690e710fddb3d5d3b2f580ee07fb/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d8c4e78603eb1f658516dde08868abbe6c06bd35", "url": "https://api.github.com/repos/rust-lang/rust/commits/d8c4e78603eb1f658516dde08868abbe6c06bd35", "html_url": "https://github.com/rust-lang/rust/commit/d8c4e78603eb1f658516dde08868abbe6c06bd35"}, {"sha": "da45340ab84603cf6932b012b977bc2e7b8d6764", "url": "https://api.github.com/repos/rust-lang/rust/commits/da45340ab84603cf6932b012b977bc2e7b8d6764", "html_url": "https://github.com/rust-lang/rust/commit/da45340ab84603cf6932b012b977bc2e7b8d6764"}], "stats": {"total": 29, "additions": 27, "deletions": 2}, "files": [{"sha": "a1565bc85dede8c4fb5e9bcee0f64e5eedad73ff", "filename": "src/libstd/rc.rs", "status": "modified", "additions": 27, "deletions": 2, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/9a9a70b3fde3690e710fddb3d5d3b2f580ee07fb/src%2Flibstd%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a9a70b3fde3690e710fddb3d5d3b2f580ee07fb/src%2Flibstd%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frc.rs?ref=9a9a70b3fde3690e710fddb3d5d3b2f580ee07fb", "patch": "@@ -50,7 +50,12 @@ impl<T> Rc<T> {\n     pub fn new(value: T) -> Rc<T> {\n         unsafe {\n             Rc {\n-                ptr: transmute(~RcBox { value: value, strong: 1, weak: 0 }),\n+                // there is an implicit weak pointer owned by all the\n+                // strong pointers, which ensures that the weak\n+                // destructor never frees the allocation while the\n+                // strong destructor is running, even if the weak\n+                // pointer is stored inside the strong one.\n+                ptr: transmute(~RcBox { value: value, strong: 1, weak: 1 }),\n                 marker: marker::NoSend,\n             }\n         }\n@@ -81,6 +86,11 @@ impl<T> Drop for Rc<T> {\n                 (*self.ptr).strong -= 1;\n                 if (*self.ptr).strong == 0 {\n                     read_ptr(self.borrow()); // destroy the contained object\n+\n+                    // remove the implicit \"strong weak\" pointer now\n+                    // that we've destroyed the contents.\n+                    (*self.ptr).weak -= 1;\n+\n                     if (*self.ptr).weak == 0 {\n                         exchange_free(self.ptr as *u8)\n                     }\n@@ -156,7 +166,9 @@ impl<T> Drop for Weak<T> {\n         unsafe {\n             if self.ptr != 0 as *mut RcBox<T> {\n                 (*self.ptr).weak -= 1;\n-                if (*self.ptr).weak == 0 && (*self.ptr).strong == 0 {\n+                // the weak count starts at 1, and will only go to\n+                // zero if all the strong pointers have disappeared.\n+                if (*self.ptr).weak == 0 {\n                     exchange_free(self.ptr as *u8)\n                 }\n             }\n@@ -242,4 +254,17 @@ mod tests {\n         let a = Rc::new(RefCell::new(Gc::new(1)));\n         assert!(a.borrow().try_borrow_mut().is_some());\n     }\n+\n+    #[test]\n+    fn weak_self_cyclic() {\n+        struct Cycle {\n+            x: RefCell<Option<Weak<Cycle>>>\n+        }\n+\n+        let a = Rc::new(Cycle { x: RefCell::new(None) });\n+        let b = a.clone().downgrade();\n+        *a.borrow().x.borrow_mut().get() = Some(b);\n+\n+        // hopefully we don't double-free (or leak)...\n+    }\n }"}]}