{"sha": "541523d10dce98dc266f6d4e6fb6131182c0f791", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU0MTUyM2QxMGRjZTk4ZGMyNjZmNmQ0ZTZmYjYxMzExODJjMGY3OTE=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-05-19T21:27:25Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-06-01T16:56:30Z"}, "message": "rewrite layout to take a (param-env, ty) pair instead of infcx", "tree": {"sha": "8a9f72b4e0c7d4e1ec48d65440016fac921337a0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8a9f72b4e0c7d4e1ec48d65440016fac921337a0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/541523d10dce98dc266f6d4e6fb6131182c0f791", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/541523d10dce98dc266f6d4e6fb6131182c0f791", "html_url": "https://github.com/rust-lang/rust/commit/541523d10dce98dc266f6d4e6fb6131182c0f791", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/541523d10dce98dc266f6d4e6fb6131182c0f791/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6c4b961effdbec1bb2fc5aaed5aeb219eb7f3b19", "url": "https://api.github.com/repos/rust-lang/rust/commits/6c4b961effdbec1bb2fc5aaed5aeb219eb7f3b19", "html_url": "https://github.com/rust-lang/rust/commit/6c4b961effdbec1bb2fc5aaed5aeb219eb7f3b19"}], "stats": {"total": 437, "additions": 225, "deletions": 212}, "files": [{"sha": "c38b3745f4c72e78c51443a311ad790f5ddda75e", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/541523d10dce98dc266f6d4e6fb6131182c0f791/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/541523d10dce98dc266f6d4e6fb6131182c0f791/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=541523d10dce98dc266f6d4e6fb6131182c0f791", "patch": "@@ -112,6 +112,7 @@ pub enum DepNode<D: Clone + Debug> {\n     IsSized(D),\n     IsFreeze(D),\n     NeedsDrop(D),\n+    Layout(D),\n \n     // The set of impls for a given trait. Ultimately, it would be\n     // nice to get more fine-grained here (e.g., to include a\n@@ -241,6 +242,7 @@ impl<D: Clone + Debug> DepNode<D> {\n             IsSized(ref d) => op(d).map(IsSized),\n             IsFreeze(ref d) => op(d).map(IsFreeze),\n             NeedsDrop(ref d) => op(d).map(NeedsDrop),\n+            Layout(ref d) => op(d).map(Layout),\n             Hir(ref d) => op(d).map(Hir),\n             HirBody(ref d) => op(d).map(HirBody),\n             MetaData(ref d) => op(d).map(MetaData),"}, {"sha": "57815b7f0b690b68cc85a0b3aaffb28cdec53fce", "filename": "src/librustc/middle/intrinsicck.rs", "status": "modified", "additions": 25, "deletions": 26, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/541523d10dce98dc266f6d4e6fb6131182c0f791/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/541523d10dce98dc266f6d4e6fb6131182c0f791/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs?ref=541523d10dce98dc266f6d4e6fb6131182c0f791", "patch": "@@ -10,7 +10,6 @@\n \n use hir::def::Def;\n use hir::def_id::DefId;\n-use infer::InferCtxt;\n use ty::{self, Ty, TyCtxt};\n use ty::layout::{LayoutError, Pointer, SizeSkeleton};\n \n@@ -30,8 +29,10 @@ struct ItemVisitor<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>\n }\n \n-struct ExprVisitor<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n-    infcx: &'a InferCtxt<'a, 'gcx, 'tcx>\n+struct ExprVisitor<'a, 'tcx: 'a> {\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tables: &'tcx ty::TypeckTables<'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n }\n \n /// If the type is `Option<T>`, it will return `T`, otherwise\n@@ -63,18 +64,18 @@ fn unpack_option_like<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     ty\n }\n \n-impl<'a, 'gcx, 'tcx> ExprVisitor<'a, 'gcx, 'tcx> {\n+impl<'a, 'tcx> ExprVisitor<'a, 'tcx> {\n     fn def_id_is_transmute(&self, def_id: DefId) -> bool {\n-        let intrinsic = match self.infcx.tcx.type_of(def_id).sty {\n+        let intrinsic = match self.tcx.type_of(def_id).sty {\n             ty::TyFnDef(.., bfty) => bfty.abi() == RustIntrinsic,\n             _ => return false\n         };\n-        intrinsic && self.infcx.tcx.item_name(def_id) == \"transmute\"\n+        intrinsic && self.tcx.item_name(def_id) == \"transmute\"\n     }\n \n-    fn check_transmute(&self, span: Span, from: Ty<'gcx>, to: Ty<'gcx>) {\n-        let sk_from = SizeSkeleton::compute(from, self.infcx);\n-        let sk_to = SizeSkeleton::compute(to, self.infcx);\n+    fn check_transmute(&self, span: Span, from: Ty<'tcx>, to: Ty<'tcx>) {\n+        let sk_from = SizeSkeleton::compute(from, self.tcx, self.param_env);\n+        let sk_to = SizeSkeleton::compute(to, self.tcx, self.param_env);\n \n         // Check for same size using the skeletons.\n         if let (Ok(sk_from), Ok(sk_to)) = (sk_from, sk_to) {\n@@ -84,11 +85,11 @@ impl<'a, 'gcx, 'tcx> ExprVisitor<'a, 'gcx, 'tcx> {\n \n             // Special-case transmutting from `typeof(function)` and\n             // `Option<typeof(function)>` to present a clearer error.\n-            let from = unpack_option_like(self.infcx.tcx.global_tcx(), from);\n+            let from = unpack_option_like(self.tcx.global_tcx(), from);\n             match (&from.sty, sk_to) {\n                 (&ty::TyFnDef(..), SizeSkeleton::Known(size_to))\n-                        if size_to == Pointer.size(self.infcx) => {\n-                    struct_span_err!(self.infcx.tcx.sess, span, E0591,\n+                        if size_to == Pointer.size(self.tcx) => {\n+                    struct_span_err!(self.tcx.sess, span, E0591,\n                                      \"`{}` is zero-sized and can't be transmuted to `{}`\",\n                                      from, to)\n                         .span_note(span, \"cast with `as` to a pointer instead\")\n@@ -100,7 +101,7 @@ impl<'a, 'gcx, 'tcx> ExprVisitor<'a, 'gcx, 'tcx> {\n         }\n \n         // Try to display a sensible error with as much information as possible.\n-        let skeleton_string = |ty: Ty<'gcx>, sk| {\n+        let skeleton_string = |ty: Ty<'tcx>, sk| {\n             match sk {\n                 Ok(SizeSkeleton::Known(size)) => {\n                     format!(\"{} bits\", size.bits())\n@@ -119,7 +120,7 @@ impl<'a, 'gcx, 'tcx> ExprVisitor<'a, 'gcx, 'tcx> {\n             }\n         };\n \n-        struct_span_err!(self.infcx.tcx.sess, span, E0512,\n+        struct_span_err!(self.tcx.sess, span, E0512,\n                   \"transmute called with differently sized types: \\\n                    {} ({}) to {} ({})\",\n                   from, skeleton_string(from, sk_from),\n@@ -138,32 +139,30 @@ impl<'a, 'tcx> Visitor<'tcx> for ItemVisitor<'a, 'tcx> {\n     }\n \n     fn visit_nested_body(&mut self, body_id: hir::BodyId) {\n+        let owner_def_id = self.tcx.hir.body_owner_def_id(body_id);\n         let body = self.tcx.hir.body(body_id);\n-        self.tcx.infer_ctxt(body_id).enter(|infcx| {\n-            let mut visitor = ExprVisitor {\n-                infcx: &infcx\n-            };\n-            visitor.visit_body(body);\n-        });\n+        let param_env = self.tcx.param_env(owner_def_id);\n+        let tables = self.tcx.typeck_tables_of(owner_def_id);\n+        ExprVisitor { tcx: self.tcx, param_env, tables }.visit_body(body);\n         self.visit_body(body);\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> Visitor<'gcx> for ExprVisitor<'a, 'gcx, 'tcx> {\n-    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'gcx> {\n+impl<'a, 'tcx> Visitor<'tcx> for ExprVisitor<'a, 'tcx> {\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n         NestedVisitorMap::None\n     }\n \n-    fn visit_expr(&mut self, expr: &'gcx hir::Expr) {\n+    fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n         let def = if let hir::ExprPath(ref qpath) = expr.node {\n-            self.infcx.tables.borrow().qpath_def(qpath, expr.id)\n+            self.tables.qpath_def(qpath, expr.id)\n         } else {\n             Def::Err\n         };\n         match def {\n             Def::Fn(did) if self.def_id_is_transmute(did) => {\n-                let typ = self.infcx.tables.borrow().node_id_to_type(expr.id);\n-                let typ = self.infcx.tcx.lift_to_global(&typ).unwrap();\n+                let typ = self.tables.node_id_to_type(expr.id);\n+                let typ = self.tcx.lift_to_global(&typ).unwrap();\n                 match typ.sty {\n                     ty::TyFnDef(.., sig) if sig.abi() == RustIntrinsic => {\n                         let from = sig.inputs().skip_binder()[0];"}, {"sha": "4dc764f6d30c275f4b2aa660e7a49b6c08f567a8", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 124, "deletions": 112, "changes": 236, "blob_url": "https://github.com/rust-lang/rust/blob/541523d10dce98dc266f6d4e6fb6131182c0f791/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/541523d10dce98dc266f6d4e6fb6131182c0f791/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=541523d10dce98dc266f6d4e6fb6131182c0f791", "patch": "@@ -12,9 +12,7 @@ pub use self::Integer::*;\n pub use self::Layout::*;\n pub use self::Primitive::*;\n \n-use infer::InferCtxt;\n use session::Session;\n-use traits;\n use ty::{self, Ty, TyCtxt, TypeFoldable, ReprOptions, ReprFlags};\n \n use syntax::ast::{FloatTy, IntTy, UintTy};\n@@ -212,6 +210,12 @@ impl<'a> HasDataLayout for &'a TargetDataLayout {\n     }\n }\n \n+impl<'a, 'tcx> HasDataLayout for TyCtxt<'a, 'tcx, 'tcx> {\n+    fn data_layout(&self) -> &TargetDataLayout {\n+        &self.data_layout\n+    }\n+}\n+\n /// Endianness of the target, which must match cfg(target-endian).\n #[derive(Copy, Clone)]\n pub enum Endian {\n@@ -457,8 +461,12 @@ impl Integer {\n     /// signed discriminant range and #[repr] attribute.\n     /// N.B.: u64 values above i64::MAX will be treated as signed, but\n     /// that shouldn't affect anything, other than maybe debuginfo.\n-    fn repr_discr(tcx: TyCtxt, ty: Ty, repr: &ReprOptions, min: i64, max: i64)\n-                      -> (Integer, bool) {\n+    fn repr_discr<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                            ty: Ty<'tcx>,\n+                            repr: &ReprOptions,\n+                            min: i64,\n+                            max: i64)\n+                            -> (Integer, bool) {\n         // Theoretically, negative values could be larger in unsigned representation\n         // than the unsigned representation of the signed minimum. However, if there\n         // are any negative values, the only valid unsigned representation is u64\n@@ -583,10 +591,13 @@ enum StructKind {\n     EnumVariant,\n }\n \n-impl<'a, 'gcx, 'tcx> Struct {\n-    fn new(dl: &TargetDataLayout, fields: &Vec<&'a Layout>,\n-                  repr: &ReprOptions, kind: StructKind,\n-                  scapegoat: Ty<'gcx>) -> Result<Struct, LayoutError<'gcx>> {\n+impl<'a, 'tcx> Struct {\n+    fn new(dl: &TargetDataLayout,\n+           fields: &Vec<&'a Layout>,\n+           repr: &ReprOptions,\n+           kind: StructKind,\n+           scapegoat: Ty<'tcx>)\n+           -> Result<Struct, LayoutError<'tcx>> {\n         if repr.packed() && repr.align > 0 {\n             bug!(\"Struct cannot be packed and aligned\");\n         }\n@@ -723,8 +734,8 @@ impl<'a, 'gcx, 'tcx> Struct {\n \n     /// Determine whether a structure would be zero-sized, given its fields.\n     fn would_be_zero_sized<I>(dl: &TargetDataLayout, fields: I)\n-                              -> Result<bool, LayoutError<'gcx>>\n-    where I: Iterator<Item=Result<&'a Layout, LayoutError<'gcx>>> {\n+                              -> Result<bool, LayoutError<'tcx>>\n+    where I: Iterator<Item=Result<&'a Layout, LayoutError<'tcx>>> {\n         for field in fields {\n             let field = field?;\n             if field.is_unsized() || field.size(dl).bytes() > 0 {\n@@ -764,11 +775,11 @@ impl<'a, 'gcx, 'tcx> Struct {\n     /// The tuple is `(path, source_path)`,\n     /// where `path` is in memory order and `source_path` in source order.\n     // FIXME(eddyb) track value ranges and traverse already optimized enums.\n-    fn non_zero_field_in_type(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n-                               ty: Ty<'gcx>)\n-                               -> Result<Option<(FieldPath, FieldPath)>, LayoutError<'gcx>> {\n-        let tcx = infcx.tcx.global_tcx();\n-        match (ty.layout(infcx)?, &ty.sty) {\n+    fn non_zero_field_in_type(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                              param_env: ty::ParamEnv<'tcx>,\n+                              ty: Ty<'tcx>)\n+                              -> Result<Option<(FieldPath, FieldPath)>, LayoutError<'tcx>> {\n+        match (ty.layout(tcx, param_env)?, &ty.sty) {\n             (&Scalar { non_zero: true, .. }, _) |\n             (&CEnum { non_zero: true, .. }, _) => Ok(Some((vec![], vec![]))),\n             (&FatPointer { non_zero: true, .. }, _) => {\n@@ -779,7 +790,7 @@ impl<'a, 'gcx, 'tcx> Struct {\n             (&Univariant { non_zero: true, .. }, &ty::TyAdt(def, substs)) => {\n                 let fields = &def.struct_variant().fields;\n                 assert_eq!(fields.len(), 1);\n-                match *fields[0].ty(tcx, substs).layout(infcx)? {\n+                match *fields[0].ty(tcx, substs).layout(tcx, param_env)? {\n                     // FIXME(eddyb) also allow floating-point types here.\n                     Scalar { value: Int(_), non_zero: false } |\n                     Scalar { value: Pointer, non_zero: false } => {\n@@ -796,37 +807,49 @@ impl<'a, 'gcx, 'tcx> Struct {\n             // Perhaps one of the fields of this struct is non-zero\n             // let's recurse and find out\n             (&Univariant { ref variant, .. }, &ty::TyAdt(def, substs)) if def.is_struct() => {\n-                Struct::non_zero_field_paths(infcx, def.struct_variant().fields\n-                                                      .iter().map(|field| {\n-                    field.ty(tcx, substs)\n-                }),\n-                Some(&variant.memory_index[..]))\n+                Struct::non_zero_field_paths(\n+                    tcx,\n+                    param_env,\n+                    def.struct_variant().fields.iter().map(|field| {\n+                        field.ty(tcx, substs)\n+                    }),\n+                    Some(&variant.memory_index[..]))\n             }\n \n             // Perhaps one of the upvars of this closure is non-zero\n             (&Univariant { ref variant, .. }, &ty::TyClosure(def, substs)) => {\n                 let upvar_tys = substs.upvar_tys(def, tcx);\n-                Struct::non_zero_field_paths(infcx, upvar_tys,\n+                Struct::non_zero_field_paths(\n+                    tcx,\n+                    param_env,\n+                    upvar_tys,\n                     Some(&variant.memory_index[..]))\n             }\n             // Can we use one of the fields in this tuple?\n             (&Univariant { ref variant, .. }, &ty::TyTuple(tys, _)) => {\n-                Struct::non_zero_field_paths(infcx, tys.iter().cloned(),\n+                Struct::non_zero_field_paths(\n+                    tcx,\n+                    param_env,\n+                    tys.iter().cloned(),\n                     Some(&variant.memory_index[..]))\n             }\n \n             // Is this a fixed-size array of something non-zero\n             // with at least one element?\n             (_, &ty::TyArray(ety, d)) if d > 0 => {\n-                Struct::non_zero_field_paths(infcx, Some(ety).into_iter(), None)\n+                Struct::non_zero_field_paths(\n+                    tcx,\n+                    param_env,\n+                    Some(ety).into_iter(),\n+                    None)\n             }\n \n             (_, &ty::TyProjection(_)) | (_, &ty::TyAnon(..)) => {\n-                let normalized = infcx.normalize_projections(ty);\n+                let normalized = tcx.normalize_associated_type_in_env(&ty, param_env);\n                 if ty == normalized {\n                     return Ok(None);\n                 }\n-                return Struct::non_zero_field_in_type(infcx, normalized);\n+                return Struct::non_zero_field_in_type(tcx, param_env, normalized);\n             }\n \n             // Anything else is not a non-zero type.\n@@ -838,13 +861,15 @@ impl<'a, 'gcx, 'tcx> Struct {\n     /// the given set of fields and recursing through aggregates.\n     /// Returns Some((path, source_path)) on success.\n     /// `path` is translated to memory order. `source_path` is not.\n-    fn non_zero_field_paths<I>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n-                                  fields: I,\n-                                  permutation: Option<&[u32]>)\n-                                  -> Result<Option<(FieldPath, FieldPath)>, LayoutError<'gcx>>\n-    where I: Iterator<Item=Ty<'gcx>> {\n+    fn non_zero_field_paths<I>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                               param_env: ty::ParamEnv<'tcx>,\n+                               fields: I,\n+                               permutation: Option<&[u32]>)\n+                               -> Result<Option<(FieldPath, FieldPath)>, LayoutError<'tcx>>\n+    where I: Iterator<Item=Ty<'tcx>> {\n         for (i, ty) in fields.enumerate() {\n-            if let Some((mut path, mut source_path)) = Struct::non_zero_field_in_type(infcx, ty)? {\n+            let r = Struct::non_zero_field_in_type(tcx, param_env, ty)?;\n+            if let Some((mut path, mut source_path)) = r {\n                 source_path.push(i as u32);\n                 let index = if let Some(p) = permutation {\n                     p[i] as usize\n@@ -881,7 +906,7 @@ pub struct Union {\n     pub packed: bool,\n }\n \n-impl<'a, 'gcx, 'tcx> Union {\n+impl<'a, 'tcx> Union {\n     fn new(dl: &TargetDataLayout, packed: bool) -> Union {\n         let align = if packed { dl.i8_align } else { dl.aggregate_align };\n         Union {\n@@ -895,9 +920,9 @@ impl<'a, 'gcx, 'tcx> Union {\n     /// Extend the Struct with more fields.\n     fn extend<I>(&mut self, dl: &TargetDataLayout,\n                  fields: I,\n-                 scapegoat: Ty<'gcx>)\n-                 -> Result<(), LayoutError<'gcx>>\n-    where I: Iterator<Item=Result<&'a Layout, LayoutError<'gcx>>> {\n+                 scapegoat: Ty<'tcx>)\n+                 -> Result<(), LayoutError<'tcx>>\n+    where I: Iterator<Item=Result<&'a Layout, LayoutError<'tcx>>> {\n         for (index, field) in fields.enumerate() {\n             let field = field?;\n             if field.is_unsized() {\n@@ -1067,19 +1092,19 @@ impl<'tcx> fmt::Display for LayoutError<'tcx> {\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> Layout {\n-    pub fn compute_uncached(ty: Ty<'gcx>,\n-                            infcx: &InferCtxt<'a, 'gcx, 'tcx>)\n-                            -> Result<&'gcx Layout, LayoutError<'gcx>> {\n-        let tcx = infcx.tcx.global_tcx();\n+impl<'a, 'tcx> Layout {\n+    pub fn compute_uncached(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                            param_env: ty::ParamEnv<'tcx>,\n+                            ty: Ty<'tcx>)\n+                            -> Result<&'tcx Layout, LayoutError<'tcx>> {\n         let success = |layout| Ok(tcx.intern_layout(layout));\n         let dl = &tcx.data_layout;\n         assert!(!ty.has_infer_types());\n \n-        let ptr_layout = |pointee: Ty<'gcx>| {\n+        let ptr_layout = |pointee: Ty<'tcx>| {\n             let non_zero = !ty.is_unsafe_ptr();\n-            let pointee = infcx.normalize_projections(pointee);\n-            if pointee.is_sized(tcx, infcx.param_env, DUMMY_SP) {\n+            let pointee = tcx.normalize_associated_type_in_env(&pointee, param_env);\n+            if pointee.is_sized(tcx, param_env, DUMMY_SP) {\n                 Ok(Scalar { value: Pointer, non_zero: non_zero })\n             } else {\n                 let unsized_part = tcx.struct_tail(pointee);\n@@ -1132,7 +1157,7 @@ impl<'a, 'gcx, 'tcx> Layout {\n \n             // Arrays and slices.\n             ty::TyArray(element, count) => {\n-                let element = element.layout(infcx)?;\n+                let element = element.layout(tcx, param_env)?;\n                 let element_size = element.size(dl);\n                 // FIXME(eddyb) Don't use host `usize` for array lengths.\n                 let usize_count: usize = count;\n@@ -1149,7 +1174,7 @@ impl<'a, 'gcx, 'tcx> Layout {\n                 }\n             }\n             ty::TySlice(element) => {\n-                let element = element.layout(infcx)?;\n+                let element = element.layout(tcx, param_env)?;\n                 Array {\n                     sized: false,\n                     align: element.align(dl),\n@@ -1187,7 +1212,7 @@ impl<'a, 'gcx, 'tcx> Layout {\n             ty::TyClosure(def_id, ref substs) => {\n                 let tys = substs.upvar_tys(def_id, tcx);\n                 let st = Struct::new(dl,\n-                    &tys.map(|ty| ty.layout(infcx))\n+                    &tys.map(|ty| ty.layout(tcx, param_env))\n                       .collect::<Result<Vec<_>, _>>()?,\n                     &ReprOptions::default(),\n                     StructKind::AlwaysSizedUnivariant, ty)?;\n@@ -1198,7 +1223,7 @@ impl<'a, 'gcx, 'tcx> Layout {\n                 // FIXME(camlorn): if we ever allow unsized tuples, this needs to be checked.\n                 // See the univariant case below to learn how.\n                 let st = Struct::new(dl,\n-                    &tys.iter().map(|ty| ty.layout(infcx))\n+                    &tys.iter().map(|ty| ty.layout(tcx, param_env))\n                       .collect::<Result<Vec<_>, _>>()?,\n                     &ReprOptions::default(), StructKind::AlwaysSizedUnivariant, ty)?;\n                 Univariant { variant: st, non_zero: false }\n@@ -1207,7 +1232,7 @@ impl<'a, 'gcx, 'tcx> Layout {\n             // SIMD vector types.\n             ty::TyAdt(def, ..) if def.repr.simd() => {\n                 let element = ty.simd_type(tcx);\n-                match *element.layout(infcx)? {\n+                match *element.layout(tcx, param_env)? {\n                     Scalar { value, .. } => {\n                         return success(Vector {\n                             element: value,\n@@ -1278,7 +1303,7 @@ impl<'a, 'gcx, 'tcx> Layout {\n                     };\n \n                     let fields = def.variants[0].fields.iter().map(|field| {\n-                        field.ty(tcx, substs).layout(infcx)\n+                        field.ty(tcx, substs).layout(tcx, param_env)\n                     }).collect::<Result<Vec<_>, _>>()?;\n                     let layout = if def.is_union() {\n                         let mut un = Union::new(dl, def.repr.packed());\n@@ -1312,20 +1337,21 @@ impl<'a, 'gcx, 'tcx> Layout {\n                     // Nullable pointer optimization\n                     for discr in 0..2 {\n                         let other_fields = variants[1 - discr].iter().map(|ty| {\n-                            ty.layout(infcx)\n+                            ty.layout(tcx, param_env)\n                         });\n                         if !Struct::would_be_zero_sized(dl, other_fields)? {\n                             continue;\n                         }\n-                        let paths = Struct::non_zero_field_paths(infcx,\n-                            variants[discr].iter().cloned(),\n-                            None)?;\n+                        let paths = Struct::non_zero_field_paths(tcx,\n+                                                                 param_env,\n+                                                                 variants[discr].iter().cloned(),\n+                                                                 None)?;\n                         let (mut path, mut path_source) = if let Some(p) = paths { p }\n                           else { continue };\n \n                         // FIXME(eddyb) should take advantage of a newtype.\n                         if path == &[0] && variants[discr].len() == 1 {\n-                            let value = match *variants[discr][0].layout(infcx)? {\n+                            let value = match *variants[discr][0].layout(tcx, param_env)? {\n                                 Scalar { value, .. } => value,\n                                 CEnum { discr, .. } => Int(discr),\n                                 _ => bug!(\"Layout::compute: `{}`'s non-zero \\\n@@ -1339,7 +1365,7 @@ impl<'a, 'gcx, 'tcx> Layout {\n                         }\n \n                         let st = Struct::new(dl,\n-                            &variants[discr].iter().map(|ty| ty.layout(infcx))\n+                            &variants[discr].iter().map(|ty| ty.layout(tcx, param_env))\n                               .collect::<Result<Vec<_>, _>>()?,\n                             &def.repr, StructKind::AlwaysSizedUnivariant, ty)?;\n \n@@ -1377,7 +1403,7 @@ impl<'a, 'gcx, 'tcx> Layout {\n                 let discr = Scalar { value: Int(min_ity), non_zero: false };\n                 let mut variants = variants.into_iter().map(|fields| {\n                     let mut fields = fields.into_iter().map(|field| {\n-                        field.layout(infcx)\n+                        field.layout(tcx, param_env)\n                     }).collect::<Result<Vec<_>, _>>()?;\n                     fields.insert(0, &discr);\n                     let st = Struct::new(dl,\n@@ -1470,11 +1496,11 @@ impl<'a, 'gcx, 'tcx> Layout {\n \n             // Types with no meaningful known layout.\n             ty::TyProjection(_) | ty::TyAnon(..) => {\n-                let normalized = infcx.normalize_projections(ty);\n+                let normalized = tcx.normalize_associated_type_in_env(&ty, param_env);\n                 if ty == normalized {\n                     return Err(LayoutError::Unknown(ty));\n                 }\n-                return normalized.layout(infcx);\n+                return normalized.layout(tcx, param_env);\n             }\n             ty::TyParam(_) => {\n                 return Err(LayoutError::Unknown(ty));\n@@ -1686,21 +1712,22 @@ pub enum SizeSkeleton<'tcx> {\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> SizeSkeleton<'gcx> {\n-    pub fn compute(ty: Ty<'gcx>, infcx: &InferCtxt<'a, 'gcx, 'tcx>)\n-                   -> Result<SizeSkeleton<'gcx>, LayoutError<'gcx>> {\n-        let tcx = infcx.tcx.global_tcx();\n+impl<'a, 'tcx> SizeSkeleton<'tcx> {\n+    pub fn compute(ty: Ty<'tcx>,\n+                   tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                   param_env: ty::ParamEnv<'tcx>)\n+                   -> Result<SizeSkeleton<'tcx>, LayoutError<'tcx>> {\n         assert!(!ty.has_infer_types());\n \n         // First try computing a static layout.\n-        let err = match ty.layout(infcx) {\n+        let err = match ty.layout(tcx, param_env) {\n             Ok(layout) => {\n                 return Ok(SizeSkeleton::Known(layout.size(tcx)));\n             }\n             Err(err) => err\n         };\n \n-        let ptr_skeleton = |pointee: Ty<'gcx>| {\n+        let ptr_skeleton = |pointee: Ty<'tcx>| {\n             let non_zero = !ty.is_unsafe_ptr();\n             let tail = tcx.struct_tail(pointee);\n             match tail.sty {\n@@ -1737,7 +1764,7 @@ impl<'a, 'gcx, 'tcx> SizeSkeleton<'gcx> {\n                 // Get a zero-sized variant or a pointer newtype.\n                 let zero_or_ptr_variant = |i: usize| {\n                     let fields = def.variants[i].fields.iter().map(|field| {\n-                        SizeSkeleton::compute(field.ty(tcx, substs), infcx)\n+                        SizeSkeleton::compute(field.ty(tcx, substs), tcx, param_env)\n                     });\n                     let mut ptr = None;\n                     for field in fields {\n@@ -1788,11 +1815,11 @@ impl<'a, 'gcx, 'tcx> SizeSkeleton<'gcx> {\n             }\n \n             ty::TyProjection(_) | ty::TyAnon(..) => {\n-                let normalized = infcx.normalize_projections(ty);\n+                let normalized = tcx.normalize_associated_type_in_env(&ty, param_env);\n                 if ty == normalized {\n                     Err(err)\n                 } else {\n-                    SizeSkeleton::compute(normalized, infcx)\n+                    SizeSkeleton::compute(normalized, tcx, param_env)\n                 }\n             }\n \n@@ -1826,71 +1853,53 @@ impl<'tcx> Deref for TyLayout<'tcx> {\n     }\n }\n \n-pub trait HasTyCtxt<'tcx>: HasDataLayout {\n+pub trait LayoutTyper<'tcx>: HasDataLayout {\n+    type TyLayout;\n+\n     fn tcx<'a>(&'a self) -> TyCtxt<'a, 'tcx, 'tcx>;\n+    fn layout_of(self, ty: Ty<'tcx>) -> Self::TyLayout;\n+    fn normalize_projections(self, ty: Ty<'tcx>) -> Ty<'tcx>;\n }\n \n-impl<'a, 'gcx, 'tcx> HasDataLayout for TyCtxt<'a, 'gcx, 'tcx> {\n-    fn data_layout(&self) -> &TargetDataLayout {\n-        &self.data_layout\n-    }\n+/// Combines a tcx with the parameter environment so that you can\n+/// compute layout operations.\n+#[derive(Copy, Clone)]\n+pub struct LayoutCx<'a, 'tcx: 'a> {\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n }\n \n-impl<'a, 'gcx, 'tcx> HasTyCtxt<'gcx> for TyCtxt<'a, 'gcx, 'tcx> {\n-    fn tcx<'b>(&'b self) -> TyCtxt<'b, 'gcx, 'gcx> {\n-        self.global_tcx()\n+impl<'a, 'tcx> LayoutCx<'a, 'tcx> {\n+    pub fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>, param_env: ty::ParamEnv<'tcx>) -> Self {\n+        LayoutCx { tcx, param_env }\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> HasDataLayout for &'a InferCtxt<'a, 'gcx, 'tcx> {\n+impl<'a, 'tcx> HasDataLayout for LayoutCx<'a, 'tcx> {\n     fn data_layout(&self) -> &TargetDataLayout {\n         &self.tcx.data_layout\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> HasTyCtxt<'gcx> for &'a InferCtxt<'a, 'gcx, 'tcx> {\n-    fn tcx<'b>(&'b self) -> TyCtxt<'b, 'gcx, 'gcx> {\n-        self.tcx.global_tcx()\n-    }\n-}\n-\n-pub trait LayoutTyper<'tcx>: HasTyCtxt<'tcx> {\n-    type TyLayout;\n-\n-    fn layout_of(self, ty: Ty<'tcx>) -> Self::TyLayout;\n-    fn normalize_projections(self, ty: Ty<'tcx>) -> Ty<'tcx>;\n-}\n+impl<'a, 'tcx> LayoutTyper<'tcx> for LayoutCx<'a, 'tcx> {\n+    type TyLayout = Result<TyLayout<'tcx>, LayoutError<'tcx>>;\n \n-impl<'a, 'gcx, 'tcx> LayoutTyper<'gcx> for &'a InferCtxt<'a, 'gcx, 'tcx> {\n-    type TyLayout = Result<TyLayout<'gcx>, LayoutError<'gcx>>;\n+    fn tcx<'b>(&'b self) -> TyCtxt<'b, 'tcx, 'tcx> {\n+        self.tcx\n+    }\n \n-    fn layout_of(self, ty: Ty<'gcx>) -> Self::TyLayout {\n+    fn layout_of(self, ty: Ty<'tcx>) -> Self::TyLayout {\n         let ty = self.normalize_projections(ty);\n \n         Ok(TyLayout {\n             ty: ty,\n-            layout: ty.layout(self)?,\n+            layout: ty.layout(self.tcx, self.param_env)?,\n             variant_index: None\n         })\n     }\n \n-    fn normalize_projections(self, ty: Ty<'gcx>) -> Ty<'gcx> {\n-        if !ty.has_projection_types() {\n-            return ty;\n-        }\n-\n-        let mut selcx = traits::SelectionContext::new(self);\n-        let cause = traits::ObligationCause::dummy();\n-        let traits::Normalized { value: result, obligations } =\n-            traits::normalize(&mut selcx, cause, &ty);\n-\n-        let mut fulfill_cx = traits::FulfillmentContext::new();\n-\n-        for obligation in obligations {\n-            fulfill_cx.register_predicate_obligation(self, obligation);\n-        }\n-\n-        self.drain_fulfillment_cx_or_panic(DUMMY_SP, &mut fulfill_cx, &result)\n+    fn normalize_projections(self, ty: Ty<'tcx>) -> Ty<'tcx> {\n+        self.tcx.normalize_associated_type_in_env(&ty, self.param_env)\n     }\n }\n \n@@ -1943,7 +1952,7 @@ impl<'a, 'tcx> TyLayout<'tcx> {\n         }\n     }\n \n-    pub fn field_type<C: HasTyCtxt<'tcx>>(&self, cx: C, i: usize) -> Ty<'tcx> {\n+    pub fn field_type<C: LayoutTyper<'tcx>>(&self, cx: C, i: usize) -> Ty<'tcx> {\n         let tcx = cx.tcx();\n \n         let ptr_field_type = |pointee: Ty<'tcx>| {\n@@ -2014,7 +2023,10 @@ impl<'a, 'tcx> TyLayout<'tcx> {\n         }\n     }\n \n-    pub fn field<C: LayoutTyper<'tcx>>(&self, cx: C, i: usize) -> C::TyLayout {\n+    pub fn field<C: LayoutTyper<'tcx>>(&self,\n+                                       cx: C,\n+                                       i: usize)\n+                                       -> C::TyLayout {\n         cx.layout_of(cx.normalize_projections(self.field_type(cx, i)))\n     }\n }"}, {"sha": "b5adcc8ed757d108435d8523d53af5ec62da60aa", "filename": "src/librustc/ty/maps.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/541523d10dce98dc266f6d4e6fb6131182c0f791/src%2Flibrustc%2Fty%2Fmaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/541523d10dce98dc266f6d4e6fb6131182c0f791/src%2Flibrustc%2Fty%2Fmaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps.rs?ref=541523d10dce98dc266f6d4e6fb6131182c0f791", "patch": "@@ -20,6 +20,7 @@ use mir::transform::{MirSuite, MirPassIndex};\n use session::CompileResult;\n use traits::specialization_graph;\n use ty::{self, CrateInherentImpls, Ty, TyCtxt};\n+use ty::layout::{Layout, LayoutError};\n use ty::item_path;\n use ty::steal::Steal;\n use ty::subst::Substs;\n@@ -293,6 +294,12 @@ impl<'tcx> QueryDescription for queries::needs_drop_raw<'tcx> {\n     }\n }\n \n+impl<'tcx> QueryDescription for queries::layout_raw<'tcx> {\n+    fn describe(_tcx: TyCtxt, env: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> String {\n+        format!(\"computing layout of `{}`\", env.value)\n+    }\n+}\n+\n impl<'tcx> QueryDescription for queries::super_predicates_of<'tcx> {\n     fn describe(tcx: TyCtxt, def_id: DefId) -> String {\n         format!(\"computing the supertraits of `{}`\",\n@@ -920,6 +927,8 @@ define_maps! { <'tcx>\n     [] is_sized_raw: is_sized_dep_node(ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool,\n     [] is_freeze_raw: is_freeze_dep_node(ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool,\n     [] needs_drop_raw: needs_drop_dep_node(ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool,\n+    [] layout_raw: layout_dep_node(ty::ParamEnvAnd<'tcx, Ty<'tcx>>)\n+                                  -> Result<&'tcx Layout, LayoutError<'tcx>>,\n }\n \n fn coherent_trait_dep_node((_, def_id): (CrateNum, DefId)) -> DepNode<DefId> {\n@@ -987,3 +996,9 @@ fn needs_drop_dep_node<'tcx>(key: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> DepNode<De\n         .unwrap_or(DefId::local(CRATE_DEF_INDEX));\n     DepNode::NeedsDrop(def_id)\n }\n+\n+fn layout_dep_node<'tcx>(key: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> DepNode<DefId> {\n+    let def_id = ty::item_path::characteristic_def_id_of_type(key.value)\n+        .unwrap_or(DefId::local(CRATE_DEF_INDEX));\n+    DepNode::Layout(def_id)\n+}"}, {"sha": "6d55f04e86aaaa9c448a2e393bf863c7747bdad7", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/541523d10dce98dc266f6d4e6fb6131182c0f791/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/541523d10dce98dc266f6d4e6fb6131182c0f791/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=541523d10dce98dc266f6d4e6fb6131182c0f791", "patch": "@@ -12,7 +12,6 @@\n \n use hir::def_id::{DefId, LOCAL_CRATE};\n use hir::map::DefPathData;\n-use infer::InferCtxt;\n use ich::{StableHashingContext, NodeIdHashingMode};\n use traits::{self, Reveal};\n use ty::{self, Ty, TyCtxt, TypeFoldable};\n@@ -791,35 +790,17 @@ impl<'a, 'tcx> ty::TyS<'tcx> {\n         tcx.needs_drop_raw(param_env.and(self))\n     }\n \n+    /// Computes the layout of a type. Note that this implicitly\n+    /// executes in \"reveal all\" mode.\n     #[inline]\n-    pub fn layout<'lcx>(&'tcx self, infcx: &InferCtxt<'a, 'tcx, 'lcx>)\n+    pub fn layout<'lcx>(&'tcx self,\n+                        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                        param_env: ty::ParamEnv<'tcx>)\n                         -> Result<&'tcx Layout, LayoutError<'tcx>> {\n-        let tcx = infcx.tcx.global_tcx();\n-        let can_cache = !self.has_param_types() && !self.has_self_ty();\n-        if can_cache {\n-            if let Some(&cached) = tcx.layout_cache.borrow().get(&self) {\n-                return Ok(cached);\n-            }\n-        }\n-\n-        let rec_limit = tcx.sess.recursion_limit.get();\n-        let depth = tcx.layout_depth.get();\n-        if depth > rec_limit {\n-            tcx.sess.fatal(\n-                &format!(\"overflow representing the type `{}`\", self));\n-        }\n-\n-        tcx.layout_depth.set(depth+1);\n-        let layout = Layout::compute_uncached(self, infcx);\n-        tcx.layout_depth.set(depth);\n-        let layout = layout?;\n-        if can_cache {\n-            tcx.layout_cache.borrow_mut().insert(self, layout);\n-        }\n-        Ok(layout)\n+        let ty = tcx.erase_regions(&self);\n+        tcx.layout_raw(param_env.reveal_all().and(ty))\n     }\n \n-\n     /// Check whether a type is representable. This means it cannot contain unboxed\n     /// structural recursion. This check is needed for structs and enums.\n     pub fn is_representable(&'tcx self,\n@@ -1074,13 +1055,32 @@ fn needs_drop_raw<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n }\n \n+fn layout_raw<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                        query: ty::ParamEnvAnd<'tcx, Ty<'tcx>>)\n+                        -> Result<&'tcx Layout, LayoutError<'tcx>>\n+{\n+    let (param_env, ty) = query.into_parts();\n+\n+    let rec_limit = tcx.sess.recursion_limit.get();\n+    let depth = tcx.layout_depth.get();\n+    if depth > rec_limit {\n+        tcx.sess.fatal(\n+            &format!(\"overflow representing the type `{}`\", ty));\n+    }\n+\n+    tcx.layout_depth.set(depth+1);\n+    let layout = Layout::compute_uncached(tcx, param_env, ty);\n+    tcx.layout_depth.set(depth);\n+    layout\n+}\n \n pub fn provide(providers: &mut ty::maps::Providers) {\n     *providers = ty::maps::Providers {\n         is_copy_raw,\n         is_sized_raw,\n         is_freeze_raw,\n         needs_drop_raw,\n+        layout_raw,\n         ..*providers\n     };\n }"}, {"sha": "3019165bfbf9a9343b424a861e485d8b481f6ad7", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/541523d10dce98dc266f6d4e6fb6131182c0f791/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/541523d10dce98dc266f6d4e6fb6131182c0f791/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=541523d10dce98dc266f6d4e6fb6131182c0f791", "patch": "@@ -14,7 +14,6 @@ use rustc::hir::def_id::DefId;\n use rustc::ty::subst::Substs;\n use rustc::ty::{self, AdtKind, Ty, TyCtxt};\n use rustc::ty::layout::{Layout, Primitive};\n-use rustc::traits::Reveal;\n use middle::const_val::ConstVal;\n use rustc_const_eval::ConstContext;\n use util::nodemap::FxHashSet;\n@@ -724,12 +723,12 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for VariantSizeDifferences {\n         if let hir::ItemEnum(ref enum_definition, ref gens) = it.node {\n             if gens.ty_params.is_empty() {\n                 // sizes only make sense for non-generic types\n-                let t = cx.tcx.type_of(cx.tcx.hir.local_def_id(it.id));\n-                let layout = cx.tcx.infer_ctxt(Reveal::All).enter(|infcx| {\n-                    let ty = cx.tcx.erase_regions(&t);\n-                    ty.layout(&infcx).unwrap_or_else(|e| {\n-                        bug!(\"failed to get layout for `{}`: {}\", t, e)\n-                    })\n+                let item_def_id = cx.tcx.hir.local_def_id(it.id);\n+                let t = cx.tcx.type_of(item_def_id);\n+                let param_env = cx.tcx.param_env(item_def_id).reveal_all();\n+                let ty = cx.tcx.erase_regions(&t);\n+                let layout = ty.layout(cx.tcx, param_env).unwrap_or_else(|e| {\n+                    bug!(\"failed to get layout for `{}`: {}\", t, e)\n                 });\n \n                 if let Layout::General { ref variants, ref size, discr, .. } = *layout {"}, {"sha": "0ac35a5fdd4722bd625317bfba4afe3e03643731", "filename": "src/librustc_mir/transform/inline.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/541523d10dce98dc266f6d4e6fb6131182c0f791/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/541523d10dce98dc266f6d4e6fb6131182c0f791/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finline.rs?ref=541523d10dce98dc266f6d4e6fb6131182c0f791", "patch": "@@ -547,10 +547,8 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n fn type_size_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                           param_env: ty::ParamEnv<'tcx>,\n                           ty: Ty<'tcx>) -> Option<u64> {\n-    tcx.infer_ctxt(param_env.reveal_all()).enter(|infcx| {\n-        ty.layout(&infcx).ok().map(|layout| {\n-            layout.size(&tcx.data_layout).bytes()\n-        })\n+    ty.layout(tcx, param_env).ok().map(|layout| {\n+        layout.size(&tcx.data_layout).bytes()\n     })\n }\n "}, {"sha": "1a13c8e6f3defaa432068bb9c3a611c410a13527", "filename": "src/librustc_trans/context.rs", "status": "modified", "additions": 18, "deletions": 28, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/541523d10dce98dc266f6d4e6fb6131182c0f791/src%2Flibrustc_trans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/541523d10dce98dc266f6d4e6fb6131182c0f791/src%2Flibrustc_trans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcontext.rs?ref=541523d10dce98dc266f6d4e6fb6131182c0f791", "patch": "@@ -25,10 +25,10 @@ use type_::Type;\n use rustc_data_structures::base_n;\n use rustc::ty::subst::Substs;\n use rustc::ty::{self, Ty, TyCtxt};\n-use rustc::ty::layout::{LayoutTyper, TyLayout};\n-use rustc::session::config::{self, NoDebugInfo};\n-use rustc::session::Session;\n-use rustc::util::nodemap::{NodeSet, DefIdMap, FxHashMap};\n+use rustc::ty::layout::{LayoutCx, LayoutError, LayoutTyper, TyLayout};\n+use session::config::{self, NoDebugInfo};\n+use session::Session;\n+use util::nodemap::{NodeSet, DefIdMap, FxHashMap};\n \n use std::ffi::{CStr, CString};\n use std::cell::{Cell, RefCell};\n@@ -709,41 +709,27 @@ impl<'a, 'tcx> ty::layout::HasDataLayout for &'a SharedCrateContext<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> ty::layout::HasTyCtxt<'tcx> for &'a SharedCrateContext<'a, 'tcx> {\n-    fn tcx<'b>(&'b self) -> TyCtxt<'b, 'tcx, 'tcx> {\n-        self.tcx\n-    }\n-}\n-\n impl<'a, 'tcx> ty::layout::HasDataLayout for &'a CrateContext<'a, 'tcx> {\n     fn data_layout(&self) -> &ty::layout::TargetDataLayout {\n         &self.shared.tcx.data_layout\n     }\n }\n \n-impl<'a, 'tcx> ty::layout::HasTyCtxt<'tcx> for &'a CrateContext<'a, 'tcx> {\n-    fn tcx<'b>(&'b self) -> TyCtxt<'b, 'tcx, 'tcx> {\n-        self.shared.tcx\n-    }\n-}\n-\n impl<'a, 'tcx> LayoutTyper<'tcx> for &'a SharedCrateContext<'a, 'tcx> {\n     type TyLayout = TyLayout<'tcx>;\n \n-    fn layout_of(self, ty: Ty<'tcx>) -> Self::TyLayout {\n-        if let Some(&layout) = self.tcx().layout_cache.borrow().get(&ty) {\n-            return TyLayout { ty: ty, layout: layout, variant_index: None };\n-        }\n+    fn tcx<'b>(&'b self) -> TyCtxt<'b, 'tcx, 'tcx> {\n+        self.tcx\n+    }\n \n-        self.tcx().infer_ctxt(traits::Reveal::All).enter(|infcx| {\n-            infcx.layout_of(ty).unwrap_or_else(|e| {\n-                match e {\n-                    ty::layout::LayoutError::SizeOverflow(_) =>\n-                        self.sess().fatal(&e.to_string()),\n-                    _ => bug!(\"failed to get layout for `{}`: {}\", ty, e)\n-                }\n+    fn layout_of(self, ty: Ty<'tcx>) -> Self::TyLayout {\n+        let param_env = ty::ParamEnv::empty(traits::Reveal::All);\n+        LayoutCx::new(self.tcx, param_env)\n+            .layout_of(ty)\n+            .unwrap_or_else(|e| match e {\n+                LayoutError::SizeOverflow(_) => self.sess().fatal(&e.to_string()),\n+                _ => bug!(\"failed to get layout for `{}`: {}\", ty, e)\n             })\n-        })\n     }\n \n     fn normalize_projections(self, ty: Ty<'tcx>) -> Ty<'tcx> {\n@@ -754,6 +740,10 @@ impl<'a, 'tcx> LayoutTyper<'tcx> for &'a SharedCrateContext<'a, 'tcx> {\n impl<'a, 'tcx> LayoutTyper<'tcx> for &'a CrateContext<'a, 'tcx> {\n     type TyLayout = TyLayout<'tcx>;\n \n+    fn tcx<'b>(&'b self) -> TyCtxt<'b, 'tcx, 'tcx> {\n+        self.shared.tcx\n+    }\n+\n     fn layout_of(self, ty: Ty<'tcx>) -> Self::TyLayout {\n         self.shared.layout_of(ty)\n     }"}, {"sha": "367f0398fa838848a1a1902a5a2131f4d6f8f868", "filename": "src/librustc_trans/glue.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/541523d10dce98dc266f6d4e6fb6131182c0f791/src%2Flibrustc_trans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/541523d10dce98dc266f6d4e6fb6131182c0f791/src%2Flibrustc_trans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fglue.rs?ref=541523d10dce98dc266f6d4e6fb6131182c0f791", "patch": "@@ -46,15 +46,13 @@ pub fn needs_drop_glue<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>, t: Ty<'tcx>\n         ty::TyAdt(def, _) if def.is_box() => {\n             let typ = t.boxed_ty();\n             if !scx.type_needs_drop(typ) && scx.type_is_sized(typ) {\n-                scx.tcx().infer_ctxt(traits::Reveal::All).enter(|infcx| {\n-                    let layout = t.layout(&infcx).unwrap();\n-                    if layout.size(scx).bytes() == 0 {\n-                        // `Box<ZeroSizeType>` does not allocate.\n-                        false\n-                    } else {\n-                        true\n-                    }\n-                })\n+                let layout = t.layout(scx.tcx(), ty::ParamEnv::empty(traits::Reveal::All)).unwrap();\n+                if layout.size(scx).bytes() == 0 {\n+                    // `Box<ZeroSizeType>` does not allocate.\n+                    false\n+                } else {\n+                    true\n+                }\n             } else {\n                 true\n             }"}]}