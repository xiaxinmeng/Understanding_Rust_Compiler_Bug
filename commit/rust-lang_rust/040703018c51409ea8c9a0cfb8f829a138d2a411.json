{"sha": "040703018c51409ea8c9a0cfb8f829a138d2a411", "node_id": "C_kwDOAAsO6NoAKDA0MDcwMzAxOGM1MTQwOWVhOGM5YTBjZmI4ZjgyOWExMzhkMmE0MTE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-03-15T10:52:32Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-03-15T10:52:32Z"}, "message": "Auto merge of #94261 - michaelwoerister:debuginfo-types-refactor, r=wesleywiser\n\ndebuginfo: Refactor debuginfo generation for types\n\nThis PR implements the refactoring of the `rustc_codegen_llvm::debuginfo::metadata` module as described in MCP https://github.com/rust-lang/compiler-team/issues/482.\n\nIn particular it\n- changes names to use `di_node` instead of `metadata`\n- uniformly names all functions that build new debuginfo nodes `build_xyz_di_node`\n- renames `CrateDebugContext` to `CodegenUnitDebugContext` (which is more accurate)\n- removes outdated parts from `compiler/rustc_codegen_llvm/src/debuginfo/doc.md`\n- moves `TypeMap` and functions that work directly work with it to a new `type_map` module\n- moves enum related builder functions to a new `enums` module\n- splits enum debuginfo building for the native and cpp-like cases, since they are mostly separate\n- uses `SmallVec` instead of `Vec` in many places\n- removes the old infrastructure for dealing with recursion cycles (`create_and_register_recursive_type_forward_declaration()`, `RecursiveTypeDescription`, `set_members_of_composite_type()`, `MemberDescription`, `MemberDescriptionFactory`, `prepare_xyz_metadata()`, etc)\n- adds `type_map::build_type_with_children()` as a replacement for dealing with recursion cycles\n- adds many (doc-)comments explaining what's going on\n- changes cpp-like naming for C-Style enums so they don't get a `enum$<...>` name (because the NatVis visualizer does not apply to them)\n- fixes detection of what is a C-style enum because some enums where classified as C-style even though they have fields\n- changes cpp-like naming for generator enums so that NatVis works for them\n- changes the position of discriminant debuginfo node so it is consistently nested inside the top-level union instead of, sometimes, next to it\n\nThe following could be done in subsequent PRs:\n- add caching for `closure_saved_names_of_captured_variables`\n- add caching for `generator_layout_and_saved_local_names`\n- fix inconsistent handling of what is considered a C-style enum wrt to debuginfo\n- rename `metadata` module to `types`\n- move common generator fields to front instead of appending them\n\nThis PR is based on https://github.com/rust-lang/rust/pull/93644 which is not merged yet.\n\nRight now, the changes are all done in one big commit. They could be split into smaller commits but hopefully the list of changes above makes it tractable to review them as a single commit too.\n\nFor now: r? `@ghost` (let's see if this affects compile times)", "tree": {"sha": "ff06562be82fd8cc0db38652629e7db98df14ffa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ff06562be82fd8cc0db38652629e7db98df14ffa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/040703018c51409ea8c9a0cfb8f829a138d2a411", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/040703018c51409ea8c9a0cfb8f829a138d2a411", "html_url": "https://github.com/rust-lang/rust/commit/040703018c51409ea8c9a0cfb8f829a138d2a411", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/040703018c51409ea8c9a0cfb8f829a138d2a411/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3ba1ebea122238d1a5c613deb1bf60ce24bd8fd8", "url": "https://api.github.com/repos/rust-lang/rust/commits/3ba1ebea122238d1a5c613deb1bf60ce24bd8fd8", "html_url": "https://github.com/rust-lang/rust/commit/3ba1ebea122238d1a5c613deb1bf60ce24bd8fd8"}, {"sha": "aa2408aa84cb3f758fbf572b1000ceea27fddb7f", "url": "https://api.github.com/repos/rust-lang/rust/commits/aa2408aa84cb3f758fbf572b1000ceea27fddb7f", "html_url": "https://github.com/rust-lang/rust/commit/aa2408aa84cb3f758fbf572b1000ceea27fddb7f"}], "stats": {"total": 4330, "additions": 2452, "deletions": 1878}, "files": [{"sha": "266759ed6cfa16e9d5d853340009b13a890aebb1", "filename": "compiler/rustc_codegen_gcc/src/debuginfo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/040703018c51409ea8c9a0cfb8f829a138d2a411/compiler%2Frustc_codegen_gcc%2Fsrc%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/040703018c51409ea8c9a0cfb8f829a138d2a411/compiler%2Frustc_codegen_gcc%2Fsrc%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fdebuginfo.rs?ref=040703018c51409ea8c9a0cfb8f829a138d2a411", "patch": "@@ -31,7 +31,7 @@ impl<'a, 'gcc, 'tcx> DebugInfoBuilderMethods for Builder<'a, 'gcc, 'tcx> {\n }\n \n impl<'gcc, 'tcx> DebugInfoMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n-    fn create_vtable_metadata(&self, _ty: Ty<'tcx>, _trait_ref: Option<PolyExistentialTraitRef<'tcx>>, _vtable: Self::Value) {\n+    fn create_vtable_debuginfo(&self, _ty: Ty<'tcx>, _trait_ref: Option<PolyExistentialTraitRef<'tcx>>, _vtable: Self::Value) {\n         // TODO(antoyo)\n     }\n "}, {"sha": "b647cfa5f4a6e999979966911798b2cb73d0a150", "filename": "compiler/rustc_codegen_llvm/src/allocator.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/040703018c51409ea8c9a0cfb8f829a138d2a411/compiler%2Frustc_codegen_llvm%2Fsrc%2Fallocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/040703018c51409ea8c9a0cfb8f829a138d2a411/compiler%2Frustc_codegen_llvm%2Fsrc%2Fallocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fallocator.rs?ref=040703018c51409ea8c9a0cfb8f829a138d2a411", "patch": "@@ -140,8 +140,8 @@ pub(crate) unsafe fn codegen(\n     llvm::LLVMDisposeBuilder(llbuilder);\n \n     if tcx.sess.opts.debuginfo != DebugInfo::None {\n-        let dbg_cx = debuginfo::CrateDebugContext::new(llmod);\n-        debuginfo::metadata::compile_unit_metadata(tcx, module_name, &dbg_cx);\n+        let dbg_cx = debuginfo::CodegenUnitDebugContext::new(llmod);\n+        debuginfo::metadata::build_compile_unit_di_node(tcx, module_name, &dbg_cx);\n         dbg_cx.finalize(tcx.sess);\n     }\n }"}, {"sha": "413ef0ba764642f3feafb20766e70deb580fbe0a", "filename": "compiler/rustc_codegen_llvm/src/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/040703018c51409ea8c9a0cfb8f829a138d2a411/compiler%2Frustc_codegen_llvm%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/040703018c51409ea8c9a0cfb8f829a138d2a411/compiler%2Frustc_codegen_llvm%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fconsts.rs?ref=040703018c51409ea8c9a0cfb8f829a138d2a411", "patch": "@@ -428,7 +428,7 @@ impl<'ll> StaticMethods for CodegenCx<'ll, '_> {\n                 llvm::LLVMSetGlobalConstant(g, llvm::True);\n             }\n \n-            debuginfo::create_global_var_metadata(self, def_id, g);\n+            debuginfo::build_global_var_di_node(self, def_id, g);\n \n             if attrs.flags.contains(CodegenFnAttrFlags::THREAD_LOCAL) {\n                 llvm::set_thread_local_mode(g, self.tls_model);"}, {"sha": "9fbc33d4b05d4075ee78819a52cb62b84a2f260c", "filename": "compiler/rustc_codegen_llvm/src/context.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/040703018c51409ea8c9a0cfb8f829a138d2a411/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/040703018c51409ea8c9a0cfb8f829a138d2a411/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs?ref=040703018c51409ea8c9a0cfb8f829a138d2a411", "patch": "@@ -95,7 +95,7 @@ pub struct CodegenCx<'ll, 'tcx> {\n     pub isize_ty: &'ll Type,\n \n     pub coverage_cx: Option<coverageinfo::CrateCoverageContext<'ll, 'tcx>>,\n-    pub dbg_cx: Option<debuginfo::CrateDebugContext<'ll, 'tcx>>,\n+    pub dbg_cx: Option<debuginfo::CodegenUnitDebugContext<'ll, 'tcx>>,\n \n     eh_personality: Cell<Option<&'ll Value>>,\n     eh_catch_typeinfo: Cell<Option<&'ll Value>>,\n@@ -396,8 +396,12 @@ impl<'ll, 'tcx> CodegenCx<'ll, 'tcx> {\n         };\n \n         let dbg_cx = if tcx.sess.opts.debuginfo != DebugInfo::None {\n-            let dctx = debuginfo::CrateDebugContext::new(llmod);\n-            debuginfo::metadata::compile_unit_metadata(tcx, codegen_unit.name().as_str(), &dctx);\n+            let dctx = debuginfo::CodegenUnitDebugContext::new(llmod);\n+            debuginfo::metadata::build_compile_unit_di_node(\n+                tcx,\n+                codegen_unit.name().as_str(),\n+                &dctx,\n+            );\n             Some(dctx)\n         } else {\n             None"}, {"sha": "5a8976c61662b3d3a4983f15cd9d5657f86d11e1", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/doc.md", "status": "modified", "additions": 4, "deletions": 53, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/040703018c51409ea8c9a0cfb8f829a138d2a411/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fdoc.md", "raw_url": "https://github.com/rust-lang/rust/raw/040703018c51409ea8c9a0cfb8f829a138d2a411/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fdoc.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fdoc.md?ref=040703018c51409ea8c9a0cfb8f829a138d2a411", "patch": "@@ -34,7 +34,7 @@ The function will take care of probing the cache for an existing node for\n that exact file path.\n \n All private state used by the module is stored within either the\n-CrateDebugContext struct (owned by the CodegenCx) or the\n+CodegenUnitDebugContext struct (owned by the CodegenCx) or the\n FunctionDebugContext (owned by the FunctionCx).\n \n This file consists of three conceptual sections:\n@@ -72,21 +72,16 @@ describe(t = List)\n       ...\n ```\n \n-To break cycles like these, we use \"forward declarations\". That is, when\n+To break cycles like these, we use \"stubs\". That is, when\n the algorithm encounters a possibly recursive type (any struct or enum), it\n immediately creates a type description node and inserts it into the cache\n *before* describing the members of the type. This type description is just\n a stub (as type members are not described and added to it yet) but it\n allows the algorithm to already refer to the type. After the stub is\n inserted into the cache, the algorithm continues as before. If it now\n encounters a recursive reference, it will hit the cache and does not try to\n-describe the type anew.\n-\n-This behavior is encapsulated in the 'RecursiveTypeDescription' enum,\n-which represents a kind of continuation, storing all state needed to\n-continue traversal at the type members after the type has been registered\n-with the cache. (This implementation approach might be a tad over-\n-engineered and may change in the future)\n+describe the type anew. This behavior is encapsulated in the\n+`type_map::build_type_with_children()` function.\n \n \n ## Source Locations and Line Information\n@@ -134,47 +129,3 @@ detection. The `create_argument_metadata()` and related functions take care\n of linking the `llvm.dbg.declare` instructions to the correct source\n locations even while source location emission is still disabled, so there\n is no need to do anything special with source location handling here.\n-\n-## Unique Type Identification\n-\n-In order for link-time optimization to work properly, LLVM needs a unique\n-type identifier that tells it across compilation units which types are the\n-same as others. This type identifier is created by\n-`TypeMap::get_unique_type_id_of_type()` using the following algorithm:\n-\n-1. Primitive types have their name as ID\n-\n-2. Structs, enums and traits have a multipart identifier\n-\n-  1. The first part is the SVH (strict version hash) of the crate they\n-     were originally defined in\n-\n-  2. The second part is the ast::NodeId of the definition in their\n-     original crate\n-\n-  3. The final part is a concatenation of the type IDs of their concrete\n-     type arguments if they are generic types.\n-\n-3. Tuple-, pointer-, and function types are structurally identified, which\n-   means that they are equivalent if their component types are equivalent\n-   (i.e., `(i32, i32)` is the same regardless in which crate it is used).\n-\n-This algorithm also provides a stable ID for types that are defined in one\n-crate but instantiated from metadata within another crate. We just have to\n-take care to always map crate and `NodeId`s back to the original crate\n-context.\n-\n-As a side-effect these unique type IDs also help to solve a problem arising\n-from lifetime parameters. Since lifetime parameters are completely omitted\n-in debuginfo, more than one `Ty` instance may map to the same debuginfo\n-type metadata, that is, some struct `Struct<'a>` may have N instantiations\n-with different concrete substitutions for `'a`, and thus there will be N\n-`Ty` instances for the type `Struct<'a>` even though it is not generic\n-otherwise. Unfortunately this means that we cannot use `ty::type_id()` as\n-cheap identifier for type metadata -- we have done this in the past, but it\n-led to unnecessary metadata duplication in the best case and LLVM\n-assertions in the worst. However, the unique type ID as described above\n-*can* be used as identifier. Since it is comparatively expensive to\n-construct, though, `ty::type_id()` is still used additionally as an\n-optimization for cases where the exact same type has been seen before\n-(which is most of the time)."}, {"sha": "f02c7b2d2e11ab8b39b47f97593b2c17f0351dbc", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/metadata.rs", "status": "modified", "additions": 538, "deletions": 1698, "changes": 2236, "blob_url": "https://github.com/rust-lang/rust/blob/040703018c51409ea8c9a0cfb8f829a138d2a411/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/040703018c51409ea8c9a0cfb8f829a138d2a411/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs?ref=040703018c51409ea8c9a0cfb8f829a138d2a411"}, {"sha": "e9772cd78d7626de9aaad652f44eca00c2488ada", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/metadata/enums/cpp_like.rs", "status": "added", "additions": 515, "deletions": 0, "changes": 515, "blob_url": "https://github.com/rust-lang/rust/blob/040703018c51409ea8c9a0cfb8f829a138d2a411/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata%2Fenums%2Fcpp_like.rs", "raw_url": "https://github.com/rust-lang/rust/raw/040703018c51409ea8c9a0cfb8f829a138d2a411/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata%2Fenums%2Fcpp_like.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata%2Fenums%2Fcpp_like.rs?ref=040703018c51409ea8c9a0cfb8f829a138d2a411", "patch": "@@ -0,0 +1,515 @@\n+use std::borrow::Cow;\n+\n+use libc::c_uint;\n+use rustc_codegen_ssa::debuginfo::{\n+    type_names::compute_debuginfo_type_name, wants_c_like_enum_debuginfo,\n+};\n+use rustc_middle::{\n+    bug,\n+    ty::{\n+        self,\n+        layout::{LayoutOf, TyAndLayout},\n+        util::Discr,\n+        AdtDef, GeneratorSubsts,\n+    },\n+};\n+use rustc_target::abi::{Size, TagEncoding, VariantIdx, Variants};\n+use smallvec::smallvec;\n+\n+use crate::{\n+    common::CodegenCx,\n+    debuginfo::{\n+        metadata::{\n+            build_field_di_node, closure_saved_names_of_captured_variables,\n+            enums::tag_base_type,\n+            file_metadata, generator_layout_and_saved_local_names, size_and_align_of,\n+            type_map::{self, UniqueTypeId},\n+            unknown_file_metadata, DINodeCreationResult, SmallVec, NO_GENERICS, NO_SCOPE_METADATA,\n+            UNKNOWN_LINE_NUMBER,\n+        },\n+        utils::DIB,\n+    },\n+    llvm::{\n+        self,\n+        debuginfo::{DIFile, DIFlags, DIType},\n+    },\n+};\n+\n+/// In CPP-like mode, we generate a union of structs for each variant and an\n+/// explicit discriminant field roughly equivalent to the following C/C++ code:\n+///\n+/// ```c\n+/// union enum$<{fully-qualified-name}> {\n+///   struct {variant 0 name} {\n+///     <variant 0 fields>\n+///   } variant0;\n+///   <other variant structs>\n+///   {name} discriminant;\n+/// }\n+/// ```\n+///\n+/// As you can see, the type name is wrapped `enum$`. This way we can have a\n+/// single NatVis rule for handling all enums.\n+///\n+/// At the LLVM IR level this looks like\n+///\n+/// ```txt\n+///       DW_TAG_union_type              (top-level type for enum)\n+///         DW_TAG_member                    (member for variant 1)\n+///         DW_TAG_member                    (member for variant 2)\n+///         DW_TAG_member                    (member for variant 3)\n+///         DW_TAG_structure_type            (type of variant 1)\n+///         DW_TAG_structure_type            (type of variant 2)\n+///         DW_TAG_structure_type            (type of variant 3)\n+///         DW_TAG_enumeration_type          (type of tag)\n+/// ```\n+///\n+/// The above encoding applies for enums with a direct tag. For niche-tag we have to do things\n+/// differently in order to allow a NatVis visualizer to extract all the information needed:\n+/// We generate a union of two fields, one for the dataful variant\n+/// and one that just points to the discriminant (which is some field within the dataful variant).\n+/// We also create a DW_TAG_enumeration_type DIE that contains tag values for the non-dataful\n+/// variants and make the discriminant field that type. We then use NatVis to render the enum type\n+/// correctly in Windbg/VS. This will generate debuginfo roughly equivalent to the following C:\n+///\n+/// ```c\n+/// union enum$<{name}, {min niche}, {max niche}, {dataful variant name}> {\n+///   struct <dataful variant name> {\n+///     <fields in dataful variant>\n+///   } dataful_variant;\n+///   enum Discriminant$ {\n+///     <non-dataful variants>\n+///   } discriminant;\n+/// }\n+/// ```\n+///\n+/// The NatVis in `intrinsic.natvis` matches on the type name `enum$<*, *, *, *>`\n+/// and evaluates `this.discriminant`. If the value is between the min niche and max\n+/// niche, then the enum is in the dataful variant and `this.dataful_variant` is\n+/// rendered. Otherwise, the enum is in one of the non-dataful variants. In that\n+/// case, we just need to render the name of the `this.discriminant` enum.\n+pub(super) fn build_enum_type_di_node<'ll, 'tcx>(\n+    cx: &CodegenCx<'ll, 'tcx>,\n+    unique_type_id: UniqueTypeId<'tcx>,\n+) -> DINodeCreationResult<'ll> {\n+    let enum_type = unique_type_id.expect_ty();\n+    let &ty::Adt(enum_adt_def, _) = enum_type.kind() else {\n+        bug!(\"build_enum_type_di_node() called with non-enum type: `{:?}`\", enum_type)\n+        };\n+\n+    let enum_type_and_layout = cx.layout_of(enum_type);\n+    let enum_type_name = compute_debuginfo_type_name(cx.tcx, enum_type, false);\n+\n+    debug_assert!(!wants_c_like_enum_debuginfo(enum_type_and_layout));\n+\n+    type_map::build_type_with_children(\n+        cx,\n+        type_map::stub(\n+            cx,\n+            type_map::Stub::Union,\n+            unique_type_id,\n+            &enum_type_name,\n+            cx.size_and_align_of(enum_type),\n+            NO_SCOPE_METADATA,\n+            DIFlags::FlagZero,\n+        ),\n+        |cx, enum_type_di_node| {\n+            match enum_type_and_layout.variants {\n+                Variants::Single { index: variant_index } => {\n+                    if enum_adt_def.variants().is_empty() {\n+                        // Uninhabited enums have Variants::Single. We don't generate\n+                        // any members for them.\n+                        return smallvec![];\n+                    }\n+\n+                    build_single_variant_union_fields(\n+                        cx,\n+                        enum_adt_def,\n+                        enum_type_and_layout,\n+                        enum_type_di_node,\n+                        variant_index,\n+                    )\n+                }\n+                Variants::Multiple {\n+                    tag_encoding: TagEncoding::Direct,\n+                    ref variants,\n+                    tag_field,\n+                    ..\n+                } => build_union_fields_for_direct_tag_enum(\n+                    cx,\n+                    enum_adt_def,\n+                    enum_type_and_layout,\n+                    enum_type_di_node,\n+                    &mut variants.indices(),\n+                    tag_field,\n+                ),\n+                Variants::Multiple {\n+                    tag_encoding: TagEncoding::Niche { dataful_variant, .. },\n+                    ref variants,\n+                    tag_field,\n+                    ..\n+                } => build_union_fields_for_niche_tag_enum(\n+                    cx,\n+                    enum_adt_def,\n+                    enum_type_and_layout,\n+                    enum_type_di_node,\n+                    dataful_variant,\n+                    &mut variants.indices(),\n+                    tag_field,\n+                ),\n+            }\n+        },\n+        NO_GENERICS,\n+    )\n+}\n+\n+/// A generator debuginfo node looks the same as a that of an enum type.\n+///\n+/// See [build_enum_type_di_node] for more information.\n+pub(super) fn build_generator_di_node<'ll, 'tcx>(\n+    cx: &CodegenCx<'ll, 'tcx>,\n+    unique_type_id: UniqueTypeId<'tcx>,\n+) -> DINodeCreationResult<'ll> {\n+    let generator_type = unique_type_id.expect_ty();\n+    let generator_type_and_layout = cx.layout_of(generator_type);\n+    let generator_type_name = compute_debuginfo_type_name(cx.tcx, generator_type, false);\n+\n+    debug_assert!(!wants_c_like_enum_debuginfo(generator_type_and_layout));\n+\n+    type_map::build_type_with_children(\n+        cx,\n+        type_map::stub(\n+            cx,\n+            type_map::Stub::Union,\n+            unique_type_id,\n+            &generator_type_name,\n+            size_and_align_of(generator_type_and_layout),\n+            NO_SCOPE_METADATA,\n+            DIFlags::FlagZero,\n+        ),\n+        |cx, generator_type_di_node| match generator_type_and_layout.variants {\n+            Variants::Multiple { tag_encoding: TagEncoding::Direct, .. } => {\n+                build_union_fields_for_direct_tag_generator(\n+                    cx,\n+                    generator_type_and_layout,\n+                    generator_type_di_node,\n+                )\n+            }\n+            Variants::Single { .. }\n+            | Variants::Multiple { tag_encoding: TagEncoding::Niche { .. }, .. } => {\n+                bug!(\n+                    \"Encountered generator with non-direct-tag layout: {:?}\",\n+                    generator_type_and_layout\n+                )\n+            }\n+        },\n+        NO_GENERICS,\n+    )\n+}\n+\n+fn build_single_variant_union_fields<'ll, 'tcx>(\n+    cx: &CodegenCx<'ll, 'tcx>,\n+    enum_adt_def: AdtDef<'tcx>,\n+    enum_type_and_layout: TyAndLayout<'tcx>,\n+    enum_type_di_node: &'ll DIType,\n+    variant_index: VariantIdx,\n+) -> SmallVec<&'ll DIType> {\n+    let variant_layout = enum_type_and_layout.for_variant(cx, variant_index);\n+    let variant_struct_type_di_node = super::build_enum_variant_struct_type_di_node(\n+        cx,\n+        enum_type_and_layout.ty,\n+        enum_type_di_node,\n+        variant_index,\n+        enum_adt_def.variant(variant_index),\n+        variant_layout,\n+    );\n+\n+    // NOTE: The field name of the union is the same as the variant name, not \"variant0\".\n+    let variant_name = enum_adt_def.variant(variant_index).name.as_str();\n+\n+    smallvec![build_field_di_node(\n+        cx,\n+        enum_type_di_node,\n+        variant_name,\n+        // NOTE: We use the size and align of the entire type, not from variant_layout\n+        //       since the later is sometimes smaller (if it has fewer fields).\n+        size_and_align_of(enum_type_and_layout),\n+        Size::ZERO,\n+        DIFlags::FlagZero,\n+        variant_struct_type_di_node,\n+    )]\n+}\n+\n+fn build_union_fields_for_direct_tag_enum<'ll, 'tcx>(\n+    cx: &CodegenCx<'ll, 'tcx>,\n+    enum_adt_def: AdtDef<'tcx>,\n+    enum_type_and_layout: TyAndLayout<'tcx>,\n+    enum_type_di_node: &'ll DIType,\n+    variant_indices: &mut dyn Iterator<Item = VariantIdx>,\n+    tag_field: usize,\n+) -> SmallVec<&'ll DIType> {\n+    let variant_field_infos: SmallVec<VariantFieldInfo<'ll>> = variant_indices\n+        .map(|variant_index| {\n+            let variant_layout = enum_type_and_layout.for_variant(cx, variant_index);\n+\n+            VariantFieldInfo {\n+                variant_index,\n+                variant_struct_type_di_node: super::build_enum_variant_struct_type_di_node(\n+                    cx,\n+                    enum_type_and_layout.ty,\n+                    enum_type_di_node,\n+                    variant_index,\n+                    enum_adt_def.variant(variant_index),\n+                    variant_layout,\n+                ),\n+                source_info: None,\n+            }\n+        })\n+        .collect();\n+\n+    let discr_type_name = cx.tcx.item_name(enum_adt_def.did());\n+    let tag_base_type = super::tag_base_type(cx, enum_type_and_layout);\n+    let discr_type_di_node = super::build_enumeration_type_di_node(\n+        cx,\n+        discr_type_name.as_str(),\n+        tag_base_type,\n+        &mut enum_adt_def.discriminants(cx.tcx).map(|(variant_index, discr)| {\n+            (discr, Cow::from(enum_adt_def.variant(variant_index).name.as_str()))\n+        }),\n+        enum_type_di_node,\n+    );\n+\n+    build_union_fields_for_direct_tag_enum_or_generator(\n+        cx,\n+        enum_type_and_layout,\n+        enum_type_di_node,\n+        &variant_field_infos,\n+        discr_type_di_node,\n+        tag_field,\n+    )\n+}\n+\n+fn build_union_fields_for_niche_tag_enum<'ll, 'tcx>(\n+    cx: &CodegenCx<'ll, 'tcx>,\n+    enum_adt_def: AdtDef<'tcx>,\n+    enum_type_and_layout: TyAndLayout<'tcx>,\n+    enum_type_di_node: &'ll DIType,\n+    dataful_variant_index: VariantIdx,\n+    variant_indices: &mut dyn Iterator<Item = VariantIdx>,\n+    tag_field: usize,\n+) -> SmallVec<&'ll DIType> {\n+    let dataful_variant_struct_type_di_node = super::build_enum_variant_struct_type_di_node(\n+        cx,\n+        enum_type_and_layout.ty,\n+        enum_type_di_node,\n+        dataful_variant_index,\n+        &enum_adt_def.variant(dataful_variant_index),\n+        enum_type_and_layout.for_variant(cx, dataful_variant_index),\n+    );\n+\n+    let tag_base_type = super::tag_base_type(cx, enum_type_and_layout);\n+    // Create an DW_TAG_enumerator for each variant except the dataful one.\n+    let discr_type_di_node = super::build_enumeration_type_di_node(\n+        cx,\n+        \"Discriminant$\",\n+        tag_base_type,\n+        &mut variant_indices.filter_map(|variant_index| {\n+            if let Some(discr_val) =\n+                super::compute_discriminant_value(cx, enum_type_and_layout, variant_index)\n+            {\n+                let discr = Discr { val: discr_val as u128, ty: tag_base_type };\n+                let variant_name = Cow::from(enum_adt_def.variant(variant_index).name.as_str());\n+                Some((discr, variant_name))\n+            } else {\n+                debug_assert_eq!(variant_index, dataful_variant_index);\n+                None\n+            }\n+        }),\n+        enum_type_di_node,\n+    );\n+\n+    smallvec![\n+        build_field_di_node(\n+            cx,\n+            enum_type_di_node,\n+            \"dataful_variant\",\n+            size_and_align_of(enum_type_and_layout),\n+            Size::ZERO,\n+            DIFlags::FlagZero,\n+            dataful_variant_struct_type_di_node,\n+        ),\n+        build_field_di_node(\n+            cx,\n+            enum_type_di_node,\n+            \"discriminant\",\n+            cx.size_and_align_of(tag_base_type),\n+            enum_type_and_layout.fields.offset(tag_field),\n+            DIFlags::FlagZero,\n+            discr_type_di_node,\n+        ),\n+    ]\n+}\n+\n+fn build_union_fields_for_direct_tag_generator<'ll, 'tcx>(\n+    cx: &CodegenCx<'ll, 'tcx>,\n+    generator_type_and_layout: TyAndLayout<'tcx>,\n+    generator_type_di_node: &'ll DIType,\n+) -> SmallVec<&'ll DIType> {\n+    let Variants::Multiple { tag_encoding: TagEncoding::Direct, tag_field, .. } = generator_type_and_layout.variants else {\n+        bug!(\"This function only supports layouts with direcly encoded tags.\")\n+    };\n+\n+    let (generator_def_id, generator_substs) = match generator_type_and_layout.ty.kind() {\n+        &ty::Generator(def_id, substs, _) => (def_id, substs.as_generator()),\n+        _ => unreachable!(),\n+    };\n+\n+    let (generator_layout, state_specific_upvar_names) =\n+        generator_layout_and_saved_local_names(cx.tcx, generator_def_id);\n+\n+    let common_upvar_names = closure_saved_names_of_captured_variables(cx.tcx, generator_def_id);\n+    let variant_range = generator_substs.variant_range(generator_def_id, cx.tcx);\n+\n+    // Build the type node for each field.\n+    let variant_field_infos: SmallVec<VariantFieldInfo<'ll>> = variant_range\n+        .clone()\n+        .map(|variant_index| {\n+            let variant_struct_type_di_node = super::build_generator_variant_struct_type_di_node(\n+                cx,\n+                variant_index,\n+                generator_type_and_layout,\n+                generator_type_di_node,\n+                generator_layout,\n+                &state_specific_upvar_names,\n+                &common_upvar_names,\n+            );\n+\n+            let span = generator_layout.variant_source_info[variant_index].span;\n+            let source_info = if !span.is_dummy() {\n+                let loc = cx.lookup_debug_loc(span.lo());\n+                Some((file_metadata(cx, &loc.file), loc.line as c_uint))\n+            } else {\n+                None\n+            };\n+\n+            VariantFieldInfo { variant_index, variant_struct_type_di_node, source_info }\n+        })\n+        .collect();\n+\n+    let tag_base_type = tag_base_type(cx, generator_type_and_layout);\n+    let discr_type_name = \"Discriminant$\";\n+    let discr_type_di_node = super::build_enumeration_type_di_node(\n+        cx,\n+        discr_type_name,\n+        tag_base_type,\n+        &mut generator_substs\n+            .discriminants(generator_def_id, cx.tcx)\n+            .map(|(variant_index, discr)| (discr, GeneratorSubsts::variant_name(variant_index))),\n+        generator_type_di_node,\n+    );\n+\n+    build_union_fields_for_direct_tag_enum_or_generator(\n+        cx,\n+        generator_type_and_layout,\n+        generator_type_di_node,\n+        &variant_field_infos[..],\n+        discr_type_di_node,\n+        tag_field,\n+    )\n+}\n+\n+/// This is a helper function shared between enums and generators that makes sure fields have the\n+/// expect names.\n+fn build_union_fields_for_direct_tag_enum_or_generator<'ll, 'tcx>(\n+    cx: &CodegenCx<'ll, 'tcx>,\n+    enum_type_and_layout: TyAndLayout<'tcx>,\n+    enum_type_di_node: &'ll DIType,\n+    variant_field_infos: &[VariantFieldInfo<'ll>],\n+    discr_type_di_node: &'ll DIType,\n+    tag_field: usize,\n+) -> SmallVec<&'ll DIType> {\n+    let mut unions_fields = SmallVec::with_capacity(variant_field_infos.len() + 1);\n+\n+    // We create a field in the union for each variant ...\n+    unions_fields.extend(variant_field_infos.into_iter().map(|variant_member_info| {\n+        let (file_di_node, line_number) = variant_member_info\n+            .source_info\n+            .unwrap_or_else(|| (unknown_file_metadata(cx), UNKNOWN_LINE_NUMBER));\n+\n+        let field_name = variant_union_field_name(variant_member_info.variant_index);\n+        let (size, align) = size_and_align_of(enum_type_and_layout);\n+\n+        // We use LLVMRustDIBuilderCreateMemberType() member type directly because\n+        // the build_field_di_node() function does not support specifying a source location,\n+        // which is something that we don't do anywhere else.\n+        unsafe {\n+            llvm::LLVMRustDIBuilderCreateMemberType(\n+                DIB(cx),\n+                enum_type_di_node,\n+                field_name.as_ptr().cast(),\n+                field_name.len(),\n+                file_di_node,\n+                line_number,\n+                // NOTE: We use the size and align of the entire type, not from variant_layout\n+                //       since the later is sometimes smaller (if it has fewer fields).\n+                size.bits(),\n+                align.bits() as u32,\n+                // Union fields are always at offset zero\n+                Size::ZERO.bits(),\n+                DIFlags::FlagZero,\n+                variant_member_info.variant_struct_type_di_node,\n+            )\n+        }\n+    }));\n+\n+    debug_assert_eq!(\n+        cx.size_and_align_of(enum_type_and_layout.field(cx, tag_field).ty),\n+        cx.size_and_align_of(super::tag_base_type(cx, enum_type_and_layout))\n+    );\n+\n+    // ... and a field for the discriminant.\n+    unions_fields.push(build_field_di_node(\n+        cx,\n+        enum_type_di_node,\n+        \"discriminant\",\n+        cx.size_and_align_of(enum_type_and_layout.field(cx, tag_field).ty),\n+        enum_type_and_layout.fields.offset(tag_field),\n+        DIFlags::FlagZero,\n+        discr_type_di_node,\n+    ));\n+\n+    unions_fields\n+}\n+\n+/// Information about a single field of the top-level DW_TAG_union_type.\n+struct VariantFieldInfo<'ll> {\n+    variant_index: VariantIdx,\n+    variant_struct_type_di_node: &'ll DIType,\n+    source_info: Option<(&'ll DIFile, c_uint)>,\n+}\n+\n+fn variant_union_field_name(variant_index: VariantIdx) -> Cow<'static, str> {\n+    const PRE_ALLOCATED: [&str; 16] = [\n+        \"variant0\",\n+        \"variant1\",\n+        \"variant2\",\n+        \"variant3\",\n+        \"variant4\",\n+        \"variant5\",\n+        \"variant6\",\n+        \"variant7\",\n+        \"variant8\",\n+        \"variant9\",\n+        \"variant10\",\n+        \"variant11\",\n+        \"variant12\",\n+        \"variant13\",\n+        \"variant14\",\n+        \"variant15\",\n+    ];\n+\n+    PRE_ALLOCATED\n+        .get(variant_index.as_usize())\n+        .map(|&s| Cow::from(s))\n+        .unwrap_or_else(|| format!(\"variant{}\", variant_index.as_usize()).into())\n+}"}, {"sha": "1eafa9501c47f928ff2422410be16baf7c001415", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/metadata/enums/mod.rs", "status": "added", "additions": 437, "deletions": 0, "changes": 437, "blob_url": "https://github.com/rust-lang/rust/blob/040703018c51409ea8c9a0cfb8f829a138d2a411/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata%2Fenums%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/040703018c51409ea8c9a0cfb8f829a138d2a411/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata%2Fenums%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata%2Fenums%2Fmod.rs?ref=040703018c51409ea8c9a0cfb8f829a138d2a411", "patch": "@@ -0,0 +1,437 @@\n+use rustc_codegen_ssa::debuginfo::{\n+    type_names::{compute_debuginfo_type_name, cpp_like_debuginfo},\n+    wants_c_like_enum_debuginfo,\n+};\n+use rustc_hir::def::CtorKind;\n+use rustc_index::vec::IndexVec;\n+use rustc_middle::{\n+    bug,\n+    mir::{Field, GeneratorLayout, GeneratorSavedLocal},\n+    ty::{\n+        self,\n+        layout::{IntegerExt, LayoutOf, PrimitiveExt, TyAndLayout},\n+        util::Discr,\n+        AdtDef, GeneratorSubsts, Ty, VariantDef,\n+    },\n+};\n+use rustc_span::Symbol;\n+use rustc_target::abi::{HasDataLayout, Integer, Primitive, TagEncoding, VariantIdx, Variants};\n+use std::borrow::Cow;\n+\n+use crate::{\n+    common::CodegenCx,\n+    debuginfo::{\n+        metadata::{\n+            build_field_di_node, build_generic_type_param_di_nodes, type_di_node,\n+            type_map::{self, Stub},\n+            unknown_file_metadata, UNKNOWN_LINE_NUMBER,\n+        },\n+        utils::{create_DIArray, get_namespace_for_item, DIB},\n+    },\n+    llvm::{\n+        self,\n+        debuginfo::{DIFlags, DIType},\n+    },\n+};\n+\n+use super::{\n+    size_and_align_of,\n+    type_map::{DINodeCreationResult, UniqueTypeId},\n+    SmallVec,\n+};\n+\n+mod cpp_like;\n+mod native;\n+\n+pub(super) fn build_enum_type_di_node<'ll, 'tcx>(\n+    cx: &CodegenCx<'ll, 'tcx>,\n+    unique_type_id: UniqueTypeId<'tcx>,\n+) -> DINodeCreationResult<'ll> {\n+    let enum_type = unique_type_id.expect_ty();\n+    let &ty::Adt(enum_adt_def, _) = enum_type.kind() else {\n+        bug!(\"build_enum_type_di_node() called with non-enum type: `{:?}`\", enum_type)\n+        };\n+\n+    let enum_type_and_layout = cx.layout_of(enum_type);\n+\n+    if wants_c_like_enum_debuginfo(enum_type_and_layout) {\n+        return build_c_style_enum_di_node(cx, enum_adt_def, enum_type_and_layout);\n+    }\n+\n+    if cpp_like_debuginfo(cx.tcx) {\n+        cpp_like::build_enum_type_di_node(cx, unique_type_id)\n+    } else {\n+        native::build_enum_type_di_node(cx, unique_type_id)\n+    }\n+}\n+\n+pub(super) fn build_generator_di_node<'ll, 'tcx>(\n+    cx: &CodegenCx<'ll, 'tcx>,\n+    unique_type_id: UniqueTypeId<'tcx>,\n+) -> DINodeCreationResult<'ll> {\n+    if cpp_like_debuginfo(cx.tcx) {\n+        cpp_like::build_generator_di_node(cx, unique_type_id)\n+    } else {\n+        native::build_generator_di_node(cx, unique_type_id)\n+    }\n+}\n+\n+/// Build the debuginfo node for a C-style enum, i.e. an enum the variants of which have no fields.\n+///\n+/// The resulting debuginfo will be a DW_TAG_enumeration_type.\n+fn build_c_style_enum_di_node<'ll, 'tcx>(\n+    cx: &CodegenCx<'ll, 'tcx>,\n+    enum_adt_def: AdtDef<'tcx>,\n+    enum_type_and_layout: TyAndLayout<'tcx>,\n+) -> DINodeCreationResult<'ll> {\n+    let containing_scope = get_namespace_for_item(cx, enum_adt_def.did());\n+    DINodeCreationResult {\n+        di_node: build_enumeration_type_di_node(\n+            cx,\n+            &compute_debuginfo_type_name(cx.tcx, enum_type_and_layout.ty, false),\n+            tag_base_type(cx, enum_type_and_layout),\n+            &mut enum_adt_def.discriminants(cx.tcx).map(|(variant_index, discr)| {\n+                (discr, Cow::from(enum_adt_def.variant(variant_index).name.as_str()))\n+            }),\n+            containing_scope,\n+        ),\n+        already_stored_in_typemap: false,\n+    }\n+}\n+\n+/// Extract the type with which we want to describe the tag of the given enum or generator.\n+fn tag_base_type<'ll, 'tcx>(\n+    cx: &CodegenCx<'ll, 'tcx>,\n+    enum_type_and_layout: TyAndLayout<'tcx>,\n+) -> Ty<'tcx> {\n+    debug_assert!(match enum_type_and_layout.ty.kind() {\n+        ty::Generator(..) => true,\n+        ty::Adt(adt_def, _) => adt_def.is_enum(),\n+        _ => false,\n+    });\n+\n+    match enum_type_and_layout.layout.variants() {\n+        // A single-variant enum has no discriminant.\n+        Variants::Single { .. } => {\n+            bug!(\"tag_base_type() called for enum without tag: {:?}\", enum_type_and_layout)\n+        }\n+\n+        Variants::Multiple { tag_encoding: TagEncoding::Niche { .. }, tag, .. } => {\n+            // Niche tags are always normalized to unsized integers of the correct size.\n+            match tag.value {\n+                Primitive::Int(t, _) => t,\n+                Primitive::F32 => Integer::I32,\n+                Primitive::F64 => Integer::I64,\n+                Primitive::Pointer => {\n+                    // If the niche is the NULL value of a reference, then `discr_enum_ty` will be\n+                    // a RawPtr. CodeView doesn't know what to do with enums whose base type is a\n+                    // pointer so we fix this up to just be `usize`.\n+                    // DWARF might be able to deal with this but with an integer type we are on\n+                    // the safe side there too.\n+                    cx.data_layout().ptr_sized_integer()\n+                }\n+            }\n+            .to_ty(cx.tcx, false)\n+        }\n+\n+        Variants::Multiple { tag_encoding: TagEncoding::Direct, tag, .. } => {\n+            // Direct tags preserve the sign.\n+            tag.value.to_ty(cx.tcx)\n+        }\n+    }\n+}\n+\n+/// Build a DW_TAG_enumeration_type debuginfo node, with the given base type and variants.\n+/// This is a helper function and does not register anything in the type map by itself.\n+///\n+/// `variants` is an iterator of (discr-value, variant-name).\n+///\n+// NOTE: Handling of discriminant values is somewhat inconsistent. They can appear as u128,\n+//       u64, and i64. Here everything gets mapped to i64 because that's what LLVM's API expects.\n+fn build_enumeration_type_di_node<'ll, 'tcx>(\n+    cx: &CodegenCx<'ll, 'tcx>,\n+    type_name: &str,\n+    base_type: Ty<'tcx>,\n+    variants: &mut dyn Iterator<Item = (Discr<'tcx>, Cow<'tcx, str>)>,\n+    containing_scope: &'ll DIType,\n+) -> &'ll DIType {\n+    let is_unsigned = match base_type.kind() {\n+        ty::Int(_) => false,\n+        ty::Uint(_) => true,\n+        _ => bug!(\"build_enumeration_type_di_node() called with non-integer tag type.\"),\n+    };\n+\n+    let enumerator_di_nodes: SmallVec<Option<&'ll DIType>> = variants\n+        .map(|(discr, variant_name)| {\n+            unsafe {\n+                Some(llvm::LLVMRustDIBuilderCreateEnumerator(\n+                    DIB(cx),\n+                    variant_name.as_ptr().cast(),\n+                    variant_name.len(),\n+                    // FIXME: what if enumeration has i128 discriminant?\n+                    discr.val as i64,\n+                    is_unsigned,\n+                ))\n+            }\n+        })\n+        .collect();\n+\n+    let (size, align) = cx.size_and_align_of(base_type);\n+\n+    unsafe {\n+        llvm::LLVMRustDIBuilderCreateEnumerationType(\n+            DIB(cx),\n+            containing_scope,\n+            type_name.as_ptr().cast(),\n+            type_name.len(),\n+            unknown_file_metadata(cx),\n+            UNKNOWN_LINE_NUMBER,\n+            size.bits(),\n+            align.bits() as u32,\n+            create_DIArray(DIB(cx), &enumerator_di_nodes[..]),\n+            type_di_node(cx, base_type),\n+            true,\n+        )\n+    }\n+}\n+\n+/// Build the debuginfo node for the struct type describing a single variant of an enum.\n+///\n+/// ```txt\n+///       DW_TAG_structure_type              (top-level type for enum)\n+///         DW_TAG_variant_part              (variant part)\n+///           DW_AT_discr                    (reference to discriminant DW_TAG_member)\n+///           DW_TAG_member                  (discriminant member)\n+///           DW_TAG_variant                 (variant 1)\n+///           DW_TAG_variant                 (variant 2)\n+///           DW_TAG_variant                 (variant 3)\n+///  --->   DW_TAG_structure_type            (type of variant 1)\n+///  --->   DW_TAG_structure_type            (type of variant 2)\n+///  --->   DW_TAG_structure_type            (type of variant 3)\n+/// ```\n+///\n+/// In CPP-like mode, we have the exact same descriptions for each variant too:\n+///\n+/// ```txt\n+///       DW_TAG_union_type              (top-level type for enum)\n+///         DW_TAG_member                    (member for variant 1)\n+///         DW_TAG_member                    (member for variant 2)\n+///         DW_TAG_member                    (member for variant 3)\n+///  --->   DW_TAG_structure_type            (type of variant 1)\n+///  --->   DW_TAG_structure_type            (type of variant 2)\n+///  --->   DW_TAG_structure_type            (type of variant 3)\n+///         DW_TAG_enumeration_type          (type of tag)\n+/// ```\n+///\n+/// The node looks like:\n+///\n+/// ```txt\n+/// DW_TAG_structure_type\n+///   DW_AT_name                  <name-of-variant>\n+///   DW_AT_byte_size             0x00000010\n+///   DW_AT_alignment             0x00000008\n+///   DW_TAG_member\n+///     DW_AT_name                  <name-of-field-0>\n+///     DW_AT_type                  <0x0000018e>\n+///     DW_AT_alignment             0x00000004\n+///     DW_AT_data_member_location  4\n+///   DW_TAG_member\n+///     DW_AT_name                  <name-of-field-1>\n+///     DW_AT_type                  <0x00000195>\n+///     DW_AT_alignment             0x00000008\n+///     DW_AT_data_member_location  8\n+///   ...\n+/// ```\n+///\n+/// The type of a variant is always a struct type with the name of the variant\n+/// and a DW_TAG_member for each field (but not the discriminant).\n+fn build_enum_variant_struct_type_di_node<'ll, 'tcx>(\n+    cx: &CodegenCx<'ll, 'tcx>,\n+    enum_type: Ty<'tcx>,\n+    enum_type_di_node: &'ll DIType,\n+    variant_index: VariantIdx,\n+    variant_def: &VariantDef,\n+    variant_layout: TyAndLayout<'tcx>,\n+) -> &'ll DIType {\n+    debug_assert_eq!(variant_layout.ty, enum_type);\n+\n+    type_map::build_type_with_children(\n+        cx,\n+        type_map::stub(\n+            cx,\n+            Stub::Struct,\n+            UniqueTypeId::for_enum_variant_struct_type(cx.tcx, enum_type, variant_index),\n+            variant_def.name.as_str(),\n+            // NOTE: We use size and align of enum_type, not from variant_layout:\n+            cx.size_and_align_of(enum_type),\n+            Some(enum_type_di_node),\n+            DIFlags::FlagZero,\n+        ),\n+        |cx, struct_type_di_node| {\n+            (0..variant_layout.fields.count())\n+                .map(|field_index| {\n+                    let field_name = if variant_def.ctor_kind != CtorKind::Fn {\n+                        // Fields have names\n+                        Cow::from(variant_def.fields[field_index].name.as_str())\n+                    } else {\n+                        // Tuple-like\n+                        super::tuple_field_name(field_index)\n+                    };\n+\n+                    let field_layout = variant_layout.field(cx, field_index);\n+\n+                    build_field_di_node(\n+                        cx,\n+                        struct_type_di_node,\n+                        &field_name,\n+                        (field_layout.size, field_layout.align.abi),\n+                        variant_layout.fields.offset(field_index),\n+                        DIFlags::FlagZero,\n+                        type_di_node(cx, field_layout.ty),\n+                    )\n+                })\n+                .collect()\n+        },\n+        |cx| build_generic_type_param_di_nodes(cx, enum_type),\n+    )\n+    .di_node\n+}\n+\n+/// Build the struct type for describing a single generator state.\n+/// See [build_generator_variant_struct_type_di_node].\n+///\n+/// ```txt\n+///\n+///       DW_TAG_structure_type              (top-level type for enum)\n+///         DW_TAG_variant_part              (variant part)\n+///           DW_AT_discr                    (reference to discriminant DW_TAG_member)\n+///           DW_TAG_member                  (discriminant member)\n+///           DW_TAG_variant                 (variant 1)\n+///           DW_TAG_variant                 (variant 2)\n+///           DW_TAG_variant                 (variant 3)\n+///  --->   DW_TAG_structure_type            (type of variant 1)\n+///  --->   DW_TAG_structure_type            (type of variant 2)\n+///  --->   DW_TAG_structure_type            (type of variant 3)\n+///\n+/// ```\n+pub fn build_generator_variant_struct_type_di_node<'ll, 'tcx>(\n+    cx: &CodegenCx<'ll, 'tcx>,\n+    variant_index: VariantIdx,\n+    generator_type_and_layout: TyAndLayout<'tcx>,\n+    generator_type_di_node: &'ll DIType,\n+    generator_layout: &GeneratorLayout<'tcx>,\n+    state_specific_upvar_names: &IndexVec<GeneratorSavedLocal, Option<Symbol>>,\n+    common_upvar_names: &[String],\n+) -> &'ll DIType {\n+    let variant_name = GeneratorSubsts::variant_name(variant_index);\n+    let unique_type_id = UniqueTypeId::for_enum_variant_struct_type(\n+        cx.tcx,\n+        generator_type_and_layout.ty,\n+        variant_index,\n+    );\n+\n+    let variant_layout = generator_type_and_layout.for_variant(cx, variant_index);\n+\n+    let generator_substs = match generator_type_and_layout.ty.kind() {\n+        ty::Generator(_, substs, _) => substs.as_generator(),\n+        _ => unreachable!(),\n+    };\n+\n+    type_map::build_type_with_children(\n+        cx,\n+        type_map::stub(\n+            cx,\n+            Stub::Struct,\n+            unique_type_id,\n+            &variant_name,\n+            size_and_align_of(generator_type_and_layout),\n+            Some(generator_type_di_node),\n+            DIFlags::FlagZero,\n+        ),\n+        |cx, variant_struct_type_di_node| {\n+            // Fields that just belong to this variant/state\n+            let state_specific_fields: SmallVec<_> = (0..variant_layout.fields.count())\n+                .map(|field_index| {\n+                    let generator_saved_local = generator_layout.variant_fields[variant_index]\n+                        [Field::from_usize(field_index)];\n+                    let field_name_maybe = state_specific_upvar_names[generator_saved_local];\n+                    let field_name = field_name_maybe\n+                        .as_ref()\n+                        .map(|s| Cow::from(s.as_str()))\n+                        .unwrap_or_else(|| super::tuple_field_name(field_index));\n+\n+                    let field_type = variant_layout.field(cx, field_index).ty;\n+\n+                    build_field_di_node(\n+                        cx,\n+                        variant_struct_type_di_node,\n+                        &field_name,\n+                        cx.size_and_align_of(field_type),\n+                        variant_layout.fields.offset(field_index),\n+                        DIFlags::FlagZero,\n+                        type_di_node(cx, field_type),\n+                    )\n+                })\n+                .collect();\n+\n+            // Fields that are common to all states\n+            let common_fields: SmallVec<_> = generator_substs\n+                .prefix_tys()\n+                .enumerate()\n+                .map(|(index, upvar_ty)| {\n+                    build_field_di_node(\n+                        cx,\n+                        variant_struct_type_di_node,\n+                        &common_upvar_names[index],\n+                        cx.size_and_align_of(upvar_ty),\n+                        generator_type_and_layout.fields.offset(index),\n+                        DIFlags::FlagZero,\n+                        type_di_node(cx, upvar_ty),\n+                    )\n+                })\n+                .collect();\n+\n+            state_specific_fields.into_iter().chain(common_fields.into_iter()).collect()\n+        },\n+        |cx| build_generic_type_param_di_nodes(cx, generator_type_and_layout.ty),\n+    )\n+    .di_node\n+}\n+\n+/// Returns the discriminant value corresponding to the variant index.\n+///\n+/// Will return `None` if there is less than two variants (because then the enum won't have)\n+/// a tag, and if this is the dataful variant of a niche-layout enum (because then there is no\n+/// single discriminant value).\n+fn compute_discriminant_value<'ll, 'tcx>(\n+    cx: &CodegenCx<'ll, 'tcx>,\n+    enum_type_and_layout: TyAndLayout<'tcx>,\n+    variant_index: VariantIdx,\n+) -> Option<u64> {\n+    match enum_type_and_layout.layout.variants() {\n+        &Variants::Single { .. } => None,\n+        &Variants::Multiple { tag_encoding: TagEncoding::Direct, .. } => Some(\n+            enum_type_and_layout.ty.discriminant_for_variant(cx.tcx, variant_index).unwrap().val\n+                as u64,\n+        ),\n+        &Variants::Multiple {\n+            tag_encoding: TagEncoding::Niche { ref niche_variants, niche_start, dataful_variant },\n+            tag,\n+            ..\n+        } => {\n+            if variant_index == dataful_variant {\n+                None\n+            } else {\n+                let value = (variant_index.as_u32() as u128)\n+                    .wrapping_sub(niche_variants.start().as_u32() as u128)\n+                    .wrapping_add(niche_start);\n+                let value = tag.value.size(cx).truncate(value);\n+                // NOTE(eddyb) do *NOT* remove this assert, until\n+                // we pass the full 128-bit value to LLVM, otherwise\n+                // truncation will be silent and remain undetected.\n+                assert_eq!(value as u64 as u128, value);\n+                Some(value as u64)\n+            }\n+        }\n+    }\n+}"}, {"sha": "f1935e0ec31afbbf4bd20bf9cb3113c0d948387b", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/metadata/enums/native.rs", "status": "added", "additions": 441, "deletions": 0, "changes": 441, "blob_url": "https://github.com/rust-lang/rust/blob/040703018c51409ea8c9a0cfb8f829a138d2a411/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata%2Fenums%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/040703018c51409ea8c9a0cfb8f829a138d2a411/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata%2Fenums%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata%2Fenums%2Fnative.rs?ref=040703018c51409ea8c9a0cfb8f829a138d2a411", "patch": "@@ -0,0 +1,441 @@\n+use std::borrow::Cow;\n+\n+use crate::{\n+    common::CodegenCx,\n+    debuginfo::{\n+        metadata::{\n+            closure_saved_names_of_captured_variables,\n+            enums::tag_base_type,\n+            file_metadata, generator_layout_and_saved_local_names, size_and_align_of, type_di_node,\n+            type_map::{self, Stub, StubInfo, UniqueTypeId},\n+            unknown_file_metadata, DINodeCreationResult, SmallVec, NO_GENERICS,\n+            UNKNOWN_LINE_NUMBER,\n+        },\n+        utils::{create_DIArray, get_namespace_for_item, DIB},\n+    },\n+    llvm::{\n+        self,\n+        debuginfo::{DIFile, DIFlags, DIType},\n+    },\n+};\n+use libc::c_uint;\n+use rustc_codegen_ssa::{\n+    debuginfo::{type_names::compute_debuginfo_type_name, wants_c_like_enum_debuginfo},\n+    traits::ConstMethods,\n+};\n+use rustc_middle::{\n+    bug,\n+    ty::{\n+        self,\n+        layout::{LayoutOf, TyAndLayout},\n+    },\n+};\n+use rustc_target::abi::{Size, TagEncoding, VariantIdx, Variants};\n+use smallvec::smallvec;\n+\n+/// Build the debuginfo node for an enum type. The listing below shows how such a\n+/// type looks like at the LLVM IR/DWARF level. It is a `DW_TAG_structure_type`\n+/// with a single `DW_TAG_variant_part` that in turn contains a `DW_TAG_variant`\n+/// for each variant of the enum. The variant-part also contains a single member\n+/// describing the discriminant, and a nested struct type for each of the variants.\n+///\n+/// ```txt\n+///  ---> DW_TAG_structure_type              (top-level type for enum)\n+///         DW_TAG_variant_part              (variant part)\n+///           DW_AT_discr                    (reference to discriminant DW_TAG_member)\n+///           DW_TAG_member                  (discriminant member)\n+///           DW_TAG_variant                 (variant 1)\n+///           DW_TAG_variant                 (variant 2)\n+///           DW_TAG_variant                 (variant 3)\n+///         DW_TAG_structure_type            (type of variant 1)\n+///         DW_TAG_structure_type            (type of variant 2)\n+///         DW_TAG_structure_type            (type of variant 3)\n+/// ```\n+pub(super) fn build_enum_type_di_node<'ll, 'tcx>(\n+    cx: &CodegenCx<'ll, 'tcx>,\n+    unique_type_id: UniqueTypeId<'tcx>,\n+) -> DINodeCreationResult<'ll> {\n+    let enum_type = unique_type_id.expect_ty();\n+    let &ty::Adt(enum_adt_def, _) = enum_type.kind() else {\n+        bug!(\"build_enum_type_di_node() called with non-enum type: `{:?}`\", enum_type)\n+        };\n+\n+    let containing_scope = get_namespace_for_item(cx, enum_adt_def.did());\n+    let enum_type_and_layout = cx.layout_of(enum_type);\n+    let enum_type_name = compute_debuginfo_type_name(cx.tcx, enum_type, false);\n+\n+    debug_assert!(!wants_c_like_enum_debuginfo(enum_type_and_layout));\n+\n+    type_map::build_type_with_children(\n+        cx,\n+        type_map::stub(\n+            cx,\n+            Stub::Struct,\n+            unique_type_id,\n+            &enum_type_name,\n+            size_and_align_of(enum_type_and_layout),\n+            Some(containing_scope),\n+            DIFlags::FlagZero,\n+        ),\n+        |cx, enum_type_di_node| {\n+            // Build the struct type for each variant. These will be referenced by the\n+            // DW_TAG_variant DIEs inside of the DW_TAG_variant_part DIE.\n+            // We also called the names for the corresponding DW_TAG_variant DIEs here.\n+            let variant_member_infos: SmallVec<_> = enum_adt_def\n+                .variant_range()\n+                .map(|variant_index| VariantMemberInfo {\n+                    variant_index,\n+                    variant_name: Cow::from(enum_adt_def.variant(variant_index).name.as_str()),\n+                    variant_struct_type_di_node: super::build_enum_variant_struct_type_di_node(\n+                        cx,\n+                        enum_type,\n+                        enum_type_di_node,\n+                        variant_index,\n+                        enum_adt_def.variant(variant_index),\n+                        enum_type_and_layout.for_variant(cx, variant_index),\n+                    ),\n+                    source_info: None,\n+                })\n+                .collect();\n+\n+            smallvec![build_enum_variant_part_di_node(\n+                cx,\n+                enum_type_and_layout,\n+                enum_type_di_node,\n+                &variant_member_infos[..],\n+            )]\n+        },\n+        // We don't seem to be emitting generic args on the enum type, it seems. Rather\n+        // they get attached to the struct type of each variant.\n+        NO_GENERICS,\n+    )\n+}\n+\n+/// Build the debuginfo node for a generator environment. It looks the same as the debuginfo for\n+/// an enum. See [build_enum_type_di_node] for more information.\n+///\n+/// ```txt\n+///\n+///  ---> DW_TAG_structure_type              (top-level type for the generator)\n+///         DW_TAG_variant_part              (variant part)\n+///           DW_AT_discr                    (reference to discriminant DW_TAG_member)\n+///           DW_TAG_member                  (discriminant member)\n+///           DW_TAG_variant                 (variant 1)\n+///           DW_TAG_variant                 (variant 2)\n+///           DW_TAG_variant                 (variant 3)\n+///         DW_TAG_structure_type            (type of variant 1)\n+///         DW_TAG_structure_type            (type of variant 2)\n+///         DW_TAG_structure_type            (type of variant 3)\n+///\n+/// ```\n+pub(super) fn build_generator_di_node<'ll, 'tcx>(\n+    cx: &CodegenCx<'ll, 'tcx>,\n+    unique_type_id: UniqueTypeId<'tcx>,\n+) -> DINodeCreationResult<'ll> {\n+    let generator_type = unique_type_id.expect_ty();\n+    let &ty::Generator(generator_def_id, _, _ ) = generator_type.kind() else {\n+        bug!(\"build_generator_di_node() called with non-generator type: `{:?}`\", generator_type)\n+        };\n+\n+    let containing_scope = get_namespace_for_item(cx, generator_def_id);\n+    let generator_type_and_layout = cx.layout_of(generator_type);\n+\n+    debug_assert!(!wants_c_like_enum_debuginfo(generator_type_and_layout));\n+\n+    let generator_type_name = compute_debuginfo_type_name(cx.tcx, generator_type, false);\n+\n+    type_map::build_type_with_children(\n+        cx,\n+        type_map::stub(\n+            cx,\n+            Stub::Struct,\n+            unique_type_id,\n+            &generator_type_name,\n+            size_and_align_of(generator_type_and_layout),\n+            Some(containing_scope),\n+            DIFlags::FlagZero,\n+        ),\n+        |cx, generator_type_di_node| {\n+            let (generator_layout, state_specific_upvar_names) =\n+                generator_layout_and_saved_local_names(cx.tcx, generator_def_id);\n+\n+            let Variants::Multiple { tag_encoding: TagEncoding::Direct, ref variants, .. } = generator_type_and_layout.variants else {\n+                bug!(\n+                    \"Encountered generator with non-direct-tag layout: {:?}\",\n+                    generator_type_and_layout\n+                )\n+            };\n+\n+            let common_upvar_names =\n+                closure_saved_names_of_captured_variables(cx.tcx, generator_def_id);\n+\n+            // Build variant struct types\n+            let variant_struct_type_di_nodes: SmallVec<_> = variants\n+                .indices()\n+                .map(|variant_index| {\n+                    // FIXME: This is problematic because just a number is not a valid identifier.\n+                    //        GeneratorSubsts::variant_name(variant_index), would be consistent\n+                    //        with enums?\n+                    let variant_name = format!(\"{}\", variant_index.as_usize()).into();\n+\n+                    let span = generator_layout.variant_source_info[variant_index].span;\n+                    let source_info = if !span.is_dummy() {\n+                        let loc = cx.lookup_debug_loc(span.lo());\n+                        Some((file_metadata(cx, &loc.file), loc.line))\n+                    } else {\n+                        None\n+                    };\n+\n+                    VariantMemberInfo {\n+                        variant_index,\n+                        variant_name,\n+                        variant_struct_type_di_node:\n+                            super::build_generator_variant_struct_type_di_node(\n+                                cx,\n+                                variant_index,\n+                                generator_type_and_layout,\n+                                generator_type_di_node,\n+                                generator_layout,\n+                                &state_specific_upvar_names,\n+                                &common_upvar_names,\n+                            ),\n+                        source_info,\n+                    }\n+                })\n+                .collect();\n+\n+            smallvec![build_enum_variant_part_di_node(\n+                cx,\n+                generator_type_and_layout,\n+                generator_type_di_node,\n+                &variant_struct_type_di_nodes[..],\n+            )]\n+        },\n+        // We don't seem to be emitting generic args on the generator type, it seems. Rather\n+        // they get attached to the struct type of each variant.\n+        NO_GENERICS,\n+    )\n+}\n+\n+/// Builds the DW_TAG_variant_part of an enum or generator debuginfo node:\n+///\n+/// ```txt\n+///       DW_TAG_structure_type              (top-level type for enum)\n+/// --->    DW_TAG_variant_part              (variant part)\n+///           DW_AT_discr                    (reference to discriminant DW_TAG_member)\n+///           DW_TAG_member                  (discriminant member)\n+///           DW_TAG_variant                 (variant 1)\n+///           DW_TAG_variant                 (variant 2)\n+///           DW_TAG_variant                 (variant 3)\n+///         DW_TAG_structure_type            (type of variant 1)\n+///         DW_TAG_structure_type            (type of variant 2)\n+///         DW_TAG_structure_type            (type of variant 3)\n+/// ```\n+fn build_enum_variant_part_di_node<'ll, 'tcx>(\n+    cx: &CodegenCx<'ll, 'tcx>,\n+    enum_type_and_layout: TyAndLayout<'tcx>,\n+    enum_type_di_node: &'ll DIType,\n+    variant_member_infos: &[VariantMemberInfo<'_, 'll>],\n+) -> &'ll DIType {\n+    let tag_member_di_node =\n+        build_discr_member_di_node(cx, enum_type_and_layout, enum_type_di_node);\n+\n+    let variant_part_unique_type_id =\n+        UniqueTypeId::for_enum_variant_part(cx.tcx, enum_type_and_layout.ty);\n+\n+    let stub = StubInfo::new(\n+        cx,\n+        variant_part_unique_type_id,\n+        |cx, variant_part_unique_type_id_str| unsafe {\n+            let variant_part_name = \"\";\n+            llvm::LLVMRustDIBuilderCreateVariantPart(\n+                DIB(cx),\n+                enum_type_di_node,\n+                variant_part_name.as_ptr().cast(),\n+                variant_part_name.len(),\n+                unknown_file_metadata(cx),\n+                UNKNOWN_LINE_NUMBER,\n+                enum_type_and_layout.size.bits(),\n+                enum_type_and_layout.align.abi.bits() as u32,\n+                DIFlags::FlagZero,\n+                tag_member_di_node,\n+                create_DIArray(DIB(cx), &[]),\n+                variant_part_unique_type_id_str.as_ptr().cast(),\n+                variant_part_unique_type_id_str.len(),\n+            )\n+        },\n+    );\n+\n+    type_map::build_type_with_children(\n+        cx,\n+        stub,\n+        |cx, variant_part_di_node| {\n+            variant_member_infos\n+                .iter()\n+                .map(|variant_member_info| {\n+                    build_enum_variant_member_di_node(\n+                        cx,\n+                        enum_type_and_layout,\n+                        variant_part_di_node,\n+                        variant_member_info,\n+                    )\n+                })\n+                .collect()\n+        },\n+        NO_GENERICS,\n+    )\n+    .di_node\n+}\n+\n+/// Builds the DW_TAG_member describing where we can find the tag of an enum.\n+/// Returns `None` if the enum does not have a tag.\n+///\n+/// ```txt\n+///\n+///       DW_TAG_structure_type              (top-level type for enum)\n+///         DW_TAG_variant_part              (variant part)\n+///           DW_AT_discr                    (reference to discriminant DW_TAG_member)\n+/// --->      DW_TAG_member                  (discriminant member)\n+///           DW_TAG_variant                 (variant 1)\n+///           DW_TAG_variant                 (variant 2)\n+///           DW_TAG_variant                 (variant 3)\n+///         DW_TAG_structure_type            (type of variant 1)\n+///         DW_TAG_structure_type            (type of variant 2)\n+///         DW_TAG_structure_type            (type of variant 3)\n+///\n+/// ```\n+fn build_discr_member_di_node<'ll, 'tcx>(\n+    cx: &CodegenCx<'ll, 'tcx>,\n+    enum_or_generator_type_and_layout: TyAndLayout<'tcx>,\n+    enum_or_generator_type_di_node: &'ll DIType,\n+) -> Option<&'ll DIType> {\n+    let tag_name = match enum_or_generator_type_and_layout.ty.kind() {\n+        ty::Generator(..) => \"__state\",\n+        _ => \"\",\n+    };\n+\n+    // NOTE: This is actually wrong. This will become a member of\n+    //       of the DW_TAG_variant_part. But, due to LLVM's API, that\n+    //       can only be constructed with this DW_TAG_member already in created.\n+    //       In LLVM IR the wrong scope will be listed but when DWARF is\n+    //       generated from it, the DW_TAG_member will be a child the\n+    //       DW_TAG_variant_part.\n+    let containing_scope = enum_or_generator_type_di_node;\n+\n+    match enum_or_generator_type_and_layout.layout.variants() {\n+        // A single-variant enum has no discriminant.\n+        &Variants::Single { .. } => None,\n+\n+        &Variants::Multiple { tag_field, .. } => {\n+            let tag_base_type = tag_base_type(cx, enum_or_generator_type_and_layout);\n+            let (size, align) = cx.size_and_align_of(tag_base_type);\n+\n+            unsafe {\n+                Some(llvm::LLVMRustDIBuilderCreateMemberType(\n+                    DIB(cx),\n+                    containing_scope,\n+                    tag_name.as_ptr().cast(),\n+                    tag_name.len(),\n+                    unknown_file_metadata(cx),\n+                    UNKNOWN_LINE_NUMBER,\n+                    size.bits(),\n+                    align.bits() as u32,\n+                    enum_or_generator_type_and_layout.fields.offset(tag_field).bits(),\n+                    DIFlags::FlagArtificial,\n+                    type_di_node(cx, tag_base_type),\n+                ))\n+            }\n+        }\n+    }\n+}\n+\n+/// Build the debuginfo node for `DW_TAG_variant`:\n+///\n+/// ```txt\n+///       DW_TAG_structure_type              (top-level type for enum)\n+///         DW_TAG_variant_part              (variant part)\n+///           DW_AT_discr                    (reference to discriminant DW_TAG_member)\n+///           DW_TAG_member                  (discriminant member)\n+///  --->     DW_TAG_variant                 (variant 1)\n+///  --->     DW_TAG_variant                 (variant 2)\n+///  --->     DW_TAG_variant                 (variant 3)\n+///         DW_TAG_structure_type            (type of variant 1)\n+///         DW_TAG_structure_type            (type of variant 2)\n+///         DW_TAG_structure_type            (type of variant 3)\n+/// ```\n+///\n+/// This node looks like:\n+///\n+/// ```txt\n+/// DW_TAG_variant\n+///   DW_AT_discr_value           0\n+///   DW_TAG_member\n+///     DW_AT_name                  None\n+///     DW_AT_type                  <0x000002a1>\n+///     DW_AT_alignment             0x00000002\n+///     DW_AT_data_member_location  0\n+/// ```\n+///\n+/// The DW_AT_discr_value is optional, and is omitted if\n+///   - This is the only variant of a univariant enum (i.e. their is no discriminant)\n+///   - This is the \"dataful\" variant of a niche-layout enum\n+///     (where only the other variants are identified by a single value)\n+///\n+/// There is only ever a single member, the type of which is a struct that describes the\n+/// fields of the variant (excluding the discriminant). The name of the member is the name\n+/// of the variant as given in the source code. The DW_AT_data_member_location is always\n+/// zero.\n+///\n+/// Note that the LLVM DIBuilder API is a bit unintuitive here. The DW_TAG_variant subtree\n+/// (including the DW_TAG_member) is built by a single call to\n+/// `LLVMRustDIBuilderCreateVariantMemberType()`.\n+fn build_enum_variant_member_di_node<'ll, 'tcx>(\n+    cx: &CodegenCx<'ll, 'tcx>,\n+    enum_type_and_layout: TyAndLayout<'tcx>,\n+    variant_part_di_node: &'ll DIType,\n+    variant_member_info: &VariantMemberInfo<'_, 'll>,\n+) -> &'ll DIType {\n+    let variant_index = variant_member_info.variant_index;\n+    let discr_value = super::compute_discriminant_value(cx, enum_type_and_layout, variant_index);\n+\n+    let (file_di_node, line_number) = variant_member_info\n+        .source_info\n+        .unwrap_or_else(|| (unknown_file_metadata(cx), UNKNOWN_LINE_NUMBER));\n+\n+    unsafe {\n+        llvm::LLVMRustDIBuilderCreateVariantMemberType(\n+            DIB(cx),\n+            variant_part_di_node,\n+            variant_member_info.variant_name.as_ptr().cast(),\n+            variant_member_info.variant_name.len(),\n+            file_di_node,\n+            line_number,\n+            enum_type_and_layout.size.bits(),\n+            enum_type_and_layout.align.abi.bits() as u32,\n+            Size::ZERO.bits(),\n+            discr_value.map(|v| cx.const_u64(v)),\n+            DIFlags::FlagZero,\n+            variant_member_info.variant_struct_type_di_node,\n+        )\n+    }\n+}\n+\n+/// Information needed for building a `DW_TAG_variant`:\n+///\n+/// ```txt\n+///       DW_TAG_structure_type              (top-level type for enum)\n+///         DW_TAG_variant_part              (variant part)\n+///           DW_AT_discr                    (reference to discriminant DW_TAG_member)\n+///           DW_TAG_member                  (discriminant member)\n+///  --->     DW_TAG_variant                 (variant 1)\n+///  --->     DW_TAG_variant                 (variant 2)\n+///  --->     DW_TAG_variant                 (variant 3)\n+///         DW_TAG_structure_type            (type of variant 1)\n+///         DW_TAG_structure_type            (type of variant 2)\n+///         DW_TAG_structure_type            (type of variant 3)\n+struct VariantMemberInfo<'a, 'll> {\n+    variant_index: VariantIdx,\n+    variant_name: Cow<'a, str>,\n+    variant_struct_type_di_node: &'ll DIType,\n+    source_info: Option<(&'ll DIFile, c_uint)>,\n+}"}, {"sha": "8ce44ada887735489e718116d736dd9cdb1852c8", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/metadata/type_map.rs", "status": "added", "additions": 270, "deletions": 0, "changes": 270, "blob_url": "https://github.com/rust-lang/rust/blob/040703018c51409ea8c9a0cfb8f829a138d2a411/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata%2Ftype_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/040703018c51409ea8c9a0cfb8f829a138d2a411/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata%2Ftype_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata%2Ftype_map.rs?ref=040703018c51409ea8c9a0cfb8f829a138d2a411", "patch": "@@ -0,0 +1,270 @@\n+use std::cell::RefCell;\n+\n+use rustc_data_structures::{\n+    fingerprint::Fingerprint,\n+    fx::FxHashMap,\n+    stable_hasher::{HashStable, NodeIdHashingMode, StableHasher},\n+};\n+use rustc_middle::{\n+    bug,\n+    ty::{ParamEnv, PolyExistentialTraitRef, Ty, TyCtxt},\n+};\n+use rustc_target::abi::{Align, Size, VariantIdx};\n+\n+use crate::{\n+    common::CodegenCx,\n+    debuginfo::utils::{create_DIArray, debug_context, DIB},\n+    llvm::{\n+        self,\n+        debuginfo::{DIFlags, DIScope, DIType},\n+    },\n+};\n+\n+use super::{unknown_file_metadata, SmallVec, UNKNOWN_LINE_NUMBER};\n+\n+mod private {\n+    // This type cannot be constructed outside of this module because\n+    // it has a private field. We make use of this in order to prevent\n+    // `UniqueTypeId` from being constructed directly, without asserting\n+    // the preconditions.\n+    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, HashStable)]\n+    pub struct HiddenZst;\n+}\n+\n+/// A unique identifier for anything that we create a debuginfo node for.\n+/// The types it contains are expected to already be normalized (which\n+/// is debug_asserted in the constructors).\n+///\n+/// Note that there are some things that only show up in debuginfo, like\n+/// the separate type descriptions for each enum variant. These get an ID\n+/// too because they have their own debuginfo node in LLVM IR.\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, HashStable)]\n+pub(super) enum UniqueTypeId<'tcx> {\n+    /// The ID of a regular type as it shows up at the language level.\n+    Ty(Ty<'tcx>, private::HiddenZst),\n+    /// The ID for the single DW_TAG_variant_part nested inside the top-level\n+    /// DW_TAG_structure_type that describes enums and generators.\n+    VariantPart(Ty<'tcx>, private::HiddenZst),\n+    /// The ID for the artificial struct type describing a single enum variant.\n+    VariantStructType(Ty<'tcx>, VariantIdx, private::HiddenZst),\n+    /// The ID of the artificial type we create for VTables.\n+    VTableTy(Ty<'tcx>, Option<PolyExistentialTraitRef<'tcx>>, private::HiddenZst),\n+}\n+\n+impl<'tcx> UniqueTypeId<'tcx> {\n+    pub fn for_ty(tcx: TyCtxt<'tcx>, t: Ty<'tcx>) -> Self {\n+        debug_assert_eq!(t, tcx.normalize_erasing_regions(ParamEnv::reveal_all(), t));\n+        UniqueTypeId::Ty(t, private::HiddenZst)\n+    }\n+\n+    pub fn for_enum_variant_part(tcx: TyCtxt<'tcx>, enum_ty: Ty<'tcx>) -> Self {\n+        debug_assert_eq!(enum_ty, tcx.normalize_erasing_regions(ParamEnv::reveal_all(), enum_ty));\n+        UniqueTypeId::VariantPart(enum_ty, private::HiddenZst)\n+    }\n+\n+    pub fn for_enum_variant_struct_type(\n+        tcx: TyCtxt<'tcx>,\n+        enum_ty: Ty<'tcx>,\n+        variant_idx: VariantIdx,\n+    ) -> Self {\n+        debug_assert_eq!(enum_ty, tcx.normalize_erasing_regions(ParamEnv::reveal_all(), enum_ty));\n+        UniqueTypeId::VariantStructType(enum_ty, variant_idx, private::HiddenZst)\n+    }\n+\n+    pub fn for_vtable_ty(\n+        tcx: TyCtxt<'tcx>,\n+        self_type: Ty<'tcx>,\n+        implemented_trait: Option<PolyExistentialTraitRef<'tcx>>,\n+    ) -> Self {\n+        debug_assert_eq!(\n+            self_type,\n+            tcx.normalize_erasing_regions(ParamEnv::reveal_all(), self_type)\n+        );\n+        debug_assert_eq!(\n+            implemented_trait,\n+            tcx.normalize_erasing_regions(ParamEnv::reveal_all(), implemented_trait)\n+        );\n+        UniqueTypeId::VTableTy(self_type, implemented_trait, private::HiddenZst)\n+    }\n+\n+    /// Generates a string version of this [UniqueTypeId], which can be used as the `UniqueId`\n+    /// argument of the various `LLVMRustDIBuilderCreate*Type()` methods.\n+    ///\n+    /// Right now this takes the form of a hex-encoded opaque hash value.\n+    pub fn generate_unique_id_string(self, tcx: TyCtxt<'tcx>) -> String {\n+        let mut hasher = StableHasher::new();\n+        let mut hcx = tcx.create_stable_hashing_context();\n+        hcx.while_hashing_spans(false, |hcx| {\n+            hcx.with_node_id_hashing_mode(NodeIdHashingMode::HashDefPath, |hcx| {\n+                self.hash_stable(hcx, &mut hasher);\n+            });\n+        });\n+        hasher.finish::<Fingerprint>().to_hex()\n+    }\n+\n+    pub fn expect_ty(self) -> Ty<'tcx> {\n+        match self {\n+            UniqueTypeId::Ty(ty, _) => ty,\n+            _ => bug!(\"Expected `UniqueTypeId::Ty` but found `{:?}`\", self),\n+        }\n+    }\n+}\n+\n+/// The `TypeMap` is where the debug context holds the type metadata nodes\n+/// created so far. The debuginfo nodes are identified by `UniqueTypeId`.\n+#[derive(Default)]\n+pub(crate) struct TypeMap<'ll, 'tcx> {\n+    pub(super) unique_id_to_di_node: RefCell<FxHashMap<UniqueTypeId<'tcx>, &'ll DIType>>,\n+}\n+\n+impl<'ll, 'tcx> TypeMap<'ll, 'tcx> {\n+    /// Adds a `UniqueTypeId` to metadata mapping to the `TypeMap`. The method will\n+    /// fail if the mapping already exists.\n+    pub(super) fn insert(&self, unique_type_id: UniqueTypeId<'tcx>, metadata: &'ll DIType) {\n+        if self.unique_id_to_di_node.borrow_mut().insert(unique_type_id, metadata).is_some() {\n+            bug!(\"type metadata for unique ID '{:?}' is already in the `TypeMap`!\", unique_type_id);\n+        }\n+    }\n+\n+    pub(super) fn di_node_for_unique_id(\n+        &self,\n+        unique_type_id: UniqueTypeId<'tcx>,\n+    ) -> Option<&'ll DIType> {\n+        self.unique_id_to_di_node.borrow().get(&unique_type_id).cloned()\n+    }\n+}\n+\n+pub struct DINodeCreationResult<'ll> {\n+    pub di_node: &'ll DIType,\n+    pub already_stored_in_typemap: bool,\n+}\n+\n+impl<'ll> DINodeCreationResult<'ll> {\n+    pub fn new(di_node: &'ll DIType, already_stored_in_typemap: bool) -> Self {\n+        DINodeCreationResult { di_node, already_stored_in_typemap }\n+    }\n+}\n+\n+#[derive(Debug, Copy, Clone, Eq, PartialEq)]\n+pub enum Stub<'ll> {\n+    Struct,\n+    Union,\n+    VtableTy { vtable_holder: &'ll DIType },\n+}\n+\n+pub struct StubInfo<'ll, 'tcx> {\n+    metadata: &'ll DIType,\n+    unique_type_id: UniqueTypeId<'tcx>,\n+}\n+\n+impl<'ll, 'tcx> StubInfo<'ll, 'tcx> {\n+    pub(super) fn new(\n+        cx: &CodegenCx<'ll, 'tcx>,\n+        unique_type_id: UniqueTypeId<'tcx>,\n+        build: impl FnOnce(&CodegenCx<'ll, 'tcx>, /* unique_type_id_str: */ &str) -> &'ll DIType,\n+    ) -> StubInfo<'ll, 'tcx> {\n+        let unique_type_id_str = unique_type_id.generate_unique_id_string(cx.tcx);\n+        let di_node = build(cx, &unique_type_id_str);\n+        StubInfo { metadata: di_node, unique_type_id }\n+    }\n+}\n+\n+/// Create a stub debuginfo node onto which fields and nested types can be attached.\n+pub(super) fn stub<'ll, 'tcx>(\n+    cx: &CodegenCx<'ll, 'tcx>,\n+    kind: Stub<'ll>,\n+    unique_type_id: UniqueTypeId<'tcx>,\n+    name: &str,\n+    (size, align): (Size, Align),\n+    containing_scope: Option<&'ll DIScope>,\n+    flags: DIFlags,\n+) -> StubInfo<'ll, 'tcx> {\n+    let empty_array = create_DIArray(DIB(cx), &[]);\n+    let unique_type_id_str = unique_type_id.generate_unique_id_string(cx.tcx);\n+\n+    let metadata = match kind {\n+        Stub::Struct | Stub::VtableTy { .. } => {\n+            let vtable_holder = match kind {\n+                Stub::VtableTy { vtable_holder } => Some(vtable_holder),\n+                _ => None,\n+            };\n+            unsafe {\n+                llvm::LLVMRustDIBuilderCreateStructType(\n+                    DIB(cx),\n+                    containing_scope,\n+                    name.as_ptr().cast(),\n+                    name.len(),\n+                    unknown_file_metadata(cx),\n+                    UNKNOWN_LINE_NUMBER,\n+                    size.bits(),\n+                    align.bits() as u32,\n+                    flags,\n+                    None,\n+                    empty_array,\n+                    0,\n+                    vtable_holder,\n+                    unique_type_id_str.as_ptr().cast(),\n+                    unique_type_id_str.len(),\n+                )\n+            }\n+        }\n+        Stub::Union => unsafe {\n+            llvm::LLVMRustDIBuilderCreateUnionType(\n+                DIB(cx),\n+                containing_scope,\n+                name.as_ptr().cast(),\n+                name.len(),\n+                unknown_file_metadata(cx),\n+                UNKNOWN_LINE_NUMBER,\n+                size.bits(),\n+                align.bits() as u32,\n+                flags,\n+                Some(empty_array),\n+                0,\n+                unique_type_id_str.as_ptr().cast(),\n+                unique_type_id_str.len(),\n+            )\n+        },\n+    };\n+    StubInfo { metadata, unique_type_id }\n+}\n+\n+/// This function enables creating debuginfo nodes that can recursively refer to themselves.\n+/// It will first insert the given stub into the type map and only then execute the `members`\n+/// and `generics` closures passed in. These closures have access to the stub so they can\n+/// directly attach fields to them. If the type of a field transitively refers back\n+/// to the type currently being built, the stub will already be found in the type map,\n+/// which effectively breaks the recursion cycle.\n+pub(super) fn build_type_with_children<'ll, 'tcx>(\n+    cx: &CodegenCx<'ll, 'tcx>,\n+    stub_info: StubInfo<'ll, 'tcx>,\n+    members: impl FnOnce(&CodegenCx<'ll, 'tcx>, &'ll DIType) -> SmallVec<&'ll DIType>,\n+    generics: impl FnOnce(&CodegenCx<'ll, 'tcx>) -> SmallVec<&'ll DIType>,\n+) -> DINodeCreationResult<'ll> {\n+    debug_assert_eq!(\n+        debug_context(cx).type_map.di_node_for_unique_id(stub_info.unique_type_id),\n+        None\n+    );\n+\n+    debug_context(cx).type_map.insert(stub_info.unique_type_id, stub_info.metadata);\n+\n+    let members: SmallVec<_> =\n+        members(cx, stub_info.metadata).into_iter().map(|node| Some(node)).collect();\n+    let generics: SmallVec<Option<&'ll DIType>> =\n+        generics(cx).into_iter().map(|node| Some(node)).collect();\n+\n+    if !(members.is_empty() && generics.is_empty()) {\n+        unsafe {\n+            let members_array = create_DIArray(DIB(cx), &members[..]);\n+            let generics_array = create_DIArray(DIB(cx), &generics[..]);\n+            llvm::LLVMRustDICompositeTypeReplaceArrays(\n+                DIB(cx),\n+                stub_info.metadata,\n+                Some(members_array),\n+                Some(generics_array),\n+            );\n+        }\n+    }\n+\n+    DINodeCreationResult { di_node: stub_info.metadata, already_stored_in_typemap: true }\n+}"}, {"sha": "4e6d3f88e67196ae2abf24ffb6d63ce367f39127", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/mod.rs", "status": "modified", "additions": 26, "deletions": 34, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/040703018c51409ea8c9a0cfb8f829a138d2a411/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/040703018c51409ea8c9a0cfb8f829a138d2a411/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmod.rs?ref=040703018c51409ea8c9a0cfb8f829a138d2a411", "patch": "@@ -2,7 +2,7 @@\n \n use rustc_codegen_ssa::mir::debuginfo::VariableKind::*;\n \n-use self::metadata::{file_metadata, type_metadata, TypeMap};\n+use self::metadata::{file_metadata, type_di_node};\n use self::metadata::{UNKNOWN_COLUMN_NUMBER, UNKNOWN_LINE_NUMBER};\n use self::namespace::mangled_name_of_instance;\n use self::utils::{create_DIArray, is_node_local_to_unit, DIB};\n@@ -20,7 +20,7 @@ use crate::value::Value;\n use rustc_codegen_ssa::debuginfo::type_names;\n use rustc_codegen_ssa::mir::debuginfo::{DebugScope, FunctionDebugContext, VariableKind};\n use rustc_codegen_ssa::traits::*;\n-use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync::Lrc;\n use rustc_hir::def_id::{DefId, DefIdMap};\n use rustc_index::vec::IndexVec;\n@@ -32,7 +32,7 @@ use rustc_session::config::{self, DebugInfo};\n use rustc_session::Session;\n use rustc_span::symbol::Symbol;\n use rustc_span::{self, BytePos, Pos, SourceFile, SourceFileAndLine, Span};\n-use rustc_target::abi::{Primitive, Size};\n+use rustc_target::abi::Size;\n \n use libc::c_uint;\n use smallvec::SmallVec;\n@@ -48,7 +48,7 @@ mod namespace;\n mod utils;\n \n pub use self::create_scope_map::compute_mir_scopes;\n-pub use self::metadata::create_global_var_metadata;\n+pub use self::metadata::build_global_var_di_node;\n pub use self::metadata::extend_scope_to_file;\n \n #[allow(non_upper_case_globals)]\n@@ -57,47 +57,39 @@ const DW_TAG_auto_variable: c_uint = 0x100;\n const DW_TAG_arg_variable: c_uint = 0x101;\n \n /// A context object for maintaining all state needed by the debuginfo module.\n-pub struct CrateDebugContext<'a, 'tcx> {\n-    llcontext: &'a llvm::Context,\n-    llmod: &'a llvm::Module,\n-    builder: &'a mut DIBuilder<'a>,\n-    created_files: RefCell<FxHashMap<(Option<String>, Option<String>), &'a DIFile>>,\n-    created_enum_disr_types: RefCell<FxHashMap<(DefId, Primitive), &'a DIType>>,\n-\n-    type_map: TypeMap<'a, 'tcx>,\n-    namespace_map: RefCell<DefIdMap<&'a DIScope>>,\n-\n-    recursion_marker_type: OnceCell<&'a DIType>,\n-\n-    // This collection is used to assert that composite types (structs, enums,\n-    // ...) have their members only set once:\n-    composite_types_completed: RefCell<FxHashSet<&'a DIType>>,\n+pub struct CodegenUnitDebugContext<'ll, 'tcx> {\n+    llcontext: &'ll llvm::Context,\n+    llmod: &'ll llvm::Module,\n+    builder: &'ll mut DIBuilder<'ll>,\n+    created_files: RefCell<FxHashMap<(Option<String>, Option<String>), &'ll DIFile>>,\n+\n+    type_map: metadata::TypeMap<'ll, 'tcx>,\n+    namespace_map: RefCell<DefIdMap<&'ll DIScope>>,\n+    recursion_marker_type: OnceCell<&'ll DIType>,\n }\n \n-impl Drop for CrateDebugContext<'_, '_> {\n+impl Drop for CodegenUnitDebugContext<'_, '_> {\n     fn drop(&mut self) {\n         unsafe {\n             llvm::LLVMRustDIBuilderDispose(&mut *(self.builder as *mut _));\n         }\n     }\n }\n \n-impl<'a, 'tcx> CrateDebugContext<'a, 'tcx> {\n-    pub fn new(llmod: &'a llvm::Module) -> Self {\n-        debug!(\"CrateDebugContext::new\");\n+impl<'ll, 'tcx> CodegenUnitDebugContext<'ll, 'tcx> {\n+    pub fn new(llmod: &'ll llvm::Module) -> Self {\n+        debug!(\"CodegenUnitDebugContext::new\");\n         let builder = unsafe { llvm::LLVMRustDIBuilderCreate(llmod) };\n         // DIBuilder inherits context from the module, so we'd better use the same one\n         let llcontext = unsafe { llvm::LLVMGetModuleContext(llmod) };\n-        CrateDebugContext {\n+        CodegenUnitDebugContext {\n             llcontext,\n             llmod,\n             builder,\n             created_files: Default::default(),\n-            created_enum_disr_types: Default::default(),\n             type_map: Default::default(),\n             namespace_map: RefCell::new(Default::default()),\n             recursion_marker_type: OnceCell::new(),\n-            composite_types_completed: Default::default(),\n         }\n     }\n \n@@ -415,7 +407,7 @@ impl<'ll, 'tcx> DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n             signature.push(if fn_abi.ret.is_ignore() {\n                 None\n             } else {\n-                Some(type_metadata(cx, fn_abi.ret.layout.ty))\n+                Some(type_di_node(cx, fn_abi.ret.layout.ty))\n             });\n \n             // Arguments types\n@@ -440,11 +432,11 @@ impl<'ll, 'tcx> DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n                         }\n                         _ => t,\n                     };\n-                    Some(type_metadata(cx, t))\n+                    Some(type_di_node(cx, t))\n                 }));\n             } else {\n                 signature\n-                    .extend(fn_abi.args.iter().map(|arg| Some(type_metadata(cx, arg.layout.ty))));\n+                    .extend(fn_abi.args.iter().map(|arg| Some(type_di_node(cx, arg.layout.ty))));\n             }\n \n             create_DIArray(DIB(cx), &signature[..])\n@@ -467,7 +459,7 @@ impl<'ll, 'tcx> DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n                         if let GenericArgKind::Type(ty) = kind.unpack() {\n                             let actual_type =\n                                 cx.tcx.normalize_erasing_regions(ParamEnv::reveal_all(), ty);\n-                            let actual_type_metadata = type_metadata(cx, actual_type);\n+                            let actual_type_metadata = type_di_node(cx, actual_type);\n                             let name = name.as_str();\n                             Some(unsafe {\n                                 Some(llvm::LLVMRustDIBuilderCreateTemplateTypeParameter(\n@@ -522,7 +514,7 @@ impl<'ll, 'tcx> DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n                             if cx.sess().opts.debuginfo == DebugInfo::Full\n                                 && !impl_self_ty.needs_subst()\n                             {\n-                                Some(type_metadata(cx, impl_self_ty))\n+                                Some(type_di_node(cx, impl_self_ty))\n                             } else {\n                                 Some(namespace::item_namespace(cx, def.did()))\n                             }\n@@ -563,13 +555,13 @@ impl<'ll, 'tcx> DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n         unsafe { llvm::LLVMRustDIBuilderCreateDebugLocation(line, col, scope, inlined_at) }\n     }\n \n-    fn create_vtable_metadata(\n+    fn create_vtable_debuginfo(\n         &self,\n         ty: Ty<'tcx>,\n         trait_ref: Option<ty::PolyExistentialTraitRef<'tcx>>,\n         vtable: Self::Value,\n     ) {\n-        metadata::create_vtable_metadata(self, ty, trait_ref, vtable)\n+        metadata::create_vtable_di_node(self, ty, trait_ref, vtable)\n     }\n \n     fn extend_scope_to_file(\n@@ -597,7 +589,7 @@ impl<'ll, 'tcx> DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n         let loc = self.lookup_debug_loc(span.lo());\n         let file_metadata = file_metadata(self, &loc.file);\n \n-        let type_metadata = type_metadata(self, variable_type);\n+        let type_metadata = type_di_node(self, variable_type);\n \n         let (argument_index, dwarf_tag) = match variable_kind {\n             ArgumentVariable(index) => (index as c_uint, DW_TAG_arg_variable),"}, {"sha": "fe9851cfa561218c93b2247a39684578aa095af5", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/utils.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/040703018c51409ea8c9a0cfb8f829a138d2a411/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/040703018c51409ea8c9a0cfb8f829a138d2a411/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Futils.rs?ref=040703018c51409ea8c9a0cfb8f829a138d2a411", "patch": "@@ -1,7 +1,7 @@\n // Utility Functions.\n \n use super::namespace::item_namespace;\n-use super::CrateDebugContext;\n+use super::CodegenUnitDebugContext;\n \n use rustc_hir::def_id::DefId;\n use rustc_middle::ty::layout::{HasParamEnv, LayoutOf};\n@@ -35,7 +35,7 @@ pub fn create_DIArray<'ll>(\n #[inline]\n pub fn debug_context<'a, 'll, 'tcx>(\n     cx: &'a CodegenCx<'ll, 'tcx>,\n-) -> &'a CrateDebugContext<'ll, 'tcx> {\n+) -> &'a CodegenUnitDebugContext<'ll, 'tcx> {\n     cx.dbg_cx.as_ref().unwrap()\n }\n "}, {"sha": "6e3f4f0b8ef0163d2f7fe6d0bc23f8e702b58238", "filename": "compiler/rustc_codegen_ssa/src/debuginfo/mod.rs", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/040703018c51409ea8c9a0cfb8f829a138d2a411/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/040703018c51409ea8c9a0cfb8f829a138d2a411/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Fmod.rs?ref=040703018c51409ea8c9a0cfb8f829a138d2a411", "patch": "@@ -1,2 +1,34 @@\n+use rustc_middle::ty::{self, layout::TyAndLayout};\n+use rustc_target::abi::Size;\n+\n // FIXME(eddyb) find a place for this (or a way to replace it).\n pub mod type_names;\n+\n+/// Returns true if we want to generate a DW_TAG_enumeration_type description for\n+/// this instead of a DW_TAG_struct_type with DW_TAG_variant_part.\n+///\n+/// NOTE: This is somewhat inconsistent right now: For empty enums and enums with a single\n+///       fieldless variant, we generate DW_TAG_struct_type, although a\n+///       DW_TAG_enumeration_type would be a better fit.\n+pub fn wants_c_like_enum_debuginfo<'tcx>(enum_type_and_layout: TyAndLayout<'tcx>) -> bool {\n+    match enum_type_and_layout.ty.kind() {\n+        ty::Adt(adt_def, _) => {\n+            if !adt_def.is_enum() {\n+                return false;\n+            }\n+\n+            match adt_def.variants().len() {\n+                0 => false,\n+                1 => {\n+                    // Univariant enums unless they are zero-sized\n+                    enum_type_and_layout.size != Size::ZERO && adt_def.all_fields().count() == 0\n+                }\n+                _ => {\n+                    // Enums with more than one variant if they have no fields\n+                    adt_def.all_fields().count() == 0\n+                }\n+            }\n+        }\n+        _ => false,\n+    }\n+}"}, {"sha": "fc2921fbd3fa03a5fc28560ad35896fc30dce541", "filename": "compiler/rustc_codegen_ssa/src/debuginfo/type_names.rs", "status": "modified", "additions": 97, "deletions": 49, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/040703018c51409ea8c9a0cfb8f829a138d2a411/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/040703018c51409ea8c9a0cfb8f829a138d2a411/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Ftype_names.rs?ref=040703018c51409ea8c9a0cfb8f829a138d2a411", "patch": "@@ -16,15 +16,18 @@ use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_hir::def_id::DefId;\n use rustc_hir::definitions::{DefPathData, DefPathDataName, DisambiguatedDefPathData};\n use rustc_hir::{AsyncGeneratorKind, GeneratorKind, Mutability};\n-use rustc_middle::ty::layout::IntegerExt;\n+use rustc_middle::ty::layout::{IntegerExt, TyAndLayout};\n use rustc_middle::ty::subst::{GenericArgKind, SubstsRef};\n-use rustc_middle::ty::{self, AdtDef, ExistentialProjection, Ty, TyCtxt};\n+use rustc_middle::ty::{self, ExistentialProjection, GeneratorSubsts, ParamEnv, Ty, TyCtxt};\n use rustc_query_system::ich::NodeIdHashingMode;\n use rustc_target::abi::{Integer, TagEncoding, Variants};\n use smallvec::SmallVec;\n \n+use std::borrow::Cow;\n use std::fmt::Write;\n \n+use crate::debuginfo::wants_c_like_enum_debuginfo;\n+\n // Compute the name of the type as it should be stored in debuginfo. Does not do\n // any caching, i.e., calling the function twice with the same type will also do\n // the work twice. The `qualified` parameter only affects the first level of the\n@@ -71,8 +74,19 @@ fn push_debuginfo_type_name<'tcx>(\n         ty::Float(float_ty) => output.push_str(float_ty.name_str()),\n         ty::Foreign(def_id) => push_item_name(tcx, def_id, qualified, output),\n         ty::Adt(def, substs) => {\n-            if def.is_enum() && cpp_like_debuginfo {\n-                msvc_enum_fallback(tcx, t, def, substs, output, visited);\n+            let ty_and_layout = tcx.layout_of(ParamEnv::reveal_all().and(t)).expect(\"layout error\");\n+\n+            if def.is_enum() && cpp_like_debuginfo && !wants_c_like_enum_debuginfo(ty_and_layout) {\n+                msvc_enum_fallback(\n+                    tcx,\n+                    ty_and_layout,\n+                    &|output, visited| {\n+                        push_item_name(tcx, def.did(), true, output);\n+                        push_generic_params_internal(tcx, substs, output, visited);\n+                    },\n+                    output,\n+                    visited,\n+                );\n             } else {\n                 push_item_name(tcx, def.did(), qualified, output);\n                 push_generic_params_internal(tcx, substs, output, visited);\n@@ -348,40 +362,26 @@ fn push_debuginfo_type_name<'tcx>(\n         ty::Closure(def_id, substs) | ty::Generator(def_id, substs, ..) => {\n             // Name will be \"{closure_env#0}<T1, T2, ...>\", \"{generator_env#0}<T1, T2, ...>\", or\n             // \"{async_fn_env#0}<T1, T2, ...>\", etc.\n-            let def_key = tcx.def_key(def_id);\n-\n-            if qualified {\n-                let parent_def_id = DefId { index: def_key.parent.unwrap(), ..def_id };\n-                push_item_name(tcx, parent_def_id, true, output);\n-                output.push_str(\"::\");\n+            // In the case of cpp-like debuginfo, the name additionally gets wrapped inside of\n+            // an artificial `enum$<>` type, as defined in msvc_enum_fallback().\n+            if cpp_like_debuginfo && t.is_generator() {\n+                let ty_and_layout = tcx.layout_of(ParamEnv::reveal_all().and(t)).unwrap();\n+                msvc_enum_fallback(\n+                    tcx,\n+                    ty_and_layout,\n+                    &|output, visited| {\n+                        push_closure_or_generator_name(tcx, def_id, substs, true, output, visited);\n+                    },\n+                    output,\n+                    visited,\n+                );\n+            } else {\n+                push_closure_or_generator_name(tcx, def_id, substs, qualified, output, visited);\n             }\n-\n-            let mut label = String::with_capacity(20);\n-            write!(&mut label, \"{}_env\", generator_kind_label(tcx.generator_kind(def_id))).unwrap();\n-\n-            push_disambiguated_special_name(\n-                &label,\n-                def_key.disambiguated_data.disambiguator,\n-                cpp_like_debuginfo,\n-                output,\n-            );\n-\n-            // We also need to add the generic arguments of the async fn/generator or\n-            // the enclosing function (for closures or async blocks), so that we end\n-            // up with a unique name for every instantiation.\n-\n-            // Find the generics of the enclosing function, as defined in the source code.\n-            let enclosing_fn_def_id = tcx.typeck_root_def_id(def_id);\n-            let generics = tcx.generics_of(enclosing_fn_def_id);\n-\n-            // Truncate the substs to the length of the above generics. This will cut off\n-            // anything closure- or generator-specific.\n-            let substs = substs.truncate_to(tcx, generics);\n-            push_generic_params_internal(tcx, substs, output, visited);\n         }\n         // Type parameters from polymorphized functions.\n         ty::Param(_) => {\n-            output.push_str(&format!(\"{:?}\", t));\n+            write!(output, \"{:?}\", t).unwrap();\n         }\n         ty::Error(_)\n         | ty::Infer(_)\n@@ -404,24 +404,32 @@ fn push_debuginfo_type_name<'tcx>(\n     // `EnumMemberDescriptionFactor::create_member_descriptions`.\n     fn msvc_enum_fallback<'tcx>(\n         tcx: TyCtxt<'tcx>,\n-        ty: Ty<'tcx>,\n-        def: AdtDef<'tcx>,\n-        substs: SubstsRef<'tcx>,\n+        ty_and_layout: TyAndLayout<'tcx>,\n+        push_inner: &dyn Fn(/*output*/ &mut String, /*visited*/ &mut FxHashSet<Ty<'tcx>>),\n         output: &mut String,\n         visited: &mut FxHashSet<Ty<'tcx>>,\n     ) {\n-        let layout = tcx.layout_of(tcx.param_env(def.did()).and(ty)).expect(\"layout error\");\n+        debug_assert!(!wants_c_like_enum_debuginfo(ty_and_layout));\n+        let ty = ty_and_layout.ty;\n \n         output.push_str(\"enum$<\");\n-        push_item_name(tcx, def.did(), true, output);\n-        push_generic_params_internal(tcx, substs, output, visited);\n+        push_inner(output, visited);\n+\n+        let variant_name = |variant_index| match ty.kind() {\n+            ty::Adt(adt_def, _) => {\n+                debug_assert!(adt_def.is_enum());\n+                Cow::from(adt_def.variant(variant_index).name.as_str())\n+            }\n+            ty::Generator(..) => GeneratorSubsts::variant_name(variant_index),\n+            _ => unreachable!(),\n+        };\n \n         if let Variants::Multiple {\n             tag_encoding: TagEncoding::Niche { dataful_variant, .. },\n             tag,\n             variants,\n             ..\n-        } = &layout.variants\n+        } = &ty_and_layout.variants\n         {\n             let dataful_variant_layout = &variants[*dataful_variant];\n \n@@ -435,16 +443,13 @@ fn push_debuginfo_type_name<'tcx>(\n             let max = dataful_discriminant_range.end;\n             let max = tag.value.size(&tcx).truncate(max);\n \n-            let dataful_variant_name = def.variant(*dataful_variant).name.as_str();\n-\n-            output.push_str(&format!(\", {}, {}, {}\", min, max, dataful_variant_name));\n-        } else if let Variants::Single { index: variant_idx } = &layout.variants {\n+            let dataful_variant_name = variant_name(*dataful_variant);\n+            write!(output, \", {}, {}, {}\", min, max, dataful_variant_name).unwrap();\n+        } else if let Variants::Single { index: variant_idx } = &ty_and_layout.variants {\n             // Uninhabited enums can't be constructed and should never need to be visualized so\n             // skip this step for them.\n-            if def.variants().len() != 0 {\n-                let variant = def.variant(*variant_idx).name.as_str();\n-\n-                output.push_str(&format!(\", {}\", variant));\n+            if !ty_and_layout.abi.is_uninhabited() {\n+                write!(output, \", {}\", variant_name(*variant_idx)).unwrap();\n             }\n         }\n         push_close_angle_bracket(true, output);\n@@ -696,6 +701,49 @@ pub fn push_generic_params<'tcx>(tcx: TyCtxt<'tcx>, substs: SubstsRef<'tcx>, out\n     push_generic_params_internal(tcx, substs, output, &mut visited);\n }\n \n+fn push_closure_or_generator_name<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    def_id: DefId,\n+    substs: SubstsRef<'tcx>,\n+    qualified: bool,\n+    output: &mut String,\n+    visited: &mut FxHashSet<Ty<'tcx>>,\n+) {\n+    // Name will be \"{closure_env#0}<T1, T2, ...>\", \"{generator_env#0}<T1, T2, ...>\", or\n+    // \"{async_fn_env#0}<T1, T2, ...>\", etc.\n+    let def_key = tcx.def_key(def_id);\n+    let generator_kind = tcx.generator_kind(def_id);\n+\n+    if qualified {\n+        let parent_def_id = DefId { index: def_key.parent.unwrap(), ..def_id };\n+        push_item_name(tcx, parent_def_id, true, output);\n+        output.push_str(\"::\");\n+    }\n+\n+    let mut label = String::with_capacity(20);\n+    write!(&mut label, \"{}_env\", generator_kind_label(generator_kind)).unwrap();\n+\n+    push_disambiguated_special_name(\n+        &label,\n+        def_key.disambiguated_data.disambiguator,\n+        cpp_like_debuginfo(tcx),\n+        output,\n+    );\n+\n+    // We also need to add the generic arguments of the async fn/generator or\n+    // the enclosing function (for closures or async blocks), so that we end\n+    // up with a unique name for every instantiation.\n+\n+    // Find the generics of the enclosing function, as defined in the source code.\n+    let enclosing_fn_def_id = tcx.typeck_root_def_id(def_id);\n+    let generics = tcx.generics_of(enclosing_fn_def_id);\n+\n+    // Truncate the substs to the length of the above generics. This will cut off\n+    // anything closure- or generator-specific.\n+    let substs = substs.truncate_to(tcx, generics);\n+    push_generic_params_internal(tcx, substs, output, visited);\n+}\n+\n fn push_close_angle_bracket(cpp_like_debuginfo: bool, output: &mut String) {\n     // MSVC debugger always treats `>>` as a shift, even when parsing templates,\n     // so add a space to avoid confusion."}, {"sha": "00f101595f27a9dcb1a9377e8e4d83db0b7bc89a", "filename": "compiler/rustc_codegen_ssa/src/meth.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/040703018c51409ea8c9a0cfb8f829a138d2a411/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/040703018c51409ea8c9a0cfb8f829a138d2a411/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmeth.rs?ref=040703018c51409ea8c9a0cfb8f829a138d2a411", "patch": "@@ -78,7 +78,7 @@ pub fn get_vtable<'tcx, Cx: CodegenMethods<'tcx>>(\n     let align = cx.data_layout().pointer_align.abi;\n     let vtable = cx.static_addr_of(vtable_const, align, Some(\"vtable\"));\n \n-    cx.create_vtable_metadata(ty, trait_ref, vtable);\n+    cx.create_vtable_debuginfo(ty, trait_ref, vtable);\n     cx.vtables().borrow_mut().insert((ty, trait_ref), vtable);\n     vtable\n }"}, {"sha": "f310789d1449c3ca178823e6f89bd9aa46bd0de1", "filename": "compiler/rustc_codegen_ssa/src/traits/debuginfo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/040703018c51409ea8c9a0cfb8f829a138d2a411/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/040703018c51409ea8c9a0cfb8f829a138d2a411/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fdebuginfo.rs?ref=040703018c51409ea8c9a0cfb8f829a138d2a411", "patch": "@@ -7,7 +7,7 @@ use rustc_target::abi::call::FnAbi;\n use rustc_target::abi::Size;\n \n pub trait DebugInfoMethods<'tcx>: BackendTypes {\n-    fn create_vtable_metadata(\n+    fn create_vtable_debuginfo(\n         &self,\n         ty: Ty<'tcx>,\n         trait_ref: Option<PolyExistentialTraitRef<'tcx>>,"}, {"sha": "8995605e3dd7208f12a8d96fa99e396f9e56ce9f", "filename": "src/test/codegen/async-fn-debug-msvc.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/040703018c51409ea8c9a0cfb8f829a138d2a411/src%2Ftest%2Fcodegen%2Fasync-fn-debug-msvc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/040703018c51409ea8c9a0cfb8f829a138d2a411/src%2Ftest%2Fcodegen%2Fasync-fn-debug-msvc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fasync-fn-debug-msvc.rs?ref=040703018c51409ea8c9a0cfb8f829a138d2a411", "patch": "@@ -16,8 +16,7 @@ async fn async_fn_test() {\n \n // FIXME: No way to reliably check the filename.\n \n-// CHECK-DAG:  [[ASYNC_FN:!.*]] = !DINamespace(name: \"async_fn_test\"\n-// CHECK-DAG:  [[GEN:!.*]] = !DICompositeType(tag: DW_TAG_union_type, name: \"async_fn_env$0\"\n+// CHECK-DAG:  [[GEN:!.*]] = !DICompositeType(tag: DW_TAG_union_type, name: \"enum$<async_fn_debug_msvc::async_fn_test::async_fn_env$0>\",\n // CHECK:      {{!.*}} = !DIDerivedType(tag: DW_TAG_member, name: \"variant0\", scope: [[GEN]],\n // For brevity, we only check the struct name and members of the last variant.\n // CHECK-SAME: file: [[FILE:![0-9]*]], line: 11,\n@@ -40,10 +39,10 @@ async fn async_fn_test() {\n // CHECK-SAME: baseType: [[VARIANT:![0-9]*]]\n // CHECK-NOT:  flags: DIFlagArtificial\n // CHECK-SAME: )\n-// CHECK:      [[S1:!.*]] = !DICompositeType(tag: DW_TAG_structure_type, name: \"Suspend1\", scope: [[GEN]],\n+// CHECK:      [[VARIANT]] = !DICompositeType(tag: DW_TAG_structure_type, name: \"Suspend1\", scope: [[GEN]],\n // CHECK-NOT:  flags: DIFlagArtificial\n // CHECK-SAME: )\n-// CHECK:      {{!.*}} = !DIDerivedType(tag: DW_TAG_member, name: \"s\", scope: [[S1]]\n+// CHECK:      {{!.*}} = !DIDerivedType(tag: DW_TAG_member, name: \"s\", scope: [[VARIANT]]\n // CHECK-NOT:  flags: DIFlagArtificial\n // CHECK-SAME: )\n // CHECK:      {{!.*}} = !DIDerivedType(tag: DW_TAG_member, name: \"discriminant\", scope: [[GEN]],"}, {"sha": "9f6058a71b3433a4ff12622850fae3bda78ad29b", "filename": "src/test/codegen/async-fn-debug.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/040703018c51409ea8c9a0cfb8f829a138d2a411/src%2Ftest%2Fcodegen%2Fasync-fn-debug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/040703018c51409ea8c9a0cfb8f829a138d2a411/src%2Ftest%2Fcodegen%2Fasync-fn-debug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fasync-fn-debug.rs?ref=040703018c51409ea8c9a0cfb8f829a138d2a411", "patch": "@@ -18,7 +18,7 @@ async fn async_fn_test() {\n \n // CHECK-DAG:  [[ASYNC_FN:!.*]] = !DINamespace(name: \"async_fn_test\"\n // CHECK-DAG:  [[GEN:!.*]] = !DICompositeType(tag: DW_TAG_structure_type, name: \"{async_fn_env#0}\", scope: [[ASYNC_FN]]\n-// CHECK:      [[VARIANT:!.*]] = !DICompositeType(tag: DW_TAG_variant_part, scope: [[ASYNC_FN]],\n+// CHECK:      [[VARIANT:!.*]] = !DICompositeType(tag: DW_TAG_variant_part, scope: [[GEN]],\n // CHECK-NOT:  flags: DIFlagArtificial\n // CHECK-SAME: discriminator: [[DISC:![0-9]*]]\n // CHECK:      {{!.*}} = !DIDerivedType(tag: DW_TAG_member, name: \"0\", scope: [[VARIANT]],\n@@ -50,7 +50,7 @@ async fn async_fn_test() {\n // CHECK:      {{!.*}} = !DIDerivedType(tag: DW_TAG_member, name: \"s\", scope: [[S1]]\n // CHECK-NOT:  flags: DIFlagArtificial\n // CHECK-SAME: )\n-// CHECK:      [[DISC]] = !DIDerivedType(tag: DW_TAG_member, name: \"__state\", scope: [[ASYNC_FN]],\n+// CHECK:      [[DISC]] = !DIDerivedType(tag: DW_TAG_member, name: \"__state\", scope: [[GEN]],\n // CHECK-SAME: flags: DIFlagArtificial\n \n fn main() {"}, {"sha": "74b1eb948b0f77f07a341260aa7687473107fbea", "filename": "src/test/codegen/generator-debug-msvc.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/040703018c51409ea8c9a0cfb8f829a138d2a411/src%2Ftest%2Fcodegen%2Fgenerator-debug-msvc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/040703018c51409ea8c9a0cfb8f829a138d2a411/src%2Ftest%2Fcodegen%2Fgenerator-debug-msvc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fgenerator-debug-msvc.rs?ref=040703018c51409ea8c9a0cfb8f829a138d2a411", "patch": "@@ -20,8 +20,7 @@ fn generator_test() -> impl Generator<Yield = i32, Return = ()> {\n \n // FIXME: No way to reliably check the filename.\n \n-// CHECK-DAG:  [[GEN_FN:!.*]] = !DINamespace(name: \"generator_test\"\n-// CHECK-DAG:  [[GEN:!.*]] = !DICompositeType(tag: DW_TAG_union_type, name: \"generator_env$0\"\n+// CHECK-DAG:  [[GEN:!.*]] = !DICompositeType(tag: DW_TAG_union_type, name: \"enum$<generator_debug_msvc::generator_test::generator_env$0>\"\n // CHECK:      {{!.*}} = !DIDerivedType(tag: DW_TAG_member, name: \"variant0\", scope: [[GEN]],\n // For brevity, we only check the struct name and members of the last variant.\n // CHECK-SAME: file: [[FILE:![0-9]*]], line: 14,\n@@ -44,10 +43,10 @@ fn generator_test() -> impl Generator<Yield = i32, Return = ()> {\n // CHECK-SAME: baseType: [[VARIANT:![0-9]*]]\n // CHECK-NOT:  flags: DIFlagArtificial\n // CHECK-SAME: )\n-// CHECK:      [[S1:!.*]] = !DICompositeType(tag: DW_TAG_structure_type, name: \"Suspend1\", scope: [[GEN]],\n+// CHECK:      [[VARIANT]] = !DICompositeType(tag: DW_TAG_structure_type, name: \"Suspend1\", scope: [[GEN]],\n // CHECK-NOT:  flags: DIFlagArtificial\n // CHECK-SAME: )\n-// CHECK:      {{!.*}} = !DIDerivedType(tag: DW_TAG_member, name: \"s\", scope: [[S1]]\n+// CHECK:      {{!.*}} = !DIDerivedType(tag: DW_TAG_member, name: \"s\", scope: [[VARIANT]]\n // CHECK-NOT:  flags: DIFlagArtificial\n // CHECK-SAME: )\n // CHECK:      {{!.*}} = !DIDerivedType(tag: DW_TAG_member, name: \"discriminant\", scope: [[GEN]],"}, {"sha": "3ec860f2cbc0681370b27d30788be1699d2fe1af", "filename": "src/test/codegen/generator-debug.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/040703018c51409ea8c9a0cfb8f829a138d2a411/src%2Ftest%2Fcodegen%2Fgenerator-debug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/040703018c51409ea8c9a0cfb8f829a138d2a411/src%2Ftest%2Fcodegen%2Fgenerator-debug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fgenerator-debug.rs?ref=040703018c51409ea8c9a0cfb8f829a138d2a411", "patch": "@@ -22,7 +22,7 @@ fn generator_test() -> impl Generator<Yield = i32, Return = ()> {\n \n // CHECK-DAG:  [[GEN_FN:!.*]] = !DINamespace(name: \"generator_test\"\n // CHECK-DAG:  [[GEN:!.*]] = !DICompositeType(tag: DW_TAG_structure_type, name: \"{generator_env#0}\", scope: [[GEN_FN]]\n-// CHECK:      [[VARIANT:!.*]] = !DICompositeType(tag: DW_TAG_variant_part, scope: [[GEN_FN]],\n+// CHECK:      [[VARIANT:!.*]] = !DICompositeType(tag: DW_TAG_variant_part, scope: [[GEN]],\n // CHECK-NOT:  flags: DIFlagArtificial\n // CHECK-SAME: discriminator: [[DISC:![0-9]*]]\n // CHECK:      {{!.*}} = !DIDerivedType(tag: DW_TAG_member, name: \"0\", scope: [[VARIANT]],\n@@ -54,7 +54,7 @@ fn generator_test() -> impl Generator<Yield = i32, Return = ()> {\n // CHECK:      {{!.*}} = !DIDerivedType(tag: DW_TAG_member, name: \"s\", scope: [[S1]]\n // CHECK-NOT:  flags: DIFlagArtificial\n // CHECK-SAME: )\n-// CHECK:      [[DISC]] = !DIDerivedType(tag: DW_TAG_member, name: \"__state\", scope: [[GEN_FN]],\n+// CHECK:      [[DISC]] = !DIDerivedType(tag: DW_TAG_member, name: \"__state\", scope: [[GEN]],\n // CHECK-SAME: flags: DIFlagArtificial\n \n fn main() {"}, {"sha": "d6d7e5b44aafc1429b96b00140ebff9de8ecfe9e", "filename": "src/test/debuginfo/generator-objects.rs", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/040703018c51409ea8c9a0cfb8f829a138d2a411/src%2Ftest%2Fdebuginfo%2Fgenerator-objects.rs", "raw_url": "https://github.com/rust-lang/rust/raw/040703018c51409ea8c9a0cfb8f829a138d2a411/src%2Ftest%2Fdebuginfo%2Fgenerator-objects.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fgenerator-objects.rs?ref=040703018c51409ea8c9a0cfb8f829a138d2a411", "patch": "@@ -37,6 +37,37 @@\n // lldb-command:print b\n // lldbg-check:(generator_objects::main::{generator_env#0}) $3 =\n \n+// === CDB TESTS ===================================================================================\n+\n+// cdb-command: g\n+// cdb-command: dx b\n+// cdb-check: b                : Unresumed [Type: enum$<generator_objects::main::generator_env$0>]\n+// cdb-check:    [variant]        : Unresumed\n+// cdb-check:    [+0x[...]] _ref__a          : 0x[...] : 5 [Type: int *]\n+\n+// cdb-command: g\n+// cdb-command: dx b\n+// cdb-check: b                : Suspend0 [Type: enum$<generator_objects::main::generator_env$0>]\n+// cdb-check:    [variant]        : Suspend0\n+// cdb-check:    [+0x[...]] c                : 6 [Type: int]\n+// cdb-check:    [+0x[...]] d                : 7 [Type: int]\n+// cdb-check:    [+0x[...]] _ref__a          : 0x[...] : 5 [Type: int *]\n+\n+// cdb-command: g\n+// cdb-command: dx b\n+// cdb-check: b                : Suspend1 [Type: enum$<generator_objects::main::generator_env$0>]\n+// cdb-check:    [variant]        : Suspend1\n+// cdb-check:    [+0x[...]] c                : 7 [Type: int]\n+// cdb-check:    [+0x[...]] d                : 8 [Type: int]\n+// cdb-check:    [+0x[...]] _ref__a          : 0x[...] : 6 [Type: int *]\n+\n+// cdb-command: g\n+// cdb-command: dx b\n+// cdb-check: b                : Returned [Type: enum$<generator_objects::main::generator_env$0>]\n+// cdb-check:    [<Raw View>]     [Type: enum$<generator_objects::main::generator_env$0>]\n+// cdb-check:    [variant]        : Returned\n+// cdb-check:    [+0x[...]] _ref__a          : 0x[...] : 6 [Type: int *]\n+\n #![feature(omit_gdb_pretty_printer_section, generators, generator_trait)]\n #![omit_gdb_pretty_printer_section]\n \n@@ -66,6 +97,7 @@ fn main() {\n     _zzz(); // #break\n }\n \n+#[inline(never)]\n fn _zzz() {\n     ()\n }"}, {"sha": "a153a9a42289a4018b913a9f68ad3dcee080465f", "filename": "src/test/debuginfo/msvc-pretty-enums.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/040703018c51409ea8c9a0cfb8f829a138d2a411/src%2Ftest%2Fdebuginfo%2Fmsvc-pretty-enums.rs", "raw_url": "https://github.com/rust-lang/rust/raw/040703018c51409ea8c9a0cfb8f829a138d2a411/src%2Ftest%2Fdebuginfo%2Fmsvc-pretty-enums.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fmsvc-pretty-enums.rs?ref=040703018c51409ea8c9a0cfb8f829a138d2a411", "patch": "@@ -4,14 +4,14 @@\n // cdb-command: g\n \n // cdb-command: dx a\n-// cdb-check:a                :  Some({...}) [Type: enum$<core::option::Option<enum$<msvc_pretty_enums::CStyleEnum> >, 2, 16, Some>]\n-// cdb-check:    [<Raw View>]     [Type: enum$<core::option::Option<enum$<msvc_pretty_enums::CStyleEnum> >, 2, 16, Some>]\n+// cdb-check:a                :  Some({...}) [Type: enum$<core::option::Option<msvc_pretty_enums::CStyleEnum>, 2, 16, Some>]\n+// cdb-check:    [<Raw View>]     [Type: enum$<core::option::Option<msvc_pretty_enums::CStyleEnum>, 2, 16, Some>]\n // cdb-check:    [variant]        :  Some\n // cdb-check:    [+0x000] __0              : Low (0x2) [Type: msvc_pretty_enums::CStyleEnum]\n \n // cdb-command: dx b\n-// cdb-check:b                : None [Type: enum$<core::option::Option<enum$<msvc_pretty_enums::CStyleEnum> >, 2, 16, Some>]\n-// cdb-check:    [<Raw View>]     [Type: enum$<core::option::Option<enum$<msvc_pretty_enums::CStyleEnum> >, 2, 16, Some>]\n+// cdb-check:b                : None [Type: enum$<core::option::Option<msvc_pretty_enums::CStyleEnum>, 2, 16, Some>]\n+// cdb-check:    [<Raw View>]     [Type: enum$<core::option::Option<msvc_pretty_enums::CStyleEnum>, 2, 16, Some>]\n // cdb-check:    [variant]        : None\n \n // cdb-command: dx c\n@@ -78,7 +78,7 @@ pub enum NicheLayoutEnum {\n     Tag2,\n }\n \n-pub enum Empty { }\n+pub enum Empty {}\n \n fn main() {\n     let a = Some(CStyleEnum::Low);\n@@ -97,4 +97,6 @@ fn main() {\n     zzz(); // #break\n }\n \n-fn zzz() { () }\n+fn zzz() {\n+    ()\n+}"}, {"sha": "52841d50f642fcb567d057a90aa5fbd75edd8291", "filename": "src/test/debuginfo/type-names.rs", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/040703018c51409ea8c9a0cfb8f829a138d2a411/src%2Ftest%2Fdebuginfo%2Ftype-names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/040703018c51409ea8c9a0cfb8f829a138d2a411/src%2Ftest%2Fdebuginfo%2Ftype-names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Ftype-names.rs?ref=040703018c51409ea8c9a0cfb8f829a138d2a411", "patch": "@@ -33,10 +33,10 @@\n // gdb-check:type = type_names::mod1::Enum2\n \n // gdb-command:whatis generic_enum_1\n-// gdb-check:type = type_names::mod1::mod2::Enum3\n+// gdb-check:type = type_names::mod1::mod2::Enum3<type_names::mod1::Struct2>\n \n // gdb-command:whatis generic_enum_2\n-// gdb-check:type = type_names::mod1::mod2::Enum3\n+// gdb-check:type = type_names::mod1::mod2::Enum3<type_names::Struct1>\n \n // TUPLES\n // gdb-command:whatis tuple1\n@@ -159,10 +159,10 @@\n \n // FOREIGN TYPES\n // gdb-command:whatis foreign1\n-// gdb-check:type = *mut ForeignType1\n+// gdb-check:type = *mut type_names::{extern#0}::ForeignType1\n \n // gdb-command:whatis foreign2\n-// gdb-check:type = *mut ForeignType2\n+// gdb-check:type = *mut type_names::mod1::{extern#0}::ForeignType2\n \n // === CDB TESTS ==================================================================================\n \n@@ -178,9 +178,9 @@\n // cdb-command:dv /t *_enum_*\n // cdb-check:union enum$<type_names::Enum1> simple_enum_1 = [...]\n // cdb-check:union enum$<type_names::Enum1> simple_enum_2 = [...]\n-// cdb-check:type_names::mod1::Enum2 simple_enum_3 = [...]\n-// cdb-check:type_names::mod1::mod2::Enum3 generic_enum_1 = [...]\n-// cdb-check:type_names::mod1::mod2::Enum3 generic_enum_2 = [...]\n+// cdb-check:union enum$<type_names::mod1::Enum2> simple_enum_3 = [...]\n+// cdb-check:union enum$<type_names::mod1::mod2::Enum3<type_names::mod1::Struct2> > generic_enum_1 = [...]\n+// cdb-check:union enum$<type_names::mod1::mod2::Enum3<type_names::Struct1> > generic_enum_2 = [...]\n \n // TUPLES\n // cdb-command:dv /t tuple*\n@@ -258,8 +258,8 @@\n \n // FOREIGN TYPES\n // cdb-command:dv /t foreign*\n-// cdb-check:struct ForeignType2 * foreign2 = [...]\n-// cdb-check:struct ForeignType1 * foreign1 = [...]\n+// cdb-check:struct type_names::mod1::extern$0::ForeignType2 * foreign2 = [...]\n+// cdb-check:struct type_names::extern$0::ForeignType1 * foreign1 = [...]\n \n #![allow(unused_variables)]\n #![feature(omit_gdb_pretty_printer_section)]\n@@ -283,7 +283,6 @@ extern \"C\" {\n }\n \n mod mod1 {\n-    pub use self::Enum2::{Variant1, Variant2};\n     pub struct Struct2;\n \n     pub enum Enum2 {\n@@ -367,14 +366,14 @@ fn main() {\n     // Enums\n     let simple_enum_1 = Variant1;\n     let simple_enum_2 = Variant2(0);\n-    let simple_enum_3 = mod1::Variant2(Struct1);\n+    let simple_enum_3 = mod1::Enum2::Variant2(Struct1);\n \n     let generic_enum_1: mod1::mod2::Enum3<mod1::Struct2> = mod1::mod2::Variant1;\n     let generic_enum_2 = mod1::mod2::Variant2(Struct1);\n \n     // Tuples\n     let tuple1 = (8u32, Struct1, mod1::mod2::Variant2(mod1::Struct2));\n-    let tuple2 = ((Struct1, mod1::mod2::Struct3), mod1::Variant1, 'x');\n+    let tuple2 = ((Struct1, mod1::mod2::Struct3), mod1::Enum2::Variant1, 'x');\n \n     // Box\n     let box1 = (Box::new(1f32), 0i32);\n@@ -404,7 +403,7 @@ fn main() {\n \n     let vec1 = vec![0_usize, 2, 3];\n     let slice1 = &*vec1;\n-    let vec2 = vec![mod1::Variant2(Struct1)];\n+    let vec2 = vec![mod1::Enum2::Variant2(Struct1)];\n     let slice2 = &*vec2;\n \n     // Trait Objects"}, {"sha": "6b27d1ecbf550038f2846a3d1e2c4c289d1f27ff", "filename": "src/tools/compiletest/src/runtest.rs", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/040703018c51409ea8c9a0cfb8f829a138d2a411/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/040703018c51409ea8c9a0cfb8f829a138d2a411/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs?ref=040703018c51409ea8c9a0cfb8f829a138d2a411", "patch": "@@ -661,6 +661,21 @@ impl<'test> TestCx<'test> {\n     }\n \n     fn run_debuginfo_cdb_test_no_opt(&self) {\n+        let exe_file = self.make_exe_name();\n+\n+        // Existing PDB files are update in-place. When changing the debuginfo\n+        // the compiler generates for something, this can lead to the situation\n+        // where both the old and the new version of the debuginfo for the same\n+        // type is present in the PDB, which is very confusing.\n+        // Therefore we delete any existing PDB file before compiling the test\n+        // case.\n+        // FIXME: If can reliably detect that MSVC's link.exe is used, then\n+        //        passing `/INCREMENTAL:NO` might be a cleaner way to do this.\n+        let pdb_file = exe_file.with_extension(\".pdb\");\n+        if pdb_file.exists() {\n+            std::fs::remove_file(pdb_file).unwrap();\n+        }\n+\n         // compile test file (it should have 'compile-flags:-g' in the header)\n         let should_run = self.run_if_enabled();\n         let compile_result = self.compile_test(should_run, EmitMetadata::No);\n@@ -671,8 +686,6 @@ impl<'test> TestCx<'test> {\n             return;\n         }\n \n-        let exe_file = self.make_exe_name();\n-\n         let prefixes = {\n             static PREFIXES: &[&str] = &[\"cdb\", \"cdbg\"];\n             // No \"native rust support\" variation for CDB yet."}]}