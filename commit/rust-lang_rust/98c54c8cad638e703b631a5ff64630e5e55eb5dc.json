{"sha": "98c54c8cad638e703b631a5ff64630e5e55eb5dc", "node_id": "C_kwDOAAsO6NoAKDk4YzU0YzhjYWQ2MzhlNzAzYjYzMWE1ZmY2NDYzMGU1ZTU1ZWI1ZGM", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-02-17T22:00:55Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-02-17T22:00:55Z"}, "message": "Rollup merge of #93758 - nnethercote:improve-folding-comments, r=BoxyUwU\n\nImprove comments about type folding/visiting.\n\nI have found this code confusing for years. I've always roughly\nunderstood it, but never exactly. I just made my fourth(?) attempt and\nfinally cracked it.\n\nThis commit improves the comments. In particular, it explicitly\ndescribes how you can't do a custom fold/visit of any type; there are\nactually a handful of \"types of interest\" (e.g. `Ty`, `Predicate`,\n`Region`, `Const`) that can be custom folded/visted, and all other types\njust get a generic traversal. I think this was the part that eluded me\non all my prior attempts at understanding.\n\nThe commit also updates comments to account for some newer changes such\nas the fallible/infallible folding distinction, does some minor\nreorderings, and moves one `impl` to a better place.\n\nr? `@BoxyUwU`", "tree": {"sha": "de391393e0e780ac495475ff69edd18d629a0638", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/de391393e0e780ac495475ff69edd18d629a0638"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/98c54c8cad638e703b631a5ff64630e5e55eb5dc", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiDsWYCRBK7hj4Ov3rIwAA7fIIAGdQkuR99f5cGDiR7NFPQBAQ\nxf8iGrc/eWa2QCjrZTyKl9t8dPsGmbpnhk2J/Vkj26NEPdBk+KvPM7pFW5i32fCH\nZc11ShdYxLyzOBdkZWPDZNHEHEooIEbMxCDXnrDlYo9S8S0D5R4wS9LJSsMg4JRf\nR/kmbOwI5AMUzXNxWkBDZHml/f+IjGxGN2AlOmMqJm9EyE9P0csZu6DsiFdm6uG9\ng55liAgZIQ+F71o6EcuXigeiCuMb34De27R8rmbqJNaTVARgejzH2R4u5KsTVDGj\noERNMzTcisk8JrnkICv/Q17vrifwrBkbSv3vCn8Y3tf4aEgVbj2NhjId36pkFlQ=\n=cSP3\n-----END PGP SIGNATURE-----\n", "payload": "tree de391393e0e780ac495475ff69edd18d629a0638\nparent 67331708e88609736e26706c4d5358f19c7e7781\nparent 94f08492af3e2acdd32cbc24607f1d1fb17192f7\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1645135255 +0100\ncommitter GitHub <noreply@github.com> 1645135255 +0100\n\nRollup merge of #93758 - nnethercote:improve-folding-comments, r=BoxyUwU\n\nImprove comments about type folding/visiting.\n\nI have found this code confusing for years. I've always roughly\nunderstood it, but never exactly. I just made my fourth(?) attempt and\nfinally cracked it.\n\nThis commit improves the comments. In particular, it explicitly\ndescribes how you can't do a custom fold/visit of any type; there are\nactually a handful of \"types of interest\" (e.g. `Ty`, `Predicate`,\n`Region`, `Const`) that can be custom folded/visted, and all other types\njust get a generic traversal. I think this was the part that eluded me\non all my prior attempts at understanding.\n\nThe commit also updates comments to account for some newer changes such\nas the fallible/infallible folding distinction, does some minor\nreorderings, and moves one `impl` to a better place.\n\nr? `@BoxyUwU`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/98c54c8cad638e703b631a5ff64630e5e55eb5dc", "html_url": "https://github.com/rust-lang/rust/commit/98c54c8cad638e703b631a5ff64630e5e55eb5dc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/98c54c8cad638e703b631a5ff64630e5e55eb5dc/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "67331708e88609736e26706c4d5358f19c7e7781", "url": "https://api.github.com/repos/rust-lang/rust/commits/67331708e88609736e26706c4d5358f19c7e7781", "html_url": "https://github.com/rust-lang/rust/commit/67331708e88609736e26706c4d5358f19c7e7781"}, {"sha": "94f08492af3e2acdd32cbc24607f1d1fb17192f7", "url": "https://api.github.com/repos/rust-lang/rust/commits/94f08492af3e2acdd32cbc24607f1d1fb17192f7", "html_url": "https://github.com/rust-lang/rust/commit/94f08492af3e2acdd32cbc24607f1d1fb17192f7"}], "stats": {"total": 190, "additions": 113, "deletions": 77}, "files": [{"sha": "4922d07ae1c5da22d649fddf7c546381db0ebfc8", "filename": "compiler/rustc_middle/src/ty/fold.rs", "status": "modified", "additions": 102, "deletions": 69, "changes": 171, "blob_url": "https://github.com/rust-lang/rust/blob/98c54c8cad638e703b631a5ff64630e5e55eb5dc/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98c54c8cad638e703b631a5ff64630e5e55eb5dc/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs?ref=98c54c8cad638e703b631a5ff64630e5e55eb5dc", "patch": "@@ -1,38 +1,56 @@\n-//! Generalized type folding mechanism. The setup is a bit convoluted\n-//! but allows for convenient usage. Let T be an instance of some\n-//! \"foldable type\" (one which implements `TypeFoldable`) and F be an\n-//! instance of a \"folder\" (a type which implements `TypeFolder`). Then\n-//! the setup is intended to be:\n+//! A generalized traversal mechanism for complex data structures that contain\n+//! type information.\n //!\n-//!     T.fold_with(F) --calls--> F.fold_T(T) --calls--> T.super_fold_with(F)\n+//! There are two types of traversal.\n+//! - Folding. This is a modifying traversal. It consumes the data structure,\n+//!   producing a (possibly) modified version of it. Both fallible and\n+//!   infallible versions are available. The name is potentially\n+//!   confusing, because this traversal is more like `Iterator::map` than\n+//!   `Iterator::fold`.\n+//! - Visiting. This is a read-only traversal of the data structure.\n //!\n-//! This way, when you define a new folder F, you can override\n-//! `fold_T()` to customize the behavior, and invoke `T.super_fold_with()`\n-//! to get the original behavior. Meanwhile, to actually fold\n-//! something, you can just write `T.fold_with(F)`, which is\n-//! convenient. (Note that `fold_with` will also transparently handle\n-//! things like a `Vec<T>` where T is foldable and so on.)\n+//! These traversals have limited flexibility. Only a small number of \"types of\n+//! interest\" within the complex data structures can receive custom\n+//! modification (when folding) or custom visitation (when visiting). These are\n+//! the ones containing the most important type-related information, such as\n+//! `Ty`, `Predicate`, `Region`, and `Const`.\n //!\n-//! In this ideal setup, the only function that actually *does*\n-//! anything is `T.super_fold_with()`, which traverses the type `T`.\n-//! Moreover, `T.super_fold_with()` should only ever call `T.fold_with()`.\n+//! There are two traits involved in each traversal type.\n+//! - The first trait is `TypeFoldable`, which is implemented once for many\n+//!   types. This includes both (a) types of interest, and (b) all other\n+//!   relevant types, including generic containers like `Vec` and `Option`. It\n+//!   defines a \"skeleton\" of how they should be traversed, for both folding\n+//!   and visiting.\n+//! - The second trait is `TypeFolder`/`FallibleTypeFolder` (for\n+//!   infallible/fallible folding traversals) or `TypeVisitor` (for visiting\n+//!   traversals). One of these is implemented for each folder/visitor. This\n+//!   defines how types of interest are handled.\n //!\n-//! In some cases, we follow a degenerate pattern where we do not have\n-//! a `fold_T` method. Instead, `T.fold_with` traverses the structure directly.\n-//! This is suboptimal because the behavior cannot be overridden, but it's\n-//! much less work to implement. If you ever *do* need an override that\n-//! doesn't exist, it's not hard to convert the degenerate pattern into the\n-//! proper thing.\n+//! This means each traversal is a mixture of (a) generic traversal operations,\n+//! and (b) custom fold/visit operations that are specific to the\n+//! folder/visitor.\n+//! - The `TypeFoldable` impls handle most of the traversal, and call into\n+//!   `TypeFolder`/`FallibleTypeFolder`/`TypeVisitor` when they encounter a\n+//!   type of interest.\n+//! - A `TypeFolder`/`FallibleTypeFolder`/`TypeVisitor` may also call back into\n+//!   a `TypeFoldable` impl, because (a) the types of interest are recursive\n+//!   and can contain other types of interest, and (b) each folder/visitor\n+//!   might provide custom handling only for some types of interest, or only\n+//!   for some variants of each type of interest, and then use default\n+//!   traversal for the remaining cases.\n //!\n-//! A `TypeFoldable` T can also be visited by a `TypeVisitor` V using similar setup:\n-//!\n-//!     T.visit_with(V) --calls--> V.visit_T(T) --calls--> T.super_visit_with(V).\n-//!\n-//! These methods return true to indicate that the visitor has found what it is\n-//! looking for, and does not need to visit anything else.\n+//! For example, if you have `struct S(Ty, U)` where `S: TypeFoldable` and `U:\n+//! TypeFoldable`, and an instance `S(ty, u)`, it would be visited like so:\n+//! ```\n+//! s.visit_with(visitor) calls\n+//! - s.super_visit_with(visitor) calls\n+//!   - ty.visit_with(visitor) calls\n+//!     - visitor.visit_ty(ty) may call\n+//!       - ty.super_visit_with(visitor)\n+//!   - u.visit_with(visitor)\n+//! ```\n use crate::mir;\n use crate::ty::{self, flags::FlagComputation, Binder, Ty, TyCtxt, TypeFlags};\n-use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n \n use rustc_data_structures::fx::FxHashSet;\n@@ -41,42 +59,67 @@ use std::collections::BTreeMap;\n use std::fmt;\n use std::ops::ControlFlow;\n \n-/// This trait is implemented for every type that can be folded.\n-/// Basically, every type that has a corresponding method in `TypeFolder`.\n+/// This trait is implemented for every type that can be folded/visited,\n+/// providing the skeleton of the traversal.\n ///\n-/// To implement this conveniently, use the derive macro located in `rustc_macros`.\n+/// To implement this conveniently, use the derive macro located in\n+/// `rustc_macros`.\n pub trait TypeFoldable<'tcx>: fmt::Debug + Clone {\n-    /// Consumers may find this more convenient to use with infallible folders than\n-    /// [`try_super_fold_with`][`TypeFoldable::try_super_fold_with`], to which the\n-    /// provided default definition delegates.  Implementors **should not** override\n-    /// this provided default definition, to ensure that the two methods are coherent\n-    /// (provide a definition of `try_super_fold_with` instead).\n-    fn super_fold_with<F: TypeFolder<'tcx, Error = !>>(self, folder: &mut F) -> Self {\n-        self.try_super_fold_with(folder).into_ok()\n+    /// The main entry point for folding. To fold a value `t` with a folder `f`\n+    /// call: `t.try_fold_with(f)`.\n+    ///\n+    /// For types of interest (such as `Ty`), this default is overridden with a\n+    /// method that calls a folder method specifically for that type (such as\n+    /// `F::try_fold_ty`). This is where control transfers from `TypeFoldable`\n+    /// to `TypeFolder`.\n+    ///\n+    /// For other types, this default is used.\n+    fn try_fold_with<F: FallibleTypeFolder<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n+        self.try_super_fold_with(folder)\n     }\n-    /// Consumers may find this more convenient to use with infallible folders than\n-    /// [`try_fold_with`][`TypeFoldable::try_fold_with`], to which the provided\n-    /// default definition delegates.  Implementors **should not** override this\n-    /// provided default definition, to ensure that the two methods are coherent\n-    /// (provide a definition of `try_fold_with` instead).\n+\n+    /// A convenient alternative to `try_fold_with` for use with infallible\n+    /// folders. Do not override this method, to ensure coherence with\n+    /// `try_fold_with`.\n     fn fold_with<F: TypeFolder<'tcx, Error = !>>(self, folder: &mut F) -> Self {\n         self.try_fold_with(folder).into_ok()\n     }\n \n+    /// Traverses the type in question, typically by calling `try_fold_with` on\n+    /// each field/element. This is true even for types of interest such as\n+    /// `Ty`. This should only be called within `TypeFolder` methods, when\n+    /// non-custom traversals are desired for types of interest.\n     fn try_super_fold_with<F: FallibleTypeFolder<'tcx>>(\n         self,\n         folder: &mut F,\n     ) -> Result<Self, F::Error>;\n \n-    fn try_fold_with<F: FallibleTypeFolder<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n-        self.try_super_fold_with(folder)\n+    /// A convenient alternative to `try_super_fold_with` for use with\n+    /// infallible folders. Do not override this method, to ensure coherence\n+    /// with `try_super_fold_with`.\n+    fn super_fold_with<F: TypeFolder<'tcx, Error = !>>(self, folder: &mut F) -> Self {\n+        self.try_super_fold_with(folder).into_ok()\n     }\n \n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<V::BreakTy>;\n+    /// The entry point for visiting. To visit a value `t` with a visitor `v`\n+    /// call: `t.visit_with(v)`.\n+    ///\n+    /// For types of interest (such as `Ty`), this default is overridden with a\n+    /// method that calls a visitor method specifically for that type (such as\n+    /// `V::visit_ty`). This is where control transfers from `TypeFoldable` to\n+    /// `TypeVisitor`.\n+    ///\n+    /// For other types, this default is used.\n     fn visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<V::BreakTy> {\n         self.super_visit_with(visitor)\n     }\n \n+    /// Traverses the type in question, typically by calling `visit_with` on\n+    /// each field/element. This is true even for types of interest such as\n+    /// `Ty`. This should only be called within `TypeVisitor` methods, when\n+    /// non-custom traversals are desired for types of interest.\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<V::BreakTy>;\n+\n     /// Returns `true` if `self` has any late-bound regions that are either\n     /// bound by `binder` or bound by some binder outside of `binder`.\n     /// If `binder` is `ty::INNERMOST`, this indicates whether\n@@ -168,24 +211,13 @@ pub trait TypeFoldable<'tcx>: fmt::Debug + Clone {\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for hir::Constness {\n-    fn try_super_fold_with<F: TypeFolder<'tcx>>(self, _: &mut F) -> Result<Self, F::Error> {\n-        Ok(self)\n-    }\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, _: &mut V) -> ControlFlow<V::BreakTy> {\n-        ControlFlow::CONTINUE\n-    }\n-}\n-\n-/// The `TypeFolder` trait defines the actual *folding*. There is a\n-/// method defined for every foldable type. Each of these has a\n-/// default implementation that does an \"identity\" fold. Within each\n-/// identity fold, it should invoke `foo.fold_with(self)` to fold each\n-/// sub-item.\n+/// This trait is implemented for every folding traversal. There is a fold\n+/// method defined for every type of interest. Each such method has a default\n+/// that does an \"identity\" fold.\n ///\n /// If this folder is fallible (and therefore its [`Error`][`TypeFolder::Error`]\n-/// associated type is something other than the default, never),\n-/// [`FallibleTypeFolder`] should be implemented manually; otherwise,\n+/// associated type is something other than the default `!`) then\n+/// [`FallibleTypeFolder`] should be implemented manually. Otherwise,\n /// a blanket implementation of [`FallibleTypeFolder`] will defer to\n /// the infallible methods of this trait to ensure that the two APIs\n /// are coherent.\n@@ -238,11 +270,9 @@ pub trait TypeFolder<'tcx>: Sized {\n     }\n }\n \n-/// The `FallibleTypeFolder` trait defines the actual *folding*. There is a\n-/// method defined for every foldable type. Each of these has a\n-/// default implementation that does an \"identity\" fold. Within each\n-/// identity fold, it should invoke `foo.try_fold_with(self)` to fold each\n-/// sub-item.\n+/// This trait is implemented for every folding traversal. There is a fold\n+/// method defined for every type of interest. Each such method has a default\n+/// that does an \"identity\" fold.\n ///\n /// A blanket implementation of this trait (that defers to the relevant\n /// method of [`TypeFolder`]) is provided for all infallible folders in\n@@ -282,8 +312,8 @@ pub trait FallibleTypeFolder<'tcx>: TypeFolder<'tcx> {\n     }\n }\n \n-// Blanket implementation of fallible trait for infallible folders\n-// delegates to infallible methods to prevent incoherence\n+// This blanket implementation of the fallible trait for infallible folders\n+// delegates to infallible methods to ensure coherence.\n impl<'tcx, F> FallibleTypeFolder<'tcx> for F\n where\n     F: TypeFolder<'tcx, Error = !>,\n@@ -322,6 +352,9 @@ where\n     }\n }\n \n+/// This trait is implemented for every visiting traversal. There is a visit\n+/// method defined for every type of interest. Each such method has a default\n+/// that recurses into the type's fields in a non-custom fashion.\n pub trait TypeVisitor<'tcx>: Sized {\n     type BreakTy = !;\n "}, {"sha": "e4691dee7793a4a80e0dceca5b40835ab2a7ad77", "filename": "compiler/rustc_middle/src/ty/structural_impls.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/98c54c8cad638e703b631a5ff64630e5e55eb5dc/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98c54c8cad638e703b631a5ff64630e5e55eb5dc/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs?ref=98c54c8cad638e703b631a5ff64630e5e55eb5dc", "patch": "@@ -8,6 +8,7 @@ use crate::ty::fold::{FallibleTypeFolder, TypeFoldable, TypeVisitor};\n use crate::ty::print::{with_no_trimmed_paths, FmtPrinter, Printer};\n use crate::ty::{self, InferConst, Lift, Term, Ty, TyCtxt};\n use rustc_data_structures::functor::IdFunctor;\n+use rustc_hir as hir;\n use rustc_hir::def::Namespace;\n use rustc_hir::def_id::CRATE_DEF_INDEX;\n use rustc_index::vec::{Idx, IndexVec};\n@@ -663,14 +664,6 @@ impl<'a, 'tcx> Lift<'tcx> for ty::InstanceDef<'a> {\n \n ///////////////////////////////////////////////////////////////////////////\n // TypeFoldable implementations.\n-//\n-// Ideally, each type should invoke `folder.fold_foo(self)` and\n-// nothing else. In some cases, though, we haven't gotten around to\n-// adding methods on the `folder` yet, and thus the folding is\n-// hard-coded here. This is less-flexible, because folders cannot\n-// override the behavior, but there are a lot of random types and one\n-// can easily refactor the folding into the TypeFolder trait as\n-// needed.\n \n /// AdtDefs are basically the same as a DefId.\n impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::AdtDef {\n@@ -1270,3 +1263,13 @@ impl<'tcx> TypeFoldable<'tcx> for ty::Unevaluated<'tcx, ()> {\n         self.substs.visit_with(visitor)\n     }\n }\n+\n+impl<'tcx> TypeFoldable<'tcx> for hir::Constness {\n+    fn try_super_fold_with<F: FallibleTypeFolder<'tcx>>(self, _: &mut F) -> Result<Self, F::Error> {\n+        Ok(self)\n+    }\n+\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, _: &mut V) -> ControlFlow<V::BreakTy> {\n+        ControlFlow::CONTINUE\n+    }\n+}"}]}