{"sha": "108cc4e0ed7da8879694e2e8e9c2d548718ac492", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEwOGNjNGUwZWQ3ZGE4ODc5Njk0ZTJlOGU5YzJkNTQ4NzE4YWM0OTI=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-06-30T23:10:33Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-06-30T23:11:39Z"}, "message": "rustc: Change function argument types to interior vectors", "tree": {"sha": "cf8f30f32fee5673225abee3ec17e0c1da27094e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cf8f30f32fee5673225abee3ec17e0c1da27094e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/108cc4e0ed7da8879694e2e8e9c2d548718ac492", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/108cc4e0ed7da8879694e2e8e9c2d548718ac492", "html_url": "https://github.com/rust-lang/rust/commit/108cc4e0ed7da8879694e2e8e9c2d548718ac492", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/108cc4e0ed7da8879694e2e8e9c2d548718ac492/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "50b1953f9b13342fa8034f91164ae8bb34d43207", "url": "https://api.github.com/repos/rust-lang/rust/commits/50b1953f9b13342fa8034f91164ae8bb34d43207", "html_url": "https://github.com/rust-lang/rust/commit/50b1953f9b13342fa8034f91164ae8bb34d43207"}], "stats": {"total": 172, "additions": 97, "deletions": 75}, "files": [{"sha": "cafabd6c3553ccbd3b216e2758629cfc20c0a1b3", "filename": "src/comp/metadata/tydecode.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/108cc4e0ed7da8879694e2e8e9c2d548718ac492/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/108cc4e0ed7da8879694e2e8e9c2d548718ac492/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Ftydecode.rs?ref=108cc4e0ed7da8879694e2e8e9c2d548718ac492", "patch": "@@ -334,9 +334,9 @@ fn parse_hex(@pstate st) -> uint {\n }\n \n fn parse_ty_fn(@pstate st, str_def sd) ->\n-   tup(vec[ty::arg], ty::t, ast::controlflow, vec[@ty::constr_def]) {\n+   tup(ty::arg[], ty::t, ast::controlflow, vec[@ty::constr_def]) {\n     assert (next(st) as char == '[');\n-    let vec[ty::arg] inputs = [];\n+    let ty::arg[] inputs = ~[];\n     while (peek(st) as char != ']') {\n         auto mode = ty::mo_val;\n         if (peek(st) as char == '&') {\n@@ -347,7 +347,7 @@ fn parse_ty_fn(@pstate st, str_def sd) ->\n                 st.pos += 1u;\n             }\n         }\n-        inputs += [rec(mode=mode, ty=parse_ty(st, sd))];\n+        inputs += ~[rec(mode=mode, ty=parse_ty(st, sd))];\n     }\n     st.pos += 1u; // eat the ']'\n     auto cs = parse_constrs(st, sd);"}, {"sha": "df33fadd632b849234e7c23b9d1d7083b3b15231", "filename": "src/comp/metadata/tyencode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/108cc4e0ed7da8879694e2e8e9c2d548718ac492/src%2Fcomp%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/108cc4e0ed7da8879694e2e8e9c2d548718ac492/src%2Fcomp%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Ftyencode.rs?ref=108cc4e0ed7da8879694e2e8e9c2d548718ac492", "patch": "@@ -199,7 +199,7 @@ fn enc_proto(&io::writer w, proto proto) {\n         case (proto_fn) { w.write_char('F'); }\n     }\n }\n-fn enc_ty_fn(&io::writer w, &@ctxt cx, &vec[ty::arg] args, &ty::t out,\n+fn enc_ty_fn(&io::writer w, &@ctxt cx, &ty::arg[] args, &ty::t out,\n              &controlflow cf, &vec[@ty::constr_def] constrs) {\n     w.write_char('[');\n     for (ty::arg arg in args) {"}, {"sha": "20bed30a7d2a01b954eb1258f2a7a7f55ec7b2b6", "filename": "src/comp/middle/alias.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/108cc4e0ed7da8879694e2e8e9c2d548718ac492/src%2Fcomp%2Fmiddle%2Falias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/108cc4e0ed7da8879694e2e8e9c2d548718ac492/src%2Fcomp%2Fmiddle%2Falias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Falias.rs?ref=108cc4e0ed7da8879694e2e8e9c2d548718ac492", "patch": "@@ -662,7 +662,7 @@ fn def_is_local(&ast::def d, bool objfields_count) -> bool {\n         };\n }\n \n-fn fty_args(&ctx cx, ty::t fty) -> vec[ty::arg] {\n+fn fty_args(&ctx cx, ty::t fty) -> ty::arg[] {\n     ret alt (ty::struct(*cx.tcx, fty)) {\n             case (ty::ty_fn(_, ?args, _, _, _)) { args }\n             case (ty::ty_native_fn(_, ?args, _)) { args }"}, {"sha": "b20074a77167c418c64cd245ba8a2ee60352f492", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/108cc4e0ed7da8879694e2e8e9c2d548718ac492/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/108cc4e0ed7da8879694e2e8e9c2d548718ac492/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=108cc4e0ed7da8879694e2e8e9c2d548718ac492", "patch": "@@ -472,7 +472,7 @@ fn T_glue_fn(&type_names tn) -> TypeRef {\n \n fn T_dtor(&@crate_ctxt ccx, &span sp, TypeRef llself_ty) -> TypeRef {\n     ret type_of_fn_full(ccx, sp, ast::proto_fn, some[TypeRef](llself_ty),\n-                        vec::empty[ty::arg](), ty::mk_nil(ccx.tcx), 0u);\n+                        ~[], ty::mk_nil(ccx.tcx), 0u);\n }\n \n fn T_cmp_glue_fn(&type_names tn) -> TypeRef {\n@@ -681,7 +681,7 @@ fn type_of(&@crate_ctxt cx, &span sp, &ty::t t) -> TypeRef {\n     ret type_of_inner(cx, sp, t);\n }\n \n-fn type_of_explicit_args(&@crate_ctxt cx, &span sp, &vec[ty::arg] inputs) ->\n+fn type_of_explicit_args(&@crate_ctxt cx, &span sp, &ty::arg[] inputs) ->\n    vec[TypeRef] {\n     let vec[TypeRef] atys = [];\n     for (ty::arg arg in inputs) {\n@@ -710,7 +710,7 @@ fn type_of_explicit_args(&@crate_ctxt cx, &span sp, &vec[ty::arg] inputs) ->\n //  - new_fn_ctxt\n //  - trans_args\n fn type_of_fn_full(&@crate_ctxt cx, &span sp, ast::proto proto,\n-                   &option::t[TypeRef] obj_self, &vec[ty::arg] inputs,\n+                   &option::t[TypeRef] obj_self, &ty::arg[] inputs,\n                    &ty::t output, uint ty_param_count) -> TypeRef {\n     let vec[TypeRef] atys = [];\n \n@@ -743,7 +743,7 @@ fn type_of_fn_full(&@crate_ctxt cx, &span sp, ast::proto proto,\n         atys +=\n             [T_fn_pair(cx.tn,\n                        type_of_fn_full(cx, sp, ast::proto_fn, none[TypeRef],\n-                                       [rec(mode=ty::mo_alias(false),\n+                                       ~[rec(mode=ty::mo_alias(false),\n                                             ty=output)], ty::mk_nil(cx.tcx),\n                                        0u))];\n     }\n@@ -754,14 +754,14 @@ fn type_of_fn_full(&@crate_ctxt cx, &span sp, ast::proto proto,\n }\n \n fn type_of_fn(&@crate_ctxt cx, &span sp, ast::proto proto,\n-              &vec[ty::arg] inputs, &ty::t output, uint ty_param_count) ->\n+              &ty::arg[] inputs, &ty::t output, uint ty_param_count) ->\n    TypeRef {\n     ret type_of_fn_full(cx, sp, proto, none[TypeRef], inputs, output,\n                         ty_param_count);\n }\n \n fn type_of_native_fn(&@crate_ctxt cx, &span sp, ast::native_abi abi,\n-                     &vec[ty::arg] inputs, &ty::t output, uint ty_param_count)\n+                     &ty::arg[] inputs, &ty::t output, uint ty_param_count)\n    -> TypeRef {\n     let vec[TypeRef] atys = [];\n     if (abi == ast::native_abi_rust) {\n@@ -2137,7 +2137,7 @@ fn trans_res_drop(@block_ctxt cx, ValueRef rs, &ast::def_id did,\n     } else {\n         auto params = decoder::get_type_param_count(ccx.tcx, did);\n         auto f_t = type_of_fn(ccx, cx.sp, ast::proto_fn,\n-                              [rec(mode=ty::mo_alias(false), ty=inner_t)],\n+                              ~[rec(mode=ty::mo_alias(false), ty=inner_t)],\n                               ty::mk_nil(ccx.tcx), params);\n         get_extern_const(ccx.externs, ccx.llmod,\n                          decoder::get_symbol(ccx.sess, did),\n@@ -4526,7 +4526,7 @@ fn trans_for_each(&@block_ctxt cx, &@ast::local local, &@ast::expr seq,\n     // and pass it in as a first class fn-arg to the iterator.\n     auto iter_body_llty =\n         type_of_fn_full(lcx.ccx, cx.sp, ast::proto_fn, none[TypeRef],\n-                        [rec(mode=ty::mo_alias(false), ty=decl_ty)],\n+                        ~[rec(mode=ty::mo_alias(false), ty=decl_ty)],\n                         ty::mk_nil(lcx.ccx.tcx), 0u);\n     let ValueRef lliterbody =\n         decl_internal_fastcall_fn(lcx.ccx.llmod, s, iter_body_llty);\n@@ -5551,7 +5551,7 @@ fn trans_args(&@block_ctxt cx, ValueRef llenv, &option::t[ValueRef] llobj,\n               &option::t[generic_info] gen, &option::t[ValueRef] lliterbody,\n               &vec[@ast::expr] es, &ty::t fn_ty) ->\n    tup(@block_ctxt, vec[ValueRef], ValueRef) {\n-    let vec[ty::arg] args = ty::ty_fn_args(cx.fcx.lcx.ccx.tcx, fn_ty);\n+    let ty::arg[] args = ty::ty_fn_args(cx.fcx.lcx.ccx.tcx, fn_ty);\n     let vec[ValueRef] llargs = [];\n     let vec[ValueRef] lltydescs = [];\n     let @block_ctxt bcx = cx;\n@@ -6342,7 +6342,7 @@ fn trans_put(&@block_ctxt cx, &option::t[@ast::expr] e) -> result {\n             auto e_ty = ty::expr_ty(cx.fcx.lcx.ccx.tcx, x);\n             auto arg = rec(mode=ty::mo_alias(false), ty=e_ty);\n             auto arg_tys =\n-                type_of_explicit_args(cx.fcx.lcx.ccx, x.span, [arg]);\n+                type_of_explicit_args(cx.fcx.lcx.ccx, x.span, ~[arg]);\n             auto r = trans_arg_expr(bcx, arg, arg_tys.(0), x);\n             bcx = r.bcx;\n             llargs += [r.val];\n@@ -6578,7 +6578,7 @@ fn mk_spawn_wrapper(&@block_ctxt cx, &@ast::expr func, &ty::t args_ty) ->\n     auto llmod = cx.fcx.lcx.ccx.llmod;\n     let TypeRef wrapper_fn_type =\n         type_of_fn(cx.fcx.lcx.ccx, cx.sp, ast::proto_fn,\n-                   [rec(mode=ty::mo_alias(false), ty=args_ty)], ty::idx_nil,\n+                   ~[rec(mode=ty::mo_alias(false), ty=args_ty)], ty::idx_nil,\n                    0u);\n     // TODO: construct a name based on tname\n \n@@ -7450,7 +7450,7 @@ fn copy_any_self_to_alloca(@fn_ctxt fcx, option::t[ty_self_pair] ty_self) {\n }\n \n fn copy_args_to_allocas(@fn_ctxt fcx, vec[ast::arg] args,\n-                        vec[ty::arg] arg_tys) {\n+                        &ty::arg[] arg_tys) {\n     auto bcx = new_raw_block_ctxt(fcx, fcx.llcopyargs);\n     let uint arg_n = 0u;\n     for (ast::arg aarg in args) {\n@@ -7468,7 +7468,7 @@ fn copy_args_to_allocas(@fn_ctxt fcx, vec[ast::arg] args,\n }\n \n fn add_cleanups_for_args(&@block_ctxt bcx, vec[ast::arg] args,\n-                         vec[ty::arg] arg_tys) {\n+                         &ty::arg[] arg_tys) {\n     let uint arg_n = 0u;\n     for (ast::arg aarg in args) {\n         if (aarg.mode == ast::val) {\n@@ -7485,7 +7485,7 @@ fn is_terminated(&@block_ctxt cx) -> bool {\n     ret llvm::LLVMIsATerminatorInst(inst) as int != 0;\n }\n \n-fn arg_tys_of_fn(&@crate_ctxt ccx,ast::node_id id) -> vec[ty::arg] {\n+fn arg_tys_of_fn(&@crate_ctxt ccx,ast::node_id id) -> ty::arg[] {\n     alt (ty::struct(ccx.tcx, ty::node_id_to_type(ccx.tcx, id))) {\n         case (ty::ty_fn(_, ?arg_tys, _, _, _)) { ret arg_tys; }\n     }\n@@ -7699,7 +7699,7 @@ fn trans_obj(@local_ctxt cx, &span sp, &ast::_obj ob, ast::node_id ctor_id,\n     create_llargs_for_fn_args(fcx, ast::proto_fn, none[ty_self_pair],\n                               ty::ret_ty_of_fn(ccx.tcx, ctor_id),\n                               fn_args, ty_params);\n-    let vec[ty::arg] arg_tys = arg_tys_of_fn(ccx, ctor_id);\n+    let ty::arg[] arg_tys = arg_tys_of_fn(ccx, ctor_id);\n     copy_args_to_allocas(fcx, fn_args, arg_tys);\n \n     //  Create the first block context in the function and keep a handle on it\n@@ -7747,7 +7747,7 @@ fn trans_obj(@local_ctxt cx, &span sp, &ast::_obj ob, ast::node_id ctor_id,\n     // a dtor, since otherwise they are never dropped, and the dtor never\n     // runs.\n     if (vec::len[ast::ty_param](ty_params) == 0u &&\n-            vec::len[ty::arg](arg_tys) == 0u) {\n+            std::ivec::len[ty::arg](arg_tys) == 0u) {\n         // If the object we're translating has no fields or type parameters,\n         // there's not much to do.\n "}, {"sha": "5022a1cb2e27614ac4c07f5c9a70c648aae414fb", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 29, "deletions": 28, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/108cc4e0ed7da8879694e2e8e9c2d548718ac492/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/108cc4e0ed7da8879694e2e8e9c2d548718ac492/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=108cc4e0ed7da8879694e2e8e9c2d548718ac492", "patch": "@@ -192,7 +192,7 @@ type field = rec(ast::ident ident, mt mt);\n type method =\n     rec(ast::proto proto,\n         ast::ident ident,\n-        vec[arg] inputs,\n+        arg[] inputs,\n         t output,\n         controlflow cf,\n         vec[@constr_def] constrs);\n@@ -266,8 +266,8 @@ tag sty {\n     ty_task;\n     ty_tup(mt[]);\n     ty_rec(field[]);\n-    ty_fn(ast::proto, vec[arg], t, controlflow, vec[@constr_def]);\n-    ty_native_fn(ast::native_abi, vec[arg], t);\n+    ty_fn(ast::proto, arg[], t, controlflow, vec[@constr_def]);\n+    ty_native_fn(ast::native_abi, arg[], t);\n     ty_obj(vec[method]);\n     ty_res(def_id, t, vec[t]);\n     ty_var(int); // type variable\n@@ -445,7 +445,7 @@ fn mk_raw_ty(&ctxt cx, &sty st, &option::t[str] cname) -> raw_t {\n         derive_flags_t(cx, has_params, has_vars, a.ty);\n     }\n     fn derive_flags_sig(&ctxt cx, &mutable bool has_params,\n-                        &mutable bool has_vars, &vec[arg] args, &t tt) {\n+                        &mutable bool has_vars, &arg[] args, &t tt) {\n         for (arg a in args) { derive_flags_arg(cx, has_params, has_vars, a); }\n         derive_flags_t(cx, has_params, has_vars, tt);\n     }\n@@ -597,12 +597,12 @@ fn mk_imm_tup(&ctxt cx, &t[] tys) -> t {\n \n fn mk_rec(&ctxt cx, &field[] fs) -> t { ret gen_ty(cx, ty_rec(fs)); }\n \n-fn mk_fn(&ctxt cx, &ast::proto proto, &vec[arg] args, &t ty, &controlflow cf,\n+fn mk_fn(&ctxt cx, &ast::proto proto, &arg[] args, &t ty, &controlflow cf,\n          &vec[@constr_def] constrs) -> t {\n     ret gen_ty(cx, ty_fn(proto, args, ty, cf, constrs));\n }\n \n-fn mk_native_fn(&ctxt cx, &ast::native_abi abi, &vec[arg] args, &t ty) -> t {\n+fn mk_native_fn(&ctxt cx, &ast::native_abi abi, &arg[] args, &t ty) -> t {\n     ret gen_ty(cx, ty_native_fn(abi, args, ty));\n }\n \n@@ -792,21 +792,21 @@ fn fold_ty(&ctxt cx, fold_mode fld, t ty_0) -> t {\n             ty = copy_cname(cx, mk_rec(cx, new_fields), ty);\n         }\n         case (ty_fn(?proto, ?args, ?ret_ty, ?cf, ?constrs)) {\n-            let vec[arg] new_args = [];\n+            let arg[] new_args = ~[];\n             for (arg a in args) {\n                 auto new_ty = fold_ty(cx, fld, a.ty);\n-                new_args += [rec(mode=a.mode, ty=new_ty)];\n+                new_args += ~[rec(mode=a.mode, ty=new_ty)];\n             }\n             ty =\n                 copy_cname(cx,\n                            mk_fn(cx, proto, new_args,\n                                  fold_ty(cx, fld, ret_ty), cf, constrs), ty);\n         }\n         case (ty_native_fn(?abi, ?args, ?ret_ty)) {\n-            let vec[arg] new_args = [];\n+            let arg[] new_args = ~[];\n             for (arg a in args) {\n                 auto new_ty = fold_ty(cx, fld, a.ty);\n-                new_args += [rec(mode=a.mode, ty=new_ty)];\n+                new_args += ~[rec(mode=a.mode, ty=new_ty)];\n             }\n             ty =\n                 copy_cname(cx,\n@@ -816,9 +816,10 @@ fn fold_ty(&ctxt cx, fold_mode fld, t ty_0) -> t {\n         case (ty_obj(?methods)) {\n             let vec[method] new_methods = [];\n             for (method m in methods) {\n-                let vec[arg] new_args = [];\n+                let arg[] new_args = ~[];\n                 for (arg a in m.inputs) {\n-                    new_args += [rec(mode=a.mode, ty=fold_ty(cx, fld, a.ty))];\n+                    new_args += ~[rec(mode=a.mode,\n+                                      ty=fold_ty(cx, fld, a.ty))];\n                 }\n                 new_methods +=\n                     [rec(proto=m.proto,\n@@ -1302,7 +1303,7 @@ fn hash_type_structure(&sty st) -> uint {\n         h += h << 5u + hash_ty(subty);\n         ret h;\n     }\n-    fn hash_fn(uint id, &vec[arg] args, &t rty) -> uint {\n+    fn hash_fn(uint id, &arg[] args, &t rty) -> uint {\n         auto h = id;\n         for (arg a in args) { h += h << 5u + hash_ty(a.ty); }\n         h += h << 5u + hash_ty(rty);\n@@ -1448,11 +1449,11 @@ fn equal_type_structures(&sty a, &sty b) -> bool {\n     fn equal_mt(&mt a, &mt b) -> bool {\n         ret a.mut == b.mut && eq_ty(a.ty, b.ty);\n     }\n-    fn equal_fn(&vec[arg] args_a, &t rty_a, &vec[arg] args_b, &t rty_b) ->\n+    fn equal_fn(&arg[] args_a, &t rty_a, &arg[] args_b, &t rty_b) ->\n        bool {\n         if (!eq_ty(rty_a, rty_b)) { ret false; }\n-        auto len = vec::len[arg](args_a);\n-        if (len != vec::len[arg](args_b)) { ret false; }\n+        auto len = ivec::len[arg](args_a);\n+        if (len != ivec::len[arg](args_b)) { ret false; }\n         auto i = 0u;\n         while (i < len) {\n             auto arg_a = args_a.(i);\n@@ -1788,7 +1789,7 @@ fn type_contains_params(&ctxt cx, &t typ) -> bool {\n \n \n // Type accessors for substructures of types\n-fn ty_fn_args(&ctxt cx, &t fty) -> vec[arg] {\n+fn ty_fn_args(&ctxt cx, &t fty) -> arg[] {\n     alt (struct(cx, fty)) {\n         case (ty::ty_fn(_, ?a, _, _, _)) { ret a; }\n         case (ty::ty_native_fn(_, ?a, _)) { ret a; }\n@@ -2073,20 +2074,20 @@ mod unify {\n     }\n     tag fn_common_res {\n         fn_common_res_err(result);\n-        fn_common_res_ok(vec[arg], t);\n+        fn_common_res_ok(arg[], t);\n     }\n     fn unify_fn_common(&@ctxt cx, &t expected, &t actual,\n-                       &vec[arg] expected_inputs, &t expected_output,\n-                       &vec[arg] actual_inputs, &t actual_output) ->\n+                       &arg[] expected_inputs, &t expected_output,\n+                       &arg[] actual_inputs, &t actual_output) ->\n        fn_common_res {\n-        auto expected_len = vec::len[arg](expected_inputs);\n-        auto actual_len = vec::len[arg](actual_inputs);\n+        auto expected_len = ivec::len[arg](expected_inputs);\n+        auto actual_len = ivec::len[arg](actual_inputs);\n         if (expected_len != actual_len) {\n             ret fn_common_res_err(ures_err(terr_arg_count));\n         }\n         // TODO: as above, we should have an iter2 iterator.\n \n-        let vec[arg] result_ins = [];\n+        let arg[] result_ins = ~[];\n         auto i = 0u;\n         while (i < expected_len) {\n             auto expected_input = expected_inputs.(i);\n@@ -2101,7 +2102,7 @@ mod unify {\n             auto result = unify_step(cx, expected_input.ty, actual_input.ty);\n             alt (result) {\n                 case (ures_ok(?rty)) {\n-                    result_ins += [rec(mode=result_mode, ty=rty)];\n+                    result_ins += ~[rec(mode=result_mode, ty=rty)];\n                 }\n                 case (_) { ret fn_common_res_err(result); }\n             }\n@@ -2116,8 +2117,8 @@ mod unify {\n         }\n     }\n     fn unify_fn(&@ctxt cx, &ast::proto e_proto, &ast::proto a_proto,\n-                &t expected, &t actual, &vec[arg] expected_inputs,\n-                &t expected_output, &vec[arg] actual_inputs, &t actual_output,\n+                &t expected, &t actual, &arg[] expected_inputs,\n+                &t expected_output, &arg[] actual_inputs, &t actual_output,\n                 &controlflow expected_cf, &controlflow actual_cf,\n                 &vec[@constr_def] expected_constrs,\n                 &vec[@constr_def] actual_constrs) -> result {\n@@ -2158,8 +2159,8 @@ mod unify {\n     }\n     fn unify_native_fn(&@ctxt cx, &ast::native_abi e_abi,\n                        &ast::native_abi a_abi, &t expected, &t actual,\n-                       &vec[arg] expected_inputs, &t expected_output,\n-                       &vec[arg] actual_inputs, &t actual_output) -> result {\n+                       &arg[] expected_inputs, &t expected_output,\n+                       &arg[] actual_inputs, &t actual_output) -> result {\n         if (e_abi != a_abi) { ret ures_err(terr_mismatch); }\n         auto t =\n             unify_fn_common(cx, expected, actual, expected_inputs,"}, {"sha": "50062f5e4923b2c60349751dccc58bc84495bf86", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 41, "deletions": 20, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/108cc4e0ed7da8879694e2e8e9c2d548718ac492/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/108cc4e0ed7da8879694e2e8e9c2d548718ac492/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=108cc4e0ed7da8879694e2e8e9c2d548718ac492", "patch": "@@ -308,9 +308,12 @@ fn ast_ty_to_ty(&ty::ctxt tcx, &ty_getter getter, &@ast::ty ast_ty) -> ty::t {\n             typ = ty::mk_rec(tcx, flds);\n         }\n         case (ast::ty_fn(?proto, ?inputs, ?output, ?cf, ?constrs)) {\n-            auto f = bind ast_arg_to_arg(tcx, getter, _);\n-            auto i = vec::map[ast::ty_arg, arg](f, inputs);\n+            auto i = ~[];\n+            for (ast::ty_arg ta in inputs) {\n+                i += ~[ast_arg_to_arg(tcx, getter, ta)];\n+            }\n             auto out_ty = ast_ty_to_ty(tcx, getter, output);\n+\n             let fn(&@ast::constr) -> @ty::constr_def g =\n                 bind ast_constr_to_constr(tcx, _);\n             let vec[@ty::constr_def] out_constrs = vec::map(g, constrs);\n@@ -336,8 +339,12 @@ fn ast_ty_to_ty(&ty::ctxt tcx, &ty_getter getter, &@ast::ty ast_ty) -> ty::t {\n             let vec[ty::method] tmeths = [];\n             auto f = bind ast_arg_to_arg(tcx, getter, _);\n             for (ast::ty_method m in meths) {\n-                auto ins = vec::map[ast::ty_arg, arg](f, m.node.inputs);\n+                auto ins = ~[];\n+                for (ast::ty_arg ta in m.node.inputs) {\n+                    ins += ~[ast_arg_to_arg(tcx, getter, ta)];\n+                }\n                 auto out = ast_ty_to_ty(tcx, getter, m.node.output);\n+\n                 let fn(&@ast::constr) -> @ty::constr_def g =\n                     bind ast_constr_to_constr(tcx, _);\n                 let vec[@ty::constr_def] out_constrs =\n@@ -453,8 +460,10 @@ mod collect {\n                      ast::proto proto, &vec[ast::ty_param] ty_params,\n                      &option::t[ast::def_id] def_id) ->\n        ty::ty_param_count_and_ty {\n-        auto input_tys = vec::map[ast::arg, arg](ty_of_arg, decl.inputs);\n+        auto input_tys = ~[];\n+        for (ast::arg a in decl.inputs) { input_tys += ~[ty_of_arg(a)]; }\n         auto output_ty = convert(decl.output);\n+\n         let fn(&@ast::constr) -> @ty::constr_def g =\n             bind ast_constr_to_constr(cx.tcx, _);\n         let vec[@ty::constr_def] out_constrs = vec::map(g, decl.constraints);\n@@ -475,8 +484,10 @@ mod collect {\n                             &vec[ast::ty_param] ty_params,\n                             &ast::def_id def_id) ->\n        ty::ty_param_count_and_ty {\n-        auto input_tys = vec::map[ast::arg, arg](ty_of_arg, decl.inputs);\n+        auto input_tys = ~[];\n+        for (ast::arg a in decl.inputs) { input_tys += ~[ty_of_arg(a)]; }\n         auto output_ty = convert(decl.output);\n+\n         auto t_fn = ty::mk_native_fn(cx.tcx, abi, input_tys, output_ty);\n         auto ty_param_count = vec::len[ast::ty_param](ty_params);\n         auto tpt = tup(ty_param_count, t_fn);\n@@ -519,8 +530,13 @@ mod collect {\n     fn ty_of_method(@ctxt cx, &@ast::method m) -> ty::method {\n         auto get = bind getter(cx, _);\n         auto convert = bind ast_ty_to_ty(cx.tcx, get, _);\n+\n+        auto inputs = ~[];\n+        for (ast::arg a in m.node.meth.decl.inputs) {\n+            inputs += ~[ty_of_arg(cx, a)];\n+        }\n         auto f = bind ty_of_arg(cx, _);\n-        auto inputs = vec::map[ast::arg, arg](f, m.node.meth.decl.inputs);\n+\n         auto output = convert(m.node.meth.decl.output);\n         let fn(&@ast::constr) -> @ty::constr_def g =\n             bind ast_constr_to_constr(cx.tcx, _);\n@@ -541,12 +557,14 @@ mod collect {\n                       ast::node_id ctor_id, &vec[ast::ty_param] ty_params) ->\n        ty::ty_param_count_and_ty {\n         auto t_obj = ty_of_obj(cx, id, obj_info, ty_params);\n-        let vec[arg] t_inputs = [];\n+\n+        let arg[] t_inputs = ~[];\n         for (ast::obj_field f in obj_info.fields) {\n             auto g = bind getter(cx, _);\n             auto t_field = ast_ty_to_ty(cx.tcx, g, f.ty);\n-            vec::push(t_inputs, rec(mode=ty::mo_alias(false), ty=t_field));\n+            t_inputs += ~[rec(mode=ty::mo_alias(false), ty=t_field)];\n         }\n+\n         auto t_fn = ty::mk_fn(cx.tcx, ast::proto_fn, t_inputs, t_obj._1,\n                               ast::return, []);\n         auto tpt = tup(t_obj._0, t_fn);\n@@ -650,10 +668,10 @@ mod collect {\n                 // should be called to resolve named types.\n \n                 auto f = bind getter(cx, _);\n-                let vec[arg] args = [];\n+                let arg[] args = ~[];\n                 for (ast::variant_arg va in variant.node.args) {\n                     auto arg_ty = ast_ty_to_ty(cx.tcx, f, va.ty);\n-                    args += [rec(mode=ty::mo_alias(false), ty=arg_ty)];\n+                    args += ~[rec(mode=ty::mo_alias(false), ty=arg_ty)];\n                 }\n                 auto tag_t = ty::mk_tag(cx.tcx, tag_id, ty_param_tys);\n                 // FIXME: this will be different for constrained types\n@@ -718,7 +736,7 @@ mod collect {\n \n                 auto args = ty::ty_fn_args(cx.tcx, tpt._1);\n                 i = 0u;\n-                while (i < vec::len[ty::arg](args)) {\n+                while (i < ivec::len[ty::arg](args)) {\n                     auto fld = object.fields.(i);\n                     write::ty_only(cx.tcx, fld.id, args.(i).ty);\n                     i += 1u;\n@@ -728,7 +746,7 @@ mod collect {\n                 alt (object.dtor) {\n                     case (none) {/* nothing to do */ }\n                     case (some(?m)) {\n-                        auto t = ty::mk_fn(cx.tcx, ast::proto_fn, [],\n+                        auto t = ty::mk_fn(cx.tcx, ast::proto_fn, ~[],\n                                    ty::mk_nil(cx.tcx), ast::return, []);\n                         write::ty_only(cx.tcx, m.node.id, t);\n                     }\n@@ -738,9 +756,9 @@ mod collect {\n                 auto t_arg = ty_of_arg(cx, f.decl.inputs.(0));\n                 auto t_res = ty::mk_res(cx.tcx, local_def(it.id), t_arg.ty,\n                                         mk_ty_params(cx, vec::len(tps)));\n-                auto t_ctor = ty::mk_fn(cx.tcx, ast::proto_fn, [t_arg],\n+                auto t_ctor = ty::mk_fn(cx.tcx, ast::proto_fn, ~[t_arg],\n                                         t_res, ast::return, []);\n-                auto t_dtor = ty::mk_fn(cx.tcx, ast::proto_fn, [t_arg],\n+                auto t_dtor = ty::mk_fn(cx.tcx, ast::proto_fn, ~[t_arg],\n                                         ty::mk_nil(cx.tcx), ast::return, []);\n                 write::ty_only(cx.tcx, it.id, t_res);\n                 write::ty_only(cx.tcx, ctor_id, t_ctor);\n@@ -1343,7 +1361,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n         }\n         // Check that the correct number of arguments were supplied.\n \n-        auto expected_arg_count = vec::len[ty::arg](arg_tys);\n+        auto expected_arg_count = ivec::len[ty::arg](arg_tys);\n         auto supplied_arg_count = vec::len[option::t[@ast::expr]](args);\n         if (expected_arg_count != supplied_arg_count) {\n             fcx.ccx.tcx.sess.span_fatal(sp,\n@@ -1794,7 +1812,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n             // Pull the argument and return types out.\n \n             auto proto_1;\n-            let vec[ty::arg] arg_tys_1 = [];\n+            let ty::arg[] arg_tys_1 = ~[];\n             auto rt_1;\n             auto fty = expr_ty(fcx.ccx.tcx, f);\n             auto t_1;\n@@ -1813,7 +1831,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n                     while (i < vec::len[option::t[@ast::expr]](args)) {\n                         alt (args.(i)) {\n                             case (some(_)) {/* no-op */ }\n-                            case (none) { arg_tys_1 += [arg_tys.(i)]; }\n+                            case (none) { arg_tys_1 += ~[arg_tys.(i)]; }\n                         }\n                         i += 1u;\n                     }\n@@ -2149,9 +2167,12 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n             }\n             fn ty_of_method(@crate_ctxt ccx, &@ast::method m) -> ty::method {\n                 auto convert = bind ast_ty_to_ty_crate(ccx, _);\n-                auto f = bind ty_of_arg(ccx, _);\n-                auto inputs =\n-                    vec::map[ast::arg, arg](f, m.node.meth.decl.inputs);\n+\n+                auto inputs = ~[];\n+                for (ast::arg aa in m.node.meth.decl.inputs) {\n+                    inputs += ~[ty_of_arg(ccx, aa)];\n+                }\n+\n                 auto output = convert(m.node.meth.decl.output);\n                 let fn(&@ast::constr) -> @ty::constr_def g =\n                     bind ast_constr_to_constr(ccx.tcx, _);"}, {"sha": "f0ebac66dbd965223636956174e04f75a63ffcd6", "filename": "src/comp/pretty/ppaux.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/108cc4e0ed7da8879694e2e8e9c2d548718ac492/src%2Fcomp%2Fpretty%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/108cc4e0ed7da8879694e2e8e9c2d548718ac492/src%2Fcomp%2Fpretty%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fpretty%2Fppaux.rs?ref=108cc4e0ed7da8879694e2e8e9c2d548718ac492", "patch": "@@ -48,17 +48,18 @@ fn ty_to_str(&ctxt cx, &t typ) -> str {\n         ret s + ty_to_str(cx, input.ty);\n     }\n     fn fn_to_str(&ctxt cx, ast::proto proto, option::t[ast::ident] ident,\n-                 vec[arg] inputs, t output, ast::controlflow cf,\n+                 &arg[] inputs, t output, ast::controlflow cf,\n                  &vec[@constr_def] constrs) -> str {\n-        auto f = bind fn_input_to_str(cx, _);\n         auto s;\n         alt (proto) {\n             case (ast::proto_iter) { s = \"iter\"; }\n             case (ast::proto_fn) { s = \"fn\"; }\n         }\n         alt (ident) { case (some(?i)) { s += \" \"; s += i; } case (_) { } }\n         s += \"(\";\n-        s += str::connect(vec::map[arg, str](f, inputs), \", \");\n+        auto strs = [];\n+        for (arg a in inputs) { strs += [fn_input_to_str(cx, a)]; }\n+        s += str::connect(strs, \", \");\n         s += \")\";\n         if (struct(cx, output) != ty_nil) {\n             alt (cf) {\n@@ -130,9 +131,8 @@ fn ty_to_str(&ctxt cx, &t typ) -> str {\n             s += fn_to_str(cx, proto, none, inputs, output, cf, constrs);\n         }\n         case (ty_native_fn(_, ?inputs, ?output)) {\n-            s +=\n-                fn_to_str(cx, ast::proto_fn, none, inputs, output,\n-                          ast::return, []);\n+            s += fn_to_str(cx, ast::proto_fn, none, inputs, output,\n+                           ast::return, []);\n         }\n         case (ty_obj(?meths)) {\n             auto f = bind method_to_str(cx, _);"}]}