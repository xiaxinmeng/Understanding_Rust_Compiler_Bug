{"sha": "3fa293c10fa9bc70130b0918fe0b2dab1deb8a82", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNmYTI5M2MxMGZhOWJjNzAxMzBiMDkxOGZlMGIyZGFiMWRlYjhhODI=", "commit": {"author": {"name": "Guillaume Pinot", "email": "texitoi@texitoi.eu", "date": "2014-05-09T15:32:06Z"}, "committer": {"name": "Guillaume Pinot", "email": "texitoi@texitoi.eu", "date": "2014-05-09T15:39:00Z"}, "message": "shootout-meteor improvement\n\n- 5-10% of raw speedup\n- parallelization of the search", "tree": {"sha": "ddb90ee9b31fbc637430313f31a29227412641a9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ddb90ee9b31fbc637430313f31a29227412641a9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3fa293c10fa9bc70130b0918fe0b2dab1deb8a82", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3fa293c10fa9bc70130b0918fe0b2dab1deb8a82", "html_url": "https://github.com/rust-lang/rust/commit/3fa293c10fa9bc70130b0918fe0b2dab1deb8a82", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3fa293c10fa9bc70130b0918fe0b2dab1deb8a82/comments", "author": {"login": "TeXitoi", "id": 5787066, "node_id": "MDQ6VXNlcjU3ODcwNjY=", "avatar_url": "https://avatars.githubusercontent.com/u/5787066?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TeXitoi", "html_url": "https://github.com/TeXitoi", "followers_url": "https://api.github.com/users/TeXitoi/followers", "following_url": "https://api.github.com/users/TeXitoi/following{/other_user}", "gists_url": "https://api.github.com/users/TeXitoi/gists{/gist_id}", "starred_url": "https://api.github.com/users/TeXitoi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TeXitoi/subscriptions", "organizations_url": "https://api.github.com/users/TeXitoi/orgs", "repos_url": "https://api.github.com/users/TeXitoi/repos", "events_url": "https://api.github.com/users/TeXitoi/events{/privacy}", "received_events_url": "https://api.github.com/users/TeXitoi/received_events", "type": "User", "site_admin": false}, "committer": {"login": "TeXitoi", "id": 5787066, "node_id": "MDQ6VXNlcjU3ODcwNjY=", "avatar_url": "https://avatars.githubusercontent.com/u/5787066?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TeXitoi", "html_url": "https://github.com/TeXitoi", "followers_url": "https://api.github.com/users/TeXitoi/followers", "following_url": "https://api.github.com/users/TeXitoi/following{/other_user}", "gists_url": "https://api.github.com/users/TeXitoi/gists{/gist_id}", "starred_url": "https://api.github.com/users/TeXitoi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TeXitoi/subscriptions", "organizations_url": "https://api.github.com/users/TeXitoi/orgs", "repos_url": "https://api.github.com/users/TeXitoi/repos", "events_url": "https://api.github.com/users/TeXitoi/events{/privacy}", "received_events_url": "https://api.github.com/users/TeXitoi/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "176df98a198ab67a5494bcca2f4e9f4979a7e2f9", "url": "https://api.github.com/repos/rust-lang/rust/commits/176df98a198ab67a5494bcca2f4e9f4979a7e2f9", "html_url": "https://github.com/rust-lang/rust/commit/176df98a198ab67a5494bcca2f4e9f4979a7e2f9"}], "stats": {"total": 201, "additions": 111, "deletions": 90}, "files": [{"sha": "45f8b1b9a839c5d7aac957c2a916ac237d0006b5", "filename": "src/test/bench/shootout-meteor.rs", "status": "modified", "additions": 111, "deletions": 90, "changes": 201, "blob_url": "https://github.com/rust-lang/rust/blob/3fa293c10fa9bc70130b0918fe0b2dab1deb8a82/src%2Ftest%2Fbench%2Fshootout-meteor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fa293c10fa9bc70130b0918fe0b2dab1deb8a82/src%2Ftest%2Fbench%2Fshootout-meteor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-meteor.rs?ref=3fa293c10fa9bc70130b0918fe0b2dab1deb8a82", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,11 +8,18 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![feature(phase)]\n+#[phase(syntax)] extern crate green;\n+extern crate sync;\n+\n+use sync::Arc;\n+\n+green_start!(main)\n+\n //\n // Utilities.\n //\n \n-\n // returns an infinite iterator of repeated applications of f to x,\n // i.e. [x, f(x), f(f(x)), ...], as haskell iterate function.\n fn iterate<'a, T>(x: T, f: |&T|: 'a -> T) -> Iterate<'a, T> {\n@@ -93,7 +100,7 @@ fn transform(piece: Vec<(int, int)> , all: bool) -> Vec<Vec<(int, int)>> {\n // Takes a piece with minimum coordinate (0, 0) (as generated by\n // transform).  Returns the corresponding mask if p translated by (dy,\n // dx) is on the board.\n-fn mask(dy: int, dx: int, id: uint, p: &[(int, int)]) -> Option<u64> {\n+fn mask(dy: int, dx: int, id: uint, p: &Vec<(int, int)>) -> Option<u64> {\n     let mut m = 1 << (50 + id);\n     for &(y, x) in p.iter() {\n         let x = x + dx + (y + (dy % 2)) / 2;\n@@ -105,7 +112,7 @@ fn mask(dy: int, dx: int, id: uint, p: &[(int, int)]) -> Option<u64> {\n     Some(m)\n }\n \n-// Makes every possible masks.  masks[id][i] correspond to every\n+// Makes every possible masks.  masks[i][id] correspond to every\n // possible masks for piece with identifier id with minimum coordinate\n // (i/5, i%5).\n fn make_masks() -> Vec<Vec<Vec<u64> > > {\n@@ -120,168 +127,182 @@ fn make_masks() -> Vec<Vec<Vec<u64> > > {\n         vec!((0,0),(0,1),(0,2),(1,0),(1,2)),\n         vec!((0,0),(0,1),(0,2),(1,2),(1,3)),\n         vec!((0,0),(0,1),(0,2),(0,3),(1,2)));\n-    let mut res = Vec::new();\n-    for (id, p) in pieces.move_iter().enumerate() {\n-        // To break the central symetry of the problem, every\n-        // transformation must be taken except for one piece (piece 3\n-        // here).\n-        let trans = transform(p, id != 3);\n-        let mut cur_piece = Vec::new();\n-        for dy in range(0, 10) {\n-            for dx in range(0, 5) {\n-                let masks =\n-                    trans.iter()\n-                    .filter_map(|t| mask(dy, dx, id, t.as_slice()))\n-                    .collect();\n-                cur_piece.push(masks);\n-            }\n-        }\n-        res.push(cur_piece);\n-    }\n-    res\n+\n+    // To break the central symetry of the problem, every\n+    // transformation must be taken except for one piece (piece 3\n+    // here).\n+    let transforms: Vec<Vec<Vec<(int, int)>>> =\n+        pieces.move_iter().enumerate()\n+        .map(|(id, p)| transform(p, id != 3))\n+        .collect();\n+\n+    range(0, 50).map(|yx| {\n+        transforms.iter().enumerate().map(|(id, t)| {\n+            t.iter().filter_map(|p| mask(yx / 5, yx % 5, id, p)).collect()\n+        }).collect()\n+    }).collect()\n }\n \n // Check if all coordinates can be covered by an unused piece and that\n // all unused piece can be placed on the board.\n-fn is_board_unfeasible(board: u64, masks: &[Vec<Vec<u64> > ]) -> bool {\n+fn is_board_unfeasible(board: u64, masks: &Vec<Vec<Vec<u64>>>) -> bool {\n     let mut coverable = board;\n-    for i in range(0, 50).filter(|&i| board & 1 << i == 0) {\n-        for (cur_id, pos_masks) in masks.iter().enumerate() {\n-            if board & 1 << (50 + cur_id) != 0 {continue;}\n-            for &cur_m in pos_masks.get(i as uint).iter() {\n-                if cur_m & board == 0 {coverable |= cur_m;}\n+    for (i, masks_at) in masks.iter().enumerate() {\n+        if board & 1 << i != 0 { continue; }\n+        for (cur_id, pos_masks) in masks_at.iter().enumerate() {\n+            if board & 1 << (50 + cur_id) != 0 { continue; }\n+            for &cur_m in pos_masks.iter() {\n+                if cur_m & board != 0 { continue; }\n+                coverable |= cur_m;\n+                // if every coordinates can be covered and every\n+                // piece can be used.\n+                if coverable == (1 << 60) - 1 { return false; }\n             }\n         }\n-        if coverable & (1 << i) == 0 {return true;}\n+        if coverable & 1 << i == 0 { return true; }\n     }\n-    // check if every coordinates can be covered and every piece can\n-    // be used.\n-    coverable != (1 << 60) - 1\n+    true\n }\n \n // Filter the masks that we can prove to result to unfeasible board.\n-fn filter_masks(masks: &[Vec<Vec<u64> > ]) -> Vec<Vec<Vec<u64> > > {\n-    masks.iter().map(\n-        |p| p.iter().map(\n-            |p| p.iter()\n-                .map(|&m| m)\n+fn filter_masks(masks: &mut Vec<Vec<Vec<u64>>>) {\n+    for i in range(0, masks.len()) {\n+        for j in range(0, masks.get(i).len()) {\n+            *masks.get_mut(i).get_mut(j) =\n+                masks.get(i).get(j).iter().map(|&m| m)\n                 .filter(|&m| !is_board_unfeasible(m, masks))\n-                .collect())\n-            .collect())\n-        .collect()\n+                .collect();\n+        }\n+    }\n }\n \n // Gets the identifier of a mask.\n fn get_id(m: u64) -> u8 {\n-    for id in range(0, 10) {\n-        if m & (1 << (id + 50)) != 0 {return id as u8;}\n+    for id in range(0u8, 10) {\n+        if m & (1 << (id + 50)) != 0 {return id;}\n     }\n     fail!(\"{:016x} does not have a valid identifier\", m);\n }\n \n // Converts a list of mask to a ~str.\n-fn to_utf8(raw_sol: &List<u64>) -> ~str {\n-    let mut sol: Vec<u8> = Vec::from_elem(50, '.' as u8);\n+fn to_vec(raw_sol: &List<u64>) -> Vec<u8> {\n+    let mut sol = Vec::from_elem(50, '.' as u8);\n     for &m in raw_sol.iter() {\n-        let id = get_id(m);\n-        for i in range(0, 50) {\n+        let id = '0' as u8 + get_id(m);\n+        for i in range(0u, 50) {\n             if m & 1 << i != 0 {\n-                *sol.get_mut(i as uint) = '0' as u8 + id;\n+                *sol.get_mut(i) = id;\n             }\n         }\n     }\n-    std::str::from_utf8(sol.as_slice()).unwrap().to_owned()\n+    sol\n }\n \n // Prints a solution in ~str form.\n-fn print_sol(sol: &str) {\n-    for (i, c) in sol.chars().enumerate() {\n+fn print_sol(sol: &Vec<u8>) {\n+    for (i, c) in sol.iter().enumerate() {\n         if (i) % 5 == 0 { println!(\"\"); }\n         if (i + 5) % 10 == 0 { print!(\" \"); }\n-        print!(\"{} \", c);\n+        print!(\"{} \", *c as char);\n     }\n     println!(\"\");\n }\n \n // The data managed during the search\n struct Data {\n-    // If more than stop_after is found, stop the search.\n-    stop_after: int,\n     // Number of solution found.\n     nb: int,\n     // Lexicographically minimal solution found.\n-    min: ~str,\n+    min: Vec<u8>,\n     // Lexicographically maximal solution found.\n-    max: ~str\n+    max: Vec<u8>\n+}\n+impl Data {\n+    fn new() -> Data {\n+        Data {nb: 0, min: vec!(), max: vec!()}\n+    }\n+    fn reduce_from(&mut self, other: Data) {\n+        self.nb += other.nb;\n+        let Data { min: min, max: max, ..} = other;\n+        if min < self.min { self.min = min; }\n+        if max > self.max { self.max = max; }\n+    }\n }\n \n // Records a new found solution.  Returns false if the search must be\n // stopped.\n-fn handle_sol(raw_sol: &List<u64>, data: &mut Data) -> bool {\n+fn handle_sol(raw_sol: &List<u64>, data: &mut Data) {\n     // because we break the symetry, 2 solutions correspond to a call\n     // to this method: the normal solution, and the same solution in\n     // reverse order, i.e. the board rotated by half a turn.\n     data.nb += 2;\n-    let sol1 = to_utf8(raw_sol);\n-    let sol2: ~str = sol1.chars().rev().collect();\n+    let sol1 = to_vec(raw_sol);\n+    let sol2: Vec<u8> = sol1.iter().rev().map(|x| *x).collect();\n \n     if data.nb == 2 {\n         data.min = sol1.clone();\n         data.max = sol1.clone();\n     }\n \n-    if sol1 < data.min {data.min = sol1.clone();}\n-    if sol2 < data.min {data.min = sol2.clone();}\n-    if sol1 > data.max {data.max = sol1;}\n-    if sol2 > data.max {data.max = sol2;}\n-    data.nb < data.stop_after\n+    if sol1 < data.min {data.min = sol1;}\n+    else if sol1 > data.max {data.max = sol1;}\n+    if sol2 < data.min {data.min = sol2;}\n+    else if sol2 > data.max {data.max = sol2;}\n }\n \n-// Search for every solutions.  Returns false if the search was\n-// stopped before the end.\n fn search(\n-    masks: &[Vec<Vec<u64> > ],\n+    masks: &Vec<Vec<Vec<u64>>>,\n     board: u64,\n-    mut i: int,\n+    mut i: uint,\n     cur: List<u64>,\n     data: &mut Data)\n-    -> bool\n {\n     // Search for the lesser empty coordinate.\n     while board & (1 << i)  != 0 && i < 50 {i += 1;}\n     // the board is full: a solution is found.\n     if i >= 50 {return handle_sol(&cur, data);}\n+    let masks_at = masks.get(i);\n \n     // for every unused piece\n-    for id in range(0, 10).filter(|id| board & (1 << (id + 50)) == 0) {\n+    for id in range(0u, 10).filter(|id| board & (1 << (id + 50)) == 0) {\n         // for each mask that fits on the board\n-        for &m in masks[id as uint].get(i as uint)\n-                                   .iter()\n-                                   .filter(|&m| board & *m == 0) {\n+        for &m in masks_at.get(id).iter().filter(|&m| board & *m == 0) {\n             // This check is too costy.\n             //if is_board_unfeasible(board | m, masks) {continue;}\n-            if !search(masks, board | m, i + 1, Cons(m, &cur), data) {\n-                return false;\n-            }\n+            search(masks, board | m, i + 1, Cons(m, &cur), data);\n         }\n     }\n-    return true;\n+}\n+\n+fn par_search(masks: Vec<Vec<Vec<u64>>>) -> Data {\n+    let masks = Arc::new(masks);\n+    let (tx, rx) = channel();\n+\n+    // launching the search in parallel on every masks at minimum\n+    // coordinate (0,0)\n+    for &m in masks.get(0).iter().flat_map(|masks_pos| masks_pos.iter()) {\n+        let masks = masks.clone();\n+        let tx = tx.clone();\n+        spawn(proc() {\n+            let mut data = Data::new();\n+            search(&*masks, m, 1, Cons(m, &Nil), &mut data);\n+            tx.send(data);\n+        });\n+    }\n+\n+    // collecting the results\n+    drop(tx);\n+    let mut data = rx.recv();\n+    for d in rx.iter() { data.reduce_from(d); }\n+    data\n }\n \n fn main () {\n-    let args = std::os::args();\n-    let args = args.as_slice();\n-    let stop_after = if args.len() <= 1 {\n-        2098\n-    } else {\n-        from_str(args[1]).unwrap()\n-    };\n-    let masks = make_masks();\n-    let masks = filter_masks(masks.as_slice());\n-    let mut data = Data {stop_after: stop_after, nb: 0, min: \"\".to_owned(), max: \"\".to_owned()};\n-    search(masks.as_slice(), 0, 0, Nil, &mut data);\n+    let mut masks = make_masks();\n+    filter_masks(&mut masks);\n+    let data = par_search(masks);\n     println!(\"{} solutions found\", data.nb);\n-    print_sol(data.min);\n-    print_sol(data.max);\n+    print_sol(&data.min);\n+    print_sol(&data.max);\n     println!(\"\");\n }"}]}