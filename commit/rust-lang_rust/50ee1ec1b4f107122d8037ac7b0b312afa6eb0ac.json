{"sha": "50ee1ec1b4f107122d8037ac7b0b312afa6eb0ac", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUwZWUxZWMxYjRmMTA3MTIyZDgwMzdhYzdiMGIzMTJhZmE2ZWIwYWM=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-06-06T20:21:18Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-07-05T19:38:42Z"}, "message": "rustc: Remove CrateId and all related support\n\nThis commit removes all support in the compiler for the #[crate_id] attribute\nand all of its derivative infrastructure. A list of the functionality removed is:\n\n* The #[crate_id] attribute no longer exists\n* There is no longer the concept of a version of a crate\n* Version numbers are no longer appended to symbol names\n* The --crate-id command line option has been removed\n\nTo migrate forward, rename #[crate_id] to #[crate_name] and only the name of the\ncrate itself should be mentioned. The version/path of the old crate id should be\nremoved.\n\nFor a transitionary state, the #[crate_id] attribute is still accepted if\nthe #[crate_name] is not present, but it is warned about if it is the only\nidentifier present.\n\nRFC: 0035-remove-crate-id\n[breaking-change]", "tree": {"sha": "6e812d9727a61ccea67f3bc922557d6d45736fbd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6e812d9727a61ccea67f3bc922557d6d45736fbd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/50ee1ec1b4f107122d8037ac7b0b312afa6eb0ac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/50ee1ec1b4f107122d8037ac7b0b312afa6eb0ac", "html_url": "https://github.com/rust-lang/rust/commit/50ee1ec1b4f107122d8037ac7b0b312afa6eb0ac", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/50ee1ec1b4f107122d8037ac7b0b312afa6eb0ac/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "aaff4e05e19b48d81e4ecb3337f288f42d06edd0", "url": "https://api.github.com/repos/rust-lang/rust/commits/aaff4e05e19b48d81e4ecb3337f288f42d06edd0", "html_url": "https://github.com/rust-lang/rust/commit/aaff4e05e19b48d81e4ecb3337f288f42d06edd0"}], "stats": {"total": 499, "additions": 230, "deletions": 269}, "files": [{"sha": "9cdf0fbb5e8fbd949352e1d8560160274a1f3412", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 61, "deletions": 48, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/50ee1ec1b4f107122d8037ac7b0b312afa6eb0ac/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50ee1ec1b4f107122d8037ac7b0b312afa6eb0ac/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=50ee1ec1b4f107122d8037ac7b0b312afa6eb0ac", "patch": "@@ -19,7 +19,7 @@ use lib::llvm::llvm;\n use lib::llvm::ModuleRef;\n use lib;\n use metadata::common::LinkMeta;\n-use metadata::{encoder, cstore, filesearch, csearch, loader};\n+use metadata::{encoder, cstore, filesearch, csearch, loader, creader};\n use middle::trans::context::CrateContext;\n use middle::trans::common::gensym_name;\n use middle::ty;\n@@ -40,9 +40,8 @@ use syntax::abi;\n use syntax::ast;\n use syntax::ast_map::{PathElem, PathElems, PathName};\n use syntax::ast_map;\n-use syntax::attr;\n use syntax::attr::AttrMetaMethods;\n-use syntax::crateid::CrateId;\n+use syntax::codemap::Span;\n use syntax::parse::token;\n \n #[deriving(Clone, PartialEq, PartialOrd, Ord, Eq)]\n@@ -547,18 +546,49 @@ pub mod write {\n  */\n \n // FIXME (#9639): This needs to handle non-utf8 `out_filestem` values\n-pub fn find_crate_id(attrs: &[ast::Attribute], out_filestem: &str) -> CrateId {\n-    match attr::find_crateid(attrs) {\n-        None => from_str(out_filestem).unwrap_or_else(|| {\n-            let mut s = out_filestem.chars().filter(|c| c.is_XID_continue());\n-            from_str(s.collect::<String>().as_slice())\n-                .or(from_str(\"rust-out\")).unwrap()\n-        }),\n-        Some(s) => s,\n+pub fn find_crate_name(sess: Option<&Session>,\n+                       attrs: &[ast::Attribute],\n+                       out_filestem: &str) -> String {\n+    use syntax::crateid::CrateId;\n+\n+    let validate = |s: String, span: Option<Span>| {\n+        creader::validate_crate_name(sess, s.as_slice(), span);\n+        s\n+    };\n+\n+    let crate_name = attrs.iter().find(|at| at.check_name(\"crate_name\"))\n+                          .and_then(|at| at.value_str().map(|s| (at, s)));\n+    match crate_name {\n+        Some((attr, s)) => return validate(s.get().to_string(), Some(attr.span)),\n+        None => {}\n+    }\n+    let crate_id = attrs.iter().find(|at| at.check_name(\"crate_id\"))\n+                        .and_then(|at| at.value_str().map(|s| (at, s)))\n+                        .and_then(|(at, s)| {\n+                            from_str::<CrateId>(s.get()).map(|id| (at, id))\n+                        });\n+    match crate_id {\n+        Some((attr, id)) => {\n+            match sess {\n+                Some(sess) => {\n+                    sess.span_warn(attr.span, \"the #[crate_id] attribute is \\\n+                                               deprecated for the \\\n+                                               #[crate_name] attribute\");\n+                }\n+                None => {}\n+            }\n+            return validate(id.name, Some(attr.span))\n+        }\n+        None => {}\n     }\n+    return validate(from_str(out_filestem).unwrap_or_else(|| {\n+        let mut s = out_filestem.chars().filter(|c| c.is_XID_continue());\n+        from_str(s.collect::<String>().as_slice())\n+            .or(from_str(\"rust-out\")).unwrap()\n+    }), None)\n }\n \n-pub fn crate_id_hash(crate_id: &CrateId) -> String {\n+pub fn crate_name_hash(sess: &Session, crate_name: &str) -> String {\n     // This calculates CMH as defined above. Note that we don't use the path of\n     // the crate id in the hash because lookups are only done by (name/vers),\n     // not by path.\n@@ -567,10 +597,9 @@ pub fn crate_id_hash(crate_id: &CrateId) -> String {\n     truncated_hash_result(&mut s).as_slice().slice_to(8).to_string()\n }\n \n-// FIXME (#9639): This needs to handle non-utf8 `out_filestem` values\n-pub fn build_link_meta(krate: &ast::Crate, out_filestem: &str) -> LinkMeta {\n+pub fn build_link_meta(krate: &ast::Crate, name: String) -> LinkMeta {\n     let r = LinkMeta {\n-        crateid: find_crate_id(krate.attrs.as_slice(), out_filestem),\n+        crate_name: name,\n         crate_hash: Svh::calculate(krate),\n     };\n     info!(\"{}\", r);\n@@ -594,7 +623,7 @@ fn symbol_hash(tcx: &ty::ctxt,\n     // to be independent of one another in the crate.\n \n     symbol_hasher.reset();\n-    symbol_hasher.input_str(link_meta.crateid.name.as_slice());\n+    symbol_hasher.input_str(link_meta.crate_name.as_slice());\n     symbol_hasher.input_str(\"-\");\n     symbol_hasher.input_str(link_meta.crate_hash.as_str());\n     symbol_hasher.input_str(\"-\");\n@@ -666,8 +695,7 @@ pub fn sanitize(s: &str) -> String {\n }\n \n pub fn mangle<PI: Iterator<PathElem>>(mut path: PI,\n-                                      hash: Option<&str>,\n-                                      vers: Option<&str>) -> String {\n+                                      hash: Option<&str>) -> String {\n     // Follow C++ namespace-mangling style, see\n     // http://en.wikipedia.org/wiki/Name_mangling for more info.\n     //\n@@ -698,25 +726,13 @@ pub fn mangle<PI: Iterator<PathElem>>(mut path: PI,\n         Some(s) => push(&mut n, s),\n         None => {}\n     }\n-    match vers {\n-        Some(s) => push(&mut n, s),\n-        None => {}\n-    }\n \n     n.push_char('E'); // End name-sequence.\n     n\n }\n \n-pub fn exported_name(path: PathElems, hash: &str, vers: &str) -> String {\n-    // The version will get mangled to have a leading '_', but it makes more\n-    // sense to lead with a 'v' b/c this is a version...\n-    let vers = if vers.len() > 0 && !char::is_XID_start(vers.char_at(0)) {\n-        format!(\"v{}\", vers)\n-    } else {\n-        vers.to_string()\n-    };\n-\n-    mangle(path, Some(hash), Some(vers.as_slice()))\n+pub fn exported_name(path: PathElems, hash: &str) -> String {\n+    mangle(path, Some(hash))\n }\n \n pub fn mangle_exported_name(ccx: &CrateContext, path: PathElems,\n@@ -741,9 +757,7 @@ pub fn mangle_exported_name(ccx: &CrateContext, path: PathElems,\n     hash.push_char(EXTRA_CHARS.as_bytes()[extra2] as char);\n     hash.push_char(EXTRA_CHARS.as_bytes()[extra3] as char);\n \n-    exported_name(path,\n-                  hash.as_slice(),\n-                  ccx.link_meta.crateid.version_or_default())\n+    exported_name(path, hash.as_slice())\n }\n \n pub fn mangle_internal_name_by_type_and_seq(ccx: &CrateContext,\n@@ -753,15 +767,11 @@ pub fn mangle_internal_name_by_type_and_seq(ccx: &CrateContext,\n     let path = [PathName(token::intern(s.as_slice())),\n                 gensym_name(name)];\n     let hash = get_symbol_hash(ccx, t);\n-    mangle(ast_map::Values(path.iter()), Some(hash.as_slice()), None)\n+    mangle(ast_map::Values(path.iter()), Some(hash.as_slice()))\n }\n \n pub fn mangle_internal_name_by_path_and_seq(path: PathElems, flav: &str) -> String {\n-    mangle(path.chain(Some(gensym_name(flav)).move_iter()), None, None)\n-}\n-\n-pub fn output_lib_filename(id: &CrateId) -> String {\n-    format!(\"{}-{}-{}\", id.name, crate_id_hash(id), id.version_or_default())\n+    mangle(path.chain(Some(gensym_name(flav)).move_iter()), None)\n }\n \n pub fn get_cc_prog(sess: &Session) -> String {\n@@ -803,14 +813,15 @@ fn remove(sess: &Session, path: &Path) {\n pub fn link_binary(sess: &Session,\n                    trans: &CrateTranslation,\n                    outputs: &OutputFilenames,\n-                   id: &CrateId) -> Vec<Path> {\n+                   crate_name: &str) -> Vec<Path> {\n     let mut out_filenames = Vec::new();\n     for &crate_type in sess.crate_types.borrow().iter() {\n         if invalid_output_for_target(sess, crate_type) {\n             sess.bug(format!(\"invalid output type `{}` for target os `{}`\",\n                              crate_type, sess.targ_cfg.os).as_slice());\n         }\n-        let out_file = link_binary_output(sess, trans, crate_type, outputs, id);\n+        let out_file = link_binary_output(sess, trans, crate_type, outputs,\n+                                          crate_name);\n         out_filenames.push(out_file);\n     }\n \n@@ -859,9 +870,11 @@ fn is_writeable(p: &Path) -> bool {\n     }\n }\n \n-pub fn filename_for_input(sess: &Session, crate_type: config::CrateType,\n-                          id: &CrateId, out_filename: &Path) -> Path {\n-    let libname = output_lib_filename(id);\n+pub fn filename_for_input(sess: &Session,\n+                          crate_type: config::CrateType,\n+                          name: &str,\n+                          out_filename: &Path) -> Path {\n+    let libname = format!(\"{}-{}\", name, crate_name_hash(sess, name));\n     match crate_type {\n         config::CrateTypeRlib => {\n             out_filename.with_filename(format!(\"lib{}.rlib\", libname))\n@@ -891,13 +904,13 @@ fn link_binary_output(sess: &Session,\n                       trans: &CrateTranslation,\n                       crate_type: config::CrateType,\n                       outputs: &OutputFilenames,\n-                      id: &CrateId) -> Path {\n+                      crate_name: &str) -> Path {\n     let obj_filename = outputs.temp_path(OutputTypeObject);\n     let out_filename = match outputs.single_output_file {\n         Some(ref file) => file.clone(),\n         None => {\n             let out_filename = outputs.path(OutputTypeExe);\n-            filename_for_input(sess, crate_type, id, &out_filename)\n+            filename_for_input(sess, crate_type, crate_name, &out_filename)\n         }\n     };\n "}, {"sha": "1474b4fddce4707e8d505906f3aec93e1d726fe7", "filename": "src/librustc/driver/config.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/50ee1ec1b4f107122d8037ac7b0b312afa6eb0ac/src%2Flibrustc%2Fdriver%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50ee1ec1b4f107122d8037ac7b0b312afa6eb0ac/src%2Flibrustc%2Fdriver%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fconfig.rs?ref=50ee1ec1b4f107122d8037ac7b0b312afa6eb0ac", "patch": "@@ -91,8 +91,8 @@ pub struct Options {\n     pub debugging_opts: u64,\n     /// Whether to write dependency files. It's (enabled, optional filename).\n     pub write_dependency_info: (bool, Option<Path>),\n-    /// Crate id-related things to maybe print. It's (crate_id, crate_name, crate_file_name).\n-    pub print_metas: (bool, bool, bool),\n+    /// Crate id-related things to maybe print. It's (crate_name, crate_file_name).\n+    pub print_metas: (bool, bool),\n     pub cg: CodegenOptions,\n     pub color: ColorConfig,\n }\n@@ -117,7 +117,7 @@ pub fn basic_options() -> Options {\n         no_analysis: false,\n         debugging_opts: 0,\n         write_dependency_info: (false, None),\n-        print_metas: (false, false, false),\n+        print_metas: (false, false),\n         cg: basic_codegen_options(),\n         color: Auto,\n     }\n@@ -505,7 +505,6 @@ pub fn optgroups() -> Vec<getopts::OptGroup> {\n                  \"[bin|lib|rlib|dylib|staticlib]\"),\n         optmulti(\"\", \"emit\", \"Comma separated list of types of output for the compiler to emit\",\n                  \"[asm|bc|ir|obj|link]\"),\n-        optflag(\"\", \"crate-id\", \"Output the crate id and exit\"),\n         optflag(\"\", \"crate-name\", \"Output the crate name and exit\"),\n         optflag(\"\", \"crate-file-name\", \"Output the file(s) that would be written if compilation \\\n               continued and exit\"),\n@@ -709,8 +708,7 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n                                  matches.opt_str(\"dep-info\")\n                                         .map(|p| Path::new(p)));\n \n-    let print_metas = (matches.opt_present(\"crate-id\"),\n-                       matches.opt_present(\"crate-name\"),\n+    let print_metas = (matches.opt_present(\"crate-name\"),\n                        matches.opt_present(\"crate-file-name\"));\n     let cg = build_codegen_options(matches);\n "}, {"sha": "356f56aac6387ce9ca74c873d743cde8a4f8045e", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 33, "deletions": 31, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/50ee1ec1b4f107122d8037ac7b0b312afa6eb0ac/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50ee1ec1b4f107122d8037ac7b0b312afa6eb0ac/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=50ee1ec1b4f107122d8037ac7b0b312afa6eb0ac", "patch": "@@ -41,7 +41,6 @@ use std::io::MemReader;\n use syntax::ast;\n use syntax::attr;\n use syntax::attr::{AttrMetaMethods};\n-use syntax::crateid::CrateId;\n use syntax::parse;\n use syntax::parse::token;\n use syntax::print::{pp, pprust};\n@@ -69,33 +68,33 @@ pub fn compile_input(sess: Session,\n     // large chunks of memory alive and we want to free them as soon as\n     // possible to keep the peak memory usage low\n     let (outputs, trans, sess) = {\n-        let (outputs, expanded_crate, ast_map) = {\n+        let (outputs, expanded_crate, ast_map, id) = {\n             let krate = phase_1_parse_input(&sess, cfg, input);\n             if stop_after_phase_1(&sess) { return; }\n             let outputs = build_output_filenames(input,\n                                                  outdir,\n                                                  output,\n                                                  krate.attrs.as_slice(),\n                                                  &sess);\n-            let id = link::find_crate_id(krate.attrs.as_slice(),\n-                                         outputs.out_filestem.as_slice());\n+            let id = link::find_crate_name(Some(&sess), krate.attrs.as_slice(),\n+                                           outputs.out_filestem.as_slice());\n             let (expanded_crate, ast_map)\n-                = match phase_2_configure_and_expand(&sess, krate, &id) {\n+                = match phase_2_configure_and_expand(&sess, krate, id.as_slice()) {\n                     None => return,\n                     Some(p) => p,\n                 };\n \n-            (outputs, expanded_crate, ast_map)\n+            (outputs, expanded_crate, ast_map, id)\n         };\n-        write_out_deps(&sess, input, &outputs, &expanded_crate);\n+        write_out_deps(&sess, input, &outputs, id.as_slice());\n \n         if stop_after_phase_2(&sess) { return; }\n \n-        let analysis = phase_3_run_analysis_passes(sess, &expanded_crate, ast_map);\n+        let analysis = phase_3_run_analysis_passes(sess, &expanded_crate,\n+                                                   ast_map, id);\n         phase_save_analysis(&analysis.ty_cx.sess, &expanded_crate, &analysis, outdir);\n         if stop_after_phase_3(&analysis.ty_cx.sess) { return; }\n-        let (tcx, trans) = phase_4_translate_to_llvm(expanded_crate,\n-                                                     analysis, &outputs);\n+        let (tcx, trans) = phase_4_translate_to_llvm(expanded_crate, analysis);\n \n         // Discard interned strings as they are no longer required.\n         token::get_ident_interner().clear();\n@@ -181,11 +180,12 @@ pub fn phase_1_parse_input(sess: &Session, cfg: ast::CrateConfig, input: &Input)\n /// Returns `None` if we're aborting after handling -W help.\n pub fn phase_2_configure_and_expand(sess: &Session,\n                                     mut krate: ast::Crate,\n-                                    crate_id: &CrateId)\n+                                    crate_name: &str)\n                                     -> Option<(ast::Crate, syntax::ast_map::Map)> {\n     let time_passes = sess.time_passes();\n \n-    *sess.crate_types.borrow_mut() = collect_crate_types(sess, krate.attrs.as_slice());\n+    *sess.crate_types.borrow_mut() =\n+        collect_crate_types(sess, krate.attrs.as_slice());\n \n     time(time_passes, \"gated feature checking\", (), |_|\n          front::feature_gate::check_crate(sess, &krate));\n@@ -247,7 +247,7 @@ pub fn phase_2_configure_and_expand(sess: &Session,\n             }\n             let cfg = syntax::ext::expand::ExpansionConfig {\n                 deriving_hash_type_parameter: sess.features.default_type_params.get(),\n-                crate_id: crate_id.clone(),\n+                crate_name: crate_name.to_string(),\n             };\n             syntax::ext::expand::expand_crate(&sess.parse_sess,\n                                               cfg,\n@@ -286,14 +286,16 @@ pub struct CrateAnalysis {\n     pub public_items: middle::privacy::PublicItems,\n     pub ty_cx: ty::ctxt,\n     pub reachable: NodeSet,\n+    pub name: String,\n }\n \n /// Run the resolution, typechecking, region checking and other\n /// miscellaneous analysis passes on the crate. Return various\n /// structures carrying the results of the analysis.\n pub fn phase_3_run_analysis_passes(sess: Session,\n                                    krate: &ast::Crate,\n-                                   ast_map: syntax::ast_map::Map) -> CrateAnalysis {\n+                                   ast_map: syntax::ast_map::Map,\n+                                   name: String) -> CrateAnalysis {\n \n     let time_passes = sess.time_passes();\n \n@@ -398,6 +400,7 @@ pub fn phase_3_run_analysis_passes(sess: Session,\n         exported_items: exported_items,\n         public_items: public_items,\n         reachable: reachable_map,\n+        name: name,\n     }\n }\n \n@@ -426,16 +429,15 @@ pub struct CrateTranslation {\n /// Run the translation phase to LLVM, after which the AST and analysis can\n /// be discarded.\n pub fn phase_4_translate_to_llvm(krate: ast::Crate,\n-                                 analysis: CrateAnalysis,\n-                                 outputs: &OutputFilenames) -> (ty::ctxt, CrateTranslation) {\n+                                 analysis: CrateAnalysis) -> (ty::ctxt, CrateTranslation) {\n     let time_passes = analysis.ty_cx.sess.time_passes();\n \n     time(time_passes, \"resolving dependency formats\", (), |_|\n          dependency_format::calculate(&analysis.ty_cx));\n \n     // Option dance to work around the lack of stack once closures.\n     time(time_passes, \"translation\", (krate, analysis), |(krate, analysis)|\n-         trans::base::trans_crate(krate, analysis, outputs))\n+         trans::base::trans_crate(krate, analysis))\n }\n \n /// Run LLVM itself, producing a bitcode file, assembly file or object file\n@@ -473,7 +475,7 @@ pub fn phase_6_link_output(sess: &Session,\n          link::link_binary(sess,\n                            trans,\n                            outputs,\n-                           &trans.link.crateid));\n+                           trans.link.crate_name.as_slice()));\n }\n \n pub fn stop_after_phase_3(sess: &Session) -> bool {\n@@ -514,17 +516,16 @@ pub fn stop_after_phase_5(sess: &Session) -> bool {\n fn write_out_deps(sess: &Session,\n                   input: &Input,\n                   outputs: &OutputFilenames,\n-                  krate: &ast::Crate) {\n-    let id = link::find_crate_id(krate.attrs.as_slice(),\n-                                 outputs.out_filestem.as_slice());\n+                  id: &str) {\n \n     let mut out_filenames = Vec::new();\n     for output_type in sess.opts.output_types.iter() {\n         let file = outputs.path(*output_type);\n         match *output_type {\n             link::OutputTypeExe => {\n                 for output in sess.crate_types.borrow().iter() {\n-                    let p = link::filename_for_input(sess, *output, &id, &file);\n+                    let p = link::filename_for_input(sess, *output,\n+                                                     id, &file);\n                     out_filenames.push(p);\n                 }\n             }\n@@ -649,13 +650,14 @@ pub fn pretty_print_input(sess: Session,\n                           ppm: PpMode,\n                           ofile: Option<Path>) {\n     let krate = phase_1_parse_input(&sess, cfg, input);\n-    let id = link::find_crate_id(krate.attrs.as_slice(),\n-                                 input.filestem().as_slice());\n+    let id = link::find_crate_name(Some(&sess), krate.attrs.as_slice(),\n+                                   input.filestem().as_slice());\n \n     let (krate, ast_map, is_expanded) = match ppm {\n         PpmExpanded | PpmExpandedIdentified | PpmTyped | PpmFlowGraph(_) => {\n             let (krate, ast_map)\n-                = match phase_2_configure_and_expand(&sess, krate, &id) {\n+                = match phase_2_configure_and_expand(&sess, krate,\n+                                                     id.as_slice()) {\n                     None => return,\n                     Some(p) => p,\n                 };\n@@ -695,7 +697,7 @@ pub fn pretty_print_input(sess: Session,\n         }\n         PpmTyped => {\n             let ast_map = ast_map.expect(\"--pretty=typed missing ast_map\");\n-            let analysis = phase_3_run_analysis_passes(sess, &krate, ast_map);\n+            let analysis = phase_3_run_analysis_passes(sess, &krate, ast_map, id);\n             let annotation = TypedAnnotation {\n                 analysis: analysis\n             };\n@@ -728,7 +730,8 @@ pub fn pretty_print_input(sess: Session,\n                     }\n                 }\n             };\n-            let analysis = phase_3_run_analysis_passes(sess, &krate, ast_map);\n+            let analysis = phase_3_run_analysis_passes(sess, &krate,\n+                                                       ast_map, id);\n             print_flowgraph(analysis, block, out)\n         }\n         _ => {\n@@ -895,11 +898,10 @@ pub fn build_output_filenames(input: &Input,\n \n             let mut stem = input.filestem();\n \n-            // If a crateid is present, we use it as the link name\n-            let crateid = attr::find_crateid(attrs);\n-            match crateid {\n+            // If a crate name is present, we use it as the link name\n+            match attr::find_crate_name(attrs) {\n                 None => {}\n-                Some(crateid) => stem = crateid.name.to_string(),\n+                Some(name) => stem = name.get().to_string(),\n             }\n             OutputFilenames {\n                 out_directory: dirpath,"}, {"sha": "f368e0ba7c8a5510eaef85de67036c123f7b14c6", "filename": "src/librustc/driver/mod.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/50ee1ec1b4f107122d8037ac7b0b312afa6eb0ac/src%2Flibrustc%2Fdriver%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50ee1ec1b4f107122d8037ac7b0b312afa6eb0ac/src%2Flibrustc%2Fdriver%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fmod.rs?ref=50ee1ec1b4f107122d8037ac7b0b312afa6eb0ac", "patch": "@@ -294,28 +294,25 @@ fn print_crate_info(sess: &Session,\n                     odir: &Option<Path>,\n                     ofile: &Option<Path>)\n                     -> bool {\n-    let (crate_id, crate_name, crate_file_name) = sess.opts.print_metas;\n+    let (crate_name, crate_file_name) = sess.opts.print_metas;\n     // these nasty nested conditions are to avoid doing extra work\n-    if crate_id || crate_name || crate_file_name {\n+    if crate_name || crate_file_name {\n         let attrs = parse_crate_attrs(sess, input);\n         let t_outputs = driver::build_output_filenames(input,\n                                                        odir,\n                                                        ofile,\n                                                        attrs.as_slice(),\n                                                        sess);\n-        let id = link::find_crate_id(attrs.as_slice(),\n-                                     t_outputs.out_filestem.as_slice());\n+        let id = link::find_crate_name(Some(sess), attrs.as_slice(),\n+                                       t_outputs.out_filestem.as_slice());\n \n-        if crate_id {\n-            println!(\"{}\", id.to_str());\n-        }\n         if crate_name {\n-            println!(\"{}\", id.name);\n+            println!(\"{}\", id);\n         }\n         if crate_file_name {\n             let crate_types = driver::collect_crate_types(sess, attrs.as_slice());\n             for &style in crate_types.iter() {\n-                let fname = link::filename_for_input(sess, style, &id,\n+                let fname = link::filename_for_input(sess, style, id.as_slice(),\n                                                      &t_outputs.with_extension(\"\"));\n                 println!(\"{}\", fname.filename_display());\n             }"}, {"sha": "351c9a6b771672c6506c4c95f04d1419a8c71b87", "filename": "src/librustc/front/std_inject.rs", "status": "modified", "additions": 4, "deletions": 18, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/50ee1ec1b4f107122d8037ac7b0b312afa6eb0ac/src%2Flibrustc%2Ffront%2Fstd_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50ee1ec1b4f107122d8037ac7b0b312afa6eb0ac/src%2Flibrustc%2Ffront%2Fstd_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fstd_inject.rs?ref=50ee1ec1b4f107122d8037ac7b0b312afa6eb0ac", "patch": "@@ -25,8 +25,6 @@ use syntax::util::small_vector::SmallVector;\n use std::mem;\n use std::gc::{Gc, GC};\n \n-pub static VERSION: &'static str = \"0.11.0\";\n-\n pub fn maybe_inject_crates_ref(sess: &Session, krate: ast::Crate)\n                                -> ast::Crate {\n     if use_std(&krate) {\n@@ -60,24 +58,12 @@ struct StandardLibraryInjector<'a> {\n     sess: &'a Session,\n }\n \n-pub fn with_version(krate: &str) -> Option<(InternedString, ast::StrStyle)> {\n-    match option_env!(\"CFG_DISABLE_INJECT_STD_VERSION\") {\n-        Some(\"1\") => None,\n-        _ => {\n-            Some((token::intern_and_get_ident(format!(\"{}#{}\",\n-                                                      krate,\n-                                                      VERSION).as_slice()),\n-                  ast::CookedStr))\n-        }\n-    }\n-}\n-\n impl<'a> fold::Folder for StandardLibraryInjector<'a> {\n     fn fold_crate(&mut self, mut krate: ast::Crate) -> ast::Crate {\n         let mut vis = vec!(ast::ViewItem {\n             node: ast::ViewItemExternCrate(token::str_to_ident(\"std\"),\n-                                         with_version(\"std\"),\n-                                         ast::DUMMY_NODE_ID),\n+                                           None,\n+                                           ast::DUMMY_NODE_ID),\n             attrs: vec!(\n                 attr::mk_attr_outer(attr::mk_attr_id(), attr::mk_list_item(\n                         InternedString::new(\"phase\"),\n@@ -95,8 +81,8 @@ impl<'a> fold::Folder for StandardLibraryInjector<'a> {\n         if use_start(&krate) && any_exe {\n             vis.push(ast::ViewItem {\n                 node: ast::ViewItemExternCrate(token::str_to_ident(\"native\"),\n-                                             with_version(\"native\"),\n-                                             ast::DUMMY_NODE_ID),\n+                                               None,\n+                                               ast::DUMMY_NODE_ID),\n                 attrs: Vec::new(),\n                 vis: ast::Inherited,\n                 span: DUMMY_SP"}, {"sha": "b2c6840ad227292b5f61a6827b192e431190ad50", "filename": "src/librustc/front/test.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/50ee1ec1b4f107122d8037ac7b0b312afa6eb0ac/src%2Flibrustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50ee1ec1b4f107122d8037ac7b0b312afa6eb0ac/src%2Flibrustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ftest.rs?ref=50ee1ec1b4f107122d8037ac7b0b312afa6eb0ac", "patch": "@@ -15,7 +15,6 @@\n \n use driver::session::Session;\n use front::config;\n-use front::std_inject::with_version;\n \n use std::cell::RefCell;\n use std::gc::{Gc, GC};\n@@ -154,7 +153,7 @@ fn generate_test_harness(sess: &Session, krate: ast::Crate)\n         ext_cx: ExtCtxt::new(&sess.parse_sess, sess.opts.cfg.clone(),\n                              ExpansionConfig {\n                                  deriving_hash_type_parameter: false,\n-                                 crate_id: from_str(\"test\").unwrap(),\n+                                 crate_name: \"test\".to_string(),\n                              }),\n         path: RefCell::new(Vec::new()),\n         testfns: RefCell::new(Vec::new()),\n@@ -298,9 +297,7 @@ fn mk_std(cx: &TestCtxt) -> ast::ViewItem {\n                                         ast::DUMMY_NODE_ID))),\n          ast::Public)\n     } else {\n-        (ast::ViewItemExternCrate(id_test,\n-                               with_version(\"test\"),\n-                               ast::DUMMY_NODE_ID),\n+        (ast::ViewItemExternCrate(id_test, None, ast::DUMMY_NODE_ID),\n          ast::Inherited)\n     };\n     ast::ViewItem {\n@@ -395,8 +392,8 @@ fn mk_tests(cx: &TestCtxt) -> Gc<ast::Item> {\n }\n \n fn is_test_crate(krate: &ast::Crate) -> bool {\n-    match attr::find_crateid(krate.attrs.as_slice()) {\n-        Some(ref s) if \"test\" == s.name.as_slice() => true,\n+    match attr::find_crate_name(krate.attrs.as_slice()) {\n+        Some(ref s) if \"test\" == s.get().as_slice() => true,\n         _ => false\n     }\n }"}, {"sha": "cdeecf3a080fe2f26fadafe77e2b673d17bb38fe", "filename": "src/librustc/metadata/common.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/50ee1ec1b4f107122d8037ac7b0b312afa6eb0ac/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50ee1ec1b4f107122d8037ac7b0b312afa6eb0ac/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcommon.rs?ref=50ee1ec1b4f107122d8037ac7b0b312afa6eb0ac", "patch": "@@ -11,7 +11,6 @@\n #![allow(non_camel_case_types)]\n \n use std::mem;\n-use syntax::crateid::CrateId;\n use back::svh::Svh;\n \n // EBML enum definitions and utils shared by the encoder and decoder\n@@ -71,9 +70,9 @@ pub static tag_crate_deps: uint = 0x18;\n pub static tag_crate_dep: uint = 0x19;\n \n pub static tag_crate_hash: uint = 0x1a;\n-pub static tag_crate_crateid: uint = 0x1b;\n+pub static tag_crate_crate_name: uint = 0x1b;\n \n-pub static tag_crate_dep_crateid: uint = 0x1d;\n+pub static tag_crate_dep_crate_name: uint = 0x1d;\n pub static tag_crate_dep_hash: uint = 0x1e;\n \n pub static tag_mod_impl: uint = 0x1f;\n@@ -215,7 +214,7 @@ pub static tag_items_data_item_stability: uint = 0x92;\n \n #[deriving(Clone, Show)]\n pub struct LinkMeta {\n-    pub crateid: CrateId,\n+    pub crate_name: String,\n     pub crate_hash: Svh,\n }\n "}, {"sha": "62178e9cd2869fc83623f32c9b81f0c32f0ddd0b", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 51, "deletions": 42, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/50ee1ec1b4f107122d8037ac7b0b312afa6eb0ac/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50ee1ec1b4f107122d8037ac7b0b312afa6eb0ac/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=50ee1ec1b4f107122d8037ac7b0b312afa6eb0ac", "patch": "@@ -12,7 +12,6 @@\n \n //! Validates all used crates and extern libraries and loads their metadata\n \n-use back::link;\n use back::svh::Svh;\n use driver::session::Session;\n use driver::{driver, config};\n@@ -33,7 +32,6 @@ use syntax::codemap::{Span};\n use syntax::diagnostic::SpanHandler;\n use syntax::parse::token::InternedString;\n use syntax::parse::token;\n-use syntax::crateid::CrateId;\n use syntax::visit;\n \n struct Env<'a> {\n@@ -69,7 +67,7 @@ impl<'a> visit::Visitor<()> for Env<'a> {\n fn dump_crates(cstore: &CStore) {\n     debug!(\"resolved crates:\");\n     cstore.iter_crate_data_origins(|_, data, opt_source| {\n-        debug!(\"crate_id: {}\", data.crate_id());\n+        debug!(\"  name: {}\", data.name());\n         debug!(\"  cnum: {}\", data.cnum);\n         debug!(\"  hash: {}\", data.hash());\n         opt_source.map(|cs| {\n@@ -83,20 +81,17 @@ fn dump_crates(cstore: &CStore) {\n fn warn_if_multiple_versions(diag: &SpanHandler, cstore: &CStore) {\n     let mut map = HashMap::new();\n     cstore.iter_crate_data(|cnum, data| {\n-        let crateid = data.crate_id();\n-        let key = (crateid.name.clone(), crateid.path.clone());\n-        map.find_or_insert_with(key, |_| Vec::new()).push(cnum);\n+        map.find_or_insert_with(data.name(), |_| Vec::new()).push(cnum);\n     });\n \n-    for ((name, _), dupes) in map.move_iter() {\n+    for (name, dupes) in map.move_iter() {\n         if dupes.len() == 1 { continue }\n         diag.handler().warn(\n-            format!(\"using multiple versions of crate `{}`\",\n-                    name).as_slice());\n+            format!(\"using multiple versions of crate `{}`\", name).as_slice());\n         for dupe in dupes.move_iter() {\n             let data = cstore.get_crate_data(dupe);\n             diag.span_note(data.span, \"used here\");\n-            loader::note_crateid_attr(diag, &data.crate_id());\n+            loader::note_crate_name(diag, data.name().as_slice());\n         }\n     }\n }\n@@ -129,7 +124,7 @@ fn visit_view_item(e: &mut Env, i: &ast::ViewItem) {\n             let (cnum, _, _) = resolve_crate(e,\n                                              &None,\n                                              info.ident.as_slice(),\n-                                             &info.crate_id,\n+                                             info.name.as_slice(),\n                                              None,\n                                              i.span);\n             e.sess.cstore.add_extern_mod_stmt_cnum(info.id, cnum);\n@@ -140,7 +135,7 @@ fn visit_view_item(e: &mut Env, i: &ast::ViewItem) {\n \n struct CrateInfo {\n     ident: String,\n-    crate_id: CrateId,\n+    name: String,\n     id: ast::NodeId,\n     should_link: bool,\n }\n@@ -151,22 +146,18 @@ fn extract_crate_info(e: &Env, i: &ast::ViewItem) -> Option<CrateInfo> {\n             let ident = token::get_ident(ident);\n             debug!(\"resolving extern crate stmt. ident: {:?} path_opt: {:?}\",\n                    ident, path_opt);\n-            let crate_id = match *path_opt {\n+            let name = match *path_opt {\n                 Some((ref path_str, _)) => {\n-                    let crateid: Option<CrateId> = from_str(path_str.get());\n-                    match crateid {\n-                        None => {\n-                            e.sess.span_err(i.span, \"malformed crate id\");\n-                            return None\n-                        }\n-                        Some(id) => id\n-                    }\n+                    let name = path_str.get().to_str();\n+                    validate_crate_name(Some(e.sess), name.as_slice(),\n+                                        Some(i.span));\n+                    name\n                 }\n-                None => from_str(ident.get().to_str().as_slice()).unwrap()\n+                None => ident.get().to_str(),\n             };\n             Some(CrateInfo {\n                 ident: ident.get().to_string(),\n-                crate_id: crate_id,\n+                name: name,\n                 id: id,\n                 should_link: should_link(i),\n             })\n@@ -175,6 +166,28 @@ fn extract_crate_info(e: &Env, i: &ast::ViewItem) -> Option<CrateInfo> {\n     }\n }\n \n+pub fn validate_crate_name(sess: Option<&Session>, s: &str, sp: Option<Span>) {\n+    let err = |s: &str| {\n+        match (sp, sess) {\n+            (_, None) => fail!(\"{}\", s),\n+            (Some(sp), Some(sess)) => sess.span_err(sp, s),\n+            (None, Some(sess)) => sess.err(s),\n+        }\n+    };\n+    if s.len() == 0 {\n+        err(\"crate name must not be empty\");\n+    }\n+    for c in s.chars() {\n+        if c.is_alphanumeric() { continue }\n+        if c == '_' || c == '-' { continue }\n+        err(format!(\"invalid character in crate name: `{}`\", c).as_slice());\n+    }\n+    match sess {\n+        Some(sess) => sess.abort_if_errors(),\n+        None => {}\n+    }\n+}\n+\n fn visit_item(e: &Env, i: &ast::Item) {\n     match i.node {\n         ast::ItemForeignMod(ref fm) => {\n@@ -263,12 +276,11 @@ fn visit_item(e: &Env, i: &ast::Item) {\n     }\n }\n \n-fn existing_match(e: &Env, crate_id: &CrateId,\n+fn existing_match(e: &Env, name: &str,\n                   hash: Option<&Svh>) -> Option<ast::CrateNum> {\n     let mut ret = None;\n     e.sess.cstore.iter_crate_data(|cnum, data| {\n-        let other_id = data.crate_id();\n-        if crate_id.matches(&other_id) {\n+        if data.name().as_slice() == name {\n             let other_hash = data.hash();\n             match hash {\n                 Some(hash) if *hash != other_hash => {}\n@@ -282,7 +294,7 @@ fn existing_match(e: &Env, crate_id: &CrateId,\n fn register_crate<'a>(e: &mut Env,\n                   root: &Option<CratePaths>,\n                   ident: &str,\n-                  crate_id: &CrateId,\n+                  name: &str,\n                   span: Span,\n                   lib: loader::Library)\n                         -> (ast::CrateNum, Rc<cstore::crate_metadata>,\n@@ -309,7 +321,7 @@ fn register_crate<'a>(e: &mut Env,\n     let loader::Library{ dylib, rlib, metadata } = lib;\n \n     let cmeta = Rc::new( cstore::crate_metadata {\n-        name: crate_id.name.to_string(),\n+        name: name.to_string(),\n         data: metadata,\n         cnum_map: cnum_map,\n         cnum: cnum,\n@@ -330,20 +342,18 @@ fn register_crate<'a>(e: &mut Env,\n fn resolve_crate<'a>(e: &mut Env,\n                  root: &Option<CratePaths>,\n                  ident: &str,\n-                 crate_id: &CrateId,\n+                 name: &str,\n                  hash: Option<&Svh>,\n                  span: Span)\n                      -> (ast::CrateNum, Rc<cstore::crate_metadata>,\n                          cstore::CrateSource) {\n-    match existing_match(e, crate_id, hash) {\n+    match existing_match(e, name, hash) {\n         None => {\n-            let id_hash = link::crate_id_hash(crate_id);\n             let mut load_ctxt = loader::Context {\n                 sess: e.sess,\n                 span: span,\n                 ident: ident,\n-                crate_id: crate_id,\n-                id_hash: id_hash.as_slice(),\n+                crate_name: name,\n                 hash: hash.map(|a| &*a),\n                 filesearch: e.sess.target_filesearch(),\n                 os: e.sess.targ_cfg.os,\n@@ -353,7 +363,7 @@ fn resolve_crate<'a>(e: &mut Env,\n                 rejected_via_triple: vec!(),\n             };\n             let library = load_ctxt.load_library_crate();\n-            register_crate(e, root, ident, crate_id, span, library)\n+            register_crate(e, root, ident, name, span, library)\n         }\n         Some(cnum) => (cnum,\n                        e.sess.cstore.get_crate_data(cnum),\n@@ -370,10 +380,10 @@ fn resolve_crate_deps(e: &mut Env,\n     // The map from crate numbers in the crate we're resolving to local crate\n     // numbers\n     decoder::get_crate_deps(cdata).iter().map(|dep| {\n-        debug!(\"resolving dep crate {} hash: `{}`\", dep.crate_id, dep.hash);\n+        debug!(\"resolving dep crate {} hash: `{}`\", dep.name, dep.hash);\n         let (local_cnum, _, _) = resolve_crate(e, root,\n-                                               dep.crate_id.name.as_slice(),\n-                                               &dep.crate_id,\n+                                               dep.name.as_slice(),\n+                                               dep.name.as_slice(),\n                                                Some(&dep.hash),\n                                                span);\n         (dep.cnum, local_cnum)\n@@ -399,14 +409,12 @@ impl<'a> PluginMetadataReader<'a> {\n         let target_triple = self.env.sess.targ_cfg.target_strs.target_triple.as_slice();\n         let is_cross = target_triple != driver::host_triple();\n         let mut should_link = info.should_link && !is_cross;\n-        let id_hash = link::crate_id_hash(&info.crate_id);\n         let os = config::get_os(driver::host_triple()).unwrap();\n         let mut load_ctxt = loader::Context {\n             sess: self.env.sess,\n             span: krate.span,\n             ident: info.ident.as_slice(),\n-            crate_id: &info.crate_id,\n-            id_hash: id_hash.as_slice(),\n+            crate_name: info.name.as_slice(),\n             hash: None,\n             filesearch: self.env.sess.host_filesearch(),\n             triple: driver::host_triple(),\n@@ -448,10 +456,11 @@ impl<'a> PluginMetadataReader<'a> {\n             macros: macros,\n             registrar_symbol: registrar,\n         };\n-        if should_link && existing_match(&self.env, &info.crate_id, None).is_none() {\n+        if should_link && existing_match(&self.env, info.name.as_slice(),\n+                                         None).is_none() {\n             // register crate now to avoid double-reading metadata\n             register_crate(&mut self.env, &None, info.ident.as_slice(),\n-                           &info.crate_id, krate.span, library);\n+                           info.name.as_slice(), krate.span, library);\n         }\n         pc\n     }"}, {"sha": "9d6fd109b48db4edc7b89ff330fb1a13c0bb27cb", "filename": "src/librustc/metadata/cstore.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/50ee1ec1b4f107122d8037ac7b0b312afa6eb0ac/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50ee1ec1b4f107122d8037ac7b0b312afa6eb0ac/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcstore.rs?ref=50ee1ec1b4f107122d8037ac7b0b312afa6eb0ac", "patch": "@@ -22,7 +22,6 @@ use std::c_vec::CVec;\n use std::rc::Rc;\n use std::collections::HashMap;\n use syntax::ast;\n-use syntax::crateid::CrateId;\n use syntax::codemap::Span;\n use syntax::parse::token::IdentInterner;\n \n@@ -220,7 +219,7 @@ impl CStore {\n \n impl crate_metadata {\n     pub fn data<'a>(&'a self) -> &'a [u8] { self.data.as_slice() }\n-    pub fn crate_id(&self) -> CrateId { decoder::get_crate_id(self.data()) }\n+    pub fn name(&self) -> String { decoder::get_crate_name(self.data()) }\n     pub fn hash(&self) -> Svh { decoder::get_crate_hash(self.data()) }\n }\n "}, {"sha": "f88c0d34ed83eebdf45eb7ce726e2fdf9e1df497", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 11, "deletions": 16, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/50ee1ec1b4f107122d8037ac7b0b312afa6eb0ac/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50ee1ec1b4f107122d8037ac7b0b312afa6eb0ac/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=50ee1ec1b4f107122d8037ac7b0b312afa6eb0ac", "patch": "@@ -46,7 +46,6 @@ use syntax::parse::token;\n use syntax::print::pprust;\n use syntax::ast;\n use syntax::codemap;\n-use syntax::crateid::CrateId;\n \n pub type Cmd<'a> = &'a crate_metadata;\n \n@@ -1101,7 +1100,7 @@ pub fn get_crate_attributes(data: &[u8]) -> Vec<ast::Attribute> {\n #[deriving(Clone)]\n pub struct CrateDep {\n     pub cnum: ast::CrateNum,\n-    pub crate_id: CrateId,\n+    pub name: String,\n     pub hash: Svh,\n }\n \n@@ -1115,13 +1114,11 @@ pub fn get_crate_deps(data: &[u8]) -> Vec<CrateDep> {\n         d.as_str_slice().to_string()\n     }\n     reader::tagged_docs(depsdoc, tag_crate_dep, |depdoc| {\n-        let crate_id =\n-            from_str(docstr(depdoc,\n-                            tag_crate_dep_crateid).as_slice()).unwrap();\n+        let name = docstr(depdoc, tag_crate_dep_crate_name);\n         let hash = Svh::new(docstr(depdoc, tag_crate_dep_hash).as_slice());\n         deps.push(CrateDep {\n             cnum: crate_num,\n-            crate_id: crate_id,\n+            name: name,\n             hash: hash,\n         });\n         crate_num += 1;\n@@ -1133,7 +1130,7 @@ pub fn get_crate_deps(data: &[u8]) -> Vec<CrateDep> {\n fn list_crate_deps(data: &[u8], out: &mut io::Writer) -> io::IoResult<()> {\n     try!(write!(out, \"=External Dependencies=\\n\"));\n     for dep in get_crate_deps(data).iter() {\n-        try!(write!(out, \"{} {}-{}\\n\", dep.cnum, dep.crate_id, dep.hash));\n+        try!(write!(out, \"{} {}-{}\\n\", dep.cnum, dep.name, dep.hash));\n     }\n     try!(write!(out, \"\\n\"));\n     Ok(())\n@@ -1152,23 +1149,21 @@ pub fn get_crate_hash(data: &[u8]) -> Svh {\n     Svh::new(hashdoc.as_str_slice())\n }\n \n-pub fn maybe_get_crate_id(data: &[u8]) -> Option<CrateId> {\n+pub fn maybe_get_crate_name(data: &[u8]) -> Option<String> {\n     let cratedoc = ebml::Doc::new(data);\n-    reader::maybe_get_doc(cratedoc, tag_crate_crateid).map(|doc| {\n-        from_str(doc.as_str_slice()).unwrap()\n+    reader::maybe_get_doc(cratedoc, tag_crate_crate_name).map(|doc| {\n+        doc.as_str_slice().to_string()\n     })\n }\n \n-pub fn get_crate_triple(data: &[u8]) -> String {\n+pub fn get_crate_triple(data: &[u8]) -> Option<String> {\n     let cratedoc = ebml::Doc::new(data);\n     let triple_doc = reader::maybe_get_doc(cratedoc, tag_crate_triple);\n-    triple_doc.expect(\"No triple in crate\").as_str().to_string()\n+    triple_doc.map(|s| s.as_str().to_string())\n }\n \n-pub fn get_crate_id(data: &[u8]) -> CrateId {\n-    let cratedoc = ebml::Doc::new(data);\n-    let hashdoc = reader::get_doc(cratedoc, tag_crate_crateid);\n-    from_str(hashdoc.as_str_slice()).unwrap()\n+pub fn get_crate_name(data: &[u8]) -> String {\n+    maybe_get_crate_name(data).expect(\"no crate name in crate\")\n }\n \n pub fn list_crate_metadata(bytes: &[u8], out: &mut io::Writer) -> io::IoResult<()> {"}, {"sha": "21713672f8149e82ab06ffce43dd4b2fb676e18b", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 10, "deletions": 42, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/50ee1ec1b4f107122d8037ac7b0b312afa6eb0ac/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50ee1ec1b4f107122d8037ac7b0b312afa6eb0ac/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=50ee1ec1b4f107122d8037ac7b0b312afa6eb0ac", "patch": "@@ -44,11 +44,9 @@ use syntax::ast_map::{PathElem, PathElems};\n use syntax::ast_map;\n use syntax::ast_util::*;\n use syntax::ast_util;\n-use syntax::attr::AttrMetaMethods;\n use syntax::attr;\n-use syntax::crateid::CrateId;\n+use syntax::attr::AttrMetaMethods;\n use syntax::diagnostic::SpanHandler;\n-use syntax::parse::token::InternedString;\n use syntax::parse::token::special_idents;\n use syntax::parse::token;\n use syntax::visit::Visitor;\n@@ -1494,44 +1492,15 @@ fn encode_attributes(ebml_w: &mut Encoder, attrs: &[Attribute]) {\n     ebml_w.end_tag();\n }\n \n-// So there's a special crate attribute called 'crate_id' which defines the\n-// metadata that Rust cares about for linking crates. If the user didn't\n-// provide it we will throw it in anyway with a default value.\n-fn synthesize_crate_attrs(ecx: &EncodeContext,\n-                          krate: &Crate) -> Vec<Attribute> {\n-\n-    fn synthesize_crateid_attr(ecx: &EncodeContext) -> Attribute {\n-        assert!(!ecx.link_meta.crateid.name.is_empty());\n-\n-        attr::mk_attr_inner(attr::mk_attr_id(),\n-            attr::mk_name_value_item_str(\n-                InternedString::new(\"crate_id\"),\n-                token::intern_and_get_ident(ecx.link_meta\n-                                               .crateid\n-                                               .to_str()\n-                                               .as_slice())))\n-    }\n-\n-    let mut attrs = Vec::new();\n-    for attr in krate.attrs.iter() {\n-        if !attr.check_name(\"crate_id\") {\n-            attrs.push(*attr);\n-        }\n-    }\n-    attrs.push(synthesize_crateid_attr(ecx));\n-\n-    attrs\n-}\n-\n fn encode_crate_deps(ebml_w: &mut Encoder, cstore: &cstore::CStore) {\n     fn get_ordered_deps(cstore: &cstore::CStore) -> Vec<decoder::CrateDep> {\n         // Pull the cnums and name,vers,hash out of cstore\n         let mut deps = Vec::new();\n         cstore.iter_crate_data(|key, val| {\n             let dep = decoder::CrateDep {\n                 cnum: key,\n-                crate_id: decoder::get_crate_id(val.data()),\n-                hash: decoder::get_crate_hash(val.data())\n+                name: decoder::get_crate_name(val.data()),\n+                hash: decoder::get_crate_hash(val.data()),\n             };\n             deps.push(dep);\n         });\n@@ -1766,8 +1735,8 @@ fn encode_reachable_extern_fns(ecx: &EncodeContext, ebml_w: &mut Encoder) {\n fn encode_crate_dep(ebml_w: &mut Encoder,\n                     dep: decoder::CrateDep) {\n     ebml_w.start_tag(tag_crate_dep);\n-    ebml_w.start_tag(tag_crate_dep_crateid);\n-    ebml_w.writer.write(dep.crate_id.to_str().as_bytes());\n+    ebml_w.start_tag(tag_crate_dep_crate_name);\n+    ebml_w.writer.write(dep.name.as_bytes());\n     ebml_w.end_tag();\n     ebml_w.start_tag(tag_crate_dep_hash);\n     ebml_w.writer.write(dep.hash.as_str().as_bytes());\n@@ -1781,9 +1750,9 @@ fn encode_hash(ebml_w: &mut Encoder, hash: &Svh) {\n     ebml_w.end_tag();\n }\n \n-fn encode_crate_id(ebml_w: &mut Encoder, crate_id: &CrateId) {\n-    ebml_w.start_tag(tag_crate_crateid);\n-    ebml_w.writer.write(crate_id.to_str().as_bytes());\n+fn encode_crate_name(ebml_w: &mut Encoder, crate_name: &str) {\n+    ebml_w.start_tag(tag_crate_crate_name);\n+    ebml_w.writer.write(crate_name.as_bytes());\n     ebml_w.end_tag();\n }\n \n@@ -1880,7 +1849,7 @@ fn encode_metadata_inner(wr: &mut MemWriter, parms: EncodeParams, krate: &Crate)\n \n     let mut ebml_w = writer::Encoder::new(wr);\n \n-    encode_crate_id(&mut ebml_w, &ecx.link_meta.crateid);\n+    encode_crate_name(&mut ebml_w, ecx.link_meta.crate_name.as_slice());\n     encode_crate_triple(&mut ebml_w,\n                         tcx.sess\n                            .targ_cfg\n@@ -1891,8 +1860,7 @@ fn encode_metadata_inner(wr: &mut MemWriter, parms: EncodeParams, krate: &Crate)\n     encode_dylib_dependency_formats(&mut ebml_w, &ecx);\n \n     let mut i = ebml_w.writer.tell().unwrap();\n-    let crate_attrs = synthesize_crate_attrs(&ecx, krate);\n-    encode_attributes(&mut ebml_w, crate_attrs.as_slice());\n+    encode_attributes(&mut ebml_w, krate.attrs.as_slice());\n     stats.attr_bytes = ebml_w.writer.tell().unwrap() - i;\n \n     i = ebml_w.writer.tell().unwrap();"}, {"sha": "1bb5ffdccb504567b5ecb53602545424986aa932", "filename": "src/librustc/middle/save/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/50ee1ec1b4f107122d8037ac7b0b312afa6eb0ac/src%2Flibrustc%2Fmiddle%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50ee1ec1b4f107122d8037ac7b0b312afa6eb0ac/src%2Flibrustc%2Fmiddle%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsave%2Fmod.rs?ref=50ee1ec1b4f107122d8037ac7b0b312afa6eb0ac", "patch": "@@ -1373,15 +1373,15 @@ pub fn process_crate(sess: &Session,\n         return;\n     }\n \n-    let (cratename, crateid) = match attr::find_crateid(krate.attrs.as_slice()) {\n-        Some(crateid) => (crateid.name.clone(), crateid.to_str()),\n+    let cratename = match attr::find_crate_name(krate.attrs.as_slice()) {\n+        Some(name) => name.get().to_string(),\n         None => {\n             info!(\"Could not find crate name, using 'unknown_crate'\");\n-            (String::from_str(\"unknown_crate\"),\"unknown_crate\".to_owned())\n+            String::from_str(\"unknown_crate\")\n         },\n     };\n \n-    info!(\"Dumping crate {} ({})\", cratename, crateid);\n+    info!(\"Dumping crate {}\", cratename);\n \n     // find a path to dump our data to\n     let mut root_path = match os::getenv(\"DXR_RUST_TEMP_FOLDER\") {"}, {"sha": "2f9a5f4a4fcd28505420da00431c051adee202ab", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/50ee1ec1b4f107122d8037ac7b0b312afa6eb0ac/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50ee1ec1b4f107122d8037ac7b0b312afa6eb0ac/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=50ee1ec1b4f107122d8037ac7b0b312afa6eb0ac", "patch": "@@ -30,7 +30,6 @@ use back::{link, abi};\n use driver::config;\n use driver::config::{NoDebugInfo, FullDebugInfo};\n use driver::session::Session;\n-use driver::driver::OutputFilenames;\n use driver::driver::{CrateAnalysis, CrateTranslation};\n use lib::llvm::{ModuleRef, ValueRef, BasicBlockRef};\n use lib::llvm::{llvm, Vector};\n@@ -2270,8 +2269,9 @@ pub fn write_metadata(cx: &CrateContext, krate: &ast::Crate) -> Vec<u8> {\n                      }.as_slice());\n     let llmeta = C_bytes(cx, compressed.as_slice());\n     let llconst = C_struct(cx, [llmeta], false);\n-    let name = format!(\"rust_metadata_{}_{}_{}\", cx.link_meta.crateid.name,\n-                       cx.link_meta.crateid.version_or_default(), cx.link_meta.crate_hash);\n+    let name = format!(\"rust_metadata_{}_{}\",\n+                       cx.link_meta.crate_name,\n+                       cx.link_meta.crate_hash);\n     let llglobal = name.with_c_str(|buf| {\n         unsafe {\n             llvm::LLVMAddGlobal(cx.metadata_llmod, val_ty(llconst).to_ref(), buf)\n@@ -2288,9 +2288,8 @@ pub fn write_metadata(cx: &CrateContext, krate: &ast::Crate) -> Vec<u8> {\n }\n \n pub fn trans_crate(krate: ast::Crate,\n-                   analysis: CrateAnalysis,\n-                   output: &OutputFilenames) -> (ty::ctxt, CrateTranslation) {\n-    let CrateAnalysis { ty_cx: tcx, exp_map2, reachable, .. } = analysis;\n+                   analysis: CrateAnalysis) -> (ty::ctxt, CrateTranslation) {\n+    let CrateAnalysis { ty_cx: tcx, exp_map2, reachable, name, .. } = analysis;\n \n     // Before we touch LLVM, make sure that multithreading is enabled.\n     unsafe {\n@@ -2310,8 +2309,7 @@ pub fn trans_crate(krate: ast::Crate,\n         }\n     }\n \n-    let link_meta = link::build_link_meta(&krate,\n-                                          output.out_filestem.as_slice());\n+    let link_meta = link::build_link_meta(&krate, name);\n \n     // Append \".rs\" to crate name as LLVM module identifier.\n     //\n@@ -2321,7 +2319,7 @@ pub fn trans_crate(krate: ast::Crate,\n     // crashes if the module identifier is same as other symbols\n     // such as a function name in the module.\n     // 1. http://llvm.org/bugs/show_bug.cgi?id=11479\n-    let mut llmod_id = link_meta.crateid.name.clone();\n+    let mut llmod_id = link_meta.crate_name.clone();\n     llmod_id.push_str(\".rs\");\n \n     let ccx = CrateContext::new(llmod_id.as_slice(), tcx, exp_map2,"}, {"sha": "0a8b844d2542e10af5383536f9f4642c3ba2e3ee", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50ee1ec1b4f107122d8037ac7b0b312afa6eb0ac/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50ee1ec1b4f107122d8037ac7b0b312afa6eb0ac/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=50ee1ec1b4f107122d8037ac7b0b312afa6eb0ac", "patch": "@@ -1496,7 +1496,7 @@ fn compile_unit_metadata(cx: &CrateContext) {\n     });\n \n     fn fallback_path(cx: &CrateContext) -> CString {\n-        cx.link_meta.crateid.name.as_slice().to_c_str()\n+        cx.link_meta.crate_name.as_slice().to_c_str()\n     }\n }\n "}, {"sha": "ff28f668c476f1bc61aff4acea464e65e40d1614", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50ee1ec1b4f107122d8037ac7b0b312afa6eb0ac/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50ee1ec1b4f107122d8037ac7b0b312afa6eb0ac/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=50ee1ec1b4f107122d8037ac7b0b312afa6eb0ac", "patch": "@@ -566,7 +566,7 @@ pub fn trans_rust_fn_with_foreign_abi(ccx: &CrateContext,\n \n         let ps = ccx.tcx.map.with_path(id, |path| {\n             let abi = Some(ast_map::PathName(special_idents::clownshoe_abi.name));\n-            link::mangle(path.chain(abi.move_iter()), None, None)\n+            link::mangle(path.chain(abi.move_iter()), None)\n         });\n \n         // Compute the type that the function would have if it were just a"}, {"sha": "768deec8edc1eb449143fd3d96341476698e008f", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/50ee1ec1b4f107122d8037ac7b0b312afa6eb0ac/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50ee1ec1b4f107122d8037ac7b0b312afa6eb0ac/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=50ee1ec1b4f107122d8037ac7b0b312afa6eb0ac", "patch": "@@ -129,9 +129,7 @@ pub fn monomorphic_fn(ccx: &CrateContext,\n         hash_id.hash(&mut state);\n         mono_ty.hash(&mut state);\n \n-        exported_name(path,\n-                      format!(\"h{}\", state.result()).as_slice(),\n-                      ccx.link_meta.crateid.version_or_default())\n+        exported_name(path, format!(\"h{}\", state.result()).as_slice())\n     });\n     debug!(\"monomorphize_fn mangled to {}\", s);\n "}, {"sha": "ff9f855c987573e5c29f171fa14b4cc3d546388c", "filename": "src/librustc/middle/typeck/infer/test.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/50ee1ec1b4f107122d8037ac7b0b312afa6eb0ac/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50ee1ec1b4f107122d8037ac7b0b312afa6eb0ac/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs?ref=50ee1ec1b4f107122d8037ac7b0b312afa6eb0ac", "patch": "@@ -37,7 +37,6 @@ use syntax::codemap;\n use syntax::codemap::{Span, CodeMap, DUMMY_SP};\n use syntax::diagnostic::{Level, RenderSpan, Bug, Fatal, Error, Warning, Note};\n use syntax::ast;\n-use syntax::crateid::CrateId;\n use util::ppaux::{ty_to_str, UserString};\n \n struct Env<'a> {\n@@ -116,11 +115,8 @@ fn test_env(_test_name: &str,\n     let krate_config = Vec::new();\n     let input = driver::StrInput(source_string.to_owned());\n     let krate = driver::phase_1_parse_input(&sess, krate_config, &input);\n-    let krate_id = CrateId { path: \"test\".to_owned(),\n-                             name: \"test\".to_owned(),\n-                             version: None };\n     let (krate, ast_map) =\n-        driver::phase_2_configure_and_expand(&sess, krate, &krate_id)\n+        driver::phase_2_configure_and_expand(&sess, krate, \"test\")\n             .expect(\"phase 2 aborted\");\n \n     // run just enough stuff to build a tcx:"}, {"sha": "3cf8d6b3827ef5edef2368cae02ae8db49ab40e0", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/50ee1ec1b4f107122d8037ac7b0b312afa6eb0ac/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50ee1ec1b4f107122d8037ac7b0b312afa6eb0ac/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=50ee1ec1b4f107122d8037ac7b0b312afa6eb0ac", "patch": "@@ -124,8 +124,9 @@ impl<'a> Clean<Crate> for visit_ast::RustdocVisitor<'a> {\n                                                        &None,\n                                                        self.attrs.as_slice(),\n                                                        cx.sess());\n-        let id = link::find_crate_id(self.attrs.as_slice(),\n-                                     t_outputs.out_filestem.as_slice());\n+        let name = link::find_crate_name(None,\n+                                         self.attrs.as_slice(),\n+                                         t_outputs.out_filestem.as_slice());\n \n         // Clean the crate, translating the entire libsyntax AST to one that is\n         // understood by rustdoc.\n@@ -188,7 +189,7 @@ impl<'a> Clean<Crate> for visit_ast::RustdocVisitor<'a> {\n         }\n \n         Crate {\n-            name: id.name.to_string(),\n+            name: name.to_string(),\n             module: Some(module),\n             externs: externs,\n             primitives: primitives,"}, {"sha": "058face151c6240bb0b0c4f518bf5dcbabb96e15", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/50ee1ec1b4f107122d8037ac7b0b312afa6eb0ac/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50ee1ec1b4f107122d8037ac7b0b312afa6eb0ac/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=50ee1ec1b4f107122d8037ac7b0b312afa6eb0ac", "patch": "@@ -12,6 +12,7 @@ use rustc;\n use rustc::{driver, middle};\n use rustc::middle::{privacy, ty};\n use rustc::lint;\n+use rustc::back::link;\n \n use syntax::ast;\n use syntax::parse::token;\n@@ -83,7 +84,8 @@ fn get_ast_and_resolve(cpath: &Path, libs: HashSet<Path>, cfgs: Vec<String>)\n     use rustc::driver::driver::{FileInput,\n                                 phase_1_parse_input,\n                                 phase_2_configure_and_expand,\n-                                phase_3_run_analysis_passes};\n+                                phase_3_run_analysis_passes,\n+                                build_output_filenames};\n     use rustc::driver::config::build_configuration;\n \n     let input = FileInput(cpath.clone());\n@@ -115,13 +117,19 @@ fn get_ast_and_resolve(cpath: &Path, libs: HashSet<Path>, cfgs: Vec<String>)\n     }\n \n     let krate = phase_1_parse_input(&sess, cfg, &input);\n+\n+    let t_outputs = build_output_filenames(&input, &None, &None,\n+                                           krate.attrs.as_slice(), &sess);\n+    let name = link::find_crate_name(Some(&sess), krate.attrs.as_slice(),\n+                                     t_outputs.out_filestem.as_slice());\n+\n     let (krate, ast_map)\n-        = phase_2_configure_and_expand(&sess, krate, &from_str(\"rustdoc\").unwrap())\n+        = phase_2_configure_and_expand(&sess, krate, name.as_slice())\n             .expect(\"phase_2_configure_and_expand aborted in rustdoc!\");\n \n     let driver::driver::CrateAnalysis {\n         exported_items, public_items, ty_cx, ..\n-    } = phase_3_run_analysis_passes(sess, &krate, ast_map);\n+    } = phase_3_run_analysis_passes(sess, &krate, ast_map, name);\n \n     debug!(\"crate: {:?}\", krate);\n     (DocContext {"}, {"sha": "7d6f44f5d168a7a3bddeba9791eed749f9dec1d3", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/50ee1ec1b4f107122d8037ac7b0b312afa6eb0ac/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50ee1ec1b4f107122d8037ac7b0b312afa6eb0ac/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=50ee1ec1b4f107122d8037ac7b0b312afa6eb0ac", "patch": "@@ -8,12 +8,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![crate_id = \"rustdoc#0.11.0\"]\n+#![crate_id = \"rustdoc#0.11.0\"] // NOTE: remove after stage0\n+#![crate_name = \"rustdoc\"]\n #![experimental]\n #![desc = \"rustdoc, the Rust documentation extractor\"]\n #![license = \"MIT/ASL2\"]\n #![crate_type = \"dylib\"]\n #![crate_type = \"rlib\"]\n+#![allow(unused_attribute)] // NOTE: remove after stage0\n \n #![feature(globs, struct_variant, managed_boxes, macro_rules, phase)]\n "}, {"sha": "18f823317808156b88ac86cf49d0af4be814d089", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50ee1ec1b4f107122d8037ac7b0b312afa6eb0ac/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50ee1ec1b4f107122d8037ac7b0b312afa6eb0ac/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=50ee1ec1b4f107122d8037ac7b0b312afa6eb0ac", "patch": "@@ -69,7 +69,7 @@ pub fn run(input: &str,\n     }));\n     let krate = driver::phase_1_parse_input(&sess, cfg, &input);\n     let (krate, _) = driver::phase_2_configure_and_expand(&sess, krate,\n-            &from_str(\"rustdoc-test\").unwrap())\n+                                                          \"rustdoc-test\")\n         .expect(\"phase_2_configure_and_expand aborted in rustdoc!\");\n \n     let ctx = box(GC) core::DocContext {"}, {"sha": "3b2ee4e2a6134a02c32aa27fb98991e834fc3296", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/50ee1ec1b4f107122d8037ac7b0b312afa6eb0ac/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50ee1ec1b4f107122d8037ac7b0b312afa6eb0ac/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=50ee1ec1b4f107122d8037ac7b0b312afa6eb0ac", "patch": "@@ -18,7 +18,6 @@ use diagnostic::SpanHandler;\n use parse::lexer::comments::{doc_comment_style, strip_doc_comment_decoration};\n use parse::token::InternedString;\n use parse::token;\n-use crateid::CrateId;\n \n use std::collections::HashSet;\n use std::collections::BitvSet;\n@@ -271,11 +270,8 @@ pub fn sort_meta_items(items: &[Gc<MetaItem>]) -> Vec<Gc<MetaItem>> {\n     }).collect()\n }\n \n-pub fn find_crateid(attrs: &[Attribute]) -> Option<CrateId> {\n-    match first_attr_value_str_by_name(attrs, \"crate_id\") {\n-        None => None,\n-        Some(id) => from_str::<CrateId>(id.get()),\n-    }\n+pub fn find_crate_name(attrs: &[Attribute]) -> Option<InternedString> {\n+    first_attr_value_str_by_name(attrs, \"crate_name\")\n }\n \n #[deriving(PartialEq)]"}, {"sha": "673ae31ef77899216e4e3f7d4a0f6357403f7569", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50ee1ec1b4f107122d8037ac7b0b312afa6eb0ac/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50ee1ec1b4f107122d8037ac7b0b312afa6eb0ac/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=50ee1ec1b4f107122d8037ac7b0b312afa6eb0ac", "patch": "@@ -452,7 +452,7 @@ impl<'a> ExtCtxt<'a> {\n     pub fn mod_pop(&mut self) { self.mod_path.pop().unwrap(); }\n     pub fn mod_path(&self) -> Vec<ast::Ident> {\n         let mut v = Vec::new();\n-        v.push(token::str_to_ident(self.ecfg.crate_id.name.as_slice()));\n+        v.push(token::str_to_ident(self.ecfg.crate_name.as_slice()));\n         v.extend(self.mod_path.iter().map(|a| *a));\n         return v;\n     }"}, {"sha": "752b3a09e652e9e9dc9270091c8192e8156ac245", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/50ee1ec1b4f107122d8037ac7b0b312afa6eb0ac/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50ee1ec1b4f107122d8037ac7b0b312afa6eb0ac/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=50ee1ec1b4f107122d8037ac7b0b312afa6eb0ac", "patch": "@@ -19,7 +19,6 @@ use attr;\n use attr::AttrMetaMethods;\n use codemap;\n use codemap::{Span, Spanned, ExpnInfo, NameAndSpan, MacroBang, MacroAttribute};\n-use crateid::CrateId;\n use ext::base::*;\n use fold;\n use fold::*;\n@@ -985,7 +984,7 @@ fn new_span(cx: &ExtCtxt, sp: Span) -> Span {\n \n pub struct ExpansionConfig {\n     pub deriving_hash_type_parameter: bool,\n-    pub crate_id: CrateId,\n+    pub crate_name: String,\n }\n \n pub struct ExportedMacros {\n@@ -1184,7 +1183,7 @@ mod test {\n         // should fail:\n         let cfg = ::syntax::ext::expand::ExpansionConfig {\n             deriving_hash_type_parameter: false,\n-            crate_id: from_str(\"test\").unwrap(),\n+            crate_name: \"test\".to_str(),\n         };\n         expand_crate(&sess,cfg,vec!(),vec!(),crate_ast);\n     }\n@@ -1201,7 +1200,7 @@ mod test {\n             Vec::new(), &sess);\n         let cfg = ::syntax::ext::expand::ExpansionConfig {\n             deriving_hash_type_parameter: false,\n-            crate_id: from_str(\"test\").unwrap(),\n+            crate_name: \"test\".to_str(),\n         };\n         expand_crate(&sess,cfg,vec!(),vec!(),crate_ast);\n     }\n@@ -1217,7 +1216,7 @@ mod test {\n             Vec::new(), &sess);\n         let cfg = ::syntax::ext::expand::ExpansionConfig {\n             deriving_hash_type_parameter: false,\n-            crate_id: from_str(\"test\").unwrap(),\n+            crate_name: \"test\".to_str(),\n         };\n         expand_crate(&sess, cfg, vec!(), vec!(), crate_ast);\n     }\n@@ -1254,7 +1253,7 @@ mod test {\n         // the cfg argument actually does matter, here...\n         let cfg = ::syntax::ext::expand::ExpansionConfig {\n             deriving_hash_type_parameter: false,\n-            crate_id: from_str(\"test\").unwrap(),\n+            crate_name: \"test\".to_str(),\n         };\n         expand_crate(&ps,cfg,vec!(),vec!(),crate_ast)\n     }"}]}