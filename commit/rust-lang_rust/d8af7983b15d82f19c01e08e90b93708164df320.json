{"sha": "d8af7983b15d82f19c01e08e90b93708164df320", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ4YWY3OTgzYjE1ZDgyZjE5YzAxZTA4ZTkwYjkzNzA4MTY0ZGYzMjA=", "commit": {"author": {"name": "Jonas Schievink", "email": "jonasschievink@gmail.com", "date": "2020-06-16T20:54:41Z"}, "committer": {"name": "Jonas Schievink", "email": "jonasschievink@gmail.com", "date": "2020-06-16T20:54:41Z"}, "message": "Use ra_fixture and reformat tests", "tree": {"sha": "89e8e723865caccb59750ef8d2bb9c353ce88d98", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/89e8e723865caccb59750ef8d2bb9c353ce88d98"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d8af7983b15d82f19c01e08e90b93708164df320", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d8af7983b15d82f19c01e08e90b93708164df320", "html_url": "https://github.com/rust-lang/rust/commit/d8af7983b15d82f19c01e08e90b93708164df320", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d8af7983b15d82f19c01e08e90b93708164df320/comments", "author": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9ecbadcedb4971d29c34453b010899ec0e336e2d", "url": "https://api.github.com/repos/rust-lang/rust/commits/9ecbadcedb4971d29c34453b010899ec0e336e2d", "html_url": "https://github.com/rust-lang/rust/commit/9ecbadcedb4971d29c34453b010899ec0e336e2d"}], "stats": {"total": 772, "additions": 385, "deletions": 387}, "files": [{"sha": "02a7a61f129f98d40c6c3a28a89db2178968f914", "filename": "crates/ra_hir_ty/src/_match.rs", "status": "modified", "additions": 385, "deletions": 387, "changes": 772, "blob_url": "https://github.com/rust-lang/rust/blob/d8af7983b15d82f19c01e08e90b93708164df320/crates%2Fra_hir_ty%2Fsrc%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8af7983b15d82f19c01e08e90b93708164df320/crates%2Fra_hir_ty%2Fsrc%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2F_match.rs?ref=d8af7983b15d82f19c01e08e90b93708164df320", "patch": "@@ -842,224 +842,223 @@ mod tests {\n \n     pub(super) use crate::{diagnostics::MissingMatchArms, test_db::TestDB};\n \n-    pub(super) fn check_diagnostic_message(content: &str) -> String {\n-        TestDB::with_single_file(content).0.diagnostic::<MissingMatchArms>().0\n+    pub(super) fn check_diagnostic_message(ra_fixture: &str) -> String {\n+        TestDB::with_single_file(ra_fixture).0.diagnostic::<MissingMatchArms>().0\n     }\n \n-    pub(super) fn check_diagnostic(content: &str) {\n+    pub(super) fn check_diagnostic(ra_fixture: &str) {\n         let diagnostic_count =\n-            TestDB::with_single_file(content).0.diagnostic::<MissingMatchArms>().1;\n+            TestDB::with_single_file(ra_fixture).0.diagnostic::<MissingMatchArms>().1;\n \n         assert_eq!(1, diagnostic_count, \"no diagnostic reported\");\n     }\n \n-    pub(super) fn check_no_diagnostic(content: &str) {\n+    pub(super) fn check_no_diagnostic(ra_fixture: &str) {\n         let diagnostic_count =\n-            TestDB::with_single_file(content).0.diagnostic::<MissingMatchArms>().1;\n+            TestDB::with_single_file(ra_fixture).0.diagnostic::<MissingMatchArms>().1;\n \n         assert_eq!(0, diagnostic_count, \"expected no diagnostic, found one\");\n     }\n \n     #[test]\n     fn empty_tuple_no_arms_diagnostic_message() {\n-        let content = r\"\n-            fn test_fn() {\n-                match () {\n-                }\n-            }\n-        \";\n-\n         assert_snapshot!(\n-            check_diagnostic_message(content),\n+            check_diagnostic_message(r\"\n+                fn test_fn() {\n+                    match () {\n+                    }\n+                }\n+            \"),\n             @\"\\\"()\\\": Missing match arm\\n\"\n         );\n     }\n \n     #[test]\n     fn empty_tuple_no_arms() {\n-        let content = r\"\n+        check_diagnostic(\n+            r\"\n             fn test_fn() {\n                 match () {\n                 }\n             }\n-        \";\n-\n-        check_diagnostic(content);\n+        \",\n+        );\n     }\n \n     #[test]\n     fn empty_tuple_wild() {\n-        let content = r\"\n+        check_no_diagnostic(\n+            r\"\n             fn test_fn() {\n                 match () {\n                     _ => {}\n                 }\n             }\n-        \";\n-\n-        check_no_diagnostic(content);\n+        \",\n+        );\n     }\n \n     #[test]\n     fn empty_tuple_no_diagnostic() {\n-        let content = r\"\n+        check_no_diagnostic(\n+            r\"\n             fn test_fn() {\n                 match () {\n                     () => {}\n                 }\n             }\n-        \";\n-\n-        check_no_diagnostic(content);\n+        \",\n+        );\n     }\n \n     #[test]\n     fn tuple_of_empty_tuple_no_arms() {\n-        let content = r\"\n+        check_diagnostic(\n+            r\"\n             fn test_fn() {\n                 match (()) {\n                 }\n             }\n-        \";\n-\n-        check_diagnostic(content);\n+        \",\n+        );\n     }\n \n     #[test]\n     fn tuple_of_empty_tuple_no_diagnostic() {\n-        let content = r\"\n+        check_no_diagnostic(\n+            r\"\n             fn test_fn() {\n                 match (()) {\n                     (()) => {}\n                 }\n             }\n-        \";\n-\n-        check_no_diagnostic(content);\n+        \",\n+        );\n     }\n \n     #[test]\n     fn tuple_of_two_empty_tuple_no_arms() {\n-        let content = r\"\n+        check_diagnostic(\n+            r\"\n             fn test_fn() {\n                 match ((), ()) {\n                 }\n             }\n-        \";\n-\n-        check_diagnostic(content);\n+        \",\n+        );\n     }\n \n     #[test]\n     fn tuple_of_two_empty_tuple_no_diagnostic() {\n-        let content = r\"\n+        check_no_diagnostic(\n+            r\"\n             fn test_fn() {\n                 match ((), ()) {\n                     ((), ()) => {}\n                 }\n             }\n-        \";\n-\n-        check_no_diagnostic(content);\n+        \",\n+        );\n     }\n \n     #[test]\n     fn bool_no_arms() {\n-        let content = r\"\n+        check_diagnostic(\n+            r\"\n             fn test_fn() {\n                 match false {\n                 }\n             }\n-        \";\n-\n-        check_diagnostic(content);\n+        \",\n+        );\n     }\n \n     #[test]\n     fn bool_missing_arm() {\n-        let content = r\"\n+        check_diagnostic(\n+            r\"\n             fn test_fn() {\n                 match false {\n                     true => {}\n                 }\n             }\n-        \";\n-\n-        check_diagnostic(content);\n+        \",\n+        );\n     }\n \n     #[test]\n     fn bool_no_diagnostic() {\n-        let content = r\"\n+        check_no_diagnostic(\n+            r\"\n             fn test_fn() {\n                 match false {\n                     true => {}\n                     false => {}\n                 }\n             }\n-        \";\n-\n-        check_no_diagnostic(content);\n+        \",\n+        );\n     }\n \n     #[test]\n     fn tuple_of_bools_no_arms() {\n-        let content = r\"\n+        check_diagnostic(\n+            r\"\n             fn test_fn() {\n                 match (false, true) {\n                 }\n             }\n-        \";\n-\n-        check_diagnostic(content);\n+        \",\n+        );\n     }\n \n     #[test]\n     fn tuple_of_bools_missing_arms() {\n-        let content = r\"\n+        check_diagnostic(\n+            r\"\n             fn test_fn() {\n                 match (false, true) {\n                     (true, true) => {},\n                 }\n             }\n-        \";\n-\n-        check_diagnostic(content);\n+        \",\n+        );\n     }\n \n     #[test]\n     fn tuple_of_bools_missing_arm() {\n-        let content = r\"\n+        check_diagnostic(\n+            r\"\n             fn test_fn() {\n                 match (false, true) {\n                     (false, true) => {},\n                     (false, false) => {},\n                     (true, false) => {},\n                 }\n             }\n-        \";\n-\n-        check_diagnostic(content);\n+        \",\n+        );\n     }\n \n     #[test]\n     fn tuple_of_bools_with_wilds() {\n-        let content = r\"\n+        check_no_diagnostic(\n+            r\"\n             fn test_fn() {\n                 match (false, true) {\n                     (false, _) => {},\n                     (true, false) => {},\n                     (_, true) => {},\n                 }\n             }\n-        \";\n-\n-        check_no_diagnostic(content);\n+        \",\n+        );\n     }\n \n     #[test]\n     fn tuple_of_bools_no_diagnostic() {\n-        let content = r\"\n+        check_no_diagnostic(\n+            r\"\n             fn test_fn() {\n                 match (false, true) {\n                     (true, true) => {},\n@@ -1068,108 +1067,108 @@ mod tests {\n                     (false, false) => {},\n                 }\n             }\n-        \";\n-\n-        check_no_diagnostic(content);\n+        \",\n+        );\n     }\n \n     #[test]\n     fn tuple_of_bools_binding_missing_arms() {\n-        let content = r\"\n+        check_diagnostic(\n+            r\"\n             fn test_fn() {\n                 match (false, true) {\n                     (true, _x) => {},\n                 }\n             }\n-        \";\n-\n-        check_diagnostic(content);\n+        \",\n+        );\n     }\n \n     #[test]\n     fn tuple_of_bools_binding_no_diagnostic() {\n-        let content = r\"\n+        check_no_diagnostic(\n+            r\"\n             fn test_fn() {\n                 match (false, true) {\n                     (true, _x) => {},\n                     (false, true) => {},\n                     (false, false) => {},\n                 }\n             }\n-        \";\n-\n-        check_no_diagnostic(content);\n+        \",\n+        );\n     }\n \n     #[test]\n     fn tuple_of_bools_with_ellipsis_at_end_no_diagnostic() {\n-        let content = r\"\n+        check_no_diagnostic(\n+            r\"\n             fn test_fn() {\n                 match (false, true, false) {\n                     (false, ..) => {},\n                     (true, ..) => {},\n                 }\n             }\n-        \";\n-\n-        check_no_diagnostic(content);\n+        \",\n+        );\n     }\n \n     #[test]\n     fn tuple_of_bools_with_ellipsis_at_beginning_no_diagnostic() {\n-        let content = r\"\n+        check_no_diagnostic(\n+            r\"\n             fn test_fn() {\n                 match (false, true, false) {\n                     (.., false) => {},\n                     (.., true) => {},\n                 }\n             }\n-        \";\n-\n-        check_no_diagnostic(content);\n+        \",\n+        );\n     }\n \n     #[test]\n     fn tuple_of_bools_with_ellipsis_no_diagnostic() {\n-        let content = r\"\n+        check_no_diagnostic(\n+            r\"\n             fn test_fn() {\n                 match (false, true, false) {\n                     (..) => {},\n                 }\n             }\n-        \";\n-\n-        check_no_diagnostic(content);\n+        \",\n+        );\n     }\n \n     #[test]\n     fn tuple_of_tuple_and_bools_no_arms() {\n-        let content = r\"\n+        check_diagnostic(\n+            r\"\n             fn test_fn() {\n                 match (false, ((), false)) {\n                 }\n             }\n-        \";\n-\n-        check_diagnostic(content);\n+        \",\n+        );\n     }\n \n     #[test]\n     fn tuple_of_tuple_and_bools_missing_arms() {\n-        let content = r\"\n+        check_diagnostic(\n+            r\"\n             fn test_fn() {\n                 match (false, ((), false)) {\n                     (true, ((), true)) => {},\n                 }\n             }\n-        \";\n-\n-        check_diagnostic(content);\n+        \",\n+        );\n     }\n \n     #[test]\n     fn tuple_of_tuple_and_bools_no_diagnostic() {\n-        let content = r\"\n+        check_no_diagnostic(\n+            r\"\n             fn test_fn() {\n                 match (false, ((), false)) {\n                     (true, ((), true)) => {},\n@@ -1178,42 +1177,42 @@ mod tests {\n                     (false, ((), false)) => {},\n                 }\n             }\n-        \";\n-\n-        check_no_diagnostic(content);\n+        \",\n+        );\n     }\n \n     #[test]\n     fn tuple_of_tuple_and_bools_wildcard_missing_arms() {\n-        let content = r\"\n+        check_diagnostic(\n+            r\"\n             fn test_fn() {\n                 match (false, ((), false)) {\n                     (true, _) => {},\n                 }\n             }\n-        \";\n-\n-        check_diagnostic(content);\n+        \",\n+        );\n     }\n \n     #[test]\n     fn tuple_of_tuple_and_bools_wildcard_no_diagnostic() {\n-        let content = r\"\n+        check_no_diagnostic(\n+            r\"\n             fn test_fn() {\n                 match (false, ((), false)) {\n                     (true, ((), true)) => {},\n                     (true, ((), false)) => {},\n                     (false, _) => {},\n                 }\n             }\n-        \";\n-\n-        check_no_diagnostic(content);\n+        \",\n+        );\n     }\n \n     #[test]\n     fn enum_no_arms() {\n-        let content = r\"\n+        check_diagnostic(\n+            r\"\n             enum Either {\n                 A,\n                 B,\n@@ -1222,14 +1221,14 @@ mod tests {\n                 match Either::A {\n                 }\n             }\n-        \";\n-\n-        check_diagnostic(content);\n+        \",\n+        );\n     }\n \n     #[test]\n     fn enum_missing_arms() {\n-        let content = r\"\n+        check_diagnostic(\n+            r\"\n             enum Either {\n                 A,\n                 B,\n@@ -1239,14 +1238,14 @@ mod tests {\n                     Either::A => {},\n                 }\n             }\n-        \";\n-\n-        check_diagnostic(content);\n+        \",\n+        );\n     }\n \n     #[test]\n     fn enum_no_diagnostic() {\n-        let content = r\"\n+        check_no_diagnostic(\n+            r\"\n             enum Either {\n                 A,\n                 B,\n@@ -1257,14 +1256,14 @@ mod tests {\n                     Either::B => {},\n                 }\n             }\n-        \";\n-\n-        check_no_diagnostic(content);\n+        \",\n+        );\n     }\n \n     #[test]\n     fn enum_ref_missing_arms() {\n-        let content = r\"\n+        check_diagnostic(\n+            r\"\n             enum Either {\n                 A,\n                 B,\n@@ -1274,14 +1273,14 @@ mod tests {\n                     Either::A => {},\n                 }\n             }\n-        \";\n-\n-        check_diagnostic(content);\n+        \",\n+        );\n     }\n \n     #[test]\n     fn enum_ref_no_diagnostic() {\n-        let content = r\"\n+        check_no_diagnostic(\n+            r\"\n             enum Either {\n                 A,\n                 B,\n@@ -1292,14 +1291,14 @@ mod tests {\n                     Either::B => {},\n                 }\n             }\n-        \";\n-\n-        check_no_diagnostic(content);\n+        \",\n+        );\n     }\n \n     #[test]\n     fn enum_containing_bool_no_arms() {\n-        let content = r\"\n+        check_diagnostic(\n+            r\"\n             enum Either {\n                 A(bool),\n                 B,\n@@ -1308,14 +1307,14 @@ mod tests {\n                 match Either::B {\n                 }\n             }\n-        \";\n-\n-        check_diagnostic(content);\n+        \",\n+        );\n     }\n \n     #[test]\n     fn enum_containing_bool_missing_arms() {\n-        let content = r\"\n+        check_diagnostic(\n+            r\"\n             enum Either {\n                 A(bool),\n                 B,\n@@ -1326,14 +1325,14 @@ mod tests {\n                     Either::B => (),\n                 }\n             }\n-        \";\n-\n-        check_diagnostic(content);\n+        \",\n+        );\n     }\n \n     #[test]\n     fn enum_containing_bool_no_diagnostic() {\n-        let content = r\"\n+        check_no_diagnostic(\n+            r\"\n             enum Either {\n                 A(bool),\n                 B,\n@@ -1345,14 +1344,14 @@ mod tests {\n                     Either::B => (),\n                 }\n             }\n-        \";\n-\n-        check_no_diagnostic(content);\n+        \",\n+        );\n     }\n \n     #[test]\n     fn enum_containing_bool_with_wild_no_diagnostic() {\n-        let content = r\"\n+        check_no_diagnostic(\n+            r\"\n             enum Either {\n                 A(bool),\n                 B,\n@@ -1363,14 +1362,14 @@ mod tests {\n                     _ => (),\n                 }\n             }\n-        \";\n-\n-        check_no_diagnostic(content);\n+        \",\n+        );\n     }\n \n     #[test]\n     fn enum_containing_bool_with_wild_2_no_diagnostic() {\n-        let content = r\"\n+        check_no_diagnostic(\n+            r\"\n             enum Either {\n                 A(bool),\n                 B,\n@@ -1381,14 +1380,14 @@ mod tests {\n                     Either::B => (),\n                 }\n             }\n-        \";\n-\n-        check_no_diagnostic(content);\n+        \",\n+        );\n     }\n \n     #[test]\n     fn enum_different_sizes_missing_arms() {\n-        let content = r\"\n+        check_diagnostic(\n+            r\"\n             enum Either {\n                 A(bool),\n                 B(bool, bool),\n@@ -1399,14 +1398,14 @@ mod tests {\n                     Either::B(false, _) => (),\n                 }\n             }\n-        \";\n-\n-        check_diagnostic(content);\n+        \",\n+        );\n     }\n \n     #[test]\n     fn enum_different_sizes_no_diagnostic() {\n-        let content = r\"\n+        check_no_diagnostic(\n+            r\"\n             enum Either {\n                 A(bool),\n                 B(bool, bool),\n@@ -1418,14 +1417,14 @@ mod tests {\n                     Either::B(false, _) => (),\n                 }\n             }\n-        \";\n-\n-        check_no_diagnostic(content);\n+        \",\n+        );\n     }\n \n     #[test]\n     fn or_no_diagnostic() {\n-        let content = r\"\n+        check_no_diagnostic(\n+            r\"\n             enum Either {\n                 A(bool),\n                 B(bool, bool),\n@@ -1437,14 +1436,14 @@ mod tests {\n                     Either::B(false, _) => (),\n                 }\n             }\n-        \";\n-\n-        check_no_diagnostic(content);\n+        \",\n+        );\n     }\n \n     #[test]\n     fn tuple_of_enum_no_diagnostic() {\n-        let content = r\"\n+        check_no_diagnostic(\n+            r\"\n             enum Either {\n                 A(bool),\n                 B(bool, bool),\n@@ -1461,14 +1460,16 @@ mod tests {\n                     (Either::B(_, _), Either2::D) => (),\n                 }\n             }\n-        \";\n-\n-        check_no_diagnostic(content);\n+        \",\n+        );\n     }\n \n     #[test]\n     fn mismatched_types() {\n-        let content = r\"\n+        // Match statements with arms that don't match the\n+        // expression pattern do not fire this diagnostic.\n+        check_no_diagnostic(\n+            r\"\n             enum Either {\n                 A,\n                 B,\n@@ -1483,47 +1484,47 @@ mod tests {\n                     Either2::D => (),\n                 }\n             }\n-        \";\n-\n-        // Match statements with arms that don't match the\n-        // expression pattern do not fire this diagnostic.\n-        check_no_diagnostic(content);\n+        \",\n+        );\n     }\n \n     #[test]\n     fn mismatched_types_with_different_arity() {\n-        let content = r\"\n+        // Match statements with arms that don't match the\n+        // expression pattern do not fire this diagnostic.\n+        check_no_diagnostic(\n+            r\"\n             fn test_fn() {\n                 match (true, false) {\n                     (true, false, true) => (),\n                     (true) => (),\n                 }\n             }\n-        \";\n-\n-        // Match statements with arms that don't match the\n-        // expression pattern do not fire this diagnostic.\n-        check_no_diagnostic(content);\n+        \",\n+        );\n     }\n \n     #[test]\n     fn malformed_match_arm_tuple_missing_pattern() {\n-        let content = r\"\n+        // Match statements with arms that don't match the\n+        // expression pattern do not fire this diagnostic.\n+        check_no_diagnostic(\n+            r\"\n             fn test_fn() {\n                 match (0) {\n                     () => (),\n                 }\n             }\n-        \";\n-\n-        // Match statements with arms that don't match the\n-        // expression pattern do not fire this diagnostic.\n-        check_no_diagnostic(content);\n+        \",\n+        );\n     }\n \n     #[test]\n     fn malformed_match_arm_tuple_enum_missing_pattern() {\n-        let content = r\"\n+        // We are testing to be sure we don't panic here when the match\n+        // arm `Either::B` is missing its pattern.\n+        check_no_diagnostic(\n+            r\"\n             enum Either {\n                 A,\n                 B(u32),\n@@ -1534,32 +1535,30 @@ mod tests {\n                     Either::B() => (),\n                 }\n             }\n-        \";\n-\n-        // We are testing to be sure we don't panic here when the match\n-        // arm `Either::B` is missing its pattern.\n-        check_no_diagnostic(content);\n+        \",\n+        );\n     }\n \n     #[test]\n     fn enum_not_in_scope() {\n-        let content = r\"\n+        // The enum is not in scope so we don't perform exhaustiveness\n+        // checking, but we want to be sure we don't panic here (and\n+        // we don't create a diagnostic).\n+        check_no_diagnostic(\n+            r\"\n             fn test_fn() {\n                 match Foo::Bar {\n                     Foo::Baz => (),\n                 }\n             }\n-        \";\n-\n-        // The enum is not in scope so we don't perform exhaustiveness\n-        // checking, but we want to be sure we don't panic here (and\n-        // we don't create a diagnostic).\n-        check_no_diagnostic(content);\n+        \",\n+        );\n     }\n \n     #[test]\n     fn expr_diverges() {\n-        let content = r\"\n+        check_no_diagnostic(\n+            r\"\n             enum Either {\n                 A,\n                 B,\n@@ -1570,14 +1569,14 @@ mod tests {\n                     Either::B => (),\n                 }\n             }\n-        \";\n-\n-        check_no_diagnostic(content);\n+        \",\n+        );\n     }\n \n     #[test]\n     fn expr_loop_with_break() {\n-        let content = r\"\n+        check_no_diagnostic(\n+            r\"\n             enum Either {\n                 A,\n                 B,\n@@ -1588,14 +1587,14 @@ mod tests {\n                     Either::B => (),\n                 }\n             }\n-        \";\n-\n-        check_no_diagnostic(content);\n+        \",\n+        );\n     }\n \n     #[test]\n     fn expr_partially_diverges() {\n-        let content = r\"\n+        check_no_diagnostic(\n+            r\"\n             enum Either<T> {\n                 A(T),\n                 B,\n@@ -1609,14 +1608,14 @@ mod tests {\n                     Either::B => 0,\n                 }\n             }\n-        \";\n-\n-        check_no_diagnostic(content);\n+        \",\n+        );\n     }\n \n     #[test]\n     fn enum_record_no_arms() {\n-        let content = r\"\n+        check_diagnostic(\n+            r\"\n             enum Either {\n                 A { foo: bool },\n                 B,\n@@ -1626,14 +1625,14 @@ mod tests {\n                 match a {\n                 }\n             }\n-        \";\n-\n-        check_diagnostic(content);\n+        \",\n+        );\n     }\n \n     #[test]\n     fn enum_record_missing_arms() {\n-        let content = r\"\n+        check_diagnostic(\n+            r\"\n             enum Either {\n                 A { foo: bool },\n                 B,\n@@ -1644,14 +1643,14 @@ mod tests {\n                     Either::A { foo: true } => (),\n                 }\n             }\n-        \";\n-\n-        check_diagnostic(content);\n+        \",\n+        );\n     }\n \n     #[test]\n     fn enum_record_no_diagnostic() {\n-        let content = r\"\n+        check_no_diagnostic(\n+            r\"\n             enum Either {\n                 A { foo: bool },\n                 B,\n@@ -1664,14 +1663,17 @@ mod tests {\n                     Either::B => (),\n                 }\n             }\n-        \";\n-\n-        check_no_diagnostic(content);\n+        \",\n+        );\n     }\n \n     #[test]\n     fn enum_record_missing_field_no_diagnostic() {\n-        let content = r\"\n+        // When `Either::A` is missing a struct member, we don't want\n+        // to fire the missing match arm diagnostic. This should fire\n+        // some other diagnostic.\n+        check_no_diagnostic(\n+            r\"\n             enum Either {\n                 A { foo: bool },\n                 B,\n@@ -1683,17 +1685,16 @@ mod tests {\n                     Either::B => (),\n                 }\n             }\n-        \";\n-\n-        // When `Either::A` is missing a struct member, we don't want\n-        // to fire the missing match arm diagnostic. This should fire\n-        // some other diagnostic.\n-        check_no_diagnostic(content);\n+        \",\n+        );\n     }\n \n     #[test]\n     fn enum_record_missing_field_missing_match_arm() {\n-        let content = r\"\n+        // Even though `Either::A` is missing fields, we still want to fire\n+        // the missing arm diagnostic here, since we know `Either::B` is missing.\n+        check_diagnostic(\n+            r\"\n             enum Either {\n                 A { foo: bool },\n                 B,\n@@ -1704,16 +1705,14 @@ mod tests {\n                     Either::A { } => (),\n                 }\n             }\n-        \";\n-\n-        // Even though `Either::A` is missing fields, we still want to fire\n-        // the missing arm diagnostic here, since we know `Either::B` is missing.\n-        check_diagnostic(content);\n+        \",\n+        );\n     }\n \n     #[test]\n     fn enum_record_no_diagnostic_wild() {\n-        let content = r\"\n+        check_no_diagnostic(\n+            r\"\n             enum Either {\n                 A { foo: bool },\n                 B,\n@@ -1725,14 +1724,14 @@ mod tests {\n                     Either::B => (),\n                 }\n             }\n-        \";\n-\n-        check_no_diagnostic(content);\n+        \",\n+        );\n     }\n \n     #[test]\n     fn enum_record_fields_out_of_order_missing_arm() {\n-        let content = r\"\n+        check_diagnostic(\n+            r\"\n             enum Either {\n                 A { foo: bool, bar: () },\n                 B,\n@@ -1744,14 +1743,14 @@ mod tests {\n                     Either::A { foo: true, bar: () } => (),\n                 }\n             }\n-        \";\n-\n-        check_diagnostic(content);\n+        \",\n+        );\n     }\n \n     #[test]\n     fn enum_record_fields_out_of_order_no_diagnostic() {\n-        let content = r\"\n+        check_no_diagnostic(\n+            r\"\n             enum Either {\n                 A { foo: bool, bar: () },\n                 B,\n@@ -1764,89 +1763,89 @@ mod tests {\n                     Either::B => (),\n                 }\n             }\n-        \";\n-\n-        check_no_diagnostic(content);\n+        \",\n+        );\n     }\n \n     #[test]\n     fn enum_record_ellipsis_missing_arm() {\n-        let content = r\"\n-             enum Either {\n-                 A { foo: bool, bar: bool },\n-                 B,\n-             }\n-             fn test_fn() {\n-                 match Either::B {\n-                     Either::A { foo: true, .. } => (),\n-                     Either::B => (),\n-                 }\n-             }\n-         \";\n-\n-        check_diagnostic(content);\n+        check_diagnostic(\n+            r\"\n+            enum Either {\n+                A { foo: bool, bar: bool },\n+                B,\n+            }\n+            fn test_fn() {\n+                match Either::B {\n+                    Either::A { foo: true, .. } => (),\n+                    Either::B => (),\n+                }\n+            }\n+        \",\n+        );\n     }\n \n     #[test]\n     fn enum_record_ellipsis_no_diagnostic() {\n-        let content = r\"\n-             enum Either {\n-                 A { foo: bool, bar: bool },\n-                 B,\n-             }\n-             fn test_fn() {\n-                 let a = Either::A { foo: true };\n-                 match a {\n-                     Either::A { foo: true, .. } => (),\n-                     Either::A { foo: false, .. } => (),\n-                     Either::B => (),\n-                 }\n-             }\n-         \";\n-\n-        check_no_diagnostic(content);\n+        check_no_diagnostic(\n+            r\"\n+            enum Either {\n+                A { foo: bool, bar: bool },\n+                B,\n+            }\n+            fn test_fn() {\n+                let a = Either::A { foo: true };\n+                match a {\n+                    Either::A { foo: true, .. } => (),\n+                    Either::A { foo: false, .. } => (),\n+                    Either::B => (),\n+                }\n+            }\n+        \",\n+        );\n     }\n \n     #[test]\n     fn enum_record_ellipsis_all_fields_missing_arm() {\n-        let content = r\"\n-             enum Either {\n-                 A { foo: bool, bar: bool },\n-                 B,\n-             }\n-             fn test_fn() {\n-                 let a = Either::B;\n-                 match a {\n-                     Either::A { .. } => (),\n-                 }\n-             }\n-         \";\n-\n-        check_diagnostic(content);\n+        check_diagnostic(\n+            r\"\n+            enum Either {\n+                A { foo: bool, bar: bool },\n+                B,\n+            }\n+            fn test_fn() {\n+                let a = Either::B;\n+                match a {\n+                    Either::A { .. } => (),\n+                }\n+            }\n+        \",\n+        );\n     }\n \n     #[test]\n     fn enum_record_ellipsis_all_fields_no_diagnostic() {\n-        let content = r\"\n-             enum Either {\n-                 A { foo: bool, bar: bool },\n-                 B,\n-             }\n-             fn test_fn() {\n-                 let a = Either::B;\n-                 match a {\n-                     Either::A { .. } => (),\n-                     Either::B => (),\n-                 }\n-             }\n-         \";\n-\n-        check_no_diagnostic(content);\n+        check_no_diagnostic(\n+            r\"\n+            enum Either {\n+                A { foo: bool, bar: bool },\n+                B,\n+            }\n+            fn test_fn() {\n+                let a = Either::B;\n+                match a {\n+                    Either::A { .. } => (),\n+                    Either::B => (),\n+                }\n+            }\n+        \",\n+        );\n     }\n \n     #[test]\n     fn enum_tuple_partial_ellipsis_no_diagnostic() {\n-        let content = r\"\n+        check_no_diagnostic(\n+            r\"\n             enum Either {\n                 A(bool, bool, bool, bool),\n                 B,\n@@ -1860,14 +1859,14 @@ mod tests {\n                     Either::B => {},\n                 }\n             }\n-        \";\n-\n-        check_no_diagnostic(content);\n+        \",\n+        );\n     }\n \n     #[test]\n     fn enum_tuple_partial_ellipsis_2_no_diagnostic() {\n-        let content = r\"\n+        check_no_diagnostic(\n+            r\"\n             enum Either {\n                 A(bool, bool, bool, bool),\n                 B,\n@@ -1881,14 +1880,14 @@ mod tests {\n                     Either::B => {},\n                 }\n             }\n-        \";\n-\n-        check_no_diagnostic(content);\n+        \",\n+        );\n     }\n \n     #[test]\n     fn enum_tuple_partial_ellipsis_missing_arm() {\n-        let content = r\"\n+        check_diagnostic(\n+            r\"\n             enum Either {\n                 A(bool, bool, bool, bool),\n                 B,\n@@ -1901,14 +1900,14 @@ mod tests {\n                     Either::B => {},\n                 }\n             }\n-        \";\n-\n-        check_diagnostic(content);\n+        \",\n+        );\n     }\n \n     #[test]\n     fn enum_tuple_partial_ellipsis_2_missing_arm() {\n-        let content = r\"\n+        check_diagnostic(\n+            r\"\n             enum Either {\n                 A(bool, bool, bool, bool),\n                 B,\n@@ -1921,14 +1920,14 @@ mod tests {\n                     Either::B => {},\n                 }\n             }\n-        \";\n-\n-        check_diagnostic(content);\n+        \",\n+        );\n     }\n \n     #[test]\n     fn enum_tuple_ellipsis_no_diagnostic() {\n-        let content = r\"\n+        check_no_diagnostic(\n+            r\"\n             enum Either {\n                 A(bool, bool, bool, bool),\n                 B,\n@@ -1939,51 +1938,51 @@ mod tests {\n                     Either::B => {},\n                 }\n             }\n-        \";\n-\n-        check_no_diagnostic(content);\n+        \",\n+        );\n     }\n \n     #[test]\n     fn enum_never() {\n-        let content = r\"\n+        check_no_diagnostic(\n+            r\"\n             enum Never {}\n \n             fn test_fn(never: Never) {\n                 match never {}\n             }\n-        \";\n-\n-        check_no_diagnostic(content);\n+        \",\n+        );\n     }\n \n     #[test]\n     fn type_never() {\n-        let content = r\"\n+        check_no_diagnostic(\n+            r\"\n             fn test_fn(never: !) {\n                 match never {}\n             }\n-        \";\n-\n-        check_no_diagnostic(content);\n+        \",\n+        );\n     }\n \n     #[test]\n     fn enum_never_ref() {\n-        let content = r\"\n+        check_no_diagnostic(\n+            r\"\n             enum Never {}\n \n             fn test_fn(never: &Never) {\n                 match never {}\n             }\n-        \";\n-\n-        check_no_diagnostic(content);\n+        \",\n+        );\n     }\n \n     #[test]\n     fn expr_diverges_missing_arm() {\n-        let content = r\"\n+        check_no_diagnostic(\n+            r\"\n             enum Either {\n                 A,\n                 B,\n@@ -1993,14 +1992,14 @@ mod tests {\n                     Either::A => (),\n                 }\n             }\n-        \";\n-\n-        check_no_diagnostic(content);\n+        \",\n+        );\n     }\n \n     #[test]\n     fn or_pattern_panic() {\n-        let content = r\"\n+        check_no_diagnostic(\n+            r\"\n             pub enum Category {\n                 Infinity,\n                 Zero,\n@@ -2012,9 +2011,8 @@ mod tests {\n                     (_, Category::Zero | Category::Infinity) => {}\n                 }\n             }\n-        \";\n-\n-        check_no_diagnostic(content);\n+        \",\n+        );\n     }\n }\n \n@@ -2034,23 +2032,26 @@ mod false_negatives {\n \n     #[test]\n     fn integers() {\n-        let content = r\"\n+        // This is a false negative.\n+        // We don't currently check integer exhaustiveness.\n+        check_no_diagnostic(\n+            r\"\n             fn test_fn() {\n                 match 5 {\n                     10 => (),\n                     11..20 => (),\n                 }\n             }\n-        \";\n-\n-        // This is a false negative.\n-        // We don't currently check integer exhaustiveness.\n-        check_no_diagnostic(content);\n+        \",\n+        );\n     }\n \n     #[test]\n     fn internal_or() {\n-        let content = r\"\n+        // This is a false negative.\n+        // We do not currently handle patterns with internal `or`s.\n+        check_no_diagnostic(\n+            r\"\n             fn test_fn() {\n                 enum Either {\n                     A(bool),\n@@ -2060,16 +2061,18 @@ mod false_negatives {\n                     Either::A(true | false) => (),\n                 }\n             }\n-        \";\n-\n-        // This is a false negative.\n-        // We do not currently handle patterns with internal `or`s.\n-        check_no_diagnostic(content);\n+        \",\n+        );\n     }\n \n     #[test]\n     fn expr_loop_missing_arm() {\n-        let content = r\"\n+        // This is a false negative.\n+        // We currently infer the type of `loop { break Foo::A }` to `!`, which\n+        // causes us to skip the diagnostic since `Either::A` doesn't type check\n+        // with `!`.\n+        check_diagnostic(\n+            r\"\n             enum Either {\n                 A,\n                 B,\n@@ -2079,48 +2082,46 @@ mod false_negatives {\n                     Either::A => (),\n                 }\n             }\n-        \";\n-\n-        // This is a false negative.\n-        // We currently infer the type of `loop { break Foo::A }` to `!`, which\n-        // causes us to skip the diagnostic since `Either::A` doesn't type check\n-        // with `!`.\n-        check_diagnostic(content);\n+        \",\n+        );\n     }\n \n     #[test]\n     fn tuple_of_bools_with_ellipsis_at_end_missing_arm() {\n-        let content = r\"\n+        // This is a false negative.\n+        // We don't currently handle tuple patterns with ellipsis.\n+        check_no_diagnostic(\n+            r\"\n             fn test_fn() {\n                 match (false, true, false) {\n                     (false, ..) => {},\n                 }\n             }\n-        \";\n-\n-        // This is a false negative.\n-        // We don't currently handle tuple patterns with ellipsis.\n-        check_no_diagnostic(content);\n+        \",\n+        );\n     }\n \n     #[test]\n     fn tuple_of_bools_with_ellipsis_at_beginning_missing_arm() {\n-        let content = r\"\n+        // This is a false negative.\n+        // We don't currently handle tuple patterns with ellipsis.\n+        check_no_diagnostic(\n+            r\"\n             fn test_fn() {\n                 match (false, true, false) {\n                     (.., false) => {},\n                 }\n             }\n-        \";\n-\n-        // This is a false negative.\n-        // We don't currently handle tuple patterns with ellipsis.\n-        check_no_diagnostic(content);\n+        \",\n+        );\n     }\n \n     #[test]\n     fn struct_missing_arm() {\n-        let content = r\"\n+        // This is a false negative.\n+        // We don't currently handle structs.\n+        check_no_diagnostic(\n+            r\"\n             struct Foo {\n                 a: bool,\n             }\n@@ -2129,10 +2130,7 @@ mod false_negatives {\n                     Foo { a: true } => {},\n                 }\n             }\n-        \";\n-\n-        // This is a false negative.\n-        // We don't currently handle structs.\n-        check_no_diagnostic(content);\n+        \",\n+        );\n     }\n }"}]}