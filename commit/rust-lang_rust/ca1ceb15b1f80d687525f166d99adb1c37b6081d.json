{"sha": "ca1ceb15b1f80d687525f166d99adb1c37b6081d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNhMWNlYjE1YjFmODBkNjg3NTI1ZjE2NmQ5OWFkYjFjMzdiNjA4MWQ=", "commit": {"author": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2013-03-02T03:07:12Z"}, "committer": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2013-03-02T19:10:16Z"}, "message": "add a TotalOrd trait", "tree": {"sha": "47803212232855c982b5c5844c55fbc86bace7f9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/47803212232855c982b5c5844c55fbc86bace7f9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ca1ceb15b1f80d687525f166d99adb1c37b6081d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ca1ceb15b1f80d687525f166d99adb1c37b6081d", "html_url": "https://github.com/rust-lang/rust/commit/ca1ceb15b1f80d687525f166d99adb1c37b6081d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ca1ceb15b1f80d687525f166d99adb1c37b6081d/comments", "author": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "committer": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a660bb362ce5a39014fb274367e6361d4deb8a7d", "url": "https://api.github.com/repos/rust-lang/rust/commits/a660bb362ce5a39014fb274367e6361d4deb8a7d", "html_url": "https://github.com/rust-lang/rust/commit/a660bb362ce5a39014fb274367e6361d4deb8a7d"}], "stats": {"total": 177, "additions": 166, "deletions": 11}, "files": [{"sha": "d588f0c53b17e1f47dea3b9b12b23d733619a1ca", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/ca1ceb15b1f80d687525f166d99adb1c37b6081d/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca1ceb15b1f80d687525f166d99adb1c37b6081d/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=ca1ceb15b1f80d687525f166d99adb1c37b6081d", "patch": "@@ -37,6 +37,70 @@ pub trait Eq {\n     pure fn ne(&self, other: &Self) -> bool;\n }\n \n+#[deriving_eq]\n+pub enum Ordering { Less, Equal, Greater }\n+\n+/// Trait for types that form a total order\n+pub trait TotalOrd {\n+    pure fn cmp(&self, other: &Self) -> Ordering;\n+}\n+\n+pure fn icmp<T: Ord>(a: &T, b: &T) -> Ordering {\n+    if *a < *b { Less }\n+    else if *a > *b { Greater }\n+    else { Equal }\n+}\n+\n+impl TotalOrd for u8 {\n+    #[inline(always)]\n+    pure fn cmp(&self, other: &u8) -> Ordering { icmp(self, other) }\n+}\n+\n+impl TotalOrd for u16 {\n+    #[inline(always)]\n+    pure fn cmp(&self, other: &u16) -> Ordering { icmp(self, other) }\n+}\n+\n+impl TotalOrd for u32 {\n+    #[inline(always)]\n+    pure fn cmp(&self, other: &u32) -> Ordering { icmp(self, other) }\n+}\n+\n+impl TotalOrd for u64 {\n+    #[inline(always)]\n+    pure fn cmp(&self, other: &u64) -> Ordering { icmp(self, other) }\n+}\n+\n+impl TotalOrd for i8 {\n+    #[inline(always)]\n+    pure fn cmp(&self, other: &i8) -> Ordering { icmp(self, other) }\n+}\n+\n+impl TotalOrd for i16 {\n+    #[inline(always)]\n+    pure fn cmp(&self, other: &i16) -> Ordering { icmp(self, other) }\n+}\n+\n+impl TotalOrd for i32 {\n+    #[inline(always)]\n+    pure fn cmp(&self, other: &i32) -> Ordering { icmp(self, other) }\n+}\n+\n+impl TotalOrd for i64 {\n+    #[inline(always)]\n+    pure fn cmp(&self, other: &i64) -> Ordering { icmp(self, other) }\n+}\n+\n+impl TotalOrd for int {\n+    #[inline(always)]\n+    pure fn cmp(&self, other: &int) -> Ordering { icmp(self, other) }\n+}\n+\n+impl TotalOrd for uint {\n+    #[inline(always)]\n+    pure fn cmp(&self, other: &uint) -> Ordering { icmp(self, other) }\n+}\n+\n /**\n * Trait for values that can be compared for a sort-order.\n *\n@@ -94,3 +158,15 @@ pub pure fn min<T:Ord>(v1: T, v2: T) -> T {\n pub pure fn max<T:Ord>(v1: T, v2: T) -> T {\n     if v1 > v2 { v1 } else { v2 }\n }\n+\n+#[cfg(test)]\n+mod test {\n+    #[test]\n+    fn test_int() {\n+        assert 5.cmp(&10) == Less;\n+        assert 10.cmp(&5) == Greater;\n+        assert 5.cmp(&5) == Equal;\n+        assert (-5).cmp(&12) == Less;\n+        assert 12.cmp(-5) == Greater;\n+    }\n+}"}, {"sha": "a7b4500c3e3802f06aae5d1c747b0f79d517f85c", "filename": "src/libcore/prelude.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca1ceb15b1f80d687525f166d99adb1c37b6081d/src%2Flibcore%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca1ceb15b1f80d687525f166d99adb1c37b6081d/src%2Flibcore%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprelude.rs?ref=ca1ceb15b1f80d687525f166d99adb1c37b6081d", "patch": "@@ -24,7 +24,7 @@ pub use result::{Result, Ok, Err};\n /* Reexported types and traits */\n \n pub use clone::Clone;\n-pub use cmp::{Eq, Ord};\n+pub use cmp::{Eq, Ord, TotalOrd, Ordering, Less, Equal, Greater};\n pub use container::{Container, Mutable, Map, Set};\n pub use hash::Hash;\n pub use iter::{BaseIter, ExtendedIter, EqIter, CopyableIter};"}, {"sha": "ef0fa9fc4e28b160a2bed8c231f863b5fa8591ef", "filename": "src/libcore/str.rs", "status": "modified", "additions": 39, "deletions": 1, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/ca1ceb15b1f80d687525f166d99adb1c37b6081d/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca1ceb15b1f80d687525f166d99adb1c37b6081d/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=ca1ceb15b1f80d687525f166d99adb1c37b6081d", "patch": "@@ -20,7 +20,7 @@\n use at_vec;\n use cast;\n use char;\n-use cmp::{Eq, Ord};\n+use cmp::{Eq, Ord, TotalOrd, Ordering, Less, Equal, Greater};\n use libc;\n use libc::size_t;\n use io::WriterUtil;\n@@ -773,6 +773,35 @@ pub pure fn eq(a: &~str, b: &~str) -> bool {\n     eq_slice(*a, *b)\n }\n \n+pure fn cmp(a: &str, b: &str) -> Ordering {\n+    let low = uint::min(a.len(), b.len());\n+\n+    for uint::range(0, low) |idx| {\n+        match a[idx].cmp(&b[idx]) {\n+          Greater => return Greater,\n+          Less => return Less,\n+          Equal => ()\n+        }\n+    }\n+\n+    a.len().cmp(&b.len())\n+}\n+\n+#[cfg(notest)]\n+impl TotalOrd for &str {\n+    pure fn cmp(&self, other: & &self/str) -> Ordering { cmp(*self, *other) }\n+}\n+\n+#[cfg(notest)]\n+impl TotalOrd for ~str {\n+    pure fn cmp(&self, other: &~str) -> Ordering { cmp(*self, *other) }\n+}\n+\n+#[cfg(notest)]\n+impl TotalOrd for @str {\n+    pure fn cmp(&self, other: &@str) -> Ordering { cmp(*self, *other) }\n+}\n+\n /// Bytewise slice less than\n pure fn lt(a: &str, b: &str) -> bool {\n     let (a_len, b_len) = (a.len(), b.len());\n@@ -2382,6 +2411,7 @@ mod tests {\n     use ptr;\n     use str::*;\n     use vec;\n+    use cmp::{TotalOrd, Less, Equal, Greater};\n \n     #[test]\n     fn test_eq() {\n@@ -3388,4 +3418,12 @@ mod tests {\n         assert view(\"abcdef\", 1, 5).to_managed() == @\"bcde\";\n     }\n \n+    #[test]\n+    fn test_total_ord() {\n+        \"1234\".cmp(& &\"123\") == Greater;\n+        \"123\".cmp(& &\"1234\") == Less;\n+        \"1234\".cmp(& &\"1234\") == Equal;\n+        \"12345555\".cmp(& &\"123456\") == Less;\n+        \"22\".cmp(& &\"1234\") == Greater;\n+    }\n }"}, {"sha": "86365247044cbb1713bbb523e15aabc269263be6", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 50, "deletions": 9, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/ca1ceb15b1f80d687525f166d99adb1c37b6081d/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca1ceb15b1f80d687525f166d99adb1c37b6081d/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=ca1ceb15b1f80d687525f166d99adb1c37b6081d", "patch": "@@ -15,7 +15,7 @@\n use container::{Container, Mutable};\n use cast::transmute;\n use cast;\n-use cmp::{Eq, Ord};\n+use cmp::{Eq, Ord, TotalOrd, Ordering, Less, Equal, Greater};\n use iter::BaseIter;\n use iter;\n use kinds::Copy;\n@@ -1425,7 +1425,7 @@ pub pure fn rev_eachi<T>(v: &r/[T], blk: fn(i: uint, v: &r/T) -> bool) {\n  * Both vectors must have the same length\n  */\n #[inline]\n-pub fn each2<U, T>(v1: &[U], v2: &[T], f: fn(u: &U, t: &T) -> bool) {\n+pub pure fn each2<U, T>(v1: &[U], v2: &[T], f: fn(u: &U, t: &T) -> bool) {\n     assert len(v1) == len(v2);\n     for uint::range(0u, len(v1)) |i| {\n         if !f(&v1[i], &v2[i]) {\n@@ -1575,6 +1575,38 @@ impl<T:Eq> Eq for @[T] {\n \n // Lexicographical comparison\n \n+pure fn cmp<T: TotalOrd>(a: &[T], b: &[T]) -> Ordering {\n+    let low = uint::min(a.len(), b.len());\n+\n+    for uint::range(0, low) |idx| {\n+        match a[idx].cmp(&b[idx]) {\n+          Greater => return Greater,\n+          Less => return Less,\n+          Equal => ()\n+        }\n+    }\n+\n+    a.len().cmp(&b.len())\n+}\n+\n+#[cfg(notest)]\n+impl<T: TotalOrd> TotalOrd for &[T] {\n+    #[inline(always)]\n+    pure fn cmp(&self, other: & &self/[T]) -> Ordering { cmp(*self, *other) }\n+}\n+\n+#[cfg(notest)]\n+impl<T: TotalOrd> TotalOrd for ~[T] {\n+    #[inline(always)]\n+    pure fn cmp(&self, other: &~[T]) -> Ordering { cmp(*self, *other) }\n+}\n+\n+#[cfg(notest)]\n+impl<T: TotalOrd> TotalOrd for @[T] {\n+    #[inline(always)]\n+    pure fn cmp(&self, other: &@[T]) -> Ordering { cmp(*self, *other) }\n+}\n+\n pure fn lt<T:Ord>(a: &[T], b: &[T]) -> bool {\n     let (a_len, b_len) = (a.len(), b.len());\n     let mut end = uint::min(a_len, b_len);\n@@ -2151,7 +2183,7 @@ pub mod bytes {\n     use vec;\n \n     /// Bytewise string comparison\n-    pub pure fn cmp(a: &~[u8], b: &~[u8]) -> int {\n+    pub pure fn memcmp(a: &~[u8], b: &~[u8]) -> int {\n         let a_len = len(*a);\n         let b_len = len(*b);\n         let n = uint::min(a_len, b_len) as libc::size_t;\n@@ -2172,22 +2204,22 @@ pub mod bytes {\n     }\n \n     /// Bytewise less than or equal\n-    pub pure fn lt(a: &~[u8], b: &~[u8]) -> bool { cmp(a, b) < 0 }\n+    pub pure fn lt(a: &~[u8], b: &~[u8]) -> bool { memcmp(a, b) < 0 }\n \n     /// Bytewise less than or equal\n-    pub pure fn le(a: &~[u8], b: &~[u8]) -> bool { cmp(a, b) <= 0 }\n+    pub pure fn le(a: &~[u8], b: &~[u8]) -> bool { memcmp(a, b) <= 0 }\n \n     /// Bytewise equality\n-    pub pure fn eq(a: &~[u8], b: &~[u8]) -> bool { cmp(a, b) == 0 }\n+    pub pure fn eq(a: &~[u8], b: &~[u8]) -> bool { memcmp(a, b) == 0 }\n \n     /// Bytewise inequality\n-    pub pure fn ne(a: &~[u8], b: &~[u8]) -> bool { cmp(a, b) != 0 }\n+    pub pure fn ne(a: &~[u8], b: &~[u8]) -> bool { memcmp(a, b) != 0 }\n \n     /// Bytewise greater than or equal\n-    pub pure fn ge(a: &~[u8], b: &~[u8]) -> bool { cmp(a, b) >= 0 }\n+    pub pure fn ge(a: &~[u8], b: &~[u8]) -> bool { memcmp(a, b) >= 0 }\n \n     /// Bytewise greater than\n-    pub pure fn gt(a: &~[u8], b: &~[u8]) -> bool { cmp(a, b) > 0 }\n+    pub pure fn gt(a: &~[u8], b: &~[u8]) -> bool { memcmp(a, b) > 0 }\n \n     /**\n       * Copies data from one vector to another.\n@@ -2429,6 +2461,7 @@ mod tests {\n     use option;\n     use sys;\n     use vec::*;\n+    use cmp::*;\n \n     fn square(n: uint) -> uint { return n * n; }\n \n@@ -3942,6 +3975,14 @@ mod tests {\n         }\n     }\n \n+    #[test]\n+    fn test_total_ord() {\n+        [1, 2, 3, 4].cmp(& &[1, 2, 3]) == Greater;\n+        [1, 2, 3].cmp(& &[1, 2, 3, 4]) == Less;\n+        [1, 2, 3, 4].cmp(& &[1, 2, 3, 4]) == Equal;\n+        [1, 2, 3, 4, 5, 5, 5, 5].cmp(& &[1, 2, 3, 4, 5, 6]) == Less;\n+        [2, 2].cmp(& &[1, 2, 3, 4]) == Greater;\n+    }\n }\n \n // Local Variables:"}]}