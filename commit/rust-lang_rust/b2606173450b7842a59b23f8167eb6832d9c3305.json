{"sha": "b2606173450b7842a59b23f8167eb6832d9c3305", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIyNjA2MTczNDUwYjc4NDJhNTliMjNmODE2N2ViNjgzMmQ5YzMzMDU=", "commit": {"author": {"name": "Srinivas Reddy Thatiparthy", "email": "thatiparthysreenivas@gmail.com", "date": "2016-10-18T17:43:02Z"}, "committer": {"name": "Srinivas Reddy Thatiparthy", "email": "thatiparthysreenivas@gmail.com", "date": "2016-10-18T17:43:02Z"}, "message": "run rustfmt on librustc_errors folder", "tree": {"sha": "cc3091180e0bd1292909473e67405d30397df5a1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cc3091180e0bd1292909473e67405d30397df5a1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b2606173450b7842a59b23f8167eb6832d9c3305", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v1\n\niQIcBAABAgAGBQJYBl8mAAoJEAkcWPS/w2Vx61EQAJMx1W7VYGwkSxfrq/i0nZSl\nRWC4WnvHH1exQPZWy0IyKt1EAPI9tO4FhbyHPwi6Hbi0/v+/ecD1BwNrdVeluyfs\nOyRbLLD9m8cE6HbqnrbSlQFpBNuk7FI6cQxuG3H7Ud0v3H1mpMeRxrkb6G7X/O+w\nv86uCwuesRTnJE/AEeBwP5pUOsCaOT4rbMrKO3NrmTqM7iJ4XhwpjCTjmL3ZIfwi\nwNlaAPsYYKFRBJ64XmxuexNlmFCzikqt/Kexldln78LkdWwis6cQsjNDEu6BQuiw\nOjBNm2g8u2gkiVyTl5mNItSV9WSFD6IEzFio0/1cxBNyhAbyqo+QFUyDycWt/KsY\nNWcl4ZLGUsgNNlZR4QkGimRnJzUoo5NaNAil4X12GYyr0vUQrNXw/wN2vPBKWT4p\n/RQLJDsG8rpiCawIvDQiauSvXD+UdEYYbBDgkjE/IEoGZZebOEXEcRqb2RkmJ2tT\nyB36Uk9Fdu0N7vN5Qa/Nhz/POzTruRSw4fpgO+CgjgiAsE7BIl8v/dvQlaQf4ggD\n8tly7f21QxcJ0P+uEcr5YUx1htd0M1F5SoNXtzvYNVE1hHg0u2gG4wjOXPzSTU05\na1nNxLnsHA60JUGt8vsT3IGTbWlShtiw8+KYFIe4D2mYD7Tb32vUbZeav+cC4pWk\nr4sqddr46UObTnIaIte5\n=QnPU\n-----END PGP SIGNATURE-----", "payload": "tree cc3091180e0bd1292909473e67405d30397df5a1\nparent 16eeeac783d2ede28e09f2a433c612dea309fe33\nauthor Srinivas Reddy Thatiparthy <thatiparthysreenivas@gmail.com> 1476812582 +0530\ncommitter Srinivas Reddy Thatiparthy <thatiparthysreenivas@gmail.com> 1476812582 +0530\n\nrun rustfmt on librustc_errors folder\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b2606173450b7842a59b23f8167eb6832d9c3305", "html_url": "https://github.com/rust-lang/rust/commit/b2606173450b7842a59b23f8167eb6832d9c3305", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b2606173450b7842a59b23f8167eb6832d9c3305/comments", "author": {"login": "srinivasreddy", "id": 198396, "node_id": "MDQ6VXNlcjE5ODM5Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/198396?v=4", "gravatar_id": "", "url": "https://api.github.com/users/srinivasreddy", "html_url": "https://github.com/srinivasreddy", "followers_url": "https://api.github.com/users/srinivasreddy/followers", "following_url": "https://api.github.com/users/srinivasreddy/following{/other_user}", "gists_url": "https://api.github.com/users/srinivasreddy/gists{/gist_id}", "starred_url": "https://api.github.com/users/srinivasreddy/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/srinivasreddy/subscriptions", "organizations_url": "https://api.github.com/users/srinivasreddy/orgs", "repos_url": "https://api.github.com/users/srinivasreddy/repos", "events_url": "https://api.github.com/users/srinivasreddy/events{/privacy}", "received_events_url": "https://api.github.com/users/srinivasreddy/received_events", "type": "User", "site_admin": false}, "committer": {"login": "srinivasreddy", "id": 198396, "node_id": "MDQ6VXNlcjE5ODM5Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/198396?v=4", "gravatar_id": "", "url": "https://api.github.com/users/srinivasreddy", "html_url": "https://github.com/srinivasreddy", "followers_url": "https://api.github.com/users/srinivasreddy/followers", "following_url": "https://api.github.com/users/srinivasreddy/following{/other_user}", "gists_url": "https://api.github.com/users/srinivasreddy/gists{/gist_id}", "starred_url": "https://api.github.com/users/srinivasreddy/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/srinivasreddy/subscriptions", "organizations_url": "https://api.github.com/users/srinivasreddy/orgs", "repos_url": "https://api.github.com/users/srinivasreddy/repos", "events_url": "https://api.github.com/users/srinivasreddy/events{/privacy}", "received_events_url": "https://api.github.com/users/srinivasreddy/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "16eeeac783d2ede28e09f2a433c612dea309fe33", "url": "https://api.github.com/repos/rust-lang/rust/commits/16eeeac783d2ede28e09f2a433c612dea309fe33", "html_url": "https://github.com/rust-lang/rust/commit/16eeeac783d2ede28e09f2a433c612dea309fe33"}], "stats": {"total": 354, "additions": 173, "deletions": 181}, "files": [{"sha": "a307e9b696def0ad6171c570d885544c6cff19b7", "filename": "src/librustc_errors/emitter.rs", "status": "modified", "additions": 84, "deletions": 90, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/b2606173450b7842a59b23f8167eb6832d9c3305/src%2Flibrustc_errors%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2606173450b7842a59b23f8167eb6832d9c3305/src%2Flibrustc_errors%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Femitter.rs?ref=b2606173450b7842a59b23f8167eb6832d9c3305", "patch": "@@ -51,8 +51,8 @@ impl ColorConfig {\n     fn use_color(&self) -> bool {\n         match *self {\n             ColorConfig::Always => true,\n-            ColorConfig::Never  => false,\n-            ColorConfig::Auto   => stderr_isatty(),\n+            ColorConfig::Never => false,\n+            ColorConfig::Auto => stderr_isatty(),\n         }\n     }\n }\n@@ -83,22 +83,22 @@ macro_rules! println_maybe_styled {\n }\n \n impl EmitterWriter {\n-    pub fn stderr(color_config: ColorConfig,\n-                  code_map: Option<Rc<CodeMapper>>)\n-                  -> EmitterWriter {\n+    pub fn stderr(color_config: ColorConfig, code_map: Option<Rc<CodeMapper>>) -> EmitterWriter {\n         if color_config.use_color() {\n             let dst = Destination::from_stderr();\n-            EmitterWriter { dst: dst,\n-                            cm: code_map}\n+            EmitterWriter {\n+                dst: dst,\n+                cm: code_map,\n+            }\n         } else {\n-            EmitterWriter { dst: Raw(Box::new(io::stderr())),\n-                            cm: code_map}\n+            EmitterWriter {\n+                dst: Raw(Box::new(io::stderr())),\n+                cm: code_map,\n+            }\n         }\n     }\n \n-    pub fn new(dst: Box<Write + Send>,\n-               code_map: Option<Rc<CodeMapper>>)\n-               -> EmitterWriter {\n+    pub fn new(dst: Box<Write + Send>, code_map: Option<Rc<CodeMapper>>) -> EmitterWriter {\n         EmitterWriter {\n             dst: Raw(dst),\n             cm: code_map,\n@@ -107,9 +107,9 @@ impl EmitterWriter {\n \n     fn preprocess_annotations(&self, msp: &MultiSpan) -> Vec<FileWithAnnotatedLines> {\n         fn add_annotation_to_file(file_vec: &mut Vec<FileWithAnnotatedLines>,\n-                                    file: Rc<FileMap>,\n-                                    line_index: usize,\n-                                    ann: Annotation) {\n+                                  file: Rc<FileMap>,\n+                                  line_index: usize,\n+                                  ann: Annotation) {\n \n             for slot in file_vec.iter_mut() {\n                 // Look through each of our files for the one we're adding to\n@@ -168,15 +168,15 @@ impl EmitterWriter {\n                 }\n \n                 add_annotation_to_file(&mut output,\n-                                        lo.file,\n-                                        lo.line,\n-                                        Annotation {\n-                                            start_col: lo.col.0,\n-                                            end_col: hi.col.0,\n-                                            is_primary: span_label.is_primary,\n-                                            is_minimized: is_minimized,\n-                                            label: span_label.label.clone(),\n-                                        });\n+                                       lo.file,\n+                                       lo.line,\n+                                       Annotation {\n+                                           start_col: lo.col.0,\n+                                           end_col: hi.col.0,\n+                                           is_primary: span_label.is_primary,\n+                                           is_minimized: is_minimized,\n+                                           label: span_label.label.clone(),\n+                                       });\n             }\n         }\n         output\n@@ -237,19 +237,15 @@ impl EmitterWriter {\n                                 '^',\n                                 Style::UnderlinePrimary);\n                     if !annotation.is_minimized {\n-                        buffer.set_style(line_offset,\n-                                            width_offset + p,\n-                                            Style::UnderlinePrimary);\n+                        buffer.set_style(line_offset, width_offset + p, Style::UnderlinePrimary);\n                     }\n                 } else {\n                     buffer.putc(line_offset + 1,\n                                 width_offset + p,\n                                 '-',\n                                 Style::UnderlineSecondary);\n                     if !annotation.is_minimized {\n-                        buffer.set_style(line_offset,\n-                                            width_offset + p,\n-                                            Style::UnderlineSecondary);\n+                        buffer.set_style(line_offset, width_offset + p, Style::UnderlineSecondary);\n                     }\n                 }\n             }\n@@ -429,8 +425,7 @@ impl EmitterWriter {\n                         }\n                         // Check to make sure we're not in any <*macros>\n                         if !cm.span_to_filename(def_site).contains(\"macros>\") &&\n-                            !trace.macro_decl_name.starts_with(\"#[\")\n-                        {\n+                           !trace.macro_decl_name.starts_with(\"#[\") {\n                             new_labels.push((trace.call_site,\n                                              \"in this macro invocation\".to_string()));\n                             break;\n@@ -475,10 +470,10 @@ impl EmitterWriter {\n         if spans_updated {\n             children.push(SubDiagnostic {\n                 level: Level::Note,\n-                message:\"this error originates in a macro outside of the current \\\n-                         crate\".to_string(),\n+                message: \"this error originates in a macro outside of the current crate\"\n+                    .to_string(),\n                 span: MultiSpan::new(),\n-                render_span: None\n+                render_span: None,\n             });\n         }\n     }\n@@ -502,8 +497,7 @@ impl EmitterWriter {\n             buffer.append(0, &level.to_string(), Style::HeaderMsg);\n             buffer.append(0, \": \", Style::NoStyle);\n             buffer.append(0, msg, Style::NoStyle);\n-        }\n-        else {\n+        } else {\n             buffer.append(0, &level.to_string(), Style::Level(level.clone()));\n             match code {\n                 &Some(ref code) => {\n@@ -522,23 +516,21 @@ impl EmitterWriter {\n         let mut annotated_files = self.preprocess_annotations(msp);\n \n         // Make sure our primary file comes first\n-        let primary_lo =\n-            if let (Some(ref cm), Some(ref primary_span)) = (self.cm.as_ref(),\n-                                                             msp.primary_span().as_ref()) {\n-                if primary_span != &&DUMMY_SP && primary_span != &&COMMAND_LINE_SP {\n-                    cm.lookup_char_pos(primary_span.lo)\n-                }\n-                else {\n-                    emit_to_destination(&buffer.render(), level, &mut self.dst)?;\n-                    return Ok(());\n-                }\n+        let primary_lo = if let (Some(ref cm), Some(ref primary_span)) =\n+            (self.cm.as_ref(), msp.primary_span().as_ref()) {\n+            if primary_span != &&DUMMY_SP && primary_span != &&COMMAND_LINE_SP {\n+                cm.lookup_char_pos(primary_span.lo)\n             } else {\n-                // If we don't have span information, emit and exit\n                 emit_to_destination(&buffer.render(), level, &mut self.dst)?;\n                 return Ok(());\n-            };\n+            }\n+        } else {\n+            // If we don't have span information, emit and exit\n+            emit_to_destination(&buffer.render(), level, &mut self.dst)?;\n+            return Ok(());\n+        };\n         if let Ok(pos) =\n-                annotated_files.binary_search_by(|x| x.file.name.cmp(&primary_lo.file.name)) {\n+            annotated_files.binary_search_by(|x| x.file.name.cmp(&primary_lo.file.name)) {\n             annotated_files.swap(0, pos);\n         }\n \n@@ -554,8 +546,8 @@ impl EmitterWriter {\n                 buffer.prepend(buffer_msg_line_offset, \"--> \", Style::LineNumber);\n                 let loc = primary_lo.clone();\n                 buffer.append(buffer_msg_line_offset,\n-                                &format!(\"{}:{}:{}\", loc.file.name, loc.line, loc.col.0 + 1),\n-                                Style::LineAndColumn);\n+                              &format!(\"{}:{}:{}\", loc.file.name, loc.line, loc.col.0 + 1),\n+                              Style::LineAndColumn);\n                 for _ in 0..max_line_num_len {\n                     buffer.prepend(buffer_msg_line_offset, \" \", Style::NoStyle);\n                 }\n@@ -569,8 +561,8 @@ impl EmitterWriter {\n                 // Then, the secondary file indicator\n                 buffer.prepend(buffer_msg_line_offset + 1, \"::: \", Style::LineNumber);\n                 buffer.append(buffer_msg_line_offset + 1,\n-                                &annotated_file.file.name,\n-                                Style::LineAndColumn);\n+                              &annotated_file.file.name,\n+                              Style::LineAndColumn);\n                 for _ in 0..max_line_num_len {\n                     buffer.prepend(buffer_msg_line_offset + 1, \" \", Style::NoStyle);\n                 }\n@@ -591,7 +583,7 @@ impl EmitterWriter {\n                 // this annotated line and the next one\n                 if line_idx < (annotated_file.lines.len() - 1) {\n                     let line_idx_delta = annotated_file.lines[line_idx + 1].line_index -\n-                                            annotated_file.lines[line_idx].line_index;\n+                                         annotated_file.lines[line_idx].line_index;\n                     if line_idx_delta > 2 {\n                         let last_buffer_line_num = buffer.num_lines();\n                         buffer.puts(last_buffer_line_num, 0, \"...\", Style::LineNumber);\n@@ -672,12 +664,7 @@ impl EmitterWriter {\n         let max_line_num = self.get_max_line_num(span, children);\n         let max_line_num_len = max_line_num.to_string().len();\n \n-        match self.emit_message_default(span,\n-                                        message,\n-                                        code,\n-                                        level,\n-                                        max_line_num_len,\n-                                        false) {\n+        match self.emit_message_default(span, message, code, level, max_line_num_len, false) {\n             Ok(()) => {\n                 if !children.is_empty() {\n                     let mut buffer = StyledBuffer::new();\n@@ -723,13 +710,15 @@ impl EmitterWriter {\n                     }\n                 }\n             }\n-            Err(e) => panic!(\"failed to emit error: {}\", e)\n+            Err(e) => panic!(\"failed to emit error: {}\", e),\n         }\n         match write!(&mut self.dst, \"\\n\") {\n             Err(e) => panic!(\"failed to emit error: {}\", e),\n-            _ => match self.dst.flush() {\n-                Err(e) => panic!(\"failed to emit error: {}\", e),\n-                _ => ()\n+            _ => {\n+                match self.dst.flush() {\n+                    Err(e) => panic!(\"failed to emit error: {}\", e),\n+                    _ => (),\n+                }\n             }\n         }\n     }\n@@ -753,8 +742,9 @@ fn overlaps(a1: &Annotation, a2: &Annotation) -> bool {\n }\n \n fn emit_to_destination(rendered_buffer: &Vec<Vec<StyledString>>,\n-        lvl: &Level,\n-        dst: &mut Destination) -> io::Result<()> {\n+                       lvl: &Level,\n+                       dst: &mut Destination)\n+                       -> io::Result<()> {\n     use lock;\n \n     // In order to prevent error message interleaving, where multiple error lines get intermixed\n@@ -795,8 +785,7 @@ fn stderr_isatty() -> bool {\n     const STD_ERROR_HANDLE: DWORD = -12i32 as DWORD;\n     extern \"system\" {\n         fn GetStdHandle(which: DWORD) -> HANDLE;\n-        fn GetConsoleMode(hConsoleHandle: HANDLE,\n-                          lpMode: *mut DWORD) -> BOOL;\n+        fn GetConsoleMode(hConsoleHandle: HANDLE, lpMode: *mut DWORD) -> BOOL;\n     }\n     unsafe {\n         let handle = GetStdHandle(STD_ERROR_HANDLE);\n@@ -824,9 +813,7 @@ impl BufferedWriter {\n     // note: we use _new because the conditional compilation at its use site may make this\n     // this function unused on some platforms\n     fn _new() -> BufferedWriter {\n-        BufferedWriter {\n-            buffer: vec![]\n-        }\n+        BufferedWriter { buffer: vec![] }\n     }\n }\n \n@@ -853,35 +840,34 @@ impl Destination {\n     /// When not on Windows, prefer the buffered terminal so that we can buffer an entire error\n     /// to be emitted at one time.\n     fn from_stderr() -> Destination {\n-        let stderr: Option<Box<BufferedStderr>>  =\n+        let stderr: Option<Box<BufferedStderr>> =\n             term::TerminfoTerminal::new(BufferedWriter::_new())\n                 .map(|t| Box::new(t) as Box<BufferedStderr>);\n \n         match stderr {\n             Some(t) => BufferedTerminal(t),\n-            None    => Raw(Box::new(io::stderr())),\n+            None => Raw(Box::new(io::stderr())),\n         }\n     }\n \n     #[cfg(windows)]\n     /// Return a normal, unbuffered terminal when on Windows.\n     fn from_stderr() -> Destination {\n-        let stderr: Option<Box<term::StderrTerminal>> =\n-            term::TerminfoTerminal::new(io::stderr())\n-                .map(|t| Box::new(t) as Box<term::StderrTerminal>)\n-                .or_else(|| term::WinConsole::new(io::stderr()).ok()\n-                    .map(|t| Box::new(t) as Box<term::StderrTerminal>));\n+        let stderr: Option<Box<term::StderrTerminal>> = term::TerminfoTerminal::new(io::stderr())\n+            .map(|t| Box::new(t) as Box<term::StderrTerminal>)\n+            .or_else(|| {\n+                term::WinConsole::new(io::stderr())\n+                    .ok()\n+                    .map(|t| Box::new(t) as Box<term::StderrTerminal>)\n+            });\n \n         match stderr {\n             Some(t) => Terminal(t),\n-            None    => Raw(Box::new(io::stderr())),\n+            None => Raw(Box::new(io::stderr())),\n         }\n     }\n \n-    fn apply_style(&mut self,\n-                   lvl: Level,\n-                   style: Style)\n-                   -> io::Result<()> {\n+    fn apply_style(&mut self, lvl: Level, style: Style) -> io::Result<()> {\n         match style {\n             Style::FileNameStyle | Style::LineAndColumn => {}\n             Style::LineNumber => {\n@@ -931,18 +917,26 @@ impl Destination {\n \n     fn start_attr(&mut self, attr: term::Attr) -> io::Result<()> {\n         match *self {\n-            Terminal(ref mut t) => { t.attr(attr)?; }\n-            BufferedTerminal(ref mut t) => { t.attr(attr)?; }\n-            Raw(_) => { }\n+            Terminal(ref mut t) => {\n+                t.attr(attr)?;\n+            }\n+            BufferedTerminal(ref mut t) => {\n+                t.attr(attr)?;\n+            }\n+            Raw(_) => {}\n         }\n         Ok(())\n     }\n \n     fn reset_attrs(&mut self) -> io::Result<()> {\n         match *self {\n-            Terminal(ref mut t) => { t.reset()?; }\n-            BufferedTerminal(ref mut t) => { t.reset()?; }\n-            Raw(_) => { }\n+            Terminal(ref mut t) => {\n+                t.reset()?;\n+            }\n+            BufferedTerminal(ref mut t) => {\n+                t.reset()?;\n+            }\n+            Raw(_) => {}\n         }\n         Ok(())\n     }"}, {"sha": "25b314256b0925e827ae949fed4056b86f174a29", "filename": "src/librustc_errors/lib.rs", "status": "modified", "additions": 73, "deletions": 77, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/b2606173450b7842a59b23f8167eb6832d9c3305/src%2Flibrustc_errors%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2606173450b7842a59b23f8167eb6832d9c3305/src%2Flibrustc_errors%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Flib.rs?ref=b2606173450b7842a59b23f8167eb6832d9c3305", "patch": "@@ -28,8 +28,10 @@\n \n extern crate serialize;\n extern crate term;\n-#[macro_use] extern crate log;\n-#[macro_use] extern crate libc;\n+#[macro_use]\n+extern crate log;\n+#[macro_use]\n+extern crate libc;\n extern crate rustc_unicode;\n extern crate serialize as rustc_serialize; // used by deriving\n extern crate syntax_pos;\n@@ -52,8 +54,8 @@ pub mod registry;\n pub mod styled_buffer;\n mod lock;\n \n-use syntax_pos::{BytePos, Loc, FileLinesResult, FileName, MultiSpan, Span, NO_EXPANSION };\n-use syntax_pos::{MacroBacktrace};\n+use syntax_pos::{BytePos, Loc, FileLinesResult, FileName, MultiSpan, Span, NO_EXPANSION};\n+use syntax_pos::MacroBacktrace;\n \n #[derive(Clone)]\n pub enum RenderSpan {\n@@ -89,9 +91,11 @@ impl CodeSuggestion {\n     pub fn splice_lines(&self, cm: &CodeMapper) -> String {\n         use syntax_pos::{CharPos, Loc, Pos};\n \n-        fn push_trailing(buf: &mut String, line_opt: Option<&str>,\n-                         lo: &Loc, hi_opt: Option<&Loc>) {\n-            let (lo, hi_opt) = (lo.col.to_usize(), hi_opt.map(|hi|hi.col.to_usize()));\n+        fn push_trailing(buf: &mut String,\n+                         line_opt: Option<&str>,\n+                         lo: &Loc,\n+                         hi_opt: Option<&Loc>) {\n+            let (lo, hi_opt) = (lo.col.to_usize(), hi_opt.map(|hi| hi.col.to_usize()));\n             if let Some(line) = line_opt {\n                 if line.len() > lo {\n                     buf.push_str(match hi_opt {\n@@ -119,7 +123,11 @@ impl CodeSuggestion {\n         // Find the bounding span.\n         let lo = primary_spans.iter().map(|sp| sp.lo).min().unwrap();\n         let hi = primary_spans.iter().map(|sp| sp.hi).min().unwrap();\n-        let bounding_span = Span { lo: lo, hi: hi, expn_id: NO_EXPANSION };\n+        let bounding_span = Span {\n+            lo: lo,\n+            hi: hi,\n+            expn_id: NO_EXPANSION,\n+        };\n         let lines = cm.span_to_lines(bounding_span).unwrap();\n         assert!(!lines.lines.is_empty());\n \n@@ -153,7 +161,7 @@ impl CodeSuggestion {\n                     }\n                 }\n                 if let Some(cur_line) = fm.get_line(cur_lo.line - 1) {\n-                    buf.push_str(&cur_line[.. cur_lo.col.to_usize()]);\n+                    buf.push_str(&cur_line[..cur_lo.col.to_usize()]);\n                 }\n             }\n             buf.push_str(substitute);\n@@ -263,8 +271,7 @@ impl<'a> DiagnosticBuilder<'a> {\n     /// all, and you just supplied a `Span` to create the diagnostic,\n     /// then the snippet will just include that `Span`, which is\n     /// called the primary span.\n-    pub fn span_label(&mut self, span: Span, label: &fmt::Display)\n-                      -> &mut DiagnosticBuilder<'a> {\n+    pub fn span_label(&mut self, span: Span, label: &fmt::Display) -> &mut DiagnosticBuilder<'a> {\n         self.span.push_span_label(span, format!(\"{}\", label));\n         self\n     }\n@@ -273,8 +280,7 @@ impl<'a> DiagnosticBuilder<'a> {\n                                label: &fmt::Display,\n                                expected: &fmt::Display,\n                                found: &fmt::Display)\n-                               -> &mut DiagnosticBuilder<'a>\n-    {\n+                               -> &mut DiagnosticBuilder<'a> {\n         self.note_expected_found_extra(label, expected, found, &\"\", &\"\")\n     }\n \n@@ -284,8 +290,7 @@ impl<'a> DiagnosticBuilder<'a> {\n                                      found: &fmt::Display,\n                                      expected_extra: &fmt::Display,\n                                      found_extra: &fmt::Display)\n-                                     -> &mut DiagnosticBuilder<'a>\n-    {\n+                                     -> &mut DiagnosticBuilder<'a> {\n         // For now, just attach these as notes\n         self.note(&format!(\"expected {} `{}`{}\", label, expected, expected_extra));\n         self.note(&format!(\"   found {} `{}`{}\", label, found, found_extra));\n@@ -314,7 +319,7 @@ impl<'a> DiagnosticBuilder<'a> {\n         self.sub(Level::Warning, msg, sp.into(), None);\n         self\n     }\n-    pub fn help(&mut self , msg: &str) -> &mut DiagnosticBuilder<'a> {\n+    pub fn help(&mut self, msg: &str) -> &mut DiagnosticBuilder<'a> {\n         self.sub(Level::Help, msg, MultiSpan::new(), None);\n         self\n     }\n@@ -333,10 +338,13 @@ impl<'a> DiagnosticBuilder<'a> {\n                                                msg: &str,\n                                                suggestion: String)\n                                                -> &mut DiagnosticBuilder<'a> {\n-        self.sub(Level::Help, msg, MultiSpan::new(), Some(Suggestion(CodeSuggestion {\n-            msp: sp.into(),\n-            substitutes: vec![suggestion],\n-        })));\n+        self.sub(Level::Help,\n+                 msg,\n+                 MultiSpan::new(),\n+                 Some(Suggestion(CodeSuggestion {\n+                     msp: sp.into(),\n+                     substitutes: vec![suggestion],\n+                 })));\n         self\n     }\n \n@@ -360,18 +368,17 @@ impl<'a> DiagnosticBuilder<'a> {\n \n     /// Convenience function for internal use, clients should use one of the\n     /// struct_* methods on Handler.\n-    fn new(handler: &'a Handler,\n-           level: Level,\n-           message: &str) -> DiagnosticBuilder<'a> {\n+    fn new(handler: &'a Handler, level: Level, message: &str) -> DiagnosticBuilder<'a> {\n         DiagnosticBuilder::new_with_code(handler, level, None, message)\n     }\n \n     /// Convenience function for internal use, clients should use one of the\n     /// struct_* methods on Handler.\n     fn new_with_code(handler: &'a Handler,\n-           level: Level,\n-           code: Option<String>,\n-           message: &str) -> DiagnosticBuilder<'a> {\n+                     level: Level,\n+                     code: Option<String>,\n+                     message: &str)\n+                     -> DiagnosticBuilder<'a> {\n         DiagnosticBuilder {\n             handler: handler,\n             level: level,\n@@ -410,9 +417,8 @@ impl<'a> fmt::Debug for DiagnosticBuilder<'a> {\n impl<'a> Drop for DiagnosticBuilder<'a> {\n     fn drop(&mut self) {\n         if !panicking() && !self.cancelled() {\n-            let mut db = DiagnosticBuilder::new(self.handler,\n-                                                Bug,\n-                                                \"Error constructed but not emitted\");\n+            let mut db =\n+                DiagnosticBuilder::new(self.handler, Bug, \"Error constructed but not emitted\");\n             db.emit();\n             panic!();\n         }\n@@ -443,7 +449,8 @@ impl Handler {\n \n     pub fn with_emitter(can_emit_warnings: bool,\n                         treat_err_as_bug: bool,\n-                        e: Box<Emitter>) -> Handler {\n+                        e: Box<Emitter>)\n+                        -> Handler {\n         Handler {\n             err_count: Cell::new(0),\n             emitter: RefCell::new(e),\n@@ -544,10 +551,10 @@ impl Handler {\n \n     pub fn cancel(&self, err: &mut DiagnosticBuilder) {\n         if err.level == Level::Error || err.level == Level::Fatal {\n-            self.err_count.set(\n-                self.err_count.get().checked_sub(1)\n-                    .expect(\"cancelled an error but err_count is 0\")\n-            );\n+            self.err_count.set(self.err_count\n+                .get()\n+                .checked_sub(1)\n+                .expect(\"cancelled an error but err_count is 0\"));\n         }\n         err.cancel();\n     }\n@@ -558,14 +565,16 @@ impl Handler {\n         }\n     }\n \n-    pub fn span_fatal<S: Into<MultiSpan>>(&self, sp: S, msg: &str)\n-                                          -> FatalError {\n+    pub fn span_fatal<S: Into<MultiSpan>>(&self, sp: S, msg: &str) -> FatalError {\n         self.emit(&sp.into(), msg, Fatal);\n         self.bump_err_count();\n         self.panic_if_treat_err_as_bug();\n         return FatalError;\n     }\n-    pub fn span_fatal_with_code<S: Into<MultiSpan>>(&self, sp: S, msg: &str, code: &str)\n+    pub fn span_fatal_with_code<S: Into<MultiSpan>>(&self,\n+                                                    sp: S,\n+                                                    msg: &str,\n+                                                    code: &str)\n                                                     -> FatalError {\n         self.emit_with_code(&sp.into(), msg, code, Fatal);\n         self.bump_err_count();\n@@ -619,9 +628,7 @@ impl Handler {\n         if self.treat_err_as_bug {\n             self.bug(msg);\n         }\n-        let mut db = DiagnosticBuilder::new(self,\n-                                            Fatal,\n-                                            msg);\n+        let mut db = DiagnosticBuilder::new(self, Fatal, msg);\n         db.emit();\n         self.bump_err_count();\n         FatalError\n@@ -630,28 +637,20 @@ impl Handler {\n         if self.treat_err_as_bug {\n             self.bug(msg);\n         }\n-        let mut db = DiagnosticBuilder::new(self,\n-                                            Error,\n-                                            msg);\n+        let mut db = DiagnosticBuilder::new(self, Error, msg);\n         db.emit();\n         self.bump_err_count();\n     }\n     pub fn warn(&self, msg: &str) {\n-        let mut db = DiagnosticBuilder::new(self,\n-                                            Warning,\n-                                            msg);\n+        let mut db = DiagnosticBuilder::new(self, Warning, msg);\n         db.emit();\n     }\n     pub fn note_without_error(&self, msg: &str) {\n-        let mut db = DiagnosticBuilder::new(self,\n-                                            Note,\n-                                            msg);\n+        let mut db = DiagnosticBuilder::new(self, Note, msg);\n         db.emit();\n     }\n     pub fn bug(&self, msg: &str) -> ! {\n-        let mut db = DiagnosticBuilder::new(self,\n-                                            Bug,\n-                                            msg);\n+        let mut db = DiagnosticBuilder::new(self, Bug, msg);\n         db.emit();\n         panic!(ExplicitBug);\n     }\n@@ -678,44 +677,41 @@ impl Handler {\n                 match *delayed_bug {\n                     Some((ref span, ref errmsg)) => {\n                         self.span_bug(span.clone(), errmsg);\n-                    },\n+                    }\n                     _ => {}\n                 }\n \n                 return;\n             }\n             1 => s = \"aborting due to previous error\".to_string(),\n-            _  => {\n-                s = format!(\"aborting due to {} previous errors\",\n-                            self.err_count.get());\n+            _ => {\n+                s = format!(\"aborting due to {} previous errors\", self.err_count.get());\n             }\n         }\n \n         panic!(self.fatal(&s));\n     }\n-    pub fn emit(&self,\n-                msp: &MultiSpan,\n-                msg: &str,\n-                lvl: Level) {\n-        if lvl == Warning && !self.can_emit_warnings { return }\n+    pub fn emit(&self, msp: &MultiSpan, msg: &str, lvl: Level) {\n+        if lvl == Warning && !self.can_emit_warnings {\n+            return;\n+        }\n         let mut db = DiagnosticBuilder::new(self, lvl, msg);\n         db.set_span(msp.clone());\n         db.emit();\n-        if !self.continue_after_error.get() { self.abort_if_errors(); }\n-    }\n-    pub fn emit_with_code(&self,\n-                          msp: &MultiSpan,\n-                          msg: &str,\n-                          code: &str,\n-                          lvl: Level) {\n-        if lvl == Warning && !self.can_emit_warnings { return }\n-        let mut db = DiagnosticBuilder::new_with_code(self,\n-                                                      lvl,\n-                                                      Some(code.to_owned()),\n-                                                      msg);\n+        if !self.continue_after_error.get() {\n+            self.abort_if_errors();\n+        }\n+    }\n+    pub fn emit_with_code(&self, msp: &MultiSpan, msg: &str, code: &str, lvl: Level) {\n+        if lvl == Warning && !self.can_emit_warnings {\n+            return;\n+        }\n+        let mut db = DiagnosticBuilder::new_with_code(self, lvl, Some(code.to_owned()), msg);\n         db.set_span(msp.clone());\n         db.emit();\n-        if !self.continue_after_error.get() { self.abort_if_errors(); }\n+        if !self.continue_after_error.get() {\n+            self.abort_if_errors();\n+        }\n     }\n }\n \n@@ -750,7 +746,7 @@ impl Level {\n                 } else {\n                     term::color::YELLOW\n                 }\n-            },\n+            }\n             Note => term::color::BRIGHT_GREEN,\n             Help => term::color::BRIGHT_CYAN,\n             Cancelled => unreachable!(),\n@@ -769,8 +765,8 @@ impl Level {\n     }\n }\n \n-pub fn expect<T, M>(diag: &Handler, opt: Option<T>, msg: M) -> T where\n-    M: FnOnce() -> String,\n+pub fn expect<T, M>(diag: &Handler, opt: Option<T>, msg: M) -> T\n+    where M: FnOnce() -> String\n {\n     match opt {\n         Some(t) => t,"}, {"sha": "4c298228c37c7f4b2fa9abf52cbccdf6380d4f93", "filename": "src/librustc_errors/lock.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b2606173450b7842a59b23f8167eb6832d9c3305/src%2Flibrustc_errors%2Flock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2606173450b7842a59b23f8167eb6832d9c3305/src%2Flibrustc_errors%2Flock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Flock.rs?ref=b2606173450b7842a59b23f8167eb6832d9c3305", "patch": "@@ -40,9 +40,9 @@ pub fn acquire_global_lock(name: &str) -> Box<Any> {\n     extern \"system\" {\n         fn CreateMutexA(lpMutexAttributes: LPSECURITY_ATTRIBUTES,\n                         bInitialOwner: BOOL,\n-                        lpName: LPCSTR) -> HANDLE;\n-        fn WaitForSingleObject(hHandle: HANDLE,\n-                               dwMilliseconds: DWORD) -> DWORD;\n+                        lpName: LPCSTR)\n+                        -> HANDLE;\n+        fn WaitForSingleObject(hHandle: HANDLE, dwMilliseconds: DWORD) -> DWORD;\n         fn ReleaseMutex(hMutex: HANDLE) -> BOOL;\n         fn CloseHandle(hObject: HANDLE) -> BOOL;\n     }\n@@ -76,7 +76,8 @@ pub fn acquire_global_lock(name: &str) -> Box<Any> {\n         // open up a handle to one if it already exists.\n         let mutex = CreateMutexA(0 as *mut _, 0, cname.as_ptr() as *const u8);\n         if mutex.is_null() {\n-            panic!(\"failed to create global mutex named `{}`: {}\", name,\n+            panic!(\"failed to create global mutex named `{}`: {}\",\n+                   name,\n                    io::Error::last_os_error());\n         }\n         let mutex = Handle(mutex);\n@@ -96,8 +97,10 @@ pub fn acquire_global_lock(name: &str) -> Box<Any> {\n             WAIT_OBJECT_0 | WAIT_ABANDONED => {}\n             code => {\n                 panic!(\"WaitForSingleObject failed on global mutex named \\\n-                        `{}`: {} (ret={:x})\", name,\n-                       io::Error::last_os_error(), code);\n+                        `{}`: {} (ret={:x})\",\n+                       name,\n+                       io::Error::last_os_error(),\n+                       code);\n             }\n         }\n "}, {"sha": "83737681471e2f6fd9e1db306940e9aee0f9ce60", "filename": "src/librustc_errors/registry.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2606173450b7842a59b23f8167eb6832d9c3305/src%2Flibrustc_errors%2Fregistry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2606173450b7842a59b23f8167eb6832d9c3305/src%2Flibrustc_errors%2Fregistry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fregistry.rs?ref=b2606173450b7842a59b23f8167eb6832d9c3305", "patch": "@@ -12,7 +12,7 @@ use std::collections::HashMap;\n \n #[derive(Clone)]\n pub struct Registry {\n-    descriptions: HashMap<&'static str, &'static str>\n+    descriptions: HashMap<&'static str, &'static str>,\n }\n \n impl Registry {"}, {"sha": "abfb71c861b2542239200d916705b86b4f8aa4f7", "filename": "src/librustc_errors/snippet.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b2606173450b7842a59b23f8167eb6832d9c3305/src%2Flibrustc_errors%2Fsnippet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2606173450b7842a59b23f8167eb6832d9c3305/src%2Flibrustc_errors%2Fsnippet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fsnippet.rs?ref=b2606173450b7842a59b23f8167eb6832d9c3305", "patch": "@@ -13,12 +13,12 @@\n use syntax_pos::{Span, FileMap};\n use CodeMapper;\n use std::rc::Rc;\n-use {Level};\n+use Level;\n \n #[derive(Clone)]\n pub struct SnippetData {\n     codemap: Rc<CodeMapper>,\n-    files: Vec<FileInfo>\n+    files: Vec<FileInfo>,\n }\n \n #[derive(Clone)]\n@@ -84,4 +84,4 @@ pub enum Style {\n     NoStyle,\n     ErrorCode,\n     Level(Level),\n-}\n\\ No newline at end of file\n+}"}, {"sha": "dfc7c64de019746710c89c9bd1917eae22cd7c39", "filename": "src/librustc_errors/styled_buffer.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b2606173450b7842a59b23f8167eb6832d9c3305/src%2Flibrustc_errors%2Fstyled_buffer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2606173450b7842a59b23f8167eb6832d9c3305/src%2Flibrustc_errors%2Fstyled_buffer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fstyled_buffer.rs?ref=b2606173450b7842a59b23f8167eb6832d9c3305", "patch": "@@ -28,10 +28,9 @@ impl StyledBuffer {\n \n     pub fn copy_tabs(&mut self, row: usize) {\n         if row < self.text.len() {\n-            for i in row+1..self.text.len() {\n+            for i in row + 1..self.text.len() {\n                 for j in 0..self.text[i].len() {\n-                    if self.text[row].len() > j &&\n-                       self.text[row][j] == '\\t' &&\n+                    if self.text[row].len() > j && self.text[row][j] == '\\t' &&\n                        self.text[i][j] == ' ' {\n                         self.text[i][j] = '\\t';\n                     }\n@@ -44,7 +43,7 @@ impl StyledBuffer {\n         let mut output: Vec<Vec<StyledString>> = vec![];\n         let mut styled_vec: Vec<StyledString> = vec![];\n \n-        //before we render, do a little patch-up work to support tabs\n+        // before we render, do a little patch-up work to support tabs\n         self.copy_tabs(3);\n \n         for (row, row_style) in self.text.iter().zip(&self.styles) {"}]}