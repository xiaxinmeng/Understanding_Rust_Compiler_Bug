{"sha": "b825477154e32e8538e00e1e230dadf93bc7e6df", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI4MjU0NzcxNTRlMzJlODUzOGUwMGUxZTIzMGRhZGY5M2JjN2U2ZGY=", "commit": {"author": {"name": "Simon Sapin", "email": "simon.sapin@exyr.org", "date": "2018-05-21T08:45:11Z"}, "committer": {"name": "Simon Sapin", "email": "simon.sapin@exyr.org", "date": "2018-05-22T17:19:09Z"}, "message": "Remove the unstable Float trait\n\nFollowing up to #49896 and #50629. Fixes #32110.\n\nE0689 is weird.", "tree": {"sha": "27914379b78147f5b7ed856eaae44d1d0fd2ac98", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/27914379b78147f5b7ed856eaae44d1d0fd2ac98"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b825477154e32e8538e00e1e230dadf93bc7e6df", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b825477154e32e8538e00e1e230dadf93bc7e6df", "html_url": "https://github.com/rust-lang/rust/commit/b825477154e32e8538e00e1e230dadf93bc7e6df", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b825477154e32e8538e00e1e230dadf93bc7e6df/comments", "author": {"login": "SimonSapin", "id": 291359, "node_id": "MDQ6VXNlcjI5MTM1OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/291359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimonSapin", "html_url": "https://github.com/SimonSapin", "followers_url": "https://api.github.com/users/SimonSapin/followers", "following_url": "https://api.github.com/users/SimonSapin/following{/other_user}", "gists_url": "https://api.github.com/users/SimonSapin/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimonSapin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimonSapin/subscriptions", "organizations_url": "https://api.github.com/users/SimonSapin/orgs", "repos_url": "https://api.github.com/users/SimonSapin/repos", "events_url": "https://api.github.com/users/SimonSapin/events{/privacy}", "received_events_url": "https://api.github.com/users/SimonSapin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SimonSapin", "id": 291359, "node_id": "MDQ6VXNlcjI5MTM1OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/291359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimonSapin", "html_url": "https://github.com/SimonSapin", "followers_url": "https://api.github.com/users/SimonSapin/followers", "following_url": "https://api.github.com/users/SimonSapin/following{/other_user}", "gists_url": "https://api.github.com/users/SimonSapin/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimonSapin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimonSapin/subscriptions", "organizations_url": "https://api.github.com/users/SimonSapin/orgs", "repos_url": "https://api.github.com/users/SimonSapin/repos", "events_url": "https://api.github.com/users/SimonSapin/events{/privacy}", "received_events_url": "https://api.github.com/users/SimonSapin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ba1363ffe12ac1ac796a620aef2008e4ae6c0477", "url": "https://api.github.com/repos/rust-lang/rust/commits/ba1363ffe12ac1ac796a620aef2008e4ae6c0477", "html_url": "https://github.com/rust-lang/rust/commit/ba1363ffe12ac1ac796a620aef2008e4ae6c0477"}], "stats": {"total": 669, "additions": 232, "deletions": 437}, "files": [{"sha": "456d0e956d42aad36258acb069674438e5845f4e", "filename": "src/libcore/num/dec2flt/rawfp.rs", "status": "modified", "additions": 23, "deletions": 10, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/b825477154e32e8538e00e1e230dadf93bc7e6df/src%2Flibcore%2Fnum%2Fdec2flt%2Frawfp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b825477154e32e8538e00e1e230dadf93bc7e6df/src%2Flibcore%2Fnum%2Fdec2flt%2Frawfp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fdec2flt%2Frawfp.rs?ref=b825477154e32e8538e00e1e230dadf93bc7e6df", "patch": "@@ -33,7 +33,7 @@ use ops::{Add, Mul, Div, Neg};\n use fmt::{Debug, LowerExp};\n use num::diy_float::Fp;\n use num::FpCategory::{Infinite, Zero, Subnormal, Normal, Nan};\n-use num::Float;\n+use num::FpCategory;\n use num::dec2flt::num::{self, Big};\n use num::dec2flt::table;\n \n@@ -54,24 +54,29 @@ impl Unpacked {\n /// See the parent module's doc comment for why this is necessary.\n ///\n /// Should **never ever** be implemented for other types or be used outside the dec2flt module.\n-/// Inherits from `Float` because there is some overlap, but all the reused methods are trivial.\n pub trait RawFloat\n-    : Float\n-    + Copy\n+    : Copy\n     + Debug\n     + LowerExp\n     + Mul<Output=Self>\n     + Div<Output=Self>\n     + Neg<Output=Self>\n-where\n-    Self: Float<Bits = <Self as RawFloat>::RawBits>\n {\n     const INFINITY: Self;\n     const NAN: Self;\n     const ZERO: Self;\n \n-    /// Same as `Float::Bits` with extra traits.\n-    type RawBits: Add<Output = Self::RawBits> + From<u8> + TryFrom<u64>;\n+    /// Type used by `to_bits` and `from_bits`.\n+    type Bits: Add<Output = Self::Bits> + From<u8> + TryFrom<u64>;\n+\n+    /// Raw transmutation to integer.\n+    fn to_bits(self) -> Self::Bits;\n+\n+    /// Raw transmutation from integer.\n+    fn from_bits(v: Self::Bits) -> Self;\n+\n+    /// Returns the category that this number falls into.\n+    fn classify(self) -> FpCategory;\n \n     /// Returns the mantissa, exponent and sign as integers.\n     fn integer_decode(self) -> (u64, i16, i8);\n@@ -153,7 +158,7 @@ macro_rules! other_constants {\n }\n \n impl RawFloat for f32 {\n-    type RawBits = u32;\n+    type Bits = u32;\n \n     const SIG_BITS: u8 = 24;\n     const EXP_BITS: u8 = 8;\n@@ -192,11 +197,15 @@ impl RawFloat for f32 {\n     fn short_fast_pow10(e: usize) -> Self {\n         table::F32_SHORT_POWERS[e]\n     }\n+\n+    fn classify(self) -> FpCategory { self.classify() }\n+    fn to_bits(self) -> Self::Bits { self.to_bits() }\n+    fn from_bits(v: Self::Bits) -> Self { Self::from_bits(v) }\n }\n \n \n impl RawFloat for f64 {\n-    type RawBits = u64;\n+    type Bits = u64;\n \n     const SIG_BITS: u8 = 53;\n     const EXP_BITS: u8 = 11;\n@@ -235,6 +244,10 @@ impl RawFloat for f64 {\n     fn short_fast_pow10(e: usize) -> Self {\n         table::F64_SHORT_POWERS[e]\n     }\n+\n+    fn classify(self) -> FpCategory { self.classify() }\n+    fn to_bits(self) -> Self::Bits { self.to_bits() }\n+    fn from_bits(v: Self::Bits) -> Self { Self::from_bits(v) }\n }\n \n /// Convert an Fp to the closest machine float type."}, {"sha": "e5dbc65cd99bb9cc309b93904b7e51896d10ef57", "filename": "src/libcore/num/f32.rs", "status": "modified", "additions": 69, "deletions": 153, "changes": 222, "blob_url": "https://github.com/rust-lang/rust/blob/b825477154e32e8538e00e1e230dadf93bc7e6df/src%2Flibcore%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b825477154e32e8538e00e1e230dadf93bc7e6df/src%2Flibcore%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff32.rs?ref=b825477154e32e8538e00e1e230dadf93bc7e6df", "patch": "@@ -18,9 +18,7 @@\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use mem;\n-use num::Float;\n use num::FpCategory;\n-use num::FpCategory as Fp;\n \n /// The radix or base of the internal representation of `f32`.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -149,136 +147,9 @@ pub mod consts {\n     pub const LN_10: f32 = 2.30258509299404568401799145468436421_f32;\n }\n \n-#[unstable(feature = \"core_float\",\n-           reason = \"stable interface is via `impl f{32,64}` in later crates\",\n-           issue = \"32110\")]\n-impl Float for f32 {\n-    type Bits = u32;\n-\n-    /// Returns `true` if the number is NaN.\n-    #[inline]\n-    fn is_nan(self) -> bool {\n-        self != self\n-    }\n-\n-    /// Returns `true` if the number is infinite.\n-    #[inline]\n-    fn is_infinite(self) -> bool {\n-        self == INFINITY || self == NEG_INFINITY\n-    }\n-\n-    /// Returns `true` if the number is neither infinite or NaN.\n-    #[inline]\n-    fn is_finite(self) -> bool {\n-        !(self.is_nan() || self.is_infinite())\n-    }\n-\n-    /// Returns `true` if the number is neither zero, infinite, subnormal or NaN.\n-    #[inline]\n-    fn is_normal(self) -> bool {\n-        self.classify() == Fp::Normal\n-    }\n-\n-    /// Returns the floating point category of the number. If only one property\n-    /// is going to be tested, it is generally faster to use the specific\n-    /// predicate instead.\n-    fn classify(self) -> Fp {\n-        const EXP_MASK: u32 = 0x7f800000;\n-        const MAN_MASK: u32 = 0x007fffff;\n-\n-        let bits = self.to_bits();\n-        match (bits & MAN_MASK, bits & EXP_MASK) {\n-            (0, 0) => Fp::Zero,\n-            (_, 0) => Fp::Subnormal,\n-            (0, EXP_MASK) => Fp::Infinite,\n-            (_, EXP_MASK) => Fp::Nan,\n-            _ => Fp::Normal,\n-        }\n-    }\n-\n-    /// Returns `true` if and only if `self` has a positive sign, including `+0.0`, `NaN`s with\n-    /// positive sign bit and positive infinity.\n-    #[inline]\n-    fn is_sign_positive(self) -> bool {\n-        !self.is_sign_negative()\n-    }\n-\n-    /// Returns `true` if and only if `self` has a negative sign, including `-0.0`, `NaN`s with\n-    /// negative sign bit and negative infinity.\n-    #[inline]\n-    fn is_sign_negative(self) -> bool {\n-        // IEEE754 says: isSignMinus(x) is true if and only if x has negative sign. isSignMinus\n-        // applies to zeros and NaNs as well.\n-        self.to_bits() & 0x8000_0000 != 0\n-    }\n-\n-    /// Returns the reciprocal (multiplicative inverse) of the number.\n-    #[inline]\n-    fn recip(self) -> f32 {\n-        1.0 / self\n-    }\n-\n-    /// Converts to degrees, assuming the number is in radians.\n-    #[inline]\n-    fn to_degrees(self) -> f32 {\n-        // Use a constant for better precision.\n-        const PIS_IN_180: f32 = 57.2957795130823208767981548141051703_f32;\n-        self * PIS_IN_180\n-    }\n-\n-    /// Converts to radians, assuming the number is in degrees.\n-    #[inline]\n-    fn to_radians(self) -> f32 {\n-        let value: f32 = consts::PI;\n-        self * (value / 180.0f32)\n-    }\n-\n-    /// Returns the maximum of the two numbers.\n-    #[inline]\n-    fn max(self, other: f32) -> f32 {\n-        // IEEE754 says: maxNum(x, y) is the canonicalized number y if x < y, x if y < x, the\n-        // canonicalized number if one operand is a number and the other a quiet NaN. Otherwise it\n-        // is either x or y, canonicalized (this means results might differ among implementations).\n-        // When either x or y is a signalingNaN, then the result is according to 6.2.\n-        //\n-        // Since we do not support sNaN in Rust yet, we do not need to handle them.\n-        // FIXME(nagisa): due to https://bugs.llvm.org/show_bug.cgi?id=33303 we canonicalize by\n-        // multiplying by 1.0. Should switch to the `canonicalize` when it works.\n-        (if self.is_nan() || self < other { other } else { self }) * 1.0\n-    }\n-\n-    /// Returns the minimum of the two numbers.\n-    #[inline]\n-    fn min(self, other: f32) -> f32 {\n-        // IEEE754 says: minNum(x, y) is the canonicalized number x if x < y, y if y < x, the\n-        // canonicalized number if one operand is a number and the other a quiet NaN. Otherwise it\n-        // is either x or y, canonicalized (this means results might differ among implementations).\n-        // When either x or y is a signalingNaN, then the result is according to 6.2.\n-        //\n-        // Since we do not support sNaN in Rust yet, we do not need to handle them.\n-        // FIXME(nagisa): due to https://bugs.llvm.org/show_bug.cgi?id=33303 we canonicalize by\n-        // multiplying by 1.0. Should switch to the `canonicalize` when it works.\n-        (if other.is_nan() || self < other { self } else { other }) * 1.0\n-    }\n-\n-    /// Raw transmutation to `u32`.\n-    #[inline]\n-    fn to_bits(self) -> u32 {\n-        unsafe { mem::transmute(self) }\n-    }\n-\n-    /// Raw transmutation from `u32`.\n-    #[inline]\n-    fn from_bits(v: u32) -> Self {\n-        // It turns out the safety issues with sNaN were overblown! Hooray!\n-        unsafe { mem::transmute(v) }\n-    }\n-}\n-\n-// FIXME: remove (inline) this macro and the Float trait\n-// when updating to a bootstrap compiler that has the new lang items.\n-#[unstable(feature = \"core_float\", issue = \"32110\")]\n-macro_rules! f32_core_methods { () => {\n+#[lang = \"f32\"]\n+#[cfg(not(test))]\n+impl f32 {\n     /// Returns `true` if this value is `NaN` and false otherwise.\n     ///\n     /// ```\n@@ -292,7 +163,9 @@ macro_rules! f32_core_methods { () => {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn is_nan(self) -> bool { Float::is_nan(self) }\n+    pub fn is_nan(self) -> bool {\n+        self != self\n+    }\n \n     /// Returns `true` if this value is positive infinity or negative infinity and\n     /// false otherwise.\n@@ -313,7 +186,9 @@ macro_rules! f32_core_methods { () => {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn is_infinite(self) -> bool { Float::is_infinite(self) }\n+    pub fn is_infinite(self) -> bool {\n+        self == INFINITY || self == NEG_INFINITY\n+    }\n \n     /// Returns `true` if this number is neither infinite nor `NaN`.\n     ///\n@@ -333,7 +208,9 @@ macro_rules! f32_core_methods { () => {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn is_finite(self) -> bool { Float::is_finite(self) }\n+    pub fn is_finite(self) -> bool {\n+        !(self.is_nan() || self.is_infinite())\n+    }\n \n     /// Returns `true` if the number is neither zero, infinite,\n     /// [subnormal][subnormal], or `NaN`.\n@@ -358,7 +235,9 @@ macro_rules! f32_core_methods { () => {\n     /// [subnormal]: https://en.wikipedia.org/wiki/Denormal_number\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn is_normal(self) -> bool { Float::is_normal(self) }\n+    pub fn is_normal(self) -> bool {\n+        self.classify() == FpCategory::Normal\n+    }\n \n     /// Returns the floating point category of the number. If only one property\n     /// is going to be tested, it is generally faster to use the specific\n@@ -375,8 +254,19 @@ macro_rules! f32_core_methods { () => {\n     /// assert_eq!(inf.classify(), FpCategory::Infinite);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn classify(self) -> FpCategory { Float::classify(self) }\n+    pub fn classify(self) -> FpCategory {\n+        const EXP_MASK: u32 = 0x7f800000;\n+        const MAN_MASK: u32 = 0x007fffff;\n+\n+        let bits = self.to_bits();\n+        match (bits & MAN_MASK, bits & EXP_MASK) {\n+            (0, 0) => FpCategory::Zero,\n+            (_, 0) => FpCategory::Subnormal,\n+            (0, EXP_MASK) => FpCategory::Infinite,\n+            (_, EXP_MASK) => FpCategory::Nan,\n+            _ => FpCategory::Normal,\n+        }\n+    }\n \n     /// Returns `true` if and only if `self` has a positive sign, including `+0.0`, `NaN`s with\n     /// positive sign bit and positive infinity.\n@@ -390,7 +280,9 @@ macro_rules! f32_core_methods { () => {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn is_sign_positive(self) -> bool { Float::is_sign_positive(self) }\n+    pub fn is_sign_positive(self) -> bool {\n+        !self.is_sign_negative()\n+    }\n \n     /// Returns `true` if and only if `self` has a negative sign, including `-0.0`, `NaN`s with\n     /// negative sign bit and negative infinity.\n@@ -404,7 +296,11 @@ macro_rules! f32_core_methods { () => {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn is_sign_negative(self) -> bool { Float::is_sign_negative(self) }\n+    pub fn is_sign_negative(self) -> bool {\n+        // IEEE754 says: isSignMinus(x) is true if and only if x has negative sign. isSignMinus\n+        // applies to zeros and NaNs as well.\n+        self.to_bits() & 0x8000_0000 != 0\n+    }\n \n     /// Takes the reciprocal (inverse) of a number, `1/x`.\n     ///\n@@ -418,7 +314,9 @@ macro_rules! f32_core_methods { () => {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn recip(self) -> f32 { Float::recip(self) }\n+    pub fn recip(self) -> f32 {\n+        1.0 / self\n+    }\n \n     /// Converts radians to degrees.\n     ///\n@@ -433,7 +331,11 @@ macro_rules! f32_core_methods { () => {\n     /// ```\n     #[stable(feature = \"f32_deg_rad_conversions\", since=\"1.7.0\")]\n     #[inline]\n-    pub fn to_degrees(self) -> f32 { Float::to_degrees(self) }\n+    pub fn to_degrees(self) -> f32 {\n+        // Use a constant for better precision.\n+        const PIS_IN_180: f32 = 57.2957795130823208767981548141051703_f32;\n+        self * PIS_IN_180\n+    }\n \n     /// Converts degrees to radians.\n     ///\n@@ -448,7 +350,10 @@ macro_rules! f32_core_methods { () => {\n     /// ```\n     #[stable(feature = \"f32_deg_rad_conversions\", since=\"1.7.0\")]\n     #[inline]\n-    pub fn to_radians(self) -> f32 { Float::to_radians(self) }\n+    pub fn to_radians(self) -> f32 {\n+        let value: f32 = consts::PI;\n+        self * (value / 180.0f32)\n+    }\n \n     /// Returns the maximum of the two numbers.\n     ///\n@@ -463,7 +368,15 @@ macro_rules! f32_core_methods { () => {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn max(self, other: f32) -> f32 {\n-        Float::max(self, other)\n+        // IEEE754 says: maxNum(x, y) is the canonicalized number y if x < y, x if y < x, the\n+        // canonicalized number if one operand is a number and the other a quiet NaN. Otherwise it\n+        // is either x or y, canonicalized (this means results might differ among implementations).\n+        // When either x or y is a signalingNaN, then the result is according to 6.2.\n+        //\n+        // Since we do not support sNaN in Rust yet, we do not need to handle them.\n+        // FIXME(nagisa): due to https://bugs.llvm.org/show_bug.cgi?id=33303 we canonicalize by\n+        // multiplying by 1.0. Should switch to the `canonicalize` when it works.\n+        (if self.is_nan() || self < other { other } else { self }) * 1.0\n     }\n \n     /// Returns the minimum of the two numbers.\n@@ -479,7 +392,15 @@ macro_rules! f32_core_methods { () => {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn min(self, other: f32) -> f32 {\n-        Float::min(self, other)\n+        // IEEE754 says: minNum(x, y) is the canonicalized number x if x < y, y if y < x, the\n+        // canonicalized number if one operand is a number and the other a quiet NaN. Otherwise it\n+        // is either x or y, canonicalized (this means results might differ among implementations).\n+        // When either x or y is a signalingNaN, then the result is according to 6.2.\n+        //\n+        // Since we do not support sNaN in Rust yet, we do not need to handle them.\n+        // FIXME(nagisa): due to https://bugs.llvm.org/show_bug.cgi?id=33303 we canonicalize by\n+        // multiplying by 1.0. Should switch to the `canonicalize` when it works.\n+        (if other.is_nan() || self < other { self } else { other }) * 1.0\n     }\n \n     /// Raw transmutation to `u32`.\n@@ -502,7 +423,7 @@ macro_rules! f32_core_methods { () => {\n     #[stable(feature = \"float_bits_conv\", since = \"1.20.0\")]\n     #[inline]\n     pub fn to_bits(self) -> u32 {\n-        Float::to_bits(self)\n+        unsafe { mem::transmute(self) }\n     }\n \n     /// Raw transmutation from `u32`.\n@@ -546,12 +467,7 @@ macro_rules! f32_core_methods { () => {\n     #[stable(feature = \"float_bits_conv\", since = \"1.20.0\")]\n     #[inline]\n     pub fn from_bits(v: u32) -> Self {\n-        Float::from_bits(v)\n+        // It turns out the safety issues with sNaN were overblown! Hooray!\n+        unsafe { mem::transmute(v) }\n     }\n-}}\n-\n-#[lang = \"f32\"]\n-#[cfg(not(test))]\n-impl f32 {\n-    f32_core_methods!();\n }"}, {"sha": "eb769c4ad5a3b38f92ac174b7e066720df0a7125", "filename": "src/libcore/num/f64.rs", "status": "modified", "additions": 74, "deletions": 154, "changes": 228, "blob_url": "https://github.com/rust-lang/rust/blob/b825477154e32e8538e00e1e230dadf93bc7e6df/src%2Flibcore%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b825477154e32e8538e00e1e230dadf93bc7e6df/src%2Flibcore%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff64.rs?ref=b825477154e32e8538e00e1e230dadf93bc7e6df", "patch": "@@ -18,9 +18,7 @@\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use mem;\n-use num::Float;\n use num::FpCategory;\n-use num::FpCategory as Fp;\n \n /// The radix or base of the internal representation of `f64`.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -149,135 +147,9 @@ pub mod consts {\n     pub const LN_10: f64 = 2.30258509299404568401799145468436421_f64;\n }\n \n-#[unstable(feature = \"core_float\",\n-           reason = \"stable interface is via `impl f{32,64}` in later crates\",\n-           issue = \"32110\")]\n-impl Float for f64 {\n-    type Bits = u64;\n-\n-    /// Returns `true` if the number is NaN.\n-    #[inline]\n-    fn is_nan(self) -> bool {\n-        self != self\n-    }\n-\n-    /// Returns `true` if the number is infinite.\n-    #[inline]\n-    fn is_infinite(self) -> bool {\n-        self == INFINITY || self == NEG_INFINITY\n-    }\n-\n-    /// Returns `true` if the number is neither infinite or NaN.\n-    #[inline]\n-    fn is_finite(self) -> bool {\n-        !(self.is_nan() || self.is_infinite())\n-    }\n-\n-    /// Returns `true` if the number is neither zero, infinite, subnormal or NaN.\n-    #[inline]\n-    fn is_normal(self) -> bool {\n-        self.classify() == Fp::Normal\n-    }\n-\n-    /// Returns the floating point category of the number. If only one property\n-    /// is going to be tested, it is generally faster to use the specific\n-    /// predicate instead.\n-    fn classify(self) -> Fp {\n-        const EXP_MASK: u64 = 0x7ff0000000000000;\n-        const MAN_MASK: u64 = 0x000fffffffffffff;\n-\n-        let bits = self.to_bits();\n-        match (bits & MAN_MASK, bits & EXP_MASK) {\n-            (0, 0) => Fp::Zero,\n-            (_, 0) => Fp::Subnormal,\n-            (0, EXP_MASK) => Fp::Infinite,\n-            (_, EXP_MASK) => Fp::Nan,\n-            _ => Fp::Normal,\n-        }\n-    }\n-\n-    /// Returns `true` if and only if `self` has a positive sign, including `+0.0`, `NaN`s with\n-    /// positive sign bit and positive infinity.\n-    #[inline]\n-    fn is_sign_positive(self) -> bool {\n-        !self.is_sign_negative()\n-    }\n-\n-    /// Returns `true` if and only if `self` has a negative sign, including `-0.0`, `NaN`s with\n-    /// negative sign bit and negative infinity.\n-    #[inline]\n-    fn is_sign_negative(self) -> bool {\n-        self.to_bits() & 0x8000_0000_0000_0000 != 0\n-    }\n-\n-    /// Returns the reciprocal (multiplicative inverse) of the number.\n-    #[inline]\n-    fn recip(self) -> f64 {\n-        1.0 / self\n-    }\n-\n-    /// Converts to degrees, assuming the number is in radians.\n-    #[inline]\n-    fn to_degrees(self) -> f64 {\n-        // The division here is correctly rounded with respect to the true\n-        // value of 180/\u03c0. (This differs from f32, where a constant must be\n-        // used to ensure a correctly rounded result.)\n-        self * (180.0f64 / consts::PI)\n-    }\n-\n-    /// Converts to radians, assuming the number is in degrees.\n-    #[inline]\n-    fn to_radians(self) -> f64 {\n-        let value: f64 = consts::PI;\n-        self * (value / 180.0)\n-    }\n-\n-    /// Returns the maximum of the two numbers.\n-    #[inline]\n-    fn max(self, other: f64) -> f64 {\n-        // IEEE754 says: maxNum(x, y) is the canonicalized number y if x < y, x if y < x, the\n-        // canonicalized number if one operand is a number and the other a quiet NaN. Otherwise it\n-        // is either x or y, canonicalized (this means results might differ among implementations).\n-        // When either x or y is a signalingNaN, then the result is according to 6.2.\n-        //\n-        // Since we do not support sNaN in Rust yet, we do not need to handle them.\n-        // FIXME(nagisa): due to https://bugs.llvm.org/show_bug.cgi?id=33303 we canonicalize by\n-        // multiplying by 1.0. Should switch to the `canonicalize` when it works.\n-        (if self.is_nan() || self < other { other } else { self }) * 1.0\n-    }\n-\n-    /// Returns the minimum of the two numbers.\n-    #[inline]\n-    fn min(self, other: f64) -> f64 {\n-        // IEEE754 says: minNum(x, y) is the canonicalized number x if x < y, y if y < x, the\n-        // canonicalized number if one operand is a number and the other a quiet NaN. Otherwise it\n-        // is either x or y, canonicalized (this means results might differ among implementations).\n-        // When either x or y is a signalingNaN, then the result is according to 6.2.\n-        //\n-        // Since we do not support sNaN in Rust yet, we do not need to handle them.\n-        // FIXME(nagisa): due to https://bugs.llvm.org/show_bug.cgi?id=33303 we canonicalize by\n-        // multiplying by 1.0. Should switch to the `canonicalize` when it works.\n-        (if other.is_nan() || self < other { self } else { other }) * 1.0\n-    }\n-\n-    /// Raw transmutation to `u64`.\n-    #[inline]\n-    fn to_bits(self) -> u64 {\n-        unsafe { mem::transmute(self) }\n-    }\n-\n-    /// Raw transmutation from `u64`.\n-    #[inline]\n-    fn from_bits(v: u64) -> Self {\n-        // It turns out the safety issues with sNaN were overblown! Hooray!\n-        unsafe { mem::transmute(v) }\n-    }\n-}\n-\n-// FIXME: remove (inline) this macro and the Float trait\n-// when updating to a bootstrap compiler that has the new lang items.\n-#[unstable(feature = \"core_float\", issue = \"32110\")]\n-macro_rules! f64_core_methods { () => {\n+#[lang = \"f64\"]\n+#[cfg(not(test))]\n+impl f64 {\n     /// Returns `true` if this value is `NaN` and false otherwise.\n     ///\n     /// ```\n@@ -291,7 +163,9 @@ macro_rules! f64_core_methods { () => {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn is_nan(self) -> bool { Float::is_nan(self) }\n+    pub fn is_nan(self) -> bool {\n+        self != self\n+    }\n \n     /// Returns `true` if this value is positive infinity or negative infinity and\n     /// false otherwise.\n@@ -312,7 +186,9 @@ macro_rules! f64_core_methods { () => {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn is_infinite(self) -> bool { Float::is_infinite(self) }\n+    pub fn is_infinite(self) -> bool {\n+        self == INFINITY || self == NEG_INFINITY\n+    }\n \n     /// Returns `true` if this number is neither infinite nor `NaN`.\n     ///\n@@ -332,7 +208,9 @@ macro_rules! f64_core_methods { () => {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn is_finite(self) -> bool { Float::is_finite(self) }\n+    pub fn is_finite(self) -> bool {\n+        !(self.is_nan() || self.is_infinite())\n+    }\n \n     /// Returns `true` if the number is neither zero, infinite,\n     /// [subnormal][subnormal], or `NaN`.\n@@ -357,7 +235,9 @@ macro_rules! f64_core_methods { () => {\n     /// [subnormal]: https://en.wikipedia.org/wiki/Denormal_number\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn is_normal(self) -> bool { Float::is_normal(self) }\n+    pub fn is_normal(self) -> bool {\n+        self.classify() == FpCategory::Normal\n+    }\n \n     /// Returns the floating point category of the number. If only one property\n     /// is going to be tested, it is generally faster to use the specific\n@@ -374,8 +254,19 @@ macro_rules! f64_core_methods { () => {\n     /// assert_eq!(inf.classify(), FpCategory::Infinite);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn classify(self) -> FpCategory { Float::classify(self) }\n+    pub fn classify(self) -> FpCategory {\n+        const EXP_MASK: u64 = 0x7ff0000000000000;\n+        const MAN_MASK: u64 = 0x000fffffffffffff;\n+\n+        let bits = self.to_bits();\n+        match (bits & MAN_MASK, bits & EXP_MASK) {\n+            (0, 0) => FpCategory::Zero,\n+            (_, 0) => FpCategory::Subnormal,\n+            (0, EXP_MASK) => FpCategory::Infinite,\n+            (_, EXP_MASK) => FpCategory::Nan,\n+            _ => FpCategory::Normal,\n+        }\n+    }\n \n     /// Returns `true` if and only if `self` has a positive sign, including `+0.0`, `NaN`s with\n     /// positive sign bit and positive infinity.\n@@ -389,13 +280,17 @@ macro_rules! f64_core_methods { () => {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn is_sign_positive(self) -> bool { Float::is_sign_positive(self) }\n+    pub fn is_sign_positive(self) -> bool {\n+        !self.is_sign_negative()\n+    }\n \n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[rustc_deprecated(since = \"1.0.0\", reason = \"renamed to is_sign_positive\")]\n     #[inline]\n     #[doc(hidden)]\n-    pub fn is_positive(self) -> bool { Float::is_sign_positive(self) }\n+    pub fn is_positive(self) -> bool {\n+        self.is_sign_positive()\n+    }\n \n     /// Returns `true` if and only if `self` has a negative sign, including `-0.0`, `NaN`s with\n     /// negative sign bit and negative infinity.\n@@ -409,13 +304,17 @@ macro_rules! f64_core_methods { () => {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn is_sign_negative(self) -> bool { Float::is_sign_negative(self) }\n+    pub fn is_sign_negative(self) -> bool {\n+        self.to_bits() & 0x8000_0000_0000_0000 != 0\n+    }\n \n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[rustc_deprecated(since = \"1.0.0\", reason = \"renamed to is_sign_negative\")]\n     #[inline]\n     #[doc(hidden)]\n-    pub fn is_negative(self) -> bool { Float::is_sign_negative(self) }\n+    pub fn is_negative(self) -> bool {\n+        self.is_sign_negative()\n+    }\n \n     /// Takes the reciprocal (inverse) of a number, `1/x`.\n     ///\n@@ -427,7 +326,9 @@ macro_rules! f64_core_methods { () => {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn recip(self) -> f64 { Float::recip(self) }\n+    pub fn recip(self) -> f64 {\n+        1.0 / self\n+    }\n \n     /// Converts radians to degrees.\n     ///\n@@ -442,7 +343,12 @@ macro_rules! f64_core_methods { () => {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn to_degrees(self) -> f64 { Float::to_degrees(self) }\n+    pub fn to_degrees(self) -> f64 {\n+        // The division here is correctly rounded with respect to the true\n+        // value of 180/\u03c0. (This differs from f32, where a constant must be\n+        // used to ensure a correctly rounded result.)\n+        self * (180.0f64 / consts::PI)\n+    }\n \n     /// Converts degrees to radians.\n     ///\n@@ -457,7 +363,10 @@ macro_rules! f64_core_methods { () => {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn to_radians(self) -> f64 { Float::to_radians(self) }\n+    pub fn to_radians(self) -> f64 {\n+        let value: f64 = consts::PI;\n+        self * (value / 180.0)\n+    }\n \n     /// Returns the maximum of the two numbers.\n     ///\n@@ -472,7 +381,15 @@ macro_rules! f64_core_methods { () => {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn max(self, other: f64) -> f64 {\n-        Float::max(self, other)\n+        // IEEE754 says: maxNum(x, y) is the canonicalized number y if x < y, x if y < x, the\n+        // canonicalized number if one operand is a number and the other a quiet NaN. Otherwise it\n+        // is either x or y, canonicalized (this means results might differ among implementations).\n+        // When either x or y is a signalingNaN, then the result is according to 6.2.\n+        //\n+        // Since we do not support sNaN in Rust yet, we do not need to handle them.\n+        // FIXME(nagisa): due to https://bugs.llvm.org/show_bug.cgi?id=33303 we canonicalize by\n+        // multiplying by 1.0. Should switch to the `canonicalize` when it works.\n+        (if self.is_nan() || self < other { other } else { self }) * 1.0\n     }\n \n     /// Returns the minimum of the two numbers.\n@@ -488,7 +405,15 @@ macro_rules! f64_core_methods { () => {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn min(self, other: f64) -> f64 {\n-        Float::min(self, other)\n+        // IEEE754 says: minNum(x, y) is the canonicalized number x if x < y, y if y < x, the\n+        // canonicalized number if one operand is a number and the other a quiet NaN. Otherwise it\n+        // is either x or y, canonicalized (this means results might differ among implementations).\n+        // When either x or y is a signalingNaN, then the result is according to 6.2.\n+        //\n+        // Since we do not support sNaN in Rust yet, we do not need to handle them.\n+        // FIXME(nagisa): due to https://bugs.llvm.org/show_bug.cgi?id=33303 we canonicalize by\n+        // multiplying by 1.0. Should switch to the `canonicalize` when it works.\n+        (if other.is_nan() || self < other { self } else { other }) * 1.0\n     }\n \n     /// Raw transmutation to `u64`.\n@@ -511,7 +436,7 @@ macro_rules! f64_core_methods { () => {\n     #[stable(feature = \"float_bits_conv\", since = \"1.20.0\")]\n     #[inline]\n     pub fn to_bits(self) -> u64 {\n-        Float::to_bits(self)\n+        unsafe { mem::transmute(self) }\n     }\n \n     /// Raw transmutation from `u64`.\n@@ -555,12 +480,7 @@ macro_rules! f64_core_methods { () => {\n     #[stable(feature = \"float_bits_conv\", since = \"1.20.0\")]\n     #[inline]\n     pub fn from_bits(v: u64) -> Self {\n-        Float::from_bits(v)\n+        // It turns out the safety issues with sNaN were overblown! Hooray!\n+        unsafe { mem::transmute(v) }\n     }\n-}}\n-\n-#[lang = \"f64\"]\n-#[cfg(not(test))]\n-impl f64 {\n-    f64_core_methods!();\n }"}, {"sha": "232ecb8fbae18f3f9cea6f021af8c4778473fc78", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 0, "deletions": 55, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/b825477154e32e8538e00e1e230dadf93bc7e6df/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b825477154e32e8538e00e1e230dadf93bc7e6df/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=b825477154e32e8538e00e1e230dadf93bc7e6df", "patch": "@@ -4080,61 +4080,6 @@ pub enum FpCategory {\n     Normal,\n }\n \n-// Technically private and only exposed for coretests:\n-#[doc(hidden)]\n-#[unstable(feature = \"float_internals\",\n-           reason = \"internal routines only exposed for testing\",\n-           issue = \"0\")]\n-pub trait Float: Sized {\n-    /// Type used by `to_bits` and `from_bits`.\n-    type Bits;\n-\n-    /// Returns `true` if this value is NaN and false otherwise.\n-    fn is_nan(self) -> bool;\n-\n-    /// Returns `true` if this value is positive infinity or negative infinity and\n-    /// false otherwise.\n-    fn is_infinite(self) -> bool;\n-\n-    /// Returns `true` if this number is neither infinite nor NaN.\n-    fn is_finite(self) -> bool;\n-\n-    /// Returns `true` if this number is neither zero, infinite, denormal, or NaN.\n-    fn is_normal(self) -> bool;\n-\n-    /// Returns the category that this number falls into.\n-    fn classify(self) -> FpCategory;\n-\n-    /// Returns `true` if `self` is positive, including `+0.0` and\n-    /// `Float::infinity()`.\n-    fn is_sign_positive(self) -> bool;\n-\n-    /// Returns `true` if `self` is negative, including `-0.0` and\n-    /// `Float::neg_infinity()`.\n-    fn is_sign_negative(self) -> bool;\n-\n-    /// Take the reciprocal (inverse) of a number, `1/x`.\n-    fn recip(self) -> Self;\n-\n-    /// Convert radians to degrees.\n-    fn to_degrees(self) -> Self;\n-\n-    /// Convert degrees to radians.\n-    fn to_radians(self) -> Self;\n-\n-    /// Returns the maximum of the two numbers.\n-    fn max(self, other: Self) -> Self;\n-\n-    /// Returns the minimum of the two numbers.\n-    fn min(self, other: Self) -> Self;\n-\n-    /// Raw transmutation to integer.\n-    fn to_bits(self) -> Self::Bits;\n-\n-    /// Raw transmutation from integer.\n-    fn from_bits(v: Self::Bits) -> Self;\n-}\n-\n macro_rules! from_str_radix_int_impl {\n     ($($t:ty)*) => {$(\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "f3439890fce50cef6fe2489e71e83eb1cb58c9bb", "filename": "src/libcore/tests/num/mod.rs", "status": "modified", "additions": 38, "deletions": 39, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/b825477154e32e8538e00e1e230dadf93bc7e6df/src%2Flibcore%2Ftests%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b825477154e32e8538e00e1e230dadf93bc7e6df/src%2Flibcore%2Ftests%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnum%2Fmod.rs?ref=b825477154e32e8538e00e1e230dadf93bc7e6df", "patch": "@@ -508,51 +508,50 @@ assume_usize_width! {\n \n macro_rules! test_float {\n     ($modname: ident, $fty: ty, $inf: expr, $neginf: expr, $nan: expr) => { mod $modname {\n-        use core::num::Float;\n         // FIXME(nagisa): these tests should test for sign of -0.0\n         #[test]\n         fn min() {\n-            assert_eq!(0.0.min(0.0), 0.0);\n-            assert_eq!((-0.0).min(-0.0), -0.0);\n-            assert_eq!(9.0.min(9.0), 9.0);\n-            assert_eq!((-9.0).min(0.0), -9.0);\n-            assert_eq!(0.0.min(9.0), 0.0);\n-            assert_eq!((-0.0).min(-9.0), -9.0);\n-            assert_eq!($inf.min(9.0), 9.0);\n-            assert_eq!(9.0.min($inf), 9.0);\n-            assert_eq!($inf.min(-9.0), -9.0);\n-            assert_eq!((-9.0).min($inf), -9.0);\n-            assert_eq!($neginf.min(9.0), $neginf);\n-            assert_eq!(9.0.min($neginf), $neginf);\n-            assert_eq!($neginf.min(-9.0), $neginf);\n-            assert_eq!((-9.0).min($neginf), $neginf);\n-            assert_eq!($nan.min(9.0), 9.0);\n-            assert_eq!($nan.min(-9.0), -9.0);\n-            assert_eq!(9.0.min($nan), 9.0);\n-            assert_eq!((-9.0).min($nan), -9.0);\n-            assert!($nan.min($nan).is_nan());\n+            assert_eq!((0.0 as $fty).min(0.0), 0.0);\n+            assert_eq!((-0.0 as $fty).min(-0.0), -0.0);\n+            assert_eq!((9.0 as $fty).min(9.0), 9.0);\n+            assert_eq!((-9.0 as $fty).min(0.0), -9.0);\n+            assert_eq!((0.0 as $fty).min(9.0), 0.0);\n+            assert_eq!((-0.0 as $fty).min(-9.0), -9.0);\n+            assert_eq!(($inf as $fty).min(9.0), 9.0);\n+            assert_eq!((9.0 as $fty).min($inf), 9.0);\n+            assert_eq!(($inf as $fty).min(-9.0), -9.0);\n+            assert_eq!((-9.0 as $fty).min($inf), -9.0);\n+            assert_eq!(($neginf as $fty).min(9.0), $neginf);\n+            assert_eq!((9.0 as $fty).min($neginf), $neginf);\n+            assert_eq!(($neginf as $fty).min(-9.0), $neginf);\n+            assert_eq!((-9.0 as $fty).min($neginf), $neginf);\n+            assert_eq!(($nan as $fty).min(9.0), 9.0);\n+            assert_eq!(($nan as $fty).min(-9.0), -9.0);\n+            assert_eq!((9.0 as $fty).min($nan), 9.0);\n+            assert_eq!((-9.0 as $fty).min($nan), -9.0);\n+            assert!(($nan as $fty).min($nan).is_nan());\n         }\n         #[test]\n         fn max() {\n-            assert_eq!(0.0.max(0.0), 0.0);\n-            assert_eq!((-0.0).max(-0.0), -0.0);\n-            assert_eq!(9.0.max(9.0), 9.0);\n-            assert_eq!((-9.0).max(0.0), 0.0);\n-            assert_eq!(0.0.max(9.0), 9.0);\n-            assert_eq!((-0.0).max(-9.0), -0.0);\n-            assert_eq!($inf.max(9.0), $inf);\n-            assert_eq!(9.0.max($inf), $inf);\n-            assert_eq!($inf.max(-9.0), $inf);\n-            assert_eq!((-9.0).max($inf), $inf);\n-            assert_eq!($neginf.max(9.0), 9.0);\n-            assert_eq!(9.0.max($neginf), 9.0);\n-            assert_eq!($neginf.max(-9.0), -9.0);\n-            assert_eq!((-9.0).max($neginf), -9.0);\n-            assert_eq!($nan.max(9.0), 9.0);\n-            assert_eq!($nan.max(-9.0), -9.0);\n-            assert_eq!(9.0.max($nan), 9.0);\n-            assert_eq!((-9.0).max($nan), -9.0);\n-            assert!($nan.max($nan).is_nan());\n+            assert_eq!((0.0 as $fty).max(0.0), 0.0);\n+            assert_eq!((-0.0 as $fty).max(-0.0), -0.0);\n+            assert_eq!((9.0 as $fty).max(9.0), 9.0);\n+            assert_eq!((-9.0 as $fty).max(0.0), 0.0);\n+            assert_eq!((0.0 as $fty).max(9.0), 9.0);\n+            assert_eq!((-0.0 as $fty).max(-9.0), -0.0);\n+            assert_eq!(($inf as $fty).max(9.0), $inf);\n+            assert_eq!((9.0 as $fty).max($inf), $inf);\n+            assert_eq!(($inf as $fty).max(-9.0), $inf);\n+            assert_eq!((-9.0 as $fty).max($inf), $inf);\n+            assert_eq!(($neginf as $fty).max(9.0), 9.0);\n+            assert_eq!((9.0 as $fty).max($neginf), 9.0);\n+            assert_eq!(($neginf as $fty).max(-9.0), -9.0);\n+            assert_eq!((-9.0 as $fty).max($neginf), -9.0);\n+            assert_eq!(($nan as $fty).max(9.0), 9.0);\n+            assert_eq!(($nan as $fty).max(-9.0), -9.0);\n+            assert_eq!((9.0 as $fty).max($nan), 9.0);\n+            assert_eq!((-9.0 as $fty).max($nan), -9.0);\n+            assert!(($nan as $fty).max($nan).is_nan());\n         }\n     } }\n }"}, {"sha": "e6a66cd613e9c112dc81ae5e3a1a22261671a4bd", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b825477154e32e8538e00e1e230dadf93bc7e6df/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b825477154e32e8538e00e1e230dadf93bc7e6df/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=b825477154e32e8538e00e1e230dadf93bc7e6df", "patch": "@@ -4552,23 +4552,25 @@ but the type of the numeric value or binding could not be identified.\n The error happens on numeric literals:\n \n ```compile_fail,E0689\n-2.0.recip();\n+2.0.neg();\n ```\n \n and on numeric bindings without an identified concrete type:\n \n ```compile_fail,E0689\n let x = 2.0;\n-x.recip();  // same error as above\n+x.neg();  // same error as above\n ```\n \n Because of this, you must give the numeric literal or binding a type:\n \n ```\n-let _ = 2.0_f32.recip();\n+use std::ops::Neg;\n+\n+let _ = 2.0_f32.neg();\n let x: f32 = 2.0;\n-let _ = x.recip();\n-let _ = (2.0 as f32).recip();\n+let _ = x.neg();\n+let _ = (2.0 as f32).neg();\n ```\n \"##,\n "}, {"sha": "0bc2dd5a601bd3558d2ef92b40f5f382eea683b3", "filename": "src/test/ui/macros/macro-backtrace-invalid-internals.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b825477154e32e8538e00e1e230dadf93bc7e6df/src%2Ftest%2Fui%2Fmacros%2Fmacro-backtrace-invalid-internals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b825477154e32e8538e00e1e230dadf93bc7e6df/src%2Ftest%2Fui%2Fmacros%2Fmacro-backtrace-invalid-internals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacro-backtrace-invalid-internals.rs?ref=b825477154e32e8538e00e1e230dadf93bc7e6df", "patch": "@@ -48,13 +48,13 @@ macro_rules! fake_anon_field_expr {\n \n macro_rules! real_method_stmt {\n      () => {\n-          2.0.recip() //~ ERROR can't call method `recip` on ambiguous numeric type `{float}`\n+          2.0.neg() //~ ERROR can't call method `neg` on ambiguous numeric type `{float}`\n      }\n }\n \n macro_rules! real_method_expr {\n      () => {\n-          2.0.recip() //~ ERROR can't call method `recip` on ambiguous numeric type `{float}`\n+          2.0.neg() //~ ERROR can't call method `neg` on ambiguous numeric type `{float}`\n      }\n }\n "}, {"sha": "ec8eee65739898690b5c5d9cfae02de5b7fb890a", "filename": "src/test/ui/macros/macro-backtrace-invalid-internals.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b825477154e32e8538e00e1e230dadf93bc7e6df/src%2Ftest%2Fui%2Fmacros%2Fmacro-backtrace-invalid-internals.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b825477154e32e8538e00e1e230dadf93bc7e6df/src%2Ftest%2Fui%2Fmacros%2Fmacro-backtrace-invalid-internals.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacro-backtrace-invalid-internals.stderr?ref=b825477154e32e8538e00e1e230dadf93bc7e6df", "patch": "@@ -25,17 +25,17 @@ LL |           (1).0 //~ ERROR doesn't have fields\n LL |     fake_anon_field_stmt!();\n    |     ------------------------ in this macro invocation\n \n-error[E0689]: can't call method `recip` on ambiguous numeric type `{float}`\n+error[E0689]: can't call method `neg` on ambiguous numeric type `{float}`\n   --> $DIR/macro-backtrace-invalid-internals.rs:51:15\n    |\n-LL |           2.0.recip() //~ ERROR can't call method `recip` on ambiguous numeric type `{float}`\n-   |               ^^^^^\n+LL |           2.0.neg() //~ ERROR can't call method `neg` on ambiguous numeric type `{float}`\n+   |               ^^^\n ...\n LL |     real_method_stmt!();\n    |     -------------------- in this macro invocation\n help: you must specify a concrete type for this numeric value, like `f32`\n    |\n-LL |           2.0_f32.recip() //~ ERROR can't call method `recip` on ambiguous numeric type `{float}`\n+LL |           2.0_f32.neg() //~ ERROR can't call method `neg` on ambiguous numeric type `{float}`\n    |           ^^^^^^^\n \n error[E0599]: no method named `fake` found for type `{integer}` in the current scope\n@@ -65,17 +65,17 @@ LL |           (1).0 //~ ERROR doesn't have fields\n LL |     let _ = fake_anon_field_expr!();\n    |             ----------------------- in this macro invocation\n \n-error[E0689]: can't call method `recip` on ambiguous numeric type `{float}`\n+error[E0689]: can't call method `neg` on ambiguous numeric type `{float}`\n   --> $DIR/macro-backtrace-invalid-internals.rs:57:15\n    |\n-LL |           2.0.recip() //~ ERROR can't call method `recip` on ambiguous numeric type `{float}`\n-   |               ^^^^^\n+LL |           2.0.neg() //~ ERROR can't call method `neg` on ambiguous numeric type `{float}`\n+   |               ^^^\n ...\n LL |     let _ = real_method_expr!();\n    |             ------------------- in this macro invocation\n help: you must specify a concrete type for this numeric value, like `f32`\n    |\n-LL |           2.0_f32.recip() //~ ERROR can't call method `recip` on ambiguous numeric type `{float}`\n+LL |           2.0_f32.neg() //~ ERROR can't call method `neg` on ambiguous numeric type `{float}`\n    |           ^^^^^^^\n \n error: aborting due to 8 previous errors"}, {"sha": "9bf74c3875fed5f379d35372a1baea0db62d2ec2", "filename": "src/test/ui/suggestions/method-on-ambiguous-numeric-type.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b825477154e32e8538e00e1e230dadf93bc7e6df/src%2Ftest%2Fui%2Fsuggestions%2Fmethod-on-ambiguous-numeric-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b825477154e32e8538e00e1e230dadf93bc7e6df/src%2Ftest%2Fui%2Fsuggestions%2Fmethod-on-ambiguous-numeric-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fmethod-on-ambiguous-numeric-type.rs?ref=b825477154e32e8538e00e1e230dadf93bc7e6df", "patch": "@@ -9,10 +9,10 @@\n // except according to those terms.\n \n fn main() {\n-    let x = 2.0.recip();\n-    //~^ ERROR can't call method `recip` on ambiguous numeric type `{float}`\n+    let x = 2.0.neg();\n+    //~^ ERROR can't call method `neg` on ambiguous numeric type `{float}`\n     let y = 2.0;\n-    let x = y.recip();\n-    //~^ ERROR can't call method `recip` on ambiguous numeric type `{float}`\n+    let x = y.neg();\n+    //~^ ERROR can't call method `neg` on ambiguous numeric type `{float}`\n     println!(\"{:?}\", x);\n }"}, {"sha": "68c8be7dff8c941de2164d31a72574735a55e3b6", "filename": "src/test/ui/suggestions/method-on-ambiguous-numeric-type.stderr", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b825477154e32e8538e00e1e230dadf93bc7e6df/src%2Ftest%2Fui%2Fsuggestions%2Fmethod-on-ambiguous-numeric-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b825477154e32e8538e00e1e230dadf93bc7e6df/src%2Ftest%2Fui%2Fsuggestions%2Fmethod-on-ambiguous-numeric-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fmethod-on-ambiguous-numeric-type.stderr?ref=b825477154e32e8538e00e1e230dadf93bc7e6df", "patch": "@@ -1,18 +1,18 @@\n-error[E0689]: can't call method `recip` on ambiguous numeric type `{float}`\n+error[E0689]: can't call method `neg` on ambiguous numeric type `{float}`\n   --> $DIR/method-on-ambiguous-numeric-type.rs:12:17\n    |\n-LL |     let x = 2.0.recip();\n-   |                 ^^^^^\n+LL |     let x = 2.0.neg();\n+   |                 ^^^\n help: you must specify a concrete type for this numeric value, like `f32`\n    |\n-LL |     let x = 2.0_f32.recip();\n+LL |     let x = 2.0_f32.neg();\n    |             ^^^^^^^\n \n-error[E0689]: can't call method `recip` on ambiguous numeric type `{float}`\n+error[E0689]: can't call method `neg` on ambiguous numeric type `{float}`\n   --> $DIR/method-on-ambiguous-numeric-type.rs:15:15\n    |\n-LL |     let x = y.recip();\n-   |               ^^^^^\n+LL |     let x = y.neg();\n+   |               ^^^\n help: you must specify a type for this binding, like `f32`\n    |\n LL |     let y: f32 = 2.0;"}]}