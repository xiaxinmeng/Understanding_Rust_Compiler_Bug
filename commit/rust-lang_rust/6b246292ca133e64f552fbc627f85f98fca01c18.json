{"sha": "6b246292ca133e64f552fbc627f85f98fca01c18", "node_id": "C_kwDOAAsO6NoAKDZiMjQ2MjkyY2ExMzNlNjRmNTUyZmJjNjI3Zjg1Zjk4ZmNhMDFjMTg", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2022-06-17T09:31:36Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2022-06-17T09:31:36Z"}, "message": "Move more ImmediateLocation::TypeAnnotation into PathKind::Type", "tree": {"sha": "b3f8d9284bb89462b85710c39ab6d9ce14693ddc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b3f8d9284bb89462b85710c39ab6d9ce14693ddc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6b246292ca133e64f552fbc627f85f98fca01c18", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6b246292ca133e64f552fbc627f85f98fca01c18", "html_url": "https://github.com/rust-lang/rust/commit/6b246292ca133e64f552fbc627f85f98fca01c18", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6b246292ca133e64f552fbc627f85f98fca01c18/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6e07b17f692a1639e94687aadfcfea567236bf04", "url": "https://api.github.com/repos/rust-lang/rust/commits/6e07b17f692a1639e94687aadfcfea567236bf04", "html_url": "https://github.com/rust-lang/rust/commit/6e07b17f692a1639e94687aadfcfea567236bf04"}], "stats": {"total": 264, "additions": 142, "deletions": 122}, "files": [{"sha": "e2eed52dfa8a1f22fa25c5631b3a9807b325c1b4", "filename": "crates/ide-completion/src/completions/field.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b246292ca133e64f552fbc627f85f98fca01c18/crates%2Fide-completion%2Fsrc%2Fcompletions%2Ffield.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b246292ca133e64f552fbc627f85f98fca01c18/crates%2Fide-completion%2Fsrc%2Fcompletions%2Ffield.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Ffield.rs?ref=6b246292ca133e64f552fbc627f85f98fca01c18", "patch": "@@ -18,7 +18,7 @@ pub(crate) fn complete_field_list(acc: &mut Completions, ctx: &CompletionContext\n                     is_absolute_path: false,\n                     qualifier: None,\n                     parent: None,\n-                    kind: PathKind::Type { in_tuple_struct: true },\n+                    kind: PathKind::Type { in_tuple_struct: true, ascription: None },\n                     has_type_args: false,\n                     ..\n                 })),"}, {"sha": "0e1cccb1831db18c5662c8a070c71e860e4805b1", "filename": "crates/ide-completion/src/completions/type.rs", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/6b246292ca133e64f552fbc627f85f98fca01c18/crates%2Fide-completion%2Fsrc%2Fcompletions%2Ftype.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b246292ca133e64f552fbc627f85f98fca01c18/crates%2Fide-completion%2Fsrc%2Fcompletions%2Ftype.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Ftype.rs?ref=6b246292ca133e64f552fbc627f85f98fca01c18", "patch": "@@ -5,8 +5,8 @@ use ide_db::FxHashSet;\n use syntax::{ast, AstNode};\n \n use crate::{\n-    context::{PathCompletionCtx, PathKind, PathQualifierCtx},\n-    patterns::{ImmediateLocation, TypeAnnotation},\n+    context::{PathCompletionCtx, PathKind, PathQualifierCtx, TypeAscriptionTarget},\n+    patterns::ImmediateLocation,\n     render::render_type_inference,\n     CompletionContext, Completions,\n };\n@@ -189,14 +189,22 @@ pub(crate) fn complete_type_path(acc: &mut Completions, ctx: &CompletionContext)\n }\n \n pub(crate) fn complete_inferred_type(acc: &mut Completions, ctx: &CompletionContext) -> Option<()> {\n-    use TypeAnnotation::*;\n-    let pat = match &ctx.completion_location {\n-        Some(ImmediateLocation::TypeAnnotation(t)) => t,\n+    let pat = match dbg!(ctx.path_context()) {\n+        Some(\n+            ctx @ PathCompletionCtx {\n+                kind: PathKind::Type { ascription: Some(ascription), .. },\n+                ..\n+            },\n+        ) if ctx.is_trivial_path() => ascription,\n         _ => return None,\n     };\n     let x = match pat {\n-        Let(pat) | FnParam(pat) => ctx.sema.type_of_pat(pat.as_ref()?),\n-        Const(exp) | RetType(exp) => ctx.sema.type_of_expr(exp.as_ref()?),\n+        TypeAscriptionTarget::Let(pat) | TypeAscriptionTarget::FnParam(pat) => {\n+            ctx.sema.type_of_pat(pat.as_ref()?)\n+        }\n+        TypeAscriptionTarget::Const(exp) | TypeAscriptionTarget::RetType(exp) => {\n+            ctx.sema.type_of_expr(exp.as_ref()?)\n+        }\n     }?\n     .adjusted();\n     let ty_string = x.display_source_code(ctx.db, ctx.module.into()).ok()?;"}, {"sha": "b298c372b35d64e83b1bf567c1b0b689f7a6f9fd", "filename": "crates/ide-completion/src/context.rs", "status": "modified", "additions": 124, "deletions": 44, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/6b246292ca133e64f552fbc627f85f98fca01c18/crates%2Fide-completion%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b246292ca133e64f552fbc627f85f98fca01c18/crates%2Fide-completion%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcontext.rs?ref=6b246292ca133e64f552fbc627f85f98fca01c18", "patch": "@@ -43,44 +43,7 @@ pub(crate) enum Visible {\n     No,\n }\n \n-#[derive(Clone, Debug, PartialEq, Eq)]\n-pub(super) enum PathKind {\n-    Expr {\n-        in_block_expr: bool,\n-        in_loop_body: bool,\n-        after_if_expr: bool,\n-        ref_expr_parent: Option<ast::RefExpr>,\n-        is_func_update: Option<ast::RecordExpr>,\n-    },\n-    Type {\n-        in_tuple_struct: bool,\n-    },\n-    Attr {\n-        kind: AttrKind,\n-        annotated_item_kind: Option<SyntaxKind>,\n-    },\n-    Derive,\n-    /// Path in item position, that is inside an (Assoc)ItemList\n-    Item {\n-        kind: ItemListKind,\n-    },\n-    Pat,\n-    Vis {\n-        has_in_token: bool,\n-    },\n-    Use,\n-}\n-\n-#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n-pub(super) enum ItemListKind {\n-    SourceFile,\n-    Module,\n-    Impl,\n-    TraitImpl,\n-    Trait,\n-    ExternBlock,\n-}\n-\n+/// Existing qualifiers for the thing we are currently completing.\n #[derive(Debug, Default)]\n pub(super) struct QualifierCtx {\n     pub(super) unsafe_tok: Option<SyntaxToken>,\n@@ -93,6 +56,7 @@ impl QualifierCtx {\n     }\n }\n \n+/// The state of the path we are currently completing.\n #[derive(Debug)]\n pub(crate) struct PathCompletionCtx {\n     /// If this is a call with () already there (or {} in case of record patterns)\n@@ -127,6 +91,58 @@ impl PathCompletionCtx {\n     }\n }\n \n+/// The kind of path we are completing right now.\n+#[derive(Clone, Debug, PartialEq, Eq)]\n+pub(super) enum PathKind {\n+    Expr {\n+        in_block_expr: bool,\n+        in_loop_body: bool,\n+        after_if_expr: bool,\n+        ref_expr_parent: Option<ast::RefExpr>,\n+        is_func_update: Option<ast::RecordExpr>,\n+    },\n+    Type {\n+        in_tuple_struct: bool,\n+        /// Whether this type path is a type ascription or not\n+        /// Original file ast node\n+        ascription: Option<TypeAscriptionTarget>,\n+    },\n+    Attr {\n+        kind: AttrKind,\n+        annotated_item_kind: Option<SyntaxKind>,\n+    },\n+    Derive,\n+    /// Path in item position, that is inside an (Assoc)ItemList\n+    Item {\n+        kind: ItemListKind,\n+    },\n+    Pat,\n+    Vis {\n+        has_in_token: bool,\n+    },\n+    Use,\n+}\n+\n+#[derive(Clone, Debug, PartialEq, Eq)]\n+pub(crate) enum TypeAscriptionTarget {\n+    Let(Option<ast::Pat>),\n+    FnParam(Option<ast::Pat>),\n+    RetType(Option<ast::Expr>),\n+    Const(Option<ast::Expr>),\n+}\n+\n+/// The kind of item list a [`PathKind::Item`] belongs to.\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+pub(super) enum ItemListKind {\n+    SourceFile,\n+    Module,\n+    Impl,\n+    TraitImpl,\n+    Trait,\n+    ExternBlock,\n+}\n+\n+/// The path qualifier state of the path we are completing.\n #[derive(Debug)]\n pub(crate) struct PathQualifierCtx {\n     pub(crate) path: ast::Path,\n@@ -139,6 +155,7 @@ pub(crate) struct PathQualifierCtx {\n     pub(crate) is_infer_qualifier: bool,\n }\n \n+/// The state of the pattern we are completing.\n #[derive(Debug)]\n pub(super) struct PatternContext {\n     pub(super) refutability: PatternRefutability,\n@@ -151,12 +168,14 @@ pub(super) struct PatternContext {\n     pub(super) record_pat: Option<ast::RecordPat>,\n }\n \n+/// The state of the lifetime we are completing.\n #[derive(Debug)]\n pub(super) struct LifetimeContext {\n     pub(super) lifetime: Option<ast::Lifetime>,\n     pub(super) kind: LifetimeKind,\n }\n \n+/// The kind of lifetime we are completing.\n #[derive(Debug)]\n pub(super) enum LifetimeKind {\n     LifetimeParam { is_decl: bool, param: ast::LifetimeParam },\n@@ -165,13 +184,15 @@ pub(super) enum LifetimeKind {\n     LabelDef,\n }\n \n+/// The state of the name we are completing.\n #[derive(Debug)]\n pub(super) struct NameContext {\n     #[allow(dead_code)]\n     pub(super) name: Option<ast::Name>,\n     pub(super) kind: NameKind,\n }\n \n+/// The kind of the name we are completing.\n #[derive(Debug)]\n #[allow(dead_code)]\n pub(super) enum NameKind {\n@@ -196,13 +217,15 @@ pub(super) enum NameKind {\n     Variant,\n }\n \n+/// The state of the NameRef we are completing.\n #[derive(Debug)]\n pub(super) struct NameRefContext {\n     /// NameRef syntax in the original file\n     pub(super) nameref: Option<ast::NameRef>,\n     pub(super) kind: Option<NameRefKind>,\n }\n \n+/// The kind of the NameRef we are completing.\n #[derive(Debug)]\n pub(super) enum NameRefKind {\n     Path(PathCompletionCtx),\n@@ -213,21 +236,26 @@ pub(super) enum NameRefKind {\n     RecordExpr(ast::RecordExpr),\n }\n \n+/// The identifier we are currently completing.\n #[derive(Debug)]\n pub(super) enum IdentContext {\n     Name(NameContext),\n     NameRef(NameRefContext),\n     Lifetime(LifetimeContext),\n-    /// Original token, fake token\n+    /// The string the cursor is currently inside\n     String {\n+        /// original token\n         original: ast::String,\n+        /// fake token\n         expanded: Option<ast::String>,\n     },\n+    /// Set if we are currently completing in an unexpanded attribute, this usually implies a builtin attribute like `allow($0)`\n     UnexpandedAttrTT {\n         fake_attribute_under_caret: Option<ast::Attr>,\n     },\n }\n \n+/// Information about the field or method access we are completing.\n #[derive(Debug)]\n pub(super) struct DotAccess {\n     pub(super) receiver: Option<ast::Expr>,\n@@ -1161,13 +1189,65 @@ impl<'a> CompletionContext<'a> {\n             None\n         };\n \n+        let fetch_ascription = |it: Option<SyntaxNode>| {\n+            let parent = it?;\n+            match_ast! {\n+                match parent {\n+                    ast::Const(it) => {\n+                        let name = find_in_original_file(it.name(), original_file)?;\n+                        let original = ast::Const::cast(name.syntax().parent()?)?;\n+                        Some(TypeAscriptionTarget::Const(original.body()))\n+                    },\n+                    ast::RetType(it) => {\n+                        if it.thin_arrow_token().is_none() {\n+                            return None;\n+                        }\n+                        let parent = match ast::Fn::cast(parent.parent()?) {\n+                            Some(x) => x.param_list(),\n+                            None => ast::ClosureExpr::cast(parent.parent()?)?.param_list(),\n+                        };\n+\n+                        let parent = find_in_original_file(parent, original_file)?.syntax().parent()?;\n+                        Some(TypeAscriptionTarget::RetType(match_ast! {\n+                            match parent {\n+                                ast::ClosureExpr(it) => {\n+                                    it.body()\n+                                },\n+                                ast::Fn(it) => {\n+                                    it.body().map(ast::Expr::BlockExpr)\n+                                },\n+                                _ => return None,\n+                            }\n+                        }))\n+                    },\n+                    ast::Param(it) => {\n+                        if it.colon_token().is_none() {\n+                            return None;\n+                        }\n+                        Some(TypeAscriptionTarget::FnParam(find_in_original_file(it.pat(), original_file)))\n+                    },\n+                    ast::LetStmt(it) => {\n+                        if it.colon_token().is_none() {\n+                            return None;\n+                        }\n+                        Some(TypeAscriptionTarget::Let(find_in_original_file(it.pat(), original_file)))\n+                    },\n+                    _ => None,\n+                }\n+            }\n+        };\n+\n         // Infer the path kind\n         let kind = path.syntax().parent().and_then(|it| {\n             match_ast! {\n                 match it {\n-                    ast::PathType(it) => Some(PathKind::Type {\n-                        in_tuple_struct: it.syntax().parent().map_or(false, |it| ast::TupleField::can_cast(it.kind()))\n-                    }),\n+                    ast::PathType(it) => {\n+                        let ascription = fetch_ascription(it.syntax().parent());\n+                        Some(PathKind::Type {\n+                            in_tuple_struct: it.syntax().parent().map_or(false, |it| ast::TupleField::can_cast(it.kind())),\n+                            ascription,\n+                        })\n+                    },\n                     ast::PathExpr(it) => {\n                         if let Some(p) = it.syntax().parent() {\n                             if ast::ExprStmt::can_cast(p.kind()) {\n@@ -1178,7 +1258,7 @@ impl<'a> CompletionContext<'a> {\n                             }\n                         }\n \n-                                                path_ctx.has_call_parens = it.syntax().parent().map_or(false, |it| ast::CallExpr::can_cast(it.kind()));\n+                        path_ctx.has_call_parens = it.syntax().parent().map_or(false, |it| ast::CallExpr::can_cast(it.kind()));\n                         let in_block_expr = is_in_block(it.syntax());\n                         let in_loop_body = is_in_loop_body(it.syntax());\n                         let after_if_expr = after_if_expr(it.syntax().clone());\n@@ -1212,7 +1292,7 @@ impl<'a> CompletionContext<'a> {\n                         let parent = it.syntax().parent();\n                         match parent.as_ref().map(|it| it.kind()) {\n                             Some(SyntaxKind::MACRO_PAT) => Some(PathKind::Pat),\n-                            Some(SyntaxKind::MACRO_TYPE) => Some(PathKind::Type { in_tuple_struct: false }),\n+                            Some(SyntaxKind::MACRO_TYPE) => Some(PathKind::Type { in_tuple_struct: false, ascription: None }),\n                             Some(SyntaxKind::ITEM_LIST) => Some(PathKind::Item { kind: ItemListKind::Module }),\n                             Some(SyntaxKind::ASSOC_ITEM_LIST) => Some(PathKind::Item { kind: match parent.and_then(|it| it.parent()) {\n                                 Some(it) => match_ast! {"}, {"sha": "88cb486f5d0f0013c4cf5300e6dbdefa4e2f1d5d", "filename": "crates/ide-completion/src/patterns.rs", "status": "modified", "additions": 2, "deletions": 70, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/6b246292ca133e64f552fbc627f85f98fca01c18/crates%2Fide-completion%2Fsrc%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b246292ca133e64f552fbc627f85f98fca01c18/crates%2Fide-completion%2Fsrc%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fpatterns.rs?ref=6b246292ca133e64f552fbc627f85f98fca01c18", "patch": "@@ -7,32 +7,22 @@\n use hir::Semantics;\n use ide_db::RootDatabase;\n use syntax::{\n-    ast::{self, HasLoopBody, HasName},\n+    ast::{self, HasLoopBody},\n     match_ast, AstNode, SyntaxElement,\n     SyntaxKind::*,\n-    SyntaxNode, SyntaxToken, TextRange, TextSize,\n+    SyntaxNode, SyntaxToken, TextSize,\n };\n \n #[cfg(test)]\n use crate::tests::check_pattern_is_applicable;\n \n-#[derive(Clone, Debug, PartialEq, Eq)]\n-pub(crate) enum TypeAnnotation {\n-    Let(Option<ast::Pat>),\n-    FnParam(Option<ast::Pat>),\n-    RetType(Option<ast::Expr>),\n-    Const(Option<ast::Expr>),\n-}\n-\n /// Direct parent \"thing\" of what we are currently completing.\n ///\n /// This may contain nodes of the fake file as well as the original, comments on the variants specify\n /// from which file the nodes are.\n #[derive(Clone, Debug, PartialEq, Eq)]\n pub(crate) enum ImmediateLocation {\n     TypeBound,\n-    /// Original file ast node\n-    TypeAnnotation(TypeAnnotation),\n     // Only set from a type arg\n     /// Original file ast node\n     GenericArgList(ast::GenericArgList),\n@@ -84,62 +74,9 @@ pub(crate) fn determine_location(\n             ast::GenericArgList(_) => sema\n                 .find_node_at_offset_with_macros(original_file, offset)\n                 .map(ImmediateLocation::GenericArgList)?,\n-            ast::Const(it) => {\n-                if !it.ty().map_or(false, |x| x.syntax().text_range().contains(offset)) {\n-                    return None;\n-                }\n-                let name = find_in_original_file(it.name(), original_file)?;\n-                let original = ast::Const::cast(name.syntax().parent()?)?;\n-                ImmediateLocation::TypeAnnotation(TypeAnnotation::Const(original.body()))\n-            },\n-            ast::RetType(it) => {\n-                if it.thin_arrow_token().is_none() {\n-                    return None;\n-                }\n-                if !it.ty().map_or(false, |x| x.syntax().text_range().contains(offset)) {\n-                    return None;\n-                }\n-                let parent = match ast::Fn::cast(parent.parent()?) {\n-                    Some(x) => x.param_list(),\n-                    None => ast::ClosureExpr::cast(parent.parent()?)?.param_list(),\n-                };\n-                let parent = find_in_original_file(parent, original_file)?.syntax().parent()?;\n-                ImmediateLocation::TypeAnnotation(TypeAnnotation::RetType(match_ast! {\n-                    match parent {\n-                        ast::ClosureExpr(it) => {\n-                            it.body()\n-                        },\n-                        ast::Fn(it) => {\n-                            it.body().map(ast::Expr::BlockExpr)\n-                        },\n-                        _ => return None,\n-                    }\n-                }))\n-            },\n-            ast::Param(it) => {\n-                if it.colon_token().is_none() {\n-                    return None;\n-                }\n-                if !it.ty().map_or(false, |x| x.syntax().text_range().contains(offset)) {\n-                    return None;\n-                }\n-                ImmediateLocation::TypeAnnotation(TypeAnnotation::FnParam(find_in_original_file(it.pat(), original_file)))\n-            },\n-            ast::LetStmt(it) => {\n-                if it.colon_token().is_none() {\n-                    return None;\n-                }\n-                if !it.ty().map_or(false, |x| x.syntax().text_range().contains(offset)) {\n-                    return None;\n-                }\n-                ImmediateLocation::TypeAnnotation(TypeAnnotation::Let(find_in_original_file(it.pat(), original_file)))\n-            },\n             _ => return None,\n         }\n     };\n-    fn find_in_original_file<N: AstNode>(x: Option<N>, original_file: &SyntaxNode) -> Option<N> {\n-        x.map(|e| e.syntax().text_range()).and_then(|r| find_node_with_range(original_file, r))\n-    }\n     Some(res)\n }\n \n@@ -164,11 +101,6 @@ fn maximize_name_ref(name_ref: &ast::NameRef) -> SyntaxNode {\n     name_ref.syntax().clone()\n }\n \n-fn find_node_with_range<N: AstNode>(syntax: &SyntaxNode, range: TextRange) -> Option<N> {\n-    let range = syntax.text_range().intersect(range)?;\n-    syntax.covering_element(range).ancestors().find_map(N::cast)\n-}\n-\n pub(crate) fn previous_token(element: SyntaxElement) -> Option<SyntaxToken> {\n     element.into_token().and_then(previous_non_trivia_token)\n }"}]}