{"sha": "f24e90ec25c066578b7ff33bbc27331e31649a14", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYyNGU5MGVjMjVjMDY2NTc4YjdmZjMzYmJjMjczMzFlMzE2NDlhMTQ=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-06-19T09:08:24Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-06-26T16:41:47Z"}, "message": "extract more helpers from instantiating query result", "tree": {"sha": "b506b1ce5fa165f2b49496a9fed4ebba58f5f220", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b506b1ce5fa165f2b49496a9fed4ebba58f5f220"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f24e90ec25c066578b7ff33bbc27331e31649a14", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f24e90ec25c066578b7ff33bbc27331e31649a14", "html_url": "https://github.com/rust-lang/rust/commit/f24e90ec25c066578b7ff33bbc27331e31649a14", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f24e90ec25c066578b7ff33bbc27331e31649a14/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7bab9f09749f497ef3a8dd1a4961f2813e9a9d11", "url": "https://api.github.com/repos/rust-lang/rust/commits/7bab9f09749f497ef3a8dd1a4961f2813e9a9d11", "html_url": "https://github.com/rust-lang/rust/commit/7bab9f09749f497ef3a8dd1a4961f2813e9a9d11"}], "stats": {"total": 103, "additions": 79, "deletions": 24}, "files": [{"sha": "71cefda6b6646a3f053380f7725c56f70e27f34f", "filename": "src/librustc/infer/canonical/query_result.rs", "status": "modified", "additions": 79, "deletions": 24, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/f24e90ec25c066578b7ff33bbc27331e31649a14/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_result.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f24e90ec25c066578b7ff33bbc27331e31649a14/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_result.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_result.rs?ref=f24e90ec25c066578b7ff33bbc27331e31649a14", "patch": "@@ -19,8 +19,8 @@\n \n use infer::canonical::substitute::substitute_value;\n use infer::canonical::{\n-    Canonical, CanonicalVarValues, CanonicalizedQueryResult, Certainty,\n-    QueryRegionConstraint, QueryResult,\n+    Canonical, CanonicalVarValues, CanonicalizedQueryResult, Certainty, QueryRegionConstraint,\n+    QueryResult,\n };\n use infer::region_constraints::{Constraint, RegionConstraintData};\n use infer::{InferCtxt, InferOk, InferResult, RegionObligation};\n@@ -155,12 +155,10 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n     where\n         R: Debug + TypeFoldable<'tcx>,\n     {\n-        let InferOk { value: result_subst, mut obligations } = self.query_result_substitution(\n-            cause,\n-            param_env,\n-            original_values,\n-            query_result,\n-        )?;\n+        let InferOk {\n+            value: result_subst,\n+            mut obligations,\n+        } = self.query_result_substitution(cause, param_env, original_values, query_result)?;\n \n         obligations.extend(self.query_region_constraints_into_obligations(\n             cause,\n@@ -188,7 +186,7 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n     /// example) we are doing lazy normalization and the value\n     /// assigned to a type variable is unified with an unnormalized\n     /// projection.\n-    pub fn query_result_substitution<R>(\n+    fn query_result_substitution<R>(\n         &self,\n         cause: &ObligationCause<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n@@ -199,7 +197,49 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n         R: Debug + TypeFoldable<'tcx>,\n     {\n         debug!(\n-            \"instantiate_query_result(original_values={:#?}, query_result={:#?})\",\n+            \"query_result_substitution(original_values={:#?}, query_result={:#?})\",\n+            original_values, query_result,\n+        );\n+\n+        let result_subst =\n+            self.query_result_substitution_guess(cause, original_values, query_result);\n+\n+        let obligations = self\n+            .unify_query_result_substitution_guess(\n+                cause,\n+                param_env,\n+                original_values,\n+                &result_subst,\n+                query_result,\n+            )?\n+            .into_obligations();\n+\n+        Ok(InferOk {\n+            value: result_subst,\n+            obligations,\n+        })\n+    }\n+\n+    /// Given the original values and the (canonicalized) result from\n+    /// computing a query, returns a **guess** at a substitution that\n+    /// can be applied to the query result to convert the result back\n+    /// into the original namespace. This is called a **guess**\n+    /// because it uses a quick heuristic to find the values for each\n+    /// canonical variable; if that quick heuristic fails, then we\n+    /// will instantiate fresh inference variables for each canonical\n+    /// variable instead. Therefore, the result of this method must be\n+    /// properly unified\n+    fn query_result_substitution_guess<R>(\n+        &self,\n+        cause: &ObligationCause<'tcx>,\n+        original_values: &CanonicalVarValues<'tcx>,\n+        query_result: &Canonical<'tcx, QueryResult<'tcx, R>>,\n+    ) -> CanonicalVarValues<'tcx>\n+    where\n+        R: Debug + TypeFoldable<'tcx>,\n+    {\n+        debug!(\n+            \"query_result_substitution_guess(original_values={:#?}, query_result={:#?})\",\n             original_values, query_result,\n         );\n \n@@ -256,22 +296,37 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n                 .collect(),\n         };\n \n-        // Unify the original values for the canonical variables in\n-        // the input with the value found in the query\n-        // post-substitution. Often, but not always, this is a no-op,\n-        // because we already found the mapping in the first step.\n-        let obligations = {\n-            let substituted_values = |index: CanonicalVar| -> Kind<'tcx> {\n-                query_result.substitute_projected(self.tcx, &result_subst, |v| &v.var_values[index])\n-            };\n-            self.unify_canonical_vars(cause, param_env, original_values, substituted_values)?\n-                .into_obligations()\n+        result_subst\n+    }\n+\n+    /// Given a \"guess\" at the values for the canonical variables in\n+    /// the input, try to unify with the *actual* values found in the\n+    /// query result.  Often, but not always, this is a no-op, because\n+    /// we already found the mapping in the \"guessing\" step.\n+    ///\n+    /// See also: `query_result_substitution_guess`\n+    fn unify_query_result_substitution_guess<R>(\n+        &self,\n+        cause: &ObligationCause<'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+        original_values: &CanonicalVarValues<'tcx>,\n+        result_subst: &CanonicalVarValues<'tcx>,\n+        query_result: &Canonical<'tcx, QueryResult<'tcx, R>>,\n+    ) -> InferResult<'tcx, ()>\n+    where\n+        R: Debug + TypeFoldable<'tcx>,\n+    {\n+        // A closure that yields the result value for the given\n+        // canonical variable; this is taken from\n+        // `query_result.var_values` after applying the substitution\n+        // `result_subst`.\n+        let substituted_query_result = |index: CanonicalVar| -> Kind<'tcx> {\n+            query_result.substitute_projected(self.tcx, &result_subst, |v| &v.var_values[index])\n         };\n \n-        Ok(InferOk {\n-            value: result_subst,\n-            obligations,\n-        })\n+        // Unify the original value for each variable with the value\n+        // taken from `query_result` (after applying `result_subst`).\n+        Ok(self.unify_canonical_vars(cause, param_env, original_values, substituted_query_result)?)\n     }\n \n     /// Converts the region constraints resulting from a query into an"}]}