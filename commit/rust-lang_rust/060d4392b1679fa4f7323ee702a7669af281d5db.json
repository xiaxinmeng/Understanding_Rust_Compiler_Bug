{"sha": "060d4392b1679fa4f7323ee702a7669af281d5db", "node_id": "C_kwDOAAsO6NoAKDA2MGQ0MzkyYjE2NzlmYTRmNzMyM2VlNzAyYTc2NjlhZjI4MWQ1ZGI", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-09-15T00:18:35Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-11-03T15:52:38Z"}, "message": "Make obligations_for_self_ty only return an obligation", "tree": {"sha": "df4c6e50f17b62a38e0cbf94c7dbc9686571fea2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/df4c6e50f17b62a38e0cbf94c7dbc9686571fea2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/060d4392b1679fa4f7323ee702a7669af281d5db", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/060d4392b1679fa4f7323ee702a7669af281d5db", "html_url": "https://github.com/rust-lang/rust/commit/060d4392b1679fa4f7323ee702a7669af281d5db", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/060d4392b1679fa4f7323ee702a7669af281d5db/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "160b19429523ea44c4c3b7cad4233b2a35f58b8f", "url": "https://api.github.com/repos/rust-lang/rust/commits/160b19429523ea44c4c3b7cad4233b2a35f58b8f", "html_url": "https://github.com/rust-lang/rust/commit/160b19429523ea44c4c3b7cad4233b2a35f58b8f"}], "stats": {"total": 155, "additions": 84, "deletions": 71}, "files": [{"sha": "cc1191d32458f607694ce6b00effb0fc555d7d9f", "filename": "compiler/rustc_hir_typeck/src/closure.rs", "status": "modified", "additions": 35, "deletions": 24, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/060d4392b1679fa4f7323ee702a7669af281d5db/compiler%2Frustc_hir_typeck%2Fsrc%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/060d4392b1679fa4f7323ee702a7669af281d5db/compiler%2Frustc_hir_typeck%2Fsrc%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fclosure.rs?ref=060d4392b1679fa4f7323ee702a7669af281d5db", "patch": "@@ -225,33 +225,44 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         &self,\n         expected_vid: ty::TyVid,\n     ) -> (Option<ExpectedSig<'tcx>>, Option<ty::ClosureKind>) {\n-        let expected_sig =\n-            self.obligations_for_self_ty(expected_vid).find_map(|(_, obligation)| {\n-                debug!(?obligation.predicate);\n-\n-                let bound_predicate = obligation.predicate.kind();\n-                if let ty::PredicateKind::Projection(proj_predicate) =\n-                    obligation.predicate.kind().skip_binder()\n-                {\n-                    // Given a Projection predicate, we can potentially infer\n-                    // the complete signature.\n-                    self.deduce_sig_from_projection(\n-                        Some(obligation.cause.span),\n-                        bound_predicate.rebind(proj_predicate),\n-                    )\n-                } else {\n-                    None\n-                }\n-            });\n-\n+        let mut expected_sig = None;\n         // Even if we can't infer the full signature, we may be able to\n         // infer the kind. This can occur when we elaborate a predicate\n         // like `F : Fn<A>`. Note that due to subtyping we could encounter\n         // many viable options, so pick the most restrictive.\n-        let expected_kind = self\n-            .obligations_for_self_ty(expected_vid)\n-            .filter_map(|(tr, _)| self.tcx.fn_trait_kind_from_lang_item(tr.def_id()))\n-            .fold(None, |best, cur| Some(best.map_or(cur, |best| cmp::min(best, cur))));\n+        let mut expected_kind = None;\n+\n+        for obligation in self.obligations_for_self_ty(expected_vid) {\n+            debug!(?obligation.predicate);\n+            let bound_predicate = obligation.predicate.kind();\n+\n+            if expected_sig.is_none()\n+                && let ty::PredicateKind::Projection(proj_predicate) = bound_predicate.skip_binder()\n+            {\n+                // Given a Projection predicate, we can potentially infer\n+                // the complete signature.\n+                expected_sig = self.deduce_sig_from_projection(\n+                    Some(obligation.cause.span),\n+                    bound_predicate.rebind(proj_predicate),\n+                );\n+            }\n+\n+            let trait_def_id = match bound_predicate.skip_binder() {\n+                ty::PredicateKind::Projection(data) => {\n+                    Some(data.projection_ty.trait_def_id(self.tcx))\n+                }\n+                ty::PredicateKind::Trait(data) => Some(data.def_id()),\n+                _ => None,\n+            };\n+            if let Some(closure_kind) =\n+                trait_def_id.and_then(|def_id| self.tcx.fn_trait_kind_from_lang_item(def_id))\n+            {\n+                expected_kind = Some(\n+                    expected_kind\n+                        .map_or_else(|| closure_kind, |current| cmp::min(current, closure_kind)),\n+                );\n+            }\n+        }\n \n         (expected_sig, expected_kind)\n     }\n@@ -689,7 +700,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         let output_ty = match *ret_ty.kind() {\n             ty::Infer(ty::TyVar(ret_vid)) => {\n-                self.obligations_for_self_ty(ret_vid).find_map(|(_, obligation)| {\n+                self.obligations_for_self_ty(ret_vid).find_map(|obligation| {\n                     get_future_output(obligation.predicate, obligation.cause.span)\n                 })?\n             }"}, {"sha": "d2962a3836faecbb3a7d66097b6e2fcea854fef4", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/_impl.rs", "status": "modified", "additions": 49, "deletions": 47, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/060d4392b1679fa4f7323ee702a7669af281d5db/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/060d4392b1679fa4f7323ee702a7669af281d5db/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs?ref=060d4392b1679fa4f7323ee702a7669af281d5db", "patch": "@@ -21,8 +21,8 @@ use rustc_middle::ty::adjustment::{Adjust, Adjustment, AutoBorrow, AutoBorrowMut\n use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::visit::TypeVisitable;\n use rustc_middle::ty::{\n-    self, AdtKind, CanonicalUserType, DefIdTree, EarlyBinder, GenericParamDefKind, ToPolyTraitRef,\n-    ToPredicate, Ty, UserType,\n+    self, AdtKind, CanonicalUserType, DefIdTree, EarlyBinder, GenericParamDefKind, ToPredicate, Ty,\n+    UserType,\n };\n use rustc_middle::ty::{GenericArgKind, InternalSubsts, SubstsRef, UserSelfTy, UserSubsts};\n use rustc_session::lint;\n@@ -650,12 +650,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     }\n \n     #[instrument(skip(self), level = \"debug\")]\n-    fn self_type_matches_expected_vid(\n-        &self,\n-        trait_ref: ty::PolyTraitRef<'tcx>,\n-        expected_vid: ty::TyVid,\n-    ) -> bool {\n-        let self_ty = self.shallow_resolve(trait_ref.skip_binder().self_ty());\n+    fn self_type_matches_expected_vid(&self, self_ty: Ty<'tcx>, expected_vid: ty::TyVid) -> bool {\n+        let self_ty = self.shallow_resolve(self_ty);\n         debug!(?self_ty);\n \n         match *self_ty.kind() {\n@@ -674,54 +670,60 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub(in super::super) fn obligations_for_self_ty<'b>(\n         &'b self,\n         self_ty: ty::TyVid,\n-    ) -> impl Iterator<Item = (ty::PolyTraitRef<'tcx>, traits::PredicateObligation<'tcx>)>\n-    + Captures<'tcx>\n-    + 'b {\n+    ) -> impl Iterator<Item = traits::PredicateObligation<'tcx>> + Captures<'tcx> + 'b {\n         // FIXME: consider using `sub_root_var` here so we\n         // can see through subtyping.\n         let ty_var_root = self.root_var(self_ty);\n         trace!(\"pending_obligations = {:#?}\", self.fulfillment_cx.borrow().pending_obligations());\n \n-        self.fulfillment_cx\n-            .borrow()\n-            .pending_obligations()\n-            .into_iter()\n-            .filter_map(move |obligation| {\n-                let bound_predicate = obligation.predicate.kind();\n-                match bound_predicate.skip_binder() {\n-                    ty::PredicateKind::Projection(data) => Some((\n-                        bound_predicate.rebind(data).required_poly_trait_ref(self.tcx),\n-                        obligation,\n-                    )),\n-                    ty::PredicateKind::Trait(data) => {\n-                        Some((bound_predicate.rebind(data).to_poly_trait_ref(), obligation))\n-                    }\n-                    ty::PredicateKind::Subtype(..) => None,\n-                    ty::PredicateKind::Coerce(..) => None,\n-                    ty::PredicateKind::RegionOutlives(..) => None,\n-                    ty::PredicateKind::TypeOutlives(..) => None,\n-                    ty::PredicateKind::WellFormed(..) => None,\n-                    ty::PredicateKind::ObjectSafe(..) => None,\n-                    ty::PredicateKind::ConstEvaluatable(..) => None,\n-                    ty::PredicateKind::ConstEquate(..) => None,\n-                    // N.B., this predicate is created by breaking down a\n-                    // `ClosureType: FnFoo()` predicate, where\n-                    // `ClosureType` represents some `Closure`. It can't\n-                    // possibly be referring to the current closure,\n-                    // because we haven't produced the `Closure` for\n-                    // this closure yet; this is exactly why the other\n-                    // code is looking for a self type of an unresolved\n-                    // inference variable.\n-                    ty::PredicateKind::ClosureKind(..) => None,\n-                    ty::PredicateKind::TypeWellFormedFromEnv(..) => None,\n+        self.fulfillment_cx.borrow().pending_obligations().into_iter().filter_map(\n+            move |obligation| match &obligation.predicate.kind().skip_binder() {\n+                ty::PredicateKind::Projection(data)\n+                    if self.self_type_matches_expected_vid(\n+                        data.projection_ty.self_ty(),\n+                        ty_var_root,\n+                    ) =>\n+                {\n+                    Some(obligation)\n                 }\n-            })\n-            .filter(move |(tr, _)| self.self_type_matches_expected_vid(*tr, ty_var_root))\n+                ty::PredicateKind::Trait(data)\n+                    if self.self_type_matches_expected_vid(data.self_ty(), ty_var_root) =>\n+                {\n+                    Some(obligation)\n+                }\n+\n+                ty::PredicateKind::Trait(..)\n+                | ty::PredicateKind::Projection(..)\n+                | ty::PredicateKind::Subtype(..)\n+                | ty::PredicateKind::Coerce(..)\n+                | ty::PredicateKind::RegionOutlives(..)\n+                | ty::PredicateKind::TypeOutlives(..)\n+                | ty::PredicateKind::WellFormed(..)\n+                | ty::PredicateKind::ObjectSafe(..)\n+                | ty::PredicateKind::ConstEvaluatable(..)\n+                | ty::PredicateKind::ConstEquate(..)\n+                // N.B., this predicate is created by breaking down a\n+                // `ClosureType: FnFoo()` predicate, where\n+                // `ClosureType` represents some `Closure`. It can't\n+                // possibly be referring to the current closure,\n+                // because we haven't produced the `Closure` for\n+                // this closure yet; this is exactly why the other\n+                // code is looking for a self type of an unresolved\n+                // inference variable.\n+                | ty::PredicateKind::ClosureKind(..)\n+                | ty::PredicateKind::TypeWellFormedFromEnv(..) => None,\n+            },\n+        )\n     }\n \n     pub(in super::super) fn type_var_is_sized(&self, self_ty: ty::TyVid) -> bool {\n-        self.obligations_for_self_ty(self_ty)\n-            .any(|(tr, _)| Some(tr.def_id()) == self.tcx.lang_items().sized_trait())\n+        let sized_did = self.tcx.lang_items().sized_trait();\n+        self.obligations_for_self_ty(self_ty).any(|obligation| {\n+            match obligation.predicate.kind().skip_binder() {\n+                ty::PredicateKind::Trait(data) => Some(data.def_id()) == sized_did,\n+                _ => false,\n+            }\n+        })\n     }\n \n     pub(in super::super) fn err_args(&self, len: usize) -> Vec<Ty<'tcx>> {"}]}