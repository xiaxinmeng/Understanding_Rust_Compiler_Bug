{"sha": "008d9d0feaec231fa2fe16468d2d44714e765700", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAwOGQ5ZDBmZWFlYzIzMWZhMmZlMTY0NjhkMmQ0NDcxNGU3NjU3MDA=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-07-25T21:20:56Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-07-25T21:20:56Z"}, "message": "Rollup merge of #62528 - SimonSapin:concat, r=alexcrichton\n\nAdd joining slices of slices with a slice separator, not just a single item\n\nhttps://github.com/rust-lang/rust/issues/27747#issuecomment-294525391\n> It's kinda annoying to be able to join strings with a str (which can have multiple chars), but joining a slice of slices, you can only join with a single element.\n\nThis turns out to be fixable, with some possible inference regressions.\n\n# TL;DR\n\nRelated trait(s) are unstable and tracked at https://github.com/rust-lang/rust/issues/27747, but the `[T]::join` method that is being extended here is already stable.\n\nExample use of the new insta-stable functionality:\n\n```rust\nlet nested: Vec<Vec<Foo>> = /* \u2026 */;\nlet separator: &[Foo] = /* \u2026 */;  // Previously: could only be a single &Foo\nnested.join(separator)\n```\n\nComplete API affected by this PR, after changes:\n\n```rust\nimpl<T> [T] {\n    pub fn concat<Item: ?Sized>(&self) -> <Self as Concat<Item>>::Output\n        where Self: Concat<Item>\n    {\n        Concat::concat(self)\n    }\n    pub fn join<Separator>(&self, sep: Separator) -> <Self as Join<Separator>>::Output\n        where Self: Join<Separator>\n    {\n        Join::join(self, sep)\n    }\n}\n\n// The `Item` parameter is only useful for the the slice-of-slices impl.\npub trait Concat<Item: ?Sized> {\n    type Output;\n    fn concat(slice: &Self) -> Self::Output;\n}\n\npub trait Join<Separator> {\n    type Output;\n    fn join(slice: &Self, sep: Separator) -> Self::Output;\n}\n\nimpl<T: Clone, V: Borrow<[T]>> Concat<T> for [V] {\n    type Output = Vec<T>;\n}\n\nimpl<T: Clone, V: Borrow<[T]>> Join<&'_ T> for [V] {\n    type Output = Vec<T>;\n}\n\n// New functionality here!\nimpl<T: Clone, V: Borrow<[T]>> Join<&'_ [T]> for [V] {\n    type Output = Vec<T>;\n}\n\nimpl<S: Borrow<str>> Concat<str> for [S] {\n    type Output = String;\n}\n\nimpl<S: Borrow<str>> Join<&'_ str> for [S] {\n    type Output = String;\n}\n```\n\n# Details\n\nAfter https://github.com/rust-lang/rust/pull/62403 but before this PR, the API is:\n\n```rust\nimpl<T> [T] {\n    pub fn concat<Separator: ?Sized>(&self) -> T::Output\n        where T: SliceConcat<Separator>\n    {\n        SliceConcat::concat(self)\n    }\n\n    pub fn join<Separator: ?Sized>(&self, sep: &Separator) -> T::Output\n        where T: SliceConcat<Separator>\n    {\n        SliceConcat::join(self, sep)\n    }\n}\n\npub trait SliceConcat<Separator: ?Sized>: Sized {\n    type Output;\n    fn concat(slice: &[Self]) -> Self::Output;\n    fn join(slice: &[Self], sep: &Separator) -> Self::Output;\n}\n\nimpl<T: Clone, V: Borrow<[T]>> SliceConcat<T> for V {\n    type Output = Vec<T>;\n}\n\nimpl<S: Borrow<str>> SliceConcat<str> for S {\n    type Output = String;\n}\n```\n\nBy adding a trait impl we should be able to accept a slice of `T` as the separator, as an alternative to a single `T` value.\n\nIn a `some_slice.join(some_separator)` call, trait resolution will pick an impl or the other based on the type of `some_separator`. In `some_slice.concat()` however there is no separator, so this call would become ambiguous. Some regression in type inference or trait resolution may be acceptable on principle, but requiring a turbofish for every single call to `concat` isn\u2019t great.\n\nThe solution to that is splitting the `SliceConcat` trait into two `Concat` and `Join` traits, one for each eponymous method. Only `Join` would gain a new impl, so that `some_slice.concat()` would not become ambiguous.\n\nNow, at the trait level the `Concat` trait does not need a `Separator` parameter anymore. However, simply removing it causes one of the impls not to be accepted anymore:\n\n```rust\nerror[E0207]: the type parameter `T` is not constrained by the impl trait, self type, or predicates\n  --> src/liballoc/slice.rs:608:6\n    |\n608 | impl<T: Clone, V: Borrow<[T]>> Concat for [V] {\n    |      ^ unconstrained type parameter\n```\n\nThis makes sense: if `[V]::concat` is a method that is itself not generic, then its return type (which is the `Concat::Output` associated type) needs to be determined based on solely `V`. And although there is no such type in the standard library, there is nothing stopping another crate from defining a `V` type that implements both `Borrow<[Foo]>` and `Borrow<[Bar]>`. It might not be a good idea, but it\u2019s possible. Both would apply here, and there would be no way to determine `T`.\n\nThis could be a warning sign that this API is too generic. Perhaps we\u2019d be better off having one less type variable, and only implement `Concat for [&'_ [T]]` and `Concat for [Vec<T>]` etc. However this aspect of `[V]::concat` is already stable, so we\u2019re stuck with it.\n\nThe solution is to keep a dummy type parameter on the `Concat` trait. That way, if a type has multiple `Borrow<[_]>` impls, it\u2019ll end up with multiple corresponding `Concat<_>` impls.\n\nIn `impl<S: Borrow<str>> Concat<str> for [S]`, the second occurrence of `str` is not meaningful. It could be any type. As long as there is only once such type with an applicable impl, trait resolution will be appeased without demanding turbofishes.\n\n# Joining strings with `char`\n\nFor symmetry I also tried adding this impl (because why not):\n\n```rust\nimpl<S: Borrow<str>> Join<char> for [S] {\n    type Output = String;\n}\n```\n\nThis immediately caused an inference regression in a dependency of rustc:\n\n```rust\nerror[E0277]: the trait bound `std::string::String: std::borrow::Borrow<[std::string::String]>` is not satisfied\n   --> /home/simon/.cargo/registry/src/github.com-1ecc6299db9ec823/getopts-0.2.19/src/lib.rs:595:37\n    |\n595 |             row.push_str(&desc_rows.join(&desc_sep));\n    |                                     ^^^^ the trait `std::borrow::Borrow<[std::string::String]>` is not implemented for `std::string::String`\n    |\n    = help: the following implementations were found:\n              <std::string::String as std::borrow::Borrow<str>>\n    = note: required because of the requirements on the impl of `std::slice::Join<&std::string::String>` for `[std::string::String]`\n```\n\nIn the context of this code, two facts are known:\n\n* `desc_rows` is a `Vec<String>`\n* `desc_sep` is a `String`\n\nPreviously the first fact alone reduces the resolution of `join` to only one solution, where its argument it expected to be `&str`. Then, `&String` is coerced to `&str`.\n\nWith the new `Join` impl, the first fact leavs two applicable impls where the separator can be either `&str` or `char`. But `&String` is neither of these things. It appears that possible coercions are not accounted for, in the search for a solution in trait resolution.\n\nI have not included this new impl in this PR. It\u2019s still possible to add later, but the `getopts` breakage does not need to block the rest of the PR. And the functionality easy for end-user to duplicate: `slice_of_strings.join(&*char_separator.encode_utf8(&mut [0_u8, 4]))`\n\nThe `&*` part of that last code snippet is another case of the same issue: `encode_utf8` returns `&mut str` which can be coerced to `&str`, but isn\u2019t when trait resolution is ambiguous.", "tree": {"sha": "90090a30dc424c16e8d6729251661f5afa0e0515", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/90090a30dc424c16e8d6729251661f5afa0e0515"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/008d9d0feaec231fa2fe16468d2d44714e765700", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdOh04CRBK7hj4Ov3rIwAAdHIIAC56qlRuO0TfS2HEmWV5l6N+\ndLPt7xxbOSwiGyXgnQeuBmcynpfOQi0FEal30WkkSOsYWVpe3uUuXcLr+o3XFSY4\nBBgTVhUdi9yUI2YSo7yOjseGTAIED7ykjoRYb9FB4gkse9Z5Xde5emrOBHpnbnRN\nK2yxmEYY0XKNg3rmqsMBII4X44ymlr30t6VSW0MJy9M5PQqEO0pa+c624TRX/SSa\n1Ny5HsoTCrWgb+uBsTwukK18hgpX3+KxIXatrn37NG7bzz+OF9Am1HFdk9jqHfyu\nTCOM0TzjsHTAM4R5N7EC5lwRKO5cK8h87UjuN2Jvz0pzUEIOq3OnfpVI2Hs62iw=\n=FnHu\n-----END PGP SIGNATURE-----\n", "payload": "tree 90090a30dc424c16e8d6729251661f5afa0e0515\nparent dbd0028dcc68b0d3fb3d50dca83e59a4abff7a3c\nparent 5f7768a976edc296c62479b936993b4dc9af065b\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1564089656 +0200\ncommitter GitHub <noreply@github.com> 1564089656 +0200\n\nRollup merge of #62528 - SimonSapin:concat, r=alexcrichton\n\nAdd joining slices of slices with a slice separator, not just a single item\n\nhttps://github.com/rust-lang/rust/issues/27747#issuecomment-294525391\n> It's kinda annoying to be able to join strings with a str (which can have multiple chars), but joining a slice of slices, you can only join with a single element.\n\nThis turns out to be fixable, with some possible inference regressions.\n\n# TL;DR\n\nRelated trait(s) are unstable and tracked at https://github.com/rust-lang/rust/issues/27747, but the `[T]::join` method that is being extended here is already stable.\n\nExample use of the new insta-stable functionality:\n\n```rust\nlet nested: Vec<Vec<Foo>> = /* \u2026 */;\nlet separator: &[Foo] = /* \u2026 */;  // Previously: could only be a single &Foo\nnested.join(separator)\n```\n\nComplete API affected by this PR, after changes:\n\n```rust\nimpl<T> [T] {\n    pub fn concat<Item: ?Sized>(&self) -> <Self as Concat<Item>>::Output\n        where Self: Concat<Item>\n    {\n        Concat::concat(self)\n    }\n    pub fn join<Separator>(&self, sep: Separator) -> <Self as Join<Separator>>::Output\n        where Self: Join<Separator>\n    {\n        Join::join(self, sep)\n    }\n}\n\n// The `Item` parameter is only useful for the the slice-of-slices impl.\npub trait Concat<Item: ?Sized> {\n    type Output;\n    fn concat(slice: &Self) -> Self::Output;\n}\n\npub trait Join<Separator> {\n    type Output;\n    fn join(slice: &Self, sep: Separator) -> Self::Output;\n}\n\nimpl<T: Clone, V: Borrow<[T]>> Concat<T> for [V] {\n    type Output = Vec<T>;\n}\n\nimpl<T: Clone, V: Borrow<[T]>> Join<&'_ T> for [V] {\n    type Output = Vec<T>;\n}\n\n// New functionality here!\nimpl<T: Clone, V: Borrow<[T]>> Join<&'_ [T]> for [V] {\n    type Output = Vec<T>;\n}\n\nimpl<S: Borrow<str>> Concat<str> for [S] {\n    type Output = String;\n}\n\nimpl<S: Borrow<str>> Join<&'_ str> for [S] {\n    type Output = String;\n}\n```\n\n# Details\n\nAfter https://github.com/rust-lang/rust/pull/62403 but before this PR, the API is:\n\n```rust\nimpl<T> [T] {\n    pub fn concat<Separator: ?Sized>(&self) -> T::Output\n        where T: SliceConcat<Separator>\n    {\n        SliceConcat::concat(self)\n    }\n\n    pub fn join<Separator: ?Sized>(&self, sep: &Separator) -> T::Output\n        where T: SliceConcat<Separator>\n    {\n        SliceConcat::join(self, sep)\n    }\n}\n\npub trait SliceConcat<Separator: ?Sized>: Sized {\n    type Output;\n    fn concat(slice: &[Self]) -> Self::Output;\n    fn join(slice: &[Self], sep: &Separator) -> Self::Output;\n}\n\nimpl<T: Clone, V: Borrow<[T]>> SliceConcat<T> for V {\n    type Output = Vec<T>;\n}\n\nimpl<S: Borrow<str>> SliceConcat<str> for S {\n    type Output = String;\n}\n```\n\nBy adding a trait impl we should be able to accept a slice of `T` as the separator, as an alternative to a single `T` value.\n\nIn a `some_slice.join(some_separator)` call, trait resolution will pick an impl or the other based on the type of `some_separator`. In `some_slice.concat()` however there is no separator, so this call would become ambiguous. Some regression in type inference or trait resolution may be acceptable on principle, but requiring a turbofish for every single call to `concat` isn\u2019t great.\n\nThe solution to that is splitting the `SliceConcat` trait into two `Concat` and `Join` traits, one for each eponymous method. Only `Join` would gain a new impl, so that `some_slice.concat()` would not become ambiguous.\n\nNow, at the trait level the `Concat` trait does not need a `Separator` parameter anymore. However, simply removing it causes one of the impls not to be accepted anymore:\n\n```rust\nerror[E0207]: the type parameter `T` is not constrained by the impl trait, self type, or predicates\n  --> src/liballoc/slice.rs:608:6\n    |\n608 | impl<T: Clone, V: Borrow<[T]>> Concat for [V] {\n    |      ^ unconstrained type parameter\n```\n\nThis makes sense: if `[V]::concat` is a method that is itself not generic, then its return type (which is the `Concat::Output` associated type) needs to be determined based on solely `V`. And although there is no such type in the standard library, there is nothing stopping another crate from defining a `V` type that implements both `Borrow<[Foo]>` and `Borrow<[Bar]>`. It might not be a good idea, but it\u2019s possible. Both would apply here, and there would be no way to determine `T`.\n\nThis could be a warning sign that this API is too generic. Perhaps we\u2019d be better off having one less type variable, and only implement `Concat for [&'_ [T]]` and `Concat for [Vec<T>]` etc. However this aspect of `[V]::concat` is already stable, so we\u2019re stuck with it.\n\nThe solution is to keep a dummy type parameter on the `Concat` trait. That way, if a type has multiple `Borrow<[_]>` impls, it\u2019ll end up with multiple corresponding `Concat<_>` impls.\n\nIn `impl<S: Borrow<str>> Concat<str> for [S]`, the second occurrence of `str` is not meaningful. It could be any type. As long as there is only once such type with an applicable impl, trait resolution will be appeased without demanding turbofishes.\n\n# Joining strings with `char`\n\nFor symmetry I also tried adding this impl (because why not):\n\n```rust\nimpl<S: Borrow<str>> Join<char> for [S] {\n    type Output = String;\n}\n```\n\nThis immediately caused an inference regression in a dependency of rustc:\n\n```rust\nerror[E0277]: the trait bound `std::string::String: std::borrow::Borrow<[std::string::String]>` is not satisfied\n   --> /home/simon/.cargo/registry/src/github.com-1ecc6299db9ec823/getopts-0.2.19/src/lib.rs:595:37\n    |\n595 |             row.push_str(&desc_rows.join(&desc_sep));\n    |                                     ^^^^ the trait `std::borrow::Borrow<[std::string::String]>` is not implemented for `std::string::String`\n    |\n    = help: the following implementations were found:\n              <std::string::String as std::borrow::Borrow<str>>\n    = note: required because of the requirements on the impl of `std::slice::Join<&std::string::String>` for `[std::string::String]`\n```\n\nIn the context of this code, two facts are known:\n\n* `desc_rows` is a `Vec<String>`\n* `desc_sep` is a `String`\n\nPreviously the first fact alone reduces the resolution of `join` to only one solution, where its argument it expected to be `&str`. Then, `&String` is coerced to `&str`.\n\nWith the new `Join` impl, the first fact leavs two applicable impls where the separator can be either `&str` or `char`. But `&String` is neither of these things. It appears that possible coercions are not accounted for, in the search for a solution in trait resolution.\n\nI have not included this new impl in this PR. It\u2019s still possible to add later, but the `getopts` breakage does not need to block the rest of the PR. And the functionality easy for end-user to duplicate: `slice_of_strings.join(&*char_separator.encode_utf8(&mut [0_u8, 4]))`\n\nThe `&*` part of that last code snippet is another case of the same issue: `encode_utf8` returns `&mut str` which can be coerced to `&str`, but isn\u2019t when trait resolution is ambiguous.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/008d9d0feaec231fa2fe16468d2d44714e765700", "html_url": "https://github.com/rust-lang/rust/commit/008d9d0feaec231fa2fe16468d2d44714e765700", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/008d9d0feaec231fa2fe16468d2d44714e765700/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dbd0028dcc68b0d3fb3d50dca83e59a4abff7a3c", "url": "https://api.github.com/repos/rust-lang/rust/commits/dbd0028dcc68b0d3fb3d50dca83e59a4abff7a3c", "html_url": "https://github.com/rust-lang/rust/commit/dbd0028dcc68b0d3fb3d50dca83e59a4abff7a3c"}, {"sha": "5f7768a976edc296c62479b936993b4dc9af065b", "url": "https://api.github.com/repos/rust-lang/rust/commits/5f7768a976edc296c62479b936993b4dc9af065b", "html_url": "https://github.com/rust-lang/rust/commit/5f7768a976edc296c62479b936993b4dc9af065b"}], "stats": {"total": 125, "additions": 96, "deletions": 29}, "files": [{"sha": "881d499c0745baf427f3e61e98281d263473b06f", "filename": "src/liballoc/slice.rs", "status": "modified", "additions": 83, "deletions": 21, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/008d9d0feaec231fa2fe16468d2d44714e765700/src%2Fliballoc%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/008d9d0feaec231fa2fe16468d2d44714e765700/src%2Fliballoc%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fslice.rs?ref=008d9d0feaec231fa2fe16468d2d44714e765700", "patch": "@@ -494,10 +494,10 @@ impl<T> [T] {\n     /// assert_eq!([[1, 2], [3, 4]].concat(), [1, 2, 3, 4]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn concat<Separator: ?Sized>(&self) -> T::Output\n-        where T: SliceConcat<Separator>\n+    pub fn concat<Item: ?Sized>(&self) -> <Self as Concat<Item>>::Output\n+        where Self: Concat<Item>\n     {\n-        SliceConcat::concat(self)\n+        Concat::concat(self)\n     }\n \n     /// Flattens a slice of `T` into a single value `Self::Output`, placing a\n@@ -508,12 +508,13 @@ impl<T> [T] {\n     /// ```\n     /// assert_eq!([\"hello\", \"world\"].join(\" \"), \"hello world\");\n     /// assert_eq!([[1, 2], [3, 4]].join(&0), [1, 2, 0, 3, 4]);\n+    /// assert_eq!([[1, 2], [3, 4]].join(&[0, 0][..]), [1, 2, 0, 0, 3, 4]);\n     /// ```\n     #[stable(feature = \"rename_connect_to_join\", since = \"1.3.0\")]\n-    pub fn join<Separator: ?Sized>(&self, sep: &Separator) -> T::Output\n-        where T: SliceConcat<Separator>\n+    pub fn join<Separator>(&self, sep: Separator) -> <Self as Join<Separator>>::Output\n+        where Self: Join<Separator>\n     {\n-        SliceConcat::join(self, sep)\n+        Join::join(self, sep)\n     }\n \n     /// Flattens a slice of `T` into a single value `Self::Output`, placing a\n@@ -528,10 +529,10 @@ impl<T> [T] {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[rustc_deprecated(since = \"1.3.0\", reason = \"renamed to join\")]\n-    pub fn connect<Separator: ?Sized>(&self, sep: &Separator) -> T::Output\n-        where T: SliceConcat<Separator>\n+    pub fn connect<Separator>(&self, sep: Separator) -> <Self as Join<Separator>>::Output\n+        where Self: Join<Separator>\n     {\n-        SliceConcat::join(self, sep)\n+        Join::join(self, sep)\n     }\n \n }\n@@ -578,45 +579,83 @@ impl [u8] {\n // Extension traits for slices over specific kinds of data\n ////////////////////////////////////////////////////////////////////////////////\n \n-/// Helper trait for [`[T]::concat`](../../std/primitive.slice.html#method.concat)\n-/// and [`[T]::join`](../../std/primitive.slice.html#method.join)\n+/// Helper trait for [`[T]::concat`](../../std/primitive.slice.html#method.concat).\n+///\n+/// Note: the `Item` type parameter is not used in this trait,\n+/// but it allows impls to be more generic.\n+/// Without it, we get this error:\n+///\n+/// ```error\n+/// error[E0207]: the type parameter `T` is not constrained by the impl trait, self type, or predica\n+///    --> src/liballoc/slice.rs:608:6\n+///     |\n+/// 608 | impl<T: Clone, V: Borrow<[T]>> Concat for [V] {\n+///     |      ^ unconstrained type parameter\n+/// ```\n+///\n+/// This is because there could exist `V` types with multiple `Borrow<[_]>` impls,\n+/// such that multiple `T` types would apply:\n+///\n+/// ```\n+/// # #[allow(dead_code)]\n+/// pub struct Foo(Vec<u32>, Vec<String>);\n+///\n+/// impl std::borrow::Borrow<[u32]> for Foo {\n+///     fn borrow(&self) -> &[u32] { &self.0 }\n+/// }\n+///\n+/// impl std::borrow::Borrow<[String]> for Foo {\n+///     fn borrow(&self) -> &[String] { &self.1 }\n+/// }\n+/// ```\n #[unstable(feature = \"slice_concat_trait\", issue = \"27747\")]\n-pub trait SliceConcat<Separator: ?Sized>: Sized {\n+pub trait Concat<Item: ?Sized> {\n     #[unstable(feature = \"slice_concat_trait\", issue = \"27747\")]\n     /// The resulting type after concatenation\n     type Output;\n \n     /// Implementation of [`[T]::concat`](../../std/primitive.slice.html#method.concat)\n     #[unstable(feature = \"slice_concat_trait\", issue = \"27747\")]\n-    fn concat(slice: &[Self]) -> Self::Output;\n+    fn concat(slice: &Self) -> Self::Output;\n+}\n+\n+/// Helper trait for [`[T]::join`](../../std/primitive.slice.html#method.join)\n+#[unstable(feature = \"slice_concat_trait\", issue = \"27747\")]\n+pub trait Join<Separator> {\n+    #[unstable(feature = \"slice_concat_trait\", issue = \"27747\")]\n+    /// The resulting type after concatenation\n+    type Output;\n \n     /// Implementation of [`[T]::join`](../../std/primitive.slice.html#method.join)\n     #[unstable(feature = \"slice_concat_trait\", issue = \"27747\")]\n-    fn join(slice: &[Self], sep: &Separator) -> Self::Output;\n+    fn join(slice: &Self, sep: Separator) -> Self::Output;\n }\n \n-#[unstable(feature = \"slice_concat_ext\",\n-           reason = \"trait should not have to exist\",\n-           issue = \"27747\")]\n-impl<T: Clone, V: Borrow<[T]>> SliceConcat<T> for V {\n+#[unstable(feature = \"slice_concat_ext\", issue = \"27747\")]\n+impl<T: Clone, V: Borrow<[T]>> Concat<T> for [V] {\n     type Output = Vec<T>;\n \n-    fn concat(slice: &[Self]) -> Vec<T> {\n+    fn concat(slice: &Self) -> Vec<T> {\n         let size = slice.iter().map(|slice| slice.borrow().len()).sum();\n         let mut result = Vec::with_capacity(size);\n         for v in slice {\n             result.extend_from_slice(v.borrow())\n         }\n         result\n     }\n+}\n+\n+#[unstable(feature = \"slice_concat_ext\", issue = \"27747\")]\n+impl<T: Clone, V: Borrow<[T]>> Join<&T> for [V] {\n+    type Output = Vec<T>;\n \n-    fn join(slice: &[Self], sep: &T) -> Vec<T> {\n+    fn join(slice: &Self, sep: &T) -> Vec<T> {\n         let mut iter = slice.iter();\n         let first = match iter.next() {\n             Some(first) => first,\n             None => return vec![],\n         };\n-        let size = slice.iter().map(|slice| slice.borrow().len()).sum::<usize>() + slice.len() - 1;\n+        let size = slice.iter().map(|v| v.borrow().len()).sum::<usize>() + slice.len() - 1;\n         let mut result = Vec::with_capacity(size);\n         result.extend_from_slice(first.borrow());\n \n@@ -628,6 +667,29 @@ impl<T: Clone, V: Borrow<[T]>> SliceConcat<T> for V {\n     }\n }\n \n+#[unstable(feature = \"slice_concat_ext\", issue = \"27747\")]\n+impl<T: Clone, V: Borrow<[T]>> Join<&[T]> for [V] {\n+    type Output = Vec<T>;\n+\n+    fn join(slice: &Self, sep: &[T]) -> Vec<T> {\n+        let mut iter = slice.iter();\n+        let first = match iter.next() {\n+            Some(first) => first,\n+            None => return vec![],\n+        };\n+        let size = slice.iter().map(|v| v.borrow().len()).sum::<usize>() +\n+            sep.len() * (slice.len() - 1);\n+        let mut result = Vec::with_capacity(size);\n+        result.extend_from_slice(first.borrow());\n+\n+        for v in iter {\n+            result.extend_from_slice(sep);\n+            result.extend_from_slice(v.borrow())\n+        }\n+        result\n+    }\n+}\n+\n ////////////////////////////////////////////////////////////////////////////////\n // Standard trait implementations for slices\n ////////////////////////////////////////////////////////////////////////////////"}, {"sha": "9a1342c30d502b57130c632b4c3011faf1420f40", "filename": "src/liballoc/str.rs", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/008d9d0feaec231fa2fe16468d2d44714e765700/src%2Fliballoc%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/008d9d0feaec231fa2fe16468d2d44714e765700/src%2Fliballoc%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fstr.rs?ref=008d9d0feaec231fa2fe16468d2d44714e765700", "patch": "@@ -37,7 +37,7 @@ use core::unicode::conversions;\n \n use crate::borrow::ToOwned;\n use crate::boxed::Box;\n-use crate::slice::{SliceConcat, SliceIndex};\n+use crate::slice::{Concat, Join, SliceIndex};\n use crate::string::String;\n use crate::vec::Vec;\n \n@@ -71,17 +71,22 @@ pub use core::str::SplitAsciiWhitespace;\n #[stable(feature = \"str_escape\", since = \"1.34.0\")]\n pub use core::str::{EscapeDebug, EscapeDefault, EscapeUnicode};\n \n-#[unstable(feature = \"slice_concat_ext\",\n-           reason = \"trait should not have to exist\",\n-           issue = \"27747\")]\n-impl<S: Borrow<str>> SliceConcat<str> for S {\n+/// Note: `str` in `Concat<str>` is not meaningful here.\n+/// This type parameter of the trait only exists to enable another impl.\n+#[unstable(feature = \"slice_concat_ext\", issue = \"27747\")]\n+impl<S: Borrow<str>> Concat<str> for [S] {\n     type Output = String;\n \n-    fn concat(slice: &[Self]) -> String {\n-        Self::join(slice, \"\")\n+    fn concat(slice: &Self) -> String {\n+        Join::join(slice, \"\")\n     }\n+}\n+\n+#[unstable(feature = \"slice_concat_ext\", issue = \"27747\")]\n+impl<S: Borrow<str>> Join<&str> for [S] {\n+    type Output = String;\n \n-    fn join(slice: &[Self], sep: &str) -> String {\n+    fn join(slice: &Self, sep: &str) -> String {\n         unsafe {\n             String::from_utf8_unchecked( join_generic_copy(slice, sep.as_bytes()) )\n         }"}]}