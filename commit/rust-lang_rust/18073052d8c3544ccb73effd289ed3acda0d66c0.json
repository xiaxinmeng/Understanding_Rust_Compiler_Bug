{"sha": "18073052d8c3544ccb73effd289ed3acda0d66c0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE4MDczMDUyZDhjMzU0NGNjYjczZWZmZDI4OWVkM2FjZGEwZDY2YzA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-07-18T10:42:23Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-07-18T10:42:23Z"}, "message": "Auto merge of #86698 - cjgillot:modc, r=estebank\n\nMove OnDiskCache to rustc_query_impl.\n\nThis should be the last remnant of the query implementation that was still in rustc_middle.", "tree": {"sha": "39d99224bf4d2b0cd5c89cc48eb8d51287b7c460", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/39d99224bf4d2b0cd5c89cc48eb8d51287b7c460"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/18073052d8c3544ccb73effd289ed3acda0d66c0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/18073052d8c3544ccb73effd289ed3acda0d66c0", "html_url": "https://github.com/rust-lang/rust/commit/18073052d8c3544ccb73effd289ed3acda0d66c0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/18073052d8c3544ccb73effd289ed3acda0d66c0/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5a8a44196b3cf099f8c9b0156bd902eaec0b4e5f", "url": "https://api.github.com/repos/rust-lang/rust/commits/5a8a44196b3cf099f8c9b0156bd902eaec0b4e5f", "html_url": "https://github.com/rust-lang/rust/commit/5a8a44196b3cf099f8c9b0156bd902eaec0b4e5f"}, {"sha": "5b921505ef0892e4d83d0e2743e3e2eecd03d461", "url": "https://api.github.com/repos/rust-lang/rust/commits/5b921505ef0892e4d83d0e2743e3e2eecd03d461", "html_url": "https://github.com/rust-lang/rust/commit/5b921505ef0892e4d83d0e2743e3e2eecd03d461"}], "stats": {"total": 435, "additions": 231, "deletions": 204}, "files": [{"sha": "753853e6acde40290e09e185f6ca75ea36ebd849", "filename": "Cargo.lock", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/18073052d8c3544ccb73effd289ed3acda0d66c0/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/18073052d8c3544ccb73effd289ed3acda0d66c0/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=18073052d8c3544ccb73effd289ed3acda0d66c0", "patch": "@@ -4242,12 +4242,16 @@ version = \"0.0.0\"\n dependencies = [\n  \"measureme\",\n  \"rustc-rayon-core\",\n+ \"rustc_ast\",\n  \"rustc_data_structures\",\n  \"rustc_errors\",\n  \"rustc_hir\",\n+ \"rustc_index\",\n+ \"rustc_macros\",\n  \"rustc_middle\",\n  \"rustc_query_system\",\n  \"rustc_serialize\",\n+ \"rustc_session\",\n  \"rustc_span\",\n  \"tracing\",\n ]"}, {"sha": "437d5596447d7a050dbd9949c990298123ecd80a", "filename": "compiler/rustc_incremental/src/persist/load.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/18073052d8c3544ccb73effd289ed3acda0d66c0/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18073052d8c3544ccb73effd289ed3acda0d66c0/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fload.rs?ref=18073052d8c3544ccb73effd289ed3acda0d66c0", "patch": "@@ -2,7 +2,7 @@\n \n use rustc_data_structures::fx::FxHashMap;\n use rustc_middle::dep_graph::{SerializedDepGraph, WorkProduct, WorkProductId};\n-use rustc_middle::ty::query::OnDiskCache;\n+use rustc_middle::ty::OnDiskCache;\n use rustc_serialize::opaque::Decoder;\n use rustc_serialize::Decodable;\n use rustc_session::Session;\n@@ -198,7 +198,7 @@ pub fn load_dep_graph(sess: &Session) -> DepGraphFuture {\n /// If we are not in incremental compilation mode, returns `None`.\n /// Otherwise, tries to load the query result cache from disk,\n /// creating an empty cache if it could not be loaded.\n-pub fn load_query_result_cache<'a>(sess: &'a Session) -> Option<OnDiskCache<'a>> {\n+pub fn load_query_result_cache<'a, C: OnDiskCache<'a>>(sess: &'a Session) -> Option<C> {\n     if sess.opts.incremental.is_none() {\n         return None;\n     }\n@@ -210,9 +210,7 @@ pub fn load_query_result_cache<'a>(sess: &'a Session) -> Option<OnDiskCache<'a>>\n         &query_cache_path(sess),\n         sess.is_nightly_build(),\n     ) {\n-        LoadResult::Ok { data: (bytes, start_pos) } => {\n-            Some(OnDiskCache::new(sess, bytes, start_pos))\n-        }\n-        _ => Some(OnDiskCache::new_empty(sess.source_map())),\n+        LoadResult::Ok { data: (bytes, start_pos) } => Some(C::new(sess, bytes, start_pos)),\n+        _ => Some(C::new_empty(sess.source_map())),\n     }\n }"}, {"sha": "8393826aa12855d367279be6e8613c0ad7cf050d", "filename": "compiler/rustc_interface/src/interface.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/18073052d8c3544ccb73effd289ed3acda0d66c0/compiler%2Frustc_interface%2Fsrc%2Finterface.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18073052d8c3544ccb73effd289ed3acda0d66c0/compiler%2Frustc_interface%2Fsrc%2Finterface.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Finterface.rs?ref=18073052d8c3544ccb73effd289ed3acda0d66c0", "patch": "@@ -12,6 +12,7 @@ use rustc_errors::{ErrorReported, Handler};\n use rustc_lint::LintStore;\n use rustc_middle::ty;\n use rustc_parse::new_parser_from_source_str;\n+use rustc_query_impl::QueryCtxt;\n use rustc_session::config::{self, ErrorOutputType, Input, OutputFilenames};\n use rustc_session::early_error;\n use rustc_session::lint;\n@@ -233,7 +234,7 @@ pub fn try_print_query_stack(handler: &Handler, num_frames: Option<usize>) {\n     // state if it was responsible for triggering the panic.\n     let i = ty::tls::with_context_opt(|icx| {\n         if let Some(icx) = icx {\n-            icx.tcx.queries.try_print_query_stack(icx.tcx, icx.query, handler, num_frames)\n+            QueryCtxt::from_tcx(icx.tcx).try_print_query_stack(icx.query, handler, num_frames)\n         } else {\n             0\n         }"}, {"sha": "5db027fb5b4734f6ab0be6de711ed6c3abe3d8f1", "filename": "compiler/rustc_interface/src/passes.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/18073052d8c3544ccb73effd289ed3acda0d66c0/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18073052d8c3544ccb73effd289ed3acda0d66c0/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs?ref=18073052d8c3544ccb73effd289ed3acda0d66c0", "patch": "@@ -26,7 +26,7 @@ use rustc_mir_build as mir_build;\n use rustc_parse::{parse_crate_from_file, parse_crate_from_source_str};\n use rustc_passes::{self, hir_stats, layout_test};\n use rustc_plugin_impl as plugin;\n-use rustc_query_impl::Queries as TcxQueries;\n+use rustc_query_impl::{OnDiskCache, Queries as TcxQueries};\n use rustc_resolve::{Resolver, ResolverArenas};\n use rustc_serialize::json;\n use rustc_session::config::{CrateType, Input, OutputFilenames, OutputType, PpMode, PpSourceMode};\n@@ -819,7 +819,9 @@ pub fn create_global_ctxt<'tcx>(\n         callback(sess, &mut local_providers, &mut extern_providers);\n     }\n \n-    let queries = queries.get_or_init(|| TcxQueries::new(local_providers, extern_providers));\n+    let queries = queries.get_or_init(|| {\n+        TcxQueries::new(local_providers, extern_providers, query_result_on_disk_cache)\n+    });\n \n     let gcx = sess.time(\"setup_global_ctxt\", || {\n         global_ctxt.get_or_init(move || {\n@@ -830,7 +832,7 @@ pub fn create_global_ctxt<'tcx>(\n                 resolver_outputs,\n                 krate,\n                 dep_graph,\n-                query_result_on_disk_cache,\n+                queries.on_disk_cache.as_ref().map(OnDiskCache::as_dyn),\n                 queries.as_dyn(),\n                 &crate_name,\n                 outputs,"}, {"sha": "8b41a0ff1769377376762984d9a9b15e5e9fc430", "filename": "compiler/rustc_interface/src/util.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/18073052d8c3544ccb73effd289ed3acda0d66c0/compiler%2Frustc_interface%2Fsrc%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18073052d8c3544ccb73effd289ed3acda0d66c0/compiler%2Frustc_interface%2Fsrc%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Futil.rs?ref=18073052d8c3544ccb73effd289ed3acda0d66c0", "patch": "@@ -10,6 +10,8 @@ use rustc_errors::registry::Registry;\n use rustc_metadata::dynamic_lib::DynamicLibrary;\n #[cfg(parallel_compiler)]\n use rustc_middle::ty::tls;\n+#[cfg(parallel_compiler)]\n+use rustc_query_impl::QueryCtxt;\n use rustc_resolve::{self, Resolver};\n use rustc_session as session;\n use rustc_session::config::{self, CrateType};\n@@ -176,7 +178,7 @@ unsafe fn handle_deadlock() {\n     thread::spawn(move || {\n         tls::enter_context(icx, |_| {\n             rustc_span::set_session_globals_then(session_globals, || {\n-                tls::with(|tcx| tcx.queries.deadlock(tcx, &registry))\n+                tls::with(|tcx| QueryCtxt::from_tcx(tcx).deadlock(&registry))\n             })\n         });\n     });"}, {"sha": "dcd36d61bc6a0e41ea6c534657761bc9dd93ec21", "filename": "compiler/rustc_macros/src/query.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/18073052d8c3544ccb73effd289ed3acda0d66c0/compiler%2Frustc_macros%2Fsrc%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18073052d8c3544ccb73effd289ed3acda0d66c0/compiler%2Frustc_macros%2Fsrc%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fquery.rs?ref=18073052d8c3544ccb73effd289ed3acda0d66c0", "patch": "@@ -367,7 +367,7 @@ fn add_query_description_impl(\n                     tcx: QueryCtxt<'tcx>,\n                     id: SerializedDepNodeIndex\n                 ) -> Option<Self::Value> {\n-                    tcx.on_disk_cache.as_ref()?.try_load_query_result(*tcx, id)\n+                    tcx.on_disk_cache().as_ref()?.try_load_query_result(*tcx, id)\n                 }\n             }\n         };"}, {"sha": "5373169bda7abb36cecad68419d16bf036f93452", "filename": "compiler/rustc_metadata/src/creader.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/18073052d8c3544ccb73effd289ed3acda0d66c0/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18073052d8c3544ccb73effd289ed3acda0d66c0/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs?ref=18073052d8c3544ccb73effd289ed3acda0d66c0", "patch": "@@ -131,7 +131,10 @@ impl<'a> std::fmt::Debug for CrateDump<'a> {\n \n impl CStore {\n     pub fn from_tcx(tcx: TyCtxt<'_>) -> &CStore {\n-        tcx.cstore_as_any().downcast_ref::<CStore>().expect(\"`tcx.cstore` is not a `CStore`\")\n+        tcx.cstore_untracked()\n+            .as_any()\n+            .downcast_ref::<CStore>()\n+            .expect(\"`tcx.cstore` is not a `CStore`\")\n     }\n \n     fn alloc_new_crate_num(&mut self) -> CrateNum {"}, {"sha": "cb99ae19ee72ea65a262fb052ec4341ffedabb2e", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/18073052d8c3544ccb73effd289ed3acda0d66c0/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18073052d8c3544ccb73effd289ed3acda0d66c0/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=18073052d8c3544ccb73effd289ed3acda0d66c0", "patch": "@@ -724,7 +724,7 @@ rustc_queries! {\n         cache_on_disk_if { true }\n         load_cached(tcx, id) {\n             let typeck_results: Option<ty::TypeckResults<'tcx>> = tcx\n-                .on_disk_cache.as_ref()\n+                .on_disk_cache().as_ref()\n                 .and_then(|c| c.try_load_query_result(*tcx, id));\n \n             typeck_results.map(|x| &*tcx.arena.alloc(x))"}, {"sha": "b84058011066f3acaf71b717598a2eddb38e0dc2", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 50, "deletions": 10, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/18073052d8c3544ccb73effd289ed3acda0d66c0/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18073052d8c3544ccb73effd289ed3acda0d66c0/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=18073052d8c3544ccb73effd289ed3acda0d66c0", "patch": "@@ -1,7 +1,7 @@\n //! Type context book-keeping.\n \n use crate::arena::Arena;\n-use crate::dep_graph::DepGraph;\n+use crate::dep_graph::{DepGraph, DepNode};\n use crate::hir::place::Place as HirPlace;\n use crate::ich::{NodeIdHashingMode, StableHashingContext};\n use crate::infer::canonical::{Canonical, CanonicalVarInfo, CanonicalVarInfos};\n@@ -14,7 +14,7 @@ use crate::mir::interpret::{self, AllocId, Allocation, ConstValue, Scalar};\n use crate::mir::{Body, Field, Local, Place, PlaceElem, ProjectionKind, Promoted};\n use crate::thir::Thir;\n use crate::traits;\n-use crate::ty::query::{self, OnDiskCache, TyCtxtAt};\n+use crate::ty::query::{self, TyCtxtAt};\n use crate::ty::subst::{GenericArg, GenericArgKind, InternalSubsts, Subst, SubstsRef, UserSubsts};\n use crate::ty::TyKind::*;\n use crate::ty::{\n@@ -52,8 +52,8 @@ use rustc_session::config::{BorrowckMode, CrateType, OutputFilenames};\n use rustc_session::lint::{Level, Lint};\n use rustc_session::Limit;\n use rustc_session::Session;\n-use rustc_span::def_id::StableCrateId;\n-use rustc_span::source_map::MultiSpan;\n+use rustc_span::def_id::{DefPathHash, StableCrateId};\n+use rustc_span::source_map::{MultiSpan, SourceMap};\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::{Span, DUMMY_SP};\n use rustc_target::abi::{Layout, TargetDataLayout, VariantIdx};\n@@ -71,6 +71,40 @@ use std::mem;\n use std::ops::{Bound, Deref};\n use std::sync::Arc;\n \n+pub trait OnDiskCache<'tcx>: rustc_data_structures::sync::Sync {\n+    /// Creates a new `OnDiskCache` instance from the serialized data in `data`.\n+    fn new(sess: &'tcx Session, data: Vec<u8>, start_pos: usize) -> Self\n+    where\n+        Self: Sized;\n+\n+    fn new_empty(source_map: &'tcx SourceMap) -> Self\n+    where\n+        Self: Sized;\n+\n+    /// Converts a `DefPathHash` to its corresponding `DefId` in the current compilation\n+    /// session, if it still exists. This is used during incremental compilation to\n+    /// turn a deserialized `DefPathHash` into its current `DefId`.\n+    fn def_path_hash_to_def_id(\n+        &self,\n+        tcx: TyCtxt<'tcx>,\n+        def_path_hash: DefPathHash,\n+    ) -> Option<DefId>;\n+\n+    /// If the given `dep_node`'s hash still exists in the current compilation,\n+    /// and its current `DefId` is foreign, calls `store_foreign_def_id` with it.\n+    ///\n+    /// Normally, `store_foreign_def_id_hash` can be called directly by\n+    /// the dependency graph when we construct a `DepNode`. However,\n+    /// when we re-use a deserialized `DepNode` from the previous compilation\n+    /// session, we only have the `DefPathHash` available. This method is used\n+    /// to that any `DepNode` that we re-use has a `DefPathHash` -> `RawId` written\n+    /// out for usage in the next compilation session.\n+    fn register_reused_dep_node(&self, tcx: TyCtxt<'tcx>, dep_node: &DepNode);\n+    fn store_foreign_def_id_hash(&self, def_id: DefId, hash: DefPathHash);\n+\n+    fn serialize(&self, tcx: TyCtxt<'tcx>, encoder: &mut FileEncoder) -> FileEncodeResult;\n+}\n+\n /// A type that is not publicly constructable. This prevents people from making [`TyKind::Error`]s\n /// except through the error-reporting functions on a [`tcx`][TyCtxt].\n #[derive(Copy, Clone, Debug, Eq, Hash, PartialEq, PartialOrd, Ord)]\n@@ -993,7 +1027,7 @@ pub struct GlobalCtxt<'tcx> {\n     /// Do not access this directly. It is only meant to be used by\n     /// `DepGraph::try_mark_green()` and the query infrastructure.\n     /// This is `None` if we are not incremental compilation mode\n-    pub on_disk_cache: Option<OnDiskCache<'tcx>>,\n+    pub on_disk_cache: Option<&'tcx dyn OnDiskCache<'tcx>>,\n \n     pub queries: &'tcx dyn query::QueryEngine<'tcx>,\n     pub query_caches: query::QueryCaches<'tcx>,\n@@ -1141,7 +1175,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         resolutions: ty::ResolverOutputs,\n         krate: &'tcx hir::Crate<'tcx>,\n         dep_graph: DepGraph,\n-        on_disk_cache: Option<query::OnDiskCache<'tcx>>,\n+        on_disk_cache: Option<&'tcx dyn OnDiskCache<'tcx>>,\n         queries: &'tcx dyn query::QueryEngine<'tcx>,\n         crate_name: &str,\n         output_filenames: OutputFilenames,\n@@ -1308,10 +1342,16 @@ impl<'tcx> TyCtxt<'tcx> {\n         self.untracked_resolutions.cstore.encode_metadata(self)\n     }\n \n-    // Note that this is *untracked* and should only be used within the query\n-    // system if the result is otherwise tracked through queries\n-    pub fn cstore_as_any(self) -> &'tcx dyn Any {\n-        self.untracked_resolutions.cstore.as_any()\n+    /// Note that this is *untracked* and should only be used within the query\n+    /// system if the result is otherwise tracked through queries\n+    pub fn cstore_untracked(self) -> &'tcx ty::CrateStoreDyn {\n+        &*self.untracked_resolutions.cstore\n+    }\n+\n+    /// Note that this is *untracked* and should only be used within the query\n+    /// system if the result is otherwise tracked through queries\n+    pub fn definitions_untracked(self) -> &'tcx hir::definitions::Definitions {\n+        &self.untracked_resolutions.definitions\n     }\n \n     #[inline(always)]"}, {"sha": "a6aff424790695b5fe169ffa61b4a14cfb5c2726", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/18073052d8c3544ccb73effd289ed3acda0d66c0/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18073052d8c3544ccb73effd289ed3acda0d66c0/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=18073052d8c3544ccb73effd289ed3acda0d66c0", "patch": "@@ -59,7 +59,7 @@ pub use self::consts::{Const, ConstInt, ConstKind, InferConst, ScalarInt, Uneval\n pub use self::context::{\n     tls, CanonicalUserType, CanonicalUserTypeAnnotation, CanonicalUserTypeAnnotations,\n     CtxtInterners, DelaySpanBugEmitted, FreeRegionInfo, GeneratorInteriorTypeCause, GlobalCtxt,\n-    Lift, TyCtxt, TypeckResults, UserType, UserTypeAnnotationIndex,\n+    Lift, OnDiskCache, TyCtxt, TypeckResults, UserType, UserTypeAnnotationIndex,\n };\n pub use self::instance::{Instance, InstanceDef};\n pub use self::list::List;"}, {"sha": "15a8888ee65eda376002df70eb59b33098f97e69", "filename": "compiler/rustc_middle/src/ty/query.rs", "status": "renamed", "additions": 2, "deletions": 24, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/18073052d8c3544ccb73effd289ed3acda0d66c0/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18073052d8c3544ccb73effd289ed3acda0d66c0/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs?ref=18073052d8c3544ccb73effd289ed3acda0d66c0", "patch": "@@ -38,14 +38,13 @@ use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexMap};\n use rustc_data_structures::steal::Steal;\n use rustc_data_structures::svh::Svh;\n use rustc_data_structures::sync::Lrc;\n-use rustc_errors::{ErrorReported, Handler};\n+use rustc_errors::ErrorReported;\n use rustc_hir as hir;\n use rustc_hir::def::DefKind;\n use rustc_hir::def_id::{CrateNum, DefId, DefIdMap, DefIdSet, LocalDefId};\n use rustc_hir::lang_items::{LangItem, LanguageItems};\n use rustc_hir::{Crate, ItemLocalId, TraitCandidate};\n use rustc_index::{bit_set::FiniteBitSet, vec::IndexVec};\n-use rustc_serialize::opaque;\n use rustc_session::config::{EntryFnType, OptLevel, OutputFilenames, SymbolManglingVersion};\n use rustc_session::utils::NativeLibKind;\n use rustc_session::Limits;\n@@ -63,9 +62,6 @@ use std::sync::Arc;\n pub(crate) use rustc_query_system::query::QueryJobId;\n use rustc_query_system::query::*;\n \n-pub mod on_disk_cache;\n-pub use self::on_disk_cache::OnDiskCache;\n-\n #[derive(Copy, Clone)]\n pub struct TyCtxtAt<'tcx> {\n     pub tcx: TyCtxt<'tcx>,\n@@ -235,28 +231,10 @@ macro_rules! define_callbacks {\n         }\n \n         pub trait QueryEngine<'tcx>: rustc_data_structures::sync::Sync {\n-            #[cfg(parallel_compiler)]\n-            unsafe fn deadlock(&'tcx self, tcx: TyCtxt<'tcx>, registry: &rustc_rayon_core::Registry);\n-\n-            fn encode_query_results(\n-                &'tcx self,\n-                tcx: TyCtxt<'tcx>,\n-                encoder: &mut on_disk_cache::CacheEncoder<'a, 'tcx, opaque::FileEncoder>,\n-                query_result_index: &mut on_disk_cache::EncodedQueryResultIndex,\n-            ) -> opaque::FileEncodeResult;\n-\n-            fn exec_cache_promotions(&'tcx self, tcx: TyCtxt<'tcx>);\n+            fn as_any(&'tcx self) -> &'tcx dyn std::any::Any;\n \n             fn try_mark_green(&'tcx self, tcx: TyCtxt<'tcx>, dep_node: &dep_graph::DepNode) -> bool;\n \n-            fn try_print_query_stack(\n-                &'tcx self,\n-                tcx: TyCtxt<'tcx>,\n-                query: Option<QueryJobId<dep_graph::DepKind>>,\n-                handler: &Handler,\n-                num_frames: Option<usize>,\n-            ) -> usize;\n-\n             $($(#[$attr])*\n             fn $name(\n                 &'tcx self,", "previous_filename": "compiler/rustc_middle/src/ty/query/mod.rs"}, {"sha": "6a1768b92dbbb33c1cf07e7614158dacff8171df", "filename": "compiler/rustc_query_impl/Cargo.toml", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/18073052d8c3544ccb73effd289ed3acda0d66c0/compiler%2Frustc_query_impl%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/18073052d8c3544ccb73effd289ed3acda0d66c0/compiler%2Frustc_query_impl%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2FCargo.toml?ref=18073052d8c3544ccb73effd289ed3acda0d66c0", "patch": "@@ -11,10 +11,14 @@ doctest = false\n measureme = \"9.0.0\"\n rustc-rayon-core = \"0.3.1\"\n tracing = \"0.1\"\n+rustc_ast = { path = \"../rustc_ast\" }\n rustc_data_structures = { path = \"../rustc_data_structures\" }\n rustc_errors = { path = \"../rustc_errors\" }\n rustc_hir = { path = \"../rustc_hir\" }\n+rustc_index = { path = \"../rustc_index\" }\n+rustc_macros = { path = \"../rustc_macros\" }\n rustc_middle = { path = \"../rustc_middle\" }\n rustc_query_system = { path = \"../rustc_query_system\" }\n-rustc_span = { path = \"../rustc_span\" }\n rustc_serialize = { path = \"../rustc_serialize\" }\n+rustc_session = { path = \"../rustc_session\" }\n+rustc_span = { path = \"../rustc_span\" }"}, {"sha": "5022bf265328a9a3d16d4f256c991f89dcba2a29", "filename": "compiler/rustc_query_impl/src/lib.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/18073052d8c3544ccb73effd289ed3acda0d66c0/compiler%2Frustc_query_impl%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18073052d8c3544ccb73effd289ed3acda0d66c0/compiler%2Frustc_query_impl%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Flib.rs?ref=18073052d8c3544ccb73effd289ed3acda0d66c0", "patch": "@@ -1,26 +1,29 @@\n //! Support for serializing the dep-graph and reloading it.\n \n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\")]\n+#![feature(crate_visibility_modifier)]\n #![feature(in_band_lifetimes)]\n #![feature(nll)]\n #![feature(min_specialization)]\n+#![feature(once_cell)]\n #![feature(rustc_attrs)]\n #![recursion_limit = \"256\"]\n \n+#[macro_use]\n+extern crate rustc_macros;\n #[macro_use]\n extern crate rustc_middle;\n #[macro_use]\n extern crate tracing;\n \n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n-use rustc_errors::{DiagnosticBuilder, Handler};\n+use rustc_errors::DiagnosticBuilder;\n use rustc_middle::dep_graph;\n use rustc_middle::ich::StableHashingContext;\n use rustc_middle::ty::query::{query_keys, query_storage, query_stored, query_values};\n use rustc_middle::ty::query::{Providers, QueryEngine};\n use rustc_middle::ty::{self, TyCtxt};\n-use rustc_serialize::opaque;\n use rustc_span::Span;\n \n #[macro_use]\n@@ -42,7 +45,8 @@ use rustc_query_system::query::QueryAccessors;\n pub use rustc_query_system::query::QueryConfig;\n pub(crate) use rustc_query_system::query::QueryDescription;\n \n-use rustc_middle::ty::query::on_disk_cache;\n+mod on_disk_cache;\n+pub use on_disk_cache::OnDiskCache;\n \n mod profiling_support;\n pub use self::profiling_support::alloc_self_profile_query_strings;"}, {"sha": "b024668d636467fcb7506364a28a1f130dff8021", "filename": "compiler/rustc_query_impl/src/on_disk_cache.rs", "status": "renamed", "additions": 96, "deletions": 114, "changes": 210, "blob_url": "https://github.com/rust-lang/rust/blob/18073052d8c3544ccb73effd289ed3acda0d66c0/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18073052d8c3544ccb73effd289ed3acda0d66c0/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs?ref=18073052d8c3544ccb73effd289ed3acda0d66c0", "patch": "@@ -1,9 +1,4 @@\n-use crate::dep_graph::{DepNode, DepNodeIndex, SerializedDepNodeIndex};\n-use crate::mir::interpret::{AllocDecodingSession, AllocDecodingState};\n-use crate::mir::{self, interpret};\n-use crate::ty::codec::{RefDecodable, TyDecoder, TyEncoder};\n-use crate::ty::context::TyCtxt;\n-use crate::ty::{self, Ty};\n+use crate::QueryCtxt;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexSet};\n use rustc_data_structures::sync::{HashMapExt, Lock, Lrc, OnceCell};\n use rustc_data_structures::thin_vec::ThinVec;\n@@ -12,6 +7,11 @@ use rustc_errors::Diagnostic;\n use rustc_hir::def_id::{CrateNum, DefId, DefIndex, LocalDefId, StableCrateId, LOCAL_CRATE};\n use rustc_hir::definitions::DefPathHash;\n use rustc_index::vec::{Idx, IndexVec};\n+use rustc_middle::dep_graph::{DepNode, DepNodeIndex, SerializedDepNodeIndex};\n+use rustc_middle::mir::interpret::{AllocDecodingSession, AllocDecodingState};\n+use rustc_middle::mir::{self, interpret};\n+use rustc_middle::ty::codec::{RefDecodable, TyDecoder, TyEncoder};\n+use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_query_system::dep_graph::DepContext;\n use rustc_query_system::query::QueryContext;\n use rustc_serialize::{\n@@ -185,9 +185,8 @@ impl EncodedSourceFileId {\n     }\n }\n \n-impl<'sess> OnDiskCache<'sess> {\n-    /// Creates a new `OnDiskCache` instance from the serialized data in `data`.\n-    pub fn new(sess: &'sess Session, data: Vec<u8>, start_pos: usize) -> Self {\n+impl<'sess> rustc_middle::ty::OnDiskCache<'sess> for OnDiskCache<'sess> {\n+    fn new(sess: &'sess Session, data: Vec<u8>, start_pos: usize) -> Self {\n         debug_assert!(sess.opts.incremental.is_some());\n \n         // Wrap in a scope so we can borrow `data`.\n@@ -228,7 +227,7 @@ impl<'sess> OnDiskCache<'sess> {\n         }\n     }\n \n-    pub fn new_empty(source_map: &'sess SourceMap) -> Self {\n+    fn new_empty(source_map: &'sess SourceMap) -> Self {\n         Self {\n             serialized_data: Vec::new(),\n             file_index_to_stable_id: Default::default(),\n@@ -249,11 +248,7 @@ impl<'sess> OnDiskCache<'sess> {\n         }\n     }\n \n-    pub fn serialize<'tcx>(\n-        &self,\n-        tcx: TyCtxt<'tcx>,\n-        encoder: &mut FileEncoder,\n-    ) -> FileEncodeResult {\n+    fn serialize(&self, tcx: TyCtxt<'sess>, encoder: &mut FileEncoder) -> FileEncodeResult {\n         // Serializing the `DepGraph` should not modify it.\n         tcx.dep_graph.with_ignore(|| {\n             // Allocate `SourceFileIndex`es.\n@@ -288,7 +283,7 @@ impl<'sess> OnDiskCache<'sess> {\n             // Do this *before* we clone 'latest_foreign_def_path_hashes', since\n             // loading existing queries may cause us to create new DepNodes, which\n             // may in turn end up invoking `store_foreign_def_id_hash`\n-            tcx.queries.exec_cache_promotions(tcx);\n+            tcx.dep_graph.exec_cache_promotions(QueryCtxt::from_tcx(tcx));\n \n             let latest_foreign_def_path_hashes = self.latest_foreign_def_path_hashes.lock().clone();\n             let hygiene_encode_context = HygieneEncodeContext::default();\n@@ -311,7 +306,7 @@ impl<'sess> OnDiskCache<'sess> {\n             tcx.sess.time(\"encode_query_results\", || -> FileEncodeResult {\n                 let enc = &mut encoder;\n                 let qri = &mut query_result_index;\n-                tcx.queries.encode_query_results(tcx, enc, qri)\n+                QueryCtxt::from_tcx(tcx).encode_query_results(enc, qri)\n             })?;\n \n             // Encode diagnostics.\n@@ -411,6 +406,88 @@ impl<'sess> OnDiskCache<'sess> {\n         })\n     }\n \n+    fn def_path_hash_to_def_id(&self, tcx: TyCtxt<'tcx>, hash: DefPathHash) -> Option<DefId> {\n+        let mut cache = self.def_path_hash_to_def_id_cache.lock();\n+        match cache.entry(hash) {\n+            Entry::Occupied(e) => *e.get(),\n+            Entry::Vacant(e) => {\n+                debug!(\"def_path_hash_to_def_id({:?})\", hash);\n+                // Check if the `DefPathHash` corresponds to a definition in the current\n+                // crate\n+                if let Some(def_id) =\n+                    tcx.definitions_untracked().local_def_path_hash_to_def_id(hash)\n+                {\n+                    let def_id = def_id.to_def_id();\n+                    e.insert(Some(def_id));\n+                    return Some(def_id);\n+                }\n+                // This `raw_def_id` represents the `DefId` of this `DefPathHash` in\n+                // the *previous* compliation session. The `DefPathHash` includes the\n+                // owning crate, so if the corresponding definition still exists in the\n+                // current compilation session, the crate is guaranteed to be the same\n+                // (otherwise, we would compute a different `DefPathHash`).\n+                let raw_def_id = self.get_raw_def_id(&hash)?;\n+                debug!(\"def_path_hash_to_def_id({:?}): raw_def_id = {:?}\", hash, raw_def_id);\n+                // If the owning crate no longer exists, the corresponding definition definitely\n+                // no longer exists.\n+                let krate = self.try_remap_cnum(tcx, hash.stable_crate_id())?;\n+                debug!(\"def_path_hash_to_def_id({:?}): krate = {:?}\", hash, krate);\n+                // If our `DefPathHash` corresponded to a definition in the local crate,\n+                // we should have either found it in `local_def_path_hash_to_def_id`, or\n+                // never attempted to load it in the first place. Any query result or `DepNode`\n+                // that references a local `DefId` should depend on some HIR-related `DepNode`.\n+                // If a local definition is removed/modified such that its old `DefPathHash`\n+                // no longer has a corresponding definition, that HIR-related `DepNode` should\n+                // end up red. This should prevent us from ever calling\n+                // `tcx.def_path_hash_to_def_id`, since we'll end up recomputing any\n+                // queries involved.\n+                debug_assert_ne!(krate, LOCAL_CRATE);\n+                // Try to find a definition in the current session, using the previous `DefIndex`\n+                // as an initial guess.\n+                let opt_def_id =\n+                    tcx.cstore_untracked().def_path_hash_to_def_id(krate, raw_def_id.index, hash);\n+                debug!(\"def_path_to_def_id({:?}): opt_def_id = {:?}\", hash, opt_def_id);\n+                e.insert(opt_def_id);\n+                opt_def_id\n+            }\n+        }\n+    }\n+\n+    fn register_reused_dep_node(&self, tcx: TyCtxt<'sess>, dep_node: &DepNode) {\n+        // For reused dep nodes, we only need to store the mapping if the node\n+        // is one whose query key we can reconstruct from the hash. We use the\n+        // mapping to aid that reconstruction in the next session. While we also\n+        // use it to decode `DefId`s we encoded in the cache as `DefPathHashes`,\n+        // they're already registered during `DefId` encoding.\n+        if dep_node.kind.can_reconstruct_query_key() {\n+            let hash = DefPathHash(dep_node.hash.into());\n+\n+            // We can't simply copy the `RawDefId` from `foreign_def_path_hashes` to\n+            // `latest_foreign_def_path_hashes`, since the `RawDefId` might have\n+            // changed in the current compilation session (e.g. we've added/removed crates,\n+            // or added/removed definitions before/after the target definition).\n+            if let Some(def_id) = self.def_path_hash_to_def_id(tcx, hash) {\n+                if !def_id.is_local() {\n+                    self.store_foreign_def_id_hash(def_id, hash);\n+                }\n+            }\n+        }\n+    }\n+\n+    fn store_foreign_def_id_hash(&self, def_id: DefId, hash: DefPathHash) {\n+        // We may overwrite an existing entry, but it will have the same value,\n+        // so it's fine\n+        self.latest_foreign_def_path_hashes\n+            .lock()\n+            .insert(hash, RawDefId { krate: def_id.krate.as_u32(), index: def_id.index.as_u32() });\n+    }\n+}\n+\n+impl<'sess> OnDiskCache<'sess> {\n+    pub fn as_dyn(&self) -> &dyn rustc_middle::ty::OnDiskCache<'sess> {\n+        self as _\n+    }\n+\n     /// Loads a diagnostic emitted during the previous compilation session.\n     pub fn load_diagnostics(\n         &self,\n@@ -449,44 +526,6 @@ impl<'sess> OnDiskCache<'sess> {\n         cnum_map.get(&stable_crate_id).copied()\n     }\n \n-    pub(crate) fn store_foreign_def_id_hash(&self, def_id: DefId, hash: DefPathHash) {\n-        // We may overwrite an existing entry, but it will have the same value,\n-        // so it's fine\n-        self.latest_foreign_def_path_hashes\n-            .lock()\n-            .insert(hash, RawDefId { krate: def_id.krate.as_u32(), index: def_id.index.as_u32() });\n-    }\n-\n-    /// If the given `dep_node`'s hash still exists in the current compilation,\n-    /// and its current `DefId` is foreign, calls `store_foreign_def_id` with it.\n-    ///\n-    /// Normally, `store_foreign_def_id_hash` can be called directly by\n-    /// the dependency graph when we construct a `DepNode`. However,\n-    /// when we re-use a deserialized `DepNode` from the previous compilation\n-    /// session, we only have the `DefPathHash` available. This method is used\n-    /// to that any `DepNode` that we re-use has a `DefPathHash` -> `RawId` written\n-    /// out for usage in the next compilation session.\n-    pub fn register_reused_dep_node(&self, tcx: TyCtxt<'tcx>, dep_node: &DepNode) {\n-        // For reused dep nodes, we only need to store the mapping if the node\n-        // is one whose query key we can reconstruct from the hash. We use the\n-        // mapping to aid that reconstruction in the next session. While we also\n-        // use it to decode `DefId`s we encoded in the cache as `DefPathHashes`,\n-        // they're already registered during `DefId` encoding.\n-        if dep_node.kind.can_reconstruct_query_key() {\n-            let hash = DefPathHash(dep_node.hash.into());\n-\n-            // We can't simply copy the `RawDefId` from `foreign_def_path_hashes` to\n-            // `latest_foreign_def_path_hashes`, since the `RawDefId` might have\n-            // changed in the current compilation session (e.g. we've added/removed crates,\n-            // or added/removed definitions before/after the target definition).\n-            if let Some(def_id) = self.def_path_hash_to_def_id(tcx, hash) {\n-                if !def_id.is_local() {\n-                    self.store_foreign_def_id_hash(def_id, hash);\n-                }\n-            }\n-        }\n-    }\n-\n     /// Returns the cached query result if there is something in the cache for\n     /// the given `SerializedDepNodeIndex`; otherwise returns `None`.\n     pub fn try_load_query_result<'tcx, T>(\n@@ -579,63 +618,6 @@ impl<'sess> OnDiskCache<'sess> {\n                 .collect()\n         })\n     }\n-\n-    /// Converts a `DefPathHash` to its corresponding `DefId` in the current compilation\n-    /// session, if it still exists. This is used during incremental compilation to\n-    /// turn a deserialized `DefPathHash` into its current `DefId`.\n-    pub(crate) fn def_path_hash_to_def_id(\n-        &self,\n-        tcx: TyCtxt<'tcx>,\n-        hash: DefPathHash,\n-    ) -> Option<DefId> {\n-        let mut cache = self.def_path_hash_to_def_id_cache.lock();\n-        match cache.entry(hash) {\n-            Entry::Occupied(e) => *e.get(),\n-            Entry::Vacant(e) => {\n-                debug!(\"def_path_hash_to_def_id({:?})\", hash);\n-                // Check if the `DefPathHash` corresponds to a definition in the current\n-                // crate\n-                if let Some(def_id) =\n-                    tcx.untracked_resolutions.definitions.local_def_path_hash_to_def_id(hash)\n-                {\n-                    let def_id = def_id.to_def_id();\n-                    e.insert(Some(def_id));\n-                    return Some(def_id);\n-                }\n-                // This `raw_def_id` represents the `DefId` of this `DefPathHash` in\n-                // the *previous* compliation session. The `DefPathHash` includes the\n-                // owning crate, so if the corresponding definition still exists in the\n-                // current compilation session, the crate is guaranteed to be the same\n-                // (otherwise, we would compute a different `DefPathHash`).\n-                let raw_def_id = self.get_raw_def_id(&hash)?;\n-                debug!(\"def_path_hash_to_def_id({:?}): raw_def_id = {:?}\", hash, raw_def_id);\n-                // If the owning crate no longer exists, the corresponding definition definitely\n-                // no longer exists.\n-                let krate = self.try_remap_cnum(tcx, hash.stable_crate_id())?;\n-                debug!(\"def_path_hash_to_def_id({:?}): krate = {:?}\", hash, krate);\n-                // If our `DefPathHash` corresponded to a definition in the local crate,\n-                // we should have either found it in `local_def_path_hash_to_def_id`, or\n-                // never attempted to load it in the first place. Any query result or `DepNode`\n-                // that references a local `DefId` should depend on some HIR-related `DepNode`.\n-                // If a local definition is removed/modified such that its old `DefPathHash`\n-                // no longer has a corresponding definition, that HIR-related `DepNode` should\n-                // end up red. This should prevent us from ever calling\n-                // `tcx.def_path_hash_to_def_id`, since we'll end up recomputing any\n-                // queries involved.\n-                debug_assert_ne!(krate, LOCAL_CRATE);\n-                // Try to find a definition in the current session, using the previous `DefIndex`\n-                // as an initial guess.\n-                let opt_def_id = tcx.untracked_resolutions.cstore.def_path_hash_to_def_id(\n-                    krate,\n-                    raw_def_id.index,\n-                    hash,\n-                );\n-                debug!(\"def_path_to_def_id({:?}): opt_def_id = {:?}\", hash, opt_def_id);\n-                e.insert(opt_def_id);\n-                opt_def_id\n-            }\n-        }\n-    }\n }\n \n //- DECODING -------------------------------------------------------------------\n@@ -776,7 +758,7 @@ impl<'a, 'tcx> TyDecoder<'tcx> for CacheDecoder<'a, 'tcx> {\n     }\n }\n \n-crate::implement_ty_decoder!(CacheDecoder<'a, 'tcx>);\n+rustc_middle::implement_ty_decoder!(CacheDecoder<'a, 'tcx>);\n \n // This ensures that the `Decodable<opaque::Decoder>::decode` specialization for `Vec<u8>` is used\n // when a `CacheDecoder` is passed to `Decodable::decode`. Unfortunately, we have to manually opt\n@@ -827,7 +809,7 @@ impl<'a, 'tcx> Decodable<CacheDecoder<'a, 'tcx>> for ExpnId {\n             rustc_span::hygiene::register_local_expn_id(data, hash)\n         } else {\n             let index_guess = decoder.foreign_expn_data[&hash];\n-            decoder.tcx.untracked_resolutions.cstore.expn_hash_to_expn_id(krate, index_guess, hash)\n+            decoder.tcx.cstore_untracked().expn_hash_to_expn_id(krate, index_guess, hash)\n         };\n \n         #[cfg(debug_assertions)]", "previous_filename": "compiler/rustc_middle/src/ty/query/on_disk_cache.rs"}, {"sha": "58c1b57dbb949fac2a7aecb6915e7bc16268c424", "filename": "compiler/rustc_query_impl/src/plumbing.rs", "status": "modified", "additions": 46, "deletions": 37, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/18073052d8c3544ccb73effd289ed3acda0d66c0/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18073052d8c3544ccb73effd289ed3acda0d66c0/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs?ref=18073052d8c3544ccb73effd289ed3acda0d66c0", "patch": "@@ -2,24 +2,25 @@\n //! generate the actual methods on tcx which find and execute the provider,\n //! manage the caches, and so forth.\n \n-use super::queries;\n+use crate::{on_disk_cache, queries, Queries};\n use rustc_middle::dep_graph::{DepKind, DepNode, DepNodeIndex, SerializedDepNodeIndex};\n-use rustc_middle::ty::query::on_disk_cache;\n use rustc_middle::ty::tls::{self, ImplicitCtxt};\n use rustc_middle::ty::{self, TyCtxt};\n use rustc_query_system::dep_graph::HasDepContext;\n use rustc_query_system::query::{QueryContext, QueryDescription, QueryJobId, QueryMap};\n \n use rustc_data_structures::sync::Lock;\n use rustc_data_structures::thin_vec::ThinVec;\n-use rustc_errors::Diagnostic;\n+use rustc_errors::{Diagnostic, Handler};\n use rustc_serialize::opaque;\n use rustc_span::def_id::LocalDefId;\n \n+use std::any::Any;\n+\n #[derive(Copy, Clone)]\n pub struct QueryCtxt<'tcx> {\n     pub tcx: TyCtxt<'tcx>,\n-    pub queries: &'tcx super::Queries<'tcx>,\n+    pub queries: &'tcx Queries<'tcx>,\n }\n \n impl<'tcx> std::ops::Deref for QueryCtxt<'tcx> {\n@@ -83,14 +84,15 @@ impl QueryContext for QueryCtxt<'tcx> {\n \n     // Interactions with on_disk_cache\n     fn load_diagnostics(&self, prev_dep_node_index: SerializedDepNodeIndex) -> Vec<Diagnostic> {\n-        self.on_disk_cache\n+        self.queries\n+            .on_disk_cache\n             .as_ref()\n             .map(|c| c.load_diagnostics(**self, prev_dep_node_index))\n             .unwrap_or_default()\n     }\n \n     fn store_diagnostics(&self, dep_node_index: DepNodeIndex, diagnostics: ThinVec<Diagnostic>) {\n-        if let Some(c) = self.on_disk_cache.as_ref() {\n+        if let Some(c) = self.queries.on_disk_cache.as_ref() {\n             c.store_diagnostics(dep_node_index, diagnostics)\n         }\n     }\n@@ -100,7 +102,7 @@ impl QueryContext for QueryCtxt<'tcx> {\n         dep_node_index: DepNodeIndex,\n         diagnostics: ThinVec<Diagnostic>,\n     ) {\n-        if let Some(c) = self.on_disk_cache.as_ref() {\n+        if let Some(c) = self.queries.on_disk_cache.as_ref() {\n             c.store_diagnostics_for_anon_node(dep_node_index, diagnostics)\n         }\n     }\n@@ -137,6 +139,27 @@ impl QueryContext for QueryCtxt<'tcx> {\n }\n \n impl<'tcx> QueryCtxt<'tcx> {\n+    #[inline]\n+    pub fn from_tcx(tcx: TyCtxt<'tcx>) -> Self {\n+        let queries = tcx.queries.as_any();\n+        let queries = unsafe {\n+            let queries = std::mem::transmute::<&dyn Any, &dyn Any>(queries);\n+            let queries = queries.downcast_ref().unwrap();\n+            let queries = std::mem::transmute::<&Queries<'_>, &Queries<'_>>(queries);\n+            queries\n+        };\n+        QueryCtxt { tcx, queries }\n+    }\n+\n+    crate fn on_disk_cache(self) -> Option<&'tcx on_disk_cache::OnDiskCache<'tcx>> {\n+        self.queries.on_disk_cache.as_ref()\n+    }\n+\n+    #[cfg(parallel_compiler)]\n+    pub unsafe fn deadlock(self, registry: &rustc_rayon_core::Registry) {\n+        rustc_query_system::query::deadlock(self, registry)\n+    }\n+\n     pub(super) fn encode_query_results(\n         self,\n         encoder: &mut on_disk_cache::CacheEncoder<'a, 'tcx, opaque::FileEncoder>,\n@@ -158,6 +181,15 @@ impl<'tcx> QueryCtxt<'tcx> {\n \n         Ok(())\n     }\n+\n+    pub fn try_print_query_stack(\n+        self,\n+        query: Option<QueryJobId<DepKind>>,\n+        handler: &Handler,\n+        num_frames: Option<usize>,\n+    ) -> usize {\n+        rustc_query_system::query::print_query_stack(self, query, handler, num_frames)\n+    }\n }\n \n /// This struct stores metadata about each Query.\n@@ -462,6 +494,8 @@ macro_rules! define_queries_struct {\n             local_providers: Box<Providers>,\n             extern_providers: Box<Providers>,\n \n+            pub on_disk_cache: Option<OnDiskCache<$tcx>>,\n+\n             $($(#[$attr])*  $name: QueryState<\n                 crate::dep_graph::DepKind,\n                 query_keys::$name<$tcx>,\n@@ -472,10 +506,12 @@ macro_rules! define_queries_struct {\n             pub fn new(\n                 local_providers: Providers,\n                 extern_providers: Providers,\n+                on_disk_cache: Option<OnDiskCache<$tcx>>,\n             ) -> Self {\n                 Queries {\n                     local_providers: Box::new(local_providers),\n                     extern_providers: Box::new(extern_providers),\n+                    on_disk_cache,\n                     $($name: Default::default()),*\n                 }\n             }\n@@ -501,43 +537,16 @@ macro_rules! define_queries_struct {\n         }\n \n         impl QueryEngine<'tcx> for Queries<'tcx> {\n-            #[cfg(parallel_compiler)]\n-            unsafe fn deadlock(&'tcx self, tcx: TyCtxt<'tcx>, registry: &rustc_rayon_core::Registry) {\n-                let tcx = QueryCtxt { tcx, queries: self };\n-                rustc_query_system::query::deadlock(tcx, registry)\n-            }\n-\n-            fn encode_query_results(\n-                &'tcx self,\n-                tcx: TyCtxt<'tcx>,\n-                encoder: &mut on_disk_cache::CacheEncoder<'a, 'tcx, opaque::FileEncoder>,\n-                query_result_index: &mut on_disk_cache::EncodedQueryResultIndex,\n-            ) -> opaque::FileEncodeResult {\n-                let tcx = QueryCtxt { tcx, queries: self };\n-                tcx.encode_query_results(encoder, query_result_index)\n-            }\n-\n-            fn exec_cache_promotions(&'tcx self, tcx: TyCtxt<'tcx>) {\n-                let tcx = QueryCtxt { tcx, queries: self };\n-                tcx.dep_graph.exec_cache_promotions(tcx)\n+            fn as_any(&'tcx self) -> &'tcx dyn std::any::Any {\n+                let this = unsafe { std::mem::transmute::<&Queries<'_>, &Queries<'_>>(self) };\n+                this as _\n             }\n \n             fn try_mark_green(&'tcx self, tcx: TyCtxt<'tcx>, dep_node: &dep_graph::DepNode) -> bool {\n                 let qcx = QueryCtxt { tcx, queries: self };\n                 tcx.dep_graph.try_mark_green(qcx, dep_node).is_some()\n             }\n \n-            fn try_print_query_stack(\n-                &'tcx self,\n-                tcx: TyCtxt<'tcx>,\n-                query: Option<QueryJobId<dep_graph::DepKind>>,\n-                handler: &Handler,\n-                num_frames: Option<usize>,\n-            ) -> usize {\n-                let qcx = QueryCtxt { tcx, queries: self };\n-                rustc_query_system::query::print_query_stack(qcx, query, handler, num_frames)\n-            }\n-\n             $($(#[$attr])*\n             #[inline(always)]\n             fn $name("}]}