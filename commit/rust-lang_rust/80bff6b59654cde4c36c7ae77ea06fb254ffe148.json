{"sha": "80bff6b59654cde4c36c7ae77ea06fb254ffe148", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgwYmZmNmI1OTY1NGNkZTRjMzZjN2FlNzdlYTA2ZmIyNTRmZmUxNDg=", "commit": {"author": {"name": "QuietMisdreavus", "email": "grey@quietmisdreavus.net", "date": "2017-03-31T23:04:42Z"}, "committer": {"name": "QuietMisdreavus", "email": "grey@quietmisdreavus.net", "date": "2017-03-31T23:04:42Z"}, "message": "rustdoc: format where clauses like rust-lang-nursery/fmt-rfcs#38", "tree": {"sha": "d64c20760c301ba3166d8af652dd6502142eefc5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d64c20760c301ba3166d8af652dd6502142eefc5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/80bff6b59654cde4c36c7ae77ea06fb254ffe148", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/80bff6b59654cde4c36c7ae77ea06fb254ffe148", "html_url": "https://github.com/rust-lang/rust/commit/80bff6b59654cde4c36c7ae77ea06fb254ffe148", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/80bff6b59654cde4c36c7ae77ea06fb254ffe148/comments", "author": {"login": "QuietMisdreavus", "id": 5217170, "node_id": "MDQ6VXNlcjUyMTcxNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/5217170?v=4", "gravatar_id": "", "url": "https://api.github.com/users/QuietMisdreavus", "html_url": "https://github.com/QuietMisdreavus", "followers_url": "https://api.github.com/users/QuietMisdreavus/followers", "following_url": "https://api.github.com/users/QuietMisdreavus/following{/other_user}", "gists_url": "https://api.github.com/users/QuietMisdreavus/gists{/gist_id}", "starred_url": "https://api.github.com/users/QuietMisdreavus/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/QuietMisdreavus/subscriptions", "organizations_url": "https://api.github.com/users/QuietMisdreavus/orgs", "repos_url": "https://api.github.com/users/QuietMisdreavus/repos", "events_url": "https://api.github.com/users/QuietMisdreavus/events{/privacy}", "received_events_url": "https://api.github.com/users/QuietMisdreavus/received_events", "type": "User", "site_admin": false}, "committer": {"login": "QuietMisdreavus", "id": 5217170, "node_id": "MDQ6VXNlcjUyMTcxNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/5217170?v=4", "gravatar_id": "", "url": "https://api.github.com/users/QuietMisdreavus", "html_url": "https://github.com/QuietMisdreavus", "followers_url": "https://api.github.com/users/QuietMisdreavus/followers", "following_url": "https://api.github.com/users/QuietMisdreavus/following{/other_user}", "gists_url": "https://api.github.com/users/QuietMisdreavus/gists{/gist_id}", "starred_url": "https://api.github.com/users/QuietMisdreavus/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/QuietMisdreavus/subscriptions", "organizations_url": "https://api.github.com/users/QuietMisdreavus/orgs", "repos_url": "https://api.github.com/users/QuietMisdreavus/repos", "events_url": "https://api.github.com/users/QuietMisdreavus/events{/privacy}", "received_events_url": "https://api.github.com/users/QuietMisdreavus/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8206d0c54e149609617a1de57cad480bbad73970", "url": "https://api.github.com/repos/rust-lang/rust/commits/8206d0c54e149609617a1de57cad480bbad73970", "html_url": "https://github.com/rust-lang/rust/commit/8206d0c54e149609617a1de57cad480bbad73970"}], "stats": {"total": 136, "additions": 55, "deletions": 81}, "files": [{"sha": "3fb90f407ebc06c1e2771cdce9df36f5a125cf97", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 29, "deletions": 32, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/80bff6b59654cde4c36c7ae77ea06fb254ffe148/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80bff6b59654cde4c36c7ae77ea06fb254ffe148/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=80bff6b59654cde4c36c7ae77ea06fb254ffe148", "patch": "@@ -49,14 +49,19 @@ pub struct MutableSpace(pub clean::Mutability);\n /// Similar to VisSpace, but used for mutability\n #[derive(Copy, Clone)]\n pub struct RawMutableSpace(pub clean::Mutability);\n-/// Wrapper struct for emitting a where clause from Generics.\n-pub struct WhereClause<'a>(pub &'a clean::Generics, pub usize);\n /// Wrapper struct for emitting type parameter bounds.\n pub struct TyParamBounds<'a>(pub &'a [clean::TyParamBound]);\n /// Wrapper struct for emitting a comma-separated list of items\n pub struct CommaSep<'a, T: 'a>(pub &'a [T]);\n pub struct AbiSpace(pub Abi);\n \n+/// Wrapper struct for emitting a where clause from Generics.\n+pub struct WhereClause<'a>{\n+    pub gens: &'a clean::Generics,\n+    pub indent: usize,\n+    pub end_newline: bool,\n+}\n+\n pub struct HRef<'a> {\n     pub did: DefId,\n     pub text: &'a str,\n@@ -167,24 +172,27 @@ impl fmt::Display for clean::Generics {\n \n impl<'a> fmt::Display for WhereClause<'a> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        let &WhereClause(gens, pad) = self;\n+        let &WhereClause{ gens, indent, end_newline } = self;\n         if gens.where_predicates.is_empty() {\n             return Ok(());\n         }\n         let mut clause = String::new();\n         if f.alternate() {\n-            clause.push_str(\" where \");\n+            clause.push_str(\" where\");\n         } else {\n-            clause.push_str(\" <span class=\\\"where fmt-newline\\\">where \");\n+            if end_newline {\n+                clause.push_str(\"<span class=\\\"where fmt-newline\\\">where\");\n+            } else {\n+                clause.push_str(\"<span class=\\\"where\\\">where\");\n+            }\n         }\n         for (i, pred) in gens.where_predicates.iter().enumerate() {\n-            if i > 0 {\n-                if f.alternate() {\n-                    clause.push_str(\", \");\n-                } else {\n-                    clause.push_str(\",<br>\");\n-                }\n+            if f.alternate() {\n+                clause.push(' ');\n+            } else {\n+                clause.push_str(\"<br>\");\n             }\n+\n             match pred {\n                 &clean::WherePredicate::BoundPredicate { ref ty, ref bounds } => {\n                     let bounds = bounds;\n@@ -213,21 +221,18 @@ impl<'a> fmt::Display for WhereClause<'a> {\n                     }\n                 }\n             }\n+\n+            if i < gens.where_predicates.len() - 1 || end_newline {\n+                clause.push(',');\n+            }\n         }\n         if !f.alternate() {\n             clause.push_str(\"</span>\");\n-            let plain = format!(\"{:#}\", self);\n-            if plain.len() + pad > 80 {\n-                // break it onto its own line regardless, but make sure method impls and trait\n-                // blocks keep their fixed padding (2 and 9, respectively)\n-                let padding = if pad > 10 {\n-                    repeat(\"&nbsp;\").take(8).collect::<String>()\n-                } else {\n-                    repeat(\"&nbsp;\").take(pad + 6).collect::<String>()\n-                };\n-                clause = clause.replace(\"<br>\", &format!(\"<br>{}\", padding));\n-            } else {\n-                clause = clause.replace(\"<br>\", \" \");\n+            let padding = repeat(\"&nbsp;\").take(indent + 4).collect::<String>();\n+            clause = clause.replace(\"<br>\", &format!(\"<br>{}\", padding));\n+            clause.insert_str(0, &repeat(\"&nbsp;\").take(indent).collect::<String>());\n+            if !end_newline {\n+                clause.insert_str(0, \"<br>\");\n             }\n         }\n         write!(f, \"{}\", clause)\n@@ -838,43 +843,35 @@ fn fmt_impl(i: &clean::Impl,\n             f: &mut fmt::Formatter,\n             link_trait: bool,\n             use_absolute: bool) -> fmt::Result {\n-    let mut plain = String::new();\n-\n     if f.alternate() {\n         write!(f, \"impl{:#} \", i.generics)?;\n     } else {\n         write!(f, \"impl{} \", i.generics)?;\n     }\n-    plain.push_str(&format!(\"impl{:#} \", i.generics));\n \n     if let Some(ref ty) = i.trait_ {\n         if i.polarity == Some(clean::ImplPolarity::Negative) {\n             write!(f, \"!\")?;\n-            plain.push_str(\"!\");\n         }\n \n         if link_trait {\n             fmt::Display::fmt(ty, f)?;\n-            plain.push_str(&format!(\"{:#}\", ty));\n         } else {\n             match *ty {\n                 clean::ResolvedPath { typarams: None, ref path, is_generic: false, .. } => {\n                     let last = path.segments.last().unwrap();\n                     fmt::Display::fmt(&last.name, f)?;\n                     fmt::Display::fmt(&last.params, f)?;\n-                    plain.push_str(&format!(\"{:#}{:#}\", last.name, last.params));\n                 }\n                 _ => unreachable!(),\n             }\n         }\n         write!(f, \" for \")?;\n-        plain.push_str(\" for \");\n     }\n \n     fmt_type(&i.for_, f, use_absolute, true)?;\n-    plain.push_str(&format!(\"{:#}\", i.for_));\n \n-    fmt::Display::fmt(&WhereClause(&i.generics, plain.len() + 1), f)?;\n+    fmt::Display::fmt(&WhereClause{ gens: &i.generics, indent: 0, end_newline: true }, f)?;\n     Ok(())\n }\n "}, {"sha": "4eb228ce68f46964bb25b0f15a295b3826bc100b", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 25, "deletions": 37, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/80bff6b59654cde4c36c7ae77ea06fb254ffe148/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80bff6b59654cde4c36c7ae77ea06fb254ffe148/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=80bff6b59654cde4c36c7ae77ea06fb254ffe148", "patch": "@@ -2012,7 +2012,7 @@ fn item_function(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n            abi = AbiSpace(f.abi),\n            name = it.name.as_ref().unwrap(),\n            generics = f.generics,\n-           where_clause = WhereClause(&f.generics, 2),\n+           where_clause = WhereClause { gens: &f.generics, indent: 0, end_newline: true },\n            decl = Method(&f.decl, indent))?;\n     document(w, cx, it)\n }\n@@ -2047,8 +2047,7 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n            it.name.as_ref().unwrap(),\n            t.generics,\n            bounds,\n-           // Where clauses in traits are indented nine spaces, per rustdoc.css\n-           WhereClause(&t.generics, 9))?;\n+           WhereClause { gens: &t.generics, indent: 0, end_newline: true })?;\n \n     let types = t.items.iter().filter(|m| m.is_associated_type()).collect::<Vec<_>>();\n     let consts = t.items.iter().filter(|m| m.is_associated_const()).collect::<Vec<_>>();\n@@ -2087,7 +2086,14 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n         for m in &provided {\n             write!(w, \"    \")?;\n             render_assoc_item(w, m, AssocItemLink::Anchor(None), ItemType::Trait)?;\n-            write!(w, \" {{ ... }}\\n\")?;\n+            match m.inner {\n+                clean::MethodItem(ref inner) if !inner.generics.where_predicates.is_empty() => {\n+                    write!(w, \",\\n    {{ ... }}\\n\")?;\n+                },\n+                _ => {\n+                    write!(w, \" {{ ... }}\\n\")?;\n+                },\n+            }\n         }\n         write!(w, \"}}\")?;\n     }\n@@ -2327,14 +2333,14 @@ fn render_assoc_item(w: &mut fmt::Formatter,\n                              name,\n                              *g);\n         let mut indent = prefix.len();\n-        let where_indent = if parent == ItemType::Trait {\n+        let (where_indent, end_newline) = if parent == ItemType::Trait {\n             indent += 4;\n-            8\n+            (4, false)\n         } else if parent == ItemType::Impl {\n-            2\n+            (0, true)\n         } else {\n             let prefix = prefix + &format!(\"{:#}\", Method(d, indent));\n-            prefix.lines().last().unwrap().len() + 1\n+            (prefix.lines().last().unwrap().len() + 1, true)\n         };\n         write!(w, \"{}{}{}fn <a href='{href}' class='fnname'>{name}</a>\\\n                    {generics}{decl}{where_clause}\",\n@@ -2345,7 +2351,11 @@ fn render_assoc_item(w: &mut fmt::Formatter,\n                name = name,\n                generics = *g,\n                decl = Method(d, indent),\n-               where_clause = WhereClause(g, where_indent))\n+               where_clause = WhereClause {\n+                   gens: g,\n+                   indent: where_indent,\n+                   end_newline: end_newline,\n+               })\n     }\n     match item.inner {\n         clean::StrippedItem(..) => Ok(()),\n@@ -2458,15 +2468,11 @@ fn item_enum(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n              e: &clean::Enum) -> fmt::Result {\n     write!(w, \"<pre class='rust enum'>\")?;\n     render_attributes(w, it)?;\n-    let padding = format!(\"{}enum {}{:#} \",\n-                          VisSpace(&it.visibility),\n-                          it.name.as_ref().unwrap(),\n-                          e.generics).len();\n     write!(w, \"{}enum {}{}{}\",\n            VisSpace(&it.visibility),\n            it.name.as_ref().unwrap(),\n            e.generics,\n-           WhereClause(&e.generics, padding))?;\n+           WhereClause { gens: &e.generics, indent: 0, end_newline: true })?;\n     if e.variants.is_empty() && !e.variants_stripped {\n         write!(w, \" {{}}\")?;\n     } else {\n@@ -2640,23 +2646,17 @@ fn render_struct(w: &mut fmt::Formatter, it: &clean::Item,\n                  fields: &[clean::Item],\n                  tab: &str,\n                  structhead: bool) -> fmt::Result {\n-    let mut plain = String::new();\n     write!(w, \"{}{}{}\",\n            VisSpace(&it.visibility),\n            if structhead {\"struct \"} else {\"\"},\n            it.name.as_ref().unwrap())?;\n-    plain.push_str(&format!(\"{}{}{}\",\n-                            VisSpace(&it.visibility),\n-                            if structhead {\"struct \"} else {\"\"},\n-                            it.name.as_ref().unwrap()));\n     if let Some(g) = g {\n-        plain.push_str(&format!(\"{:#}\", g));\n         write!(w, \"{}\", g)?\n     }\n     match ty {\n         doctree::Plain => {\n             if let Some(g) = g {\n-                write!(w, \"{}\", WhereClause(g, plain.len() + 1))?\n+                write!(w, \"{}\", WhereClause { gens: g, indent: 0, end_newline: true })?\n             }\n             let mut has_visible_fields = false;\n             write!(w, \" {{\")?;\n@@ -2685,35 +2685,30 @@ fn render_struct(w: &mut fmt::Formatter, it: &clean::Item,\n         }\n         doctree::Tuple => {\n             write!(w, \"(\")?;\n-            plain.push_str(\"(\");\n             for (i, field) in fields.iter().enumerate() {\n                 if i > 0 {\n                     write!(w, \", \")?;\n-                    plain.push_str(\", \");\n                 }\n                 match field.inner {\n                     clean::StrippedItem(box clean::StructFieldItem(..)) => {\n-                        plain.push_str(\"_\");\n                         write!(w, \"_\")?\n                     }\n                     clean::StructFieldItem(ref ty) => {\n-                        plain.push_str(&format!(\"{}{:#}\", VisSpace(&field.visibility), *ty));\n                         write!(w, \"{}{}\", VisSpace(&field.visibility), *ty)?\n                     }\n                     _ => unreachable!()\n                 }\n             }\n             write!(w, \")\")?;\n-            plain.push_str(\")\");\n             if let Some(g) = g {\n-                write!(w, \"{}\", WhereClause(g, plain.len() + 1))?\n+                write!(w, \"{}\", WhereClause { gens: g, indent: 0, end_newline: true })?\n             }\n             write!(w, \";\")?;\n         }\n         doctree::Unit => {\n             // Needed for PhantomData.\n             if let Some(g) = g {\n-                write!(w, \"{}\", WhereClause(g, plain.len() + 1))?\n+                write!(w, \"{}\", WhereClause { gens: g, indent: 0, end_newline: true })?\n             }\n             write!(w, \";\")?;\n         }\n@@ -2726,19 +2721,13 @@ fn render_union(w: &mut fmt::Formatter, it: &clean::Item,\n                 fields: &[clean::Item],\n                 tab: &str,\n                 structhead: bool) -> fmt::Result {\n-    let mut plain = String::new();\n     write!(w, \"{}{}{}\",\n            VisSpace(&it.visibility),\n            if structhead {\"union \"} else {\"\"},\n            it.name.as_ref().unwrap())?;\n-    plain.push_str(&format!(\"{}{}{}\",\n-                            VisSpace(&it.visibility),\n-                            if structhead {\"union \"} else {\"\"},\n-                            it.name.as_ref().unwrap()));\n     if let Some(g) = g {\n         write!(w, \"{}\", g)?;\n-        plain.push_str(&format!(\"{:#}\", g));\n-        write!(w, \"{}\", WhereClause(g, plain.len() + 1))?;\n+        write!(w, \"{}\", WhereClause { gens: g, indent: 0, end_newline: true })?;\n     }\n \n     write!(w, \" {{\\n{}\", tab)?;\n@@ -3037,13 +3026,12 @@ fn render_impl(w: &mut fmt::Formatter, cx: &Context, i: &Impl, link: AssocItemLi\n \n fn item_typedef(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n                 t: &clean::Typedef) -> fmt::Result {\n-    let indent = format!(\"type {}{:#} \", it.name.as_ref().unwrap(), t.generics).len();\n     write!(w, \"<pre class='rust typedef'>\")?;\n     render_attributes(w, it)?;\n     write!(w, \"type {}{}{where_clause} = {type_};</pre>\",\n            it.name.as_ref().unwrap(),\n            t.generics,\n-           where_clause = WhereClause(&t.generics, indent),\n+           where_clause = WhereClause { gens: &t.generics, indent: 0, end_newline: true },\n            type_ = t.type_)?;\n \n     document(w, cx, it)"}, {"sha": "77ae2b5870427e3c793cf0958b7104901e30cf2a", "filename": "src/librustdoc/html/static/rustdoc.css", "status": "modified", "additions": 1, "deletions": 12, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/80bff6b59654cde4c36c7ae77ea06fb254ffe148/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/80bff6b59654cde4c36c7ae77ea06fb254ffe148/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css?ref=80bff6b59654cde4c36c7ae77ea06fb254ffe148", "patch": "@@ -379,12 +379,6 @@ h4 > code, h3 > code, .invisible > code {\n .content .where.fmt-newline {\n \tdisplay: block;\n }\n-/* Bit of whitespace to indent it */\n-.content .method .where::before,\n-.content .fn .where::before,\n-.content .where.fmt-newline::before {\n-\tcontent: '  ';\n-}\n \n .content .methods > div { margin-left: 40px; }\n \n@@ -399,11 +393,6 @@ h4 > code, h3 > code, .invisible > code {\n \tfont-size: 90%;\n }\n \n-/* Shift where in trait listing down a line */\n-pre.trait .where::before {\n-\tcontent: '\\a         ';\n-}\n-\n nav {\n \tborder-bottom: 1px solid;\n \tpadding-bottom: 10px;\n@@ -772,4 +761,4 @@ span.since {\n \tnav.sub, .content .out-of-band, .collapse-toggle {\n \t\tdisplay: none;\n \t}\n-}\n\\ No newline at end of file\n+}"}]}