{"sha": "601f89f2cb085ab7e638f034088f32b9428a0611", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYwMWY4OWYyY2IwODVhYjdlNjM4ZjAzNDA4OGYzMmI5NDI4YTA2MTE=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-04-23T23:54:21Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-04-23T23:54:21Z"}, "message": "Merge #4114\n\n4114: Refactor completion sorting r=matklad a=matklad\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "2dd1fe075f1343c2a1bfaa03f800d4d3d53809ee", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2dd1fe075f1343c2a1bfaa03f800d4d3d53809ee"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/601f89f2cb085ab7e638f034088f32b9428a0611", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeoiqtCRBK7hj4Ov3rIwAAdHIIABZmKlVFfnVpZRGthyTpVWpU\nH0IuT2VK2YQdUuwBVLFXXlLubUQBwTpHDj1vggJUNt5+OJThdKLkSFvjYqH+LheM\nLdw1qgJFKwXq4Fi1cf06Xoqg1ngWf2GgCgePCyCzV8y27+4UOMVLFbVXVB9WgWhL\nyPd1Jv5MPrLA+ONDLRTbo8mn5Pjltx9krP21tADAZtp+fUM8NIkjvZFuMr9kbrVb\n0Kl78SzdNLrQPKASBJSbL+kr5qloy59edRChRBe9HtXRQwkyBuC96RLU6oNprN0x\n6+6nv7+pEOZiSud3WbGx18ZY3zTDlXYLNrRBHSJwh0pN6Ob3CRXgQ7+xO1ZhJB8=\n=8Asv\n-----END PGP SIGNATURE-----\n", "payload": "tree 2dd1fe075f1343c2a1bfaa03f800d4d3d53809ee\nparent 5eb51c1e6049c61be60a28894b80a7753f06cfeb\nparent 88d243c742ecd724372c4293b6b6ea293bae2d17\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1587686061 +0000\ncommitter GitHub <noreply@github.com> 1587686061 +0000\n\nMerge #4114\n\n4114: Refactor completion sorting r=matklad a=matklad\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/601f89f2cb085ab7e638f034088f32b9428a0611", "html_url": "https://github.com/rust-lang/rust/commit/601f89f2cb085ab7e638f034088f32b9428a0611", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/601f89f2cb085ab7e638f034088f32b9428a0611/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5eb51c1e6049c61be60a28894b80a7753f06cfeb", "url": "https://api.github.com/repos/rust-lang/rust/commits/5eb51c1e6049c61be60a28894b80a7753f06cfeb", "html_url": "https://github.com/rust-lang/rust/commit/5eb51c1e6049c61be60a28894b80a7753f06cfeb"}, {"sha": "88d243c742ecd724372c4293b6b6ea293bae2d17", "url": "https://api.github.com/repos/rust-lang/rust/commits/88d243c742ecd724372c4293b6b6ea293bae2d17", "html_url": "https://github.com/rust-lang/rust/commit/88d243c742ecd724372c4293b6b6ea293bae2d17"}], "stats": {"total": 662, "additions": 329, "deletions": 333}, "files": [{"sha": "5da254a6e9a95a1bcf84ef2358069c2a069827d7", "filename": "crates/ra_ide/src/call_info.rs", "status": "modified", "additions": 26, "deletions": 4, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/601f89f2cb085ab7e638f034088f32b9428a0611/crates%2Fra_ide%2Fsrc%2Fcall_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/601f89f2cb085ab7e638f034088f32b9428a0611/crates%2Fra_ide%2Fsrc%2Fcall_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcall_info.rs?ref=601f89f2cb085ab7e638f034088f32b9428a0611", "patch": "@@ -19,10 +19,24 @@ pub(crate) fn call_info(db: &RootDatabase, position: FilePosition) -> Option<Cal\n     call_info_for_token(&sema, token)\n }\n \n-pub(crate) fn call_info_for_token(\n-    sema: &Semantics<RootDatabase>,\n-    token: SyntaxToken,\n-) -> Option<CallInfo> {\n+#[derive(Debug)]\n+pub(crate) struct ActiveParameter {\n+    /// FIXME: should be `Type` and `Name\n+    pub(crate) ty: String,\n+    pub(crate) name: String,\n+}\n+\n+impl ActiveParameter {\n+    pub(crate) fn at(db: &RootDatabase, position: FilePosition) -> Option<Self> {\n+        call_info(db, position)?.into_active_parameter()\n+    }\n+\n+    pub(crate) fn at_token(sema: &Semantics<RootDatabase>, token: SyntaxToken) -> Option<Self> {\n+        call_info_for_token(sema, token)?.into_active_parameter()\n+    }\n+}\n+\n+fn call_info_for_token(sema: &Semantics<RootDatabase>, token: SyntaxToken) -> Option<CallInfo> {\n     // Find the calling expression and it's NameRef\n     let calling_node = FnCallNode::with_node(&token.parent())?;\n \n@@ -160,6 +174,14 @@ impl FnCallNode {\n }\n \n impl CallInfo {\n+    fn into_active_parameter(self) -> Option<ActiveParameter> {\n+        let idx = self.active_parameter?;\n+        let ty = self.signature.parameter_types.get(idx)?.clone();\n+        let name = self.signature.parameter_names.get(idx)?.clone();\n+        let res = ActiveParameter { ty, name };\n+        Some(res)\n+    }\n+\n     fn with_fn(db: &RootDatabase, function: hir::Function) -> Self {\n         let signature = FunctionSignature::from_hir(db, function);\n "}, {"sha": "b93153b488fa81f76279df43e7daea3a3bc7e9eb", "filename": "crates/ra_ide/src/completion/complete_dot.rs", "status": "modified", "additions": 0, "deletions": 231, "changes": 231, "blob_url": "https://github.com/rust-lang/rust/blob/601f89f2cb085ab7e638f034088f32b9428a0611/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_dot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/601f89f2cb085ab7e638f034088f32b9428a0611/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_dot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_dot.rs?ref=601f89f2cb085ab7e638f034088f32b9428a0611", "patch": "@@ -105,237 +105,6 @@ mod tests {\n         );\n     }\n \n-    #[test]\n-    fn test_struct_field_completion_in_func_call() {\n-        assert_debug_snapshot!(\n-        do_ref_completion(\n-                r\"\n-                struct A { another_field: i64, the_field: u32, my_string: String }\n-                fn test(my_param: u32) -> u32 { my_param }\n-                fn foo(a: A) {\n-                    test(a.<|>)\n-                }\n-                \",\n-        ),\n-            @r###\"\n-        [\n-            CompletionItem {\n-                label: \"another_field\",\n-                source_range: [201; 201),\n-                delete: [201; 201),\n-                insert: \"another_field\",\n-                kind: Field,\n-                detail: \"i64\",\n-            },\n-            CompletionItem {\n-                label: \"my_string\",\n-                source_range: [201; 201),\n-                delete: [201; 201),\n-                insert: \"my_string\",\n-                kind: Field,\n-                detail: \"{unknown}\",\n-            },\n-            CompletionItem {\n-                label: \"the_field\",\n-                source_range: [201; 201),\n-                delete: [201; 201),\n-                insert: \"the_field\",\n-                kind: Field,\n-                detail: \"u32\",\n-                score: TypeMatch,\n-            },\n-        ]\n-        \"###\n-        );\n-    }\n-\n-    #[test]\n-    fn test_struct_field_completion_in_func_call_with_type_and_name() {\n-        assert_debug_snapshot!(\n-        do_ref_completion(\n-                r\"\n-                struct A { another_field: i64, another_good_type: u32, the_field: u32 }\n-                fn test(the_field: u32) -> u32 { the_field }\n-                fn foo(a: A) {\n-                    test(a.<|>)\n-                }\n-                \",\n-        ),\n-            @r###\"\n-        [\n-            CompletionItem {\n-                label: \"another_field\",\n-                source_range: [208; 208),\n-                delete: [208; 208),\n-                insert: \"another_field\",\n-                kind: Field,\n-                detail: \"i64\",\n-            },\n-            CompletionItem {\n-                label: \"another_good_type\",\n-                source_range: [208; 208),\n-                delete: [208; 208),\n-                insert: \"another_good_type\",\n-                kind: Field,\n-                detail: \"u32\",\n-                score: TypeMatch,\n-            },\n-            CompletionItem {\n-                label: \"the_field\",\n-                source_range: [208; 208),\n-                delete: [208; 208),\n-                insert: \"the_field\",\n-                kind: Field,\n-                detail: \"u32\",\n-                score: TypeAndNameMatch,\n-            },\n-        ]\n-        \"###\n-        );\n-    }\n-\n-    #[test]\n-    fn test_struct_field_completion_in_record_lit() {\n-        assert_debug_snapshot!(\n-        do_ref_completion(\n-                r\"\n-                struct A { another_field: i64, another_good_type: u32, the_field: u32 }\n-                struct B { my_string: String, my_vec: Vec<u32>, the_field: u32 }\n-                fn foo(a: A) {\n-                    let b = B {\n-                        the_field: a.<|>\n-                    };\n-                }\n-                \",\n-        ),\n-            @r###\"\n-        [\n-            CompletionItem {\n-                label: \"another_field\",\n-                source_range: [270; 270),\n-                delete: [270; 270),\n-                insert: \"another_field\",\n-                kind: Field,\n-                detail: \"i64\",\n-            },\n-            CompletionItem {\n-                label: \"another_good_type\",\n-                source_range: [270; 270),\n-                delete: [270; 270),\n-                insert: \"another_good_type\",\n-                kind: Field,\n-                detail: \"u32\",\n-                score: TypeMatch,\n-            },\n-            CompletionItem {\n-                label: \"the_field\",\n-                source_range: [270; 270),\n-                delete: [270; 270),\n-                insert: \"the_field\",\n-                kind: Field,\n-                detail: \"u32\",\n-                score: TypeAndNameMatch,\n-            },\n-        ]\n-        \"###\n-        );\n-    }\n-\n-    #[test]\n-    fn test_struct_field_completion_in_record_lit_and_fn_call() {\n-        assert_debug_snapshot!(\n-        do_ref_completion(\n-                r\"\n-                struct A { another_field: i64, another_good_type: u32, the_field: u32 }\n-                struct B { my_string: String, my_vec: Vec<u32>, the_field: u32 }\n-                fn test(the_field: i64) -> i64 { the_field }\n-                fn foo(a: A) {\n-                    let b = B {\n-                        the_field: test(a.<|>)\n-                    };\n-                }\n-                \",\n-        ),\n-            @r###\"\n-        [\n-            CompletionItem {\n-                label: \"another_field\",\n-                source_range: [336; 336),\n-                delete: [336; 336),\n-                insert: \"another_field\",\n-                kind: Field,\n-                detail: \"i64\",\n-                score: TypeMatch,\n-            },\n-            CompletionItem {\n-                label: \"another_good_type\",\n-                source_range: [336; 336),\n-                delete: [336; 336),\n-                insert: \"another_good_type\",\n-                kind: Field,\n-                detail: \"u32\",\n-            },\n-            CompletionItem {\n-                label: \"the_field\",\n-                source_range: [336; 336),\n-                delete: [336; 336),\n-                insert: \"the_field\",\n-                kind: Field,\n-                detail: \"u32\",\n-            },\n-        ]\n-        \"###\n-        );\n-    }\n-\n-    #[test]\n-    fn test_struct_field_completion_in_fn_call_and_record_lit() {\n-        assert_debug_snapshot!(\n-        do_ref_completion(\n-                r\"\n-                struct A { another_field: i64, another_good_type: u32, the_field: u32 }\n-                struct B { my_string: String, my_vec: Vec<u32>, the_field: u32 }\n-                fn test(the_field: i64) -> i64 { the_field }\n-                fn foo(a: A) {\n-                    test(B {\n-                        the_field: a.<|>\n-                    });\n-                }\n-                \",\n-        ),\n-            @r###\"\n-        [\n-            CompletionItem {\n-                label: \"another_field\",\n-                source_range: [328; 328),\n-                delete: [328; 328),\n-                insert: \"another_field\",\n-                kind: Field,\n-                detail: \"i64\",\n-            },\n-            CompletionItem {\n-                label: \"another_good_type\",\n-                source_range: [328; 328),\n-                delete: [328; 328),\n-                insert: \"another_good_type\",\n-                kind: Field,\n-                detail: \"u32\",\n-                score: TypeMatch,\n-            },\n-            CompletionItem {\n-                label: \"the_field\",\n-                source_range: [328; 328),\n-                delete: [328; 328),\n-                insert: \"the_field\",\n-                kind: Field,\n-                detail: \"u32\",\n-                score: TypeAndNameMatch,\n-            },\n-        ]\n-        \"###\n-        );\n-    }\n-\n     #[test]\n     fn test_struct_field_completion_self() {\n         assert_debug_snapshot!("}, {"sha": "a76d1ce450d2435fbca0140a883a206b15d13f38", "filename": "crates/ra_ide/src/completion/completion_context.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/601f89f2cb085ab7e638f034088f32b9428a0611/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcompletion_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/601f89f2cb085ab7e638f034088f32b9428a0611/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcompletion_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcompletion_context.rs?ref=601f89f2cb085ab7e638f034088f32b9428a0611", "patch": "@@ -11,7 +11,7 @@ use ra_syntax::{\n };\n use ra_text_edit::AtomTextEdit;\n \n-use crate::{completion::CompletionConfig, FilePosition};\n+use crate::{call_info::ActiveParameter, completion::CompletionConfig, FilePosition};\n \n /// `CompletionContext` is created early during completion to figure out, where\n /// exactly is the cursor, syntax-wise.\n@@ -21,7 +21,6 @@ pub(crate) struct CompletionContext<'a> {\n     pub(super) db: &'a RootDatabase,\n     pub(super) config: &'a CompletionConfig,\n     pub(super) offset: TextUnit,\n-    pub(super) file_position: FilePosition,\n     /// The token before the cursor, in the original file.\n     pub(super) original_token: SyntaxToken,\n     /// The token before the cursor, in the macro-expanded file.\n@@ -34,6 +33,8 @@ pub(crate) struct CompletionContext<'a> {\n     pub(super) record_pat_syntax: Option<ast::RecordPat>,\n     pub(super) record_field_syntax: Option<ast::RecordField>,\n     pub(super) impl_def: Option<ast::ImplDef>,\n+    /// FIXME: `ActiveParameter` is string-based, which is very wrong\n+    pub(super) active_parameter: Option<ActiveParameter>,\n     pub(super) is_param: bool,\n     /// If a name-binding or reference to a const in a pattern.\n     /// Irrefutable patterns (like let) are excluded.\n@@ -90,7 +91,6 @@ impl<'a> CompletionContext<'a> {\n             original_token,\n             token,\n             offset: position.offset,\n-            file_position: position,\n             krate,\n             name_ref_syntax: None,\n             function_syntax: None,\n@@ -99,6 +99,7 @@ impl<'a> CompletionContext<'a> {\n             record_pat_syntax: None,\n             record_field_syntax: None,\n             impl_def: None,\n+            active_parameter: ActiveParameter::at(db, position),\n             is_param: false,\n             is_pat_binding_or_const: false,\n             is_trivial_path: false,"}, {"sha": "edbf4a5b756da2602f4f4e7d64d00d62cca70de6", "filename": "crates/ra_ide/src/completion/completion_item.rs", "status": "modified", "additions": 11, "deletions": 16, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/601f89f2cb085ab7e638f034088f32b9428a0611/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcompletion_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/601f89f2cb085ab7e638f034088f32b9428a0611/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcompletion_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcompletion_item.rs?ref=601f89f2cb085ab7e638f034088f32b9428a0611", "patch": "@@ -52,7 +52,7 @@ pub struct CompletionItem {\n     /// after completion.\n     trigger_call_info: bool,\n \n-    /// Score is usefull to pre select or display in better order completion items\n+    /// Score is useful to pre select or display in better order completion items\n     score: Option<CompletionScore>,\n }\n \n@@ -93,6 +93,14 @@ impl fmt::Debug for CompletionItem {\n     }\n }\n \n+#[derive(Debug, Clone, Copy)]\n+pub enum CompletionScore {\n+    /// If only type match\n+    TypeMatch,\n+    /// If type and name match\n+    TypeAndNameMatch,\n+}\n+\n #[derive(Debug, Clone, Copy, PartialEq, Eq)]\n pub enum CompletionItemKind {\n     Snippet,\n@@ -182,7 +190,7 @@ impl CompletionItem {\n     }\n     /// What string is used for filtering.\n     pub fn lookup(&self) -> &str {\n-        self.lookup.as_deref().unwrap_or_else(|| self.label())\n+        self.lookup.as_deref().unwrap_or(&self.label)\n     }\n \n     pub fn kind(&self) -> Option<CompletionItemKind> {\n@@ -194,11 +202,7 @@ impl CompletionItem {\n     }\n \n     pub fn score(&self) -> Option<CompletionScore> {\n-        self.score.clone()\n-    }\n-\n-    pub fn set_score(&mut self, score: CompletionScore) {\n-        self.score = Some(score);\n+        self.score\n     }\n \n     pub fn trigger_call_info(&self) -> bool {\n@@ -302,7 +306,6 @@ impl Builder {\n         self.deprecated = Some(deprecated);\n         self\n     }\n-    #[allow(unused)]\n     pub(crate) fn set_score(mut self, score: CompletionScore) -> Builder {\n         self.score = Some(score);\n         self\n@@ -319,14 +322,6 @@ impl<'a> Into<CompletionItem> for Builder {\n     }\n }\n \n-#[derive(Debug, Clone)]\n-pub enum CompletionScore {\n-    /// If only type match\n-    TypeMatch,\n-    /// If type and name match\n-    TypeAndNameMatch,\n-}\n-\n /// Represents an in-progress set of completions being built.\n #[derive(Debug, Default)]\n pub(crate) struct Completions {"}, {"sha": "78df9cbdb7ea138073a10d706e597100b81b1a19", "filename": "crates/ra_ide/src/completion/presentation.rs", "status": "modified", "additions": 273, "deletions": 41, "changes": 314, "blob_url": "https://github.com/rust-lang/rust/blob/601f89f2cb085ab7e638f034088f32b9428a0611/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fpresentation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/601f89f2cb085ab7e638f034088f32b9428a0611/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fpresentation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fpresentation.rs?ref=601f89f2cb085ab7e638f034088f32b9428a0611", "patch": "@@ -6,7 +6,6 @@ use stdx::SepBy;\n use test_utils::tested_by;\n \n use crate::{\n-    call_info::call_info,\n     completion::{\n         completion_item::Builder, CompletionContext, CompletionItem, CompletionItemKind,\n         CompletionKind, Completions,\n@@ -23,20 +22,20 @@ impl Completions {\n         ty: &Type,\n     ) {\n         let is_deprecated = is_deprecated(field, ctx.db);\n-        let mut completion_item = CompletionItem::new(\n-            CompletionKind::Reference,\n-            ctx.source_range(),\n-            field.name(ctx.db).to_string(),\n-        )\n-        .kind(CompletionItemKind::Field)\n-        .detail(ty.display(ctx.db).to_string())\n-        .set_documentation(field.docs(ctx.db))\n-        .set_deprecated(is_deprecated)\n-        .build();\n-\n-        compute_score(&mut completion_item, ctx);\n+        let ty = ty.display(ctx.db).to_string();\n+        let name = field.name(ctx.db);\n+        let mut completion_item =\n+            CompletionItem::new(CompletionKind::Reference, ctx.source_range(), name.to_string())\n+                .kind(CompletionItemKind::Field)\n+                .detail(ty.clone())\n+                .set_documentation(field.docs(ctx.db))\n+                .set_deprecated(is_deprecated);\n+\n+        if let Some(score) = compute_score(ctx, &ty, &name.to_string()) {\n+            completion_item = completion_item.set_score(score);\n+        }\n \n-        self.add(completion_item);\n+        completion_item.add_to(self);\n     }\n \n     pub(crate) fn add_tuple_field(&mut self, ctx: &CompletionContext, field: usize, ty: &Type) {\n@@ -305,40 +304,40 @@ impl Completions {\n     }\n }\n \n-pub(crate) fn compute_score(completion_item: &mut CompletionItem, ctx: &CompletionContext) {\n+pub(crate) fn compute_score(\n+    ctx: &CompletionContext,\n+    // FIXME: this definitely should be a `Type`\n+    ty: &str,\n+    name: &str,\n+) -> Option<CompletionScore> {\n     let (active_name, active_type) = if let Some(record_field) = &ctx.record_field_syntax {\n-        if let Some((struct_field, _)) = ctx.sema.resolve_record_field(record_field) {\n-            (\n-                struct_field.name(ctx.db).to_string(),\n-                struct_field.signature_ty(ctx.db).display(ctx.db).to_string(),\n-            )\n-        } else {\n-            return;\n-        }\n-    } else if let Some(call_info) = call_info(ctx.db, ctx.file_position) {\n-        if call_info.active_parameter_type().is_some()\n-            && call_info.active_parameter_name().is_some()\n-        {\n-            (call_info.active_parameter_name().unwrap(), call_info.active_parameter_type().unwrap())\n-        } else {\n-            return;\n-        }\n+        tested_by!(test_struct_field_completion_in_record_lit);\n+        let (struct_field, _local) = ctx.sema.resolve_record_field(record_field)?;\n+        (\n+            struct_field.name(ctx.db).to_string(),\n+            struct_field.signature_ty(ctx.db).display(ctx.db).to_string(),\n+        )\n+    } else if let Some(active_parameter) = &ctx.active_parameter {\n+        tested_by!(test_struct_field_completion_in_func_call);\n+        (active_parameter.name.clone(), active_parameter.ty.clone())\n     } else {\n-        return;\n+        return None;\n     };\n \n     // Compute score\n     // For the same type\n-    if let Some(a_parameter_type) = completion_item.detail() {\n-        if &active_type == a_parameter_type {\n-            // If same type + same name then go top position\n-            if active_name == completion_item.label() {\n-                completion_item.set_score(CompletionScore::TypeAndNameMatch);\n-            } else {\n-                completion_item.set_score(CompletionScore::TypeMatch);\n-            }\n-        }\n+    if &active_type != ty {\n+        return None;\n+    }\n+\n+    let mut res = CompletionScore::TypeMatch;\n+\n+    // If same type + same name then go top position\n+    if active_name == name {\n+        res = CompletionScore::TypeAndNameMatch\n     }\n+\n+    Some(res)\n }\n \n enum Params {\n@@ -1072,4 +1071,237 @@ mod tests {\n         \"###\n         );\n     }\n+\n+    #[test]\n+    fn test_struct_field_completion_in_func_call() {\n+        covers!(test_struct_field_completion_in_func_call);\n+        assert_debug_snapshot!(\n+        do_reference_completion(\n+                r\"\n+                struct A { another_field: i64, the_field: u32, my_string: String }\n+                fn test(my_param: u32) -> u32 { my_param }\n+                fn foo(a: A) {\n+                    test(a.<|>)\n+                }\n+                \",\n+        ),\n+            @r###\"\n+        [\n+            CompletionItem {\n+                label: \"another_field\",\n+                source_range: [201; 201),\n+                delete: [201; 201),\n+                insert: \"another_field\",\n+                kind: Field,\n+                detail: \"i64\",\n+            },\n+            CompletionItem {\n+                label: \"my_string\",\n+                source_range: [201; 201),\n+                delete: [201; 201),\n+                insert: \"my_string\",\n+                kind: Field,\n+                detail: \"{unknown}\",\n+            },\n+            CompletionItem {\n+                label: \"the_field\",\n+                source_range: [201; 201),\n+                delete: [201; 201),\n+                insert: \"the_field\",\n+                kind: Field,\n+                detail: \"u32\",\n+                score: TypeMatch,\n+            },\n+        ]\n+        \"###\n+        );\n+    }\n+\n+    #[test]\n+    fn test_struct_field_completion_in_func_call_with_type_and_name() {\n+        assert_debug_snapshot!(\n+        do_reference_completion(\n+                r\"\n+                struct A { another_field: i64, another_good_type: u32, the_field: u32 }\n+                fn test(the_field: u32) -> u32 { the_field }\n+                fn foo(a: A) {\n+                    test(a.<|>)\n+                }\n+                \",\n+        ),\n+            @r###\"\n+        [\n+            CompletionItem {\n+                label: \"another_field\",\n+                source_range: [208; 208),\n+                delete: [208; 208),\n+                insert: \"another_field\",\n+                kind: Field,\n+                detail: \"i64\",\n+            },\n+            CompletionItem {\n+                label: \"another_good_type\",\n+                source_range: [208; 208),\n+                delete: [208; 208),\n+                insert: \"another_good_type\",\n+                kind: Field,\n+                detail: \"u32\",\n+                score: TypeMatch,\n+            },\n+            CompletionItem {\n+                label: \"the_field\",\n+                source_range: [208; 208),\n+                delete: [208; 208),\n+                insert: \"the_field\",\n+                kind: Field,\n+                detail: \"u32\",\n+                score: TypeAndNameMatch,\n+            },\n+        ]\n+        \"###\n+        );\n+    }\n+\n+    #[test]\n+    fn test_struct_field_completion_in_record_lit() {\n+        covers!(test_struct_field_completion_in_func_call);\n+        assert_debug_snapshot!(\n+        do_reference_completion(\n+                r\"\n+                struct A { another_field: i64, another_good_type: u32, the_field: u32 }\n+                struct B { my_string: String, my_vec: Vec<u32>, the_field: u32 }\n+                fn foo(a: A) {\n+                    let b = B {\n+                        the_field: a.<|>\n+                    };\n+                }\n+                \",\n+        ),\n+            @r###\"\n+        [\n+            CompletionItem {\n+                label: \"another_field\",\n+                source_range: [270; 270),\n+                delete: [270; 270),\n+                insert: \"another_field\",\n+                kind: Field,\n+                detail: \"i64\",\n+            },\n+            CompletionItem {\n+                label: \"another_good_type\",\n+                source_range: [270; 270),\n+                delete: [270; 270),\n+                insert: \"another_good_type\",\n+                kind: Field,\n+                detail: \"u32\",\n+                score: TypeMatch,\n+            },\n+            CompletionItem {\n+                label: \"the_field\",\n+                source_range: [270; 270),\n+                delete: [270; 270),\n+                insert: \"the_field\",\n+                kind: Field,\n+                detail: \"u32\",\n+                score: TypeAndNameMatch,\n+            },\n+        ]\n+        \"###\n+        );\n+    }\n+\n+    #[test]\n+    fn test_struct_field_completion_in_record_lit_and_fn_call() {\n+        assert_debug_snapshot!(\n+        do_reference_completion(\n+                r\"\n+                struct A { another_field: i64, another_good_type: u32, the_field: u32 }\n+                struct B { my_string: String, my_vec: Vec<u32>, the_field: u32 }\n+                fn test(the_field: i64) -> i64 { the_field }\n+                fn foo(a: A) {\n+                    let b = B {\n+                        the_field: test(a.<|>)\n+                    };\n+                }\n+                \",\n+        ),\n+            @r###\"\n+        [\n+            CompletionItem {\n+                label: \"another_field\",\n+                source_range: [336; 336),\n+                delete: [336; 336),\n+                insert: \"another_field\",\n+                kind: Field,\n+                detail: \"i64\",\n+                score: TypeMatch,\n+            },\n+            CompletionItem {\n+                label: \"another_good_type\",\n+                source_range: [336; 336),\n+                delete: [336; 336),\n+                insert: \"another_good_type\",\n+                kind: Field,\n+                detail: \"u32\",\n+            },\n+            CompletionItem {\n+                label: \"the_field\",\n+                source_range: [336; 336),\n+                delete: [336; 336),\n+                insert: \"the_field\",\n+                kind: Field,\n+                detail: \"u32\",\n+            },\n+        ]\n+        \"###\n+        );\n+    }\n+\n+    #[test]\n+    fn test_struct_field_completion_in_fn_call_and_record_lit() {\n+        assert_debug_snapshot!(\n+        do_reference_completion(\n+                r\"\n+                struct A { another_field: i64, another_good_type: u32, the_field: u32 }\n+                struct B { my_string: String, my_vec: Vec<u32>, the_field: u32 }\n+                fn test(the_field: i64) -> i64 { the_field }\n+                fn foo(a: A) {\n+                    test(B {\n+                        the_field: a.<|>\n+                    });\n+                }\n+                \",\n+        ),\n+            @r###\"\n+        [\n+            CompletionItem {\n+                label: \"another_field\",\n+                source_range: [328; 328),\n+                delete: [328; 328),\n+                insert: \"another_field\",\n+                kind: Field,\n+                detail: \"i64\",\n+            },\n+            CompletionItem {\n+                label: \"another_good_type\",\n+                source_range: [328; 328),\n+                delete: [328; 328),\n+                insert: \"another_good_type\",\n+                kind: Field,\n+                detail: \"u32\",\n+                score: TypeMatch,\n+            },\n+            CompletionItem {\n+                label: \"the_field\",\n+                source_range: [328; 328),\n+                delete: [328; 328),\n+                insert: \"the_field\",\n+                kind: Field,\n+                detail: \"u32\",\n+                score: TypeAndNameMatch,\n+            },\n+        ]\n+        \"###\n+        );\n+    }\n }"}, {"sha": "f692fbaa2eb654cd5a1e7339ed44a2024bb8dc8e", "filename": "crates/ra_ide/src/lib.rs", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/601f89f2cb085ab7e638f034088f32b9428a0611/crates%2Fra_ide%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/601f89f2cb085ab7e638f034088f32b9428a0611/crates%2Fra_ide%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Flib.rs?ref=601f89f2cb085ab7e638f034088f32b9428a0611", "patch": "@@ -129,21 +129,6 @@ pub struct CallInfo {\n     pub active_parameter: Option<usize>,\n }\n \n-impl CallInfo {\n-    pub fn active_parameter_type(&self) -> Option<String> {\n-        if let Some(id) = self.active_parameter {\n-            return self.signature.parameter_types.get(id).map(|param_ty| param_ty.clone());\n-        }\n-        None\n-    }\n-    pub fn active_parameter_name(&self) -> Option<String> {\n-        if let Some(id) = self.active_parameter {\n-            return self.signature.parameter_names.get(id).map(|param_ty| param_ty.clone());\n-        }\n-        None\n-    }\n-}\n-\n /// `AnalysisHost` stores the current state of the world.\n #[derive(Debug)]\n pub struct AnalysisHost {"}, {"sha": "bea30fe2af55d53d33d907b392f064127b7dac78", "filename": "crates/ra_ide/src/marks.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/601f89f2cb085ab7e638f034088f32b9428a0611/crates%2Fra_ide%2Fsrc%2Fmarks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/601f89f2cb085ab7e638f034088f32b9428a0611/crates%2Fra_ide%2Fsrc%2Fmarks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fmarks.rs?ref=601f89f2cb085ab7e638f034088f32b9428a0611", "patch": "@@ -9,4 +9,6 @@ test_utils::marks!(\n     search_filters_by_range\n     dont_insert_macro_call_parens_unncessary\n     self_fulfilling_completion\n+    test_struct_field_completion_in_func_call\n+    test_struct_field_completion_in_record_lit\n );"}, {"sha": "d9912155b99ccd456e686e8f2f0865a5a13d514d", "filename": "crates/ra_ide/src/syntax_highlighting.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/601f89f2cb085ab7e638f034088f32b9428a0611/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/601f89f2cb085ab7e638f034088f32b9428a0611/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting.rs?ref=601f89f2cb085ab7e638f034088f32b9428a0611", "patch": "@@ -19,7 +19,7 @@ use ra_syntax::{\n };\n use rustc_hash::FxHashMap;\n \n-use crate::{call_info::call_info_for_token, Analysis, FileId};\n+use crate::{call_info::ActiveParameter, Analysis, FileId};\n \n pub(crate) use html::highlight_as_html;\n pub use tags::{Highlight, HighlightModifier, HighlightModifiers, HighlightTag};\n@@ -364,10 +364,8 @@ fn highlight_injection(\n     literal: ast::RawString,\n     expanded: SyntaxToken,\n ) -> Option<()> {\n-    let call_info = call_info_for_token(&sema, expanded)?;\n-    let idx = call_info.active_parameter?;\n-    let name = call_info.signature.parameter_names.get(idx)?;\n-    if !name.starts_with(\"ra_fixture\") {\n+    let active_parameter = ActiveParameter::at_token(&sema, expanded)?;\n+    if !active_parameter.name.starts_with(\"ra_fixture\") {\n         return None;\n     }\n     let value = literal.value()?;"}, {"sha": "098ee369c2adb95af5d6c33b673539b04cd49fbf", "filename": "crates/rust-analyzer/src/conv.rs", "status": "modified", "additions": 8, "deletions": 13, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/601f89f2cb085ab7e638f034088f32b9428a0611/crates%2Frust-analyzer%2Fsrc%2Fconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/601f89f2cb085ab7e638f034088f32b9428a0611/crates%2Frust-analyzer%2Fsrc%2Fconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fconv.rs?ref=601f89f2cb085ab7e638f034088f32b9428a0611", "patch": "@@ -9,10 +9,10 @@ use lsp_types::{\n     TextDocumentPositionParams, Url, VersionedTextDocumentIdentifier, WorkspaceEdit,\n };\n use ra_ide::{\n-    translate_offset_with_edit, CompletionItem, CompletionItemKind, CompletionScore, FileId,\n-    FilePosition, FileRange, FileSystemEdit, Fold, FoldKind, Highlight, HighlightModifier,\n-    HighlightTag, InlayHint, InlayKind, InsertTextFormat, LineCol, LineIndex, NavigationTarget,\n-    RangeInfo, ReferenceAccess, Severity, SourceChange, SourceFileEdit,\n+    translate_offset_with_edit, CompletionItem, CompletionItemKind, FileId, FilePosition,\n+    FileRange, FileSystemEdit, Fold, FoldKind, Highlight, HighlightModifier, HighlightTag,\n+    InlayHint, InlayKind, InsertTextFormat, LineCol, LineIndex, NavigationTarget, RangeInfo,\n+    ReferenceAccess, Severity, SourceChange, SourceFileEdit,\n };\n use ra_syntax::{SyntaxKind, TextRange, TextUnit};\n use ra_text_edit::{AtomTextEdit, TextEdit};\n@@ -114,10 +114,10 @@ impl Conv for Severity {\n     }\n }\n \n-impl ConvWith<(&LineIndex, LineEndings, &mut usize)> for CompletionItem {\n+impl ConvWith<(&LineIndex, LineEndings)> for CompletionItem {\n     type Output = ::lsp_types::CompletionItem;\n \n-    fn conv_with(self, ctx: (&LineIndex, LineEndings, &mut usize)) -> ::lsp_types::CompletionItem {\n+    fn conv_with(self, ctx: (&LineIndex, LineEndings)) -> ::lsp_types::CompletionItem {\n         let mut additional_text_edits = Vec::new();\n         let mut text_edit = None;\n         // LSP does not allow arbitrary edits in completion, so we have to do a\n@@ -165,13 +165,8 @@ impl ConvWith<(&LineIndex, LineEndings, &mut usize)> for CompletionItem {\n             ..Default::default()\n         };\n \n-        if let Some(score) = self.score() {\n-            match score {\n-                CompletionScore::TypeAndNameMatch => res.preselect = Some(true),\n-                CompletionScore::TypeMatch => {}\n-            }\n-            res.sort_text = Some(format!(\"{:02}\", *ctx.2));\n-            *ctx.2 += 1;\n+        if self.score().is_some() {\n+            res.preselect = Some(true)\n         }\n \n         if self.deprecated() {"}, {"sha": "41d9fe344d4d97f0ad155968ff2f0d30e909e0e9", "filename": "crates/rust-analyzer/src/main_loop/handlers.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/601f89f2cb085ab7e638f034088f32b9428a0611/crates%2Frust-analyzer%2Fsrc%2Fmain_loop%2Fhandlers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/601f89f2cb085ab7e638f034088f32b9428a0611/crates%2Frust-analyzer%2Fsrc%2Fmain_loop%2Fhandlers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fmain_loop%2Fhandlers.rs?ref=601f89f2cb085ab7e638f034088f32b9428a0611", "patch": "@@ -423,11 +423,8 @@ pub fn handle_completion(\n     };\n     let line_index = world.analysis().file_line_index(position.file_id)?;\n     let line_endings = world.file_line_endings(position.file_id);\n-    let mut count_sort_text_item = 0usize;\n-    let items: Vec<CompletionItem> = items\n-        .into_iter()\n-        .map(|item| item.conv_with((&line_index, line_endings, &mut count_sort_text_item)))\n-        .collect();\n+    let items: Vec<CompletionItem> =\n+        items.into_iter().map(|item| item.conv_with((&line_index, line_endings))).collect();\n \n     Ok(Some(items.into()))\n }"}]}