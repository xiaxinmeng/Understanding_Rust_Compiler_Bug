{"sha": "71f41405500cec42be22f0080bf3f83f97bfa768", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcxZjQxNDA1NTAwY2VjNDJiZTIyZjAwODBiZjNmODNmOTdiZmE3Njg=", "commit": {"author": {"name": "hyd-dev", "email": "yd-huang@outlook.com", "date": "2021-05-29T17:36:06Z"}, "committer": {"name": "hyd-dev", "email": "yd-huang@outlook.com", "date": "2021-05-31T03:14:23Z"}, "message": "Add `-Zmiri-disable-abi-check`", "tree": {"sha": "8df5ce22252d2fa79c0729c8e9dc5102276b2c98", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8df5ce22252d2fa79c0729c8e9dc5102276b2c98"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/71f41405500cec42be22f0080bf3f83f97bfa768", "comment_count": 0, "verification": {"verified": false, "reason": "no_user", "signature": "-----BEGIN PGP SIGNATURE-----\n\niIsEABYIADMWIQRJ2jPMDdiQ+U4U42Z0+n/VuNoUuAUCYLRUkRUceWQtaHVhbmdA\nb3V0bG9vay5jb20ACgkQdPp/1bjaFLj4NgEA7k7gHfqGHq+NtFi56qC1EQ44o86U\nvF44SXNbL06JQAkBANAa65SXNHZMxcI914oiehU5vcB/mmCHJvxjHAfoCdYL\n=uxEK\n-----END PGP SIGNATURE-----", "payload": "tree 8df5ce22252d2fa79c0729c8e9dc5102276b2c98\nparent 178ae8e44c5ecbe7445772a499679f62efd54a91\nauthor hyd-dev <yd-huang@outlook.com> 1622309766 +0800\ncommitter hyd-dev <yd-huang@outlook.com> 1622430863 +0800\n\nAdd `-Zmiri-disable-abi-check`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/71f41405500cec42be22f0080bf3f83f97bfa768", "html_url": "https://github.com/rust-lang/rust/commit/71f41405500cec42be22f0080bf3f83f97bfa768", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/71f41405500cec42be22f0080bf3f83f97bfa768/comments", "author": null, "committer": null, "parents": [{"sha": "178ae8e44c5ecbe7445772a499679f62efd54a91", "url": "https://api.github.com/repos/rust-lang/rust/commits/178ae8e44c5ecbe7445772a499679f62efd54a91", "html_url": "https://github.com/rust-lang/rust/commit/178ae8e44c5ecbe7445772a499679f62efd54a91"}], "stats": {"total": 409, "additions": 235, "deletions": 174}, "files": [{"sha": "f87a7e989d97361a9f0689ccb1d6f48f8511faf4", "filename": "README.md", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/71f41405500cec42be22f0080bf3f83f97bfa768/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/71f41405500cec42be22f0080bf3f83f97bfa768/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=71f41405500cec42be22f0080bf3f83f97bfa768", "patch": "@@ -214,6 +214,8 @@ environment variable:\n   as out-of-bounds accesses) first.  Setting this flag means Miri can miss bugs\n   in your program.  However, this can also help to make Miri run faster.  Using\n   this flag is **unsound**.\n+* `-Zmiri-disable-abi-check` disables checking [function ABI]. Using this flag\n+  is **unsound**.\n * `-Zmiri-disable-isolation` disables host isolation.  As a consequence,\n   the program has access to host resources such as environment variables, file\n   systems, and randomness.\n@@ -263,6 +265,8 @@ environment variable:\n   with `-Zmiri-track-raw-pointers` also works without\n   `-Zmiri-track-raw-pointers`, but for the vast majority of code, this will be the case.\n \n+[function ABI]: https://doc.rust-lang.org/reference/items/functions.html#extern-function-qualifier\n+\n Some native rustc `-Z` flags are also very relevant for Miri:\n \n * `-Zmir-opt-level` controls how many MIR optimizations are performed.  Miri"}, {"sha": "e921407f63fb4a879cbcc8a48f48812007d689b3", "filename": "src/bin/miri.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/71f41405500cec42be22f0080bf3f83f97bfa768/src%2Fbin%2Fmiri.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71f41405500cec42be22f0080bf3f83f97bfa768/src%2Fbin%2Fmiri.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Fmiri.rs?ref=71f41405500cec42be22f0080bf3f83f97bfa768", "patch": "@@ -227,6 +227,9 @@ fn main() {\n                 \"-Zmiri-symbolic-alignment-check\" => {\n                     miri_config.check_alignment = miri::AlignmentCheck::Symbolic;\n                 }\n+                \"-Zmiri-disable-abi-check\" => {\n+                    miri_config.check_abi = false;\n+                }\n                 \"-Zmiri-disable-isolation\" => {\n                     miri_config.communicate = true;\n                 }"}, {"sha": "6646783d349cae3358cba1b66c2c84dada45c163", "filename": "src/eval.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/71f41405500cec42be22f0080bf3f83f97bfa768/src%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71f41405500cec42be22f0080bf3f83f97bfa768/src%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feval.rs?ref=71f41405500cec42be22f0080bf3f83f97bfa768", "patch": "@@ -31,6 +31,8 @@ pub struct MiriConfig {\n     pub stacked_borrows: bool,\n     /// Controls alignment checking.\n     pub check_alignment: AlignmentCheck,\n+    /// Controls function [ABI](Abi) checking.\n+    pub check_abi: bool,\n     /// Determines if communication with the host environment is enabled.\n     pub communicate: bool,\n     /// Determines if memory leaks should be ignored.\n@@ -65,6 +67,7 @@ impl Default for MiriConfig {\n             validate: true,\n             stacked_borrows: true,\n             check_alignment: AlignmentCheck::Int,\n+            check_abi: true,\n             communicate: false,\n             ignore_leaks: false,\n             excluded_env_vars: vec![],"}, {"sha": "af6985ccebdbf4c4a7d468dff33a27de357a48ce", "filename": "src/helpers.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/71f41405500cec42be22f0080bf3f83f97bfa768/src%2Fhelpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71f41405500cec42be22f0080bf3f83f97bfa768/src%2Fhelpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fhelpers.rs?ref=71f41405500cec42be22f0080bf3f83f97bfa768", "patch": "@@ -165,7 +165,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let this = self.eval_context_mut();\n         let param_env = ty::ParamEnv::reveal_all(); // in Miri this is always the param_env we use... and this.param_env is private.\n         let callee_abi = f.ty(*this.tcx, param_env).fn_sig(*this.tcx).abi();\n-        if callee_abi != caller_abi {\n+        if this.machine.enforce_abi && callee_abi != caller_abi {\n             throw_ub_format!(\n                 \"calling a function with ABI {} using caller ABI {}\",\n                 callee_abi.name(),\n@@ -632,16 +632,19 @@ where\n }\n \n /// Check that the ABI is what we expect.\n-pub fn check_abi<'a>(abi: Abi, exp_abi: Abi) -> InterpResult<'a, ()> {\n-    if abi == exp_abi {\n-        Ok(())\n-    } else {\n+pub fn check_abi<'a>(\n+    this: &MiriEvalContext<'_, '_>,\n+    abi: Abi,\n+    exp_abi: Abi,\n+) -> InterpResult<'a, ()> {\n+    if this.machine.enforce_abi && abi != exp_abi {\n         throw_ub_format!(\n             \"calling a function with ABI {} using caller ABI {}\",\n             exp_abi.name(),\n             abi.name()\n         )\n     }\n+    Ok(())\n }\n \n pub fn isolation_error(name: &str) -> InterpResult<'static> {"}, {"sha": "175396ed119ccb731de84df858025badc458b31f", "filename": "src/machine.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/71f41405500cec42be22f0080bf3f83f97bfa768/src%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71f41405500cec42be22f0080bf3f83f97bfa768/src%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmachine.rs?ref=71f41405500cec42be22f0080bf3f83f97bfa768", "patch": "@@ -270,6 +270,9 @@ pub struct Evaluator<'mir, 'tcx> {\n     /// Whether to enforce the validity invariant.\n     pub(crate) validate: bool,\n \n+    /// Whether to enforce [ABI](Abi) of function calls.\n+    pub(crate) enforce_abi: bool,\n+\n     pub(crate) file_handler: shims::posix::FileHandler,\n     pub(crate) dir_handler: shims::posix::DirHandler,\n \n@@ -310,6 +313,7 @@ impl<'mir, 'tcx> Evaluator<'mir, 'tcx> {\n             tls: TlsData::default(),\n             communicate: config.communicate,\n             validate: config.validate,\n+            enforce_abi: config.check_abi,\n             file_handler: Default::default(),\n             dir_handler: Default::default(),\n             time_anchor: Instant::now(),\n@@ -371,6 +375,11 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n         ecx.machine.validate\n     }\n \n+    #[inline(always)]\n+    fn enforce_abi(ecx: &InterpCx<'mir, 'tcx, Self>) -> bool {\n+        ecx.machine.enforce_abi\n+    }\n+\n     #[inline(always)]\n     fn find_mir_or_eval_fn(\n         ecx: &mut InterpCx<'mir, 'tcx, Self>,"}, {"sha": "2afa1a8671289ad0f91068449086c1fc1d6c5371", "filename": "src/shims/foreign_items.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/71f41405500cec42be22f0080bf3f83f97bfa768/src%2Fshims%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71f41405500cec42be22f0080bf3f83f97bfa768/src%2Fshims%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fforeign_items.rs?ref=71f41405500cec42be22f0080bf3f83f97bfa768", "patch": "@@ -136,14 +136,14 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let (dest, ret) = match ret {\n             None => match link_name {\n                 \"miri_start_panic\" => {\n-                    check_abi(abi, Abi::Rust)?;\n+                    check_abi(this, abi, Abi::Rust)?;\n                     this.handle_miri_start_panic(args, unwind)?;\n                     return Ok(None);\n                 }\n                 // This matches calls to the foreign item `panic_impl`.\n                 // The implementation is provided by the function with the `#[panic_handler]` attribute.\n                 \"panic_impl\" => {\n-                    check_abi(abi, Abi::Rust)?;\n+                    check_abi(this, abi, Abi::Rust)?;\n                     let panic_impl_id = tcx.lang_items().panic_impl().unwrap();\n                     let panic_impl_instance = ty::Instance::mono(tcx, panic_impl_id);\n                     return Ok(Some(&*this.load_mir(panic_impl_instance.def, None)?));\n@@ -152,14 +152,14 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 | \"exit\"\n                 | \"ExitProcess\"\n                 => {\n-                    check_abi(abi, if link_name == \"exit\" { Abi::C { unwind: false } } else { Abi::System { unwind: false } })?;\n+                    check_abi(this, abi, if link_name == \"exit\" { Abi::C { unwind: false } } else { Abi::System { unwind: false } })?;\n                     let &[ref code] = check_arg_count(args)?;\n                     // it's really u32 for ExitProcess, but we have to put it into the `Exit` variant anyway\n                     let code = this.read_scalar(code)?.to_i32()?;\n                     throw_machine_stop!(TerminationInfo::Exit(code.into()));\n                 }\n                 \"abort\" => {\n-                    check_abi(abi, Abi::C { unwind: false })?;\n+                    check_abi(this, abi, Abi::C { unwind: false })?;\n                     throw_machine_stop!(TerminationInfo::Abort(\n                         \"the program aborted execution\".to_owned()\n                     ))\n@@ -180,7 +180,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             #[rustfmt::skip]\n             \"__rust_start_panic\" |\n             \"__rust_panic_cleanup\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                check_abi(this, abi, Abi::C { unwind: false })?;\n                 // This replicates some of the logic in `inject_panic_runtime`.\n                 // FIXME: is there a way to reuse that logic?\n                 let panic_runtime = match this.tcx.sess.panic_strategy() {\n@@ -221,7 +221,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         match link_name {\n             // Miri-specific extern functions\n             \"miri_static_root\" => {\n-                check_abi(abi, Abi::Rust)?;\n+                check_abi(this, abi, Abi::Rust)?;\n                 let &[ref ptr] = check_arg_count(args)?;\n                 let ptr = this.read_scalar(ptr)?.check_init()?;\n                 let ptr = this.force_ptr(ptr)?;\n@@ -233,27 +233,27 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n             // Obtains a Miri backtrace. See the README for details.\n             \"miri_get_backtrace\" => {\n-                check_abi(abi, Abi::Rust)?;\n+                check_abi(this, abi, Abi::Rust)?;\n                 this.handle_miri_get_backtrace(args, dest)?;\n             }\n \n             // Resolves a Miri backtrace frame. See the README for details.\n             \"miri_resolve_frame\" => {\n-                check_abi(abi, Abi::Rust)?;\n+                check_abi(this, abi, Abi::Rust)?;\n                 this.handle_miri_resolve_frame(args, dest)?;\n             }\n \n \n             // Standard C allocation\n             \"malloc\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                check_abi(this, abi, Abi::C { unwind: false })?;\n                 let &[ref size] = check_arg_count(args)?;\n                 let size = this.read_scalar(size)?.to_machine_usize(this)?;\n                 let res = this.malloc(size, /*zero_init:*/ false, MiriMemoryKind::C);\n                 this.write_scalar(res, dest)?;\n             }\n             \"calloc\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                check_abi(this, abi, Abi::C { unwind: false })?;\n                 let &[ref items, ref len] = check_arg_count(args)?;\n                 let items = this.read_scalar(items)?.to_machine_usize(this)?;\n                 let len = this.read_scalar(len)?.to_machine_usize(this)?;\n@@ -263,13 +263,13 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.write_scalar(res, dest)?;\n             }\n             \"free\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                check_abi(this, abi, Abi::C { unwind: false })?;\n                 let &[ref ptr] = check_arg_count(args)?;\n                 let ptr = this.read_scalar(ptr)?.check_init()?;\n                 this.free(ptr, MiriMemoryKind::C)?;\n             }\n             \"realloc\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                check_abi(this, abi, Abi::C { unwind: false })?;\n                 let &[ref old_ptr, ref new_size] = check_arg_count(args)?;\n                 let old_ptr = this.read_scalar(old_ptr)?.check_init()?;\n                 let new_size = this.read_scalar(new_size)?.to_machine_usize(this)?;\n@@ -281,7 +281,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             // (Usually these would be forwarded to to `#[global_allocator]`; we instead implement a generic\n             // allocation that also checks that all conditions are met, such as not permitting zero-sized allocations.)\n             \"__rust_alloc\" => {\n-                check_abi(abi, Abi::Rust)?;\n+                check_abi(this, abi, Abi::Rust)?;\n                 let &[ref size, ref align] = check_arg_count(args)?;\n                 let size = this.read_scalar(size)?.to_machine_usize(this)?;\n                 let align = this.read_scalar(align)?.to_machine_usize(this)?;\n@@ -294,7 +294,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.write_scalar(ptr, dest)?;\n             }\n             \"__rust_alloc_zeroed\" => {\n-                check_abi(abi, Abi::Rust)?;\n+                check_abi(this, abi, Abi::Rust)?;\n                 let &[ref size, ref align] = check_arg_count(args)?;\n                 let size = this.read_scalar(size)?.to_machine_usize(this)?;\n                 let align = this.read_scalar(align)?.to_machine_usize(this)?;\n@@ -309,7 +309,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.write_scalar(ptr, dest)?;\n             }\n             \"__rust_dealloc\" => {\n-                check_abi(abi, Abi::Rust)?;\n+                check_abi(this, abi, Abi::Rust)?;\n                 let &[ref ptr, ref old_size, ref align] = check_arg_count(args)?;\n                 let ptr = this.read_scalar(ptr)?.check_init()?;\n                 let old_size = this.read_scalar(old_size)?.to_machine_usize(this)?;\n@@ -323,7 +323,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 )?;\n             }\n             \"__rust_realloc\" => {\n-                check_abi(abi, Abi::Rust)?;\n+                check_abi(this, abi, Abi::Rust)?;\n                 let &[ref ptr, ref old_size, ref align, ref new_size] = check_arg_count(args)?;\n                 let ptr = this.force_ptr(this.read_scalar(ptr)?.check_init()?)?;\n                 let old_size = this.read_scalar(old_size)?.to_machine_usize(this)?;\n@@ -344,7 +344,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n             // C memory handling functions\n             \"memcmp\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                check_abi(this, abi, Abi::C { unwind: false })?;\n                 let &[ref left, ref right, ref n] = check_arg_count(args)?;\n                 let left = this.read_scalar(left)?.check_init()?;\n                 let right = this.read_scalar(right)?.check_init()?;\n@@ -365,7 +365,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"memrchr\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                check_abi(this, abi, Abi::C { unwind: false })?;\n                 let &[ref ptr, ref val, ref num] = check_arg_count(args)?;\n                 let ptr = this.read_scalar(ptr)?.check_init()?;\n                 let val = this.read_scalar(val)?.to_i32()? as u8;\n@@ -384,7 +384,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 }\n             }\n             \"memchr\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                check_abi(this, abi, Abi::C { unwind: false })?;\n                 let &[ref ptr, ref val, ref num] = check_arg_count(args)?;\n                 let ptr = this.read_scalar(ptr)?.check_init()?;\n                 let val = this.read_scalar(val)?.to_i32()? as u8;\n@@ -402,7 +402,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 }\n             }\n             \"strlen\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                check_abi(this, abi, Abi::C { unwind: false })?;\n                 let &[ref ptr] = check_arg_count(args)?;\n                 let ptr = this.read_scalar(ptr)?.check_init()?;\n                 let n = this.read_c_str(ptr)?.len();\n@@ -419,7 +419,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             | \"asinf\"\n             | \"atanf\"\n             => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                check_abi(this, abi, Abi::C { unwind: false })?;\n                 let &[ref f] = check_arg_count(args)?;\n                 // FIXME: Using host floats.\n                 let f = f32::from_bits(this.read_scalar(f)?.to_u32()?);\n@@ -440,7 +440,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             | \"hypotf\"\n             | \"atan2f\"\n             => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                check_abi(this, abi, Abi::C { unwind: false })?;\n                 let &[ref f1, ref f2] = check_arg_count(args)?;\n                 // underscore case for windows, here and below\n                 // (see https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/floating-point-primitives?view=vs-2019)\n@@ -463,7 +463,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             | \"asin\"\n             | \"atan\"\n             => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                check_abi(this, abi, Abi::C { unwind: false })?;\n                 let &[ref f] = check_arg_count(args)?;\n                 // FIXME: Using host floats.\n                 let f = f64::from_bits(this.read_scalar(f)?.to_u64()?);\n@@ -484,7 +484,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             | \"hypot\"\n             | \"atan2\"\n             => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                check_abi(this, abi, Abi::C { unwind: false })?;\n                 let &[ref f1, ref f2] = check_arg_count(args)?;\n                 // FIXME: Using host floats.\n                 let f1 = f64::from_bits(this.read_scalar(f1)?.to_u64()?);\n@@ -501,7 +501,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             | \"ldexp\"\n             | \"scalbn\"\n             => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                check_abi(this, abi, Abi::C { unwind: false })?;\n                 let &[ref x, ref exp] = check_arg_count(args)?;\n                 // For radix-2 (binary) systems, `ldexp` and `scalbn` are the same.\n                 let x = this.read_scalar(x)?.to_f64()?;\n@@ -523,12 +523,12 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n             // Architecture-specific shims\n             \"llvm.x86.sse2.pause\" if this.tcx.sess.target.arch == \"x86\" || this.tcx.sess.target.arch == \"x86_64\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                check_abi(this, abi, Abi::C { unwind: false })?;\n                 let &[] = check_arg_count(args)?;\n                 this.yield_active_thread();\n             }\n             \"llvm.aarch64.isb\" if this.tcx.sess.target.arch == \"aarch64\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                check_abi(this, abi, Abi::C { unwind: false })?;\n                 let &[ref arg] = check_arg_count(args)?;\n                 let arg = this.read_scalar(arg)?.to_i32()?;\n                 match arg {"}, {"sha": "5f420ac5363bbfc088752f82f4f2867475179380", "filename": "src/shims/posix/dlsym.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/71f41405500cec42be22f0080bf3f83f97bfa768/src%2Fshims%2Fposix%2Fdlsym.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71f41405500cec42be22f0080bf3f83f97bfa768/src%2Fshims%2Fposix%2Fdlsym.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fposix%2Fdlsym.rs?ref=71f41405500cec42be22f0080bf3f83f97bfa768", "patch": "@@ -35,7 +35,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     ) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n \n-        check_abi(abi, Abi::C { unwind: false })?;\n+        check_abi(this, abi, Abi::C { unwind: false })?;\n \n         match dlsym {\n             Dlsym::Linux(dlsym) => linux::EvalContextExt::call_dlsym(this, dlsym, args, ret),"}, {"sha": "5eb731d09c8641788b4e6d541ad5112cf45fb518", "filename": "src/shims/posix/foreign_items.rs", "status": "modified", "additions": 61, "deletions": 61, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/71f41405500cec42be22f0080bf3f83f97bfa768/src%2Fshims%2Fposix%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71f41405500cec42be22f0080bf3f83f97bfa768/src%2Fshims%2Fposix%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fposix%2Fforeign_items.rs?ref=71f41405500cec42be22f0080bf3f83f97bfa768", "patch": "@@ -25,51 +25,51 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         match link_name {\n             // Environment related shims\n             \"getenv\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                check_abi(this, abi, Abi::C { unwind: false })?;\n                 let &[ref name] = check_arg_count(args)?;\n                 let result = this.getenv(name)?;\n                 this.write_scalar(result, dest)?;\n             }\n             \"unsetenv\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                check_abi(this, abi, Abi::C { unwind: false })?;\n                 let &[ref name] = check_arg_count(args)?;\n                 let result = this.unsetenv(name)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"setenv\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                check_abi(this, abi, Abi::C { unwind: false })?;\n                 let &[ref name, ref value, ref overwrite] = check_arg_count(args)?;\n                 this.read_scalar(overwrite)?.to_i32()?;\n                 let result = this.setenv(name, value)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"getcwd\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                check_abi(this, abi, Abi::C { unwind: false })?;\n                 let &[ref buf, ref size] = check_arg_count(args)?;\n                 let result = this.getcwd(buf, size)?;\n                 this.write_scalar(result, dest)?;\n             }\n             \"chdir\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                check_abi(this, abi, Abi::C { unwind: false })?;\n                 let &[ref path] = check_arg_count(args)?;\n                 let result = this.chdir(path)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n \n             // File related shims\n             \"open\" | \"open64\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                check_abi(this, abi, Abi::C { unwind: false })?;\n                 let &[ref path, ref flag, ref mode] = check_arg_count(args)?;\n                 let result = this.open(path, flag, mode)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"fcntl\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                check_abi(this, abi, Abi::C { unwind: false })?;\n                 let result = this.fcntl(args)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"read\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                check_abi(this, abi, Abi::C { unwind: false })?;\n                 let &[ref fd, ref buf, ref count] = check_arg_count(args)?;\n                 let fd = this.read_scalar(fd)?.to_i32()?;\n                 let buf = this.read_scalar(buf)?.check_init()?;\n@@ -78,7 +78,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.write_scalar(Scalar::from_machine_isize(result, this), dest)?;\n             }\n             \"write\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                check_abi(this, abi, Abi::C { unwind: false })?;\n                 let &[ref fd, ref buf, ref n] = check_arg_count(args)?;\n                 let fd = this.read_scalar(fd)?.to_i32()?;\n                 let buf = this.read_scalar(buf)?.check_init()?;\n@@ -89,70 +89,70 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.write_scalar(Scalar::from_machine_isize(result, this), dest)?;\n             }\n             \"unlink\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                check_abi(this, abi, Abi::C { unwind: false })?;\n                 let &[ref path] = check_arg_count(args)?;\n                 let result = this.unlink(path)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"symlink\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                check_abi(this, abi, Abi::C { unwind: false })?;\n                 let &[ref target, ref linkpath] = check_arg_count(args)?;\n                 let result = this.symlink(target, linkpath)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"rename\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                check_abi(this, abi, Abi::C { unwind: false })?;\n                 let &[ref oldpath, ref newpath] = check_arg_count(args)?;\n                 let result = this.rename(oldpath, newpath)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"mkdir\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                check_abi(this, abi, Abi::C { unwind: false })?;\n                 let &[ref path, ref mode] = check_arg_count(args)?;\n                 let result = this.mkdir(path, mode)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"rmdir\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                check_abi(this, abi, Abi::C { unwind: false })?;\n                 let &[ref path] = check_arg_count(args)?;\n                 let result = this.rmdir(path)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"closedir\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                check_abi(this, abi, Abi::C { unwind: false })?;\n                 let &[ref dirp] = check_arg_count(args)?;\n                 let result = this.closedir(dirp)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"lseek\" | \"lseek64\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                check_abi(this, abi, Abi::C { unwind: false })?;\n                 let &[ref fd, ref offset, ref whence] = check_arg_count(args)?;\n                 let result = this.lseek64(fd, offset, whence)?;\n                 // \"lseek\" is only used on macOS which is 64bit-only, so `i64` always works.\n                 this.write_scalar(Scalar::from_i64(result), dest)?;\n             }\n             \"fsync\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                check_abi(this, abi, Abi::C { unwind: false })?;\n                 let &[ref fd] = check_arg_count(args)?;\n                 let result = this.fsync(fd)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"fdatasync\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                check_abi(this, abi, Abi::C { unwind: false })?;\n                 let &[ref fd] = check_arg_count(args)?;\n                 let result = this.fdatasync(fd)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"readlink\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                check_abi(this, abi, Abi::C { unwind: false })?;\n                 let &[ref pathname, ref buf, ref bufsize] = check_arg_count(args)?;\n                 let result = this.readlink(pathname, buf, bufsize)?;\n                 this.write_scalar(Scalar::from_machine_isize(result, this), dest)?;\n             }\n \n             // Allocation\n             \"posix_memalign\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                check_abi(this, abi, Abi::C { unwind: false })?;\n                 let &[ref ret, ref align, ref size] = check_arg_count(args)?;\n                 let ret = this.deref_operand(ret)?;\n                 let align = this.read_scalar(align)?.to_machine_usize(this)?;\n@@ -183,7 +183,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n             // Dynamic symbol loading\n             \"dlsym\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                check_abi(this, abi, Abi::C { unwind: false })?;\n                 let &[ref handle, ref symbol] = check_arg_count(args)?;\n                 this.read_scalar(handle)?.to_machine_usize(this)?;\n                 let symbol = this.read_scalar(symbol)?.check_init()?;\n@@ -198,7 +198,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n             // Querying system information\n             \"sysconf\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                check_abi(this, abi, Abi::C { unwind: false })?;\n                 let &[ref name] = check_arg_count(args)?;\n                 let name = this.read_scalar(name)?.to_i32()?;\n \n@@ -224,7 +224,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n             // Thread-local storage\n             \"pthread_key_create\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                check_abi(this, abi, Abi::C { unwind: false })?;\n                 let &[ref key, ref dtor] = check_arg_count(args)?;\n                 let key_place = this.deref_operand(key)?;\n                 let dtor = this.read_scalar(dtor)?.check_init()?;\n@@ -253,23 +253,23 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.write_null(dest)?;\n             }\n             \"pthread_key_delete\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                check_abi(this, abi, Abi::C { unwind: false })?;\n                 let &[ref key] = check_arg_count(args)?;\n                 let key = this.force_bits(this.read_scalar(key)?.check_init()?, key.layout.size)?;\n                 this.machine.tls.delete_tls_key(key)?;\n                 // Return success (0)\n                 this.write_null(dest)?;\n             }\n             \"pthread_getspecific\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                check_abi(this, abi, Abi::C { unwind: false })?;\n                 let &[ref key] = check_arg_count(args)?;\n                 let key = this.force_bits(this.read_scalar(key)?.check_init()?, key.layout.size)?;\n                 let active_thread = this.get_active_thread();\n                 let ptr = this.machine.tls.load_tls(key, active_thread, this)?;\n                 this.write_scalar(ptr, dest)?;\n             }\n             \"pthread_setspecific\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                check_abi(this, abi, Abi::C { unwind: false })?;\n                 let &[ref key, ref new_ptr] = check_arg_count(args)?;\n                 let key = this.force_bits(this.read_scalar(key)?.check_init()?, key.layout.size)?;\n                 let active_thread = this.get_active_thread();\n@@ -282,177 +282,177 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n             // Synchronization primitives\n             \"pthread_mutexattr_init\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                check_abi(this, abi, Abi::C { unwind: false })?;\n                 let &[ref attr] = check_arg_count(args)?;\n                 let result = this.pthread_mutexattr_init(attr)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_mutexattr_settype\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                check_abi(this, abi, Abi::C { unwind: false })?;\n                 let &[ref attr, ref kind] = check_arg_count(args)?;\n                 let result = this.pthread_mutexattr_settype(attr, kind)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_mutexattr_destroy\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                check_abi(this, abi, Abi::C { unwind: false })?;\n                 let &[ref attr] = check_arg_count(args)?;\n                 let result = this.pthread_mutexattr_destroy(attr)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_mutex_init\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                check_abi(this, abi, Abi::C { unwind: false })?;\n                 let &[ref mutex, ref attr] = check_arg_count(args)?;\n                 let result = this.pthread_mutex_init(mutex, attr)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_mutex_lock\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                check_abi(this, abi, Abi::C { unwind: false })?;\n                 let &[ref mutex] = check_arg_count(args)?;\n                 let result = this.pthread_mutex_lock(mutex)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_mutex_trylock\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                check_abi(this, abi, Abi::C { unwind: false })?;\n                 let &[ref mutex] = check_arg_count(args)?;\n                 let result = this.pthread_mutex_trylock(mutex)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_mutex_unlock\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                check_abi(this, abi, Abi::C { unwind: false })?;\n                 let &[ref mutex] = check_arg_count(args)?;\n                 let result = this.pthread_mutex_unlock(mutex)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_mutex_destroy\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                check_abi(this, abi, Abi::C { unwind: false })?;\n                 let &[ref mutex] = check_arg_count(args)?;\n                 let result = this.pthread_mutex_destroy(mutex)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_rwlock_rdlock\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                check_abi(this, abi, Abi::C { unwind: false })?;\n                 let &[ref rwlock] = check_arg_count(args)?;\n                 let result = this.pthread_rwlock_rdlock(rwlock)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_rwlock_tryrdlock\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                check_abi(this, abi, Abi::C { unwind: false })?;\n                 let &[ref rwlock] = check_arg_count(args)?;\n                 let result = this.pthread_rwlock_tryrdlock(rwlock)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_rwlock_wrlock\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                check_abi(this, abi, Abi::C { unwind: false })?;\n                 let &[ref rwlock] = check_arg_count(args)?;\n                 let result = this.pthread_rwlock_wrlock(rwlock)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_rwlock_trywrlock\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                check_abi(this, abi, Abi::C { unwind: false })?;\n                 let &[ref rwlock] = check_arg_count(args)?;\n                 let result = this.pthread_rwlock_trywrlock(rwlock)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_rwlock_unlock\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                check_abi(this, abi, Abi::C { unwind: false })?;\n                 let &[ref rwlock] = check_arg_count(args)?;\n                 let result = this.pthread_rwlock_unlock(rwlock)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_rwlock_destroy\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                check_abi(this, abi, Abi::C { unwind: false })?;\n                 let &[ref rwlock] = check_arg_count(args)?;\n                 let result = this.pthread_rwlock_destroy(rwlock)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_condattr_init\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                check_abi(this, abi, Abi::C { unwind: false })?;\n                 let &[ref attr] = check_arg_count(args)?;\n                 let result = this.pthread_condattr_init(attr)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_condattr_destroy\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                check_abi(this, abi, Abi::C { unwind: false })?;\n                 let &[ref attr] = check_arg_count(args)?;\n                 let result = this.pthread_condattr_destroy(attr)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_cond_init\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                check_abi(this, abi, Abi::C { unwind: false })?;\n                 let &[ref cond, ref attr] = check_arg_count(args)?;\n                 let result = this.pthread_cond_init(cond, attr)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_cond_signal\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                check_abi(this, abi, Abi::C { unwind: false })?;\n                 let &[ref cond] = check_arg_count(args)?;\n                 let result = this.pthread_cond_signal(cond)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_cond_broadcast\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                check_abi(this, abi, Abi::C { unwind: false })?;\n                 let &[ref cond] = check_arg_count(args)?;\n                 let result = this.pthread_cond_broadcast(cond)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_cond_wait\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                check_abi(this, abi, Abi::C { unwind: false })?;\n                 let &[ref cond, ref mutex] = check_arg_count(args)?;\n                 let result = this.pthread_cond_wait(cond, mutex)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_cond_timedwait\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                check_abi(this, abi, Abi::C { unwind: false })?;\n                 let &[ref cond, ref mutex, ref abstime] = check_arg_count(args)?;\n                 this.pthread_cond_timedwait(cond, mutex, abstime, dest)?;\n             }\n             \"pthread_cond_destroy\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                check_abi(this, abi, Abi::C { unwind: false })?;\n                 let &[ref cond] = check_arg_count(args)?;\n                 let result = this.pthread_cond_destroy(cond)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n \n             // Threading\n             \"pthread_create\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                check_abi(this, abi, Abi::C { unwind: false })?;\n                 let &[ref thread, ref attr, ref start, ref arg] = check_arg_count(args)?;\n                 let result = this.pthread_create(thread, attr, start, arg)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_join\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                check_abi(this, abi, Abi::C { unwind: false })?;\n                 let &[ref thread, ref retval] = check_arg_count(args)?;\n                 let result = this.pthread_join(thread, retval)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_detach\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                check_abi(this, abi, Abi::C { unwind: false })?;\n                 let &[ref thread] = check_arg_count(args)?;\n                 let result = this.pthread_detach(thread)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_self\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                check_abi(this, abi, Abi::C { unwind: false })?;\n                 let &[] = check_arg_count(args)?;\n                 this.pthread_self(dest)?;\n             }\n             \"sched_yield\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                check_abi(this, abi, Abi::C { unwind: false })?;\n                 let &[] = check_arg_count(args)?;\n                 let result = this.sched_yield()?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"nanosleep\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                check_abi(this, abi, Abi::C { unwind: false })?;\n                 let &[ref req, ref rem] = check_arg_count(args)?;\n                 let result = this.nanosleep(req, rem)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n \n             // Miscellaneous\n             \"isatty\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                check_abi(this, abi, Abi::C { unwind: false })?;\n                 let &[ref fd] = check_arg_count(args)?;\n                 this.read_scalar(fd)?.to_i32()?;\n                 // \"returns 1 if fd is an open file descriptor referring to a terminal; otherwise 0 is returned, and errno is set to indicate the error\"\n@@ -462,7 +462,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.write_null(dest)?;\n             }\n             \"pthread_atfork\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                check_abi(this, abi, Abi::C { unwind: false })?;\n                 let &[ref prepare, ref parent, ref child] = check_arg_count(args)?;\n                 this.force_bits(this.read_scalar(prepare)?.check_init()?, this.memory.pointer_size())?;\n                 this.force_bits(this.read_scalar(parent)?.check_init()?, this.memory.pointer_size())?;\n@@ -475,7 +475,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             // These shims are enabled only when the caller is in the standard library.\n             \"pthread_attr_getguardsize\"\n             if this.frame().instance.to_string().starts_with(\"std::sys::unix::\") => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                check_abi(this, abi, Abi::C { unwind: false })?;\n                 let &[ref _attr, ref guard_size] = check_arg_count(args)?;\n                 let guard_size = this.deref_operand(guard_size)?;\n                 let guard_size_layout = this.libc_ty_layout(\"size_t\")?;\n@@ -488,28 +488,28 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             | \"pthread_attr_init\"\n             | \"pthread_attr_destroy\"\n             if this.frame().instance.to_string().starts_with(\"std::sys::unix::\") => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                check_abi(this, abi, Abi::C { unwind: false })?;\n                 let &[_] = check_arg_count(args)?;\n                 this.write_null(dest)?;\n             }\n             | \"pthread_attr_setstacksize\"\n             if this.frame().instance.to_string().starts_with(\"std::sys::unix::\") => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                check_abi(this, abi, Abi::C { unwind: false })?;\n                 let &[_, _] = check_arg_count(args)?;\n                 this.write_null(dest)?;\n             }\n \n             | \"signal\"\n             | \"sigaltstack\"\n             if this.frame().instance.to_string().starts_with(\"std::sys::unix::\") => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                check_abi(this, abi, Abi::C { unwind: false })?;\n                 let &[_, _] = check_arg_count(args)?;\n                 this.write_null(dest)?;\n             }\n             | \"sigaction\"\n             | \"mprotect\"\n             if this.frame().instance.to_string().starts_with(\"std::sys::unix::\") => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                check_abi(this, abi, Abi::C { unwind: false })?;\n                 let &[_, _, _] = check_arg_count(args)?;\n                 this.write_null(dest)?;\n             }"}, {"sha": "d16c740ffc547ff8221730e58de13a4eecf25d2d", "filename": "src/shims/posix/linux/foreign_items.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/71f41405500cec42be22f0080bf3f83f97bfa768/src%2Fshims%2Fposix%2Flinux%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71f41405500cec42be22f0080bf3f83f97bfa768/src%2Fshims%2Fposix%2Flinux%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fposix%2Flinux%2Fforeign_items.rs?ref=71f41405500cec42be22f0080bf3f83f97bfa768", "patch": "@@ -23,7 +23,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         match link_name {\n             // errno\n             \"__errno_location\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                check_abi(this, abi, Abi::C { unwind: false })?;\n                 let &[] = check_arg_count(args)?;\n                 let errno_place = this.last_error_place()?;\n                 this.write_scalar(errno_place.to_ref().to_scalar()?, dest)?;\n@@ -33,32 +33,32 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             // These symbols have different names on Linux and macOS, which is the only reason they are not\n             // in the `posix` module.\n             \"close\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                check_abi(this, abi, Abi::C { unwind: false })?;\n                 let &[ref fd] = check_arg_count(args)?;\n                 let result = this.close(fd)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"opendir\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                check_abi(this, abi, Abi::C { unwind: false })?;\n                 let &[ref name] = check_arg_count(args)?;\n                 let result = this.opendir(name)?;\n                 this.write_scalar(result, dest)?;\n             }\n             \"readdir64_r\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                check_abi(this, abi, Abi::C { unwind: false })?;\n                 let &[ref dirp, ref entry, ref result] = check_arg_count(args)?;\n                 let result = this.linux_readdir64_r(dirp, entry, result)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"ftruncate64\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                check_abi(this, abi, Abi::C { unwind: false })?;\n                 let &[ref fd, ref length] = check_arg_count(args)?;\n                 let result = this.ftruncate64(fd, length)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             // Linux-only\n             \"posix_fadvise\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                check_abi(this, abi, Abi::C { unwind: false })?;\n                 let &[ref fd, ref offset, ref len, ref advice] = check_arg_count(args)?;\n                 this.read_scalar(fd)?.to_i32()?;\n                 this.read_scalar(offset)?.to_machine_isize(this)?;\n@@ -68,15 +68,15 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.write_null(dest)?;\n             }\n             \"sync_file_range\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                check_abi(this, abi, Abi::C { unwind: false })?;\n                 let &[ref fd, ref offset, ref nbytes, ref flags] = check_arg_count(args)?;\n                 let result = this.sync_file_range(fd, offset, nbytes, flags)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n \n             // Time related shims\n             \"clock_gettime\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                check_abi(this, abi, Abi::C { unwind: false })?;\n                 // This is a POSIX function but it has only been tested on linux.\n                 let &[ref clk_id, ref tp] = check_arg_count(args)?;\n                 let result = this.clock_gettime(clk_id, tp)?;\n@@ -85,7 +85,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n             // Querying system information\n             \"pthread_attr_getstack\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                check_abi(this, abi, Abi::C { unwind: false })?;\n                 // We don't support \"pthread_attr_setstack\", so we just pretend all stacks have the same values here.\n                 let &[ref attr_place, ref addr_place, ref size_place] = check_arg_count(args)?;\n                 this.deref_operand(attr_place)?;\n@@ -107,27 +107,27 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n             // Threading\n             \"prctl\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                check_abi(this, abi, Abi::C { unwind: false })?;\n                 let &[ref option, ref arg2, ref arg3, ref arg4, ref arg5] = check_arg_count(args)?;\n                 let result = this.prctl(option, arg2, arg3, arg4, arg5)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_condattr_setclock\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                check_abi(this, abi, Abi::C { unwind: false })?;\n                 let &[ref attr, ref clock_id] = check_arg_count(args)?;\n                 let result = this.pthread_condattr_setclock(attr, clock_id)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_condattr_getclock\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                check_abi(this, abi, Abi::C { unwind: false })?;\n                 let &[ref attr, ref clock_id] = check_arg_count(args)?;\n                 let result = this.pthread_condattr_getclock(attr, clock_id)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n \n             // Dynamically invoked syscalls\n             \"syscall\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                check_abi(this, abi, Abi::C { unwind: false })?;\n                 // The syscall variadic function is legal to call with more arguments than needed,\n                 // extra arguments are simply ignored. However, all arguments need to be scalars;\n                 // other types might be treated differently by the calling convention.\n@@ -188,12 +188,12 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n             // Miscelanneous\n             \"getrandom\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                check_abi(this, abi, Abi::C { unwind: false })?;\n                 let &[ref ptr, ref len, ref flags] = check_arg_count(args)?;\n                 getrandom(this, ptr, len, flags, dest)?;\n             }\n             \"sched_getaffinity\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                check_abi(this, abi, Abi::C { unwind: false })?;\n                 let &[ref pid, ref cpusetsize, ref mask] = check_arg_count(args)?;\n                 this.read_scalar(pid)?.to_i32()?;\n                 this.read_scalar(cpusetsize)?.to_machine_usize(this)?;\n@@ -209,7 +209,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             \"pthread_getattr_np\"\n                 if this.frame().instance.to_string().starts_with(\"std::sys::unix::\") =>\n             {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                check_abi(this, abi, Abi::C { unwind: false })?;\n                 let &[ref _thread, ref _attr] = check_arg_count(args)?;\n                 this.write_null(dest)?;\n             }"}, {"sha": "de4ed56633cbf6033c2f7e6316f77d01b6e4a79a", "filename": "src/shims/posix/macos/foreign_items.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/71f41405500cec42be22f0080bf3f83f97bfa768/src%2Fshims%2Fposix%2Fmacos%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71f41405500cec42be22f0080bf3f83f97bfa768/src%2Fshims%2Fposix%2Fmacos%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fposix%2Fmacos%2Fforeign_items.rs?ref=71f41405500cec42be22f0080bf3f83f97bfa768", "patch": "@@ -21,99 +21,99 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         match link_name {\n             // errno\n             \"__error\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                check_abi(this, abi, Abi::C { unwind: false })?;\n                 let &[] = check_arg_count(args)?;\n                 let errno_place = this.last_error_place()?;\n                 this.write_scalar(errno_place.to_ref().to_scalar()?, dest)?;\n             }\n \n             // File related shims\n             \"close\" | \"close$NOCANCEL\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                check_abi(this, abi, Abi::C { unwind: false })?;\n                 let &[ref result] = check_arg_count(args)?;\n                 let result = this.close(result)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"stat\" | \"stat$INODE64\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                check_abi(this, abi, Abi::C { unwind: false })?;\n                 let &[ref path, ref buf] = check_arg_count(args)?;\n                 let result = this.macos_stat(path, buf)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"lstat\" | \"lstat$INODE64\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                check_abi(this, abi, Abi::C { unwind: false })?;\n                 let &[ref path, ref buf] = check_arg_count(args)?;\n                 let result = this.macos_lstat(path, buf)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"fstat\" | \"fstat$INODE64\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                check_abi(this, abi, Abi::C { unwind: false })?;\n                 let &[ref fd, ref buf] = check_arg_count(args)?;\n                 let result = this.macos_fstat(fd, buf)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"opendir\" | \"opendir$INODE64\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                check_abi(this, abi, Abi::C { unwind: false })?;\n                 let &[ref name] = check_arg_count(args)?;\n                 let result = this.opendir(name)?;\n                 this.write_scalar(result, dest)?;\n             }\n             \"readdir_r\" | \"readdir_r$INODE64\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                check_abi(this, abi, Abi::C { unwind: false })?;\n                 let &[ref dirp, ref entry, ref result] = check_arg_count(args)?;\n                 let result = this.macos_readdir_r(dirp, entry, result)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"ftruncate\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                check_abi(this, abi, Abi::C { unwind: false })?;\n                 let &[ref fd, ref length] = check_arg_count(args)?;\n                 let result = this.ftruncate64(fd, length)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n \n             // Environment related shims\n             \"_NSGetEnviron\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                check_abi(this, abi, Abi::C { unwind: false })?;\n                 let &[] = check_arg_count(args)?;\n                 this.write_scalar(this.machine.env_vars.environ.unwrap().ptr, dest)?;\n             }\n \n             // Time related shims\n             \"gettimeofday\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                check_abi(this, abi, Abi::C { unwind: false })?;\n                 let &[ref tv, ref tz] = check_arg_count(args)?;\n                 let result = this.gettimeofday(tv, tz)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"mach_absolute_time\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                check_abi(this, abi, Abi::C { unwind: false })?;\n                 let &[] = check_arg_count(args)?;\n                 let result = this.mach_absolute_time()?;\n                 this.write_scalar(Scalar::from_u64(result), dest)?;\n             }\n \n             \"mach_timebase_info\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                check_abi(this, abi, Abi::C { unwind: false })?;\n                 let &[ref info] = check_arg_count(args)?;\n                 let result = this.mach_timebase_info(info)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n \n             // Access to command-line arguments\n             \"_NSGetArgc\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                check_abi(this, abi, Abi::C { unwind: false })?;\n                 let &[] = check_arg_count(args)?;\n                 this.write_scalar(this.machine.argc.expect(\"machine must be initialized\"), dest)?;\n             }\n             \"_NSGetArgv\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                check_abi(this, abi, Abi::C { unwind: false })?;\n                 let &[] = check_arg_count(args)?;\n                 this.write_scalar(this.machine.argv.expect(\"machine must be initialized\"), dest)?;\n             }\n \n             // Thread-local storage\n             \"_tlv_atexit\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                check_abi(this, abi, Abi::C { unwind: false })?;\n                 let &[ref dtor, ref data] = check_arg_count(args)?;\n                 let dtor = this.read_scalar(dtor)?.check_init()?;\n                 let dtor = this.memory.get_fn(dtor)?.as_instance()?;\n@@ -124,14 +124,14 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n             // Querying system information\n             \"pthread_get_stackaddr_np\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                check_abi(this, abi, Abi::C { unwind: false })?;\n                 let &[ref thread] = check_arg_count(args)?;\n                 this.read_scalar(thread)?.to_machine_usize(this)?;\n                 let stack_addr = Scalar::from_uint(STACK_ADDR, this.pointer_size());\n                 this.write_scalar(stack_addr, dest)?;\n             }\n             \"pthread_get_stacksize_np\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                check_abi(this, abi, Abi::C { unwind: false })?;\n                 let &[ref thread] = check_arg_count(args)?;\n                 this.read_scalar(thread)?.to_machine_usize(this)?;\n                 let stack_size = Scalar::from_uint(STACK_SIZE, this.pointer_size());\n@@ -140,7 +140,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n             // Threading\n             \"pthread_setname_np\" => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                check_abi(this, abi, Abi::C { unwind: false })?;\n                 let &[ref name] = check_arg_count(args)?;\n                 let name = this.read_scalar(name)?.check_init()?;\n                 this.pthread_setname_np(name)?;\n@@ -149,7 +149,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             // Incomplete shims that we \"stub out\" just to get pre-main initialization code to work.\n             // These shims are enabled only when the caller is in the standard library.\n             \"mmap\" if this.frame().instance.to_string().starts_with(\"std::sys::unix::\") => {\n-                check_abi(abi, Abi::C { unwind: false })?;\n+                check_abi(this, abi, Abi::C { unwind: false })?;\n                 // This is a horrible hack, but since the guard page mechanism calls mmap and expects a particular return value, we just give it that value.\n                 let &[ref addr, _, _, _, _, _] = check_arg_count(args)?;\n                 let addr = this.read_scalar(addr)?.check_init()?;"}, {"sha": "18e2ed3db59b519fff29fac5335835e02adbe7cf", "filename": "src/shims/windows/dlsym.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/71f41405500cec42be22f0080bf3f83f97bfa768/src%2Fshims%2Fwindows%2Fdlsym.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71f41405500cec42be22f0080bf3f83f97bfa768/src%2Fshims%2Fwindows%2Fdlsym.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fwindows%2Fdlsym.rs?ref=71f41405500cec42be22f0080bf3f83f97bfa768", "patch": "@@ -31,7 +31,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let (_dest, _ret) = ret.expect(\"we don't support any diverging dlsym\");\n         assert!(this.tcx.sess.target.os == \"windows\");\n \n-        check_abi(abi, Abi::System { unwind: false })?;\n+        check_abi(this, abi, Abi::System { unwind: false })?;\n \n         match dlsym {}\n     }"}, {"sha": "d7b86fff7327431faf586d643fcc451c79e1ee15", "filename": "src/shims/windows/foreign_items.rs", "status": "modified", "additions": 40, "deletions": 40, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/71f41405500cec42be22f0080bf3f83f97bfa768/src%2Fshims%2Fwindows%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71f41405500cec42be22f0080bf3f83f97bfa768/src%2Fshims%2Fwindows%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fwindows%2Fforeign_items.rs?ref=71f41405500cec42be22f0080bf3f83f97bfa768", "patch": "@@ -28,53 +28,53 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         match link_name {\n             // Environment related shims\n             \"GetEnvironmentVariableW\" => {\n-                check_abi(abi, Abi::System { unwind: false })?;\n+                check_abi(this, abi, Abi::System { unwind: false })?;\n                 let &[ref name, ref buf, ref size] = check_arg_count(args)?;\n                 let result = this.GetEnvironmentVariableW(name, buf, size)?;\n                 this.write_scalar(Scalar::from_u32(result), dest)?;\n             }\n             \"SetEnvironmentVariableW\" => {\n-                check_abi(abi, Abi::System { unwind: false })?;\n+                check_abi(this, abi, Abi::System { unwind: false })?;\n                 let &[ref name, ref value] = check_arg_count(args)?;\n                 let result = this.SetEnvironmentVariableW(name, value)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"GetEnvironmentStringsW\" => {\n-                check_abi(abi, Abi::System { unwind: false })?;\n+                check_abi(this, abi, Abi::System { unwind: false })?;\n                 let &[] = check_arg_count(args)?;\n                 let result = this.GetEnvironmentStringsW()?;\n                 this.write_scalar(result, dest)?;\n             }\n             \"FreeEnvironmentStringsW\" => {\n-                check_abi(abi, Abi::System { unwind: false })?;\n+                check_abi(this, abi, Abi::System { unwind: false })?;\n                 let &[ref env_block] = check_arg_count(args)?;\n                 let result = this.FreeEnvironmentStringsW(env_block)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"GetCurrentDirectoryW\" => {\n-                check_abi(abi, Abi::System { unwind: false })?;\n+                check_abi(this, abi, Abi::System { unwind: false })?;\n                 let &[ref size, ref buf] = check_arg_count(args)?;\n                 let result = this.GetCurrentDirectoryW(size, buf)?;\n                 this.write_scalar(Scalar::from_u32(result), dest)?;\n             }\n             \"SetCurrentDirectoryW\" => {\n-                check_abi(abi, Abi::System { unwind: false })?;\n+                check_abi(this, abi, Abi::System { unwind: false })?;\n                 let &[ref path] = check_arg_count(args)?;\n                 let result = this.SetCurrentDirectoryW(path)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n \n             // File related shims\n             \"GetStdHandle\" => {\n-                check_abi(abi, Abi::System { unwind: false })?;\n+                check_abi(this, abi, Abi::System { unwind: false })?;\n                 let &[ref which] = check_arg_count(args)?;\n                 let which = this.read_scalar(which)?.to_i32()?;\n                 // We just make this the identity function, so we know later in `WriteFile`\n                 // which one it is.\n                 this.write_scalar(Scalar::from_machine_isize(which.into(), this), dest)?;\n             }\n             \"WriteFile\" => {\n-                check_abi(abi, Abi::System { unwind: false })?;\n+                check_abi(this, abi, Abi::System { unwind: false })?;\n                 let &[ref handle, ref buf, ref n, ref written_ptr, ref overlapped] =\n                     check_arg_count(args)?;\n                 this.read_scalar(overlapped)?.to_machine_usize(this)?; // this is a poiner, that we ignore\n@@ -110,7 +110,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n             // Allocation\n             \"HeapAlloc\" => {\n-                check_abi(abi, Abi::System { unwind: false })?;\n+                check_abi(this, abi, Abi::System { unwind: false })?;\n                 let &[ref handle, ref flags, ref size] = check_arg_count(args)?;\n                 this.read_scalar(handle)?.to_machine_isize(this)?;\n                 let flags = this.read_scalar(flags)?.to_u32()?;\n@@ -120,7 +120,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.write_scalar(res, dest)?;\n             }\n             \"HeapFree\" => {\n-                check_abi(abi, Abi::System { unwind: false })?;\n+                check_abi(this, abi, Abi::System { unwind: false })?;\n                 let &[ref handle, ref flags, ref ptr] = check_arg_count(args)?;\n                 this.read_scalar(handle)?.to_machine_isize(this)?;\n                 this.read_scalar(flags)?.to_u32()?;\n@@ -129,7 +129,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.write_scalar(Scalar::from_i32(1), dest)?;\n             }\n             \"HeapReAlloc\" => {\n-                check_abi(abi, Abi::System { unwind: false })?;\n+                check_abi(this, abi, Abi::System { unwind: false })?;\n                 let &[ref handle, ref flags, ref ptr, ref size] = check_arg_count(args)?;\n                 this.read_scalar(handle)?.to_machine_isize(this)?;\n                 this.read_scalar(flags)?.to_u32()?;\n@@ -141,21 +141,21 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n             // errno\n             \"SetLastError\" => {\n-                check_abi(abi, Abi::System { unwind: false })?;\n+                check_abi(this, abi, Abi::System { unwind: false })?;\n                 let &[ref error] = check_arg_count(args)?;\n                 let error = this.read_scalar(error)?.check_init()?;\n                 this.set_last_error(error)?;\n             }\n             \"GetLastError\" => {\n-                check_abi(abi, Abi::System { unwind: false })?;\n+                check_abi(this, abi, Abi::System { unwind: false })?;\n                 let &[] = check_arg_count(args)?;\n                 let last_error = this.get_last_error()?;\n                 this.write_scalar(last_error, dest)?;\n             }\n \n             // Querying system information\n             \"GetSystemInfo\" => {\n-                check_abi(abi, Abi::System { unwind: false })?;\n+                check_abi(this, abi, Abi::System { unwind: false })?;\n                 let &[ref system_info] = check_arg_count(args)?;\n                 let system_info = this.deref_operand(system_info)?;\n                 // Initialize with `0`.\n@@ -171,7 +171,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n             // Thread-local storage\n             \"TlsAlloc\" => {\n-                check_abi(abi, Abi::System { unwind: false })?;\n+                check_abi(this, abi, Abi::System { unwind: false })?;\n                 // This just creates a key; Windows does not natively support TLS destructors.\n \n                 // Create key and return it.\n@@ -180,15 +180,15 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.write_scalar(Scalar::from_uint(key, dest.layout.size), dest)?;\n             }\n             \"TlsGetValue\" => {\n-                check_abi(abi, Abi::System { unwind: false })?;\n+                check_abi(this, abi, Abi::System { unwind: false })?;\n                 let &[ref key] = check_arg_count(args)?;\n                 let key = u128::from(this.read_scalar(key)?.to_u32()?);\n                 let active_thread = this.get_active_thread();\n                 let ptr = this.machine.tls.load_tls(key, active_thread, this)?;\n                 this.write_scalar(ptr, dest)?;\n             }\n             \"TlsSetValue\" => {\n-                check_abi(abi, Abi::System { unwind: false })?;\n+                check_abi(this, abi, Abi::System { unwind: false })?;\n                 let &[ref key, ref new_ptr] = check_arg_count(args)?;\n                 let key = u128::from(this.read_scalar(key)?.to_u32()?);\n                 let active_thread = this.get_active_thread();\n@@ -201,7 +201,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n             // Access to command-line arguments\n             \"GetCommandLineW\" => {\n-                check_abi(abi, Abi::System { unwind: false })?;\n+                check_abi(this, abi, Abi::System { unwind: false })?;\n                 let &[] = check_arg_count(args)?;\n                 this.write_scalar(\n                     this.machine.cmd_line.expect(\"machine must be initialized\"),\n@@ -211,20 +211,20 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n             // Time related shims\n             \"GetSystemTimeAsFileTime\" => {\n-                check_abi(abi, Abi::System { unwind: false })?;\n+                check_abi(this, abi, Abi::System { unwind: false })?;\n                 #[allow(non_snake_case)]\n                 let &[ref LPFILETIME] = check_arg_count(args)?;\n                 this.GetSystemTimeAsFileTime(LPFILETIME)?;\n             }\n             \"QueryPerformanceCounter\" => {\n-                check_abi(abi, Abi::System { unwind: false })?;\n+                check_abi(this, abi, Abi::System { unwind: false })?;\n                 #[allow(non_snake_case)]\n                 let &[ref lpPerformanceCount] = check_arg_count(args)?;\n                 let result = this.QueryPerformanceCounter(lpPerformanceCount)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"QueryPerformanceFrequency\" => {\n-                check_abi(abi, Abi::System { unwind: false })?;\n+                check_abi(this, abi, Abi::System { unwind: false })?;\n                 #[allow(non_snake_case)]\n                 let &[ref lpFrequency] = check_arg_count(args)?;\n                 let result = this.QueryPerformanceFrequency(lpFrequency)?;\n@@ -233,41 +233,41 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n             // Synchronization primitives\n             \"AcquireSRWLockExclusive\" => {\n-                check_abi(abi, Abi::System { unwind: false })?;\n+                check_abi(this, abi, Abi::System { unwind: false })?;\n                 let &[ref ptr] = check_arg_count(args)?;\n                 this.AcquireSRWLockExclusive(ptr)?;\n             }\n             \"ReleaseSRWLockExclusive\" => {\n-                check_abi(abi, Abi::System { unwind: false })?;\n+                check_abi(this, abi, Abi::System { unwind: false })?;\n                 let &[ref ptr] = check_arg_count(args)?;\n                 this.ReleaseSRWLockExclusive(ptr)?;\n             }\n             \"TryAcquireSRWLockExclusive\" => {\n-                check_abi(abi, Abi::System { unwind: false })?;\n+                check_abi(this, abi, Abi::System { unwind: false })?;\n                 let &[ref ptr] = check_arg_count(args)?;\n                 let ret = this.TryAcquireSRWLockExclusive(ptr)?;\n                 this.write_scalar(Scalar::from_u8(ret), dest)?;\n             }\n             \"AcquireSRWLockShared\" => {\n-                check_abi(abi, Abi::System { unwind: false })?;\n+                check_abi(this, abi, Abi::System { unwind: false })?;\n                 let &[ref ptr] = check_arg_count(args)?;\n                 this.AcquireSRWLockShared(ptr)?;\n             }\n             \"ReleaseSRWLockShared\" => {\n-                check_abi(abi, Abi::System { unwind: false })?;\n+                check_abi(this, abi, Abi::System { unwind: false })?;\n                 let &[ref ptr] = check_arg_count(args)?;\n                 this.ReleaseSRWLockShared(ptr)?;\n             }\n             \"TryAcquireSRWLockShared\" => {\n-                check_abi(abi, Abi::System { unwind: false })?;\n+                check_abi(this, abi, Abi::System { unwind: false })?;\n                 let &[ref ptr] = check_arg_count(args)?;\n                 let ret = this.TryAcquireSRWLockShared(ptr)?;\n                 this.write_scalar(Scalar::from_u8(ret), dest)?;\n             }\n \n             // Dynamic symbol loading\n             \"GetProcAddress\" => {\n-                check_abi(abi, Abi::System { unwind: false })?;\n+                check_abi(this, abi, Abi::System { unwind: false })?;\n                 #[allow(non_snake_case)]\n                 let &[ref hModule, ref lpProcName] = check_arg_count(args)?;\n                 this.read_scalar(hModule)?.to_machine_isize(this)?;\n@@ -283,15 +283,15 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             // Miscellaneous\n             \"SystemFunction036\" => {\n                 // This is really 'RtlGenRandom'.\n-                check_abi(abi, Abi::System { unwind: false })?;\n+                check_abi(this, abi, Abi::System { unwind: false })?;\n                 let &[ref ptr, ref len] = check_arg_count(args)?;\n                 let ptr = this.read_scalar(ptr)?.check_init()?;\n                 let len = this.read_scalar(len)?.to_u32()?;\n                 this.gen_random(ptr, len.into())?;\n                 this.write_scalar(Scalar::from_bool(true), dest)?;\n             }\n             \"BCryptGenRandom\" => {\n-                check_abi(abi, Abi::System { unwind: false })?;\n+                check_abi(this, abi, Abi::System { unwind: false })?;\n                 let &[ref algorithm, ref ptr, ref len, ref flags] = check_arg_count(args)?;\n                 let algorithm = this.read_scalar(algorithm)?;\n                 let ptr = this.read_scalar(ptr)?.check_init()?;\n@@ -312,7 +312,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.write_null(dest)?; // STATUS_SUCCESS\n             }\n             \"GetConsoleScreenBufferInfo\" => {\n-                check_abi(abi, Abi::System { unwind: false })?;\n+                check_abi(this, abi, Abi::System { unwind: false })?;\n                 // `term` needs this, so we fake it.\n                 let &[ref console, ref buffer_info] = check_arg_count(args)?;\n                 this.read_scalar(console)?.to_machine_isize(this)?;\n@@ -322,7 +322,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.write_null(dest)?;\n             }\n             \"GetConsoleMode\" => {\n-                check_abi(abi, Abi::System { unwind: false })?;\n+                check_abi(this, abi, Abi::System { unwind: false })?;\n                 // Windows \"isatty\" (in libtest) needs this, so we fake it.\n                 let &[ref console, ref mode] = check_arg_count(args)?;\n                 this.read_scalar(console)?.to_machine_isize(this)?;\n@@ -332,7 +332,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.write_null(dest)?;\n             }\n             \"SwitchToThread\" => {\n-                check_abi(abi, Abi::System { unwind: false })?;\n+                check_abi(this, abi, Abi::System { unwind: false })?;\n                 let &[] = check_arg_count(args)?;\n                 // Note that once Miri supports concurrency, this will need to return a nonzero\n                 // value if this call does result in switching to another thread.\n@@ -341,7 +341,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n             // Better error for attempts to create a thread\n             \"CreateThread\" => {\n-                check_abi(abi, Abi::System { unwind: false })?;\n+                check_abi(this, abi, Abi::System { unwind: false })?;\n                 throw_unsup_format!(\"Miri does not support concurrency on Windows\");\n             }\n \n@@ -350,15 +350,15 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             \"GetProcessHeap\"\n                 if this.frame().instance.to_string().starts_with(\"std::sys::windows::\") =>\n             {\n-                check_abi(abi, Abi::System { unwind: false })?;\n+                check_abi(this, abi, Abi::System { unwind: false })?;\n                 let &[] = check_arg_count(args)?;\n                 // Just fake a HANDLE\n                 this.write_scalar(Scalar::from_machine_isize(1, this), dest)?;\n             }\n             \"SetConsoleTextAttribute\"\n                 if this.frame().instance.to_string().starts_with(\"std::sys::windows::\") =>\n             {\n-                check_abi(abi, Abi::System { unwind: false })?;\n+                check_abi(this, abi, Abi::System { unwind: false })?;\n                 #[allow(non_snake_case)]\n                 let &[ref _hConsoleOutput, ref _wAttribute] = check_arg_count(args)?;\n                 // Pretend these does not exist / nothing happened, by returning zero.\n@@ -367,7 +367,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             \"AddVectoredExceptionHandler\"\n                 if this.frame().instance.to_string().starts_with(\"std::sys::windows::\") =>\n             {\n-                check_abi(abi, Abi::System { unwind: false })?;\n+                check_abi(this, abi, Abi::System { unwind: false })?;\n                 #[allow(non_snake_case)]\n                 let &[ref _First, ref _Handler] = check_arg_count(args)?;\n                 // Any non zero value works for the stdlib. This is just used for stack overflows anyway.\n@@ -376,7 +376,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             \"SetThreadStackGuarantee\"\n                 if this.frame().instance.to_string().starts_with(\"std::sys::windows::\") =>\n             {\n-                check_abi(abi, Abi::System { unwind: false })?;\n+                check_abi(this, abi, Abi::System { unwind: false })?;\n                 #[allow(non_snake_case)]\n                 let &[_StackSizeInBytes] = check_arg_count(args)?;\n                 // Any non zero value works for the stdlib. This is just used for stack overflows anyway.\n@@ -388,7 +388,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             | \"DeleteCriticalSection\"\n                 if this.frame().instance.to_string().starts_with(\"std::sys::windows::\") =>\n             {\n-                check_abi(abi, Abi::System { unwind: false })?;\n+                check_abi(this, abi, Abi::System { unwind: false })?;\n                 #[allow(non_snake_case)]\n                 let &[ref _lpCriticalSection] = check_arg_count(args)?;\n                 assert_eq!(\n@@ -403,7 +403,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             \"TryEnterCriticalSection\"\n                 if this.frame().instance.to_string().starts_with(\"std::sys::windows::\") =>\n             {\n-                check_abi(abi, Abi::System { unwind: false })?;\n+                check_abi(this, abi, Abi::System { unwind: false })?;\n                 #[allow(non_snake_case)]\n                 let &[ref _lpCriticalSection] = check_arg_count(args)?;\n                 assert_eq!("}, {"sha": "69dfc03598313cf823cc11f499ebd5b0444cb18e", "filename": "tests/compile-fail/check_callback_abi.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/71f41405500cec42be22f0080bf3f83f97bfa768/tests%2Fcompile-fail%2Fcheck_callback_abi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71f41405500cec42be22f0080bf3f83f97bfa768/tests%2Fcompile-fail%2Fcheck_callback_abi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fcheck_callback_abi.rs?ref=71f41405500cec42be22f0080bf3f83f97bfa768", "patch": "@@ -0,0 +1,15 @@\n+#![feature(core_intrinsics)]\n+\n+extern \"C\" fn try_fn(_: *mut u8) {\n+    unreachable!();\n+}\n+\n+fn main() {\n+    unsafe {\n+        std::intrinsics::r#try( //~ ERROR calling a function with ABI C using caller ABI Rust\n+            std::mem::transmute::<extern \"C\" fn(*mut u8), _>(try_fn),\n+            std::ptr::null_mut(),\n+            |_, _| unreachable!(),\n+        );\n+    }\n+}"}, {"sha": "138a43d9d7310cc69f7b971e9dcdf72f9d126d67", "filename": "tests/compile-fail/concurrency/unwind_top_of_stack.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/71f41405500cec42be22f0080bf3f83f97bfa768/tests%2Fcompile-fail%2Fconcurrency%2Funwind_top_of_stack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71f41405500cec42be22f0080bf3f83f97bfa768/tests%2Fcompile-fail%2Fconcurrency%2Funwind_top_of_stack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fconcurrency%2Funwind_top_of_stack.rs?ref=71f41405500cec42be22f0080bf3f83f97bfa768", "patch": "@@ -1,10 +1,8 @@\n // ignore-windows: Concurrency on Windows is not supported yet.\n-// error-pattern: calling a function with ABI C-unwind using caller ABI C\n+// compile-flags: -Zmiri-disable-abi-check\n+// error-pattern: unwinding past the topmost frame of the stack\n \n //! Unwinding past the top frame of a stack is Undefined Behavior.\n-//! However, it is impossible to do that in pure Rust since one cannot write an unwinding\n-//! function with `C` ABI... so let's instead test that we are indeed correctly checking\n-//! the callee ABI in `pthread_create`.\n \n #![feature(rustc_private, c_unwind)]\n "}, {"sha": "cfb109cb8b56af05c0bc3bfc7396bc07df641739", "filename": "tests/compile-fail/panic/bad_unwind.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/71f41405500cec42be22f0080bf3f83f97bfa768/tests%2Fcompile-fail%2Fpanic%2Fbad_unwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71f41405500cec42be22f0080bf3f83f97bfa768/tests%2Fcompile-fail%2Fpanic%2Fbad_unwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fpanic%2Fbad_unwind.rs?ref=71f41405500cec42be22f0080bf3f83f97bfa768", "patch": "@@ -4,6 +4,8 @@\n //! Unwinding when the caller ABI is \"C\" (without \"-unwind\") is UB.\n //! Currently we detect the ABI mismatch; we could probably allow such calls in principle one day\n //! but then we have to detect the unexpected unwinding.\n+//! FIXME: `-Zmiri-disable-abi-check` does not work for this test because function pointers are\n+//! always allowed to unwind.\n \n extern \"C-unwind\" fn unwind() {\n     panic!();"}, {"sha": "1f8554741376ba13e4f65f19fe24552fb0e5cb74", "filename": "tests/run-pass/disable_abi_check.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/71f41405500cec42be22f0080bf3f83f97bfa768/tests%2Frun-pass%2Fdisable_abi_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71f41405500cec42be22f0080bf3f83f97bfa768/tests%2Frun-pass%2Fdisable_abi_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fdisable_abi_check.rs?ref=71f41405500cec42be22f0080bf3f83f97bfa768", "patch": "@@ -0,0 +1,24 @@\n+// compile-flags: -Zmiri-disable-abi-check\n+#![feature(core_intrinsics)]\n+\n+fn main() {\n+    fn foo() {}\n+\n+    extern \"C\" fn try_fn(ptr: *mut u8) {\n+        assert!(ptr.is_null());\n+    }\n+\n+    extern \"Rust\" {\n+        fn malloc(size: usize) -> *mut std::ffi::c_void;\n+    }\n+\n+    unsafe {\n+        let _ = malloc(0);\n+        std::mem::transmute::<fn(), extern \"C\" fn()>(foo)();\n+        std::intrinsics::r#try(\n+            std::mem::transmute::<extern \"C\" fn(*mut u8), _>(try_fn),\n+            std::ptr::null_mut(),\n+            |_, _| unreachable!(),\n+        );\n+    }\n+}"}]}