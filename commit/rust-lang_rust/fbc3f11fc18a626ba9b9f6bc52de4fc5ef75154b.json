{"sha": "fbc3f11fc18a626ba9b9f6bc52de4fc5ef75154b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZiYzNmMTFmYzE4YTYyNmJhOWI5ZjZiYzUyZGU0ZmM1ZWY3NTE1NGI=", "commit": {"author": {"name": "Ulrik Sverdrup", "email": "bluss@users.noreply.github.com", "date": "2016-12-09T15:28:54Z"}, "committer": {"name": "Ulrik Sverdrup", "email": "bluss@users.noreply.github.com", "date": "2016-12-09T17:16:38Z"}, "message": "mir: Reinstate while loop in deaggregator pass\n\nA previous commit must have removed the `while let` loop here by\nmistake; for each basic block, it should find and deaggregate multiple\nstatements in their index order, and the `curr` index tracks the\nprogress through the block.\n\nThis fixes both the case of deaggregating statements in separate\nbasic blocks (preserving `curr` could prevent that) as well\nas multiple times in the same block (missing loop prevented that).", "tree": {"sha": "dc4bed62f9b5e72c0d973211cb66b574ffe60377", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dc4bed62f9b5e72c0d973211cb66b574ffe60377"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fbc3f11fc18a626ba9b9f6bc52de4fc5ef75154b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fbc3f11fc18a626ba9b9f6bc52de4fc5ef75154b", "html_url": "https://github.com/rust-lang/rust/commit/fbc3f11fc18a626ba9b9f6bc52de4fc5ef75154b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fbc3f11fc18a626ba9b9f6bc52de4fc5ef75154b/comments", "author": {"login": "bluss", "id": 3209739, "node_id": "MDQ6VXNlcjMyMDk3Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/3209739?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bluss", "html_url": "https://github.com/bluss", "followers_url": "https://api.github.com/users/bluss/followers", "following_url": "https://api.github.com/users/bluss/following{/other_user}", "gists_url": "https://api.github.com/users/bluss/gists{/gist_id}", "starred_url": "https://api.github.com/users/bluss/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bluss/subscriptions", "organizations_url": "https://api.github.com/users/bluss/orgs", "repos_url": "https://api.github.com/users/bluss/repos", "events_url": "https://api.github.com/users/bluss/events{/privacy}", "received_events_url": "https://api.github.com/users/bluss/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bluss", "id": 3209739, "node_id": "MDQ6VXNlcjMyMDk3Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/3209739?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bluss", "html_url": "https://github.com/bluss", "followers_url": "https://api.github.com/users/bluss/followers", "following_url": "https://api.github.com/users/bluss/following{/other_user}", "gists_url": "https://api.github.com/users/bluss/gists{/gist_id}", "starred_url": "https://api.github.com/users/bluss/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bluss/subscriptions", "organizations_url": "https://api.github.com/users/bluss/orgs", "repos_url": "https://api.github.com/users/bluss/repos", "events_url": "https://api.github.com/users/bluss/events{/privacy}", "received_events_url": "https://api.github.com/users/bluss/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dedd9850841f20880b6318ce9cbe60e2b205b6a9", "url": "https://api.github.com/repos/rust-lang/rust/commits/dedd9850841f20880b6318ce9cbe60e2b205b6a9", "html_url": "https://github.com/rust-lang/rust/commit/dedd9850841f20880b6318ce9cbe60e2b205b6a9"}], "stats": {"total": 222, "additions": 163, "deletions": 59}, "files": [{"sha": "e13c8e02137a06db29d73c551ae50a127f60a656", "filename": "src/librustc_mir/transform/deaggregator.rs", "status": "modified", "additions": 58, "deletions": 59, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/fbc3f11fc18a626ba9b9f6bc52de4fc5ef75154b/src%2Flibrustc_mir%2Ftransform%2Fdeaggregator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbc3f11fc18a626ba9b9f6bc52de4fc5ef75154b/src%2Flibrustc_mir%2Ftransform%2Fdeaggregator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fdeaggregator.rs?ref=fbc3f11fc18a626ba9b9f6bc52de4fc5ef75154b", "patch": "@@ -36,71 +36,70 @@ impl<'tcx> MirPass<'tcx> for Deaggregator {\n         // In fact, we might not want to trigger in other cases.\n         // Ex: when we could use SROA.  See issue #35259\n \n-        let mut curr: usize = 0;\n         for bb in mir.basic_blocks_mut() {\n-            let idx = match get_aggregate_statement_index(curr, &bb.statements) {\n-                Some(idx) => idx,\n-                None => continue,\n-            };\n-            // do the replacement\n-            debug!(\"removing statement {:?}\", idx);\n-            let src_info = bb.statements[idx].source_info;\n-            let suffix_stmts = bb.statements.split_off(idx+1);\n-            let orig_stmt = bb.statements.pop().unwrap();\n-            let (lhs, rhs) = match orig_stmt.kind {\n-                StatementKind::Assign(ref lhs, ref rhs) => (lhs, rhs),\n-                _ => span_bug!(src_info.span, \"expected assign, not {:?}\", orig_stmt),\n-            };\n-            let (agg_kind, operands) = match rhs {\n-                &Rvalue::Aggregate(ref agg_kind, ref operands) => (agg_kind, operands),\n-                _ => span_bug!(src_info.span, \"expected aggregate, not {:?}\", rhs),\n-            };\n-            let (adt_def, variant, substs) = match agg_kind {\n-                &AggregateKind::Adt(adt_def, variant, substs, None) => (adt_def, variant, substs),\n-                _ => span_bug!(src_info.span, \"expected struct, not {:?}\", rhs),\n-            };\n-            let n = bb.statements.len();\n-            bb.statements.reserve(n + operands.len() + suffix_stmts.len());\n-            for (i, op) in operands.iter().enumerate() {\n-                let ref variant_def = adt_def.variants[variant];\n-                let ty = variant_def.fields[i].ty(tcx, substs);\n-                let rhs = Rvalue::Use(op.clone());\n-\n-                let lhs_cast = if adt_def.variants.len() > 1 {\n-                    Lvalue::Projection(Box::new(LvalueProjection {\n-                        base: lhs.clone(),\n-                        elem: ProjectionElem::Downcast(adt_def, variant),\n-                    }))\n-                } else {\n-                    lhs.clone()\n+            let mut curr: usize = 0;\n+            while let Some(idx) = get_aggregate_statement_index(curr, &bb.statements) {\n+                // do the replacement\n+                debug!(\"removing statement {:?}\", idx);\n+                let src_info = bb.statements[idx].source_info;\n+                let suffix_stmts = bb.statements.split_off(idx+1);\n+                let orig_stmt = bb.statements.pop().unwrap();\n+                let (lhs, rhs) = match orig_stmt.kind {\n+                    StatementKind::Assign(ref lhs, ref rhs) => (lhs, rhs),\n+                    _ => span_bug!(src_info.span, \"expected assign, not {:?}\", orig_stmt),\n                 };\n-\n-                let lhs_proj = Lvalue::Projection(Box::new(LvalueProjection {\n-                    base: lhs_cast,\n-                    elem: ProjectionElem::Field(Field::new(i), ty),\n-                }));\n-                let new_statement = Statement {\n-                    source_info: src_info,\n-                    kind: StatementKind::Assign(lhs_proj, rhs),\n+                let (agg_kind, operands) = match rhs {\n+                    &Rvalue::Aggregate(ref agg_kind, ref operands) => (agg_kind, operands),\n+                    _ => span_bug!(src_info.span, \"expected aggregate, not {:?}\", rhs),\n                 };\n-                debug!(\"inserting: {:?} @ {:?}\", new_statement, idx + i);\n-                bb.statements.push(new_statement);\n-            }\n+                let (adt_def, variant, substs) = match agg_kind {\n+                    &AggregateKind::Adt(adt_def, variant, substs, None)\n+                        => (adt_def, variant, substs),\n+                    _ => span_bug!(src_info.span, \"expected struct, not {:?}\", rhs),\n+                };\n+                let n = bb.statements.len();\n+                bb.statements.reserve(n + operands.len() + suffix_stmts.len());\n+                for (i, op) in operands.iter().enumerate() {\n+                    let ref variant_def = adt_def.variants[variant];\n+                    let ty = variant_def.fields[i].ty(tcx, substs);\n+                    let rhs = Rvalue::Use(op.clone());\n \n-            // if the aggregate was an enum, we need to set the discriminant\n-            if adt_def.variants.len() > 1 {\n-                let set_discriminant = Statement {\n-                    kind: StatementKind::SetDiscriminant {\n-                        lvalue: lhs.clone(),\n-                        variant_index: variant,\n-                    },\n-                    source_info: src_info,\n+                    let lhs_cast = if adt_def.variants.len() > 1 {\n+                        Lvalue::Projection(Box::new(LvalueProjection {\n+                            base: lhs.clone(),\n+                            elem: ProjectionElem::Downcast(adt_def, variant),\n+                        }))\n+                    } else {\n+                        lhs.clone()\n+                    };\n+\n+                    let lhs_proj = Lvalue::Projection(Box::new(LvalueProjection {\n+                        base: lhs_cast,\n+                        elem: ProjectionElem::Field(Field::new(i), ty),\n+                    }));\n+                    let new_statement = Statement {\n+                        source_info: src_info,\n+                        kind: StatementKind::Assign(lhs_proj, rhs),\n+                    };\n+                    debug!(\"inserting: {:?} @ {:?}\", new_statement, idx + i);\n+                    bb.statements.push(new_statement);\n+                }\n+\n+                // if the aggregate was an enum, we need to set the discriminant\n+                if adt_def.variants.len() > 1 {\n+                    let set_discriminant = Statement {\n+                        kind: StatementKind::SetDiscriminant {\n+                            lvalue: lhs.clone(),\n+                            variant_index: variant,\n+                        },\n+                        source_info: src_info,\n+                    };\n+                    bb.statements.push(set_discriminant);\n                 };\n-                bb.statements.push(set_discriminant);\n-            };\n \n-            curr = bb.statements.len();\n-            bb.statements.extend(suffix_stmts);\n+                curr = bb.statements.len();\n+                bb.statements.extend(suffix_stmts);\n+            }\n         }\n     }\n }"}, {"sha": "02d496b2901e66b1b4a428cccde5ed8662e59b4b", "filename": "src/test/mir-opt/deaggregator_test_enum_2.rs", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/fbc3f11fc18a626ba9b9f6bc52de4fc5ef75154b/src%2Ftest%2Fmir-opt%2Fdeaggregator_test_enum_2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbc3f11fc18a626ba9b9f6bc52de4fc5ef75154b/src%2Ftest%2Fmir-opt%2Fdeaggregator_test_enum_2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fdeaggregator_test_enum_2.rs?ref=fbc3f11fc18a626ba9b9f6bc52de4fc5ef75154b", "patch": "@@ -0,0 +1,57 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that deaggregate fires in more than one basic block\n+\n+enum Foo {\n+    A(i32),\n+    B(i32),\n+}\n+\n+fn test1(x: bool, y: i32) -> Foo {\n+    if x {\n+        Foo::A(y)\n+    } else {\n+        Foo::B(y)\n+    }\n+}\n+\n+fn main() {}\n+\n+// END RUST SOURCE\n+// START rustc.node12.Deaggregator.before.mir\n+//  bb1: {\n+//      _6 = _4;\n+//      _0 = Foo::A(_6,);\n+//      goto -> bb3;\n+//  }\n+//\n+//  bb2: {\n+//      _7 = _4;\n+//      _0 = Foo::B(_7,);\n+//      goto -> bb3;\n+//  }\n+// END rustc.node12.Deaggregator.before.mir\n+// START rustc.node12.Deaggregator.after.mir\n+//  bb1: {\n+//      _6 = _4;\n+//      ((_0 as A).0: i32) = _6;\n+//      discriminant(_0) = 0;\n+//      goto -> bb3;\n+//  }\n+//\n+//  bb2: {\n+//      _7 = _4;\n+//      ((_0 as B).0: i32) = _7;\n+//      discriminant(_0) = 1;\n+//      goto -> bb3;\n+//  }\n+// END rustc.node12.Deaggregator.after.mir\n+//"}, {"sha": "a180a69be55af71c3b977ce75751757eb4741fd4", "filename": "src/test/mir-opt/deaggregator_test_multiple.rs", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/fbc3f11fc18a626ba9b9f6bc52de4fc5ef75154b/src%2Ftest%2Fmir-opt%2Fdeaggregator_test_multiple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbc3f11fc18a626ba9b9f6bc52de4fc5ef75154b/src%2Ftest%2Fmir-opt%2Fdeaggregator_test_multiple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fdeaggregator_test_multiple.rs?ref=fbc3f11fc18a626ba9b9f6bc52de4fc5ef75154b", "patch": "@@ -0,0 +1,48 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that deaggregate fires more than once per block\n+\n+enum Foo {\n+    A(i32),\n+    B,\n+}\n+\n+fn test(x: i32) -> [Foo; 2] {\n+    [Foo::A(x), Foo::A(x)]\n+}\n+\n+fn main() { }\n+\n+// END RUST SOURCE\n+// START rustc.node10.Deaggregator.before.mir\n+// bb0: {\n+//     _2 = _1;\n+//     _4 = _2;\n+//     _3 = Foo::A(_4,);\n+//     _6 = _2;\n+//     _5 = Foo::A(_6,);\n+//     _0 = [_3, _5];\n+//     return;\n+// }\n+// END rustc.node10.Deaggregator.before.mir\n+// START rustc.node10.Deaggregator.after.mir\n+// bb0: {\n+//     _2 = _1;\n+//     _4 = _2;\n+//     ((_3 as A).0: i32) = _4;\n+//     discriminant(_3) = 0;\n+//     _6 = _2;\n+//     ((_5 as A).0: i32) = _6;\n+//     discriminant(_5) = 0;\n+//     _0 = [_3, _5];\n+//     return;\n+// }\n+// END rustc.node10.Deaggregator.after.mir"}]}