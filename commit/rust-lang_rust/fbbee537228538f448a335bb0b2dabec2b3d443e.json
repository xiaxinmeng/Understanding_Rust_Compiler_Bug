{"sha": "fbbee537228538f448a335bb0b2dabec2b3d443e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZiYmVlNTM3MjI4NTM4ZjQ0OGEzMzViYjBiMmRhYmVjMmIzZDQ0M2U=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-10-30T23:08:54Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-10-30T23:08:54Z"}, "message": "Add ModuleScope as a query\n\nThis is a first step towards queryifing completion and resolve.\n\nSome code currently duplicates ra_editor: the plan is to move all\ncompletion from ra_editor, but it'll take more than one commit.", "tree": {"sha": "db676e2c84585c13179e0116b018a3e67b550190", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/db676e2c84585c13179e0116b018a3e67b550190"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fbbee537228538f448a335bb0b2dabec2b3d443e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fbbee537228538f448a335bb0b2dabec2b3d443e", "html_url": "https://github.com/rust-lang/rust/commit/fbbee537228538f448a335bb0b2dabec2b3d443e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fbbee537228538f448a335bb0b2dabec2b3d443e/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d10214581e18a3c98760ecf8ebbd27aaf48ec9ae", "url": "https://api.github.com/repos/rust-lang/rust/commits/d10214581e18a3c98760ecf8ebbd27aaf48ec9ae", "html_url": "https://github.com/rust-lang/rust/commit/d10214581e18a3c98760ecf8ebbd27aaf48ec9ae"}], "stats": {"total": 245, "additions": 223, "deletions": 22}, "files": [{"sha": "0141d132e7aa42d4418548d766aee630c39cc983", "filename": "crates/ra_analysis/src/completion.rs", "status": "modified", "additions": 23, "deletions": 12, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/fbbee537228538f448a335bb0b2dabec2b3d443e/crates%2Fra_analysis%2Fsrc%2Fcompletion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbbee537228538f448a335bb0b2dabec2b3d443e/crates%2Fra_analysis%2Fsrc%2Fcompletion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fcompletion.rs?ref=fbbee537228538f448a335bb0b2dabec2b3d443e", "patch": "@@ -1,40 +1,51 @@\n-use ra_editor::{CompletionItem, find_node_at_offset, complete_module_items};\n+use ra_editor::{CompletionItem, find_node_at_offset};\n use ra_syntax::{\n     AtomEdit, File, TextUnit, AstNode,\n-    ast::{self, ModuleItemOwner},\n+    ast::{self, ModuleItemOwner, AstChildren},\n };\n \n use crate::{\n     FileId, Cancelable,\n     input::FilesDatabase,\n     db::{self, SyntaxDatabase},\n-    descriptors::module::{ModulesDatabase, ModuleTree, ModuleId},\n+    descriptors::module::{ModulesDatabase, ModuleTree, ModuleId, scope::ModuleScope},\n };\n \n pub(crate) fn resolve_based_completion(db: &db::RootDatabase, file_id: FileId, offset: TextUnit) -> Cancelable<Option<Vec<CompletionItem>>> {\n     let source_root_id = db.file_source_root(file_id);\n     let file = db.file_syntax(file_id);\n     let module_tree = db.module_tree(source_root_id)?;\n+    let module_id = match module_tree.any_module_for_file(file_id) {\n+        None => return Ok(None),\n+        Some(it) => it,\n+    };\n     let file = {\n         let edit = AtomEdit::insert(offset, \"intellijRulezz\".to_string());\n         file.reparse(&edit)\n     };\n-    let target_file = match find_target_module(&module_tree, file_id, &file, offset) {\n+    let target_module_id = match find_target_module(&module_tree, module_id, &file, offset) {\n         None => return Ok(None),\n-        Some(target_module) => {\n-            let file_id = target_module.file_id(&module_tree);\n-            db.file_syntax(file_id)\n-        }\n+        Some(it) => it,\n     };\n-    let mut res = Vec::new();\n-    complete_module_items(target_file.ast().items(), None, &mut res);\n+    let module_scope = db.module_scope(source_root_id, target_module_id)?;\n+    let res: Vec<_> = module_scope\n+        .entries()\n+        .iter()\n+        .map(|entry| CompletionItem {\n+            label: entry.name().to_string(),\n+            lookup: None,\n+            snippet: None,\n+        })\n+        .collect();\n     Ok(Some(res))\n }\n \n-pub(crate) fn find_target_module(module_tree: &ModuleTree, file_id: FileId, file: &File, offset: TextUnit) -> Option<ModuleId> {\n+\n+\n+pub(crate) fn find_target_module(module_tree: &ModuleTree, module_id: ModuleId, file: &File, offset: TextUnit) -> Option<ModuleId> {\n     let name_ref: ast::NameRef = find_node_at_offset(file.syntax(), offset)?;\n     let mut crate_path = crate_path(name_ref)?;\n-    let module_id = module_tree.any_module_for_file(file_id)?;\n+\n     crate_path.pop();\n     let mut target_module = module_id.root(&module_tree);\n     for name in crate_path {"}, {"sha": "e7a5d5e2fb4156a87bbb47d58da05c1df05c5888", "filename": "crates/ra_analysis/src/db.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fbbee537228538f448a335bb0b2dabec2b3d443e/crates%2Fra_analysis%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbbee537228538f448a335bb0b2dabec2b3d443e/crates%2Fra_analysis%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fdb.rs?ref=fbbee537228538f448a335bb0b2dabec2b3d443e", "patch": "@@ -9,8 +9,9 @@ use salsa;\n use crate::{\n     db,\n     Cancelable, Canceled,\n-    descriptors::module::{SubmodulesQuery, ModuleTreeQuery, ModulesDatabase},\n+    descriptors::module::{SubmodulesQuery, ModuleTreeQuery, ModulesDatabase, ModuleScopeQuery},\n     symbol_index::SymbolIndex,\n+    syntax_ptr::{SyntaxPtrDatabase, ResolveSyntaxPtrQuery},\n     FileId,\n };\n \n@@ -65,6 +66,10 @@ salsa::database_storage! {\n         impl ModulesDatabase {\n             fn module_tree() for ModuleTreeQuery;\n             fn module_descriptor() for SubmodulesQuery;\n+            fn module_scope() for ModuleScopeQuery;\n+        }\n+        impl SyntaxPtrDatabase {\n+            fn resolve_syntax_ptr() for ResolveSyntaxPtrQuery;\n         }\n     }\n }"}, {"sha": "5fdaad137825b3eb0d02fadb6dd873ed384403e1", "filename": "crates/ra_analysis/src/descriptors/module/imp.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/fbbee537228538f448a335bb0b2dabec2b3d443e/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Fmodule%2Fimp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbbee537228538f448a335bb0b2dabec2b3d443e/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Fmodule%2Fimp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Fmodule%2Fimp.rs?ref=fbbee537228538f448a335bb0b2dabec2b3d443e", "patch": "@@ -13,7 +13,7 @@ use crate::{\n };\n \n use super::{\n-    ModuleData, ModuleTree, ModuleId, LinkId, LinkData, Problem, ModulesDatabase\n+    ModuleData, ModuleTree, ModuleId, LinkId, LinkData, Problem, ModulesDatabase, ModuleScope\n };\n \n \n@@ -35,6 +35,18 @@ pub(super) fn modules(root: ast::Root<'_>) -> impl Iterator<Item = (SmolStr, ast\n     })\n }\n \n+pub(super) fn module_scope(\n+    db: &impl ModulesDatabase,\n+    source_root_id: SourceRootId,\n+    module_id: ModuleId,\n+) -> Cancelable<Arc<ModuleScope>> {\n+    let tree = db.module_tree(source_root_id)?;\n+    let file_id = module_id.file_id(&tree);\n+    let syntax = db.file_syntax(file_id);\n+    let res = ModuleScope::new(&syntax);\n+    Ok(Arc::new(res))\n+}\n+\n pub(super) fn module_tree(\n     db: &impl ModulesDatabase,\n     source_root: SourceRootId,"}, {"sha": "9e5d73f94a6556b121195495c5bb8a07fb11e76d", "filename": "crates/ra_analysis/src/descriptors/module/mod.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fbbee537228538f448a335bb0b2dabec2b3d443e/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Fmodule%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbbee537228538f448a335bb0b2dabec2b3d443e/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Fmodule%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Fmodule%2Fmod.rs?ref=fbbee537228538f448a335bb0b2dabec2b3d443e", "patch": "@@ -1,4 +1,5 @@\n mod imp;\n+pub(crate) mod scope;\n \n use std::sync::Arc;\n \n@@ -11,6 +12,8 @@ use crate::{\n     input::SourceRootId,\n };\n \n+pub(crate) use self::scope::ModuleScope;\n+\n salsa::query_group! {\n     pub(crate) trait ModulesDatabase: SyntaxDatabase {\n         fn module_tree(source_root_id: SourceRootId) -> Cancelable<Arc<ModuleTree>> {\n@@ -21,6 +24,10 @@ salsa::query_group! {\n             type SubmodulesQuery;\n             use fn imp::submodules;\n         }\n+        fn module_scope(source_root_id: SourceRootId, module_id: ModuleId) -> Cancelable<Arc<ModuleScope>> {\n+            type ModuleScopeQuery;\n+            use fn imp::module_scope;\n+        }\n     }\n }\n \n@@ -78,6 +85,7 @@ impl ModuleId {\n         while let Some(next) = curr.parent(tree) {\n             curr = next;\n             i += 1;\n+            // simplistic cycle detection\n             if i > 100 {\n                 return self;\n             }"}, {"sha": "da58ddce072fb0cbe013099400cdb8425cf04d3f", "filename": "crates/ra_analysis/src/descriptors/module/scope.rs", "status": "added", "additions": 128, "deletions": 0, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/fbbee537228538f448a335bb0b2dabec2b3d443e/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Fmodule%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbbee537228538f448a335bb0b2dabec2b3d443e/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Fmodule%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Fmodule%2Fscope.rs?ref=fbbee537228538f448a335bb0b2dabec2b3d443e", "patch": "@@ -0,0 +1,128 @@\n+//! Backend for module-level scope resolution & completion\n+\n+\n+use ra_syntax::{\n+    ast::{self, AstChildren, ModuleItemOwner},\n+    File, AstNode, SmolStr, SyntaxNode, SyntaxNodeRef,\n+};\n+\n+use crate::syntax_ptr::LocalSyntaxPtr;\n+\n+/// `ModuleScope` contains all named items declared in the scope.\n+#[derive(Debug, PartialEq, Eq)]\n+pub(crate) struct ModuleScope {\n+    entries: Vec<Entry>,\n+}\n+\n+/// `Entry` is a single named declaration iside a module.\n+#[derive(Debug, PartialEq, Eq)]\n+pub(crate) struct Entry {\n+    ptr: LocalSyntaxPtr,\n+    kind: EntryKind,\n+    name: SmolStr,\n+}\n+\n+#[derive(Debug, PartialEq, Eq)]\n+enum EntryKind {\n+    Item,\n+    Import,\n+}\n+\n+impl ModuleScope {\n+    pub fn new(file: &File) -> ModuleScope {\n+        let mut entries = Vec::new();\n+        for item in file.ast().items() {\n+            let entry = match item {\n+                ast::ModuleItem::StructDef(item) => Entry::new(item),\n+                ast::ModuleItem::EnumDef(item) => Entry::new(item),\n+                ast::ModuleItem::FnDef(item) => Entry::new(item),\n+                ast::ModuleItem::ConstDef(item) => Entry::new(item),\n+                ast::ModuleItem::StaticDef(item) => Entry::new(item),\n+                ast::ModuleItem::TraitDef(item) => Entry::new(item),\n+                ast::ModuleItem::TypeDef(item) => Entry::new(item),\n+                ast::ModuleItem::Module(item) => Entry::new(item),\n+                ast::ModuleItem::UseItem(item) => {\n+                    if let Some(tree) = item.use_tree() {\n+                        collect_imports(tree, &mut entries);\n+                    }\n+                    continue;\n+                }\n+                ast::ModuleItem::ExternCrateItem(_) | ast::ModuleItem::ImplItem(_) => continue,\n+            };\n+            entries.extend(entry)\n+        }\n+\n+        ModuleScope { entries }\n+    }\n+\n+    pub fn entries(&self) -> &[Entry] {\n+        self.entries.as_slice()\n+    }\n+}\n+\n+impl Entry {\n+    fn new<'a>(item: impl ast::NameOwner<'a>) -> Option<Entry> {\n+        let name = item.name()?;\n+        Some(Entry {\n+            name: name.text(),\n+            ptr: LocalSyntaxPtr::new(name.syntax()),\n+            kind: EntryKind::Item,\n+        })\n+    }\n+    fn new_import(path: ast::Path) -> Option<Entry> {\n+        let name_ref = path.segment()?.name_ref()?;\n+        Some(Entry {\n+            name: name_ref.text(),\n+            ptr: LocalSyntaxPtr::new(name_ref.syntax()),\n+            kind: EntryKind::Import,\n+        })\n+    }\n+    pub fn name(&self) -> &SmolStr {\n+        &self.name\n+    }\n+    pub fn ptr(&self) -> LocalSyntaxPtr {\n+        self.ptr\n+    }\n+}\n+\n+fn collect_imports(tree: ast::UseTree, acc: &mut Vec<Entry>) {\n+    if let Some(use_tree_list) = tree.use_tree_list() {\n+        return use_tree_list\n+            .use_trees()\n+            .for_each(|it| collect_imports(it, acc));\n+    }\n+    if let Some(path) = tree.path() {\n+        acc.extend(Entry::new_import(path));\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+    use ra_syntax::{ast::ModuleItemOwner, File};\n+\n+    fn do_check(code: &str, expected: &[&str]) {\n+        let file = File::parse(&code);\n+        let scope = ModuleScope::new(&file);\n+        let actual = scope.entries.iter().map(|it| it.name()).collect::<Vec<_>>();\n+        assert_eq!(expected, actual.as_slice());\n+    }\n+\n+    #[test]\n+    fn test_module_scope() {\n+        do_check(\n+            \"\n+            struct Foo;\n+            enum Bar {}\n+            mod baz {}\n+            fn quux() {}\n+            use x::{\n+                y::z,\n+                t,\n+            };\n+            type T = ();\n+        \",\n+            &[\"Foo\", \"Bar\", \"baz\", \"quux\", \"z\", \"t\", \"T\"],\n+        )\n+    }\n+}"}, {"sha": "adbff48065f1cc19c128e62f1d843d27cbdd0ca4", "filename": "crates/ra_analysis/src/syntax_ptr.rs", "status": "modified", "additions": 37, "deletions": 8, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/fbbee537228538f448a335bb0b2dabec2b3d443e/crates%2Fra_analysis%2Fsrc%2Fsyntax_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbbee537228538f448a335bb0b2dabec2b3d443e/crates%2Fra_analysis%2Fsrc%2Fsyntax_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fsyntax_ptr.rs?ref=fbbee537228538f448a335bb0b2dabec2b3d443e", "patch": "@@ -1,3 +1,5 @@\n+use std::marker::PhantomData;\n+\n use ra_syntax::{\n     File, TextRange, SyntaxKind, SyntaxNode, SyntaxNodeRef,\n     ast::{self, AstNode},\n@@ -6,10 +8,24 @@ use ra_syntax::{\n use crate::FileId;\n use crate::db::SyntaxDatabase;\n \n+salsa::query_group! {\n+    pub(crate) trait SyntaxPtrDatabase: SyntaxDatabase {\n+        fn resolve_syntax_ptr(ptr: SyntaxPtr) -> SyntaxNode {\n+            type ResolveSyntaxPtrQuery;\n+            storage volatile;\n+        }\n+    }\n+}\n+\n+fn resolve_syntax_ptr(db: &impl SyntaxDatabase, ptr: SyntaxPtr) -> SyntaxNode {\n+    let syntax = db.file_syntax(ptr.file_id);\n+    ptr.local.resolve(&syntax)\n+}\n+\n /// SyntaxPtr is a cheap `Copy` id which identifies a particular syntax node,\n /// without retainig syntax tree in memory. You need to explicitelly `resovle`\n /// `SyntaxPtr` to get a `SyntaxNode`\n-#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub(crate) struct SyntaxPtr {\n     file_id: FileId,\n     local: LocalSyntaxPtr,\n@@ -20,30 +36,43 @@ impl SyntaxPtr {\n         let local = LocalSyntaxPtr::new(node);\n         SyntaxPtr { file_id, local }\n     }\n+}\n+\n+struct OwnedAst<T> {\n+    syntax: SyntaxNode,\n+    phantom: PhantomData<T>,\n+}\n+\n+trait ToAst {\n+    type Ast;\n+    fn to_ast(self) -> Self::Ast;\n+}\n \n-    pub(crate) fn resolve(self, db: &impl SyntaxDatabase) -> SyntaxNode {\n-        let syntax = db.file_syntax(self.file_id);\n-        self.local.resolve(&syntax)\n+impl<'a> ToAst for &'a OwnedAst<ast::FnDef<'static>> {\n+    type Ast = ast::FnDef<'a>;\n+    fn to_ast(self) -> ast::FnDef<'a> {\n+        ast::FnDef::cast(self.syntax.borrowed())\n+            .unwrap()\n     }\n }\n \n \n /// A pionter to a syntax node inside a file.\n-#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n-struct LocalSyntaxPtr {\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub(crate) struct LocalSyntaxPtr {\n     range: TextRange,\n     kind: SyntaxKind,\n }\n \n impl LocalSyntaxPtr {\n-    fn new(node: SyntaxNodeRef) -> LocalSyntaxPtr {\n+    pub(crate) fn new(node: SyntaxNodeRef) -> LocalSyntaxPtr {\n         LocalSyntaxPtr {\n             range: node.range(),\n             kind: node.kind(),\n         }\n     }\n \n-    fn resolve(self, file: &File) -> SyntaxNode {\n+    pub(crate) fn resolve(self, file: &File) -> SyntaxNode {\n         let mut curr = file.syntax();\n         loop {\n             if curr.range() == self.range && curr.kind() == self.kind {"}, {"sha": "20c8546a471b878ff6eee3f3d344cd2f9539b8da", "filename": "crates/ra_editor/src/completion.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fbbee537228538f448a335bb0b2dabec2b3d443e/crates%2Fra_editor%2Fsrc%2Fcompletion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbbee537228538f448a335bb0b2dabec2b3d443e/crates%2Fra_editor%2Fsrc%2Fcompletion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_editor%2Fsrc%2Fcompletion.rs?ref=fbbee537228538f448a335bb0b2dabec2b3d443e", "patch": "@@ -1,3 +1,5 @@\n+/// FIXME: move completion from ra_editor to ra_analysis\n+\n use rustc_hash::{FxHashMap, FxHashSet};\n \n use ra_syntax::{"}, {"sha": "818749a1258f17ce8dcbfd2a495ac410f21222f3", "filename": "crates/ra_editor/src/scope/mod_scope.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fbbee537228538f448a335bb0b2dabec2b3d443e/crates%2Fra_editor%2Fsrc%2Fscope%2Fmod_scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbbee537228538f448a335bb0b2dabec2b3d443e/crates%2Fra_editor%2Fsrc%2Fscope%2Fmod_scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_editor%2Fsrc%2Fscope%2Fmod_scope.rs?ref=fbbee537228538f448a335bb0b2dabec2b3d443e", "patch": "@@ -1,3 +1,9 @@\n+/// FIXME: this is now moved to ra_analysis::descriptors::module::scope.\n+///\n+/// Current copy will be deleted as soon as we move the rest of the completion\n+/// to the analyezer.\n+\n+\n use ra_syntax::{\n     ast::{self, AstChildren},\n     AstNode, SmolStr, SyntaxNode, SyntaxNodeRef,"}]}