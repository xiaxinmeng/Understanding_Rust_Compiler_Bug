{"sha": "194c27bcd16ad92e2edf11ff7446cb679a91c1d3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE5NGMyN2JjZDE2YWQ5MmUyZWRmMTFmZjc0NDZjYjY3OWE5MWMxZDM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-03-07T04:57:37Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-03-07T04:57:37Z"}, "message": "auto merge of #5183 : jld/rust/adt-renovation, r=brson\n\nThis series of changes moves the representation details of algebraic datatypes (enums, and special cases like structs and tuples and (until they're fully removed) records) from various places around rustc::middle::trans into a single module, to enable future improvements in this area.\r\n\r\nr?(@nikomatsakis), and the core developers in general; this seems like a \u201csuper-review\u201d kind of change.", "tree": {"sha": "a44df3bb57a58dc22665fe0753f99ce366f886c2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a44df3bb57a58dc22665fe0753f99ce366f886c2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/194c27bcd16ad92e2edf11ff7446cb679a91c1d3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/194c27bcd16ad92e2edf11ff7446cb679a91c1d3", "html_url": "https://github.com/rust-lang/rust/commit/194c27bcd16ad92e2edf11ff7446cb679a91c1d3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/194c27bcd16ad92e2edf11ff7446cb679a91c1d3/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c3c018f8ab017f915d629b2dfe5f4199d2d0145c", "url": "https://api.github.com/repos/rust-lang/rust/commits/c3c018f8ab017f915d629b2dfe5f4199d2d0145c", "html_url": "https://github.com/rust-lang/rust/commit/c3c018f8ab017f915d629b2dfe5f4199d2d0145c"}, {"sha": "a69ec175f8ebddf210f846abdbb7e8a441790f0a", "url": "https://api.github.com/repos/rust-lang/rust/commits/a69ec175f8ebddf210f846abdbb7e8a441790f0a", "html_url": "https://github.com/rust-lang/rust/commit/a69ec175f8ebddf210f846abdbb7e8a441790f0a"}], "stats": {"total": 1669, "additions": 1041, "deletions": 628}, "files": [{"sha": "c00856a0a98bd89b9857a234e4bc403bc3082af2", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/194c27bcd16ad92e2edf11ff7446cb679a91c1d3/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/194c27bcd16ad92e2edf11ff7446cb679a91c1d3/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=194c27bcd16ad92e2edf11ff7446cb679a91c1d3", "patch": "@@ -168,8 +168,8 @@ pub fn check_expr(sess: Session,\n           expr_field(*) |\n           expr_index(*) |\n           expr_tup(*) |\n-          expr_struct(*) |\n-          expr_rec(*) => { }\n+          expr_struct(_, _, None) |\n+          expr_rec(_, None) => { }\n           expr_addr_of(*) => {\n                 sess.span_err(\n                     e.span,"}, {"sha": "5bfa314e3976924d41d84373f8f849639dddc11c", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 72, "deletions": 97, "changes": 169, "blob_url": "https://github.com/rust-lang/rust/blob/194c27bcd16ad92e2edf11ff7446cb679a91c1d3/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/194c27bcd16ad92e2edf11ff7446cb679a91c1d3/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=194c27bcd16ad92e2edf11ff7446cb679a91c1d3", "patch": "@@ -145,12 +145,12 @@\n use core::prelude::*;\n \n use back::abi;\n-use lib;\n use lib::llvm::{llvm, ValueRef, BasicBlockRef};\n use middle::const_eval;\n use middle::borrowck::root_map_key;\n use middle::pat_util::*;\n use middle::resolve::DefMap;\n+use middle::trans::adt;\n use middle::trans::base::*;\n use middle::trans::build::*;\n use middle::trans::callee;\n@@ -169,9 +169,7 @@ use util::common::indenter;\n \n use core::dvec::DVec;\n use core::dvec;\n-use core::libc::c_ulonglong;\n use std::oldmap::HashMap;\n-use syntax::ast::def_id;\n use syntax::ast;\n use syntax::ast::ident;\n use syntax::ast_util::path_to_ident;\n@@ -191,15 +189,15 @@ pub enum Lit {\n // range)\n pub enum Opt {\n     lit(Lit),\n-    var(/* disr val */int, /* variant dids (enm, var) */(def_id, def_id)),\n+    var(/* disr val */int, @adt::Repr),\n     range(@ast::expr, @ast::expr),\n     vec_len_eq(uint),\n     vec_len_ge(uint)\n }\n \n pub fn opt_eq(tcx: ty::ctxt, a: &Opt, b: &Opt) -> bool {\n-    match (*a, *b) {\n-      (lit(a), lit(b)) => {\n+    match (a, b) {\n+      (&lit(a), &lit(b)) => {\n         match (a, b) {\n             (UnitLikeStructLit(a), UnitLikeStructLit(b)) => a == b,\n             _ => {\n@@ -233,13 +231,13 @@ pub fn opt_eq(tcx: ty::ctxt, a: &Opt, b: &Opt) -> bool {\n             }\n         }\n       }\n-      (range(a1, a2), range(b1, b2)) => {\n+      (&range(a1, a2), &range(b1, b2)) => {\n         const_eval::compare_lit_exprs(tcx, a1, b1) == 0 &&\n         const_eval::compare_lit_exprs(tcx, a2, b2) == 0\n       }\n-      (var(a, _), var(b, _)) => a == b,\n-      (vec_len_eq(a), vec_len_eq(b)) => a == b,\n-      (vec_len_ge(a), vec_len_ge(b)) => a == b,\n+      (&var(a, _), &var(b, _)) => a == b,\n+      (&vec_len_eq(a), &vec_len_eq(b)) => a == b,\n+      (&vec_len_ge(a), &vec_len_ge(b)) => a == b,\n       _ => false\n     }\n }\n@@ -267,8 +265,8 @@ pub fn trans_opt(bcx: block, o: &Opt) -> opt_result {\n             let llval = consts::get_const_val(bcx.ccx(), lit_id);\n             return single_result(rslt(bcx, llval));\n         }\n-        var(disr_val, _) => {\n-            return single_result(rslt(bcx, C_int(ccx, disr_val)));\n+        var(disr_val, repr) => {\n+            return adt::trans_case(bcx, repr, disr_val);\n         }\n         range(l1, l2) => {\n             return range_result(rslt(bcx, consts::const_expr(ccx, l1)),\n@@ -283,13 +281,16 @@ pub fn trans_opt(bcx: block, o: &Opt) -> opt_result {\n     }\n }\n \n-pub fn variant_opt(tcx: ty::ctxt, pat_id: ast::node_id) -> Opt {\n-    match tcx.def_map.get(&pat_id) {\n+pub fn variant_opt(bcx: block, pat_id: ast::node_id)\n+    -> Opt {\n+    let ccx = bcx.ccx();\n+    match ccx.tcx.def_map.get(&pat_id) {\n         ast::def_variant(enum_id, var_id) => {\n-            let variants = ty::enum_variants(tcx, enum_id);\n+            let variants = ty::enum_variants(ccx.tcx, enum_id);\n             for vec::each(*variants) |v| {\n                 if var_id == v.id {\n-                    return var(v.disr_val, (enum_id, var_id));\n+                    return var(v.disr_val,\n+                               adt::represent_node(bcx, pat_id))\n                 }\n             }\n             ::core::util::unreachable();\n@@ -298,7 +299,7 @@ pub fn variant_opt(tcx: ty::ctxt, pat_id: ast::node_id) -> Opt {\n             return lit(UnitLikeStructLit(pat_id));\n         }\n         _ => {\n-            tcx.sess.bug(~\"non-variant or struct in variant_opt()\");\n+            ccx.sess.bug(~\"non-variant or struct in variant_opt()\");\n         }\n     }\n }\n@@ -505,7 +506,7 @@ pub fn enter_opt(bcx: block, m: &[@Match/&r], opt: &Opt, col: uint,\n     do enter_match(bcx, tcx.def_map, m, col, val) |p| {\n         match /*bad*/copy p.node {\n             ast::pat_enum(_, subpats) => {\n-                if opt_eq(tcx, &variant_opt(tcx, p.id), opt) {\n+                if opt_eq(tcx, &variant_opt(bcx, p.id), opt) {\n                     Some(option::get_or_default(subpats,\n                                              vec::from_elem(variant_size,\n                                                             dummy)))\n@@ -515,7 +516,7 @@ pub fn enter_opt(bcx: block, m: &[@Match/&r], opt: &Opt, col: uint,\n             }\n             ast::pat_ident(_, _, None)\n                     if pat_is_variant_or_struct(tcx.def_map, p) => {\n-                if opt_eq(tcx, &variant_opt(tcx, p.id), opt) {\n+                if opt_eq(tcx, &variant_opt(bcx, p.id), opt) {\n                     Some(~[])\n                 } else {\n                     None\n@@ -537,7 +538,7 @@ pub fn enter_opt(bcx: block, m: &[@Match/&r], opt: &Opt, col: uint,\n                 if opt_eq(tcx, &range(l1, l2), opt) {Some(~[])} else {None}\n             }\n             ast::pat_struct(_, field_pats, _) => {\n-                if opt_eq(tcx, &variant_opt(tcx, p.id), opt) {\n+                if opt_eq(tcx, &variant_opt(bcx, p.id), opt) {\n                     // Look up the struct variant ID.\n                     let struct_id;\n                     match tcx.def_map.get(&p.id) {\n@@ -762,8 +763,9 @@ pub fn enter_region(bcx: block,\n // Returns the options in one column of matches. An option is something that\n // needs to be conditionally matched at runtime; for example, the discriminant\n // on a set of enum variants or a literal.\n-pub fn get_options(ccx: @CrateContext, m: &[@Match], col: uint) -> ~[Opt] {\n-    fn add_to_set(tcx: ty::ctxt, set: &DVec<Opt>, val: Opt) {\n+pub fn get_options(bcx: block, m: &[@Match], col: uint) -> ~[Opt] {\n+    let ccx = bcx.ccx();\n+    fn add_to_set(tcx: ty::ctxt, set: &DVec<Opt>, +val: Opt) {\n         if set.any(|l| opt_eq(tcx, l, &val)) {return;}\n         set.push(val);\n     }\n@@ -781,7 +783,7 @@ pub fn get_options(ccx: @CrateContext, m: &[@Match], col: uint) -> ~[Opt] {\n                 match ccx.tcx.def_map.find(&cur.id) {\n                     Some(ast::def_variant(*)) => {\n                         add_to_set(ccx.tcx, &found,\n-                                   variant_opt(ccx.tcx, cur.id));\n+                                   variant_opt(bcx, cur.id));\n                     }\n                     Some(ast::def_struct(*)) => {\n                         add_to_set(ccx.tcx, &found,\n@@ -800,7 +802,7 @@ pub fn get_options(ccx: @CrateContext, m: &[@Match], col: uint) -> ~[Opt] {\n                 match ccx.tcx.def_map.find(&cur.id) {\n                     Some(ast::def_variant(*)) => {\n                         add_to_set(ccx.tcx, &found,\n-                                   variant_opt(ccx.tcx, cur.id));\n+                                   variant_opt(bcx, cur.id));\n                     }\n                     _ => {}\n                 }\n@@ -827,34 +829,13 @@ pub struct ExtractedBlock {\n }\n \n pub fn extract_variant_args(bcx: block,\n-                            pat_id: ast::node_id,\n-                            vdefs: (def_id, def_id),\n+                            repr: &adt::Repr,\n+                            disr_val: int,\n                             val: ValueRef)\n-                         -> ExtractedBlock {\n-    let (enm, evar) = vdefs;\n+    -> ExtractedBlock {\n     let _icx = bcx.insn_ctxt(\"match::extract_variant_args\");\n-    let ccx = *bcx.fcx.ccx;\n-    let enum_ty_substs = match ty::get(node_id_type(bcx, pat_id)).sty {\n-      ty::ty_enum(id, ref substs) => {\n-        assert id == enm;\n-        /*bad*/copy (*substs).tps\n-      }\n-      _ => bcx.sess().bug(~\"extract_variant_args: pattern has non-enum type\")\n-    };\n-    let mut blobptr = val;\n-    let variants = ty::enum_variants(ccx.tcx, enm);\n-    let size = ty::enum_variant_with_id(ccx.tcx, enm,\n-                                        evar).args.len();\n-    if size > 0u && (*variants).len() != 1u {\n-        let enumptr =\n-            PointerCast(bcx, val, T_opaque_enum_ptr(ccx));\n-        blobptr = GEPi(bcx, enumptr, [0u, 1u]);\n-    }\n-    let vdefs_tg = enm;\n-    let vdefs_var = evar;\n-    let args = do vec::from_fn(size) |i| {\n-        GEP_enum(bcx, blobptr, vdefs_tg, vdefs_var,\n-                 /*bad*/copy enum_ty_substs, i)\n+    let args = do vec::from_fn(adt::num_args(repr, disr_val)) |i| {\n+        adt::trans_field_ptr(bcx, repr, val, disr_val, i)\n     };\n \n     ExtractedBlock { vals: args, bcx: bcx }\n@@ -1283,14 +1264,14 @@ pub fn compile_submatch(bcx: block,\n     }\n \n     bcx = root_pats_as_necessary(bcx, m, col, val);\n-\n     let rec_fields = collect_record_or_struct_fields(bcx, m, col);\n     if rec_fields.len() > 0 {\n         let pat_ty = node_id_type(bcx, pat_id);\n-        do expr::with_field_tys(tcx, pat_ty, None) |_has_dtor, field_tys| {\n+        let pat_repr = adt::represent_type(bcx.ccx(), pat_ty);\n+        do expr::with_field_tys(tcx, pat_ty, None) |discr, field_tys| {\n             let rec_vals = rec_fields.map(|field_name| {\n                 let ix = ty::field_idx_strict(tcx, *field_name, field_tys);\n-                GEPi(bcx, val, struct_field(ix))\n+                adt::trans_field_ptr(bcx, pat_repr, val, discr, ix)\n             });\n             compile_submatch(\n                 bcx,\n@@ -1303,11 +1284,14 @@ pub fn compile_submatch(bcx: block,\n \n     if any_tup_pat(m, col) {\n         let tup_ty = node_id_type(bcx, pat_id);\n+        let tup_repr = adt::represent_type(bcx.ccx(), tup_ty);\n         let n_tup_elts = match /*bad*/copy ty::get(tup_ty).sty {\n           ty::ty_tup(elts) => elts.len(),\n           _ => ccx.sess.bug(~\"non-tuple type in tuple pattern\")\n         };\n-        let tup_vals = vec::from_fn(n_tup_elts, |i| GEPi(bcx, val, [0u, i]));\n+        let tup_vals = do vec::from_fn(n_tup_elts) |i| {\n+            adt::trans_field_ptr(bcx, tup_repr, val, 0, i)\n+        };\n         compile_submatch(bcx, enter_tup(bcx, dm, m, col, val, n_tup_elts),\n                          vec::append(tup_vals, vals_left), chk);\n         return;\n@@ -1326,8 +1310,10 @@ pub fn compile_submatch(bcx: block,\n             }\n         }\n \n-        let llstructvals = vec::from_fn(\n-            struct_element_count, |i| GEPi(bcx, val, struct_field(i)));\n+        let struct_repr = adt::represent_type(bcx.ccx(), struct_ty);\n+        let llstructvals = do vec::from_fn(struct_element_count) |i| {\n+            adt::trans_field_ptr(bcx, struct_repr, val, 0, i)\n+        };\n         compile_submatch(bcx,\n                          enter_tuple_struct(bcx, dm, m, col, val,\n                                             struct_element_count),\n@@ -1365,37 +1351,15 @@ pub fn compile_submatch(bcx: block,\n     }\n \n     // Decide what kind of branch we need\n-    let opts = get_options(ccx, m, col);\n+    let opts = get_options(bcx, m, col);\n     let mut kind = no_branch;\n     let mut test_val = val;\n     if opts.len() > 0u {\n         match opts[0] {\n-            var(_, (enm, _)) => {\n-                let variants = ty::enum_variants(tcx, enm);\n-                if variants.len() == 1 {\n-                    kind = single;\n-                } else {\n-                    let enumptr =\n-                        PointerCast(bcx, val, T_opaque_enum_ptr(ccx));\n-                    let discrimptr = GEPi(bcx, enumptr, [0u, 0u]);\n-\n-\n-                    assert variants.len() > 1;\n-                    let min_discrim = do variants.foldr(0) |&x, y| {\n-                        int::min(x.disr_val, y)\n-                    };\n-                    let max_discrim = do variants.foldr(0) |&x, y| {\n-                        int::max(x.disr_val, y)\n-                    };\n-\n-                    test_val = LoadRangeAssert(bcx, discrimptr,\n-                                               min_discrim as c_ulonglong,\n-                                               (max_discrim + 1)\n-                                               as c_ulonglong,\n-                                               lib::llvm::True);\n-\n-                    kind = switch;\n-                }\n+            var(_, repr) => {\n+                let (the_kind, val_opt) = adt::trans_switch(bcx, repr, val);\n+                kind = the_kind;\n+                for val_opt.each |&tval| { test_val = tval; }\n             }\n             lit(_) => {\n                 let pty = node_id_type(bcx, pat_id);\n@@ -1544,11 +1508,12 @@ pub fn compile_submatch(bcx: block,\n         let mut size = 0u;\n         let mut unpacked = ~[];\n         match *opt {\n-            var(_, vdef) => {\n-                let args = extract_variant_args(opt_cx, pat_id, vdef, val);\n-                size = args.vals.len();\n-                unpacked = /*bad*/copy args.vals;\n-                opt_cx = args.bcx;\n+            var(disr_val, repr) => {\n+                let ExtractedBlock {vals: argvals, bcx: new_bcx} =\n+                    extract_variant_args(opt_cx, repr, disr_val, val);\n+                size = argvals.len();\n+                unpacked = argvals;\n+                opt_cx = new_bcx;\n             }\n             vec_len_eq(n) | vec_len_ge(n) => {\n                 let tail = match *opt {\n@@ -1757,10 +1722,15 @@ pub fn bind_irrefutable_pat(bcx: block,\n         }\n         ast::pat_enum(_, sub_pats) => {\n             match bcx.tcx().def_map.find(&pat.id) {\n-                Some(ast::def_variant(*)) => {\n-                    let pat_def = ccx.tcx.def_map.get(&pat.id);\n-                    let vdefs = ast_util::variant_def_ids(pat_def);\n-                    let args = extract_variant_args(bcx, pat.id, vdefs, val);\n+                Some(ast::def_variant(enum_id, var_id)) => {\n+                    let repr = adt::represent_node(bcx, pat.id);\n+                    let vinfo = ty::enum_variant_with_id(ccx.tcx,\n+                                                         enum_id,\n+                                                         var_id);\n+                    let args = extract_variant_args(bcx,\n+                                                    repr,\n+                                                    vinfo.disr_val,\n+                                                    val);\n                     for sub_pats.each |sub_pat| {\n                         for vec::eachi(args.vals) |i, argval| {\n                             bcx = bind_irrefutable_pat(bcx,\n@@ -1777,9 +1747,11 @@ pub fn bind_irrefutable_pat(bcx: block,\n                             // This is a unit-like struct. Nothing to do here.\n                         }\n                         Some(elems) => {\n-                            // This is the tuple variant case.\n+                            // This is the tuple struct case.\n+                            let repr = adt::represent_node(bcx, pat.id);\n                             for vec::eachi(elems) |i, elem| {\n-                                let fldptr = GEPi(bcx, val, struct_field(i));\n+                                let fldptr = adt::trans_field_ptr(bcx, repr,\n+                                                            val, 0, i);\n                                 bcx = bind_irrefutable_pat(bcx,\n                                                            *elem,\n                                                            fldptr,\n@@ -1797,10 +1769,12 @@ pub fn bind_irrefutable_pat(bcx: block,\n         ast::pat_rec(fields, _) | ast::pat_struct(_, fields, _) => {\n             let tcx = bcx.tcx();\n             let pat_ty = node_id_type(bcx, pat.id);\n-            do expr::with_field_tys(tcx, pat_ty, None) |_hd, field_tys| {\n+            let pat_repr = adt::represent_type(bcx.ccx(), pat_ty);\n+            do expr::with_field_tys(tcx, pat_ty, None) |discr, field_tys| {\n                 for vec::each(fields) |f| {\n                     let ix = ty::field_idx_strict(tcx, f.ident, field_tys);\n-                    let fldptr = GEPi(bcx, val, struct_field(ix));\n+                    let fldptr = adt::trans_field_ptr(bcx, pat_repr, val,\n+                                                discr, ix);\n                     bcx = bind_irrefutable_pat(bcx,\n                                                f.pat,\n                                                fldptr,\n@@ -1810,8 +1784,9 @@ pub fn bind_irrefutable_pat(bcx: block,\n             }\n         }\n         ast::pat_tup(elems) => {\n+            let repr = adt::represent_node(bcx, pat.id);\n             for vec::eachi(elems) |i, elem| {\n-                let fldptr = GEPi(bcx, val, [0u, i]);\n+                let fldptr = adt::trans_field_ptr(bcx, repr, val, 0, i);\n                 bcx = bind_irrefutable_pat(bcx,\n                                            *elem,\n                                            fldptr,"}, {"sha": "3d3b40e4ff2621123b0ad33400b855a6b4feae0a", "filename": "src/librustc/middle/trans/adt.rs", "status": "added", "additions": 554, "deletions": 0, "changes": 554, "blob_url": "https://github.com/rust-lang/rust/blob/194c27bcd16ad92e2edf11ff7446cb679a91c1d3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/194c27bcd16ad92e2edf11ff7446cb679a91c1d3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs?ref=194c27bcd16ad92e2edf11ff7446cb679a91c1d3", "patch": "@@ -0,0 +1,554 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/*!\n+ * # Representation of Algebraic Data Types\n+ *\n+ * This module determines how to represent enums, structs, tuples, and\n+ * (deprecated) structural records based on their monomorphized types;\n+ * it is responsible both for choosing a representation and\n+ * translating basic operations on values of those types.\n+ *\n+ * Note that the interface treats everything as a general case of an\n+ * enum, so structs/tuples/etc. have one pseudo-variant with\n+ * discriminant 0; i.e., as if they were a univariant enum.\n+ *\n+ * Having everything in one place will enable improvements to data\n+ * structure representation; possibilities include:\n+ *\n+ * - Aligning enum bodies correctly, which in turn makes possible SIMD\n+ *   vector types (which are strict-alignment even on x86) and ports\n+ *   to strict-alignment architectures (PowerPC, SPARC, etc.).\n+ *\n+ * - User-specified alignment (e.g., cacheline-aligning parts of\n+ *   concurrently accessed data structures); LLVM can't represent this\n+ *   directly, so we'd have to insert padding fields in any structure\n+ *   that might contain one and adjust GEP indices accordingly.  See\n+ *   issue #4578.\n+ *\n+ * - Rendering `Option<&T>` as a possibly-null `*T` instead of using\n+ *   an extra word (and likewise for `@T` and `~T`).  Can and probably\n+ *   should also apply to any enum with one empty case and one case\n+ *   starting with a non-null pointer (e.g., `Result<(), ~str>`).\n+ *\n+ * - Using smaller integer types for discriminants.\n+ *\n+ * - Store nested enums' discriminants in the same word.  Rather, if\n+ *   some variants start with enums, and those enums representations\n+ *   have unused alignment padding between discriminant and body, the\n+ *   outer enum's discriminant can be stored there and those variants\n+ *   can start at offset 0.  Kind of fancy, and might need work to\n+ *   make copies of the inner enum type cooperate, but it could help\n+ *   with `Option` or `Result` wrapped around another enum.\n+ *\n+ * - Tagged pointers would be neat, but given that any type can be\n+ *   used unboxed and any field can have pointers (including mutable)\n+ *   taken to it, implementing them for Rust seems difficult.\n+ */\n+\n+use core::container::Map;\n+use core::libc::c_ulonglong;\n+use core::option::{Option, Some, None};\n+use core::vec;\n+\n+use lib::llvm::{ValueRef, TypeRef, True, False};\n+use middle::trans::_match;\n+use middle::trans::build::*;\n+use middle::trans::common::*;\n+use middle::trans::machine;\n+use middle::trans::type_of;\n+use middle::ty;\n+use syntax::ast;\n+use util::ppaux::ty_to_str;\n+\n+\n+/// Representations.\n+pub enum Repr {\n+    /**\n+     * `Unit` exists only so that an enum with a single C-like variant\n+     * can occupy no space, for ABI compatibility with rustc from\n+     * before (and during) the creation of this module.  It may not be\n+     * worth keeping around; `CEnum` and `Univariant` cover it\n+     * overwise.\n+     */\n+    Unit(int),\n+    /// C-like enums; basically an int.\n+    CEnum(int, int), // discriminant range\n+    /// Single-case variants, and structs/tuples/records.\n+    Univariant(Struct, Destructor),\n+    /**\n+     * General-case enums: discriminant as int, followed by fields.\n+     * The fields start immediately after the discriminant, meaning\n+     * that they may not be correctly aligned for the platform's ABI;\n+     * see above.\n+     */\n+    General(~[Struct])\n+}\n+\n+/**\n+ * Structs without destructors have historically had an extra layer of\n+ * LLVM-struct to make accessing them work the same as structs with\n+ * destructors.  This could probably be flattened to a boolean now\n+ * that this module exists.\n+ */\n+enum Destructor {\n+    StructWithDtor,\n+    StructWithoutDtor,\n+    NonStruct\n+}\n+\n+/// For structs, and struct-like parts of anything fancier.\n+struct Struct {\n+    size: u64,\n+    align: u64,\n+    fields: ~[ty::t]\n+}\n+\n+/**\n+ * Convenience for `represent_type`.  There should probably be more or\n+ * these, for places in trans where the `ty::t` isn't directly\n+ * available.\n+ */\n+pub fn represent_node(bcx: block, node: ast::node_id) -> @Repr {\n+    represent_type(bcx.ccx(), node_id_type(bcx, node))\n+}\n+\n+/// Decides how to represent a given type.\n+pub fn represent_type(cx: @CrateContext, t: ty::t) -> @Repr {\n+    debug!(\"Representing: %s\", ty_to_str(cx.tcx, t));\n+    match cx.adt_reprs.find(&t) {\n+        Some(repr) => return *repr,\n+        None => { }\n+    }\n+    let repr = @match ty::get(t).sty {\n+        ty::ty_tup(ref elems) => {\n+            Univariant(mk_struct(cx, *elems), NonStruct)\n+        }\n+        ty::ty_rec(ref fields) => {\n+            // XXX: Are these in the right order?\n+            Univariant(mk_struct(cx, fields.map(|f| f.mt.ty)),\n+                       StructWithoutDtor)\n+        }\n+        ty::ty_struct(def_id, ref substs) => {\n+            let fields = ty::lookup_struct_fields(cx.tcx, def_id);\n+            let dt = ty::ty_dtor(cx.tcx, def_id).is_present();\n+            Univariant(mk_struct(cx, fields.map(|field| {\n+                ty::lookup_field_type(cx.tcx, def_id, field.id, substs)\n+            })), if dt { StructWithDtor } else { StructWithoutDtor })\n+        }\n+        ty::ty_enum(def_id, ref substs) => {\n+            struct Case { discr: int, tys: ~[ty::t] };\n+\n+            let cases = do ty::enum_variants(cx.tcx, def_id).map |vi| {\n+                let arg_tys = do vi.args.map |&raw_ty| {\n+                    ty::subst(cx.tcx, substs, raw_ty)\n+                };\n+                Case { discr: vi.disr_val, tys: arg_tys }\n+            };\n+            if cases.len() == 0 {\n+                // Uninhabitable; represent as unit\n+                Unit(0)\n+            } else if cases.len() == 1 && cases[0].tys.len() == 0 {\n+                // `()`-like; see comment on definition of `Unit`.\n+                Unit(cases[0].discr)\n+            } else if cases.len() == 1 {\n+                // Equivalent to a struct/tuple/newtype.\n+                assert cases[0].discr == 0;\n+                Univariant(mk_struct(cx, cases[0].tys), NonStruct)\n+            } else if cases.all(|c| c.tys.len() == 0) {\n+                // All bodies empty -> intlike\n+                let discrs = cases.map(|c| c.discr);\n+                CEnum(discrs.min(), discrs.max())\n+            } else {\n+                // The general case.  Since there's at least one\n+                // non-empty body, explicit discriminants should have\n+                // been rejected by a checker before this point.\n+                if !cases.alli(|i,c| c.discr == (i as int)) {\n+                    cx.sess.bug(fmt!(\"non-C-like enum %s with specified \\\n+                                      discriminants\",\n+                                     ty::item_path_str(cx.tcx, def_id)))\n+                }\n+                General(cases.map(|c| mk_struct(cx, c.tys)))\n+            }\n+        }\n+        _ => cx.sess.bug(~\"adt::represent_type called on non-ADT type\")\n+    };\n+    cx.adt_reprs.insert(t, repr);\n+    return repr;\n+}\n+\n+fn mk_struct(cx: @CrateContext, tys: &[ty::t]) -> Struct {\n+    let lltys = tys.map(|&ty| type_of::sizing_type_of(cx, ty));\n+    let llty_rec = T_struct(lltys);\n+    Struct {\n+        size: machine::llsize_of_alloc(cx, llty_rec) /*bad*/as u64,\n+        align: machine::llalign_of_min(cx, llty_rec) /*bad*/as u64,\n+        fields: vec::from_slice(tys)\n+    }\n+}\n+\n+/**\n+ * Returns the fields of a struct for the given representation.\n+ * All nominal types are LLVM structs, in order to be able to use\n+ * forward-declared opaque types to prevent circularity in `type_of`.\n+ */\n+pub fn fields_of(cx: @CrateContext, r: &Repr) -> ~[TypeRef] {\n+    generic_fields_of(cx, r, false)\n+}\n+/// Like `fields_of`, but for `type_of::sizing_type_of` (q.v.).\n+pub fn sizing_fields_of(cx: @CrateContext, r: &Repr) -> ~[TypeRef] {\n+    generic_fields_of(cx, r, true)\n+}\n+fn generic_fields_of(cx: @CrateContext, r: &Repr, sizing: bool)\n+    -> ~[TypeRef] {\n+    match *r {\n+        Unit(*) => ~[],\n+        CEnum(*) => ~[T_enum_discrim(cx)],\n+        Univariant(ref st, dt) => {\n+            let f = if sizing {\n+                st.fields.map(|&ty| type_of::sizing_type_of(cx, ty))\n+            } else {\n+                st.fields.map(|&ty| type_of::type_of(cx, ty))\n+            };\n+            match dt {\n+                NonStruct => f,\n+                StructWithoutDtor => ~[T_struct(f)],\n+                StructWithDtor => ~[T_struct(f), T_i8()]\n+            }\n+        }\n+        General(ref sts) => {\n+            ~[T_enum_discrim(cx),\n+              T_array(T_i8(), sts.map(|st| st.size).max() /*bad*/as uint)]\n+        }\n+    }\n+}\n+\n+/**\n+ * Obtain a representation of the discriminant sufficient to translate\n+ * destructuring; this may or may not involve the actual discriminant.\n+ *\n+ * This should ideally be less tightly tied to `_match`.\n+ */\n+pub fn trans_switch(bcx: block, r: &Repr, scrutinee: ValueRef)\n+    -> (_match::branch_kind, Option<ValueRef>) {\n+    match *r {\n+        CEnum(*) | General(*) => {\n+            (_match::switch, Some(trans_get_discr(bcx, r, scrutinee)))\n+        }\n+        Unit(*) | Univariant(*) => {\n+            (_match::single, None)\n+        }\n+    }\n+}\n+\n+/// Obtain the actual discriminant of a value.\n+pub fn trans_get_discr(bcx: block, r: &Repr, scrutinee: ValueRef)\n+    -> ValueRef {\n+    match *r {\n+        Unit(the_disc) => C_int(bcx.ccx(), the_disc),\n+        CEnum(min, max) => load_discr(bcx, scrutinee, min, max),\n+        Univariant(*) => C_int(bcx.ccx(), 0),\n+        General(ref cases) => load_discr(bcx, scrutinee, 0,\n+                                         (cases.len() - 1) as int)\n+    }\n+}\n+\n+/// Helper for cases where the discriminant is simply loaded.\n+fn load_discr(bcx: block, scrutinee: ValueRef, min: int, max: int)\n+    -> ValueRef {\n+    let ptr = GEPi(bcx, scrutinee, [0, 0]);\n+    if max + 1 == min {\n+        // i.e., if the range is everything.  The lo==hi case would be\n+        // rejected by the LLVM verifier (it would mean either an\n+        // empty set, which is impossible, or the entire range of the\n+        // type, which is pointless).\n+        Load(bcx, ptr)\n+    } else {\n+        // llvm::ConstantRange can deal with ranges that wrap around,\n+        // so an overflow on (max + 1) is fine.\n+        LoadRangeAssert(bcx, ptr, min as c_ulonglong,\n+                        (max + 1) as c_ulonglong,\n+                        /* signed: */ True)\n+    }\n+}\n+\n+/**\n+ * Yield information about how to dispatch a case of the\n+ * discriminant-like value returned by `trans_switch`.\n+ *\n+ * This should ideally be less tightly tied to `_match`.\n+ */\n+pub fn trans_case(bcx: block, r: &Repr, discr: int) -> _match::opt_result {\n+    match *r {\n+        CEnum(*) => {\n+            _match::single_result(rslt(bcx, C_int(bcx.ccx(), discr)))\n+        }\n+        Unit(*) | Univariant(*)=> {\n+            bcx.ccx().sess.bug(~\"no cases for univariants or structs\")\n+        }\n+        General(*) => {\n+            _match::single_result(rslt(bcx, C_int(bcx.ccx(), discr)))\n+        }\n+    }\n+}\n+\n+/**\n+ * Begin initializing a new value of the given case of the given\n+ * representation.  The fields, if any, should then be initialized via\n+ * `trans_field_ptr`.\n+ */\n+pub fn trans_start_init(bcx: block, r: &Repr, val: ValueRef, discr: int) {\n+    match *r {\n+        Unit(the_discr) => {\n+            assert discr == the_discr;\n+        }\n+        CEnum(min, max) => {\n+            assert min <= discr && discr <= max;\n+            Store(bcx, C_int(bcx.ccx(), discr), GEPi(bcx, val, [0, 0]))\n+        }\n+        Univariant(_, StructWithDtor) => {\n+            assert discr == 0;\n+            Store(bcx, C_u8(1), GEPi(bcx, val, [0, 1]))\n+        }\n+        Univariant(*) => {\n+            assert discr == 0;\n+        }\n+        General(*) => {\n+            Store(bcx, C_int(bcx.ccx(), discr), GEPi(bcx, val, [0, 0]))\n+        }\n+    }\n+}\n+\n+/**\n+ * The number of fields in a given case; for use when obtaining this\n+ * information from the type or definition is less convenient.\n+ */\n+pub fn num_args(r: &Repr, discr: int) -> uint {\n+    match *r {\n+        Unit(*) | CEnum(*) => 0,\n+        Univariant(ref st, _dt) => { assert discr == 0; st.fields.len() }\n+        General(ref cases) => cases[discr as uint].fields.len()\n+    }\n+}\n+\n+/// Access a field, at a point when the value's case is known.\n+pub fn trans_field_ptr(bcx: block, r: &Repr, val: ValueRef, discr: int,\n+                       ix: uint) -> ValueRef {\n+    // Note: if this ever needs to generate conditionals (e.g., if we\n+    // decide to do some kind of cdr-coding-like non-unique repr\n+    // someday), it will need to return a possibly-new bcx as well.\n+    match *r {\n+        Unit(*) | CEnum(*) => {\n+            bcx.ccx().sess.bug(~\"element access in C-like enum\")\n+        }\n+        Univariant(ref st, dt) => {\n+            assert discr == 0;\n+            let val = match dt {\n+                NonStruct => val,\n+                StructWithDtor | StructWithoutDtor => GEPi(bcx, val, [0, 0])\n+            };\n+            struct_field_ptr(bcx, st, val, ix, false)\n+        }\n+        General(ref cases) => {\n+            struct_field_ptr(bcx, &cases[discr as uint],\n+                                 GEPi(bcx, val, [0, 1]), ix, true)\n+        }\n+    }\n+}\n+\n+fn struct_field_ptr(bcx: block, st: &Struct, val: ValueRef, ix: uint,\n+              needs_cast: bool) -> ValueRef {\n+    let ccx = bcx.ccx();\n+\n+    let val = if needs_cast {\n+        let real_llty = T_struct(st.fields.map(\n+            |&ty| type_of::type_of(ccx, ty)));\n+        PointerCast(bcx, val, T_ptr(real_llty))\n+    } else {\n+        val\n+    };\n+\n+    GEPi(bcx, val, [0, ix])\n+}\n+\n+/// Access the struct drop flag, if present.\n+pub fn trans_drop_flag_ptr(bcx: block, r: &Repr, val: ValueRef) -> ValueRef {\n+    match *r {\n+        Univariant(_, StructWithDtor) => GEPi(bcx, val, [0, 1]),\n+        _ => bcx.ccx().sess.bug(~\"tried to get drop flag of non-droppable \\\n+                                  type\")\n+    }\n+}\n+\n+/**\n+ * Construct a constant value, suitable for initializing a\n+ * GlobalVariable, given a case and constant values for its fields.\n+ * Note that this may have a different LLVM type (and different\n+ * alignment!) from the representation's `type_of`, so it needs a\n+ * pointer cast before use.\n+ *\n+ * The LLVM type system does not directly support unions, and only\n+ * pointers can be bitcast, so a constant (and, by extension, the\n+ * GlobalVariable initialized by it) will have a type that can vary\n+ * depending on which case of an enum it is.\n+ *\n+ * To understand the alignment situation, consider `enum E { V64(u64),\n+ * V32(u32, u32) }` on win32.  The type should have 8-byte alignment\n+ * to accommodate the u64 (currently it doesn't; this is a known bug),\n+ * but `V32(x, y)` would have LLVM type `{i32, i32, i32}`, which is\n+ * 4-byte aligned.\n+ *\n+ * Currently the returned value has the same size as the type, but\n+ * this may be changed in the future to avoid allocating unnecessary\n+ * space after values of shorter-than-maximum cases.\n+ */\n+pub fn trans_const(ccx: @CrateContext, r: &Repr, discr: int,\n+                   vals: &[ValueRef]) -> ValueRef {\n+    match *r {\n+        Unit(*) => {\n+            C_struct(~[])\n+        }\n+        CEnum(min, max) => {\n+            assert vals.len() == 0;\n+            assert min <= discr && discr <= max;\n+            C_int(ccx, discr)\n+        }\n+        Univariant(ref st, dt) => {\n+            assert discr == 0;\n+            let s = C_struct(build_const_struct(ccx, st, vals));\n+            match dt {\n+                NonStruct => s,\n+                // The actual destructor flag doesn't need to be present.\n+                // But add an extra struct layer for compatibility.\n+                StructWithDtor | StructWithoutDtor => C_struct(~[s])\n+            }\n+        }\n+        General(ref cases) => {\n+            let case = &cases[discr as uint];\n+            let max_sz = cases.map(|s| s.size).max();\n+            let body = build_const_struct(ccx, case, vals);\n+\n+            // The unary packed struct has alignment 1 regardless of\n+            // its contents, so it will always be located at the\n+            // expected offset at runtime.\n+            C_struct([C_int(ccx, discr),\n+                      C_packed_struct([C_struct(body)]),\n+                      padding(max_sz - case.size)])\n+        }\n+    }\n+}\n+\n+/**\n+ * Building structs is a little complicated, because we might need to\n+ * insert padding if a field's value is less aligned than its type.\n+ *\n+ * Continuing the example from `trans_const`, a value of type `(u32,\n+ * E)` should have the `E` at offset 8, but if that field's\n+ * initializer is 4-byte aligned then simply translating the tuple as\n+ * a two-element struct will locate it at offset 4, and accesses to it\n+ * will read the wrong memory.\n+ */\n+fn build_const_struct(ccx: @CrateContext, st: &Struct, vals: &[ValueRef])\n+    -> ~[ValueRef] {\n+    assert vals.len() == st.fields.len();\n+\n+    let mut offset = 0;\n+    let mut cfields = ~[];\n+    for st.fields.eachi |i, &ty| {\n+        let llty = type_of::sizing_type_of(ccx, ty);\n+        let type_align = machine::llalign_of_min(ccx, llty)\n+            /*bad*/as u64;\n+        let val_align = machine::llalign_of_min(ccx, val_ty(vals[i]))\n+            /*bad*/as u64;\n+        let target_offset = roundup(offset, type_align);\n+        offset = roundup(offset, val_align);\n+        if (offset != target_offset) {\n+            cfields.push(padding(target_offset - offset));\n+            offset = target_offset;\n+        }\n+        assert !is_undef(vals[i]);\n+        // If that assert fails, could change it to wrap in a struct?\n+        // (See `const_struct_field` for why real fields must not be undef.)\n+        cfields.push(vals[i]);\n+    }\n+\n+    return cfields;\n+}\n+\n+fn padding(size: u64) -> ValueRef {\n+    C_undef(T_array(T_i8(), size /*bad*/as uint))\n+}\n+\n+// XXX this utility routine should be somewhere more general\n+#[always_inline]\n+fn roundup(x: u64, a: u64) -> u64 { ((x + (a - 1)) / a) * a }\n+\n+/// Get the discriminant of a constant value.  (Not currently used.)\n+pub fn const_get_discrim(ccx: @CrateContext, r: &Repr, val: ValueRef)\n+    -> int {\n+    match *r {\n+        Unit(discr) => discr,\n+        CEnum(*) => const_to_int(val) as int,\n+        Univariant(*) => 0,\n+        General(*) => const_to_int(const_get_elt(ccx, val, [0])) as int,\n+    }\n+}\n+\n+/**\n+ * Extract a field of a constant value, as appropriate for its\n+ * representation.\n+ *\n+ * (Not to be confused with `common::const_get_elt`, which operates on\n+ * raw LLVM-level structs and arrays.)\n+ */\n+pub fn const_get_field(ccx: @CrateContext, r: &Repr, val: ValueRef,\n+                       _discr: int, ix: uint) -> ValueRef {\n+    match *r {\n+        Unit(*) | CEnum(*) => ccx.sess.bug(~\"element access in C-like enum \\\n+                                             const\"),\n+        Univariant(_, NonStruct) => const_struct_field(ccx, val, ix),\n+        Univariant(*) => const_struct_field(ccx, const_get_elt(ccx, val,\n+                                                               [0]), ix),\n+        General(*) => const_struct_field(ccx, const_get_elt(ccx, val,\n+                                                            [1, 0]), ix)\n+    }\n+}\n+\n+/// Extract field of struct-like const, skipping our alignment padding.\n+fn const_struct_field(ccx: @CrateContext, val: ValueRef, ix: uint)\n+    -> ValueRef {\n+    // Get the ix-th non-undef element of the struct.\n+    let mut real_ix = 0; // actual position in the struct\n+    let mut ix = ix; // logical index relative to real_ix\n+    let mut field;\n+    loop {\n+        loop {\n+            field = const_get_elt(ccx, val, [real_ix]);\n+            if !is_undef(field) {\n+                break;\n+            }\n+            real_ix = real_ix + 1;\n+        }\n+        if ix == 0 {\n+            return field;\n+        }\n+        ix = ix - 1;\n+        real_ix = real_ix + 1;\n+    }\n+}\n+\n+/// Is it safe to bitcast a value to the one field of its one variant?\n+pub fn is_newtypeish(r: &Repr) -> bool {\n+    match *r {\n+        Univariant(ref st, StructWithoutDtor)\n+        | Univariant(ref st, NonStruct) => st.fields.len() == 1,\n+        _ => false\n+    }\n+}"}, {"sha": "8280243455d9b70322756fd79859d856928a4b87", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 89, "deletions": 134, "changes": 223, "blob_url": "https://github.com/rust-lang/rust/blob/194c27bcd16ad92e2edf11ff7446cb679a91c1d3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/194c27bcd16ad92e2edf11ff7446cb679a91c1d3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=194c27bcd16ad92e2edf11ff7446cb679a91c1d3", "patch": "@@ -39,6 +39,7 @@ use middle::astencode;\n use middle::borrowck::RootInfo;\n use middle::resolve;\n use middle::trans::_match;\n+use middle::trans::adt;\n use middle::trans::base;\n use middle::trans::build::*;\n use middle::trans::callee;\n@@ -66,6 +67,7 @@ use util::ppaux::{ty_to_str, ty_to_short_str};\n use util::ppaux;\n \n use core::hash;\n+use core::hashmap::linear::LinearMap;\n use core::int;\n use core::io;\n use core::libc::{c_uint, c_ulonglong};\n@@ -238,25 +240,6 @@ pub fn bump_ptr(bcx: block, t: ty::t, base: ValueRef, sz: ValueRef) ->\n     PointerCast(bcx, bumped, typ)\n }\n \n-// Replacement for the LLVM 'GEP' instruction when field indexing into a enum.\n-// @llblobptr is the data part of a enum value; its actual type\n-// is meaningless, as it will be cast away.\n-pub fn GEP_enum(bcx: block, llblobptr: ValueRef, enum_id: ast::def_id,\n-                variant_id: ast::def_id, ty_substs: &[ty::t],\n-                ix: uint) -> ValueRef {\n-    let _icx = bcx.insn_ctxt(\"GEP_enum\");\n-    let ccx = bcx.ccx();\n-    let variant = ty::enum_variant_with_id(ccx.tcx, enum_id, variant_id);\n-    assert ix < variant.args.len();\n-\n-    let arg_lltys = vec::map(variant.args, |aty| {\n-        type_of(ccx, ty::subst_tps(ccx.tcx, ty_substs, None, *aty))\n-    });\n-    let typed_blobptr = PointerCast(bcx, llblobptr,\n-                                    T_ptr(T_struct(arg_lltys)));\n-    GEPi(bcx, typed_blobptr, [0u, ix])\n-}\n-\n // Returns a pointer to the body for the box. The box may be an opaque\n // box. The result will be casted to the type of body_t, if it is statically\n // known.\n@@ -639,45 +622,28 @@ pub fn iter_structural_ty(cx: block, av: ValueRef, t: ty::t,\n                           f: val_and_ty_fn) -> block {\n     let _icx = cx.insn_ctxt(\"iter_structural_ty\");\n \n-    fn iter_variant(cx: block, a_tup: ValueRef,\n+    fn iter_variant(cx: block, repr: &adt::Repr, av: ValueRef,\n                     variant: ty::VariantInfo,\n-                    tps: &[ty::t], tid: ast::def_id,\n-                    f: val_and_ty_fn) -> block {\n+                    tps: &[ty::t], f: val_and_ty_fn) -> block {\n         let _icx = cx.insn_ctxt(\"iter_variant\");\n-        if variant.args.len() == 0u { return cx; }\n-        let fn_ty = variant.ctor_ty;\n-        let ccx = cx.ccx();\n+        let tcx = cx.tcx();\n         let mut cx = cx;\n-        match ty::get(fn_ty).sty {\n-          ty::ty_bare_fn(ref fn_ty) => {\n-            let mut j = 0u;\n-            let v_id = variant.id;\n-            for vec::each(fn_ty.sig.inputs) |a| {\n-                let llfldp_a = GEP_enum(cx, a_tup, tid, v_id,\n-                                        /*bad*/copy tps, j);\n-                // This assumes the self type is absent (it passes\n-                // None for the self_ty_opt arg of substs_tps).\n-                // I think that's ok since you can't have an enum\n-                // inside a trait.\n-                let ty_subst = ty::subst_tps(ccx.tcx, tps, None, a.ty);\n-                cx = f(cx, llfldp_a, ty_subst);\n-                j += 1u;\n-            }\n-          }\n-          _ => cx.tcx().sess.bug(fmt!(\"iter_variant: not a function type: \\\n-                                       %s (variant name = %s)\",\n-                                      cx.ty_to_str(fn_ty),\n-                                      *cx.sess().str_of(variant.name)))\n+\n+        for variant.args.eachi |i, &arg| {\n+            cx = f(cx,\n+                   adt::trans_field_ptr(cx, repr, av, variant.disr_val, i),\n+                   ty::subst_tps(tcx, tps, None, arg));\n         }\n         return cx;\n     }\n \n     let mut cx = cx;\n     match /*bad*/copy ty::get(t).sty {\n       ty::ty_rec(*) | ty::ty_struct(*) => {\n-          do expr::with_field_tys(cx.tcx(), t, None) |_has_dtor, field_tys| {\n+          let repr = adt::represent_type(cx.ccx(), t);\n+          do expr::with_field_tys(cx.tcx(), t, None) |discr, field_tys| {\n               for vec::eachi(field_tys) |i, field_ty| {\n-                  let llfld_a = GEPi(cx, av, struct_field(i));\n+                  let llfld_a = adt::trans_field_ptr(cx, repr, av, discr, i);\n                   cx = f(cx, llfld_a, field_ty.mt.ty);\n               }\n           }\n@@ -688,51 +654,56 @@ pub fn iter_structural_ty(cx: block, av: ValueRef, t: ty::t,\n         cx = tvec::iter_vec_raw(cx, base, t, len, f);\n       }\n       ty::ty_tup(args) => {\n-        for vec::eachi(args) |i, arg| {\n-            let llfld_a = GEPi(cx, av, [0u, i]);\n-            cx = f(cx, llfld_a, *arg);\n-        }\n+          let repr = adt::represent_type(cx.ccx(), t);\n+          for vec::eachi(args) |i, arg| {\n+              let llfld_a = adt::trans_field_ptr(cx, repr, av, 0, i);\n+              cx = f(cx, llfld_a, *arg);\n+          }\n       }\n       ty::ty_enum(tid, ref substs) => {\n-        let variants = ty::enum_variants(cx.tcx(), tid);\n-        let n_variants = (*variants).len();\n-\n-        // Cast the enums to types we can GEP into.\n-        if n_variants == 1u {\n-            return iter_variant(cx,\n-                                av,\n-                                variants[0],\n-                                /*bad*/copy substs.tps,\n-                                tid,\n-                                f);\n-        }\n+          let ccx = cx.ccx();\n \n-        let ccx = cx.ccx();\n-        let llenumty = T_opaque_enum_ptr(ccx);\n-        let av_enum = PointerCast(cx, av, llenumty);\n-        let lldiscrim_a_ptr = GEPi(cx, av_enum, [0u, 0u]);\n-        let llunion_a_ptr = GEPi(cx, av_enum, [0u, 1u]);\n-        let lldiscrim_a = Load(cx, lldiscrim_a_ptr);\n-\n-        // NB: we must hit the discriminant first so that structural\n-        // comparison know not to proceed when the discriminants differ.\n-        cx = f(cx, lldiscrim_a_ptr, ty::mk_int(cx.tcx()));\n-        let unr_cx = sub_block(cx, ~\"enum-iter-unr\");\n-        Unreachable(unr_cx);\n-        let llswitch = Switch(cx, lldiscrim_a, unr_cx.llbb, n_variants);\n-        let next_cx = sub_block(cx, ~\"enum-iter-next\");\n-        for vec::each(*variants) |variant| {\n-            let variant_cx =\n-                sub_block(cx,\n-                                   ~\"enum-iter-variant-\" +\n-                                       int::to_str(variant.disr_val));\n-            AddCase(llswitch, C_int(ccx, variant.disr_val), variant_cx.llbb);\n-            let variant_cx =\n-                iter_variant(variant_cx, llunion_a_ptr, *variant,\n-                             /*bad*/copy (*substs).tps, tid, f);\n-            Br(variant_cx, next_cx.llbb);\n-        }\n-        return next_cx;\n+          let repr = adt::represent_type(ccx, t);\n+          let variants = ty::enum_variants(ccx.tcx, tid);\n+          let n_variants = (*variants).len();\n+\n+          // NB: we must hit the discriminant first so that structural\n+          // comparison know not to proceed when the discriminants differ.\n+\n+          match adt::trans_switch(cx, repr, av) {\n+              (_match::single, None) => {\n+                  cx = iter_variant(cx, repr, av, variants[0],\n+                                    substs.tps, f);\n+              }\n+              (_match::switch, Some(lldiscrim_a)) => {\n+                  cx = f(cx, lldiscrim_a, ty::mk_int(cx.tcx()));\n+                  let unr_cx = sub_block(cx, ~\"enum-iter-unr\");\n+                  Unreachable(unr_cx);\n+                  let llswitch = Switch(cx, lldiscrim_a, unr_cx.llbb,\n+                                        n_variants);\n+                  let next_cx = sub_block(cx, ~\"enum-iter-next\");\n+\n+                  for vec::each(*variants) |variant| {\n+                      let variant_cx =\n+                          sub_block(cx, ~\"enum-iter-variant-\" +\n+                                    int::to_str(variant.disr_val));\n+                      let variant_cx =\n+                          iter_variant(variant_cx, repr, av, *variant,\n+                                       substs.tps, f);\n+                      match adt::trans_case(cx, repr, variant.disr_val) {\n+                          _match::single_result(r) => {\n+                              AddCase(llswitch, r.val, variant_cx.llbb)\n+                          }\n+                          _ => ccx.sess.unimpl(~\"value from adt::trans_case \\\n+                                                 in iter_structural_ty\")\n+                      }\n+                      Br(variant_cx, next_cx.llbb);\n+                  }\n+                  cx = next_cx;\n+              }\n+              _ => ccx.sess.unimpl(~\"value from adt::trans_switch \\\n+                                     in iter_structural_ty\")\n+          }\n       }\n       _ => cx.sess().unimpl(~\"type in iter_structural_ty\")\n     }\n@@ -828,30 +799,6 @@ pub fn trans_external_path(ccx: @CrateContext, did: ast::def_id, t: ty::t)\n     };\n }\n \n-pub fn get_discrim_val(cx: @CrateContext, span: span, enum_did: ast::def_id,\n-                       variant_did: ast::def_id) -> ValueRef {\n-    // Can't use `discrims` from the crate context here because\n-    // those discriminants have an extra level of indirection,\n-    // and there's no LLVM constant load instruction.\n-    let mut lldiscrim_opt = None;\n-    for ty::enum_variants(cx.tcx, enum_did).each |variant_info| {\n-        if variant_info.id == variant_did {\n-            lldiscrim_opt = Some(C_int(cx,\n-                                       variant_info.disr_val));\n-            break;\n-        }\n-    }\n-\n-    match lldiscrim_opt {\n-        None => {\n-            cx.tcx.sess.span_bug(span, ~\"didn't find discriminant?!\");\n-        }\n-        Some(found_lldiscrim) => {\n-            found_lldiscrim\n-        }\n-    }\n-}\n-\n pub fn invoke(bcx: block, llfn: ValueRef, +llargs: ~[ValueRef]) -> block {\n     let _icx = bcx.insn_ctxt(\"invoke_\");\n     if bcx.unreachable { return bcx; }\n@@ -1885,7 +1832,6 @@ pub fn trans_enum_variant(ccx: @CrateContext,\n                           variant: ast::variant,\n                           args: &[ast::variant_arg],\n                           disr: int,\n-                          is_degen: bool,\n                           param_substs: Option<@param_substs>,\n                           llfndecl: ValueRef) {\n     let _icx = ccx.insn_ctxt(\"trans_enum_variant\");\n@@ -1914,21 +1860,16 @@ pub fn trans_enum_variant(ccx: @CrateContext,\n     let arg_tys = ty::ty_fn_args(node_id_type(bcx, variant.node.id));\n     let bcx = copy_args_to_allocas(fcx, bcx, fn_args, raw_llargs, arg_tys);\n \n-    // Cast the enum to a type we can GEP into.\n-    let llblobptr = if is_degen {\n-        fcx.llretptr\n-    } else {\n-        let llenumptr =\n-            PointerCast(bcx, fcx.llretptr, T_opaque_enum_ptr(ccx));\n-        let lldiscrimptr = GEPi(bcx, llenumptr, [0u, 0u]);\n-        Store(bcx, C_int(ccx, disr), lldiscrimptr);\n-        GEPi(bcx, llenumptr, [0u, 1u])\n-    };\n-    let t_id = local_def(enum_id);\n-    let v_id = local_def(variant.node.id);\n+    // XXX is there a better way to reconstruct the ty::t?\n+    let enum_ty = ty::subst_tps(ccx.tcx, ty_param_substs, None,\n+                                ty::node_id_to_type(ccx.tcx, enum_id));\n+    let repr = adt::represent_type(ccx, enum_ty);\n+\n+    adt::trans_start_init(bcx, repr, fcx.llretptr, disr);\n     for vec::eachi(args) |i, va| {\n-        let lldestptr = GEP_enum(bcx, llblobptr, t_id, v_id,\n-                                 /*bad*/copy ty_param_substs, i);\n+        let lldestptr = adt::trans_field_ptr(bcx, repr, fcx.llretptr,\n+                                             disr, i);\n+\n         // If this argument to this function is a enum, it'll have come in to\n         // this function as an opaque blob due to the way that type_of()\n         // works. So we have to cast to the destination's view of the type.\n@@ -1981,8 +1922,23 @@ pub fn trans_tuple_struct(ccx: @CrateContext,\n     let arg_tys = ty::ty_fn_args(node_id_type(bcx, ctor_id));\n     let bcx = copy_args_to_allocas(fcx, bcx, fn_args, raw_llargs, arg_tys);\n \n+    // XXX is there a better way to reconstruct the ty::t?\n+    let ty_param_substs = match param_substs {\n+        Some(ref substs) => /*bad*/copy substs.tys,\n+        None => ~[]\n+    };\n+    let ctor_ty = ty::subst_tps(ccx.tcx, ty_param_substs, None,\n+                                ty::node_id_to_type(ccx.tcx, ctor_id));\n+    let tup_ty = match ty::get(ctor_ty).sty {\n+        ty::ty_bare_fn(ref bft) => bft.sig.output,\n+        _ => ccx.sess.bug(fmt!(\"trans_tuple_struct: unexpected ctor \\\n+                                return type %s\",\n+                               ty_to_str(ccx.tcx, ctor_ty)))\n+    };\n+    let repr = adt::represent_type(ccx, tup_ty);\n+\n     for fields.eachi |i, field| {\n-        let lldestptr = GEPi(bcx, fcx.llretptr, [0, 0, i]);\n+        let lldestptr = adt::trans_field_ptr(bcx, repr, fcx.llretptr, 0, i);\n         let llarg = match fcx.llargs.get(&field.node.id) {\n             local_mem(x) => x,\n             _ => {\n@@ -2038,7 +1994,7 @@ pub fn trans_struct_dtor(ccx: @CrateContext,\n }\n \n pub fn trans_enum_def(ccx: @CrateContext, enum_definition: ast::enum_def,\n-                      id: ast::node_id, degen: bool,\n+                      id: ast::node_id,\n                       path: @ast_map::path, vi: @~[ty::VariantInfo],\n                       i: &mut uint) {\n     for vec::each(enum_definition.variants) |variant| {\n@@ -2049,7 +2005,7 @@ pub fn trans_enum_def(ccx: @CrateContext, enum_definition: ast::enum_def,\n             ast::tuple_variant_kind(ref args) if args.len() > 0 => {\n                 let llfn = get_item_val(ccx, variant.node.id);\n                 trans_enum_variant(ccx, id, *variant, /*bad*/copy *args,\n-                                   disr_val, degen, None, llfn);\n+                                   disr_val, None, llfn);\n             }\n             ast::tuple_variant_kind(_) => {\n                 // Nothing to do.\n@@ -2062,7 +2018,6 @@ pub fn trans_enum_def(ccx: @CrateContext, enum_definition: ast::enum_def,\n                 trans_enum_def(ccx,\n                                *enum_definition,\n                                id,\n-                               degen,\n                                path,\n                                vi,\n                                &mut *i);\n@@ -2113,11 +2068,10 @@ pub fn trans_item(ccx: @CrateContext, item: ast::item) {\n       }\n       ast::item_enum(ref enum_definition, ref generics) => {\n         if !generics.is_type_parameterized() {\n-            let degen = (*enum_definition).variants.len() == 1u;\n             let vi = ty::enum_variants(ccx.tcx, local_def(item.id));\n             let mut i = 0;\n             trans_enum_def(ccx, (*enum_definition), item.id,\n-                           degen, path, vi, &mut i);\n+                           path, vi, &mut i);\n         }\n       }\n       ast::item_const(_, expr) => consts::trans_const(ccx, expr, item.id),\n@@ -3099,6 +3053,7 @@ pub fn trans_crate(sess: session::Session,\n               module_data: HashMap(),\n               lltypes: ty::new_ty_hash(),\n               llsizingtypes: ty::new_ty_hash(),\n+              adt_reprs: @mut LinearMap::new(),\n               names: new_namegen(sess.parse_sess.interner),\n               next_addrspace: new_addrspace_gen(),\n               symbol_hasher: symbol_hasher,"}, {"sha": "a363a950f9b24763f25a5d18de7344e31d01ae06", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 42, "deletions": 44, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/194c27bcd16ad92e2edf11ff7446cb679a91c1d3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/194c27bcd16ad92e2edf11ff7446cb679a91c1d3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=194c27bcd16ad92e2edf11ff7446cb679a91c1d3", "patch": "@@ -26,6 +26,7 @@ use lib;\n use metadata::common::LinkMeta;\n use middle::astencode;\n use middle::resolve;\n+use middle::trans::adt;\n use middle::trans::base;\n use middle::trans::build;\n use middle::trans::callee;\n@@ -44,7 +45,8 @@ use util::ppaux::{expr_repr, ty_to_str};\n \n use core::cast;\n use core::hash;\n-use core::libc::c_uint;\n+use core::hashmap::linear::LinearMap;\n+use core::libc::{c_uint, c_longlong, c_ulonglong};\n use core::ptr;\n use core::str;\n use core::to_bytes;\n@@ -203,6 +205,7 @@ pub struct CrateContext {\n      module_data: HashMap<~str, ValueRef>,\n      lltypes: HashMap<ty::t, TypeRef>,\n      llsizingtypes: HashMap<ty::t, TypeRef>,\n+     adt_reprs: @mut LinearMap<ty::t, @adt::Repr>,\n      names: namegen,\n      next_addrspace: addrspace_gen,\n      symbol_hasher: @hash::State,\n@@ -1016,22 +1019,6 @@ pub fn T_chan(cx: @CrateContext, _t: TypeRef) -> TypeRef {\n pub fn T_taskptr(cx: @CrateContext) -> TypeRef { return T_ptr(cx.task_type); }\n \n \n-// This type must never be used directly; it must always be cast away.\n-pub fn T_typaram(tn: @TypeNames) -> TypeRef {\n-    let s = @\"typaram\";\n-    match name_has_type(tn, s) {\n-      Some(t) => return t,\n-      _ => ()\n-    }\n-    let t = T_i8();\n-    associate_type(tn, s, t);\n-    return t;\n-}\n-\n-pub fn T_typaram_ptr(tn: @TypeNames) -> TypeRef {\n-    return T_ptr(T_typaram(tn));\n-}\n-\n pub fn T_opaque_cbox_ptr(cx: @CrateContext) -> TypeRef {\n     // closures look like boxes (even when they are ~fn or &fn)\n     // see trans_closure.rs\n@@ -1042,21 +1029,6 @@ pub fn T_enum_discrim(cx: @CrateContext) -> TypeRef {\n     return cx.int_type;\n }\n \n-pub fn T_opaque_enum(cx: @CrateContext) -> TypeRef {\n-    let s = @\"opaque_enum\";\n-    match name_has_type(cx.tn, s) {\n-      Some(t) => return t,\n-      _ => ()\n-    }\n-    let t = T_struct(~[T_enum_discrim(cx), T_i8()]);\n-    associate_type(cx.tn, s, t);\n-    return t;\n-}\n-\n-pub fn T_opaque_enum_ptr(cx: @CrateContext) -> TypeRef {\n-    return T_ptr(T_opaque_enum(cx));\n-}\n-\n pub fn T_captured_tydescs(cx: @CrateContext, n: uint) -> TypeRef {\n     return T_struct(vec::from_elem::<TypeRef>(n, T_ptr(cx.tydesc_type)));\n }\n@@ -1087,6 +1059,12 @@ pub fn C_null(t: TypeRef) -> ValueRef {\n     }\n }\n \n+pub fn C_undef(t: TypeRef) -> ValueRef {\n+    unsafe {\n+        return llvm::LLVMGetUndef(t);\n+    }\n+}\n+\n pub fn C_integral(t: TypeRef, u: u64, sign_extend: Bool) -> ValueRef {\n     unsafe {\n         return llvm::LLVMConstInt(t, u, sign_extend);\n@@ -1254,6 +1232,38 @@ pub fn get_param(fndecl: ValueRef, param: uint) -> ValueRef {\n     }\n }\n \n+pub fn const_get_elt(cx: @CrateContext, v: ValueRef, us: &[c_uint])\n+                  -> ValueRef {\n+    unsafe {\n+        let r = do vec::as_imm_buf(us) |p, len| {\n+            llvm::LLVMConstExtractValue(v, p, len as c_uint)\n+        };\n+\n+        debug!(\"const_get_elt(v=%s, us=%?, r=%s)\",\n+               val_str(cx.tn, v), us, val_str(cx.tn, r));\n+\n+        return r;\n+    }\n+}\n+\n+pub fn const_to_int(v: ValueRef) -> c_longlong {\n+    unsafe {\n+        llvm::LLVMConstIntGetSExtValue(v)\n+    }\n+}\n+\n+pub fn const_to_uint(v: ValueRef) -> c_ulonglong {\n+    unsafe {\n+        llvm::LLVMConstIntGetZExtValue(v)\n+    }\n+}\n+\n+pub fn is_undef(val: ValueRef) -> bool {\n+    unsafe {\n+        llvm::LLVMIsUndef(val) != False\n+    }\n+}\n+\n // Used to identify cached monomorphized functions and vtables\n #[deriving_eq]\n pub enum mono_param_id {\n@@ -1430,18 +1440,6 @@ pub fn dummy_substs(+tps: ~[ty::t]) -> ty::substs {\n     }\n }\n \n-pub fn struct_field(index: uint) -> [uint * 3] {\n-    //! The GEPi sequence to access a field of a record/struct.\n-\n-    [0, 0, index]\n-}\n-\n-pub fn struct_dtor() -> [uint * 2] {\n-    //! The GEPi sequence to access the dtor of a struct.\n-\n-    [0, 1]\n-}\n-\n // Casts a Rust bool value to an i1.\n pub fn bool_to_i1(bcx: block, llval: ValueRef) -> ValueRef {\n     build::ICmp(bcx, lib::llvm::IntNE, llval, C_bool(false))"}, {"sha": "d19ffe8cb211f73f1fc17442c232ba5ae367649b", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 47, "deletions": 110, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/194c27bcd16ad92e2edf11ff7446cb679a91c1d3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/194c27bcd16ad92e2edf11ff7446cb679a91c1d3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=194c27bcd16ad92e2edf11ff7446cb679a91c1d3", "patch": "@@ -12,6 +12,7 @@ use core::prelude::*;\n \n use lib::llvm::{llvm, ValueRef, TypeRef, Bool, True, False};\n use middle::const_eval;\n+use middle::trans::adt;\n use middle::trans::base;\n use middle::trans::base::get_insn_ctxt;\n use middle::trans::common::*;\n@@ -103,20 +104,6 @@ pub fn const_deref(cx: @CrateContext, v: ValueRef) -> ValueRef {\n     }\n }\n \n-pub fn const_get_elt(cx: @CrateContext, v: ValueRef, us: &[c_uint])\n-                  -> ValueRef {\n-    unsafe {\n-        let r = do vec::as_imm_buf(us) |p, len| {\n-            llvm::LLVMConstExtractValue(v, p, len as c_uint)\n-        };\n-\n-        debug!(\"const_get_elt(v=%s, us=%?, r=%s)\",\n-               val_str(cx.tn, v), us, val_str(cx.tn, r));\n-\n-        return r;\n-    }\n-}\n-\n pub fn const_autoderef(cx: @CrateContext, ty: ty::t, v: ValueRef)\n     -> (ty::t, ValueRef) {\n     let mut t1 = ty;\n@@ -253,16 +240,12 @@ fn const_expr_unchecked(cx: @CrateContext, e: @ast::expr) -> ValueRef {\n           }\n           ast::expr_field(base, field, _) => {\n               let bt = ty::expr_ty(cx.tcx, base);\n+              let brepr = adt::represent_type(cx, bt);\n               let bv = const_expr(cx, base);\n               let (bt, bv) = const_autoderef(cx, bt, bv);\n-              do expr::with_field_tys(cx.tcx, bt, None) |_, field_tys| {\n+              do expr::with_field_tys(cx.tcx, bt, None) |discr, field_tys| {\n                   let ix = ty::field_idx_strict(cx.tcx, field, field_tys);\n-\n-                  // Note: ideally, we'd use `struct_field()` here instead\n-                  // of hardcoding [0, ix], but we can't because it yields\n-                  // the wrong type and also inserts an extra 0 that is\n-                  // not needed in the constant variety:\n-                  const_get_elt(cx, bv, [0, ix as c_uint])\n+                  adt::const_get_field(cx, brepr, bv, discr, ix)\n               }\n           }\n \n@@ -342,24 +325,8 @@ fn const_expr_unchecked(cx: @CrateContext, e: @ast::expr) -> ValueRef {\n               }\n               (expr::cast_enum, expr::cast_integral) |\n               (expr::cast_enum, expr::cast_float)  => {\n-                let def = ty::resolve_expr(cx.tcx, base);\n-                let (enum_did, variant_did) = match def {\n-                    ast::def_variant(enum_did, variant_did) => {\n-                        (enum_did, variant_did)\n-                    }\n-                    _ => cx.sess.bug(~\"enum cast source is not enum\")\n-                };\n-                // Note that we know this is a C-like (nullary) enum\n-                // variant or we wouldn't have gotten here\n-                let variants = ty::enum_variants(cx.tcx, enum_did);\n-                let iv = if variants.len() == 1 {\n-                    // Univariants don't have a discriminant field,\n-                    // because there's only one value it could have:\n-                    C_integral(T_i64(),\n-                               variants[0].disr_val as u64, True)\n-                } else {\n-                    base::get_discrim_val(cx, e.span, enum_did, variant_did)\n-                };\n+                let repr = adt::represent_type(cx, basety);\n+                let iv = C_int(cx, adt::const_get_discrim(cx, repr, v));\n                 let ety_cast = expr::cast_type_kind(ety);\n                 match ety_cast {\n                     expr::cast_integral => {\n@@ -387,28 +354,32 @@ fn const_expr_unchecked(cx: @CrateContext, e: @ast::expr) -> ValueRef {\n             gv\n           }\n           ast::expr_tup(es) => {\n-            C_struct(es.map(|e| const_expr(cx, *e)))\n+              let ety = ty::expr_ty(cx.tcx, e);\n+              let repr = adt::represent_type(cx, ety);\n+              adt::trans_const(cx, repr, 0, es.map(|e| const_expr(cx, *e)))\n           }\n           ast::expr_rec(ref fs, None) => {\n-              C_struct([C_struct(\n-                  (*fs).map(|f| const_expr(cx, f.node.expr)))])\n+              let ety = ty::expr_ty(cx.tcx, e);\n+              let repr = adt::represent_type(cx, ety);\n+              adt::trans_const(cx, repr, 0,\n+                               fs.map(|f| const_expr(cx, f.node.expr)))\n           }\n-          ast::expr_struct(_, ref fs, _) => {\n+          ast::expr_struct(_, ref fs, None) => {\n               let ety = ty::expr_ty(cx.tcx, e);\n-              let cs = do expr::with_field_tys(cx.tcx,\n-                                               ety,\n-                                               None) |_hd, field_tys| {\n-                  field_tys.map(|field_ty| {\n+              let repr = adt::represent_type(cx, ety);\n+              do expr::with_field_tys(cx.tcx, ety, Some(e.id))\n+                  |discr, field_tys| {\n+                  let cs = field_tys.map(|field_ty| {\n                       match fs.find(|f| field_ty.ident == f.node.ident) {\n                           Some(ref f) => const_expr(cx, (*f).node.expr),\n                           None => {\n                               cx.tcx.sess.span_bug(\n                                   e.span, ~\"missing struct field\");\n                           }\n                       }\n-                  })\n-              };\n-              C_struct([C_struct(cs)])\n+                  });\n+                  adt::trans_const(cx, repr, discr, cs)\n+              }\n           }\n           ast::expr_vec(es, ast::m_imm) => {\n             let (v, _, _) = const_vec(cx, e, es);\n@@ -466,78 +437,44 @@ fn const_expr_unchecked(cx: @CrateContext, e: @ast::expr) -> ValueRef {\n                     get_const_val(cx, def_id)\n                 }\n                 Some(ast::def_variant(enum_did, variant_did)) => {\n-                    // Note that we know this is a C-like (nullary) enum\n-                    // variant or we wouldn't have gotten here -- the constant\n-                    // checker forbids paths that don't map to C-like enum\n-                    // variants.\n-                    if ty::enum_is_univariant(cx.tcx, enum_did) {\n-                        // Univariants have no discriminant field.\n-                        C_struct(~[])\n-                    } else {\n-                    let lldiscrim = base::get_discrim_val(cx, e.span,\n-                                                          enum_did,\n-                                                          variant_did);\n-                    // However, we still have to pad it out to the\n-                    // size of the full enum; see the expr_call case,\n-                    // below.\n                     let ety = ty::expr_ty(cx.tcx, e);\n-                    let size = machine::static_size_of_enum(cx, ety);\n-                    let padding = C_null(T_array(T_i8(), size));\n-                    C_struct(~[lldiscrim, padding])\n-                }\n+                    let repr = adt::represent_type(cx, ety);\n+                    let vinfo = ty::enum_variant_with_id(cx.tcx,\n+                                                         enum_did,\n+                                                         variant_did);\n+                    adt::trans_const(cx, repr, vinfo.disr_val, [])\n                 }\n                 Some(ast::def_struct(_)) => {\n                     let ety = ty::expr_ty(cx.tcx, e);\n                     let llty = type_of::type_of(cx, ety);\n                     C_null(llty)\n                 }\n                 _ => {\n-                    cx.sess.span_bug(e.span,\n-                                     ~\"expected a const, fn, or variant def\")\n+                    cx.sess.span_bug(e.span, ~\"expected a const, fn, \\\n+                                               struct, or variant def\")\n                 }\n             }\n           }\n           ast::expr_call(callee, args, _) => {\n-            match cx.tcx.def_map.find(&callee.id) {\n-                Some(ast::def_struct(def_id)) => {\n-                    let llstructbody =\n-                        C_struct(args.map(|a| const_expr(cx, *a)));\n-                    if ty::ty_dtor(cx.tcx, def_id).is_present() {\n-                        C_struct(~[ llstructbody, C_u8(0) ])\n-                    } else {\n-                        C_struct(~[ llstructbody ])\n-                    }\n-                }\n-            Some(ast::def_variant(tid, vid)) => {\n-                let ety = ty::expr_ty(cx.tcx, e);\n-                let univar = ty::enum_is_univariant(cx.tcx, tid);\n-                let size = machine::static_size_of_enum(cx, ety);\n-\n-                let discrim = base::get_discrim_val(cx, e.span, tid, vid);\n-                let c_args = C_struct(args.map(|a| const_expr(cx, *a)));\n-\n-                // FIXME (#1645): enum body alignment is generaly wrong.\n-                if !univar {\n-                    // Pad out the data to the size of its type_of;\n-                    // this is necessary if the enum is contained\n-                    // within an aggregate (tuple, struct, vector) so\n-                    // that the next element is at the right offset.\n-                    let actual_size =\n-                        machine::llsize_of_real(cx, llvm::LLVMTypeOf(c_args));\n-                    let padding =\n-                        C_null(T_array(T_i8(), size - actual_size));\n-                    // A packed_struct has an alignment of 1; thus,\n-                    // wrapping one around c_args will misalign it the\n-                    // same way we normally misalign enum bodies\n-                    // without affecting its internal alignment or\n-                    // changing the alignment of the enum.\n-                    C_struct(~[discrim, C_packed_struct(~[c_args]), padding])\n-                } else {\n-                    C_struct(~[c_args])\n-                }\n-            }\n-                _ => cx.sess.span_bug(e.span, ~\"expected a struct def\")\n-            }\n+              match cx.tcx.def_map.find(&callee.id) {\n+                  Some(ast::def_struct(_)) => {\n+                      let ety = ty::expr_ty(cx.tcx, e);\n+                      let repr = adt::represent_type(cx, ety);\n+                      adt::trans_const(cx, repr, 0,\n+                                       args.map(|a| const_expr(cx, *a)))\n+                  }\n+                  Some(ast::def_variant(enum_did, variant_did)) => {\n+                      let ety = ty::expr_ty(cx.tcx, e);\n+                      let repr = adt::represent_type(cx, ety);\n+                      let vinfo = ty::enum_variant_with_id(cx.tcx,\n+                                                           enum_did,\n+                                                           variant_did);\n+                      adt::trans_const(cx, repr, vinfo.disr_val,\n+                                       args.map(|a| const_expr(cx, *a)))\n+                  }\n+                  _ => cx.sess.span_bug(e.span, ~\"expected a struct or \\\n+                                                  variant def\")\n+              }\n           }\n           ast::expr_paren(e) => { return const_expr(cx, e); }\n           _ => cx.sess.span_bug(e.span,"}, {"sha": "e6089914564179de1048f79b9d8282773e61524a", "filename": "src/librustc/middle/trans/datum.rs", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/194c27bcd16ad92e2edf11ff7446cb679a91c1d3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/194c27bcd16ad92e2edf11ff7446cb679a91c1d3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs?ref=194c27bcd16ad92e2edf11ff7446cb679a91c1d3", "patch": "@@ -90,6 +90,7 @@ use core::prelude::*;\n use lib;\n use lib::llvm::ValueRef;\n use middle::borrowck::{RootInfo, root_map_key};\n+use middle::trans::adt;\n use middle::trans::base::*;\n use middle::trans::build::*;\n use middle::trans::callee;\n@@ -511,14 +512,13 @@ pub impl Datum {\n         }\n     }\n \n-    fn GEPi(&self, bcx: block,\n-            ixs: &[uint],\n-            ty: ty::t,\n-            source: DatumCleanup)\n-         -> Datum {\n+    fn get_element(&self, bcx: block,\n+                   ty: ty::t,\n+                   source: DatumCleanup,\n+                   gep: fn(ValueRef) -> ValueRef) -> Datum {\n         let base_val = self.to_ref_llval(bcx);\n         Datum {\n-            val: GEPi(bcx, base_val, ixs),\n+            val: gep(base_val),\n             mode: ByRef,\n             ty: ty,\n             source: source\n@@ -678,15 +678,17 @@ pub impl Datum {\n                     return (None, bcx);\n                 }\n \n+                let repr = adt::represent_type(ccx, self.ty);\n+                assert adt::is_newtypeish(repr);\n                 let ty = ty::subst(ccx.tcx, substs, variants[0].args[0]);\n                 return match self.mode {\n                     ByRef => {\n                         // Recast lv.val as a pointer to the newtype\n                         // rather than a ptr to the enum type.\n-                        let llty = T_ptr(type_of::type_of(ccx, ty));\n                         (\n                             Some(Datum {\n-                                val: PointerCast(bcx, self.val, llty),\n+                                val: adt::trans_field_ptr(bcx, repr, self.val,\n+                                                    0, 0),\n                                 ty: ty,\n                                 mode: ByRef,\n                                 source: ZeroMem\n@@ -716,6 +718,8 @@ pub impl Datum {\n                     return (None, bcx);\n                 }\n \n+                let repr = adt::represent_type(ccx, self.ty);\n+                assert adt::is_newtypeish(repr);\n                 let ty = fields[0].mt.ty;\n                 return match self.mode {\n                     ByRef => {\n@@ -725,7 +729,8 @@ pub impl Datum {\n                         // destructors.\n                         (\n                             Some(Datum {\n-                                val: GEPi(bcx, self.val, [0, 0, 0]),\n+                                val: adt::trans_field_ptr(bcx, repr, self.val,\n+                                                    0, 0),\n                                 ty: ty,\n                                 mode: ByRef,\n                                 source: ZeroMem"}, {"sha": "1dae9fccc62118829c302e0dc03a47f24a826f18", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 113, "deletions": 134, "changes": 247, "blob_url": "https://github.com/rust-lang/rust/blob/194c27bcd16ad92e2edf11ff7446cb679a91c1d3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/194c27bcd16ad92e2edf11ff7446cb679a91c1d3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=194c27bcd16ad92e2edf11ff7446cb679a91c1d3", "patch": "@@ -126,6 +126,7 @@ use lib;\n use lib::llvm::{ValueRef, TypeRef, llvm, True};\n use middle::borrowck::root_map_key;\n use middle::trans::_match;\n+use middle::trans::adt;\n use middle::trans::base;\n use middle::trans::base::*;\n use middle::trans::build::*;\n@@ -602,7 +603,9 @@ fn trans_rvalue_dps_unadjusted(bcx: block, expr: @ast::expr,\n             return trans_rec_or_struct(bcx, (*fields), base, expr.id, dest);\n         }\n         ast::expr_tup(ref args) => {\n-            return trans_tup(bcx, *args, dest);\n+            let repr = adt::represent_type(bcx.ccx(), expr_ty(bcx, expr));\n+            return trans_adt(bcx, repr, 0, args.mapi(|i, arg| (i, *arg)),\n+                             None, dest);\n         }\n         ast::expr_lit(@codemap::spanned {node: ast::lit_str(s), _}) => {\n             return tvec::trans_lit_str(bcx, expr, s, dest);\n@@ -719,14 +722,12 @@ fn trans_def_dps_unadjusted(bcx: block, ref_expr: @ast::expr,\n                 let fn_data = callee::trans_fn_ref(bcx, vid, ref_expr.id);\n                 Store(bcx, fn_data.llfn, lldest);\n                 return bcx;\n-            } else if !ty::enum_is_univariant(ccx.tcx, tid) {\n-                // Nullary variant.\n-                let lldiscrimptr = GEPi(bcx, lldest, [0u, 0u]);\n-                let lldiscrim = C_int(bcx.ccx(), variant_info.disr_val);\n-                Store(bcx, lldiscrim, lldiscrimptr);\n-                return bcx;\n             } else {\n-                // Nullary univariant.\n+                // Nullary variant.\n+                let ty = expr_ty(bcx, ref_expr);\n+                let repr = adt::represent_type(ccx, ty);\n+                adt::trans_start_init(bcx, repr, lldest,\n+                                      variant_info.disr_val);\n                 return bcx;\n             }\n         }\n@@ -883,13 +884,15 @@ fn trans_lvalue_unadjusted(bcx: block, expr: @ast::expr) -> DatumBlock {\n         let _icx = bcx.insn_ctxt(\"trans_rec_field\");\n \n         let base_datum = unpack_datum!(bcx, trans_to_datum(bcx, base));\n-        do with_field_tys(bcx.tcx(), base_datum.ty, None) |_dtor, field_tys| {\n+        let repr = adt::represent_type(bcx.ccx(), base_datum.ty);\n+        do with_field_tys(bcx.tcx(), base_datum.ty, None) |discr, field_tys| {\n             let ix = ty::field_idx_strict(bcx.tcx(), field, field_tys);\n             DatumBlock {\n-                datum: base_datum.GEPi(bcx,\n-                                       [0u, 0u, ix],\n-                                       field_tys[ix].mt.ty,\n-                                       ZeroMem),\n+                datum: do base_datum.get_element(bcx,\n+                                                 field_tys[ix].mt.ty,\n+                                                 ZeroMem) |srcval| {\n+                    adt::trans_field_ptr(bcx, repr, srcval, discr, ix)\n+                },\n                 bcx: bcx\n             }\n         }\n@@ -1096,15 +1099,14 @@ pub fn trans_local_var(bcx: block, def: ast::def) -> Datum {\n pub fn with_field_tys<R>(tcx: ty::ctxt,\n                          ty: ty::t,\n                          node_id_opt: Option<ast::node_id>,\n-                         op: fn(bool, (&[ty::field])) -> R) -> R {\n+                         op: fn(int, (&[ty::field])) -> R) -> R {\n     match ty::get(ty).sty {\n         ty::ty_rec(ref fields) => {\n-            op(false, *fields)\n+            op(0, *fields)\n         }\n \n         ty::ty_struct(did, ref substs) => {\n-            let has_dtor = ty::ty_dtor(tcx, did).is_present();\n-            op(has_dtor, struct_mutable_fields(tcx, did, substs))\n+            op(0, struct_mutable_fields(tcx, did, substs))\n         }\n \n         ty::ty_enum(_, ref substs) => {\n@@ -1118,8 +1120,10 @@ pub fn with_field_tys<R>(tcx: ty::ctxt,\n                 }\n                 Some(node_id) => {\n                     match tcx.def_map.get(&node_id) {\n-                        ast::def_variant(_, variant_id) => {\n-                            op(false, struct_mutable_fields(\n+                        ast::def_variant(enum_id, variant_id) => {\n+                            let variant_info = ty::enum_variant_with_id(\n+                                tcx, enum_id, variant_id);\n+                            op(variant_info.disr_val, struct_mutable_fields(\n                                 tcx, variant_id, substs))\n                         }\n                         _ => {\n@@ -1148,133 +1152,122 @@ fn trans_rec_or_struct(bcx: block,\n     let _icx = bcx.insn_ctxt(\"trans_rec\");\n     let mut bcx = bcx;\n \n-    // Handle the case where the result is ignored.\n-    let addr;\n-    match dest {\n-        SaveIn(p) => {\n-            addr = p;\n-        }\n-        Ignore => {\n-            // just evaluate the values for each field and drop them\n-            // on the floor\n-            for vec::each(fields) |fld| {\n-                bcx = trans_into(bcx, fld.node.expr, Ignore);\n-            }\n-            return bcx;\n-        }\n-    }\n-\n-    // If this is a struct-like variant, write in the discriminant if\n-    // necessary, position the address at the right location, and cast the\n-    // address.\n     let ty = node_id_type(bcx, id);\n     let tcx = bcx.tcx();\n-    let addr = match ty::get(ty).sty {\n-        ty::ty_enum(_, ref substs) => {\n-            match tcx.def_map.get(&id) {\n-                ast::def_variant(enum_id, variant_id) => {\n-                    let variant_info = ty::enum_variant_with_id(\n-                        tcx, enum_id, variant_id);\n-                    let addr = if ty::enum_is_univariant(tcx, enum_id) {\n-                        addr\n-                    } else {\n-                        Store(bcx,\n-                              C_int(bcx.ccx(), variant_info.disr_val),\n-                              GEPi(bcx, addr, [0, 0]));\n-                        GEPi(bcx, addr, [0, 1])\n-                    };\n-                    let fields = ty::struct_mutable_fields(\n-                        tcx, variant_id, substs);\n-                    let field_lltys = do fields.map |field| {\n-                        type_of::type_of(bcx.ccx(),\n-                                ty::subst_tps(\n-                                    tcx, substs.tps, None, field.mt.ty))\n-                    };\n-                    PointerCast(bcx, addr,\n-                                T_ptr(T_struct(~[T_struct(field_lltys)])))\n+    do with_field_tys(tcx, ty, Some(id)) |discr, field_tys| {\n+        let mut need_base = vec::from_elem(field_tys.len(), true);\n+\n+        let numbered_fields = do fields.map |field| {\n+            let opt_pos = vec::position(field_tys, |field_ty|\n+                                        field_ty.ident == field.node.ident);\n+            match opt_pos {\n+                Some(i) => {\n+                    need_base[i] = false;\n+                    (i, field.node.expr)\n                 }\n-                _ => {\n-                    tcx.sess.bug(~\"resolve didn't write the right def in for \\\n-                                   this struct-like variant\")\n+                None => {\n+                    tcx.sess.span_bug(field.span,\n+                                      ~\"Couldn't find field in struct type\")\n                 }\n             }\n-        }\n-        _ => addr\n-    };\n-\n-    do with_field_tys(tcx, ty, Some(id)) |has_dtor, field_tys| {\n-        // evaluate each of the fields and store them into their\n-        // correct locations\n-        let mut temp_cleanups = ~[];\n-        for fields.each |field| {\n-            let ix = ty::field_idx_strict(tcx, field.node.ident, field_tys);\n-            let dest = GEPi(bcx, addr, struct_field(ix));\n-            bcx = trans_into(bcx, field.node.expr, SaveIn(dest));\n-            add_clean_temp_mem(bcx, dest, field_tys[ix].mt.ty);\n-            temp_cleanups.push(dest);\n-        }\n-\n-        // copy over any remaining fields from the base (for\n-        // functional record update)\n-        for base.each |base_expr| {\n-            let base_datum = unpack_datum!(\n-                bcx, trans_to_datum(bcx, *base_expr));\n-\n-            // Copy/move over inherited fields\n-            for field_tys.eachi |i, field_ty| {\n-                if !fields.any(|f| f.node.ident == field_ty.ident) {\n-                    let dest = GEPi(bcx, addr, struct_field(i));\n-                    let base_field =\n-                        base_datum.GEPi(bcx,\n-                                        struct_field(i),\n-                                        field_ty.mt.ty,\n-                                        ZeroMem);\n-                    bcx = base_field.store_to(bcx, base_expr.id, INIT, dest);\n+        };\n+        let optbase = match base {\n+            Some(base_expr) => {\n+                let mut leftovers = ~[];\n+                for need_base.eachi |i, b| {\n+                    if *b {\n+                        leftovers.push((i, field_tys[i].mt.ty))\n+                    }\n                 }\n+                Some(StructBaseInfo {expr: base_expr,\n+                                     fields: leftovers })\n             }\n-        }\n-\n-        // Add the drop flag if necessary.\n-        if has_dtor {\n-            let dest = GEPi(bcx, addr, struct_dtor());\n-            Store(bcx, C_u8(1), dest);\n-        }\n+            None => {\n+                if need_base.any(|b| *b) {\n+                    // XXX should be span bug\n+                    tcx.sess.bug(~\"missing fields and no base expr\")\n+                }\n+                None\n+            }\n+        };\n \n-        // Now revoke the cleanups as we pass responsibility for the data\n-        // structure on to the caller\n-        for temp_cleanups.each |cleanup| {\n-            revoke_clean(bcx, *cleanup);\n-        }\n-        bcx\n+        let repr = adt::represent_type(bcx.ccx(), ty);\n+        trans_adt(bcx, repr, discr, numbered_fields, optbase, dest)\n     }\n }\n \n-fn trans_tup(bcx: block, elts: &[@ast::expr], dest: Dest) -> block {\n-    let _icx = bcx.insn_ctxt(\"trans_tup\");\n+/**\n+ * Information that `trans_adt` needs in order to fill in the fields\n+ * of a struct copied from a base struct (e.g., from an expression\n+ * like `Foo { a: b, ..base }`.\n+ *\n+ * Note that `fields` may be empty; the base expression must always be\n+ * evaluated for side-effects.\n+ */\n+struct StructBaseInfo {\n+    /// The base expression; will be evaluated after all explicit fields.\n+    expr: @ast::expr,\n+    /// The indices of fields to copy paired with their types.\n+    fields: ~[(uint, ty::t)]\n+}\n+\n+/**\n+ * Constructs an ADT instance:\n+ *\n+ * - `fields` should be a list of field indices paired with the\n+ * expression to store into that field.  The initializers will be\n+ * evaluated in the order specified by `fields`.\n+ *\n+ * - `optbase` contains information on the base struct (if any) from\n+ * which remaining fields are copied; see comments on `StructBaseInfo`.\n+ */\n+fn trans_adt(bcx: block, repr: &adt::Repr, discr: int,\n+             fields: &[(uint, @ast::expr)],\n+             optbase: Option<StructBaseInfo>,\n+             dest: Dest) -> block {\n+    let _icx = bcx.insn_ctxt(\"trans_adt\");\n     let mut bcx = bcx;\n     let addr = match dest {\n         Ignore => {\n-            for vec::each(elts) |ex| {\n-                bcx = trans_into(bcx, *ex, Ignore);\n+            for fields.each |&(_i, e)| {\n+                bcx = trans_into(bcx, e, Ignore);\n+            }\n+            for optbase.each |sbi| {\n+                bcx = trans_into(bcx, sbi.expr, Ignore);\n             }\n             return bcx;\n         }\n-        SaveIn(pos) => pos,\n+        SaveIn(pos) => pos\n     };\n     let mut temp_cleanups = ~[];\n-    for vec::eachi(elts) |i, e| {\n-        let dest = GEPi(bcx, addr, [0u, i]);\n-        let e_ty = expr_ty(bcx, *e);\n-        bcx = trans_into(bcx, *e, SaveIn(dest));\n+    adt::trans_start_init(bcx, repr, addr, discr);\n+    for fields.each |&(i, e)| {\n+        let dest = adt::trans_field_ptr(bcx, repr, addr, discr, i);\n+        let e_ty = expr_ty(bcx, e);\n+        bcx = trans_into(bcx, e, SaveIn(dest));\n         add_clean_temp_mem(bcx, dest, e_ty);\n         temp_cleanups.push(dest);\n     }\n+    for optbase.each |base| {\n+        // XXX is it sound to use the destination's repr on the base?\n+        // XXX would it ever be reasonable to be here with discr != 0?\n+        let base_datum = unpack_datum!(bcx, trans_to_datum(bcx, base.expr));\n+        for base.fields.each |&(i, t)| {\n+            let datum = do base_datum.get_element(bcx, t, ZeroMem) |srcval| {\n+                adt::trans_field_ptr(bcx, repr, srcval, discr, i)\n+            };\n+            let dest = adt::trans_field_ptr(bcx, repr, addr, discr, i);\n+            bcx = datum.store_to(bcx, base.expr.id, INIT, dest);\n+        }\n+    }\n+\n     for vec::each(temp_cleanups) |cleanup| {\n         revoke_clean(bcx, *cleanup);\n     }\n     return bcx;\n }\n \n+\n fn trans_immediate_lit(bcx: block, expr: @ast::expr,\n                        lit: ast::lit) -> DatumBlock {\n     // must not be a string constant, that is a RvalueDpsExpr\n@@ -1671,22 +1664,8 @@ fn trans_imm_cast(bcx: block, expr: @ast::expr,\n             (cast_enum, cast_integral) |\n             (cast_enum, cast_float) => {\n                 let bcx = bcx;\n-                let in_tid = match ty::get(t_in).sty {\n-                    ty::ty_enum(did, _) => did,\n-                    _ => ccx.sess.bug(~\"enum cast source is not enum\")\n-                };\n-                let variants = ty::enum_variants(ccx.tcx, in_tid);\n-                let lldiscrim_a = if variants.len() == 1 {\n-                    // Univariants don't have a discriminant field,\n-                    // because there's only one value it could have:\n-                    C_integral(T_enum_discrim(ccx),\n-                               variants[0].disr_val as u64, True)\n-                } else {\n-                    let llenumty = T_opaque_enum_ptr(ccx);\n-                    let av_enum = PointerCast(bcx, llexpr, llenumty);\n-                    let lldiscrim_a_ptr = GEPi(bcx, av_enum, [0u, 0u]);\n-                    Load(bcx, lldiscrim_a_ptr)\n-                };\n+                let repr = adt::represent_type(ccx, t_in);\n+                let lldiscrim_a = adt::trans_get_discr(bcx, repr, llexpr);\n                 match k_out {\n                     cast_integral => int_cast(bcx, ll_t_out,\n                                               val_ty(lldiscrim_a),"}, {"sha": "b692ae67950ec98c6e75767057c36df202acd3af", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/194c27bcd16ad92e2edf11ff7446cb679a91c1d3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/194c27bcd16ad92e2edf11ff7446cb679a91c1d3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=194c27bcd16ad92e2edf11ff7446cb679a91c1d3", "patch": "@@ -19,6 +19,7 @@ use back::link::*;\n use driver::session;\n use lib;\n use lib::llvm::{llvm, ValueRef, TypeRef, True};\n+use middle::trans::adt;\n use middle::trans::base::*;\n use middle::trans::callee;\n use middle::trans::closure;\n@@ -447,10 +448,10 @@ pub fn make_free_glue(bcx: block, v: ValueRef, t: ty::t) {\n         match ty::ty_dtor(bcx.tcx(), did) {\n             ty::NoDtor => bcx,\n             ty::LegacyDtor(ref dt_id) => {\n-                trans_struct_drop(bcx, v, *dt_id, did, substs, false)\n+                trans_struct_drop(bcx, t, v, *dt_id, did, substs, false)\n             }\n             ty::TraitDtor(ref dt_id) => {\n-                trans_struct_drop(bcx, v, *dt_id, did, substs, true)\n+                trans_struct_drop(bcx, t, v, *dt_id, did, substs, true)\n             }\n         }\n       }\n@@ -460,13 +461,15 @@ pub fn make_free_glue(bcx: block, v: ValueRef, t: ty::t) {\n }\n \n pub fn trans_struct_drop(bcx: block,\n+                         t: ty::t,\n                          v0: ValueRef,\n                          dtor_did: ast::def_id,\n                          class_did: ast::def_id,\n                          substs: &ty::substs,\n                          take_ref: bool)\n                       -> block {\n-    let drop_flag = GEPi(bcx, v0, struct_dtor());\n+    let repr = adt::represent_type(bcx.ccx(), t);\n+    let drop_flag = adt::trans_drop_flag_ptr(bcx, repr, v0);\n     do with_cond(bcx, IsNotNull(bcx, Load(bcx, drop_flag))) |cx| {\n         let mut bcx = cx;\n \n@@ -504,7 +507,7 @@ pub fn trans_struct_drop(bcx: block,\n             ty::struct_mutable_fields(bcx.tcx(), class_did,\n                                               substs);\n         for vec::eachi(field_tys) |i, fld| {\n-            let llfld_a = GEPi(bcx, v0, struct_field(i));\n+            let llfld_a = adt::trans_field_ptr(bcx, repr, v0, 0, i);\n             bcx = drop_ty(bcx, llfld_a, fld.mt.ty);\n         }\n \n@@ -534,10 +537,10 @@ pub fn make_drop_glue(bcx: block, v0: ValueRef, t: ty::t) {\n         let tcx = bcx.tcx();\n         match ty::ty_dtor(tcx, did) {\n           ty::TraitDtor(dtor) => {\n-            trans_struct_drop(bcx, v0, dtor, did, substs, true)\n+            trans_struct_drop(bcx, t, v0, dtor, did, substs, true)\n           }\n           ty::LegacyDtor(dtor) => {\n-            trans_struct_drop(bcx, v0, dtor, did, substs, false)\n+            trans_struct_drop(bcx, t, v0, dtor, did, substs, false)\n           }\n           ty::NoDtor => {\n             // No dtor? Just the default case"}, {"sha": "ffc5d132c9fd8d9e024914b7c2753fbfccf74576", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/194c27bcd16ad92e2edf11ff7446cb679a91c1d3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/194c27bcd16ad92e2edf11ff7446cb679a91c1d3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=194c27bcd16ad92e2edf11ff7446cb679a91c1d3", "patch": "@@ -196,8 +196,7 @@ pub fn monomorphic_fn(ccx: @CrateContext,\n         match (*v).node.kind {\n             ast::tuple_variant_kind(ref args) => {\n                 trans_enum_variant(ccx, enum_item.id, *v, /*bad*/copy *args,\n-                                   this_tv.disr_val, tvs.len() == 1u,\n-                                   psubsts, d);\n+                                   this_tv.disr_val, psubsts, d);\n             }\n             ast::struct_variant_kind(_) =>\n                 ccx.tcx.sess.bug(~\"can't monomorphize struct variants\"),"}, {"sha": "8dac607bd5287f6c09b6122457d98a7b77e7faee", "filename": "src/librustc/middle/trans/type_of.rs", "status": "modified", "additions": 11, "deletions": 90, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/194c27bcd16ad92e2edf11ff7446cb679a91c1d3/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/194c27bcd16ad92e2edf11ff7446cb679a91c1d3/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=194c27bcd16ad92e2edf11ff7446cb679a91c1d3", "patch": "@@ -11,15 +11,14 @@\n \n use lib::llvm::llvm;\n use lib::llvm::{TypeRef};\n+use middle::trans::adt;\n use middle::trans::base;\n use middle::trans::common::*;\n use middle::trans::common;\n-use middle::trans::machine;\n use middle::ty;\n use util::ppaux;\n \n use core::option::None;\n-use core::vec;\n use syntax::ast;\n \n pub fn type_of_explicit_arg(ccx: @CrateContext, arg: ty::arg) -> TypeRef {\n@@ -143,32 +142,12 @@ pub fn sizing_type_of(cx: @CrateContext, t: ty::t) -> TypeRef {\n \n         ty::ty_unboxed_vec(mt) => T_vec(cx, sizing_type_of(cx, mt.ty)),\n \n-        ty::ty_tup(ref elems) => {\n-            T_struct(elems.map(|&t| sizing_type_of(cx, t)))\n+        ty::ty_tup(*) | ty::ty_rec(*) | ty::ty_struct(*)\n+        | ty::ty_enum(*) => {\n+            let repr = adt::represent_type(cx, t);\n+            T_struct(adt::sizing_fields_of(cx, repr))\n         }\n \n-        ty::ty_rec(ref fields) => {\n-            T_struct(fields.map(|f| sizing_type_of(cx, f.mt.ty)))\n-        }\n-\n-        ty::ty_struct(def_id, ref substs) => {\n-            let fields = ty::lookup_struct_fields(cx.tcx, def_id);\n-            let lltype = T_struct(fields.map(|field| {\n-                let field_type = ty::lookup_field_type(cx.tcx,\n-                                                       def_id,\n-                                                       field.id,\n-                                                       substs);\n-                sizing_type_of(cx, field_type)\n-            }));\n-            if ty::ty_dtor(cx.tcx, def_id).is_present() {\n-                T_struct(~[lltype, T_i8()])\n-            } else {\n-                lltype\n-            }\n-        }\n-\n-        ty::ty_enum(def_id, _) => T_struct(enum_body_types(cx, def_id, t)),\n-\n         ty::ty_self | ty::ty_infer(*) | ty::ty_param(*) | ty::ty_err(*) => {\n             cx.tcx.sess.bug(\n                 fmt!(\"fictitious type %? in sizing_type_of()\",\n@@ -257,28 +236,13 @@ pub fn type_of(cx: @CrateContext, t: ty::t) -> TypeRef {\n         T_array(type_of(cx, mt.ty), n)\n       }\n \n-      ty::ty_rec(fields) => {\n-        let mut tys: ~[TypeRef] = ~[];\n-        for vec::each(fields) |f| {\n-            let mt_ty = f.mt.ty;\n-            tys.push(type_of(cx, mt_ty));\n-        }\n-\n-        // n.b.: introduce an extra layer of indirection to match\n-        // structs\n-        T_struct(~[T_struct(tys)])\n-      }\n-\n       ty::ty_bare_fn(_) => T_ptr(type_of_fn_from_ty(cx, t)),\n       ty::ty_closure(_) => T_fn_pair(cx, type_of_fn_from_ty(cx, t)),\n       ty::ty_trait(_, _, vstore) => T_opaque_trait(cx, vstore),\n       ty::ty_type => T_ptr(cx.tydesc_type),\n-      ty::ty_tup(elts) => {\n-        let mut tys = ~[];\n-        for vec::each(elts) |elt| {\n-            tys.push(type_of(cx, *elt));\n-        }\n-        T_struct(tys)\n+      ty::ty_tup(*) | ty::ty_rec(*) => {\n+          let repr = adt::represent_type(cx, t);\n+          T_struct(adt::fields_of(cx, repr))\n       }\n       ty::ty_opaque_closure_ptr(_) => T_opaque_box_ptr(cx),\n       ty::ty_struct(did, ref substs) => {\n@@ -301,59 +265,16 @@ pub fn type_of(cx: @CrateContext, t: ty::t) -> TypeRef {\n \n     // If this was an enum or struct, fill in the type now.\n     match ty::get(t).sty {\n-      ty::ty_enum(did, _) => {\n-        fill_type_of_enum(cx, did, t, llty);\n-      }\n-      ty::ty_struct(did, ref substs) => {\n-        // Only instance vars are record fields at runtime.\n-        let fields = ty::lookup_struct_fields(cx.tcx, did);\n-        let mut tys = do vec::map(fields) |f| {\n-            let t = ty::lookup_field_type(cx.tcx, did, f.id, substs);\n-            type_of(cx, t)\n-        };\n-\n-        // include a byte flag if there is a dtor so that we know when we've\n-        // been dropped\n-        if ty::ty_dtor(cx.tcx, did).is_present() {\n-            common::set_struct_body(llty, ~[T_struct(tys), T_i8()]);\n-        } else {\n-            common::set_struct_body(llty, ~[T_struct(tys)]);\n-        }\n+      ty::ty_enum(*) | ty::ty_struct(*) => {\n+          let repr = adt::represent_type(cx, t);\n+          common::set_struct_body(llty, adt::fields_of(cx, repr));\n       }\n       _ => ()\n     }\n \n     return llty;\n }\n \n-pub fn enum_body_types(cx: @CrateContext, did: ast::def_id, t: ty::t)\n-                    -> ~[TypeRef] {\n-    let univar = ty::enum_is_univariant(cx.tcx, did);\n-    if !univar {\n-        let size = machine::static_size_of_enum(cx, t);\n-        ~[T_enum_discrim(cx), T_array(T_i8(), size)]\n-    }\n-    else {\n-        // Use the actual fields, so we get the alignment right.\n-        match ty::get(t).sty {\n-            ty::ty_enum(_, ref substs) => {\n-                do ty::enum_variants(cx.tcx, did)[0].args.map |&field_ty| {\n-                    sizing_type_of(cx, ty::subst(cx.tcx, substs, field_ty))\n-                }\n-            }\n-            _ => cx.sess.bug(~\"enum is not an enum\")\n-        }\n-    }\n-}\n-\n-pub fn fill_type_of_enum(cx: @CrateContext,\n-                         did: ast::def_id,\n-                         t: ty::t,\n-                         llty: TypeRef) {\n-    debug!(\"type_of_enum %?: %?\", t, ty::get(t));\n-    common::set_struct_body(llty, enum_body_types(cx, did, t));\n-}\n-\n // Want refinements! (Or case classes, I guess\n pub enum named_ty { a_struct, an_enum }\n "}, {"sha": "355ecaed7d7e0a6d7ba6d8f651e35df67869fc5f", "filename": "src/librustc/rustc.rc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/194c27bcd16ad92e2edf11ff7446cb679a91c1d3/src%2Flibrustc%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/194c27bcd16ad92e2edf11ff7446cb679a91c1d3/src%2Flibrustc%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Frustc.rc?ref=194c27bcd16ad92e2edf11ff7446cb679a91c1d3", "patch": "@@ -65,6 +65,7 @@ pub mod middle {\n         pub mod type_use;\n         pub mod reachable;\n         pub mod machine;\n+        pub mod adt;\n     }\n     pub mod ty;\n     pub mod resolve;"}, {"sha": "83d8174075938b03236b608e2e4f3f94b4f948be", "filename": "src/test/run-pass/const-enum-structlike.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/194c27bcd16ad92e2edf11ff7446cb679a91c1d3/src%2Ftest%2Frun-pass%2Fconst-enum-structlike.rs", "raw_url": "https://github.com/rust-lang/rust/raw/194c27bcd16ad92e2edf11ff7446cb679a91c1d3/src%2Ftest%2Frun-pass%2Fconst-enum-structlike.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-enum-structlike.rs?ref=194c27bcd16ad92e2edf11ff7446cb679a91c1d3", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+enum E {\n+    S0 { s: ~str },\n+    S1 { u: uint }\n+}\n+\n+const C: E = S1 { u: 23 };\n+\n+fn main() {\n+    match C {\n+        S0 { _ } => fail!(),\n+        S1 { u } => assert u == 23\n+    }\n+}"}, {"sha": "a6806fba14269e7edae342bc6bb69281e59dd62f", "filename": "src/test/run-pass/enum-discrim-range-overflow.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/194c27bcd16ad92e2edf11ff7446cb679a91c1d3/src%2Ftest%2Frun-pass%2Fenum-discrim-range-overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/194c27bcd16ad92e2edf11ff7446cb679a91c1d3/src%2Ftest%2Frun-pass%2Fenum-discrim-range-overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fenum-discrim-range-overflow.rs?ref=194c27bcd16ad92e2edf11ff7446cb679a91c1d3", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub enum E64 {\n+\tH64 = 0x7FFF_FFFF_FFFF_FFFF,\n+\tL64 = 0x8000_0000_0000_0000\n+}\n+pub enum E32 {\n+\tH32 = 0x7FFF_FFFF,\n+\tL32 = 0x8000_0000\n+}\n+\n+pub fn f(e64: E64, e32: E32) -> (bool,bool) {\n+\t(match e64 {\n+\t\tH64 => true,\n+\t\tL64 => false\n+\t},\n+\t match e32 {\n+\t\tH32 => true,\n+\t\tL32 => false\n+\t})\n+}\n+\n+pub fn main() { }"}, {"sha": "db7c73cbfc5eab3c5c2ea71b2ac67abdbec9e792", "filename": "src/test/run-pass/struct-order-of-eval-1.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/194c27bcd16ad92e2edf11ff7446cb679a91c1d3/src%2Ftest%2Frun-pass%2Fstruct-order-of-eval-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/194c27bcd16ad92e2edf11ff7446cb679a91c1d3/src%2Ftest%2Frun-pass%2Fstruct-order-of-eval-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstruct-order-of-eval-1.rs?ref=194c27bcd16ad92e2edf11ff7446cb679a91c1d3", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct S { f0: ~str, f1: int }\n+\n+pub fn main() {\n+    let s = ~\"Hello, world!\";\n+    let _s = S { f0: str::from_slice(s), ..S { f0: s, f1: 23 } };\n+}"}, {"sha": "413f185659a6f1fb862d5418f9e02811b3875082", "filename": "src/test/run-pass/struct-order-of-eval-2.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/194c27bcd16ad92e2edf11ff7446cb679a91c1d3/src%2Ftest%2Frun-pass%2Fstruct-order-of-eval-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/194c27bcd16ad92e2edf11ff7446cb679a91c1d3/src%2Ftest%2Frun-pass%2Fstruct-order-of-eval-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstruct-order-of-eval-2.rs?ref=194c27bcd16ad92e2edf11ff7446cb679a91c1d3", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct S { f0: ~str, f1: ~str }\n+\n+pub fn main() {\n+    let s = ~\"Hello, world!\";\n+    let _s = S { f1: str::from_slice(s), f0: s };\n+}"}]}