{"sha": "629e97a5a02edb3d8dc63c5157962c093217d441", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYyOWU5N2E1YTAyZWRiM2Q4ZGM2M2M1MTU3OTYyYzA5MzIxN2Q0NDE=", "commit": {"author": {"name": "Russell Cohen", "email": "russell.r.cohen@gmail.com", "date": "2020-03-28T05:46:20Z"}, "committer": {"name": "Russell Cohen", "email": "russell.r.cohen@gmail.com", "date": "2020-03-29T04:43:43Z"}, "message": "Improve error messages for raw strings (#60762)\n\nThis diff improves error messages around raw strings in a few ways:\n- Catch extra trailing `#` in the parser. This can't be handled in the lexer because we could be in a macro that actually expects another # (see test)\n- Refactor & unify error handling in the lexer between ByteStrings and RawByteStrings\n- Detect potentially intended terminators (longest sequence of \"#*\" is suggested)", "tree": {"sha": "ec748780e2098a0581b06d0501bc297447ca59ba", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ec748780e2098a0581b06d0501bc297447ca59ba"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/629e97a5a02edb3d8dc63c5157962c093217d441", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/629e97a5a02edb3d8dc63c5157962c093217d441", "html_url": "https://github.com/rust-lang/rust/commit/629e97a5a02edb3d8dc63c5157962c093217d441", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/629e97a5a02edb3d8dc63c5157962c093217d441/comments", "author": {"login": "rcoh", "id": 492903, "node_id": "MDQ6VXNlcjQ5MjkwMw==", "avatar_url": "https://avatars.githubusercontent.com/u/492903?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rcoh", "html_url": "https://github.com/rcoh", "followers_url": "https://api.github.com/users/rcoh/followers", "following_url": "https://api.github.com/users/rcoh/following{/other_user}", "gists_url": "https://api.github.com/users/rcoh/gists{/gist_id}", "starred_url": "https://api.github.com/users/rcoh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rcoh/subscriptions", "organizations_url": "https://api.github.com/users/rcoh/orgs", "repos_url": "https://api.github.com/users/rcoh/repos", "events_url": "https://api.github.com/users/rcoh/events{/privacy}", "received_events_url": "https://api.github.com/users/rcoh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rcoh", "id": 492903, "node_id": "MDQ6VXNlcjQ5MjkwMw==", "avatar_url": "https://avatars.githubusercontent.com/u/492903?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rcoh", "html_url": "https://github.com/rcoh", "followers_url": "https://api.github.com/users/rcoh/followers", "following_url": "https://api.github.com/users/rcoh/following{/other_user}", "gists_url": "https://api.github.com/users/rcoh/gists{/gist_id}", "starred_url": "https://api.github.com/users/rcoh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rcoh/subscriptions", "organizations_url": "https://api.github.com/users/rcoh/orgs", "repos_url": "https://api.github.com/users/rcoh/repos", "events_url": "https://api.github.com/users/rcoh/events{/privacy}", "received_events_url": "https://api.github.com/users/rcoh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "840a5769b0879f39e21d973a60ac0b0db172f050", "url": "https://api.github.com/repos/rust-lang/rust/commits/840a5769b0879f39e21d973a60ac0b0db172f050", "html_url": "https://github.com/rust-lang/rust/commit/840a5769b0879f39e21d973a60ac0b0db172f050"}], "stats": {"total": 407, "additions": 344, "deletions": 63}, "files": [{"sha": "13d0b07d98baeeb345e2f3404aac4bca316872ee", "filename": "src/librustc_lexer/src/cursor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/629e97a5a02edb3d8dc63c5157962c093217d441/src%2Flibrustc_lexer%2Fsrc%2Fcursor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/629e97a5a02edb3d8dc63c5157962c093217d441/src%2Flibrustc_lexer%2Fsrc%2Fcursor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lexer%2Fsrc%2Fcursor.rs?ref=629e97a5a02edb3d8dc63c5157962c093217d441", "patch": "@@ -41,7 +41,7 @@ impl<'a> Cursor<'a> {\n     /// If requested position doesn't exist, `EOF_CHAR` is returned.\n     /// However, getting `EOF_CHAR` doesn't always mean actual end of file,\n     /// it should be checked with `is_eof` method.\n-    fn nth_char(&self, n: usize) -> char {\n+    pub(crate) fn nth_char(&self, n: usize) -> char {\n         self.chars().nth(n).unwrap_or(EOF_CHAR)\n     }\n "}, {"sha": "70df6d210f4a15911ca99b92a7324feb007a0561", "filename": "src/librustc_lexer/src/lib.rs", "status": "modified", "additions": 109, "deletions": 22, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/629e97a5a02edb3d8dc63c5157962c093217d441/src%2Flibrustc_lexer%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/629e97a5a02edb3d8dc63c5157962c093217d441/src%2Flibrustc_lexer%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lexer%2Fsrc%2Flib.rs?ref=629e97a5a02edb3d8dc63c5157962c093217d441", "patch": "@@ -17,9 +17,13 @@\n mod cursor;\n pub mod unescape;\n \n+#[cfg(test)]\n+mod tests;\n+\n use self::LiteralKind::*;\n use self::TokenKind::*;\n use crate::cursor::{Cursor, EOF_CHAR};\n+use std::convert::TryInto;\n \n /// Parsed token.\n /// It doesn't contain information about data that has been parsed,\n@@ -132,9 +136,65 @@ pub enum LiteralKind {\n     /// \"b\"abc\"\", \"b\"abc\"\n     ByteStr { terminated: bool },\n     /// \"r\"abc\"\", \"r#\"abc\"#\", \"r####\"ab\"###\"c\"####\", \"r#\"a\"\n-    RawStr { n_hashes: usize, started: bool, terminated: bool },\n+    RawStr(UnvalidatedRawStr),\n     /// \"br\"abc\"\", \"br#\"abc\"#\", \"br####\"ab\"###\"c\"####\", \"br#\"a\"\n-    RawByteStr { n_hashes: usize, started: bool, terminated: bool },\n+    RawByteStr(UnvalidatedRawStr),\n+}\n+\n+#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]\n+pub struct UnvalidatedRawStr {\n+    valid_start: bool,\n+    n_start_hashes: usize,\n+    n_end_hashes: usize,\n+    possible_terminator_offset: Option<usize>,\n+}\n+\n+#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]\n+pub enum LexRawStrError {\n+    /// Non # characters between `r` and `\"` eg. `r#~\"..`\n+    InvalidStarter,\n+    /// The string was never terminated. `possible_terminator_offset` is the best guess of where they\n+    /// may have intended to terminate it.\n+    NoTerminator { expected: usize, found: usize, possible_terminator_offset: Option<usize> },\n+    /// More than 65536 # signs\n+    TooManyDelimiters,\n+}\n+\n+#[derive(Debug, Eq, PartialEq, Copy, Clone)]\n+pub struct ValidatedRawStr {\n+    n_hashes: u16,\n+}\n+\n+impl ValidatedRawStr {\n+    pub fn num_hashes(&self) -> u16 {\n+        self.n_hashes\n+    }\n+}\n+\n+impl UnvalidatedRawStr {\n+    pub fn started(&self) -> bool {\n+        self.valid_start\n+    }\n+\n+    pub fn validate(self) -> Result<ValidatedRawStr, LexRawStrError> {\n+        if !self.valid_start {\n+            return Err(LexRawStrError::InvalidStarter);\n+        }\n+\n+        let n_start_safe: u16 =\n+            self.n_start_hashes.try_into().map_err(|_| LexRawStrError::TooManyDelimiters)?;\n+        match (self.n_start_hashes, self.n_end_hashes) {\n+            (n_start, n_end) if n_start > n_end => Err(LexRawStrError::NoTerminator {\n+                expected: n_start,\n+                found: self.n_end_hashes,\n+                possible_terminator_offset: self.possible_terminator_offset,\n+            }),\n+            (n_start, n_end) => {\n+                debug_assert_eq!(n_start, n_end);\n+                Ok(ValidatedRawStr { n_hashes: n_start_safe })\n+            }\n+        }\n+    }\n }\n \n /// Base of numeric literal encoding according to its prefix.\n@@ -209,7 +269,7 @@ pub fn is_whitespace(c: char) -> bool {\n         // Dedicated whitespace characters from Unicode\n         | '\\u{2028}' // LINE SEPARATOR\n         | '\\u{2029}' // PARAGRAPH SEPARATOR\n-            => true,\n+        => true,\n         _ => false,\n     }\n }\n@@ -258,12 +318,12 @@ impl Cursor<'_> {\n             'r' => match (self.first(), self.second()) {\n                 ('#', c1) if is_id_start(c1) => self.raw_ident(),\n                 ('#', _) | ('\"', _) => {\n-                    let (n_hashes, started, terminated) = self.raw_double_quoted_string();\n+                    let raw_str_i = self.raw_double_quoted_string(1);\n                     let suffix_start = self.len_consumed();\n-                    if terminated {\n+                    if raw_str_i.n_end_hashes == raw_str_i.n_start_hashes {\n                         self.eat_literal_suffix();\n                     }\n-                    let kind = RawStr { n_hashes, started, terminated };\n+                    let kind = RawStr(raw_str_i);\n                     Literal { kind, suffix_start }\n                 }\n                 _ => self.ident(),\n@@ -293,12 +353,14 @@ impl Cursor<'_> {\n                 }\n                 ('r', '\"') | ('r', '#') => {\n                     self.bump();\n-                    let (n_hashes, started, terminated) = self.raw_double_quoted_string();\n+                    let raw_str_i = self.raw_double_quoted_string(2);\n                     let suffix_start = self.len_consumed();\n+                    let terminated = raw_str_i.n_start_hashes == raw_str_i.n_end_hashes;\n                     if terminated {\n                         self.eat_literal_suffix();\n                     }\n-                    let kind = RawByteStr { n_hashes, started, terminated };\n+\n+                    let kind = RawByteStr(raw_str_i);\n                     Literal { kind, suffix_start }\n                 }\n                 _ => self.ident(),\n@@ -594,37 +656,49 @@ impl Cursor<'_> {\n         false\n     }\n \n-    /// Eats the double-quoted string and returns a tuple of\n-    /// (amount of the '#' symbols, raw string started, raw string terminated)\n-    fn raw_double_quoted_string(&mut self) -> (usize, bool, bool) {\n+    /// Eats the double-quoted string an UnvalidatedRawStr\n+    fn raw_double_quoted_string(&mut self, prefix_len: usize) -> UnvalidatedRawStr {\n         debug_assert!(self.prev() == 'r');\n-        let mut started: bool = false;\n-        let mut finished: bool = false;\n+        let mut valid_start: bool = false;\n+        let start_pos = self.len_consumed();\n+        let (mut possible_terminator_offset, mut max_hashes) = (None, 0);\n \n         // Count opening '#' symbols.\n-        let n_hashes = self.eat_while(|c| c == '#');\n+        let n_start_hashes = self.eat_while(|c| c == '#');\n \n         // Check that string is started.\n         match self.bump() {\n-            Some('\"') => started = true,\n-            _ => return (n_hashes, started, finished),\n+            Some('\"') => valid_start = true,\n+            _ => {\n+                return UnvalidatedRawStr {\n+                    valid_start,\n+                    n_start_hashes,\n+                    n_end_hashes: 0,\n+                    possible_terminator_offset,\n+                };\n+            }\n         }\n \n         // Skip the string contents and on each '#' character met, check if this is\n         // a raw string termination.\n-        while !finished {\n+        loop {\n             self.eat_while(|c| c != '\"');\n \n             if self.is_eof() {\n-                return (n_hashes, started, finished);\n+                return UnvalidatedRawStr {\n+                    valid_start,\n+                    n_start_hashes,\n+                    n_end_hashes: max_hashes,\n+                    possible_terminator_offset,\n+                };\n             }\n \n             // Eat closing double quote.\n             self.bump();\n \n             // Check that amount of closing '#' symbols\n             // is equal to the amount of opening ones.\n-            let mut hashes_left = n_hashes;\n+            let mut hashes_left = n_start_hashes;\n             let is_closing_hash = |c| {\n                 if c == '#' && hashes_left != 0 {\n                     hashes_left -= 1;\n@@ -633,10 +707,23 @@ impl Cursor<'_> {\n                     false\n                 }\n             };\n-            finished = self.eat_while(is_closing_hash) == n_hashes;\n+            let n_end_hashes = self.eat_while(is_closing_hash);\n+\n+            if n_end_hashes == n_start_hashes {\n+                return UnvalidatedRawStr {\n+                    valid_start,\n+                    n_start_hashes,\n+                    n_end_hashes,\n+                    possible_terminator_offset: None,\n+                };\n+            } else if n_end_hashes > 0 && n_end_hashes > max_hashes {\n+                // Keep track of possible terminators to give a hint about where there might be\n+                // a missing terminator\n+                possible_terminator_offset =\n+                    Some(self.len_consumed() - start_pos - n_end_hashes + prefix_len);\n+                max_hashes = n_end_hashes;\n+            }\n         }\n-\n-        (n_hashes, started, finished)\n     }\n \n     fn eat_decimal_digits(&mut self) -> bool {"}, {"sha": "ba5897c5d421866ea9144f5c591a6c637dedf25a", "filename": "src/librustc_lexer/src/tests.rs", "status": "added", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/629e97a5a02edb3d8dc63c5157962c093217d441/src%2Flibrustc_lexer%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/629e97a5a02edb3d8dc63c5157962c093217d441/src%2Flibrustc_lexer%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lexer%2Fsrc%2Ftests.rs?ref=629e97a5a02edb3d8dc63c5157962c093217d441", "patch": "@@ -0,0 +1,119 @@\n+#[cfg(test)]\n+mod tests {\n+    use crate::*;\n+\n+    fn check_raw_str(\n+        s: &str,\n+        expected: UnvalidatedRawStr,\n+        validated: Result<ValidatedRawStr, LexRawStrError>,\n+    ) {\n+        let mut cursor = Cursor::new(s);\n+        let tok = cursor.raw_double_quoted_string(0);\n+        assert_eq!(tok, expected);\n+        assert_eq!(tok.validate(), validated);\n+    }\n+\n+    #[test]\n+    fn test_naked_raw_str() {\n+        check_raw_str(\n+            r#\"\"abc\"\"#,\n+            UnvalidatedRawStr {\n+                n_start_hashes: 0,\n+                n_end_hashes: 0,\n+                valid_start: true,\n+                possible_terminator_offset: None,\n+            },\n+            Ok(ValidatedRawStr { n_hashes: 0 }),\n+        );\n+    }\n+\n+    #[test]\n+    fn test_raw_no_start() {\n+        check_raw_str(\n+            r##\"\"abc\"#\"##,\n+            UnvalidatedRawStr {\n+                n_start_hashes: 0,\n+                n_end_hashes: 0,\n+                valid_start: true,\n+                possible_terminator_offset: None,\n+            },\n+            Ok(ValidatedRawStr { n_hashes: 0 }),\n+        );\n+    }\n+\n+    #[test]\n+    fn test_too_many_terminators() {\n+        // this error is handled in the parser later\n+        check_raw_str(\n+            r###\"#\"abc\"##\"###,\n+            UnvalidatedRawStr {\n+                n_start_hashes: 1,\n+                n_end_hashes: 1,\n+                valid_start: true,\n+                possible_terminator_offset: None,\n+            },\n+            Ok(ValidatedRawStr { n_hashes: 1 }),\n+        );\n+    }\n+\n+    #[test]\n+    fn test_unterminated() {\n+        check_raw_str(\n+            r#\"#\"abc\"#,\n+            UnvalidatedRawStr {\n+                n_start_hashes: 1,\n+                n_end_hashes: 0,\n+                valid_start: true,\n+                possible_terminator_offset: None,\n+            },\n+            Err(LexRawStrError::NoTerminator {\n+                expected: 1,\n+                found: 0,\n+                possible_terminator_offset: None,\n+            }),\n+        );\n+        check_raw_str(\n+            r###\"##\"abc\"#\"###,\n+            UnvalidatedRawStr {\n+                n_start_hashes: 2,\n+                n_end_hashes: 1,\n+                valid_start: true,\n+                possible_terminator_offset: Some(7),\n+            },\n+            Err(LexRawStrError::NoTerminator {\n+                expected: 2,\n+                found: 1,\n+                possible_terminator_offset: Some(7),\n+            }),\n+        );\n+        // We're looking for \"# not just any #\n+        check_raw_str(\n+            r###\"##\"abc#\"###,\n+            UnvalidatedRawStr {\n+                n_start_hashes: 2,\n+                n_end_hashes: 0,\n+                valid_start: true,\n+                possible_terminator_offset: None,\n+            },\n+            Err(LexRawStrError::NoTerminator {\n+                expected: 2,\n+                found: 0,\n+                possible_terminator_offset: None,\n+            }),\n+        )\n+    }\n+\n+    #[test]\n+    fn test_invalid_start() {\n+        check_raw_str(\n+            r##\"#~\"abc\"#\"##,\n+            UnvalidatedRawStr {\n+                n_start_hashes: 1,\n+                n_end_hashes: 0,\n+                valid_start: false,\n+                possible_terminator_offset: None,\n+            },\n+            Err(LexRawStrError::InvalidStarter),\n+        );\n+    }\n+}"}, {"sha": "2f720d95c6d2f04d68a4526b68d88ddef0edc03b", "filename": "src/librustc_parse/lexer/mod.rs", "status": "modified", "additions": 60, "deletions": 34, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/629e97a5a02edb3d8dc63c5157962c093217d441/src%2Flibrustc_parse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/629e97a5a02edb3d8dc63c5157962c093217d441/src%2Flibrustc_parse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Flexer%2Fmod.rs?ref=629e97a5a02edb3d8dc63c5157962c093217d441", "patch": "@@ -1,20 +1,20 @@\n use rustc_ast::token::{self, Token, TokenKind};\n use rustc_ast::util::comments;\n use rustc_data_structures::sync::Lrc;\n-use rustc_errors::{error_code, DiagnosticBuilder, FatalError};\n-use rustc_lexer::unescape;\n+use rustc_errors::{error_code, Applicability, DiagnosticBuilder, FatalError};\n use rustc_lexer::Base;\n+use rustc_lexer::{unescape, LexRawStrError, UnvalidatedRawStr, ValidatedRawStr};\n use rustc_session::parse::ParseSess;\n use rustc_span::symbol::{sym, Symbol};\n use rustc_span::{BytePos, Pos, Span};\n \n use log::debug;\n use std::char;\n-use std::convert::TryInto;\n \n mod tokentrees;\n mod unescape_error_reporting;\n mod unicode_chars;\n+\n use unescape_error_reporting::{emit_unescape_error, push_escaped_char};\n \n #[derive(Clone, Debug)]\n@@ -376,30 +376,22 @@ impl<'a> StringReader<'a> {\n                 let id = self.symbol_from_to(content_start, content_end);\n                 (token::ByteStr, id)\n             }\n-            rustc_lexer::LiteralKind::RawStr { n_hashes, started, terminated } => {\n-                if !started {\n-                    self.report_non_started_raw_string(start);\n-                }\n-                if !terminated {\n-                    self.report_unterminated_raw_string(start, n_hashes)\n-                }\n-                let n_hashes: u16 = self.restrict_n_hashes(start, n_hashes);\n+            rustc_lexer::LiteralKind::RawStr(unvalidated_raw_str) => {\n+                let valid_raw_str = self.validate_and_report_errors(start, unvalidated_raw_str);\n+                let n_hashes = valid_raw_str.num_hashes();\n                 let n = u32::from(n_hashes);\n+\n                 let content_start = start + BytePos(2 + n);\n                 let content_end = suffix_start - BytePos(1 + n);\n                 self.validate_raw_str_escape(content_start, content_end);\n                 let id = self.symbol_from_to(content_start, content_end);\n                 (token::StrRaw(n_hashes), id)\n             }\n-            rustc_lexer::LiteralKind::RawByteStr { n_hashes, started, terminated } => {\n-                if !started {\n-                    self.report_non_started_raw_string(start);\n-                }\n-                if !terminated {\n-                    self.report_unterminated_raw_string(start, n_hashes)\n-                }\n-                let n_hashes: u16 = self.restrict_n_hashes(start, n_hashes);\n+            rustc_lexer::LiteralKind::RawByteStr(unvalidated_raw_str) => {\n+                let validated_raw_str = self.validate_and_report_errors(start, unvalidated_raw_str);\n+                let n_hashes = validated_raw_str.num_hashes();\n                 let n = u32::from(n_hashes);\n+\n                 let content_start = start + BytePos(3 + n);\n                 let content_end = suffix_start - BytePos(1 + n);\n                 self.validate_raw_byte_str_escape(content_start, content_end);\n@@ -485,6 +477,26 @@ impl<'a> StringReader<'a> {\n         }\n     }\n \n+    fn validate_and_report_errors(\n+        &self,\n+        start: BytePos,\n+        unvalidated_raw_str: UnvalidatedRawStr,\n+    ) -> ValidatedRawStr {\n+        match unvalidated_raw_str.validate() {\n+            Err(LexRawStrError::InvalidStarter) => self.report_non_started_raw_string(start),\n+            Err(LexRawStrError::NoTerminator { expected, found, possible_terminator_offset }) => {\n+                self.report_unterminated_raw_string(\n+                    start,\n+                    expected,\n+                    possible_terminator_offset,\n+                    found,\n+                )\n+            }\n+            Err(LexRawStrError::TooManyDelimiters) => self.report_too_many_hashes(start),\n+            Ok(valid) => valid,\n+        }\n+    }\n+\n     fn report_non_started_raw_string(&self, start: BytePos) -> ! {\n         let bad_char = self.str_from(start).chars().last().unwrap();\n         self.struct_fatal_span_char(\n@@ -498,38 +510,52 @@ impl<'a> StringReader<'a> {\n         FatalError.raise()\n     }\n \n-    fn report_unterminated_raw_string(&self, start: BytePos, n_hashes: usize) -> ! {\n+    fn report_unterminated_raw_string(\n+        &self,\n+        start: BytePos,\n+        n_hashes: usize,\n+        possible_offset: Option<usize>,\n+        found_terminators: usize,\n+    ) -> ! {\n         let mut err = self.sess.span_diagnostic.struct_span_fatal_with_code(\n             self.mk_sp(start, start),\n             \"unterminated raw string\",\n             error_code!(E0748),\n         );\n+\n         err.span_label(self.mk_sp(start, start), \"unterminated raw string\");\n \n         if n_hashes > 0 {\n             err.note(&format!(\n                 \"this raw string should be terminated with `\\\"{}`\",\n-                \"#\".repeat(n_hashes as usize)\n+                \"#\".repeat(n_hashes)\n             ));\n         }\n \n+        if let Some(possible_offset) = possible_offset {\n+            let span = self.mk_sp(\n+                start + BytePos(possible_offset as u32),\n+                start + BytePos(possible_offset as u32) + BytePos(found_terminators as u32),\n+            );\n+            err.span_suggestion(\n+                span,\n+                \"you might have intended to terminate the string here\",\n+                \"#\".repeat(n_hashes),\n+                Applicability::MaybeIncorrect,\n+            );\n+        }\n+\n         err.emit();\n         FatalError.raise()\n     }\n \n-    fn restrict_n_hashes(&self, start: BytePos, n_hashes: usize) -> u16 {\n-        match n_hashes.try_into() {\n-            Ok(n_hashes) => n_hashes,\n-            Err(_) => {\n-                self.fatal_span_(\n-                    start,\n-                    self.pos,\n-                    \"too many `#` symbols: raw strings may be \\\n-                                  delimited by up to 65535 `#` symbols\",\n-                )\n-                .raise();\n-            }\n-        }\n+    fn report_too_many_hashes(&self, start: BytePos) -> ! {\n+        self.fatal_span_(\n+            start,\n+            self.pos,\n+            \"too many `#` symbols: raw strings may be delimited by up to 65535 `#` symbols\",\n+        )\n+        .raise();\n     }\n \n     fn validate_char_escape(&self, content_start: BytePos, content_end: BytePos) {"}, {"sha": "7b6840307cb42c354994fa2ef2adcf2b9138717d", "filename": "src/librustc_parse/parser/diagnostics.rs", "status": "modified", "additions": 30, "deletions": 1, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/629e97a5a02edb3d8dc63c5157962c093217d441/src%2Flibrustc_parse%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/629e97a5a02edb3d8dc63c5157962c093217d441/src%2Flibrustc_parse%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fdiagnostics.rs?ref=629e97a5a02edb3d8dc63c5157962c093217d441", "patch": "@@ -6,7 +6,7 @@ use rustc_ast::ast::{\n };\n use rustc_ast::ast::{AttrVec, ItemKind, Mutability, Pat, PatKind, PathSegment, QSelf, Ty, TyKind};\n use rustc_ast::ptr::P;\n-use rustc_ast::token::{self, TokenKind};\n+use rustc_ast::token::{self, Lit, LitKind, Token, TokenKind};\n use rustc_ast::util::parser::AssocOp;\n use rustc_ast_pretty::pprust;\n use rustc_data_structures::fx::FxHashSet;\n@@ -255,6 +255,10 @@ impl<'a> Parser<'a> {\n             }\n         }\n \n+        if self.check_too_many_raw_str_terminators(&mut err) {\n+            return Err(err);\n+        }\n+\n         let sm = self.sess.source_map();\n         if self.prev_token.span == DUMMY_SP {\n             // Account for macro context where the previous span might not be\n@@ -282,6 +286,31 @@ impl<'a> Parser<'a> {\n         Err(err)\n     }\n \n+    fn check_too_many_raw_str_terminators(&mut self, err: &mut DiagnosticBuilder<'_>) -> bool {\n+        let prev_token_raw_str = match self.prev_token {\n+            Token { kind: TokenKind::Literal(Lit { kind: LitKind::StrRaw(n), .. }), .. } => Some(n),\n+            Token {\n+                kind: TokenKind::Literal(Lit { kind: LitKind::ByteStrRaw(n), .. }), ..\n+            } => Some(n),\n+            _ => None,\n+        };\n+\n+        if let Some(n_hashes) = prev_token_raw_str {\n+            if self.token.kind == TokenKind::Pound {\n+                err.set_primary_message(\"too many `#` when terminating raw string\");\n+                err.span_suggestion(\n+                    self.token.span,\n+                    \"Remove the extra `#`\",\n+                    String::new(),\n+                    Applicability::MachineApplicable,\n+                );\n+                err.note(&format!(\"The raw string started with {} `#`s\", n_hashes));\n+                return true;\n+            }\n+        }\n+        false\n+    }\n+\n     pub fn maybe_annotate_with_ascription(\n         &mut self,\n         err: &mut DiagnosticBuilder<'_>,"}, {"sha": "81344841c270011a88dd12ceb6fecc5b048d9060", "filename": "src/test/ui/parser/raw/raw-byte-string-eof.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/629e97a5a02edb3d8dc63c5157962c093217d441/src%2Ftest%2Fui%2Fparser%2Fraw%2Fraw-byte-string-eof.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/629e97a5a02edb3d8dc63c5157962c093217d441/src%2Ftest%2Fui%2Fparser%2Fraw%2Fraw-byte-string-eof.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fraw%2Fraw-byte-string-eof.stderr?ref=629e97a5a02edb3d8dc63c5157962c093217d441", "patch": "@@ -2,7 +2,9 @@ error[E0748]: unterminated raw string\n   --> $DIR/raw-byte-string-eof.rs:2:5\n    |\n LL |     br##\"a\"#;\n-   |     ^ unterminated raw string\n+   |     ^      - help: you might have intended to terminate the string here: `##`\n+   |     |\n+   |     unterminated raw string\n    |\n    = note: this raw string should be terminated with `\"##`\n "}, {"sha": "462c2279f5c1c3791af6098c461d17d68ed2929d", "filename": "src/test/ui/parser/raw/raw-str-in-macro-call.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/629e97a5a02edb3d8dc63c5157962c093217d441/src%2Ftest%2Fui%2Fparser%2Fraw%2Fraw-str-in-macro-call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/629e97a5a02edb3d8dc63c5157962c093217d441/src%2Ftest%2Fui%2Fparser%2Fraw%2Fraw-str-in-macro-call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fraw%2Fraw-str-in-macro-call.rs?ref=629e97a5a02edb3d8dc63c5157962c093217d441", "patch": "@@ -0,0 +1,14 @@\n+// check-pass\n+\n+macro_rules! m1 {\n+    ($tt:tt #) => ()\n+}\n+\n+macro_rules! m2 {\n+    ($tt:tt) => ()\n+}\n+\n+fn main() {\n+    m1!(r#\"abc\"##);\n+    m2!(r#\"abc\"#);\n+}"}, {"sha": "35f118f5ce6eed46af1e1b3a89f2be036f7204ea", "filename": "src/test/ui/parser/raw/raw-str-unbalanced.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/629e97a5a02edb3d8dc63c5157962c093217d441/src%2Ftest%2Fui%2Fparser%2Fraw%2Fraw-str-unbalanced.rs", "raw_url": "https://github.com/rust-lang/rust/raw/629e97a5a02edb3d8dc63c5157962c093217d441/src%2Ftest%2Fui%2Fparser%2Fraw%2Fraw-str-unbalanced.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fraw%2Fraw-str-unbalanced.rs?ref=629e97a5a02edb3d8dc63c5157962c093217d441", "patch": "@@ -1,4 +1,4 @@\n static s: &'static str =\n     r#\"\n-      \"## //~ ERROR expected one of `.`, `;`, `?`, or an operator, found `#`\n+      \"## //~ too many `#` when terminating raw string\n ;"}, {"sha": "891f1d6337cd2a77774cfde54e77d80ddd8cd0fb", "filename": "src/test/ui/parser/raw/raw-str-unbalanced.stderr", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/629e97a5a02edb3d8dc63c5157962c093217d441/src%2Ftest%2Fui%2Fparser%2Fraw%2Fraw-str-unbalanced.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/629e97a5a02edb3d8dc63c5157962c093217d441/src%2Ftest%2Fui%2Fparser%2Fraw%2Fraw-str-unbalanced.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fraw%2Fraw-str-unbalanced.stderr?ref=629e97a5a02edb3d8dc63c5157962c093217d441", "patch": "@@ -1,8 +1,10 @@\n-error: expected one of `.`, `;`, `?`, or an operator, found `#`\n+error: too many `#` when terminating raw string\n   --> $DIR/raw-str-unbalanced.rs:3:9\n    |\n LL |       \"##\n-   |         ^ expected one of `.`, `;`, `?`, or an operator\n+   |         ^ help: Remove the extra `#`\n+   |\n+   = note: The raw string started with 1 `#`s\n \n error: aborting due to previous error\n "}, {"sha": "e91a16bedc46e7366758fb145b9e3f8e44e125ce", "filename": "src/test/ui/parser/raw/raw_string.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/629e97a5a02edb3d8dc63c5157962c093217d441/src%2Ftest%2Fui%2Fparser%2Fraw%2Fraw_string.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/629e97a5a02edb3d8dc63c5157962c093217d441/src%2Ftest%2Fui%2Fparser%2Fraw%2Fraw_string.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fraw%2Fraw_string.stderr?ref=629e97a5a02edb3d8dc63c5157962c093217d441", "patch": "@@ -2,7 +2,9 @@ error[E0748]: unterminated raw string\n   --> $DIR/raw_string.rs:2:13\n    |\n LL |     let x = r##\"lol\"#;\n-   |             ^ unterminated raw string\n+   |             ^       - help: you might have intended to terminate the string here: `##`\n+   |             |\n+   |             unterminated raw string\n    |\n    = note: this raw string should be terminated with `\"##`\n "}]}