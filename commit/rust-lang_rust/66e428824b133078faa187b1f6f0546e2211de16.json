{"sha": "66e428824b133078faa187b1f6f0546e2211de16", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY2ZTQyODgyNGIxMzMwNzhmYWExODdiMWY2ZjA1NDZlMjIxMWRlMTY=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-10-14T05:36:55Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-10-14T05:36:55Z"}, "message": "Rollup merge of #65362 - Centril:extract_fun, r=petrochenkov\n\nsyntax: consolidate function parsing in item.rs\n\nExtracted from https://github.com/rust-lang/rust/pull/65324.\n\nr? @estebank", "tree": {"sha": "fb3b060b7ae34a25eb064750c6d417bed5099874", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fb3b060b7ae34a25eb064750c6d417bed5099874"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/66e428824b133078faa187b1f6f0546e2211de16", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdpAl3CRBK7hj4Ov3rIwAAdHIIAFfluhH5tlsY1AZQGh4tqPLC\nfNMvIUeM7onGUD3Kpta29OW6OmWDWp/3zIe8NfOHtEUGfiYXLMY4hl/AtTsoWE82\ndYUzcBHzIV5hbrC8fhyZ10Hhc2KRyunbwGDzwc2Bp+1XqcjbGPe26K69RP9caqK2\nB8ii90FpRsrTTKPPxVEI8OP9hum72jdz1Grgo4wzaUCyE1kJUU6Z6CWWKg0ePk/V\nGKEazF5K0f96XK2A1I4puTrvg5jRIXXWxHed4L3csQrEj2ggGZEB7ALxmwK7DvEX\nBnRuAGzt4CjWZ6U+V/GqtwoSvBvv+xAip31RKQFa9PjIINDNlYK1k2w8fgkBC7U=\n=P91u\n-----END PGP SIGNATURE-----\n", "payload": "tree fb3b060b7ae34a25eb064750c6d417bed5099874\nparent c2ae4ded4dbccb7583a09294a2abd6095ebd3285\nparent 4a0c487d1bfe483a9341a8e477475dbc4a72b3a6\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1571031415 +0200\ncommitter GitHub <noreply@github.com> 1571031415 +0200\n\nRollup merge of #65362 - Centril:extract_fun, r=petrochenkov\n\nsyntax: consolidate function parsing in item.rs\n\nExtracted from https://github.com/rust-lang/rust/pull/65324.\n\nr? @estebank\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/66e428824b133078faa187b1f6f0546e2211de16", "html_url": "https://github.com/rust-lang/rust/commit/66e428824b133078faa187b1f6f0546e2211de16", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/66e428824b133078faa187b1f6f0546e2211de16/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c2ae4ded4dbccb7583a09294a2abd6095ebd3285", "url": "https://api.github.com/repos/rust-lang/rust/commits/c2ae4ded4dbccb7583a09294a2abd6095ebd3285", "html_url": "https://github.com/rust-lang/rust/commit/c2ae4ded4dbccb7583a09294a2abd6095ebd3285"}, {"sha": "4a0c487d1bfe483a9341a8e477475dbc4a72b3a6", "url": "https://api.github.com/repos/rust-lang/rust/commits/4a0c487d1bfe483a9341a8e477475dbc4a72b3a6", "html_url": "https://github.com/rust-lang/rust/commit/4a0c487d1bfe483a9341a8e477475dbc4a72b3a6"}], "stats": {"total": 978, "additions": 491, "deletions": 487}, "files": [{"sha": "920208c8fd9e63208e8af763eb1571aa60e9691a", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 4, "deletions": 281, "changes": 285, "blob_url": "https://github.com/rust-lang/rust/blob/66e428824b133078faa187b1f6f0546e2211de16/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66e428824b133078faa187b1f6f0546e2211de16/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=66e428824b133078faa187b1f6f0546e2211de16", "patch": "@@ -9,20 +9,19 @@ mod path;\n pub use path::PathStyle;\n mod stmt;\n mod generics;\n+use super::diagnostics::Error;\n \n use crate::ast::{\n-    self, DUMMY_NODE_ID, AttrStyle, Attribute, BindingMode, CrateSugar, Ident,\n-    IsAsync, MacDelimiter, Mutability, Param, StrStyle, SelfKind, TyKind, Visibility,\n-    VisibilityKind, Unsafety,\n+    self, DUMMY_NODE_ID, AttrStyle, Attribute, CrateSugar, Ident,\n+    IsAsync, MacDelimiter, Mutability, StrStyle, Visibility, VisibilityKind, Unsafety,\n };\n use crate::parse::{ParseSess, PResult, Directory, DirectoryOwnership, SeqSep, literal, token};\n-use crate::parse::diagnostics::{Error, dummy_arg};\n use crate::parse::lexer::UnmatchedBrace;\n use crate::parse::lexer::comments::{doc_comment_style, strip_doc_comment_decoration};\n use crate::parse::token::{Token, TokenKind, DelimToken};\n use crate::print::pprust;\n use crate::ptr::P;\n-use crate::source_map::{self, respan};\n+use crate::source_map::respan;\n use crate::symbol::{kw, sym, Symbol};\n use crate::tokenstream::{self, DelimSpan, TokenTree, TokenStream, TreeAndJoint};\n use crate::ThinVec;\n@@ -56,17 +55,6 @@ crate enum BlockMode {\n     Ignore,\n }\n \n-/// The parsing configuration used to parse a parameter list (see `parse_fn_params`).\n-struct ParamCfg {\n-    /// Is `self` is allowed as the first parameter?\n-    is_self_allowed: bool,\n-    /// Is `...` allowed as the tail of the parameter list?\n-    allow_c_variadic: bool,\n-    /// `is_name_required` decides if, per-parameter,\n-    /// the parameter must have a pattern or just a type.\n-    is_name_required: fn(&token::Token) -> bool,\n-}\n-\n /// Like `maybe_whole_expr`, but for things other than expressions.\n #[macro_export]\n macro_rules! maybe_whole {\n@@ -1105,271 +1093,6 @@ impl<'a> Parser<'a> {\n         res\n     }\n \n-    /// Parses the parameter list of a function, including the `(` and `)` delimiters.\n-    fn parse_fn_params(&mut self, mut cfg: ParamCfg) -> PResult<'a, Vec<Param>> {\n-        let sp = self.token.span;\n-        let is_trait_item = cfg.is_self_allowed;\n-        let mut c_variadic = false;\n-        // Parse the arguments, starting out with `self` being possibly allowed...\n-        let (params, _) = self.parse_paren_comma_seq(|p| {\n-            let param = p.parse_param_general(&cfg, is_trait_item);\n-            // ...now that we've parsed the first argument, `self` is no longer allowed.\n-            cfg.is_self_allowed = false;\n-\n-            match param {\n-                Ok(param) => Ok(\n-                    if let TyKind::CVarArgs = param.ty.kind {\n-                        c_variadic = true;\n-                        if p.token != token::CloseDelim(token::Paren) {\n-                            p.span_err(\n-                                p.token.span,\n-                                \"`...` must be the last argument of a C-variadic function\",\n-                            );\n-                            // FIXME(eddyb) this should probably still push `CVarArgs`.\n-                            // Maybe AST validation/HIR lowering should emit the above error?\n-                            None\n-                        } else {\n-                            Some(param)\n-                        }\n-                    } else {\n-                        Some(param)\n-                    }\n-                ),\n-                Err(mut e) => {\n-                    e.emit();\n-                    let lo = p.prev_span;\n-                    // Skip every token until next possible arg or end.\n-                    p.eat_to_tokens(&[&token::Comma, &token::CloseDelim(token::Paren)]);\n-                    // Create a placeholder argument for proper arg count (issue #34264).\n-                    let span = lo.to(p.prev_span);\n-                    Ok(Some(dummy_arg(Ident::new(kw::Invalid, span))))\n-                }\n-            }\n-        })?;\n-\n-        let mut params: Vec<_> = params.into_iter().filter_map(|x| x).collect();\n-\n-        // Replace duplicated recovered params with `_` pattern to avoid unecessary errors.\n-        self.deduplicate_recovered_params_names(&mut params);\n-\n-        if c_variadic && params.len() <= 1 {\n-            self.span_err(\n-                sp,\n-                \"C-variadic function must be declared with at least one named argument\",\n-            );\n-        }\n-\n-        Ok(params)\n-    }\n-\n-    /// Skips unexpected attributes and doc comments in this position and emits an appropriate\n-    /// error.\n-    /// This version of parse param doesn't necessarily require identifier names.\n-    fn parse_param_general(&mut self, cfg: &ParamCfg, is_trait_item: bool) -> PResult<'a, Param> {\n-        let lo = self.token.span;\n-        let attrs = self.parse_outer_attributes()?;\n-\n-        // Possibly parse `self`. Recover if we parsed it and it wasn't allowed here.\n-        if let Some(mut param) = self.parse_self_param()? {\n-            param.attrs = attrs.into();\n-            return if cfg.is_self_allowed {\n-                Ok(param)\n-            } else {\n-                self.recover_bad_self_param(param, is_trait_item)\n-            };\n-        }\n-\n-        let is_name_required = match self.token.kind {\n-            token::DotDotDot => false,\n-            _ => (cfg.is_name_required)(&self.token),\n-        };\n-        let (pat, ty) = if is_name_required || self.is_named_param() {\n-            debug!(\"parse_param_general parse_pat (is_name_required:{})\", is_name_required);\n-\n-            let pat = self.parse_fn_param_pat()?;\n-            if let Err(mut err) = self.expect(&token::Colon) {\n-                return if let Some(ident) = self.parameter_without_type(\n-                    &mut err,\n-                    pat,\n-                    is_name_required,\n-                    cfg.is_self_allowed,\n-                    is_trait_item,\n-                ) {\n-                    err.emit();\n-                    Ok(dummy_arg(ident))\n-                } else {\n-                    Err(err)\n-                };\n-            }\n-\n-            self.eat_incorrect_doc_comment_for_param_type();\n-            (pat, self.parse_ty_common(true, true, cfg.allow_c_variadic)?)\n-        } else {\n-            debug!(\"parse_param_general ident_to_pat\");\n-            let parser_snapshot_before_ty = self.clone();\n-            self.eat_incorrect_doc_comment_for_param_type();\n-            let mut ty = self.parse_ty_common(true, true, cfg.allow_c_variadic);\n-            if ty.is_ok() && self.token != token::Comma &&\n-               self.token != token::CloseDelim(token::Paren) {\n-                // This wasn't actually a type, but a pattern looking like a type,\n-                // so we are going to rollback and re-parse for recovery.\n-                ty = self.unexpected();\n-            }\n-            match ty {\n-                Ok(ty) => {\n-                    let ident = Ident::new(kw::Invalid, self.prev_span);\n-                    let bm = BindingMode::ByValue(Mutability::Immutable);\n-                    let pat = self.mk_pat_ident(ty.span, bm, ident);\n-                    (pat, ty)\n-                }\n-                // If this is a C-variadic argument and we hit an error, return the error.\n-                Err(err) if self.token == token::DotDotDot => return Err(err),\n-                // Recover from attempting to parse the argument as a type without pattern.\n-                Err(mut err) => {\n-                    err.cancel();\n-                    mem::replace(self, parser_snapshot_before_ty);\n-                    self.recover_arg_parse()?\n-                }\n-            }\n-        };\n-\n-        let span = lo.to(self.token.span);\n-\n-        Ok(Param {\n-            attrs: attrs.into(),\n-            id: ast::DUMMY_NODE_ID,\n-            is_placeholder: false,\n-            pat,\n-            span,\n-            ty,\n-        })\n-    }\n-\n-    /// Returns the parsed optional self parameter and whether a self shortcut was used.\n-    ///\n-    /// See `parse_self_param_with_attrs` to collect attributes.\n-    fn parse_self_param(&mut self) -> PResult<'a, Option<Param>> {\n-        // Extract an identifier *after* having confirmed that the token is one.\n-        let expect_self_ident = |this: &mut Self| {\n-            match this.token.kind {\n-                // Preserve hygienic context.\n-                token::Ident(name, _) => {\n-                    let span = this.token.span;\n-                    this.bump();\n-                    Ident::new(name, span)\n-                }\n-                _ => unreachable!(),\n-            }\n-        };\n-        // Is `self` `n` tokens ahead?\n-        let is_isolated_self = |this: &Self, n| {\n-            this.is_keyword_ahead(n, &[kw::SelfLower])\n-            && this.look_ahead(n + 1, |t| t != &token::ModSep)\n-        };\n-        // Is `mut self` `n` tokens ahead?\n-        let is_isolated_mut_self = |this: &Self, n| {\n-            this.is_keyword_ahead(n, &[kw::Mut])\n-            && is_isolated_self(this, n + 1)\n-        };\n-        // Parse `self` or `self: TYPE`. We already know the current token is `self`.\n-        let parse_self_possibly_typed = |this: &mut Self, m| {\n-            let eself_ident = expect_self_ident(this);\n-            let eself_hi = this.prev_span;\n-            let eself = if this.eat(&token::Colon) {\n-                SelfKind::Explicit(this.parse_ty()?, m)\n-            } else {\n-                SelfKind::Value(m)\n-            };\n-            Ok((eself, eself_ident, eself_hi))\n-        };\n-        // Recover for the grammar `*self`, `*const self`, and `*mut self`.\n-        let recover_self_ptr = |this: &mut Self| {\n-            let msg = \"cannot pass `self` by raw pointer\";\n-            let span = this.token.span;\n-            this.struct_span_err(span, msg)\n-                .span_label(span, msg)\n-                .emit();\n-\n-            Ok((SelfKind::Value(Mutability::Immutable), expect_self_ident(this), this.prev_span))\n-        };\n-\n-        // Parse optional `self` parameter of a method.\n-        // Only a limited set of initial token sequences is considered `self` parameters; anything\n-        // else is parsed as a normal function parameter list, so some lookahead is required.\n-        let eself_lo = self.token.span;\n-        let (eself, eself_ident, eself_hi) = match self.token.kind {\n-            token::BinOp(token::And) => {\n-                let eself = if is_isolated_self(self, 1) {\n-                    // `&self`\n-                    self.bump();\n-                    SelfKind::Region(None, Mutability::Immutable)\n-                } else if is_isolated_mut_self(self, 1) {\n-                    // `&mut self`\n-                    self.bump();\n-                    self.bump();\n-                    SelfKind::Region(None, Mutability::Mutable)\n-                } else if self.look_ahead(1, |t| t.is_lifetime()) && is_isolated_self(self, 2) {\n-                    // `&'lt self`\n-                    self.bump();\n-                    let lt = self.expect_lifetime();\n-                    SelfKind::Region(Some(lt), Mutability::Immutable)\n-                } else if self.look_ahead(1, |t| t.is_lifetime()) && is_isolated_mut_self(self, 2) {\n-                    // `&'lt mut self`\n-                    self.bump();\n-                    let lt = self.expect_lifetime();\n-                    self.bump();\n-                    SelfKind::Region(Some(lt), Mutability::Mutable)\n-                } else {\n-                    // `&not_self`\n-                    return Ok(None);\n-                };\n-                (eself, expect_self_ident(self), self.prev_span)\n-            }\n-            // `*self`\n-            token::BinOp(token::Star) if is_isolated_self(self, 1) => {\n-                self.bump();\n-                recover_self_ptr(self)?\n-            }\n-            // `*mut self` and `*const self`\n-            token::BinOp(token::Star) if\n-                self.look_ahead(1, |t| t.is_mutability())\n-                && is_isolated_self(self, 2) =>\n-            {\n-                self.bump();\n-                self.bump();\n-                recover_self_ptr(self)?\n-            }\n-            // `self` and `self: TYPE`\n-            token::Ident(..) if is_isolated_self(self, 0) => {\n-                parse_self_possibly_typed(self, Mutability::Immutable)?\n-            }\n-            // `mut self` and `mut self: TYPE`\n-            token::Ident(..) if is_isolated_mut_self(self, 0) => {\n-                self.bump();\n-                parse_self_possibly_typed(self, Mutability::Mutable)?\n-            }\n-            _ => return Ok(None),\n-        };\n-\n-        let eself = source_map::respan(eself_lo.to(eself_hi), eself);\n-        Ok(Some(Param::from_self(ThinVec::default(), eself, eself_ident)))\n-    }\n-\n-    fn is_named_param(&self) -> bool {\n-        let offset = match self.token.kind {\n-            token::Interpolated(ref nt) => match **nt {\n-                token::NtPat(..) => return self.look_ahead(1, |t| t == &token::Colon),\n-                _ => 0,\n-            }\n-            token::BinOp(token::And) | token::AndAnd => 1,\n-            _ if self.token.is_keyword(kw::Mut) => 1,\n-            _ => 0,\n-        };\n-\n-        self.look_ahead(offset, |t| t.is_ident()) &&\n-        self.look_ahead(offset + 1, |t| t == &token::Colon)\n-    }\n-\n     fn is_crate_vis(&self) -> bool {\n         self.token.is_keyword(kw::Crate) && self.look_ahead(1, |t| t != &token::ModSep)\n     }"}, {"sha": "08c624b5539d153ad7ad08556fef72911548ec1a", "filename": "src/libsyntax/parse/parser/item.rs", "status": "modified", "additions": 485, "deletions": 205, "changes": 690, "blob_url": "https://github.com/rust-lang/rust/blob/66e428824b133078faa187b1f6f0546e2211de16/src%2Flibsyntax%2Fparse%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66e428824b133078faa187b1f6f0546e2211de16/src%2Flibsyntax%2Fparse%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser%2Fitem.rs?ref=66e428824b133078faa187b1f6f0546e2211de16", "patch": "@@ -1,28 +1,23 @@\n-use super::{Parser, PResult, PathStyle, SemiColonMode, BlockMode, ParamCfg};\n-\n+use super::{Parser, PResult, PathStyle, SemiColonMode, BlockMode};\n use crate::maybe_whole;\n use crate::ptr::P;\n-use crate::ast::{\n-    self, DUMMY_NODE_ID, Ident, Attribute, AttrStyle,\n-    Item, ItemKind, ImplItem, ImplItemKind, TraitItem, TraitItemKind,\n-    UseTree, UseTreeKind, PathSegment,\n-    IsAuto, Constness, IsAsync, Unsafety, Defaultness,\n-    Visibility, VisibilityKind, Mutability, FnDecl, FnHeader, MethodSig, Block,\n-    ForeignItem, ForeignItemKind,\n-    Ty, TyKind, Generics, GenericBounds, TraitRef,\n-    EnumDef, VariantData, StructField, AnonConst,\n-    Mac, MacDelimiter,\n-};\n+use crate::ast::{self, DUMMY_NODE_ID, Ident, Attribute, AttrStyle, AnonConst, Item, ItemKind};\n+use crate::ast::{ImplItem, ImplItemKind, TraitItem, TraitItemKind, UseTree, UseTreeKind};\n+use crate::ast::{PathSegment, IsAuto, Constness, IsAsync, Unsafety, Defaultness};\n+use crate::ast::{Visibility, VisibilityKind, Mutability, FnHeader, ForeignItem, ForeignItemKind};\n+use crate::ast::{Ty, TyKind, Generics, GenericBounds, TraitRef, EnumDef, VariantData, StructField};\n+use crate::ast::{Mac, MacDelimiter, Block, BindingMode, FnDecl, MethodSig, SelfKind, Param};\n use crate::ext::base::DummyResult;\n use crate::parse::token;\n use crate::parse::parser::maybe_append;\n-use crate::parse::diagnostics::Error;\n+use crate::parse::diagnostics::{Error, dummy_arg};\n use crate::tokenstream::{TokenTree, TokenStream};\n-use crate::source_map::{respan, Span};\n use crate::symbol::{kw, sym};\n+use crate::source_map::{self, respan, Span};\n+use crate::ThinVec;\n \n-use std::mem;\n use log::debug;\n+use std::mem;\n use rustc_target::spec::abi::Abi;\n use errors::{Applicability, DiagnosticBuilder, DiagnosticId, StashKey};\n \n@@ -412,7 +407,7 @@ impl<'a> Parser<'a> {\n         self.parse_macro_use_or_failure(attrs, macros_allowed, attributes_allowed, lo, vis)\n     }\n \n-    fn mk_item_with_info(\n+    pub(super) fn mk_item_with_info(\n         &self,\n         attrs: Vec<Attribute>,\n         lo: Span,\n@@ -425,16 +420,6 @@ impl<'a> Parser<'a> {\n         Ok(Some(self.mk_item(span, ident, item, vis, attrs)))\n     }\n \n-    fn recover_first_param(&mut self) -> &'static str {\n-        match self.parse_outer_attributes()\n-            .and_then(|_| self.parse_self_param())\n-            .map_err(|mut e| e.cancel())\n-        {\n-            Ok(Some(_)) => \"method\",\n-            _ => \"function\",\n-        }\n-    }\n-\n     /// This is the fall-through for parsing items.\n     fn parse_macro_use_or_failure(\n         &mut self,\n@@ -707,9 +692,11 @@ impl<'a> Parser<'a> {\n         Ok(item)\n     }\n \n-    fn parse_impl_item_(&mut self,\n-                        at_end: &mut bool,\n-                        mut attrs: Vec<Attribute>) -> PResult<'a, ImplItem> {\n+    fn parse_impl_item_(\n+        &mut self,\n+        at_end: &mut bool,\n+        mut attrs: Vec<Attribute>,\n+    ) -> PResult<'a, ImplItem> {\n         let lo = self.token.span;\n         let vis = self.parse_visibility(false)?;\n         let defaultness = self.parse_defaultness();\n@@ -722,8 +709,11 @@ impl<'a> Parser<'a> {\n             (name, kind, generics)\n         } else if self.is_const_item() {\n             self.parse_impl_const()?\n+        } else if let Some(mac) = self.parse_assoc_macro_invoc(\"impl\", Some(&vis), at_end)? {\n+            // FIXME: code copied from `parse_macro_use_or_failure` -- use abstraction!\n+            (Ident::invalid(), ast::ImplItemKind::Macro(mac), Generics::default())\n         } else {\n-            let (name, inner_attrs, generics, kind) = self.parse_impl_method(&vis, at_end)?;\n+            let (name, inner_attrs, generics, kind) = self.parse_impl_method(at_end)?;\n             attrs.extend(inner_attrs);\n             (name, kind, generics)\n         };\n@@ -783,71 +773,6 @@ impl<'a> Parser<'a> {\n         Ok((name, ImplItemKind::Const(typ, expr), Generics::default()))\n     }\n \n-    /// Parses a method or a macro invocation in a trait impl.\n-    fn parse_impl_method(\n-        &mut self,\n-        vis: &Visibility,\n-        at_end: &mut bool\n-    ) -> PResult<'a, (Ident, Vec<Attribute>, Generics, ImplItemKind)> {\n-        // FIXME: code copied from `parse_macro_use_or_failure` -- use abstraction!\n-        if let Some(mac) = self.parse_assoc_macro_invoc(\"impl\", Some(vis), at_end)? {\n-            // method macro\n-            Ok((Ident::invalid(), vec![], Generics::default(), ast::ImplItemKind::Macro(mac)))\n-        } else {\n-            let (ident, sig, generics) = self.parse_method_sig(|_| true)?;\n-            *at_end = true;\n-            let (inner_attrs, body) = self.parse_inner_attrs_and_block()?;\n-            Ok((ident, inner_attrs, generics, ast::ImplItemKind::Method(sig, body)))\n-        }\n-    }\n-\n-    /// Parse the \"signature\", including the identifier, parameters, and generics\n-    /// of a method. The body is not parsed as that differs between `trait`s and `impl`s.\n-    fn parse_method_sig(\n-        &mut self,\n-        is_name_required: fn(&token::Token) -> bool,\n-    ) -> PResult<'a, (Ident, MethodSig, Generics)> {\n-        let header = self.parse_fn_front_matter()?;\n-        let (ident, decl, generics) = self.parse_fn_sig(ParamCfg {\n-            is_self_allowed: true,\n-            allow_c_variadic: false,\n-            is_name_required,\n-        })?;\n-        Ok((ident, MethodSig { header, decl }, generics))\n-    }\n-\n-    /// Parses all the \"front matter\" for a `fn` declaration, up to\n-    /// and including the `fn` keyword:\n-    ///\n-    /// - `const fn`\n-    /// - `unsafe fn`\n-    /// - `const unsafe fn`\n-    /// - `extern fn`\n-    /// - etc.\n-    fn parse_fn_front_matter(&mut self) -> PResult<'a, FnHeader> {\n-        let is_const_fn = self.eat_keyword(kw::Const);\n-        let const_span = self.prev_span;\n-        let asyncness = self.parse_asyncness();\n-        if let IsAsync::Async { .. } = asyncness {\n-            self.ban_async_in_2015(self.prev_span);\n-        }\n-        let asyncness = respan(self.prev_span, asyncness);\n-        let unsafety = self.parse_unsafety();\n-        let (constness, unsafety, abi) = if is_const_fn {\n-            (respan(const_span, Constness::Const), unsafety, Abi::Rust)\n-        } else {\n-            let abi = self.parse_extern_abi()?;\n-            (respan(self.prev_span, Constness::NotConst), unsafety, abi)\n-        };\n-        if !self.eat_keyword(kw::Fn) {\n-            // It is possible for `expect_one_of` to recover given the contents of\n-            // `self.expected_tokens`, therefore, do not use `self.unexpected()` which doesn't\n-            // account for this.\n-            if !self.expect_one_of(&[], &[])? { unreachable!() }\n-        }\n-        Ok(FnHeader { constness, unsafety, asyncness, abi })\n-    }\n-\n     /// Parses `auto? trait Foo { ... }` or `trait Foo = Bar;`.\n     fn parse_item_trait(&mut self, unsafety: Unsafety) -> PResult<'a, ItemInfo> {\n         // Parse optional `auto` prefix.\n@@ -957,13 +882,7 @@ impl<'a> Parser<'a> {\n             // trait item macro.\n             (Ident::invalid(), TraitItemKind::Macro(mac), Generics::default())\n         } else {\n-            // This is somewhat dubious; We don't want to allow\n-            // argument names to be left off if there is a definition...\n-            //\n-            // We don't allow argument names to be left off in edition 2018.\n-            let (ident, sig, generics) = self.parse_method_sig(|t| t.span.rust_2018())?;\n-            let body = self.parse_trait_method_body(at_end, &mut attrs)?;\n-            (ident, TraitItemKind::Method(sig, body), generics)\n+            self.parse_trait_item_method(at_end, &mut attrs)?\n         };\n \n         Ok(TraitItem {\n@@ -991,43 +910,6 @@ impl<'a> Parser<'a> {\n         Ok((ident, TraitItemKind::Const(ty, default), Generics::default()))\n     }\n \n-    /// Parse the \"body\" of a method in a trait item definition.\n-    /// This can either be `;` when there's no body,\n-    /// or e.g. a block when the method is a provided one.\n-    fn parse_trait_method_body(\n-        &mut self,\n-        at_end: &mut bool,\n-        attrs: &mut Vec<Attribute>,\n-    ) -> PResult<'a, Option<P<Block>>> {\n-        Ok(match self.token.kind {\n-            token::Semi => {\n-                debug!(\"parse_trait_method_body(): parsing required method\");\n-                self.bump();\n-                *at_end = true;\n-                None\n-            }\n-            token::OpenDelim(token::Brace) => {\n-                debug!(\"parse_trait_method_body(): parsing provided method\");\n-                *at_end = true;\n-                let (inner_attrs, body) = self.parse_inner_attrs_and_block()?;\n-                attrs.extend(inner_attrs.iter().cloned());\n-                Some(body)\n-            }\n-            token::Interpolated(ref nt) => {\n-                match **nt {\n-                    token::NtBlock(..) => {\n-                        *at_end = true;\n-                        let (inner_attrs, body) = self.parse_inner_attrs_and_block()?;\n-                        attrs.extend(inner_attrs.iter().cloned());\n-                        Some(body)\n-                    }\n-                    _ => return self.expected_semi_or_open_brace(),\n-                }\n-            }\n-            _ => return self.expected_semi_or_open_brace(),\n-        })\n-    }\n-\n     /// Parses the following grammar:\n     ///\n     ///     TraitItemAssocTy = Ident [\"<\"...\">\"] [\":\" [GenericBounds]] [\"where\" ...] [\"=\" Ty]\n@@ -1194,45 +1076,6 @@ impl<'a> Parser<'a> {\n         Ok(ident)\n     }\n \n-    /// Parses an item-position function declaration.\n-    fn parse_item_fn(\n-        &mut self,\n-        lo: Span,\n-        vis: Visibility,\n-        attrs: Vec<Attribute>,\n-        header: FnHeader,\n-    ) -> PResult<'a, Option<P<Item>>> {\n-        let (ident, decl, generics) = self.parse_fn_sig(ParamCfg {\n-            is_self_allowed: false,\n-            allow_c_variadic: header.abi == Abi::C && header.unsafety == Unsafety::Unsafe,\n-            is_name_required: |_| true,\n-        })?;\n-        let (inner_attrs, body) = self.parse_inner_attrs_and_block()?;\n-        let kind = ItemKind::Fn(decl, header, generics, body);\n-        self.mk_item_with_info(attrs, lo, vis, (ident, kind, Some(inner_attrs)))\n-    }\n-\n-    /// Parse the \"signature\", including the identifier, parameters, and generics of a function.\n-    fn parse_fn_sig(&mut self, cfg: ParamCfg) -> PResult<'a, (Ident, P<FnDecl>, Generics)> {\n-        let ident = self.parse_ident()?;\n-        let mut generics = self.parse_generics()?;\n-        let decl = self.parse_fn_decl(cfg, true)?;\n-        generics.where_clause = self.parse_where_clause()?;\n-        Ok((ident, decl, generics))\n-    }\n-\n-    /// Parses the parameter list and result type of a function declaration.\n-    pub(super) fn parse_fn_decl(\n-        &mut self,\n-        cfg: ParamCfg,\n-        ret_allow_plus: bool,\n-    ) -> PResult<'a, P<FnDecl>> {\n-        Ok(P(FnDecl {\n-            inputs: self.parse_fn_params(cfg)?,\n-            output: self.parse_ret_ty(ret_allow_plus)?,\n-        }))\n-    }\n-\n     /// Parses `extern` for foreign ABIs modules.\n     ///\n     /// `extern` is expected to have been\n@@ -1344,32 +1187,6 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    /// Parses a function declaration from a foreign module.\n-    fn parse_item_foreign_fn(\n-        &mut self,\n-        vis: ast::Visibility,\n-        lo: Span,\n-        attrs: Vec<Attribute>,\n-        extern_sp: Span,\n-    ) -> PResult<'a, ForeignItem> {\n-        self.expect_keyword(kw::Fn)?;\n-        let (ident, decl, generics) = self.parse_fn_sig(super::ParamCfg {\n-            is_self_allowed: false,\n-            allow_c_variadic: true,\n-            is_name_required: |_| true,\n-        })?;\n-        let span = lo.to(self.token.span);\n-        self.parse_semi_or_incorrect_foreign_fn_body(&ident, extern_sp)?;\n-        Ok(ast::ForeignItem {\n-            ident,\n-            attrs,\n-            kind: ForeignItemKind::Fn(decl, generics),\n-            id: DUMMY_NODE_ID,\n-            span,\n-            vis,\n-        })\n-    }\n-\n     /// Parses a static item from a foreign module.\n     /// Assumes that the `static` keyword is already parsed.\n     fn parse_item_foreign_static(&mut self, vis: ast::Visibility, lo: Span, attrs: Vec<Attribute>)\n@@ -1910,3 +1727,466 @@ impl<'a> Parser<'a> {\n         })\n     }\n }\n+\n+/// The parsing configuration used to parse a parameter list (see `parse_fn_params`).\n+pub(super) struct ParamCfg {\n+    /// Is `self` is allowed as the first parameter?\n+    pub is_self_allowed: bool,\n+    /// Is `...` allowed as the tail of the parameter list?\n+    pub allow_c_variadic: bool,\n+    /// `is_name_required` decides if, per-parameter,\n+    /// the parameter must have a pattern or just a type.\n+    pub is_name_required: fn(&token::Token) -> bool,\n+}\n+\n+/// Parsing of functions and methods.\n+impl<'a> Parser<'a> {\n+    /// Parses an item-position function declaration.\n+    fn parse_item_fn(\n+        &mut self,\n+        lo: Span,\n+        vis: Visibility,\n+        attrs: Vec<Attribute>,\n+        header: FnHeader,\n+    ) -> PResult<'a, Option<P<Item>>> {\n+        let (ident, decl, generics) = self.parse_fn_sig(ParamCfg {\n+            is_self_allowed: false,\n+            allow_c_variadic: header.abi == Abi::C && header.unsafety == Unsafety::Unsafe,\n+            is_name_required: |_| true,\n+        })?;\n+        let (inner_attrs, body) = self.parse_inner_attrs_and_block()?;\n+        let kind = ItemKind::Fn(decl, header, generics, body);\n+        self.mk_item_with_info(attrs, lo, vis, (ident, kind, Some(inner_attrs)))\n+    }\n+\n+    /// Parses a function declaration from a foreign module.\n+    fn parse_item_foreign_fn(\n+        &mut self,\n+        vis: ast::Visibility,\n+        lo: Span,\n+        attrs: Vec<Attribute>,\n+        extern_sp: Span,\n+    ) -> PResult<'a, ForeignItem> {\n+        self.expect_keyword(kw::Fn)?;\n+        let (ident, decl, generics) = self.parse_fn_sig(ParamCfg {\n+            is_self_allowed: false,\n+            allow_c_variadic: true,\n+            is_name_required: |_| true,\n+        })?;\n+        let span = lo.to(self.token.span);\n+        self.parse_semi_or_incorrect_foreign_fn_body(&ident, extern_sp)?;\n+        Ok(ast::ForeignItem {\n+            ident,\n+            attrs,\n+            kind: ForeignItemKind::Fn(decl, generics),\n+            id: DUMMY_NODE_ID,\n+            span,\n+            vis,\n+        })\n+    }\n+\n+    /// Parses a method or a macro invocation in a trait impl.\n+    fn parse_impl_method(\n+        &mut self,\n+        at_end: &mut bool,\n+    ) -> PResult<'a, (Ident, Vec<Attribute>, Generics, ImplItemKind)> {\n+        let (ident, sig, generics) = self.parse_method_sig(|_| true)?;\n+        *at_end = true;\n+        let (inner_attrs, body) = self.parse_inner_attrs_and_block()?;\n+        Ok((ident, inner_attrs, generics, ast::ImplItemKind::Method(sig, body)))\n+    }\n+\n+    fn parse_trait_item_method(\n+        &mut self,\n+        at_end: &mut bool,\n+        attrs: &mut Vec<Attribute>,\n+    ) -> PResult<'a, (Ident, TraitItemKind, Generics)> {\n+        // This is somewhat dubious; We don't want to allow\n+        // argument names to be left off if there is a definition...\n+        //\n+        // We don't allow argument names to be left off in edition 2018.\n+        let (ident, sig, generics) = self.parse_method_sig(|t| t.span.rust_2018())?;\n+        let body = self.parse_trait_method_body(at_end, attrs)?;\n+        Ok((ident, TraitItemKind::Method(sig, body), generics))\n+    }\n+\n+    /// Parse the \"body\" of a method in a trait item definition.\n+    /// This can either be `;` when there's no body,\n+    /// or e.g. a block when the method is a provided one.\n+    fn parse_trait_method_body(\n+        &mut self,\n+        at_end: &mut bool,\n+        attrs: &mut Vec<Attribute>,\n+    ) -> PResult<'a, Option<P<Block>>> {\n+        Ok(match self.token.kind {\n+            token::Semi => {\n+                debug!(\"parse_trait_method_body(): parsing required method\");\n+                self.bump();\n+                *at_end = true;\n+                None\n+            }\n+            token::OpenDelim(token::Brace) => {\n+                debug!(\"parse_trait_method_body(): parsing provided method\");\n+                *at_end = true;\n+                let (inner_attrs, body) = self.parse_inner_attrs_and_block()?;\n+                attrs.extend(inner_attrs.iter().cloned());\n+                Some(body)\n+            }\n+            token::Interpolated(ref nt) => {\n+                match **nt {\n+                    token::NtBlock(..) => {\n+                        *at_end = true;\n+                        let (inner_attrs, body) = self.parse_inner_attrs_and_block()?;\n+                        attrs.extend(inner_attrs.iter().cloned());\n+                        Some(body)\n+                    }\n+                    _ => return self.expected_semi_or_open_brace(),\n+                }\n+            }\n+            _ => return self.expected_semi_or_open_brace(),\n+        })\n+    }\n+\n+    /// Parse the \"signature\", including the identifier, parameters, and generics\n+    /// of a method. The body is not parsed as that differs between `trait`s and `impl`s.\n+    fn parse_method_sig(\n+        &mut self,\n+        is_name_required: fn(&token::Token) -> bool,\n+    ) -> PResult<'a, (Ident, MethodSig, Generics)> {\n+        let header = self.parse_fn_front_matter()?;\n+        let (ident, decl, generics) = self.parse_fn_sig(ParamCfg {\n+            is_self_allowed: true,\n+            allow_c_variadic: false,\n+            is_name_required,\n+        })?;\n+        Ok((ident, MethodSig { header, decl }, generics))\n+    }\n+\n+    /// Parses all the \"front matter\" for a `fn` declaration, up to\n+    /// and including the `fn` keyword:\n+    ///\n+    /// - `const fn`\n+    /// - `unsafe fn`\n+    /// - `const unsafe fn`\n+    /// - `extern fn`\n+    /// - etc.\n+    fn parse_fn_front_matter(&mut self) -> PResult<'a, FnHeader> {\n+        let is_const_fn = self.eat_keyword(kw::Const);\n+        let const_span = self.prev_span;\n+        let asyncness = self.parse_asyncness();\n+        if let IsAsync::Async { .. } = asyncness {\n+            self.ban_async_in_2015(self.prev_span);\n+        }\n+        let asyncness = respan(self.prev_span, asyncness);\n+        let unsafety = self.parse_unsafety();\n+        let (constness, unsafety, abi) = if is_const_fn {\n+            (respan(const_span, Constness::Const), unsafety, Abi::Rust)\n+        } else {\n+            let abi = self.parse_extern_abi()?;\n+            (respan(self.prev_span, Constness::NotConst), unsafety, abi)\n+        };\n+        if !self.eat_keyword(kw::Fn) {\n+            // It is possible for `expect_one_of` to recover given the contents of\n+            // `self.expected_tokens`, therefore, do not use `self.unexpected()` which doesn't\n+            // account for this.\n+            if !self.expect_one_of(&[], &[])? { unreachable!() }\n+        }\n+        Ok(FnHeader { constness, unsafety, asyncness, abi })\n+    }\n+\n+    /// Parse the \"signature\", including the identifier, parameters, and generics of a function.\n+    fn parse_fn_sig(&mut self, cfg: ParamCfg) -> PResult<'a, (Ident, P<FnDecl>, Generics)> {\n+        let ident = self.parse_ident()?;\n+        let mut generics = self.parse_generics()?;\n+        let decl = self.parse_fn_decl(cfg, true)?;\n+        generics.where_clause = self.parse_where_clause()?;\n+        Ok((ident, decl, generics))\n+    }\n+\n+    /// Parses the parameter list and result type of a function declaration.\n+    pub(super) fn parse_fn_decl(\n+        &mut self,\n+        cfg: ParamCfg,\n+        ret_allow_plus: bool,\n+    ) -> PResult<'a, P<FnDecl>> {\n+        Ok(P(FnDecl {\n+            inputs: self.parse_fn_params(cfg)?,\n+            output: self.parse_ret_ty(ret_allow_plus)?,\n+        }))\n+    }\n+\n+    /// Parses the parameter list of a function, including the `(` and `)` delimiters.\n+    fn parse_fn_params(&mut self, mut cfg: ParamCfg) -> PResult<'a, Vec<Param>> {\n+        let sp = self.token.span;\n+        let is_trait_item = cfg.is_self_allowed;\n+        let mut c_variadic = false;\n+        // Parse the arguments, starting out with `self` being possibly allowed...\n+        let (params, _) = self.parse_paren_comma_seq(|p| {\n+            let param = p.parse_param_general(&cfg, is_trait_item);\n+            // ...now that we've parsed the first argument, `self` is no longer allowed.\n+            cfg.is_self_allowed = false;\n+\n+            match param {\n+                Ok(param) => Ok(\n+                    if let TyKind::CVarArgs = param.ty.kind {\n+                        c_variadic = true;\n+                        if p.token != token::CloseDelim(token::Paren) {\n+                            p.span_err(\n+                                p.token.span,\n+                                \"`...` must be the last argument of a C-variadic function\",\n+                            );\n+                            // FIXME(eddyb) this should probably still push `CVarArgs`.\n+                            // Maybe AST validation/HIR lowering should emit the above error?\n+                            None\n+                        } else {\n+                            Some(param)\n+                        }\n+                    } else {\n+                        Some(param)\n+                    }\n+                ),\n+                Err(mut e) => {\n+                    e.emit();\n+                    let lo = p.prev_span;\n+                    // Skip every token until next possible arg or end.\n+                    p.eat_to_tokens(&[&token::Comma, &token::CloseDelim(token::Paren)]);\n+                    // Create a placeholder argument for proper arg count (issue #34264).\n+                    let span = lo.to(p.prev_span);\n+                    Ok(Some(dummy_arg(Ident::new(kw::Invalid, span))))\n+                }\n+            }\n+        })?;\n+\n+        let mut params: Vec<_> = params.into_iter().filter_map(|x| x).collect();\n+\n+        // Replace duplicated recovered params with `_` pattern to avoid unecessary errors.\n+        self.deduplicate_recovered_params_names(&mut params);\n+\n+        if c_variadic && params.len() <= 1 {\n+            self.span_err(\n+                sp,\n+                \"C-variadic function must be declared with at least one named argument\",\n+            );\n+        }\n+\n+        Ok(params)\n+    }\n+\n+    /// Skips unexpected attributes and doc comments in this position and emits an appropriate\n+    /// error.\n+    /// This version of parse param doesn't necessarily require identifier names.\n+    fn parse_param_general(&mut self, cfg: &ParamCfg, is_trait_item: bool) -> PResult<'a, Param> {\n+        let lo = self.token.span;\n+        let attrs = self.parse_outer_attributes()?;\n+\n+        // Possibly parse `self`. Recover if we parsed it and it wasn't allowed here.\n+        if let Some(mut param) = self.parse_self_param()? {\n+            param.attrs = attrs.into();\n+            return if cfg.is_self_allowed {\n+                Ok(param)\n+            } else {\n+                self.recover_bad_self_param(param, is_trait_item)\n+            };\n+        }\n+\n+        let is_name_required = match self.token.kind {\n+            token::DotDotDot => false,\n+            _ => (cfg.is_name_required)(&self.token),\n+        };\n+        let (pat, ty) = if is_name_required || self.is_named_param() {\n+            debug!(\"parse_param_general parse_pat (is_name_required:{})\", is_name_required);\n+\n+            let pat = self.parse_fn_param_pat()?;\n+            if let Err(mut err) = self.expect(&token::Colon) {\n+                return if let Some(ident) = self.parameter_without_type(\n+                    &mut err,\n+                    pat,\n+                    is_name_required,\n+                    cfg.is_self_allowed,\n+                    is_trait_item,\n+                ) {\n+                    err.emit();\n+                    Ok(dummy_arg(ident))\n+                } else {\n+                    Err(err)\n+                };\n+            }\n+\n+            self.eat_incorrect_doc_comment_for_param_type();\n+            (pat, self.parse_ty_common(true, true, cfg.allow_c_variadic)?)\n+        } else {\n+            debug!(\"parse_param_general ident_to_pat\");\n+            let parser_snapshot_before_ty = self.clone();\n+            self.eat_incorrect_doc_comment_for_param_type();\n+            let mut ty = self.parse_ty_common(true, true, cfg.allow_c_variadic);\n+            if ty.is_ok() && self.token != token::Comma &&\n+               self.token != token::CloseDelim(token::Paren) {\n+                // This wasn't actually a type, but a pattern looking like a type,\n+                // so we are going to rollback and re-parse for recovery.\n+                ty = self.unexpected();\n+            }\n+            match ty {\n+                Ok(ty) => {\n+                    let ident = Ident::new(kw::Invalid, self.prev_span);\n+                    let bm = BindingMode::ByValue(Mutability::Immutable);\n+                    let pat = self.mk_pat_ident(ty.span, bm, ident);\n+                    (pat, ty)\n+                }\n+                // If this is a C-variadic argument and we hit an error, return the error.\n+                Err(err) if self.token == token::DotDotDot => return Err(err),\n+                // Recover from attempting to parse the argument as a type without pattern.\n+                Err(mut err) => {\n+                    err.cancel();\n+                    mem::replace(self, parser_snapshot_before_ty);\n+                    self.recover_arg_parse()?\n+                }\n+            }\n+        };\n+\n+        let span = lo.to(self.token.span);\n+\n+        Ok(Param {\n+            attrs: attrs.into(),\n+            id: ast::DUMMY_NODE_ID,\n+            is_placeholder: false,\n+            pat,\n+            span,\n+            ty,\n+        })\n+    }\n+\n+    /// Returns the parsed optional self parameter and whether a self shortcut was used.\n+    ///\n+    /// See `parse_self_param_with_attrs` to collect attributes.\n+    fn parse_self_param(&mut self) -> PResult<'a, Option<Param>> {\n+        // Extract an identifier *after* having confirmed that the token is one.\n+        let expect_self_ident = |this: &mut Self| {\n+            match this.token.kind {\n+                // Preserve hygienic context.\n+                token::Ident(name, _) => {\n+                    let span = this.token.span;\n+                    this.bump();\n+                    Ident::new(name, span)\n+                }\n+                _ => unreachable!(),\n+            }\n+        };\n+        // Is `self` `n` tokens ahead?\n+        let is_isolated_self = |this: &Self, n| {\n+            this.is_keyword_ahead(n, &[kw::SelfLower])\n+            && this.look_ahead(n + 1, |t| t != &token::ModSep)\n+        };\n+        // Is `mut self` `n` tokens ahead?\n+        let is_isolated_mut_self = |this: &Self, n| {\n+            this.is_keyword_ahead(n, &[kw::Mut])\n+            && is_isolated_self(this, n + 1)\n+        };\n+        // Parse `self` or `self: TYPE`. We already know the current token is `self`.\n+        let parse_self_possibly_typed = |this: &mut Self, m| {\n+            let eself_ident = expect_self_ident(this);\n+            let eself_hi = this.prev_span;\n+            let eself = if this.eat(&token::Colon) {\n+                SelfKind::Explicit(this.parse_ty()?, m)\n+            } else {\n+                SelfKind::Value(m)\n+            };\n+            Ok((eself, eself_ident, eself_hi))\n+        };\n+        // Recover for the grammar `*self`, `*const self`, and `*mut self`.\n+        let recover_self_ptr = |this: &mut Self| {\n+            let msg = \"cannot pass `self` by raw pointer\";\n+            let span = this.token.span;\n+            this.struct_span_err(span, msg)\n+                .span_label(span, msg)\n+                .emit();\n+\n+            Ok((SelfKind::Value(Mutability::Immutable), expect_self_ident(this), this.prev_span))\n+        };\n+\n+        // Parse optional `self` parameter of a method.\n+        // Only a limited set of initial token sequences is considered `self` parameters; anything\n+        // else is parsed as a normal function parameter list, so some lookahead is required.\n+        let eself_lo = self.token.span;\n+        let (eself, eself_ident, eself_hi) = match self.token.kind {\n+            token::BinOp(token::And) => {\n+                let eself = if is_isolated_self(self, 1) {\n+                    // `&self`\n+                    self.bump();\n+                    SelfKind::Region(None, Mutability::Immutable)\n+                } else if is_isolated_mut_self(self, 1) {\n+                    // `&mut self`\n+                    self.bump();\n+                    self.bump();\n+                    SelfKind::Region(None, Mutability::Mutable)\n+                } else if self.look_ahead(1, |t| t.is_lifetime()) && is_isolated_self(self, 2) {\n+                    // `&'lt self`\n+                    self.bump();\n+                    let lt = self.expect_lifetime();\n+                    SelfKind::Region(Some(lt), Mutability::Immutable)\n+                } else if self.look_ahead(1, |t| t.is_lifetime()) && is_isolated_mut_self(self, 2) {\n+                    // `&'lt mut self`\n+                    self.bump();\n+                    let lt = self.expect_lifetime();\n+                    self.bump();\n+                    SelfKind::Region(Some(lt), Mutability::Mutable)\n+                } else {\n+                    // `&not_self`\n+                    return Ok(None);\n+                };\n+                (eself, expect_self_ident(self), self.prev_span)\n+            }\n+            // `*self`\n+            token::BinOp(token::Star) if is_isolated_self(self, 1) => {\n+                self.bump();\n+                recover_self_ptr(self)?\n+            }\n+            // `*mut self` and `*const self`\n+            token::BinOp(token::Star) if\n+                self.look_ahead(1, |t| t.is_mutability())\n+                && is_isolated_self(self, 2) =>\n+            {\n+                self.bump();\n+                self.bump();\n+                recover_self_ptr(self)?\n+            }\n+            // `self` and `self: TYPE`\n+            token::Ident(..) if is_isolated_self(self, 0) => {\n+                parse_self_possibly_typed(self, Mutability::Immutable)?\n+            }\n+            // `mut self` and `mut self: TYPE`\n+            token::Ident(..) if is_isolated_mut_self(self, 0) => {\n+                self.bump();\n+                parse_self_possibly_typed(self, Mutability::Mutable)?\n+            }\n+            _ => return Ok(None),\n+        };\n+\n+        let eself = source_map::respan(eself_lo.to(eself_hi), eself);\n+        Ok(Some(Param::from_self(ThinVec::default(), eself, eself_ident)))\n+    }\n+\n+    fn is_named_param(&self) -> bool {\n+        let offset = match self.token.kind {\n+            token::Interpolated(ref nt) => match **nt {\n+                token::NtPat(..) => return self.look_ahead(1, |t| t == &token::Colon),\n+                _ => 0,\n+            }\n+            token::BinOp(token::And) | token::AndAnd => 1,\n+            _ if self.token.is_keyword(kw::Mut) => 1,\n+            _ => 0,\n+        };\n+\n+        self.look_ahead(offset, |t| t.is_ident()) &&\n+        self.look_ahead(offset + 1, |t| t == &token::Colon)\n+    }\n+\n+    fn recover_first_param(&mut self) -> &'static str {\n+        match self.parse_outer_attributes()\n+            .and_then(|_| self.parse_self_param())\n+            .map_err(|mut e| e.cancel())\n+        {\n+            Ok(Some(_)) => \"method\",\n+            _ => \"function\",\n+        }\n+    }\n+}"}, {"sha": "e696ab0804d6929f0e6c4215f52ddc1267476323", "filename": "src/libsyntax/parse/parser/ty.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/66e428824b133078faa187b1f6f0546e2211de16/src%2Flibsyntax%2Fparse%2Fparser%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66e428824b133078faa187b1f6f0546e2211de16/src%2Flibsyntax%2Fparse%2Fparser%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser%2Fty.rs?ref=66e428824b133078faa187b1f6f0546e2211de16", "patch": "@@ -1,4 +1,5 @@\n use super::{Parser, PResult, PathStyle, PrevTokenKind, TokenType};\n+use super::item::ParamCfg;\n \n use crate::{maybe_whole, maybe_recover_from_interpolated_ty_qpath};\n use crate::ptr::P;\n@@ -281,7 +282,7 @@ impl<'a> Parser<'a> {\n         let unsafety = self.parse_unsafety();\n         let abi = self.parse_extern_abi()?;\n         self.expect_keyword(kw::Fn)?;\n-        let cfg = super::ParamCfg {\n+        let cfg = ParamCfg {\n             is_self_allowed: false,\n             allow_c_variadic: true,\n             is_name_required: |_| false,"}]}