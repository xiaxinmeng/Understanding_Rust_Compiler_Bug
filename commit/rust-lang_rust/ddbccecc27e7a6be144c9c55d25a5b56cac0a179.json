{"sha": "ddbccecc27e7a6be144c9c55d25a5b56cac0a179", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRkYmNjZWNjMjdlN2E2YmUxNDRjOWM1NWQyNWE1YjU2Y2FjMGExNzk=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-06-27T00:00:29Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-06-27T00:00:42Z"}, "message": "std::rt: Some cleanup", "tree": {"sha": "c437cab1044beb6c3605cd0c35eacd3770b0c5da", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c437cab1044beb6c3605cd0c35eacd3770b0c5da"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ddbccecc27e7a6be144c9c55d25a5b56cac0a179", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ddbccecc27e7a6be144c9c55d25a5b56cac0a179", "html_url": "https://github.com/rust-lang/rust/commit/ddbccecc27e7a6be144c9c55d25a5b56cac0a179", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ddbccecc27e7a6be144c9c55d25a5b56cac0a179/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e65d0cbabebc73f2c9733a7ed158576c9702e71e", "url": "https://api.github.com/repos/rust-lang/rust/commits/e65d0cbabebc73f2c9733a7ed158576c9702e71e", "html_url": "https://github.com/rust-lang/rust/commit/e65d0cbabebc73f2c9733a7ed158576c9702e71e"}], "stats": {"total": 38, "additions": 18, "deletions": 20}, "files": [{"sha": "97a0285ea196e55fa435207fc749a07317e62935", "filename": "src/libstd/rt/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ddbccecc27e7a6be144c9c55d25a5b56cac0a179/src%2Flibstd%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddbccecc27e7a6be144c9c55d25a5b56cac0a179/src%2Flibstd%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmod.rs?ref=ddbccecc27e7a6be144c9c55d25a5b56cac0a179", "patch": "@@ -267,11 +267,10 @@ pub fn run(main: ~fn()) -> int {\n     };\n \n     // Create and enqueue the main task.\n-    let main_cell = Cell::new(main);\n     let mut new_task = ~Task::new_root();\n     new_task.on_exit = Some(on_exit);\n     let main_task = ~Coroutine::with_task(&mut scheds[0].stack_pool,\n-                                          new_task, main_cell.take());\n+                                          new_task, main);\n     scheds[0].enqueue_task(main_task);\n \n     // Run each scheduler in a thread."}, {"sha": "26956c49a629a59cf294fa60a8544465386d6982", "filename": "src/libstd/rt/sched.rs", "status": "modified", "additions": 17, "deletions": 18, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/ddbccecc27e7a6be144c9c55d25a5b56cac0a179/src%2Flibstd%2Frt%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddbccecc27e7a6be144c9c55d25a5b56cac0a179/src%2Flibstd%2Frt%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fsched.rs?ref=ddbccecc27e7a6be144c9c55d25a5b56cac0a179", "patch": "@@ -177,7 +177,7 @@ impl Scheduler {\n \n         rtdebug!(\"run taking sched\");\n         let sched = Local::take::<Scheduler>();\n-        // XXX: Reenable this once we're using a per-task queue. With a shared\n+        // XXX: Reenable this once we're using a per-scheduler queue. With a shared\n         // queue this is not true\n         //assert!(sched.work_queue.is_empty());\n         rtdebug!(\"scheduler metrics: %s\\n\", {\n@@ -213,29 +213,29 @@ impl Scheduler {\n         if sched.resume_task_from_queue() {\n             // We performed a scheduling action. There may be other work\n             // to do yet, so let's try again later.\n-            let mut sched = Local::take::<Scheduler>();\n-            sched.metrics.tasks_resumed_from_queue += 1;\n-            sched.event_loop.callback(Scheduler::run_sched_once);\n-            Local::put(sched);\n+            do Local::borrow::<Scheduler, ()> |sched| {\n+                sched.metrics.tasks_resumed_from_queue += 1;\n+                sched.event_loop.callback(Scheduler::run_sched_once);\n+            }\n             return;\n         }\n \n         // If we got here then there was no work to do.\n         // Generate a SchedHandle and push it to the sleeper list so\n         // somebody can wake us up later.\n         rtdebug!(\"no work to do\");\n-        let mut sched = Local::take::<Scheduler>();\n-        sched.metrics.wasted_turns += 1;\n-        if !sched.sleepy && !sched.no_sleep {\n-            rtdebug!(\"sleeping\");\n-            sched.metrics.sleepy_times += 1;\n-            sched.sleepy = true;\n-            let handle = sched.make_handle();\n-            sched.sleeper_list.push(handle);\n-        } else {\n-            rtdebug!(\"not sleeping\");\n+        do Local::borrow::<Scheduler, ()> |sched| {\n+            sched.metrics.wasted_turns += 1;\n+            if !sched.sleepy && !sched.no_sleep {\n+                rtdebug!(\"sleeping\");\n+                sched.metrics.sleepy_times += 1;\n+                sched.sleepy = true;\n+                let handle = sched.make_handle();\n+                sched.sleeper_list.push(handle);\n+            } else {\n+                rtdebug!(\"not sleeping\");\n+            }\n         }\n-        Local::put(sched);\n     }\n \n     pub fn make_handle(&mut self) -> SchedHandle {\n@@ -462,8 +462,7 @@ impl Scheduler {\n             // here we know we are home, execute now OR we know we\n             // aren't homed, and that this sched doesn't care\n             do this.switch_running_tasks_and_then(task) |sched, last_task| {\n-                let last_task = Cell::new(last_task);\n-                sched.enqueue_task(last_task.take());\n+                sched.enqueue_task(last_task);\n             }\n         } else if !homed && !this.run_anything {\n             // the task isn't homed, but it can't be run here"}]}