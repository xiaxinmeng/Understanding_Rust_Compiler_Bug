{"sha": "86f89d9b31fc7e4fd9300570e6b6304c749caa6c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg2Zjg5ZDliMzFmYzdlNGZkOTMwMDU3MGU2YjYzMDRjNzQ5Y2FhNmM=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-08-13T20:41:55Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-08-13T20:41:55Z"}, "message": "Remove Hygiene from completion", "tree": {"sha": "a155074dd0b2cdbaf207025a30ce66c6780f4c65", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a155074dd0b2cdbaf207025a30ce66c6780f4c65"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/86f89d9b31fc7e4fd9300570e6b6304c749caa6c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/86f89d9b31fc7e4fd9300570e6b6304c749caa6c", "html_url": "https://github.com/rust-lang/rust/commit/86f89d9b31fc7e4fd9300570e6b6304c749caa6c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/86f89d9b31fc7e4fd9300570e6b6304c749caa6c/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3d6fd620e80050d68e6da55aabad2ca780ba2323", "url": "https://api.github.com/repos/rust-lang/rust/commits/3d6fd620e80050d68e6da55aabad2ca780ba2323", "html_url": "https://github.com/rust-lang/rust/commit/3d6fd620e80050d68e6da55aabad2ca780ba2323"}], "stats": {"total": 124, "additions": 65, "deletions": 59}, "files": [{"sha": "22ada3cf2937d69666f1657c49a2e8444c9f8019", "filename": "crates/ide/src/completion/complete_keyword.rs", "status": "modified", "additions": 10, "deletions": 19, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/86f89d9b31fc7e4fd9300570e6b6304c749caa6c/crates%2Fide%2Fsrc%2Fcompletion%2Fcomplete_keyword.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86f89d9b31fc7e4fd9300570e6b6304c749caa6c/crates%2Fide%2Fsrc%2Fcompletion%2Fcomplete_keyword.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fcompletion%2Fcomplete_keyword.rs?ref=86f89d9b31fc7e4fd9300570e6b6304c749caa6c", "patch": "@@ -10,30 +10,21 @@ use crate::completion::{\n pub(super) fn complete_use_tree_keyword(acc: &mut Completions, ctx: &CompletionContext) {\n     // complete keyword \"crate\" in use stmt\n     let source_range = ctx.source_range();\n-    match (ctx.use_item_syntax.as_ref(), ctx.path_prefix.as_ref()) {\n-        (Some(_), None) => {\n+\n+    if ctx.use_item_syntax.is_some() {\n+        if ctx.path_qual.is_none() {\n             CompletionItem::new(CompletionKind::Keyword, source_range, \"crate::\")\n                 .kind(CompletionItemKind::Keyword)\n                 .insert_text(\"crate::\")\n                 .add_to(acc);\n-            CompletionItem::new(CompletionKind::Keyword, source_range, \"self\")\n-                .kind(CompletionItemKind::Keyword)\n-                .add_to(acc);\n-            CompletionItem::new(CompletionKind::Keyword, source_range, \"super::\")\n-                .kind(CompletionItemKind::Keyword)\n-                .insert_text(\"super::\")\n-                .add_to(acc);\n-        }\n-        (Some(_), Some(_)) => {\n-            CompletionItem::new(CompletionKind::Keyword, source_range, \"self\")\n-                .kind(CompletionItemKind::Keyword)\n-                .add_to(acc);\n-            CompletionItem::new(CompletionKind::Keyword, source_range, \"super::\")\n-                .kind(CompletionItemKind::Keyword)\n-                .insert_text(\"super::\")\n-                .add_to(acc);\n         }\n-        _ => {}\n+        CompletionItem::new(CompletionKind::Keyword, source_range, \"self\")\n+            .kind(CompletionItemKind::Keyword)\n+            .add_to(acc);\n+        CompletionItem::new(CompletionKind::Keyword, source_range, \"super::\")\n+            .kind(CompletionItemKind::Keyword)\n+            .insert_text(\"super::\")\n+            .add_to(acc);\n     }\n \n     // Suggest .await syntax for types that implement Future trait"}, {"sha": "74794dc88bf52ed79d208061d6a1642ac1c55cc7", "filename": "crates/ide/src/completion/complete_qualified_path.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/86f89d9b31fc7e4fd9300570e6b6304c749caa6c/crates%2Fide%2Fsrc%2Fcompletion%2Fcomplete_qualified_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86f89d9b31fc7e4fd9300570e6b6304c749caa6c/crates%2Fide%2Fsrc%2Fcompletion%2Fcomplete_qualified_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fcompletion%2Fcomplete_qualified_path.rs?ref=86f89d9b31fc7e4fd9300570e6b6304c749caa6c", "patch": "@@ -8,7 +8,7 @@ use test_utils::mark;\n use crate::completion::{CompletionContext, Completions};\n \n pub(super) fn complete_qualified_path(acc: &mut Completions, ctx: &CompletionContext) {\n-    let path = match &ctx.path_prefix {\n+    let path = match &ctx.path_qual {\n         Some(path) => path.clone(),\n         None => return,\n     };\n@@ -19,7 +19,7 @@ pub(super) fn complete_qualified_path(acc: &mut Completions, ctx: &CompletionCon\n \n     let context_module = ctx.scope.module();\n \n-    let resolution = match ctx.scope.resolve_hir_path_qualifier(&path) {\n+    let resolution = match ctx.sema.resolve_path(&path) {\n         Some(res) => res,\n         None => return,\n     };"}, {"sha": "3857dce6721b106cf838f43999342e66768526e2", "filename": "crates/ide/src/completion/completion_context.rs", "status": "modified", "additions": 53, "deletions": 38, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/86f89d9b31fc7e4fd9300570e6b6304c749caa6c/crates%2Fide%2Fsrc%2Fcompletion%2Fcompletion_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86f89d9b31fc7e4fd9300570e6b6304c749caa6c/crates%2Fide%2Fsrc%2Fcompletion%2Fcompletion_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fcompletion%2Fcompletion_context.rs?ref=86f89d9b31fc7e4fd9300570e6b6304c749caa6c", "patch": "@@ -56,7 +56,7 @@ pub(crate) struct CompletionContext<'a> {\n     /// A single-indent path, like `foo`. `::foo` should not be considered a trivial path.\n     pub(super) is_trivial_path: bool,\n     /// If not a trivial path, the prefix (qualifier).\n-    pub(super) path_prefix: Option<hir::Path>,\n+    pub(super) path_qual: Option<ast::Path>,\n     pub(super) after_if: bool,\n     /// `true` if we are a statement or a last expr in the block.\n     pub(super) can_be_stmt: bool,\n@@ -137,7 +137,7 @@ impl<'a> CompletionContext<'a> {\n             is_param: false,\n             is_pat_binding_or_const: false,\n             is_trivial_path: false,\n-            path_prefix: None,\n+            path_qual: None,\n             after_if: false,\n             can_be_stmt: false,\n             is_expr: false,\n@@ -385,48 +385,54 @@ impl<'a> CompletionContext<'a> {\n             self.is_path_type = path.syntax().parent().and_then(ast::PathType::cast).is_some();\n             self.has_type_args = segment.generic_arg_list().is_some();\n \n-            let hygiene = hir::Hygiene::new(self.db, self.position.file_id.into());\n-            if let Some(path) = hir::Path::from_src(path.clone(), &hygiene) {\n-                if let Some(path_prefix) = path.qualifier() {\n-                    self.path_prefix = Some(path_prefix);\n+            if let Some(path) = path_or_use_tree_qualifier(&path) {\n+                self.path_qual = path\n+                    .segment()\n+                    .and_then(|it| {\n+                        find_node_with_range::<ast::PathSegment>(\n+                            original_file,\n+                            it.syntax().text_range(),\n+                        )\n+                    })\n+                    .map(|it| it.parent_path());\n+                return;\n+            }\n+\n+            if let Some(segment) = path.segment() {\n+                if segment.coloncolon_token().is_some() {\n                     return;\n                 }\n             }\n \n-            if path.qualifier().is_none() {\n-                self.is_trivial_path = true;\n-\n-                // Find either enclosing expr statement (thing with `;`) or a\n-                // block. If block, check that we are the last expr.\n-                self.can_be_stmt = name_ref\n-                    .syntax()\n-                    .ancestors()\n-                    .find_map(|node| {\n-                        if let Some(stmt) = ast::ExprStmt::cast(node.clone()) {\n-                            return Some(\n-                                stmt.syntax().text_range() == name_ref.syntax().text_range(),\n-                            );\n-                        }\n-                        if let Some(block) = ast::BlockExpr::cast(node) {\n-                            return Some(\n-                                block.expr().map(|e| e.syntax().text_range())\n-                                    == Some(name_ref.syntax().text_range()),\n-                            );\n-                        }\n-                        None\n-                    })\n-                    .unwrap_or(false);\n-                self.is_expr = path.syntax().parent().and_then(ast::PathExpr::cast).is_some();\n+            self.is_trivial_path = true;\n \n-                if let Some(off) = name_ref.syntax().text_range().start().checked_sub(2.into()) {\n-                    if let Some(if_expr) =\n-                        self.sema.find_node_at_offset_with_macros::<ast::IfExpr>(original_file, off)\n+            // Find either enclosing expr statement (thing with `;`) or a\n+            // block. If block, check that we are the last expr.\n+            self.can_be_stmt = name_ref\n+                .syntax()\n+                .ancestors()\n+                .find_map(|node| {\n+                    if let Some(stmt) = ast::ExprStmt::cast(node.clone()) {\n+                        return Some(stmt.syntax().text_range() == name_ref.syntax().text_range());\n+                    }\n+                    if let Some(block) = ast::BlockExpr::cast(node) {\n+                        return Some(\n+                            block.expr().map(|e| e.syntax().text_range())\n+                                == Some(name_ref.syntax().text_range()),\n+                        );\n+                    }\n+                    None\n+                })\n+                .unwrap_or(false);\n+            self.is_expr = path.syntax().parent().and_then(ast::PathExpr::cast).is_some();\n+\n+            if let Some(off) = name_ref.syntax().text_range().start().checked_sub(2.into()) {\n+                if let Some(if_expr) =\n+                    self.sema.find_node_at_offset_with_macros::<ast::IfExpr>(original_file, off)\n+                {\n+                    if if_expr.syntax().text_range().end() < name_ref.syntax().text_range().start()\n                     {\n-                        if if_expr.syntax().text_range().end()\n-                            < name_ref.syntax().text_range().start()\n-                        {\n-                            self.after_if = true;\n-                        }\n+                        self.after_if = true;\n                     }\n                 }\n             }\n@@ -469,3 +475,12 @@ fn is_node<N: AstNode>(node: &SyntaxNode) -> bool {\n         Some(n) => n.syntax().text_range() == node.text_range(),\n     }\n }\n+\n+fn path_or_use_tree_qualifier(path: &ast::Path) -> Option<ast::Path> {\n+    if let Some(qual) = path.qualifier() {\n+        return Some(qual);\n+    }\n+    let use_tree_list = path.syntax().ancestors().find_map(ast::UseTreeList::cast)?;\n+    let use_tree = use_tree_list.syntax().parent().and_then(ast::UseTree::cast)?;\n+    use_tree.path()\n+}"}]}