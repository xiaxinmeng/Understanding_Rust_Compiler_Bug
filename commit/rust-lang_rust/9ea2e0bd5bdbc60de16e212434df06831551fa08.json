{"sha": "9ea2e0bd5bdbc60de16e212434df06831551fa08", "node_id": "C_kwDOAAsO6NoAKDllYTJlMGJkNWJkYmM2MGRlMTZlMjEyNDM0ZGYwNjgzMTU1MWZhMDg", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2022-03-17T16:02:58Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2022-03-17T16:04:32Z"}, "message": "Fixes for consts", "tree": {"sha": "912249ef9dd02179728a699c1ed9e4716ac05639", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/912249ef9dd02179728a699c1ed9e4716ac05639"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9ea2e0bd5bdbc60de16e212434df06831551fa08", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9ea2e0bd5bdbc60de16e212434df06831551fa08", "html_url": "https://github.com/rust-lang/rust/commit/9ea2e0bd5bdbc60de16e212434df06831551fa08", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9ea2e0bd5bdbc60de16e212434df06831551fa08/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "59b5696aaa43f2b1193028848aede20979f3e37f", "url": "https://api.github.com/repos/rust-lang/rust/commits/59b5696aaa43f2b1193028848aede20979f3e37f", "html_url": "https://github.com/rust-lang/rust/commit/59b5696aaa43f2b1193028848aede20979f3e37f"}], "stats": {"total": 179, "additions": 136, "deletions": 43}, "files": [{"sha": "8121b27dcb7d37a83f46a61a124a28449a363d71", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9ea2e0bd5bdbc60de16e212434df06831551fa08/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ea2e0bd5bdbc60de16e212434df06831551fa08/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=9ea2e0bd5bdbc60de16e212434df06831551fa08", "patch": "@@ -1541,9 +1541,7 @@ impl SelfParam {\n \n impl HasVisibility for Function {\n     fn visibility(&self, db: &dyn HirDatabase) -> Visibility {\n-        let function_data = db.function_data(self.id);\n-        let visibility = &function_data.visibility;\n-        visibility.resolve(db.upcast(), &self.id.resolver(db.upcast()))\n+        db.function_visibility(self.id)\n     }\n }\n \n@@ -1594,9 +1592,7 @@ impl Const {\n \n impl HasVisibility for Const {\n     fn visibility(&self, db: &dyn HirDatabase) -> Visibility {\n-        let function_data = db.const_data(self.id);\n-        let visibility = &function_data.visibility;\n-        visibility.resolve(db.upcast(), &self.id.resolver(db.upcast()))\n+        db.const_visibility(self.id)\n     }\n }\n "}, {"sha": "74bb7472d57d0b49a571ed0abdec452aaf70f063", "filename": "crates/hir_def/src/db.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9ea2e0bd5bdbc60de16e212434df06831551fa08/crates%2Fhir_def%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ea2e0bd5bdbc60de16e212434df06831551fa08/crates%2Fhir_def%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fdb.rs?ref=9ea2e0bd5bdbc60de16e212434df06831551fa08", "patch": "@@ -175,9 +175,13 @@ pub trait DefDatabase: InternDatabase + AstDatabase + Upcast<dyn AstDatabase> {\n     #[salsa::invoke(visibility::field_visibilities_query)]\n     fn field_visibilities(&self, var: VariantId) -> Arc<ArenaMap<LocalFieldId, Visibility>>;\n \n+    // FIXME: unify function_visibility and const_visibility?\n     #[salsa::invoke(visibility::function_visibility_query)]\n     fn function_visibility(&self, def: FunctionId) -> Visibility;\n \n+    #[salsa::invoke(visibility::const_visibility_query)]\n+    fn const_visibility(&self, def: ConstId) -> Visibility;\n+\n     #[salsa::transparent]\n     fn crate_limits(&self, crate_id: CrateId) -> CrateLimits;\n }"}, {"sha": "6e22a877a9fa7980921f19be2af230e6eec56a3b", "filename": "crates/hir_def/src/visibility.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9ea2e0bd5bdbc60de16e212434df06831551fa08/crates%2Fhir_def%2Fsrc%2Fvisibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ea2e0bd5bdbc60de16e212434df06831551fa08/crates%2Fhir_def%2Fsrc%2Fvisibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fvisibility.rs?ref=9ea2e0bd5bdbc60de16e212434df06831551fa08", "patch": "@@ -11,7 +11,7 @@ use crate::{\n     nameres::DefMap,\n     path::{ModPath, PathKind},\n     resolver::HasResolver,\n-    FunctionId, HasModule, LocalFieldId, ModuleId, VariantId,\n+    ConstId, FunctionId, HasModule, LocalFieldId, ModuleId, VariantId,\n };\n \n /// Visibility of an item, not yet resolved.\n@@ -234,3 +234,9 @@ pub(crate) fn function_visibility_query(db: &dyn DefDatabase, def: FunctionId) -\n     let resolver = def.resolver(db);\n     db.function_data(def).visibility.resolve(db, &resolver)\n }\n+\n+/// Resolve visibility of a const.\n+pub(crate) fn const_visibility_query(db: &dyn DefDatabase, def: ConstId) -> Visibility {\n+    let resolver = def.resolver(db);\n+    db.const_data(def).visibility.resolve(db, &resolver)\n+}"}, {"sha": "ef0675d59f686fb5201d1c8c5031db11f4f09ed2", "filename": "crates/hir_ty/src/infer/unify.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9ea2e0bd5bdbc60de16e212434df06831551fa08/crates%2Fhir_ty%2Fsrc%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ea2e0bd5bdbc60de16e212434df06831551fa08/crates%2Fhir_ty%2Fsrc%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Funify.rs?ref=9ea2e0bd5bdbc60de16e212434df06831551fa08", "patch": "@@ -379,6 +379,13 @@ impl<'a> InferenceTable<'a> {\n         self.pending_obligations = snapshot.pending_obligations;\n     }\n \n+    pub(crate) fn run_in_snapshot<T>(&mut self, f: impl FnOnce(&mut InferenceTable) -> T) -> T {\n+        let snapshot = self.snapshot();\n+        let result = f(self);\n+        self.rollback_to(snapshot);\n+        result\n+    }\n+\n     /// Checks an obligation without registering it. Useful mostly to check\n     /// whether a trait *might* be implemented before deciding to 'lock in' the\n     /// choice (during e.g. method resolution or deref)."}, {"sha": "9120f80e2c538fea4a62c2c20fca7bd56c35f735", "filename": "crates/hir_ty/src/method_resolution.rs", "status": "modified", "additions": 58, "deletions": 36, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/9ea2e0bd5bdbc60de16e212434df06831551fa08/crates%2Fhir_ty%2Fsrc%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ea2e0bd5bdbc60de16e212434df06831551fa08/crates%2Fhir_ty%2Fsrc%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fmethod_resolution.rs?ref=9ea2e0bd5bdbc60de16e212434df06831551fa08", "patch": "@@ -985,56 +985,78 @@ fn is_valid_candidate(\n                     return false;\n                 }\n             }\n-            let snap = table.snapshot();\n-            let subst = TyBuilder::subst_for_def(db, m).fill_with_inference_vars(table).build();\n-            let expected_self_ty = match m.lookup(db.upcast()).container {\n-                ItemContainerId::TraitId(_) => {\n-                    subst.at(Interner, 0).assert_ty_ref(Interner).clone()\n+            table.run_in_snapshot(|table| {\n+                let subst = TyBuilder::subst_for_def(db, m).fill_with_inference_vars(table).build();\n+                let expected_self_ty = match m.lookup(db.upcast()).container {\n+                    ItemContainerId::TraitId(_) => {\n+                        subst.at(Interner, 0).assert_ty_ref(Interner).clone()\n+                    }\n+                    ItemContainerId::ImplId(impl_id) => {\n+                        subst.apply(db.impl_self_ty(impl_id).skip_binders().clone(), Interner)\n+                    }\n+                    // We should only get called for associated items (impl/trait)\n+                    ItemContainerId::ModuleId(_) | ItemContainerId::ExternBlockId(_) => {\n+                        unreachable!()\n+                    }\n+                };\n+                if !table.unify(&expected_self_ty, &self_ty) {\n+                    return false;\n                 }\n-                ItemContainerId::ImplId(impl_id) => {\n-                    subst.apply(db.impl_self_ty(impl_id).skip_binders().clone(), Interner)\n+                if let Some(receiver_ty) = receiver_ty {\n+                    if !data.has_self_param() {\n+                        return false;\n+                    }\n+\n+                    let sig = db.callable_item_signature(m.into());\n+                    let expected_receiver =\n+                        sig.map(|s| s.params()[0].clone()).substitute(Interner, &subst);\n+                    let receiver_matches = table.unify(&receiver_ty, &expected_receiver);\n+\n+                    if !receiver_matches {\n+                        return false;\n+                    }\n                 }\n-                // We should only get called for associated items (impl/trait)\n-                ItemContainerId::ModuleId(_) | ItemContainerId::ExternBlockId(_) => unreachable!(),\n-            };\n-            if !table.unify(&expected_self_ty, &self_ty) {\n-                // FIXME handle rollbacks better\n-                table.rollback_to(snap);\n+                if let Some(from_module) = visible_from_module {\n+                    if !db.function_visibility(m).is_visible_from(db.upcast(), from_module) {\n+                        cov_mark::hit!(autoderef_candidate_not_visible);\n+                        return false;\n+                    }\n+                }\n+\n+                true\n+            })\n+        }\n+        AssocItemId::ConstId(c) => {\n+            let data = db.const_data(c);\n+            if receiver_ty.is_some() {\n                 return false;\n             }\n-            if let Some(receiver_ty) = receiver_ty {\n-                if !data.has_self_param() {\n-                    table.rollback_to(snap);\n+            if let Some(name) = name {\n+                if data.name.as_ref() != Some(name) {\n                     return false;\n                 }\n-\n-                let sig = db.callable_item_signature(m.into());\n-                let expected_receiver =\n-                    sig.map(|s| s.params()[0].clone()).substitute(Interner, &subst);\n-                let receiver_matches = table.unify(&receiver_ty, &expected_receiver);\n-                table.rollback_to(snap);\n-\n-                if !receiver_matches {\n+            }\n+            if let Some(from_module) = visible_from_module {\n+                if !db.const_visibility(c).is_visible_from(db.upcast(), from_module) {\n+                    cov_mark::hit!(const_candidate_not_visible);\n                     return false;\n                 }\n-            } else {\n-                table.rollback_to(snap);\n             }\n-            if let Some(from_module) = visible_from_module {\n-                if !db.function_visibility(m).is_visible_from(db.upcast(), from_module) {\n-                    cov_mark::hit!(autoderef_candidate_not_visible);\n+            if let ItemContainerId::ImplId(impl_id) = c.lookup(db.upcast()).container {\n+                let self_ty_matches = table.run_in_snapshot(|table| {\n+                    let subst =\n+                        TyBuilder::subst_for_def(db, c).fill_with_inference_vars(table).build();\n+                    let expected_self_ty =\n+                        subst.apply(db.impl_self_ty(impl_id).skip_binders().clone(), Interner);\n+                    table.unify(&expected_self_ty, &self_ty)\n+                });\n+                if !self_ty_matches {\n+                    cov_mark::hit!(const_candidate_self_type_mismatch);\n                     return false;\n                 }\n             }\n-\n             true\n         }\n-        AssocItemId::ConstId(c) => {\n-            let data = db.const_data(c);\n-            // TODO check unify self ty\n-            // TODO check visibility\n-            name.map_or(true, |name| data.name.as_ref() == Some(name)) && receiver_ty.is_none()\n-        }\n         _ => false,\n     }\n }"}, {"sha": "56b8db1319e1ae7528e257388221063dca932c33", "filename": "crates/hir_ty/src/tests/method_resolution.rs", "status": "modified", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/9ea2e0bd5bdbc60de16e212434df06831551fa08/crates%2Fhir_ty%2Fsrc%2Ftests%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ea2e0bd5bdbc60de16e212434df06831551fa08/crates%2Fhir_ty%2Fsrc%2Ftests%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftests%2Fmethod_resolution.rs?ref=9ea2e0bd5bdbc60de16e212434df06831551fa08", "patch": "@@ -953,6 +953,33 @@ fn main() {\n     );\n }\n \n+#[test]\n+fn method_resolution_overloaded_const() {\n+    cov_mark::check!(const_candidate_self_type_mismatch);\n+    check_types(\n+        r#\"\n+struct Wrapper<T>(T);\n+struct Foo<T>(T);\n+struct Bar<T>(T);\n+\n+impl<T> Wrapper<Foo<T>> {\n+    pub const VALUE: Foo<T>;\n+}\n+\n+impl<T> Wrapper<Bar<T>> {\n+    pub const VALUE: Bar<T>;\n+}\n+\n+fn main() {\n+    let a = Wrapper::<Foo<f32>>::VALUE;\n+    let b = Wrapper::<Bar<f32>>::VALUE;\n+    (a, b);\n+  //^^^^^^ (Foo<f32>, Bar<f32>)\n+}\n+\"#,\n+    );\n+}\n+\n #[test]\n fn method_resolution_encountering_fn_type() {\n     check_types(\n@@ -1256,6 +1283,37 @@ mod b {\n     )\n }\n \n+#[test]\n+fn trait_vs_private_inherent_const() {\n+    cov_mark::check!(const_candidate_not_visible);\n+    check(\n+        r#\"\n+mod a {\n+    pub struct Foo;\n+    impl Foo {\n+        const VALUE: u32 = 2;\n+    }\n+    pub trait Trait {\n+        const VALUE: usize;\n+    }\n+    impl Trait for Foo {\n+        const VALUE: usize = 3;\n+    }\n+\n+    fn foo() {\n+        let x = Foo::VALUE;\n+            //  ^^^^^^^^^^ type: u32\n+    }\n+}\n+use a::Trait;\n+fn foo() {\n+    let x = a::Foo::VALUE;\n+         // ^^^^^^^^^^^^^ type: usize\n+}\n+\"#,\n+    )\n+}\n+\n #[test]\n fn trait_impl_in_unnamed_const() {\n     check_types("}]}