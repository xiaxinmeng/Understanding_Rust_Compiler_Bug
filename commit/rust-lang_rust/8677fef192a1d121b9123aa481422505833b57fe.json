{"sha": "8677fef192a1d121b9123aa481422505833b57fe", "node_id": "C_kwDOAAsO6NoAKDg2NzdmZWYxOTJhMWQxMjFiOTEyM2FhNDgxNDIyNTA1ODMzYjU3ZmU", "commit": {"author": {"name": "David Wood", "email": "david.wood@huawei.com", "date": "2022-03-30T02:08:58Z"}, "committer": {"name": "David Wood", "email": "david.wood@huawei.com", "date": "2022-04-05T06:01:02Z"}, "message": "macros: move suggestion type handling to fn\n\nMove the handling of `Span` or `(Span, Applicability)` types in\n`#[suggestion]` attributes to its own function.\n\nSigned-off-by: David Wood <david.wood@huawei.com>", "tree": {"sha": "578f640f1ea3afea288717b5cce32e696fda2e1c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/578f640f1ea3afea288717b5cce32e696fda2e1c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8677fef192a1d121b9123aa481422505833b57fe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8677fef192a1d121b9123aa481422505833b57fe", "html_url": "https://github.com/rust-lang/rust/commit/8677fef192a1d121b9123aa481422505833b57fe", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8677fef192a1d121b9123aa481422505833b57fe/comments", "author": {"login": "davidtwco", "id": 1295100, "node_id": "MDQ6VXNlcjEyOTUxMDA=", "avatar_url": "https://avatars.githubusercontent.com/u/1295100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidtwco", "html_url": "https://github.com/davidtwco", "followers_url": "https://api.github.com/users/davidtwco/followers", "following_url": "https://api.github.com/users/davidtwco/following{/other_user}", "gists_url": "https://api.github.com/users/davidtwco/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidtwco/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidtwco/subscriptions", "organizations_url": "https://api.github.com/users/davidtwco/orgs", "repos_url": "https://api.github.com/users/davidtwco/repos", "events_url": "https://api.github.com/users/davidtwco/events{/privacy}", "received_events_url": "https://api.github.com/users/davidtwco/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidtwco", "id": 1295100, "node_id": "MDQ6VXNlcjEyOTUxMDA=", "avatar_url": "https://avatars.githubusercontent.com/u/1295100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidtwco", "html_url": "https://github.com/davidtwco", "followers_url": "https://api.github.com/users/davidtwco/followers", "following_url": "https://api.github.com/users/davidtwco/following{/other_user}", "gists_url": "https://api.github.com/users/davidtwco/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidtwco/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidtwco/subscriptions", "organizations_url": "https://api.github.com/users/davidtwco/orgs", "repos_url": "https://api.github.com/users/davidtwco/repos", "events_url": "https://api.github.com/users/davidtwco/events{/privacy}", "received_events_url": "https://api.github.com/users/davidtwco/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2bf64d64832be674f26fa6e92740ac71c00c2ee5", "url": "https://api.github.com/repos/rust-lang/rust/commits/2bf64d64832be674f26fa6e92740ac71c00c2ee5", "html_url": "https://github.com/rust-lang/rust/commit/2bf64d64832be674f26fa6e92740ac71c00c2ee5"}], "stats": {"total": 129, "additions": 61, "deletions": 68}, "files": [{"sha": "5e221875b108072c8a060bbd4b6a834263272fef", "filename": "compiler/rustc_macros/src/session_diagnostic.rs", "status": "modified", "additions": 61, "deletions": 68, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/8677fef192a1d121b9123aa481422505833b57fe/compiler%2Frustc_macros%2Fsrc%2Fsession_diagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8677fef192a1d121b9123aa481422505833b57fe/compiler%2Frustc_macros%2Fsrc%2Fsession_diagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fsession_diagnostic.rs?ref=8677fef192a1d121b9123aa481422505833b57fe", "patch": "@@ -430,74 +430,8 @@ impl<'a> SessionDiagnosticDeriveBuilder<'a> {\n                     | suggestion_kind @ \"suggestion_short\"\n                     | suggestion_kind @ \"suggestion_hidden\"\n                     | suggestion_kind @ \"suggestion_verbose\" => {\n-                        // For suggest, we need to ensure we are running on a (Span,\n-                        // Applicability) pair.\n-                        let (span, applicability) = (|| match &info.ty {\n-                            ty @ syn::Type::Path(..)\n-                                if type_matches_path(ty, &[\"rustc_span\", \"Span\"]) =>\n-                            {\n-                                let binding = &info.binding.binding;\n-                                Ok((\n-                                    quote!(*#binding),\n-                                    quote!(rustc_errors::Applicability::Unspecified),\n-                                ))\n-                            }\n-                            syn::Type::Tuple(tup) => {\n-                                let mut span_idx = None;\n-                                let mut applicability_idx = None;\n-                                for (idx, elem) in tup.elems.iter().enumerate() {\n-                                    if type_matches_path(elem, &[\"rustc_span\", \"Span\"]) {\n-                                        if span_idx.is_none() {\n-                                            span_idx = Some(syn::Index::from(idx));\n-                                        } else {\n-                                            throw_span_err!(\n-                                                info.span.unwrap(),\n-                                                \"type of field annotated with `#[suggestion(...)]` contains more than one Span\"\n-                                            );\n-                                        }\n-                                    } else if type_matches_path(\n-                                        elem,\n-                                        &[\"rustc_errors\", \"Applicability\"],\n-                                    ) {\n-                                        if applicability_idx.is_none() {\n-                                            applicability_idx = Some(syn::Index::from(idx));\n-                                        } else {\n-                                            throw_span_err!(\n-                                                info.span.unwrap(),\n-                                                \"type of field annotated with `#[suggestion(...)]` contains more than one Applicability\"\n-                                            );\n-                                        }\n-                                    }\n-                                }\n-                                if let Some(span_idx) = span_idx {\n-                                    let binding = &info.binding.binding;\n-                                    let span = quote!(#binding.#span_idx);\n-                                    let applicability = applicability_idx\n-                                        .map(\n-                                            |applicability_idx| quote!(#binding.#applicability_idx),\n-                                        )\n-                                        .unwrap_or_else(|| {\n-                                            quote!(rustc_errors::Applicability::Unspecified)\n-                                        });\n-                                    return Ok((span, applicability));\n-                                }\n-                                throw_span_err!(\n-                                    info.span.unwrap(),\n-                                    \"wrong types for suggestion\",\n-                                    |diag| {\n-                                        diag.help(\"#[suggestion(...)] on a tuple field must be applied to fields of type (Span, Applicability)\")\n-                                    }\n-                                );\n-                            }\n-                            _ => throw_span_err!(\n-                                info.span.unwrap(),\n-                                \"wrong field type for suggestion\",\n-                                |diag| {\n-                                    diag.help(\"#[suggestion(...)] should be applied to fields of type Span or (Span, Applicability)\")\n-                                }\n-                            ),\n-                        })()?;\n-                        // Now read the key-value pairs.\n+                        let (span, applicability) = self.span_and_applicability_of_ty(info)?;\n+\n                         let mut msg = None;\n                         let mut code = None;\n \n@@ -562,6 +496,65 @@ impl<'a> SessionDiagnosticDeriveBuilder<'a> {\n         })\n     }\n \n+    fn span_and_applicability_of_ty(\n+        &self,\n+        info: FieldInfo<'_>,\n+    ) -> Result<(proc_macro2::TokenStream, proc_macro2::TokenStream), SessionDiagnosticDeriveError>\n+    {\n+        match &info.ty {\n+            // If `ty` is `Span` w/out applicability, then use `Applicability::Unspecified`.\n+            ty @ syn::Type::Path(..) if type_matches_path(ty, &[\"rustc_span\", \"Span\"]) => {\n+                let binding = &info.binding.binding;\n+                Ok((quote!(*#binding), quote!(rustc_errors::Applicability::Unspecified)))\n+            }\n+            // If `ty` is `(Span, Applicability)` then return tokens accessing those.\n+            syn::Type::Tuple(tup) => {\n+                let mut span_idx = None;\n+                let mut applicability_idx = None;\n+\n+                for (idx, elem) in tup.elems.iter().enumerate() {\n+                    if type_matches_path(elem, &[\"rustc_span\", \"Span\"]) {\n+                        if span_idx.is_none() {\n+                            span_idx = Some(syn::Index::from(idx));\n+                        } else {\n+                            throw_span_err!(\n+                                info.span.unwrap(),\n+                                \"type of field annotated with `#[suggestion(...)]` contains more than one Span\"\n+                            );\n+                        }\n+                    } else if type_matches_path(elem, &[\"rustc_errors\", \"Applicability\"]) {\n+                        if applicability_idx.is_none() {\n+                            applicability_idx = Some(syn::Index::from(idx));\n+                        } else {\n+                            throw_span_err!(\n+                                info.span.unwrap(),\n+                                \"type of field annotated with `#[suggestion(...)]` contains more than one Applicability\"\n+                            );\n+                        }\n+                    }\n+                }\n+\n+                if let Some(span_idx) = span_idx {\n+                    let binding = &info.binding.binding;\n+                    let span = quote!(#binding.#span_idx);\n+                    let applicability = applicability_idx\n+                        .map(|applicability_idx| quote!(#binding.#applicability_idx))\n+                        .unwrap_or_else(|| quote!(rustc_errors::Applicability::Unspecified));\n+\n+                    return Ok((span, applicability));\n+                }\n+\n+                throw_span_err!(info.span.unwrap(), \"wrong types for suggestion\", |diag| {\n+                    diag.help(\"#[suggestion(...)] on a tuple field must be applied to fields of type `(Span, Applicability)`\")\n+                });\n+            }\n+            // If `ty` isn't a `Span` or `(Span, Applicability)` then emit an error.\n+            _ => throw_span_err!(info.span.unwrap(), \"wrong field type for suggestion\", |diag| {\n+                diag.help(\"#[suggestion(...)] should be applied to fields of type `Span` or `(Span, Applicability)`\")\n+            }),\n+        }\n+    }\n+\n     /// In the strings in the attributes supplied to this macro, we want callers to be able to\n     /// reference fields in the format string. For example:\n     ///"}]}