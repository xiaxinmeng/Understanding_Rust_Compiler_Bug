{"sha": "ed0eb8f45ab979f866208a0c06179bd2f73a2ec1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVkMGViOGY0NWFiOTc5Zjg2NjIwOGEwYzA2MTc5YmQyZjczYTJlYzE=", "commit": {"author": {"name": "Brian Anderson", "email": "andersrb@gmail.com", "date": "2011-05-31T04:13:37Z"}, "committer": {"name": "Brian Anderson", "email": "andersrb@gmail.com", "date": "2011-05-31T05:23:53Z"}, "message": "stdlib: Remove unneeded type params from alt patterns", "tree": {"sha": "22cb3aa49e5b0ed069a4dae67b90d7a613cf042d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/22cb3aa49e5b0ed069a4dae67b90d7a613cf042d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ed0eb8f45ab979f866208a0c06179bd2f73a2ec1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ed0eb8f45ab979f866208a0c06179bd2f73a2ec1", "html_url": "https://github.com/rust-lang/rust/commit/ed0eb8f45ab979f866208a0c06179bd2f73a2ec1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ed0eb8f45ab979f866208a0c06179bd2f73a2ec1/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c1d97a41ebd823b90b6d7e741733152d7b931680", "url": "https://api.github.com/repos/rust-lang/rust/commits/c1d97a41ebd823b90b6d7e741733152d7b931680", "html_url": "https://github.com/rust-lang/rust/commit/c1d97a41ebd823b90b6d7e741733152d7b931680"}], "stats": {"total": 110, "additions": 55, "deletions": 55}, "files": [{"sha": "6ad44af52883a84d6951cd1ba032b6ebe6983898", "filename": "src/lib/deque.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed0eb8f45ab979f866208a0c06179bd2f73a2ec1/src%2Flib%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed0eb8f45ab979f866208a0c06179bd2f73a2ec1/src%2Flib%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fdeque.rs?ref=ed0eb8f45ab979f866208a0c06179bd2f73a2ec1", "patch": "@@ -48,7 +48,7 @@ fn create[T]() -> t[T] {\n \n     fn get[T](vec[cell[T]] elts, uint i) -> T {\n         ret alt (elts.(i)) {\n-            case (option::some[T](?t)) { t }\n+            case (option::some(?t)) { t }\n             case (_) { fail }\n         };\n     }"}, {"sha": "93dd6134776b06beb680dda5f5875ee1269aa3cb", "filename": "src/lib/ebml.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ed0eb8f45ab979f866208a0c06179bd2f73a2ec1/src%2Flib%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed0eb8f45ab979f866208a0c06179bd2f73a2ec1/src%2Flib%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Febml.rs?ref=ed0eb8f45ab979f866208a0c06179bd2f73a2ec1", "patch": "@@ -63,8 +63,8 @@ fn maybe_get_doc(doc d, uint tg) -> option::t[doc] {\n \n fn get_doc(doc d, uint tg) -> doc {\n     alt (maybe_get_doc(d, tg)) {\n-        case (some[doc](?d)) {ret d;}\n-        case (none[doc]) {\n+        case (some(?d)) {ret d;}\n+        case (none) {\n             log_err \"failed to find block with tag \" + uint::to_str(tg, 10u);\n             fail;\n         }"}, {"sha": "2df831c0cab734bceaf4ebd62e857bf438853838", "filename": "src/lib/extfmt.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ed0eb8f45ab979f866208a0c06179bd2f73a2ec1/src%2Flib%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed0eb8f45ab979f866208a0c06179bd2f73a2ec1/src%2Flib%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fextfmt.rs?ref=ed0eb8f45ab979f866208a0c06179bd2f73a2ec1", "patch": "@@ -130,10 +130,10 @@ mod ct {\n \n         auto n = (c - ('0' as u8)) as uint;\n         ret alt (peek_num(s, i + 1u, lim)) {\n-            case (none[tup(uint, uint)]) {\n+            case (none) {\n                 some[tup(uint, uint)](tup(n, i + 1u))\n             }\n-            case (some[tup(uint, uint)](?next)) {\n+            case (some(?next)) {\n                 auto m = next._0;\n                 auto j = next._1;\n                 some[tup(uint, uint)](tup(n * 10u + m, j))\n@@ -162,10 +162,10 @@ mod ct {\n \n         auto num = peek_num(s, i, lim);\n         ret alt (num) {\n-            case (none[tup(uint, uint)]) {\n+            case (none) {\n                 tup(none[int], i)\n             }\n-            case (some[tup(uint, uint)](?t)) {\n+            case (some(?t)) {\n                 auto n = t._0;\n                 auto j = t._1;\n                 if (j < lim && s.(j) == '$' as u8) {\n@@ -218,20 +218,20 @@ mod ct {\n             auto param = parse_parameter(s, i + 1u, lim);\n             auto j = param._1;\n             alt (param._0) {\n-                case (none[int]) {\n+                case (none) {\n                     tup(count_is_next_param, j)\n                 }\n-                case (some[int](?n)) {\n+                case (some(?n)) {\n                     tup(count_is_param(n), j)\n                 }\n             }\n         } else {\n             auto num = peek_num(s, i, lim);\n             alt (num) {\n-                case (none[tup(uint, uint)]) {\n+                case (none) {\n                     tup(count_implied, i)\n                 }\n-                case (some[tup(uint, uint)](?num)) {\n+                case (some(?num)) {\n                     tup(count_is(num._0 as int), num._1)\n                 }\n             }"}, {"sha": "abe1a15789d783a0546edfc43289c8ff0b603328", "filename": "src/lib/getopts.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ed0eb8f45ab979f866208a0c06179bd2f73a2ec1/src%2Flib%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed0eb8f45ab979f866208a0c06179bd2f73a2ec1/src%2Flib%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fgetopts.rs?ref=ed0eb8f45ab979f866208a0c06179bd2f73a2ec1", "patch": "@@ -175,8 +175,8 @@ fn getopts(vec[str] args, vec[opt] opts) -> result {\n                 name_pos += 1u;\n                 auto optid;\n                 alt (find_opt(opts, nm)) {\n-                    case (some[uint](?id)) {optid = id;}\n-                    case (none[uint]) {\n+                    case (some(?id)) {optid = id;}\n+                    case (none) {\n                         ret failure(unrecognized_option(name_str(nm)));\n                     }\n                 }\n@@ -234,8 +234,8 @@ fn getopts(vec[str] args, vec[opt] opts) -> result {\n \n fn opt_vals(match m, str nm) -> vec[optval] {\n     ret alt (find_opt(m.opts, mkname(nm))) {\n-        case (some[uint](?id)) { m.vals.(id) }\n-        case (none[uint]) {\n+        case (some(?id)) { m.vals.(id) }\n+        case (none) {\n             log_err \"No option '\" + nm + \"' defined.\";\n             fail\n         }"}, {"sha": "342b50ff9a348c022e82e394202536a865e4ddd4", "filename": "src/lib/list.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ed0eb8f45ab979f866208a0c06179bd2f73a2ec1/src%2Flib%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed0eb8f45ab979f866208a0c06179bd2f73a2ec1/src%2Flib%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Flist.rs?ref=ed0eb8f45ab979f866208a0c06179bd2f73a2ec1", "patch": "@@ -23,11 +23,11 @@ fn from_vec[T](vec[T] v) -> list[T] {\n \n fn foldl[T,U](&list[T] ls, &U u, fn(&T t, &U u) -> U f) -> U {\n     alt(ls) {\n-        case (cons[T](?hd, ?tl)) {\n+        case (cons(?hd, ?tl)) {\n             auto u_ = f(hd, u);\n             be foldl[T,U](*tl, u_, f);\n         }\n-        case (nil[T]) {\n+        case (nil) {\n             ret u;\n         }\n     }\n@@ -36,32 +36,32 @@ fn foldl[T,U](&list[T] ls, &U u, fn(&T t, &U u) -> U f) -> U {\n fn find[T,U](&list[T] ls,\n              (fn(&T) -> option::t[U]) f) -> option::t[U] {\n     alt(ls) {\n-        case (cons[T](?hd, ?tl)) {\n+        case (cons(?hd, ?tl)) {\n             alt (f(hd)) {\n-                case (none[U]) {\n+                case (none) {\n                     be find[T,U](*tl, f);\n                 }\n-                case (some[U](?res)) {\n+                case (some(?res)) {\n                     ret some[U](res);\n                 }\n             }\n         }\n-        case (nil[T]) {\n+        case (nil) {\n             ret none[U];\n         }\n     }\n }\n \n fn has[T](&list[T] ls, &T elt) -> bool {\n     alt(ls) {\n-        case (cons[T](?hd, ?tl)) {\n+        case (cons(?hd, ?tl)) {\n             if (elt == hd) {\n                 ret true;\n             } else {\n                 be has(*tl, elt);\n             }\n         }\n-        case (nil[T]) { ret false; }\n+        case (nil) { ret false; }\n     }\n }\n \n@@ -74,22 +74,22 @@ fn length[T](&list[T] ls) -> uint {\n \n fn cdr[T](&list[T] ls) -> list[T] {\n     alt (ls) {\n-        case (cons[T](_, ?tl)) {ret *tl;}\n+        case (cons(_, ?tl)) {ret *tl;}\n     }\n }\n fn car[T](&list[T] ls) -> T {\n     alt (ls) {\n-        case (cons[T](?hd, _)) {ret hd;}\n+        case (cons(?hd, _)) {ret hd;}\n     }\n }\n \n \n fn append[T](&list[T] l, &list[T] m) -> list[T] {\n     alt (l) {\n-        case (nil[T]) {\n+        case (nil) {\n             ret m;\n         }\n-        case (cons[T](?x, ?xs)) {\n+        case (cons(?x, ?xs)) {\n             let list[T] rest = append[T](*xs, m);\n             ret cons[T](x, @rest);\n         }"}, {"sha": "3b7f01acbe19c887ed2925b8c318e3e02fda74b2", "filename": "src/lib/map.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ed0eb8f45ab979f866208a0c06179bd2f73a2ec1/src%2Flib%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed0eb8f45ab979f866208a0c06179bd2f73a2ec1/src%2Flib%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fmap.rs?ref=ed0eb8f45ab979f866208a0c06179bd2f73a2ec1", "patch": "@@ -75,7 +75,7 @@ fn mk_hashmap[K, V](&hashfn[K] hasher, &eqfn[K] eqer) -> hashmap[K, V] {\n             while (i < nbkts) {\n                 let uint j = hash(h, nbkts, i);\n                 alt (bkts.(j)) {\n-                    case (some[K, V](?k, _)) {\n+                    case (some(?k, _)) {\n                         if (eqer(key, k)) {\n                             bkts.(j) = some[K, V](k, val);\n                             ret false;\n@@ -103,12 +103,12 @@ fn mk_hashmap[K, V](&hashfn[K] hasher, &eqfn[K] eqer) -> hashmap[K, V] {\n             while (i < nbkts) {\n                 let uint j = (hash(h, nbkts, i));\n                 alt (bkts.(j)) {\n-                    case (some[K, V](?k, ?v)) {\n+                    case (some(?k, ?v)) {\n                         if (eqer(key, k)) {\n                             ret option::some[V](v);\n                         }\n                     }\n-                    case (nil[K, V]) {\n+                    case (nil) {\n                         ret option::none[V];\n                     }\n                     case (deleted[K, V]) { }\n@@ -126,7 +126,7 @@ fn mk_hashmap[K, V](&hashfn[K] hasher, &eqfn[K] eqer) -> hashmap[K, V] {\n         {\n             for (bucket[K, V] b in oldbkts) {\n                 alt (b) {\n-                    case (some[K, V](?k, ?v)) {\n+                    case (some(?k, ?v)) {\n                         insert_common[K, V](hasher, eqer, newbkts,\n                                             nnewbkts, k, v);\n                     }\n@@ -167,14 +167,14 @@ fn mk_hashmap[K, V](&hashfn[K] hasher, &eqfn[K] eqer) -> hashmap[K, V] {\n \n             fn contains_key(&K key) -> bool {\n                 ret alt (find_common[K, V](hasher, eqer, bkts, nbkts, key)) {\n-                    case (option::some[V](_)) { true }\n+                    case (option::some(_)) { true }\n                     case (_) { false }\n                 };\n             }\n \n             fn get(&K key) -> V {\n                 ret alt (find_common[K, V](hasher, eqer, bkts, nbkts, key)) {\n-                    case (option::some[V](?val)) { val }\n+                    case (option::some(?val)) { val }\n                     case (_) { fail }\n                 };\n             }\n@@ -189,15 +189,15 @@ fn mk_hashmap[K, V](&hashfn[K] hasher, &eqfn[K] eqer) -> hashmap[K, V] {\n                 while (i < nbkts) {\n                     let uint j = (hash(h, nbkts, i));\n                     alt (bkts.(j)) {\n-                        case (some[K, V](?k, ?v)) {\n+                        case (some(?k, ?v)) {\n                             if (eqer(key, k)) {\n                                 bkts.(j) = deleted[K, V];\n                                 nelts -= 1u;\n                                 ret option::some[V](v);\n                             }\n                         }\n-                        case (deleted[K, V]) { }\n-                        case (nil[K, V]) {\n+                        case (deleted) { }\n+                        case (nil) {\n                             ret option::none[V];\n                         }\n                     }\n@@ -216,7 +216,7 @@ fn mk_hashmap[K, V](&hashfn[K] hasher, &eqfn[K] eqer) -> hashmap[K, V] {\n             iter items() -> @tup(K,V) {\n                 for (bucket[K,V] b in bkts) {\n                     alt (b) {\n-                        case(some[K,V](?k,?v)) {\n+                        case(some(?k,?v)) {\n                             put @tup(k,v);\n                         }\n                         case (_) { }"}, {"sha": "3420f3fe6900107b06f17e27d4655ec22a70d571", "filename": "src/lib/option.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ed0eb8f45ab979f866208a0c06179bd2f73a2ec1/src%2Flib%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed0eb8f45ab979f866208a0c06179bd2f73a2ec1/src%2Flib%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Foption.rs?ref=ed0eb8f45ab979f866208a0c06179bd2f73a2ec1", "patch": "@@ -9,30 +9,30 @@ type operator[T, U] = fn(&T) -> U;\n \n fn get[T](&t[T] opt) -> T {\n     ret alt (opt) {\n-        case (some[T](?x)) {\n+        case (some(?x)) {\n             x\n         }\n-        case (none[T]) {\n+        case (none) {\n             fail\n         }\n     };\n }\n \n fn map[T, U](&operator[T, U] f, &t[T] opt) -> t[U] {\n     ret alt (opt) {\n-        case (some[T](?x)) {\n+        case (some(?x)) {\n             some[U](f(x))\n         }\n-        case (none[T]) {\n+        case (none) {\n             none[U]\n         }\n     };\n }\n \n fn is_none[T](&t[T] opt) -> bool {\n     ret alt (opt) {\n-        case (none[T])      { true }\n-        case (some[T](_))   { false }\n+        case (none)      { true }\n+        case (some(_))   { false }\n     };\n }\n \n@@ -43,16 +43,16 @@ fn from_maybe[T](&T def, &t[T] opt) -> T {\n \n fn maybe[T, U](&U def, fn(&T) -> U f, &t[T] opt) -> U {\n     ret alt (opt) {\n-        case (none[T]) { def }\n-        case (some[T](?t)) { f(t) }\n+        case (none) { def }\n+        case (some(?t)) { f(t) }\n     };\n }\n \n // Can be defined in terms of the above when/if we have const bind.\n fn may[T](fn(&T) f, &t[T] opt) {\n     alt (opt) {\n-        case (none[T]) { /* nothing */ }\n-        case (some[T](?t)) { f(t); }\n+        case (none) { /* nothing */ }\n+        case (some(?t)) { f(t); }\n     }\n }\n "}, {"sha": "7dfa861c6ed30954c437c2b3e55783de6937fa86", "filename": "src/lib/ufind.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ed0eb8f45ab979f866208a0c06179bd2f73a2ec1/src%2Flib%2Fufind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed0eb8f45ab979f866208a0c06179bd2f73a2ec1/src%2Flib%2Fufind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fufind.rs?ref=ed0eb8f45ab979f866208a0c06179bd2f73a2ec1", "patch": "@@ -22,8 +22,8 @@ fn make_set(&ufind ufnd) -> uint {\n \n fn find(&ufind ufnd, uint n) -> uint {\n     alt (ufnd.nodes.(n)) {\n-        case (none[uint]) { ret n; }\n-        case (some[uint](?m)) { be find(ufnd, m); }\n+        case (none) { ret n; }\n+        case (some(?m)) { be find(ufnd, m); }\n     }\n }\n "}, {"sha": "3815031b3052a9b776f66239940a8ebc4bfea9f6", "filename": "src/lib/vec.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ed0eb8f45ab979f866208a0c06179bd2f73a2ec1/src%2Flib%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed0eb8f45ab979f866208a0c06179bd2f73a2ec1/src%2Flib%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fvec.rs?ref=ed0eb8f45ab979f866208a0c06179bd2f73a2ec1", "patch": "@@ -233,8 +233,8 @@ fn filter_map[T, U](&fn(&T) -> option::t[U] f, &array[T] v) -> vec[U] {\n     let vec[U] res = []; //TODO does this work these days?\n     for(T ve in v) {\n         alt(f(ve)) {\n-            case (some[U](?elt)) { res += [elt]; }\n-            case (none[U]) {}\n+            case (some(?elt)) { res += [elt]; }\n+            case (none) {}\n         }\n     }\n     ret res;\n@@ -305,8 +305,8 @@ fn clone[T](&vec[T] v) -> vec[T] {\n \n fn plus_option[T](&vec[T] v, &option::t[T] o) -> () {\n     alt (o) {\n-        case (none[T]) {}\n-        case (some[T](?x)) { v += [x]; }\n+        case (none) {}\n+        case (some(?x)) { v += [x]; }\n     }\n }\n \n@@ -315,8 +315,8 @@ fn cat_options[T](&vec[option::t[T]] v) -> vec[T] {\n \n     for (option::t[T] o in v) {\n         alt (o) {\n-            case (none[T]) { }\n-            case (some[T](?t)) {\n+            case (none) { }\n+            case (some(?t)) {\n                 res += [t];\n             }\n         }"}]}