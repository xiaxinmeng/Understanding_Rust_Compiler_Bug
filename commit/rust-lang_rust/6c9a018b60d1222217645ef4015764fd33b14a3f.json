{"sha": "6c9a018b60d1222217645ef4015764fd33b14a3f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZjOWEwMThiNjBkMTIyMjIxNzY0NWVmNDAxNTc2NGZkMzNiMTRhM2Y=", "commit": {"author": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2019-05-26T08:55:50Z"}, "committer": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2019-06-06T15:10:37Z"}, "message": "Don't run MIR passes on constructor shims", "tree": {"sha": "e5850a73bdeda19bca5cbe08d81bbf4081dab0e0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e5850a73bdeda19bca5cbe08d81bbf4081dab0e0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6c9a018b60d1222217645ef4015764fd33b14a3f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6c9a018b60d1222217645ef4015764fd33b14a3f", "html_url": "https://github.com/rust-lang/rust/commit/6c9a018b60d1222217645ef4015764fd33b14a3f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6c9a018b60d1222217645ef4015764fd33b14a3f/comments", "author": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8b36867093fb774bcbd9f787cbc470a5f44c1310", "url": "https://api.github.com/repos/rust-lang/rust/commits/8b36867093fb774bcbd9f787cbc470a5f44c1310", "html_url": "https://github.com/rust-lang/rust/commit/8b36867093fb774bcbd9f787cbc470a5f44c1310"}], "stats": {"total": 307, "additions": 152, "deletions": 155}, "files": [{"sha": "74b2faa7a4ce8b160b36ed7c9d4616ebee9cf308", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/6c9a018b60d1222217645ef4015764fd33b14a3f/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c9a018b60d1222217645ef4015764fd33b14a3f/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=6c9a018b60d1222217645ef4015764fd33b14a3f", "patch": "@@ -91,34 +91,6 @@ fn mir_borrowck<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> BorrowC\n     let input_mir = tcx.mir_validated(def_id);\n     debug!(\"run query mir_borrowck: {}\", tcx.def_path_str(def_id));\n \n-    // We are not borrow checking the automatically generated struct/variant constructors\n-    // because we want to accept structs such as this (taken from the `linked-hash-map`\n-    // crate):\n-    // ```rust\n-    // struct Qey<Q: ?Sized>(Q);\n-    // ```\n-    // MIR of this struct constructor looks something like this:\n-    // ```rust\n-    // fn Qey(_1: Q) -> Qey<Q>{\n-    //     let mut _0: Qey<Q>;                  // return place\n-    //\n-    //     bb0: {\n-    //         (_0.0: Q) = move _1;             // bb0[0]: scope 0 at src/main.rs:1:1: 1:26\n-    //         return;                          // bb0[1]: scope 0 at src/main.rs:1:1: 1:26\n-    //     }\n-    // }\n-    // ```\n-    // The problem here is that `(_0.0: Q) = move _1;` is valid only if `Q` is\n-    // of statically known size, which is not known to be true because of the\n-    // `Q: ?Sized` constraint. However, it is true because the constructor can be\n-    // called only when `Q` is of statically known size.\n-    if tcx.is_constructor(def_id) {\n-        return BorrowCheckResult {\n-            closure_requirements: None,\n-            used_mut_upvars: SmallVec::new(),\n-        };\n-    }\n-\n     let opt_closure_req = tcx.infer_ctxt().enter(|infcx| {\n         let input_mir: &Body<'_> = &input_mir.borrow();\n         do_mir_borrowck(&infcx, input_mir, def_id)"}, {"sha": "6bde349390ee8972c74bec1b7c093bfbb1fa0d81", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/6c9a018b60d1222217645ef4015764fd33b14a3f/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c9a018b60d1222217645ef4015764fd33b14a3f/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=6c9a018b60d1222217645ef4015764fd33b14a3f", "patch": "@@ -2,7 +2,6 @@ use crate::build;\n use crate::build::scope::DropKind;\n use crate::hair::cx::Cx;\n use crate::hair::{LintLevel, BindingMode, PatternKind};\n-use crate::shim;\n use crate::transform::MirSource;\n use crate::util as mir_util;\n use rustc::hir;\n@@ -31,8 +30,6 @@ pub fn mir_build<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Body<'\n \n     // Figure out what primary body this item has.\n     let (body_id, return_ty_span) = match tcx.hir().get_by_hir_id(id) {\n-        Node::Ctor(ctor) => return create_constructor_shim(tcx, id, ctor),\n-\n         Node::Expr(hir::Expr { node: hir::ExprKind::Closure(_, decl, body_id, _, _), .. })\n         | Node::Item(hir::Item { node: hir::ItemKind::Fn(decl, _, _, body_id), .. })\n         | Node::ImplItem(\n@@ -234,38 +231,6 @@ impl<'a, 'gcx: 'tcx, 'tcx> MutVisitor<'tcx> for GlobalizeMir<'a, 'gcx> {\n     }\n }\n \n-fn create_constructor_shim<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                     ctor_id: hir::HirId,\n-                                     v: &'tcx hir::VariantData)\n-                                     -> Body<'tcx>\n-{\n-    let span = tcx.hir().span_by_hir_id(ctor_id);\n-    if let hir::VariantData::Tuple(ref fields, ctor_id) = *v {\n-        tcx.infer_ctxt().enter(|infcx| {\n-            let mut mir = shim::build_adt_ctor(&infcx, ctor_id, fields, span);\n-\n-            // Convert the `mir::Body` to global types.\n-            let tcx = infcx.tcx.global_tcx();\n-            let mut globalizer = GlobalizeMir {\n-                tcx,\n-                span: mir.span\n-            };\n-            globalizer.visit_body(&mut mir);\n-            let mir = unsafe {\n-                mem::transmute::<Body<'_>, Body<'tcx>>(mir)\n-            };\n-\n-            mir_util::dump_mir(tcx, None, \"mir_map\", &0,\n-                               MirSource::item(tcx.hir().local_def_id_from_hir_id(ctor_id)),\n-                               &mir, |_, _| Ok(()) );\n-\n-            mir\n-        })\n-    } else {\n-        span_bug!(span, \"attempting to create MIR for non-tuple variant {:?}\", v);\n-    }\n-}\n-\n ///////////////////////////////////////////////////////////////////////////\n // BuildMir -- walks a crate, looking for fn items and methods to build MIR from\n "}, {"sha": "53302810b40525503892cf08502bdd83d24b5180", "filename": "src/librustc_mir/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6c9a018b60d1222217645ef4015764fd33b14a3f/src%2Flibrustc_mir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c9a018b60d1222217645ef4015764fd33b14a3f/src%2Flibrustc_mir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flib.rs?ref=6c9a018b60d1222217645ef4015764fd33b14a3f", "patch": "@@ -22,6 +22,7 @@ Rust MIR: a lowered representation of Rust. Also: an experiment!\n #![feature(unicode_internals)]\n #![feature(step_trait)]\n #![feature(slice_concat_ext)]\n+#![feature(trusted_len)]\n #![feature(try_blocks)]\n \n #![recursion_limit=\"256\"]"}, {"sha": "169e426c1d3c63161b0f083db36f4a7b02432a7b", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 51, "deletions": 31, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/6c9a018b60d1222217645ef4015764fd33b14a3f/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c9a018b60d1222217645ef4015764fd33b14a3f/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=6c9a018b60d1222217645ef4015764fd33b14a3f", "patch": "@@ -1,6 +1,5 @@\n use rustc::hir;\n use rustc::hir::def_id::DefId;\n-use rustc::infer;\n use rustc::mir::*;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::layout::VariantIdx;\n@@ -21,6 +20,7 @@ use crate::transform::{\n };\n use crate::util::elaborate_drops::{self, DropElaborator, DropStyle, DropFlagMode};\n use crate::util::patch::MirPatch;\n+use crate::util::expand_aggregate;\n \n pub fn provide(providers: &mut Providers<'_>) {\n     providers.mir_shims = make_shim;\n@@ -842,29 +842,26 @@ fn build_call_shim<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     mir\n }\n \n-pub fn build_adt_ctor<'a, 'gcx, 'tcx>(infcx: &infer::InferCtxt<'a, 'gcx, 'tcx>,\n-                                      ctor_id: hir::HirId,\n-                                      fields: &[hir::StructField],\n-                                      span: Span)\n-                                      -> Body<'tcx>\n-{\n-    let tcx = infcx.tcx;\n-    let gcx = tcx.global_tcx();\n-    let def_id = tcx.hir().local_def_id_from_hir_id(ctor_id);\n-    let param_env = gcx.param_env(def_id);\n+pub fn build_adt_ctor<'gcx>(tcx: TyCtxt<'_, 'gcx, 'gcx>, ctor_id: DefId) -> &'gcx Body<'gcx> {\n+    debug_assert!(tcx.is_constructor(ctor_id));\n+\n+    let span = tcx.hir().span_if_local(ctor_id)\n+        .unwrap_or_else(|| bug!(\"no span for ctor {:?}\", ctor_id));\n+\n+    let param_env = tcx.param_env(ctor_id);\n \n     // Normalize the sig.\n-    let sig = gcx.fn_sig(def_id)\n+    let sig = tcx.fn_sig(ctor_id)\n         .no_bound_vars()\n         .expect(\"LBR in ADT constructor signature\");\n-    let sig = gcx.normalize_erasing_regions(param_env, sig);\n+    let sig = tcx.normalize_erasing_regions(param_env, sig);\n \n     let (adt_def, substs) = match sig.output().sty {\n         ty::Adt(adt_def, substs) => (adt_def, substs),\n         _ => bug!(\"unexpected type for ADT ctor {:?}\", sig.output())\n     };\n \n-    debug!(\"build_ctor: def_id={:?} sig={:?} fields={:?}\", def_id, sig, fields);\n+    debug!(\"build_ctor: ctor_id={:?} sig={:?}\", ctor_id, sig);\n \n     let local_decls = local_decls_for_sig(&sig, span);\n \n@@ -873,34 +870,45 @@ pub fn build_adt_ctor<'a, 'gcx, 'tcx>(infcx: &infer::InferCtxt<'a, 'gcx, 'tcx>,\n         scope: OUTERMOST_SOURCE_SCOPE\n     };\n \n-    let variant_no = if adt_def.is_enum() {\n-        adt_def.variant_index_with_ctor_id(def_id)\n+    let variant_index = if adt_def.is_enum() {\n+        adt_def.variant_index_with_ctor_id(ctor_id)\n     } else {\n         VariantIdx::new(0)\n     };\n \n-    // return = ADT(arg0, arg1, ...); return\n+    // Generate the following MIR:\n+    //\n+    // (return as Variant).field0 = arg0;\n+    // (return as Variant).field1 = arg1;\n+    //\n+    // return;\n+    debug!(\"build_ctor: variant_index={:?}\", variant_index);\n+\n+    let statements = expand_aggregate(\n+        Place::RETURN_PLACE,\n+        adt_def\n+            .variants[variant_index]\n+            .fields\n+            .iter()\n+            .enumerate()\n+            .map(|(idx, field_def)| (\n+                Operand::Move(Place::Base(PlaceBase::Local(Local::new(idx + 1)))),\n+                field_def.ty(tcx, substs),\n+            )),\n+        AggregateKind::Adt(adt_def, variant_index, substs, None, None),\n+        source_info,\n+    ).collect();\n+\n     let start_block = BasicBlockData {\n-        statements: vec![Statement {\n-            source_info,\n-            kind: StatementKind::Assign(\n-                Place::RETURN_PLACE,\n-                box Rvalue::Aggregate(\n-                    box AggregateKind::Adt(adt_def, variant_no, substs, None, None),\n-                    (1..sig.inputs().len()+1).map(|i| {\n-                        Operand::Move(Place::Base(PlaceBase::Local(Local::new(i))))\n-                    }).collect()\n-                )\n-            )\n-        }],\n+        statements,\n         terminator: Some(Terminator {\n             source_info,\n             kind: TerminatorKind::Return,\n         }),\n         is_cleanup: false\n     };\n \n-    Body::new(\n+    let body = Body::new(\n         IndexVec::from_elem_n(start_block, 1),\n         IndexVec::from_elem_n(\n             SourceScopeData { span: span, parent_scope: None }, 1\n@@ -914,5 +922,17 @@ pub fn build_adt_ctor<'a, 'gcx, 'tcx>(infcx: &infer::InferCtxt<'a, 'gcx, 'tcx>,\n         vec![],\n         span,\n         vec![],\n-    )\n+    );\n+\n+    crate::util::dump_mir(\n+        tcx,\n+        None,\n+        \"mir_map\",\n+        &0,\n+        crate::transform::MirSource::item(ctor_id),\n+        &body,\n+        |_, _| Ok(()),\n+    );\n+\n+    tcx.arena.alloc(body)\n }"}, {"sha": "286c412622dd5db25666f237695a7365d5921a1e", "filename": "src/librustc_mir/transform/deaggregator.rs", "status": "modified", "additions": 10, "deletions": 58, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/6c9a018b60d1222217645ef4015764fd33b14a3f/src%2Flibrustc_mir%2Ftransform%2Fdeaggregator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c9a018b60d1222217645ef4015764fd33b14a3f/src%2Flibrustc_mir%2Ftransform%2Fdeaggregator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fdeaggregator.rs?ref=6c9a018b60d1222217645ef4015764fd33b14a3f", "patch": "@@ -1,8 +1,7 @@\n use rustc::mir::*;\n use rustc::ty::TyCtxt;\n-use rustc::ty::layout::VariantIdx;\n-use rustc_data_structures::indexed_vec::Idx;\n use crate::transform::{MirPass, MirSource};\n+use crate::util::expand_aggregate;\n \n pub struct Deaggregator;\n \n@@ -31,7 +30,7 @@ impl MirPass for Deaggregator {\n \n                 let stmt = stmt.replace_nop();\n                 let source_info = stmt.source_info;\n-                let (mut lhs, kind, operands) = match stmt.kind {\n+                let (lhs, kind, operands) = match stmt.kind {\n                     StatementKind::Assign(lhs, box rvalue) => {\n                         match rvalue {\n                             Rvalue::Aggregate(kind, operands) => (lhs, kind, operands),\n@@ -41,62 +40,15 @@ impl MirPass for Deaggregator {\n                     _ => bug!()\n                 };\n \n-                let mut set_discriminant = None;\n-                let active_field_index = match *kind {\n-                    AggregateKind::Adt(adt_def, variant_index, _, _, active_field_index) => {\n-                        if adt_def.is_enum() {\n-                            set_discriminant = Some(Statement {\n-                                kind: StatementKind::SetDiscriminant {\n-                                    place: lhs.clone(),\n-                                    variant_index,\n-                                },\n-                                source_info,\n-                            });\n-                            lhs = lhs.downcast(adt_def, variant_index);\n-                        }\n-                        active_field_index\n-                    }\n-                    AggregateKind::Generator(..) => {\n-                        // Right now we only support initializing generators to\n-                        // variant 0 (Unresumed).\n-                        let variant_index = VariantIdx::new(0);\n-                        set_discriminant = Some(Statement {\n-                            kind: StatementKind::SetDiscriminant {\n-                                place: lhs.clone(),\n-                                variant_index,\n-                            },\n-                            source_info,\n-                        });\n-\n-                        // Operands are upvars stored on the base place, so no\n-                        // downcast is necessary.\n-\n-                        None\n-                    }\n-                    _ => None\n-                };\n-\n-                Some(operands.into_iter().enumerate().map(move |(i, op)| {\n-                    let lhs_field = if let AggregateKind::Array(_) = *kind {\n-                        // FIXME(eddyb) `offset` should be u64.\n-                        let offset = i as u32;\n-                        assert_eq!(offset as usize, i);\n-                        lhs.clone().elem(ProjectionElem::ConstantIndex {\n-                            offset,\n-                            // FIXME(eddyb) `min_length` doesn't appear to be used.\n-                            min_length: offset + 1,\n-                            from_end: false\n-                        })\n-                    } else {\n+                Some(expand_aggregate(\n+                    lhs,\n+                    operands.into_iter().map(|op| {\n                         let ty = op.ty(local_decls, tcx);\n-                        let field = Field::new(active_field_index.unwrap_or(i));\n-                        lhs.clone().field(field, ty)\n-                    };\n-                    Statement {\n-                        source_info,\n-                        kind: StatementKind::Assign(lhs_field, box Rvalue::Use(op)),\n-                    }\n-                }).chain(set_discriminant))\n+                        (op, ty)\n+                    }),\n+                    *kind,\n+                    source_info,\n+                ))\n             });\n         }\n     }"}, {"sha": "cc8aaa1c97fb398d0f10876b37887c35efa07538", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6c9a018b60d1222217645ef4015764fd33b14a3f/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c9a018b60d1222217645ef4015764fd33b14a3f/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=6c9a018b60d1222217645ef4015764fd33b14a3f", "patch": "@@ -1,4 +1,4 @@\n-use crate::build;\n+use crate::{build, shim};\n use rustc::hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n use rustc::mir::{Body, MirPhase, Promoted};\n use rustc::ty::{TyCtxt, InstanceDef};\n@@ -228,7 +228,15 @@ fn mir_validated<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx\n }\n \n fn optimized_mir<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx Body<'tcx> {\n-    // `mir_borrowck` uses `mir_validated`, so we have to force it to\n+    if tcx.is_constructor(def_id) {\n+        // There's no reason to run all of the MIR passes on constructors when\n+        // we can just output the MIR we want directly. This also saves const\n+        // qualification and borrow checking the trouble of special casing\n+        // constructors.\n+        return shim::build_adt_ctor(tcx, def_id);\n+    }\n+\n+    // (Mir-)Borrowck uses `mir_validated`, so we have to force it to\n     // execute before we can steal.\n     tcx.ensure().mir_borrowck(def_id);\n "}, {"sha": "98e70671ab71562bfc1a0007eba8fdf58eacc9b6", "filename": "src/librustc_mir/util/aggregate.rs", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/6c9a018b60d1222217645ef4015764fd33b14a3f/src%2Flibrustc_mir%2Futil%2Faggregate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c9a018b60d1222217645ef4015764fd33b14a3f/src%2Flibrustc_mir%2Futil%2Faggregate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Faggregate.rs?ref=6c9a018b60d1222217645ef4015764fd33b14a3f", "patch": "@@ -0,0 +1,76 @@\n+use rustc::mir::*;\n+use rustc::ty::Ty;\n+use rustc::ty::layout::VariantIdx;\n+use rustc_data_structures::indexed_vec::Idx;\n+\n+use std::iter::TrustedLen;\n+\n+/// Expand `lhs = Rvalue::Aggregate(kind, operands)` into assignments to the fields.\n+///\n+/// Produces something like\n+///\n+/// (lhs as Variant).field0 = arg0;     // We only have a downcast if this is an enum\n+/// (lhs as Variant).field1 = arg1;\n+/// discriminant(lhs) = variant_index;  // If lhs is an enum or generator.\n+pub fn expand_aggregate<'tcx>(\n+    mut lhs: Place<'tcx>,\n+    operands: impl Iterator<Item=(Operand<'tcx>, Ty<'tcx>)> + TrustedLen,\n+    kind: AggregateKind<'tcx>,\n+    source_info: SourceInfo,\n+) -> impl Iterator<Item=Statement<'tcx>> + TrustedLen {\n+    let mut set_discriminant = None;\n+    let active_field_index = match kind {\n+        AggregateKind::Adt(adt_def, variant_index, _, _, active_field_index) => {\n+            if adt_def.is_enum() {\n+                set_discriminant = Some(Statement {\n+                    kind: StatementKind::SetDiscriminant {\n+                        place: lhs.clone(),\n+                        variant_index,\n+                    },\n+                    source_info,\n+                });\n+                lhs = lhs.downcast(adt_def, variant_index);\n+            }\n+            active_field_index\n+        }\n+        AggregateKind::Generator(..) => {\n+            // Right now we only support initializing generators to\n+            // variant 0 (Unresumed).\n+            let variant_index = VariantIdx::new(0);\n+            set_discriminant = Some(Statement {\n+                kind: StatementKind::SetDiscriminant {\n+                    place: lhs.clone(),\n+                    variant_index,\n+                },\n+                source_info,\n+            });\n+\n+            // Operands are upvars stored on the base place, so no\n+            // downcast is necessary.\n+\n+            None\n+        }\n+        _ => None\n+    };\n+\n+    operands.into_iter().enumerate().map(move |(i, (op, ty))| {\n+        let lhs_field = if let AggregateKind::Array(_) = kind {\n+            // FIXME(eddyb) `offset` should be u64.\n+            let offset = i as u32;\n+            assert_eq!(offset as usize, i);\n+            lhs.clone().elem(ProjectionElem::ConstantIndex {\n+                offset,\n+                // FIXME(eddyb) `min_length` doesn't appear to be used.\n+                min_length: offset + 1,\n+                from_end: false\n+            })\n+        } else {\n+            let field = Field::new(active_field_index.unwrap_or(i));\n+            lhs.clone().field(field, ty)\n+        };\n+        Statement {\n+            source_info,\n+            kind: StatementKind::Assign(lhs_field, box Rvalue::Use(op)),\n+        }\n+    }).chain(set_discriminant)\n+}"}, {"sha": "e340029434d815416e4b667de3beb1b2dc4aebbb", "filename": "src/librustc_mir/util/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c9a018b60d1222217645ef4015764fd33b14a3f/src%2Flibrustc_mir%2Futil%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c9a018b60d1222217645ef4015764fd33b14a3f/src%2Flibrustc_mir%2Futil%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fmod.rs?ref=6c9a018b60d1222217645ef4015764fd33b14a3f", "patch": "@@ -2,6 +2,7 @@ use core::unicode::property::Pattern_White_Space;\n use rustc::ty::TyCtxt;\n use syntax_pos::Span;\n \n+pub mod aggregate;\n pub mod borrowck_errors;\n pub mod elaborate_drops;\n pub mod def_use;\n@@ -13,6 +14,7 @@ pub(crate) mod pretty;\n pub mod liveness;\n pub mod collect_writes;\n \n+pub use self::aggregate::expand_aggregate;\n pub use self::alignment::is_disaligned;\n pub use self::pretty::{dump_enabled, dump_mir, write_mir_pretty, PassWhere};\n pub use self::graphviz::{graphviz_safe_def_name, write_mir_graphviz};"}, {"sha": "f4d848dfc7ad12084dcf1ddee976683794cc7a8f", "filename": "src/test/mir-opt/unusual-item-types.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6c9a018b60d1222217645ef4015764fd33b14a3f/src%2Ftest%2Fmir-opt%2Funusual-item-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c9a018b60d1222217645ef4015764fd33b14a3f/src%2Ftest%2Fmir-opt%2Funusual-item-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Funusual-item-types.rs?ref=6c9a018b60d1222217645ef4015764fd33b14a3f", "patch": "@@ -78,7 +78,8 @@ fn main() {\n //     let mut _0: Test;\n //\n //     bb0: {\n-//         _0 = Test::X(move _1,);\n+//         ((_0 as X).0: usize) = move _1;\n+//         discriminant(_0) = 0;\n //         return;\n //     }\n // }"}]}