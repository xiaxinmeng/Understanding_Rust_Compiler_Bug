{"sha": "97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk3NDIyZjBmMGZkY2JkZDE3YTc2OWZhOTU4OGU3NmI4YmY4YTViZGY=", "commit": {"author": {"name": "Paul Stansifer", "email": "paul.stansifer@gmail.com", "date": "2012-07-26T23:16:28Z"}, "committer": {"name": "Paul Stansifer", "email": "paul.stansifer@gmail.com", "date": "2012-07-26T23:16:28Z"}, "message": "Merge branch 'incoming' of github.com:mozilla/rust", "tree": {"sha": "a91f89c585b54fccf34cd873d2488d2cb3c09909", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a91f89c585b54fccf34cd873d2488d2cb3c09909"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf", "html_url": "https://github.com/rust-lang/rust/commit/97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf/comments", "author": {"login": "paulstansifer", "id": 1431, "node_id": "MDQ6VXNlcjE0MzE=", "avatar_url": "https://avatars.githubusercontent.com/u/1431?v=4", "gravatar_id": "", "url": "https://api.github.com/users/paulstansifer", "html_url": "https://github.com/paulstansifer", "followers_url": "https://api.github.com/users/paulstansifer/followers", "following_url": "https://api.github.com/users/paulstansifer/following{/other_user}", "gists_url": "https://api.github.com/users/paulstansifer/gists{/gist_id}", "starred_url": "https://api.github.com/users/paulstansifer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/paulstansifer/subscriptions", "organizations_url": "https://api.github.com/users/paulstansifer/orgs", "repos_url": "https://api.github.com/users/paulstansifer/repos", "events_url": "https://api.github.com/users/paulstansifer/events{/privacy}", "received_events_url": "https://api.github.com/users/paulstansifer/received_events", "type": "User", "site_admin": false}, "committer": {"login": "paulstansifer", "id": 1431, "node_id": "MDQ6VXNlcjE0MzE=", "avatar_url": "https://avatars.githubusercontent.com/u/1431?v=4", "gravatar_id": "", "url": "https://api.github.com/users/paulstansifer", "html_url": "https://github.com/paulstansifer", "followers_url": "https://api.github.com/users/paulstansifer/followers", "following_url": "https://api.github.com/users/paulstansifer/following{/other_user}", "gists_url": "https://api.github.com/users/paulstansifer/gists{/gist_id}", "starred_url": "https://api.github.com/users/paulstansifer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/paulstansifer/subscriptions", "organizations_url": "https://api.github.com/users/paulstansifer/orgs", "repos_url": "https://api.github.com/users/paulstansifer/repos", "events_url": "https://api.github.com/users/paulstansifer/events{/privacy}", "received_events_url": "https://api.github.com/users/paulstansifer/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8209b2e9b383b9e38a09b1ec79c7b5691aeb5d22", "url": "https://api.github.com/repos/rust-lang/rust/commits/8209b2e9b383b9e38a09b1ec79c7b5691aeb5d22", "html_url": "https://github.com/rust-lang/rust/commit/8209b2e9b383b9e38a09b1ec79c7b5691aeb5d22"}, {"sha": "44631722ff234241cb7100103320a402fe4fdfa9", "url": "https://api.github.com/repos/rust-lang/rust/commits/44631722ff234241cb7100103320a402fe4fdfa9", "html_url": "https://github.com/rust-lang/rust/commit/44631722ff234241cb7100103320a402fe4fdfa9"}], "stats": {"total": 1306, "additions": 834, "deletions": 472}, "files": [{"sha": "ed32100c6fc644f3d952b517c73f03c3cd96f4b1", "filename": "doc/tutorial.md", "status": "modified", "additions": 59, "deletions": 52, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf", "patch": "@@ -34,8 +34,9 @@ high-level features include:\n * ***Higher-order functions.*** Rust functions may take closures as\n   arguments or return closures as return values.  Closures in Rust are\n   very powerful and used pervasively.\n-* ***Interface polymorphism.*** Rust's type system features a unique\n-  combination of Java-style interfaces and Haskell-style typeclasses.\n+* ***Trait polymorphism.*** Rust's type system features a unique\n+  combination of Java-style interfaces and Haskell-style typeclasses\n+  called _traits_.\n * ***Parametric polymorphism (generics).*** Functions and types can be\n   parameterized over type variables with optional type constraints.\n * ***Type inference.*** Type annotations on local variable\n@@ -734,9 +735,12 @@ of numeric literal patterns can be expressed with `to`. The underscore\n (`_`) is a wildcard pattern that matches everything.\n \n If the arm with the wildcard pattern was left off in the above\n-example, running it on a number greater than ten (or negative) would\n-cause a run-time failure. When no arm matches, `alt` constructs do not\n-silently fall through\u2014they blow up instead.\n+example, the typechecker would reject it at compile time. `alt`\n+constructs must be exhaustive: they must have an arm covering every\n+possible case. (You may use the `alt check` construct to write a\n+non-exhaustive match, but it's highly undesirable to do so. You may\n+reason that the missing cases will never occur, but the typechecker\n+provides you with no assurance that your reasoning is correct.)\n \n A powerful application of pattern matching is *destructuring*, where\n you use the matching to get at the contents of data types. Remember\n@@ -2089,9 +2093,9 @@ resource type. Rust has several kinds that can be used as type bounds:\n   mutable fields nor shared boxes.\n \n > ***Note:*** Rust type kinds are syntactically very similar to\n-> [interfaces](#interfaces) when used as type bounds, and can be\n-> conveniently thought of as built-in interfaces. In the future type\n-> kinds will actually be interfaces that the compiler has special\n+> [traits](#traits) when used as type bounds, and can be\n+> conveniently thought of as built-in traits. In the future type\n+> kinds will actually be traits that the compiler has special\n > knowledge about.\n \n ## Generic functions and argument-passing\n@@ -2388,9 +2392,9 @@ This makes it possible to rebind a variable without actually mutating\n it, which is mostly useful for destructuring (which can rebind, but\n not assign).\n \n-# Interfaces\n+# Traits\n \n-Interfaces are Rust's take on value polymorphism\u2014the thing that\n+Traits are Rust's take on value polymorphism\u2014the thing that\n object-oriented languages tend to solve with methods and inheritance.\n For example, writing a function that can operate on multiple types of\n collections.\n@@ -2400,27 +2404,27 @@ collections.\n \n ## Declaration\n \n-An interface consists of a set of methods. A method is a function that\n+A trait consists of a set of methods. A method is a function that\n can be applied to a `self` value and a number of arguments, using the\n dot notation: `self.foo(arg1, arg2)`.\n \n-For example, we could declare the interface `to_str` for things that\n+For example, we could declare the trait `to_str` for things that\n can be converted to a string, with a single method of the same name:\n \n ~~~~\n-iface to_str {\n+trait to_str {\n     fn to_str() -> ~str;\n }\n ~~~~\n \n ## Implementation\n \n-To actually implement an interface for a given type, the `impl` form\n+To actually implement an trait for a given type, the `impl` form\n is used. This defines implementations of `to_str` for the `int` and\n `~str` types.\n \n ~~~~\n-# iface to_str { fn to_str() -> ~str; }\n+# trait to_str { fn to_str() -> ~str; }\n impl of to_str for int {\n     fn to_str() -> ~str { int::to_str(self, 10u) }\n }\n@@ -2439,13 +2443,13 @@ method that matches the name, and simply calls that.\n \n Implementations are not globally visible. Resolving a method to an\n implementation requires that implementation to be in scope. You can\n-import and export implementations using the name of the interface they\n+import and export implementations using the name of the trait they\n implement (multiple implementations with the same name can be in scope\n without problems). Or you can give them an explicit name if you\n prefer, using this syntax:\n \n ~~~~\n-# iface to_str { fn to_str() -> ~str; }\n+# trait to_str { fn to_str() -> ~str; }\n impl nil_to_str of to_str for () {\n     fn to_str() -> ~str { ~\"()\" }\n }\n@@ -2461,7 +2465,7 @@ known at compile time, it is possible to specify 'bounds' for type\n parameters.\n \n ~~~~\n-# iface to_str { fn to_str() -> ~str; }\n+# trait to_str { fn to_str() -> ~str; }\n fn comma_sep<T: to_str>(elts: ~[T]) -> ~str {\n     let mut result = ~\"\", first = true;\n     for elts.each |elt| {\n@@ -2476,18 +2480,18 @@ fn comma_sep<T: to_str>(elts: ~[T]) -> ~str {\n The syntax for this is similar to the syntax for specifying that a\n parameter type has to be copyable (which is, in principle, another\n kind of bound). By declaring `T` as conforming to the `to_str`\n-interface, it becomes possible to call methods from that interface on\n+trait, it becomes possible to call methods from that trait on\n values of that type inside the function. It will also cause a\n compile-time error when anyone tries to call `comma_sep` on an array\n whose element type does not have a `to_str` implementation in scope.\n \n-## Polymorphic interfaces\n+## Polymorphic traits\n \n-Interfaces may contain type parameters. This defines an interface for\n+Traits may contain type parameters. This defines a trait for\n generalized sequence types:\n \n ~~~~\n-iface seq<T> {\n+trait seq<T> {\n     fn len() -> uint;\n     fn iter(fn(T));\n }\n@@ -2499,26 +2503,26 @@ impl <T> of seq<T> for ~[T] {\n }\n ~~~~\n \n-Note that the implementation has to explicitly declare the its\n-parameter `T` before using it to specify its interface type. This is\n+Note that the implementation has to explicitly declare the type\n+parameter that it binds, `T`, before using it to specify its trait type. This is\n needed because it could also, for example, specify an implementation\n of `seq<int>`\u2014the `of` clause *refers* to a type, rather than defining\n one.\n \n-The type parameters bound by an iface are in scope in each of the\n+The type parameters bound by a trait are in scope in each of the\n method declarations. So, re-declaring the type parameter\n-`T` as an explicit type parameter for `len` -- in either the iface or\n+`T` as an explicit type parameter for `len` -- in either the trait or\n the impl -- would be a compile-time error.\n \n-## The `self` type in interfaces\n+## The `self` type in traits\n \n-In an interface, `self` is a special type that you can think of as a\n-type parameter. An implementation of the interface for any given type\n+In a trait, `self` is a special type that you can think of as a\n+type parameter. An implementation of the trait for any given type\n `T` replaces the `self` type parameter with `T`. The following\n-interface describes types that support an equality operation:\n+trait describes types that support an equality operation:\n \n ~~~~\n-iface eq {\n+trait eq {\n   fn equals(&&other: self) -> bool;\n }\n \n@@ -2530,15 +2534,15 @@ impl of eq for int {\n Notice that `equals` takes an `int` argument, rather than a `self` argument, in\n an implementation for type `int`.\n \n-## Casting to an interface type\n+## Casting to an trait type\n \n The above allows us to define functions that polymorphically act on\n-values of *an* unknown type that conforms to a given interface.\n+values of *an* unknown type that conforms to a given trait.\n However, consider this function:\n \n ~~~~\n # type circle = int; type rectangle = int;\n-# iface drawable { fn draw(); }\n+# trait drawable { fn draw(); }\n # impl of drawable for int { fn draw() {} }\n # fn new_circle() -> int { 1 }\n fn draw_all<T: drawable>(shapes: ~[T]) {\n@@ -2549,14 +2553,14 @@ fn draw_all<T: drawable>(shapes: ~[T]) {\n ~~~~\n \n You can call that on an array of circles, or an array of squares\n-(assuming those have suitable `drawable` interfaces defined), but not\n+(assuming those have suitable `drawable` traits defined), but not\n on an array containing both circles and squares.\n \n-When this is needed, an interface name can be used as a type, causing\n+When this is needed, a trait name can be used as a type, causing\n the function to be written simply like this:\n \n ~~~~\n-# iface drawable { fn draw(); }\n+# trait drawable { fn draw(); }\n fn draw_all(shapes: ~[drawable]) {\n     for shapes.each |shape| { shape.draw(); }\n }\n@@ -2571,11 +2575,11 @@ is very similar to the 'vtables' used in most object-oriented\n languages.\n \n To construct such a value, you use the `as` operator to cast a value\n-to an interface type:\n+to a trait type:\n \n ~~~~\n # type circle = int; type rectangle = int;\n-# iface drawable { fn draw(); }\n+# trait drawable { fn draw(); }\n # impl of drawable for int { fn draw() {} }\n # fn new_circle() -> int { 1 }\n # fn new_rectangle() -> int { 2 }\n@@ -2594,10 +2598,10 @@ Note that the allocation of a box is somewhat more expensive than\n simply using a type parameter and passing in the value as-is, and much\n more expensive than statically resolved method calls.\n \n-## Interface-less implementations\n+## Trait-less implementations\n \n If you only intend to use an implementation for static overloading,\n-and there is no interface available that it conforms to, you are free\n+and there is no trait available that it conforms to, you are free\n to leave off the `of` clause.  However, this is only possible when you\n are defining an implementation in the same module as the receiver\n type, and the receiver type is a named type (i.e., an enum or a\n@@ -2620,9 +2624,10 @@ OpenSSL libraries installed, it should 'just work'.\n \n ~~~~ {.xfail-test}\n use std;\n+import libc::c_uint;\n \n extern mod crypto {\n-    fn SHA1(src: *u8, sz: uint, out: *u8) -> *u8;\n+    fn SHA1(src: *u8, sz: c_uint, out: *u8) -> *u8;\n }\n \n fn as_hex(data: ~[u8]) -> ~str {\n@@ -2634,7 +2639,7 @@ fn as_hex(data: ~[u8]) -> ~str {\n fn sha1(data: ~str) -> ~str unsafe {\n     let bytes = str::bytes(data);\n     let hash = crypto::SHA1(vec::unsafe::to_ptr(bytes),\n-                            vec::len(bytes), ptr::null());\n+                            vec::len(bytes) as c_uint, ptr::null());\n     ret as_hex(vec::unsafe::from_buf(hash, 20u));\n }\n \n@@ -2700,7 +2705,7 @@ return a pointer.\n \n ~~~~ {.xfail-test}\n # extern mod crypto {\n-fn SHA1(src: *u8, sz: uint, out: *u8) -> *u8;\n+fn SHA1(src: *u8, sz: libc::c_uint, out: *u8) -> *u8;\n # }\n ~~~~\n \n@@ -2791,7 +2796,7 @@ This pointer will become invalid as soon as the vector it points into\n is cleaned up, so you should be very careful how you use it. In this\n case, the local variable `bytes` outlives the pointer, so we're good.\n \n-Passing a null pointer as third argument to `SHA1` causes it to use a\n+Passing a null pointer as the third argument to `SHA1` makes it use a\n static buffer, and thus save us the effort of allocating memory\n ourselves. `ptr::null` is a generic function that will return an\n unsafe null pointer of the correct type (Rust generics are awesome\n@@ -2814,15 +2819,17 @@ microsecond-resolution timer.\n \n ~~~~\n use std;\n-type timeval = {mut tv_sec: uint,\n-                mut tv_usec: uint};\n+import libc::c_ulonglong;\n+\n+type timeval = {mut tv_sec: c_ulonglong,\n+                mut tv_usec: c_ulonglong};\n #[nolink]\n-extern mod libc {\n+extern mod lib_c {\n     fn gettimeofday(tv: *timeval, tz: *()) -> i32;\n }\n fn unix_time_in_microseconds() -> u64 unsafe {\n-    let x = {mut tv_sec: 0u, mut tv_usec: 0u};\n-    libc::gettimeofday(ptr::addr_of(x), ptr::null());\n+    let x = {mut tv_sec: 0 as c_ulonglong, mut tv_usec: 0 as c_ulonglong};\n+    lib_c::gettimeofday(ptr::addr_of(x), ptr::null());\n     ret (x.tv_sec as u64) * 1000_000_u64 + (x.tv_usec as u64);\n }\n \n@@ -2838,8 +2845,8 @@ define a record type with the same contents, and declare\n \n The second argument to `gettimeofday` (the time zone) is not used by\n this program, so it simply declares it to be a pointer to the nil\n-type. Since null pointer look the same, no matter which type they are\n-supposed to point at, this is safe.\n+type. Since all null pointers have the same representation regardless of\n+their referent type, this is safe.\n \n # Tasks\n "}, {"sha": "cf33cff82ea5c194b77abb8f08be56a2a5232995", "filename": "mk/tests.mk", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf/mk%2Ftests.mk", "raw_url": "https://github.com/rust-lang/rust/raw/97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf/mk%2Ftests.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftests.mk?ref=97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf", "patch": "@@ -95,6 +95,9 @@ cleantestlibs:\n check: cleantestlibs cleantmptestlogs tidy all check-stage2\n \t$(Q)$(S)src/etc/check-summary.py tmp/*.log\n \n+check-notidy: cleantestlibs cleantmptestlogs all check-stage2\n+\t$(Q)$(S)src/etc/check-summary.py tmp/*.log\n+\n check-full: cleantestlibs cleantmptestlogs tidy \\\n             all check-stage1 check-stage2 check-stage3\n \t$(Q)$(S)src/etc/check-summary.py tmp/*.log"}, {"sha": "9c46df9731b93fdeae925b8e0ab968d4f40c13e5", "filename": "src/libcore/arc.rs", "status": "modified", "additions": 1, "deletions": 64, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf/src%2Flibcore%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf/src%2Flibcore%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Farc.rs?ref=97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf", "patch": "@@ -3,10 +3,9 @@\n  * share immutable data between tasks.\n  */\n \n-import comm::{port, chan, methods};\n import sys::methods;\n \n-export arc, get, clone, shared_arc, get_arc;\n+export arc, get, clone;\n \n export exclusive, methods;\n \n@@ -122,49 +121,6 @@ impl methods<T: send> for exclusive<T> {\n     }\n }\n \n-// Convenience code for sharing arcs between tasks\n-\n-type get_chan<T: const send> = chan<chan<arc<T>>>;\n-\n-// (terminate, get)\n-type shared_arc<T: const send> = (shared_arc_res, get_chan<T>);\n-\n-class shared_arc_res {\n-   let c: comm::chan<()>;\n-   new(c: comm::chan<()>) { self.c = c; }\n-   drop { self.c.send(()); }\n-}\n-\n-fn shared_arc<T: send const>(-data: T) -> shared_arc<T> {\n-    let a = arc::arc(data);\n-    let p = port();\n-    let c = chan(p);\n-    do task::spawn() |move a| {\n-        let mut live = true;\n-        let terminate = port();\n-        let get = port();\n-\n-        c.send((chan(terminate), chan(get)));\n-\n-        while live {\n-            alt comm::select2(terminate, get) {\n-              either::left(()) { live = false; }\n-              either::right(cc) {\n-                comm::send(cc, arc::clone(&a));\n-              }\n-            }\n-        }\n-    };\n-    let (terminate, get) = p.recv();\n-    (shared_arc_res(terminate), get)\n-}\n-\n-fn get_arc<T: send const>(c: get_chan<T>) -> arc::arc<T> {\n-    let p = port();\n-    c.send(chan(p));\n-    p.recv()\n-}\n-\n #[cfg(test)]\n mod tests {\n     import comm::*;\n@@ -196,25 +152,6 @@ mod tests {\n         log(info, arc_v);\n     }\n \n-    #[test]\n-    fn auto_share_arc() {\n-        let v = ~[1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n-        let (_res, arc_c) = shared_arc(v);\n-\n-        let p = port();\n-        let c = chan(p);\n-\n-        do task::spawn() {\n-            let arc_v = get_arc(arc_c);\n-            let v = *get(&arc_v);\n-            assert v[2] == 3;\n-\n-            c.send(());\n-        };\n-\n-        assert p.recv() == ();\n-    }\n-\n     #[test]\n     #[ignore] // this can probably infinite loop too.\n     fn exclusive_arc() {"}, {"sha": "d10b9603af0dd7d6fed1aafc0c380e95a2f645a2", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf", "patch": "@@ -1,10 +1,10 @@\n /// Interfaces used for comparison.\n \n-iface ord {\n-    fn lt(&&other: self) -> bool;\n+trait ord {\n+    pure fn lt(&&other: self) -> bool;\n }\n \n-iface eq {\n-    fn eq(&&other: self) -> bool;\n+trait eq {\n+    pure fn eq(&&other: self) -> bool;\n }\n "}, {"sha": "11e305e22e8b01119fac94925f6b7269be5720d0", "filename": "src/libcore/core.rc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf/src%2Flibcore%2Fcore.rc", "raw_url": "https://github.com/rust-lang/rust/raw/97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf/src%2Flibcore%2Fcore.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcore.rc?ref=97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf", "patch": "@@ -161,6 +161,7 @@ mod tuple;\n \n // Ubiquitous-utility-type modules\n \n+mod ops;\n mod cmp;\n mod num;\n mod hash;"}, {"sha": "fdf5352418887599e4595e6fff5b9a0da96c2d79", "filename": "src/libcore/core.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf/src%2Flibcore%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf/src%2Flibcore%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcore.rs?ref=97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf", "patch": "@@ -30,6 +30,8 @@ import float::num;\n import f32::num;\n import f64::num;\n import num::num;\n+import ops::{const, copy, send, owned};\n+import ops::{add, sub, mul, div, modulo, neg, bitops, index};\n \n export path, option, some, none, unreachable;\n export extensions;\n@@ -42,6 +44,9 @@ export immutable_copyable_vector, iter_trait_extensions, vec_concat;\n export base_iter, copyable_iter, extended_iter;\n export tuple_ops, extended_tuple_ops;\n export ptr;\n+// The following exports are the core operators and kinds\n+export const, copy, send, owned;\n+export add, sub, mul, div, modulo, neg, bitops, index;\n \n // Export the log levels as global constants. Higher levels mean\n // more-verbosity. Error is the bottom level, default logging level is"}, {"sha": "cd36d14816cb482428d23cc1c21d3a3570e28403", "filename": "src/libcore/dlist.rs", "status": "modified", "additions": 61, "deletions": 38, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf/src%2Flibcore%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf/src%2Flibcore%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fdlist.rs?ref=97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf", "patch": "@@ -18,12 +18,28 @@ enum dlist_node<T> = @{\n     mut next: dlist_link<T>\n };\n \n-// Needs to be an @-box so nodes can back-reference it.\n-enum dlist<T> = @{\n-    mut size: uint,\n-    mut hd: dlist_link<T>,\n-    mut tl: dlist_link<T>\n-};\n+class dlist_root<T> {\n+    let mut size: uint;\n+    let mut hd:   dlist_link<T>;\n+    let mut tl:   dlist_link<T>;\n+    new() {\n+        self.size = 0; self.hd = none; self.tl = none;\n+    }\n+    drop {\n+        /* FIXME (#????) This doesn't work during task failure - the box\n+         * annihilator might have killed some of our nodes already. This will\n+         * be safe to uncomment when the box annihilator is safer. As is,\n+         * this makes test_dlist_cyclic_link below crash the runtime.\n+        // Empty the list. Not doing this explicitly would leave cyclic links\n+        // around, not to be freed until cycle collection at task exit.\n+        while self.hd.is_some() {\n+            self.unlink(self.hd.get());\n+        }\n+        */\n+    }\n+}\n+\n+type dlist<T> = @dlist_root<T>;\n \n impl private_methods<T> for dlist_node<T> {\n     pure fn assert_links() {\n@@ -91,7 +107,7 @@ pure fn new_dlist_node<T>(+data: T) -> dlist_node<T> {\n \n /// Creates a new, empty dlist.\n pure fn new_dlist<T>() -> dlist<T> {\n-    dlist(@{mut size: 0, mut hd: none, mut tl: none})\n+    @unchecked { dlist_root() }\n }\n \n /// Creates a new dlist with a single element\n@@ -118,7 +134,7 @@ fn concat<T>(lists: dlist<dlist<T>>) -> dlist<T> {\n     result\n }\n \n-impl private_methods<T> for dlist<T> {\n+impl private_methods<T> for dlist_root<T> {\n     pure fn new_link(-data: T) -> dlist_link<T> {\n         some(dlist_node(@{data: data, mut linked: true,\n                           mut prev: none, mut next: none}))\n@@ -288,20 +304,6 @@ impl extensions<T> for dlist<T> {\n         tl.map(|nobe| self.unlink(nobe));\n         tl\n     }\n-    /// Remove data from the head of the list. O(1).\n-    fn pop() -> option<T> {\n-        do option::map_consume(self.pop_n()) |nobe| {\n-            let dlist_node(@{ data: x, _ }) <- nobe;\n-            x\n-        }\n-    }\n-    /// Remove data from the tail of the list. O(1).\n-    fn pop_tail() -> option<T> {\n-        do option::map_consume(self.pop_tail_n()) |nobe| {\n-            let dlist_node(@{ data: x, _ }) <- nobe;\n-            x\n-        }\n-    }\n     /// Get the node at the list's head. O(1).\n     pure fn peek_n() -> option<dlist_node<T>> { self.hd }\n     /// Get the node at the list's tail. O(1).\n@@ -334,7 +336,7 @@ impl extensions<T> for dlist<T> {\n      * to the other list's head. O(1).\n      */\n     fn append(them: dlist<T>) {\n-        if box::ptr_eq(*self, *them) {\n+        if box::ptr_eq(self, them) {\n             fail ~\"Cannot append a dlist to itself!\"\n         }\n         if them.len() > 0 {\n@@ -351,7 +353,7 @@ impl extensions<T> for dlist<T> {\n      * list's tail to this list's head. O(1).\n      */\n     fn prepend(them: dlist<T>) {\n-        if box::ptr_eq(*self, *them) {\n+        if box::ptr_eq(self, them) {\n             fail ~\"Cannot prepend a dlist to itself!\"\n         }\n         if them.len() > 0 {\n@@ -366,15 +368,25 @@ impl extensions<T> for dlist<T> {\n \n     /// Reverse the list's elements in place. O(n).\n     fn reverse() {\n-        let temp = new_dlist::<T>();\n+        do option::while_some(self.hd) |nobe| {\n+            let next_nobe = nobe.next;\n+            self.remove(nobe);\n+            self.make_mine(nobe);\n+            self.add_head(some(nobe));\n+            next_nobe\n+        }\n+    }\n+\n+    /**\n+     * Remove everything from the list. This is important because the cyclic\n+     * links won't otherwise be automatically refcounted-collected. O(n).\n+     */\n+    fn clear() {\n+        // Cute as it would be to simply detach the list and proclaim \"O(1)!\",\n+        // the GC would still be a hidden O(n). Better to be honest about it.\n         while !self.is_empty() {\n-            let nobe = self.pop_n().get();\n-            nobe.linked = true; // meh, kind of disorganised.\n-            temp.add_head(some(nobe));\n+            let _ = self.pop_n();\n         }\n-        self.hd   = temp.hd;\n-        self.tl   = temp.tl;\n-        self.size = temp.size;\n     }\n \n     /// Iterate over nodes.\n@@ -431,6 +443,10 @@ impl extensions<T> for dlist<T> {\n }\n \n impl extensions<T: copy> for dlist<T> {\n+    /// Remove data from the head of the list. O(1).\n+    fn pop()       -> option<T> { self.pop_n().map       (|nobe| nobe.data) }\n+    /// Remove data from the tail of the list. O(1).\n+    fn pop_tail()  -> option<T> { self.pop_tail_n().map  (|nobe| nobe.data) }\n     /// Get data at the list's head. O(1).\n     pure fn peek() -> option<T> { self.peek_n().map      (|nobe| nobe.data) }\n     /// Get data at the list's tail. O(1).\n@@ -596,6 +612,13 @@ mod tests {\n         a.assert_consistent(); assert a.is_empty();\n     }\n     #[test]\n+    fn test_dlist_clear() {\n+        let a = from_vec(~[5,4,3,2,1]);\n+        a.clear();\n+        assert a.len() == 0;\n+        a.assert_consistent();\n+    }\n+    #[test]\n     fn test_dlist_is_empty() {\n         let empty = new_dlist::<int>();\n         let full1 = from_vec(~[1,2,3]);\n@@ -847,15 +870,15 @@ mod tests {\n         l.assert_consistent(); assert l.is_empty();\n     }\n     #[test] #[should_fail] #[ignore(cfg(windows))]\n-    fn test_asymmetric_link() {\n+    fn test_dlist_asymmetric_link() {\n         let l = new_dlist::<int>();\n         let _one = l.push_n(1);\n         let two = l.push_n(2);\n         two.prev = none;\n         l.assert_consistent();\n     }\n     #[test] #[should_fail] #[ignore(cfg(windows))]\n-    fn test_cyclic_list() {\n+    fn test_dlist_cyclic_list() {\n         let l = new_dlist::<int>();\n         let one = l.push_n(1);\n         let _two = l.push_n(2);\n@@ -865,32 +888,32 @@ mod tests {\n         l.assert_consistent();\n     }\n     #[test] #[should_fail] #[ignore(cfg(windows))]\n-    fn test_headless() {\n+    fn test_dlist_headless() {\n         new_dlist::<int>().head();\n     }\n     #[test] #[should_fail] #[ignore(cfg(windows))]\n-    fn test_insert_already_present_before() {\n+    fn test_dlist_insert_already_present_before() {\n         let l = new_dlist::<int>();\n         let one = l.push_n(1);\n         let two = l.push_n(2);\n         l.insert_n_before(two, one);\n     }\n     #[test] #[should_fail] #[ignore(cfg(windows))]\n-    fn test_insert_already_present_after() {\n+    fn test_dlist_insert_already_present_after() {\n         let l = new_dlist::<int>();\n         let one = l.push_n(1);\n         let two = l.push_n(2);\n         l.insert_n_after(one, two);\n     }\n     #[test] #[should_fail] #[ignore(cfg(windows))]\n-    fn test_insert_before_orphan() {\n+    fn test_dlist_insert_before_orphan() {\n         let l = new_dlist::<int>();\n         let one = new_dlist_node(1);\n         let two = new_dlist_node(2);\n         l.insert_n_before(one, two);\n     }\n     #[test] #[should_fail] #[ignore(cfg(windows))]\n-    fn test_insert_after_orphan() {\n+    fn test_dlist_insert_after_orphan() {\n         let l = new_dlist::<int>();\n         let one = new_dlist_node(1);\n         let two = new_dlist_node(2);"}, {"sha": "3e7bc0097f7422b5423242476dfcdd5282930a78", "filename": "src/libcore/f32.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf/src%2Flibcore%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf/src%2Flibcore%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ff32.rs?ref=97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf", "patch": "@@ -168,15 +168,15 @@ pure fn log2(n: f32) -> f32 {\n }\n \n impl num of num::num for f32 {\n-    fn add(&&other: f32)    -> f32 { ret self + other; }\n-    fn sub(&&other: f32)    -> f32 { ret self - other; }\n-    fn mul(&&other: f32)    -> f32 { ret self * other; }\n-    fn div(&&other: f32)    -> f32 { ret self / other; }\n-    fn modulo(&&other: f32) -> f32 { ret self % other; }\n-    fn neg()                -> f32 { ret -self;        }\n-\n-    fn to_int()         -> int { ret self as int; }\n-    fn from_int(n: int) -> f32 { ret n as f32;    }\n+    pure fn add(&&other: f32)    -> f32 { ret self + other; }\n+    pure fn sub(&&other: f32)    -> f32 { ret self - other; }\n+    pure fn mul(&&other: f32)    -> f32 { ret self * other; }\n+    pure fn div(&&other: f32)    -> f32 { ret self / other; }\n+    pure fn modulo(&&other: f32) -> f32 { ret self % other; }\n+    pure fn neg()                -> f32 { ret -self;        }\n+\n+    pure fn to_int()         -> int { ret self as int; }\n+    pure fn from_int(n: int) -> f32 { ret n as f32;    }\n }\n \n //"}, {"sha": "9e84c432bad269fed9652513537affa56a5ffedf", "filename": "src/libcore/f64.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf/src%2Flibcore%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf/src%2Flibcore%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ff64.rs?ref=97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf", "patch": "@@ -195,15 +195,15 @@ pure fn log2(n: f64) -> f64 {\n }\n \n impl num of num::num for f64 {\n-    fn add(&&other: f64)    -> f64 { ret self + other; }\n-    fn sub(&&other: f64)    -> f64 { ret self - other; }\n-    fn mul(&&other: f64)    -> f64 { ret self * other; }\n-    fn div(&&other: f64)    -> f64 { ret self / other; }\n-    fn modulo(&&other: f64) -> f64 { ret self % other; }\n-    fn neg()                -> f64 { ret -self;        }\n-\n-    fn to_int()         -> int { ret self as int; }\n-    fn from_int(n: int) -> f64 { ret n as f64;    }\n+    pure fn add(&&other: f64)    -> f64 { ret self + other; }\n+    pure fn sub(&&other: f64)    -> f64 { ret self - other; }\n+    pure fn mul(&&other: f64)    -> f64 { ret self * other; }\n+    pure fn div(&&other: f64)    -> f64 { ret self / other; }\n+    pure fn modulo(&&other: f64) -> f64 { ret self % other; }\n+    pure fn neg()                -> f64 { ret -self;        }\n+\n+    pure fn to_int()         -> int { ret self as int; }\n+    pure fn from_int(n: int) -> f64 { ret n as f64;    }\n }\n \n //"}, {"sha": "8b8cc4664dc8c67a219971f9833326ae1a02c724", "filename": "src/libcore/float.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf/src%2Flibcore%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf/src%2Flibcore%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffloat.rs?ref=97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf", "patch": "@@ -403,32 +403,32 @@ fn pow_with_uint(base: uint, pow: uint) -> float {\n     ret total;\n }\n \n-fn is_positive(x: float) -> bool { f64::is_positive(x as f64) }\n-fn is_negative(x: float) -> bool { f64::is_negative(x as f64) }\n-fn is_nonpositive(x: float) -> bool { f64::is_nonpositive(x as f64) }\n-fn is_nonnegative(x: float) -> bool { f64::is_nonnegative(x as f64) }\n-fn is_zero(x: float) -> bool { f64::is_zero(x as f64) }\n-fn is_infinite(x: float) -> bool { f64::is_infinite(x as f64) }\n-fn is_finite(x: float) -> bool { f64::is_finite(x as f64) }\n-fn is_NaN(x: float) -> bool { f64::is_NaN(x as f64) }\n-\n-fn abs(x: float) -> float { f64::abs(x as f64) as float }\n-fn sqrt(x: float) -> float { f64::sqrt(x as f64) as float }\n-fn atan(x: float) -> float { f64::atan(x as f64) as float }\n-fn sin(x: float) -> float { f64::sin(x as f64) as float }\n-fn cos(x: float) -> float { f64::cos(x as f64) as float }\n-fn tan(x: float) -> float { f64::tan(x as f64) as float }\n+pure fn is_positive(x: float) -> bool { f64::is_positive(x as f64) }\n+pure fn is_negative(x: float) -> bool { f64::is_negative(x as f64) }\n+pure fn is_nonpositive(x: float) -> bool { f64::is_nonpositive(x as f64) }\n+pure fn is_nonnegative(x: float) -> bool { f64::is_nonnegative(x as f64) }\n+pure fn is_zero(x: float) -> bool { f64::is_zero(x as f64) }\n+pure fn is_infinite(x: float) -> bool { f64::is_infinite(x as f64) }\n+pure fn is_finite(x: float) -> bool { f64::is_finite(x as f64) }\n+pure fn is_NaN(x: float) -> bool { f64::is_NaN(x as f64) }\n+\n+pure fn abs(x: float) -> float { f64::abs(x as f64) as float }\n+pure fn sqrt(x: float) -> float { f64::sqrt(x as f64) as float }\n+pure fn atan(x: float) -> float { f64::atan(x as f64) as float }\n+pure fn sin(x: float) -> float { f64::sin(x as f64) as float }\n+pure fn cos(x: float) -> float { f64::cos(x as f64) as float }\n+pure fn tan(x: float) -> float { f64::tan(x as f64) as float }\n \n impl num of num::num for float {\n-    fn add(&&other: float)    -> float { ret self + other; }\n-    fn sub(&&other: float)    -> float { ret self - other; }\n-    fn mul(&&other: float)    -> float { ret self * other; }\n-    fn div(&&other: float)    -> float { ret self / other; }\n-    fn modulo(&&other: float) -> float { ret self % other; }\n-    fn neg()                  -> float { ret -self;        }\n-\n-    fn to_int()         -> int   { ret self as int; }\n-    fn from_int(n: int) -> float { ret n as float;  }\n+    pure fn add(&&other: float)    -> float { ret self + other; }\n+    pure fn sub(&&other: float)    -> float { ret self - other; }\n+    pure fn mul(&&other: float)    -> float { ret self * other; }\n+    pure fn div(&&other: float)    -> float { ret self / other; }\n+    pure fn modulo(&&other: float) -> float { ret self % other; }\n+    pure fn neg()                  -> float { ret -self;        }\n+\n+    pure fn to_int()         -> int   { ret self as int; }\n+    pure fn from_int(n: int) -> float { ret n as float;  }\n }\n \n #[test]"}, {"sha": "2b950e4a7977f2749caa2bfa5d939c06da7fe7dc", "filename": "src/libcore/int-template.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf/src%2Flibcore%2Fint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf/src%2Flibcore%2Fint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fint-template.rs?ref=97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf", "patch": "@@ -112,27 +112,27 @@ fn to_str_bytes<U>(n: T, radix: uint, f: fn(v: &[u8]) -> U) -> U {\n fn str(i: T) -> ~str { ret to_str(i, 10u); }\n \n impl ord of ord for T {\n-    fn lt(&&other: T) -> bool {\n+    pure fn lt(&&other: T) -> bool {\n         ret self < other;\n     }\n }\n \n impl eq of eq for T {\n-    fn eq(&&other: T) -> bool {\n+    pure fn eq(&&other: T) -> bool {\n         ret self == other;\n     }\n }\n \n impl num of num::num for T {\n-    fn add(&&other: T)    -> T { ret self + other; }\n-    fn sub(&&other: T)    -> T { ret self - other; }\n-    fn mul(&&other: T)    -> T { ret self * other; }\n-    fn div(&&other: T)    -> T { ret self / other; }\n-    fn modulo(&&other: T) -> T { ret self % other; }\n-    fn neg()              -> T { ret -self;        }\n-\n-    fn to_int()         -> int { ret self as int; }\n-    fn from_int(n: int) -> T   { ret n as T;      }\n+    pure fn add(&&other: T)    -> T { ret self + other; }\n+    pure fn sub(&&other: T)    -> T { ret self - other; }\n+    pure fn mul(&&other: T)    -> T { ret self * other; }\n+    pure fn div(&&other: T)    -> T { ret self / other; }\n+    pure fn modulo(&&other: T) -> T { ret self % other; }\n+    pure fn neg()              -> T { ret -self;        }\n+\n+    pure fn to_int()         -> int { ret self as int; }\n+    pure fn from_int(n: int) -> T   { ret n as T;      }\n }\n \n impl times of iter::times for T {"}, {"sha": "3704f2b70da4844aa145fd3a15559ae41535d2bf", "filename": "src/libcore/io.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf/src%2Flibcore%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf/src%2Flibcore%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fio.rs?ref=97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf", "patch": "@@ -687,7 +687,11 @@ fn seek_in_buf(offset: int, pos: uint, len: uint, whence: seek_style) ->\n \n fn read_whole_file_str(file: ~str) -> result<~str, ~str> {\n     result::chain(read_whole_file(file), |bytes| {\n-        result::ok(str::from_bytes(bytes))\n+        if str::is_utf8(bytes) {\n+            result::ok(str::from_bytes(bytes))\n+       } else {\n+           result::err(file + ~\" is not UTF-8\")\n+       }\n     })\n }\n "}, {"sha": "03868527655928f2d7437e892363bf7b1950a7c1", "filename": "src/libcore/num.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf/src%2Flibcore%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf/src%2Flibcore%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum.rs?ref=97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf", "patch": "@@ -1,17 +1,17 @@\n /// An interface for numbers.\n \n-iface num {\n+trait num {\n     // FIXME: Cross-crate overloading doesn't work yet. (#2615)\n     // FIXME: Interface inheritance. (#2616)\n-    fn add(&&other: self) -> self;\n-    fn sub(&&other: self) -> self;\n-    fn mul(&&other: self) -> self;\n-    fn div(&&other: self) -> self;\n-    fn modulo(&&other: self) -> self;\n-    fn neg() -> self;\n+    pure fn add(&&other: self) -> self;\n+    pure fn sub(&&other: self) -> self;\n+    pure fn mul(&&other: self) -> self;\n+    pure fn div(&&other: self) -> self;\n+    pure fn modulo(&&other: self) -> self;\n+    pure fn neg() -> self;\n \n-    fn to_int() -> int;\n-    fn from_int(n: int) -> self;    // FIXME (#2376) Static functions.\n+    pure fn to_int() -> int;\n+    pure fn from_int(n: int) -> self;    // FIXME (#2376) Static functions.\n     // n.b. #2376 is for classes, not ifaces, but it could be generalized...\n }\n "}, {"sha": "61efe704974af6cebc84234031de1b560c0e0beb", "filename": "src/libcore/ops.rs", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf", "patch": "@@ -0,0 +1,66 @@\n+// Core operators and kinds.\n+\n+#[lang=\"const\"]\n+trait const {\n+    // Empty.\n+}\n+\n+#[lang=\"copy\"]\n+trait copy {\n+    // Empty.\n+}\n+\n+#[lang=\"send\"]\n+trait send {\n+    // Empty.\n+}\n+\n+#[lang=\"owned\"]\n+trait owned {\n+    // Empty.\n+}\n+\n+#[lang=\"add\"]\n+trait add<RHS,Result> {\n+    pure fn add(rhs: RHS) -> Result;\n+}\n+\n+#[lang=\"sub\"]\n+trait sub<RHS,Result> {\n+    pure fn sub(rhs: RHS) -> Result;\n+}\n+\n+#[lang=\"mul\"]\n+trait mul<RHS,Result> {\n+    pure fn mul(rhs: RHS) -> Result;\n+}\n+\n+#[lang=\"div\"]\n+trait div<RHS,Result> {\n+    pure fn div(rhs: RHS) -> Result;\n+}\n+\n+#[lang=\"modulo\"]\n+trait modulo<RHS,Result> {\n+    pure fn modulo(rhs: RHS) -> Result;\n+}\n+\n+#[lang=\"neg\"]\n+trait neg<RHS,Result> {\n+    pure fn neg(rhs: RHS) -> Result;\n+}\n+\n+#[lang=\"bitops\"]\n+trait bitops<RHS,BitCount,Result> {\n+    pure fn and(rhs: RHS) -> Result;\n+    pure fn or(rhs: RHS) -> Result;\n+    pure fn xor(rhs: RHS) -> Result;\n+    pure fn shl(n: BitCount) -> Result;\n+    pure fn shr(n: BitCount) -> Result;\n+}\n+\n+#[lang=\"index\"]\n+trait index<Index,Result> {\n+    pure fn index(index: Index) -> Result;\n+}\n+"}, {"sha": "4ffa040250f65a0c453fff2b6cc04e0a4b3eb983", "filename": "src/libcore/pipes.rs", "status": "modified", "additions": 55, "deletions": 53, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf/src%2Flibcore%2Fpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf/src%2Flibcore%2Fpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpipes.rs?ref=97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf", "patch": "@@ -30,59 +30,6 @@ macro_rules! move {\n // places. Once there is unary move, it can be removed.\n fn move<T>(-x: T) -> T { x }\n \n-/**\n-\n-Some thoughts about fixed buffers.\n-\n-The idea is if a protocol is bounded, we will synthesize a record that\n-has a field for each state. Each of these states contains a packet for\n-the messages that are legal to be sent in that state. Then, instead of\n-allocating, the send code just finds a pointer to the right field and\n-uses that instead.\n-\n-Unforunately, this makes things kind of tricky. We need to be able to\n-find the buffer, which means we need to pass it around. This could\n-either be associated with the (send|recv)_packet classes, or with the\n-packet itself. We will also need some form of reference counting so we\n-can track who has the responsibility of freeing the buffer.\n-\n-We want to preserve the ability to do things like optimistic buffer\n-re-use, and skipping over to a new buffer when necessary. What I mean\n-is, suppose we had the typical stream protocol. It'd make sense to\n-amortize allocation costs by allocating a buffer with say 16\n-messages. When the sender gets to the end of the buffer, it could\n-check if the receiver is done with the packet in slot 0. If so, it can\n-just reuse that one, checking if the receiver is done with the next\n-one in each case. If it is ever not done, it just allocates a new\n-buffer and skips over to that.\n-\n-Also, since protocols are in libcore, we have to do this in a way that\n-maintains backwards compatibility.\n-\n-buffer header and buffer. Cast as c_void when necessary.\n-\n-===\n-\n-Okay, here are some new ideas.\n-\n-It'd be nice to keep the bounded/unbounded case as uniform as\n-possible. It leads to less code duplication, and less things that can\n-go sublty wrong. For the bounded case, we could either have a struct\n-with a bunch of unique pointers to pre-allocated packets, or we could\n-lay them out inline. Inline layout is better, if for no other reason\n-than that we don't have to allocate each packet\n-individually. Currently we pass unique packets around as unsafe\n-pointers, but they are actually unique pointers. We should instead use\n-real unsafe pointers. This makes freeing data and running destructors\n-trickier though. Thus, we should allocate all packets in parter of a\n-higher level buffer structure. Packets can maintain a pointer to their\n-buffer, and this is the part that gets freed.\n-\n-It might be helpful to have some idea of a semi-unique pointer (like\n-being partially pregnant, also like an ARC).\n-\n-*/\n-\n enum state {\n     empty,\n     full,\n@@ -805,6 +752,12 @@ class port_set<T: send> : recv<T> {\n         vec::push(self.ports, port)\n     }\n \n+    fn chan() -> chan<T> {\n+        let (ch, po) = stream();\n+        self.add(po);\n+        ch\n+    }\n+\n     fn try_recv() -> option<T> {\n         let mut result = none;\n         while result == none && self.ports.len() > 0 {\n@@ -869,3 +822,52 @@ impl chan<T: send> of channel<T> for shared_chan<T> {\n fn shared_chan<T:send>(+c: chan<T>) -> shared_chan<T> {\n     arc::exclusive(c)\n }\n+\n+trait select2<T: send, U: send> {\n+    fn try_select() -> either<option<T>, option<U>>;\n+    fn select() -> either<T, U>;\n+}\n+\n+impl<T: send, U: send, Left: selectable recv<T>, Right: selectable recv<U>>\n+    of select2<T, U> for (Left, Right) {\n+\n+    fn select() -> either<T, U> {\n+        alt self {\n+          (lp, rp) {\n+            alt select2i(lp, rp) {\n+              left(())  { left (lp.recv()) }\n+              right(()) { right(rp.recv()) }\n+            }\n+          }\n+        }\n+    }\n+\n+    fn try_select() -> either<option<T>, option<U>> {\n+        alt self {\n+          (lp, rp) {\n+            alt select2i(lp, rp) {\n+              left(())  { left (lp.try_recv()) }\n+              right(()) { right(rp.try_recv()) }\n+            }\n+          }\n+        }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    #[test]\n+    fn test_select2() {\n+        let (c1, p1) = pipes::stream();\n+        let (c2, p2) = pipes::stream();\n+\n+        c1.send(\"abc\");\n+\n+        alt (p1, p2).select() {\n+          right(_) { fail }\n+          _ { }\n+        }\n+\n+        c2.send(123);\n+    }\n+}"}, {"sha": "9561ed4e65f8c83912bee80c6ff8da19ec53ae56", "filename": "src/libcore/uint-template.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf/src%2Flibcore%2Fuint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf/src%2Flibcore%2Fuint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fuint-template.rs?ref=97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf", "patch": "@@ -53,27 +53,27 @@ pure fn compl(i: T) -> T {\n }\n \n impl ord of ord for T {\n-    fn lt(&&other: T) -> bool {\n+    pure fn lt(&&other: T) -> bool {\n         ret self < other;\n     }\n }\n \n impl eq of eq for T {\n-    fn eq(&&other: T) -> bool {\n+    pure fn eq(&&other: T) -> bool {\n         ret self == other;\n     }\n }\n \n impl num of num::num for T {\n-    fn add(&&other: T)    -> T { ret self + other; }\n-    fn sub(&&other: T)    -> T { ret self - other; }\n-    fn mul(&&other: T)    -> T { ret self * other; }\n-    fn div(&&other: T)    -> T { ret self / other; }\n-    fn modulo(&&other: T) -> T { ret self % other; }\n-    fn neg()              -> T { ret -self;        }\n-\n-    fn to_int()         -> int { ret self as int; }\n-    fn from_int(n: int) -> T   { ret n as T;      }\n+    pure fn add(&&other: T)    -> T { ret self + other; }\n+    pure fn sub(&&other: T)    -> T { ret self - other; }\n+    pure fn mul(&&other: T)    -> T { ret self * other; }\n+    pure fn div(&&other: T)    -> T { ret self / other; }\n+    pure fn modulo(&&other: T) -> T { ret self % other; }\n+    pure fn neg()              -> T { ret -self;        }\n+\n+    pure fn to_int()         -> int { ret self as int; }\n+    pure fn from_int(n: int) -> T   { ret n as T;      }\n }\n \n /**"}, {"sha": "f74cbba23ce2a577d240d4111ff297b9c4bcf3b8", "filename": "src/libstd/cmp.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf/src%2Flibstd%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf/src%2Flibstd%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcmp.rs?ref=97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf", "patch": "@@ -2,24 +2,24 @@\n \n const fuzzy_epsilon: float = 1.0e-6;\n \n-iface fuzzy_eq {\n-    fn fuzzy_eq(&&other: self) -> bool;\n+trait fuzzy_eq {\n+    pure fn fuzzy_eq(&&other: self) -> bool;\n }\n \n impl fuzzy_eq of fuzzy_eq for float {\n-    fn fuzzy_eq(&&other: float) -> bool {\n+    pure fn fuzzy_eq(&&other: float) -> bool {\n         ret float::abs(self - other) < fuzzy_epsilon;\n     }\n }\n \n impl fuzzy_eq of fuzzy_eq for f32 {\n-    fn fuzzy_eq(&&other: f32) -> bool {\n+    pure fn fuzzy_eq(&&other: f32) -> bool {\n         ret f32::abs(self - other) < (fuzzy_epsilon as f32);\n     }\n }\n \n impl fuzzy_eq of fuzzy_eq for f64 {\n-    fn fuzzy_eq(&&other: f64) -> bool {\n+    pure fn fuzzy_eq(&&other: f64) -> bool {\n         ret f64::abs(self - other) < (fuzzy_epsilon as f64);\n     }\n }"}, {"sha": "4988adf93734a8d137cedbce8dff837565482bf1", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf", "patch": "@@ -87,7 +87,7 @@ enum def {\n     def_upvar(node_id /* local id of closed over var */,\n               @def    /* closed over def */,\n               node_id /* expr node that creates the closure */),\n-    def_class(def_id),\n+    def_class(def_id, bool /* has constructor */),\n     def_region(node_id)\n }\n "}, {"sha": "0cf593efdc304918d77f5f7d384848094f23e090", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf", "patch": "@@ -53,7 +53,7 @@ pure fn def_id_of_def(d: def) -> def_id {\n       def_fn(id, _) | def_mod(id) |\n       def_foreign_mod(id) | def_const(id) |\n       def_variant(_, id) | def_ty(id) | def_ty_param(id, _) |\n-      def_use(id) | def_class(id) { id }\n+      def_use(id) | def_class(id, _) { id }\n       def_arg(id, _) | def_local(id, _) | def_self(id) |\n       def_upvar(id, _, _) | def_binding(id) | def_region(id) {\n         local_def(id)"}, {"sha": "f367fb63985a301f73919d2d3c2458f8053591bd", "filename": "src/libsyntax/ext/pipes/ast_builder.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs?ref=97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf", "patch": "@@ -183,7 +183,6 @@ impl ast_builder of ext_ctxt_ast_builder for ext_ctxt {\n         {mode: ast::infer(self.next_id()),\n          ty: ty,\n          ident: name,\n-         // FIXME #2886: should this be the same as the infer id?\n          id: self.next_id()}\n     }\n \n@@ -280,7 +279,6 @@ impl ast_builder of ext_ctxt_ast_builder for ext_ctxt {\n     }\n \n     fn ty_path_ast_builder(path: @ast::path) -> @ast::ty {\n-        // FIXME #2886: make sure the node ids are legal.\n         @{id: self.next_id(),\n           node: ast::ty_path(path, self.next_id()),\n           span: self.empty_span()}"}, {"sha": "a6734b285a1909ac6785e75e43f0ee04e4797c36", "filename": "src/rustc/driver/driver.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf/src%2Frustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf/src%2Frustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fdriver%2Fdriver.rs?ref=97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf", "patch": "@@ -14,6 +14,7 @@ import io::{reader_util, writer_util};\n import getopts::{optopt, optmulti, optflag, optflagopt, opt_present};\n import back::{x86, x86_64};\n import std::map::hashmap;\n+import lib::llvm::llvm;\n \n enum pp_mode {ppm_normal, ppm_expanded, ppm_typed, ppm_identified,\n               ppm_expanded_identified }\n@@ -169,6 +170,9 @@ fn compile_upto(sess: session, cfg: ast::crate_cfg,\n                              session::sess_os_to_meta_os(sess.targ_cfg.os),\n                              sess.opts.static));\n \n+    time(time_passes, ~\"language item collection\", ||\n+         middle::lang_items::collect_language_items(crate, sess));\n+\n     let { def_map: def_map,\n           exp_map: exp_map,\n           impl_map: impl_map,\n@@ -440,6 +444,9 @@ fn build_session_options(match: getopts::match,\n         }\n         debugging_opts |= this_bit;\n     }\n+    if debugging_opts & session::debug_llvm != 0 {\n+        llvm::LLVMSetDebug(1);\n+    }\n \n     let output_type =\n         if parse_only || no_trans {"}, {"sha": "61ef9f73c3f3593bc4d6bf5ae200620f871e2498", "filename": "src/rustc/driver/session.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf/src%2Frustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf/src%2Frustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fdriver%2Fsession.rs?ref=97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf", "patch": "@@ -40,6 +40,7 @@ const borrowck_stats: uint = 1024u;\n const borrowck_note_pure: uint = 2048;\n const borrowck_note_loan: uint = 4096;\n const no_landing_pads: uint = 8192;\n+const debug_llvm: uint = 16384;\n \n fn debugging_opts_map() -> ~[(~str, ~str, uint)] {\n     ~[(~\"ppregions\", ~\"prettyprint regions with \\\n@@ -61,7 +62,8 @@ fn debugging_opts_map() -> ~[(~str, ~str, uint)] {\n      (~\"borrowck-note-loan\", ~\"note where loans are req'd\",\n       borrowck_note_loan),\n      (~\"no-landing-pads\", ~\"omit landing pads for unwinding\",\n-      no_landing_pads)\n+      no_landing_pads),\n+     (~\"debug-llvm\", ~\"enable debug output from LLVM\", debug_llvm)\n     ]\n }\n "}, {"sha": "7dbefa8e4980cec1043e65fa6efcdac29a2428c2", "filename": "src/rustc/lib/llvm.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf/src%2Frustc%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf/src%2Frustc%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Flib%2Fllvm.rs?ref=97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf", "patch": "@@ -969,6 +969,9 @@ extern mod llvm {\n \n     fn LLVMConstNamedStruct(S: TypeRef, ConstantVals: *ValueRef,\n                             Count: c_uint) -> ValueRef;\n+\n+    /** Enables LLVM debug output. */\n+    fn LLVMSetDebug(Enabled: c_int);\n }\n \n fn SetInstructionCallConv(Instr: ValueRef, CC: CallConv) {"}, {"sha": "0ba76c49246a65f8cb5daf6f0407c21aecefa327", "filename": "src/rustc/metadata/csearch.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf/src%2Frustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf/src%2Frustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fcsearch.rs?ref=97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf", "patch": "@@ -25,6 +25,7 @@ export get_enum_variants;\n export get_impls_for_mod;\n export get_trait_methods;\n export get_method_names_if_trait;\n+export get_item_attrs;\n export each_path;\n export get_type;\n export get_impl_traits;\n@@ -149,6 +150,14 @@ fn get_method_names_if_trait(cstore: cstore::cstore, def: ast::def_id)\n     ret decoder::get_method_names_if_trait(cdata, def.node);\n }\n \n+fn get_item_attrs(cstore: cstore::cstore,\n+                  def_id: ast::def_id,\n+                  f: fn(~[@ast::meta_item])) {\n+\n+    let cdata = cstore::get_crate_data(cstore, def_id.crate);\n+    decoder::get_item_attrs(cdata, def_id.node, f)\n+}\n+\n fn get_class_fields(tcx: ty::ctxt, def: ast::def_id) -> ~[ty::field_ty] {\n     let cstore = tcx.cstore;\n     let cdata = cstore::get_crate_data(cstore, def.crate);"}, {"sha": "83684413641f30d105d297d5aa853f09d9a6ca6b", "filename": "src/rustc/metadata/decoder.rs", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf/src%2Frustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf/src%2Frustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fdecoder.rs?ref=97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf", "patch": "@@ -39,6 +39,7 @@ export get_crate_vers;\n export get_impls_for_mod;\n export get_trait_methods;\n export get_method_names_if_trait;\n+export get_item_attrs;\n export get_crate_module_paths;\n export def_like;\n export dl_def;\n@@ -282,7 +283,8 @@ fn item_to_def_like(item: ebml::doc, did: ast::def_id, cnum: ast::crate_num)\n     let fam_ch = item_family(item);\n     alt fam_ch {\n       'c' { dl_def(ast::def_const(did)) }\n-      'C' { dl_def(ast::def_class(did)) }\n+      'C' { dl_def(ast::def_class(did, true)) }\n+      'S' { dl_def(ast::def_class(did, false)) }\n       'u' { dl_def(ast::def_fn(did, ast::unsafe_fn)) }\n       'f' { dl_def(ast::def_fn(did, ast::impure_fn)) }\n       'p' { dl_def(ast::def_fn(did, ast::pure_fn)) }\n@@ -659,6 +661,18 @@ fn get_method_names_if_trait(cdata: cmd, node_id: ast::node_id)\n     ret some(resulting_method_names);\n }\n \n+fn get_item_attrs(cdata: cmd,\n+                  node_id: ast::node_id,\n+                  f: fn(~[@ast::meta_item])) {\n+\n+    let item = lookup_item(node_id, cdata.data);\n+    do ebml::tagged_docs(item, tag_attributes) |attributes| {\n+        do ebml::tagged_docs(attributes, tag_attribute) |attribute| {\n+            f(get_meta_items(attribute));\n+        }\n+    }\n+}\n+\n // Helper function that gets either fields or methods\n fn get_class_members(cdata: cmd, id: ast::node_id,\n                      p: fn(char) -> bool) -> ~[ty::field_ty] {\n@@ -694,7 +708,7 @@ fn family_has_type_params(fam_ch: char) -> bool {\n     alt check fam_ch {\n       'c' | 'T' | 'm' | 'n' | 'g' | 'h' | 'j' { false }\n       'f' | 'u' | 'p' | 'F' | 'U' | 'P' | 'y' | 't' | 'v' | 'i' | 'I' | 'C'\n-          | 'a'\n+          | 'a' | 'S'\n           { true }\n     }\n }\n@@ -738,6 +752,7 @@ fn item_family_to_str(fam: char) -> ~str {\n       'i' { ret ~\"impl\"; }\n       'I' { ret ~\"trait\"; }\n       'C' { ret ~\"class\"; }\n+      'S' { ret ~\"struct\"; }\n       'g' { ret ~\"public field\"; }\n       'j' { ret ~\"private field\"; }\n     }"}, {"sha": "e1ed9fe396aae30b83f3f28990dcec1fd7f919ba", "filename": "src/rustc/metadata/encoder.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf/src%2Frustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf/src%2Frustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fencoder.rs?ref=97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf", "patch": "@@ -663,7 +663,16 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n         /* Now, make an item for the class itself */\n         ebml_w.start_tag(tag_items_data_item);\n         encode_def_id(ebml_w, local_def(item.id));\n-        encode_family(ebml_w, 'C');\n+\n+        alt ctor {\n+            none {\n+                encode_family(ebml_w, 'S');\n+            }\n+            some(_) {\n+                encode_family(ebml_w, 'C');\n+            }\n+        }\n+\n         encode_type_param_bounds(ebml_w, ecx, tps);\n         encode_type(ecx, ebml_w, node_id_to_type(tcx, item.id));\n         encode_name(ebml_w, item.ident);\n@@ -759,6 +768,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n         encode_type_param_bounds(ebml_w, ecx, tps);\n         encode_type(ecx, ebml_w, node_id_to_type(tcx, item.id));\n         encode_name(ebml_w, item.ident);\n+        encode_attributes(ebml_w, item.attrs);\n         let mut i = 0u;\n         for vec::each(*ty::trait_methods(tcx, local_def(item.id))) |mty| {\n             alt ms[i] {"}, {"sha": "1f5f7c4518d597923431fadd5fe8cd9fbde2e892", "filename": "src/rustc/middle/astencode.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf/src%2Frustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf/src%2Frustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fastencode.rs?ref=97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf", "patch": "@@ -369,8 +369,8 @@ impl of tr for ast::def {\n           ast::def_upvar(nid1, def, nid2) {\n             ast::def_upvar(xcx.tr_id(nid1), @(*def).tr(xcx), xcx.tr_id(nid2))\n           }\n-          ast::def_class(did) {\n-            ast::def_class(did.tr(xcx))\n+          ast::def_class(did, has_constructor) {\n+            ast::def_class(did.tr(xcx), has_constructor)\n           }\n           ast::def_region(nid) { ast::def_region(xcx.tr_id(nid)) }\n         }"}, {"sha": "4088945e550e1b2c29e4db3984806f5ce5317392", "filename": "src/rustc/middle/borrowck/categorization.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf/src%2Frustc%2Fmiddle%2Fborrowck%2Fcategorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf/src%2Frustc%2Fmiddle%2Fborrowck%2Fcategorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck%2Fcategorization.rs?ref=97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf", "patch": "@@ -196,7 +196,7 @@ impl public_methods for borrowck_ctxt {\n           ast::def_foreign_mod(_) | ast::def_const(_) |\n           ast::def_use(_) | ast::def_variant(_, _) |\n           ast::def_ty(_) | ast::def_prim_ty(_) |\n-          ast::def_ty_param(_, _) | ast::def_class(_) |\n+          ast::def_ty_param(_, _) | ast::def_class(_, _) |\n           ast::def_region(_) {\n             @{id:id, span:span,\n               cat:cat_special(sk_static_item), lp:none,"}, {"sha": "2353da51f98170d96e5ebf56da3455d708e2041d", "filename": "src/rustc/middle/lang_items.rs", "status": "added", "additions": 209, "deletions": 0, "changes": 209, "blob_url": "https://github.com/rust-lang/rust/blob/97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf/src%2Frustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf/src%2Frustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Flang_items.rs?ref=97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf", "patch": "@@ -0,0 +1,209 @@\n+// Detecting language items.\n+//\n+// Language items are items that represent concepts intrinsic to the language\n+// itself. Examples are:\n+//\n+// * Traits that specify \"kinds\"; e.g. \"const\", \"copy\", \"send\".\n+//\n+// * Traits that represent operators; e.g. \"add\", \"sub\", \"index\".\n+//\n+// * Functions called by the compiler itself.\n+\n+import driver::session::session;\n+import metadata::csearch::{each_path, get_item_attrs};\n+import metadata::cstore::{iter_crate_data};\n+import metadata::decoder::{dl_def, dl_field, dl_impl};\n+import syntax::ast::{crate, def_id, def_ty, lit_str, meta_item, meta_list};\n+import syntax::ast::{meta_name_value, meta_word};\n+import syntax::ast_util::{local_def};\n+import syntax::visit::{default_simple_visitor, mk_simple_visitor};\n+import syntax::visit::{visit_crate, visit_item};\n+\n+import std::map::{hashmap, str_hash};\n+import str_eq = str::eq;\n+\n+class LanguageItems {\n+    let mut const_trait: option<def_id>;\n+    let mut copy_trait: option<def_id>;\n+    let mut send_trait: option<def_id>;\n+    let mut owned_trait: option<def_id>;\n+\n+    let mut add_trait: option<def_id>;\n+    let mut sub_trait: option<def_id>;\n+    let mut mul_trait: option<def_id>;\n+    let mut div_trait: option<def_id>;\n+    let mut modulo_trait: option<def_id>;\n+    let mut neg_trait: option<def_id>;\n+    let mut bitops_trait: option<def_id>;\n+    let mut index_trait: option<def_id>;\n+\n+    new() {\n+        self.const_trait = none;\n+        self.copy_trait = none;\n+        self.send_trait = none;\n+        self.owned_trait = none;\n+\n+        self.add_trait = none;\n+        self.sub_trait = none;\n+        self.mul_trait = none;\n+        self.div_trait = none;\n+        self.modulo_trait = none;\n+        self.neg_trait = none;\n+        self.bitops_trait = none;\n+        self.index_trait = none;\n+    }\n+}\n+\n+class LanguageItemCollector {\n+    let items: LanguageItems;\n+\n+    let crate: @crate;\n+    let session: session;\n+\n+    let item_refs: hashmap<~str,&mut option<def_id>>;\n+\n+    new(crate: @crate, session: session) {\n+        self.crate = crate;\n+        self.session = session;\n+\n+        self.items = LanguageItems();\n+\n+        self.item_refs = str_hash();\n+    }\n+\n+    // XXX: Needed to work around an issue with constructors.\n+    fn init() {\n+        self.item_refs.insert(~\"const\", &mut self.items.const_trait);\n+        self.item_refs.insert(~\"copy\", &mut self.items.copy_trait);\n+        self.item_refs.insert(~\"send\", &mut self.items.send_trait);\n+        self.item_refs.insert(~\"owned\", &mut self.items.owned_trait);\n+\n+        self.item_refs.insert(~\"add\", &mut self.items.add_trait);\n+        self.item_refs.insert(~\"sub\", &mut self.items.sub_trait);\n+        self.item_refs.insert(~\"mul\", &mut self.items.mul_trait);\n+        self.item_refs.insert(~\"div\", &mut self.items.div_trait);\n+        self.item_refs.insert(~\"modulo\", &mut self.items.modulo_trait);\n+        self.item_refs.insert(~\"neg\", &mut self.items.neg_trait);\n+        self.item_refs.insert(~\"bitops\", &mut self.items.bitops_trait);\n+        self.item_refs.insert(~\"index\", &mut self.items.index_trait);\n+    }\n+\n+    fn match_and_collect_meta_item(item_def_id: def_id,\n+                                   meta_item: meta_item) {\n+\n+        alt meta_item.node {\n+            meta_name_value(key, literal) => {\n+                alt literal.node {\n+                    lit_str(value) => {\n+                        self.match_and_collect_item(item_def_id,\n+                                                    *key,\n+                                                    *value);\n+                    }\n+                    _ => {\n+                        // Skip.\n+                    }\n+                }\n+            }\n+            meta_word(*) | meta_list(*) {\n+                // Skip.\n+            }\n+        }\n+    }\n+\n+    fn match_and_collect_item(item_def_id: def_id, key: ~str, value: ~str) {\n+        if !str_eq(key, ~\"lang\") {\n+            ret;    // Didn't match.\n+        }\n+\n+        alt self.item_refs.find(value) {\n+            none => {\n+                // Didn't match.\n+            }\n+            some(item_ref) => {\n+                // Check for duplicates.\n+                alt copy *item_ref {\n+                    some(original_def_id)\n+                            if original_def_id != item_def_id => {\n+\n+                        self.session.warn(#fmt(\"duplicate entry for `%s`\",\n+                                               value));\n+                    }\n+                    some(_) | none => {\n+                        // OK.\n+                    }\n+                }\n+\n+                // Matched.\n+                *item_ref = some(item_def_id);\n+            }\n+        }\n+    }\n+\n+    fn collect_local_language_items() {\n+        let this = unsafe { ptr::addr_of(self) };\n+        visit_crate(*self.crate, (), mk_simple_visitor(@{\n+            visit_item: |item| {\n+                for item.attrs.each |attribute| {\n+                    unsafe {\n+                        (*this).match_and_collect_meta_item(local_def(item\n+                                                                      .id),\n+                                                            attribute.node\n+                                                                     .value);\n+                    }\n+                }\n+            }\n+            with *default_simple_visitor()\n+        }));\n+    }\n+\n+    fn collect_external_language_items() {\n+        let crate_store = self.session.cstore;\n+        do iter_crate_data(crate_store) |crate_number, _crate_metadata| {\n+            for each_path(crate_store, crate_number) |path_entry| {\n+                let def_id;\n+                alt path_entry.def_like {\n+                    dl_def(def_ty(did)) => {\n+                        def_id = did;\n+                    }\n+                    dl_def(_) | dl_impl(_) | dl_field {\n+                        // Skip this.\n+                        again;\n+                    }\n+                }\n+\n+                do get_item_attrs(crate_store, def_id) |meta_items| {\n+                    for meta_items.each |meta_item| {\n+                        self.match_and_collect_meta_item(def_id, *meta_item);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    fn check_completeness() {\n+        for self.item_refs.each |key, item_ref| {\n+            alt copy *item_ref {\n+                none => {\n+                    self.session.warn(#fmt(\"no item found for `%s`\", key));\n+                }\n+                some(did) => {\n+                    // OK.\n+                }\n+            }\n+        }\n+    }\n+\n+    fn collect() {\n+        self.init();\n+        self.collect_local_language_items();\n+        self.collect_external_language_items();\n+        self.check_completeness();\n+    }\n+}\n+\n+fn collect_language_items(crate: @crate, session: session) -> LanguageItems {\n+    let collector = LanguageItemCollector(crate, session);\n+    collector.collect();\n+    copy collector.items\n+}\n+"}, {"sha": "cc6874bc9679b5e5590eb444b6b085a2a86112f1", "filename": "src/rustc/middle/region.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf/src%2Frustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf/src%2Frustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fregion.rs?ref=97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf", "patch": "@@ -467,7 +467,7 @@ fn determine_rp_in_ty(ty: @ast::ty,\n     alt ty.node {\n       ast::ty_path(_, id) {\n         alt cx.def_map.get(id) {\n-          ast::def_ty(did) | ast::def_class(did) {\n+          ast::def_ty(did) | ast::def_class(did, _) {\n             if did.crate == ast::local_crate {\n                 cx.add_dep(did.node, cx.item_id);\n             } else {"}, {"sha": "e75268cde7f6cef07acfa95923c63950d198640c", "filename": "src/rustc/middle/resolve3.rs", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf/src%2Frustc%2Fmiddle%2Fresolve3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf/src%2Frustc%2Fmiddle%2Fresolve3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fresolve3.rs?ref=97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf", "patch": "@@ -41,7 +41,7 @@ import syntax::visit::{visit_mod, visit_ty, vt};\n \n import box::ptr_eq;\n import dvec::{dvec, extensions};\n-import option::get;\n+import option::{get, is_some};\n import str::{connect, split_str};\n import vec::pop;\n \n@@ -604,7 +604,7 @@ class Resolver {\n     let unused_import_lint_level: level;\n \n     let trait_info: hashmap<def_id,@hashmap<Atom,()>>;\n-    let structs: hashmap<def_id,()>;\n+    let structs: hashmap<def_id,bool>;\n \n     // The number of imports that are currently unresolved.\n     let mut unresolved_imports: uint;\n@@ -926,7 +926,8 @@ class Resolver {\n                 (*name_bindings).define_impl(impl_info);\n \n                 // Record the def ID of this struct.\n-                self.structs.insert(local_def(item.id), ());\n+                self.structs.insert(local_def(item.id),\n+                                    is_some(optional_ctor));\n \n                 visit_item(item, new_parent, visitor);\n             }\n@@ -1378,12 +1379,16 @@ class Resolver {\n \n                             (*child_name_bindings).define_type(def);\n                         }\n-                        def_class(def_id) {\n+                        def_class(def_id, has_constructor) {\n                             #debug(\"(building reduced graph for external \\\n-                                    crate) building value and type %s\",\n-                                    final_ident);\n-                            (*child_name_bindings).define_value(def);\n+                                    crate) building type %s (value? %d)\",\n+                                    final_ident,\n+                                    if has_constructor { 1 } else { 0 });\n                             (*child_name_bindings).define_type(def);\n+\n+                            if has_constructor {\n+                                (*child_name_bindings).define_value(def);\n+                            }\n                         }\n                         def_self(*) | def_arg(*) | def_local(*) |\n                         def_prim_ty(*) | def_ty_param(*) | def_binding(*) |\n@@ -4201,7 +4206,9 @@ class Resolver {\n                     some(definition @ def_ty(class_id))\n                             if self.structs.contains_key(class_id) {\n \n-                        self.record_def(expr.id, def_class(class_id));\n+                        let has_constructor = self.structs.get(class_id);\n+                        let class_def = def_class(class_id, has_constructor);\n+                        self.record_def(expr.id, class_def);\n                     }\n                     _ {\n                         self.session.span_err(path.span,"}, {"sha": "465aeebe3af2e86f04db171b0fc102d9b08dbde0", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf", "patch": "@@ -2587,7 +2587,7 @@ fn type_err_to_str(cx: ctxt, err: type_err) -> ~str {\n \n fn def_has_ty_params(def: ast::def) -> bool {\n     alt def {\n-      ast::def_fn(_, _) | ast::def_variant(_, _) | ast::def_class(_)\n+      ast::def_fn(_, _) | ast::def_variant(_, _) | ast::def_class(_, _)\n         { true }\n       _ { false }\n     }"}, {"sha": "3baea12ab484f4db3adc3638e69d71af1048a332", "filename": "src/rustc/middle/typeck/astconv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf/src%2Frustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf/src%2Frustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf", "patch": "@@ -270,7 +270,7 @@ fn ast_ty_to_ty<AC: ast_conv, RS: region_scope copy owned>(\n                                                        path_to_str(path))); }\n           some(d) { d }};\n         alt a_def {\n-          ast::def_ty(did) | ast::def_class(did) {\n+          ast::def_ty(did) | ast::def_class(did, _) {\n             ast_path_to_ty(self, rscope, did, path, id).ty\n           }\n           ast::def_prim_ty(nty) {"}, {"sha": "eaf0e90b26d624372d80c49cc288ac2a5d84ddb4", "filename": "src/rustc/middle/typeck/check.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs?ref=97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf", "patch": "@@ -1649,7 +1649,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         // Resolve the path.\n         let class_id;\n         alt tcx.def_map.find(id) {\n-            some(ast::def_class(type_def_id)) => {\n+            some(ast::def_class(type_def_id, _)) => {\n                 class_id = type_def_id;\n             }\n             _ => {\n@@ -2160,7 +2160,7 @@ fn ty_param_bounds_and_ty_for_def(fcx: @fn_ctxt, sp: span, defn: ast::def) ->\n       }\n \n       ast::def_fn(id, _) | ast::def_const(id) |\n-      ast::def_variant(_, id) | ast::def_class(id) {\n+      ast::def_variant(_, id) | ast::def_class(id, _) {\n         ret ty::lookup_item_type(fcx.ccx.tcx, id);\n       }\n       ast::def_binding(nid) {"}, {"sha": "d1052fd6a2abf78b75e0adcd69d89b3b3ba181c1", "filename": "src/rustc/middle/typeck/check/regionmanip.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs?ref=97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf", "patch": "@@ -200,7 +200,7 @@ fn region_of(fcx: @fn_ctxt, expr: @ast::expr) -> ty::region {\n           ast::def_foreign_mod(_) | ast::def_const(_) |\n           ast::def_use(_) | ast::def_variant(_, _) |\n           ast::def_ty(_) | ast::def_prim_ty(_) |\n-          ast::def_ty_param(_, _) | ast::def_class(_) |\n+          ast::def_ty_param(_, _) | ast::def_class(_, _) |\n           ast::def_region(_) {\n             ty::re_static\n           }"}, {"sha": "b2cce508e57f9dc9b2e438da2f3e944376ddb200", "filename": "src/rustc/rustc.rc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf/src%2Frustc%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf/src%2Frustc%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Frustc.rc?ref=97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf", "patch": "@@ -88,6 +88,7 @@ mod middle {\n     mod region;\n     mod const_eval;\n     mod astencode;\n+    mod lang_items;\n }\n \n mod front {"}, {"sha": "4a927744f07a0e15014db331f8e6bddebcde2e81", "filename": "src/rustllvm/RustWrapper.cpp", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf/src%2Frustllvm%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf/src%2Frustllvm%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FRustWrapper.cpp?ref=97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf", "patch": "@@ -27,6 +27,7 @@\n #include \"llvm/Support/SourceMgr.h\"\n #include \"llvm/Target/TargetOptions.h\"\n #include \"llvm/Support/Host.h\"\n+#include \"llvm/Support/Debug.h\"\n #include \"llvm-c/Core.h\"\n #include \"llvm-c/BitReader.h\"\n #include \"llvm-c/Object.h\"\n@@ -185,3 +186,7 @@ extern \"C\" LLVMValueRef LLVMBuildAtomicRMW(LLVMBuilderRef B,\n                                            unwrap(target), unwrap(source),\n                                            order));\n }\n+\n+extern \"C\" void LLVMSetDebug(int Enabled) {\n+  DebugFlag = Enabled;\n+}"}, {"sha": "64b560999bec5e40e34f43b51d745aa28d297b07", "filename": "src/rustllvm/rustllvm.def.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf/src%2Frustllvm%2Frustllvm.def.in", "raw_url": "https://github.com/rust-lang/rust/raw/97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf/src%2Frustllvm%2Frustllvm.def.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2Frustllvm.def.in?ref=97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf", "patch": "@@ -528,6 +528,7 @@ LLVMSetAlignment\n LLVMSetCleanup\n LLVMSetCurrentDebugLocation\n LLVMSetDataLayout\n+LLVMSetDebug\n LLVMSetFunctionCallConv\n LLVMSetGC\n LLVMSetGlobalConstant"}, {"sha": "4148e5b88fe6369c7056f9659bb48902fefa19c6", "filename": "src/test/compile-fail/not-utf8.bin", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf/src%2Ftest%2Fcompile-fail%2Fnot-utf8.bin", "raw_url": "https://github.com/rust-lang/rust/raw/97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf/src%2Ftest%2Fcompile-fail%2Fnot-utf8.bin", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnot-utf8.bin?ref=97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf"}, {"sha": "2038f1393590900ff10f60d7c7470cf94be8c9f1", "filename": "src/test/compile-fail/not-utf8.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf/src%2Ftest%2Fcompile-fail%2Fnot-utf8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf/src%2Ftest%2Fcompile-fail%2Fnot-utf8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnot-utf8.rs?ref=97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf", "patch": "@@ -0,0 +1,5 @@\n+// error-pattern: is not UTF-8\n+\n+fn foo() {\n+    #include(\"not-utf8.bin\")\n+}"}, {"sha": "352ada202e2adcff964b4dc6674f4c236e57dbe9", "filename": "src/test/run-pass/issue-3029.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf/src%2Ftest%2Frun-pass%2Fissue-3029.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf/src%2Ftest%2Frun-pass%2Fissue-3029.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3029.rs?ref=97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf", "patch": "@@ -0,0 +1,8 @@\n+// xfail-test\n+fn fail_then_concat() {\n+    let x = ~[], y = ~[3];\n+    fail;\n+    x += y;\n+    ~\"good\" + ~\"bye\";\n+}\n+"}, {"sha": "dcc8c4e08db83d833924e73bcfca703096a462cf", "filename": "src/test/run-pass/issue-868.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf/src%2Ftest%2Frun-pass%2Fissue-868.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf/src%2Ftest%2Frun-pass%2Fissue-868.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-868.rs?ref=97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf", "patch": "@@ -0,0 +1,15 @@\n+fn f<T>(g: fn() -> T) -> T { g() }\n+\n+fn main() {\n+  let _x = f( | | { 10 });\n+    // used to be: cannot determine a type for this expression\n+    f(| | { });\n+    // ditto\n+    f( | | { ()});\n+    // always worked\n+    let _: () = f(| | { });\n+    // empty block with no type info should compile too\n+    let _ = f(||{});\n+    let _ = (||{});\n+}\n+"}, {"sha": "eb866ee7b3e7934bf3857a2336ceca4c4f15d81e", "filename": "src/test/run-pass/task-comm-0.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf/src%2Ftest%2Frun-pass%2Ftask-comm-0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf/src%2Ftest%2Frun-pass%2Ftask-comm-0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-0.rs?ref=97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf", "patch": "@@ -1,31 +1,29 @@\n use std;\n \n-import comm;\n-import comm::chan;\n-import comm::send;\n+import pipes;\n+import pipes::chan;\n+import pipes::port;\n import task;\n \n fn main() { test05(); }\n \n fn test05_start(ch : chan<int>) {\n-    log(error, ch);\n-    send(ch, 10);\n+    ch.send(10);\n     #error(\"sent 10\");\n-    send(ch, 20);\n+    ch.send(20);\n     #error(\"sent 20\");\n-    send(ch, 30);\n+    ch.send(30);\n     #error(\"sent 30\");\n }\n \n fn test05() {\n-    let po = comm::port();\n-    let ch = comm::chan(po);\n+    let (ch, po) = pipes::stream();\n     task::spawn(|| test05_start(ch) );\n-    let mut value = comm::recv(po);\n+    let mut value = po.recv();\n     log(error, value);\n-    value = comm::recv(po);\n+    value = po.recv();\n     log(error, value);\n-    value = comm::recv(po);\n+    value = po.recv();\n     log(error, value);\n     assert (value == 30);\n }"}, {"sha": "ef94a13c072616ccb94eca9186b1af8d5a4d2a53", "filename": "src/test/run-pass/task-comm-10.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf/src%2Ftest%2Frun-pass%2Ftask-comm-10.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf/src%2Ftest%2Frun-pass%2Ftask-comm-10.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-10.rs?ref=97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf", "patch": "@@ -1,28 +1,27 @@\n use std;\n import task;\n-import comm;\n+import pipes;\n \n-fn start(c: comm::chan<comm::chan<~str>>) {\n-    let p = comm::port();\n-    comm::send(c, comm::chan(p));\n+fn start(c: pipes::chan<pipes::chan<~str>>) {\n+    let (ch, p) = pipes::stream();\n+    c.send(ch);\n \n     let mut a;\n     let mut b;\n-    a = comm::recv(p);\n+    a = p.recv();\n     assert a == ~\"A\";\n     log(error, a);\n-    b = comm::recv(p);\n+    b = p.recv();\n     assert b == ~\"B\";\n     log(error, b);\n }\n \n fn main() {\n-    let p = comm::port();\n-    let ch = comm::chan(p);\n+    let (ch, p) = pipes::stream();\n     let child = task::spawn(|| start(ch) );\n \n-    let c = comm::recv(p);\n-    comm::send(c, ~\"A\");\n-    comm::send(c, ~\"B\");\n+    let c = p.recv();\n+    c.send(~\"A\");\n+    c.send(~\"B\");\n     task::yield();\n }"}, {"sha": "5e1e5c5facd264389195ee14e41e44af4cb98d2a", "filename": "src/test/run-pass/task-comm-11.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf/src%2Ftest%2Frun-pass%2Ftask-comm-11.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf/src%2Ftest%2Frun-pass%2Ftask-comm-11.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-11.rs?ref=97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf", "patch": "@@ -1,15 +1,14 @@\n use std;\n-import comm;\n+import pipes;\n import task;\n \n-fn start(c: comm::chan<comm::chan<int>>) {\n-    let p: comm::port<int> = comm::port();\n-    comm::send(c, comm::chan(p));\n+fn start(c: pipes::chan<pipes::chan<int>>) {\n+    let (ch, p) = pipes::stream();\n+    c.send(ch);\n }\n \n fn main() {\n-    let p = comm::port();\n-    let ch = comm::chan(p);\n+    let (ch, p) = pipes::stream();\n     let child = task::spawn(|| start(ch) );\n-    let c = comm::recv(p);\n+    let c = p.recv();\n }"}, {"sha": "88220437c4316e191cca987ec90d79d227108c0a", "filename": "src/test/run-pass/task-comm-13.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf/src%2Ftest%2Frun-pass%2Ftask-comm-13.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf/src%2Ftest%2Frun-pass%2Ftask-comm-13.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-13.rs?ref=97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf", "patch": "@@ -1,17 +1,16 @@\n use std;\n import task;\n-import comm;\n-import comm::send;\n+import pipes;\n+import pipes::send;\n \n-fn start(c: comm::chan<int>, start: int, number_of_messages: int) {\n+fn start(c: pipes::chan<int>, start: int, number_of_messages: int) {\n     let mut i: int = 0;\n-    while i < number_of_messages { send(c, start + i); i += 1; }\n+    while i < number_of_messages { c.send(start + i); i += 1; }\n }\n \n fn main() {\n     #debug(\"Check that we don't deadlock.\");\n-    let p = comm::port::<int>();\n-    let ch = comm::chan(p);\n+    let (ch, p) = pipes::stream();\n     task::try(|| start(ch, 0, 10) );\n     #debug(\"Joined task\");\n }"}, {"sha": "268b6d06dfdeed98229b5a4eee9788111d4278f8", "filename": "src/test/run-pass/task-comm-14.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf/src%2Ftest%2Frun-pass%2Ftask-comm-14.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf/src%2Ftest%2Frun-pass%2Ftask-comm-14.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-14.rs?ref=97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf", "patch": "@@ -1,15 +1,14 @@\n-use std;\n-import comm;\n import task;\n \n fn main() {\n-    let po = comm::port::<int>();\n-    let ch = comm::chan(po);\n+    let po = pipes::port_set();\n \n     // Spawn 10 tasks each sending us back one int.\n     let mut i = 10;\n     while (i > 0) {\n         log(debug, i);\n+        let (ch, p) = pipes::stream();\n+        po.add(p);\n         task::spawn(|copy i| child(i, ch) );\n         i = i - 1;\n     }\n@@ -18,17 +17,16 @@ fn main() {\n     // anything back, so we deadlock here.\n \n     i = 10;\n-    let mut value = 0;\n     while (i > 0) {\n         log(debug, i);\n-        value = comm::recv(po);\n+        po.recv();\n         i = i - 1;\n     }\n \n     #debug(\"main thread exiting\");\n }\n \n-fn child(x: int, ch: comm::chan<int>) {\n+fn child(x: int, ch: pipes::chan<int>) {\n     log(debug, x);\n-    comm::send(ch, copy x);\n+    ch.send(x);\n }"}, {"sha": "71a732490ce00787278d8dac84fde60059585d2c", "filename": "src/test/run-pass/task-comm-15.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf/src%2Ftest%2Frun-pass%2Ftask-comm-15.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf/src%2Ftest%2Frun-pass%2Ftask-comm-15.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-15.rs?ref=97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf", "patch": "@@ -1,23 +1,21 @@\n // xfail-win32\n use std;\n-import comm;\n import task;\n \n-fn start(c: comm::chan<int>, i0: int) {\n+fn start(c: pipes::chan<int>, i0: int) {\n     let mut i = i0;\n     while i > 0 {\n-        comm::send(c, 0);\n+        c.send(0);\n         i = i - 1;\n     }\n }\n \n fn main() {\n-    let p = comm::port();\n     // Spawn a task that sends us back messages. The parent task\n     // is likely to terminate before the child completes, so from\n     // the child's point of view the receiver may die. We should\n     // drop messages on the floor in this case, and not crash!\n-    let ch = comm::chan(p);\n-    let child = task::spawn(|| start(ch, 10) );\n-    let c = comm::recv(p);\n+    let (ch, p) = pipes::stream();\n+    task::spawn(|| start(ch, 10));\n+    p.recv();\n }"}, {"sha": "2d1c72df713c9cf2065b0d77075e431a3943c2ee", "filename": "src/test/run-pass/task-comm-16.rs", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf/src%2Ftest%2Frun-pass%2Ftask-comm-16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf/src%2Ftest%2Frun-pass%2Ftask-comm-16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-16.rs?ref=97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf", "patch": "@@ -1,44 +1,41 @@\n // -*- rust -*-\n \n use std;\n-import comm;\n-import comm::send;\n-import comm::port;\n-import comm::recv;\n-import comm::chan;\n+import pipes;\n+import pipes::send;\n+import pipes::port;\n+import pipes::recv;\n+import pipes::chan;\n \n // Tests of ports and channels on various types\n fn test_rec() {\n     type r = {val0: int, val1: u8, val2: char};\n \n-    let po = comm::port();\n-    let ch = chan(po);\n+    let (ch, po) = pipes::stream();\n     let r0: r = {val0: 0, val1: 1u8, val2: '2'};\n-    send(ch, r0);\n+    ch.send(r0);\n     let mut r1: r;\n-    r1 = recv(po);\n+    r1 = po.recv();\n     assert (r1.val0 == 0);\n     assert (r1.val1 == 1u8);\n     assert (r1.val2 == '2');\n }\n \n fn test_vec() {\n-    let po = port();\n-    let ch = chan(po);\n+    let (ch, po) = pipes::stream();\n     let v0: ~[int] = ~[0, 1, 2];\n-    send(ch, v0);\n-    let v1 = recv(po);\n+    ch.send(v0);\n+    let v1 = po.recv();\n     assert (v1[0] == 0);\n     assert (v1[1] == 1);\n     assert (v1[2] == 2);\n }\n \n fn test_str() {\n-    let po = port();\n-    let ch = chan(po);\n-    let s0 = ~\"test\";\n-    send(ch, s0);\n-    let s1 = recv(po);\n+    let (ch, po) = pipes::stream();\n+    let s0 = \"test\";\n+    ch.send(s0);\n+    let s1 = po.recv();\n     assert (s1[0] == 't' as u8);\n     assert (s1[1] == 'e' as u8);\n     assert (s1[2] == 's' as u8);\n@@ -47,33 +44,36 @@ fn test_str() {\n \n fn test_tag() {\n     enum t { tag1, tag2(int), tag3(int, u8, char), }\n-    let po = port();\n-    let ch = chan(po);\n-    send(ch, tag1);\n-    send(ch, tag2(10));\n-    send(ch, tag3(10, 11u8, 'A'));\n+    let (ch, po) = pipes::stream();\n+    ch.send(tag1);\n+    ch.send(tag2(10));\n+    ch.send(tag3(10, 11u8, 'A'));\n     let mut t1: t;\n-    t1 = recv(po);\n+    t1 = po.recv();\n     assert (t1 == tag1);\n-    t1 = recv(po);\n+    t1 = po.recv();\n     assert (t1 == tag2(10));\n-    t1 = recv(po);\n+    t1 = po.recv();\n     assert (t1 == tag3(10, 11u8, 'A'));\n }\n \n fn test_chan() {\n-    let po = port();\n-    let ch = chan(po);\n-    let po0 = port();\n-    let ch0 = chan(po0);\n-    send(ch, ch0);\n-    let ch1 = recv(po);\n+    let (ch, po) = pipes::stream();\n+    let (ch0, po0) = pipes::stream();\n+    ch.send(ch0);\n+    let ch1 = po.recv();\n     // Does the transmitted channel still work?\n \n-    send(ch1, 10);\n+    ch1.send(10);\n     let mut i: int;\n-    i = recv(po0);\n+    i = po0.recv();\n     assert (i == 10);\n }\n \n-fn main() { test_rec(); test_vec(); test_str(); test_tag(); test_chan(); }\n+fn main() {\n+    test_rec();\n+    test_vec();\n+    test_str();\n+    test_tag();\n+    test_chan();\n+}"}, {"sha": "05c057d85fd8814a0903261312e682d2c1127845", "filename": "src/test/run-pass/task-comm-3.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf/src%2Ftest%2Frun-pass%2Ftask-comm-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf/src%2Ftest%2Frun-pass%2Ftask-comm-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-3.rs?ref=97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf", "patch": "@@ -1,9 +1,9 @@\n use std;\n import task;\n-import comm;\n-import comm::chan;\n-import comm::send;\n-import comm::recv;\n+import pipes;\n+import pipes::chan;\n+import pipes::send;\n+import pipes::recv;\n \n fn main() { #debug(\"===== WITHOUT THREADS =====\"); test00(); }\n \n@@ -12,7 +12,7 @@ fn test00_start(ch: chan<int>, message: int, count: int) {\n     let mut i: int = 0;\n     while i < count {\n         #debug(\"Sending Message\");\n-        send(ch, message + 0);\n+        ch.send(message + 0);\n         i = i + 1;\n     }\n     #debug(\"Ending test00_start\");\n@@ -24,14 +24,14 @@ fn test00() {\n \n     #debug(\"Creating tasks\");\n \n-    let po = comm::port();\n-    let ch = chan(po);\n+    let po = pipes::port_set();\n \n     let mut i: int = 0;\n \n     // Create and spawn tasks...\n     let mut results = ~[];\n     while i < number_of_tasks {\n+        let ch = po.chan();        \n         do task::task().future_result(|-r| {\n             results += ~[r];\n         }).spawn |copy i| {\n@@ -45,7 +45,7 @@ fn test00() {\n     for results.each |r| {\n         i = 0;\n         while i < number_of_messages {\n-            let value = recv(po);\n+            let value = po.recv();\n             sum += value;\n             i = i + 1;\n         }"}, {"sha": "9b99c1cb799bd5ef6faf5c340e48fbab10d31a6a", "filename": "src/test/run-pass/task-comm-4.rs", "status": "modified", "additions": 19, "deletions": 20, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf/src%2Ftest%2Frun-pass%2Ftask-comm-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf/src%2Ftest%2Frun-pass%2Ftask-comm-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-4.rs?ref=97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf", "patch": "@@ -1,44 +1,43 @@\n use std;\n-import comm;\n-import comm::send;\n+import pipes;\n+import pipes::send;\n \n fn main() { test00(); }\n \n fn test00() {\n     let mut r: int = 0;\n     let mut sum: int = 0;\n-    let p = comm::port();\n-    let c = comm::chan(p);\n-    send(c, 1);\n-    send(c, 2);\n-    send(c, 3);\n-    send(c, 4);\n-    r = comm::recv(p);\n+    let (c, p) = pipes::stream();\n+    c.send(1);\n+    c.send(2);\n+    c.send(3);\n+    c.send(4);\n+    r = p.recv();\n     sum += r;\n     log(debug, r);\n-    r = comm::recv(p);\n+    r = p.recv();\n     sum += r;\n     log(debug, r);\n-    r = comm::recv(p);\n+    r = p.recv();\n     sum += r;\n     log(debug, r);\n-    r = comm::recv(p);\n+    r = p.recv();\n     sum += r;\n     log(debug, r);\n-    send(c, 5);\n-    send(c, 6);\n-    send(c, 7);\n-    send(c, 8);\n-    r = comm::recv(p);\n+    c.send(5);\n+    c.send(6);\n+    c.send(7);\n+    c.send(8);\n+    r = p.recv();\n     sum += r;\n     log(debug, r);\n-    r = comm::recv(p);\n+    r = p.recv();\n     sum += r;\n     log(debug, r);\n-    r = comm::recv(p);\n+    r = p.recv();\n     sum += r;\n     log(debug, r);\n-    r = comm::recv(p);\n+    r = p.recv();\n     sum += r;\n     log(debug, r);\n     assert (sum == 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8);"}, {"sha": "249bdaf1c9a5d649b748fc6d54d4ebb957ce7946", "filename": "src/test/run-pass/task-comm-5.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf/src%2Ftest%2Frun-pass%2Ftask-comm-5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf/src%2Ftest%2Frun-pass%2Ftask-comm-5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-5.rs?ref=97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf", "patch": "@@ -1,17 +1,16 @@\n use std;\n-import comm;\n+import pipes;\n \n fn main() { test00(); }\n \n fn test00() {\n     let r: int = 0;\n     let mut sum: int = 0;\n-    let p = comm::port();\n-    let c = comm::chan(p);\n+    let (c, p) = pipes::stream();\n     let number_of_messages: int = 1000;\n     let mut i: int = 0;\n-    while i < number_of_messages { comm::send(c, i + 0); i += 1; }\n+    while i < number_of_messages { c.send(i + 0); i += 1; }\n     i = 0;\n-    while i < number_of_messages { sum += comm::recv(p); i += 1; }\n+    while i < number_of_messages { sum += p.recv(); i += 1; }\n     assert (sum == number_of_messages * (number_of_messages - 1) / 2);\n }"}, {"sha": "8bc93a78913d01910a19b3ae613b22b4d01ea668", "filename": "src/test/run-pass/task-comm-6.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf/src%2Ftest%2Frun-pass%2Ftask-comm-6.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf/src%2Ftest%2Frun-pass%2Ftask-comm-6.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-6.rs?ref=97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf", "patch": "@@ -1,37 +1,37 @@\n use std;\n-import comm;\n-import comm::send;\n-import comm::chan;\n-import comm::recv;\n+import pipes;\n+import pipes::send;\n+import pipes::chan;\n+import pipes::recv;\n \n fn main() { test00(); }\n \n fn test00() {\n     let mut r: int = 0;\n     let mut sum: int = 0;\n-    let p = comm::port();\n-    let c0 = chan(p);\n-    let c1 = chan(p);\n-    let c2 = chan(p);\n-    let c3 = chan(p);\n+    let p = pipes::port_set();\n+    let c0 = p.chan();\n+    let c1 = p.chan();\n+    let c2 = p.chan();\n+    let c3 = p.chan();\n     let number_of_messages: int = 1000;\n     let mut i: int = 0;\n     while i < number_of_messages {\n-        send(c0, i + 0);\n-        send(c1, i + 0);\n-        send(c2, i + 0);\n-        send(c3, i + 0);\n+        c0.send(i + 0);\n+        c1.send(i + 0);\n+        c2.send(i + 0);\n+        c3.send(i + 0);\n         i += 1;\n     }\n     i = 0;\n     while i < number_of_messages {\n-        r = recv(p);\n+        r = p.recv();\n         sum += r;\n-        r = recv(p);\n+        r = p.recv();\n         sum += r;\n-        r = recv(p);\n+        r = p.recv();\n         sum += r;\n-        r = recv(p);\n+        r = p.recv();\n         sum += r;\n         i += 1;\n     }"}, {"sha": "1df3de6ba1eb8f59d391d1ea3bceb269e9954579", "filename": "src/test/run-pass/task-comm-7.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf/src%2Ftest%2Frun-pass%2Ftask-comm-7.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf/src%2Ftest%2Frun-pass%2Ftask-comm-7.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-7.rs?ref=97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf", "patch": "@@ -1,43 +1,45 @@\n use std;\n import task;\n-import comm;\n \n fn main() { test00(); }\n \n-fn test00_start(c: comm::chan<int>, start: int, number_of_messages: int) {\n+fn test00_start(c: pipes::chan<int>, start: int, number_of_messages: int) {\n     let mut i: int = 0;\n-    while i < number_of_messages { comm::send(c, start + i); i += 1; }\n+    while i < number_of_messages { c.send(start + i); i += 1; }\n }\n \n fn test00() {\n     let mut r: int = 0;\n     let mut sum: int = 0;\n-    let p = comm::port();\n+    let p = pipes::port_set();\n     let number_of_messages: int = 10;\n-    let c = comm::chan(p);\n \n+    let c = p.chan();\n     do task::spawn {\n         test00_start(c, number_of_messages * 0, number_of_messages);\n     }\n+    let c = p.chan();\n     do task::spawn {\n         test00_start(c, number_of_messages * 1, number_of_messages);\n     }\n+    let c = p.chan();\n     do task::spawn {\n         test00_start(c, number_of_messages * 2, number_of_messages);\n     }\n+    let c = p.chan();\n     do task::spawn {\n         test00_start(c, number_of_messages * 3, number_of_messages);\n     }\n \n     let mut i: int = 0;\n     while i < number_of_messages {\n-        r = comm::recv(p);\n+        r = p.recv();\n         sum += r;\n-        r = comm::recv(p);\n+        r = p.recv();\n         sum += r;\n-        r = comm::recv(p);\n+        r = p.recv();\n         sum += r;\n-        r = comm::recv(p);\n+        r = p.recv();\n         sum += r;\n         i += 1;\n     }"}, {"sha": "939cfd15797f1e4624ed88e30f2ed46b74e26bc9", "filename": "src/test/run-pass/task-comm-9.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf/src%2Ftest%2Frun-pass%2Ftask-comm-9.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf/src%2Ftest%2Frun-pass%2Ftask-comm-9.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-9.rs?ref=97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf", "patch": "@@ -1,20 +1,19 @@\n use std;\n import task;\n-import comm;\n \n fn main() { test00(); }\n \n-fn test00_start(c: comm::chan<int>, number_of_messages: int) {\n+fn test00_start(c: pipes::chan<int>, number_of_messages: int) {\n     let mut i: int = 0;\n-    while i < number_of_messages { comm::send(c, i + 0); i += 1; }\n+    while i < number_of_messages { c.send(i + 0); i += 1; }\n }\n \n fn test00() {\n     let r: int = 0;\n     let mut sum: int = 0;\n-    let p = comm::port();\n+    let p = pipes::port_set();\n     let number_of_messages: int = 10;\n-    let ch = comm::chan(p);\n+    let ch = p.chan();\n \n     let mut result = none;\n     do task::task().future_result(|-r| { result = some(r); }).spawn {\n@@ -23,7 +22,7 @@ fn test00() {\n \n     let mut i: int = 0;\n     while i < number_of_messages {\n-        sum += comm::recv(p);\n+        sum += p.recv();\n         log(debug, r);\n         i += 1;\n     }"}, {"sha": "ab3efd6b22eaeed0002036c30fa20083d0e08aa4", "filename": "src/test/run-pass/trivial-message.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf/src%2Ftest%2Frun-pass%2Ftrivial-message.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf/src%2Ftest%2Frun-pass%2Ftrivial-message.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrivial-message.rs?ref=97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf", "patch": "@@ -1,14 +1,12 @@\n-use std;\n-import comm::*;\n+import pipes::{port, chan};\n \n /*\n   This is about the simplest program that can successfully send a\n   message.\n  */\n fn main() {\n-    let po = port();\n-    let ch = chan(po);\n-    send(ch, 42);\n-    let r = recv(po);\n+    let (ch, po) = pipes::stream();\n+    ch.send(42);\n+    let r = po.recv();\n     log(error, r);\n }"}, {"sha": "0d1a49917512376c32799ea3a9fe9054d6ab0654", "filename": "src/test/run-pass/unreachable-code.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf/src%2Ftest%2Frun-pass%2Funreachable-code.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf/src%2Ftest%2Frun-pass%2Funreachable-code.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funreachable-code.rs?ref=97422f0f0fdcbdd17a769fa9588e76b8bf8a5bdf", "patch": "@@ -0,0 +1,31 @@\n+// xfail-pretty\n+\n+fn id(x: bool) -> bool { x }\n+\n+fn call_id() {\n+    let c <- fail;\n+    id(c);\n+}\n+\n+fn call_id_2() { id(true) && id(ret); }\n+\n+fn call_id_3() { id(ret) && id(ret); }\n+\n+fn log_fail() { log(error, fail); }\n+\n+fn log_ret() { log(error, ret); }\n+\n+fn log_break() { loop { log(error, break); } }\n+\n+fn log_again() { loop { log(error, again); } }\n+\n+fn ret_ret() -> int { ret (ret 2) + 3; }\n+\n+fn ret_guard() {\n+    alt 2 {\n+      x if (ret) { x; }\n+      _ {}\n+    }\n+}\n+\n+fn main() {}"}]}