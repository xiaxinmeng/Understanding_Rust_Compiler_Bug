{"sha": "32b2ef7add2836cba5867d2e5ac9610cef416447", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMyYjJlZjdhZGQyODM2Y2JhNTg2N2QyZTVhYzk2MTBjZWY0MTY0NDc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-02-09T22:28:45Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-02-09T22:28:45Z"}, "message": "Auto merge of #31523 - steveklabnik:rollup, r=steveklabnik\n\n- Successful merges: #31473, #31513, #31514, #31515, #31516, #31520\n- Failed merges:", "tree": {"sha": "4e7fd04d0b3cac99c23257d42a79cf4d58b53af1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4e7fd04d0b3cac99c23257d42a79cf4d58b53af1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/32b2ef7add2836cba5867d2e5ac9610cef416447", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/32b2ef7add2836cba5867d2e5ac9610cef416447", "html_url": "https://github.com/rust-lang/rust/commit/32b2ef7add2836cba5867d2e5ac9610cef416447", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/32b2ef7add2836cba5867d2e5ac9610cef416447/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "096dbf84c7acc78283adfa46eecd41d7355f6f3e", "url": "https://api.github.com/repos/rust-lang/rust/commits/096dbf84c7acc78283adfa46eecd41d7355f6f3e", "html_url": "https://github.com/rust-lang/rust/commit/096dbf84c7acc78283adfa46eecd41d7355f6f3e"}, {"sha": "af1a0a346639966373206b70d7cd6376937bb544", "url": "https://api.github.com/repos/rust-lang/rust/commits/af1a0a346639966373206b70d7cd6376937bb544", "html_url": "https://github.com/rust-lang/rust/commit/af1a0a346639966373206b70d7cd6376937bb544"}], "stats": {"total": 280, "additions": 165, "deletions": 115}, "files": [{"sha": "11086af10bd3daca6cecf3eafdc6071d7da8a72d", "filename": "src/doc/book/error-handling.md", "status": "modified", "additions": 45, "deletions": 46, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/32b2ef7add2836cba5867d2e5ac9610cef416447/src%2Fdoc%2Fbook%2Ferror-handling.md", "raw_url": "https://github.com/rust-lang/rust/raw/32b2ef7add2836cba5867d2e5ac9610cef416447/src%2Fdoc%2Fbook%2Ferror-handling.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Ferror-handling.md?ref=32b2ef7add2836cba5867d2e5ac9610cef416447", "patch": "@@ -265,7 +265,7 @@ fn map<F, T, A>(option: Option<T>, f: F) -> Option<A> where F: FnOnce(T) -> A {\n ```\n \n Indeed, `map` is [defined as a method][2] on `Option<T>` in the standard library.\n-As a method, it has a slighly different signature: methods take `self`, `&self`,\n+As a method, it has a slightly different signature: methods take `self`, `&self`,\n or `&mut self` as their first argument.\n \n Armed with our new combinator, we can rewrite our `extension_explicit` method\n@@ -1592,7 +1592,7 @@ fn print_usage(program: &str, opts: Options) {\n \n fn main() {\n     let args: Vec<String> = env::args().collect();\n-    let program = args[0].clone();\n+    let program = &args[0];\n \n     let mut opts = Options::new();\n     opts.optflag(\"h\", \"help\", \"Show this usage message.\");\n@@ -1605,10 +1605,10 @@ fn main() {\n         print_usage(&program, opts);\n         return;\n     }\n-    let data_path = args[1].clone();\n-    let city = args[2].clone();\n+    let data_path = &args[1];\n+    let city = &args[2];\n \n-\t// Do stuff with information\n+    // Do stuff with information\n }\n ```\n \n@@ -1640,7 +1640,6 @@ sure to add `extern crate csv;` to the top of your file.)\n \n ```rust,ignore\n use std::fs::File;\n-use std::path::Path;\n \n // This struct represents the data in each row of the CSV file.\n // Type based decoding absolves us of a lot of the nitty gritty error\n@@ -1666,7 +1665,7 @@ fn print_usage(program: &str, opts: Options) {\n \n fn main() {\n     let args: Vec<String> = env::args().collect();\n-    let program = args[0].clone();\n+    let program = &args[0];\n \n     let mut opts = Options::new();\n     opts.optflag(\"h\", \"help\", \"Show this usage message.\");\n@@ -1678,25 +1677,24 @@ fn main() {\n \n     if matches.opt_present(\"h\") {\n         print_usage(&program, opts);\n-\t\treturn;\n-\t}\n+        return;\n+    }\n \n-\tlet data_file = args[1].clone();\n-\tlet data_path = Path::new(&data_file);\n-\tlet city = args[2].clone();\n+    let data_path = &args[1];\n+    let city: &str = &args[2];\n \n-\tlet file = File::open(data_path).unwrap();\n-\tlet mut rdr = csv::Reader::from_reader(file);\n+    let file = File::open(data_path).unwrap();\n+    let mut rdr = csv::Reader::from_reader(file);\n \n-\tfor row in rdr.decode::<Row>() {\n-\t\tlet row = row.unwrap();\n+    for row in rdr.decode::<Row>() {\n+        let row = row.unwrap();\n \n-\t\tif row.city == city {\n-\t\t\tprintln!(\"{}, {}: {:?}\",\n-\t\t\t\trow.city, row.country,\n-\t\t\t\trow.population.expect(\"population count\"));\n-\t\t}\n-\t}\n+        if row.city == city {\n+            println!(\"{}, {}: {:?}\",\n+                row.city, row.country,\n+                row.population.expect(\"population count\"));\n+        }\n+    }\n }\n ```\n \n@@ -1745,6 +1743,8 @@ Note that we opt to handle the possibility of a missing population count by\n simply ignoring that row.\n \n ```rust,ignore\n+use std::path::Path;\n+\n struct Row {\n     // unchanged\n }\n@@ -1782,27 +1782,26 @@ fn search<P: AsRef<Path>>(file_path: P, city: &str) -> Vec<PopulationCount> {\n }\n \n fn main() {\n-\tlet args: Vec<String> = env::args().collect();\n-\tlet program = args[0].clone();\n+    let args: Vec<String> = env::args().collect();\n+    let program = &args[0];\n \n-\tlet mut opts = Options::new();\n-\topts.optflag(\"h\", \"help\", \"Show this usage message.\");\n+    let mut opts = Options::new();\n+    opts.optflag(\"h\", \"help\", \"Show this usage message.\");\n \n-\tlet matches = match opts.parse(&args[1..]) {\n-\t\tOk(m)  => { m }\n-\t\tErr(e) => { panic!(e.to_string()) }\n-\t};\n-\tif matches.opt_present(\"h\") {\n-\t\tprint_usage(&program, opts);\n-\t\treturn;\n-\t}\n+    let matches = match opts.parse(&args[1..]) {\n+        Ok(m)  => { m }\n+        Err(e) => { panic!(e.to_string()) }\n+    };\n+    if matches.opt_present(\"h\") {\n+        print_usage(&program, opts);\n+        return;\n+    }\n \n-\tlet data_file = args[1].clone();\n-\tlet data_path = Path::new(&data_file);\n-\tlet city = args[2].clone();\n-\tfor pop in search(&data_path, &city) {\n-\t\tprintln!(\"{}, {}: {:?}\", pop.city, pop.country, pop.count);\n-\t}\n+    let data_path = &args[1];\n+    let city = &args[2];\n+    for pop in search(data_path, city) {\n+        println!(\"{}, {}: {:?}\", pop.city, pop.country, pop.count);\n+    }\n }\n \n ```\n@@ -1912,7 +1911,7 @@ First, here's the new usage:\n \n ```rust,ignore\n fn print_usage(program: &str, opts: Options) {\n-\tprintln!(\"{}\", opts.usage(&format!(\"Usage: {} [options] <city>\", program)));\n+    println!(\"{}\", opts.usage(&format!(\"Usage: {} [options] <city>\", program)));\n }\n ```\n The next part is going to be only a little harder:\n@@ -1924,16 +1923,16 @@ opts.optopt(\"f\", \"file\", \"Choose an input file, instead of using STDIN.\", \"NAME\"\n opts.optflag(\"h\", \"help\", \"Show this usage message.\");\n ...\n let file = matches.opt_str(\"f\");\n-let data_file = file.as_ref().map(Path::new);\n+let data_file = &file.as_ref().map(Path::new);\n \n let city = if !matches.free.is_empty() {\n-\tmatches.free[0].clone()\n+    &matches.free[0]\n } else {\n-\tprint_usage(&program, opts);\n-\treturn;\n+    print_usage(&program, opts);\n+    return;\n };\n \n-match search(&data_file, &city) {\n+match search(data_file, city) {\n     Ok(pops) => {\n         for pop in pops {\n             println!(\"{}, {}: {:?}\", pop.city, pop.country, pop.count);"}, {"sha": "4087dd729175082d6e00f7371b4fbab18236aa78", "filename": "src/libbacktrace/ansidecl.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32b2ef7add2836cba5867d2e5ac9610cef416447/src%2Flibbacktrace%2Fansidecl.h", "raw_url": "https://github.com/rust-lang/rust/raw/32b2ef7add2836cba5867d2e5ac9610cef416447/src%2Flibbacktrace%2Fansidecl.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fansidecl.h?ref=32b2ef7add2836cba5867d2e5ac9610cef416447", "patch": "@@ -1,4 +1,4 @@\n-/* ANSI and traditional C compatability macros\n+/* ANSI and traditional C compatibility macros\n    Copyright (C) 1991-2015 Free Software Foundation, Inc.\n    This file is part of the GNU C Library.\n "}, {"sha": "8ae23a646e48855caa7ed93019d42d6e8bcc060b", "filename": "src/libcollections/btree/node.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32b2ef7add2836cba5867d2e5ac9610cef416447/src%2Flibcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32b2ef7add2836cba5867d2e5ac9610cef416447/src%2Flibcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fnode.rs?ref=32b2ef7add2836cba5867d2e5ac9610cef416447", "patch": "@@ -28,7 +28,7 @@\n // }\n // ```\n //\n-// Since Rust doesn't acutally have dependent types and polymorphic recursion,\n+// Since Rust doesn't actually have dependent types and polymorphic recursion,\n // we make do with lots of unsafety.\n \n use alloc::heap;"}, {"sha": "89b5e5b30755c11c11a531a626231398478b8a53", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32b2ef7add2836cba5867d2e5ac9610cef416447/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32b2ef7add2836cba5867d2e5ac9610cef416447/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=32b2ef7add2836cba5867d2e5ac9610cef416447", "patch": "@@ -1808,7 +1808,7 @@ impl str {\n                 // \u03a3 maps to \u03c3, except at the end of a word where it maps to \u03c2.\n                 // This is the only conditional (contextual) but language-independent mapping\n                 // in `SpecialCasing.txt`,\n-                // so hard-code it rather than have a generic \"condition\" mechanim.\n+                // so hard-code it rather than have a generic \"condition\" mechanism.\n                 // See https://github.com/rust-lang/rust/issues/26035\n                 map_uppercase_sigma(self, i, &mut s)\n             } else {"}, {"sha": "62ae7938e15e389b3133d5b20b5e09ce05c5768f", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/32b2ef7add2836cba5867d2e5ac9610cef416447/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32b2ef7add2836cba5867d2e5ac9610cef416447/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=32b2ef7add2836cba5867d2e5ac9610cef416447", "patch": "@@ -193,7 +193,7 @@ use boxed::Box;\n /// mem::forget(story);\n ///\n /// // We can re-build a String out of ptr, len, and capacity. This is all\n-/// // unsafe becuase we are responsible for making sure the components are\n+/// // unsafe because we are responsible for making sure the components are\n /// // valid:\n /// let s = unsafe { String::from_raw_parts(ptr as *mut _, len, capacity) } ;\n ///\n@@ -1842,6 +1842,12 @@ impl fmt::Write for String {\n }\n \n /// A draining iterator for `String`.\n+///\n+/// This struct is created by the [`drain()`] method on [`String`]. See its\n+/// documentation for more.\n+///\n+/// [`drain()`]: struct.String.html#method.drain\n+/// [`String`]: struct.String.html\n #[stable(feature = \"drain\", since = \"1.6.0\")]\n pub struct Drain<'a> {\n     /// Will be used as &'a mut String in the destructor"}, {"sha": "b4ac020795c3804b01453c70baf82b253ebfa466", "filename": "src/libcore/convert.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32b2ef7add2836cba5867d2e5ac9610cef416447/src%2Flibcore%2Fconvert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32b2ef7add2836cba5867d2e5ac9610cef416447/src%2Flibcore%2Fconvert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fconvert.rs?ref=32b2ef7add2836cba5867d2e5ac9610cef416447", "patch": "@@ -19,7 +19,7 @@\n //!\n //! - Impl the `As*` traits for reference-to-reference conversions\n //! - Impl the `Into` trait when you want to consume the value in the conversion\n-//! - The `From` trait is the most flexible, usefull for values _and_ references conversions\n+//! - The `From` trait is the most flexible, useful for values _and_ references conversions\n //!\n //! As a library writer, you should prefer implementing `From<T>` rather than\n //! `Into<U>`, as `From` provides greater flexibility and offer the equivalent `Into`"}, {"sha": "9e946dc65c25388d75305e687456ccdd59ffeed6", "filename": "src/libcore/num/dec2flt/mod.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/32b2ef7add2836cba5867d2e5ac9610cef416447/src%2Flibcore%2Fnum%2Fdec2flt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32b2ef7add2836cba5867d2e5ac9610cef416447/src%2Flibcore%2Fnum%2Fdec2flt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fdec2flt%2Fmod.rs?ref=32b2ef7add2836cba5867d2e5ac9610cef416447", "patch": "@@ -149,6 +149,13 @@ from_str_float_impl!(f32);\n from_str_float_impl!(f64);\n \n /// An error which can be returned when parsing a float.\n+///\n+/// This error is used as the error type for the [`FromStr`] implementation\n+/// for [`f32`] and [`f64`].\n+///\n+/// [`FromStr`]: ../str/trait.FromStr.html\n+/// [`f32`]: ../primitive.f32.html\n+/// [`f64`]: ../primitive.f64.html\n #[derive(Debug, Clone, PartialEq)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct ParseFloatError {"}, {"sha": "9a9dfaa26797a3977c39708940c4cefcce3a8dc9", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/32b2ef7add2836cba5867d2e5ac9610cef416447/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32b2ef7add2836cba5867d2e5ac9610cef416447/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=32b2ef7add2836cba5867d2e5ac9610cef416447", "patch": "@@ -2160,7 +2160,13 @@ impl usize {\n         intrinsics::mul_with_overflow }\n }\n \n-/// Used for representing the classification of floating point numbers\n+/// A classification of floating point numbers.\n+///\n+/// This `enum` is used as the return type for [`f32::classify()`] and [`f64::classify()`]. See\n+/// their documentation for more.\n+///\n+/// [`f32::classify()`]: ../primitive.f32.html#method.classify\n+/// [`f64::classify()`]: ../primitive.f64.html#method.classify\n #[derive(Copy, Clone, PartialEq, Debug)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub enum FpCategory {\n@@ -2387,6 +2393,11 @@ fn from_str_radix<T: FromStrRadixHelper>(src: &str, radix: u32)\n }\n \n /// An error which can be returned when parsing an integer.\n+///\n+/// This error is used as the error type for the `from_str_radix()` functions\n+/// on the primitive integer types, such as [`i8::from_str_radix()`].\n+///\n+/// [`i8::from_str_radix()`]: ../std/primitive.i8.html#method.from_str_radix\n #[derive(Debug, Clone, PartialEq)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct ParseIntError { kind: IntErrorKind }"}, {"sha": "fa169416a1081ab6042fe2327ae8f71e99b8cb54", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32b2ef7add2836cba5867d2e5ac9610cef416447/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32b2ef7add2836cba5867d2e5ac9610cef416447/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=32b2ef7add2836cba5867d2e5ac9610cef416447", "patch": "@@ -1740,7 +1740,7 @@ impl StrExt for str {\n         let mut matcher = pat.into_searcher(self);\n         if let Some((a, b)) = matcher.next_reject() {\n             i = a;\n-            j = b; // Rember earliest known match, correct it below if\n+            j = b; // Remember earliest known match, correct it below if\n                    // last match is different\n         }\n         if let Some((_, b)) = matcher.next_reject_back() {"}, {"sha": "abaabfd129b383d31584a10657dc0a71232f7a3c", "filename": "src/libcore/tuple.rs", "status": "modified", "additions": 1, "deletions": 18, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/32b2ef7add2836cba5867d2e5ac9610cef416447/src%2Flibcore%2Ftuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32b2ef7add2836cba5867d2e5ac9610cef416447/src%2Flibcore%2Ftuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftuple.rs?ref=32b2ef7add2836cba5867d2e5ac9610cef416447", "patch": "@@ -8,24 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! A finite heterogeneous sequence, `(T, U, ..)`\n-//!\n-//! To access a single element of a tuple one can use the `.0`\n-//! field access syntax.\n-//!\n-//! Indexing starts from zero, so `.0` returns first value, `.1`\n-//! returns second value, and so on. In general, a tuple with *N*\n-//! elements has field accessors from 0 to *N* - 1.\n-//!\n-//! If every type inside a tuple implements one of the following\n-//! traits, then a tuple itself also implements it.\n-//!\n-//! * `Clone`\n-//! * `PartialEq`\n-//! * `Eq`\n-//! * `PartialOrd`\n-//! * `Ord`\n-//! * `Default`\n+// See src/libstd/primitive_docs.rs for documentation.\n \n use clone::Clone;\n use cmp::*;"}, {"sha": "1727fa2a0d34ad382876850dd0d55ccd28ff7099", "filename": "src/librbml/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32b2ef7add2836cba5867d2e5ac9610cef416447/src%2Flibrbml%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32b2ef7add2836cba5867d2e5ac9610cef416447/src%2Flibrbml%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrbml%2Flib.rs?ref=32b2ef7add2836cba5867d2e5ac9610cef416447", "patch": "@@ -107,7 +107,7 @@\n //!\n //! - `Opaque` (`17`): An opaque, custom-format tag.\n //!   Used to wrap ordinary custom tags or data in the auto-serialized context.\n-//!   Rustc typically uses this to encode type informations.\n+//!   Rustc typically uses this to encode type information.\n //!\n //! First 0x20 tags are reserved by RBML; custom tags start at 0x20.\n "}, {"sha": "8181e7d798c126a3953eab2176e546d156dc21bd", "filename": "src/librustc/middle/pat_util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/32b2ef7add2836cba5867d2e5ac9610cef416447/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32b2ef7add2836cba5867d2e5ac9610cef416447/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fpat_util.rs?ref=32b2ef7add2836cba5867d2e5ac9610cef416447", "patch": "@@ -153,7 +153,7 @@ pub fn pat_contains_bindings(dm: &DefMap, pat: &hir::Pat) -> bool {\n }\n \n /// Checks if the pattern contains any `ref` or `ref mut` bindings,\n-/// and if yes wether its containing mutable ones or just immutables ones.\n+/// and if yes whether its containing mutable ones or just immutables ones.\n pub fn pat_contains_ref_binding(dm: &RefCell<DefMap>, pat: &hir::Pat) -> Option<hir::Mutability> {\n     let mut result = None;\n     pat_bindings(dm, pat, |mode, _, _, _| {\n@@ -172,7 +172,7 @@ pub fn pat_contains_ref_binding(dm: &RefCell<DefMap>, pat: &hir::Pat) -> Option<\n }\n \n /// Checks if the patterns for this arm contain any `ref` or `ref mut`\n-/// bindings, and if yes wether its containing mutable ones or just immutables ones.\n+/// bindings, and if yes whether its containing mutable ones or just immutables ones.\n pub fn arm_contains_ref_binding(dm: &RefCell<DefMap>, arm: &hir::Arm) -> Option<hir::Mutability> {\n     arm.pats.iter()\n             .filter_map(|pat| pat_contains_ref_binding(dm, pat))"}, {"sha": "e3357aabd5dd568aa2a739874859288e4c9e5e84", "filename": "src/librustc/middle/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32b2ef7add2836cba5867d2e5ac9610cef416447/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32b2ef7add2836cba5867d2e5ac9610cef416447/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs?ref=32b2ef7add2836cba5867d2e5ac9610cef416447", "patch": "@@ -2236,7 +2236,7 @@ impl<'tcx> ctxt<'tcx> {\n     /// Given the did of an ADT, return a reference to its definition.\n     pub fn lookup_adt_def(&self, did: DefId) -> AdtDef<'tcx> {\n         // when reverse-variance goes away, a transmute::<AdtDefMaster,AdtDef>\n-        // woud be needed here.\n+        // would be needed here.\n         self.lookup_adt_def_master(did)\n     }\n "}, {"sha": "5e3c6e028a32524159aad94610b58b2494561767", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32b2ef7add2836cba5867d2e5ac9610cef416447/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32b2ef7add2836cba5867d2e5ac9610cef416447/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=32b2ef7add2836cba5867d2e5ac9610cef416447", "patch": "@@ -92,7 +92,7 @@ macro_rules! make_mir_visitor {\n             }\n \n             // The `super_xxx` methods comprise the default behavior and are\n-            // not meant to be overidden.\n+            // not meant to be overridden.\n \n             fn super_mir(&mut self,\n                          mir: & $($mutability)* Mir<'tcx>) {"}, {"sha": "1269c266c7c10ade2bcab46130bbd5924d83ff1e", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32b2ef7add2836cba5867d2e5ac9610cef416447/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32b2ef7add2836cba5867d2e5ac9610cef416447/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=32b2ef7add2836cba5867d2e5ac9610cef416447", "patch": "@@ -541,7 +541,7 @@ impl<'a, 'tcx> FunctionContext<'a, 'tcx> {\n     }\n \n     // Returns a ValueRef of the \"eh_unwind_resume\" lang item if one is defined,\n-    // otherwise declares it as an external funtion.\n+    // otherwise declares it as an external function.\n     pub fn eh_unwind_resume(&self) -> ValueRef {\n         use trans::attributes;\n         assert!(self.ccx.sess().target.target.options.custom_unwind_resume);"}, {"sha": "a476f9e1a8060d4fe3db42ad8773468a7f931bd8", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32b2ef7add2836cba5867d2e5ac9610cef416447/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32b2ef7add2836cba5867d2e5ac9610cef416447/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=32b2ef7add2836cba5867d2e5ac9610cef416447", "patch": "@@ -1809,7 +1809,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             debug!(\"select_all_obligations_and_apply_defaults: defaults={:?}\", default_map);\n \n             // We loop over the unsolved variables, resolving them and if they are\n-            // and unconstrainted numberic type we add them to the set of unbound\n+            // and unconstrainted numeric type we add them to the set of unbound\n             // variables. We do this so we only apply literal fallback to type\n             // variables without defaults.\n             for ty in &unsolved_variables {"}, {"sha": "d42b948918049ba2291048438e8eb82dad97252a", "filename": "src/libstd/fs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32b2ef7add2836cba5867d2e5ac9610cef416447/src%2Flibstd%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32b2ef7add2836cba5867d2e5ac9610cef416447/src%2Flibstd%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffs.rs?ref=32b2ef7add2836cba5867d2e5ac9610cef416447", "patch": "@@ -521,7 +521,7 @@ impl OpenOptions {\n     /// No file is allowed to exist at the target location, also no (dangling)\n     /// symlink.\n     ///\n-    /// This option is usefull because it as atomic. Otherwise between checking\n+    /// This option is useful because it as atomic. Otherwise between checking\n     /// whether a file exists and creating a new one, the file may have been\n     /// created by another process (a TOCTOU race condition / attack).\n     ///"}, {"sha": "1d97611eabb2671261826c8abfa2a090dcc2f886", "filename": "src/libstd/memchr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32b2ef7add2836cba5867d2e5ac9610cef416447/src%2Flibstd%2Fmemchr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32b2ef7add2836cba5867d2e5ac9610cef416447/src%2Flibstd%2Fmemchr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmemchr.rs?ref=32b2ef7add2836cba5867d2e5ac9610cef416447", "patch": "@@ -150,7 +150,7 @@ mod fallback {\n         // Scan for a single byte value by reading two `usize` words at a time.\n         //\n         // Split `text` in three parts\n-        // - unaligned inital part, before the first word aligned address in text\n+        // - unaligned initial part, before the first word aligned address in text\n         // - body, scan by 2 words at a time\n         // - the last remaining part, < 2 word size\n         let len = text.len();"}, {"sha": "dd0d874ee4b7cbdd942e317180ea114c56849ee0", "filename": "src/libstd/num/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/32b2ef7add2836cba5867d2e5ac9610cef416447/src%2Flibstd%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32b2ef7add2836cba5867d2e5ac9610cef416447/src%2Flibstd%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fmod.rs?ref=32b2ef7add2836cba5867d2e5ac9610cef416447", "patch": "@@ -8,10 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Numeric traits and functions for generic mathematics\n+//! Additional functionality for numerics.\n //!\n-//! These are implemented for the primitive numeric types in `std::{u8, u16,\n-//! u32, u64, usize, i8, i16, i32, i64, isize, f32, f64}`.\n+//! This module provides some extra types that are useful when doing numerical\n+//! work. See the individual documentation for each piece for more information.\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n #![allow(missing_docs)]"}, {"sha": "83df54f1830146da666602c1efa109a4cad7fe6e", "filename": "src/libstd/panic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32b2ef7add2836cba5867d2e5ac9610cef416447/src%2Flibstd%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32b2ef7add2836cba5867d2e5ac9610cef416447/src%2Flibstd%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpanic.rs?ref=32b2ef7add2836cba5867d2e5ac9610cef416447", "patch": "@@ -84,7 +84,7 @@ pub use panicking::{take_handler, set_handler, PanicInfo, Location};\n /// recover safe. The general idea is that any mutable state which can be shared\n /// across `recover` is not recover safe by default. This is because it is very\n /// easy to witness a broken invariant outside of `recover` as the data is\n-/// simply accesed as usual.\n+/// simply accessed as usual.\n ///\n /// Types like `&Mutex<T>`, however, are recover safe because they implement\n /// poisoning by default. They still allow witnessing a broken invariant, but"}, {"sha": "a0db471deceb3e8619d82e306228802d1e2da31d", "filename": "src/libstd/prelude/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32b2ef7add2836cba5867d2e5ac9610cef416447/src%2Flibstd%2Fprelude%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32b2ef7add2836cba5867d2e5ac9610cef416447/src%2Flibstd%2Fprelude%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude%2Fmod.rs?ref=32b2ef7add2836cba5867d2e5ac9610cef416447", "patch": "@@ -17,7 +17,7 @@\n //!\n //! The *prelude* is the list of things that Rust automatically imports into\n //! every Rust program. It's kept as small as possible, and is focused on\n-//! things, particuarly traits, which are used in almost every single Rust\n+//! things, particularly traits, which are used in almost every single Rust\n //! program.\n //!\n //! On a technical level, Rust inserts"}, {"sha": "ad93fe0094ae4f626d6c419cc252349f128786a5", "filename": "src/libstd/primitive_docs.rs", "status": "modified", "additions": 71, "deletions": 27, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/32b2ef7add2836cba5867d2e5ac9610cef416447/src%2Flibstd%2Fprimitive_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32b2ef7add2836cba5867d2e5ac9610cef416447/src%2Flibstd%2Fprimitive_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprimitive_docs.rs?ref=32b2ef7add2836cba5867d2e5ac9610cef416447", "patch": "@@ -357,50 +357,94 @@ mod prim_str { }\n //\n /// A finite heterogeneous sequence, `(T, U, ..)`.\n ///\n-/// To access the _N_-th element of a tuple one can use `N` itself\n-/// as a field of the tuple.\n+/// Let's cover each of those in turn:\n ///\n-/// Indexing starts from zero, so `0` returns first value, `1`\n-/// returns second value, and so on. In general, a tuple with _S_\n-/// elements provides aforementioned fields from `0` to `S-1`.\n+/// Tuples are *finite*. In other words, a tuple has a length. Here's a tuple\n+/// of length `3`:\n+///\n+/// ```\n+/// (\"hello\", 5, 'c');\n+/// ```\n+///\n+/// 'Length' is also sometimes called 'arity' here; each tuple of a different\n+/// length is a different, distinct type.\n+///\n+/// Tuples are *heterogeneous*. This means that each element of the tuple can\n+/// have a different type. In that tuple above, it has the type:\n+///\n+/// ```rust,ignore\n+/// (&'static str, i32, char)\n+/// ```\n+///\n+/// Tuples are a *sequence*. This means that they can be accessed by position;\n+/// this is called 'tuple indexing', and it looks like this:\n+///\n+/// ```rust\n+/// let tuple = (\"hello\", 5, 'c');\n+///\n+/// assert_eq!(tuple.0, \"hello\");\n+/// assert_eq!(tuple.1, 5);\n+/// assert_eq!(tuple.2, 'c');\n+/// ```\n+///\n+/// For more about tuples, see [the book](../../book/primitive-types.html#tuples).\n+///\n+/// # Trait implementations\n ///\n /// If every type inside a tuple implements one of the following\n /// traits, then a tuple itself also implements it.\n ///\n-/// * `Clone`\n-/// * `PartialEq`\n-/// * `Eq`\n-/// * `PartialOrd`\n-/// * `Ord`\n-/// * `Debug`\n-/// * `Default`\n-/// * `Hash`\n+/// * [`Clone`]\n+/// * [`PartialEq`]\n+/// * [`Eq`]\n+/// * [`PartialOrd`]\n+/// * [`Ord`]\n+/// * [`Debug`]\n+/// * [`Default`]\n+/// * [`Hash`]\n+///\n+/// [`Clone`]: ../clone/trait.Clone.html\n+/// [`PartialEq`]: ../cmp/trait.PartialEq.html\n+/// [`Eq`]: ../cmp/trait.Eq.html\n+/// [`PartialOrd`]: ../cmp/trait.PartialOrd.html\n+/// [`Ord`]: ../cmp/trait.Ord.html\n+/// [`Debug`]: ../fmt/trait.Debug.html\n+/// [`Default`]: ../default/trait.Default.html\n+/// [`Hash`]: ../hash/trait.Hash.html\n+///\n+/// Due to a temporary restriction in Rust's type system, these traits are only\n+/// implemented on tuples of arity 32 or less. In the future, this may change.\n ///\n /// # Examples\n ///\n-/// Accessing elements of a tuple at specified indices:\n+/// Basic usage:\n ///\n /// ```\n-/// let x = (\"colorless\",  \"green\", \"ideas\", \"sleep\", \"furiously\");\n-/// assert_eq!(x.3, \"sleep\");\n+/// let tuple = (\"hello\", 5, 'c');\n ///\n-/// let v = (3, 3);\n-/// let u = (1, -5);\n-/// assert_eq!(v.0 * u.0 + v.1 * u.1, -12);\n+/// assert_eq!(tuple.0, \"hello\");\n /// ```\n ///\n-/// Using traits implemented for tuples:\n+/// Tuples are often used as a return type when you want to return more than\n+/// one value:\n ///\n /// ```\n-/// let a = (1, 2);\n-/// let b = (3, 4);\n-/// assert!(a != b);\n+/// fn calculate_point() -> (i32, i32) {\n+///     // Don't do a calculation, that's not the point of the example\n+///     (4, 5)\n+/// }\n+///\n+/// let point = calculate_point();\n+///\n+/// assert_eq!(point.0, 4);\n+/// assert_eq!(point.1, 5);\n+///\n+/// // Combining this with patterns can be nicer.\n ///\n-/// let c = b.clone();\n-/// assert!(b == c);\n+/// let (x, y) = calculate_point();\n ///\n-/// let d : (u32, f32) = Default::default();\n-/// assert_eq!(d, (0, 0.0f32));\n+/// assert_eq!(x, 4);\n+/// assert_eq!(y, 5);\n /// ```\n ///\n mod prim_tuple { }"}, {"sha": "2b4d0dc339bf0da0b4ada1f5a5dcdadb084bc40e", "filename": "src/test/compile-fail/issue-30438-c.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32b2ef7add2836cba5867d2e5ac9610cef416447/src%2Ftest%2Fcompile-fail%2Fissue-30438-c.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32b2ef7add2836cba5867d2e5ac9610cef416447/src%2Ftest%2Fcompile-fail%2Fissue-30438-c.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-30438-c.rs?ref=32b2ef7add2836cba5867d2e5ac9610cef416447", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// Simplfied regression test for #30438, inspired by arielb1.\n+// Simplified regression test for #30438, inspired by arielb1.\n \n trait Trait { type Out; }\n "}, {"sha": "ec8db996600d1478520f5e4bc50b9b3f68ae66af", "filename": "src/test/compile-fail/traits-inductive-overflow-supertrait-oibit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32b2ef7add2836cba5867d2e5ac9610cef416447/src%2Ftest%2Fcompile-fail%2Ftraits-inductive-overflow-supertrait-oibit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32b2ef7add2836cba5867d2e5ac9610cef416447/src%2Ftest%2Fcompile-fail%2Ftraits-inductive-overflow-supertrait-oibit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftraits-inductive-overflow-supertrait-oibit.rs?ref=32b2ef7add2836cba5867d2e5ac9610cef416447", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n // OIBIT-based version of #29859, supertrait version. Test that using\n-// a simple OIBIT `..` impl alone still doesn't allow arbitary bounds\n+// a simple OIBIT `..` impl alone still doesn't allow arbitrary bounds\n // to be synthesized.\n \n #![feature(optin_builtin_traits)]"}, {"sha": "fc45fbf72784036a78b85d384c1469c7e2bd6bed", "filename": "src/test/run-pass/mir_trans_calls.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32b2ef7add2836cba5867d2e5ac9610cef416447/src%2Ftest%2Frun-pass%2Fmir_trans_calls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32b2ef7add2836cba5867d2e5ac9610cef416447/src%2Ftest%2Frun-pass%2Fmir_trans_calls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmir_trans_calls.rs?ref=32b2ef7add2836cba5867d2e5ac9610cef416447", "patch": "@@ -113,7 +113,7 @@ fn test_fn_object(f: &Fn(i32, i32) -> i32, x: i32, y: i32) -> i32 {\n fn test_fn_impl(f: &&Fn(i32, i32) -> i32, x: i32, y: i32) -> i32 {\n     // This call goes through the Fn implementation for &Fn provided in\n     // core::ops::impls. It expands to a static Fn::call() that calls the\n-    // Fn::call() implemenation of the object shim underneath.\n+    // Fn::call() implementation of the object shim underneath.\n     f(x, y)\n }\n "}]}