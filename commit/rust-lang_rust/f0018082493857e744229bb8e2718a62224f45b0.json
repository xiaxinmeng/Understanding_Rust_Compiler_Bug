{"sha": "f0018082493857e744229bb8e2718a62224f45b0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYwMDE4MDgyNDkzODU3ZTc0NDIyOWJiOGUyNzE4YTYyMjI0ZjQ1YjA=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2018-07-31T10:25:16Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2018-07-31T10:25:16Z"}, "message": "Run rustfmt 0.9.0-nightly (69ad879 2018-07-27)", "tree": {"sha": "035f8a439592092ee9a5f20272652ee987c3edbf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/035f8a439592092ee9a5f20272652ee987c3edbf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f0018082493857e744229bb8e2718a62224f45b0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f0018082493857e744229bb8e2718a62224f45b0", "html_url": "https://github.com/rust-lang/rust/commit/f0018082493857e744229bb8e2718a62224f45b0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f0018082493857e744229bb8e2718a62224f45b0/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "82dbd0780694bd5281f9eb93199369da56e21ee2", "url": "https://api.github.com/repos/rust-lang/rust/commits/82dbd0780694bd5281f9eb93199369da56e21ee2", "html_url": "https://github.com/rust-lang/rust/commit/82dbd0780694bd5281f9eb93199369da56e21ee2"}], "stats": {"total": 913, "additions": 599, "deletions": 314}, "files": [{"sha": "e9896ef6c759458f0f25992e1f7836f627dc855b", "filename": "examples/example.rs", "status": "modified", "additions": 9, "deletions": 23, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/f0018082493857e744229bb8e2718a62224f45b0/examples%2Fexample.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0018082493857e744229bb8e2718a62224f45b0/examples%2Fexample.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/examples%2Fexample.rs?ref=f0018082493857e744229bb8e2718a62224f45b0", "patch": "@@ -62,16 +62,8 @@ fn cmp_raw_ptr(a: *const u8, b: *const u8) -> bool {\n \n fn int_cast(a: u16, b: i16) -> (u8, u16, u32, usize, i8, i16, i32, isize, u8, u32) {\n     (\n-        a as u8,\n-        a as u16,\n-        a as u32,\n-        a as usize,\n-        a as i8,\n-        a as i16,\n-        a as i32,\n-        a as isize,\n-        b as u8,\n-        b as u32\n+        a as u8, a as u16, a as u32, a as usize, a as i8, a as i16, a as i32, a as isize, b as u8,\n+        b as u32,\n     )\n }\n \n@@ -86,9 +78,7 @@ fn debug_tuple() -> DebugTuple {\n }\n \n fn size_of<T>() -> usize {\n-    unsafe {\n-        intrinsics::size_of::<T>()\n-    }\n+    unsafe { intrinsics::size_of::<T>() }\n }\n \n fn use_size_of() -> usize {\n@@ -111,31 +101,27 @@ fn use_const() -> u8 {\n }\n \n fn call_closure_3arg() {\n-    (|_, _, _| {\n-\n-    })(0u8, 42u16, 0u8)\n+    (|_, _, _| {})(0u8, 42u16, 0u8)\n }\n \n fn call_closure_2arg() {\n-    (|_, _| {\n-\n-    })(0u8, 42u16)\n+    (|_, _| {})(0u8, 42u16)\n }\n \n struct IsNotEmpty;\n \n-impl<'a, 'b> FnOnce<(&'a &'b [u16], )> for IsNotEmpty {\n+impl<'a, 'b> FnOnce<(&'a &'b [u16],)> for IsNotEmpty {\n     type Output = bool;\n \n     #[inline]\n-    extern \"rust-call\" fn call_once(mut self, arg: (&'a &'b [u16], )) -> bool {\n+    extern \"rust-call\" fn call_once(mut self, arg: (&'a &'b [u16],)) -> bool {\n         self.call_mut(arg)\n     }\n }\n \n-impl<'a, 'b> FnMut<(&'a &'b [u16], )> for IsNotEmpty {\n+impl<'a, 'b> FnMut<(&'a &'b [u16],)> for IsNotEmpty {\n     #[inline]\n-    extern \"rust-call\" fn call_mut(&mut self, arg: (&'a &'b [u16], )) -> bool {\n+    extern \"rust-call\" fn call_mut(&mut self, arg: (&'a &'b [u16],)) -> bool {\n         true\n     }\n }"}, {"sha": "ff22aad5a65d09bd3d8e2a94c7d83e39530b90e3", "filename": "examples/mini_core.rs", "status": "modified", "additions": 26, "deletions": 14, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/f0018082493857e744229bb8e2718a62224f45b0/examples%2Fmini_core.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0018082493857e744229bb8e2718a62224f45b0/examples%2Fmini_core.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/examples%2Fmini_core.rs?ref=f0018082493857e744229bb8e2718a62224f45b0", "patch": "@@ -2,7 +2,7 @@\n #![no_core]\n #![allow(dead_code)]\n \n-#[lang=\"sized\"]\n+#[lang = \"sized\"]\n pub trait Sized {}\n \n #[lang = \"unsize\"]\n@@ -11,9 +11,9 @@ pub trait Unsize<T: ?Sized> {}\n #[lang = \"coerce_unsized\"]\n pub trait CoerceUnsized<T> {}\n \n-impl<'a, 'b: 'a, T: ?Sized+Unsize<U>, U: ?Sized> CoerceUnsized<&'a U> for &'b T {}\n+impl<'a, 'b: 'a, T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<&'a U> for &'b T {}\n \n-#[lang=\"copy\"]\n+#[lang = \"copy\"]\n pub unsafe trait Copy {}\n \n unsafe impl Copy for bool {}\n@@ -30,10 +30,10 @@ unsafe impl Copy for char {}\n unsafe impl<'a, T: ?Sized> Copy for &'a T {}\n unsafe impl<T: ?Sized> Copy for *const T {}\n \n-#[lang=\"freeze\"]\n+#[lang = \"freeze\"]\n trait Freeze {}\n \n-#[lang=\"mul\"]\n+#[lang = \"mul\"]\n pub trait Mul<RHS = Self> {\n     type Output;\n \n@@ -49,7 +49,7 @@ impl Mul for u8 {\n     }\n }\n \n-#[lang=\"bitor\"]\n+#[lang = \"bitor\"]\n pub trait BitOr<RHS = Self> {\n     type Output;\n \n@@ -80,18 +80,30 @@ pub trait PartialEq<Rhs: ?Sized = Self> {\n }\n \n impl PartialEq for u8 {\n-    fn eq(&self, other: &u8) -> bool { (*self) == (*other) }\n-    fn ne(&self, other: &u8) -> bool { (*self) != (*other) }\n+    fn eq(&self, other: &u8) -> bool {\n+        (*self) == (*other)\n+    }\n+    fn ne(&self, other: &u8) -> bool {\n+        (*self) != (*other)\n+    }\n }\n \n impl PartialEq for char {\n-    fn eq(&self, other: &char) -> bool { (*self) == (*other) }\n-    fn ne(&self, other: &char) -> bool { (*self) != (*other) }\n+    fn eq(&self, other: &char) -> bool {\n+        (*self) == (*other)\n+    }\n+    fn ne(&self, other: &char) -> bool {\n+        (*self) != (*other)\n+    }\n }\n \n impl<T: ?Sized> PartialEq for *const T {\n-    fn eq(&self, other: &*const T) -> bool { *self == *other }\n-    fn ne(&self, other: &*const T) -> bool { *self != *other }\n+    fn eq(&self, other: &*const T) -> bool {\n+        *self == *other\n+    }\n+    fn ne(&self, other: &*const T) -> bool {\n+        *self != *other\n+    }\n }\n \n #[lang = \"fn_once\"]\n@@ -104,11 +116,11 @@ pub trait FnOnce<Args> {\n \n #[lang = \"fn_mut\"]\n #[rustc_paren_sugar]\n-pub trait FnMut<Args> : FnOnce<Args> {\n+pub trait FnMut<Args>: FnOnce<Args> {\n     extern \"rust-call\" fn call_mut(&mut self, args: Args) -> Self::Output;\n }\n \n-#[lang=\"panic\"]\n+#[lang = \"panic\"]\n pub fn panic(_expr_file_line_col: &(&'static str, &'static str, u32, u32)) -> ! {\n     loop {}\n }"}, {"sha": "3931ef4a3f1de2d9d5ada1499eec1d8830d2e440", "filename": "src/abi.rs", "status": "modified", "additions": 90, "deletions": 42, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/f0018082493857e744229bb8e2718a62224f45b0/src%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0018082493857e744229bb8e2718a62224f45b0/src%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fabi.rs?ref=f0018082493857e744229bb8e2718a62224f45b0", "patch": "@@ -5,26 +5,30 @@ use rustc_target::spec::abi::Abi;\n \n use crate::prelude::*;\n \n-pub fn cton_sig_from_fn_ty<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>, fn_ty: Ty<'tcx>) -> Signature {\n+pub fn cton_sig_from_fn_ty<'a, 'tcx: 'a>(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    fn_ty: Ty<'tcx>,\n+) -> Signature {\n     let sig = ty_fn_sig(tcx, fn_ty);\n     assert!(!sig.variadic, \"Variadic function are not yet supported\");\n     let (call_conv, inputs, _output): (CallConv, Vec<Ty>, Ty) = match sig.abi {\n         Abi::Rust => (CallConv::Fast, sig.inputs().to_vec(), sig.output()),\n         Abi::C => (CallConv::SystemV, sig.inputs().to_vec(), sig.output()),\n         Abi::RustCall => {\n-            println!(\"rust-call sig: {:?} inputs: {:?} output: {:?}\", sig, sig.inputs(), sig.output());\n+            println!(\n+                \"rust-call sig: {:?} inputs: {:?} output: {:?}\",\n+                sig,\n+                sig.inputs(),\n+                sig.output()\n+            );\n             assert_eq!(sig.inputs().len(), 2);\n             let extra_args = match sig.inputs().last().unwrap().sty {\n                 ty::TyTuple(ref tupled_arguments) => tupled_arguments,\n                 _ => bug!(\"argument to function with \\\"rust-call\\\" ABI is not a tuple\"),\n             };\n             let mut inputs: Vec<Ty> = vec![sig.inputs()[0]];\n             inputs.extend(extra_args.into_iter());\n-            (\n-                CallConv::Fast,\n-                inputs,\n-                sig.output(),\n-            )\n+            (CallConv::Fast, inputs, sig.output())\n         }\n         Abi::System => bug!(\"system abi should be selected elsewhere\"),\n         Abi::RustIntrinsic => (CallConv::SystemV, sig.inputs().to_vec(), sig.output()),\n@@ -50,10 +54,7 @@ pub fn cton_sig_from_fn_ty<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>, fn_ty: Ty<\n     }\n }\n \n-fn ty_fn_sig<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    ty: Ty<'tcx>\n-) -> ty::FnSig<'tcx> {\n+fn ty_fn_sig<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, ty: Ty<'tcx>) -> ty::FnSig<'tcx> {\n     let sig = match ty.sty {\n         ty::TyFnDef(..) |\n         // Shims currently have type TyFnPtr. Not sure this should remain.\n@@ -104,11 +105,16 @@ impl<'a, 'tcx: 'a> FunctionCx<'a, 'tcx> {\n         assert!(!inst.substs.needs_infer() && !inst.substs.has_param_types());\n         let fn_ty = inst.ty(self.tcx);\n         let sig = cton_sig_from_fn_ty(self.tcx, fn_ty);\n-        let def_path_based_names = ::rustc_mir::monomorphize::item::DefPathBasedNames::new(self.tcx, false, false);\n+        let def_path_based_names =\n+            ::rustc_mir::monomorphize::item::DefPathBasedNames::new(self.tcx, false, false);\n         let mut name = String::new();\n         def_path_based_names.push_instance_as_string(inst, &mut name);\n-        let func_id = self.module.declare_function(&name, Linkage::Import, &sig).unwrap();\n-        self.module.declare_func_in_func(func_id, &mut self.bcx.func)\n+        let func_id = self\n+            .module\n+            .declare_function(&name, Linkage::Import, &sig)\n+            .unwrap();\n+        self.module\n+            .declare_func_in_func(func_id, &mut self.bcx.func)\n     }\n \n     fn lib_call(\n@@ -124,8 +130,13 @@ impl<'a, 'tcx: 'a> FunctionCx<'a, 'tcx> {\n             call_conv: CallConv::SystemV,\n             argument_bytes: None,\n         };\n-        let func_id = self.module.declare_function(&name, Linkage::Import, &sig).unwrap();\n-        let func_ref = self.module.declare_func_in_func(func_id, &mut self.bcx.func);\n+        let func_id = self\n+            .module\n+            .declare_function(&name, Linkage::Import, &sig)\n+            .unwrap();\n+        let func_ref = self\n+            .module\n+            .declare_func_in_func(func_id, &mut self.bcx.func);\n         let call_inst = self.bcx.ins().call(func_ref, args);\n         if output_ty.is_none() {\n             return None;\n@@ -135,8 +146,20 @@ impl<'a, 'tcx: 'a> FunctionCx<'a, 'tcx> {\n         Some(results[0])\n     }\n \n-    pub fn easy_call(&mut self, name: &str, args: &[CValue<'tcx>], return_ty: Ty<'tcx>) -> CValue<'tcx> {\n-        let (input_tys, args): (Vec<_>, Vec<_>) = args.into_iter().map(|arg| (self.cton_type(arg.layout().ty).unwrap(), arg.load_value(self))).unzip();\n+    pub fn easy_call(\n+        &mut self,\n+        name: &str,\n+        args: &[CValue<'tcx>],\n+        return_ty: Ty<'tcx>,\n+    ) -> CValue<'tcx> {\n+        let (input_tys, args): (Vec<_>, Vec<_>) = args\n+            .into_iter()\n+            .map(|arg| {\n+                (\n+                    self.cton_type(arg.layout().ty).unwrap(),\n+                    arg.load_value(self),\n+                )\n+            }).unzip();\n         let return_layout = self.layout_of(return_ty);\n         let return_ty = if let TypeVariants::TyTuple(tup) = return_ty.sty {\n             if !tup.is_empty() {\n@@ -209,7 +232,8 @@ pub fn codegen_fn_prelude<'a, 'tcx: 'a>(fx: &mut FunctionCx<'a, 'tcx>, start_ebb\n     }).collect::<Vec<(Local, ArgKind, Ty)>>();\n \n     let ret_layout = fx.layout_of(fx.return_type());\n-    fx.local_map.insert(RETURN_PLACE, CPlace::Addr(ret_param, ret_layout));\n+    fx.local_map\n+        .insert(RETURN_PLACE, CPlace::Addr(ret_param, ret_layout));\n \n     for (local, arg_kind, ty) in func_params {\n         let layout = fx.layout_of(ty);\n@@ -284,17 +308,18 @@ pub fn codegen_call<'a, 'tcx: 'a>(\n                 for (i, _) in tupled_arguments.iter().enumerate() {\n                     args.push(pack_arg.value_field(fx, mir::Field::new(i)));\n                 }\n-            },\n+            }\n             _ => bug!(\"argument to function with \\\"rust-call\\\" ABI is not a tuple\"),\n         }\n-        println!(\"{:?} {:?}\", pack_arg.layout().ty, args.iter().map(|a|a.layout().ty).collect::<Vec<_>>());\n+        println!(\n+            \"{:?} {:?}\",\n+            pack_arg.layout().ty,\n+            args.iter().map(|a| a.layout().ty).collect::<Vec<_>>()\n+        );\n         args\n     } else {\n-        args\n-            .into_iter()\n-            .map(|arg| {\n-                trans_operand(fx, arg)\n-            })\n+        args.into_iter()\n+            .map(|arg| trans_operand(fx, arg))\n             .collect::<Vec<_>>()\n     };\n \n@@ -326,7 +351,11 @@ pub fn codegen_call<'a, 'tcx: 'a>(\n                     let dst = args[1];\n                     let count = args[2].load_value(fx);\n                     let byte_amount = fx.bcx.ins().imul(count, elem_size);\n-                    fx.easy_call(\"memmove\", &[dst, src, CValue::ByVal(byte_amount, usize_layout)], nil_ty);\n+                    fx.easy_call(\n+                        \"memmove\",\n+                        &[dst, src, CValue::ByVal(byte_amount, usize_layout)],\n+                        nil_ty,\n+                    );\n                     unimplemented!(\"copy\");\n                 }\n                 \"discriminant_value\" => {\n@@ -362,12 +391,24 @@ pub fn codegen_call<'a, 'tcx: 'a>(\n                         _ => unimplemented!(\"intrinsic {}\", intrinsic),\n                     };\n                     let res = match ret.layout().ty.sty {\n-                        TypeVariants::TyUint(_) => {\n-                            crate::base::trans_int_binop(fx, bin_op, args[0], args[1], ret.layout().ty, false, false)\n-                        }\n-                        TypeVariants::TyInt(_) => {\n-                            crate::base::trans_int_binop(fx, bin_op, args[0], args[1], ret.layout().ty, true, false)\n-                        }\n+                        TypeVariants::TyUint(_) => crate::base::trans_int_binop(\n+                            fx,\n+                            bin_op,\n+                            args[0],\n+                            args[1],\n+                            ret.layout().ty,\n+                            false,\n+                            false,\n+                        ),\n+                        TypeVariants::TyInt(_) => crate::base::trans_int_binop(\n+                            fx,\n+                            bin_op,\n+                            args[0],\n+                            args[1],\n+                            ret.layout().ty,\n+                            true,\n+                            false,\n+                        ),\n                         _ => panic!(),\n                     };\n                     ret.write_cvalue(fx, res);\n@@ -402,7 +443,10 @@ pub fn codegen_call<'a, 'tcx: 'a>(\n                     let uninit_val = uninit_place.to_cvalue(fx);\n                     ret.write_cvalue(fx, uninit_val);\n                 }\n-                _ => fx.tcx.sess.fatal(&format!(\"unsupported intrinsic {}\", intrinsic)),\n+                _ => fx\n+                    .tcx\n+                    .sess\n+                    .fatal(&format!(\"unsupported intrinsic {}\", intrinsic)),\n             }\n             if let Some((_, dest)) = *destination {\n                 let ret_ebb = fx.get_ebb(dest);\n@@ -419,13 +463,15 @@ pub fn codegen_call<'a, 'tcx: 'a>(\n         None => fx.bcx.ins().iconst(types::I64, 0),\n     };\n \n-    let call_args = Some(return_ptr).into_iter().chain(args.into_iter().map(|arg| {\n-        if fx.cton_type(arg.layout().ty).is_some() {\n-            arg.load_value(fx)\n-        } else {\n-            arg.force_stack(fx)\n-        }\n-    })).collect::<Vec<_>>();\n+    let call_args = Some(return_ptr)\n+        .into_iter()\n+        .chain(args.into_iter().map(|arg| {\n+            if fx.cton_type(arg.layout().ty).is_some() {\n+                arg.load_value(fx)\n+            } else {\n+                arg.force_stack(fx)\n+            }\n+        })).collect::<Vec<_>>();\n \n     match func {\n         CValue::Func(func, _) => {\n@@ -434,7 +480,9 @@ pub fn codegen_call<'a, 'tcx: 'a>(\n         func => {\n             let func_ty = func.layout().ty;\n             let func = func.load_value(fx);\n-            let sig = fx.bcx.import_signature(cton_sig_from_fn_ty(fx.tcx, func_ty));\n+            let sig = fx\n+                .bcx\n+                .import_signature(cton_sig_from_fn_ty(fx.tcx, func_ty));\n             fx.bcx.ins().call_indirect(sig, func, &call_args);\n         }\n     }"}, {"sha": "4970eef10d859e4e9a3d720867e3364d143f9617", "filename": "src/base.rs", "status": "modified", "additions": 235, "deletions": 77, "changes": 312, "blob_url": "https://github.com/rust-lang/rust/blob/f0018082493857e744229bb8e2718a62224f45b0/src%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0018082493857e744229bb8e2718a62224f45b0/src%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbase.rs?ref=f0018082493857e744229bb8e2718a62224f45b0", "patch": "@@ -1,6 +1,10 @@\n use crate::prelude::*;\n \n-pub fn trans_mono_item<'a, 'tcx: 'a>(cx: &mut CodegenCx<'a, 'tcx, CurrentBackend>, context: &mut Context, mono_item: MonoItem<'tcx>) {\n+pub fn trans_mono_item<'a, 'tcx: 'a>(\n+    cx: &mut CodegenCx<'a, 'tcx, CurrentBackend>,\n+    context: &mut Context,\n+    mono_item: MonoItem<'tcx>,\n+) {\n     let tcx = cx.tcx;\n \n     match mono_item {\n@@ -11,7 +15,11 @@ pub fn trans_mono_item<'a, 'tcx: 'a>(cx: &mut CodegenCx<'a, 'tcx, CurrentBackend\n             } => {\n                 let mut mir = ::std::io::Cursor::new(Vec::new());\n                 ::rustc_mir::util::write_mir_pretty(tcx, Some(def_id), &mut mir).unwrap();\n-                tcx.sess.warn(&format!(\"{:?}:\\n\\n{}\", inst, String::from_utf8_lossy(&mir.into_inner())));\n+                tcx.sess.warn(&format!(\n+                    \"{:?}:\\n\\n{}\",\n+                    inst,\n+                    String::from_utf8_lossy(&mir.into_inner())\n+                ));\n \n                 let fn_ty = inst.ty(tcx);\n                 let fn_ty = tcx.subst_and_normalize_erasing_regions(\n@@ -23,15 +31,23 @@ pub fn trans_mono_item<'a, 'tcx: 'a>(cx: &mut CodegenCx<'a, 'tcx, CurrentBackend\n \n                 let func_id = {\n                     // WARNING: keep in sync with FunctionCx::get_function_ref\n-                    let def_path_based_names = ::rustc_mir::monomorphize::item::DefPathBasedNames::new(cx.tcx, false, false);\n+                    let def_path_based_names =\n+                        ::rustc_mir::monomorphize::item::DefPathBasedNames::new(\n+                            cx.tcx, false, false,\n+                        );\n                     let mut name = String::new();\n                     def_path_based_names.push_instance_as_string(inst, &mut name);\n-                    cx.module.declare_function(&name, Linkage::Export, &sig).unwrap()\n+                    cx.module\n+                        .declare_function(&name, Linkage::Export, &sig)\n+                        .unwrap()\n                 };\n \n-                let mut f = Function::with_name_signature(ExternalName::user(0, func_id.index() as u32), sig);\n+                let mut f = Function::with_name_signature(\n+                    ExternalName::user(0, func_id.index() as u32),\n+                    sig,\n+                );\n \n-                let comments = match trans_fn(cx, &mut f, inst){\n+                let comments = match trans_fn(cx, &mut f, inst) {\n                     Ok(comments) => comments,\n                     Err(err) => {\n                         tcx.sess.err(&err);\n@@ -41,16 +57,24 @@ pub fn trans_mono_item<'a, 'tcx: 'a>(cx: &mut CodegenCx<'a, 'tcx, CurrentBackend\n \n                 let mut writer = crate::pretty_clif::CommentWriter(comments);\n                 let mut cton = String::new();\n-                ::cranelift::codegen::write::decorate_function(&mut writer, &mut cton, &f, None).unwrap();\n+                ::cranelift::codegen::write::decorate_function(&mut writer, &mut cton, &f, None)\n+                    .unwrap();\n                 tcx.sess.warn(&cton);\n \n                 let flags = settings::Flags::new(settings::builder());\n                 match ::cranelift::codegen::verify_function(&f, &flags) {\n                     Ok(_) => {}\n                     Err(err) => {\n                         tcx.sess.err(&format!(\"{:?}\", err));\n-                        let pretty_error = ::cranelift::codegen::print_errors::pretty_verifier_error(&f, None, Some(Box::new(writer)), &err);\n-                        tcx.sess.fatal(&format!(\"cretonne verify error:\\n{}\", pretty_error));\n+                        let pretty_error =\n+                            ::cranelift::codegen::print_errors::pretty_verifier_error(\n+                                &f,\n+                                None,\n+                                Some(Box::new(writer)),\n+                                &err,\n+                            );\n+                        tcx.sess\n+                            .fatal(&format!(\"cretonne verify error:\\n{}\", pretty_error));\n                     }\n                 }\n \n@@ -60,14 +84,27 @@ pub fn trans_mono_item<'a, 'tcx: 'a>(cx: &mut CodegenCx<'a, 'tcx, CurrentBackend\n \n                 context.clear();\n             }\n-            inst => cx.tcx.sess.warn(&format!(\"Unimplemented instance {:?}\", inst)),\n-        }\n-        MonoItem::Static(def_id) => cx.tcx.sess.err(&format!(\"Unimplemented static mono item {:?}\", def_id)),\n-        MonoItem::GlobalAsm(node_id) => cx.tcx.sess.err(&format!(\"Unimplemented global asm mono item {:?}\", node_id)),\n+            inst => cx\n+                .tcx\n+                .sess\n+                .warn(&format!(\"Unimplemented instance {:?}\", inst)),\n+        },\n+        MonoItem::Static(def_id) => cx\n+            .tcx\n+            .sess\n+            .err(&format!(\"Unimplemented static mono item {:?}\", def_id)),\n+        MonoItem::GlobalAsm(node_id) => cx\n+            .tcx\n+            .sess\n+            .err(&format!(\"Unimplemented global asm mono item {:?}\", node_id)),\n     }\n }\n \n-pub fn trans_fn<'a, 'tcx: 'a>(cx: &mut CodegenCx<'a, 'tcx, CurrentBackend>, f: &mut Function, instance: Instance<'tcx>) -> Result<HashMap<Inst, String>, String> {\n+pub fn trans_fn<'a, 'tcx: 'a>(\n+    cx: &mut CodegenCx<'a, 'tcx, CurrentBackend>,\n+    f: &mut Function,\n+    instance: Instance<'tcx>,\n+) -> Result<HashMap<Inst, String>, String> {\n     let mir = cx.tcx.optimized_mir(instance.def_id());\n     let mut func_ctx = FunctionBuilderContext::new();\n     let mut bcx: FunctionBuilder<Variable> = FunctionBuilder::new(f, &mut func_ctx);\n@@ -98,7 +135,9 @@ pub fn trans_fn<'a, 'tcx: 'a>(cx: &mut CodegenCx<'a, 'tcx, CurrentBackend>, f: &\n \n     crate::abi::codegen_fn_prelude(fx, start_ebb);\n \n-    fx.bcx.ins().jump(*fx.ebb_map.get(&START_BLOCK).unwrap(), &[]);\n+    fx.bcx\n+        .ins()\n+        .jump(*fx.ebb_map.get(&START_BLOCK).unwrap(), &[]);\n \n     for (bb, bb_data) in mir.basic_blocks().iter_enumerated() {\n         let ebb = fx.get_ebb(bb);\n@@ -110,7 +149,11 @@ pub fn trans_fn<'a, 'tcx: 'a>(cx: &mut CodegenCx<'a, 'tcx, CurrentBackend>, f: &\n         }\n \n         let mut terminator_head = \"\\n\".to_string();\n-        bb_data.terminator().kind.fmt_head(&mut terminator_head).unwrap();\n+        bb_data\n+            .terminator()\n+            .kind\n+            .fmt_head(&mut terminator_head)\n+            .unwrap();\n         let inst = fx.bcx.func.layout.last_inst(ebb).unwrap();\n         fx.add_comment(inst, terminator_head);\n \n@@ -122,7 +165,13 @@ pub fn trans_fn<'a, 'tcx: 'a>(cx: &mut CodegenCx<'a, 'tcx, CurrentBackend>, f: &\n             TerminatorKind::Return => {\n                 fx.bcx.ins().return_(&[]);\n             }\n-            TerminatorKind::Assert { cond, expected, msg: _, target, cleanup: _ } => {\n+            TerminatorKind::Assert {\n+                cond,\n+                expected,\n+                msg: _,\n+                target,\n+                cleanup: _,\n+            } => {\n                 let cond = trans_operand(fx, cond).load_value(fx);\n                 let target = fx.get_ebb(*target);\n                 if *expected {\n@@ -133,7 +182,12 @@ pub fn trans_fn<'a, 'tcx: 'a>(cx: &mut CodegenCx<'a, 'tcx, CurrentBackend>, f: &\n                 fx.bcx.ins().trap(TrapCode::User(!0));\n             }\n \n-            TerminatorKind::SwitchInt { discr, switch_ty: _, values, targets } => {\n+            TerminatorKind::SwitchInt {\n+                discr,\n+                switch_ty: _,\n+                values,\n+                targets,\n+            } => {\n                 let discr = trans_operand(fx, discr).load_value(fx);\n                 let mut jt_data = JumpTableData::new();\n                 for (i, value) in values.iter().enumerate() {\n@@ -145,15 +199,20 @@ pub fn trans_fn<'a, 'tcx: 'a>(cx: &mut CodegenCx<'a, 'tcx, CurrentBackend>, f: &\n                 let otherwise_ebb = fx.get_ebb(targets[targets.len() - 1]);\n                 fx.bcx.ins().jump(otherwise_ebb, &[]);\n             }\n-            TerminatorKind::Call { func, args, destination, cleanup: _ } => {\n+            TerminatorKind::Call {\n+                func,\n+                args,\n+                destination,\n+                cleanup: _,\n+            } => {\n                 crate::abi::codegen_call(fx, func, args, destination);\n             }\n             TerminatorKind::Resume | TerminatorKind::Abort | TerminatorKind::Unreachable => {\n                 fx.bcx.ins().trap(TrapCode::User(!0));\n             }\n-            TerminatorKind::Yield { .. } |\n-            TerminatorKind::FalseEdges { .. } |\n-            TerminatorKind::FalseUnwind { .. } => {\n+            TerminatorKind::Yield { .. }\n+            | TerminatorKind::FalseEdges { .. }\n+            | TerminatorKind::FalseUnwind { .. } => {\n                 bug!(\"shouldn't exist at trans {:?}\", bb_data.terminator());\n             }\n             TerminatorKind::Drop { target, .. } | TerminatorKind::DropAndReplace { target, .. } => {\n@@ -174,14 +233,21 @@ pub fn trans_fn<'a, 'tcx: 'a>(cx: &mut CodegenCx<'a, 'tcx, CurrentBackend>, f: &\n     Ok(fx.comments.clone())\n }\n \n-fn trans_stmt<'a, 'tcx: 'a>(fx: &mut FunctionCx<'a, 'tcx>, cur_ebb: Ebb, stmt: &Statement<'tcx>) -> Result<(), String> {\n+fn trans_stmt<'a, 'tcx: 'a>(\n+    fx: &mut FunctionCx<'a, 'tcx>,\n+    cur_ebb: Ebb,\n+    stmt: &Statement<'tcx>,\n+) -> Result<(), String> {\n     fx.tcx.sess.warn(&format!(\"stmt {:?}\", stmt));\n \n     let inst = fx.bcx.func.layout.last_inst(cur_ebb).unwrap();\n     fx.add_comment(inst, format!(\"{:?}\", stmt));\n \n     match &stmt.kind {\n-        StatementKind::SetDiscriminant { place, variant_index } => {\n+        StatementKind::SetDiscriminant {\n+            place,\n+            variant_index,\n+        } => {\n             let place = trans_place(fx, place);\n             let layout = place.layout();\n             if layout.for_variant(&*fx, *variant_index).abi == layout::Abi::Uninhabited {\n@@ -193,7 +259,10 @@ fn trans_stmt<'a, 'tcx: 'a>(fx: &mut FunctionCx<'a, 'tcx>, cur_ebb: Ebb, stmt: &\n                 }\n                 layout::Variants::Tagged { .. } => {\n                     let ptr = place.place_field(fx, mir::Field::new(0));\n-                    let to = layout.ty.ty_adt_def().unwrap()\n+                    let to = layout\n+                        .ty\n+                        .ty_adt_def()\n+                        .unwrap()\n                         .discriminant_for_variant(fx.tcx, *variant_index)\n                         .val;\n                     let discr = CValue::const_val(fx, ptr.layout().ty, to as u64 as i64);\n@@ -288,7 +357,7 @@ fn trans_stmt<'a, 'tcx: 'a>(fx: &mut FunctionCx<'a, 'tcx>, cur_ebb: Ebb, stmt: &\n                         UnOp::Neg => match ty.sty {\n                             TypeVariants::TyFloat(_) => fx.bcx.ins().fneg(val),\n                             _ => unimplemented!(\"un op Neg for {:?}\", ty),\n-                        }\n+                        },\n                     };\n                     lval.write_cvalue(fx, CValue::ByVal(res, layout));\n                 }\n@@ -306,64 +375,79 @@ fn trans_stmt<'a, 'tcx: 'a>(fx: &mut FunctionCx<'a, 'tcx>, cur_ebb: Ebb, stmt: &\n                     let operand = trans_operand(fx, operand);\n                     let from_ty = operand.layout().ty;\n                     match (&from_ty.sty, &to_ty.sty) {\n-                        (TypeVariants::TyRef(..), TypeVariants::TyRef(..)) |\n-                        (TypeVariants::TyRef(..), TypeVariants::TyRawPtr(..)) |\n-                        (TypeVariants::TyRawPtr(..), TypeVariants::TyRef(..)) |\n-                        (TypeVariants::TyRawPtr(..), TypeVariants::TyRawPtr(..)) => {\n+                        (TypeVariants::TyRef(..), TypeVariants::TyRef(..))\n+                        | (TypeVariants::TyRef(..), TypeVariants::TyRawPtr(..))\n+                        | (TypeVariants::TyRawPtr(..), TypeVariants::TyRef(..))\n+                        | (TypeVariants::TyRawPtr(..), TypeVariants::TyRawPtr(..)) => {\n                             lval.write_cvalue(fx, operand.unchecked_cast_to(dest_layout));\n                         }\n-                        (TypeVariants::TyChar, TypeVariants::TyUint(_)) |\n-                        (TypeVariants::TyUint(_), TypeVariants::TyInt(_)) |\n-                        (TypeVariants::TyUint(_), TypeVariants::TyUint(_)) => {\n+                        (TypeVariants::TyChar, TypeVariants::TyUint(_))\n+                        | (TypeVariants::TyUint(_), TypeVariants::TyInt(_))\n+                        | (TypeVariants::TyUint(_), TypeVariants::TyUint(_)) => {\n                             let from = operand.load_value(fx);\n                             let res = crate::common::cton_intcast(fx, from, from_ty, to_ty, false);\n                             lval.write_cvalue(fx, CValue::ByVal(res, dest_layout));\n                         }\n-                        (TypeVariants::TyInt(_), TypeVariants::TyInt(_)) |\n-                        (TypeVariants::TyInt(_), TypeVariants::TyUint(_)) => {\n+                        (TypeVariants::TyInt(_), TypeVariants::TyInt(_))\n+                        | (TypeVariants::TyInt(_), TypeVariants::TyUint(_)) => {\n                             let from = operand.load_value(fx);\n                             let res = crate::common::cton_intcast(fx, from, from_ty, to_ty, true);\n                             lval.write_cvalue(fx, CValue::ByVal(res, dest_layout));\n                         }\n                         _ => return Err(format!(\"rval misc {:?} {:?}\", operand, to_ty)),\n                     }\n-                },\n-                Rvalue::Cast(CastKind::ClosureFnPointer, operand, ty) => unimplemented!(\"rval closure_fn_ptr {:?} {:?}\", operand, ty),\n-                Rvalue::Cast(CastKind::Unsize, operand, ty) => return Err(format!(\"rval unsize {:?} {:?}\", operand, ty)),\n+                }\n+                Rvalue::Cast(CastKind::ClosureFnPointer, operand, ty) => {\n+                    unimplemented!(\"rval closure_fn_ptr {:?} {:?}\", operand, ty)\n+                }\n+                Rvalue::Cast(CastKind::Unsize, operand, ty) => {\n+                    return Err(format!(\"rval unsize {:?} {:?}\", operand, ty))\n+                }\n                 Rvalue::Discriminant(place) => {\n                     let place = trans_place(fx, place).to_cvalue(fx);\n                     let discr = trans_get_discriminant(fx, place, dest_layout);\n                     lval.write_cvalue(fx, discr);\n                 }\n-                Rvalue::Repeat(operand, times) => unimplemented!(\"rval repeat {:?} {:?}\", operand, times),\n+                Rvalue::Repeat(operand, times) => {\n+                    unimplemented!(\"rval repeat {:?} {:?}\", operand, times)\n+                }\n                 Rvalue::Len(lval) => return Err(format!(\"rval len {:?}\", lval)),\n                 Rvalue::NullaryOp(NullOp::Box, ty) => unimplemented!(\"rval box {:?}\", ty),\n                 Rvalue::NullaryOp(NullOp::SizeOf, ty) => unimplemented!(\"rval size_of {:?}\", ty),\n                 Rvalue::Aggregate(_, _) => bug!(\"shouldn't exist at trans {:?}\", rval),\n             }\n         }\n-        StatementKind::StorageLive(_) | StatementKind::StorageDead(_) | StatementKind::Nop | StatementKind::ReadForMatch(_) | StatementKind::Validate(_, _) | StatementKind::EndRegion(_) | StatementKind::UserAssertTy(_, _) => {}\n+        StatementKind::StorageLive(_)\n+        | StatementKind::StorageDead(_)\n+        | StatementKind::Nop\n+        | StatementKind::ReadForMatch(_)\n+        | StatementKind::Validate(_, _)\n+        | StatementKind::EndRegion(_)\n+        | StatementKind::UserAssertTy(_, _) => {}\n         StatementKind::InlineAsm { .. } => fx.tcx.sess.fatal(\"Inline assembly is not supported\"),\n     }\n \n     Ok(())\n }\n \n-pub fn trans_get_discriminant<'a, 'tcx: 'a>(fx: &mut FunctionCx<'a, 'tcx>, value: CValue<'tcx>, dest_layout: TyLayout<'tcx>) -> CValue<'tcx> {\n+pub fn trans_get_discriminant<'a, 'tcx: 'a>(\n+    fx: &mut FunctionCx<'a, 'tcx>,\n+    value: CValue<'tcx>,\n+    dest_layout: TyLayout<'tcx>,\n+) -> CValue<'tcx> {\n     let layout = value.layout();\n \n     if layout.abi == layout::Abi::Uninhabited {\n         fx.bcx.ins().trap(TrapCode::User(!0));\n     }\n     match layout.variants {\n         layout::Variants::Single { index } => {\n-            let discr_val = layout.ty.ty_adt_def().map_or(\n-                index as u128,\n-                |def| def.discriminant_for_variant(fx.tcx, index).val);\n+            let discr_val = layout.ty.ty_adt_def().map_or(index as u128, |def| {\n+                def.discriminant_for_variant(fx.tcx, index).val\n+            });\n             return CValue::const_val(fx, dest_layout.ty, discr_val as u64 as i64);\n         }\n-        layout::Variants::Tagged { .. } |\n-        layout::Variants::NicheFilling { .. } => {},\n+        layout::Variants::Tagged { .. } | layout::Variants::NicheFilling { .. } => {}\n     }\n \n     let discr = value.value_field(fx, mir::Field::new(0));\n@@ -374,7 +458,7 @@ pub fn trans_get_discriminant<'a, 'tcx: 'a>(fx: &mut FunctionCx<'a, 'tcx>, value\n         layout::Variants::Tagged { ref tag, .. } => {\n             let signed = match tag.value {\n                 layout::Int(_, signed) => signed,\n-                _ => false\n+                _ => false,\n             };\n             let val = cton_intcast(fx, lldiscr, discr_ty, dest_layout.ty, signed);\n             return CValue::ByVal(val, dest_layout);\n@@ -388,19 +472,35 @@ pub fn trans_get_discriminant<'a, 'tcx: 'a>(fx: &mut FunctionCx<'a, 'tcx>, value\n             let niche_llty = fx.cton_type(discr_ty).unwrap();\n             if niche_variants.start() == niche_variants.end() {\n                 let dest_cton_ty = fx.cton_type(dest_layout.ty).unwrap();\n-                let b = fx.bcx.ins().icmp_imm(IntCC::Equal, lldiscr, niche_start as u64 as i64);\n-                let if_true = fx.bcx.ins().iconst(dest_cton_ty, *niche_variants.start() as u64 as i64);\n-                let if_false = fx.bcx.ins().iconst(dest_cton_ty, dataful_variant as u64 as i64);\n+                let b = fx\n+                    .bcx\n+                    .ins()\n+                    .icmp_imm(IntCC::Equal, lldiscr, niche_start as u64 as i64);\n+                let if_true = fx\n+                    .bcx\n+                    .ins()\n+                    .iconst(dest_cton_ty, *niche_variants.start() as u64 as i64);\n+                let if_false = fx\n+                    .bcx\n+                    .ins()\n+                    .iconst(dest_cton_ty, dataful_variant as u64 as i64);\n                 let val = fx.bcx.ins().select(b, if_true, if_false);\n                 return CValue::ByVal(val, dest_layout);\n             } else {\n                 // Rebase from niche values to discriminant values.\n                 let delta = niche_start.wrapping_sub(*niche_variants.start() as u128);\n                 let delta = fx.bcx.ins().iconst(niche_llty, delta as u64 as i64);\n                 let lldiscr = fx.bcx.ins().isub(lldiscr, delta);\n-                let b = fx.bcx.ins().icmp_imm(IntCC::UnsignedLessThanOrEqual, lldiscr, *niche_variants.end() as u64 as i64);\n+                let b = fx.bcx.ins().icmp_imm(\n+                    IntCC::UnsignedLessThanOrEqual,\n+                    lldiscr,\n+                    *niche_variants.end() as u64 as i64,\n+                );\n                 let if_true = cton_intcast(fx, lldiscr, discr_ty, dest_layout.ty, false);\n-                let if_false = fx.bcx.ins().iconst(niche_llty, dataful_variant as u64 as i64);\n+                let if_false = fx\n+                    .bcx\n+                    .ins()\n+                    .iconst(niche_llty, dataful_variant as u64 as i64);\n                 let val = fx.bcx.ins().select(b, if_true, if_false);\n                 return CValue::ByVal(val, dest_layout);\n             }\n@@ -447,7 +547,13 @@ macro_rules! binop_match {\n     }}\n }\n \n-fn trans_bool_binop<'a, 'tcx: 'a>(fx: &mut FunctionCx<'a, 'tcx>, bin_op: BinOp, lhs: CValue<'tcx>, rhs: CValue<'tcx>, ty: Ty<'tcx>) -> CValue<'tcx> {\n+fn trans_bool_binop<'a, 'tcx: 'a>(\n+    fx: &mut FunctionCx<'a, 'tcx>,\n+    bin_op: BinOp,\n+    lhs: CValue<'tcx>,\n+    rhs: CValue<'tcx>,\n+    ty: Ty<'tcx>,\n+) -> CValue<'tcx> {\n     let res = binop_match! {\n         fx, bin_op, false, lhs, rhs, ty, \"bool\";\n         Add (_) bug;\n@@ -474,7 +580,15 @@ fn trans_bool_binop<'a, 'tcx: 'a>(fx: &mut FunctionCx<'a, 'tcx>, bin_op: BinOp,\n     res\n }\n \n-pub fn trans_int_binop<'a, 'tcx: 'a>(fx: &mut FunctionCx<'a, 'tcx>, bin_op: BinOp, lhs: CValue<'tcx>, rhs: CValue<'tcx>, ty: Ty<'tcx>, signed: bool, _checked: bool) -> CValue<'tcx> {\n+pub fn trans_int_binop<'a, 'tcx: 'a>(\n+    fx: &mut FunctionCx<'a, 'tcx>,\n+    bin_op: BinOp,\n+    lhs: CValue<'tcx>,\n+    rhs: CValue<'tcx>,\n+    ty: Ty<'tcx>,\n+    signed: bool,\n+    _checked: bool,\n+) -> CValue<'tcx> {\n     let res = binop_match! {\n         fx, bin_op, signed, lhs, rhs, ty, \"int/uint\";\n         Add (_) iadd;\n@@ -509,7 +623,13 @@ pub fn trans_int_binop<'a, 'tcx: 'a>(fx: &mut FunctionCx<'a, 'tcx>, bin_op: BinO\n     res\n }\n \n-fn trans_float_binop<'a, 'tcx: 'a>(fx: &mut FunctionCx<'a, 'tcx>, bin_op: BinOp, lhs: CValue<'tcx>, rhs: CValue<'tcx>, ty: Ty<'tcx>) -> CValue<'tcx> {\n+fn trans_float_binop<'a, 'tcx: 'a>(\n+    fx: &mut FunctionCx<'a, 'tcx>,\n+    bin_op: BinOp,\n+    lhs: CValue<'tcx>,\n+    rhs: CValue<'tcx>,\n+    ty: Ty<'tcx>,\n+) -> CValue<'tcx> {\n     let res = binop_match! {\n         fx, bin_op, false, lhs, rhs, ty, \"float\";\n         Add (_) fadd;\n@@ -544,7 +664,13 @@ fn trans_float_binop<'a, 'tcx: 'a>(fx: &mut FunctionCx<'a, 'tcx>, bin_op: BinOp,\n     res\n }\n \n-fn trans_char_binop<'a, 'tcx: 'a>(fx: &mut FunctionCx<'a, 'tcx>, bin_op: BinOp, lhs: CValue<'tcx>, rhs: CValue<'tcx>, ty: Ty<'tcx>) -> CValue<'tcx> {\n+fn trans_char_binop<'a, 'tcx: 'a>(\n+    fx: &mut FunctionCx<'a, 'tcx>,\n+    bin_op: BinOp,\n+    lhs: CValue<'tcx>,\n+    rhs: CValue<'tcx>,\n+    ty: Ty<'tcx>,\n+) -> CValue<'tcx> {\n     let res = binop_match! {\n         fx, bin_op, false, lhs, rhs, ty, \"char\";\n         Add (_) bug;\n@@ -571,7 +697,14 @@ fn trans_char_binop<'a, 'tcx: 'a>(fx: &mut FunctionCx<'a, 'tcx>, bin_op: BinOp,\n     res\n }\n \n-fn trans_ptr_binop<'a, 'tcx: 'a>(fx: &mut FunctionCx<'a, 'tcx>, bin_op: BinOp, lhs: CValue<'tcx>, rhs: CValue<'tcx>, ty: Ty<'tcx>, _checked: bool) -> CValue<'tcx> {\n+fn trans_ptr_binop<'a, 'tcx: 'a>(\n+    fx: &mut FunctionCx<'a, 'tcx>,\n+    bin_op: BinOp,\n+    lhs: CValue<'tcx>,\n+    rhs: CValue<'tcx>,\n+    ty: Ty<'tcx>,\n+    _checked: bool,\n+) -> CValue<'tcx> {\n     binop_match! {\n         fx, bin_op, false, lhs, rhs, ty, \"ptr\";\n         Add (_) bug;\n@@ -596,41 +729,66 @@ fn trans_ptr_binop<'a, 'tcx: 'a>(fx: &mut FunctionCx<'a, 'tcx>, bin_op: BinOp, l\n     }\n }\n \n-pub fn trans_place<'a, 'tcx: 'a>(fx: &mut FunctionCx<'a, 'tcx>, place: &Place<'tcx>) -> CPlace<'tcx> {\n+pub fn trans_place<'a, 'tcx: 'a>(\n+    fx: &mut FunctionCx<'a, 'tcx>,\n+    place: &Place<'tcx>,\n+) -> CPlace<'tcx> {\n     match place {\n         Place::Local(local) => fx.get_local_place(*local),\n         Place::Promoted(promoted) => crate::constant::trans_promoted(fx, promoted.0),\n-        Place::Static(static_) => unimplemented!(\"static place {:?} ty {:?}\", static_.def_id, static_.ty),\n+        Place::Static(static_) => {\n+            unimplemented!(\"static place {:?} ty {:?}\", static_.def_id, static_.ty)\n+        }\n         Place::Projection(projection) => {\n             let base = trans_place(fx, &projection.base);\n             match projection.elem {\n-                ProjectionElem::Deref => {\n-                    CPlace::Addr(base.to_cvalue(fx).load_value(fx), fx.layout_of(place.ty(&*fx.mir, fx.tcx).to_ty(fx.tcx)))\n-                }\n-                ProjectionElem::Field(field, _ty) => {\n-                    base.place_field(fx, field)\n-                }\n-                ProjectionElem::Index(local) => unimplemented!(\"projection index {:?} {:?}\", projection.base, local),\n-                ProjectionElem::ConstantIndex { offset, min_length: _, from_end: false } => unimplemented!(\"projection const index {:?} offset {:?} not from end\", projection.base, offset),\n-                ProjectionElem::ConstantIndex { offset, min_length: _, from_end: true } => unimplemented!(\"projection const index {:?} offset {:?} from end\", projection.base, offset),\n-                ProjectionElem::Subslice { from, to } => unimplemented!(\"projection subslice {:?} from {} to {}\", projection.base, from, to),\n-                ProjectionElem::Downcast(_adt_def, variant) => {\n-                    base.downcast_variant(fx, variant)\n+                ProjectionElem::Deref => CPlace::Addr(\n+                    base.to_cvalue(fx).load_value(fx),\n+                    fx.layout_of(place.ty(&*fx.mir, fx.tcx).to_ty(fx.tcx)),\n+                ),\n+                ProjectionElem::Field(field, _ty) => base.place_field(fx, field),\n+                ProjectionElem::Index(local) => {\n+                    unimplemented!(\"projection index {:?} {:?}\", projection.base, local)\n                 }\n+                ProjectionElem::ConstantIndex {\n+                    offset,\n+                    min_length: _,\n+                    from_end: false,\n+                } => unimplemented!(\n+                    \"projection const index {:?} offset {:?} not from end\",\n+                    projection.base,\n+                    offset\n+                ),\n+                ProjectionElem::ConstantIndex {\n+                    offset,\n+                    min_length: _,\n+                    from_end: true,\n+                } => unimplemented!(\n+                    \"projection const index {:?} offset {:?} from end\",\n+                    projection.base,\n+                    offset\n+                ),\n+                ProjectionElem::Subslice { from, to } => unimplemented!(\n+                    \"projection subslice {:?} from {} to {}\",\n+                    projection.base,\n+                    from,\n+                    to\n+                ),\n+                ProjectionElem::Downcast(_adt_def, variant) => base.downcast_variant(fx, variant),\n             }\n         }\n     }\n }\n \n-pub fn trans_operand<'a, 'tcx>(fx: &mut FunctionCx<'a, 'tcx>, operand: &Operand<'tcx>) -> CValue<'tcx> {\n+pub fn trans_operand<'a, 'tcx>(\n+    fx: &mut FunctionCx<'a, 'tcx>,\n+    operand: &Operand<'tcx>,\n+) -> CValue<'tcx> {\n     match operand {\n-        Operand::Move(place) |\n-        Operand::Copy(place) => {\n+        Operand::Move(place) | Operand::Copy(place) => {\n             let cplace = trans_place(fx, place);\n             cplace.to_cvalue(fx)\n-        },\n-        Operand::Constant(const_) => {\n-            crate::constant::trans_constant(fx, const_)\n         }\n+        Operand::Constant(const_) => crate::constant::trans_constant(fx, const_),\n     }\n }"}, {"sha": "421b2cb2d03b07df2a20d52e5c38e63771bfa62c", "filename": "src/common.rs", "status": "modified", "additions": 88, "deletions": 56, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/f0018082493857e744229bb8e2718a62224f45b0/src%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0018082493857e744229bb8e2718a62224f45b0/src%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcommon.rs?ref=f0018082493857e744229bb8e2718a62224f45b0", "patch": "@@ -2,7 +2,7 @@ use std::fmt;\n \n use rustc_target::spec::{HasTargetSpec, Target};\n \n-use cranelift_module::{Module, DataId};\n+use cranelift_module::{DataId, Module};\n \n use crate::prelude::*;\n \n@@ -21,36 +21,33 @@ impl EntityRef for Variable {\n     }\n }\n \n-pub fn cton_type_from_ty<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>, ty: Ty<'tcx>) -> Option<types::Type> {\n+pub fn cton_type_from_ty<'a, 'tcx: 'a>(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    ty: Ty<'tcx>,\n+) -> Option<types::Type> {\n     Some(match ty.sty {\n         TypeVariants::TyBool => types::I8,\n-        TypeVariants::TyUint(size) => {\n-            match size {\n-                UintTy::U8 => types::I8,\n-                UintTy::U16 => types::I16,\n-                UintTy::U32 => types::I32,\n-                UintTy::U64 => types::I64,\n-                UintTy::U128 => unimplemented!(\"u128\"),\n-                UintTy::Usize => types::I64,\n-            }\n-        }\n-        TypeVariants::TyInt(size) => {\n-            match size {\n-                IntTy::I8 => types::I8,\n-                IntTy::I16 => types::I16,\n-                IntTy::I32 => types::I32,\n-                IntTy::I64 => types::I64,\n-                IntTy::I128 => unimplemented!(\"i128\"),\n-                IntTy::Isize => types::I64,\n-            }\n-        }\n+        TypeVariants::TyUint(size) => match size {\n+            UintTy::U8 => types::I8,\n+            UintTy::U16 => types::I16,\n+            UintTy::U32 => types::I32,\n+            UintTy::U64 => types::I64,\n+            UintTy::U128 => unimplemented!(\"u128\"),\n+            UintTy::Usize => types::I64,\n+        },\n+        TypeVariants::TyInt(size) => match size {\n+            IntTy::I8 => types::I8,\n+            IntTy::I16 => types::I16,\n+            IntTy::I32 => types::I32,\n+            IntTy::I64 => types::I64,\n+            IntTy::I128 => unimplemented!(\"i128\"),\n+            IntTy::Isize => types::I64,\n+        },\n         TypeVariants::TyChar => types::I32,\n-        TypeVariants::TyFloat(size) => {\n-            match size {\n-                FloatTy::F32 => types::I32,\n-                FloatTy::F64 => types::I64,\n-            }\n-        }\n+        TypeVariants::TyFloat(size) => match size {\n+            FloatTy::F32 => types::I32,\n+            FloatTy::F64 => types::I64,\n+        },\n         TypeVariants::TyFnPtr(_) => types::I64,\n         TypeVariants::TyRawPtr(TypeAndMut { ty, mutbl: _ }) | TypeVariants::TyRef(_, ty, _) => {\n             if ty.is_sized(tcx.at(DUMMY_SP), ParamEnv::reveal_all()) {\n@@ -59,7 +56,7 @@ pub fn cton_type_from_ty<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>, ty: Ty<'tcx>\n                 return None;\n             }\n         }\n-        TypeVariants::TyParam(_)  => bug!(\"{:?}: {:?}\", ty, ty.sty),\n+        TypeVariants::TyParam(_) => bug!(\"{:?}: {:?}\", ty, ty.sty),\n         _ => return None,\n     })\n }\n@@ -68,7 +65,7 @@ fn codegen_field<'a, 'tcx: 'a>(\n     fx: &mut FunctionCx<'a, 'tcx>,\n     base: Value,\n     layout: TyLayout<'tcx>,\n-    field: mir::Field\n+    field: mir::Field,\n ) -> (Value, TyLayout<'tcx>) {\n     let field_offset = layout.fields.offset(field.index());\n     let field_ty = layout.field(&*fx, field.index());\n@@ -91,13 +88,14 @@ pub enum CValue<'tcx> {\n impl<'tcx> CValue<'tcx> {\n     pub fn layout(&self) -> TyLayout<'tcx> {\n         match *self {\n-            CValue::ByRef(_, layout) |\n-            CValue::ByVal(_, layout) |\n-            CValue::Func(_, layout) => layout\n+            CValue::ByRef(_, layout) | CValue::ByVal(_, layout) | CValue::Func(_, layout) => layout,\n         }\n     }\n \n-    pub fn force_stack<'a>(self, fx: &mut FunctionCx<'a, 'tcx>) -> Value where 'tcx: 'a {\n+    pub fn force_stack<'a>(self, fx: &mut FunctionCx<'a, 'tcx>) -> Value\n+    where\n+        'tcx: 'a,\n+    {\n         match self {\n             CValue::ByRef(value, _layout) => value,\n             CValue::ByVal(value, layout) => {\n@@ -116,16 +114,19 @@ impl<'tcx> CValue<'tcx> {\n         }\n     }\n \n-    pub fn load_value<'a>(self, fx: &mut FunctionCx<'a, 'tcx>) -> Value where 'tcx: 'a{\n+    pub fn load_value<'a>(self, fx: &mut FunctionCx<'a, 'tcx>) -> Value\n+    where\n+        'tcx: 'a,\n+    {\n         match self {\n             CValue::ByRef(addr, layout) => {\n-                let cton_ty = fx.cton_type(layout.ty).expect(&format!(\"load_value of type {:?}\", layout.ty));\n+                let cton_ty = fx\n+                    .cton_type(layout.ty)\n+                    .expect(&format!(\"load_value of type {:?}\", layout.ty));\n                 fx.bcx.ins().load(cton_ty, MemFlags::new(), addr, 0)\n             }\n             CValue::ByVal(value, _layout) => value,\n-            CValue::Func(func, _layout) => {\n-                fx.bcx.ins().func_addr(types::I64, func)\n-            }\n+            CValue::Func(func, _layout) => fx.bcx.ins().func_addr(types::I64, func),\n         }\n     }\n \n@@ -137,7 +138,10 @@ impl<'tcx> CValue<'tcx> {\n         }\n     }\n \n-    pub fn value_field<'a>(self, fx: &mut FunctionCx<'a, 'tcx>, field: mir::Field) -> CValue<'tcx> where 'tcx: 'a {\n+    pub fn value_field<'a>(self, fx: &mut FunctionCx<'a, 'tcx>, field: mir::Field) -> CValue<'tcx>\n+    where\n+        'tcx: 'a,\n+    {\n         let (base, layout) = match self {\n             CValue::ByRef(addr, layout) => (addr, layout),\n             _ => bug!(\"place_field for {:?}\", self),\n@@ -147,7 +151,14 @@ impl<'tcx> CValue<'tcx> {\n         CValue::ByRef(field_ptr, field_layout)\n     }\n \n-    pub fn const_val<'a>(fx: &mut FunctionCx<'a, 'tcx>, ty: Ty<'tcx>, const_val: i64) -> CValue<'tcx> where 'tcx: 'a {\n+    pub fn const_val<'a>(\n+        fx: &mut FunctionCx<'a, 'tcx>,\n+        ty: Ty<'tcx>,\n+        const_val: i64,\n+    ) -> CValue<'tcx>\n+    where\n+        'tcx: 'a,\n+    {\n         let cton_ty = fx.cton_type(ty).unwrap();\n         let layout = fx.layout_of(ty);\n         CValue::ByVal(fx.bcx.ins().iconst(cton_ty, const_val), layout)\n@@ -172,12 +183,15 @@ pub enum CPlace<'tcx> {\n impl<'a, 'tcx: 'a> CPlace<'tcx> {\n     pub fn layout(&self) -> TyLayout<'tcx> {\n         match *self {\n-            CPlace::Var(_, layout) |\n-            CPlace::Addr(_, layout) => layout,\n+            CPlace::Var(_, layout) | CPlace::Addr(_, layout) => layout,\n         }\n     }\n \n-    pub fn from_stack_slot(fx: &mut FunctionCx<'a, 'tcx>, stack_slot: StackSlot, ty: Ty<'tcx>) -> CPlace<'tcx> {\n+    pub fn from_stack_slot(\n+        fx: &mut FunctionCx<'a, 'tcx>,\n+        stack_slot: StackSlot,\n+        ty: Ty<'tcx>,\n+    ) -> CPlace<'tcx> {\n         let layout = fx.layout_of(ty);\n         CPlace::Addr(fx.bcx.ins().stack_addr(types::I64, stack_slot, 0), layout)\n     }\n@@ -198,23 +212,25 @@ impl<'a, 'tcx: 'a> CPlace<'tcx> {\n \n     pub fn write_cvalue(self, fx: &mut FunctionCx<'a, 'tcx>, from: CValue<'tcx>) {\n         match (&self.layout().ty.sty, &from.layout().ty.sty) {\n-            (TypeVariants::TyRef(_, t, dest_mut), TypeVariants::TyRef(_, u, src_mut)) if (\n-                if *dest_mut != ::rustc::hir::Mutability::MutImmutable && src_mut != dest_mut {\n+            (TypeVariants::TyRef(_, t, dest_mut), TypeVariants::TyRef(_, u, src_mut))\n+                if (if *dest_mut != ::rustc::hir::Mutability::MutImmutable && src_mut != dest_mut {\n                     false\n                 } else if t != u {\n                     false\n                 } else {\n                     true\n-                }\n-            ) => {\n+                }) =>\n+            {\n                 // &mut T -> &T is allowed\n                 // &'a T -> &'b T is allowed\n             }\n             _ => {\n                 assert_eq!(\n-                    self.layout().ty, from.layout().ty,\n+                    self.layout().ty,\n+                    from.layout().ty,\n                     \"Can't write value of incompatible type to place {:?} {:?}\\n\\n{:#?}\",\n-                    self.layout().ty.sty, from.layout().ty.sty,\n+                    self.layout().ty.sty,\n+                    from.layout().ty.sty,\n                     fx,\n                 );\n             }\n@@ -224,7 +240,7 @@ impl<'a, 'tcx: 'a> CPlace<'tcx> {\n             CPlace::Var(var, _) => {\n                 let data = from.load_value(fx);\n                 fx.bcx.def_var(var, data)\n-            },\n+            }\n             CPlace::Addr(addr, layout) => {\n                 let size = layout.size.bytes() as i32;\n \n@@ -235,17 +251,26 @@ impl<'a, 'tcx: 'a> CPlace<'tcx> {\n                     let from = from.expect_byref();\n                     let mut offset = 0;\n                     while size - offset >= 8 {\n-                        let byte = fx.bcx.ins().load(types::I64, MemFlags::new(), from.0, offset);\n+                        let byte = fx\n+                            .bcx\n+                            .ins()\n+                            .load(types::I64, MemFlags::new(), from.0, offset);\n                         fx.bcx.ins().store(MemFlags::new(), byte, addr, offset);\n                         offset += 8;\n                     }\n                     while size - offset >= 4 {\n-                        let byte = fx.bcx.ins().load(types::I32, MemFlags::new(), from.0, offset);\n+                        let byte = fx\n+                            .bcx\n+                            .ins()\n+                            .load(types::I32, MemFlags::new(), from.0, offset);\n                         fx.bcx.ins().store(MemFlags::new(), byte, addr, offset);\n                         offset += 4;\n                     }\n                     while offset < size {\n-                        let byte = fx.bcx.ins().load(types::I8, MemFlags::new(), from.0, offset);\n+                        let byte = fx\n+                            .bcx\n+                            .ins()\n+                            .load(types::I8, MemFlags::new(), from.0, offset);\n                         fx.bcx.ins().store(MemFlags::new(), byte, addr, offset);\n                         offset += 1;\n                     }\n@@ -275,7 +300,13 @@ impl<'a, 'tcx: 'a> CPlace<'tcx> {\n     }\n }\n \n-pub fn cton_intcast<'a, 'tcx: 'a>(fx: &mut FunctionCx<'a, 'tcx>, val: Value, from: Ty<'tcx>, to: Ty<'tcx>, signed: bool) -> Value {\n+pub fn cton_intcast<'a, 'tcx: 'a>(\n+    fx: &mut FunctionCx<'a, 'tcx>,\n+    val: Value,\n+    from: Ty<'tcx>,\n+    to: Ty<'tcx>,\n+    signed: bool,\n+) -> Value {\n     let from = fx.cton_type(from).unwrap();\n     let to = fx.cton_type(to).unwrap();\n     if from == to {\n@@ -352,7 +383,8 @@ impl<'a, 'tcx> HasTargetSpec for &'a FunctionCx<'a, 'tcx> {\n \n impl<'a, 'tcx: 'a> FunctionCx<'a, 'tcx> {\n     pub fn monomorphize<T>(&self, value: &T) -> T\n-        where T: TypeFoldable<'tcx>\n+    where\n+        T: TypeFoldable<'tcx>,\n     {\n         self.tcx.subst_and_normalize_erasing_regions(\n             self.param_substs,"}, {"sha": "6136f5024fbf378abce7f9e70746db1675ecb49d", "filename": "src/constant.rs", "status": "modified", "additions": 55, "deletions": 23, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/f0018082493857e744229bb8e2718a62224f45b0/src%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0018082493857e744229bb8e2718a62224f45b0/src%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconstant.rs?ref=f0018082493857e744229bb8e2718a62224f45b0", "patch": "@@ -1,29 +1,37 @@\n+use cranelift_module::*;\n use crate::prelude::*;\n+use rustc::mir::interpret::{read_target_uint, AllocId, ConstValue, GlobalId};\n use rustc::ty::Const;\n-use rustc::mir::interpret::{ConstValue, GlobalId, AllocId, read_target_uint};\n use rustc_mir::interpret::{CompileTimeEvaluator, Memory, MemoryKind};\n-use cranelift_module::*;\n \n-pub fn trans_promoted<'a, 'tcx: 'a>(fx: &mut FunctionCx<'a, 'tcx>, promoted: Promoted) -> CPlace<'tcx> {\n+pub fn trans_promoted<'a, 'tcx: 'a>(\n+    fx: &mut FunctionCx<'a, 'tcx>,\n+    promoted: Promoted,\n+) -> CPlace<'tcx> {\n     let const_ = fx\n         .tcx\n         .const_eval(ParamEnv::reveal_all().and(GlobalId {\n             instance: fx.instance,\n             promoted: Some(promoted),\n-        }))\n-        .unwrap();\n+        })).unwrap();\n \n     let const_ = force_eval_const(fx, const_);\n     trans_const_place(fx, const_)\n }\n \n-pub fn trans_constant<'a, 'tcx: 'a>(fx: &mut FunctionCx<'a, 'tcx>, constant: &Constant<'tcx>) -> CValue<'tcx> {\n+pub fn trans_constant<'a, 'tcx: 'a>(\n+    fx: &mut FunctionCx<'a, 'tcx>,\n+    constant: &Constant<'tcx>,\n+) -> CValue<'tcx> {\n     let const_ = fx.monomorphize(&constant.literal);\n     let const_ = force_eval_const(fx, const_);\n     trans_const_value(fx, const_)\n }\n \n-fn force_eval_const<'a, 'tcx: 'a>(fx: &FunctionCx<'a, 'tcx>, const_: &'tcx Const<'tcx>) -> &'tcx Const<'tcx> {\n+fn force_eval_const<'a, 'tcx: 'a>(\n+    fx: &FunctionCx<'a, 'tcx>,\n+    const_: &'tcx Const<'tcx>,\n+) -> &'tcx Const<'tcx> {\n     match const_.val {\n         ConstValue::Unevaluated(def_id, ref substs) => {\n             let param_env = ParamEnv::reveal_all();\n@@ -33,12 +41,15 @@ fn force_eval_const<'a, 'tcx: 'a>(fx: &FunctionCx<'a, 'tcx>, const_: &'tcx Const\n                 promoted: None,\n             };\n             fx.tcx.const_eval(param_env.and(cid)).unwrap()\n-        },\n+        }\n         _ => const_,\n     }\n }\n \n-fn trans_const_value<'a, 'tcx: 'a>(fx: &mut FunctionCx<'a, 'tcx>, const_: &'tcx Const<'tcx>) -> CValue<'tcx> {\n+fn trans_const_value<'a, 'tcx: 'a>(\n+    fx: &mut FunctionCx<'a, 'tcx>,\n+    const_: &'tcx Const<'tcx>,\n+) -> CValue<'tcx> {\n     let ty = fx.monomorphize(&const_.ty);\n     let layout = fx.layout_of(ty);\n     match ty.sty {\n@@ -58,13 +69,14 @@ fn trans_const_value<'a, 'tcx: 'a>(fx: &mut FunctionCx<'a, 'tcx>, const_: &'tcx\n             let func_ref = fx.get_function_ref(Instance::new(def_id, substs));\n             CValue::Func(func_ref, layout)\n         }\n-        _ => {\n-            trans_const_place(fx, const_).to_cvalue(fx)\n-        }\n+        _ => trans_const_place(fx, const_).to_cvalue(fx),\n     }\n }\n \n-fn trans_const_place<'a, 'tcx: 'a>(fx: &mut FunctionCx<'a, 'tcx>, const_: &'tcx Const<'tcx>) -> CPlace<'tcx> {\n+fn trans_const_place<'a, 'tcx: 'a>(\n+    fx: &mut FunctionCx<'a, 'tcx>,\n+    const_: &'tcx Const<'tcx>,\n+) -> CPlace<'tcx> {\n     let ty = fx.monomorphize(&const_.ty);\n     let layout = fx.layout_of(ty);\n     if true {\n@@ -75,7 +87,9 @@ fn trans_const_place<'a, 'tcx: 'a>(fx: &mut FunctionCx<'a, 'tcx>, const_: &'tcx\n     let mut memory = Memory::<CompileTimeEvaluator>::new(fx.tcx.at(DUMMY_SP), ());\n     let alloc = fx.tcx.const_value_to_allocation(const_);\n     //println!(\"const value: {:?} allocation: {:?}\", value, alloc);\n-    let alloc_id = memory.allocate_value(alloc.clone(), MemoryKind::Stack).unwrap();\n+    let alloc_id = memory\n+        .allocate_value(alloc.clone(), MemoryKind::Stack)\n+        .unwrap();\n     let data_id = get_global_for_alloc_id(fx, &memory, alloc_id);\n     let local_data_id = fx.module.declare_data_in_func(data_id, &mut fx.bcx.func);\n     // TODO: does global_value return a ptr of a val?\n@@ -84,22 +98,31 @@ fn trans_const_place<'a, 'tcx: 'a>(fx: &mut FunctionCx<'a, 'tcx>, const_: &'tcx\n }\n \n // If ret.1 is true, then the global didn't exist before\n-fn define_global_for_alloc_id(fx: &mut FunctionCx, alloc_id: AllocId, todo: &mut HashMap<AllocId, DataId>) -> (DataId, bool) {\n+fn define_global_for_alloc_id(\n+    fx: &mut FunctionCx,\n+    alloc_id: AllocId,\n+    todo: &mut HashMap<AllocId, DataId>,\n+) -> (DataId, bool) {\n     use std::collections::hash_map::Entry;\n     match fx.constants.entry(alloc_id) {\n-        Entry::Occupied(mut occ) => {\n-            (*occ.get_mut(), false)\n-        }\n+        Entry::Occupied(mut occ) => (*occ.get_mut(), false),\n         Entry::Vacant(vac) => {\n-            let data_id = fx.module.declare_data(&alloc_id.0.to_string(), Linkage::Local, false).unwrap();\n+            let data_id = fx\n+                .module\n+                .declare_data(&alloc_id.0.to_string(), Linkage::Local, false)\n+                .unwrap();\n             todo.insert(alloc_id, data_id);\n             vac.insert(data_id);\n             (data_id, true)\n         }\n     }\n }\n \n-fn get_global_for_alloc_id(fx: &mut FunctionCx, memory: &Memory<CompileTimeEvaluator>, alloc_id: AllocId) -> DataId {\n+fn get_global_for_alloc_id(\n+    fx: &mut FunctionCx,\n+    memory: &Memory<CompileTimeEvaluator>,\n+    alloc_id: AllocId,\n+) -> DataId {\n     if let Some(data_id) = fx.constants.get(&alloc_id) {\n         return *data_id;\n     }\n@@ -108,13 +131,22 @@ fn get_global_for_alloc_id(fx: &mut FunctionCx, memory: &Memory<CompileTimeEvalu\n     let mut done = HashSet::new();\n     define_global_for_alloc_id(fx, alloc_id, &mut todo);\n \n-    while let Some((alloc_id, data_id)) = { let next = todo.drain().next(); next } {\n-        println!(\"cur: {:?}:{:?} todo: {:?} done: {:?}\", alloc_id, data_id, todo, done);\n+    while let Some((alloc_id, data_id)) = {\n+        let next = todo.drain().next();\n+        next\n+    } {\n+        println!(\n+            \"cur: {:?}:{:?} todo: {:?} done: {:?}\",\n+            alloc_id, data_id, todo, done\n+        );\n \n         let alloc = memory.get(alloc_id).unwrap();\n         let mut data_ctx = DataContext::new();\n \n-        data_ctx.define(alloc.bytes.to_vec().into_boxed_slice(), Writability::Readonly);\n+        data_ctx.define(\n+            alloc.bytes.to_vec().into_boxed_slice(),\n+            Writability::Readonly,\n+        );\n \n         for &(offset, reloc) in alloc.relocations.iter() {\n             let data_id = define_global_for_alloc_id(fx, reloc, &mut todo).0;"}, {"sha": "0995639e375067b87786314f5af5942720e57a34", "filename": "src/lib.rs", "status": "modified", "additions": 96, "deletions": 79, "changes": 175, "blob_url": "https://github.com/rust-lang/rust/blob/f0018082493857e744229bb8e2718a62224f45b0/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0018082493857e744229bb8e2718a62224f45b0/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=f0018082493857e744229bb8e2718a62224f45b0", "patch": "@@ -4,82 +4,81 @@\n extern crate syntax;\n #[macro_use]\n extern crate rustc;\n-extern crate rustc_mir;\n extern crate rustc_codegen_utils;\n-extern crate rustc_target;\n extern crate rustc_incremental;\n+extern crate rustc_mir;\n+extern crate rustc_target;\n #[macro_use]\n extern crate rustc_data_structures;\n \n extern crate ar;\n extern crate faerie;\n //extern crate goblin;\n-extern crate target_lexicon;\n extern crate cranelift;\n+extern crate cranelift_faerie;\n extern crate cranelift_module;\n extern crate cranelift_simplejit;\n-extern crate cranelift_faerie;\n+extern crate target_lexicon;\n \n use std::any::Any;\n-use std::sync::{mpsc, Arc};\n-use std::path::Path;\n use std::fs::File;\n+use std::path::Path;\n+use std::sync::{mpsc, Arc};\n \n-use syntax::symbol::Symbol;\n+use rustc::dep_graph::DepGraph;\n+use rustc::middle::cstore::MetadataLoader;\n use rustc::session::{\n+    config::{CrateType, OutputFilenames},\n     CompileIncomplete,\n-    config::{\n-        CrateType,\n-        OutputFilenames,\n-    },\n };\n-use rustc::middle::cstore::MetadataLoader;\n-use rustc::dep_graph::DepGraph;\n use rustc::ty::query::Providers;\n use rustc_codegen_utils::codegen_backend::CodegenBackend;\n-use rustc_codegen_utils::link::{out_filename, build_link_meta};\n+use rustc_codegen_utils::link::{build_link_meta, out_filename};\n use rustc_data_structures::owning_ref::{self, OwningRef};\n+use syntax::symbol::Symbol;\n \n use cranelift::codegen::settings;\n use cranelift_faerie::*;\n \n mod abi;\n mod base;\n-mod constant;\n mod common;\n+mod constant;\n mod pretty_clif;\n \n mod prelude {\n     pub use std::any::Any;\n     pub use std::collections::{HashMap, HashSet};\n \n-    pub use syntax::codemap::DUMMY_SP;\n-    pub use syntax::ast::{IntTy, UintTy, FloatTy};\n     pub use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n     pub use rustc::mir;\n-    pub use rustc::mir::*;\n     pub use rustc::mir::interpret::AllocId;\n+    pub use rustc::mir::*;\n     pub use rustc::session::Session;\n-    pub use rustc::ty::layout::{self, LayoutOf, TyLayout, Size};\n+    pub use rustc::ty::layout::{self, LayoutOf, Size, TyLayout};\n     pub use rustc::ty::{\n         self, subst::Substs, FnSig, Instance, InstanceDef, ParamEnv, PolyFnSig, Ty, TyCtxt,\n-        TypeFoldable, TypeVariants, TypeAndMut,\n+        TypeAndMut, TypeFoldable, TypeVariants,\n     };\n     pub use rustc_data_structures::{indexed_vec::Idx, sync::Lrc};\n-    pub use rustc_mir::monomorphize::{MonoItem, collector};\n+    pub use rustc_mir::monomorphize::{collector, MonoItem};\n+    pub use syntax::ast::{FloatTy, IntTy, UintTy};\n+    pub use syntax::codemap::DUMMY_SP;\n \n     pub use cranelift::codegen::ir::{\n-        condcodes::IntCC, function::Function, ExternalName, FuncRef, StackSlot, Inst\n+        condcodes::IntCC, function::Function, ExternalName, FuncRef, Inst, StackSlot,\n     };\n     pub use cranelift::codegen::Context;\n     pub use cranelift::prelude::*;\n-    pub use cranelift_module::{Module, Backend, DataContext, FuncId, DataId, Linkage, Writability};\n-    pub use cranelift_simplejit::{SimpleJITBuilder, SimpleJITBackend};\n+    pub use cranelift_module::{\n+        Backend, DataContext, DataId, FuncId, Linkage, Module, Writability,\n+    };\n+    pub use cranelift_simplejit::{SimpleJITBackend, SimpleJITBuilder};\n \n     pub use crate::abi::*;\n+    pub use crate::base::{trans_operand, trans_place};\n     pub use crate::common::Variable;\n     pub use crate::common::*;\n-    pub use crate::base::{trans_operand, trans_place};\n \n     pub use crate::CodegenCx;\n }\n@@ -95,14 +94,18 @@ pub struct CodegenCx<'a, 'tcx: 'a, B: Backend + 'a> {\n struct CraneliftMetadataLoader;\n \n impl MetadataLoader for CraneliftMetadataLoader {\n-    fn get_rlib_metadata(&self, _target: &rustc_target::spec::Target, path: &Path) -> Result<owning_ref::ErasedBoxRef<[u8]>, String> {\n-        let mut archive = ar::Archive::new(File::open(path).map_err(|e|format!(\"{:?}\", e))?);\n+    fn get_rlib_metadata(\n+        &self,\n+        _target: &rustc_target::spec::Target,\n+        path: &Path,\n+    ) -> Result<owning_ref::ErasedBoxRef<[u8]>, String> {\n+        let mut archive = ar::Archive::new(File::open(path).map_err(|e| format!(\"{:?}\", e))?);\n         // Iterate over all entries in the archive:\n         while let Some(entry_result) = archive.next_entry() {\n-            let mut entry = entry_result.map_err(|e|format!(\"{:?}\", e))?;\n+            let mut entry = entry_result.map_err(|e| format!(\"{:?}\", e))?;\n             if entry.header().identifier() == b\".rustc.clif_metadata\" {\n                 let mut buf = Vec::new();\n-                ::std::io::copy(&mut entry, &mut buf).map_err(|e|format!(\"{:?}\", e))?;\n+                ::std::io::copy(&mut entry, &mut buf).map_err(|e| format!(\"{:?}\", e))?;\n                 let buf: OwningRef<Vec<u8>, [u8]> = OwningRef::new(buf).into();\n                 return Ok(rustc_erase_owner!(buf.map_owner_box()));\n             }\n@@ -112,7 +115,11 @@ impl MetadataLoader for CraneliftMetadataLoader {\n         //self.get_dylib_metadata(target, path)\n     }\n \n-    fn get_dylib_metadata(&self, _target: &rustc_target::spec::Target, _path: &Path) -> Result<owning_ref::ErasedBoxRef<[u8]>, String> {\n+    fn get_dylib_metadata(\n+        &self,\n+        _target: &rustc_target::spec::Target,\n+        _path: &Path,\n+    ) -> Result<owning_ref::ErasedBoxRef<[u8]>, String> {\n         //use goblin::Object;\n \n         //let buffer = ::std::fs::read(path).map_err(|e|format!(\"{:?}\", e))?;\n@@ -149,13 +156,15 @@ impl CodegenBackend for CraneliftCodegenBackend {\n     fn init(&self, sess: &Session) {\n         for cty in sess.opts.crate_types.iter() {\n             match *cty {\n-                CrateType::CrateTypeRlib | CrateType::CrateTypeDylib |\n-                CrateType::CrateTypeExecutable => {},\n+                CrateType::CrateTypeRlib\n+                | CrateType::CrateTypeDylib\n+                | CrateType::CrateTypeExecutable => {}\n                 _ => {\n-                    sess.parse_sess.span_diagnostic.warn(\n-                        &format!(\"LLVM unsupported, so output type {} is not supported\", cty)\n-                    );\n-                },\n+                    sess.parse_sess.span_diagnostic.warn(&format!(\n+                        \"LLVM unsupported, so output type {} is not supported\",\n+                        cty\n+                    ));\n+                }\n             }\n         }\n     }\n@@ -167,9 +176,7 @@ impl CodegenBackend for CraneliftCodegenBackend {\n     fn provide(&self, providers: &mut Providers) {\n         rustc_codegen_utils::symbol_names::provide(providers);\n \n-        providers.target_features_whitelist = |_tcx, _cnum| {\n-            Lrc::new(Default::default())\n-        };\n+        providers.target_features_whitelist = |_tcx, _cnum| Lrc::new(Default::default());\n         providers.is_reachable_non_generic = |_tcx, _defid| true;\n         providers.exported_symbols = |_tcx, _crate| Arc::new(Vec::new());\n     }\n@@ -180,32 +187,30 @@ impl CodegenBackend for CraneliftCodegenBackend {\n     fn codegen_crate<'a, 'tcx>(\n         &self,\n         tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-        _rx: mpsc::Receiver<Box<Any + Send>>\n+        _rx: mpsc::Receiver<Box<Any + Send>>,\n     ) -> Box<Any> {\n         use rustc_mir::monomorphize::item::MonoItem;\n \n         rustc_codegen_utils::check_for_rustc_errors_attr(tcx);\n         rustc_codegen_utils::symbol_names_test::report_symbol_names(tcx);\n         rustc_incremental::assert_dep_graph(tcx);\n         rustc_incremental::assert_module_sources::assert_module_sources(tcx);\n-        rustc_mir::monomorphize::assert_symbols_are_distinct(tcx,\n-            collector::collect_crate_mono_items(\n-                tcx,\n-                collector::MonoItemCollectionMode::Eager\n-            ).0.iter()\n+        rustc_mir::monomorphize::assert_symbols_are_distinct(\n+            tcx,\n+            collector::collect_crate_mono_items(tcx, collector::MonoItemCollectionMode::Eager)\n+                .0\n+                .iter(),\n         );\n         //::rustc::middle::dependency_format::calculate(tcx);\n         let _ = tcx.link_args(LOCAL_CRATE);\n         let _ = tcx.native_libraries(LOCAL_CRATE);\n         for mono_item in\n-            collector::collect_crate_mono_items(\n-                tcx,\n-                collector::MonoItemCollectionMode::Eager\n-            ).0 {\n+            collector::collect_crate_mono_items(tcx, collector::MonoItemCollectionMode::Eager).0\n+        {\n             match mono_item {\n                 MonoItem::Fn(inst) => {\n                     let def_id = inst.def_id();\n-                    if def_id.is_local()  {\n+                    if def_id.is_local() {\n                         let _ = inst.def.is_inline(tcx);\n                         let _ = tcx.codegen_fn_attrs(def_id);\n                     }\n@@ -221,7 +226,9 @@ impl CodegenBackend for CraneliftCodegenBackend {\n         let mut flags_builder = settings::builder();\n         flags_builder.enable(\"is_pic\").unwrap();\n         let flags = settings::Flags::new(flags_builder);\n-        let isa = cranelift::codegen::isa::lookup(target_lexicon::Triple::host()).unwrap().finish(flags);\n+        let isa = cranelift::codegen::isa::lookup(target_lexicon::Triple::host())\n+            .unwrap()\n+            .finish(flags);\n         let mut module: Module<SimpleJITBackend> = Module::new(SimpleJITBuilder::new());\n         let mut context = Context::new();\n \n@@ -233,10 +240,8 @@ impl CodegenBackend for CraneliftCodegenBackend {\n             };\n \n             for mono_item in\n-                collector::collect_crate_mono_items(\n-                    tcx,\n-                    collector::MonoItemCollectionMode::Eager\n-                ).0 {\n+                collector::collect_crate_mono_items(tcx, collector::MonoItemCollectionMode::Eager).0\n+            {\n                 base::trans_mono_item(&mut cx, &mut context, mono_item)\n             }\n         }\n@@ -249,11 +254,8 @@ impl CodegenBackend for CraneliftCodegenBackend {\n             tcx.sess.warn(\"Finalized everything\");\n \n             for mono_item in\n-                collector::collect_crate_mono_items(\n-                    tcx,\n-                    collector::MonoItemCollectionMode::Eager\n-                ).0 {\n-\n+                collector::collect_crate_mono_items(tcx, collector::MonoItemCollectionMode::Eager).0\n+            {\n                 let inst = match mono_item {\n                     MonoItem::Fn(inst) => inst,\n                     _ => continue,\n@@ -266,17 +268,21 @@ impl CodegenBackend for CraneliftCodegenBackend {\n \n                 let fn_ty = inst.ty(tcx);\n                 let sig = cton_sig_from_fn_ty(tcx, fn_ty);\n-                let def_path_based_names = ::rustc_mir::monomorphize::item::DefPathBasedNames::new(tcx, false, false);\n+                let def_path_based_names =\n+                    ::rustc_mir::monomorphize::item::DefPathBasedNames::new(tcx, false, false);\n                 let mut name = String::new();\n                 def_path_based_names.push_instance_as_string(inst, &mut name);\n-                let func_id = module.declare_function(&name, Linkage::Import, &sig).unwrap();\n+                let func_id = module\n+                    .declare_function(&name, Linkage::Import, &sig)\n+                    .unwrap();\n \n                 let finalized_function: *const u8 = module.finalize_function(func_id);\n                 /*let f: extern \"C\" fn(&mut u32) = unsafe { ::std::mem::transmute(finalized_function) };\n                 let mut res = 0u32;\n                 f(&mut res);\n                 tcx.sess.warn(&format!(\"ret_42 returned {}\", res));*/\n-                let f: extern \"C\" fn(&mut bool, &u8, bool) = unsafe { ::std::mem::transmute(finalized_function) };\n+                let f: extern \"C\" fn(&mut bool, &u8, bool) =\n+                    unsafe { ::std::mem::transmute(finalized_function) };\n                 let mut res = false;\n                 f(&mut res, &3, false);\n                 tcx.sess.warn(&format!(\"option_unwrap_or returned {}\", res));\n@@ -290,9 +296,8 @@ impl CodegenBackend for CraneliftCodegenBackend {\n                 isa,\n                 \"some_file.o\".to_string(),\n                 FaerieTrapCollection::Disabled,\n-                FaerieBuilder::default_libcall_names()\n-            )\n-                .unwrap()\n+                FaerieBuilder::default_libcall_names(),\n+            ).unwrap(),\n         );\n \n         Box::new(OngoingCodegen {\n@@ -309,30 +314,42 @@ impl CodegenBackend for CraneliftCodegenBackend {\n         _dep_graph: &DepGraph,\n         outputs: &OutputFilenames,\n     ) -> Result<(), CompileIncomplete> {\n-        let ongoing_codegen = *ongoing_codegen.downcast::<OngoingCodegen>()\n+        let ongoing_codegen = *ongoing_codegen\n+            .downcast::<OngoingCodegen>()\n             .expect(\"Expected CraneliftCodegenBackend's OngoingCodegen, found Box<Any>\");\n \n         let mut artifact = ongoing_codegen.product.artifact;\n         let metadata = ongoing_codegen.metadata;\n \n-        artifact.declare_with(\n-            \".rustc.clif_metadata\",\n-            faerie::artifact::Decl::Data {\n-                global: true,\n-                writeable: false\n-            },\n-            metadata.clone(),\n-        ).unwrap();\n+        artifact\n+            .declare_with(\n+                \".rustc.clif_metadata\",\n+                faerie::artifact::Decl::Data {\n+                    global: true,\n+                    writeable: false,\n+                },\n+                metadata.clone(),\n+            ).unwrap();\n \n         for &crate_type in sess.opts.crate_types.iter() {\n-            if crate_type != CrateType::CrateTypeRlib /*&& crate_type != CrateType::CrateTypeDylib*/ {\n+            if crate_type != CrateType::CrateTypeRlib\n+            /*&& crate_type != CrateType::CrateTypeDylib*/\n+            {\n                 sess.fatal(&format!(\"Unsupported crate type: {:?}\", crate_type));\n             }\n-            let output_name =\n-                out_filename(sess, crate_type, &outputs, &ongoing_codegen.crate_name.as_str());\n+            let output_name = out_filename(\n+                sess,\n+                crate_type,\n+                &outputs,\n+                &ongoing_codegen.crate_name.as_str(),\n+            );\n             let file = File::create(&output_name).unwrap();\n             let mut builder = ar::Builder::new(file);\n-            builder.append(&ar::Header::new(b\".rustc.clif_metadata\".to_vec(), metadata.len() as u64), ::std::io::Cursor::new(metadata.clone())).unwrap();\n+            builder\n+                .append(\n+                    &ar::Header::new(b\".rustc.clif_metadata\".to_vec(), metadata.len() as u64),\n+                    ::std::io::Cursor::new(metadata.clone()),\n+                ).unwrap();\n             //artifact.write(file).unwrap();\n         }\n "}]}