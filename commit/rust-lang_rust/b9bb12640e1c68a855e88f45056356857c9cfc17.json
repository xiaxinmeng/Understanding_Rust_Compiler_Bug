{"sha": "b9bb12640e1c68a855e88f45056356857c9cfc17", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI5YmIxMjY0MGUxYzY4YTg1NWU4OGY0NTA1NjM1Njg1N2M5Y2ZjMTc=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2020-04-08T16:37:22Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-04-08T16:37:22Z"}, "message": "Rollup merge of #70850 - ssomers:btreemap_first_last, r=Amanieu\n\nBTreeMap first last proposal tweaks\n\nClean-up and following up on a request in #62924.\n\nTrying the reviewer of the original code #65637...\nr? @scottmcm", "tree": {"sha": "011513dc8c1970b60d1251f05a491622ef5bbba2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/011513dc8c1970b60d1251f05a491622ef5bbba2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b9bb12640e1c68a855e88f45056356857c9cfc17", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJejf3CCRBK7hj4Ov3rIwAAdHIIAFRPuHsa0m+fdUxmdzMOhTOa\n/7qEGcRjdNqCMQmVopKeSqZHLKAwjYaUQSpo/YHbIsNAS5aT6yL3bGxUqdQqGxts\nM56iMljiFYyO9Ukrphuyb9D69opMqKbIigMiKuenwMemKyXhJZr9EYkBqOKRpxRj\nQ8LBjzpYHZ4mk1ca1zeZeomAmmlMSBo/osDvTLihB0A/rVbm05shoqAS/khUcxFR\nyzDjy34wClCxOUdrDLzFbOCGqp50rg9VlBzwKuKSrH6Df7I2h94fa9tqEHHi+DDt\nUikbaFYMybU5tBn5ufMP3ztc3cEa40qeus5MY5Is4PYl4xgb84L3nEY22mJ7BzA=\n=WR8N\n-----END PGP SIGNATURE-----\n", "payload": "tree 011513dc8c1970b60d1251f05a491622ef5bbba2\nparent 54abd4ffcfe44f5d7223ee701360eff3e944e4c9\nparent 8212b9772e486ae272639fb22ee3b6e7f9047d3f\nauthor Dylan DPC <dylan.dpc@gmail.com> 1586363842 +0200\ncommitter GitHub <noreply@github.com> 1586363842 +0200\n\nRollup merge of #70850 - ssomers:btreemap_first_last, r=Amanieu\n\nBTreeMap first last proposal tweaks\n\nClean-up and following up on a request in #62924.\n\nTrying the reviewer of the original code #65637...\nr? @scottmcm\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b9bb12640e1c68a855e88f45056356857c9cfc17", "html_url": "https://github.com/rust-lang/rust/commit/b9bb12640e1c68a855e88f45056356857c9cfc17", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b9bb12640e1c68a855e88f45056356857c9cfc17/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "54abd4ffcfe44f5d7223ee701360eff3e944e4c9", "url": "https://api.github.com/repos/rust-lang/rust/commits/54abd4ffcfe44f5d7223ee701360eff3e944e4c9", "html_url": "https://github.com/rust-lang/rust/commit/54abd4ffcfe44f5d7223ee701360eff3e944e4c9"}, {"sha": "8212b9772e486ae272639fb22ee3b6e7f9047d3f", "url": "https://api.github.com/repos/rust-lang/rust/commits/8212b9772e486ae272639fb22ee3b6e7f9047d3f", "html_url": "https://github.com/rust-lang/rust/commit/8212b9772e486ae272639fb22ee3b6e7f9047d3f"}], "stats": {"total": 124, "additions": 76, "deletions": 48}, "files": [{"sha": "a1e59b2e6afb33220cfb22c4938339725ee2f080", "filename": "src/liballoc/collections/btree/map.rs", "status": "modified", "additions": 76, "deletions": 48, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/b9bb12640e1c68a855e88f45056356857c9cfc17/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9bb12640e1c68a855e88f45056356857c9cfc17/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs?ref=b9bb12640e1c68a855e88f45056356857c9cfc17", "patch": "@@ -653,11 +653,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// assert_eq!(map.first_key_value(), Some((&1, &\"b\")));\n     /// ```\n     #[unstable(feature = \"map_first_last\", issue = \"62924\")]\n-    pub fn first_key_value<T: ?Sized>(&self) -> Option<(&K, &V)>\n-    where\n-        T: Ord,\n-        K: Borrow<T>,\n-    {\n+    pub fn first_key_value(&self) -> Option<(&K, &V)> {\n         let front = self.root.as_ref()?.as_ref().first_leaf_edge();\n         front.right_kv().ok().map(Handle::into_kv)\n     }\n@@ -667,36 +663,54 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     ///\n     /// # Examples\n     ///\n-    /// Contrived way to `clear` a map:\n-    ///\n     /// ```\n     /// #![feature(map_first_last)]\n     /// use std::collections::BTreeMap;\n     ///\n     /// let mut map = BTreeMap::new();\n     /// map.insert(1, \"a\");\n     /// map.insert(2, \"b\");\n-    /// while let Some(entry) = map.first_entry() {\n-    ///     let (key, val) = entry.remove_entry();\n-    ///     assert!(!map.contains_key(&key));\n+    /// if let Some(mut entry) = map.first_entry() {\n+    ///     if *entry.key() > 0 {\n+    ///         entry.insert(\"first\");\n+    ///     }\n     /// }\n+    /// assert_eq!(*map.get(&1).unwrap(), \"first\");\n+    /// assert_eq!(*map.get(&2).unwrap(), \"b\");\n     /// ```\n     #[unstable(feature = \"map_first_last\", issue = \"62924\")]\n-    pub fn first_entry<T: ?Sized>(&mut self) -> Option<OccupiedEntry<'_, K, V>>\n-    where\n-        T: Ord,\n-        K: Borrow<T>,\n-    {\n+    pub fn first_entry(&mut self) -> Option<OccupiedEntry<'_, K, V>> {\n         let front = self.root.as_mut()?.as_mut().first_leaf_edge();\n-        if let Ok(kv) = front.right_kv() {\n-            Some(OccupiedEntry {\n-                handle: kv.forget_node_type(),\n-                length: &mut self.length,\n-                _marker: PhantomData,\n-            })\n-        } else {\n-            None\n-        }\n+        let kv = front.right_kv().ok()?;\n+        Some(OccupiedEntry {\n+            handle: kv.forget_node_type(),\n+            length: &mut self.length,\n+            _marker: PhantomData,\n+        })\n+    }\n+\n+    /// Removes and returns the first element in the map.\n+    /// The key of this element is the minimum key that was in the map.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Draining elements in ascending order, while keeping a usable map each iteration.\n+    ///\n+    /// ```\n+    /// #![feature(map_first_last)]\n+    /// use std::collections::BTreeMap;\n+    ///\n+    /// let mut map = BTreeMap::new();\n+    /// map.insert(1, \"a\");\n+    /// map.insert(2, \"b\");\n+    /// while let Some((key, _val)) = map.pop_first() {\n+    ///     assert!(map.iter().all(|(k, _v)| *k > key));\n+    /// }\n+    /// assert!(map.is_empty());\n+    /// ```\n+    #[unstable(feature = \"map_first_last\", issue = \"62924\")]\n+    pub fn pop_first(&mut self) -> Option<(K, V)> {\n+        self.first_entry().map(|entry| entry.remove_entry())\n     }\n \n     /// Returns the last key-value pair in the map.\n@@ -716,11 +730,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// assert_eq!(map.last_key_value(), Some((&2, &\"a\")));\n     /// ```\n     #[unstable(feature = \"map_first_last\", issue = \"62924\")]\n-    pub fn last_key_value<T: ?Sized>(&self) -> Option<(&K, &V)>\n-    where\n-        T: Ord,\n-        K: Borrow<T>,\n-    {\n+    pub fn last_key_value(&self) -> Option<(&K, &V)> {\n         let back = self.root.as_ref()?.as_ref().last_leaf_edge();\n         back.left_kv().ok().map(Handle::into_kv)\n     }\n@@ -730,36 +740,54 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     ///\n     /// # Examples\n     ///\n-    /// Contrived way to `clear` a map:\n-    ///\n     /// ```\n     /// #![feature(map_first_last)]\n     /// use std::collections::BTreeMap;\n     ///\n     /// let mut map = BTreeMap::new();\n     /// map.insert(1, \"a\");\n     /// map.insert(2, \"b\");\n-    /// while let Some(entry) = map.last_entry() {\n-    ///     let (key, val) = entry.remove_entry();\n-    ///     assert!(!map.contains_key(&key));\n+    /// if let Some(mut entry) = map.last_entry() {\n+    ///     if *entry.key() > 0 {\n+    ///         entry.insert(\"last\");\n+    ///     }\n     /// }\n+    /// assert_eq!(*map.get(&1).unwrap(), \"a\");\n+    /// assert_eq!(*map.get(&2).unwrap(), \"last\");\n     /// ```\n     #[unstable(feature = \"map_first_last\", issue = \"62924\")]\n-    pub fn last_entry<T: ?Sized>(&mut self) -> Option<OccupiedEntry<'_, K, V>>\n-    where\n-        T: Ord,\n-        K: Borrow<T>,\n-    {\n+    pub fn last_entry(&mut self) -> Option<OccupiedEntry<'_, K, V>> {\n         let back = self.root.as_mut()?.as_mut().last_leaf_edge();\n-        if let Ok(kv) = back.left_kv() {\n-            Some(OccupiedEntry {\n-                handle: kv.forget_node_type(),\n-                length: &mut self.length,\n-                _marker: PhantomData,\n-            })\n-        } else {\n-            None\n-        }\n+        let kv = back.left_kv().ok()?;\n+        Some(OccupiedEntry {\n+            handle: kv.forget_node_type(),\n+            length: &mut self.length,\n+            _marker: PhantomData,\n+        })\n+    }\n+\n+    /// Removes and returns the last element in the map.\n+    /// The key of this element is the maximum key that was in the map.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Draining elements in descending order, while keeping a usable map each iteration.\n+    ///\n+    /// ```\n+    /// #![feature(map_first_last)]\n+    /// use std::collections::BTreeMap;\n+    ///\n+    /// let mut map = BTreeMap::new();\n+    /// map.insert(1, \"a\");\n+    /// map.insert(2, \"b\");\n+    /// while let Some((key, _val)) = map.pop_last() {\n+    ///     assert!(map.iter().all(|(k, _v)| *k < key));\n+    /// }\n+    /// assert!(map.is_empty());\n+    /// ```\n+    #[unstable(feature = \"map_first_last\", issue = \"62924\")]\n+    pub fn pop_last(&mut self) -> Option<(K, V)> {\n+        self.last_entry().map(|entry| entry.remove_entry())\n     }\n \n     /// Returns `true` if the map contains a value for the specified key."}]}