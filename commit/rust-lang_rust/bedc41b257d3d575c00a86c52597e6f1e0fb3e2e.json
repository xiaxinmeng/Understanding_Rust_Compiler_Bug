{"sha": "bedc41b257d3d575c00a86c52597e6f1e0fb3e2e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJlZGM0MWIyNTdkM2Q1NzVjMDBhODZjNTI1OTdlNmYxZTBmYjNlMmU=", "commit": {"author": {"name": "Luqman Aden", "email": "laden@csclub.uwaterloo.ca", "date": "2014-06-21T21:05:05Z"}, "committer": {"name": "Luqman Aden", "email": "me@luqman.ca", "date": "2014-07-03T03:22:34Z"}, "message": "librustc: Use different alloca slot for non-move bindings.", "tree": {"sha": "7dec670fb38e2015bf473258da8a52dd0e7487ef", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7dec670fb38e2015bf473258da8a52dd0e7487ef"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bedc41b257d3d575c00a86c52597e6f1e0fb3e2e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bedc41b257d3d575c00a86c52597e6f1e0fb3e2e", "html_url": "https://github.com/rust-lang/rust/commit/bedc41b257d3d575c00a86c52597e6f1e0fb3e2e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bedc41b257d3d575c00a86c52597e6f1e0fb3e2e/comments", "author": {"login": "luqmana", "id": 287063, "node_id": "MDQ6VXNlcjI4NzA2Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/287063?v=4", "gravatar_id": "", "url": "https://api.github.com/users/luqmana", "html_url": "https://github.com/luqmana", "followers_url": "https://api.github.com/users/luqmana/followers", "following_url": "https://api.github.com/users/luqmana/following{/other_user}", "gists_url": "https://api.github.com/users/luqmana/gists{/gist_id}", "starred_url": "https://api.github.com/users/luqmana/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/luqmana/subscriptions", "organizations_url": "https://api.github.com/users/luqmana/orgs", "repos_url": "https://api.github.com/users/luqmana/repos", "events_url": "https://api.github.com/users/luqmana/events{/privacy}", "received_events_url": "https://api.github.com/users/luqmana/received_events", "type": "User", "site_admin": false}, "committer": {"login": "luqmana", "id": 287063, "node_id": "MDQ6VXNlcjI4NzA2Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/287063?v=4", "gravatar_id": "", "url": "https://api.github.com/users/luqmana", "html_url": "https://github.com/luqmana", "followers_url": "https://api.github.com/users/luqmana/followers", "following_url": "https://api.github.com/users/luqmana/following{/other_user}", "gists_url": "https://api.github.com/users/luqmana/gists{/gist_id}", "starred_url": "https://api.github.com/users/luqmana/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/luqmana/subscriptions", "organizations_url": "https://api.github.com/users/luqmana/orgs", "repos_url": "https://api.github.com/users/luqmana/repos", "events_url": "https://api.github.com/users/luqmana/events{/privacy}", "received_events_url": "https://api.github.com/users/luqmana/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "94a56a375803abf1826ed31756b6ac12df23de7c", "url": "https://api.github.com/repos/rust-lang/rust/commits/94a56a375803abf1826ed31756b6ac12df23de7c", "html_url": "https://github.com/rust-lang/rust/commit/94a56a375803abf1826ed31756b6ac12df23de7c"}], "stats": {"total": 48, "additions": 38, "deletions": 10}, "files": [{"sha": "a305f26406556ff3cafaba6a7b2bec0baa791bde", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 31, "deletions": 6, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/bedc41b257d3d575c00a86c52597e6f1e0fb3e2e/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bedc41b257d3d575c00a86c52597e6f1e0fb3e2e/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=bedc41b257d3d575c00a86c52597e6f1e0fb3e2e", "patch": "@@ -65,7 +65,11 @@\n  * per-arm `ArmData` struct.  There is a mapping from identifiers to\n  * `BindingInfo` structs.  These structs contain the mode/id/type of the\n  * binding, but they also contain an LLVM value which points at an alloca\n- * called `llmatch`.\n+ * called `llmatch`. For by value bindings that are Copy, we also create\n+ * an extra alloca that we copy the matched value to so that any changes\n+ * we do to our copy is not reflected in the original and vice-versa.\n+ * We don't do this if it's a move since the original value can't be used\n+ * and thus allowing us to cheat in not creating an extra alloca.\n  *\n  * The `llmatch` binding always stores a pointer into the value being matched\n  * which points at the data for the binding.  If the value being matched has\n@@ -352,7 +356,8 @@ fn variant_opt(bcx: &Block, pat_id: ast::NodeId) -> Opt {\n \n #[deriving(Clone)]\n pub enum TransBindingMode {\n-    TrByValue,\n+    TrByCopy(/* llbinding */ ValueRef),\n+    TrByMove,\n     TrByRef,\n }\n \n@@ -1249,7 +1254,7 @@ fn compare_values<'a>(\n     }\n }\n \n-fn insert_lllocals<'a>(bcx: &'a Block<'a>,\n+fn insert_lllocals<'a>(mut bcx: &'a Block<'a>,\n                        bindings_map: &BindingsMap,\n                        cleanup_scope: cleanup::ScopeId)\n                        -> &'a Block<'a> {\n@@ -1262,8 +1267,18 @@ fn insert_lllocals<'a>(bcx: &'a Block<'a>,\n \n     for (&ident, &binding_info) in bindings_map.iter() {\n         let llval = match binding_info.trmode {\n-            // By value bindings: load from the ptr into the matched value\n-            TrByValue => Load(bcx, binding_info.llmatch),\n+            // By value mut binding for a copy type: load from the ptr\n+            // into the matched value and copy to our alloca\n+            TrByCopy(llbinding) => {\n+                let llval = Load(bcx, binding_info.llmatch);\n+                let datum = Datum::new(llval, binding_info.ty, Lvalue);\n+                bcx = datum.store_to(bcx, llbinding);\n+\n+                llbinding\n+            },\n+\n+            // By value move bindings: load from the ptr into the matched value\n+            TrByMove => Load(bcx, binding_info.llmatch),\n \n             // By ref binding: use the ptr into the matched value\n             TrByRef => binding_info.llmatch\n@@ -1762,18 +1777,28 @@ fn create_bindings_map(bcx: &Block, pat: Gc<ast::Pat>) -> BindingsMap {\n         let ident = path_to_ident(path);\n         let variable_ty = node_id_type(bcx, p_id);\n         let llvariable_ty = type_of::type_of(ccx, variable_ty);\n+        let tcx = bcx.tcx();\n \n         let llmatch;\n         let trmode;\n         match bm {\n+            ast::BindByValue(_)\n+                if !ty::type_moves_by_default(tcx, variable_ty) => {\n+                llmatch = alloca(bcx,\n+                                 llvariable_ty.ptr_to(),\n+                                 \"__llmatch\");\n+                trmode = TrByCopy(alloca(bcx,\n+                                         llvariable_ty,\n+                                         bcx.ident(ident).as_slice()));\n+            }\n             ast::BindByValue(_) => {\n                 // in this case, the final type of the variable will be T,\n                 // but during matching we need to store a *T as explained\n                 // above\n                 llmatch = alloca(bcx,\n                                  llvariable_ty.ptr_to(),\n                                  bcx.ident(ident).as_slice());\n-                trmode = TrByValue;\n+                trmode = TrByMove;\n             }\n             ast::BindByRef(_) => {\n                 llmatch = alloca(bcx,"}, {"sha": "83b956290ef696bf5e3ee4401886439c12104570", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/bedc41b257d3d575c00a86c52597e6f1e0fb3e2e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bedc41b257d3d575c00a86c52597e6f1e0fb3e2e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=bedc41b257d3d575c00a86c52597e6f1e0fb3e2e", "patch": "@@ -188,7 +188,7 @@ use middle::subst;\n use middle::trans::adt;\n use middle::trans::common::*;\n use middle::trans::machine;\n-use middle::trans::_match::{BindingInfo, TrByValue, TrByRef};\n+use middle::trans::_match::{BindingInfo, TrByCopy, TrByMove, TrByRef};\n use middle::trans::type_of;\n use middle::trans::type_::Type;\n use middle::trans;\n@@ -948,11 +948,14 @@ pub fn create_match_binding_metadata(bcx: &Block,\n         [llvm::LLVMDIBuilderCreateOpDeref(bcx.ccx().int_type.to_ref())]\n     };\n     // Regardless of the actual type (`T`) we're always passed the stack slot (alloca)\n-    // for the binding. For ByRef bindings that's a `T*` but for ByValue bindings we\n+    // for the binding. For ByRef bindings that's a `T*` but for ByMove bindings we\n     // actually have `T**`. So to get the actual variable we need to dereference once\n-    // more.\n+    // more. For ByCopy we just use the stack slot we created for the binding.\n     let var_type = match binding.trmode {\n-        TrByValue => IndirectVariable {\n+        TrByCopy(llbinding) => DirectVariable {\n+            alloca: llbinding\n+        },\n+        TrByMove => IndirectVariable {\n             alloca: binding.llmatch,\n             address_operations: aops\n         },"}]}