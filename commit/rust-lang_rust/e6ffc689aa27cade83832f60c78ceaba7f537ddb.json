{"sha": "e6ffc689aa27cade83832f60c78ceaba7f537ddb", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU2ZmZjNjg5YWEyN2NhZGU4MzgzMmY2MGM3OGNlYWJhN2Y1MzdkZGI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-04-11T14:59:27Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-04-11T14:59:27Z"}, "message": "Auto merge of #1772 - RalfJung:less-timeout-checking, r=RalfJung\n\nonly check timeouts when a thread yields\n\nCurrently, we check for expired timeouts after each step of execution. That seems excessive. This changes the scheduler to only check for timeouts when the active thread cannot continue running any more.\n\n`@vakaras` does this sound right? `pthread_cond_timedwait` anyway already yields, of course, since it blocks on getting the signal (or the timeout).", "tree": {"sha": "0ec61b0ada6f8f6737273da49f893d0038a9b3e0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0ec61b0ada6f8f6737273da49f893d0038a9b3e0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e6ffc689aa27cade83832f60c78ceaba7f537ddb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e6ffc689aa27cade83832f60c78ceaba7f537ddb", "html_url": "https://github.com/rust-lang/rust/commit/e6ffc689aa27cade83832f60c78ceaba7f537ddb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e6ffc689aa27cade83832f60c78ceaba7f537ddb/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "afabaf30d7a012399e6f23462c212aae18b7c167", "url": "https://api.github.com/repos/rust-lang/rust/commits/afabaf30d7a012399e6f23462c212aae18b7c167", "html_url": "https://github.com/rust-lang/rust/commit/afabaf30d7a012399e6f23462c212aae18b7c167"}, {"sha": "0674d439b620495480f126e96a4b97ae779d1ae7", "url": "https://api.github.com/repos/rust-lang/rust/commits/0674d439b620495480f126e96a4b97ae779d1ae7", "html_url": "https://github.com/rust-lang/rust/commit/0674d439b620495480f126e96a4b97ae779d1ae7"}], "stats": {"total": 34, "additions": 20, "deletions": 14}, "files": [{"sha": "8b1787132cbcca7414d53f1111c601325c2afae9", "filename": "src/thread.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/e6ffc689aa27cade83832f60c78ceaba7f537ddb/src%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6ffc689aa27cade83832f60c78ceaba7f537ddb/src%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fthread.rs?ref=e6ffc689aa27cade83832f60c78ceaba7f537ddb", "patch": "@@ -477,6 +477,7 @@ impl<'mir, 'tcx: 'mir> ThreadManager<'mir, 'tcx> {\n         if self.threads[self.active_thread].check_terminated() {\n             return Ok(SchedulingAction::ExecuteDtors);\n         }\n+        // If we get here again and the thread is *still* terminated, there are no more dtors to run.\n         if self.threads[MAIN_THREAD].state == ThreadState::Terminated {\n             // The main thread terminated; stop the program.\n             if self.threads.iter().any(|thread| thread.state != ThreadState::Terminated) {\n@@ -490,26 +491,25 @@ impl<'mir, 'tcx: 'mir> ThreadManager<'mir, 'tcx> {\n             }\n             return Ok(SchedulingAction::Stop);\n         }\n-        // At least for `pthread_cond_timedwait` we need to report timeout when\n-        // the function is called already after the specified time even if a\n-        // signal is received before the thread gets scheduled. Therefore, we\n-        // need to schedule all timeout callbacks before we continue regular\n-        // execution.\n-        //\n-        // Documentation:\n-        // https://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_cond_timedwait.html#\n-        let potential_sleep_time =\n-            self.timeout_callbacks.values().map(|info| info.call_time.get_wait_time()).min();\n-        if potential_sleep_time == Some(Duration::new(0, 0)) {\n-            return Ok(SchedulingAction::ExecuteTimeoutCallback);\n-        }\n-        // No callbacks scheduled, pick a regular thread to execute.\n+        // This thread and the program can keep going.\n         if self.threads[self.active_thread].state == ThreadState::Enabled\n             && !self.yield_active_thread\n         {\n             // The currently active thread is still enabled, just continue with it.\n             return Ok(SchedulingAction::ExecuteStep);\n         }\n+        // The active thread yielded. Let's see if there are any timeouts to take care of. We do\n+        // this *before* running any other thread, to ensure that timeouts \"in the past\" fire before\n+        // any other thread can take an action. This ensures that for `pthread_cond_timedwait`, \"an\n+        // error is returned if [...] the absolute time specified by abstime has already been passed\n+        // at the time of the call\".\n+        // <https://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_cond_timedwait.html>\n+        let potential_sleep_time =\n+            self.timeout_callbacks.values().map(|info| info.call_time.get_wait_time()).min();\n+        if potential_sleep_time == Some(Duration::new(0, 0)) {\n+            return Ok(SchedulingAction::ExecuteTimeoutCallback);\n+        }\n+        // No callbacks scheduled, pick a regular thread to execute.\n         // We need to pick a new thread for execution.\n         for (id, thread) in self.threads.iter_enumerated() {\n             if thread.state == ThreadState::Enabled {"}, {"sha": "a545c922db1abac6ad449d403fd5c08162b4555b", "filename": "tests/run-pass/concurrency/libc_pthread_cond.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e6ffc689aa27cade83832f60c78ceaba7f537ddb/tests%2Frun-pass%2Fconcurrency%2Flibc_pthread_cond.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6ffc689aa27cade83832f60c78ceaba7f537ddb/tests%2Frun-pass%2Fconcurrency%2Flibc_pthread_cond.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fconcurrency%2Flibc_pthread_cond.rs?ref=e6ffc689aa27cade83832f60c78ceaba7f537ddb", "patch": "@@ -38,6 +38,12 @@ fn test_timed_wait_timeout(clock_id: i32) {\n         let elapsed_time = current_time.elapsed().as_millis();\n         assert!(900 <= elapsed_time && elapsed_time <= 1300);\n \n+        // Test calling `pthread_cond_timedwait` again with an already elapsed timeout.\n+        assert_eq!(\n+            libc::pthread_cond_timedwait(&mut cond as *mut _, &mut mutex as *mut _, &timeout),\n+            libc::ETIMEDOUT\n+        );\n+\n         // Test that invalid nanosecond values (above 10^9 or negative) are rejected with the\n         // correct error code.\n         let invalid_timeout_1 = libc::timespec { tv_sec: now.tv_sec + 1, tv_nsec: 1_000_000_000 };"}]}