{"sha": "212e82fd4183f17670a343a8fabf220ab4b6f7a2", "node_id": "C_kwDOAAsO6NoAKDIxMmU4MmZkNDE4M2YxNzY3MGEzNDNhOGZhYmYyMjBhYjRiNmY3YTI", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2022-02-07T11:54:08Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2022-02-07T11:54:08Z"}, "message": "Add test for giving attribute proc macros valid syntax", "tree": {"sha": "92e2330a0f4c80c85a4043c99713827b97bcbd89", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/92e2330a0f4c80c85a4043c99713827b97bcbd89"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/212e82fd4183f17670a343a8fabf220ab4b6f7a2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/212e82fd4183f17670a343a8fabf220ab4b6f7a2", "html_url": "https://github.com/rust-lang/rust/commit/212e82fd4183f17670a343a8fabf220ab4b6f7a2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/212e82fd4183f17670a343a8fabf220ab4b6f7a2/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9b1978a3ed405c2a5ec34703914ec1878b599e14", "url": "https://api.github.com/repos/rust-lang/rust/commits/9b1978a3ed405c2a5ec34703914ec1878b599e14", "html_url": "https://github.com/rust-lang/rust/commit/9b1978a3ed405c2a5ec34703914ec1878b599e14"}], "stats": {"total": 224, "additions": 186, "deletions": 38}, "files": [{"sha": "af825a2e00b872ed4381df03bf04b5e183139aa0", "filename": "crates/base_db/src/fixture.rs", "status": "modified", "additions": 83, "deletions": 32, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/212e82fd4183f17670a343a8fabf220ab4b6f7a2/crates%2Fbase_db%2Fsrc%2Ffixture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/212e82fd4183f17670a343a8fabf220ab4b6f7a2/crates%2Fbase_db%2Fsrc%2Ffixture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fbase_db%2Fsrc%2Ffixture.rs?ref=212e82fd4183f17670a343a8fabf220ab4b6f7a2", "patch": "@@ -43,6 +43,17 @@ pub trait WithFixture: Default + SourceDatabaseExt + 'static {\n         db\n     }\n \n+    fn with_files_extra_proc_macros(\n+        ra_fixture: &str,\n+        proc_macros: Vec<(String, ProcMacro)>,\n+    ) -> Self {\n+        let fixture = ChangeFixture::parse_with_proc_macros(ra_fixture, proc_macros);\n+        let mut db = Self::default();\n+        fixture.change.apply(&mut db);\n+        assert!(fixture.file_position.is_none());\n+        db\n+    }\n+\n     fn with_position(ra_fixture: &str) -> (Self, FilePosition) {\n         let (db, file_id, range_or_offset) = Self::with_range_or_offset(ra_fixture);\n         let offset = range_or_offset.expect_offset();\n@@ -84,7 +95,14 @@ pub struct ChangeFixture {\n \n impl ChangeFixture {\n     pub fn parse(ra_fixture: &str) -> ChangeFixture {\n-        let (mini_core, proc_macros, fixture) = Fixture::parse(ra_fixture);\n+        Self::parse_with_proc_macros(ra_fixture, Vec::new())\n+    }\n+\n+    pub fn parse_with_proc_macros(\n+        ra_fixture: &str,\n+        mut proc_macros: Vec<(String, ProcMacro)>,\n+    ) -> ChangeFixture {\n+        let (mini_core, proc_macro_names, fixture) = Fixture::parse(ra_fixture);\n         let mut change = Change::new();\n \n         let mut files = Vec::new();\n@@ -222,11 +240,12 @@ impl ChangeFixture {\n             }\n         }\n \n-        if !proc_macros.is_empty() {\n+        if !proc_macro_names.is_empty() {\n             let proc_lib_file = file_id;\n             file_id.0 += 1;\n \n-            let (proc_macro, source) = test_proc_macros(&proc_macros);\n+            proc_macros.extend(default_test_proc_macros());\n+            let (proc_macro, source) = filter_test_proc_macros(&proc_macro_names, proc_macros);\n             let mut fs = FileSet::default();\n             fs.insert(\n                 proc_lib_file,\n@@ -272,52 +291,84 @@ impl ChangeFixture {\n     }\n }\n \n-fn test_proc_macros(proc_macros: &[String]) -> (Vec<ProcMacro>, String) {\n-    // The source here is only required so that paths to the macros exist and are resolvable.\n-    let source = r#\"\n+fn default_test_proc_macros() -> [(String, ProcMacro); 4] {\n+    [\n+        (\n+            r#\"\n #[proc_macro_attribute]\n pub fn identity(_attr: TokenStream, item: TokenStream) -> TokenStream {\n     item\n }\n+\"#\n+            .into(),\n+            ProcMacro {\n+                name: \"identity\".into(),\n+                kind: crate::ProcMacroKind::Attr,\n+                expander: Arc::new(IdentityProcMacroExpander),\n+            },\n+        ),\n+        (\n+            r#\"\n #[proc_macro_derive(DeriveIdentity)]\n pub fn derive_identity(item: TokenStream) -> TokenStream {\n     item\n }\n+\"#\n+            .into(),\n+            ProcMacro {\n+                name: \"DeriveIdentity\".into(),\n+                kind: crate::ProcMacroKind::CustomDerive,\n+                expander: Arc::new(IdentityProcMacroExpander),\n+            },\n+        ),\n+        (\n+            r#\"\n #[proc_macro_attribute]\n pub fn input_replace(attr: TokenStream, _item: TokenStream) -> TokenStream {\n     attr\n }\n+\"#\n+            .into(),\n+            ProcMacro {\n+                name: \"input_replace\".into(),\n+                kind: crate::ProcMacroKind::Attr,\n+                expander: Arc::new(AttributeInputReplaceProcMacroExpander),\n+            },\n+        ),\n+        (\n+            r#\"\n #[proc_macro]\n pub fn mirror(input: TokenStream) -> TokenStream {\n     input\n }\n-\"#;\n-    let proc_macros = [\n-        ProcMacro {\n-            name: \"identity\".into(),\n-            kind: crate::ProcMacroKind::Attr,\n-            expander: Arc::new(IdentityProcMacroExpander),\n-        },\n-        ProcMacro {\n-            name: \"DeriveIdentity\".into(),\n-            kind: crate::ProcMacroKind::CustomDerive,\n-            expander: Arc::new(IdentityProcMacroExpander),\n-        },\n-        ProcMacro {\n-            name: \"input_replace\".into(),\n-            kind: crate::ProcMacroKind::Attr,\n-            expander: Arc::new(AttributeInputReplaceProcMacroExpander),\n-        },\n-        ProcMacro {\n-            name: \"mirror\".into(),\n-            kind: crate::ProcMacroKind::FuncLike,\n-            expander: Arc::new(MirrorProcMacroExpander),\n-        },\n+\"#\n+            .into(),\n+            ProcMacro {\n+                name: \"mirror\".into(),\n+                kind: crate::ProcMacroKind::FuncLike,\n+                expander: Arc::new(MirrorProcMacroExpander),\n+            },\n+        ),\n     ]\n-    .into_iter()\n-    .filter(|pm| proc_macros.iter().any(|name| name == &stdx::to_lower_snake_case(&pm.name)))\n-    .collect();\n-    (proc_macros, source.into())\n+}\n+\n+fn filter_test_proc_macros(\n+    proc_macro_names: &[String],\n+    proc_macro_defs: Vec<(String, ProcMacro)>,\n+) -> (Vec<ProcMacro>, String) {\n+    // The source here is only required so that paths to the macros exist and are resolvable.\n+    let mut source = String::new();\n+    let mut proc_macros = Vec::new();\n+\n+    for (c, p) in proc_macro_defs {\n+        if !proc_macro_names.iter().any(|name| name == &stdx::to_lower_snake_case(&p.name)) {\n+            continue;\n+        }\n+        proc_macros.push(p);\n+        source += &c;\n+    }\n+\n+    (proc_macros, source)\n }\n \n #[derive(Debug, Clone, Copy)]"}, {"sha": "80747f6c6345aeb046ac18c3aa4bd1d3bdbdf353", "filename": "crates/hir_def/src/macro_expansion_tests.rs", "status": "modified", "additions": 66, "deletions": 6, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/212e82fd4183f17670a343a8fabf220ab4b6f7a2/crates%2Fhir_def%2Fsrc%2Fmacro_expansion_tests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/212e82fd4183f17670a343a8fabf220ab4b6f7a2/crates%2Fhir_def%2Fsrc%2Fmacro_expansion_tests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fmacro_expansion_tests.rs?ref=212e82fd4183f17670a343a8fabf220ab4b6f7a2", "patch": "@@ -14,10 +14,10 @@ mod builtin_fn_macro;\n mod builtin_derive_macro;\n mod proc_macros;\n \n-use std::{iter, ops::Range};\n+use std::{iter, ops::Range, sync::Arc};\n \n use ::mbe::TokenMap;\n-use base_db::{fixture::WithFixture, SourceDatabase};\n+use base_db::{fixture::WithFixture, ProcMacro, SourceDatabase};\n use expect_test::Expect;\n use hir_expand::{\n     db::{AstDatabase, TokenExpander},\n@@ -39,7 +39,21 @@ use crate::{\n \n #[track_caller]\n fn check(ra_fixture: &str, mut expect: Expect) {\n-    let db = TestDB::with_files(ra_fixture);\n+    let extra_proc_macros = vec![(\n+        r#\"\n+#[proc_macro_attribute]\n+pub fn identity_when_valid(_attr: TokenStream, item: TokenStream) -> TokenStream {\n+    item\n+}\n+\"#\n+        .into(),\n+        ProcMacro {\n+            name: \"identity_when_valid\".into(),\n+            kind: base_db::ProcMacroKind::Attr,\n+            expander: Arc::new(IdentityWhenValidProcMacroExpander),\n+        },\n+    )];\n+    let db = TestDB::with_files_extra_proc_macros(ra_fixture, extra_proc_macros);\n     let krate = db.crate_graph().iter().next().unwrap();\n     let def_map = db.crate_def_map(krate);\n     let local_id = def_map.root();\n@@ -201,10 +215,19 @@ fn check(ra_fixture: &str, mut expect: Expect) {\n     }\n \n     for decl_id in def_map[local_id].scope.declarations() {\n-        if let ModuleDefId::AdtId(AdtId::StructId(struct_id)) = decl_id {\n-            let src = struct_id.lookup(&db).source(&db);\n+        // FIXME: I'm sure there's already better way to do this\n+        let src = match decl_id {\n+            ModuleDefId::AdtId(AdtId::StructId(struct_id)) => {\n+                Some(struct_id.lookup(&db).source(&db).syntax().cloned())\n+            }\n+            ModuleDefId::FunctionId(function_id) => {\n+                Some(function_id.lookup(&db).source(&db).syntax().cloned())\n+            }\n+            _ => None,\n+        };\n+        if let Some(src) = src {\n             if src.file_id.is_attr_macro(&db) || src.file_id.is_custom_derive(&db) {\n-                let pp = pretty_print_macro_expansion(src.value.syntax().clone(), None);\n+                let pp = pretty_print_macro_expansion(src.value, None);\n                 format_to!(expanded_text, \"\\n{}\", pp)\n             }\n         }\n@@ -304,3 +327,40 @@ fn pretty_print_macro_expansion(expn: SyntaxNode, map: Option<&TokenMap>) -> Str\n     }\n     res\n }\n+\n+// Identity mapping, but only works when the input is syntactically valid. This\n+// simulates common proc macros that unnecessarily parse their input and return\n+// compile errors.\n+#[derive(Debug)]\n+struct IdentityWhenValidProcMacroExpander;\n+impl base_db::ProcMacroExpander for IdentityWhenValidProcMacroExpander {\n+    fn expand(\n+        &self,\n+        subtree: &Subtree,\n+        _: Option<&Subtree>,\n+        _: &base_db::Env,\n+    ) -> Result<Subtree, base_db::ProcMacroExpansionError> {\n+        let (parse, _) =\n+            ::mbe::token_tree_to_syntax_node(subtree, ::mbe::TopEntryPoint::MacroItems);\n+        if parse.errors().is_empty() {\n+            Ok(subtree.clone())\n+        } else {\n+            use tt::{Delimiter, DelimiterKind, Ident, Leaf, Literal, Punct, TokenTree};\n+            let mut subtree = Subtree::default();\n+            subtree.token_trees.push(TokenTree::Leaf(\n+                Ident { text: \"compile_error!\".into(), id: TokenId(0) }.into(),\n+            ));\n+            subtree.token_trees.push(TokenTree::Subtree(Subtree {\n+                delimiter: Some(Delimiter { id: TokenId(2), kind: DelimiterKind::Parenthesis }),\n+                token_trees: vec![TokenTree::Leaf(Leaf::Literal(Literal {\n+                    text: r#\"\"parse error\"\"#.into(),\n+                    id: TokenId::unspecified(),\n+                }))],\n+            }));\n+            subtree.token_trees.push(TokenTree::Leaf(\n+                Punct { char: ';', spacing: tt::Spacing::Alone, id: TokenId::unspecified() }.into(),\n+            ));\n+            Ok(subtree)\n+        }\n+    }\n+}"}, {"sha": "dead99a40c620040134b323da8b09a45a467ff9c", "filename": "crates/hir_def/src/macro_expansion_tests/proc_macros.rs", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/212e82fd4183f17670a343a8fabf220ab4b6f7a2/crates%2Fhir_def%2Fsrc%2Fmacro_expansion_tests%2Fproc_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/212e82fd4183f17670a343a8fabf220ab4b6f7a2/crates%2Fhir_def%2Fsrc%2Fmacro_expansion_tests%2Fproc_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fmacro_expansion_tests%2Fproc_macros.rs?ref=212e82fd4183f17670a343a8fabf220ab4b6f7a2", "patch": "@@ -52,3 +52,40 @@ struct S;\n #[attr2] struct S;\"##]],\n     );\n }\n+\n+#[test]\n+fn attribute_macro_syntax_completion_1() {\n+    // this is just the case where the input is actually valid\n+    check(\n+        r#\"\n+//- proc_macros: identity_when_valid\n+#[proc_macros::identity_when_valid]\n+fn foo() { bar.baz(); blub }\n+\"#,\n+        expect![[r##\"\n+#[proc_macros::identity_when_valid]\n+fn foo() { bar.baz(); blub }\n+\n+fn foo() {\n+    bar.baz();\n+    blub\n+}\"##]],\n+    );\n+}\n+\n+#[test]\n+fn attribute_macro_syntax_completion_2() {\n+    // common case of dot completion while typing\n+    // right now not working\n+    check(\n+        r#\"\n+//- proc_macros: identity_when_valid\n+#[proc_macros::identity_when_valid]\n+fn foo() { bar.; blub }\n+\"#,\n+        expect![[r##\"\n+#[proc_macros::identity_when_valid]\n+fn foo() { bar.; blub }\n+\"##]],\n+    );\n+}"}]}