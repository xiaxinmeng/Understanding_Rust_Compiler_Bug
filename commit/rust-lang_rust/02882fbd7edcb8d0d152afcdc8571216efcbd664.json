{"sha": "02882fbd7edcb8d0d152afcdc8571216efcbd664", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAyODgyZmJkN2VkY2I4ZDBkMTUyYWZjZGM4NTcxMjE2ZWZjYmQ2NjQ=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-02-28T09:23:06Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-03-01T07:01:54Z"}, "message": "std: Change assert_eq!() to use {} instead of {:?}\n\nFormatting via reflection has been a little questionable for some time now, and\nit's a little unfortunate that one of the standard macros will silently use\nreflection when you weren't expecting it. This adds small bits of code bloat to\nlibraries, as well as not always being necessary. In light of this information,\nthis commit switches assert_eq!() to using {} in the error message instead of\n{:?}.\n\nIn updating existing code, there were a few error cases that I encountered:\n\n* It's impossible to define Show for [T, ..N]. I think DST will alleviate this\n  because we can define Show for [T].\n* A few types here and there just needed a #[deriving(Show)]\n* Type parameters needed a Show bound, I often moved this to `assert!(a == b)`\n* `Path` doesn't implement `Show`, so assert_eq!() cannot be used on two paths.\n  I don't think this is much of a regression though because {:?} on paths looks\n  awful (it's a byte array).\n\nConcretely speaking, this shaved 10K off a 656K binary. Not a lot, but sometime\nsignificant for smaller binaries.", "tree": {"sha": "ab893c74b3fdd3d58394e8dd9d74561adfe3326b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ab893c74b3fdd3d58394e8dd9d74561adfe3326b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/02882fbd7edcb8d0d152afcdc8571216efcbd664", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/02882fbd7edcb8d0d152afcdc8571216efcbd664", "html_url": "https://github.com/rust-lang/rust/commit/02882fbd7edcb8d0d152afcdc8571216efcbd664", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/02882fbd7edcb8d0d152afcdc8571216efcbd664/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "123eb4ebea695f724a2375a73db53b91273e5ce0", "url": "https://api.github.com/repos/rust-lang/rust/commits/123eb4ebea695f724a2375a73db53b91273e5ce0", "html_url": "https://github.com/rust-lang/rust/commit/123eb4ebea695f724a2375a73db53b91273e5ce0"}], "stats": {"total": 655, "additions": 354, "deletions": 301}, "files": [{"sha": "dbf8c6512d43cf3158dcc83be972caa420b41358", "filename": "src/doc/guide-container.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Fdoc%2Fguide-container.md", "raw_url": "https://github.com/rust-lang/rust/raw/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Fdoc%2Fguide-container.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-container.md?ref=02882fbd7edcb8d0d152afcdc8571216efcbd664", "patch": "@@ -384,7 +384,7 @@ the trailing underscore is a workaround for issue #5898 and will be removed.\n ~~~\n let mut ys = [1, 2, 3, 4, 5];\n ys.mut_iter().reverse_();\n-assert_eq!(ys, [5, 4, 3, 2, 1]);\n+assert!(ys == [5, 4, 3, 2, 1]);\n ~~~\n \n ## Random-access iterators"}, {"sha": "d6ef241b458164c17866a91420215d59570c3565", "filename": "src/doc/tutorial.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Fdoc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Fdoc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftutorial.md?ref=02882fbd7edcb8d0d152afcdc8571216efcbd664", "patch": "@@ -1688,7 +1688,7 @@ let x = Rc::new([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);\n let y = x.clone(); // a new owner\n let z = x; // this moves `x` into `z`, rather than creating a new owner\n \n-assert_eq!(*z.borrow(), [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);\n+assert!(*z.borrow() == [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);\n \n // the variable is mutable, but not the contents of the box\n let mut a = Rc::new([10, 9, 8, 7, 6, 5, 4, 3, 2, 1]);\n@@ -1707,7 +1707,7 @@ let x = Gc::new([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);\n let y = x; // does not perform a move, unlike with `Rc`\n let z = x;\n \n-assert_eq!(*z.borrow(), [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);\n+assert!(*z.borrow() == [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);\n ~~~\n \n With shared ownership, mutability cannot be inherited so the boxes are always immutable. However,"}, {"sha": "116bb80d8c077389e6906a812818168855c63429", "filename": "src/libcollections/bitv.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Flibcollections%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Flibcollections%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbitv.rs?ref=02882fbd7edcb8d0d152afcdc8571216efcbd664", "patch": "@@ -1542,7 +1542,7 @@ mod tests {\n \n         let mut b = a.clone();\n \n-        assert_eq!(&a, &b);\n+        assert!(a == b);\n \n         assert!(b.remove(&1));\n         assert!(a.contains(&1));\n@@ -1561,7 +1561,7 @@ mod tests {\n         let mut r = rng();\n         let mut bitv = 0 as uint;\n         b.iter(|| {\n-            bitv |= (1 << ((r.next_u32() as uint) % uint::BITS));\n+            bitv |= 1 << ((r.next_u32() as uint) % uint::BITS);\n             &bitv\n         })\n     }"}, {"sha": "6c059d3f40c427cc8c5e8765460ba7c652c97f3a", "filename": "src/libcollections/dlist.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Flibcollections%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Flibcollections%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fdlist.rs?ref=02882fbd7edcb8d0d152afcdc8571216efcbd664", "patch": "@@ -982,11 +982,11 @@ mod tests {\n     fn test_eq() {\n         let mut n: DList<u8> = list_from([]);\n         let mut m = list_from([]);\n-        assert_eq!(&n, &m);\n+        assert!(n == m);\n         n.push_front(1);\n         assert!(n != m);\n         m.push_back(1);\n-        assert_eq!(&n, &m);\n+        assert!(n == m);\n \n         let n = list_from([2,3,4]);\n         let m = list_from([1,2,3]);"}, {"sha": "7fda99d8d2cbac39134fa2b564f97c70f0bcc3bf", "filename": "src/libcollections/enum_set.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Flibcollections%2Fenum_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Flibcollections%2Fenum_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fenum_set.rs?ref=02882fbd7edcb8d0d152afcdc8571216efcbd664", "patch": "@@ -141,7 +141,7 @@ mod test {\n \n     use enum_set::{EnumSet, CLike};\n \n-    #[deriving(Eq)]\n+    #[deriving(Eq, Show)]\n     #[repr(uint)]\n     enum Foo {\n         A, B, C"}, {"sha": "b4b843289f80abaaa2d7737e0678c82ce35abc84", "filename": "src/libcollections/hashmap.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Flibcollections%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Flibcollections%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fhashmap.rs?ref=02882fbd7edcb8d0d152afcdc8571216efcbd664", "patch": "@@ -1065,7 +1065,7 @@ mod test_map {\n         let mut observed = 0;\n         for (k, v) in m.iter() {\n             assert_eq!(*v, *k * 2);\n-            observed |= (1 << *k);\n+            observed |= 1 << *k;\n         }\n         assert_eq!(observed, 0xFFFF_FFFF);\n     }\n@@ -1293,7 +1293,7 @@ mod test_set {\n         }\n         let mut observed = 0;\n         for k in a.iter() {\n-            observed |= (1 << *k);\n+            observed |= 1 << *k;\n         }\n         assert_eq!(observed, 0xFFFF_FFFF);\n     }"}, {"sha": "18da9671419eeff111c0abd7ae060778cf9c4d1b", "filename": "src/libcollections/list.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Flibcollections%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Flibcollections%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flist.rs?ref=02882fbd7edcb8d0d152afcdc8571216efcbd664", "patch": "@@ -153,7 +153,7 @@ mod tests {\n     #[test]\n     fn test_from_vec_empty() {\n         let empty : list::List<int> = List::from_vec([]);\n-        assert_eq!(empty, Nil::<int>);\n+        assert!(empty == Nil::<int>);\n     }\n \n     #[test]\n@@ -222,8 +222,8 @@ mod tests {\n \n     #[test]\n     fn test_append() {\n-        assert_eq!(List::from_vec([1, 2, 3, 4]),\n-                   List::from_vec([1, 2]).append(List::from_vec([3, 4])));\n+        assert!(List::from_vec([1, 2, 3, 4]) ==\n+                List::from_vec([1, 2]).append(List::from_vec([3, 4])));\n     }\n \n     #[test]\n@@ -232,6 +232,6 @@ mod tests {\n         let new_list = list.unshift(0);\n         assert_eq!(list.len(), 1u);\n         assert_eq!(new_list.len(), 2u);\n-        assert_eq!(new_list, List::from_vec([0, 1]));\n+        assert!(new_list == List::from_vec([0, 1]));\n     }\n }"}, {"sha": "0aace71813eba5942773f5beffe5fae9eb56acfd", "filename": "src/libcollections/lru_cache.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Flibcollections%2Flru_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Flibcollections%2Flru_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flru_cache.rs?ref=02882fbd7edcb8d0d152afcdc8571216efcbd664", "patch": "@@ -277,7 +277,7 @@ mod tests {\n \n     fn assert_opt_eq<V: Eq>(opt: Option<&V>, v: V) {\n         assert!(opt.is_some());\n-        assert_eq!(opt.unwrap(), &v);\n+        assert!(opt.unwrap() == &v);\n     }\n \n     #[test]"}, {"sha": "e09bf1023d6798d3cad2aa3038c23920c32b13cf", "filename": "src/libcollections/ringbuf.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Flibcollections%2Fringbuf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Flibcollections%2Fringbuf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fringbuf.rs?ref=02882fbd7edcb8d0d152afcdc8571216efcbd664", "patch": "@@ -409,6 +409,7 @@ mod tests {\n     use deque::Deque;\n     use std::clone::Clone;\n     use std::cmp::Eq;\n+    use std::fmt::Show;\n     use super::RingBuf;\n \n     #[test]\n@@ -493,7 +494,7 @@ mod tests {\n     }\n \n     #[cfg(test)]\n-    fn test_parameterized<T:Clone + Eq>(a: T, b: T, c: T, d: T) {\n+    fn test_parameterized<T:Clone + Eq + Show>(a: T, b: T, c: T, d: T) {\n         let mut deq = RingBuf::new();\n         assert_eq!(deq.len(), 0);\n         deq.push_front(a.clone());\n@@ -578,21 +579,21 @@ mod tests {\n         })\n     }\n \n-    #[deriving(Clone, Eq)]\n+    #[deriving(Clone, Eq, Show)]\n     enum Taggy {\n         One(int),\n         Two(int, int),\n         Three(int, int, int),\n     }\n \n-    #[deriving(Clone, Eq)]\n+    #[deriving(Clone, Eq, Show)]\n     enum Taggypar<T> {\n         Onepar(int),\n         Twopar(int, int),\n         Threepar(int, int, int),\n     }\n \n-    #[deriving(Clone, Eq)]\n+    #[deriving(Clone, Eq, Show)]\n     struct RecCy {\n         x: int,\n         y: int,\n@@ -812,7 +813,7 @@ mod tests {\n     #[test]\n     fn test_eq() {\n         let mut d = RingBuf::new();\n-        assert_eq!(&d, &RingBuf::with_capacity(0));\n+        assert!(d == RingBuf::with_capacity(0));\n         d.push_front(137);\n         d.push_front(17);\n         d.push_front(42);\n@@ -822,11 +823,11 @@ mod tests {\n         e.push_back(17);\n         e.push_back(137);\n         e.push_back(137);\n-        assert_eq!(&e, &d);\n+        assert!(&e == &d);\n         e.pop_back();\n         e.push_back(0);\n         assert!(e != d);\n         e.clear();\n-        assert_eq!(e, RingBuf::new());\n+        assert!(e == RingBuf::new());\n     }\n }"}, {"sha": "c9b8ed363916348bb9a317c2d005a0e1c75398d0", "filename": "src/libgetopts/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Flibgetopts%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Flibgetopts%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgetopts%2Flib.rs?ref=02882fbd7edcb8d0d152afcdc8571216efcbd664", "patch": "@@ -1361,7 +1361,7 @@ mod tests {\n                                 aliases: ~[] }];\n         let verbose = reqopt(\"b\", \"banana\", \"some bananas\", \"VAL\");\n \n-        assert_eq!(verbose.long_to_short(), short);\n+        assert!(verbose.long_to_short() == short);\n     }\n \n     #[test]"}, {"sha": "77989d2ea5e538fbc612093a511364856fb8041f", "filename": "src/libnum/bigint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Flibnum%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Flibnum%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnum%2Fbigint.rs?ref=02882fbd7edcb8d0d152afcdc8571216efcbd664", "patch": "@@ -829,7 +829,7 @@ fn get_radix_base(radix: uint) -> (uint, uint) {\n }\n \n /// A Sign is a `BigInt`'s composing element.\n-#[deriving(Eq, Clone)]\n+#[deriving(Eq, Clone, Show)]\n pub enum Sign { Minus, Zero, Plus }\n \n impl Ord for Sign {"}, {"sha": "4b331925b393f91f56d2749372cc7002b4897df4", "filename": "src/librustc/back/rpath.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Flibrustc%2Fback%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Flibrustc%2Fback%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Frpath.rs?ref=02882fbd7edcb8d0d152afcdc8571216efcbd664", "patch": "@@ -215,7 +215,7 @@ mod test {\n     #[test]\n     fn test_minimize1() {\n         let res = minimize_rpaths([~\"rpath1\", ~\"rpath2\", ~\"rpath1\"]);\n-        assert_eq!(res.as_slice(), [~\"rpath1\", ~\"rpath2\"]);\n+        assert!(res.as_slice() == [~\"rpath1\", ~\"rpath2\"]);\n     }\n \n     #[test]\n@@ -224,7 +224,7 @@ mod test {\n                                    ~\"1a\", ~\"4a\", ~\"1a\",\n                                    ~\"2\",  ~\"3\",  ~\"4a\",\n                                    ~\"3\"]);\n-        assert_eq!(res.as_slice(), [~\"1a\", ~\"2\", ~\"4a\", ~\"3\"]);\n+        assert!(res.as_slice() == [~\"1a\", ~\"2\", ~\"4a\", ~\"3\"]);\n     }\n \n     #[test]"}, {"sha": "0ab826fb1ad96d36b9f1680e6e65df060c49b2d7", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=02882fbd7edcb8d0d152afcdc8571216efcbd664", "patch": "@@ -1468,7 +1468,7 @@ fn roundtrip(in_item: Option<@ast::Item>) {\n     let ebml_doc = reader::Doc(wr.get_ref());\n     let out_item = decode_item_ast(ebml_doc);\n \n-    assert_eq!(in_item, out_item);\n+    assert!(in_item == out_item);\n }\n \n #[test]"}, {"sha": "b59922a61cb192338afd1392b1e569c9f31378e8", "filename": "src/librustc/middle/graph.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Flibrustc%2Fmiddle%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Flibrustc%2Fmiddle%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fgraph.rs?ref=02882fbd7edcb8d0d152afcdc8571216efcbd664", "patch": "@@ -349,19 +349,19 @@ mod test {\n                                       start_data: N,\n                                       expected_incoming: &[(E,N)],\n                                       expected_outgoing: &[(E,N)]) {\n-        assert_eq!(graph.node_data(start_index), &start_data);\n+        assert!(graph.node_data(start_index) == &start_data);\n \n         let mut counter = 0;\n         graph.each_incoming_edge(start_index, |edge_index, edge| {\n-            assert_eq!(graph.edge_data(edge_index), &edge.data);\n+            assert!(graph.edge_data(edge_index) == &edge.data);\n             assert!(counter < expected_incoming.len());\n             debug!(\"counter={:?} expected={:?} edge_index={:?} edge={:?}\",\n                    counter, expected_incoming[counter], edge_index, edge);\n             match expected_incoming[counter] {\n                 (ref e, ref n) => {\n-                    assert_eq!(e, &edge.data);\n-                    assert_eq!(n, graph.node_data(edge.source));\n-                    assert_eq!(start_index, edge.target);\n+                    assert!(e == &edge.data);\n+                    assert!(n == graph.node_data(edge.source));\n+                    assert!(start_index == edge.target);\n                 }\n             }\n             counter += 1;\n@@ -371,15 +371,15 @@ mod test {\n \n         let mut counter = 0;\n         graph.each_outgoing_edge(start_index, |edge_index, edge| {\n-            assert_eq!(graph.edge_data(edge_index), &edge.data);\n+            assert!(graph.edge_data(edge_index) == &edge.data);\n             assert!(counter < expected_outgoing.len());\n             debug!(\"counter={:?} expected={:?} edge_index={:?} edge={:?}\",\n                    counter, expected_outgoing[counter], edge_index, edge);\n             match expected_outgoing[counter] {\n                 (ref e, ref n) => {\n-                    assert_eq!(e, &edge.data);\n-                    assert_eq!(start_index, edge.source);\n-                    assert_eq!(n, graph.node_data(edge.target));\n+                    assert!(e == &edge.data);\n+                    assert!(start_index == edge.source);\n+                    assert!(n == graph.node_data(edge.target));\n                 }\n             }\n             counter += 1;"}, {"sha": "61d00ed2eda535ca1d9bd6e6def799039392db3f", "filename": "src/librustc/middle/trans/type_.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs?ref=02882fbd7edcb8d0d152afcdc8571216efcbd664", "patch": "@@ -25,7 +25,7 @@ use std::cast;\n \n use std::libc::{c_uint};\n \n-#[deriving(Clone, Eq)]\n+#[deriving(Clone, Eq, Show)]\n pub struct Type {\n     priv rf: TypeRef\n }"}, {"sha": "55d33f9691855ed2827d873aef826db7d4c9d0d6", "filename": "src/librustc/middle/typeck/infer/region_inference/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs?ref=02882fbd7edcb8d0d152afcdc8571216efcbd664", "patch": "@@ -761,7 +761,7 @@ impl RegionVarBindings {\n \n // ______________________________________________________________________\n \n-#[deriving(Eq)]\n+#[deriving(Eq, Show)]\n enum Classification { Expanding, Contracting }\n \n enum VarValue { NoValue, Value(Region), ErrorValue }"}, {"sha": "5fd5767d8909425e7e294d5ed7380f61d357e010", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=02882fbd7edcb8d0d152afcdc8571216efcbd664", "patch": "@@ -1588,20 +1588,20 @@ mod tests {\n     use std::io;\n     use collections::TreeMap;\n \n-    #[deriving(Eq, Encodable, Decodable)]\n+    #[deriving(Eq, Encodable, Decodable, Show)]\n     enum Animal {\n         Dog,\n         Frog(~str, int)\n     }\n \n-    #[deriving(Eq, Encodable, Decodable)]\n+    #[deriving(Eq, Encodable, Decodable, Show)]\n     struct Inner {\n         a: (),\n         b: uint,\n         c: ~[~str],\n     }\n \n-    #[deriving(Eq, Encodable, Decodable)]\n+    #[deriving(Eq, Encodable, Decodable, Show)]\n     struct Outer {\n         inner: ~[Inner],\n     }"}, {"sha": "709da1ee34dad1be662cd3e9faae4d4b5c767a10", "filename": "src/libstd/any.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Flibstd%2Fany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Flibstd%2Fany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fany.rs?ref=02882fbd7edcb8d0d152afcdc8571216efcbd664", "patch": "@@ -167,7 +167,7 @@ mod tests {\n     use prelude::*;\n     use super::*;\n \n-    #[deriving(Eq)]\n+    #[deriving(Eq, Show)]\n     struct Test;\n \n     static TEST: &'static str = \"Test\";"}, {"sha": "a21393e268954a435ab162004b2ae9fe5ebd29aa", "filename": "src/libstd/ascii.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Flibstd%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Flibstd%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fascii.rs?ref=02882fbd7edcb8d0d152afcdc8571216efcbd664", "patch": "@@ -475,7 +475,7 @@ mod tests {\n     use char::from_u32;\n \n     macro_rules! v2ascii (\n-        ( [$($e:expr),*]) => ( [$(Ascii{chr:$e}),*]);\n+        ( [$($e:expr),*]) => (&[$(Ascii{chr:$e}),*]);\n         (&[$($e:expr),*]) => (&[$(Ascii{chr:$e}),*]);\n         (~[$($e:expr),*]) => (~[$(Ascii{chr:$e}),*]);\n     )"}, {"sha": "05efa3eab7982391e1c9a79563342c0c4e7f5e9b", "filename": "src/libstd/bool.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Flibstd%2Fbool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Flibstd%2Fbool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbool.rs?ref=02882fbd7edcb8d0d152afcdc8571216efcbd664", "patch": "@@ -293,9 +293,9 @@ mod tests {\n \n     #[test]\n     fn test_totalord() {\n-        assert_eq!(true.cmp(&true), Equal);\n-        assert_eq!(false.cmp(&false), Equal);\n-        assert_eq!(true.cmp(&false), Greater);\n-        assert_eq!(false.cmp(&true), Less);\n+        assert!(true.cmp(&true) == Equal);\n+        assert!(false.cmp(&false) == Equal);\n+        assert!(true.cmp(&false) == Greater);\n+        assert!(false.cmp(&true) == Less);\n     }\n }"}, {"sha": "12524499a32981972761d58b27e3a06e6229213a", "filename": "src/libstd/cell.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Flibstd%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Flibstd%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcell.rs?ref=02882fbd7edcb8d0d152afcdc8571216efcbd664", "patch": "@@ -10,12 +10,13 @@\n \n //! Types dealing with dynamic mutability\n \n+use cast;\n use clone::{Clone, DeepClone};\n use cmp::Eq;\n+use fmt;\n+use kinds::{marker, Pod};\n use ops::Drop;\n use option::{None, Option, Some};\n-use cast;\n-use kinds::{marker, Pod};\n \n /// A mutable memory location that admits only `Pod` data.\n pub struct Cell<T> {\n@@ -61,6 +62,12 @@ impl<T:Eq + Pod> Eq for Cell<T> {\n     }\n }\n \n+impl<T: fmt::Show> fmt::Show for Cell<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f.buf, r\"Cell \\{ value: {} \\}\", self.value)\n+    }\n+}\n+\n /// A mutable memory location with dynamically checked borrow rules\n pub struct RefCell<T> {\n     priv value: T,"}, {"sha": "291f1dd04d30d5e45ad1d56bf23457fff7f1da9f", "filename": "src/libstd/cmp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Flibstd%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Flibstd%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcmp.rs?ref=02882fbd7edcb8d0d152afcdc8571216efcbd664", "patch": "@@ -72,7 +72,7 @@ totaleq_impl!(uint)\n \n totaleq_impl!(char)\n \n-#[deriving(Clone, Eq)]\n+#[deriving(Clone, Eq, Show)]\n pub enum Ordering { Less = -1, Equal = 0, Greater = 1 }\n \n /// Trait for types that form a total order"}, {"sha": "7345193a751bedb9bd63a27d3723f223c4c962ff", "filename": "src/libstd/comm/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Flibstd%2Fcomm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Flibstd%2Fcomm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Fmod.rs?ref=02882fbd7edcb8d0d152afcdc8571216efcbd664", "patch": "@@ -313,7 +313,7 @@ pub struct Chan<T> {\n \n /// This enumeration is the list of the possible reasons that try_recv could not\n /// return data when called.\n-#[deriving(Eq, Clone)]\n+#[deriving(Eq, Clone, Show)]\n pub enum TryRecvResult<T> {\n     /// This channel is currently empty, but the sender(s) have not yet\n     /// disconnected, so data may yet become available."}, {"sha": "948f85ca1c2629a1d98dd4f6ecff79e051bde8eb", "filename": "src/libstd/fmt/parse.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Flibstd%2Ffmt%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Flibstd%2Ffmt%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffmt%2Fparse.rs?ref=02882fbd7edcb8d0d152afcdc8571216efcbd664", "patch": "@@ -657,7 +657,7 @@ mod tests {\n \n     fn same(fmt: &'static str, p: ~[Piece<'static>]) {\n         let mut parser = Parser::new(fmt);\n-        assert_eq!(p, parser.collect());\n+        assert!(p == parser.collect());\n     }\n \n     fn fmtdflt() -> FormatSpec<'static> {"}, {"sha": "f0ea36c251ede9d4338f55e5ea44179de60a4a35", "filename": "src/libstd/intrinsics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Flibstd%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Flibstd%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fintrinsics.rs?ref=02882fbd7edcb8d0d152afcdc8571216efcbd664", "patch": "@@ -444,7 +444,7 @@ extern \"rust-intrinsic\" {\n /// `TypeId` represents a globally unique identifier for a type\n #[lang=\"type_id\"] // This needs to be kept in lockstep with the code in trans/intrinsic.rs and\n                   // middle/lang_items.rs\n-#[deriving(Eq, Hash)]\n+#[deriving(Eq, Hash, Show)]\n #[cfg(not(test))]\n pub struct TypeId {\n     priv t: u64,"}, {"sha": "d1bd6ae13f459124684859d7156506513ba321b0", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=02882fbd7edcb8d0d152afcdc8571216efcbd664", "patch": "@@ -391,21 +391,21 @@ mod test {\n         let mut buf = [0, 0, 0];\n         let nread = reader.read(buf);\n         assert_eq!(Ok(2), nread);\n-        assert_eq!([0, 1, 0], buf);\n+        assert_eq!(buf.as_slice(), &[0, 1, 0]);\n \n         let mut buf = [0];\n         let nread = reader.read(buf);\n         assert_eq!(Ok(1), nread);\n-        assert_eq!([2], buf);\n+        assert_eq!(buf.as_slice(), &[2]);\n \n         let mut buf = [0, 0, 0];\n         let nread = reader.read(buf);\n         assert_eq!(Ok(1), nread);\n-        assert_eq!([3, 0, 0], buf);\n+        assert_eq!(buf.as_slice(), &[3, 0, 0]);\n \n         let nread = reader.read(buf);\n         assert_eq!(Ok(1), nread);\n-        assert_eq!([4, 0, 0], buf);\n+        assert_eq!(buf.as_slice(), &[4, 0, 0]);\n \n         assert!(reader.read(buf).is_err());\n     }\n@@ -416,45 +416,45 @@ mod test {\n         let mut writer = BufferedWriter::with_capacity(2, inner);\n \n         writer.write([0, 1]).unwrap();\n-        assert_eq!([], writer.get_ref().get_ref());\n+        assert_eq!(writer.get_ref().get_ref(), &[]);\n \n         writer.write([2]).unwrap();\n-        assert_eq!([0, 1], writer.get_ref().get_ref());\n+        assert_eq!(writer.get_ref().get_ref(), &[0, 1]);\n \n         writer.write([3]).unwrap();\n-        assert_eq!([0, 1], writer.get_ref().get_ref());\n+        assert_eq!(writer.get_ref().get_ref(), &[0, 1]);\n \n         writer.flush().unwrap();\n-        assert_eq!([0, 1, 2, 3], writer.get_ref().get_ref());\n+        assert_eq!(&[0, 1, 2, 3], writer.get_ref().get_ref());\n \n         writer.write([4]).unwrap();\n         writer.write([5]).unwrap();\n-        assert_eq!([0, 1, 2, 3], writer.get_ref().get_ref());\n+        assert_eq!(&[0, 1, 2, 3], writer.get_ref().get_ref());\n \n         writer.write([6]).unwrap();\n-        assert_eq!([0, 1, 2, 3, 4, 5],\n+        assert_eq!(&[0, 1, 2, 3, 4, 5],\n                    writer.get_ref().get_ref());\n \n         writer.write([7, 8]).unwrap();\n-        assert_eq!([0, 1, 2, 3, 4, 5, 6],\n+        assert_eq!(&[0, 1, 2, 3, 4, 5, 6],\n                    writer.get_ref().get_ref());\n \n         writer.write([9, 10, 11]).unwrap();\n-        assert_eq!([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11],\n+        assert_eq!(&[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11],\n                    writer.get_ref().get_ref());\n \n         writer.flush().unwrap();\n-        assert_eq!([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11],\n+        assert_eq!(&[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11],\n                    writer.get_ref().get_ref());\n     }\n \n     #[test]\n     fn test_buffered_writer_inner_flushes() {\n         let mut w = BufferedWriter::with_capacity(3, MemWriter::new());\n         w.write([0, 1]).unwrap();\n-        assert_eq!([], w.get_ref().get_ref());\n+        assert_eq!(&[], w.get_ref().get_ref());\n         let w = w.unwrap();\n-        assert_eq!([0, 1], w.get_ref());\n+        assert_eq!(&[0, 1], w.get_ref());\n     }\n \n     // This is just here to make sure that we don't infinite loop in the\n@@ -495,20 +495,20 @@ mod test {\n     fn test_line_buffer() {\n         let mut writer = LineBufferedWriter::new(MemWriter::new());\n         writer.write([0]).unwrap();\n-        assert_eq!(writer.get_ref().get_ref(), []);\n+        assert_eq!(writer.get_ref().get_ref(), &[]);\n         writer.write([1]).unwrap();\n-        assert_eq!(writer.get_ref().get_ref(), []);\n+        assert_eq!(writer.get_ref().get_ref(), &[]);\n         writer.flush().unwrap();\n-        assert_eq!(writer.get_ref().get_ref(), [0, 1]);\n+        assert_eq!(writer.get_ref().get_ref(), &[0, 1]);\n         writer.write([0, '\\n' as u8, 1, '\\n' as u8, 2]).unwrap();\n         assert_eq!(writer.get_ref().get_ref(),\n-            [0, 1, 0, '\\n' as u8, 1, '\\n' as u8]);\n+                   &[0, 1, 0, '\\n' as u8, 1, '\\n' as u8]);\n         writer.flush().unwrap();\n         assert_eq!(writer.get_ref().get_ref(),\n-            [0, 1, 0, '\\n' as u8, 1, '\\n' as u8, 2]);\n+                   &[0, 1, 0, '\\n' as u8, 1, '\\n' as u8, 2]);\n         writer.write([3, '\\n' as u8]).unwrap();\n         assert_eq!(writer.get_ref().get_ref(),\n-            [0, 1, 0, '\\n' as u8, 1, '\\n' as u8, 2, 3, '\\n' as u8]);\n+            &[0, 1, 0, '\\n' as u8, 1, '\\n' as u8, 2, 3, '\\n' as u8]);\n     }\n \n     #[test]"}, {"sha": "3e79225f9abbec99374618887ce903bf8436932f", "filename": "src/libstd/io/mem.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Flibstd%2Fio%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Flibstd%2Fio%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmem.rs?ref=02882fbd7edcb8d0d152afcdc8571216efcbd664", "patch": "@@ -216,7 +216,7 @@ impl Buffer for MemReader {\n ///     let mut w = BufWriter::new(buf);\n ///     w.write([0, 1, 2]);\n /// }\n-/// assert_eq!(buf, [0, 1, 2, 0]);\n+/// assert!(buf == [0, 1, 2, 0]);\n /// ```\n pub struct BufWriter<'a> {\n     priv buf: &'a mut [u8],\n@@ -348,24 +348,24 @@ mod test {\n         writer.write([1, 2, 3]).unwrap();\n         writer.write([4, 5, 6, 7]).unwrap();\n         assert_eq!(writer.tell(), Ok(8));\n-        assert_eq!(writer.get_ref(), [0, 1, 2, 3, 4, 5, 6, 7]);\n+        assert_eq!(writer.get_ref(), &[0, 1, 2, 3, 4, 5, 6, 7]);\n \n         writer.seek(0, SeekSet).unwrap();\n         assert_eq!(writer.tell(), Ok(0));\n         writer.write([3, 4]).unwrap();\n-        assert_eq!(writer.get_ref(), [3, 4, 2, 3, 4, 5, 6, 7]);\n+        assert_eq!(writer.get_ref(), &[3, 4, 2, 3, 4, 5, 6, 7]);\n \n         writer.seek(1, SeekCur).unwrap();\n         writer.write([0, 1]).unwrap();\n-        assert_eq!(writer.get_ref(), [3, 4, 2, 0, 1, 5, 6, 7]);\n+        assert_eq!(writer.get_ref(), &[3, 4, 2, 0, 1, 5, 6, 7]);\n \n         writer.seek(-1, SeekEnd).unwrap();\n         writer.write([1, 2]).unwrap();\n-        assert_eq!(writer.get_ref(), [3, 4, 2, 0, 1, 5, 6, 1, 2]);\n+        assert_eq!(writer.get_ref(), &[3, 4, 2, 0, 1, 5, 6, 1, 2]);\n \n         writer.seek(1, SeekEnd).unwrap();\n         writer.write([1]).unwrap();\n-        assert_eq!(writer.get_ref(), [3, 4, 2, 0, 1, 5, 6, 1, 2, 0, 1]);\n+        assert_eq!(writer.get_ref(), &[3, 4, 2, 0, 1, 5, 6, 1, 2, 0, 1]);\n     }\n \n     #[test]\n@@ -380,7 +380,7 @@ mod test {\n             writer.write([4, 5, 6, 7]).unwrap();\n             assert_eq!(writer.tell(), Ok(8));\n         }\n-        assert_eq!(buf, [0, 1, 2, 3, 4, 5, 6, 7]);\n+        assert_eq!(buf.as_slice(), &[0, 1, 2, 3, 4, 5, 6, 7]);\n     }\n \n     #[test]\n@@ -408,7 +408,7 @@ mod test {\n             assert_eq!(writer.tell(), Ok(8));\n \n         }\n-        assert_eq!(buf, [1, 3, 2, 0, 0, 0, 0, 4]);\n+        assert_eq!(buf.as_slice(), &[1, 3, 2, 0, 0, 0, 0, 4]);\n     }\n \n     #[test]\n@@ -432,13 +432,13 @@ mod test {\n         let mut buf = [0];\n         assert_eq!(reader.read(buf), Ok(1));\n         assert_eq!(reader.tell(), Ok(1));\n-        assert_eq!(buf, [0]);\n+        assert_eq!(buf.as_slice(), &[0]);\n         let mut buf = [0, ..4];\n         assert_eq!(reader.read(buf), Ok(4));\n         assert_eq!(reader.tell(), Ok(5));\n-        assert_eq!(buf, [1, 2, 3, 4]);\n+        assert_eq!(buf.as_slice(), &[1, 2, 3, 4]);\n         assert_eq!(reader.read(buf), Ok(3));\n-        assert_eq!(buf.slice(0, 3), [5, 6, 7]);\n+        assert_eq!(buf.slice(0, 3), &[5, 6, 7]);\n         assert!(reader.read(buf).is_err());\n         let mut reader = MemReader::new(~[0, 1, 2, 3, 4, 5, 6, 7]);\n         assert_eq!(reader.read_until(3).unwrap(), ~[0, 1, 2, 3]);\n@@ -456,13 +456,13 @@ mod test {\n         let mut buf = [0];\n         assert_eq!(reader.read(buf), Ok(1));\n         assert_eq!(reader.tell(), Ok(1));\n-        assert_eq!(buf, [0]);\n+        assert_eq!(buf.as_slice(), &[0]);\n         let mut buf = [0, ..4];\n         assert_eq!(reader.read(buf), Ok(4));\n         assert_eq!(reader.tell(), Ok(5));\n-        assert_eq!(buf, [1, 2, 3, 4]);\n+        assert_eq!(buf.as_slice(), &[1, 2, 3, 4]);\n         assert_eq!(reader.read(buf), Ok(3));\n-        assert_eq!(buf.slice(0, 3), [5, 6, 7]);\n+        assert_eq!(buf.slice(0, 3), &[5, 6, 7]);\n         assert!(reader.read(buf).is_err());\n         let mut reader = BufReader::new(in_buf);\n         assert_eq!(reader.read_until(3).unwrap(), ~[0, 1, 2, 3]);"}, {"sha": "d9811e3a900687e269532067d59001df63c7abaa", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=02882fbd7edcb8d0d152afcdc8571216efcbd664", "patch": "@@ -1286,7 +1286,7 @@ pub enum FileAccess {\n }\n \n /// Different kinds of files which can be identified by a call to stat\n-#[deriving(Eq)]\n+#[deriving(Eq, Show)]\n pub enum FileType {\n     /// This is a normal file, corresponding to `S_IFREG`\n     TypeFile,"}, {"sha": "7681e208bc44dbf1640d4d1b7d7fc0912c73b3dd", "filename": "src/libstd/io/result.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Flibstd%2Fio%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Flibstd%2Fio%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fresult.rs?ref=02882fbd7edcb8d0d152afcdc8571216efcbd664", "patch": "@@ -111,7 +111,7 @@ mod test {\n             Ok(MemReader::new(~[0, 1, 2, 3]));\n         let mut buf = [0, 0];\n         reader.read(buf).unwrap();\n-        assert_eq!(buf, [0, 1]);\n+        assert_eq!(buf.as_slice(), &[0, 1]);\n     }\n \n     #[test]"}, {"sha": "63df3d2c4f1cf1204cc531e169397210f5116111", "filename": "src/libstd/io/signal.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Flibstd%2Fio%2Fsignal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Flibstd%2Fio%2Fsignal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fsignal.rs?ref=02882fbd7edcb8d0d152afcdc8571216efcbd664", "patch": "@@ -31,7 +31,7 @@ use vec::{ImmutableVector, OwnedVector};\n \n /// Signals that can be sent and received\n #[repr(int)]\n-#[deriving(Eq, Hash)]\n+#[deriving(Eq, Hash, Show)]\n pub enum Signum {\n     /// Equivalent to SIGBREAK, delivered when the user presses Ctrl-Break.\n     Break = 21i,"}, {"sha": "a01a4bf3d6273d65cda650ed8924e88eedaafe2a", "filename": "src/libstd/iter.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Flibstd%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Flibstd%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fiter.rs?ref=02882fbd7edcb8d0d152afcdc8571216efcbd664", "patch": "@@ -983,7 +983,7 @@ impl<A: Ord, T: Iterator<A>> OrdIterator<A> for T {\n }\n \n /// `MinMaxResult` is an enum returned by `min_max`. See `OrdIterator::min_max` for more detail.\n-#[deriving(Clone, Eq)]\n+#[deriving(Clone, Eq, Show)]\n pub enum MinMaxResult<T> {\n     /// Empty iterator\n     NoElements,\n@@ -2507,7 +2507,7 @@ mod tests {\n                    .collect::<~[uint]>();\n \n         assert_eq!(n, xs.len());\n-        assert_eq!(xs, ys.as_slice());\n+        assert_eq!(xs.as_slice(), ys.as_slice());\n     }\n \n     #[test]\n@@ -2824,11 +2824,11 @@ mod tests {\n         assert_eq!(len, b.indexable());\n         let mut n = 0;\n         for (i, elt) in a.enumerate() {\n-            assert_eq!(Some(elt), b.idx(i));\n+            assert!(Some(elt) == b.idx(i));\n             n += 1;\n         }\n         assert_eq!(n, len);\n-        assert_eq!(None, b.idx(n));\n+        assert!(None == b.idx(n));\n         // call recursively to check after picking off an element\n         if len > 0 {\n             b.next();\n@@ -3051,7 +3051,7 @@ mod tests {\n     fn test_reverse() {\n         let mut ys = [1, 2, 3, 4, 5];\n         ys.mut_iter().reverse_();\n-        assert_eq!(ys, [5, 4, 3, 2, 1]);\n+        assert!(ys == [5, 4, 3, 2, 1]);\n     }\n \n     #[test]"}, {"sha": "ba72e1f2549bb9c09da2da923f060344a2aa2173", "filename": "src/libstd/macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Flibstd%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Flibstd%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros.rs?ref=02882fbd7edcb8d0d152afcdc8571216efcbd664", "patch": "@@ -224,7 +224,7 @@ macro_rules! assert_eq(\n         if !((*given_val == *expected_val) &&\n              (*expected_val == *given_val)) {\n             fail!(\"assertion failed: `(left == right) && (right == left)` \\\n-                   (left: `{:?}`, right: `{:?}`)\", *given_val, *expected_val)\n+                   (left: `{}`, right: `{}`)\", *given_val, *expected_val)\n         }\n     })\n )"}, {"sha": "2051eeef60c79a2681a88c5294c8964bcc50eb3e", "filename": "src/libstd/num/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Flibstd%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Flibstd%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fmod.rs?ref=02882fbd7edcb8d0d152afcdc8571216efcbd664", "patch": "@@ -295,7 +295,7 @@ pub fn checked_next_power_of_two<T: Unsigned + Int>(n: T) -> Option<T> {\n }\n \n /// Used for representing the classification of floating point numbers\n-#[deriving(Eq)]\n+#[deriving(Eq, Show)]\n pub enum FPCategory {\n     /// \"Not a Number\", often obtained by dividing by zero\n     FPNaN,\n@@ -1075,7 +1075,7 @@ pub trait CheckedDiv: Div<Self, Self> {\n \n /// Helper function for testing numeric operations\n #[cfg(test)]\n-pub fn test_num<T:Num + NumCast>(ten: T, two: T) {\n+pub fn test_num<T:Num + NumCast + Show>(ten: T, two: T) {\n     assert_eq!(ten.add(&two),  cast(12).unwrap());\n     assert_eq!(ten.sub(&two),  cast(8).unwrap());\n     assert_eq!(ten.mul(&two),  cast(20).unwrap());\n@@ -1650,7 +1650,7 @@ mod tests {\n     test_checked_next_power_of_two!(test_checked_next_power_of_two_u64, u64)\n     test_checked_next_power_of_two!(test_checked_next_power_of_two_uint, uint)\n \n-    #[deriving(Eq)]\n+    #[deriving(Eq, Show)]\n     struct Value { x: int }\n \n     impl ToPrimitive for Value {"}, {"sha": "8efa9763ba9ff600bedb665b50facb80b5a67390", "filename": "src/libstd/os.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=02882fbd7edcb8d0d152afcdc8571216efcbd664", "patch": "@@ -1535,7 +1535,7 @@ mod tests {\n         let oldhome = getenv(\"HOME\");\n \n         setenv(\"HOME\", \"/home/MountainView\");\n-        assert_eq!(os::homedir(), Some(Path::new(\"/home/MountainView\")));\n+        assert!(os::homedir() == Some(Path::new(\"/home/MountainView\")));\n \n         setenv(\"HOME\", \"\");\n         assert!(os::homedir().is_none());\n@@ -1556,16 +1556,16 @@ mod tests {\n         assert!(os::homedir().is_none());\n \n         setenv(\"HOME\", \"/home/MountainView\");\n-        assert_eq!(os::homedir(), Some(Path::new(\"/home/MountainView\")));\n+        assert!(os::homedir() == Some(Path::new(\"/home/MountainView\")));\n \n         setenv(\"HOME\", \"\");\n \n         setenv(\"USERPROFILE\", \"/home/MountainView\");\n-        assert_eq!(os::homedir(), Some(Path::new(\"/home/MountainView\")));\n+        assert!(os::homedir() == Some(Path::new(\"/home/MountainView\")));\n \n         setenv(\"HOME\", \"/home/MountainView\");\n         setenv(\"USERPROFILE\", \"/home/PaloAlto\");\n-        assert_eq!(os::homedir(), Some(Path::new(\"/home/MountainView\")));\n+        assert!(os::homedir() == Some(Path::new(\"/home/MountainView\")));\n \n         for s in oldhome.iter() { setenv(\"HOME\", *s) }\n         for s in olduserprofile.iter() { setenv(\"USERPROFILE\", *s) }"}, {"sha": "321186e4808c0bcc57a7e4fe9ced4e412dccedc9", "filename": "src/libstd/path/posix.rs", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Flibstd%2Fpath%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Flibstd%2Fpath%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fposix.rs?ref=02882fbd7edcb8d0d152afcdc8571216efcbd664", "patch": "@@ -455,13 +455,13 @@ mod tests {\n         (s: $path:expr, $exp:expr) => (\n             {\n                 let path = $path;\n-                assert_eq!(path.as_str(), Some($exp));\n+                assert!(path.as_str() == Some($exp));\n             }\n         );\n         (v: $path:expr, $exp:expr) => (\n             {\n                 let path = $path;\n-                assert_eq!(path.as_vec(), $exp);\n+                assert!(path.as_vec() == $exp);\n             }\n         )\n     )\n@@ -484,7 +484,7 @@ mod tests {\n         t!(v: Path::new(b!(\"a/b/c\", 0xff)), b!(\"a/b/c\", 0xff));\n         t!(v: Path::new(b!(0xff, \"/../foo\", 0x80)), b!(\"foo\", 0x80));\n         let p = Path::new(b!(\"a/b/c\", 0xff));\n-        assert_eq!(p.as_str(), None);\n+        assert!(p.as_str() == None);\n \n         t!(s: Path::new(\"\"), \".\");\n         t!(s: Path::new(\"/\"), \"/\");\n@@ -509,19 +509,19 @@ mod tests {\n         t!(s: Path::new(\"foo/../../..\"), \"../..\");\n         t!(s: Path::new(\"foo/../../bar\"), \"../bar\");\n \n-        assert_eq!(Path::new(b!(\"foo/bar\")).into_vec(), b!(\"foo/bar\").to_owned());\n-        assert_eq!(Path::new(b!(\"/foo/../../bar\")).into_vec(),\n+        assert!(Path::new(b!(\"foo/bar\")).into_vec() == b!(\"foo/bar\").to_owned());\n+        assert!(Path::new(b!(\"/foo/../../bar\")).into_vec() ==\n                    b!(\"/bar\").to_owned());\n \n         let p = Path::new(b!(\"foo/bar\", 0x80));\n-        assert_eq!(p.as_str(), None);\n+        assert!(p.as_str() == None);\n     }\n \n     #[test]\n     fn test_opt_paths() {\n-        assert_eq!(Path::new_opt(b!(\"foo/bar\", 0)), None);\n+        assert!(Path::new_opt(b!(\"foo/bar\", 0)) == None);\n         t!(v: Path::new_opt(b!(\"foo/bar\")).unwrap(), b!(\"foo/bar\"));\n-        assert_eq!(Path::new_opt(\"foo/bar\\0\"), None);\n+        assert!(Path::new_opt(\"foo/bar\\0\") == None);\n         t!(s: Path::new_opt(\"foo/bar\").unwrap(), \"foo/bar\");\n     }\n \n@@ -550,7 +550,7 @@ mod tests {\n             ($path:expr, $disp:ident, $exp:expr) => (\n                 {\n                     let path = Path::new($path);\n-                    assert_eq!(path.$disp().to_str(), ~$exp);\n+                    assert!(path.$disp().to_str() == ~$exp);\n                 }\n             )\n         )\n@@ -566,14 +566,14 @@ mod tests {\n                 {\n                     let path = Path::new($path);\n                     let mo = path.display().as_maybe_owned();\n-                    assert_eq!(mo.as_slice(), $exp);\n+                    assert!(mo.as_slice() == $exp);\n                 }\n             );\n             ($path:expr, $exp:expr, filename) => (\n                 {\n                     let path = Path::new($path);\n                     let mo = path.filename_display().as_maybe_owned();\n-                    assert_eq!(mo.as_slice(), $exp);\n+                    assert!(mo.as_slice() == $exp);\n                 }\n             )\n         )\n@@ -593,9 +593,9 @@ mod tests {\n                 {\n                     let path = Path::new($path);\n                     let f = format!(\"{}\", path.display());\n-                    assert_eq!(f.as_slice(), $exp);\n+                    assert!(f.as_slice() == $exp);\n                     let f = format!(\"{}\", path.filename_display());\n-                    assert_eq!(f.as_slice(), $expf);\n+                    assert!(f.as_slice() == $expf);\n                 }\n             )\n         )\n@@ -615,21 +615,21 @@ mod tests {\n             (s: $path:expr, $op:ident, $exp:expr) => (\n                 {\n                     let path = Path::new($path);\n-                    assert_eq!(path.$op(), ($exp).as_bytes());\n+                    assert!(path.$op() == ($exp).as_bytes());\n                 }\n             );\n             (s: $path:expr, $op:ident, $exp:expr, opt) => (\n                 {\n                     let path = Path::new($path);\n                     let left = path.$op().map(|x| str::from_utf8(x).unwrap());\n-                    assert_eq!(left, $exp);\n+                    assert!(left == $exp);\n                 }\n             );\n             (v: $path:expr, $op:ident, $exp:expr) => (\n                 {\n                     let arg = $path;\n                     let path = Path::new(arg);\n-                    assert_eq!(path.$op(), $exp);\n+                    assert!(path.$op() == $exp);\n                 }\n             );\n         )\n@@ -703,7 +703,7 @@ mod tests {\n                     let mut p1 = Path::new(path);\n                     let p2 = p1.clone();\n                     p1.push(join);\n-                    assert_eq!(p1, p2.join(join));\n+                    assert!(p1 == p2.join(join));\n                 }\n             )\n         )\n@@ -722,7 +722,7 @@ mod tests {\n                     let mut p = Path::new($path);\n                     let push = Path::new($push);\n                     p.push(&push);\n-                    assert_eq!(p.as_str(), Some($exp));\n+                    assert!(p.as_str() == Some($exp));\n                 }\n             )\n         )\n@@ -742,14 +742,14 @@ mod tests {\n                 {\n                     let mut p = Path::new($path);\n                     p.push_many($push);\n-                    assert_eq!(p.as_str(), Some($exp));\n+                    assert!(p.as_str() == Some($exp));\n                 }\n             );\n             (v: $path:expr, $push:expr, $exp:expr) => (\n                 {\n                     let mut p = Path::new($path);\n                     p.push_many($push);\n-                    assert_eq!(p.as_vec(), $exp);\n+                    assert!(p.as_vec() == $exp);\n                 }\n             )\n         )\n@@ -770,16 +770,16 @@ mod tests {\n                 {\n                     let mut p = Path::new($path);\n                     let result = p.pop();\n-                    assert_eq!(p.as_str(), Some($left));\n-                    assert_eq!(result, $right);\n+                    assert!(p.as_str() == Some($left));\n+                    assert!(result == $right);\n                 }\n             );\n             (v: [$($path:expr),+], [$($left:expr),+], $right:expr) => (\n                 {\n                     let mut p = Path::new(b!($($path),+));\n                     let result = p.pop();\n-                    assert_eq!(p.as_vec(), b!($($left),+));\n-                    assert_eq!(result, $right);\n+                    assert!(p.as_vec() == b!($($left),+));\n+                    assert!(result == $right);\n                 }\n             )\n         )\n@@ -802,8 +802,8 @@ mod tests {\n \n     #[test]\n     fn test_root_path() {\n-        assert_eq!(Path::new(b!(\"a/b/c\")).root_path(), None);\n-        assert_eq!(Path::new(b!(\"/a/b/c\")).root_path(), Some(Path::new(\"/\")));\n+        assert!(Path::new(b!(\"a/b/c\")).root_path() == None);\n+        assert!(Path::new(b!(\"/a/b/c\")).root_path() == Some(Path::new(\"/\")));\n     }\n \n     #[test]\n@@ -827,7 +827,7 @@ mod tests {\n                     let path = Path::new($path);\n                     let join = Path::new($join);\n                     let res = path.join(&join);\n-                    assert_eq!(res.as_str(), Some($exp));\n+                    assert!(res.as_str() == Some($exp));\n                 }\n             )\n         )\n@@ -847,14 +847,14 @@ mod tests {\n                 {\n                     let path = Path::new($path);\n                     let res = path.join_many($join);\n-                    assert_eq!(res.as_str(), Some($exp));\n+                    assert!(res.as_str() == Some($exp));\n                 }\n             );\n             (v: $path:expr, $join:expr, $exp:expr) => (\n                 {\n                     let path = Path::new($path);\n                     let res = path.join_many($join);\n-                    assert_eq!(res.as_vec(), $exp);\n+                    assert!(res.as_vec() == $exp);\n                 }\n             )\n         )\n@@ -928,7 +928,7 @@ mod tests {\n                     let mut p1 = Path::new(path);\n                     p1.$set(arg);\n                     let p2 = Path::new(path);\n-                    assert_eq!(p1, p2.$with(arg));\n+                    assert!(p1 == p2.$with(arg));\n                 }\n             );\n             (v: $path:expr, $set:ident, $with:ident, $arg:expr) => (\n@@ -938,7 +938,7 @@ mod tests {\n                     let mut p1 = Path::new(path);\n                     p1.$set(arg);\n                     let p2 = Path::new(path);\n-                    assert_eq!(p1, p2.$with(arg));\n+                    assert!(p1 == p2.$with(arg));\n                 }\n             )\n         )\n@@ -989,10 +989,10 @@ mod tests {\n             (v: $path:expr, $filename:expr, $dirname:expr, $filestem:expr, $ext:expr) => (\n                 {\n                     let path = $path;\n-                    assert_eq!(path.filename(), $filename);\n-                    assert_eq!(path.dirname(), $dirname);\n-                    assert_eq!(path.filestem(), $filestem);\n-                    assert_eq!(path.extension(), $ext);\n+                    assert!(path.filename() == $filename);\n+                    assert!(path.dirname() == $dirname);\n+                    assert!(path.filestem() == $filestem);\n+                    assert!(path.extension() == $ext);\n                 }\n             )\n         )"}, {"sha": "90f7890f9ea2468b195ca70e4b0c5b260ebf4294", "filename": "src/libstd/path/windows.rs", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Flibstd%2Fpath%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Flibstd%2Fpath%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fwindows.rs?ref=02882fbd7edcb8d0d152afcdc8571216efcbd664", "patch": "@@ -1097,13 +1097,13 @@ mod tests {\n         (s: $path:expr, $exp:expr) => (\n             {\n                 let path = $path;\n-                assert_eq!(path.as_str(), Some($exp));\n+                assert!(path.as_str() == Some($exp));\n             }\n         );\n         (v: $path:expr, $exp:expr) => (\n             {\n                 let path = $path;\n-                assert_eq!(path.as_vec(), $exp);\n+                assert!(path.as_vec() == $exp);\n             }\n         )\n     )\n@@ -1270,10 +1270,10 @@ mod tests {\n \n     #[test]\n     fn test_opt_paths() {\n-        assert_eq!(Path::new_opt(b!(\"foo\\\\bar\", 0)), None);\n-        assert_eq!(Path::new_opt(b!(\"foo\\\\bar\", 0x80)), None);\n+        assert!(Path::new_opt(b!(\"foo\\\\bar\", 0)) == None);\n+        assert!(Path::new_opt(b!(\"foo\\\\bar\", 0x80)) == None);\n         t!(v: Path::new_opt(b!(\"foo\\\\bar\")).unwrap(), b!(\"foo\\\\bar\"));\n-        assert_eq!(Path::new_opt(\"foo\\\\bar\\0\"), None);\n+        assert!(Path::new_opt(\"foo\\\\bar\\0\") == None);\n         t!(s: Path::new_opt(\"foo\\\\bar\").unwrap(), \"foo\\\\bar\");\n     }\n \n@@ -1343,22 +1343,22 @@ mod tests {\n                 {\n                     let path = $path;\n                     let path = Path::new(path);\n-                    assert_eq!(path.$op(), Some($exp));\n+                    assert!(path.$op() == Some($exp));\n                 }\n             );\n             (s: $path:expr, $op:ident, $exp:expr, opt) => (\n                 {\n                     let path = $path;\n                     let path = Path::new(path);\n                     let left = path.$op();\n-                    assert_eq!(left, $exp);\n+                    assert!(left == $exp);\n                 }\n             );\n             (v: $path:expr, $op:ident, $exp:expr) => (\n                 {\n                     let path = $path;\n                     let path = Path::new(path);\n-                    assert_eq!(path.$op(), $exp);\n+                    assert!(path.$op() == $exp);\n                 }\n             )\n         )\n@@ -1469,7 +1469,7 @@ mod tests {\n                     let mut p1 = Path::new(path);\n                     let p2 = p1.clone();\n                     p1.push(join);\n-                    assert_eq!(p1, p2.join(join));\n+                    assert!(p1 == p2.join(join));\n                 }\n             )\n         )\n@@ -1483,9 +1483,9 @@ mod tests {\n \n         // we do want to check one odd case though to ensure the prefix is re-parsed\n         let mut p = Path::new(\"\\\\\\\\?\\\\C:\");\n-        assert_eq!(prefix(&p), Some(VerbatimPrefix(2)));\n+        assert!(prefix(&p) == Some(VerbatimPrefix(2)));\n         p.push(\"foo\");\n-        assert_eq!(prefix(&p), Some(VerbatimDiskPrefix));\n+        assert!(prefix(&p) == Some(VerbatimDiskPrefix));\n         assert_eq!(p.as_str(), Some(\"\\\\\\\\?\\\\C:\\\\foo\"));\n \n         // and another with verbatim non-normalized paths\n@@ -1586,15 +1586,15 @@ mod tests {\n                     assert!(p.as_str() == Some(left),\n                         \"`{}`.pop() failed; expected remainder `{}`, found `{}`\",\n                         pstr, left, p.as_str().unwrap());\n-                    assert_eq!(result, $right);\n+                    assert!(result == $right);\n                 }\n             );\n             (v: [$($path:expr),+], [$($left:expr),+], $right:expr) => (\n                 {\n                     let mut p = Path::new(b!($($path),+));\n                     let result = p.pop();\n                     assert_eq!(p.as_vec(), b!($($left),+));\n-                    assert_eq!(result, $right);\n+                    assert!(result == $right);\n                 }\n             )\n         )\n@@ -1637,16 +1637,16 @@ mod tests {\n \n     #[test]\n     fn test_root_path() {\n-        assert_eq!(Path::new(\"a\\\\b\\\\c\").root_path(), None);\n-        assert_eq!(Path::new(\"\\\\a\\\\b\\\\c\").root_path(), Some(Path::new(\"\\\\\")));\n-        assert_eq!(Path::new(\"C:a\").root_path(), Some(Path::new(\"C:\")));\n-        assert_eq!(Path::new(\"C:\\\\a\").root_path(), Some(Path::new(\"C:\\\\\")));\n-        assert_eq!(Path::new(\"\\\\\\\\a\\\\b\\\\c\").root_path(), Some(Path::new(\"\\\\\\\\a\\\\b\")));\n-        assert_eq!(Path::new(\"\\\\\\\\?\\\\a\\\\b\").root_path(), Some(Path::new(\"\\\\\\\\?\\\\a\")));\n-        assert_eq!(Path::new(\"\\\\\\\\?\\\\C:\\\\a\").root_path(), Some(Path::new(\"\\\\\\\\?\\\\C:\\\\\")));\n-        assert_eq!(Path::new(\"\\\\\\\\?\\\\UNC\\\\a\\\\b\\\\c\").root_path(),\n-                   Some(Path::new(\"\\\\\\\\?\\\\UNC\\\\a\\\\b\")));\n-        assert_eq!(Path::new(\"\\\\\\\\.\\\\a\\\\b\").root_path(), Some(Path::new(\"\\\\\\\\.\\\\a\")));\n+        assert!(Path::new(\"a\\\\b\\\\c\").root_path() == None);\n+        assert!(Path::new(\"\\\\a\\\\b\\\\c\").root_path() == Some(Path::new(\"\\\\\")));\n+        assert!(Path::new(\"C:a\").root_path() == Some(Path::new(\"C:\")));\n+        assert!(Path::new(\"C:\\\\a\").root_path() == Some(Path::new(\"C:\\\\\")));\n+        assert!(Path::new(\"\\\\\\\\a\\\\b\\\\c\").root_path() == Some(Path::new(\"\\\\\\\\a\\\\b\")));\n+        assert!(Path::new(\"\\\\\\\\?\\\\a\\\\b\").root_path() == Some(Path::new(\"\\\\\\\\?\\\\a\")));\n+        assert!(Path::new(\"\\\\\\\\?\\\\C:\\\\a\").root_path() == Some(Path::new(\"\\\\\\\\?\\\\C:\\\\\")));\n+        assert!(Path::new(\"\\\\\\\\?\\\\UNC\\\\a\\\\b\\\\c\").root_path() ==\n+                Some(Path::new(\"\\\\\\\\?\\\\UNC\\\\a\\\\b\")));\n+        assert!(Path::new(\"\\\\\\\\.\\\\a\\\\b\").root_path() == Some(Path::new(\"\\\\\\\\.\\\\a\")));\n     }\n \n     #[test]\n@@ -1808,7 +1808,7 @@ mod tests {\n                     let mut p1 = Path::new(path);\n                     p1.$set(arg);\n                     let p2 = Path::new(path);\n-                    assert_eq!(p1, p2.$with(arg));\n+                    assert!(p1 == p2.$with(arg));\n                 }\n             );\n             (v: $path:expr, $set:ident, $with:ident, $arg:expr) => (\n@@ -1818,7 +1818,7 @@ mod tests {\n                     let mut p1 = Path::new(path);\n                     p1.$set(arg);\n                     let p2 = Path::new(path);\n-                    assert_eq!(p1, p2.$with(arg));\n+                    assert!(p1 == p2.$with(arg));\n                 }\n             )\n         )\n@@ -1870,10 +1870,10 @@ mod tests {\n             (v: $path:expr, $filename:expr, $dirname:expr, $filestem:expr, $ext:expr) => (\n                 {\n                     let path = $path;\n-                    assert_eq!(path.filename(), $filename);\n-                    assert_eq!(path.dirname(), $dirname);\n-                    assert_eq!(path.filestem(), $filestem);\n-                    assert_eq!(path.extension(), $ext);\n+                    assert!(path.filename() == $filename);\n+                    assert!(path.dirname() == $dirname);\n+                    assert!(path.filestem() == $filestem);\n+                    assert!(path.extension() == $ext);\n                 }\n             )\n         )\n@@ -2325,7 +2325,7 @@ mod tests {\n                     let path = Path::new($path);\n                     let exp: Option<&str> = $exp;\n                     let exp = exp.map(|s| Path::new(s));\n-                    assert_eq!(make_non_verbatim(&path), exp);\n+                    assert!(make_non_verbatim(&path) == exp);\n                 }\n             )\n         )"}, {"sha": "95eda1cecc09ebbc01dd15be78dd03968b0d36ed", "filename": "src/libstd/ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Flibstd%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Flibstd%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fptr.rs?ref=02882fbd7edcb8d0d152afcdc8571216efcbd664", "patch": "@@ -636,6 +636,6 @@ pub mod ptr_tests {\n         let mut xs = [0u8, ..20];\n         let ptr = xs.as_mut_ptr();\n         unsafe { set_memory(ptr, 5u8, xs.len()); }\n-        assert_eq!(xs, [5u8, ..20]);\n+        assert!(xs == [5u8, ..20]);\n     }\n }"}, {"sha": "7372d171de704e1281177d1197269afa609e1f5a", "filename": "src/libstd/rand/distributions/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Flibstd%2Frand%2Fdistributions%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Flibstd%2Frand%2Fdistributions%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fdistributions%2Fmod.rs?ref=02882fbd7edcb8d0d152afcdc8571216efcbd664", "patch": "@@ -257,7 +257,7 @@ mod tests {\n     use rand::*;\n     use super::*;\n \n-    #[deriving(Eq)]\n+    #[deriving(Eq, Show)]\n     struct ConstRand(uint);\n     impl Rand for ConstRand {\n         fn rand<R: Rng>(_: &mut R) -> ConstRand {"}, {"sha": "4c9a8f7f9a2d491763c7258f54351f537a4b347f", "filename": "src/libstd/rand/reader.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Flibstd%2Frand%2Freader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Flibstd%2Frand%2Freader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Freader.rs?ref=02882fbd7edcb8d0d152afcdc8571216efcbd664", "patch": "@@ -111,7 +111,7 @@ mod test {\n         let mut rng = ReaderRng::new(MemReader::new(v.to_owned()));\n         rng.fill_bytes(w);\n \n-        assert_eq!(v, w);\n+        assert!(v == w);\n     }\n \n     #[test]"}, {"sha": "5131c684795b4a11961e31e6da5a5222db88f6b9", "filename": "src/libstd/str.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=02882fbd7edcb8d0d152afcdc8571216efcbd664", "patch": "@@ -858,7 +858,7 @@ pub struct UTF16Items<'a> {\n     priv iter: vec::Items<'a, u16>\n }\n /// The possibilities for values decoded from a `u16` stream.\n-#[deriving(Eq, TotalEq, Clone)]\n+#[deriving(Eq, TotalEq, Clone, Show)]\n pub enum UTF16Item {\n     /// A valid codepoint.\n     ScalarValue(char),\n@@ -3743,7 +3743,7 @@ mod tests {\n         ];\n         assert_eq!(\"\".as_bytes(), &[]);\n         assert_eq!(\"abc\".as_bytes(), &['a' as u8, 'b' as u8, 'c' as u8]);\n-        assert_eq!(\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".as_bytes(), v);\n+        assert_eq!(\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".as_bytes(), v.as_slice());\n     }\n \n     #[test]\n@@ -4442,11 +4442,11 @@ mod tests {\n         assert!(o.lt(&Slice(\"bcdef\")));\n         assert_eq!(Owned(~\"\"), Default::default());\n \n-        assert_eq!(s.cmp(&o), Equal);\n+        assert!(s.cmp(&o) == Equal);\n         assert!(s.equals(&o));\n         assert!(s.equiv(&o));\n \n-        assert_eq!(o.cmp(&s), Equal);\n+        assert!(o.cmp(&s) == Equal);\n         assert!(o.equals(&s));\n         assert!(o.equiv(&s));\n     }"}, {"sha": "1cd6920612e14843c537d733f5153079e9174214", "filename": "src/libstd/sync/deque.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Flibstd%2Fsync%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Flibstd%2Fsync%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fdeque.rs?ref=02882fbd7edcb8d0d152afcdc8571216efcbd664", "patch": "@@ -97,7 +97,7 @@ pub struct Stealer<T> {\n }\n \n /// When stealing some data, this is an enumeration of the possible outcomes.\n-#[deriving(Eq)]\n+#[deriving(Eq, Show)]\n pub enum Stolen<T> {\n     /// The deque was empty at the time of stealing\n     Empty,"}, {"sha": "e9125dde01172d87f0b00d0d397c7f64157b74f5", "filename": "src/libstd/tuple.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Flibstd%2Ftuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Flibstd%2Ftuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftuple.rs?ref=02882fbd7edcb8d0d152afcdc8571216efcbd664", "patch": "@@ -345,10 +345,10 @@ mod tests {\n         assert!(!big.equals(&small));\n \n         // TotalOrd\n-        assert_eq!(small.cmp(&small), Equal);\n-        assert_eq!(big.cmp(&big), Equal);\n-        assert_eq!(small.cmp(&big), Less);\n-        assert_eq!(big.cmp(&small), Greater);\n+        assert!(small.cmp(&small) == Equal);\n+        assert!(big.cmp(&big) == Equal);\n+        assert!(small.cmp(&big) == Less);\n+        assert!(big.cmp(&small) == Greater);\n     }\n \n     #[test]"}, {"sha": "6a4f1871b8644ad0dbd43cf9037d2522d4f6c79f", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 42, "deletions": 43, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=02882fbd7edcb8d0d152afcdc8571216efcbd664", "patch": "@@ -2127,7 +2127,7 @@ pub trait MutableVector<'a, T> {\n     /// ```rust\n     /// let mut v = [\"a\", \"b\", \"c\", \"d\"];\n     /// v.swap(1, 3);\n-    /// assert_eq!(v, [\"a\", \"d\", \"c\", \"b\"]);\n+    /// assert!(v == [\"a\", \"d\", \"c\", \"b\"]);\n     /// ```\n     fn swap(self, a: uint, b: uint);\n \n@@ -2148,24 +2148,23 @@ pub trait MutableVector<'a, T> {\n     /// // scoped to restrict the lifetime of the borrows\n     /// {\n     ///    let (left, right) = v.mut_split_at(0);\n-    ///    assert_eq!(left, &mut []);\n-    ///    assert_eq!(right, &mut [1, 2, 3, 4, 5, 6]);\n+    ///    assert!(left == &mut []);\n+    ///    assert!(right == &mut [1, 2, 3, 4, 5, 6]);\n     /// }\n     ///\n     /// {\n     ///     let (left, right) = v.mut_split_at(2);\n-    ///     assert_eq!(left, &mut [1, 2]);\n-    ///     assert_eq!(right, &mut [3, 4, 5, 6]);\n+    ///     assert!(left == &mut [1, 2]);\n+    ///     assert!(right == &mut [3, 4, 5, 6]);\n     /// }\n     ///\n     /// {\n     ///     let (left, right) = v.mut_split_at(6);\n-    ///     assert_eq!(left, &mut [1, 2, 3, 4, 5, 6]);\n-    ///     assert_eq!(right, &mut []);\n+    ///     assert!(left == &mut [1, 2, 3, 4, 5, 6]);\n+    ///     assert!(right == &mut []);\n     /// }\n     /// ```\n-    fn mut_split_at(self, mid: uint) -> (&'a mut [T],\n-                                      &'a mut [T]);\n+    fn mut_split_at(self, mid: uint) -> (&'a mut [T], &'a mut [T]);\n \n     /// Reverse the order of elements in a vector, in place.\n     ///\n@@ -2174,7 +2173,7 @@ pub trait MutableVector<'a, T> {\n     /// ```rust\n     /// let mut v = [1, 2, 3];\n     /// v.reverse();\n-    /// assert_eq!(v, [3, 2, 1]);\n+    /// assert!(v == [3, 2, 1]);\n     /// ```\n     fn reverse(self);\n \n@@ -2189,11 +2188,11 @@ pub trait MutableVector<'a, T> {\n     /// ```rust\n     /// let mut v = [5i, 4, 1, 3, 2];\n     /// v.sort_by(|a, b| a.cmp(b));\n-    /// assert_eq!(v, [1, 2, 3, 4, 5]);\n+    /// assert!(v == [1, 2, 3, 4, 5]);\n     ///\n     /// // reverse sorting\n     /// v.sort_by(|a, b| b.cmp(a));\n-    /// assert_eq!(v, [5, 4, 3, 2, 1]);\n+    /// assert!(v == [5, 4, 3, 2, 1]);\n     /// ```\n     fn sort_by(self, compare: |&T, &T| -> Ordering);\n \n@@ -2434,12 +2433,12 @@ pub trait MutableCloneableVector<T> {\n     /// let mut dst = [0, 0, 0];\n     /// let src = [1, 2];\n     ///\n-    /// assert_eq!(dst.copy_from(src), 2);\n-    /// assert_eq!(dst, [1, 2, 0]);\n+    /// assert!(dst.copy_from(src) == 2);\n+    /// assert!(dst == [1, 2, 0]);\n     ///\n     /// let src2 = [3, 4, 5, 6];\n-    /// assert_eq!(dst.copy_from(src2), 3);\n-    /// assert_eq!(dst, [3, 4, 5]);\n+    /// assert!(dst.copy_from(src2) == 3);\n+    /// assert!(dst == [3, 4, 5]);\n     /// ```\n     fn copy_from(self, &[T]) -> uint;\n }\n@@ -2467,7 +2466,7 @@ pub trait MutableTotalOrdVector<T> {\n     /// let mut v = [-5, 4, 1, -3, 2];\n     ///\n     /// v.sort();\n-    /// assert_eq!(v, [-5, -3, 1, 2, 4]);\n+    /// assert!(v == [-5, -3, 1, 2, 4]);\n     /// ```\n     fn sort(self);\n }\n@@ -3391,12 +3390,12 @@ mod tests {\n         for (i, (a, b)) in ElementSwaps::new(v.len()).enumerate() {\n             v.swap(a, b);\n             match i {\n-                0 => assert_eq!(v, [1, 3, 2]),\n-                1 => assert_eq!(v, [3, 1, 2]),\n-                2 => assert_eq!(v, [3, 2, 1]),\n-                3 => assert_eq!(v, [2, 3, 1]),\n-                4 => assert_eq!(v, [2, 1, 3]),\n-                5 => assert_eq!(v, [1, 2, 3]),\n+                0 => assert!(v == [1, 3, 2]),\n+                1 => assert!(v == [3, 1, 2]),\n+                2 => assert!(v == [3, 2, 1]),\n+                3 => assert!(v == [2, 3, 1]),\n+                4 => assert!(v == [2, 1, 3]),\n+                5 => assert!(v == [1, 2, 3]),\n                 _ => fail!(),\n             }\n         }\n@@ -3530,7 +3529,7 @@ mod tests {\n \n         let mut v = [0xDEADBEEFu];\n         v.sort();\n-        assert_eq!(v, [0xDEADBEEF]);\n+        assert!(v == [0xDEADBEEF]);\n     }\n \n     #[test]\n@@ -3896,7 +3895,7 @@ mod tests {\n         for x in xs.mut_iter() {\n             *x += 1;\n         }\n-        assert_eq!(xs, [2, 3, 4, 5, 6])\n+        assert!(xs == [2, 3, 4, 5, 6])\n     }\n \n     #[test]\n@@ -3920,7 +3919,7 @@ mod tests {\n         for (i,x) in xs.mut_rev_iter().enumerate() {\n             *x += i;\n         }\n-        assert_eq!(xs, [5, 5, 5, 5, 5])\n+        assert!(xs == [5, 5, 5, 5, 5])\n     }\n \n     #[test]\n@@ -4048,38 +4047,38 @@ mod tests {\n         let mut a = [1,2,3,4,5];\n         let b = ~[6,7,8];\n         assert_eq!(a.move_from(b, 0, 3), 3);\n-        assert_eq!(a, [6,7,8,4,5]);\n+        assert!(a == [6,7,8,4,5]);\n         let mut a = [7,2,8,1];\n         let b = ~[3,1,4,1,5,9];\n         assert_eq!(a.move_from(b, 0, 6), 4);\n-        assert_eq!(a, [3,1,4,1]);\n+        assert!(a == [3,1,4,1]);\n         let mut a = [1,2,3,4];\n         let b = ~[5,6,7,8,9,0];\n         assert_eq!(a.move_from(b, 2, 3), 1);\n-        assert_eq!(a, [7,2,3,4]);\n+        assert!(a == [7,2,3,4]);\n         let mut a = [1,2,3,4,5];\n         let b = ~[5,6,7,8,9,0];\n         assert_eq!(a.mut_slice(2,4).move_from(b,1,6), 2);\n-        assert_eq!(a, [1,2,6,7,5]);\n+        assert!(a == [1,2,6,7,5]);\n     }\n \n     #[test]\n     fn test_copy_from() {\n         let mut a = [1,2,3,4,5];\n         let b = [6,7,8];\n         assert_eq!(a.copy_from(b), 3);\n-        assert_eq!(a, [6,7,8,4,5]);\n+        assert!(a == [6,7,8,4,5]);\n         let mut c = [7,2,8,1];\n         let d = [3,1,4,1,5,9];\n         assert_eq!(c.copy_from(d), 4);\n-        assert_eq!(c, [3,1,4,1]);\n+        assert!(c == [3,1,4,1]);\n     }\n \n     #[test]\n     fn test_reverse_part() {\n         let mut values = [1,2,3,4,5];\n         values.mut_slice(1, 4).reverse();\n-        assert_eq!(values, [1,4,3,2,5]);\n+        assert!(values == [1,4,3,2,5]);\n     }\n \n     #[test]\n@@ -4117,9 +4116,9 @@ mod tests {\n         use vec::bytes::MutableByteVector;\n         let mut values = [1u8,2,3,4,5];\n         values.mut_slice(0,5).set_memory(0xAB);\n-        assert_eq!(values, [0xAB, 0xAB, 0xAB, 0xAB, 0xAB]);\n+        assert!(values == [0xAB, 0xAB, 0xAB, 0xAB, 0xAB]);\n         values.mut_slice(2,4).set_memory(0xFF);\n-        assert_eq!(values, [0xAB, 0xAB, 0xFF, 0xFF, 0xAB]);\n+        assert!(values == [0xAB, 0xAB, 0xFF, 0xFF, 0xAB]);\n     }\n \n     #[test]\n@@ -4145,18 +4144,18 @@ mod tests {\n         let mut values = [1u8,2,3,4,5];\n         {\n             let (left, right) = values.mut_split_at(2);\n-            assert_eq!(left.slice(0, left.len()), [1, 2]);\n+            assert!(left.slice(0, left.len()) == [1, 2]);\n             for p in left.mut_iter() {\n                 *p += 1;\n             }\n \n-            assert_eq!(right.slice(0, right.len()), [3, 4, 5]);\n+            assert!(right.slice(0, right.len()) == [3, 4, 5]);\n             for p in right.mut_iter() {\n                 *p += 2;\n             }\n         }\n \n-        assert_eq!(values, [2, 3, 5, 6, 7]);\n+        assert!(values == [2, 3, 5, 6, 7]);\n     }\n \n     #[deriving(Clone, Eq)]\n@@ -4280,13 +4279,13 @@ mod tests {\n         for slice in xs.mut_split(|x| *x == 0) {\n             slice.reverse();\n         }\n-        assert_eq!(xs, [0,1,0,3,2,0,0,5,4,0]);\n+        assert!(xs == [0,1,0,3,2,0,0,5,4,0]);\n \n         let mut xs = [0,1,0,2,3,0,0,4,5,0,6,7];\n         for slice in xs.mut_split(|x| *x == 0).take(5) {\n             slice.reverse();\n         }\n-        assert_eq!(xs, [0,1,0,3,2,0,0,5,4,0,6,7]);\n+        assert!(xs == [0,1,0,3,2,0,0,5,4,0,6,7]);\n     }\n \n     #[test]\n@@ -4295,7 +4294,7 @@ mod tests {\n         for slice in xs.mut_split(|x| *x == 0).rev().take(4) {\n             slice.reverse();\n         }\n-        assert_eq!(xs, [1,2,0,4,3,0,0,6,5,0]);\n+        assert!(xs == [1,2,0,4,3,0,0,6,5,0]);\n     }\n \n     #[test]\n@@ -4307,7 +4306,7 @@ mod tests {\n             }\n         }\n         let result = [0u8, 0, 0, 1, 1, 1, 2];\n-        assert_eq!(v, result);\n+        assert!(v == result);\n     }\n \n     #[test]\n@@ -4319,7 +4318,7 @@ mod tests {\n             }\n         }\n         let result = [2u8, 2, 2, 1, 1, 1, 0];\n-        assert_eq!(v, result);\n+        assert!(v == result);\n     }\n \n     #[test]"}, {"sha": "9938f20927a3e4094d2a944ecfdbfcc667bc7929", "filename": "src/libsync/sync/mutex.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Flibsync%2Fsync%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Flibsync%2Fsync%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fsync%2Fmutex.rs?ref=02882fbd7edcb8d0d152afcdc8571216efcbd664", "patch": "@@ -94,7 +94,7 @@ pub struct Mutex {\n     priv lock: StaticMutex,\n }\n \n-#[deriving(Eq)]\n+#[deriving(Eq, Show)]\n enum Flavor {\n     Unlocked,\n     TryLockAcquisition,"}, {"sha": "4cf4aefa0e2a8e334e435abbbdb5e379fbaa7d7e", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=02882fbd7edcb8d0d152afcdc8571216efcbd664", "patch": "@@ -979,7 +979,7 @@ mod test {\n \n     // because of the SCTable, I now need a tidy way of\n     // creating syntax objects. Sigh.\n-    #[deriving(Clone, Eq)]\n+    #[deriving(Clone, Eq, Show)]\n     enum TestSC {\n         M(Mrk),\n         R(Ident,Name)\n@@ -1024,9 +1024,9 @@ mod test {\n         assert_eq!(unfold_test_sc(test_sc.clone(),EMPTY_CTXT,&mut t),4);\n         {\n             let table = t.table.borrow();\n-            assert_eq!(table.get()[2],Mark(9,0));\n-            assert_eq!(table.get()[3],Rename(id(101,0),14,2));\n-            assert_eq!(table.get()[4],Mark(3,3));\n+            assert!(table.get()[2] == Mark(9,0));\n+            assert!(table.get()[3] == Rename(id(101,0),14,2));\n+            assert!(table.get()[4] == Mark(3,3));\n         }\n         assert_eq!(refold_test_sc(4,&t),test_sc);\n     }\n@@ -1045,8 +1045,8 @@ mod test {\n         assert_eq!(unfold_marks(~[3,7],EMPTY_CTXT,&mut t),3);\n         {\n             let table = t.table.borrow();\n-            assert_eq!(table.get()[2],Mark(7,0));\n-            assert_eq!(table.get()[3],Mark(3,2));\n+            assert!(table.get()[2] == Mark(7,0));\n+            assert!(table.get()[3] == Mark(3,2));\n         }\n     }\n "}, {"sha": "6a3ca911d7657b9452286679e7d6d08326458488", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=02882fbd7edcb8d0d152afcdc8571216efcbd664", "patch": "@@ -455,7 +455,7 @@ fn int_type_of_word(s: &str) -> Option<IntType> {\n     }\n }\n \n-#[deriving(Eq)]\n+#[deriving(Eq, Show)]\n pub enum ReprAttr {\n     ReprAny,\n     ReprInt(Span, IntType),\n@@ -472,7 +472,7 @@ impl ReprAttr {\n     }\n }\n \n-#[deriving(Eq)]\n+#[deriving(Eq, Show)]\n pub enum IntType {\n     SignedInt(ast::IntTy),\n     UnsignedInt(ast::UintTy)"}, {"sha": "d114d8971f7474c9ba6ab035c4cb0e668059126d", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=02882fbd7edcb8d0d152afcdc8571216efcbd664", "patch": "@@ -32,13 +32,13 @@ pub trait Pos {\n \n /// A byte offset. Keep this small (currently 32-bits), as AST contains\n /// a lot of them.\n-#[deriving(Clone, Eq, Hash, Ord)]\n+#[deriving(Clone, Eq, Hash, Ord, Show)]\n pub struct BytePos(u32);\n \n /// A character offset. Because of multibyte utf8 characters, a byte offset\n /// is not equivalent to a character offset. The CodeMap will convert BytePos\n /// values to CharPos values as necessary.\n-#[deriving(Eq, Hash, Ord)]\n+#[deriving(Eq, Hash, Ord, Show)]\n pub struct CharPos(uint);\n \n // FIXME: Lots of boilerplate in these impls, but so far my attempts to fix\n@@ -84,7 +84,7 @@ are *absolute* positions from the beginning of the codemap, not positions\n relative to FileMaps. Methods on the CodeMap can be used to relate spans back\n to the original source.\n */\n-#[deriving(Clone, Hash)]\n+#[deriving(Clone, Show, Hash)]\n pub struct Span {\n     lo: BytePos,\n     hi: BytePos,\n@@ -160,15 +160,15 @@ pub struct LocWithOpt {\n pub struct FileMapAndLine {fm: @FileMap, line: uint}\n pub struct FileMapAndBytePos {fm: @FileMap, pos: BytePos}\n \n-#[deriving(Clone, Hash)]\n+#[deriving(Clone, Hash, Show)]\n pub enum MacroFormat {\n     // e.g. #[deriving(...)] <item>\n     MacroAttribute,\n     // e.g. `format!()`\n     MacroBang\n }\n \n-#[deriving(Clone, Hash)]\n+#[deriving(Clone, Hash, Show)]\n pub struct NameAndSpan {\n     name: ~str,\n     // the format with which the macro was invoked.\n@@ -177,7 +177,7 @@ pub struct NameAndSpan {\n }\n \n /// Extra information for tracking macro expansion of spans\n-#[deriving(Hash)]\n+#[deriving(Hash, Show)]\n pub struct ExpnInfo {\n     call_site: Span,\n     callee: NameAndSpan"}, {"sha": "93fdcb41d2b24257a3d71707442e237bbecf71ef", "filename": "src/libsyntax/parse/lexer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Flibsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Flibsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer.rs?ref=02882fbd7edcb8d0d152afcdc8571216efcbd664", "patch": "@@ -32,7 +32,7 @@ pub trait Reader {\n     fn dup(&self) -> ~Reader:;\n }\n \n-#[deriving(Clone, Eq)]\n+#[deriving(Clone, Eq, Show)]\n pub struct TokenAndSpan {\n     tok: token::Token,\n     sp: Span,"}, {"sha": "6bcb7afb120beec803a34d473b0c45bb0b1dc5e7", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=02882fbd7edcb8d0d152afcdc8571216efcbd664", "patch": "@@ -312,7 +312,7 @@ mod test {\n     }\n \n     #[test] fn path_exprs_1() {\n-        assert_eq!(string_to_expr(~\"a\"),\n+        assert!(string_to_expr(~\"a\") ==\n                    @ast::Expr{\n                     id: ast::DUMMY_NODE_ID,\n                     node: ast::ExprPath(ast::Path {\n@@ -331,7 +331,7 @@ mod test {\n     }\n \n     #[test] fn path_exprs_2 () {\n-        assert_eq!(string_to_expr(~\"::a::b\"),\n+        assert!(string_to_expr(~\"::a::b\") ==\n                    @ast::Expr {\n                     id: ast::DUMMY_NODE_ID,\n                     node: ast::ExprPath(ast::Path {\n@@ -542,7 +542,7 @@ mod test {\n     }\n \n     #[test] fn ret_expr() {\n-        assert_eq!(string_to_expr(~\"return d\"),\n+        assert!(string_to_expr(~\"return d\") ==\n                    @ast::Expr{\n                     id: ast::DUMMY_NODE_ID,\n                     node:ast::ExprRet(Some(@ast::Expr{\n@@ -565,7 +565,7 @@ mod test {\n     }\n \n     #[test] fn parse_stmt_1 () {\n-        assert_eq!(string_to_stmt(~\"b;\"),\n+        assert!(string_to_stmt(~\"b;\") ==\n                    @Spanned{\n                        node: ast::StmtExpr(@ast::Expr {\n                            id: ast::DUMMY_NODE_ID,\n@@ -592,7 +592,7 @@ mod test {\n \n     #[test] fn parse_ident_pat () {\n         let mut parser = string_to_parser(~\"b\");\n-        assert_eq!(parser.parse_pat(),\n+        assert!(parser.parse_pat() ==\n                    @ast::Pat{id: ast::DUMMY_NODE_ID,\n                              node: ast::PatIdent(\n                                 ast::BindByValue(ast::MutImmutable),\n@@ -615,7 +615,7 @@ mod test {\n     // check the contents of the tt manually:\n     #[test] fn parse_fundecl () {\n         // this test depends on the intern order of \"fn\" and \"int\"\n-        assert_eq!(string_to_item(~\"fn a (b : int) { b; }\"),\n+        assert!(string_to_item(~\"fn a (b : int) { b; }\") ==\n                   Some(\n                       @ast::Item{ident:str_to_ident(\"a\"),\n                             attrs:~[],"}, {"sha": "edc5e613f9116e8da966e98883fed265ec8a1520", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 20, "deletions": 2, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=02882fbd7edcb8d0d152afcdc8571216efcbd664", "patch": "@@ -23,7 +23,7 @@ use std::local_data;\n use std::path::BytesContainer;\n \n #[allow(non_camel_case_types)]\n-#[deriving(Clone, Encodable, Decodable, Eq, Hash)]\n+#[deriving(Clone, Encodable, Decodable, Eq, Hash, Show)]\n pub enum BinOp {\n     PLUS,\n     MINUS,\n@@ -38,7 +38,7 @@ pub enum BinOp {\n }\n \n #[allow(non_camel_case_types)]\n-#[deriving(Clone, Encodable, Decodable, Eq, Hash)]\n+#[deriving(Clone, Encodable, Decodable, Eq, Hash, Show)]\n pub enum Token {\n     /* Expression-operator symbols. */\n     EQ,\n@@ -118,6 +118,24 @@ pub enum Nonterminal {\n     NtMatchers(~[ast::Matcher])\n }\n \n+impl fmt::Show for Nonterminal {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        match *self {\n+            NtItem(..) => f.pad(\"NtItem(..)\"),\n+            NtBlock(..) => f.pad(\"NtBlock(..)\"),\n+            NtStmt(..) => f.pad(\"NtStmt(..)\"),\n+            NtPat(..) => f.pad(\"NtPat(..)\"),\n+            NtExpr(..) => f.pad(\"NtExpr(..)\"),\n+            NtTy(..) => f.pad(\"NtTy(..)\"),\n+            NtIdent(..) => f.pad(\"NtIdent(..)\"),\n+            NtAttr(..) => f.pad(\"NtAttr(..)\"),\n+            NtPath(..) => f.pad(\"NtPath(..)\"),\n+            NtTT(..) => f.pad(\"NtTT(..)\"),\n+            NtMatchers(..) => f.pad(\"NtMatchers(..)\"),\n+        }\n+    }\n+}\n+\n pub fn binop_to_str(o: BinOp) -> ~str {\n     match o {\n       PLUS => ~\"+\","}, {"sha": "7b885df0317ee123dbf32a9387700efd24a5db46", "filename": "src/libsyntax/util/interner.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Flibsyntax%2Futil%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Flibsyntax%2Futil%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Finterner.rs?ref=02882fbd7edcb8d0d152afcdc8571216efcbd664", "patch": "@@ -18,6 +18,7 @@ use collections::HashMap;\n use std::cast;\n use std::cell::RefCell;\n use std::cmp::Equiv;\n+use std::fmt;\n use std::hash::Hash;\n use std::rc::Rc;\n \n@@ -114,6 +115,13 @@ impl Str for RcStr {\n     }\n }\n \n+impl fmt::Show for RcStr {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        use std::fmt::Show;\n+        self.as_slice().fmt(f)\n+    }\n+}\n+\n impl RcStr {\n     pub fn new(string: &str) -> RcStr {\n         RcStr {"}, {"sha": "3162fe02a0facb2cef83510bc2173ae25a1ee7a4", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=02882fbd7edcb8d0d152afcdc8571216efcbd664", "patch": "@@ -163,7 +163,7 @@ pub struct TestDescAndFn {\n     testfn: TestFn,\n }\n \n-#[deriving(Clone, Encodable, Decodable, Eq)]\n+#[deriving(Clone, Encodable, Decodable, Eq, Show)]\n pub struct Metric {\n     priv value: f64,\n     priv noise: f64\n@@ -186,7 +186,7 @@ impl Clone for MetricMap {\n }\n \n /// Analysis of a single change in metric\n-#[deriving(Eq)]\n+#[deriving(Eq, Show)]\n pub enum MetricChange {\n     LikelyNoise,\n     MetricAdded,\n@@ -1341,7 +1341,7 @@ mod tests {\n         let (p, ch) = Chan::new();\n         run_test(false, desc, ch);\n         let (_, res, _) = p.recv();\n-        assert_eq!(res, TrIgnored);\n+        assert!(res == TrIgnored);\n     }\n \n     #[test]\n@@ -1358,7 +1358,7 @@ mod tests {\n         let (p, ch) = Chan::new();\n         run_test(false, desc, ch);\n         let (_, res, _) = p.recv();\n-        assert_eq!(res, TrOk);\n+        assert!(res == TrOk);\n     }\n \n     #[test]\n@@ -1375,7 +1375,7 @@ mod tests {\n         let (p, ch) = Chan::new();\n         run_test(false, desc, ch);\n         let (_, res, _) = p.recv();\n-        assert_eq!(res, TrFailed);\n+        assert!(res == TrFailed);\n     }\n \n     #[test]"}, {"sha": "fb09ee0923a4c2b2d3c7deb903029b0f79e7db15", "filename": "src/libtime/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Flibtime%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Flibtime%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtime%2Flib.rs?ref=02882fbd7edcb8d0d152afcdc8571216efcbd664", "patch": "@@ -64,7 +64,7 @@ mod imp {\n /// A record specifying a time value in seconds and nanoseconds.\n \n \n-#[deriving(Clone, DeepClone, Eq, Encodable, Decodable)]\n+#[deriving(Clone, DeepClone, Eq, Encodable, Decodable, Show)]\n pub struct Timespec { sec: i64, nsec: i32 }\n /*\n  * Timespec assumes that pre-epoch Timespecs have negative sec and positive\n@@ -191,7 +191,7 @@ pub fn tzset() {\n     }\n }\n \n-#[deriving(Clone, DeepClone, Eq, Encodable, Decodable)]\n+#[deriving(Clone, DeepClone, Eq, Encodable, Decodable, Show)]\n pub struct Tm {\n     tm_sec: i32, // seconds after the minute ~[0-60]\n     tm_min: i32, // minutes after the hour ~[0-59]\n@@ -1138,7 +1138,7 @@ mod tests {\n         let time = Timespec::new(1234567890, 54321);\n         let local = at(time);\n \n-        error!(\"time_at: {:?}\", local);\n+        debug!(\"time_at: {:?}\", local);\n \n         assert_eq!(local.tm_sec, 30_i32);\n         assert_eq!(local.tm_min, 31_i32);\n@@ -1355,7 +1355,7 @@ mod tests {\n         let utc   = at_utc(time);\n         let local = at(time);\n \n-        error!(\"test_ctime: {:?} {:?}\", utc.ctime(), local.ctime());\n+        debug!(\"test_ctime: {:?} {:?}\", utc.ctime(), local.ctime());\n \n         assert_eq!(utc.ctime(), ~\"Fri Feb 13 23:31:30 2009\");\n         assert_eq!(local.ctime(), ~\"Fri Feb 13 15:31:30 2009\");"}, {"sha": "6c98cd11169f554a18c1e9901b13bfd022d1482d", "filename": "src/test/auxiliary/trait_inheritance_overloading_xc.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Ftest%2Fauxiliary%2Ftrait_inheritance_overloading_xc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Ftest%2Fauxiliary%2Ftrait_inheritance_overloading_xc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Ftrait_inheritance_overloading_xc.rs?ref=02882fbd7edcb8d0d152afcdc8571216efcbd664", "patch": "@@ -13,6 +13,7 @@ use std::cmp::Eq;\n pub trait MyNum : Add<Self,Self> + Sub<Self,Self> + Mul<Self,Self> + Eq {\n }\n \n+#[deriving(Show)]\n pub struct MyInt {\n     val: int\n }"}, {"sha": "f7389f65067165340ce0ca832f3a931c76d02556", "filename": "src/test/run-pass/assert-eq-macro-success.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Ftest%2Frun-pass%2Fassert-eq-macro-success.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Ftest%2Frun-pass%2Fassert-eq-macro-success.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassert-eq-macro-success.rs?ref=02882fbd7edcb8d0d152afcdc8571216efcbd664", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[deriving(Eq)]\n+#[deriving(Eq, Show)]\n struct Point { x : int }\n \n pub fn main() {"}, {"sha": "233509a8cd2a87ff9b7140afffdf39ddb064c5c8", "filename": "src/test/run-pass/binops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Ftest%2Frun-pass%2Fbinops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Ftest%2Frun-pass%2Fbinops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbinops.rs?ref=02882fbd7edcb8d0d152afcdc8571216efcbd664", "patch": "@@ -63,7 +63,7 @@ fn test_ptr() {\n     }\n }\n \n-#[deriving(Eq)]\n+#[deriving(Eq, Show)]\n struct p {\n   x: int,\n   y: int,"}, {"sha": "b9288a67f969f6d46c6e7ce35a54f512983cba37", "filename": "src/test/run-pass/class-impl-very-parameterized-trait.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Ftest%2Frun-pass%2Fclass-impl-very-parameterized-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Ftest%2Frun-pass%2Fclass-impl-very-parameterized-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-impl-very-parameterized-trait.rs?ref=02882fbd7edcb8d0d152afcdc8571216efcbd664", "patch": "@@ -12,6 +12,7 @@\n \n use std::cmp;\n \n+#[deriving(Show)]\n enum cat_type { tuxedo, tabby, tortoiseshell }\n \n impl cmp::Eq for cat_type {"}, {"sha": "075709b1c36a7f5f0f714b348c15fa450cb25100", "filename": "src/test/run-pass/coerce-to-closure-and-proc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Ftest%2Frun-pass%2Fcoerce-to-closure-and-proc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Ftest%2Frun-pass%2Fcoerce-to-closure-and-proc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcoerce-to-closure-and-proc.rs?ref=02882fbd7edcb8d0d152afcdc8571216efcbd664", "patch": "@@ -12,10 +12,10 @@ fn id<T>(x: T) -> T {\n     x\n }\n \n-#[deriving(Eq)]\n+#[deriving(Eq, Show)]\n struct Foo<T>(T);\n \n-#[deriving(Eq)]\n+#[deriving(Eq, Show)]\n enum Bar<T> {\n     Bar(T)\n }"}, {"sha": "f5f6b599dc906aed6af635dadd6e340b29f31d24", "filename": "src/test/run-pass/const-cross-crate-extern.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Ftest%2Frun-pass%2Fconst-cross-crate-extern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Ftest%2Frun-pass%2Fconst-cross-crate-extern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-cross-crate-extern.rs?ref=02882fbd7edcb8d0d152afcdc8571216efcbd664", "patch": "@@ -16,5 +16,5 @@ use cci_const::bar;\n static foo: extern \"C\" fn() = bar;\n \n pub fn main() {\n-    assert_eq!(foo, bar);\n+    assert!(foo == bar);\n }"}, {"sha": "be7c47dafc01746015183c331e0d4b1f4fb0fc79", "filename": "src/test/run-pass/const-extern-function.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Ftest%2Frun-pass%2Fconst-extern-function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Ftest%2Frun-pass%2Fconst-extern-function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-extern-function.rs?ref=02882fbd7edcb8d0d152afcdc8571216efcbd664", "patch": "@@ -18,6 +18,6 @@ struct S {\n }\n \n pub fn main() {\n-    assert_eq!(foopy, f);\n-    assert_eq!(f, s.f);\n+    assert!(foopy == f);\n+    assert!(f == s.f);\n }"}, {"sha": "4508295b1ccefab5154f4ce4b3498105e98346a2", "filename": "src/test/run-pass/const-struct.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Ftest%2Frun-pass%2Fconst-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Ftest%2Frun-pass%2Fconst-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-struct.rs?ref=02882fbd7edcb8d0d152afcdc8571216efcbd664", "patch": "@@ -10,6 +10,7 @@\n \n use std::cmp;\n \n+#[deriving(Show)]\n struct foo { a: int, b: int, c: int }\n \n impl cmp::Eq for foo {"}, {"sha": "e90d7c803aa3b3caf46f1761f509a7ebeed10552", "filename": "src/test/run-pass/deriving-primitive.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Ftest%2Frun-pass%2Fderiving-primitive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Ftest%2Frun-pass%2Fderiving-primitive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-primitive.rs?ref=02882fbd7edcb8d0d152afcdc8571216efcbd664", "patch": "@@ -11,7 +11,7 @@\n use std::num::FromPrimitive;\n use std::int;\n \n-#[deriving(Eq, FromPrimitive)]\n+#[deriving(Eq, FromPrimitive, Show)]\n enum A {\n     Foo = int::MAX,\n     Bar = 1,"}, {"sha": "8fbff8f8f31bc607be7c091b23c2a0377311e637", "filename": "src/test/run-pass/deriving-via-extension-c-enum.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Ftest%2Frun-pass%2Fderiving-via-extension-c-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Ftest%2Frun-pass%2Fderiving-via-extension-c-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-via-extension-c-enum.rs?ref=02882fbd7edcb8d0d152afcdc8571216efcbd664", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[deriving(Eq)]\n+#[deriving(Eq, Show)]\n enum Foo {\n     Bar,\n     Baz,"}, {"sha": "74d530b93ffd743930070b5017293260eee7ddc4", "filename": "src/test/run-pass/deriving-via-extension-enum.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Ftest%2Frun-pass%2Fderiving-via-extension-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Ftest%2Frun-pass%2Fderiving-via-extension-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-via-extension-enum.rs?ref=02882fbd7edcb8d0d152afcdc8571216efcbd664", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[deriving(Eq)]\n+#[deriving(Eq, Show)]\n enum Foo {\n     Bar(int, int),\n     Baz(f64, f64)"}, {"sha": "f7c711e27d0a30d74646e0f815058b322557968a", "filename": "src/test/run-pass/deriving-via-extension-struct-empty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Ftest%2Frun-pass%2Fderiving-via-extension-struct-empty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Ftest%2Frun-pass%2Fderiving-via-extension-struct-empty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-via-extension-struct-empty.rs?ref=02882fbd7edcb8d0d152afcdc8571216efcbd664", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[deriving(Eq)]\n+#[deriving(Eq, Show)]\n struct Foo;\n \n pub fn main() {"}, {"sha": "78768ca52b9516e0b62919ef7240f5385a751219", "filename": "src/test/run-pass/deriving-via-extension-struct-like-enum-variant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Ftest%2Frun-pass%2Fderiving-via-extension-struct-like-enum-variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Ftest%2Frun-pass%2Fderiving-via-extension-struct-like-enum-variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-via-extension-struct-like-enum-variant.rs?ref=02882fbd7edcb8d0d152afcdc8571216efcbd664", "patch": "@@ -10,7 +10,7 @@\n \n #[feature(struct_variant)];\n \n-#[deriving(Eq)]\n+#[deriving(Eq, Show)]\n enum S {\n     X { x: int, y: int },\n     Y"}, {"sha": "39c23914abcb98d6005fb030a682dca81e38d568", "filename": "src/test/run-pass/deriving-via-extension-struct-tuple.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Ftest%2Frun-pass%2Fderiving-via-extension-struct-tuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Ftest%2Frun-pass%2Fderiving-via-extension-struct-tuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-via-extension-struct-tuple.rs?ref=02882fbd7edcb8d0d152afcdc8571216efcbd664", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[deriving(Eq)]\n+#[deriving(Eq, Show)]\n struct Foo(int, int, ~str);\n \n pub fn main() {"}, {"sha": "db36623186064da5d83a1fe3d48d5deafbad4e1b", "filename": "src/test/run-pass/deriving-via-extension-struct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Ftest%2Frun-pass%2Fderiving-via-extension-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Ftest%2Frun-pass%2Fderiving-via-extension-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-via-extension-struct.rs?ref=02882fbd7edcb8d0d152afcdc8571216efcbd664", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[deriving(Eq)]\n+#[deriving(Eq, Show)]\n struct Foo {\n     x: int,\n     y: int,"}, {"sha": "077d82ec6dc8532962a406823cacb793fae0561a", "filename": "src/test/run-pass/deriving-via-extension-type-params.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Ftest%2Frun-pass%2Fderiving-via-extension-type-params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Ftest%2Frun-pass%2Fderiving-via-extension-type-params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-via-extension-type-params.rs?ref=02882fbd7edcb8d0d152afcdc8571216efcbd664", "patch": "@@ -10,7 +10,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[deriving(Eq, Hash)]\n+#[deriving(Eq, Hash, Show)]\n struct Foo<T> {\n     x: int,\n     y: T,"}, {"sha": "b79de737ce02b0ea6b30e007547ec5e0d6aa66b5", "filename": "src/test/run-pass/empty-tag.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Ftest%2Frun-pass%2Fempty-tag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Ftest%2Frun-pass%2Fempty-tag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fempty-tag.rs?ref=02882fbd7edcb8d0d152afcdc8571216efcbd664", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#[deriving(Show)]\n enum chan { chan_t, }\n \n impl Eq for chan {"}, {"sha": "58e8a35fbfcd65ce9222e59e2e975f32a0d38b41", "filename": "src/test/run-pass/expr-if-struct.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Ftest%2Frun-pass%2Fexpr-if-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Ftest%2Frun-pass%2Fexpr-if-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-if-struct.rs?ref=02882fbd7edcb8d0d152afcdc8571216efcbd664", "patch": "@@ -21,6 +21,7 @@ fn test_rec() {\n     assert_eq!(rs.i, 100);\n }\n \n+#[deriving(Show)]\n enum mood { happy, sad, }\n \n impl Eq for mood {"}, {"sha": "93f0575b5a089e4fe374da57a0cd3fdf277a6857", "filename": "src/test/run-pass/expr-match-struct.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Ftest%2Frun-pass%2Fexpr-match-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Ftest%2Frun-pass%2Fexpr-match-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-match-struct.rs?ref=02882fbd7edcb8d0d152afcdc8571216efcbd664", "patch": "@@ -20,6 +20,7 @@ fn test_rec() {\n     assert_eq!(rs.i, 100);\n }\n \n+#[deriving(Show)]\n enum mood { happy, sad, }\n \n impl Eq for mood {"}, {"sha": "057394b2624fecc5b78a66251dc2d8f261e1c18f", "filename": "src/test/run-pass/extern-compare-with-return-type.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Ftest%2Frun-pass%2Fextern-compare-with-return-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Ftest%2Frun-pass%2Fextern-compare-with-return-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-compare-with-return-type.rs?ref=02882fbd7edcb8d0d152afcdc8571216efcbd664", "patch": "@@ -20,13 +20,13 @@ extern fn uintvoidret(_x: uint) {}\n extern fn uintuintuintuintret(x: uint, y: uint, z: uint) -> uint { x+y+z }\n \n pub fn main() {\n-    assert_eq!(voidret1, voidret1);\n+    assert!(voidret1 == voidret1);\n     assert!(voidret1 != voidret2);\n \n-    assert_eq!(uintret, uintret);\n+    assert!(uintret == uintret);\n \n-    assert_eq!(uintvoidret, uintvoidret);\n+    assert!(uintvoidret == uintvoidret);\n \n-    assert_eq!(uintuintuintuintret, uintuintuintuintret);\n+    assert!(uintuintuintuintret == uintuintuintuintret);\n }\n "}, {"sha": "ea093f1daaae63e5ca77dd2c64af0c25de0bb9e0", "filename": "src/test/run-pass/extern-pass-TwoU32s.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Ftest%2Frun-pass%2Fextern-pass-TwoU32s.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Ftest%2Frun-pass%2Fextern-pass-TwoU32s.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-pass-TwoU32s.rs?ref=02882fbd7edcb8d0d152afcdc8571216efcbd664", "patch": "@@ -11,7 +11,7 @@\n // Test a foreign function that accepts and returns a struct\n // by value.\n \n-#[deriving(Eq)]\n+#[deriving(Eq, Show)]\n struct TwoU32s {\n     one: u32, two: u32\n }"}, {"sha": "a716e038507724b997dd50c8a9925b535cb15e20", "filename": "src/test/run-pass/extern-pass-TwoU64s.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Ftest%2Frun-pass%2Fextern-pass-TwoU64s.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Ftest%2Frun-pass%2Fextern-pass-TwoU64s.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-pass-TwoU64s.rs?ref=02882fbd7edcb8d0d152afcdc8571216efcbd664", "patch": "@@ -13,7 +13,7 @@\n \n // ignore-win32 #9205\n \n-#[deriving(Eq)]\n+#[deriving(Eq, Show)]\n struct TwoU64s {\n     one: u64, two: u64\n }"}, {"sha": "1934ef8024fd4aead06bb52fc8f23b90e678a38f", "filename": "src/test/run-pass/extern-take-value.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Ftest%2Frun-pass%2Fextern-take-value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Ftest%2Frun-pass%2Fextern-take-value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-take-value.rs?ref=02882fbd7edcb8d0d152afcdc8571216efcbd664", "patch": "@@ -19,6 +19,6 @@ pub fn main() {\n     let b: extern \"C\" fn() = f;\n     let c: extern \"C\" fn() = g;\n \n-    assert_eq!(a, b);\n+    assert!(a == b);\n     assert!(a != c);\n }"}, {"sha": "8be8fcbdd5423deb1904e5d7128c7b20301fd1b3", "filename": "src/test/run-pass/generic-default-type-params.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Ftest%2Frun-pass%2Fgeneric-default-type-params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Ftest%2Frun-pass%2Fgeneric-default-type-params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-default-type-params.rs?ref=02882fbd7edcb8d0d152afcdc8571216efcbd664", "patch": "@@ -50,10 +50,10 @@ fn default_foo(x: Foo) {\n     assert_eq!(x.baz(), (1, 'a'));\n }\n \n-#[deriving(Eq)]\n+#[deriving(Eq, Show)]\n struct BazHelper<T>(T);\n \n-#[deriving(Eq)]\n+#[deriving(Eq, Show)]\n // Ensure that we can use previous type parameters in defaults.\n struct Baz<T, U = BazHelper<T>, V = Option<U>>(T, U, V);\n "}, {"sha": "39261094911c1737202216bf63b9c6b5b274c291", "filename": "src/test/run-pass/glob-std.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Ftest%2Frun-pass%2Fglob-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Ftest%2Frun-pass%2Fglob-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fglob-std.rs?ref=02882fbd7edcb8d0d152afcdc8571216efcbd664", "patch": "@@ -11,6 +11,8 @@\n // ignore-fast check-fast doesn't like 'extern crate extra'\n // ignore-win32 TempDir may cause IoError on windows: #10462\n \n+#[feature(macro_rules)];\n+\n extern crate extra;\n extern crate glob;\n \n@@ -20,6 +22,12 @@ use std::unstable::finally::Finally;\n use std::{os, unstable};\n use std::io;\n \n+macro_rules! assert_eq ( ($e1:expr, $e2:expr) => (\n+    if $e1 != $e2 {\n+        fail!(\"{} != {}\", stringify!($e1), stringify!($e2))\n+    }\n+) )\n+\n pub fn main() {\n     fn mk_file(path: &str, directory: bool) {\n         if directory {"}, {"sha": "7c2c1eab87bbb531c30f5ef4d04c575eba17cf83", "filename": "src/test/run-pass/issue-2718.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Ftest%2Frun-pass%2Fissue-2718.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Ftest%2Frun-pass%2Fissue-2718.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2718.rs?ref=02882fbd7edcb8d0d152afcdc8571216efcbd664", "patch": "@@ -26,7 +26,7 @@ pub mod pipes {\n         payload: Option<T>\n     }\n \n-    #[deriving(Eq)]\n+    #[deriving(Eq, Show)]\n     #[repr(int)]\n     pub enum state {\n         empty,"}, {"sha": "58d4d6a3dbac731b0fe51dc068fe6e1c1e55dd96", "filename": "src/test/run-pass/monomorphize-abi-alignment.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Ftest%2Frun-pass%2Fmonomorphize-abi-alignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Ftest%2Frun-pass%2Fmonomorphize-abi-alignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmonomorphize-abi-alignment.rs?ref=02882fbd7edcb8d0d152afcdc8571216efcbd664", "patch": "@@ -20,9 +20,9 @@\n \n struct S<T> { i:u8, t:T }\n impl<T> S<T> { fn unwrap(self) -> T { self.t } }\n-#[deriving(Eq)]\n+#[deriving(Eq, Show)]\n struct A((u32, u32));\n-#[deriving(Eq)]\n+#[deriving(Eq, Show)]\n struct B(u64);\n \n pub fn main() {"}, {"sha": "1ed93dd278b68dfe01b13c1c6ead13cc88c92218", "filename": "src/test/run-pass/newtype-temporary.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Ftest%2Frun-pass%2Fnewtype-temporary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Ftest%2Frun-pass%2Fnewtype-temporary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnewtype-temporary.rs?ref=02882fbd7edcb8d0d152afcdc8571216efcbd664", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[deriving(Eq)]\n+#[deriving(Eq, Show)]\n struct Foo(uint);\n \n fn foo() -> Foo {"}, {"sha": "c6819971e358dccb2364f024a6ce1d130ad69bdf", "filename": "src/test/run-pass/operator-overloading.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Ftest%2Frun-pass%2Foperator-overloading.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Ftest%2Frun-pass%2Foperator-overloading.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foperator-overloading.rs?ref=02882fbd7edcb8d0d152afcdc8571216efcbd664", "patch": "@@ -13,6 +13,7 @@\n use std::cmp;\n use std::ops;\n \n+#[deriving(Show)]\n struct Point {\n     x: int,\n     y: int"}, {"sha": "8b20b8e14c483dbca59c17a5c3fbb3ecaa81de64", "filename": "src/test/run-pass/packed-struct-generic-layout.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Ftest%2Frun-pass%2Fpacked-struct-generic-layout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Ftest%2Frun-pass%2Fpacked-struct-generic-layout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpacked-struct-generic-layout.rs?ref=02882fbd7edcb8d0d152afcdc8571216efcbd664", "patch": "@@ -22,7 +22,7 @@ pub fn main() {\n         let s = S { a: 0xff_ff_ff_ffu32, b: 1, c: 0xaa_aa_aa_aa as i32 };\n         let transd : [u8, .. 9] = cast::transmute(s);\n         // Don't worry about endianness, the numbers are palindromic.\n-        assert_eq!(transd,\n+        assert!(transd ==\n                    [0xff, 0xff, 0xff, 0xff,\n                     1,\n                     0xaa, 0xaa, 0xaa, 0xaa]);\n@@ -31,7 +31,7 @@ pub fn main() {\n         let s = S { a: 1u8, b: 2u8, c: 0b10000001_10000001 as i16};\n         let transd : [u8, .. 4] = cast::transmute(s);\n         // Again, no endianness problems.\n-        assert_eq!(transd,\n+        assert!(transd ==\n                    [1, 2, 0b10000001, 0b10000001]);\n     }\n }"}, {"sha": "0dc781805007e5593e5e33c754b0411443e924da", "filename": "src/test/run-pass/packed-struct-layout.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Ftest%2Frun-pass%2Fpacked-struct-layout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Ftest%2Frun-pass%2Fpacked-struct-layout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpacked-struct-layout.rs?ref=02882fbd7edcb8d0d152afcdc8571216efcbd664", "patch": "@@ -26,11 +26,11 @@ pub fn main() {\n     unsafe {\n         let s4 = S4 { a: 1, b: [2,3,4] };\n         let transd : [u8, .. 4] = cast::transmute(s4);\n-        assert_eq!(transd, [1, 2, 3, 4]);\n+        assert!(transd == [1, 2, 3, 4]);\n \n         let s5 = S5 { a: 1, b: 0xff_00_00_ff };\n         let transd : [u8, .. 5] = cast::transmute(s5);\n         // Don't worry about endianness, the u32 is palindromic.\n-        assert_eq!(transd, [1, 0xff, 0, 0, 0xff]);\n+        assert!(transd == [1, 0xff, 0, 0, 0xff]);\n     }\n }"}, {"sha": "94e4e3c6bef296ee0c1cc7e1d8ff8430e1607aef", "filename": "src/test/run-pass/packed-struct-vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Ftest%2Frun-pass%2Fpacked-struct-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Ftest%2Frun-pass%2Fpacked-struct-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpacked-struct-vec.rs?ref=02882fbd7edcb8d0d152afcdc8571216efcbd664", "patch": "@@ -13,7 +13,7 @@\n use std::mem;\n \n #[packed]\n-#[deriving(Eq)]\n+#[deriving(Eq, Show)]\n struct Foo {\n     bar: u8,\n     baz: u64"}, {"sha": "0cdaeddf25db39ed087c84e3a5cca68969b429eb", "filename": "src/test/run-pass/packed-tuple-struct-layout.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Ftest%2Frun-pass%2Fpacked-tuple-struct-layout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Ftest%2Frun-pass%2Fpacked-tuple-struct-layout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpacked-tuple-struct-layout.rs?ref=02882fbd7edcb8d0d152afcdc8571216efcbd664", "patch": "@@ -20,11 +20,11 @@ pub fn main() {\n     unsafe {\n         let s4 = S4(1, [2,3,4]);\n         let transd : [u8, .. 4] = cast::transmute(s4);\n-        assert_eq!(transd, [1, 2, 3, 4]);\n+        assert!(transd == [1, 2, 3, 4]);\n \n         let s5 = S5(1, 0xff_00_00_ff);\n         let transd : [u8, .. 5] = cast::transmute(s5);\n         // Don't worry about endianness, the u32 is palindromic.\n-        assert_eq!(transd, [1, 0xff, 0, 0, 0xff]);\n+        assert!(transd == [1, 0xff, 0, 0, 0xff]);\n     }\n }"}, {"sha": "c8e8c045614c39a3767e283776701461d034a374", "filename": "src/test/run-pass/regions-mock-tcx.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Ftest%2Frun-pass%2Fregions-mock-tcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Ftest%2Frun-pass%2Fregions-mock-tcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-mock-tcx.rs?ref=02882fbd7edcb8d0d152afcdc8571216efcbd664", "patch": "@@ -27,6 +27,7 @@ use std::mem;\n \n type Type<'tcx> = &'tcx TypeStructure<'tcx>;\n \n+#[deriving(Show)]\n enum TypeStructure<'tcx> {\n     TypeInt,\n     TypeFunction(Type<'tcx>, Type<'tcx>),"}, {"sha": "9955673bb0b12aa1755ae03d795b78a270bbfebb", "filename": "src/test/run-pass/repeat-expr-in-static.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Ftest%2Frun-pass%2Frepeat-expr-in-static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Ftest%2Frun-pass%2Frepeat-expr-in-static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frepeat-expr-in-static.rs?ref=02882fbd7edcb8d0d152afcdc8571216efcbd664", "patch": "@@ -12,5 +12,5 @@ static FOO: [int, ..4] = [32, ..4];\n static BAR: [int, ..4] = [32, 32, 32, 32];\n \n pub fn main() {\n-    assert_eq!(FOO, BAR);\n+    assert!(FOO == BAR);\n }"}, {"sha": "ef7319eca0952e0e601f021dc2d692eb9a714d48", "filename": "src/test/run-pass/small-enums-with-fields.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Ftest%2Frun-pass%2Fsmall-enums-with-fields.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Ftest%2Frun-pass%2Fsmall-enums-with-fields.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsmall-enums-with-fields.rs?ref=02882fbd7edcb8d0d152afcdc8571216efcbd664", "patch": "@@ -12,7 +12,7 @@\n \n use std::mem::size_of;\n \n-#[deriving(Eq)]\n+#[deriving(Eq, Show)]\n enum Either<T, U> { Left(T), Right(U) }\n \n macro_rules! check {"}, {"sha": "d6a972350b624a47b1e223a33489c4a87835c534", "filename": "src/test/run-pass/struct-lit-functional-update-no-fields.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Ftest%2Frun-pass%2Fstruct-lit-functional-update-no-fields.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Ftest%2Frun-pass%2Fstruct-lit-functional-update-no-fields.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstruct-lit-functional-update-no-fields.rs?ref=02882fbd7edcb8d0d152afcdc8571216efcbd664", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[deriving(Eq,Clone)]\n+#[deriving(Show,Eq,Clone)]\n struct Foo<T> {\n     bar: T,\n     baz: T"}, {"sha": "b21c7684f691e260969bf780f2843bf89b35049b", "filename": "src/test/run-pass/structured-compare.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Ftest%2Frun-pass%2Fstructured-compare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Ftest%2Frun-pass%2Fstructured-compare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstructured-compare.rs?ref=02882fbd7edcb8d0d152afcdc8571216efcbd664", "patch": "@@ -10,6 +10,7 @@\n \n \n \n+#[deriving(Show)]\n enum foo { large, small, }\n \n impl Eq for foo {"}, {"sha": "6c0520b5f284c47483dd57bbdd8d7961da3a5414", "filename": "src/test/run-pass/task-comm-16.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Ftest%2Frun-pass%2Ftask-comm-16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Ftest%2Frun-pass%2Ftask-comm-16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-16.rs?ref=02882fbd7edcb8d0d152afcdc8571216efcbd664", "patch": "@@ -45,6 +45,7 @@ fn test_str() {\n     assert_eq!(s1[3], 't' as u8);\n }\n \n+#[deriving(Show)]\n enum t {\n     tag1,\n     tag2(int),"}, {"sha": "13cfb08e81be2dce1810c8bcbcebc79fcb1210ac", "filename": "src/test/run-pass/trait-inheritance-overloading-simple.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Ftest%2Frun-pass%2Ftrait-inheritance-overloading-simple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Ftest%2Frun-pass%2Ftrait-inheritance-overloading-simple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-inheritance-overloading-simple.rs?ref=02882fbd7edcb8d0d152afcdc8571216efcbd664", "patch": "@@ -12,6 +12,7 @@ use std::cmp::Eq;\n \n trait MyNum : Eq { }\n \n+#[deriving(Show)]\n struct MyInt { val: int }\n \n impl Eq for MyInt {"}, {"sha": "f7c124b945a707bec2b5d34c96737a2058ddfb7e", "filename": "src/test/run-pass/trait-inheritance-overloading.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Ftest%2Frun-pass%2Ftrait-inheritance-overloading.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Ftest%2Frun-pass%2Ftrait-inheritance-overloading.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-inheritance-overloading.rs?ref=02882fbd7edcb8d0d152afcdc8571216efcbd664", "patch": "@@ -12,6 +12,7 @@ use std::cmp::Eq;\n \n trait MyNum : Add<Self,Self> + Sub<Self,Self> + Mul<Self,Self> + Eq { }\n \n+#[deriving(Show)]\n struct MyInt { val: int }\n \n impl Add<MyInt, MyInt> for MyInt {"}, {"sha": "77bfa4390630b08d2445a8a3d5083544f8fbc6fd", "filename": "src/test/run-pass/tuple-struct-constructor-pointer.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Ftest%2Frun-pass%2Ftuple-struct-constructor-pointer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Ftest%2Frun-pass%2Ftuple-struct-constructor-pointer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftuple-struct-constructor-pointer.rs?ref=02882fbd7edcb8d0d152afcdc8571216efcbd664", "patch": "@@ -8,9 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[deriving(Eq)]\n+#[deriving(Eq, Show)]\n struct Foo(int);\n-#[deriving(Eq)]\n+#[deriving(Eq, Show)]\n struct Bar(int, int);\n \n pub fn main() {"}, {"sha": "118d0cd744d58d7c10f8212ffdceb236833de7bb", "filename": "src/test/run-pass/unique-kinds.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Ftest%2Frun-pass%2Funique-kinds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Ftest%2Frun-pass%2Funique-kinds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funique-kinds.rs?ref=02882fbd7edcb8d0d152afcdc8571216efcbd664", "patch": "@@ -13,7 +13,7 @@ use std::cmp::Eq;\n fn sendable() {\n \n     fn f<T:Send + Eq>(i: T, j: T) {\n-        assert_eq!(i, j);\n+        assert!(i == j);\n     }\n \n     fn g<T:Send + Eq>(i: T, j: T) {\n@@ -31,7 +31,7 @@ fn sendable() {\n fn copyable() {\n \n     fn f<T:Eq>(i: T, j: T) {\n-        assert_eq!(i, j);\n+        assert!(i == j);\n     }\n \n     fn g<T:Eq>(i: T, j: T) {\n@@ -49,7 +49,7 @@ fn copyable() {\n fn noncopyable() {\n \n     fn f<T:Eq>(i: T, j: T) {\n-        assert_eq!(i, j);\n+        assert!(i == j);\n     }\n \n     fn g<T:Eq>(i: T, j: T) {"}, {"sha": "a318e0a75fbf9d5ab0c0c9815c6fa4609b316f36", "filename": "src/test/run-pass/vec-matching-autoslice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Ftest%2Frun-pass%2Fvec-matching-autoslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02882fbd7edcb8d0d152afcdc8571216efcbd664/src%2Ftest%2Frun-pass%2Fvec-matching-autoslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvec-matching-autoslice.rs?ref=02882fbd7edcb8d0d152afcdc8571216efcbd664", "patch": "@@ -13,7 +13,7 @@ pub fn main() {\n     match x {\n         [2, _, _] => fail!(),\n         [1, a, b] => {\n-            assert_eq!([a, b], [2, 3]);\n+            assert!([a, b] == [2, 3]);\n         }\n         [_, _, _] => fail!(),\n     }"}]}