{"sha": "531e1523908c7f2201ad3c877ede48a3faec14be", "node_id": "C_kwDOAAsO6NoAKDUzMWUxNTIzOTA4YzdmMjIwMWFkM2M4NzdlZGU0OGEzZmFlYzE0YmU", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2022-07-01T12:43:57Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2022-07-01T12:49:30Z"}, "message": "fix: Simplify macro statement expansion handling", "tree": {"sha": "1ab7c33624452580fb859cdc5cbcc8082c76c11e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1ab7c33624452580fb859cdc5cbcc8082c76c11e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/531e1523908c7f2201ad3c877ede48a3faec14be", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/531e1523908c7f2201ad3c877ede48a3faec14be", "html_url": "https://github.com/rust-lang/rust/commit/531e1523908c7f2201ad3c877ede48a3faec14be", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/531e1523908c7f2201ad3c877ede48a3faec14be/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f8c416e1b9b591d9c72b613f4dcbe05432f57ee8", "url": "https://api.github.com/repos/rust-lang/rust/commits/f8c416e1b9b591d9c72b613f4dcbe05432f57ee8", "html_url": "https://github.com/rust-lang/rust/commit/f8c416e1b9b591d9c72b613f4dcbe05432f57ee8"}], "stats": {"total": 271, "additions": 158, "deletions": 113}, "files": [{"sha": "94210ab33fb69bd7d500c4b07db30b38840fb99e", "filename": "crates/hir-def/src/body.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/531e1523908c7f2201ad3c877ede48a3faec14be/crates%2Fhir-def%2Fsrc%2Fbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/531e1523908c7f2201ad3c877ede48a3faec14be/crates%2Fhir-def%2Fsrc%2Fbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fbody.rs?ref=531e1523908c7f2201ad3c877ede48a3faec14be", "patch": "@@ -19,7 +19,6 @@ use la_arena::{Arena, ArenaMap};\n use limit::Limit;\n use profile::Count;\n use rustc_hash::FxHashMap;\n-use smallvec::SmallVec;\n use syntax::{ast, AstNode, AstPtr, SyntaxNodePtr};\n \n use crate::{\n@@ -294,10 +293,6 @@ pub struct BodySourceMap {\n     field_map: FxHashMap<InFile<AstPtr<ast::RecordExprField>>, ExprId>,\n     field_map_back: FxHashMap<ExprId, InFile<AstPtr<ast::RecordExprField>>>,\n \n-    /// Maps a macro call to its lowered expressions, a single one if it expands to an expression,\n-    /// or multiple if it expands to MacroStmts.\n-    macro_call_to_exprs: FxHashMap<InFile<AstPtr<ast::MacroCall>>, SmallVec<[ExprId; 1]>>,\n-\n     expansions: FxHashMap<InFile<AstPtr<ast::MacroCall>>, HirFileId>,\n \n     /// Diagnostics accumulated during body lowering. These contain `AstPtr`s and so are stored in\n@@ -466,9 +461,9 @@ impl BodySourceMap {\n         self.field_map.get(&src).cloned()\n     }\n \n-    pub fn macro_expansion_expr(&self, node: InFile<&ast::MacroCall>) -> Option<&[ExprId]> {\n-        let src = node.map(AstPtr::new);\n-        self.macro_call_to_exprs.get(&src).map(|it| &**it)\n+    pub fn macro_expansion_expr(&self, node: InFile<&ast::MacroExpr>) -> Option<ExprId> {\n+        let src = node.map(AstPtr::new).map(AstPtr::upcast::<ast::MacroExpr>).map(AstPtr::upcast);\n+        self.expr_map.get(&src).copied()\n     }\n \n     /// Get a reference to the body source map's diagnostics."}, {"sha": "409193b269f66c66a4c66f4c757cf8e480460651", "filename": "crates/hir-def/src/body/lower.rs", "status": "modified", "additions": 61, "deletions": 84, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/531e1523908c7f2201ad3c877ede48a3faec14be/crates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/531e1523908c7f2201ad3c877ede48a3faec14be/crates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs?ref=531e1523908c7f2201ad3c877ede48a3faec14be", "patch": "@@ -13,7 +13,6 @@ use hir_expand::{\n use la_arena::Arena;\n use profile::Count;\n use rustc_hash::FxHashMap;\n-use smallvec::smallvec;\n use syntax::{\n     ast::{\n         self, ArrayExprKind, AstChildren, HasArgList, HasLoopBody, HasName, LiteralKind,\n@@ -97,7 +96,6 @@ pub(super) fn lower(\n             or_pats: Default::default(),\n         },\n         expander,\n-        statements_in_scope: Vec::new(),\n         name_to_pat_grouping: Default::default(),\n         is_lowering_inside_or_pat: false,\n     }\n@@ -109,7 +107,6 @@ struct ExprCollector<'a> {\n     expander: Expander,\n     body: Body,\n     source_map: BodySourceMap,\n-    statements_in_scope: Vec<Statement>,\n     // a poor-mans union-find?\n     name_to_pat_grouping: FxHashMap<Name, Vec<PatId>>,\n     is_lowering_inside_or_pat: bool,\n@@ -514,27 +511,25 @@ impl ExprCollector<'_> {\n             ast::Expr::MacroExpr(e) => {\n                 let e = e.macro_call()?;\n                 let macro_ptr = AstPtr::new(&e);\n-                let id = self.collect_macro_call(e, macro_ptr.clone(), true, |this, expansion| {\n+                let id = self.collect_macro_call(e, macro_ptr, true, |this, expansion| {\n                     expansion.map(|it| this.collect_expr(it))\n                 });\n                 match id {\n                     Some(id) => {\n-                        self.source_map\n-                            .macro_call_to_exprs\n-                            .insert(self.expander.to_source(macro_ptr), smallvec![id]);\n+                        // Make the macro-call point to its expanded expression so we can query\n+                        // semantics on syntax pointers to the macro\n+                        let src = self.expander.to_source(syntax_ptr);\n+                        self.source_map.expr_map.insert(src, id);\n                         id\n                     }\n-                    None => self.alloc_expr(Expr::Missing, syntax_ptr.clone()),\n+                    None => self.alloc_expr(Expr::Missing, syntax_ptr),\n                 }\n             }\n             ast::Expr::MacroStmts(e) => {\n-                e.statements().for_each(|s| self.collect_stmt(s));\n-                let tail = e\n-                    .expr()\n-                    .map(|e| self.collect_expr(e))\n-                    .unwrap_or_else(|| self.alloc_expr(Expr::Missing, syntax_ptr.clone()));\n+                let statements = e.statements().filter_map(|s| self.collect_stmt(s)).collect();\n+                let tail = e.expr().map(|e| self.collect_expr(e));\n \n-                self.alloc_expr(Expr::MacroStmts { tail }, syntax_ptr)\n+                self.alloc_expr(Expr::MacroStmts { tail, statements }, syntax_ptr)\n             }\n             ast::Expr::UnderscoreExpr(_) => self.alloc_expr(Expr::Underscore, syntax_ptr),\n         })\n@@ -607,11 +602,11 @@ impl ExprCollector<'_> {\n         }\n     }\n \n-    fn collect_stmt(&mut self, s: ast::Stmt) {\n+    fn collect_stmt(&mut self, s: ast::Stmt) -> Option<Statement> {\n         match s {\n             ast::Stmt::LetStmt(stmt) => {\n                 if self.check_cfg(&stmt).is_none() {\n-                    return;\n+                    return None;\n                 }\n                 let pat = self.collect_pat_opt(stmt.pat());\n                 let type_ref =\n@@ -621,70 +616,62 @@ impl ExprCollector<'_> {\n                     .let_else()\n                     .and_then(|let_else| let_else.block_expr())\n                     .map(|block| self.collect_block(block));\n-                self.statements_in_scope.push(Statement::Let {\n-                    pat,\n-                    type_ref,\n-                    initializer,\n-                    else_branch,\n-                });\n+                Some(Statement::Let { pat, type_ref, initializer, else_branch })\n             }\n             ast::Stmt::ExprStmt(stmt) => {\n-                if let Some(expr) = stmt.expr() {\n-                    if self.check_cfg(&expr).is_none() {\n-                        return;\n+                let expr = stmt.expr();\n+                if let Some(expr) = &expr {\n+                    if self.check_cfg(expr).is_none() {\n+                        return None;\n                     }\n                 }\n                 let has_semi = stmt.semicolon_token().is_some();\n-                // Note that macro could be expended to multiple statements\n-                if let Some(ast::Expr::MacroExpr(e)) = stmt.expr() {\n-                    let m = match e.macro_call() {\n-                        Some(it) => it,\n-                        None => return,\n-                    };\n-                    let macro_ptr = AstPtr::new(&m);\n-                    let syntax_ptr = AstPtr::new(&stmt.expr().unwrap());\n-\n-                    let prev_stmt = self.statements_in_scope.len();\n-                    self.collect_macro_call(m, macro_ptr.clone(), false, |this, expansion| {\n-                        match expansion {\n+                // Note that macro could be expanded to multiple statements\n+                if let Some(expr @ ast::Expr::MacroExpr(mac)) = &expr {\n+                    let mac_call = mac.macro_call()?;\n+                    let syntax_ptr = AstPtr::new(expr);\n+                    let macro_ptr = AstPtr::new(&mac_call);\n+                    // let prev_stmt = self.statements_in_scope.len();\n+                    let stmt = self.collect_macro_call(\n+                        mac_call,\n+                        macro_ptr,\n+                        false,\n+                        |this, expansion: Option<ast::MacroStmts>| match expansion {\n                             Some(expansion) => {\n-                                let statements: ast::MacroStmts = expansion;\n-\n-                                statements.statements().for_each(|stmt| this.collect_stmt(stmt));\n-                                if let Some(expr) = statements.expr() {\n-                                    let expr = this.collect_expr(expr);\n-                                    this.statements_in_scope\n-                                        .push(Statement::Expr { expr, has_semi });\n-                                }\n+                                let statements = expansion\n+                                    .statements()\n+                                    .filter_map(|stmt| this.collect_stmt(stmt))\n+                                    .collect();\n+                                let tail = expansion.expr().map(|expr| this.collect_expr(expr));\n+\n+                                let mac_stmts = this.alloc_expr(\n+                                    Expr::MacroStmts { tail, statements },\n+                                    AstPtr::new(&ast::Expr::MacroStmts(expansion)),\n+                                );\n+\n+                                Some(mac_stmts)\n                             }\n-                            None => {\n-                                let expr = this.alloc_expr(Expr::Missing, syntax_ptr.clone());\n-                                this.statements_in_scope.push(Statement::Expr { expr, has_semi });\n-                            }\n-                        }\n-                    });\n+                            None => None,\n+                        },\n+                    );\n \n-                    let mut macro_exprs = smallvec![];\n-                    for stmt in &self.statements_in_scope[prev_stmt..] {\n-                        match *stmt {\n-                            Statement::Let { initializer, else_branch, .. } => {\n-                                macro_exprs.extend(initializer);\n-                                macro_exprs.extend(else_branch);\n-                            }\n-                            Statement::Expr { expr, .. } => macro_exprs.push(expr),\n+                    let expr = match stmt {\n+                        Some(expr) => {\n+                            // Make the macro-call point to its expanded expression so we can query\n+                            // semantics on syntax pointers to the macro\n+                            let src = self.expander.to_source(syntax_ptr);\n+                            self.source_map.expr_map.insert(src, expr);\n+                            expr\n                         }\n-                    }\n-                    if !macro_exprs.is_empty() {\n-                        self.source_map\n-                            .macro_call_to_exprs\n-                            .insert(self.expander.to_source(macro_ptr), macro_exprs);\n-                    }\n+                        None => self.alloc_expr(Expr::Missing, syntax_ptr),\n+                    };\n+                    Some(Statement::Expr { expr, has_semi })\n                 } else {\n-                    let expr = self.collect_expr_opt(stmt.expr());\n-                    self.statements_in_scope.push(Statement::Expr { expr, has_semi });\n+                    let expr = self.collect_expr_opt(expr);\n+                    Some(Statement::Expr { expr, has_semi })\n                 }\n             }\n-            ast::Stmt::Item(_item) => {}\n+            ast::Stmt::Item(_item) => None,\n         }\n     }\n \n@@ -703,22 +690,10 @@ impl ExprCollector<'_> {\n         };\n         let prev_def_map = mem::replace(&mut self.expander.def_map, def_map);\n         let prev_local_module = mem::replace(&mut self.expander.module, module);\n-        let prev_statements = std::mem::take(&mut self.statements_in_scope);\n-\n-        block.statements().for_each(|s| self.collect_stmt(s));\n-        block.tail_expr().and_then(|e| {\n-            let expr = self.maybe_collect_expr(e)?;\n-            self.statements_in_scope.push(Statement::Expr { expr, has_semi: false });\n-            Some(())\n-        });\n-\n-        let mut tail = None;\n-        if let Some(Statement::Expr { expr, has_semi: false }) = self.statements_in_scope.last() {\n-            tail = Some(*expr);\n-            self.statements_in_scope.pop();\n-        }\n-        let tail = tail;\n-        let statements = std::mem::replace(&mut self.statements_in_scope, prev_statements).into();\n+\n+        let statements = block.statements().filter_map(|s| self.collect_stmt(s)).collect();\n+        let tail = block.tail_expr().and_then(|e| self.maybe_collect_expr(e));\n+\n         let syntax_node_ptr = AstPtr::new(&block.into());\n         let expr_id = self.alloc_expr(\n             Expr::Block { id: block_id, statements, tail, label: None },\n@@ -903,10 +878,12 @@ impl ExprCollector<'_> {\n             ast::Pat::MacroPat(mac) => match mac.macro_call() {\n                 Some(call) => {\n                     let macro_ptr = AstPtr::new(&call);\n+                    let src = self.expander.to_source(Either::Left(AstPtr::new(&pat)));\n                     let pat =\n                         self.collect_macro_call(call, macro_ptr, true, |this, expanded_pat| {\n                             this.collect_pat_opt_(expanded_pat)\n                         });\n+                    self.source_map.pat_map.insert(src, pat);\n                     return pat;\n                 }\n                 None => Pat::Missing,"}, {"sha": "4295bacc4668e490a185a70c9b9988728dd7166a", "filename": "crates/hir-def/src/expr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/531e1523908c7f2201ad3c877ede48a3faec14be/crates%2Fhir-def%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/531e1523908c7f2201ad3c877ede48a3faec14be/crates%2Fhir-def%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fexpr.rs?ref=531e1523908c7f2201ad3c877ede48a3faec14be", "patch": "@@ -199,7 +199,8 @@ pub enum Expr {\n         body: ExprId,\n     },\n     MacroStmts {\n-        tail: ExprId,\n+        statements: Box<[Statement]>,\n+        tail: Option<ExprId>,\n     },\n     Array(Array),\n     Literal(Literal),\n@@ -254,7 +255,7 @@ impl Expr {\n             Expr::Let { expr, .. } => {\n                 f(*expr);\n             }\n-            Expr::Block { statements, tail, .. } => {\n+            Expr::MacroStmts { tail, statements } | Expr::Block { statements, tail, .. } => {\n                 for stmt in statements.iter() {\n                     match stmt {\n                         Statement::Let { initializer, .. } => {\n@@ -344,7 +345,6 @@ impl Expr {\n                     f(*repeat)\n                 }\n             },\n-            Expr::MacroStmts { tail } => f(*tail),\n             Expr::Literal(_) => {}\n             Expr::Underscore => {}\n         }"}, {"sha": "defceefc79fae5a02d1835a994ed98bb07f373cc", "filename": "crates/hir-ty/src/infer/expr.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/531e1523908c7f2201ad3c877ede48a3faec14be/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/531e1523908c7f2201ad3c877ede48a3faec14be/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs?ref=531e1523908c7f2201ad3c877ede48a3faec14be", "patch": "@@ -774,7 +774,9 @@ impl<'a> InferenceContext<'a> {\n                     None => self.table.new_float_var(),\n                 },\n             },\n-            Expr::MacroStmts { tail } => self.infer_expr_inner(*tail, expected),\n+            Expr::MacroStmts { tail, statements } => {\n+                self.infer_block(tgt_expr, statements, *tail, expected)\n+            }\n             Expr::Underscore => {\n                 // Underscore expressions may only appear in assignee expressions,\n                 // which are handled by `infer_assignee_expr()`, so any underscore"}, {"sha": "ef17f2a75e1d23a197cf7d57e00139b4425547b2", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/531e1523908c7f2201ad3c877ede48a3faec14be/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/531e1523908c7f2201ad3c877ede48a3faec14be/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=531e1523908c7f2201ad3c877ede48a3faec14be", "patch": "@@ -2223,6 +2223,7 @@ impl Local {\n         let src = source_map.pat_syntax(self.pat_id).unwrap(); // Hmm...\n         let root = src.file_syntax(db.upcast());\n         src.map(|ast| match ast {\n+            // Suspicious unwrap\n             Either::Left(it) => Either::Left(it.cast().unwrap().to_node(&root)),\n             Either::Right(it) => Either::Right(it.to_node(&root)),\n         })"}, {"sha": "2298a75d57ff0b8d11b26534386969ec6453929b", "filename": "crates/hir/src/source_analyzer.rs", "status": "modified", "additions": 18, "deletions": 16, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/531e1523908c7f2201ad3c877ede48a3faec14be/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/531e1523908c7f2201ad3c877ede48a3faec14be/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs?ref=531e1523908c7f2201ad3c877ede48a3faec14be", "patch": "@@ -539,24 +539,26 @@ impl SourceAnalyzer {\n                 _ => (),\n             }\n         }\n+        let macro_expr = match macro_call\n+            .map(|it| it.syntax().parent().and_then(ast::MacroExpr::cast))\n+            .transpose()\n+        {\n+            Some(it) => it,\n+            None => return false,\n+        };\n+\n         if let (Some((def, body, sm)), Some(infer)) = (&self.def, &self.infer) {\n-            if let Some(expr_ids) = sm.macro_expansion_expr(macro_call) {\n+            if let Some(expanded_expr) = sm.macro_expansion_expr(macro_expr.as_ref()) {\n                 let mut is_unsafe = false;\n-                for &expr_id in expr_ids {\n-                    unsafe_expressions(\n-                        db,\n-                        infer,\n-                        *def,\n-                        body,\n-                        expr_id,\n-                        &mut |UnsafeExpr { inside_unsafe_block, .. }| {\n-                            is_unsafe |= !inside_unsafe_block\n-                        },\n-                    );\n-                    if is_unsafe {\n-                        return true;\n-                    }\n-                }\n+                unsafe_expressions(\n+                    db,\n+                    infer,\n+                    *def,\n+                    body,\n+                    expanded_expr,\n+                    &mut |UnsafeExpr { inside_unsafe_block, .. }| is_unsafe |= !inside_unsafe_block,\n+                );\n+                return is_unsafe;\n             }\n         }\n         false"}, {"sha": "96d0219fef6fa3d122d8b2b0dd651dc828235264", "filename": "crates/ide-completion/src/tests/special.rs", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/531e1523908c7f2201ad3c877ede48a3faec14be/crates%2Fide-completion%2Fsrc%2Ftests%2Fspecial.rs", "raw_url": "https://github.com/rust-lang/rust/raw/531e1523908c7f2201ad3c877ede48a3faec14be/crates%2Fide-completion%2Fsrc%2Ftests%2Fspecial.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Ftests%2Fspecial.rs?ref=531e1523908c7f2201ad3c877ede48a3faec14be", "patch": "@@ -810,3 +810,33 @@ fn main() {\n         \"#]],\n     )\n }\n+\n+#[test]\n+fn regression_12644() {\n+    check(\n+        r#\"\n+macro_rules! __rust_force_expr {\n+    ($e:expr) => {\n+        $e\n+    };\n+}\n+macro_rules! vec {\n+    ($elem:expr) => {\n+        __rust_force_expr!($elem)\n+    };\n+}\n+\n+struct Struct;\n+impl Struct {\n+    fn foo(self) {}\n+}\n+\n+fn f() {\n+    vec![Struct].$0;\n+}\n+\"#,\n+        expect![[r#\"\n+            me foo() fn(self)\n+        \"#]],\n+    );\n+}"}, {"sha": "7c0a7fa1e7243a5b2e7a2654a40ff8caf8cc60f3", "filename": "crates/ide/src/highlight_related.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/531e1523908c7f2201ad3c877ede48a3faec14be/crates%2Fide%2Fsrc%2Fhighlight_related.rs", "raw_url": "https://github.com/rust-lang/rust/raw/531e1523908c7f2201ad3c877ede48a3faec14be/crates%2Fide%2Fsrc%2Fhighlight_related.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhighlight_related.rs?ref=531e1523908c7f2201ad3c877ede48a3faec14be", "patch": "@@ -689,7 +689,7 @@ fn foo() ->$0 u32 {\n     never();\n  // ^^^^^^^\n     never!();\n- // FIXME sema doesn't give us types for macrocalls\n+ // ^^^^^^^^\n \n     Never.never();\n  // ^^^^^^^^^^^^^"}, {"sha": "a1484fa19fcde1ffe5a97c73eaf83daced7e3a72", "filename": "crates/ide/src/hover/tests.rs", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/531e1523908c7f2201ad3c877ede48a3faec14be/crates%2Fide%2Fsrc%2Fhover%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/531e1523908c7f2201ad3c877ede48a3faec14be/crates%2Fide%2Fsrc%2Fhover%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhover%2Ftests.rs?ref=531e1523908c7f2201ad3c877ede48a3faec14be", "patch": "@@ -4920,3 +4920,34 @@ impl T for () {\n         \"#]],\n     );\n }\n+\n+#[test]\n+fn hover_ranged_macro_call() {\n+    check_hover_range(\n+        r#\"\n+macro_rules! __rust_force_expr {\n+    ($e:expr) => {\n+        $e\n+    };\n+}\n+macro_rules! vec {\n+    ($elem:expr) => {\n+        __rust_force_expr!($elem)\n+    };\n+}\n+\n+struct Struct;\n+impl Struct {\n+    fn foo(self) {}\n+}\n+\n+fn f() {\n+    $0vec![Struct]$0;\n+}\n+\"#,\n+        expect![[r#\"\n+            ```rust\n+            Struct\n+            ```\"#]],\n+    );\n+}"}, {"sha": "bd96e35cc6e5d31cc201c6e8398e86802272696d", "filename": "crates/syntax/src/ptr.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/531e1523908c7f2201ad3c877ede48a3faec14be/crates%2Fsyntax%2Fsrc%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/531e1523908c7f2201ad3c877ede48a3faec14be/crates%2Fsyntax%2Fsrc%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fptr.rs?ref=531e1523908c7f2201ad3c877ede48a3faec14be", "patch": "@@ -67,6 +67,13 @@ impl<N: AstNode> AstPtr<N> {\n         Some(AstPtr { raw: self.raw, _ty: PhantomData })\n     }\n \n+    pub fn upcast<M: AstNode>(self) -> AstPtr<M>\n+    where\n+        N: Into<M>,\n+    {\n+        AstPtr { raw: self.raw, _ty: PhantomData }\n+    }\n+\n     /// Like `SyntaxNodePtr::cast` but the trait bounds work out.\n     pub fn try_from_raw(raw: SyntaxNodePtr) -> Option<AstPtr<N>> {\n         N::can_cast(raw.kind()).then(|| AstPtr { raw, _ty: PhantomData })"}]}