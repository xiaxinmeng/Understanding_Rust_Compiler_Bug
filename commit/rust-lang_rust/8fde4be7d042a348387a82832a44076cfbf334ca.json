{"sha": "8fde4be7d042a348387a82832a44076cfbf334ca", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhmZGU0YmU3ZDA0MmEzNDgzODdhODI4MzJhNDQwNzZjZmJmMzM0Y2E=", "commit": {"author": {"name": "Jonas Schievink", "email": "jonasschievink@gmail.com", "date": "2020-11-24T12:17:28Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-11-24T12:17:28Z"}, "message": "Rollup merge of #76858 - rcvalle:rust-lang-exploit-mitigations, r=steveklabnik\n\nAdd exploit mitigations chapter to the rustc book\n\nThis section documents the exploit mitigations applicable to the Rust compiler when building programs for the Linux operating system on the AMD64 architecture and equivalent. This was done for a project I'm currently working on, and I hope it'll also be helpful to others.", "tree": {"sha": "66839a039d0115ea08ac71ac5e3c310818ea9e0b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/66839a039d0115ea08ac71ac5e3c310818ea9e0b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8fde4be7d042a348387a82832a44076cfbf334ca", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfvPnZCRBK7hj4Ov3rIwAAdHIIAGXDDo53muz56c5RInslmdY9\ncycADuB4htnGocF/QNvm6UiXidCRkqZSJYXMnt6n71HOybpt9rRBlAxofYFQQuaJ\nsWLguEgCQ2KgD2W34Rh32PDCs4G1jsIMs+Xl9JlVqxvpQP5fAPSzQBS1V0lkzVWx\nEFDgGeMJye5i32evXqpVegIJhIwWZfOLaECe18VMxv+ORirurpniVXzbMiIKtNJ1\n6hq0NN0S7cKaI4jV6s/oKtmJ812HgbvUHoOdLy38cXoD0KESoOuYXDeMaI8bLmIV\nlMAPwy9QgHO0AG01lAbolnRrCayeUn6tmXUVEIY7fg7ulMoKPbpqDdlr2P2pssU=\n=eUmf\n-----END PGP SIGNATURE-----\n", "payload": "tree 66839a039d0115ea08ac71ac5e3c310818ea9e0b\nparent 6331023708aabef7fbd4ca502feb48c3afc83b41\nparent 5b1cb0eb8a9eb3dcc69de2133f42d616511481b8\nauthor Jonas Schievink <jonasschievink@gmail.com> 1606220248 +0100\ncommitter GitHub <noreply@github.com> 1606220248 +0100\n\nRollup merge of #76858 - rcvalle:rust-lang-exploit-mitigations, r=steveklabnik\n\nAdd exploit mitigations chapter to the rustc book\n\nThis section documents the exploit mitigations applicable to the Rust compiler when building programs for the Linux operating system on the AMD64 architecture and equivalent. This was done for a project I'm currently working on, and I hope it'll also be helpful to others.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8fde4be7d042a348387a82832a44076cfbf334ca", "html_url": "https://github.com/rust-lang/rust/commit/8fde4be7d042a348387a82832a44076cfbf334ca", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8fde4be7d042a348387a82832a44076cfbf334ca/comments", "author": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6331023708aabef7fbd4ca502feb48c3afc83b41", "url": "https://api.github.com/repos/rust-lang/rust/commits/6331023708aabef7fbd4ca502feb48c3afc83b41", "html_url": "https://github.com/rust-lang/rust/commit/6331023708aabef7fbd4ca502feb48c3afc83b41"}, {"sha": "5b1cb0eb8a9eb3dcc69de2133f42d616511481b8", "url": "https://api.github.com/repos/rust-lang/rust/commits/5b1cb0eb8a9eb3dcc69de2133f42d616511481b8", "html_url": "https://github.com/rust-lang/rust/commit/5b1cb0eb8a9eb3dcc69de2133f42d616511481b8"}], "stats": {"total": 694, "additions": 694, "deletions": 0}, "files": [{"sha": "dd1986157366761f28b60fce17dfa48d20f07bb3", "filename": "src/doc/rustc/src/SUMMARY.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8fde4be7d042a348387a82832a44076cfbf334ca/src%2Fdoc%2Frustc%2Fsrc%2FSUMMARY.md", "raw_url": "https://github.com/rust-lang/rust/raw/8fde4be7d042a348387a82832a44076cfbf334ca/src%2Fdoc%2Frustc%2Fsrc%2FSUMMARY.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2FSUMMARY.md?ref=8fde4be7d042a348387a82832a44076cfbf334ca", "patch": "@@ -18,4 +18,5 @@\n     - [Known Issues](targets/known-issues.md)\n - [Profile-guided Optimization](profile-guided-optimization.md)\n - [Linker-plugin based LTO](linker-plugin-lto.md)\n+- [Exploit Mitigations](exploit-mitigations.md)\n - [Contributing to `rustc`](contributing.md)"}, {"sha": "44d5d9564f267a7c6f666209f41684cb48bc0534", "filename": "src/doc/rustc/src/exploit-mitigations.md", "status": "added", "additions": 693, "deletions": 0, "changes": 693, "blob_url": "https://github.com/rust-lang/rust/blob/8fde4be7d042a348387a82832a44076cfbf334ca/src%2Fdoc%2Frustc%2Fsrc%2Fexploit-mitigations.md", "raw_url": "https://github.com/rust-lang/rust/raw/8fde4be7d042a348387a82832a44076cfbf334ca/src%2Fdoc%2Frustc%2Fsrc%2Fexploit-mitigations.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Fexploit-mitigations.md?ref=8fde4be7d042a348387a82832a44076cfbf334ca", "patch": "@@ -0,0 +1,693 @@\n+# Exploit Mitigations\n+\n+This chapter documents the exploit mitigations supported by the Rust\n+compiler, and is by no means an extensive survey of the Rust programming\n+language\u2019s security features.\n+\n+This chapter is for software engineers working with the Rust programming\n+language, and assumes prior knowledge of the Rust programming language and\n+its toolchain.\n+\n+\n+## Introduction\n+\n+The Rust programming language provides memory[1] and thread[2] safety\n+guarantees via its ownership[3], references and borrowing[4], and slice\n+types[5] features. However, Unsafe Rust[6] introduces unsafe blocks, unsafe\n+functions and methods, unsafe traits, and new types that are not subject to\n+the borrowing rules.\n+\n+Parts of the Rust standard library are implemented as safe abstractions over\n+unsafe code (and historically have been vulnerable to memory corruption[7]).\n+Furthermore, the Rust code and documentation encourage creating safe\n+abstractions over unsafe code. This can cause a false sense of security if\n+unsafe code is not properly reviewed and tested.\n+\n+Unsafe Rust introduces features that do not provide the same memory and\n+thread safety guarantees. This causes programs or libraries to be\n+susceptible to memory corruption (CWE-119)[8] and concurrency issues\n+(CWE-557)[9]. Modern C and C++ compilers provide exploit mitigations to\n+increase the difficulty to exploit vulnerabilities resulting from these\n+issues. Therefore, the Rust compiler must also support these exploit\n+mitigations in order to mitigate vulnerabilities resulting from the use of\n+Unsafe Rust. This chapter documents these exploit mitigations and how they\n+apply to Rust.\n+\n+This chapter does not discuss the effectiveness of these exploit mitigations\n+as they vary greatly depending on several factors besides their design and\n+implementation, but rather describe what they do, so their effectiveness can\n+be understood within a given context.\n+\n+\n+## Exploit mitigations\n+\n+This section documents the exploit mitigations applicable to the Rust\n+compiler when building programs for the Linux operating system on the AMD64\n+architecture and equivalent.<sup id=\"fnref:1\" role=\"doc-noteref\"><a\n+href=\"#fn:1\" class=\"footnote\">1</a></sup>\n+\n+The Rust Programming Language currently has no specification. The Rust\n+compiler (i.e., rustc) is the language reference implementation. All\n+references to \u201cthe Rust compiler\u201d in this chapter refer to the language\n+reference implementation.\n+\n+Table I \\\n+Summary of exploit mitigations supported by the Rust compiler when building\n+programs for the Linux operating system on the AMD64 architecture and\n+equivalent.\n+<table class=\"table\">\n+  <tr>\n+   <td><strong>Exploit mitigation</strong>\n+   </td>\n+   <td><strong>Supported and enabled by default</strong>\n+   </td>\n+   <td><strong>Since</strong>\n+   </td>\n+  </tr>\n+  <tr>\n+   <td>Position-independent executable\n+   </td>\n+   <td>Yes\n+   </td>\n+   <td>0.12.0 (2014-10-09)\n+   </td>\n+  </tr>\n+  <tr>\n+   <td>Integer overflow checks\n+   </td>\n+   <td>Yes (enabled when debug assertions are enabled, and disabled when debug assertions are disabled)\n+   </td>\n+   <td>1.1.0 (2015-06-25)\n+   </td>\n+  </tr>\n+  <tr>\n+   <td>Non-executable memory regions\n+   </td>\n+   <td>Yes\n+   </td>\n+   <td>1.8.0 (2016-04-14)\n+   </td>\n+  </tr>\n+  <tr>\n+   <td>Stack clashing protection\n+   </td>\n+   <td>Yes\n+   </td>\n+   <td>1.20.0 (2017-08-31)\n+   </td>\n+  </tr>\n+  <tr>\n+   <td>Read-only relocations and immediate binding\n+   </td>\n+   <td>Yes\n+   </td>\n+   <td>1.21.0 (2017-10-12)\n+   </td>\n+  </tr>\n+  <tr>\n+   <td>Heap corruption protection\n+   </td>\n+   <td>Yes\n+   </td>\n+   <td>1.32.0 (2019-01-17) (via operating system default or specified allocator)\n+   </td>\n+  </tr>\n+  <tr>\n+   <td>Stack smashing protection\n+   </td>\n+   <td>No\n+   </td>\n+   <td>\n+   </td>\n+  </tr>\n+  <tr>\n+   <td>Forward-edge control flow protection\n+   </td>\n+   <td>No\n+   </td>\n+   <td>\n+   </td>\n+  </tr>\n+  <tr>\n+   <td>Backward-edge control flow protection (e.g., shadow and safe stack)\n+   </td>\n+   <td>No\n+   </td>\n+   <td>\n+   </td>\n+  </tr>\n+</table>\n+\n+<small id=\"fn:1\">1\\. See\n+<https://github.com/rust-lang/rust/tree/master/compiler/rustc_target/src/spec>\n+for a list of targets and their default options. <a href=\"#fnref:1\"\n+class=\"reversefootnote\" role=\"doc-backlink\">\u21a9</a></small>\n+\n+\n+### Position-independent executable\n+\n+Position-independent executable increases the difficulty of the use of code\n+reuse exploitation techniques, such as return-oriented programming (ROP) and\n+variants, by generating position-independent code for the executable, and\n+instructing the dynamic linker to load it similarly to a shared object at a\n+random load address, thus also benefiting from address-space layout\n+randomization (ASLR). This is also referred to as \u201cfull ASLR\u201d.\n+\n+The Rust compiler supports position-independent executable, and enables it\n+by default since version 0.12.0 (2014-10-09)[10]\u2013[13].\n+\n+```text\n+$ readelf -h target/release/hello-rust | grep Type:\n+  Type:                              DYN (Shared object file)\n+```\n+Fig. 1.\u2003Checking if an executable is a position-independent executable.\n+\n+An executable with an object type of `ET_DYN` (i.e., shared object) and not\n+`ET_EXEC` (i.e., executable) is a position-independent executable (see Fig.\n+1).\n+\n+\n+### Integer overflow checks\n+\n+Integer overflow checks protects programs from undefined and unintended\n+behavior (which may cause vulnerabilities) by checking for results of signed\n+and unsigned integer computations that cannot be represented in their type,\n+resulting in an overflow or wraparound.\n+\n+The Rust compiler supports integer overflow checks, and enables it when\n+debug assertions are enabled since version 1.1.0 (2015-06-25)[14]\u2013[20].\n+\n+```compile_fail\n+fn main() {\n+    let u: u8 = 255;\n+    println!(\"u: {}\", u + 1);\n+}\n+```\n+Fig. 2.\u2003hello-rust-integer program.\n+\n+```text\n+$ cargo run\n+   Compiling hello-rust-integer v0.1.0 (/home/rcvalle/hello-rust-integer)\n+    Finished dev [unoptimized + debuginfo] target(s) in 0.23s\n+     Running `target/debug/hello-rust-integer`\n+thread 'main' panicked at 'attempt to add with overflow', src/main.rs:3:23\n+note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.\n+```\n+Fig. 3.\u2003Build and execution of hello-rust-integer with debug assertions\n+enabled.\n+\n+```text\n+$ cargo run --release\n+   Compiling hello-rust-integer v0.1.0 (/home/rcvalle/hello-rust-integer)\n+    Finished release [optimized] target(s) in 0.23s\n+     Running `target/release/hello-rust-integer`\n+u: 0\n+```\n+Fig. 4.\u2003Build and execution of hello-rust-integer with debug assertions\n+disabled.\n+\n+Integer overflow checks are enabled when debug assertions are enabled (see\n+Fig. 3), and disabled when debug assertions are disabled (see Fig. 4). To\n+enable integer overflow checks independently, use the option to control\n+integer overflow checks, scoped attributes, or explicit checking methods\n+such as `checked_add`<sup id=\"fnref:2\" role=\"doc-noteref\"><a href=\"#fn:2\"\n+class=\"footnote\">2</a></sup>.\n+\n+It is recommended that explicit wrapping methods such as `wrapping_add` be\n+used when wrapping semantics are intended, and that explicit checking and\n+wrapping methods always be used when using Unsafe Rust.\n+\n+<small id=\"fn:2\">2\\. See <https://doc.rust-lang.org/std/primitive.u32.html>\n+for more information on the checked, overflowing, saturating, and wrapping\n+methods (using u32 as an example). <a href=\"#fnref:2\"\n+class=\"reversefootnote\" role=\"doc-backlink\">\u21a9</a></small>\n+\n+\n+### Non-executable memory regions\n+\n+Non-executable memory regions increase the difficulty of exploitation by\n+limiting the memory regions that can be used to execute arbitrary code. Most\n+modern processors provide support for the operating system to mark memory\n+regions as non executable, but it was previously emulated by software, such\n+as in grsecurity/PaX's\n+[PAGEEXEC](https://pax.grsecurity.net/docs/pageexec.txt) and\n+[SEGMEXEC](https://pax.grsecurity.net/docs/segmexec.txt), on processors that\n+did not provide support for it. This is also known as \u201cNo Execute (NX) Bit\u201d,\n+\u201cExecute Disable (XD) Bit\u201d, \u201cExecute Never (XN) Bit\u201d, and others.\n+\n+The Rust compiler supports non-executable memory regions, and enables it by\n+default since its initial release, version 0.1 (2012-01-20)[21], [22], but\n+has regressed since then[23]\u2013[25], and enforced by default since version\n+1.8.0 (2016-04-14)[25].\n+\n+```text\n+$ readelf -l target/release/hello-rust | grep -A 1 GNU_STACK\n+  GNU_STACK      0x0000000000000000 0x0000000000000000 0x0000000000000000\n+                 0x0000000000000000 0x0000000000000000  RW     0x10\n+```\n+Fig. 5.\u2003Checking if non-executable memory regions are enabled for a given\n+binary.\n+\n+The presence of an element of type `PT_GNU_STACK` in the program header\n+table with the `PF_X` (i.e., executable) flag unset indicates non-executable\n+memory regions<sup id=\"fnref:3\" role=\"doc-noteref\"><a href=\"#fn:3\"\n+class=\"footnote\">3</a></sup> are enabled for a given binary (see Fig. 5).\n+Conversely, the presence of an element of type `PT_GNU_STACK` in the program\n+header table with the `PF_X` flag set or the absence of an element of type\n+`PT_GNU_STACK` in the program header table indicates non-executable memory\n+regions are not enabled for a given binary.\n+\n+<small id=\"fn:3\">3\\. See the Appendix section for more information on why it\n+affects other memory regions besides the stack. <a href=\"#fnref:3\"\n+class=\"reversefootnote\" role=\"doc-backlink\">\u21a9</a></small>\n+\n+\n+### Stack clashing protection\n+\n+Stack clashing protection protects the stack from overlapping with another\n+memory region\u2014allowing arbitrary data in both to be overwritten using each\n+other\u2014by reading from the stack pages as the stack grows to cause a page\n+fault when attempting to read from the guard page/region. This is also\n+referred to as \u201cstack probes\u201d or \u201cstack probing\u201d.\n+\n+The Rust compiler supports stack clashing protection via stack probing, and\n+enables it by default since version 1.20.0 (2017-08-31)[26]\u2013[29].\n+\n+![Screenshot of IDA Pro listing cross references to __rust_probestack in hello-rust.](images/image1.png \"Cross references to __rust_probestack in hello-rust.\")\n+Fig. 6. IDA Pro listing cross references to `__rust_probestack` in\n+hello-rust.\n+\n+```rust\n+fn hello() {\n+    println!(\"Hello, world!\");\n+}\n+\n+fn main() {\n+    let _: [u64; 1024] = [0; 1024];\n+    hello();\n+}\n+```\n+Fig 7. Modified hello-rust.\n+\n+![Screenshot of IDA Pro listing cross references to __rust_probestack in modified hello-rust.](images/image2.png \"Cross references to __rust_probestack in modified hello-rust.\")\n+Fig. 8. IDA Pro listing cross references to `__rust_probestack` in modified\n+hello-rust.\n+\n+To check if stack clashing protection is enabled for a given binary, search\n+for cross references to `__rust_probestack`. The `__rust_probestack` is\n+called in the prologue of functions whose stack size is larger than a page\n+size (see Fig. 6), and can be forced for illustration purposes by modifying\n+the hello-rust example as seen in Fig. 7 and Fig. 8.\n+\n+\n+### Read-only relocations and immediate binding\n+\n+**Read-only relocations** protect segments containing relocations and\n+relocation information (i.e., `.init_array`, `.fini_array`, `.dynamic`, and\n+`.got`) from being overwritten by marking these segments read only. This is\n+also referred to as \u201cpartial RELRO\u201d.\n+\n+The Rust compiler supports read-only relocations, and enables it by default\n+since version 1.21.0 (2017-10-12)[30], [31].\n+\n+```text\n+$ readelf -l target/release/hello-rust | grep GNU_RELRO\n+  GNU_RELRO      0x000000000002ee00 0x000000000002fe00 0x000000000002fe00\n+```\n+Fig. 9.\u2003Checking if read-only relocations is enabled for a given binary.\n+\n+The presence of an element of type `PT_GNU_RELRO` in the program header\n+table indicates read-only relocations are enabled for a given binary (see\n+Fig. 9). Conversely, the absence of an element of type `PT_GNU_RELRO` in the\n+program header table indicates read-only relocations are not enabled for a\n+given binary.\n+\n+**Immediate binding** protects additional segments containing relocations\n+(i.e., `.got.plt`) from being overwritten by instructing the dynamic linker\n+to perform all relocations before transferring control to the program during\n+startup, so all segments containing relocations can be marked read only\n+(when combined with read-only relocations). This is also referred to as\n+\u201cfull RELRO\u201d.\n+\n+The Rust compiler supports immediate binding, and enables it by default\n+since version 1.21.0 (2017-10-12)[30], [31].\n+\n+```text\n+$ readelf -d target/release/hello-rust | grep BIND_NOW\n+ 0x000000000000001e (FLAGS)              BIND_NOW\n+```\n+Fig. 10.\u2003Checking if immediate binding is enabled for a given binary.\n+\n+The presence of an element with the `DT_BIND_NOW` tag and the `DF_BIND_NOW`\n+flag<sup id=\"fnref:4\" role=\"doc-noteref\"><a href=\"#fn:4\"\n+class=\"footnote\">4</a></sup> in the dynamic section indicates immediate\n+binding is enabled for a given binary (see Fig. 10). Conversely, the absence\n+of an element with the `DT_BIND_NOW` tag and the `DF_BIND_NOW` flag in the\n+dynamic section indicates immediate binding is not enabled for a given\n+binary.\n+\n+The presence of both an element of type `PT_GNU_RELRO` in the program header\n+table and of an element with the `DT_BIND_NOW` tag and the `DF_BIND_NOW`\n+flag in the dynamic section indicates full RELRO is enabled for a given\n+binary (see Fig. 9 and Fig. 10).\n+\n+<small id=\"fn:4\">4\\. And the `DF_1_NOW` flag for some link editors. <a\n+href=\"#fnref:4\" class=\"reversefootnote\" role=\"doc-backlink\">\u21a9</a></small>\n+\n+\n+### Heap corruption protection\n+\n+Heap corruption protection protects memory allocated dynamically by\n+performing several checks, such as checks for corrupted links between list\n+elements, invalid pointers, invalid sizes, double/multiple \u201cfrees\u201d of the\n+same memory allocated, and many corner cases of these. These checks are\n+implementation specific, and vary per allocator.\n+\n+[ARM Memory Tagging Extension\n+(MTE)](https://community.arm.com/developer/ip-products/processors/b/processors-ip-blog/posts/enhancing-memory-safety),\n+when available, will provide hardware assistance for a probabilistic\n+mitigation to detect memory safety violations by tagging memory allocations,\n+and automatically checking that the correct tag is used on every memory\n+access.\n+\n+Rust\u2019s default allocator has historically been\n+[jemalloc](http://jemalloc.net/), and it has long been the cause of issues\n+and the subject of much discussion[32]\u2013[38]. Consequently, it has been\n+removed as the default allocator in favor of the operating system\u2019s standard\n+C library default allocator<sup id=\"fnref:5\" role=\"doc-noteref\"><a\n+href=\"#fn:5\" class=\"footnote\">5</a></sup> since version 1.32.0\n+(2019-01-17)[39].\n+\n+```ignore\n+fn main() {\n+    let mut x = Box::new([0; 1024]);\n+\n+    for i in 0..1026 {\n+        unsafe {\n+            let elem = x.get_unchecked_mut(i);\n+            *elem = 0x4141414141414141u64;\n+        }\n+    }\n+}\n+```\n+Fig. 11.\u2003hello-rust-heap program.\n+\n+```text\n+$ cargo run\n+   Compiling hello-rust-heap v0.1.0 (/home/rcvalle/hello-rust-heap)\n+    Finished dev [unoptimized + debuginfo] target(s) in 0.25s\n+     Running `target/debug/hello-rust-heap`\n+free(): invalid next size (normal)\n+Aborted\n+```\n+Fig. 12.\u2003Build and execution of hello-rust-heap with debug assertions\n+enabled.\n+\n+```text\n+$ cargo run --release\n+   Compiling hello-rust-heap v0.1.0 (/home/rcvalle/hello-rust-heap)\n+    Finished release [optimized] target(s) in 0.25s\n+     Running `target/release/hello-rust-heap`\n+free(): invalid next size (normal)\n+Aborted\n+```\n+Fig. 13.\u2003Build and execution of hello-rust-heap with debug assertions\n+disabled.\n+\n+Heap corruption checks are being performed when using the default allocator\n+(i.e., the GNU Allocator) as seen in Fig. 12 and Fig. 13.\n+\n+<small id=\"fn:5\">5\\. Linux's standard C library default allocator is the GNU\n+Allocator, which is derived from ptmalloc (pthreads malloc) by Wolfram\n+Gloger, which in turn is derived from dlmalloc (Doug Lea malloc) by Doug\n+Lea. <a href=\"#fnref:5\" class=\"reversefootnote\"\n+role=\"doc-backlink\">\u21a9</a></small>\n+\n+\n+### Stack smashing protection\n+\n+Stack smashing protection protects programs from stack-based buffer\n+overflows by inserting a random guard value between local variables and the\n+saved return instruction pointer, and checking if this value has changed\n+when returning from a function. This is also known as \u201cStack Protector\u201d or\n+\u201cStack Smashing Protector (SSP)\u201d.\n+\n+The Rust compiler does not support stack smashing protection. However, more\n+comprehensive alternatives to stack smashing protection exist, such as\n+shadow and safe stack (see backward-edge control flow protection).\n+\n+![Screenshot of IDA Pro listing cross references to __stack_chk_fail in hello-rust.](images/image3.png \"Cross references to __stack_chk_fail in hello-rust.\")\n+Fig. 14. IDA Pro listing cross references to `__stack_chk_fail` in\n+hello-rust.\n+\n+To check if stack smashing protection is enabled for a given binary, search\n+for cross references to `__stack_chk_fail`. The only cross references to\n+`__stack_chk_fail` in hello-rust are from the statically-linked libbacktrace\n+library (see Fig. 14).\n+\n+\n+### Forward-edge control flow protection\n+\n+Forward-edge control flow protection protects programs from having its\n+control flow changed/hijacked by performing checks to ensure that\n+destinations of indirect branches are one of their valid destinations in the\n+control flow graph. The comprehensiveness of these checks vary per\n+implementation. This is also known as \u201cforward-edge control flow integrity\n+(CFI)\u201d.\n+\n+Newer processors provide hardware assistance for forward-edge control flow\n+protection, such as ARM Branch Target Identification (BTI), ARM Pointer\n+Authentication, and Intel Indirect Branch Tracking (IBT) as part of Intel\n+Control-flow Enforcement Technology (CET). However, ARM BTI and Intel IBT\n+-based implementations are less comprehensive than software-based\n+implementations such as [LLVM ControlFlowIntegrity\n+(CFI)](https://clang.llvm.org/docs/ControlFlowIntegrity.html), and the\n+commercially available [grsecurity/PaX Reuse Attack Protector\n+(RAP)](https://grsecurity.net/rap_faq).\n+\n+The Rust compiler does not support forward-edge control flow protection on\n+Linux<sup id=\"fnref:6\" role=\"doc-noteref\"><a href=\"#fn:6\"\n+class=\"footnote\">6</a></sup>. There is work currently ongoing to add support\n+for the [sanitizers](https://github.com/google/sanitizers)[40], which may or\n+may not include support for LLVM CFI.\n+\n+```text\n+$ readelf -s target/release/hello-rust | grep __cfi_init\n+```\n+Fig. 15.\u2003Checking if LLVM CFI is enabled for a given binary.\n+\n+The presence of the `__cfi_init` symbol (and references to `__cfi_check`)\n+indicates that LLVM CFI (i.e., forward-edge control flow protection) is\n+enabled for a given binary. Conversely, the absence of the `__cfi_init`\n+symbol (and references to `__cfi_check`) indicates that LLVM CFI is not\n+enabled for a given binary (see Fig. 15).\n+\n+<small id=\"fn:6\">6\\. It supports Control Flow Guard (CFG) on Windows (see\n+<https://github.com/rust-lang/rust/issues/68793>). <a href=\"#fnref:6\"\n+class=\"reversefootnote\" role=\"doc-backlink\">\u21a9</a></small>\n+\n+\n+### Backward-edge control flow protection\n+\n+**Shadow stack** protects saved return instruction pointers from being\n+overwritten by storing a copy of them on a separate (shadow) stack, and\n+using these copies as authoritative values when returning from functions.\n+This is also known as \u201cShadowCallStack\u201d and \u201cReturn Flow Guard\u201d, and is\n+considered an implementation of backward-edge control flow protection (or\n+\u201cbackward-edge CFI\u201d).\n+\n+**Safe stack** protects not only the saved return instruction pointers, but\n+also register spills and some local variables from being overwritten by\n+storing unsafe variables, such as large arrays, on a separate (unsafe)\n+stack, and using these unsafe variables on the separate stack instead. This\n+is also known as \u201cSafeStack\u201d, and is also considered an implementation of\n+backward-edge control flow protection.\n+\n+Both shadow and safe stack are intended to be a more comprehensive\n+alternatives to stack smashing protection as they protect the saved return\n+instruction pointers (and other data in the case of safe stack) from\n+arbitrary writes and non-linear out-of-bounds writes.\n+\n+Newer processors provide hardware assistance for backward-edge control flow\n+protection, such as ARM Pointer Authentication, and Intel Shadow Stack as\n+part of Intel CET.\n+\n+The Rust compiler does not support shadow or safe stack. There is work\n+currently ongoing to add support for the sanitizers[40], which may or may\n+not include support for safe stack<sup id=\"fnref:7\" role=\"doc-noteref\"><a\n+href=\"#fn:7\" class=\"footnote\">7</a></sup>.\n+\n+```text\n+$ readelf -s target/release/hello-rust | grep __safestack_init\n+```\n+Fig. 16.\u2003Checking if LLVM SafeStack is enabled for a given binary.\n+\n+The presence of the `__safestack_init` symbol indicates that LLVM SafeStack\n+is enabled for a given binary. Conversely, the absence of the\n+`__safestack_init` symbol indicates that LLVM SafeStack is not enabled for a\n+given binary (see Fig. 16).\n+\n+<small id=\"fn:7\">7\\. The shadow stack implementation for the AMD64\n+architecture and equivalent in LLVM was removed due to performance and\n+security issues. <a href=\"#fnref:7\" class=\"reversefootnote\"\n+role=\"doc-backlink\">\u21a9</a></small>\n+\n+\n+## Appendix\n+\n+As of the latest version of the [Linux Standard Base (LSB) Core\n+Specification](https://refspecs.linuxfoundation.org/LSB_5.0.0/LSB-Core-generic/LSB-Core-generic/progheader.html),\n+the `PT_GNU_STACK` program header indicates whether the stack should be\n+executable, and the absence of this header indicates that the stack should\n+be executable. However, the Linux kernel currently sets the\n+`READ_IMPLIES_EXEC` personality upon loading any executable with the\n+`PT_GNU_STACK` program header and the `PF_X `flag set or with the absence of\n+this header, resulting in not only the stack, but also all readable virtual\n+memory mappings being executable.\n+\n+An attempt to fix this [was made in\n+2012](https://lore.kernel.org/lkml/f298f914-2239-44e4-8aa1-a51282e7fac0@zmail15.collab.prod.int.phx2.redhat.com/),\n+and another [was made in\n+2020](https://lore.kernel.org/kernel-hardening/20200327064820.12602-1-keescook@chromium.org/).\n+The former never landed, and the latter partially fixed it, but introduced\n+other issues\u2014the absence of the `PT_GNU_STACK` program header still causes\n+not only the stack, but also all readable virtual memory mappings to be\n+executable in some architectures, such as IA-32 and equivalent (or causes\n+the stack to be non-executable in some architectures, such as AMD64 and\n+equivalent, contradicting the LSB).\n+\n+The `READ_IMPLIES_EXEC` personality needs to be completely separated from\n+the `PT_GNU_STACK` program header by having a separate option for it (or\n+setarch -X could just be used whenever `READ_IMPLIES_EXEC` is needed), and\n+the absence of the `PT_GNU_STACK` program header needs to have more secure\n+defaults (unrelated to `READ_IMPLIES_EXEC`).\n+\n+\n+## References\n+\n+1. D. Hosfelt. \u201cFearless security: memory safety.\u201d Mozilla Hacks.\n+   <https://hacks.mozilla.org/2019/01/fearless-security-memory-safety/>.\n+\n+2. D. Hosfelt. \u201cFearless security: thread safety.\u201d Mozilla Hacks.\n+   <https://hacks.mozilla.org/2019/02/fearless-security-thread-safety/>.\n+\n+3. S. Klabnik and C. Nichols. \u201cWhat Is Ownership?.\u201d The Rust Programming\n+   Language. <https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html>.\n+\n+4. S. Klabnik and C. Nichols. \u201cReferences and Borrowing.\u201d The Rust\n+   Programming Language.\n+   <https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html>.\n+\n+5. S. Klabnik and C. Nichols. \u201cThe Slice Type.\u201d The Rust Programming\n+   Language. <https://doc.rust-lang.org/book/ch04-03-slices.html>.\n+\n+6. S. Klabnik and C. Nichols. \u201cUnsafe Rust.\u201d The Rust Programming Language.\n+   <https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html>.\n+\n+7. S. Davidoff. \u201cHow Rust\u2019s standard library was vulnerable for years and\n+   nobody noticed.\u201d Medium.\n+   <https://medium.com/@shnatsel/how-rusts-standard-library-was-vulnerable-for-years-and-nobody-noticed-aebf0503c3d6>.\n+\n+8. \u201cImproper restriction of operations within the bounds of a memory buffer\n+   (CWE-119).\u201d MITRE CWE List.\n+   <https://cwe.mitre.org/data/definitions/119.html>.\n+\n+9. \u201cConcurrency issues (CWE-557).\u201d MITRE CWE List.\n+   <https://cwe.mitre.org/data/definitions/557.html>.\n+\n+10. K. McAllister. \u201cMemory exploit mitigations #15179.\u201d GitHub.\n+    <https://github.com/rust-lang/rust/issues/15179>.\n+\n+11. K. McAllister. \u201cRFC: Memory exploit mitigation #145.\u201d GitHub.\n+    <https://github.com/rust-lang/rfcs/pull/145>.\n+\n+12. K. McAllister. \u201cRFC: Memory exploit mitigation.\u201d GitHub.\n+    <https://github.com/kmcallister/rfcs/blob/hardening/active/0000-memory-exploit-mitigation.md>.\n+\n+13. D. Micay. \u201cEnable PIE by default on Linux for full ASLR #16340.\u201d GitHub.\n+    <https://github.com/rust-lang/rust/pull/16340>.\n+\n+14. N. Matsakis. \u201cInteger overflow #560.\u201d GitHub.\n+    <https://github.com/rust-lang/rfcs/pull/560>.\n+\n+15. G. Lehel and N. Matsakis. \u201cInteger overflow.\u201d GitHub.\n+    <https://rust-lang.github.io/rfcs/0560-integer-overflow.html>.\n+\n+16. A. Turon. \u201cTracking issue for integer overflow (RFC 560) #22020.\u201d\n+    GitHub. <https://github.com/rust-lang/rust/issues/22020>.\n+\n+17. H. Wilson. \u201cMyths and legends about integer overflow in Rust.\u201d Huon on\n+    the Internet.\n+    <http://huonw.github.io/blog/2016/04/myths-and-legends-about-integer-overflow-in-rust/>.\n+\n+18. B. Anderson. \u201cStabilize -C overflow-checks #1535.\u201d GitHub.\n+    <https://github.com/rust-lang/rfcs/pull/1535>.\n+\n+19. B. Anderson. \u201cStable overflow checks.\u201d GitHub.\n+    <https://github.com/brson/rfcs/blob/overflow/text/0000-stable-overflow-checks.md>.\n+\n+20. N. Froyd. \u201cAdd -C overflow-checks option #40037.\u201d GitHub.\n+    <https://github.com/rust-lang/rust/pull/40037>.\n+\n+21. R. \u00c1. de Esp\u00edndola. \u201crustc requires executable stack #798.\u201d GitHub.\n+    <https://github.com/rust-lang/rust/issues/798>.\n+\n+22. A. Seipp. \u201cMake sure librustrt.so is linked with a non-executable stack.\n+    #1066.\u201d GitHub. <https://github.com/rust-lang/rust/pull/1066>.\n+\n+23. D. Micay. \u201cRust binaries should not have an executable stack #5643.\u201d\n+    GitHub. <https://github.com/rust-lang/rust/issues/5643>.\n+\n+24. D. Micay. \u201cMark the assembly object stacks as non-executable #5647.\u201d\n+    GitHub. <https://github.com/rust-lang/rust/pull/5647>.\n+\n+25. A. Clark. \u201cExplicitly disable stack execution on linux and bsd #30859.\u201d\n+    GitHub. <https://github.com/rust-lang/rust/pull/30859>.\n+\n+26. \u201cReplace stack overflow checking with stack probes #16012.\u201d GitHub.\n+    <https://github.com/rust-lang/rust/issues/16012>.\n+\n+27. B. Striegel. \u201cExtend stack probe support to non-tier-1 platforms, and\n+    clarify policy for mitigating LLVM-dependent unsafety #43241.\u201d GitHub.\n+    <https://github.com/rust-lang/rust/issues/43241>.\n+\n+28. A. Crichton. \u201crustc: Implement stack probes for x86 #42816.\u201d GitHub.\n+    <https://github.com/rust-lang/rust/pull/42816>.\n+\n+29. A. Crichton. \u201cAdd \\_\\_rust\\_probestack intrinsic #175.\u201d GitHub.\n+    <https://github.com/rust-lang/compiler-builtins/pull/175>.\n+\n+30. B. Anderson. \u201cConsider applying -Wl,-z,relro or -Wl,-z,relro,-z,now by\n+    default #29877.\u201d GitHub. <https://github.com/rust-lang/rust/issues/29877>.\n+\n+31. J. L\u00f6thberg. \u201cAdd support for full RELRO #43170.\u201d GitHub.\n+    <https://github.com/rust-lang/rust/pull/43170>.\n+\n+32. N. Matsakis. \u201cAllocators in Rust.\u201d Baby Steps.\n+    <http://smallcultfollowing.com/babysteps/blog/2014/11/14/allocators-in-rust/>.\n+\n+33. A. Crichton. \u201cRFC: Allow changing the default allocator #1183.\u201d GitHub.\n+    <https://github.com/rust-lang/rfcs/pull/1183>.\n+\n+34. A. Crichton. \u201cRFC: Swap out jemalloc.\u201d GitHub.\n+    <https://rust-lang.github.io/rfcs/1183-swap-out-jemalloc.html>.\n+\n+35. A. Crichton. \u201cTracking issue for changing the global, default allocator\n+    (RFC 1974) #27389.\u201d GitHub.\n+    <https://github.com/rust-lang/rust/issues/27389>.\n+\n+36. S. Fackler. \u201cPrepare global allocators for stabilization #1974.\u201d GitHub.\n+    <https://github.com/rust-lang/rfcs/pull/1974>.\n+\n+37. A. Crichton. \u201cRFC: Global allocators.\u201d GitHub.\n+    <https://rust-lang.github.io/rfcs/1974-global-allocators.html>.\n+\n+38. B. Anderson. \u201cSwitch the default global allocator to System, remove\n+    alloc\\_jemalloc, use jemallocator in rustc #36963.\u201d GitHub.\n+    <https://github.com/rust-lang/rust/issues/36963>.\n+\n+39. A. Crichton. \u201cRemove the alloc\\_jemalloc crate #55238.\u201d GitHub.\n+    <https://github.com/rust-lang/rust/pull/55238>.\n+\n+40. J. Aparicio. 2017. \u201cTracking issue for sanitizer support #39699.\u201d\n+    <https://github.com/rust-lang/rust/issues/39699>."}, {"sha": "ee2d3fd4f43c6727b5042114519e12917242c3c6", "filename": "src/doc/rustc/src/images/image1.png", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8fde4be7d042a348387a82832a44076cfbf334ca/src%2Fdoc%2Frustc%2Fsrc%2Fimages%2Fimage1.png", "raw_url": "https://github.com/rust-lang/rust/raw/8fde4be7d042a348387a82832a44076cfbf334ca/src%2Fdoc%2Frustc%2Fsrc%2Fimages%2Fimage1.png", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Fimages%2Fimage1.png?ref=8fde4be7d042a348387a82832a44076cfbf334ca"}, {"sha": "03061e1f0b12dced3a87d9e4e913c1d47559f578", "filename": "src/doc/rustc/src/images/image2.png", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8fde4be7d042a348387a82832a44076cfbf334ca/src%2Fdoc%2Frustc%2Fsrc%2Fimages%2Fimage2.png", "raw_url": "https://github.com/rust-lang/rust/raw/8fde4be7d042a348387a82832a44076cfbf334ca/src%2Fdoc%2Frustc%2Fsrc%2Fimages%2Fimage2.png", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Fimages%2Fimage2.png?ref=8fde4be7d042a348387a82832a44076cfbf334ca"}, {"sha": "a49e14b5ed22298a41d2e7bdd4b56a396b42fb94", "filename": "src/doc/rustc/src/images/image3.png", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8fde4be7d042a348387a82832a44076cfbf334ca/src%2Fdoc%2Frustc%2Fsrc%2Fimages%2Fimage3.png", "raw_url": "https://github.com/rust-lang/rust/raw/8fde4be7d042a348387a82832a44076cfbf334ca/src%2Fdoc%2Frustc%2Fsrc%2Fimages%2Fimage3.png", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Fimages%2Fimage3.png?ref=8fde4be7d042a348387a82832a44076cfbf334ca"}]}