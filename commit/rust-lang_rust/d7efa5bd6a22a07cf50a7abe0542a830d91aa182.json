{"sha": "d7efa5bd6a22a07cf50a7abe0542a830d91aa182", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ3ZWZhNWJkNmEyMmEwN2NmNTBhN2FiZTA1NDJhODMwZDkxYWExODI=", "commit": {"author": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2019-11-17T01:10:13Z"}, "committer": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2019-11-17T01:10:13Z"}, "message": "review comments", "tree": {"sha": "aa4f7d27eba6f21f91411dade14368ebf75260a3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aa4f7d27eba6f21f91411dade14368ebf75260a3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d7efa5bd6a22a07cf50a7abe0542a830d91aa182", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d7efa5bd6a22a07cf50a7abe0542a830d91aa182", "html_url": "https://github.com/rust-lang/rust/commit/d7efa5bd6a22a07cf50a7abe0542a830d91aa182", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d7efa5bd6a22a07cf50a7abe0542a830d91aa182/comments", "author": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "committer": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0487f0c0c38c1bae95bd786bc044307a3ff082e6", "url": "https://api.github.com/repos/rust-lang/rust/commits/0487f0c0c38c1bae95bd786bc044307a3ff082e6", "html_url": "https://github.com/rust-lang/rust/commit/0487f0c0c38c1bae95bd786bc044307a3ff082e6"}], "stats": {"total": 172, "additions": 91, "deletions": 81}, "files": [{"sha": "b1652f58772d04cc47876dc6bb7bee47db1d8188", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 91, "deletions": 81, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/d7efa5bd6a22a07cf50a7abe0542a830d91aa182/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7efa5bd6a22a07cf50a7abe0542a830d91aa182/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=d7efa5bd6a22a07cf50a7abe0542a830d91aa182", "patch": "@@ -1230,6 +1230,24 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         }\n     }\n \n+    fn mk_obligation_for_def_id(\n+        &self,\n+        def_id: DefId,\n+        output_ty: Ty<'tcx>,\n+        cause: ObligationCause<'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+    ) -> PredicateObligation<'tcx> {\n+        let new_trait_ref = ty::TraitRef {\n+            def_id,\n+            substs: self.tcx.mk_substs_trait(output_ty, &[]),\n+        };\n+        Obligation::new(cause, param_env, new_trait_ref.to_predicate())\n+    }\n+\n+\n+    /// We tried to apply the bound to an `fn` or closure. Check whether calling it would\n+    /// evaluate to a type that *would* satisfy the trait binding. If it would, suggest calling\n+    /// it: `bar(foo)` \u2192 `bar(foo())`. This case is *very* likely to be hit if `foo` is `async`.\n     fn suggest_fn_call(\n         &self,\n         obligation: &PredicateObligation<'tcx>,\n@@ -1248,19 +1266,14 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             _ => return,\n         };\n         let msg = format!(\"use parentheses to call the {}\", callable);\n-        // We tried to apply the bound to an `fn` or closure. Check whether calling it would\n-        // evaluate to a type that *would* satisfy the trait binding. If it would, suggest calling\n-        // it: `bar(foo)` \u2192 `bar(foo())`. This case is *very* likely to be hit if `foo` is `async`.\n \n-        let new_trait_ref = ty::TraitRef {\n-            def_id: trait_ref.def_id(),\n-            substs: self.tcx.mk_substs_trait(output_ty.skip_binder(), &[]),\n-        };\n-        let obligation = Obligation::new(\n+        let obligation = self.mk_obligation_for_def_id(\n+            trait_ref.def_id(),\n+            output_ty.skip_binder(),\n             obligation.cause.clone(),\n             obligation.param_env,\n-            new_trait_ref.to_predicate(),\n         );\n+\n         let get_name = |err: &mut DiagnosticBuilder<'_>, kind: &hir::PatKind| -> Option<String> {\n             // Get the local name of this closure. This can be inaccurate because\n             // of the possibility of reassignment, but this should be good enough.\n@@ -1277,73 +1290,72 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         match self.evaluate_obligation(&obligation) {\n             Ok(EvaluationResult::EvaluatedToOk) |\n             Ok(EvaluationResult::EvaluatedToOkModuloRegions) |\n-            Ok(EvaluationResult::EvaluatedToAmbig) => {\n-                let hir = self.tcx.hir();\n-                // Get the name of the callable and the arguments to be used in the suggestion.\n-                let snippet = match hir.get_if_local(def_id) {\n-                    Some(hir::Node::Expr(hir::Expr {\n-                        kind: hir::ExprKind::Closure(_, decl, _, span, ..),\n-                        ..\n-                    })) => {\n-                        err.span_label(*span, \"consider calling this closure\");\n-                        let hir_id = match hir.as_local_hir_id(def_id) {\n-                            Some(hir_id) => hir_id,\n-                            None => return,\n-                        };\n-                        let parent_node = hir.get_parent_node(hir_id);\n-                        let name = match hir.find(parent_node) {\n-                            Some(hir::Node::Stmt(hir::Stmt {\n-                                kind: hir::StmtKind::Local(local), ..\n-                            })) => match get_name(err, &local.pat.kind) {\n-                                Some(name) => name,\n-                                None => return,\n-                            },\n-                            // Different to previous arm because one is `&hir::Local` and the other\n-                            // is `P<hir::Local>`.\n-                            Some(hir::Node::Local(local)) => match get_name(err, &local.pat.kind) {\n-                                Some(name) => name,\n-                                None => return,\n-                            },\n-                            _ => return,\n-                        };\n-                        let args = decl.inputs.iter()\n-                            .map(|_| \"_\")\n-                            .collect::<Vec<_>>().join(\", \");\n-                        format!(\"{}({})\", name, args)\n-                    }\n-                    Some(hir::Node::Item(hir::Item {\n-                        ident,\n-                        kind: hir::ItemKind::Fn(.., body_id),\n-                        ..\n-                    })) => {\n-                        err.span_label(ident.span, \"consider calling this function\");\n-                        let body = hir.body(*body_id);\n-                        let args = body.params.iter()\n-                            .map(|arg| match &arg.pat.kind {\n-                                hir::PatKind::Binding(_, _, ident, None)\n-                                if ident.name != kw::SelfLower => ident.to_string(),\n-                                _ => \"_\".to_string(),\n-                            }).collect::<Vec<_>>().join(\", \");\n-                        format!(\"{}({})\", ident, args)\n-                    }\n+            Ok(EvaluationResult::EvaluatedToAmbig) => {}\n+            _ => return,\n+        }\n+        let hir = self.tcx.hir();\n+        // Get the name of the callable and the arguments to be used in the suggestion.\n+        let snippet = match hir.get_if_local(def_id) {\n+            Some(hir::Node::Expr(hir::Expr {\n+                kind: hir::ExprKind::Closure(_, decl, _, span, ..),\n+                ..\n+            })) => {\n+                err.span_label(*span, \"consider calling this closure\");\n+                let hir_id = match hir.as_local_hir_id(def_id) {\n+                    Some(hir_id) => hir_id,\n+                    None => return,\n+                };\n+                let parent_node = hir.get_parent_node(hir_id);\n+                let name = match hir.find(parent_node) {\n+                    Some(hir::Node::Stmt(hir::Stmt {\n+                        kind: hir::StmtKind::Local(local), ..\n+                    })) => match get_name(err, &local.pat.kind) {\n+                        Some(name) => name,\n+                        None => return,\n+                    },\n+                    // Different to previous arm because one is `&hir::Local` and the other\n+                    // is `P<hir::Local>`.\n+                    Some(hir::Node::Local(local)) => match get_name(err, &local.pat.kind) {\n+                        Some(name) => name,\n+                        None => return,\n+                    },\n                     _ => return,\n                 };\n-                if points_at_arg {\n-                    // When the obligation error has been ensured to have been caused by\n-                    // an argument, the `obligation.cause.span` points at the expression\n-                    // of the argument, so we can provide a suggestion. This is signaled\n-                    // by `points_at_arg`. Otherwise, we give a more general note.\n-                    err.span_suggestion(\n-                        obligation.cause.span,\n-                        &msg,\n-                        snippet,\n-                        Applicability::HasPlaceholders,\n-                    );\n-                } else {\n-                    err.help(&format!(\"{}: `{}`\", msg, snippet));\n-                }\n+                let args = decl.inputs.iter()\n+                    .map(|_| \"_\")\n+                    .collect::<Vec<_>>().join(\", \");\n+                format!(\"{}({})\", name, args)\n+            }\n+            Some(hir::Node::Item(hir::Item {\n+                ident,\n+                kind: hir::ItemKind::Fn(.., body_id),\n+                ..\n+            })) => {\n+                err.span_label(ident.span, \"consider calling this function\");\n+                let body = hir.body(*body_id);\n+                let args = body.params.iter()\n+                    .map(|arg| match &arg.pat.kind {\n+                        hir::PatKind::Binding(_, _, ident, None)\n+                        if ident.name != kw::SelfLower => ident.to_string(),\n+                        _ => \"_\".to_string(),\n+                    }).collect::<Vec<_>>().join(\", \");\n+                format!(\"{}({})\", ident, args)\n             }\n-            _ => {}\n+            _ => return,\n+        };\n+        if points_at_arg {\n+            // When the obligation error has been ensured to have been caused by\n+            // an argument, the `obligation.cause.span` points at the expression\n+            // of the argument, so we can provide a suggestion. This is signaled\n+            // by `points_at_arg`. Otherwise, we give a more general note.\n+            err.span_suggestion(\n+                obligation.cause.span,\n+                &msg,\n+                snippet,\n+                Applicability::HasPlaceholders,\n+            );\n+        } else {\n+            err.help(&format!(\"{}: `{}`\", msg, snippet));\n         }\n     }\n \n@@ -1377,12 +1389,11 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 if let ty::Ref(_, t_type, _) = trait_type.kind {\n                     trait_type = t_type;\n \n-                    let substs = self.tcx.mk_substs_trait(trait_type, &[]);\n-                    let new_trait_ref = ty::TraitRef::new(trait_ref.def_id, substs);\n-                    let new_obligation = Obligation::new(\n+                    let new_obligation = self.mk_obligation_for_def_id(\n+                        trait_ref.def_id,\n+                        trait_type,\n                         ObligationCause::dummy(),\n                         obligation.param_env,\n-                        new_trait_ref.to_predicate(),\n                     );\n \n                     if self.predicate_may_hold(&new_obligation) {\n@@ -1440,12 +1451,11 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     hir::Mutability::Immutable => self.tcx.mk_mut_ref(region, t_type),\n                 };\n \n-                let substs = self.tcx.mk_substs_trait(&trait_type, &[]);\n-                let new_trait_ref = ty::TraitRef::new(trait_ref.skip_binder().def_id, substs);\n-                let new_obligation = Obligation::new(\n+                let new_obligation = self.mk_obligation_for_def_id(\n+                    trait_ref.skip_binder().def_id,\n+                    trait_type,\n                     ObligationCause::dummy(),\n                     obligation.param_env,\n-                    new_trait_ref.to_predicate(),\n                 );\n \n                 if self.evaluate_obligation_no_overflow("}]}