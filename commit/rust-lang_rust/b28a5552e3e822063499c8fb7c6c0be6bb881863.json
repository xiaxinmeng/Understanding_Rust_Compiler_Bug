{"sha": "b28a5552e3e822063499c8fb7c6c0be6bb881863", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIyOGE1NTUyZTNlODIyMDYzNDk5YzhmYjdjNmMwYmU2YmI4ODE4NjM=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-02-07T10:25:04Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-02-07T13:36:02Z"}, "message": "Reuse monomorphized functions for different box types\n\nThe free glue for opaque boxes will pick the actual tydesc out of the\nbox, and call its glue.\n\nIssue #1736", "tree": {"sha": "837024f6ad4c54e40b200c716c5a1370ee5ff110", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/837024f6ad4c54e40b200c716c5a1370ee5ff110"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b28a5552e3e822063499c8fb7c6c0be6bb881863", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b28a5552e3e822063499c8fb7c6c0be6bb881863", "html_url": "https://github.com/rust-lang/rust/commit/b28a5552e3e822063499c8fb7c6c0be6bb881863", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b28a5552e3e822063499c8fb7c6c0be6bb881863/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3bd0338c19a594d538bc6dd4656c0cb8da9b9680", "url": "https://api.github.com/repos/rust-lang/rust/commits/3bd0338c19a594d538bc6dd4656c0cb8da9b9680", "html_url": "https://github.com/rust-lang/rust/commit/3bd0338c19a594d538bc6dd4656c0cb8da9b9680"}], "stats": {"total": 488, "additions": 228, "deletions": 260}, "files": [{"sha": "9a3d6b21512b4c154948853c3692afb55f385628", "filename": "src/comp/metadata/tydecode.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b28a5552e3e822063499c8fb7c6c0be6bb881863/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b28a5552e3e822063499c8fb7c6c0be6bb881863/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Ftydecode.rs?ref=b28a5552e3e822063499c8fb7c6c0be6bb881863", "patch": "@@ -301,6 +301,7 @@ fn parse_ty(st: @pstate, conv: conv_did) -> ty::t {\n         let inner = parse_ty(st, conv);\n         ty::mk_named(st.tcx, inner, name)\n       }\n+      'B' { ty::mk_opaque_box(st.tcx) }\n       c { #error(\"unexpected char in type string: %c\", c); fail;}\n     }\n }"}, {"sha": "829947a193f2e4cd082bf9699926f7465b869e51", "filename": "src/comp/metadata/tyencode.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b28a5552e3e822063499c8fb7c6c0be6bb881863/src%2Fcomp%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b28a5552e3e822063499c8fb7c6c0be6bb881863/src%2Fcomp%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Ftyencode.rs?ref=b28a5552e3e822063499c8fb7c6c0be6bb881863", "patch": "@@ -192,6 +192,7 @@ fn enc_sty(w: io::writer, cx: @ctxt, st: ty::sty) {\n         for tc: @ty::type_constr in cs { enc_ty_constr(w, cx, tc); }\n         w.write_char(']');\n       }\n+      ty::ty_opaque_box { w.write_char('B'); }\n     }\n }\n fn enc_proto(w: io::writer, proto: proto) {"}, {"sha": "f1f7ddaf7b88eda29e53ca5d035d302f0e7e6e97", "filename": "src/comp/middle/shape.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b28a5552e3e822063499c8fb7c6c0be6bb881863/src%2Fcomp%2Fmiddle%2Fshape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b28a5552e3e822063499c8fb7c6c0be6bb881863/src%2Fcomp%2Fmiddle%2Fshape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fshape.rs?ref=b28a5552e3e822063499c8fb7c6c0be6bb881863", "patch": "@@ -381,6 +381,10 @@ fn shape_of(ccx: @crate_ctxt, t: ty::t, ty_param_map: [uint]) -> [u8] {\n         s += [shape_box];\n         add_substr(s, shape_of(ccx, mt.ty, ty_param_map));\n       }\n+      ty::ty_opaque_box {\n+        s += [shape_box];\n+        add_substr(s, [shape_u8]);\n+      }\n       ty::ty_uniq(mt) {\n         s += [shape_uniq];\n         add_substr(s, shape_of(ccx, mt.ty, ty_param_map));"}, {"sha": "2f4417d751afa59678cf99779db76d5abc26cf82", "filename": "src/comp/middle/trans/base.rs", "status": "modified", "additions": 152, "deletions": 150, "changes": 302, "blob_url": "https://github.com/rust-lang/rust/blob/b28a5552e3e822063499c8fb7c6c0be6bb881863/src%2Fcomp%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b28a5552e3e822063499c8fb7c6c0be6bb881863/src%2Fcomp%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Fbase.rs?ref=b28a5552e3e822063499c8fb7c6c0be6bb881863", "patch": "@@ -47,24 +47,11 @@ import common::*;\n import build::*;\n import ast_map::{path, path_mod, path_name};\n \n-fn type_of_1(bcx: @block_ctxt, t: ty::t) -> TypeRef {\n-    let cx = bcx_ccx(bcx);\n-    check type_has_static_size(cx, t);\n-    type_of(cx, t)\n-}\n-\n-fn type_of(cx: @crate_ctxt, t: ty::t) : type_has_static_size(cx, t)\n-   -> TypeRef {\n-    type_of_inner(cx, t)\n-}\n-\n-fn type_of_explicit_args(cx: @crate_ctxt, inputs: [ty::arg]) ->\n-   [TypeRef] {\n-    let tcx = ccx_tcx(cx);\n+fn type_of_explicit_args(cx: @crate_ctxt, inputs: [ty::arg]) -> [TypeRef] {\n     vec::map(inputs) {|arg|\n         let arg_ty = arg.ty;\n-        let llty = type_of_inner(cx, arg_ty);\n-        alt ty::resolved_mode(tcx, arg.mode) {\n+        let llty = type_of(cx, arg_ty);\n+        alt ty::resolved_mode(cx.tcx, arg.mode) {\n           ast::by_val { llty }\n           _ { T_ptr(llty) }\n         }\n@@ -83,8 +70,7 @@ fn type_of_fn(cx: @crate_ctxt, inputs: [ty::arg],\n     let atys: [TypeRef] = [];\n \n     // Arg 0: Output pointer.\n-    let out_ty = T_ptr(type_of_inner(cx, output));\n-    atys += [out_ty];\n+    atys += [T_ptr(type_of(cx, output))];\n \n     // Arg 1: Environment\n     atys += [T_opaque_box_ptr(cx)];\n@@ -110,16 +96,13 @@ fn type_of_fn_from_ty(cx: @crate_ctxt, fty: ty::t,\n     type_of_fn(cx, ty::ty_fn_args(fty), ty::ty_fn_ret(fty), param_bounds)\n }\n \n-fn type_of_inner(cx: @crate_ctxt, t: ty::t) -> TypeRef {\n+fn type_of(cx: @crate_ctxt, t: ty::t) -> TypeRef {\n     assert !ty::type_has_vars(t);\n     // Check the cache.\n \n     if cx.lltypes.contains_key(t) { ret cx.lltypes.get(t); }\n     let llty = alt ty::get(t).struct {\n-      ty::ty_nil { T_nil() }\n-      ty::ty_bot {\n-        T_nil() /* ...I guess? */\n-      }\n+      ty::ty_nil | ty::ty_bot { T_nil() }\n       ty::ty_bool { T_bool() }\n       ty::ty_int(t) { T_int_ty(cx, t) }\n       ty::ty_uint(t) { T_uint_ty(cx, t) }\n@@ -128,25 +111,26 @@ fn type_of_inner(cx: @crate_ctxt, t: ty::t) -> TypeRef {\n       ty::ty_enum(did, _) { type_of_enum(cx, did, t) }\n       ty::ty_box(mt) {\n         let mt_ty = mt.ty;\n-        T_ptr(T_box(cx, type_of_inner(cx, mt_ty))) }\n+        T_ptr(T_box(cx, type_of(cx, mt_ty))) }\n+      ty::ty_opaque_box { T_ptr(T_box(cx, T_i8())) }\n       ty::ty_uniq(mt) {\n         let mt_ty = mt.ty;\n-        T_ptr(type_of_inner(cx, mt_ty)) }\n+        T_ptr(type_of(cx, mt_ty)) }\n       ty::ty_vec(mt) {\n         let mt_ty = mt.ty;\n         if ty::type_has_dynamic_size(cx.tcx, mt_ty) {\n             T_ptr(cx.opaque_vec_type)\n         } else {\n-            T_ptr(T_vec(cx, type_of_inner(cx, mt_ty))) }\n+            T_ptr(T_vec(cx, type_of(cx, mt_ty))) }\n       }\n       ty::ty_ptr(mt) {\n         let mt_ty = mt.ty;\n-        T_ptr(type_of_inner(cx, mt_ty)) }\n+        T_ptr(type_of(cx, mt_ty)) }\n       ty::ty_rec(fields) {\n         let tys: [TypeRef] = [];\n         for f: ty::field in fields {\n             let mt_ty = f.mt.ty;\n-            tys += [type_of_inner(cx, mt_ty)];\n+            tys += [type_of(cx, mt_ty)];\n         }\n         T_struct(tys)\n       }\n@@ -157,33 +141,21 @@ fn type_of_inner(cx: @crate_ctxt, t: ty::t) -> TypeRef {\n       ty::ty_res(_, sub, tps) {\n         let sub1 = ty::substitute_type_params(cx.tcx, tps, sub);\n         // FIXME #1184: Resource flag is larger than necessary\n-        ret T_struct([cx.int_type, type_of_inner(cx, sub1)]);\n-      }\n-      ty::ty_var(_) {\n-        // Should be unreachable b/c of precondition.\n-        // FIXME: would be nice to have a way of expressing this\n-        // through postconditions, and then making it sound to omit\n-        // cases in the alt\n-        std::util::unreachable()\n+        ret T_struct([cx.int_type, type_of(cx, sub1)]);\n       }\n       ty::ty_param(_, _) { T_typaram(cx.tn) }\n       ty::ty_send_type | ty::ty_type { T_ptr(cx.tydesc_type) }\n       ty::ty_tup(elts) {\n         let tys = [];\n         for elt in elts {\n-            tys += [type_of_inner(cx, elt)];\n+            tys += [type_of(cx, elt)];\n         }\n         T_struct(tys)\n       }\n-      ty::ty_opaque_closure_ptr(_) {\n-        T_opaque_box_ptr(cx)\n-      }\n-      ty::ty_constr(subt,_) {\n-          type_of_inner(cx, subt)\n-      }\n-      _ {\n-        fail \"type_of_inner not implemented for this kind of type\";\n-      }\n+      ty::ty_opaque_closure_ptr(_) { T_opaque_box_ptr(cx) }\n+      ty::ty_constr(subt,_) { type_of(cx, subt) }\n+\n+      _ { fail \"type_of not implemented for this kind of type\"; }\n     };\n     cx.lltypes.insert(t, llty);\n     ret llty;\n@@ -222,8 +194,7 @@ fn type_of_ty_param_bounds_and_ty\n     type_of(ccx, t)\n }\n \n-fn type_of_or_i8(bcx: @block_ctxt, typ: ty::t) -> TypeRef {\n-    let ccx = bcx_ccx(bcx);\n+fn type_of_or_i8(ccx: @crate_ctxt, typ: ty::t) -> TypeRef {\n     if check type_has_static_size(ccx, typ) {\n         type_of(ccx, typ)\n     } else { T_i8() }\n@@ -311,7 +282,7 @@ fn get_simple_extern_fn(cx: @block_ctxt,\n                         llmod: ModuleRef,\n                         name: str, n_args: int) -> ValueRef {\n     let ccx = cx.fcx.ccx;\n-    let inputs = vec::init_elt::<TypeRef>(n_args as uint, ccx.int_type);\n+    let inputs = vec::init_elt(n_args as uint, ccx.int_type);\n     let output = ccx.int_type;\n     let t = T_fn(inputs, output);\n     ret get_extern_fn(externs, llmod, name, lib::llvm::CCallConv, t);\n@@ -396,7 +367,7 @@ fn alloca(cx: @block_ctxt, t: TypeRef) -> ValueRef {\n \n fn dynastack_alloca(cx: @block_ctxt, t: TypeRef, n: ValueRef, ty: ty::t) ->\n    ValueRef {\n-    if cx.unreachable { ret llvm::LLVMGetUndef(t); }\n+    if cx.unreachable { ret llvm::LLVMGetUndef(T_ptr(t)); }\n     let bcx = cx;\n     let dy_cx = new_raw_block_ctxt(cx.fcx, cx.fcx.lldynamicallocas);\n     alt bcx_fcx(cx).llobstacktoken {\n@@ -433,7 +404,7 @@ fn mk_obstack_token(ccx: @crate_ctxt, fcx: @fn_ctxt) ->\n fn simplify_type(ccx: @crate_ctxt, typ: ty::t) -> ty::t {\n     fn simplifier(ccx: @crate_ctxt, typ: ty::t) -> ty::t {\n         alt ty::get(typ).struct {\n-          ty::ty_box(_) | ty::ty_iface(_, _) {\n+          ty::ty_box(_) | ty::ty_iface(_, _) | ty::ty_opaque_box {\n             ret ty::mk_imm_box(ccx.tcx, ty::mk_nil(ccx.tcx));\n           }\n           ty::ty_uniq(_) {\n@@ -846,9 +817,9 @@ fn get_derived_tydesc(cx: @block_ctxt, t: ty::t, escapes: bool,\n     bcx_ccx(cx).stats.n_derived_tydescs += 1u;\n     let bcx = new_raw_block_ctxt(cx.fcx, cx.fcx.llderivedtydescs);\n     let tys = linearize_ty_params(bcx, t);\n-    let root_ti = get_static_tydesc(bcx, t, tys.params);\n+    let root_ti = get_static_tydesc(bcx_ccx(bcx), t, tys.params);\n     static_ti = some::<@tydesc_info>(root_ti);\n-    lazily_emit_all_tydesc_glue(cx, static_ti);\n+    lazily_emit_all_tydesc_glue(bcx_ccx(cx), static_ti);\n     let root = root_ti.tydesc;\n     let sz = size_of(bcx, t);\n     bcx = sz.bcx;\n@@ -926,19 +897,19 @@ fn get_tydesc(cx: @block_ctxt, t: ty::t, escapes: bool,\n              result: get_derived_tydesc(cx, t, escapes, static_ti)};\n     }\n     // Otherwise, generate a tydesc if necessary, and return it.\n-    let info = get_static_tydesc(cx, t, []);\n+    let info = get_static_tydesc(bcx_ccx(cx), t, []);\n     static_ti = some(info);\n     ret {kind: tk_static, result: rslt(cx, info.tydesc)};\n }\n \n-fn get_static_tydesc(cx: @block_ctxt, t: ty::t, ty_params: [uint])\n+fn get_static_tydesc(ccx: @crate_ctxt, t: ty::t, ty_params: [uint])\n     -> @tydesc_info {\n-    alt bcx_ccx(cx).tydescs.find(t) {\n+    alt ccx.tydescs.find(t) {\n       some(info) { ret info; }\n       none {\n-        bcx_ccx(cx).stats.n_static_tydescs += 1u;\n-        let info = declare_tydesc(cx.fcx.ccx, t, ty_params);\n-        bcx_ccx(cx).tydescs.insert(t, info);\n+        ccx.stats.n_static_tydescs += 1u;\n+        let info = declare_tydesc(ccx, t, ty_params);\n+        ccx.tydescs.insert(t, info);\n         ret info;\n       }\n     }\n@@ -1142,7 +1113,7 @@ fn make_take_glue(cx: @block_ctxt, v: ValueRef, t: ty::t) {\n     let bcx = cx;\n     // NB: v is an *alias* of type t here, not a direct value.\n     bcx = alt ty::get(t).struct {\n-      ty::ty_box(_) | ty::ty_iface(_, _) {\n+      ty::ty_box(_) | ty::ty_iface(_, _) | ty::ty_opaque_box {\n         incr_refcnt_of_boxed(bcx, Load(bcx, v))\n       }\n       ty::ty_uniq(_) {\n@@ -1188,33 +1159,32 @@ fn incr_refcnt_of_boxed(cx: @block_ctxt, box_ptr: ValueRef) -> @block_ctxt {\n     ret cx;\n }\n \n-fn free_box(bcx: @block_ctxt, v: ValueRef, t: ty::t) -> @block_ctxt {\n-    ret alt ty::get(t).struct {\n-      ty::ty_box(body_mt) {\n-        let v = PointerCast(bcx, v, type_of_1(bcx, t));\n-        let body = GEPi(bcx, v, [0, abi::box_field_body]);\n-        let bcx = drop_ty(bcx, body, body_mt.ty);\n-        trans_free(bcx, v)\n-      }\n-\n-      _ { fail \"free_box invoked with non-box type\"; }\n-    };\n-}\n-\n fn make_free_glue(bcx: @block_ctxt, v: ValueRef, t: ty::t) {\n     // v is a pointer to the actual box component of the type here. The\n     // ValueRef will have the wrong type here (make_generic_glue is casting\n     // everything to a pointer to the type that the glue acts on).\n+    let ccx = bcx_ccx(bcx);\n     let bcx = alt ty::get(t).struct {\n       ty::ty_box(body_mt) {\n-        free_box(bcx, v, t)\n+        let v = PointerCast(bcx, v, type_of(ccx, t));\n+        let body = GEPi(bcx, v, [0, abi::box_field_body]);\n+        let bcx = drop_ty(bcx, body, body_mt.ty);\n+        trans_free(bcx, v)\n+      }\n+      ty::ty_opaque_box {\n+        let v = PointerCast(bcx, v, type_of(ccx, t));\n+        let td = Load(bcx, GEPi(bcx, v, [0, abi::box_field_tydesc]));\n+        let valptr = GEPi(bcx, v, [0, abi::box_field_body]);\n+        call_tydesc_glue_full(bcx, valptr, td, abi::tydesc_field_drop_glue,\n+                              none);\n+        trans_free(bcx, v)\n       }\n       ty::ty_uniq(content_mt) {\n-        let v = PointerCast(bcx, v, type_of_1(bcx, t));\n+        let v = PointerCast(bcx, v, type_of(ccx, t));\n         uniq::make_free_glue(bcx, v, t)\n       }\n       ty::ty_vec(_) | ty::ty_str {\n-        tvec::make_free_glue(bcx, PointerCast(bcx, v, type_of_1(bcx, t)), t)\n+        tvec::make_free_glue(bcx, PointerCast(bcx, v, type_of(ccx, t)), t)\n       }\n       ty::ty_iface(_, _) {\n         // Call through the box's own fields-drop glue first.\n@@ -1253,7 +1223,7 @@ fn make_drop_glue(bcx: @block_ctxt, v0: ValueRef, t: ty::t) {\n     // NB: v0 is an *alias* of type t here, not a direct value.\n     let ccx = bcx_ccx(bcx);\n     let bcx = alt ty::get(t).struct {\n-      ty::ty_box(_) | ty::ty_iface(_, _) {\n+      ty::ty_box(_) | ty::ty_iface(_, _) | ty::ty_opaque_box {\n         decr_refcnt_maybe_free(bcx, Load(bcx, v0), t)\n       }\n       ty::ty_uniq(_) | ty::ty_vec(_) | ty::ty_str | ty::ty_send_type {\n@@ -1573,24 +1543,23 @@ fn iter_structural_ty(cx: @block_ctxt, av: ValueRef, t: ty::t,\n     ret cx;\n }\n \n-fn lazily_emit_all_tydesc_glue(cx: @block_ctxt,\n+fn lazily_emit_all_tydesc_glue(ccx: @crate_ctxt,\n                                static_ti: option<@tydesc_info>) {\n-    lazily_emit_tydesc_glue(cx, abi::tydesc_field_take_glue, static_ti);\n-    lazily_emit_tydesc_glue(cx, abi::tydesc_field_drop_glue, static_ti);\n-    lazily_emit_tydesc_glue(cx, abi::tydesc_field_free_glue, static_ti);\n-    lazily_emit_tydesc_glue(cx, abi::tydesc_field_cmp_glue, static_ti);\n+    lazily_emit_tydesc_glue(ccx, abi::tydesc_field_take_glue, static_ti);\n+    lazily_emit_tydesc_glue(ccx, abi::tydesc_field_drop_glue, static_ti);\n+    lazily_emit_tydesc_glue(ccx, abi::tydesc_field_free_glue, static_ti);\n+    lazily_emit_tydesc_glue(ccx, abi::tydesc_field_cmp_glue, static_ti);\n }\n \n-fn lazily_emit_all_generic_info_tydesc_glues(cx: @block_ctxt,\n+fn lazily_emit_all_generic_info_tydesc_glues(ccx: @crate_ctxt,\n                                              gi: generic_info) {\n     for ti: option<@tydesc_info> in gi.static_tis {\n-        lazily_emit_all_tydesc_glue(cx, ti);\n+        lazily_emit_all_tydesc_glue(ccx, ti);\n     }\n }\n \n-fn lazily_emit_tydesc_glue(cx: @block_ctxt, field: int,\n+fn lazily_emit_tydesc_glue(ccx: @crate_ctxt, field: int,\n                            static_ti: option<@tydesc_info>) {\n-    let ccx = cx.fcx.ccx;\n     alt static_ti {\n       none { }\n       some(ti) {\n@@ -1599,58 +1568,58 @@ fn lazily_emit_tydesc_glue(cx: @block_ctxt, field: int,\n               some(_) { }\n               none {\n                 #debug(\"+++ lazily_emit_tydesc_glue TAKE %s\",\n-                       ty_to_str(bcx_tcx(cx), ti.ty));\n+                       ty_to_str(ccx.tcx, ti.ty));\n                 let glue_fn = declare_generic_glue\n                     (ccx, ti.ty, T_glue_fn(ccx), \"take\");\n                 ti.take_glue = some(glue_fn);\n                 make_generic_glue(ccx, ti.ty, glue_fn,\n                                   make_take_glue,\n                                   ti.ty_params, \"take\");\n                 #debug(\"--- lazily_emit_tydesc_glue TAKE %s\",\n-                       ty_to_str(bcx_tcx(cx), ti.ty));\n+                       ty_to_str(ccx.tcx, ti.ty));\n               }\n             }\n         } else if field == abi::tydesc_field_drop_glue {\n             alt ti.drop_glue {\n               some(_) { }\n               none {\n                 #debug(\"+++ lazily_emit_tydesc_glue DROP %s\",\n-                       ty_to_str(bcx_tcx(cx), ti.ty));\n+                       ty_to_str(ccx.tcx, ti.ty));\n                 let glue_fn =\n                     declare_generic_glue(ccx, ti.ty, T_glue_fn(ccx), \"drop\");\n                 ti.drop_glue = some(glue_fn);\n                 make_generic_glue(ccx, ti.ty, glue_fn,\n                                   make_drop_glue,\n                                   ti.ty_params, \"drop\");\n                 #debug(\"--- lazily_emit_tydesc_glue DROP %s\",\n-                       ty_to_str(bcx_tcx(cx), ti.ty));\n+                       ty_to_str(ccx.tcx, ti.ty));\n               }\n             }\n         } else if field == abi::tydesc_field_free_glue {\n             alt ti.free_glue {\n               some(_) { }\n               none {\n                 #debug(\"+++ lazily_emit_tydesc_glue FREE %s\",\n-                       ty_to_str(bcx_tcx(cx), ti.ty));\n+                       ty_to_str(ccx.tcx, ti.ty));\n                 let glue_fn =\n                     declare_generic_glue(ccx, ti.ty, T_glue_fn(ccx), \"free\");\n                 ti.free_glue = some(glue_fn);\n                 make_generic_glue(ccx, ti.ty, glue_fn,\n                                   make_free_glue,\n                                   ti.ty_params, \"free\");\n                 #debug(\"--- lazily_emit_tydesc_glue FREE %s\",\n-                       ty_to_str(bcx_tcx(cx), ti.ty));\n+                       ty_to_str(ccx.tcx, ti.ty));\n               }\n             }\n         } else if field == abi::tydesc_field_cmp_glue {\n             alt ti.cmp_glue {\n               some(_) { }\n               none {\n                 #debug(\"+++ lazily_emit_tydesc_glue CMP %s\",\n-                       ty_to_str(bcx_tcx(cx), ti.ty));\n-                ti.cmp_glue = some(bcx_ccx(cx).upcalls.cmp_type);\n+                       ty_to_str(ccx.tcx, ti.ty));\n+                ti.cmp_glue = some(ccx.upcalls.cmp_type);\n                 #debug(\"--- lazily_emit_tydesc_glue CMP %s\",\n-                       ty_to_str(bcx_tcx(cx), ti.ty));\n+                       ty_to_str(ccx.tcx, ti.ty));\n               }\n             }\n         }\n@@ -1660,7 +1629,7 @@ fn lazily_emit_tydesc_glue(cx: @block_ctxt, field: int,\n \n fn call_tydesc_glue_full(cx: @block_ctxt, v: ValueRef, tydesc: ValueRef,\n                          field: int, static_ti: option<@tydesc_info>) {\n-    lazily_emit_tydesc_glue(cx, field, static_ti);\n+    lazily_emit_tydesc_glue(bcx_ccx(cx), field, static_ti);\n \n     let static_glue_fn = none;\n     alt static_ti {\n@@ -1722,7 +1691,7 @@ fn call_cmp_glue(cx: @block_ctxt, lhs: ValueRef, rhs: ValueRef, t: ty::t,\n     r = get_tydesc(bcx, t, false, ti).result;\n     let lltydesc = r.val;\n     bcx = r.bcx;\n-    lazily_emit_tydesc_glue(bcx, abi::tydesc_field_cmp_glue, ti);\n+    lazily_emit_tydesc_glue(bcx_ccx(bcx), abi::tydesc_field_cmp_glue, ti);\n     let lltydescs =\n         GEPi(bcx, lltydesc, [0, abi::tydesc_field_first_param]);\n     lltydescs = Load(bcx, lltydescs);\n@@ -1760,15 +1729,17 @@ fn drop_ty(cx: @block_ctxt, v: ValueRef, t: ty::t) -> @block_ctxt {\n fn drop_ty_immediate(bcx: @block_ctxt, v: ValueRef, t: ty::t) -> @block_ctxt {\n     alt ty::get(t).struct {\n       ty::ty_uniq(_) | ty::ty_vec(_) | ty::ty_str { free_ty(bcx, v, t) }\n-      ty::ty_box(_) | ty::ty_iface(_, _) { decr_refcnt_maybe_free(bcx, v, t) }\n+      ty::ty_box(_) | ty::ty_iface(_, _) | ty::ty_opaque_box {\n+        decr_refcnt_maybe_free(bcx, v, t)\n+      }\n       // Precondition?\n       _ { bcx_tcx(bcx).sess.bug(\"drop_ty_immediate: non-box ty\"); }\n     }\n }\n \n fn take_ty_immediate(bcx: @block_ctxt, v: ValueRef, t: ty::t) -> result {\n     alt ty::get(t).struct {\n-      ty::ty_box(_) | ty::ty_iface(_, _) {\n+      ty::ty_box(_) | ty::ty_iface(_, _) | ty::ty_opaque_box {\n         rslt(incr_refcnt_of_boxed(bcx, v), v)\n       }\n       ty::ty_uniq(_) {\n@@ -2369,7 +2340,8 @@ fn trans_for(cx: @block_ctxt, local: @ast::local, seq: @ast::expr,\n                                       outer_next_cx, \"for loop scope\",\n                                       body.span);\n         Br(bcx, scope_cx.llbb);\n-        let curr = PointerCast(bcx, curr, T_ptr(type_of_or_i8(bcx, t)));\n+        let curr = PointerCast(bcx, curr,\n+                               T_ptr(type_of_or_i8(bcx_ccx(bcx), t)));\n         let bcx = alt::bind_irrefutable_pat(scope_cx, local.node.pat,\n                                                   curr, false);\n         bcx = trans_block_dps(bcx, body, ignore);\n@@ -2423,13 +2395,17 @@ fn trans_do_while(cx: @block_ctxt, body: ast::blk, cond: @ast::expr) ->\n     ret next_cx;\n }\n \n-type generic_info = {\n-    item_type: ty::t,\n-    static_tis: [option<@tydesc_info>],\n-    tydescs: [ValueRef],\n-    param_bounds: @[ty::param_bounds],\n-    origins: option<typeck::dict_res>\n-};\n+type generic_info = {item_type: ty::t,\n+                     static_tis: [option<@tydesc_info>],\n+                     tydescs: [ValueRef],\n+                     param_bounds: @[ty::param_bounds],\n+                     origins: option<typeck::dict_res>};\n+\n+enum generic_callee {\n+    generic_full(generic_info),\n+    generic_mono(ty::t),\n+    generic_none,\n+}\n \n enum lval_kind {\n     temporary, //< Temporary value passed by value if of immediate type\n@@ -2448,7 +2424,7 @@ type lval_maybe_callee = {bcx: @block_ctxt,\n                           val: ValueRef,\n                           kind: lval_kind,\n                           env: callee_env,\n-                          generic: option<generic_info>};\n+                          generic: generic_callee};\n \n fn null_env_ptr(bcx: @block_ctxt) -> ValueRef {\n     C_null(T_opaque_box_ptr(bcx_ccx(bcx)))\n@@ -2467,7 +2443,8 @@ fn lval_temp(bcx: @block_ctxt, val: ValueRef) -> lval_result {\n \n fn lval_no_env(bcx: @block_ctxt, val: ValueRef, kind: lval_kind)\n     -> lval_maybe_callee {\n-    ret {bcx: bcx, val: val, kind: kind, env: is_closure, generic: none};\n+    ret {bcx: bcx, val: val, kind: kind, env: is_closure,\n+         generic: generic_none};\n }\n \n fn trans_external_path(cx: @block_ctxt, did: ast::def_id,\n@@ -2479,7 +2456,20 @@ fn trans_external_path(cx: @block_ctxt, did: ast::def_id,\n }\n \n fn monomorphic_fn(ccx: @crate_ctxt, fn_id: ast::def_id, substs: [ty::t],\n-                  dicts: option<typeck::dict_res>) -> ValueRef {\n+                  dicts: option<typeck::dict_res>)\n+    -> {llfn: ValueRef, fty: ty::t} {\n+    let substs = vec::map(substs, {|t|\n+        alt ty::get(t).struct {\n+          ty::ty_box(mt) {\n+            if !ty::type_has_params(mt.ty) {\n+                let ti = some(get_static_tydesc(ccx, mt.ty, []));\n+                lazily_emit_all_tydesc_glue(ccx, ti);\n+            }\n+            ty::mk_opaque_box(ccx.tcx)\n+          }\n+          _ { t }\n+        }\n+    });\n     let hash_id = @{def: fn_id, substs: substs, dicts: alt dicts {\n       some(os) { vec::map(*os, {|o| impl::dict_id(ccx.tcx, o)}) }\n       none { [] }\n@@ -2505,8 +2495,9 @@ fn monomorphic_fn(ccx: @crate_ctxt, fn_id: ast::def_id, substs: [ty::t],\n       }\n       _ { fail \"FIXME[mono] handle other constructs\"; }\n     };\n-    ccx.monomorphized.insert(hash_id, result);\n-    result\n+    let val = {llfn: result, fty: mono_ty};\n+    ccx.monomorphized.insert(hash_id, val);\n+    val\n }\n \n fn lval_static_fn(bcx: @block_ctxt, fn_id: ast::def_id, id: ast::node_id)\n@@ -2521,8 +2512,10 @@ fn lval_static_fn(bcx: @block_ctxt, fn_id: ast::def_id, id: ast::node_id)\n            alt b { ty::bound_iface(_) { false } _ { true } }\n        })}) {\n         let dicts = ccx.dict_map.find(id);\n-        ret {bcx: bcx, val: monomorphic_fn(ccx, fn_id, tys, dicts),\n-             kind: owned, env: null_env, generic: none};\n+        let {llfn, fty} = monomorphic_fn(ccx, fn_id, tys, dicts);\n+        ret {bcx: bcx, val: llfn,\n+             kind: owned, env: null_env,\n+             generic: generic_mono(fty)};\n     }\n     let val = if fn_id.crate == ast::local_crate {\n         // Internal reference.\n@@ -2532,7 +2525,7 @@ fn lval_static_fn(bcx: @block_ctxt, fn_id: ast::def_id, id: ast::node_id)\n         // External reference.\n         trans_external_path(bcx, fn_id, tpt)\n     };\n-    let gen = none, bcx = bcx;\n+    let gen = generic_none, bcx = bcx;\n     if vec::len(tys) > 0u {\n         let tydescs = [], tis = [];\n         for t in tys {\n@@ -2543,11 +2536,11 @@ fn lval_static_fn(bcx: @block_ctxt, fn_id: ast::def_id, id: ast::node_id)\n             bcx = td.bcx;\n             tydescs += [td.val];\n         }\n-        gen = some({item_type: tpt.ty,\n-                    static_tis: tis,\n-                    tydescs: tydescs,\n-                    param_bounds: tpt.bounds,\n-                    origins: ccx.dict_map.find(id)});\n+        gen = generic_full({item_type: tpt.ty,\n+                            static_tis: tis,\n+                            tydescs: tydescs,\n+                            param_bounds: tpt.bounds,\n+                            origins: ccx.dict_map.find(id)});\n     }\n     ret {bcx: bcx, val: val, kind: owned, env: null_env, generic: gen};\n }\n@@ -2594,7 +2587,8 @@ fn trans_local_var(cx: @block_ctxt, def: ast::def) -> local_var_result {\n       }\n       ast::def_self(did) {\n         let slf = option::get(cx.fcx.llself);\n-        let ptr = PointerCast(cx, slf.v, T_ptr(type_of_or_i8(cx, slf.t)));\n+        let ptr = PointerCast(cx, slf.v,\n+                              T_ptr(type_of_or_i8(bcx_ccx(cx), slf.t)));\n         ret {val: ptr, kind: owned};\n       }\n       _ {\n@@ -2693,7 +2687,7 @@ fn trans_index(cx: @block_ctxt, ex: @ast::expr, base: @ast::expr,\n     let scaled_ix = Mul(bcx, ix_val, unit_sz.val);\n     maybe_name_value(bcx_ccx(cx), scaled_ix, \"scaled_ix\");\n     let lim = tvec::get_fill(bcx, v);\n-    let body = tvec::get_dataptr(bcx, v, type_of_or_i8(bcx, unit_ty));\n+    let body = tvec::get_dataptr(bcx, v, type_of_or_i8(ccx, unit_ty));\n     let bounds_check = ICmp(bcx, lib::llvm::IntULT, scaled_ix, lim);\n     let fail_cx = new_sub_block_ctxt(bcx, \"fail\");\n     let next_cx = new_sub_block_ctxt(bcx, \"next\");\n@@ -2807,7 +2801,7 @@ fn maybe_add_env(bcx: @block_ctxt, c: lval_maybe_callee)\n \n fn lval_maybe_callee_to_lval(c: lval_maybe_callee, ty: ty::t) -> lval_result {\n     alt c.generic {\n-      some(gi) {\n+      generic_full(gi) {\n         let n_args = vec::len(ty::ty_fn_args(ty));\n         let args = vec::init_elt(n_args, none::<@ast::expr>);\n         let space = alloc_ty(c.bcx, ty);\n@@ -2816,7 +2810,7 @@ fn lval_maybe_callee_to_lval(c: lval_maybe_callee, ty: ty::t) -> lval_result {\n         add_clean_temp(bcx, space.val, ty);\n         ret {bcx: bcx, val: space.val, kind: temporary};\n       }\n-      none {\n+      _ {\n         let (kind, val) = maybe_add_env(c.bcx, c);\n         ret {bcx: c.bcx, val: val, kind: kind};\n       }\n@@ -2976,7 +2970,7 @@ fn trans_arg_expr(cx: @block_ctxt, arg: ty::arg, lldestty: TypeRef,\n         bcx = r.bcx;\n     }\n \n-    if !is_bot && ty::type_has_params(arg.ty) {\n+    if !is_bot && arg.ty != e_ty || ty::type_has_params(arg.ty) {\n         val = PointerCast(bcx, val, lldestty);\n     }\n \n@@ -2999,7 +2993,7 @@ fn trans_arg_expr(cx: @block_ctxt, arg: ty::arg, lldestty: TypeRef,\n //  - new_fn_ctxt\n //  - trans_args\n fn trans_args(cx: @block_ctxt, llenv: ValueRef,\n-              gen: option<generic_info>, es: [@ast::expr], fn_ty: ty::t,\n+              gen: generic_callee, es: [@ast::expr], fn_ty: ty::t,\n               dest: dest)\n    -> {bcx: @block_ctxt,\n        args: [ValueRef],\n@@ -3018,8 +3012,8 @@ fn trans_args(cx: @block_ctxt, llenv: ValueRef,\n \n     let retty = ty::ty_fn_ret(fn_ty), full_retty = retty;\n     alt gen {\n-      some(g) {\n-        lazily_emit_all_generic_info_tydesc_glues(cx, g);\n+      generic_full(g) {\n+        lazily_emit_all_generic_info_tydesc_glues(ccx, g);\n         let i = 0u, n_orig = 0u;\n         for param in *g.param_bounds {\n             lltydescs += [g.tydescs[i]];\n@@ -3040,6 +3034,10 @@ fn trans_args(cx: @block_ctxt, llenv: ValueRef,\n         args = ty::ty_fn_args(g.item_type);\n         retty = ty::ty_fn_ret(g.item_type);\n       }\n+      generic_mono(t) {\n+        args = ty::ty_fn_args(t);\n+        retty = ty::ty_fn_ret(t);\n+      }\n       _ { }\n     }\n     // Arg 0: Output pointer.\n@@ -3061,13 +3059,13 @@ fn trans_args(cx: @block_ctxt, llenv: ValueRef,\n       }\n     };\n \n-    if ty::type_has_params(retty) {\n+    if retty != full_retty || ty::type_has_params(retty) {\n         // It's possible that the callee has some generic-ness somewhere in\n         // its return value -- say a method signature within an obj or a fn\n         // type deep in a structure -- which the caller has a concrete view\n         // of. If so, cast the caller's view of the restlot to the callee's\n         // view, for the sake of making a type-compatible call.\n-        let llretty = T_ptr(type_of_inner(ccx, retty));\n+        let llretty = T_ptr(type_of(ccx, retty));\n         llargs += [PointerCast(cx, llretslot, llretty)];\n     } else { llargs += [llretslot]; }\n \n@@ -3439,7 +3437,6 @@ fn trans_expr(bcx: @block_ctxt, e: @ast::expr, dest: dest) -> @block_ctxt {\n         ret trans_if(bcx, cond, thn, els, dest);\n       }\n       ast::expr_alt(expr, arms) {\n-          //          tcx.sess.span_note(e.span, \"about to call trans_alt\");\n         ret alt::trans_alt(bcx, expr, arms, dest);\n       }\n       ast::expr_block(blk) {\n@@ -3759,15 +3756,15 @@ fn trans_fail_expr(bcx: @block_ctxt, sp_opt: option<span>,\n     let bcx = bcx;\n     alt fail_expr {\n       some(expr) {\n-        let tcx = bcx_tcx(bcx);\n+        let ccx = bcx_ccx(bcx), tcx = ccx.tcx;\n         let expr_res = trans_temp_expr(bcx, expr);\n         let e_ty = expr_ty(bcx, expr);\n         bcx = expr_res.bcx;\n \n         if ty::type_is_str(e_ty) {\n             let data = tvec::get_dataptr(\n                 bcx, expr_res.val, type_of_or_i8(\n-                    bcx, ty::mk_mach_uint(tcx, ast::ty_u8)));\n+                    ccx, ty::mk_mach_uint(tcx, ast::ty_u8)));\n             ret trans_fail_value(bcx, sp_opt, data);\n         } else if bcx.unreachable || ty::type_is_bot(e_ty) {\n             ret bcx;\n@@ -4155,21 +4152,19 @@ fn llderivedtydescs_block_ctxt(fcx: @fn_ctxt) -> @block_ctxt {\n \n \n fn alloc_ty(cx: @block_ctxt, t: ty::t) -> result {\n-    let bcx = cx;\n-    let ccx = bcx_ccx(cx);\n-    let val =\n-        if check type_has_static_size(ccx, t) {\n-            alloca(bcx, type_of(ccx, t))\n-        } else {\n-            // NB: we have to run this particular 'size_of' in a\n-            // block_ctxt built on the llderivedtydescs block for the fn,\n-            // so that the size dominates the array_alloca that\n-            // comes next.\n-\n-            let n = size_of(llderivedtydescs_block_ctxt(bcx.fcx), t);\n-            bcx.fcx.llderivedtydescs = n.bcx.llbb;\n-            dynastack_alloca(bcx, T_i8(), n.val, t)\n-        };\n+    let bcx = cx, ccx = bcx_ccx(cx);\n+    let llty = type_of(ccx, t);\n+    let val = if type_has_static_size(ccx, t) {\n+        alloca(bcx, llty)\n+    } else {\n+        // NB: we have to run this particular 'size_of' in a\n+        // block_ctxt built on the llderivedtydescs block for the fn,\n+        // so that the size dominates the array_alloca that\n+        // comes next.\n+        let n = size_of(llderivedtydescs_block_ctxt(bcx.fcx), t);\n+        bcx.fcx.llderivedtydescs = n.bcx.llbb;\n+        PointerCast(bcx, dynastack_alloca(bcx, T_i8(), n.val, t), T_ptr(llty))\n+    };\n \n     // NB: since we've pushed all size calculations in this\n     // function up to the alloca block, we actually return the\n@@ -4395,7 +4390,6 @@ fn copy_args_to_allocas(fcx: @fn_ctxt, bcx: @block_ctxt, args: [ast::arg],\n     ret bcx;\n }\n \n-// cries out for a precondition\n fn arg_tys_of_fn(ccx: @crate_ctxt, id: ast::node_id) -> [ty::arg] {\n     let tt = ty::node_id_to_type(ccx.tcx, id);\n     alt ty::get(tt).struct {\n@@ -4442,6 +4436,14 @@ fn trans_closure(ccx: @crate_ctxt, path: path, decl: ast::fn_decl,\n     let block_ty = node_id_type(bcx, body.node.id);\n \n     let arg_tys = arg_tys_of_fn(fcx.ccx, id);\n+    alt param_substs {\n+      some(ts) {\n+        arg_tys = vec::map(arg_tys, {|a|\n+            {mode: a.mode,\n+             ty: ty::substitute_type_params(fcx.ccx.tcx, ts, a.ty)}})\n+      }\n+      _ {}\n+    }\n     bcx = copy_args_to_allocas(fcx, bcx, decl.inputs, arg_tys);\n \n     maybe_load_env(fcx);\n@@ -4696,7 +4698,7 @@ fn c_stack_tys(ccx: @crate_ctxt,\n     alt ty::get(ty::node_id_to_type(ccx.tcx, id)).struct {\n       ty::ty_fn({inputs: arg_tys, output: ret_ty, _}) {\n         let llargtys = type_of_explicit_args(ccx, arg_tys);\n-        let llretty = type_of_inner(ccx, ret_ty);\n+        let llretty = type_of(ccx, ret_ty);\n         let bundle_ty = T_struct(llargtys + [T_ptr(llretty)]);\n         ret @{\n             arg_tys: llargtys,"}, {"sha": "922e53d62510f83d431e76c44386960ef08076e8", "filename": "src/comp/middle/trans/closure.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b28a5552e3e822063499c8fb7c6c0be6bb881863/src%2Fcomp%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b28a5552e3e822063499c8fb7c6c0be6bb881863/src%2Fcomp%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Fclosure.rs?ref=b28a5552e3e822063499c8fb7c6c0be6bb881863", "patch": "@@ -168,7 +168,7 @@ fn allocate_cbox(bcx: @block_ctxt,\n     -> (@block_ctxt, ValueRef, [ValueRef]) {\n \n     // let ccx = bcx_ccx(bcx);\n-    let tcx = bcx_tcx(bcx);\n+    let ccx = bcx_ccx(bcx), tcx = ccx.tcx;\n \n     fn nuke_ref_count(bcx: @block_ctxt, box: ValueRef) {\n         // Initialize ref count to arbitrary value for debugging:\n@@ -215,9 +215,9 @@ fn allocate_cbox(bcx: @block_ctxt,\n       }\n     };\n \n-    base::lazily_emit_tydesc_glue(bcx, abi::tydesc_field_take_glue, ti);\n-    base::lazily_emit_tydesc_glue(bcx, abi::tydesc_field_drop_glue, ti);\n-    base::lazily_emit_tydesc_glue(bcx, abi::tydesc_field_free_glue, ti);\n+    base::lazily_emit_tydesc_glue(ccx, abi::tydesc_field_take_glue, ti);\n+    base::lazily_emit_tydesc_glue(ccx, abi::tydesc_field_drop_glue, ti);\n+    base::lazily_emit_tydesc_glue(ccx, abi::tydesc_field_free_glue, ti);\n \n     ret (bcx, box, temp_cleanups);\n }\n@@ -506,8 +506,7 @@ fn trans_bind_1(cx: @block_ctxt, outgoing_fty: ty::t,\n \n     // Figure out which tydescs we need to pass, if any.\n     let (outgoing_fty_real, lltydescs, param_bounds) = alt f_res.generic {\n-      none { (outgoing_fty, [], @[]) }\n-      some(ginfo) {\n+      generic_full(ginfo) {\n         let tds = [], orig = 0u;\n         vec::iter2(ginfo.tydescs, *ginfo.param_bounds) {|td, bounds|\n             tds += [td];\n@@ -524,9 +523,10 @@ fn trans_bind_1(cx: @block_ctxt, outgoing_fty: ty::t,\n                 }\n             }\n         }\n-        lazily_emit_all_generic_info_tydesc_glues(cx, ginfo);\n+        lazily_emit_all_generic_info_tydesc_glues(bcx_ccx(cx), ginfo);\n         (ginfo.item_type, tds, ginfo.param_bounds)\n       }\n+      _ { (outgoing_fty, [], @[]) }\n     };\n \n     if vec::len(bound) == 0u && vec::len(lltydescs) == 0u {\n@@ -831,7 +831,7 @@ fn trans_bind_thunk(ccx: @crate_ctxt,\n     // to be the correct type.  Cast it to f's return type, if necessary.\n     let llretptr = fcx.llretptr;\n     if ty::type_has_params(outgoing_ret_ty) {\n-        let llretty = type_of_inner(ccx, outgoing_ret_ty);\n+        let llretty = type_of(ccx, outgoing_ret_ty);\n         llretptr = PointerCast(bcx, llretptr, T_ptr(llretty));\n     }\n "}, {"sha": "43daef253c1717d084a0beb43a26c7fbf83f063c", "filename": "src/comp/middle/trans/common.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b28a5552e3e822063499c8fb7c6c0be6bb881863/src%2Fcomp%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b28a5552e3e822063499c8fb7c6c0be6bb881863/src%2Fcomp%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Fcommon.rs?ref=b28a5552e3e822063499c8fb7c6c0be6bb881863", "patch": "@@ -99,7 +99,7 @@ type crate_ctxt =\n      consts: hashmap<ast::node_id, ValueRef>,\n      tydescs: hashmap<ty::t, @tydesc_info>,\n      dicts: hashmap<dict_id, ValueRef>,\n-     monomorphized: hashmap<mono_id, ValueRef>,\n+     monomorphized: hashmap<mono_id, {llfn: ValueRef, fty: ty::t}>,\n      module_data: hashmap<str, ValueRef>,\n      lltypes: hashmap<ty::t, TypeRef>,\n      names: namegen,\n@@ -873,7 +873,6 @@ fn hash_dict_id(&&dp: dict_id) -> uint {\n }\n \n // Used to identify cached monomorphized functions\n-// FIXME[mono] don't count different boxes as different types\n type mono_id = @{def: ast::def_id, substs: [ty::t], dicts: [dict_id]};\n fn hash_mono_id(&&mi: mono_id) -> uint {\n     let h = syntax::ast_util::hash_def_id(mi.def);"}, {"sha": "1e66e3e9044f3f175f6e1de6c63dec45378692e4", "filename": "src/comp/middle/trans/impl.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/b28a5552e3e822063499c8fb7c6c0be6bb881863/src%2Fcomp%2Fmiddle%2Ftrans%2Fimpl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b28a5552e3e822063499c8fb7c6c0be6bb881863/src%2Fcomp%2Fmiddle%2Ftrans%2Fimpl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Fimpl.rs?ref=b28a5552e3e822063499c8fb7c6c0be6bb881863", "patch": "@@ -64,9 +64,10 @@ fn trans_self_arg(bcx: @block_ctxt, base: @ast::expr) -> result {\n     let tz = [], tr = [];\n     let basety = expr_ty(bcx, base);\n     let m_by_ref = ast::expl(ast::by_ref);\n-    let {bcx, val} = trans_arg_expr(bcx, {mode: m_by_ref, ty: basety},\n-                                    T_ptr(type_of_or_i8(bcx, basety)), tz,\n-                                    tr, base);\n+    let {bcx, val} =\n+        trans_arg_expr(bcx, {mode: m_by_ref, ty: basety},\n+                       T_ptr(type_of_or_i8(bcx_ccx(bcx), basety)), tz,\n+                       tr, base);\n     rslt(bcx, PointerCast(bcx, val, T_opaque_cbox_ptr(bcx_ccx(bcx))))\n }\n \n@@ -112,7 +113,7 @@ fn trans_vtable_callee(bcx: @block_ctxt, self: ValueRef, dict: ValueRef,\n     let vtable = PointerCast(bcx, Load(bcx, GEPi(bcx, dict, [0, 0])),\n                              T_ptr(T_array(T_ptr(llfty), n_method + 1u)));\n     let mptr = Load(bcx, GEPi(bcx, vtable, [0, n_method as int]));\n-    let generic = none;\n+    let generic = generic_none;\n     if vec::len(*method.tps) > 0u || ty::type_has_params(fty) {\n         let tydescs = [], tis = [];\n         let tptys = ty::node_id_to_type_params(tcx, callee_id);\n@@ -123,11 +124,11 @@ fn trans_vtable_callee(bcx: @block_ctxt, self: ValueRef, dict: ValueRef,\n             tydescs += [td.val];\n             bcx = td.bcx;\n         }\n-        generic = some({item_type: fty,\n-                        static_tis: tis,\n-                        tydescs: tydescs,\n-                        param_bounds: method.tps,\n-                        origins: bcx_ccx(bcx).dict_map.find(callee_id)});\n+        generic = generic_full({item_type: fty,\n+                                static_tis: tis,\n+                                tydescs: tydescs,\n+                                param_bounds: method.tps,\n+                                origins: ccx.dict_map.find(callee_id)});\n     }\n     {bcx: bcx, val: mptr, kind: owned,\n      env: dict_env(dict, self),\n@@ -447,7 +448,7 @@ fn trans_cast(bcx: @block_ctxt, val: @ast::expr, id: ast::node_id, dest: dest)\n                                    val_ty]);\n     let ti = none;\n     let {bcx, val: tydesc} = get_tydesc(bcx, body_ty, true, ti).result;\n-    lazily_emit_all_tydesc_glue(bcx, ti);\n+    lazily_emit_all_tydesc_glue(ccx, ti);\n     let {bcx, box, body: box_body} = trans_malloc_boxed(bcx, body_ty);\n     Store(bcx, tydesc, GEPi(bcx, box_body, [0, 0]));\n     Store(bcx, PointerCast(bcx, dict, T_ptr(ccx.tydesc_type)),"}, {"sha": "b177060fd08de0d91fcbb0bc13fc7e6675e09b82", "filename": "src/comp/middle/trans/tvec.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b28a5552e3e822063499c8fb7c6c0be6bb881863/src%2Fcomp%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b28a5552e3e822063499c8fb7c6c0be6bb881863/src%2Fcomp%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Ftvec.rs?ref=b28a5552e3e822063499c8fb7c6c0be6bb881863", "patch": "@@ -48,7 +48,7 @@ type alloc_result =\n fn alloc(bcx: @block_ctxt, vec_ty: ty::t, elts: uint) -> alloc_result {\n     let ccx = bcx_ccx(bcx);\n     let unit_ty = ty::sequence_element_type(bcx_tcx(bcx), vec_ty);\n-    let llunitty = type_of_or_i8(bcx, unit_ty);\n+    let llunitty = type_of_or_i8(ccx, unit_ty);\n     let llvecty = T_vec(ccx, llunitty);\n     let {bcx: bcx, val: unit_sz} = size_of(bcx, unit_ty);\n \n@@ -167,7 +167,7 @@ fn trans_append(cx: @block_ctxt, vec_ty: ty::t, lhsptr: ValueRef,\n     };\n \n     let {bcx: bcx, val: unit_sz} = size_of(cx, unit_ty);\n-    let llunitty = type_of_or_i8(cx, unit_ty);\n+    let llunitty = type_of_or_i8(ccx, unit_ty);\n \n     let lhs = Load(bcx, lhsptr);\n     let self_append = ICmp(bcx, lib::llvm::IntEQ, lhs, rhs);\n@@ -215,7 +215,7 @@ fn trans_append_literal(bcx: @block_ctxt, vptrptr: ValueRef, vec_ty: ty::t,\n     let ti = none;\n     let {bcx: bcx, val: td} =\n         get_tydesc(bcx, elt_ty, false, ti).result;\n-    base::lazily_emit_tydesc_glue(bcx, abi::tydesc_field_take_glue, ti);\n+    base::lazily_emit_tydesc_glue(ccx, abi::tydesc_field_take_glue, ti);\n     let opaque_v = PointerCast(bcx, vptrptr,\n                                T_ptr(T_ptr(ccx.opaque_vec_type)));\n     for val in vals {\n@@ -238,7 +238,7 @@ fn trans_add(bcx: @block_ctxt, vec_ty: ty::t, lhs: ValueRef,\n       _ { false }\n     };\n     let unit_ty = ty::sequence_element_type(bcx_tcx(bcx), vec_ty);\n-    let llunitty = type_of_or_i8(bcx, unit_ty);\n+    let llunitty = type_of_or_i8(ccx, unit_ty);\n     let {bcx: bcx, val: llunitsz} = size_of(bcx, unit_ty);\n \n     let lhs_fill = get_fill(bcx, lhs);\n@@ -280,7 +280,7 @@ fn iter_vec_raw(bcx: @block_ctxt, vptr: ValueRef, vec_ty: ty::t,\n                 fill: ValueRef, f: iter_vec_block) -> @block_ctxt {\n     let ccx = bcx_ccx(bcx);\n     let unit_ty = ty::sequence_element_type(bcx_tcx(bcx), vec_ty);\n-    let llunitty = type_of_or_i8(bcx, unit_ty);\n+    let llunitty = type_of_or_i8(ccx, unit_ty);\n     let {bcx: bcx, val: unit_sz} = size_of(bcx, unit_ty);\n     let vptr = PointerCast(bcx, vptr, T_ptr(T_vec(ccx, llunitty)));\n     let data_ptr = get_dataptr(bcx, vptr, llunitty);"}, {"sha": "46cddf4a7e3a4665f1e1198998d4ab50c132b649", "filename": "src/comp/middle/trans/uniq.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b28a5552e3e822063499c8fb7c6c0be6bb881863/src%2Fcomp%2Fmiddle%2Ftrans%2Funiq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b28a5552e3e822063499c8fb7c6c0be6bb881863/src%2Fcomp%2Fmiddle%2Ftrans%2Funiq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Funiq.rs?ref=b28a5552e3e822063499c8fb7c6c0be6bb881863", "patch": "@@ -4,7 +4,7 @@ import common::*;\n import build::*;\n import base::{\n     trans_shared_malloc,\n-    type_of_inner,\n+    type_of,\n     INIT,\n     trans_shared_free,\n     drop_ty,\n@@ -33,7 +33,7 @@ fn alloc_uniq(cx: @block_ctxt, uniq_ty: ty::t) -> result {\n     bcx = r.bcx;\n     let llsz = r.val;\n \n-    let llptrty = T_ptr(type_of_inner(bcx_ccx(bcx), contents_ty));\n+    let llptrty = T_ptr(type_of(bcx_ccx(bcx), contents_ty));\n \n     r = trans_shared_malloc(bcx, llptrty, llsz);\n     bcx = r.bcx;"}, {"sha": "3740a86413b52a971041740e8d750c49e92d8d65", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 42, "deletions": 83, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/b28a5552e3e822063499c8fb7c6c0be6bb881863/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b28a5552e3e822063499c8fb7c6c0be6bb881863/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=b28a5552e3e822063499c8fb7c6c0be6bb881863", "patch": "@@ -48,39 +48,8 @@ export is_pred_ty;\n export lookup_item_type;\n export method;\n export method_idx;\n-export mk_bool;\n-export mk_bot;\n-export mk_box;\n-export mk_char;\n-export mk_constr;\n export mk_ctxt;\n-export mk_float;\n-export mk_fn;\n-export mk_imm_box;\n-export mk_imm_uniq;\n-export mk_mut_ptr;\n-export mk_int;\n-export mk_str;\n-export mk_vec;\n-export mk_mach_int;\n-export mk_mach_uint;\n-export mk_mach_float;\n-export mk_nil;\n-export mk_iface;\n-export mk_res;\n-export mk_param;\n-export mk_ptr;\n-export mk_rec;\n-export mk_enum;\n-export mk_tup;\n-export mk_type;\n-export mk_send_type;\n-export mk_uint;\n-export mk_uniq;\n-export mk_var;\n-export mk_self;\n-export mk_opaque_closure_ptr;\n-export mk_named;\n+export mk_named, type_name;\n export mt;\n export node_type_table;\n export pat_ty;\n@@ -96,34 +65,34 @@ export enum_variants;\n export iface_methods, store_iface_methods, impl_iface;\n export enum_variant_with_id;\n export ty_param_bounds_and_ty;\n-export ty_bool;\n-export ty_bot;\n-export ty_box;\n-export ty_constr;\n-export ty_opaque_closure_ptr;\n+export ty_bool, mk_bool, type_is_bool;\n+export ty_bot, mk_bot, type_is_bot;\n+export ty_box, mk_box, mk_imm_box, type_is_box, type_is_boxed;\n+export ty_constr, mk_constr;\n+export ty_opaque_closure_ptr, mk_opaque_closure_ptr;\n+export ty_opaque_box, mk_opaque_box;\n export ty_constr_arg;\n-export ty_float;\n-export ty_fn, fn_ty;\n-export ty_fn_proto;\n-export ty_fn_ret;\n-export ty_fn_ret_style;\n-export ty_int;\n-export ty_str;\n-export ty_vec;\n-export ty_nil;\n-export ty_iface;\n-export ty_res;\n-export ty_param;\n-export ty_ptr;\n-export ty_rec;\n-export ty_enum;\n-export ty_tup;\n-export ty_send_type;\n-export ty_uint;\n-export ty_uniq;\n-export ty_var;\n-export ty_self;\n-export get, type_has_params, type_has_vars, type_name, type_id;\n+export ty_float, mk_float, mk_mach_float, type_is_fp;\n+export ty_fn, fn_ty, mk_fn;\n+export ty_fn_proto, ty_fn_ret, ty_fn_ret_style;\n+export ty_int, mk_int, mk_mach_int, mk_char;\n+export ty_str, mk_str, type_is_str;\n+export ty_vec, mk_vec, type_is_vec;\n+export ty_nil, mk_nil, type_is_nil;\n+export ty_iface, mk_iface;\n+export ty_res, mk_res;\n+export ty_param, mk_param;\n+export ty_ptr, mk_ptr, mk_mut_ptr, type_is_unsafe_ptr;\n+export ty_rec, mk_rec;\n+export ty_enum, mk_enum, type_is_enum;\n+export ty_tup, mk_tup;\n+export ty_send_type, mk_send_type;\n+export ty_type, mk_type;\n+export ty_uint, mk_uint, mk_mach_uint;\n+export ty_uniq, mk_uniq, mk_imm_uniq, type_is_unique_box;\n+export ty_var, mk_var;\n+export ty_self, mk_self;\n+export get, type_has_params, type_has_vars, type_id;\n export same_type;\n export ty_var_id;\n export ty_fn_args;\n@@ -134,18 +103,9 @@ export type_err;\n export type_err_to_str;\n export type_has_dynamic_size;\n export type_needs_drop;\n-export type_is_bool;\n-export type_is_bot;\n-export type_is_box;\n-export type_is_boxed;\n-export type_is_unique_box;\n-export type_is_unsafe_ptr;\n-export type_is_vec;\n-export type_is_fp;\n export type_allows_implicit_copy;\n export type_is_integral;\n export type_is_numeric;\n-export type_is_nil;\n export type_is_pod;\n export type_is_scalar;\n export type_is_immediate;\n@@ -154,9 +114,7 @@ export type_is_signed;\n export type_is_structural;\n export type_is_copyable;\n export type_is_tup_like;\n-export type_is_str;\n export type_is_unique;\n-export type_is_enum;\n export type_is_c_like_enum;\n export type_structurally_contains;\n export type_structurally_contains_uniques;\n@@ -285,6 +243,7 @@ enum sty {\n \n     ty_type, // type_desc*\n     ty_send_type, // type_desc* that has been cloned into exchange heap\n+    ty_opaque_box, // used by monomorphizer to represend any @ box\n     ty_constr(t, [@type_constr]),\n     ty_opaque_closure_ptr(closure_kind), // ptr to env for fn, fn@, fn~\n }\n@@ -400,7 +359,8 @@ fn mk_t_named(cx: ctxt, st: sty, name: option<str>) -> t {\n     }\n     alt st {\n       ty_nil | ty_bot | ty_bool | ty_int(_) | ty_float(_) | ty_uint(_) |\n-      ty_str | ty_type | ty_send_type | ty_opaque_closure_ptr(_) {}\n+      ty_str | ty_type | ty_send_type | ty_opaque_closure_ptr(_) |\n+      ty_opaque_box {}\n       ty_param(_, _) { has_params = true; }\n       ty_var(_) | ty_self(_) { has_vars = true; }\n       ty_enum(_, tys) | ty_iface(_, tys) {\n@@ -509,6 +469,8 @@ fn mk_opaque_closure_ptr(cx: ctxt, ck: closure_kind) -> t {\n     mk_t(cx, ty_opaque_closure_ptr(ck))\n }\n \n+fn mk_opaque_box(cx: ctxt) -> t { mk_t(cx, ty_opaque_box) }\n+\n fn mk_named(cx: ctxt, base: t, name: str) -> t {\n     mk_t_named(cx, get(base).struct, some(name))\n }\n@@ -531,7 +493,7 @@ fn default_arg_mode_for_ty(ty: ty::t) -> ast::rmode {\n fn walk_ty(cx: ctxt, ty: t, f: fn(t)) {\n     alt get(ty).struct {\n       ty_nil | ty_bot | ty_bool | ty_int(_) | ty_uint(_) | ty_float(_) |\n-      ty_str | ty_send_type | ty_type |\n+      ty_str | ty_send_type | ty_type | ty_opaque_box |\n       ty_opaque_closure_ptr(_) | ty_var(_) | ty_param(_, _) {}\n       ty_box(tm) | ty_vec(tm) | ty_ptr(tm) { walk_ty(cx, tm.ty, f); }\n       ty_enum(_, subtys) | ty_iface(_, subtys) | ty_self(subtys) {\n@@ -573,7 +535,8 @@ fn fold_ty(cx: ctxt, fld: fold_mode, ty_0: t) -> t {\n \n     alt tb.struct {\n       ty_nil | ty_bot | ty_bool | ty_int(_) | ty_uint(_) | ty_float(_) |\n-      ty_str | ty_type | ty_send_type | ty_opaque_closure_ptr(_) {}\n+      ty_str | ty_type | ty_send_type | ty_opaque_closure_ptr(_) |\n+      ty_opaque_box {}\n       ty_box(tm) {\n         ty = mk_box(cx, {ty: fold_ty(cx, fld, tm.ty), mut: tm.mut});\n       }\n@@ -705,8 +668,8 @@ pure fn type_is_box(ty: t) -> bool {\n \n pure fn type_is_boxed(ty: t) -> bool {\n     alt get(ty).struct {\n-      ty_box(_) | ty_iface(_, _) { ret true; }\n-      _ { ret false; }\n+      ty_box(_) | ty_iface(_, _) | ty_opaque_box { true }\n+      _ { false }\n     }\n }\n \n@@ -856,7 +819,7 @@ fn type_kind(cx: ctxt, ty: t) -> kind {\n       ty_opaque_closure_ptr(ck_uniq) { kind_sendable }\n       // Those with refcounts-to-inner raise pinned to shared,\n       // lower unique to shared. Therefore just set result to shared.\n-      ty_box(_) | ty_iface(_, _) { kind_copyable }\n+      ty_box(_) | ty_iface(_, _) | ty_opaque_box { kind_copyable }\n       // Boxes and unique pointers raise pinned to shared.\n       ty_vec(tm) | ty_uniq(tm) { type_kind(cx, tm.ty) }\n       // Records lower to the lowest of their members.\n@@ -932,7 +895,6 @@ fn type_structurally_contains(cx: ctxt, ty: t, test: fn(sty) -> bool) ->\n }\n \n pure fn type_has_dynamic_size(cx: ctxt, ty: t) -> bool unchecked {\n-\n     /* type_structurally_contains can't be declared pure\n     because it takes a function argument. But it should be\n     referentially transparent, since a given type's size should\n@@ -1019,7 +981,7 @@ fn type_is_pod(cx: ctxt, ty: t) -> bool {\n       ty_send_type | ty_type | ty_ptr(_) { result = true; }\n       // Boxed types\n       ty_str | ty_box(_) | ty_uniq(_) | ty_vec(_) | ty_fn(_) |\n-      ty_iface(_, _) { result = false; }\n+      ty_iface(_, _) | ty_opaque_box { result = false; }\n       // Structural types\n       ty_enum(did, tps) {\n         let variants = enum_variants(cx, did);\n@@ -1201,6 +1163,7 @@ fn hash_type_structure(st: sty) -> uint {\n       ty_opaque_closure_ptr(ck_block) { 41u }\n       ty_opaque_closure_ptr(ck_box) { 42u }\n       ty_opaque_closure_ptr(ck_uniq) { 43u }\n+      ty_opaque_box { 44u }\n     }\n }\n \n@@ -2358,12 +2321,8 @@ fn substitute_type_params(cx: ctxt, substs: [ty::t], typ: t) -> t {\n \n fn def_has_ty_params(def: ast::def) -> bool {\n     alt def {\n-      ast::def_mod(_) | ast::def_const(_) |\n-      ast::def_arg(_, _) | ast::def_local(_, _) | ast::def_upvar(_, _, _) |\n-      ast::def_ty_param(_, _) | ast::def_binding(_) | ast::def_use(_) |\n-      ast::def_self(_) | ast::def_ty(_) { false }\n       ast::def_fn(_, _) | ast::def_variant(_, _) { true }\n-      _ { false } // ????\n+      _ { false }\n     }\n }\n "}, {"sha": "8fbe0ed7888bf1d019ac2379de817f12daafaefd", "filename": "src/rt/rust_builtin.cpp", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b28a5552e3e822063499c8fb7c6c0be6bb881863/src%2Frt%2Frust_builtin.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/b28a5552e3e822063499c8fb7c6c0be6bb881863/src%2Frt%2Frust_builtin.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_builtin.cpp?ref=b28a5552e3e822063499c8fb7c6c0be6bb881863", "patch": "@@ -191,6 +191,7 @@ debug_opaque(type_desc *t, uint8_t *front) {\n     }\n }\n \n+// FIXME this no longer reflects the actual structure of boxes!\n struct rust_box {\n     RUST_REFCOUNTED(rust_box)\n "}]}