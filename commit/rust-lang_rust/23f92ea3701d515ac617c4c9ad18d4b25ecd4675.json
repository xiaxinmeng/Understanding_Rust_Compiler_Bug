{"sha": "23f92ea3701d515ac617c4c9ad18d4b25ecd4675", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIzZjkyZWEzNzAxZDUxNWFjNjE3YzRjOWFkMThkNGIyNWVjZDQ2NzU=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-03-28T20:42:33Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-03-29T00:02:54Z"}, "message": "Detect and report types which could never be instantiated.\n\nFixes #2063.", "tree": {"sha": "6596de9e4d89a5525098986553534ad0fb8bf6d1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6596de9e4d89a5525098986553534ad0fb8bf6d1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/23f92ea3701d515ac617c4c9ad18d4b25ecd4675", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/23f92ea3701d515ac617c4c9ad18d4b25ecd4675", "html_url": "https://github.com/rust-lang/rust/commit/23f92ea3701d515ac617c4c9ad18d4b25ecd4675", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/23f92ea3701d515ac617c4c9ad18d4b25ecd4675/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8cf44bed57cccacdb853e620c0b479c358c83056", "url": "https://api.github.com/repos/rust-lang/rust/commits/8cf44bed57cccacdb853e620c0b479c358c83056", "html_url": "https://github.com/rust-lang/rust/commit/8cf44bed57cccacdb853e620c0b479c358c83056"}], "stats": {"total": 198, "additions": 194, "deletions": 4}, "files": [{"sha": "bfaf356a3e50e3aff3691fc56545b311609acefa", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 131, "deletions": 0, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/23f92ea3701d515ac617c4c9ad18d4b25ecd4675/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23f92ea3701d515ac617c4c9ad18d4b25ecd4675/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=23f92ea3701d515ac617c4c9ad18d4b25ecd4675", "patch": "@@ -15,6 +15,7 @@ import util::ppaux::ty_to_str;\n import util::ppaux::ty_constr_to_str;\n import syntax::print::pprust::*;\n \n+export is_instantiable;\n export node_id_to_type;\n export node_id_to_type_params;\n export arg;\n@@ -1007,6 +1008,136 @@ fn type_kind(cx: ctxt, ty: t) -> kind {\n     ret result;\n }\n \n+// True if instantiating an instance of `ty` requires an instead of `r_ty`.\n+fn is_instantiable(cx: ctxt, r_ty: t) -> bool {\n+\n+    fn type_requires(cx: ctxt, seen: @mut [def_id],\n+                     r_ty: t, ty: t) -> bool {\n+        #debug[\"type_requires(%s, %s)?\",\n+               ty_to_str(cx, r_ty),\n+               ty_to_str(cx, ty)];\n+\n+        let r = {\n+            get(r_ty).struct == get(ty).struct ||\n+                subtypes_require(cx, seen, r_ty, ty)\n+        };\n+\n+        #debug[\"type_requires(%s, %s)? %b\",\n+               ty_to_str(cx, r_ty),\n+               ty_to_str(cx, ty),\n+               r];\n+        ret r;\n+    }\n+\n+    fn subtypes_require(cx: ctxt, seen: @mut [def_id],\n+                        r_ty: t, ty: t) -> bool {\n+        #debug[\"subtypes_require(%s, %s)?\",\n+               ty_to_str(cx, r_ty),\n+               ty_to_str(cx, ty)];\n+\n+        let r = alt get(ty).struct {\n+          ty_nil |\n+          ty_bot |\n+          ty_bool |\n+          ty_int(_) |\n+          ty_uint(_) |\n+          ty_float(_) |\n+          ty_str |\n+          ty_fn(_) |\n+          ty_var(_) |\n+          ty_param(_, _) |\n+          ty_self(_) |\n+          ty_type |\n+          ty_opaque_box |\n+          ty_opaque_closure_ptr(_) |\n+          ty_vec(_) {\n+            false\n+          }\n+\n+          ty_constr(t, _) {\n+            type_requires(cx, seen, r_ty, t)\n+          }\n+\n+          ty_box(mt) |\n+          ty_uniq(mt) |\n+          ty_ptr(mt) |\n+          ty_rptr(_, mt) {\n+            be type_requires(cx, seen, r_ty, mt.ty);\n+          }\n+\n+          ty_rec(fields) {\n+            vec::any(fields) {|field|\n+                type_requires(cx, seen, r_ty, field.mt.ty)\n+            }\n+          }\n+\n+          ty_iface(_, _) {\n+            false\n+          }\n+\n+          ty_class(did, _) if vec::contains(*seen, did) {\n+            false\n+          }\n+\n+          ty_class(did, tps) {\n+            vec::push(*seen, did);\n+            let r = vec::any(lookup_class_fields(cx, did)) {|f|\n+                let fty = ty::lookup_item_type(cx, f.id);\n+                let sty = substitute_type_params(cx, tps, fty.ty);\n+                type_requires(cx, seen, r_ty, sty)\n+            };\n+            vec::pop(*seen);\n+            r\n+          }\n+\n+          ty_res(did, _, _) if vec::contains(*seen, did) {\n+            false\n+          }\n+\n+          ty_res(did, sub, tps) {\n+            vec::push(*seen, did);\n+            let sty = substitute_type_params(cx, tps, sub);\n+            let r = type_requires(cx, seen, r_ty, sty);\n+            vec::pop(*seen);\n+            r\n+          }\n+\n+          ty_tup(ts) {\n+            vec::any(ts) {|t|\n+                type_requires(cx, seen, r_ty, t)\n+            }\n+          }\n+\n+          ty_enum(did, _) if vec::contains(*seen, did) {\n+            false\n+          }\n+\n+          ty_enum(did, tps) {\n+            vec::push(*seen, did);\n+            let vs = enum_variants(cx, did);\n+            let r = vec::len(*vs) > 0u && vec::all(*vs) {|variant|\n+                vec::any(variant.args) {|aty|\n+                    let sty = substitute_type_params(cx, tps, aty);\n+                    type_requires(cx, seen, r_ty, sty)\n+                }\n+            };\n+            vec::pop(*seen);\n+            r\n+          }\n+        };\n+\n+        #debug[\"subtypes_require(%s, %s)? %b\",\n+               ty_to_str(cx, r_ty),\n+               ty_to_str(cx, ty),\n+               r];\n+\n+        ret r;\n+    }\n+\n+    let seen = @mut [];\n+    !subtypes_require(cx, seen, r_ty, r_ty)\n+}\n+\n fn type_structurally_contains(cx: ctxt, ty: t, test: fn(sty) -> bool) ->\n    bool {\n     let sty = get(ty).struct;"}, {"sha": "7d89091d475b13d3eaa6f3922fcfeb566c3da22f", "filename": "src/rustc/middle/typeck.rs", "status": "modified", "additions": 32, "deletions": 3, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/23f92ea3701d515ac617c4c9ad18d4b25ecd4675/src%2Frustc%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23f92ea3701d515ac617c4c9ad18d4b25ecd4675/src%2Frustc%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck.rs?ref=23f92ea3701d515ac617c4c9ad18d4b25ecd4675", "patch": "@@ -1145,6 +1145,7 @@ mod unify {\n // instead of ty::struct.\n fn do_autoderef(fcx: @fn_ctxt, sp: span, t: ty::t) -> ty::t {\n     let mut t1 = t;\n+    let mut enum_dids = [];\n     loop {\n         alt structure_of(fcx, sp, t1) {\n           ty::ty_box(inner) | ty::ty_uniq(inner) | ty::ty_rptr(_, inner) {\n@@ -1161,6 +1162,16 @@ fn do_autoderef(fcx: @fn_ctxt, sp: span, t: ty::t) -> ty::t {\n             t1 = ty::substitute_type_params(fcx.ccx.tcx, tps, inner);\n           }\n           ty::ty_enum(did, tps) {\n+            // Watch out for a type like `enum t = @t`.  Such a type would\n+            // otherwise infinitely auto-deref.  This is the only autoderef\n+            // loop that needs to be concerned with this, as an error will be\n+            // reported on the enum definition as well because the enum is not\n+            // instantiable.\n+            if vec::contains(enum_dids, did) {\n+                ret t1;\n+            }\n+            vec::push(enum_dids, did);\n+\n             let variants = ty::enum_variants(fcx.ccx.tcx, did);\n             if vec::len(*variants) != 1u || vec::len(variants[0].args) != 1u {\n                 ret t1;\n@@ -3396,6 +3407,18 @@ fn check_const(ccx: @crate_ctxt, _sp: span, e: @ast::expr, id: ast::node_id) {\n     demand::simple(fcx, e.span, declty, cty);\n }\n \n+fn check_instantiable(tcx: ty::ctxt,\n+                      sp: span,\n+                      item_id: ast::node_id) {\n+    let rty = ty::node_id_to_type(tcx, item_id);\n+    if !ty::is_instantiable(tcx, rty) {\n+        tcx.sess.span_err(sp, #fmt[\"this type cannot be instantiated \\\n+                                    without an instance of itself. \\\n+                                    Consider using option<%s>.\",\n+                                   ty_to_str(tcx, rty)]);\n+    }\n+}\n+\n fn check_enum_variants(ccx: @crate_ctxt, sp: span, vs: [ast::variant],\n                       id: ast::node_id) {\n     // FIXME: this is kinda a kludge; we manufacture a fake function context\n@@ -3443,6 +3466,8 @@ fn check_enum_variants(ccx: @crate_ctxt, sp: span, vs: [ast::variant],\n         disr_vals += [disr_val];\n         disr_val += 1;\n     }\n+\n+    // Check that it is possible to represent this enum:\n     let mut outer = true, did = local_def(id);\n     if ty::type_structurally_contains(ccx.tcx, rty, {|sty|\n         alt sty {\n@@ -3453,10 +3478,13 @@ fn check_enum_variants(ccx: @crate_ctxt, sp: span, vs: [ast::variant],\n           _ { false }\n         }\n     }) {\n-        ccx.tcx.sess.span_fatal(sp, \"illegal recursive enum type. \\\n-                                     wrap the inner value in a box to \\\n-                                     make it represenable\");\n+        ccx.tcx.sess.span_err(sp, \"illegal recursive enum type. \\\n+                                   wrap the inner value in a box to \\\n+                                   make it represenable\");\n     }\n+\n+    // Check that it is possible to instantiate this enum:\n+    check_instantiable(ccx.tcx, sp, id);\n }\n \n // A generic function for checking the pred in a check\n@@ -3672,6 +3700,7 @@ fn check_item(ccx: @crate_ctxt, it: @ast::item) {\n         check_fn(ccx, ast::proto_bare, decl, body, it.id, false, none);\n       }\n       ast::item_res(decl, tps, body, dtor_id, _) {\n+        check_instantiable(ccx.tcx, it.span, it.id);\n         check_fn(ccx, ast::proto_bare, decl, body, dtor_id, false, none);\n       }\n       ast::item_impl(tps, _, ty, ms) {"}, {"sha": "821365f43ac04fd3fa41c8ce15dfbca334db75f1", "filename": "src/test/compile-fail/issue-2063-resource.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/23f92ea3701d515ac617c4c9ad18d4b25ecd4675/src%2Ftest%2Fcompile-fail%2Fissue-2063-resource.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23f92ea3701d515ac617c4c9ad18d4b25ecd4675/src%2Ftest%2Fcompile-fail%2Fissue-2063-resource.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2063-resource.rs?ref=23f92ea3701d515ac617c4c9ad18d4b25ecd4675", "patch": "@@ -0,0 +1,12 @@\n+// test that autoderef of a type like this does not\n+// cause compiler to loop.  Note that no instances\n+// of such a type could ever be constructed.\n+resource t(x: x) {} //! ERROR this type cannot be instantiated\n+enum x = @t; //! ERROR this type cannot be instantiated\n+\n+fn new_t(x: t) {\n+    x.to_str; //! ERROR attempted access of field to_str\n+}\n+\n+fn main() {\n+}"}, {"sha": "b061ed9d7338f0e1dede51b669f717e01563ce02", "filename": "src/test/compile-fail/issue-2063.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/23f92ea3701d515ac617c4c9ad18d4b25ecd4675/src%2Ftest%2Fcompile-fail%2Fissue-2063.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23f92ea3701d515ac617c4c9ad18d4b25ecd4675/src%2Ftest%2Fcompile-fail%2Fissue-2063.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2063.rs?ref=23f92ea3701d515ac617c4c9ad18d4b25ecd4675", "patch": "@@ -0,0 +1,18 @@\n+// test that autoderef of a type like this does not\n+// cause compiler to loop.  Note that no instances\n+// of such a type could ever be constructed.\n+enum t = @t; //! ERROR this type cannot be instantiated\n+\n+// I use an impl here because it will cause\n+// the compiler to attempt autoderef and then\n+// try to resolve the method.\n+impl methods for t {\n+    fn to_str() -> str { \"t\" }\n+}\n+\n+fn new_t(x: t) {\n+    x.to_str();\n+}\n+\n+fn main() {\n+}"}, {"sha": "3aa1c31bb7291fd662d8918b330c35379639913c", "filename": "src/test/run-pass/export-non-interference.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/23f92ea3701d515ac617c4c9ad18d4b25ecd4675/src%2Ftest%2Frun-pass%2Fexport-non-interference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23f92ea3701d515ac617c4c9ad18d4b25ecd4675/src%2Ftest%2Frun-pass%2Fexport-non-interference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexport-non-interference.rs?ref=23f92ea3701d515ac617c4c9ad18d4b25ecd4675", "patch": "@@ -2,6 +2,6 @@\n export foo;\n export main;\n \n-enum list_cell<T> { cons(@list_cell<T>), }\n+enum list_cell<T> { cons(@list_cell<T>), nil }\n \n fn main() { }"}]}