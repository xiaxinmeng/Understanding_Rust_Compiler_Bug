{"sha": "63eb8e0e8784ad8cc126bf80a9267c30b4a3a82a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYzZWI4ZTBlODc4NGFkOGNjMTI2YmY4MGE5MjY3YzMwYjRhM2E4MmE=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-05-11T20:09:19Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-05-11T21:05:58Z"}, "message": "move purity checking into borrowck, addresses #1422", "tree": {"sha": "f82e34007301b2bb272260440b1c3b498bc43044", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f82e34007301b2bb272260440b1c3b498bc43044"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/63eb8e0e8784ad8cc126bf80a9267c30b4a3a82a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/63eb8e0e8784ad8cc126bf80a9267c30b4a3a82a", "html_url": "https://github.com/rust-lang/rust/commit/63eb8e0e8784ad8cc126bf80a9267c30b4a3a82a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/63eb8e0e8784ad8cc126bf80a9267c30b4a3a82a/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2585384c977046a58e140c598ac5d4270501568d", "url": "https://api.github.com/repos/rust-lang/rust/commits/2585384c977046a58e140c598ac5d4270501568d", "html_url": "https://github.com/rust-lang/rust/commit/2585384c977046a58e140c598ac5d4270501568d"}], "stats": {"total": 291, "additions": 203, "deletions": 88}, "files": [{"sha": "7a316507912fa3dde25e438c1b9d40a0a2f64383", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/63eb8e0e8784ad8cc126bf80a9267c30b4a3a82a/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63eb8e0e8784ad8cc126bf80a9267c30b4a3a82a/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=63eb8e0e8784ad8cc126bf80a9267c30b4a3a82a", "patch": "@@ -997,7 +997,7 @@ impl extensions<T> for [const T] {\n     fn iteri(f: fn(uint, T)) { iteri(self, f) }\n     #[doc = \"Returns the length of a vector\"]\n     #[inline]\n-    fn len() -> uint { len(self) }\n+    pure fn len() -> uint { len(self) }\n     #[doc = \"\n     Find the first index matching some predicate\n "}, {"sha": "cd881f1c73188e937403baf58ce58707eea9c137", "filename": "src/rustc/middle/borrowck.rs", "status": "modified", "additions": 141, "deletions": 25, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/63eb8e0e8784ad8cc126bf80a9267c30b4a3a82a/src%2Frustc%2Fmiddle%2Fborrowck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63eb8e0e8784ad8cc126bf80a9267c30b4a3a82a/src%2Frustc%2Fmiddle%2Fborrowck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck.rs?ref=63eb8e0e8784ad8cc126bf80a9267c30b4a3a82a", "patch": "@@ -149,6 +149,13 @@ fn check_sup_mutbl(req_m: ast::mutability,\n     }\n }\n \n+fn save_and_restore<T:copy,U>(&t: T, f: fn() -> U) -> U {\n+    let old_t = t;\n+    let u <- f();\n+    t = old_t;\n+    ret u;\n+}\n+\n // ----------------------------------------------------------------------\n // Gathering loans\n //\n@@ -398,15 +405,18 @@ enum check_loan_ctxt = @{\n     // Keep track of whether we're inside a ctor, so as to\n     // allow mutating immutable fields in the same class if\n     // we are in a ctor, we track the self id\n-    mut in_ctor: bool\n+    mut in_ctor: bool,\n+\n+    mut is_pure: bool\n };\n \n fn check_loans(bccx: borrowck_ctxt,\n                req_loan_map: req_loan_map,\n                crate: @ast::crate) {\n     let clcx = check_loan_ctxt(@{bccx: bccx,\n                                  req_loan_map: req_loan_map,\n-                                 mut in_ctor: false});\n+                                 mut in_ctor: false,\n+                                 mut is_pure: false});\n     let vt = visit::mk_vt(@{visit_expr: check_loans_in_expr,\n                             visit_block: check_loans_in_block,\n                             visit_fn: check_loans_in_fn\n@@ -465,6 +475,76 @@ impl methods for check_loan_ctxt {\n         }\n     }\n \n+    // when we are in a pure context, we check each call to ensure\n+    // that the function which is invoked is itself pure.\n+    fn check_pure(expr: @ast::expr) {\n+        let tcx = self.tcx();\n+        alt ty::get(tcx.ty(expr)).struct {\n+          ty::ty_fn(_) {\n+            // Extract purity or unsafety based on what kind of callee\n+            // we've got.  This would be cleaner if we just admitted\n+            // that we have an effect system and carried the purity\n+            // etc around in the type.\n+\n+            // First, check the def_map---if expr.id is present then\n+            // expr must be a path (at least I think that's the idea---NDM)\n+            let callee_purity = alt tcx.def_map.find(expr.id) {\n+              some(ast::def_fn(_, p)) { p }\n+              some(ast::def_variant(_, _)) { ast::pure_fn }\n+              _ {\n+                // otherwise it may be a method call that we can trace\n+                // to the def'n site:\n+                alt self.bccx.method_map.find(expr.id) {\n+                  some(typeck::method_static(did)) {\n+                    if did.crate == ast::local_crate {\n+                        alt tcx.items.get(did.node) {\n+                          ast_map::node_method(m, _, _) { m.decl.purity }\n+                          _ { tcx.sess.span_bug(expr.span,\n+                                                \"Node not bound \\\n+                                                 to a method\") }\n+                        }\n+                    } else {\n+                        metadata::csearch::lookup_method_purity(\n+                            tcx.sess.cstore,\n+                            did)\n+                    }\n+                  }\n+                  some(typeck::method_param(iid, n_m, _, _)) |\n+                  some(typeck::method_iface(iid, n_m)) {\n+                    ty::iface_methods(tcx, iid)[n_m].purity\n+                  }\n+                  none {\n+                    // otherwise it's just some dang thing.  We know\n+                    // it cannot be unsafe because we do not allow\n+                    // unsafe functions to be used as values (or,\n+                    // rather, we only allow that inside an unsafe\n+                    // block, and then it's up to the user to keep\n+                    // things confined).\n+                    ast::impure_fn\n+                  }\n+                }\n+              }\n+            };\n+\n+            alt callee_purity {\n+              ast::crust_fn | ast::pure_fn { /*ok*/ }\n+              ast::impure_fn {\n+                self.bccx.span_err(\n+                    expr.span,\n+                    \"pure function calls function \\\n+                     not known to be pure\");\n+              }\n+              ast::unsafe_fn {\n+                self.bccx.span_err(\n+                    expr.span,\n+                    \"pure function calls unsafe function\");\n+              }\n+            }\n+          }\n+          _ { /* not a fn, ok */ }\n+        }\n+    }\n+\n     fn check_for_conflicting_loans(scope_id: ast::node_id) {\n         let new_loanss = alt self.req_loan_map.find(scope_id) {\n             none { ret; }\n@@ -532,6 +612,16 @@ impl methods for check_loan_ctxt {\n             }\n         }\n \n+        // if this is a pure function, only loan-able state can be\n+        // assigned, because it is uniquely tied to this function and\n+        // is not visible from the outside\n+        if self.is_pure && cmt.lp.is_none() {\n+            self.bccx.span_err(\n+                ex.span,\n+                #fmt[\"%s prohibited in pure functions\",\n+                     at.ing_form(self.bccx.cmt_to_str(cmt))]);\n+        }\n+\n         // check for a conflicting loan as well, except in the case of\n         // taking a mutable ref.  that will create a loan of its own\n         // which will be checked for compat separately in\n@@ -617,21 +707,27 @@ fn check_loans_in_fn(fk: visit::fn_kind, decl: ast::fn_decl, body: ast::blk,\n                      sp: span, id: ast::node_id, &&self: check_loan_ctxt,\n                      visitor: visit::vt<check_loan_ctxt>) {\n \n-    let old_in_ctor = self.in_ctor;\n-\n-    // In principle, we could consider fk_anon(*) or fk_fn_block(*) to\n-    // be in a ctor, I suppose, but the purpose of the in_ctor flag is\n-    // to allow modifications of otherwise immutable fields and\n-    // typestate wouldn't be able to \"see\" into those functions\n-    // anyway, so it wouldn't be very helpful.\n-    alt fk {\n-      visit::fk_ctor(*) { self.in_ctor = true; }\n-      _ { self.in_ctor = false; }\n-    };\n+    save_and_restore(self.in_ctor) {||\n+        save_and_restore(self.is_pure) {||\n+            // In principle, we could consider fk_anon(*) or\n+            // fk_fn_block(*) to be in a ctor, I suppose, but the\n+            // purpose of the in_ctor flag is to allow modifications\n+            // of otherwise immutable fields and typestate wouldn't be\n+            // able to \"see\" into those functions anyway, so it\n+            // wouldn't be very helpful.\n+            alt fk {\n+              visit::fk_ctor(*) { self.in_ctor = true; }\n+              _ { self.in_ctor = false; }\n+            };\n \n-    visit::visit_fn(fk, decl, body, sp, id, self, visitor);\n+            alt decl.purity {\n+              ast::pure_fn { self.is_pure = true; }\n+              _ { }\n+            }\n \n-    self.in_ctor = old_in_ctor;\n+            visit::visit_fn(fk, decl, body, sp, id, self, visitor);\n+        }\n+    }\n }\n \n fn check_loans_in_expr(expr: @ast::expr,\n@@ -680,6 +776,10 @@ fn check_loans_in_expr(expr: @ast::expr,\n         }\n       }\n       ast::expr_call(f, args, _) {\n+        if self.is_pure {\n+            self.check_pure(f);\n+            for args.each { |arg| self.check_pure(arg) }\n+        }\n         let arg_tys = ty::ty_fn_args(ty::expr_ty(self.tcx(), f));\n         vec::iter2(args, arg_tys) { |arg, arg_ty|\n             alt ty::resolved_mode(self.tcx(), arg_ty.mode) {\n@@ -696,14 +796,25 @@ fn check_loans_in_expr(expr: @ast::expr,\n       }\n       _ { }\n     }\n+\n     visit::visit_expr(expr, self, vt);\n }\n \n fn check_loans_in_block(blk: ast::blk,\n                         &&self: check_loan_ctxt,\n                         vt: visit::vt<check_loan_ctxt>) {\n-    self.check_for_conflicting_loans(blk.node.id);\n-    visit::visit_block(blk, self, vt);\n+    save_and_restore(self.is_pure) {||\n+        self.check_for_conflicting_loans(blk.node.id);\n+\n+        alt blk.node.rules {\n+          ast::default_blk {\n+          }\n+          ast::unchecked_blk |\n+          ast::unsafe_blk { self.is_pure = false; }\n+        }\n+\n+        visit::visit_block(blk, self, vt);\n+    }\n }\n \n // ----------------------------------------------------------------------\n@@ -1022,20 +1133,25 @@ impl categorize_methods for borrowck_ctxt {\n             // lp: loan path, must be none for aliasable things\n             let {m,lp} = alt ty::resolved_mode(self.tcx, mode) {\n               ast::by_mutbl_ref {\n-                {m:m_mutbl, lp:none}\n+                {m: m_mutbl,\n+                 lp: none}\n               }\n               ast::by_move | ast::by_copy {\n-                {m:m_mutbl, lp:some(@lp_arg(vid))}\n+                {m: m_mutbl,\n+                 lp: some(@lp_arg(vid))}\n               }\n               ast::by_ref {\n-                if TREAT_CONST_AS_IMM {\n-                    {m:m_imm, lp:some(@lp_arg(vid))}\n-                } else {\n-                    {m:m_const, lp:none}\n-                }\n+                {m: if TREAT_CONST_AS_IMM {m_imm} else {m_const},\n+                 lp: none}\n               }\n               ast::by_val {\n-                {m:m_imm, lp:some(@lp_arg(vid))}\n+                // by-value is this hybrid mode where we have a\n+                // pointer but we do not own it.  This is not\n+                // considered loanable because, for example, a by-ref\n+                // and and by-val argument might both actually contain\n+                // the same unique ptr.\n+                {m: m_imm,\n+                 lp: none}\n               }\n             };\n             @{id:id, span:span,"}, {"sha": "6f77fc957b2dfb8c2cabad1ff813491cac38faea", "filename": "src/rustc/middle/typeck.rs", "status": "modified", "additions": 0, "deletions": 59, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/63eb8e0e8784ad8cc126bf80a9267c30b4a3a82a/src%2Frustc%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63eb8e0e8784ad8cc126bf80a9267c30b4a3a82a/src%2Frustc%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck.rs?ref=63eb8e0e8784ad8cc126bf80a9267c30b4a3a82a", "patch": "@@ -1349,18 +1349,6 @@ impl methods for @fn_ctxt {\n         infer::mk_eqty(self.infcx, sub, sup)\n     }\n \n-    fn require_impure(sp: span) {\n-        alt self.purity {\n-          ast::unsafe_fn { ret; }\n-          ast::impure_fn | ast::crust_fn { ret; }\n-          ast::pure_fn {\n-            self.ccx.tcx.sess.span_err(\n-                sp,\n-                \"found impure expression in pure function decl\");\n-          }\n-        }\n-    }\n-\n     fn require_unsafe(sp: span, op: str) {\n         alt self.purity {\n           ast::unsafe_fn {/*ok*/}\n@@ -2425,45 +2413,6 @@ fn check_pat(pcx: pat_ctxt, pat: @ast::pat, expected: ty::t) {\n     }\n }\n \n-fn require_pure_call(ccx: @crate_ctxt, caller_purity: ast::purity,\n-                     callee: @ast::expr, sp: span) {\n-    if caller_purity == ast::unsafe_fn { ret; }\n-    let callee_purity = alt ccx.tcx.def_map.find(callee.id) {\n-      some(ast::def_fn(_, p)) { p }\n-      some(ast::def_variant(_, _)) { ast::pure_fn }\n-      _ {\n-        alt ccx.method_map.find(callee.id) {\n-          some(method_static(did)) {\n-            if did.crate == ast::local_crate {\n-                alt ccx.tcx.items.get(did.node) {\n-                  ast_map::node_method(m, _, _) { m.decl.purity }\n-                  _ { ccx.tcx.sess.span_bug(sp,\n-                             \"Node not bound to a method\") }\n-                }\n-            } else {\n-                csearch::lookup_method_purity(ccx.tcx.sess.cstore, did)\n-            }\n-          }\n-          some(method_param(iid, n_m, _, _)) | some(method_iface(iid, n_m)) {\n-            ty::iface_methods(ccx.tcx, iid)[n_m].purity\n-          }\n-          none { ast::impure_fn }\n-        }\n-      }\n-    };\n-    alt (caller_purity, callee_purity) {\n-      (ast::impure_fn, ast::unsafe_fn) | (ast::crust_fn, ast::unsafe_fn) {\n-        ccx.tcx.sess.span_err(sp, \"safe function calls function marked \\\n-                                   unsafe\");\n-      }\n-      (ast::pure_fn, ast::unsafe_fn) | (ast::pure_fn, ast::impure_fn) {\n-        ccx.tcx.sess.span_err(sp, \"pure function calls function not \\\n-                                   known to be pure\");\n-      }\n-      _ {}\n-    }\n-}\n-\n fn check_expr_with(fcx: @fn_ctxt, expr: @ast::expr, expected: ty::t) -> bool {\n     check_expr(fcx, expr, some(expected))\n }\n@@ -2989,10 +2938,6 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n             r.fty\n         };\n \n-        // Need to restrict oper to being an explicit expr_path if we're\n-        // inside a pure function\n-        require_pure_call(fcx.ccx, fcx.purity, f, sp);\n-\n         // Pull the return type out of the type of the function.\n         alt structure_of(fcx, sp, fty) {\n           ty::ty_fn(f) {\n@@ -3277,7 +3222,6 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         bot |= check_binop(fcx, expr, op, lhs, rhs);\n       }\n       ast::expr_assign_op(op, lhs, rhs) {\n-        fcx.require_impure(expr.span);\n         bot |= check_binop(fcx, expr, op, lhs, rhs);\n         let lhs_t = fcx.expr_ty(lhs);\n         let result_t = fcx.expr_ty(expr);\n@@ -3437,15 +3381,12 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         fcx.write_ty(id, fcx.expr_ty(a));\n       }\n       ast::expr_move(lhs, rhs) {\n-        fcx.require_impure(expr.span);\n         bot = check_assignment(fcx, expr.span, lhs, rhs, id);\n       }\n       ast::expr_assign(lhs, rhs) {\n-        fcx.require_impure(expr.span);\n         bot = check_assignment(fcx, expr.span, lhs, rhs, id);\n       }\n       ast::expr_swap(lhs, rhs) {\n-        fcx.require_impure(expr.span);\n         bot = check_assignment(fcx, expr.span, lhs, rhs, id);\n       }\n       ast::expr_if(cond, thn, elsopt) {"}, {"sha": "ee44500fee392705e3a5906a8d5c76dc03dd21d1", "filename": "src/test/compile-fail/native-unsafe-fn-called.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/63eb8e0e8784ad8cc126bf80a9267c30b4a3a82a/src%2Ftest%2Fcompile-fail%2Fnative-unsafe-fn-called.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63eb8e0e8784ad8cc126bf80a9267c30b4a3a82a/src%2Ftest%2Fcompile-fail%2Fnative-unsafe-fn-called.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnative-unsafe-fn-called.rs?ref=63eb8e0e8784ad8cc126bf80a9267c30b4a3a82a", "patch": "@@ -1,11 +1,12 @@\n // -*- rust -*-\n-// error-pattern: safe function calls function marked unsafe\n+\n #[abi = \"cdecl\"]\n native mod test {\n     unsafe fn free();\n }\n \n fn main() {\n     test::free();\n+    //!^ ERROR access to unsafe function requires unsafe function or block\n }\n "}, {"sha": "9e825b9dacad0633d7e68f7bb6af4145a55d6d25", "filename": "src/test/compile-fail/pure-modifies-aliased.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/63eb8e0e8784ad8cc126bf80a9267c30b4a3a82a/src%2Ftest%2Fcompile-fail%2Fpure-modifies-aliased.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63eb8e0e8784ad8cc126bf80a9267c30b4a3a82a/src%2Ftest%2Fcompile-fail%2Fpure-modifies-aliased.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpure-modifies-aliased.rs?ref=63eb8e0e8784ad8cc126bf80a9267c30b4a3a82a", "patch": "@@ -0,0 +1,18 @@\n+// Check that pure functions cannot modify aliased state.\n+\n+pure fn modify_in_ref(&&sum: {mut f: int}) {\n+    sum.f = 3; //! ERROR assigning to mutable field prohibited in pure functions\n+}\n+\n+pure fn modify_in_box(sum: @mut {f: int}) {\n+    sum.f = 3; //! ERROR assigning to mutable field prohibited in pure functions\n+}\n+\n+impl foo for int {\n+    pure fn modify_in_box_rec(sum: @{mut f: int}) {\n+        sum.f = self; //! ERROR assigning to mutable field prohibited in pure functions\n+    }\n+}\n+\n+fn main() {\n+}\n\\ No newline at end of file"}, {"sha": "2353be31c2bf9add95813475963ab4c3890e4761", "filename": "src/test/compile-fail/unsafe-fn-called-from-safe.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/63eb8e0e8784ad8cc126bf80a9267c30b4a3a82a/src%2Ftest%2Fcompile-fail%2Funsafe-fn-called-from-safe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63eb8e0e8784ad8cc126bf80a9267c30b4a3a82a/src%2Ftest%2Fcompile-fail%2Funsafe-fn-called-from-safe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsafe-fn-called-from-safe.rs?ref=63eb8e0e8784ad8cc126bf80a9267c30b4a3a82a", "patch": "@@ -1,8 +1,7 @@\n // -*- rust -*-\n-// error-pattern: safe function calls function marked unsafe\n \n unsafe fn f() { ret; }\n \n fn main() {\n-    f();\n+    f(); //! ERROR access to unsafe function requires unsafe function or block\n }"}, {"sha": "f5bc71d94b057b7c74f4443d8e30917e9332f610", "filename": "src/test/run-pass/pure-sum.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/63eb8e0e8784ad8cc126bf80a9267c30b4a3a82a/src%2Ftest%2Frun-pass%2Fpure-sum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63eb8e0e8784ad8cc126bf80a9267c30b4a3a82a/src%2Ftest%2Frun-pass%2Fpure-sum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpure-sum.rs?ref=63eb8e0e8784ad8cc126bf80a9267c30b4a3a82a", "patch": "@@ -0,0 +1,40 @@\n+// Check that pure functions can modify local state.\n+\n+pure fn sums_to(v: [int], sum: int) -> bool {\n+    let mut i = 0u, sum0 = 0;\n+    while i < v.len() {\n+        sum0 += v[i];\n+        i += 1u;\n+    }\n+    ret sum0 == sum;\n+}\n+\n+pure fn sums_to_using_uniq(v: [int], sum: int) -> bool {\n+    let mut i = 0u, sum0 = ~mut 0;\n+    while i < v.len() {\n+        *sum0 += v[i];\n+        i += 1u;\n+    }\n+    ret *sum0 == sum;\n+}\n+\n+pure fn sums_to_using_rec(v: [int], sum: int) -> bool {\n+    let mut i = 0u, sum0 = {f: 0};\n+    while i < v.len() {\n+        sum0.f += v[i];\n+        i += 1u;\n+    }\n+    ret sum0.f == sum;\n+}\n+\n+pure fn sums_to_using_uniq_rec(v: [int], sum: int) -> bool {\n+    let mut i = 0u, sum0 = {f: ~mut 0};\n+    while i < v.len() {\n+        *sum0.f += v[i];\n+        i += 1u;\n+    }\n+    ret *sum0.f == sum;\n+}\n+\n+fn main() {\n+}\n\\ No newline at end of file"}]}