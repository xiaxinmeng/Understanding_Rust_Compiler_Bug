{"sha": "b822e699c3e811f929fd69046095c1d6eb9abd22", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI4MjJlNjk5YzNlODExZjkyOWZkNjkwNDYwOTVjMWQ2ZWI5YWJkMjI=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2018-07-16T06:57:49Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2018-07-16T06:57:49Z"}, "message": "Revert \"Use callback-based interface to load ThinLTO import data into rustc.\"\n\nThis reverts commit e045a6cd8c0235a26ef11e6cd9a13ebd817f1265.", "tree": {"sha": "d18fec3f7882dca43be036aa8dde18d5f4acf227", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d18fec3f7882dca43be036aa8dde18d5f4acf227"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b822e699c3e811f929fd69046095c1d6eb9abd22", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b822e699c3e811f929fd69046095c1d6eb9abd22", "html_url": "https://github.com/rust-lang/rust/commit/b822e699c3e811f929fd69046095c1d6eb9abd22", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b822e699c3e811f929fd69046095c1d6eb9abd22/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "99140df0bd5a4dd77db28d78e73df4b5f6ba79a6", "url": "https://api.github.com/repos/rust-lang/rust/commits/99140df0bd5a4dd77db28d78e73df4b5f6ba79a6", "html_url": "https://github.com/rust-lang/rust/commit/99140df0bd5a4dd77db28d78e73df4b5f6ba79a6"}], "stats": {"total": 154, "additions": 96, "deletions": 58}, "files": [{"sha": "a68f22b2651f9eee70f506b9bb85b2f8c1e83e27", "filename": "src/librustc_codegen_llvm/back/lto.rs", "status": "modified", "additions": 43, "deletions": 31, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/b822e699c3e811f929fd69046095c1d6eb9abd22/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b822e699c3e811f929fd69046095c1d6eb9abd22/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs?ref=b822e699c3e811f929fd69046095c1d6eb9abd22", "patch": "@@ -805,54 +805,66 @@ pub struct ThinLTOImports {\n \n impl ThinLTOImports {\n \n-    pub fn new() -> ThinLTOImports {\n+    pub fn new_empty() -> ThinLTOImports {\n         ThinLTOImports {\n             imports: FxHashMap(),\n         }\n     }\n \n     /// Load the ThinLTO import map from ThinLTOData.\n     unsafe fn from_thin_lto_data(data: *const llvm::ThinLTOData) -> ThinLTOImports {\n+        let raw_data: *const llvm::ThinLTOModuleImports =\n+            llvm::LLVMRustGetThinLTOModuleImports(data);\n \n-        fn module_name_to_str(c_str: &CStr) -> &str {\n-            match c_str.to_str() {\n-                Ok(s) => s,\n-                Err(e) => {\n-                    bug!(\"Encountered non-utf8 LLVM module name `{}`: {}\",\n-                        c_str.to_string_lossy(),\n-                        e)\n-                }\n+        assert!(!raw_data.is_null());\n+\n+        let mut imports = FxHashMap();\n+        let mut module_ptr = raw_data;\n+        let mut module_index = 0;\n+\n+        loop {\n+            let mut entry_ptr: *const llvm::ThinLTOModuleName = *module_ptr;\n+\n+            if entry_ptr.is_null() {\n+                break;\n             }\n-        }\n \n-        unsafe extern \"C\" fn imported_module_callback(payload: *mut libc::c_void,\n-                                                      importing_module_name: *const libc::c_char,\n-                                                      imported_module_name: *const libc::c_char) {\n-            let map = &mut* (payload as *mut ThinLTOImports);\n+            let importing_module_name = CStr::from_ptr(*entry_ptr)\n+                .to_str()\n+                .expect(\"Non-utf8 LLVM module name encountered\")\n+                .to_owned();\n+\n+            entry_ptr = entry_ptr.offset(1);\n \n-            let importing_module_name = CStr::from_ptr(importing_module_name);\n-            let importing_module_name = module_name_to_str(&importing_module_name);\n-            let imported_module_name = CStr::from_ptr(imported_module_name);\n-            let imported_module_name = module_name_to_str(&imported_module_name);\n+            let mut imported_modules = vec![];\n \n-            if !map.imports.contains_key(importing_module_name) {\n-                map.imports.insert(importing_module_name.to_owned(), vec![]);\n+            loop {\n+                let imported_module_name = *entry_ptr;\n+\n+                if imported_module_name.is_null() {\n+                    break\n+                }\n+\n+                let imported_module_name = CStr::from_ptr(imported_module_name)\n+                    .to_str()\n+                    .expect(\"Non-utf8 LLVM module name encountered\")\n+                    .to_owned();\n+\n+                imported_modules.push(imported_module_name);\n+                entry_ptr = entry_ptr.offset(1);\n             }\n \n-            map.imports\n-               .get_mut(importing_module_name)\n-               .unwrap()\n-               .push(imported_module_name.to_owned());\n+            imports.insert(importing_module_name, imported_modules);\n+\n+            module_ptr = module_ptr.offset(1);\n+            module_index += 1;\n         }\n \n-        let mut map = ThinLTOImports {\n-            imports: FxHashMap(),\n-        };\n+        assert_eq!(module_index, imports.len());\n \n-        llvm::LLVMRustGetThinLTOModuleImports(data,\n-                                              imported_module_callback,\n-                                              &mut map as *mut _ as *mut libc::c_void);\n-        map\n+        ThinLTOImports {\n+            imports\n+        }\n     }\n \n     pub fn save_to_file(&self, path: &Path) -> io::Result<()> {"}, {"sha": "603ee78585ea69601bee01f7a050aefa787c4889", "filename": "src/librustc_codegen_llvm/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b822e699c3e811f929fd69046095c1d6eb9abd22/src%2Flibrustc_codegen_llvm%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b822e699c3e811f929fd69046095c1d6eb9abd22/src%2Flibrustc_codegen_llvm%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbase.rs?ref=b822e699c3e811f929fd69046095c1d6eb9abd22", "patch": "@@ -1360,7 +1360,7 @@ fn load_thin_lto_imports(sess: &Session) -> lto::ThinLTOImports {\n     );\n \n     if !path.exists() {\n-        return lto::ThinLTOImports::new();\n+        return lto::ThinLTOImports::new_empty();\n     }\n \n     match lto::ThinLTOImports::load_from_file(&path) {"}, {"sha": "9b2309a4e2b6b80269df35888b46b7320da75596", "filename": "src/librustc_llvm/ffi.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b822e699c3e811f929fd69046095c1d6eb9abd22/src%2Flibrustc_llvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b822e699c3e811f929fd69046095c1d6eb9abd22/src%2Flibrustc_llvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Fffi.rs?ref=b822e699c3e811f929fd69046095c1d6eb9abd22", "patch": "@@ -351,9 +351,10 @@ pub enum ThinLTOData {}\n /// LLVMRustThinLTOBuffer\n pub enum ThinLTOBuffer {}\n \n-// LLVMRustModuleNameCallback\n-pub type ThinLTOModuleNameCallback =\n-    unsafe extern \"C\" fn(*mut c_void, *const c_char, *const c_char);\n+/// LLVMRustThinLTOModuleName\n+pub type ThinLTOModuleName = *const c_char;\n+/// LLVMRustThinLTOModuleImports\n+pub type ThinLTOModuleImports = *const ThinLTOModuleName;\n \n /// LLVMRustThinLTOModule\n #[repr(C)]\n@@ -1785,9 +1786,7 @@ extern \"C\" {\n     ) -> bool;\n     pub fn LLVMRustGetThinLTOModuleImports(\n         Data: *const ThinLTOData,\n-        ModuleNameCallback: ThinLTOModuleNameCallback,\n-        CallbackPayload: *mut c_void,\n-    );\n+    ) -> *const ThinLTOModuleImports;\n     pub fn LLVMRustFreeThinLTOData(Data: *mut ThinLTOData);\n     pub fn LLVMRustParseBitcodeForThinLTO(\n         Context: ContextRef,"}, {"sha": "30f585efedc125ddbe1a8b2134d71f38736f6be3", "filename": "src/rustllvm/PassWrapper.cpp", "status": "modified", "additions": 47, "deletions": 20, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/b822e699c3e811f929fd69046095c1d6eb9abd22/src%2Frustllvm%2FPassWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/b822e699c3e811f929fd69046095c1d6eb9abd22/src%2Frustllvm%2FPassWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FPassWrapper.cpp?ref=b822e699c3e811f929fd69046095c1d6eb9abd22", "patch": "@@ -798,6 +798,11 @@ LLVMRustPGOAvailable() {\n #endif\n }\n \n+// We encode the ThinLTO module import map as a nested null-terminated list to\n+// get it into Rust.\n+typedef const char* LLVMRustThinLTOModuleName;\n+typedef LLVMRustThinLTOModuleName* LLVMRustThinLTOModuleImports;\n+\n #if LLVM_VERSION_GE(4, 0)\n \n // Here you'll find an implementation of ThinLTO as used by the Rust compiler\n@@ -1099,28 +1104,50 @@ LLVMRustPrepareThinLTOImport(const LLVMRustThinLTOData *Data, LLVMModuleRef M) {\n   return true;\n }\n \n-extern \"C\" typedef void (*LLVMRustModuleNameCallback)(void*, // payload\n-                                                      const char*, // importing module name\n-                                                      const char*); // imported module name\n-\n-// Calls `module_name_callback` for each module import done by ThinLTO.\n-// The callback is provided with regular null-terminated C strings.\n-extern \"C\" void\n-LLVMRustGetThinLTOModuleImports(const LLVMRustThinLTOData *data,\n-                                LLVMRustModuleNameCallback module_name_callback,\n-                                void* callback_payload) {\n-  for (const auto& importing_module : data->ImportLists) {\n-    const std::string importing_module_id = importing_module.getKey().str();\n-\n-    const auto& imports = importing_module.getValue();\n-\n-    for (const auto& imported_module : imports) {\n-      const std::string imported_module_id = imported_module.getKey().str();\n-      module_name_callback(callback_payload,\n-                           importing_module_id.c_str(),\n-                           imported_module_id.c_str());\n+/// Converts the LLVMRustThinLTOData::ImportLists map into a nested list. The\n+/// first level is a null-terminated array with an entry for each module. Each\n+/// entry is a pointer that points to a null-termined array of module names. The\n+/// first entry is always the name of the *importing* module, the following\n+/// entries are  the names of the modules it imports from. Each module name is\n+/// a regular C string.\n+extern \"C\" LLVMRustThinLTOModuleImports*\n+LLVMRustGetThinLTOModuleImports(const LLVMRustThinLTOData *Data) {\n+  // Allocate number of module +1. This is a null-terminated array.\n+  LLVMRustThinLTOModuleImports* thinLTOModuleImports =\n+    new LLVMRustThinLTOModuleImports[Data->ImportLists.size() + 1];\n+  size_t module_index = 0;\n+\n+  for (const auto & module : Data->ImportLists) {\n+    StringRef module_id = module.getKey();\n+    const auto& imports = module.getValue();\n+\n+    // Allocate number of imported module + 2, one extra for the name of the\n+    // importing module and another one for null-termination.\n+    LLVMRustThinLTOModuleImports imports_array =\n+      new LLVMRustThinLTOModuleName[imports.size() + 2];\n+\n+    // The first value is always the name of the *importing* module.\n+    imports_array[0] = strndup(module_id.data(), module_id.size());\n+\n+    size_t imports_array_index = 1;\n+    for (const auto imported_module_id : imports.keys()) {\n+      // The following values are the names of the imported modules.\n+      imports_array[imports_array_index] = strndup(imported_module_id.data(),\n+                                                   imported_module_id.size());\n+      imports_array_index += 1;\n     }\n+\n+    assert(imports_array_index == imports.size() + 1);\n+    imports_array[imports_array_index] = nullptr;\n+\n+    thinLTOModuleImports[module_index] = imports_array;\n+    module_index += 1;\n   }\n+\n+  assert(module_index == Data->ImportLists.size());\n+  thinLTOModuleImports[module_index] = nullptr;\n+\n+  return thinLTOModuleImports;\n }\n \n // This struct and various functions are sort of a hack right now, but the"}]}