{"sha": "d55deaeb217aeec7c1a5af859d389d926b08f80a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ1NWRlYWViMjE3YWVlYzdjMWE1YWY4NTlkMzg5ZDkyNmIwOGY4MGE=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2014-04-14T19:34:42Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2014-04-22T16:06:53Z"}, "message": "rustc: de-@ borrowck.", "tree": {"sha": "ed045ae08caa3cd2ec1157dee084b9036df8879d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ed045ae08caa3cd2ec1157dee084b9036df8879d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d55deaeb217aeec7c1a5af859d389d926b08f80a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d55deaeb217aeec7c1a5af859d389d926b08f80a", "html_url": "https://github.com/rust-lang/rust/commit/d55deaeb217aeec7c1a5af859d389d926b08f80a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d55deaeb217aeec7c1a5af859d389d926b08f80a/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3683f16e9e88947ac58d5dd95fa2254a05d5bc88", "url": "https://api.github.com/repos/rust-lang/rust/commits/3683f16e9e88947ac58d5dd95fa2254a05d5bc88", "html_url": "https://github.com/rust-lang/rust/commit/3683f16e9e88947ac58d5dd95fa2254a05d5bc88"}], "stats": {"total": 297, "additions": 137, "deletions": 160}, "files": [{"sha": "13849512ba6e4e2b30b71a91268fc35a9b8e9f1e", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 52, "deletions": 51, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/d55deaeb217aeec7c1a5af859d389d926b08f80a/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d55deaeb217aeec7c1a5af859d389d926b08f80a/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=d55deaeb217aeec7c1a5af859d389d926b08f80a", "patch": "@@ -30,6 +30,8 @@ use syntax::visit::Visitor;\n use syntax::visit;\n use util::ppaux::Repr;\n \n+use std::rc::Rc;\n+\n struct CheckLoanCtxt<'a> {\n     bccx: &'a BorrowckCtxt<'a>,\n     dfcx_loans: &'a LoanDataFlow<'a>,\n@@ -82,7 +84,7 @@ pub fn check_loans(bccx: &BorrowckCtxt,\n #[deriving(Eq)]\n enum MoveError {\n     MoveOk,\n-    MoveWhileBorrowed(/*loan*/@LoanPath, /*loan*/Span)\n+    MoveWhileBorrowed(/*loan*/Rc<LoanPath>, /*loan*/Span)\n }\n \n impl<'a> CheckLoanCtxt<'a> {\n@@ -121,7 +123,7 @@ impl<'a> CheckLoanCtxt<'a> {\n \n     pub fn each_in_scope_restriction(&self,\n                                      scope_id: ast::NodeId,\n-                                     loan_path: @LoanPath,\n+                                     loan_path: &LoanPath,\n                                      op: |&Loan, &Restriction| -> bool)\n                                      -> bool {\n         //! Iterates through all the in-scope restrictions for the\n@@ -133,7 +135,7 @@ impl<'a> CheckLoanCtxt<'a> {\n \n             let mut ret = true;\n             for restr in loan.restrictions.iter() {\n-                if restr.loan_path == loan_path {\n+                if *restr.loan_path == *loan_path {\n                     if !op(loan, restr) {\n                         ret = false;\n                         break;\n@@ -243,7 +245,7 @@ impl<'a> CheckLoanCtxt<'a> {\n                 \"it\".to_owned()\n             } else {\n                 format!(\"`{}`\",\n-                        self.bccx.loan_path_to_str(old_loan.loan_path))\n+                        self.bccx.loan_path_to_str(&*old_loan.loan_path))\n             };\n \n             match (new_loan.kind, old_loan.kind) {\n@@ -252,15 +254,15 @@ impl<'a> CheckLoanCtxt<'a> {\n                         new_loan.span,\n                         format!(\"cannot borrow `{}` as mutable \\\n                                 more than once at a time\",\n-                                self.bccx.loan_path_to_str(new_loan.loan_path)));\n+                                self.bccx.loan_path_to_str(&*new_loan.loan_path)));\n                 }\n \n                 (ty::UniqueImmBorrow, _) => {\n                     self.bccx.span_err(\n                         new_loan.span,\n                         format!(\"closure requires unique access to `{}` \\\n                                 but {} is already borrowed\",\n-                                self.bccx.loan_path_to_str(new_loan.loan_path),\n+                                self.bccx.loan_path_to_str(&*new_loan.loan_path),\n                                 old_pronoun));\n                 }\n \n@@ -269,7 +271,7 @@ impl<'a> CheckLoanCtxt<'a> {\n                         new_loan.span,\n                         format!(\"cannot borrow `{}` as {} because \\\n                                 previous closure requires unique access\",\n-                                self.bccx.loan_path_to_str(new_loan.loan_path),\n+                                self.bccx.loan_path_to_str(&*new_loan.loan_path),\n                                 new_loan.kind.to_user_str()));\n                 }\n \n@@ -278,7 +280,7 @@ impl<'a> CheckLoanCtxt<'a> {\n                         new_loan.span,\n                         format!(\"cannot borrow `{}` as {} because \\\n                                 {} is also borrowed as {}\",\n-                                self.bccx.loan_path_to_str(new_loan.loan_path),\n+                                self.bccx.loan_path_to_str(&*new_loan.loan_path),\n                                 new_loan.kind.to_user_str(),\n                                 old_pronoun,\n                                 old_loan.kind.to_user_str()));\n@@ -290,7 +292,7 @@ impl<'a> CheckLoanCtxt<'a> {\n                     self.bccx.span_note(\n                         span,\n                         format!(\"borrow occurs due to use of `{}` in closure\",\n-                                self.bccx.loan_path_to_str(new_loan.loan_path)));\n+                                self.bccx.loan_path_to_str(&*new_loan.loan_path)));\n                 }\n                 _ => { }\n             }\n@@ -300,34 +302,34 @@ impl<'a> CheckLoanCtxt<'a> {\n                     format!(\"the mutable borrow prevents subsequent \\\n                             moves, borrows, or modification of `{0}` \\\n                             until the borrow ends\",\n-                            self.bccx.loan_path_to_str(old_loan.loan_path))\n+                            self.bccx.loan_path_to_str(&*old_loan.loan_path))\n                 }\n \n                 ty::ImmBorrow => {\n                     format!(\"the immutable borrow prevents subsequent \\\n                             moves or mutable borrows of `{0}` \\\n                             until the borrow ends\",\n-                            self.bccx.loan_path_to_str(old_loan.loan_path))\n+                            self.bccx.loan_path_to_str(&*old_loan.loan_path))\n                 }\n \n                 ty::UniqueImmBorrow => {\n                     format!(\"the unique capture prevents subsequent \\\n                             moves or borrows of `{0}` \\\n                             until the borrow ends\",\n-                            self.bccx.loan_path_to_str(old_loan.loan_path))\n+                            self.bccx.loan_path_to_str(&*old_loan.loan_path))\n                 }\n             };\n \n             let borrow_summary = match old_loan.cause {\n                 ClosureCapture(_) => {\n                     format!(\"previous borrow of `{}` occurs here due to \\\n                             use in closure\",\n-                            self.bccx.loan_path_to_str(old_loan.loan_path))\n+                            self.bccx.loan_path_to_str(&*old_loan.loan_path))\n                 }\n \n                 AddrOf | AutoRef | RefBinding => {\n                     format!(\"previous borrow of `{}` occurs here\",\n-                            self.bccx.loan_path_to_str(old_loan.loan_path))\n+                            self.bccx.loan_path_to_str(&*old_loan.loan_path))\n                 }\n             };\n \n@@ -356,7 +358,7 @@ impl<'a> CheckLoanCtxt<'a> {\n                                   id: ast::NodeId,\n                                   span: Span,\n                                   use_kind: MovedValueUseKind,\n-                                  lp: @LoanPath) {\n+                                  lp: &Rc<LoanPath>) {\n         /*!\n          * Reports an error if `expr` (which should be a path)\n          * is using a moved/uninitialized value\n@@ -368,7 +370,7 @@ impl<'a> CheckLoanCtxt<'a> {\n             self.bccx.report_use_of_moved_value(\n                 span,\n                 use_kind,\n-                lp,\n+                &**lp,\n                 move,\n                 moved_lp);\n             false\n@@ -404,10 +406,10 @@ impl<'a> CheckLoanCtxt<'a> {\n         if self.is_local_variable(cmt) {\n             assert!(cmt.mutbl.is_immutable()); // no \"const\" locals\n             let lp = opt_loan_path(cmt).unwrap();\n-            self.move_data.each_assignment_of(expr.id, lp, |assign| {\n+            self.move_data.each_assignment_of(expr.id, &lp, |assign| {\n                 self.bccx.report_reassigned_immutable_variable(\n                     expr.span,\n-                    lp,\n+                    &*lp,\n                     assign);\n                 false\n             });\n@@ -422,7 +424,7 @@ impl<'a> CheckLoanCtxt<'a> {\n                     format!(\"cannot assign to {} {} `{}`\",\n                             cmt.mutbl.to_user_str(),\n                             self.bccx.cmt_to_str(cmt),\n-                            self.bccx.loan_path_to_str(lp)));\n+                            self.bccx.loan_path_to_str(&*lp)));\n             }\n             None => {\n                 self.bccx.span_err(\n@@ -571,10 +573,10 @@ impl<'a> CheckLoanCtxt<'a> {\n             // owned pointer are borrowed, and hence while `v[*]` is not\n             // restricted from being written, `v` is.\n             let cont = this.each_in_scope_restriction(expr.id,\n-                                                      loan_path,\n+                                                      &*loan_path,\n                                                       |loan, restr| {\n                 if restr.set.intersects(RESTR_MUTATE) {\n-                    this.report_illegal_mutation(expr, loan_path, loan);\n+                    this.report_illegal_mutation(expr, &*loan_path, loan);\n                     false\n                 } else {\n                     true\n@@ -623,17 +625,17 @@ impl<'a> CheckLoanCtxt<'a> {\n             //\n             // Here the restriction that `v` not be mutated would be misapplied\n             // to block the subpath `v[1]`.\n-            let full_loan_path = loan_path;\n+            let full_loan_path = loan_path.clone();\n             let mut loan_path = loan_path;\n             loop {\n-                match *loan_path {\n+                loan_path = match *loan_path {\n                     // Peel back one layer if, for `loan_path` to be\n                     // mutable, `lp_base` must be mutable. This occurs\n                     // with inherited mutability and with `&mut`\n                     // pointers.\n-                    LpExtend(lp_base, mc::McInherited, _) |\n-                    LpExtend(lp_base, _, LpDeref(mc::BorrowedPtr(ty::MutBorrow, _))) => {\n-                        loan_path = lp_base;\n+                    LpExtend(ref lp_base, mc::McInherited, _) |\n+                    LpExtend(ref lp_base, _, LpDeref(mc::BorrowedPtr(ty::MutBorrow, _))) => {\n+                        lp_base.clone()\n                     }\n \n                     // Otherwise stop iterating\n@@ -642,12 +644,12 @@ impl<'a> CheckLoanCtxt<'a> {\n                     LpVar(_) => {\n                         return true;\n                     }\n-                }\n+                };\n \n                 // Check for a non-const loan of `loan_path`\n                 let cont = this.each_in_scope_loan(expr.id, |loan| {\n                     if loan.loan_path == loan_path {\n-                        this.report_illegal_mutation(expr, full_loan_path, loan);\n+                        this.report_illegal_mutation(expr, &*full_loan_path, loan);\n                         false\n                     } else {\n                         true\n@@ -700,7 +702,7 @@ impl<'a> CheckLoanCtxt<'a> {\n                     self.bccx.span_note(\n                         loan_span,\n                         format!(\"borrow of `{}` occurs here\",\n-                                self.bccx.loan_path_to_str(loan_path)));\n+                                self.bccx.loan_path_to_str(&*loan_path)));\n                 }\n             }\n             true\n@@ -712,13 +714,12 @@ impl<'a> CheckLoanCtxt<'a> {\n                                 span: Span) {\n         for cap_var in self.bccx.capture_map.get(&closure_id).iter() {\n             let var_id = ast_util::def_id_of_def(cap_var.def).node;\n-            let var_path = @LpVar(var_id);\n             self.check_if_path_is_moved(closure_id, span,\n-                                        MovedInCapture, var_path);\n+                                        MovedInCapture, &Rc::new(LpVar(var_id)));\n             match cap_var.mode {\n                 moves::CapRef | moves::CapCopy => {}\n                 moves::CapMove => {\n-                    check_by_move_capture(self, closure_id, cap_var, var_path);\n+                    check_by_move_capture(self, closure_id, cap_var, &LpVar(var_id));\n                 }\n             }\n         }\n@@ -727,7 +728,7 @@ impl<'a> CheckLoanCtxt<'a> {\n         fn check_by_move_capture(this: &CheckLoanCtxt,\n                                  closure_id: ast::NodeId,\n                                  cap_var: &moves::CaptureVar,\n-                                 move_path: @LoanPath) {\n+                                 move_path: &LoanPath) {\n             let move_err = this.analyze_move_out_from(closure_id, move_path);\n             match move_err {\n                 MoveOk => {}\n@@ -740,38 +741,39 @@ impl<'a> CheckLoanCtxt<'a> {\n                     this.bccx.span_note(\n                         loan_span,\n                         format!(\"borrow of `{}` occurs here\",\n-                                this.bccx.loan_path_to_str(loan_path)));\n+                                this.bccx.loan_path_to_str(&*loan_path)));\n                 }\n             }\n         }\n     }\n \n     pub fn analyze_move_out_from(&self,\n                                  expr_id: ast::NodeId,\n-                                 mut move_path: @LoanPath)\n+                                 move_path: &LoanPath)\n                                  -> MoveError {\n         debug!(\"analyze_move_out_from(expr_id={:?}, move_path={})\",\n                self.tcx().map.node_to_str(expr_id),\n                move_path.repr(self.tcx()));\n \n         // We must check every element of a move path. See\n         // `borrowck-move-subcomponent.rs` for a test case.\n-        loop {\n-            // check for a conflicting loan:\n-            let mut ret = MoveOk;\n-            self.each_in_scope_restriction(expr_id, move_path, |loan, _| {\n-                // Any restriction prevents moves.\n-                ret = MoveWhileBorrowed(loan.loan_path, loan.span);\n-                false\n-            });\n \n-            if ret != MoveOk {\n-                return ret\n-            }\n+        // check for a conflicting loan:\n+        let mut ret = MoveOk;\n+        self.each_in_scope_restriction(expr_id, move_path, |loan, _| {\n+            // Any restriction prevents moves.\n+            ret = MoveWhileBorrowed(loan.loan_path.clone(), loan.span);\n+            false\n+        });\n+\n+        if ret != MoveOk {\n+            return ret\n+        }\n \n-            match *move_path {\n-                LpVar(_) => return MoveOk,\n-                LpExtend(subpath, _, _) => move_path = subpath,\n+        match *move_path {\n+            LpVar(_) => MoveOk,\n+            LpExtend(ref subpath, _, _) => {\n+                self.analyze_move_out_from(expr_id, &**subpath)\n             }\n         }\n     }\n@@ -812,8 +814,7 @@ fn check_loans_in_expr<'a>(this: &mut CheckLoanCtxt<'a>,\n           if !this.move_data.is_assignee(expr.id) {\n               let cmt = this.bccx.cat_expr_unadjusted(expr);\n               debug!(\"path cmt={}\", cmt.repr(this.tcx()));\n-              let r = opt_loan_path(cmt);\n-              for &lp in r.iter() {\n+              for lp in opt_loan_path(cmt).iter() {\n                   this.check_if_path_is_moved(expr.id, expr.span, MovedInUse, lp);\n               }\n           }"}, {"sha": "b44db1f3fc9aa0c0c0360df257603e615dfe209c", "filename": "src/librustc/middle/borrowck/gather_loans/gather_moves.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d55deaeb217aeec7c1a5af859d389d926b08f80a/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d55deaeb217aeec7c1a5af859d389d926b08f80a/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fgather_moves.rs?ref=d55deaeb217aeec7c1a5af859d389d926b08f80a", "patch": "@@ -30,12 +30,14 @@ struct GatherMoveInfo {\n     span_path_opt: Option<MoveSpanAndPath>\n }\n \n+use std::rc::Rc;\n+\n pub fn gather_decl(bccx: &BorrowckCtxt,\n                    move_data: &MoveData,\n                    decl_id: ast::NodeId,\n                    _decl_span: Span,\n                    var_id: ast::NodeId) {\n-    let loan_path = @LpVar(var_id);\n+    let loan_path = Rc::new(LpVar(var_id));\n     move_data.add_move(bccx.tcx, loan_path, decl_id, Declared);\n }\n \n@@ -131,7 +133,7 @@ pub fn gather_assignment(bccx: &BorrowckCtxt,\n                          move_data: &MoveData,\n                          assignment_id: ast::NodeId,\n                          assignment_span: Span,\n-                         assignee_loan_path: @LoanPath,\n+                         assignee_loan_path: Rc<LoanPath>,\n                          assignee_id: ast::NodeId) {\n     move_data.add_assignment(bccx.tcx,\n                              assignee_loan_path,\n@@ -145,7 +147,7 @@ pub fn gather_move_and_assignment(bccx: &BorrowckCtxt,\n                                   move_data: &MoveData,\n                                   assignment_id: ast::NodeId,\n                                   assignment_span: Span,\n-                                  assignee_loan_path: @LoanPath,\n+                                  assignee_loan_path: Rc<LoanPath>,\n                                   assignee_id: ast::NodeId) {\n     move_data.add_assignment(bccx.tcx,\n                              assignee_loan_path,"}, {"sha": "106c2a5ee525a79389409a3ef399cd1ad8c3dd5d", "filename": "src/librustc/middle/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d55deaeb217aeec7c1a5af859d389d926b08f80a/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d55deaeb217aeec7c1a5af859d389d926b08f80a/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=d55deaeb217aeec7c1a5af859d389d926b08f80a", "patch": "@@ -36,6 +36,8 @@ use syntax::visit;\n use syntax::visit::{Visitor, FnKind};\n use syntax::ast::{Expr, FnDecl, Block, NodeId, Stmt, Pat, Local};\n \n+use std::rc::Rc;\n+\n mod lifetime;\n mod restrictions;\n mod gather_moves;\n@@ -296,7 +298,7 @@ fn gather_loans_in_expr(this: &mut GatherLoanCtxt,\n     }\n }\n \n-fn with_assignee_loan_path(bccx: &BorrowckCtxt, expr: &ast::Expr, op: |@LoanPath|) {\n+fn with_assignee_loan_path(bccx: &BorrowckCtxt, expr: &ast::Expr, op: |Rc<LoanPath>|) {\n     let cmt = bccx.cat_expr(expr);\n     match opt_loan_path(cmt) {\n         Some(lp) => op(lp),\n@@ -611,11 +613,11 @@ impl<'a> GatherLoanCtxt<'a> {\n                 let gen_scope = self.compute_gen_scope(borrow_id, loan_scope);\n                 debug!(\"gen_scope = {:?}\", gen_scope);\n \n-                let kill_scope = self.compute_kill_scope(loan_scope, loan_path);\n+                let kill_scope = self.compute_kill_scope(loan_scope, &*loan_path);\n                 debug!(\"kill_scope = {:?}\", kill_scope);\n \n                 if req_kind == ty::MutBorrow {\n-                    self.mark_loan_path_as_mutated(loan_path);\n+                    self.mark_loan_path_as_mutated(&*loan_path);\n                 }\n \n                 Loan {\n@@ -717,16 +719,16 @@ impl<'a> GatherLoanCtxt<'a> {\n         }\n     }\n \n-    pub fn mark_loan_path_as_mutated(&self, loan_path: @LoanPath) {\n+    pub fn mark_loan_path_as_mutated(&self, loan_path: &LoanPath) {\n         //! For mutable loans of content whose mutability derives\n         //! from a local variable, mark the mutability decl as necessary.\n \n         match *loan_path {\n             LpVar(local_id) => {\n                 self.tcx().used_mut_nodes.borrow_mut().insert(local_id);\n             }\n-            LpExtend(base, mc::McInherited, _) => {\n-                self.mark_loan_path_as_mutated(base);\n+            LpExtend(ref base, mc::McInherited, _) => {\n+                self.mark_loan_path_as_mutated(&**base);\n             }\n             LpExtend(_, mc::McDeclared, _) |\n             LpExtend(_, mc::McImmutable, _) => {\n@@ -751,7 +753,7 @@ impl<'a> GatherLoanCtxt<'a> {\n         }\n     }\n \n-    pub fn compute_kill_scope(&self, loan_scope: ast::NodeId, lp: @LoanPath)\n+    pub fn compute_kill_scope(&self, loan_scope: ast::NodeId, lp: &LoanPath)\n                               -> ast::NodeId {\n         //! Determine when the loan restrictions go out of scope.\n         //! This is either when the lifetime expires or when the\n@@ -826,7 +828,7 @@ impl<'a> GatherLoanCtxt<'a> {\n                                                     &self.move_data,\n                                                     id,\n                                                     span,\n-                                                    @LpVar(id),\n+                                                    Rc::new(LpVar(id)),\n                                                     id);\n                 });\n "}, {"sha": "c4e1b0bf27f35f04d2f5081aaccd70f34e754544", "filename": "src/librustc/middle/borrowck/gather_loans/restrictions.rs", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d55deaeb217aeec7c1a5af859d389d926b08f80a/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d55deaeb217aeec7c1a5af859d389d926b08f80a/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs?ref=d55deaeb217aeec7c1a5af859d389d926b08f80a", "patch": "@@ -18,9 +18,11 @@ use middle::ty;\n use syntax::codemap::Span;\n use util::ppaux::Repr;\n \n+use std::rc::Rc;\n+\n pub enum RestrictionResult {\n     Safe,\n-    SafeIf(@LoanPath, Vec<Restriction> )\n+    SafeIf(Rc<LoanPath>, Vec<Restriction>)\n }\n \n pub fn compute_restrictions(bccx: &BorrowckCtxt,\n@@ -73,9 +75,11 @@ impl<'a> RestrictionsContext<'a> {\n             mc::cat_arg(local_id) |\n             mc::cat_upvar(ty::UpvarId {var_id: local_id, ..}, _) => {\n                 // R-Variable\n-                let lp = @LpVar(local_id);\n-                SafeIf(lp, vec!(Restriction {loan_path: lp,\n-                                          set: restrictions}))\n+                let lp = Rc::new(LpVar(local_id));\n+                SafeIf(lp.clone(), vec!(Restriction {\n+                    loan_path: lp,\n+                    set: restrictions\n+                }))\n             }\n \n             mc::cat_downcast(cmt_base) => {\n@@ -170,9 +174,13 @@ impl<'a> RestrictionsContext<'a> {\n               restrictions: RestrictionSet) -> RestrictionResult {\n         match result {\n             Safe => Safe,\n-            SafeIf(base_lp, base_vec) => {\n-                let lp = @LpExtend(base_lp, mc, elem);\n-                SafeIf(lp, base_vec.append_one(Restriction { loan_path: lp, set: restrictions }))\n+            SafeIf(base_lp, mut base_vec) => {\n+                let lp = Rc::new(LpExtend(base_lp, mc, elem));\n+                base_vec.push(Restriction {\n+                    loan_path: lp.clone(),\n+                    set: restrictions\n+                });\n+                SafeIf(lp, base_vec)\n             }\n         }\n     }"}, {"sha": "ba01e4aa4189c11f84f546f228e7c71456fec345", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 28, "deletions": 62, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/d55deaeb217aeec7c1a5af859d389d926b08f80a/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d55deaeb217aeec7c1a5af859d389d926b08f80a/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=d55deaeb217aeec7c1a5af859d389d926b08f80a", "patch": "@@ -21,11 +21,11 @@ use middle::dataflow::DataFlowOperator;\n use util::nodemap::{NodeMap, NodeSet};\n use util::ppaux::{note_and_explain_region, Repr, UserString};\n \n-use std::cell::{Cell, RefCell};\n-use collections::HashMap;\n+use std::cell::RefCell;\n use std::ops::{BitOr, BitAnd};\n-use std::result::Result;\n+use std::rc::Rc;\n use std::strbuf::StrBuf;\n+use collections::HashMap;\n use syntax::ast;\n use syntax::ast_map;\n use syntax::ast_util;\n@@ -86,36 +86,12 @@ pub fn check_crate(tcx: &ty::ctxt,\n         moves_map: moves_map,\n         moved_variables_set: moved_variables_set,\n         capture_map: capture_map,\n-        root_map: RefCell::new(HashMap::new()),\n-        stats: @BorrowStats {\n-            loaned_paths_same: Cell::new(0),\n-            loaned_paths_imm: Cell::new(0),\n-            stable_paths: Cell::new(0),\n-            guaranteed_paths: Cell::new(0),\n-        }\n+        root_map: RefCell::new(HashMap::new())\n     };\n \n     visit::walk_crate(&mut bccx, krate, ());\n \n-    if tcx.sess.borrowck_stats() {\n-        println!(\"--- borrowck stats ---\");\n-        println!(\"paths requiring guarantees: {}\",\n-                 bccx.stats.guaranteed_paths.get());\n-        println!(\"paths requiring loans     : {}\",\n-                 make_stat(&bccx, bccx.stats.loaned_paths_same.get()));\n-        println!(\"paths requiring imm loans : {}\",\n-                 make_stat(&bccx, bccx.stats.loaned_paths_imm.get()));\n-        println!(\"stable paths              : {}\",\n-                 make_stat(&bccx, bccx.stats.stable_paths.get()));\n-    }\n-\n     return bccx.root_map.unwrap();\n-\n-    fn make_stat(bccx: &BorrowckCtxt, stat: uint) -> ~str {\n-        let stat_f = stat as f64;\n-        let total = bccx.stats.guaranteed_paths.get() as f64;\n-        format!(\"{} ({:.0f}%)\", stat, stat_f * 100.0 / total)\n-    }\n }\n \n fn borrowck_item(this: &mut BorrowckCtxt, item: &ast::Item) {\n@@ -175,16 +151,6 @@ pub struct BorrowckCtxt<'a> {\n     moved_variables_set: &'a NodeSet,\n     capture_map: &'a moves::CaptureMap,\n     root_map: RefCell<root_map>,\n-\n-    // Statistics:\n-    stats: @BorrowStats\n-}\n-\n-pub struct BorrowStats {\n-    loaned_paths_same: Cell<uint>,\n-    loaned_paths_imm: Cell<uint>,\n-    stable_paths: Cell<uint>,\n-    guaranteed_paths: Cell<uint>,\n }\n \n // The keys to the root map combine the `id` of the deref expression\n@@ -220,10 +186,10 @@ pub enum PartialTotal {\n /// Record of a loan that was issued.\n pub struct Loan {\n     index: uint,\n-    loan_path: @LoanPath,\n+    loan_path: Rc<LoanPath>,\n     cmt: mc::cmt,\n     kind: ty::BorrowKind,\n-    restrictions: Vec<Restriction> ,\n+    restrictions: Vec<Restriction>,\n     gen_scope: ast::NodeId,\n     kill_scope: ast::NodeId,\n     span: Span,\n@@ -241,7 +207,7 @@ pub enum LoanCause {\n #[deriving(Eq, TotalEq, Hash)]\n pub enum LoanPath {\n     LpVar(ast::NodeId),               // `x` in doc.rs\n-    LpExtend(@LoanPath, mc::MutabilityCategory, LoanPathElem)\n+    LpExtend(Rc<LoanPath>, mc::MutabilityCategory, LoanPathElem)\n }\n \n #[deriving(Eq, TotalEq, Hash)]\n@@ -254,12 +220,12 @@ impl LoanPath {\n     pub fn node_id(&self) -> ast::NodeId {\n         match *self {\n             LpVar(local_id) => local_id,\n-            LpExtend(base, _, _) => base.node_id()\n+            LpExtend(ref base, _, _) => base.node_id()\n         }\n     }\n }\n \n-pub fn opt_loan_path(cmt: mc::cmt) -> Option<@LoanPath> {\n+pub fn opt_loan_path(cmt: mc::cmt) -> Option<Rc<LoanPath>> {\n     //! Computes the `LoanPath` (if any) for a `cmt`.\n     //! Note that this logic is somewhat duplicated in\n     //! the method `compute()` found in `gather_loans::restrictions`,\n@@ -277,18 +243,18 @@ pub fn opt_loan_path(cmt: mc::cmt) -> Option<@LoanPath> {\n         mc::cat_arg(id) |\n         mc::cat_copied_upvar(mc::CopiedUpvar { upvar_id: id, .. }) |\n         mc::cat_upvar(ty::UpvarId {var_id: id, ..}, _) => {\n-            Some(@LpVar(id))\n+            Some(Rc::new(LpVar(id)))\n         }\n \n         mc::cat_deref(cmt_base, _, pk) => {\n             opt_loan_path(cmt_base).map(|lp| {\n-                @LpExtend(lp, cmt.mutbl, LpDeref(pk))\n+                Rc::new(LpExtend(lp, cmt.mutbl, LpDeref(pk)))\n             })\n         }\n \n         mc::cat_interior(cmt_base, ik) => {\n             opt_loan_path(cmt_base).map(|lp| {\n-                @LpExtend(lp, cmt.mutbl, LpInterior(ik))\n+                Rc::new(LpExtend(lp, cmt.mutbl, LpInterior(ik)))\n             })\n         }\n \n@@ -313,7 +279,7 @@ pub fn opt_loan_path(cmt: mc::cmt) -> Option<@LoanPath> {\n // because the restriction against moves is implied.\n \n pub struct Restriction {\n-    loan_path: @LoanPath,\n+    loan_path: Rc<LoanPath>,\n     set: RestrictionSet\n }\n \n@@ -528,7 +494,7 @@ impl<'a> BorrowckCtxt<'a> {\n                                      use_kind: MovedValueUseKind,\n                                      lp: &LoanPath,\n                                      move: &move_data::Move,\n-                                     moved_lp: @LoanPath) {\n+                                     moved_lp: &LoanPath) {\n         let verb = match use_kind {\n             MovedInUse => \"use\",\n             MovedInCapture => \"capture\",\n@@ -651,7 +617,7 @@ impl<'a> BorrowckCtxt<'a> {\n                     Some(lp) => format!(\"{} {} `{}`\",\n                                         err.cmt.mutbl.to_user_str(),\n                                         self.cmt_to_str(err.cmt),\n-                                        self.loan_path_to_str(lp)),\n+                                        self.loan_path_to_str(&*lp)),\n                 };\n \n                 match err.cause {\n@@ -669,13 +635,13 @@ impl<'a> BorrowckCtxt<'a> {\n             err_out_of_scope(..) => {\n                 let msg = match opt_loan_path(err.cmt) {\n                     None => format!(\"borrowed value\"),\n-                    Some(lp) => format!(\"`{}`\", self.loan_path_to_str(lp)),\n+                    Some(lp) => format!(\"`{}`\", self.loan_path_to_str(&*lp)),\n                 };\n                 format!(\"{} does not live long enough\", msg)\n             }\n             err_borrowed_pointer_too_short(..) => {\n                 let descr = match opt_loan_path(err.cmt) {\n-                    Some(lp) => format!(\"`{}`\", self.loan_path_to_str(lp)),\n+                    Some(lp) => format!(\"`{}`\", self.loan_path_to_str(&*lp)),\n                     None => self.cmt_to_str(err.cmt),\n                 };\n \n@@ -769,7 +735,7 @@ impl<'a> BorrowckCtxt<'a> {\n \n             err_borrowed_pointer_too_short(loan_scope, ptr_scope, _) => {\n                 let descr = match opt_loan_path(err.cmt) {\n-                    Some(lp) => format!(\"`{}`\", self.loan_path_to_str(lp)),\n+                    Some(lp) => format!(\"`{}`\", self.loan_path_to_str(&*lp)),\n                     None => self.cmt_to_str(err.cmt),\n                 };\n                 note_and_explain_region(\n@@ -794,8 +760,8 @@ impl<'a> BorrowckCtxt<'a> {\n                 out.push_str(ty::local_var_name_str(self.tcx, id).get());\n             }\n \n-            LpExtend(lp_base, _, LpInterior(mc::InteriorField(fname))) => {\n-                self.append_autoderefd_loan_path_to_str(lp_base, out);\n+            LpExtend(ref lp_base, _, LpInterior(mc::InteriorField(fname))) => {\n+                self.append_autoderefd_loan_path_to_str(&**lp_base, out);\n                 match fname {\n                     mc::NamedField(fname) => {\n                         out.push_char('.');\n@@ -808,14 +774,14 @@ impl<'a> BorrowckCtxt<'a> {\n                 }\n             }\n \n-            LpExtend(lp_base, _, LpInterior(mc::InteriorElement(_))) => {\n-                self.append_autoderefd_loan_path_to_str(lp_base, out);\n+            LpExtend(ref lp_base, _, LpInterior(mc::InteriorElement(_))) => {\n+                self.append_autoderefd_loan_path_to_str(&**lp_base, out);\n                 out.push_str(\"[..]\");\n             }\n \n-            LpExtend(lp_base, _, LpDeref(_)) => {\n+            LpExtend(ref lp_base, _, LpDeref(_)) => {\n                 out.push_char('*');\n-                self.append_loan_path_to_str(lp_base, out);\n+                self.append_loan_path_to_str(&**lp_base, out);\n             }\n         }\n     }\n@@ -824,11 +790,11 @@ impl<'a> BorrowckCtxt<'a> {\n                                               loan_path: &LoanPath,\n                                               out: &mut StrBuf) {\n         match *loan_path {\n-            LpExtend(lp_base, _, LpDeref(_)) => {\n+            LpExtend(ref lp_base, _, LpDeref(_)) => {\n                 // For a path like `(*x).f` or `(*x)[3]`, autoderef\n                 // rules would normally allow users to omit the `*x`.\n                 // So just serialize such paths to `x.f` or x[3]` respectively.\n-                self.append_autoderefd_loan_path_to_str(lp_base, out)\n+                self.append_autoderefd_loan_path_to_str(&**lp_base, out)\n             }\n \n             LpVar(..) | LpExtend(_, _, LpInterior(..)) => {\n@@ -887,11 +853,11 @@ impl Repr for LoanPath {\n                 format!(\"$({})\", tcx.map.node_to_str(id))\n             }\n \n-            &LpExtend(lp, _, LpDeref(_)) => {\n+            &LpExtend(ref lp, _, LpDeref(_)) => {\n                 format!(\"{}.*\", lp.repr(tcx))\n             }\n \n-            &LpExtend(lp, _, LpInterior(ref interior)) => {\n+            &LpExtend(ref lp, _, LpInterior(ref interior)) => {\n                 format!(\"{}.{}\", lp.repr(tcx), interior.repr(tcx))\n             }\n         }"}, {"sha": "efdc103d14d1e0f40e0e7e7373e01a84973248e4", "filename": "src/librustc/middle/borrowck/move_data.rs", "status": "modified", "additions": 27, "deletions": 29, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/d55deaeb217aeec7c1a5af859d389d926b08f80a/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d55deaeb217aeec7c1a5af859d389d926b08f80a/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs?ref=d55deaeb217aeec7c1a5af859d389d926b08f80a", "patch": "@@ -16,6 +16,7 @@ comments in the section \"Moves and initialization\" and in `doc.rs`.\n */\n \n use std::cell::RefCell;\n+use std::rc::Rc;\n use std::uint;\n use collections::{HashMap, HashSet};\n use middle::borrowck::*;\n@@ -32,7 +33,7 @@ pub struct MoveData {\n     pub paths: RefCell<Vec<MovePath>>,\n \n     /// Cache of loan path to move path index, for easy lookup.\n-    pub path_map: RefCell<HashMap<@LoanPath, MovePathIndex>>,\n+    pub path_map: RefCell<HashMap<Rc<LoanPath>, MovePathIndex>>,\n \n     /// Each move or uninitialized variable gets an entry here.\n     pub moves: RefCell<Vec<Move>>,\n@@ -96,7 +97,7 @@ static InvalidMoveIndex: MoveIndex =\n \n pub struct MovePath {\n     /// Loan path corresponding to this move path\n-    pub loan_path: @LoanPath,\n+    pub loan_path: Rc<LoanPath>,\n \n     /// Parent pointer, `InvalidMovePathIndex` if root\n     pub parent: MovePathIndex,\n@@ -181,8 +182,8 @@ impl MoveData {\n         }\n     }\n \n-    fn path_loan_path(&self, index: MovePathIndex) -> @LoanPath {\n-        self.paths.borrow().get(index.get()).loan_path\n+    fn path_loan_path(&self, index: MovePathIndex) -> Rc<LoanPath> {\n+        self.paths.borrow().get(index.get()).loan_path.clone()\n     }\n \n     fn path_parent(&self, index: MovePathIndex) -> MovePathIndex {\n@@ -225,7 +226,7 @@ impl MoveData {\n \n     pub fn move_path(&self,\n                      tcx: &ty::ctxt,\n-                     lp: @LoanPath) -> MovePathIndex {\n+                     lp: Rc<LoanPath>) -> MovePathIndex {\n         /*!\n          * Returns the existing move path index for `lp`, if any,\n          * and otherwise adds a new index for `lp` and any of its\n@@ -244,7 +245,7 @@ impl MoveData {\n                 let index = MovePathIndex(self.paths.borrow().len());\n \n                 self.paths.borrow_mut().push(MovePath {\n-                    loan_path: lp,\n+                    loan_path: lp.clone(),\n                     parent: InvalidMovePathIndex,\n                     first_move: InvalidMoveIndex,\n                     first_child: InvalidMovePathIndex,\n@@ -254,16 +255,16 @@ impl MoveData {\n                 index\n             }\n \n-            LpExtend(base, _, _) => {\n-                let parent_index = self.move_path(tcx, base);\n+            LpExtend(ref base, _, _) => {\n+                let parent_index = self.move_path(tcx, base.clone());\n \n                 let index = MovePathIndex(self.paths.borrow().len());\n \n                 let next_sibling = self.path_first_child(parent_index);\n                 self.set_path_first_child(parent_index, index);\n \n                 self.paths.borrow_mut().push(MovePath {\n-                    loan_path: lp,\n+                    loan_path: lp.clone(),\n                     parent: parent_index,\n                     first_move: InvalidMoveIndex,\n                     first_child: InvalidMovePathIndex,\n@@ -283,39 +284,36 @@ impl MoveData {\n         return index;\n     }\n \n-    fn existing_move_path(&self,\n-                          lp: @LoanPath)\n+    fn existing_move_path(&self, lp: &Rc<LoanPath>)\n                           -> Option<MovePathIndex> {\n-        self.path_map.borrow().find_copy(&lp)\n+        self.path_map.borrow().find_copy(lp)\n     }\n \n-    fn existing_base_paths(&self,\n-                           lp: @LoanPath)\n+    fn existing_base_paths(&self, lp: &Rc<LoanPath>)\n                            -> Vec<MovePathIndex> {\n         let mut result = vec!();\n         self.add_existing_base_paths(lp, &mut result);\n         result\n     }\n \n-    fn add_existing_base_paths(&self,\n-                               lp: @LoanPath,\n+    fn add_existing_base_paths(&self, lp: &Rc<LoanPath>,\n                                result: &mut Vec<MovePathIndex>) {\n         /*!\n          * Adds any existing move path indices for `lp` and any base\n          * paths of `lp` to `result`, but does not add new move paths\n          */\n \n-        match self.path_map.borrow().find_copy(&lp) {\n+        match self.path_map.borrow().find_copy(lp) {\n             Some(index) => {\n                 self.each_base_path(index, |p| {\n                     result.push(p);\n                     true\n                 });\n             }\n             None => {\n-                match *lp {\n+                match **lp {\n                     LpVar(..) => { }\n-                    LpExtend(b, _, _) => {\n+                    LpExtend(ref b, _, _) => {\n                         self.add_existing_base_paths(b, result);\n                     }\n                 }\n@@ -326,7 +324,7 @@ impl MoveData {\n \n     pub fn add_move(&self,\n                     tcx: &ty::ctxt,\n-                    lp: @LoanPath,\n+                    lp: Rc<LoanPath>,\n                     id: ast::NodeId,\n                     kind: MoveKind) {\n         /*!\n@@ -355,7 +353,7 @@ impl MoveData {\n \n     pub fn add_assignment(&self,\n                           tcx: &ty::ctxt,\n-                          lp: @LoanPath,\n+                          lp: Rc<LoanPath>,\n                           assign_id: ast::NodeId,\n                           span: Span,\n                           assignee_id: ast::NodeId,\n@@ -368,7 +366,7 @@ impl MoveData {\n         debug!(\"add_assignment(lp={}, assign_id={:?}, assignee_id={:?}\",\n                lp.repr(tcx), assign_id, assignee_id);\n \n-        let path_index = self.move_path(tcx, lp);\n+        let path_index = self.move_path(tcx, lp.clone());\n \n         if !is_also_move {\n             self.assignee_ids.borrow_mut().insert(assignee_id);\n@@ -535,7 +533,7 @@ impl<'a> FlowedMoveData<'a> {\n \n     pub fn each_path_moved_by(&self,\n                               id: ast::NodeId,\n-                              f: |&Move, @LoanPath| -> bool)\n+                              f: |&Move, &LoanPath| -> bool)\n                               -> bool {\n         /*!\n          * Iterates through each path moved by `id`\n@@ -545,14 +543,14 @@ impl<'a> FlowedMoveData<'a> {\n             let move = self.move_data.moves.borrow();\n             let move = move.get(index);\n             let moved_path = move.path;\n-            f(move, self.move_data.path_loan_path(moved_path))\n+            f(move, &*self.move_data.path_loan_path(moved_path))\n         })\n     }\n \n     pub fn each_move_of(&self,\n                         id: ast::NodeId,\n-                        loan_path: @LoanPath,\n-                        f: |&Move, @LoanPath| -> bool)\n+                        loan_path: &Rc<LoanPath>,\n+                        f: |&Move, &LoanPath| -> bool)\n                         -> bool {\n         /*!\n          * Iterates through each move of `loan_path` (or some base path\n@@ -587,7 +585,7 @@ impl<'a> FlowedMoveData<'a> {\n             if base_indices.iter().any(|x| x == &moved_path) {\n                 // Scenario 1 or 2: `loan_path` or some base path of\n                 // `loan_path` was moved.\n-                if !f(move, self.move_data.path_loan_path(moved_path)) {\n+                if !f(move, &*self.move_data.path_loan_path(moved_path)) {\n                     ret = false;\n                 }\n             } else {\n@@ -596,7 +594,7 @@ impl<'a> FlowedMoveData<'a> {\n                         if p == loan_path_index {\n                             // Scenario 3: some extension of `loan_path`\n                             // was moved\n-                            f(move, self.move_data.path_loan_path(moved_path))\n+                            f(move, &*self.move_data.path_loan_path(moved_path))\n                         } else {\n                             true\n                         }\n@@ -617,7 +615,7 @@ impl<'a> FlowedMoveData<'a> {\n \n     pub fn each_assignment_of(&self,\n                               id: ast::NodeId,\n-                              loan_path: @LoanPath,\n+                              loan_path: &Rc<LoanPath>,\n                               f: |&Assignment| -> bool)\n                               -> bool {\n         /*!"}]}