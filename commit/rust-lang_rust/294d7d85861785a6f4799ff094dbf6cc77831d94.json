{"sha": "294d7d85861785a6f4799ff094dbf6cc77831d94", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI5NGQ3ZDg1ODYxNzg1YTZmNDc5OWZmMDk0ZGJmNmNjNzc4MzFkOTQ=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-09-24T06:31:18Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-09-24T06:31:18Z"}, "message": "Merge branch 'pr-347'", "tree": {"sha": "8ee779a5ddec25560b5f31d08b7d677053282482", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8ee779a5ddec25560b5f31d08b7d677053282482"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/294d7d85861785a6f4799ff094dbf6cc77831d94", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/294d7d85861785a6f4799ff094dbf6cc77831d94", "html_url": "https://github.com/rust-lang/rust/commit/294d7d85861785a6f4799ff094dbf6cc77831d94", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/294d7d85861785a6f4799ff094dbf6cc77831d94/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4838e8a3b4539ffc7feb9bfa2e2c72b00c55f0b5", "url": "https://api.github.com/repos/rust-lang/rust/commits/4838e8a3b4539ffc7feb9bfa2e2c72b00c55f0b5", "html_url": "https://github.com/rust-lang/rust/commit/4838e8a3b4539ffc7feb9bfa2e2c72b00c55f0b5"}, {"sha": "b2c66d1a0eb77338dc6b421fd18903fca4d8975e", "url": "https://api.github.com/repos/rust-lang/rust/commits/b2c66d1a0eb77338dc6b421fd18903fca4d8975e", "html_url": "https://github.com/rust-lang/rust/commit/b2c66d1a0eb77338dc6b421fd18903fca4d8975e"}], "stats": {"total": 64, "additions": 32, "deletions": 32}, "files": [{"sha": "8a905ffac4233f3b1234ff1f809d3a66d04003bb", "filename": "Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/294d7d85861785a6f4799ff094dbf6cc77831d94/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/294d7d85861785a6f4799ff094dbf6cc77831d94/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=294d7d85861785a6f4799ff094dbf6cc77831d94", "patch": "@@ -1,6 +1,6 @@\n [package]\n name = \"clippy\"\n-version = \"0.0.15\"\n+version = \"0.0.16\"\n authors = [\n \t\"Manish Goregaokar <manishsmail@gmail.com>\",\n \t\"Andre Bogus <bogusandre@gmail.com>\","}, {"sha": "936548c04f8a2421f8b3583bafafa16d2051b607", "filename": "src/attrs.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/294d7d85861785a6f4799ff094dbf6cc77831d94/src%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/294d7d85861785a6f4799ff094dbf6cc77831d94/src%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fattrs.rs?ref=294d7d85861785a6f4799ff094dbf6cc77831d94", "patch": "@@ -24,19 +24,19 @@ impl LintPass for AttrPass {\n impl LateLintPass for AttrPass {\n     fn check_item(&mut self, cx: &LateContext, item: &Item) {\n         if is_relevant_item(item) {\n-            check_attrs(cx, item.span, &item.ident, &item.attrs)\n+            check_attrs(cx, item.span, &item.name, &item.attrs)\n         }\n     }\n \n     fn check_impl_item(&mut self, cx: &LateContext, item: &ImplItem) {\n         if is_relevant_impl(item) {\n-            check_attrs(cx, item.span, &item.ident, &item.attrs)\n+            check_attrs(cx, item.span, &item.name, &item.attrs)\n         }\n     }\n \n     fn check_trait_item(&mut self, cx: &LateContext, item: &TraitItem) {\n         if is_relevant_trait(item) {\n-            check_attrs(cx, item.span, &item.ident, &item.attrs)\n+            check_attrs(cx, item.span, &item.name, &item.attrs)\n         }\n     }\n }\n@@ -88,7 +88,7 @@ fn is_relevant_expr(expr: &Expr) -> bool {\n     }\n }\n \n-fn check_attrs(cx: &LateContext, span: Span, ident: &Ident,\n+fn check_attrs(cx: &LateContext, span: Span, name: &Name,\n         attrs: &[Attribute]) {\n     if in_macro(cx, span) { return; }\n \n@@ -100,7 +100,7 @@ fn check_attrs(cx: &LateContext, span: Span, ident: &Ident,\n                 span_lint(cx, INLINE_ALWAYS, attr.span, &format!(\n                     \"you have declared `#[inline(always)]` on `{}`. This \\\n                      is usually a bad idea. Are you sure?\",\n-                    ident.name));\n+                    name));\n             }\n         }\n     }"}, {"sha": "620c6bfd7b8e40313601399ec4c230b92ebec8b9", "filename": "src/len_zero.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/294d7d85861785a6f4799ff094dbf6cc77831d94/src%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/294d7d85861785a6f4799ff094dbf6cc77831d94/src%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flen_zero.rs?ref=294d7d85861785a6f4799ff094dbf6cc77831d94", "patch": "@@ -1,5 +1,6 @@\n use rustc::lint::*;\n use rustc_front::hir::*;\n+use syntax::ast::Name;\n use syntax::ptr::P;\n use syntax::codemap::{Span, Spanned};\n use rustc::middle::def_id::DefId;\n@@ -51,7 +52,7 @@ impl LateLintPass for LenZero {\n \n fn check_trait_items(cx: &LateContext, item: &Item, trait_items: &[P<TraitItem>]) {\n     fn is_named_self(item: &TraitItem, name: &str) -> bool {\n-        item.ident.name == name && if let MethodTraitItem(ref sig, _) =\n+        item.name == name && if let MethodTraitItem(ref sig, _) =\n             item.node { is_self_sig(sig) } else { false }\n     }\n \n@@ -62,15 +63,15 @@ fn check_trait_items(cx: &LateContext, item: &Item, trait_items: &[P<TraitItem>]\n                 span_lint(cx, LEN_WITHOUT_IS_EMPTY, i.span,\n                           &format!(\"trait `{}` has a `.len(_: &Self)` method, but no \\\n                                     `.is_empty(_: &Self)` method. Consider adding one\",\n-                                   item.ident.name));\n+                                   item.name));\n             }\n         };\n     }\n }\n \n fn check_impl_items(cx: &LateContext, item: &Item, impl_items: &[P<ImplItem>]) {\n     fn is_named_self(item: &ImplItem, name: &str) -> bool {\n-        item.ident.name == name && if let MethodImplItem(ref sig, _) =\n+        item.name == name && if let MethodImplItem(ref sig, _) =\n             item.node { is_self_sig(sig) } else { false }\n     }\n \n@@ -82,7 +83,7 @@ fn check_impl_items(cx: &LateContext, item: &Item, impl_items: &[P<ImplItem>]) {\n                           Span{ lo: s.lo, hi: s.lo, expn_id: s.expn_id },\n                           &format!(\"item `{}` has a `.len(_: &Self)` method, but no \\\n                                     `.is_empty(_: &Self)` method. Consider adding one\",\n-                                   item.ident.name));\n+                                   item.name));\n                 return;\n             }\n         }\n@@ -101,17 +102,17 @@ fn check_cmp(cx: &LateContext, span: Span, left: &Expr, right: &Expr, op: &str)\n     }\n     match (&left.node, &right.node) {\n         (&ExprLit(ref lit), &ExprMethodCall(ref method, _, ref args)) =>\n-            check_len_zero(cx, span, method, args, lit, op),\n+            check_len_zero(cx, span, &method.node, args, lit, op),\n         (&ExprMethodCall(ref method, _, ref args), &ExprLit(ref lit)) =>\n-            check_len_zero(cx, span, method, args, lit, op),\n+            check_len_zero(cx, span, &method.node, args, lit, op),\n         _ => ()\n     }\n }\n \n-fn check_len_zero(cx: &LateContext, span: Span, method: &SpannedIdent,\n+fn check_len_zero(cx: &LateContext, span: Span, name: &Name,\n                   args: &[P<Expr>], lit: &Lit, op: &str) {\n     if let Spanned{node: LitInt(0, _), ..} = *lit {\n-        if method.node.name == \"len\" && args.len() == 1 &&\n+        if name == &\"len\" && args.len() == 1 &&\n             has_is_empty(cx, &args[0]) {\n                 span_lint(cx, LEN_ZERO, span, &format!(\n                     \"consider replacing the len comparison with `{}{}.is_empty()`\","}, {"sha": "4afa31ff5154498d95ae57a242ac898f403f2b56", "filename": "src/loops.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/294d7d85861785a6f4799ff094dbf6cc77831d94/src%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/294d7d85861785a6f4799ff094dbf6cc77831d94/src%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Floops.rs?ref=294d7d85861785a6f4799ff094dbf6cc77831d94", "patch": "@@ -108,7 +108,7 @@ impl LateLintPass for LoopsPass {\n             if let ExprMethodCall(ref method, _, ref args) = arg.node {\n                 // just the receiver, no arguments\n                 if args.len() == 1 {\n-                    let method_name = method.node.name;\n+                    let method_name = method.node;\n                     // check for looping over x.iter() or x.iter_mut(), could use &x or &mut x\n                     if method_name == \"iter\" || method_name == \"iter_mut\" {\n                         if is_ref_iterable_type(cx, &args[0]) {\n@@ -191,7 +191,7 @@ impl LateLintPass for LoopsPass {\n     fn check_stmt(&mut self, cx: &LateContext, stmt: &Stmt) {\n         if let StmtSemi(ref expr, _) = stmt.node {\n             if let ExprMethodCall(ref method, _, ref args) = expr.node {\n-                if args.len() == 1 && method.node.name == \"collect\" &&\n+                if args.len() == 1 && method.node == \"collect\" &&\n                         match_trait_method(cx, expr, &[\"core\", \"iter\", \"Iterator\"]) {\n                     span_lint(cx, UNUSED_COLLECT, expr.span, &format!(\n                         \"you are collect()ing an iterator and throwing away the result. \\"}, {"sha": "946e09858232766070ed95b339c3e59fd544bdcf", "filename": "src/methods.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/294d7d85861785a6f4799ff094dbf6cc77831d94/src%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/294d7d85861785a6f4799ff094dbf6cc77831d94/src%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmethods.rs?ref=294d7d85861785a6f4799ff094dbf6cc77831d94", "patch": "@@ -40,9 +40,9 @@ impl LintPass for MethodsPass {\n \n impl LateLintPass for MethodsPass {\n     fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n-        if let ExprMethodCall(ref ident, _, ref args) = expr.node {\n+        if let ExprMethodCall(ref name, _, ref args) = expr.node {\n             let (obj_ty, ptr_depth) = walk_ptrs_ty_depth(cx.tcx.expr_ty(&args[0]));\n-            if ident.node.name == \"unwrap\" {\n+            if name.node == \"unwrap\" {\n                 if match_type(cx, obj_ty, &OPTION_PATH) {\n                     span_lint(cx, OPTION_UNWRAP_USED, expr.span,\n                               \"used unwrap() on an Option value. If you don't want \\\n@@ -54,7 +54,7 @@ impl LateLintPass for MethodsPass {\n                                of Err values is preferred\");\n                 }\n             }\n-            else if ident.node.name == \"to_string\" {\n+            else if name.node == \"to_string\" {\n                 if obj_ty.sty == ty::TyStr {\n                     let mut arg_str = snippet(cx, args[0].span, \"_\");\n                     if ptr_depth > 1 {\n@@ -76,7 +76,7 @@ impl LateLintPass for MethodsPass {\n     fn check_item(&mut self, cx: &LateContext, item: &Item) {\n         if let ItemImpl(_, _, _, None, ref ty, ref items) = item.node {\n             for implitem in items {\n-                let name = implitem.ident.name;\n+                let name = implitem.name;\n                 if let MethodImplItem(ref sig, _) = implitem.node {\n                     // check missing trait implementations\n                     for &(method_name, n_args, self_kind, out_type, trait_name) in &TRAIT_METHODS {"}, {"sha": "2dd396cb1c5cf80605d79852e4a85f78f0ba102b", "filename": "src/misc.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/294d7d85861785a6f4799ff094dbf6cc77831d94/src%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/294d7d85861785a6f4799ff094dbf6cc77831d94/src%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmisc.rs?ref=294d7d85861785a6f4799ff094dbf6cc77831d94", "patch": "@@ -173,10 +173,9 @@ impl LateLintPass for CmpOwned {\n \n fn check_to_owned(cx: &LateContext, expr: &Expr, other_span: Span) {\n     match expr.node {\n-        ExprMethodCall(Spanned{node: ref ident, ..}, _, ref args) => {\n-            let name = ident.name;\n-            if name == \"to_string\" ||\n-                name == \"to_owned\" && is_str_arg(cx, args) {\n+        ExprMethodCall(Spanned{node: ref name, ..}, _, ref args) => {\n+            if name == &\"to_string\" ||\n+                name == &\"to_owned\" && is_str_arg(cx, args) {\n                     span_lint(cx, CMP_OWNED, expr.span, &format!(\n                         \"this creates an owned instance just for comparison. \\\n                          Consider using `{}.as_slice()` to compare without allocation\","}, {"sha": "94bbb34a421cd39f27a521c9cea52d6b711434d5", "filename": "src/ranges.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/294d7d85861785a6f4799ff094dbf6cc77831d94/src%2Franges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/294d7d85861785a6f4799ff094dbf6cc77831d94/src%2Franges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Franges.rs?ref=294d7d85861785a6f4799ff094dbf6cc77831d94", "patch": "@@ -19,10 +19,10 @@ impl LintPass for StepByZero {\n \n impl LateLintPass for StepByZero {\n     fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n-        if let ExprMethodCall(Spanned { node: ref ident, .. }, _,\n+        if let ExprMethodCall(Spanned { node: ref name, .. }, _,\n                               ref args) = expr.node {\n             // Only warn on literal ranges.\n-            if ident.name == \"step_by\" && args.len() == 2 &&\n+            if name == &\"step_by\" && args.len() == 2 &&\n                 is_range(cx, &args[0]) && is_integer_literal(&args[1], 0) {\n                 cx.span_lint(RANGE_STEP_BY_ZERO, expr.span,\n                              \"Range::step_by(0) produces an infinite iterator. \\"}, {"sha": "25970df399db90859d9f3acc08a5922e7425aa08", "filename": "src/shadow.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/294d7d85861785a6f4799ff094dbf6cc77831d94/src%2Fshadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/294d7d85861785a6f4799ff094dbf6cc77831d94/src%2Fshadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshadow.rs?ref=294d7d85861785a6f4799ff094dbf6cc77831d94", "patch": "@@ -106,9 +106,9 @@ fn check_pat(cx: &LateContext, pat: &Pat, init: &Option<&Expr>, span: Span,\n             if let Some(ref init_struct) = *init {\n                 if let ExprStruct(_, ref efields, _) = init_struct.node {\n                     for field in pfields {\n-                        let ident = field.node.ident;\n+                        let name = field.node.name;\n                         let efield = efields.iter()\n-                            .find(|ref f| f.ident.node == ident)\n+                            .find(|ref f| f.name.node == name)\n                             .map(|f| &*f.expr);\n                         check_pat(cx, &field.node.pat, &efield, span, bindings);\n                     }"}, {"sha": "250e24ac646f17b7b87d8c85821cb9a01fca55e2", "filename": "src/utils.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/294d7d85861785a6f4799ff094dbf6cc77831d94/src%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/294d7d85861785a6f4799ff094dbf6cc77831d94/src%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils.rs?ref=294d7d85861785a6f4799ff094dbf6cc77831d94", "patch": "@@ -105,10 +105,10 @@ pub fn match_path(path: &Path, segments: &[&str]) -> bool {\n pub fn get_item_name(cx: &LateContext, expr: &Expr) -> Option<Name> {\n     let parent_id = cx.tcx.map.get_parent(expr.id);\n     match cx.tcx.map.find(parent_id) {\n-        Some(NodeItem(&Item{ ref ident, .. })) |\n-        Some(NodeTraitItem(&TraitItem{ id: _, ref ident, .. })) |\n-        Some(NodeImplItem(&ImplItem{ id: _, ref ident, .. })) => {\n-            Some(ident.name)\n+        Some(NodeItem(&Item{ ref name, .. })) |\n+        Some(NodeTraitItem(&TraitItem{ id: _, ref name, .. })) |\n+        Some(NodeImplItem(&ImplItem{ id: _, ref name, .. })) => {\n+            Some(*name)\n         },\n         _ => None,\n     }"}]}