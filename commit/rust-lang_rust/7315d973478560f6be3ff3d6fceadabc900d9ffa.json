{"sha": "7315d973478560f6be3ff3d6fceadabc900d9ffa", "node_id": "C_kwDOAAsO6NoAKDczMTVkOTczNDc4NTYwZjZiZTNmZjNkNmZjZWFkYWJjOTAwZDlmZmE", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2022-03-19T19:15:06Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-03-19T19:15:06Z"}, "message": "Merge #11755\n\n11755: feat: Implement lifetime elision hints r=Veykril a=Veykril\n\nWith names on:\r\n![Code_erl26zKvuf](https://user-images.githubusercontent.com/3757771/159134856-e2c75d2d-f17c-45c7-9a78-3da5ee8b1acd.png)\r\nWith names off:\r\n![Code_MRP1Pbfe9d](https://user-images.githubusercontent.com/3757771/159134857-30fac3a1-825e-4f49-ba9b-9fa0bb215694.png)\r\n\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>", "tree": {"sha": "6c0bf3d51efddc99cd51a3680442f71affb511b0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6c0bf3d51efddc99cd51a3680442f71affb511b0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7315d973478560f6be3ff3d6fceadabc900d9ffa", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiNiu6CRBK7hj4Ov3rIwAAABkIAFdkA/YLMNXYpZz/PbKPg1mT\nMC3hxJrbvh9o/1j2kbFiRePrdWG+UUYuym2N5rYE5aeA/+xJpEVV/D0fNgs7MgFv\nZhDZaUh3pwEvQmXUZ8GtzEG62VUGhcG2Kfpn3e4h18GUSqTxo1bbVS1CYYAtm3y7\nFt/f2hU6q8qh6vnqQSi9EIu9CdZhKtvf423kFjuR626jM1akSPNNqWlng4S6TDuf\nLNfYOgynE1kfM+ZDvwJskO7ZsdQLs5X735YqiI8D5g1WE3Nx5IrToBPaFNt3NVjy\ny3vYMvMiKbpiCX3mmzHZZYihrKYm2h9nKkKQCQC+P3wFpXcc4GCDt4+BhBnUv1c=\n=HF1Y\n-----END PGP SIGNATURE-----\n", "payload": "tree 6c0bf3d51efddc99cd51a3680442f71affb511b0\nparent 85311a862747e4d4857dd49493e1ef7b45de8be3\nparent 7da5b80f259a777a43ea4e208def4672cb0fb545\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1647717306 +0000\ncommitter GitHub <noreply@github.com> 1647717306 +0000\n\nMerge #11755\n\n11755: feat: Implement lifetime elision hints r=Veykril a=Veykril\n\nWith names on:\r\n![Code_erl26zKvuf](https://user-images.githubusercontent.com/3757771/159134856-e2c75d2d-f17c-45c7-9a78-3da5ee8b1acd.png)\r\nWith names off:\r\n![Code_MRP1Pbfe9d](https://user-images.githubusercontent.com/3757771/159134857-30fac3a1-825e-4f49-ba9b-9fa0bb215694.png)\r\n\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7315d973478560f6be3ff3d6fceadabc900d9ffa", "html_url": "https://github.com/rust-lang/rust/commit/7315d973478560f6be3ff3d6fceadabc900d9ffa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7315d973478560f6be3ff3d6fceadabc900d9ffa/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "85311a862747e4d4857dd49493e1ef7b45de8be3", "url": "https://api.github.com/repos/rust-lang/rust/commits/85311a862747e4d4857dd49493e1ef7b45de8be3", "html_url": "https://github.com/rust-lang/rust/commit/85311a862747e4d4857dd49493e1ef7b45de8be3"}, {"sha": "7da5b80f259a777a43ea4e208def4672cb0fb545", "url": "https://api.github.com/repos/rust-lang/rust/commits/7da5b80f259a777a43ea4e208def4672cb0fb545", "html_url": "https://github.com/rust-lang/rust/commit/7da5b80f259a777a43ea4e208def4672cb0fb545"}], "stats": {"total": 497, "additions": 432, "deletions": 65}, "files": [{"sha": "13e7a0ac8892f94c9298a4e0976950ff81451f8d", "filename": "crates/ide/src/inlay_hints.rs", "status": "modified", "additions": 336, "deletions": 43, "changes": 379, "blob_url": "https://github.com/rust-lang/rust/blob/7315d973478560f6be3ff3d6fceadabc900d9ffa/crates%2Fide%2Fsrc%2Finlay_hints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7315d973478560f6be3ff3d6fceadabc900d9ffa/crates%2Fide%2Fsrc%2Finlay_hints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Finlay_hints.rs?ref=7315d973478560f6be3ff3d6fceadabc900d9ffa", "patch": "@@ -1,10 +1,13 @@\n use either::Either;\n use hir::{known, Callable, HasVisibility, HirDisplay, Semantics, TypeInfo};\n-use ide_db::{base_db::FileRange, famous_defs::FamousDefs, RootDatabase};\n+use ide_db::{\n+    base_db::FileRange, famous_defs::FamousDefs, syntax_helpers::node_ext::walk_ty, RootDatabase,\n+};\n use itertools::Itertools;\n+use rustc_hash::FxHashMap;\n use stdx::to_lower_snake_case;\n use syntax::{\n-    ast::{self, AstNode, HasArgList, HasName, UnaryOp},\n+    ast::{self, AstNode, HasArgList, HasGenericParams, HasName, UnaryOp},\n     match_ast, Direction, NodeOrToken, SmolStr, SyntaxKind, SyntaxNode, TextRange, T,\n };\n \n@@ -17,16 +20,27 @@ pub struct InlayHintsConfig {\n     pub parameter_hints: bool,\n     pub chaining_hints: bool,\n     pub closure_return_type_hints: bool,\n+    pub lifetime_elision_hints: LifetimeElisionHints,\n+    pub param_names_for_lifetime_elision_hints: bool,\n     pub hide_named_constructor_hints: bool,\n     pub max_length: Option<usize>,\n }\n \n+#[derive(Clone, Debug, PartialEq, Eq)]\n+pub enum LifetimeElisionHints {\n+    Always,\n+    SkipTrivial,\n+    Never,\n+}\n+\n #[derive(Clone, Debug, PartialEq, Eq)]\n pub enum InlayKind {\n     TypeHint,\n     ParameterHint,\n     ClosureReturnTypeHint,\n     ChainingHint,\n+    GenericParamListHint,\n+    LifetimeHint,\n }\n \n #[derive(Debug)]\n@@ -41,12 +55,17 @@ pub struct InlayHint {\n // rust-analyzer shows additional information inline with the source code.\n // Editors usually render this using read-only virtual text snippets interspersed with code.\n //\n-// rust-analyzer shows hints for\n+// rust-analyzer by default shows hints for\n //\n // * types of local variables\n // * names of function arguments\n // * types of chained expressions\n //\n+// Optionally, one can enable additional hints for\n+//\n+// * return types of closure expressions with blocks\n+// * elided lifetimes\n+//\n // **Note:** VS Code does not have native support for inlay hints https://github.com/microsoft/vscode/issues/16221[yet] and the hints are implemented using decorations.\n // This approach has limitations, the caret movement and bracket highlighting near the edges of the hint may be weird:\n // https://github.com/rust-analyzer/rust-analyzer/issues/1623[1], https://github.com/rust-analyzer/rust-analyzer/issues/3453[2].\n@@ -108,9 +127,210 @@ fn hints(\n             }\n             _ => (),\n         }\n-    } else if let Some(it) = ast::IdentPat::cast(node) {\n+    } else if let Some(it) = ast::IdentPat::cast(node.clone()) {\n         bind_pat_hints(hints, sema, config, &it);\n+    } else if let Some(it) = ast::Fn::cast(node) {\n+        lifetime_hints(hints, config, it);\n+    }\n+}\n+\n+fn lifetime_hints(\n+    acc: &mut Vec<InlayHint>,\n+    config: &InlayHintsConfig,\n+    func: ast::Fn,\n+) -> Option<()> {\n+    if config.lifetime_elision_hints == LifetimeElisionHints::Never {\n+        return None;\n+    }\n+    let param_list = func.param_list()?;\n+    let generic_param_list = func.generic_param_list();\n+    let ret_type = func.ret_type();\n+    let self_param = param_list.self_param().filter(|it| it.amp_token().is_some());\n+\n+    let mut used_names: FxHashMap<SmolStr, usize> = generic_param_list\n+        .iter()\n+        .filter(|_| config.param_names_for_lifetime_elision_hints)\n+        .flat_map(|gpl| gpl.lifetime_params())\n+        .filter_map(|param| param.lifetime())\n+        .filter_map(|lt| Some((SmolStr::from(lt.text().as_str().get(1..)?), 0)))\n+        .collect();\n+\n+    let mut allocated_lifetimes = vec![];\n+    let mut gen_idx_name = {\n+        let mut gen = (0u8..).map(|idx| match idx {\n+            idx if idx < 10 => SmolStr::from_iter(['\\'', (idx + 48) as char]),\n+            idx => format!(\"'{idx}\").into(),\n+        });\n+        move || gen.next().unwrap_or_default()\n+    };\n+\n+    let mut potential_lt_refs: Vec<_> = vec![];\n+    param_list\n+        .params()\n+        .filter_map(|it| {\n+            Some((\n+                config.param_names_for_lifetime_elision_hints.then(|| it.pat()).flatten(),\n+                it.ty()?,\n+            ))\n+        })\n+        .for_each(|(pat, ty)| {\n+            // FIXME: check path types\n+            walk_ty(&ty, &mut |ty| match ty {\n+                ast::Type::RefType(r) => potential_lt_refs.push((\n+                    pat.as_ref().and_then(|it| match it {\n+                        ast::Pat::IdentPat(p) => p.name(),\n+                        _ => None,\n+                    }),\n+                    r,\n+                )),\n+                _ => (),\n+            })\n+        });\n+\n+    enum LifetimeKind {\n+        Elided,\n+        Named(SmolStr),\n+        Static,\n+    }\n+\n+    let fetch_lt_text = |lt: Option<ast::Lifetime>| match lt {\n+        Some(lt) => match lt.text().as_str() {\n+            \"'_\" => LifetimeKind::Elided,\n+            \"'static\" => LifetimeKind::Static,\n+            name => LifetimeKind::Named(name.into()),\n+        },\n+        None => LifetimeKind::Elided,\n+    };\n+    let is_elided = |lt: Option<ast::Lifetime>| match lt {\n+        Some(lt) => matches!(lt.text().as_str(), \"'_\"),\n+        None => true,\n+    };\n+\n+    // allocate names\n+    if let Some(self_param) = &self_param {\n+        if is_elided(self_param.lifetime()) {\n+            allocated_lifetimes.push(if config.param_names_for_lifetime_elision_hints {\n+                // self can't be used as a lifetime, so no need to check for collisions\n+                \"'self\".into()\n+            } else {\n+                gen_idx_name()\n+            });\n+        }\n+    }\n+    potential_lt_refs.iter().for_each(|(name, it)| {\n+        if is_elided(it.lifetime()) {\n+            let name = match name {\n+                Some(it) => {\n+                    if let Some(c) = used_names.get_mut(it.text().as_str()) {\n+                        *c += 1;\n+                        SmolStr::from(format!(\"'{text}{c}\", text = it.text().as_str()))\n+                    } else {\n+                        used_names.insert(it.text().as_str().into(), 0);\n+                        SmolStr::from_iter([\"\\'\", it.text().as_str()])\n+                    }\n+                }\n+                _ => gen_idx_name(),\n+            };\n+            allocated_lifetimes.push(name);\n+        }\n+    });\n+\n+    // fetch output lifetime if elision rule applies\n+\n+    let output = if let Some(self_param) = &self_param {\n+        match fetch_lt_text(self_param.lifetime()) {\n+            LifetimeKind::Elided => allocated_lifetimes.get(0).cloned(),\n+            LifetimeKind::Named(name) => Some(name),\n+            LifetimeKind::Static => None,\n+        }\n+    } else {\n+        match potential_lt_refs.as_slice() {\n+            [(_, r)] => match fetch_lt_text(r.lifetime()) {\n+                LifetimeKind::Elided => allocated_lifetimes.get(0).cloned(),\n+                LifetimeKind::Named(name) => Some(name),\n+                LifetimeKind::Static => None,\n+            },\n+            [..] => None,\n+        }\n+    };\n+\n+    if allocated_lifetimes.is_empty() && output.is_none() {\n+        return None;\n+    }\n+\n+    // apply hints\n+    // apply output if required\n+    let mut is_trivial = true;\n+    if let (Some(output_lt), Some(r)) = (&output, ret_type) {\n+        if let Some(ty) = r.ty() {\n+            walk_ty(&ty, &mut |ty| match ty {\n+                ast::Type::RefType(ty) if ty.lifetime().is_none() => {\n+                    if let Some(amp) = ty.amp_token() {\n+                        is_trivial = false;\n+                        acc.push(InlayHint {\n+                            range: amp.text_range(),\n+                            kind: InlayKind::LifetimeHint,\n+                            label: output_lt.clone(),\n+                        });\n+                    }\n+                }\n+                _ => (),\n+            })\n+        }\n+    }\n+\n+    if config.lifetime_elision_hints == LifetimeElisionHints::SkipTrivial && is_trivial {\n+        return None;\n+    }\n+\n+    let mut idx = match &self_param {\n+        Some(self_param) if is_elided(self_param.lifetime()) => {\n+            if let Some(amp) = self_param.amp_token() {\n+                let lt = allocated_lifetimes[0].clone();\n+                acc.push(InlayHint {\n+                    range: amp.text_range(),\n+                    kind: InlayKind::LifetimeHint,\n+                    label: lt,\n+                });\n+            }\n+            1\n+        }\n+        _ => 0,\n+    };\n+\n+    for (_, p) in potential_lt_refs.iter() {\n+        if is_elided(p.lifetime()) {\n+            let t = p.amp_token()?;\n+            let lt = allocated_lifetimes[idx].clone();\n+            acc.push(InlayHint { range: t.text_range(), kind: InlayKind::LifetimeHint, label: lt });\n+            idx += 1;\n+        }\n+    }\n+\n+    // generate generic param list things\n+    match (generic_param_list, allocated_lifetimes.as_slice()) {\n+        (_, []) => (),\n+        (Some(gpl), allocated_lifetimes) => {\n+            let angle_tok = gpl.l_angle_token()?;\n+            let is_empty = gpl.generic_params().next().is_none();\n+            acc.push(InlayHint {\n+                range: angle_tok.text_range(),\n+                kind: InlayKind::GenericParamListHint,\n+                label: format!(\n+                    \"{}{}\",\n+                    allocated_lifetimes.iter().format(\", \"),\n+                    if is_empty { \"\" } else { \", \" }\n+                )\n+                .into(),\n+            });\n+        }\n+        (None, allocated_lifetimes) => acc.push(InlayHint {\n+            range: func.name()?.syntax().text_range(),\n+            kind: InlayKind::GenericParamListHint,\n+            label: format!(\"<{}>\", allocated_lifetimes.iter().format(\", \"),).into(),\n+        }),\n     }\n+    Some(())\n }\n \n fn closure_ret_hints(\n@@ -600,25 +820,29 @@ fn get_callable(\n mod tests {\n     use expect_test::{expect, Expect};\n     use ide_db::base_db::FileRange;\n+    use itertools::Itertools;\n     use syntax::{TextRange, TextSize};\n     use test_utils::extract_annotations;\n \n-    use crate::{fixture, inlay_hints::InlayHintsConfig};\n+    use crate::{fixture, inlay_hints::InlayHintsConfig, LifetimeElisionHints};\n \n     const DISABLED_CONFIG: InlayHintsConfig = InlayHintsConfig {\n         render_colons: false,\n         type_hints: false,\n         parameter_hints: false,\n         chaining_hints: false,\n+        lifetime_elision_hints: LifetimeElisionHints::Never,\n         hide_named_constructor_hints: false,\n         closure_return_type_hints: false,\n+        param_names_for_lifetime_elision_hints: false,\n         max_length: None,\n     };\n     const TEST_CONFIG: InlayHintsConfig = InlayHintsConfig {\n         type_hints: true,\n         parameter_hints: true,\n         chaining_hints: true,\n         closure_return_type_hints: true,\n+        lifetime_elision_hints: LifetimeElisionHints::Always,\n         ..DISABLED_CONFIG\n     };\n \n@@ -648,10 +872,15 @@ mod tests {\n     #[track_caller]\n     fn check_with_config(config: InlayHintsConfig, ra_fixture: &str) {\n         let (analysis, file_id) = fixture::file(ra_fixture);\n-        let expected = extract_annotations(&*analysis.file_text(file_id).unwrap());\n+        let mut expected = extract_annotations(&*analysis.file_text(file_id).unwrap());\n         let inlay_hints = analysis.inlay_hints(&config, file_id, None).unwrap();\n-        let actual =\n-            inlay_hints.into_iter().map(|it| (it.range, it.label.to_string())).collect::<Vec<_>>();\n+        let actual = inlay_hints\n+            .into_iter()\n+            .map(|it| (it.range, it.label.to_string()))\n+            .sorted_by_key(|(range, _)| range.start())\n+            .collect::<Vec<_>>();\n+        expected.sort_by_key(|(range, _)| range.start());\n+\n         assert_eq!(expected, actual, \"\\nExpected:\\n{:#?}\\n\\nActual:\\n{:#?}\", expected, actual);\n     }\n \n@@ -1289,41 +1518,6 @@ fn main() {\n         );\n     }\n \n-    #[test]\n-    fn incomplete_for_no_hint() {\n-        check_types(\n-            r#\"\n-fn main() {\n-    let data = &[1i32, 2, 3];\n-      //^^^^ &[i32; 3]\n-    for i\n-}\"#,\n-        );\n-        check(\n-            r#\"\n-pub struct Vec<T> {}\n-\n-impl<T> Vec<T> {\n-    pub fn new() -> Self { Vec {} }\n-    pub fn push(&mut self, t: T) {}\n-}\n-\n-impl<T> IntoIterator for Vec<T> {\n-    type Item=T;\n-}\n-\n-fn main() {\n-    let mut data = Vec::new();\n-          //^^^^ Vec<&str>\n-    data.push(\"foo\");\n-    for i in\n-\n-    println!(\"Unit expr\");\n-}\n-\"#,\n-        );\n-    }\n-\n     #[test]\n     fn complete_for_hint() {\n         check_types(\n@@ -1825,4 +2019,103 @@ fn main() {\n             \"#]],\n         );\n     }\n+\n+    #[test]\n+    fn hints_lifetimes() {\n+        check(\n+            r#\"\n+fn empty() {}\n+\n+fn no_gpl(a: &()) {}\n+ //^^^^^^<'0>\n+          // ^'0\n+fn empty_gpl<>(a: &()) {}\n+      //    ^'0   ^'0\n+fn partial<'b>(a: &(), b: &'b ()) {}\n+//        ^'0, $  ^'0\n+fn partial<'a>(a: &'a (), b: &()) {}\n+//        ^'0, $             ^'0\n+\n+fn single_ret(a: &()) -> &() {}\n+// ^^^^^^^^^^<'0>\n+              // ^'0     ^'0\n+fn full_mul(a: &(), b: &()) {}\n+// ^^^^^^^^<'0, '1>\n+            // ^'0     ^'1\n+\n+fn foo<'c>(a: &'c ()) -> &() {}\n+                      // ^'c\n+\n+fn nested_in(a: &   &X< &()>) {}\n+// ^^^^^^^^^<'0, '1, '2>\n+              //^'0 ^'1 ^'2\n+fn nested_out(a: &()) -> &   &X< &()>{}\n+// ^^^^^^^^^^<'0>\n+               //^'0     ^'0 ^'0 ^'0\n+\n+impl () {\n+    fn foo(&self) {}\n+    // ^^^<'0>\n+        // ^'0\n+    fn foo(&self) -> &() {}\n+    // ^^^<'0>\n+        // ^'0       ^'0\n+    fn foo(&self, a: &()) -> &() {}\n+    // ^^^<'0, '1>\n+        // ^'0       ^'1     ^'0\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn hints_lifetimes_named() {\n+        check_with_config(\n+            InlayHintsConfig { param_names_for_lifetime_elision_hints: true, ..TEST_CONFIG },\n+            r#\"\n+fn nested_in<'named>(named: &        &X<      &()>) {}\n+//          ^'named1, 'named2, 'named3, $\n+                          //^'named1 ^'named2 ^'named3\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn hints_lifetimes_trivial_skip() {\n+        check_with_config(\n+            InlayHintsConfig {\n+                lifetime_elision_hints: LifetimeElisionHints::SkipTrivial,\n+                ..TEST_CONFIG\n+            },\n+            r#\"\n+fn no_gpl(a: &()) {}\n+fn empty_gpl<>(a: &()) {}\n+fn partial<'b>(a: &(), b: &'b ()) {}\n+fn partial<'a>(a: &'a (), b: &()) {}\n+\n+fn single_ret(a: &()) -> &() {}\n+// ^^^^^^^^^^<'0>\n+              // ^'0     ^'0\n+fn full_mul(a: &(), b: &()) {}\n+\n+fn foo<'c>(a: &'c ()) -> &() {}\n+                      // ^'c\n+\n+fn nested_in(a: &   &X< &()>) {}\n+fn nested_out(a: &()) -> &   &X< &()>{}\n+// ^^^^^^^^^^<'0>\n+               //^'0     ^'0 ^'0 ^'0\n+\n+impl () {\n+    fn foo(&self) {}\n+    fn foo(&self) -> &() {}\n+    // ^^^<'0>\n+        // ^'0       ^'0\n+    fn foo(&self, a: &()) -> &() {}\n+    // ^^^<'0, '1>\n+        // ^'0       ^'1     ^'0\n+}\n+\"#,\n+        );\n+    }\n }"}, {"sha": "7fcb09b5e2299f500facee283633a5507c87d1a4", "filename": "crates/ide/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7315d973478560f6be3ff3d6fceadabc900d9ffa/crates%2Fide%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7315d973478560f6be3ff3d6fceadabc900d9ffa/crates%2Fide%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Flib.rs?ref=7315d973478560f6be3ff3d6fceadabc900d9ffa", "patch": "@@ -80,7 +80,7 @@ pub use crate::{\n     folding_ranges::{Fold, FoldKind},\n     highlight_related::{HighlightRelatedConfig, HighlightedRange},\n     hover::{HoverAction, HoverConfig, HoverDocFormat, HoverGotoTypeData, HoverResult},\n-    inlay_hints::{InlayHint, InlayHintsConfig, InlayKind},\n+    inlay_hints::{InlayHint, InlayHintsConfig, InlayKind, LifetimeElisionHints},\n     join_lines::JoinLinesConfig,\n     markup::Markup,\n     moniker::{MonikerKind, MonikerResult, PackageInformation},"}, {"sha": "3c81bfa3a92def85648eff16b42f7bf0d7e705ca", "filename": "crates/ide/src/static_index.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7315d973478560f6be3ff3d6fceadabc900d9ffa/crates%2Fide%2Fsrc%2Fstatic_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7315d973478560f6be3ff3d6fceadabc900d9ffa/crates%2Fide%2Fsrc%2Fstatic_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fstatic_index.rs?ref=7315d973478560f6be3ff3d6fceadabc900d9ffa", "patch": "@@ -12,11 +12,14 @@ use ide_db::{\n use rustc_hash::FxHashSet;\n use syntax::{AstNode, SyntaxKind::*, SyntaxToken, TextRange, T};\n \n-use crate::moniker::{crate_for_file, def_to_moniker, MonikerResult};\n use crate::{\n     hover::hover_for_definition, Analysis, Fold, HoverConfig, HoverDocFormat, HoverResult,\n     InlayHint, InlayHintsConfig, TryToNav,\n };\n+use crate::{\n+    moniker::{crate_for_file, def_to_moniker, MonikerResult},\n+    LifetimeElisionHints,\n+};\n \n /// A static representation of fully analyzed source code.\n ///\n@@ -110,7 +113,9 @@ impl StaticIndex<'_> {\n                     parameter_hints: true,\n                     chaining_hints: true,\n                     closure_return_type_hints: true,\n+                    lifetime_elision_hints: LifetimeElisionHints::Never,\n                     hide_named_constructor_hints: false,\n+                    param_names_for_lifetime_elision_hints: false,\n                     max_length: Some(25),\n                 },\n                 file_id,"}, {"sha": "3afbeac47c7e0bdcfd6ac10c1260b2e27ba16e92", "filename": "crates/rust-analyzer/src/config.rs", "status": "modified", "additions": 41, "deletions": 9, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/7315d973478560f6be3ff3d6fceadabc900d9ffa/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7315d973478560f6be3ff3d6fceadabc900d9ffa/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs?ref=7315d973478560f6be3ff3d6fceadabc900d9ffa", "patch": "@@ -12,7 +12,8 @@ use std::{ffi::OsString, iter, path::PathBuf};\n use flycheck::FlycheckConfig;\n use ide::{\n     AssistConfig, CompletionConfig, DiagnosticsConfig, ExprFillDefaultMode, HighlightRelatedConfig,\n-    HoverConfig, HoverDocFormat, InlayHintsConfig, JoinLinesConfig, Snippet, SnippetScope,\n+    HoverConfig, HoverDocFormat, InlayHintsConfig, JoinLinesConfig, LifetimeElisionHints, Snippet,\n+    SnippetScope,\n };\n use ide_db::{\n     imports::insert_use::{ImportGranularity, InsertUseConfig, PrefixKind},\n@@ -243,20 +244,24 @@ config_data! {\n         hoverActions_run: bool             = \"true\",\n \n         /// Whether to render trailing colons for parameter hints, and trailing colons for parameter hints.\n-        inlayHints_renderColons: bool               = \"true\",\n+        inlayHints_renderColons: bool                      = \"true\",\n         /// Maximum length for inlay hints. Set to null to have an unlimited length.\n-        inlayHints_maxLength: Option<usize>         = \"25\",\n+        inlayHints_maxLength: Option<usize>                = \"25\",\n         /// Whether to show function parameter name inlay hints at the call\n         /// site.\n-        inlayHints_parameterHints: bool             = \"true\",\n+        inlayHints_parameterHints: bool                     = \"true\",\n         /// Whether to show inlay type hints for variables.\n-        inlayHints_typeHints: bool                  = \"true\",\n+        inlayHints_typeHints: bool                          = \"true\",\n         /// Whether to show inlay type hints for method chains.\n-        inlayHints_chainingHints: bool              = \"true\",\n+        inlayHints_chainingHints: bool                      = \"true\",\n         /// Whether to show inlay type hints for return types of closures with blocks.\n-        inlayHints_closureReturnTypeHints: bool     = \"false\",\n+        inlayHints_closureReturnTypeHints: bool             = \"false\",\n+        /// Whether to show inlay type hints for elided lifetimes in function signatures.\n+        inlayHints_lifetimeElisionHints: LifetimeElisionDef = \"\\\"never\\\"\",\n+        /// Whether to prefer using parameter names as the name for elided lifetime hints if possible.\n+        inlayHints_lifetimeElisionHints_useParameterNames: bool  = \"false\",\n         /// Whether to hide inlay hints for constructors.\n-        inlayHints_hideNamedConstructorHints: bool  = \"false\",\n+        inlayHints_hideNamedConstructorHints: bool          = \"false\",\n \n         /// Join lines inserts else between consecutive ifs.\n         joinLines_joinElseIf: bool = \"true\",\n@@ -855,7 +860,15 @@ impl Config {\n             parameter_hints: self.data.inlayHints_parameterHints,\n             chaining_hints: self.data.inlayHints_chainingHints,\n             closure_return_type_hints: self.data.inlayHints_closureReturnTypeHints,\n+            lifetime_elision_hints: match self.data.inlayHints_lifetimeElisionHints {\n+                LifetimeElisionDef::Always => LifetimeElisionHints::Always,\n+                LifetimeElisionDef::Never => LifetimeElisionHints::Never,\n+                LifetimeElisionDef::SkipTrivial => LifetimeElisionHints::SkipTrivial,\n+            },\n             hide_named_constructor_hints: self.data.inlayHints_hideNamedConstructorHints,\n+            param_names_for_lifetime_elision_hints: self\n+                .data\n+                .inlayHints_lifetimeElisionHints_useParameterNames,\n             max_length: self.data.inlayHints_maxLength,\n         }\n     }\n@@ -1125,6 +1138,16 @@ enum ImportGranularityDef {\n     Module,\n }\n \n+#[derive(Deserialize, Debug, Clone)]\n+#[serde(rename_all = \"snake_case\")]\n+enum LifetimeElisionDef {\n+    #[serde(alias = \"true\")]\n+    Always,\n+    #[serde(alias = \"false\")]\n+    Never,\n+    SkipTrivial,\n+}\n+\n #[derive(Deserialize, Debug, Clone)]\n #[serde(rename_all = \"snake_case\")]\n enum ImportPrefixDef {\n@@ -1377,7 +1400,16 @@ fn field_props(field: &str, ty: &str, doc: &[&str], default: &str) -> serde_json\n             \"minimum\": 0,\n             \"maximum\": 255\n         },\n-        _ => panic!(\"{}: {}\", ty, default),\n+        \"LifetimeElisionDef\" => set! {\n+            \"type\": \"string\",\n+            \"enum\": [\"always\", \"never\", \"skip_trivial\"],\n+            \"enumDescriptions\": [\n+                \"Always show lifetime elision hints.\",\n+                \"Never show lifetime elision hints.\",\n+                \"Only show lifetime elision hints if a return type is involved.\"\n+            ],\n+        },\n+        _ => panic!(\"missing entry for {}: {}\", ty, default),\n     }\n \n     map.into()"}, {"sha": "693b394d3bdc4650b1b18853a47a81f0f7658efe", "filename": "crates/rust-analyzer/src/to_proto.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7315d973478560f6be3ff3d6fceadabc900d9ffa/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7315d973478560f6be3ff3d6fceadabc900d9ffa/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs?ref=7315d973478560f6be3ff3d6fceadabc900d9ffa", "patch": "@@ -427,27 +427,34 @@ pub(crate) fn inlay_hint(\n         }),\n         position: match inlay_hint.kind {\n             InlayKind::ParameterHint => position(line_index, inlay_hint.range.start()),\n-            InlayKind::ClosureReturnTypeHint | InlayKind::TypeHint | InlayKind::ChainingHint => {\n-                position(line_index, inlay_hint.range.end())\n-            }\n+            InlayKind::ClosureReturnTypeHint\n+            | InlayKind::TypeHint\n+            | InlayKind::ChainingHint\n+            | InlayKind::GenericParamListHint\n+            | InlayKind::LifetimeHint => position(line_index, inlay_hint.range.end()),\n         },\n         kind: match inlay_hint.kind {\n             InlayKind::ParameterHint => Some(lsp_ext::InlayHintKind::PARAMETER),\n             InlayKind::ClosureReturnTypeHint | InlayKind::TypeHint | InlayKind::ChainingHint => {\n                 Some(lsp_ext::InlayHintKind::TYPE)\n             }\n+            InlayKind::GenericParamListHint | InlayKind::LifetimeHint => None,\n         },\n         tooltip: None,\n         padding_left: Some(match inlay_hint.kind {\n             InlayKind::TypeHint => !render_colons,\n             InlayKind::ParameterHint | InlayKind::ClosureReturnTypeHint => false,\n             InlayKind::ChainingHint => true,\n+            InlayKind::GenericParamListHint => false,\n+            InlayKind::LifetimeHint => false,\n         }),\n         padding_right: Some(match inlay_hint.kind {\n             InlayKind::TypeHint | InlayKind::ChainingHint | InlayKind::ClosureReturnTypeHint => {\n                 false\n             }\n             InlayKind::ParameterHint => true,\n+            InlayKind::LifetimeHint => true,\n+            InlayKind::GenericParamListHint => false,\n         }),\n     }\n }"}, {"sha": "4438a12093a63040d9dda06d975b18a5718bd827", "filename": "crates/test_utils/src/lib.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7315d973478560f6be3ff3d6fceadabc900d9ffa/crates%2Ftest_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7315d973478560f6be3ff3d6fceadabc900d9ffa/crates%2Ftest_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest_utils%2Fsrc%2Flib.rs?ref=7315d973478560f6be3ff3d6fceadabc900d9ffa", "patch": "@@ -306,15 +306,15 @@ fn extract_line_annotations(mut line: &str) -> Vec<LineAnnotation> {\n         let end_marker = line_no_caret.find(|c| c == '$');\n         let next = line_no_caret.find(marker).map_or(line.len(), |it| it + len);\n \n-        let mut content = match end_marker {\n-            Some(end_marker)\n-                if end_marker < next\n-                    && line_no_caret[end_marker..]\n+        let cond = |end_marker| {\n+            end_marker < next\n+                && (line_no_caret[end_marker + 1..].is_empty()\n+                    || line_no_caret[end_marker + 1..]\n                         .strip_prefix(|c: char| c.is_whitespace() || c == '^')\n-                        .is_some() =>\n-            {\n-                &line_no_caret[..end_marker]\n-            }\n+                        .is_some())\n+        };\n+        let mut content = match end_marker {\n+            Some(end_marker) if cond(end_marker) => &line_no_caret[..end_marker],\n             _ => line_no_caret[..next - len].trim_end(),\n         };\n "}, {"sha": "42f485b5111dbf467d50496c03b28d0ed403155e", "filename": "docs/user/generated_config.adoc", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7315d973478560f6be3ff3d6fceadabc900d9ffa/docs%2Fuser%2Fgenerated_config.adoc", "raw_url": "https://github.com/rust-lang/rust/raw/7315d973478560f6be3ff3d6fceadabc900d9ffa/docs%2Fuser%2Fgenerated_config.adoc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fuser%2Fgenerated_config.adoc?ref=7315d973478560f6be3ff3d6fceadabc900d9ffa", "patch": "@@ -378,6 +378,16 @@ Whether to show inlay type hints for method chains.\n --\n Whether to show inlay type hints for return types of closures with blocks.\n --\n+[[rust-analyzer.inlayHints.lifetimeElisionHints]]rust-analyzer.inlayHints.lifetimeElisionHints (default: `\"never\"`)::\n++\n+--\n+Whether to show inlay type hints for elided lifetimes in function signatures.\n+--\n+[[rust-analyzer.inlayHints.lifetimeElisionHints.useParameterNames]]rust-analyzer.inlayHints.lifetimeElisionHints.useParameterNames (default: `false`)::\n++\n+--\n+Whether to prefer using parameter names as the name for elided lifetime hints if possible.\n+--\n [[rust-analyzer.inlayHints.hideNamedConstructorHints]]rust-analyzer.inlayHints.hideNamedConstructorHints (default: `false`)::\n +\n --"}, {"sha": "ffd89d96d4c309a5bb6616c4f6f0cc9eaede7afe", "filename": "editors/code/package.json", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7315d973478560f6be3ff3d6fceadabc900d9ffa/editors%2Fcode%2Fpackage.json", "raw_url": "https://github.com/rust-lang/rust/raw/7315d973478560f6be3ff3d6fceadabc900d9ffa/editors%2Fcode%2Fpackage.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fpackage.json?ref=7315d973478560f6be3ff3d6fceadabc900d9ffa", "patch": "@@ -795,6 +795,26 @@\n                     \"default\": false,\n                     \"type\": \"boolean\"\n                 },\n+                \"rust-analyzer.inlayHints.lifetimeElisionHints\": {\n+                    \"markdownDescription\": \"Whether to show inlay type hints for elided lifetimes in function signatures.\",\n+                    \"default\": \"never\",\n+                    \"type\": \"string\",\n+                    \"enum\": [\n+                        \"always\",\n+                        \"never\",\n+                        \"skip_trivial\"\n+                    ],\n+                    \"enumDescriptions\": [\n+                        \"Always show lifetime elision hints.\",\n+                        \"Never show lifetime elision hints.\",\n+                        \"Only show lifetime elision hints if a return type is involved.\"\n+                    ]\n+                },\n+                \"rust-analyzer.inlayHints.lifetimeElisionHints.useParameterNames\": {\n+                    \"markdownDescription\": \"Whether to prefer using parameter names as the name for elided lifetime hints if possible.\",\n+                    \"default\": false,\n+                    \"type\": \"boolean\"\n+                },\n                 \"rust-analyzer.inlayHints.hideNamedConstructorHints\": {\n                     \"markdownDescription\": \"Whether to hide inlay hints for constructors.\",\n                     \"default\": false,"}]}