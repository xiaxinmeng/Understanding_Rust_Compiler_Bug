{"sha": "c8b0d667c30e0918714ac178edaed883c6a8132a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM4YjBkNjY3YzMwZTA5MTg3MTRhYzE3OGVkYWVkODgzYzZhODEzMmE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-09-11T12:20:43Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-09-11T12:20:43Z"}, "message": "auto merge of #17157 : nikomatsakis/rust/occurs-check, r=pcwalton\n\nAvoid ever constructing cyclic types in the first place, rather than detecting them in resolve. This simplifies logic elsewhere in the compiler, in particular on the trait reform branch.\r\n\r\nr? @pnkfelix or @pcwalton \r\n\r\ncc #5527", "tree": {"sha": "cb65ab992247c1444c3c29adf30373a216440e4e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cb65ab992247c1444c3c29adf30373a216440e4e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c8b0d667c30e0918714ac178edaed883c6a8132a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c8b0d667c30e0918714ac178edaed883c6a8132a", "html_url": "https://github.com/rust-lang/rust/commit/c8b0d667c30e0918714ac178edaed883c6a8132a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c8b0d667c30e0918714ac178edaed883c6a8132a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "29f817fa22c906b4bb764e43fb6877a6cde3c07f", "url": "https://api.github.com/repos/rust-lang/rust/commits/29f817fa22c906b4bb764e43fb6877a6cde3c07f", "html_url": "https://github.com/rust-lang/rust/commit/29f817fa22c906b4bb764e43fb6877a6cde3c07f"}, {"sha": "c4d56b7ee734359e7b6be73eff4596367b645d62", "url": "https://api.github.com/repos/rust-lang/rust/commits/c4d56b7ee734359e7b6be73eff4596367b645d62", "html_url": "https://github.com/rust-lang/rust/commit/c4d56b7ee734359e7b6be73eff4596367b645d62"}], "stats": {"total": 178, "additions": 127, "deletions": 51}, "files": [{"sha": "e196304b82ac39a6b65ae086bbef84e8b480884e", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c8b0d667c30e0918714ac178edaed883c6a8132a/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8b0d667c30e0918714ac178edaed883c6a8132a/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=c8b0d667c30e0918714ac178edaed883c6a8132a", "patch": "@@ -1002,7 +1002,8 @@ pub enum type_err {\n     terr_float_mismatch(expected_found<ast::FloatTy>),\n     terr_traits(expected_found<ast::DefId>),\n     terr_builtin_bounds(expected_found<BuiltinBounds>),\n-    terr_variadic_mismatch(expected_found<bool>)\n+    terr_variadic_mismatch(expected_found<bool>),\n+    terr_cyclic_ty,\n }\n \n /// Bounds suitable for a named type parameter like `A` in `fn foo<A>`\n@@ -3791,6 +3792,7 @@ pub fn type_err_to_str(cx: &ctxt, err: &type_err) -> String {\n     }\n \n     match *err {\n+        terr_cyclic_ty => \"cyclic type of infinite size\".to_string(),\n         terr_mismatch => \"types differ\".to_string(),\n         terr_fn_style_mismatch(values) => {\n             format!(\"expected {} fn, found {} fn\","}, {"sha": "17e7aa8ddc34cf3085f870be1aa8d127d635bc6c", "filename": "src/librustc/middle/typeck/infer/combine.rs", "status": "modified", "additions": 90, "deletions": 14, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/c8b0d667c30e0918714ac178edaed883c6a8132a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8b0d667c30e0918714ac178edaed883c6a8132a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs?ref=c8b0d667c30e0918714ac178edaed883c6a8132a", "patch": "@@ -39,6 +39,7 @@ use middle::ty::{FloatVar, FnSig, IntVar, TyVar};\n use middle::ty::{IntType, UintType};\n use middle::ty::{BuiltinBounds};\n use middle::ty;\n+use middle::ty_fold;\n use middle::typeck::infer::equate::Equate;\n use middle::typeck::infer::glb::Glb;\n use middle::typeck::infer::lub::Lub;\n@@ -48,14 +49,15 @@ use middle::typeck::infer::{InferCtxt, cres};\n use middle::typeck::infer::{MiscVariable, TypeTrace};\n use middle::typeck::infer::type_variable::{RelationDir, EqTo,\n                                            SubtypeOf, SupertypeOf};\n-use middle::ty_fold::{RegionFolder, TypeFoldable};\n+use middle::ty_fold::{TypeFoldable};\n use util::ppaux::Repr;\n \n use std::result;\n \n use syntax::ast::{Onceness, FnStyle};\n use syntax::ast;\n use syntax::abi;\n+use syntax::codemap::Span;\n \n pub trait Combine<'tcx> {\n     fn infcx<'a>(&'a self) -> &'a InferCtxt<'a, 'tcx>;\n@@ -637,10 +639,14 @@ impl<'f, 'tcx> CombineFields<'f, 'tcx> {\n                 Some(t) => t, // ...already instantiated.\n                 None => {     // ...not yet instantiated:\n                     // Generalize type if necessary.\n-                    let generalized_ty = match dir {\n-                        EqTo => a_ty,\n-                        SupertypeOf | SubtypeOf => self.generalize(a_ty)\n-                    };\n+                    let generalized_ty = try!(match dir {\n+                        EqTo => {\n+                            self.generalize(a_ty, b_vid, false)\n+                        }\n+                        SupertypeOf | SubtypeOf => {\n+                            self.generalize(a_ty, b_vid, true)\n+                        }\n+                    });\n                     debug!(\"instantiate(a_ty={}, dir={}, \\\n                                         b_vid={}, generalized_ty={})\",\n                            a_ty.repr(tcx), dir, b_vid.repr(tcx),\n@@ -678,15 +684,85 @@ impl<'f, 'tcx> CombineFields<'f, 'tcx> {\n         Ok(())\n     }\n \n-    fn generalize(&self, t: ty::t) -> ty::t {\n-        // FIXME(#16847): This is non-ideal because we don't give a\n-        // very descriptive origin for this region variable.\n+    fn generalize(&self,\n+                  ty: ty::t,\n+                  for_vid: ty::TyVid,\n+                  make_region_vars: bool)\n+                  -> cres<ty::t>\n+    {\n+        /*!\n+         * Attempts to generalize `ty` for the type variable\n+         * `for_vid`.  This checks for cycle -- that is, whether the\n+         * type `ty` references `for_vid`. If `make_region_vars` is\n+         * true, it will also replace all regions with fresh\n+         * variables. Returns `ty_err` in the case of a cycle, `Ok`\n+         * otherwise.\n+         */\n+\n+        let mut generalize = Generalizer { infcx: self.infcx,\n+                                           span: self.trace.origin.span(),\n+                                           for_vid: for_vid,\n+                                           make_region_vars: make_region_vars,\n+                                           cycle_detected: false };\n+        let u = ty.fold_with(&mut generalize);\n+        if generalize.cycle_detected {\n+            Err(ty::terr_cyclic_ty)\n+        } else {\n+            Ok(u)\n+        }\n+    }\n+}\n \n-        let infcx = self.infcx;\n-        let span = self.trace.origin.span();\n-        t.fold_with(\n-            &mut RegionFolder::regions(\n-                self.infcx.tcx,\n-                |_| infcx.next_region_var(MiscVariable(span))))\n+struct Generalizer<'cx, 'tcx:'cx> {\n+    infcx: &'cx InferCtxt<'cx, 'tcx>,\n+    span: Span,\n+    for_vid: ty::TyVid,\n+    make_region_vars: bool,\n+    cycle_detected: bool,\n+}\n+\n+impl<'cx, 'tcx> ty_fold::TypeFolder<'tcx> for Generalizer<'cx, 'tcx> {\n+    fn tcx(&self) -> &ty::ctxt<'tcx> {\n+        self.infcx.tcx\n+    }\n+\n+    fn fold_ty(&mut self, t: ty::t) -> ty::t {\n+        // Check to see whether the type we are genealizing references\n+        // `vid`. At the same time, also update any type variables to\n+        // the values that they are bound to. This is needed to truly\n+        // check for cycles, but also just makes things readable.\n+        //\n+        // (In particular, you could have something like `$0 = Box<$1>`\n+        //  where `$1` has already been instantiated with `Box<$0>`)\n+        match ty::get(t).sty {\n+            ty::ty_infer(ty::TyVar(vid)) => {\n+                if vid == self.for_vid {\n+                    self.cycle_detected = true;\n+                    ty::mk_err()\n+                } else {\n+                    match self.infcx.type_variables.borrow().probe(vid) {\n+                        Some(u) => self.fold_ty(u),\n+                        None => t,\n+                    }\n+                }\n+            }\n+            _ => {\n+                ty_fold::super_fold_ty(self, t)\n+            }\n+        }\n+    }\n+\n+    fn fold_region(&mut self, r: ty::Region) -> ty::Region {\n+        match r {\n+            ty::ReLateBound(..) | ty::ReEarlyBound(..) => r,\n+            _ if self.make_region_vars => {\n+                // FIXME: This is non-ideal because we don't give a\n+                // very descriptive origin for this region variable.\n+                self.infcx.next_region_var(MiscVariable(self.span))\n+            }\n+            _ => r,\n+        }\n     }\n }\n+\n+"}, {"sha": "f917ced08ce9435c94dc59f984417f997c137a9d", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c8b0d667c30e0918714ac178edaed883c6a8132a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8b0d667c30e0918714ac178edaed883c6a8132a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=c8b0d667c30e0918714ac178edaed883c6a8132a", "patch": "@@ -266,7 +266,6 @@ pub enum fixup_err {\n     unresolved_int_ty(IntVid),\n     unresolved_float_ty(FloatVid),\n     unresolved_ty(TyVid),\n-    cyclic_ty(TyVid),\n     unresolved_region(RegionVid),\n     region_var_bound_by_region_var(RegionVid, RegionVid)\n }\n@@ -282,7 +281,6 @@ pub fn fixup_err_to_string(f: fixup_err) -> String {\n            the type explicitly\".to_string()\n       }\n       unresolved_ty(_) => \"unconstrained type\".to_string(),\n-      cyclic_ty(_) => \"cyclic type of infinite size\".to_string(),\n       unresolved_region(_) => \"unconstrained region\".to_string(),\n       region_var_bound_by_region_var(r1, r2) => {\n         format!(\"region var {:?} bound by another region var {:?}; \\"}, {"sha": "569206f6754f9917679e64c87b043ee7d060a7e7", "filename": "src/librustc/middle/typeck/infer/resolve.rs", "status": "modified", "additions": 14, "deletions": 32, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/c8b0d667c30e0918714ac178edaed883c6a8132a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8b0d667c30e0918714ac178edaed883c6a8132a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs?ref=c8b0d667c30e0918714ac178edaed883c6a8132a", "patch": "@@ -51,7 +51,7 @@ use middle::ty::{FloatVar, FloatVid, IntVar, IntVid, RegionVid, TyVar, TyVid};\n use middle::ty::{IntType, UintType};\n use middle::ty;\n use middle::ty_fold;\n-use middle::typeck::infer::{cyclic_ty, fixup_err, fres, InferCtxt};\n+use middle::typeck::infer::{fixup_err, fres, InferCtxt};\n use middle::typeck::infer::{unresolved_int_ty,unresolved_float_ty,unresolved_ty};\n use syntax::codemap::Span;\n use util::common::indent;\n@@ -78,7 +78,6 @@ pub struct ResolveState<'a, 'tcx: 'a> {\n     infcx: &'a InferCtxt<'a, 'tcx>,\n     modes: uint,\n     err: Option<fixup_err>,\n-    v_seen: Vec<TyVid> ,\n     type_depth: uint,\n }\n \n@@ -90,7 +89,6 @@ pub fn resolver<'a, 'tcx>(infcx: &'a InferCtxt<'a, 'tcx>,\n         infcx: infcx,\n         modes: modes,\n         err: None,\n-        v_seen: Vec::new(),\n         type_depth: 0,\n     }\n }\n@@ -126,9 +124,7 @@ impl<'a, 'tcx> ResolveState<'a, 'tcx> {\n         // n.b. This is a hokey mess because the current fold doesn't\n         // allow us to pass back errors in any useful way.\n \n-        assert!(self.v_seen.is_empty());\n-        let rty = indent(|| self.resolve_type(typ) );\n-        assert!(self.v_seen.is_empty());\n+        let rty = self.resolve_type(typ);\n         match self.err {\n           None => {\n             debug!(\"Resolved {} to {} (modes={:x})\",\n@@ -205,33 +201,19 @@ impl<'a, 'tcx> ResolveState<'a, 'tcx> {\n     }\n \n     pub fn resolve_ty_var(&mut self, vid: TyVid) -> ty::t {\n-        if self.v_seen.contains(&vid) {\n-            self.err = Some(cyclic_ty(vid));\n-            return ty::mk_var(self.infcx.tcx, vid);\n-        } else {\n-            self.v_seen.push(vid);\n-            let tcx = self.infcx.tcx;\n-\n-            // Nonobvious: prefer the most specific type\n-            // (i.e., the lower bound) to the more general\n-            // one.  More general types in Rust (e.g., fn())\n-            // tend to carry more restrictions or higher\n-            // perf. penalties, so it pays to know more.\n-\n-            let t1 = match self.infcx.type_variables.borrow().probe(vid) {\n-                Some(t) => {\n-                    self.resolve_type(t)\n-                }\n-                None => {\n-                    if self.should(force_tvar) {\n-                        self.err = Some(unresolved_ty(vid));\n-                    }\n-                    ty::mk_var(tcx, vid)\n+        let tcx = self.infcx.tcx;\n+        let t1 = match self.infcx.type_variables.borrow().probe(vid) {\n+            Some(t) => {\n+                self.resolve_type(t)\n+            }\n+            None => {\n+                if self.should(force_tvar) {\n+                    self.err = Some(unresolved_ty(vid));\n                 }\n-            };\n-            self.v_seen.pop().unwrap();\n-            return t1;\n-        }\n+                ty::mk_var(tcx, vid)\n+            }\n+        };\n+        return t1;\n     }\n \n     pub fn resolve_int_var(&mut self, vid: IntVid) -> ty::t {"}, {"sha": "69c012e0d8e0e466ef43a53957f4c28d7ef2f596", "filename": "src/test/compile-fail/occurs-check-2.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c8b0d667c30e0918714ac178edaed883c6a8132a/src%2Ftest%2Fcompile-fail%2Foccurs-check-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8b0d667c30e0918714ac178edaed883c6a8132a/src%2Ftest%2Fcompile-fail%2Foccurs-check-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Foccurs-check-2.rs?ref=c8b0d667c30e0918714ac178edaed883c6a8132a", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::gc::GC;\n+\n+fn main() {\n+    let f;\n+    let g;\n+    g = f;\n+    f = box(GC) g; //~ ERROR cyclic type of infinite size\n+}"}, {"sha": "a00528616c3e5e3d0f4cdb5ac0edbf83a23bbcb9", "filename": "src/test/compile-fail/occurs-check.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c8b0d667c30e0918714ac178edaed883c6a8132a/src%2Ftest%2Fcompile-fail%2Foccurs-check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8b0d667c30e0918714ac178edaed883c6a8132a/src%2Ftest%2Fcompile-fail%2Foccurs-check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Foccurs-check.rs?ref=c8b0d667c30e0918714ac178edaed883c6a8132a", "patch": "@@ -12,6 +12,6 @@\n use std::gc::GC;\n \n fn main() {\n-    let f; //~ ERROR cyclic type of infinite size\n-    f = box(GC) f;\n+    let f;\n+    f = box(GC) f; //~ ERROR cyclic type of infinite size\n }"}]}