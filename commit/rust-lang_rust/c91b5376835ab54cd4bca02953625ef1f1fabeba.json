{"sha": "c91b5376835ab54cd4bca02953625ef1f1fabeba", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM5MWI1Mzc2ODM1YWI1NGNkNGJjYTAyOTUzNjI1ZWYxZjFmYWJlYmE=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-04-05T17:25:19Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-04-05T17:25:19Z"}, "message": "Merge #8348\n\n8348: Make `Binders` more like Chalk r=flodiebold a=flodiebold\n\nWorking towards #8313.\r\n - hide `value`\r\n - use `VariableKinds`\r\n - adjust `subst` to be like Chalk's `substitute`\r\n - also clean up some other `TypeWalk` stuff to prepare for it being replaced by Chalk's `Fold`\n\nCo-authored-by: Florian Diebold <flodiebold@gmail.com>", "tree": {"sha": "390be0ec3c0a57db5188b06c86f0a7df0242b01c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/390be0ec3c0a57db5188b06c86f0a7df0242b01c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c91b5376835ab54cd4bca02953625ef1f1fabeba", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJga0f/CRBK7hj4Ov3rIwAAdHIIAJoKkv7bzt450pnEbwwudaRp\nA50iCPOOyLJMvWRNtUy0H8UcM0wFV4yNJSQCxdbh/22Za5/Mg1cgxsFGJcjX2Lzn\nGQElmPlDzLIRMk7kpuH4GfCLfmmiIfwgKdSc4lLukXKkgFlRrwvkRcFn15ltwZY7\n0ONFl/APHkBF76QDNmEegoOirZ+DOFajwHayzEy9KzVgNlkZ+1vsRr6m7AYYdV6c\nY4BIxYSgu+qXJZsQDfbx92rOvx7LMLHVwmnFt3tYAsmcpHI/oOPVlNaW20kRGrKH\nsLpJmZAlj1m0mVOtF4WsRby/T3aD3+UaQZsmcfRVLY0hd8IPCVfKETUiq30Hazw=\n=oXiX\n-----END PGP SIGNATURE-----\n", "payload": "tree 390be0ec3c0a57db5188b06c86f0a7df0242b01c\nparent 467a5c6cd13af6ccb76e9ebdb35f96fc10fb438f\nparent a316d583600e11ee1fcc8027a838efafe435f03c\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1617643519 +0000\ncommitter GitHub <noreply@github.com> 1617643519 +0000\n\nMerge #8348\n\n8348: Make `Binders` more like Chalk r=flodiebold a=flodiebold\n\nWorking towards #8313.\r\n - hide `value`\r\n - use `VariableKinds`\r\n - adjust `subst` to be like Chalk's `substitute`\r\n - also clean up some other `TypeWalk` stuff to prepare for it being replaced by Chalk's `Fold`\n\nCo-authored-by: Florian Diebold <flodiebold@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c91b5376835ab54cd4bca02953625ef1f1fabeba", "html_url": "https://github.com/rust-lang/rust/commit/c91b5376835ab54cd4bca02953625ef1f1fabeba", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c91b5376835ab54cd4bca02953625ef1f1fabeba/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "467a5c6cd13af6ccb76e9ebdb35f96fc10fb438f", "url": "https://api.github.com/repos/rust-lang/rust/commits/467a5c6cd13af6ccb76e9ebdb35f96fc10fb438f", "html_url": "https://github.com/rust-lang/rust/commit/467a5c6cd13af6ccb76e9ebdb35f96fc10fb438f"}, {"sha": "a316d583600e11ee1fcc8027a838efafe435f03c", "url": "https://api.github.com/repos/rust-lang/rust/commits/a316d583600e11ee1fcc8027a838efafe435f03c", "html_url": "https://github.com/rust-lang/rust/commit/a316d583600e11ee1fcc8027a838efafe435f03c"}], "stats": {"total": 524, "additions": 296, "deletions": 228}, "files": [{"sha": "01a4d205fd6a5c9e107505cdce1c0cd2e5def856", "filename": "crates/hir/src/display.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c91b5376835ab54cd4bca02953625ef1f1fabeba/crates%2Fhir%2Fsrc%2Fdisplay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c91b5376835ab54cd4bca02953625ef1f1fabeba/crates%2Fhir%2Fsrc%2Fdisplay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fdisplay.rs?ref=c91b5376835ab54cd4bca02953625ef1f1fabeba", "patch": "@@ -9,6 +9,7 @@ use hir_ty::display::{\n     write_bounds_like_dyn_trait_with_prefix, write_visibility, HirDisplay, HirDisplayError,\n     HirFormatter,\n };\n+use hir_ty::Interner;\n use syntax::ast::{self, NameOwner};\n \n use crate::{\n@@ -235,7 +236,8 @@ impl HirDisplay for TypeParam {\n         write!(f, \"{}\", self.name(f.db))?;\n         let bounds = f.db.generic_predicates_for_param(self.id);\n         let substs = TyBuilder::type_params_subst(f.db, self.id.parent);\n-        let predicates = bounds.iter().cloned().map(|b| b.subst(&substs)).collect::<Vec<_>>();\n+        let predicates =\n+            bounds.iter().cloned().map(|b| b.substitute(&Interner, &substs)).collect::<Vec<_>>();\n         if !(predicates.is_empty() || f.omit_verbose_types()) {\n             write_bounds_like_dyn_trait_with_prefix(\":\", &predicates, f)?;\n         }"}, {"sha": "0038219818b6fb5d4c8961dbfbadfb295a5232e1", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c91b5376835ab54cd4bca02953625ef1f1fabeba/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c91b5376835ab54cd4bca02953625ef1f1fabeba/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=c91b5376835ab54cd4bca02953625ef1f1fabeba", "patch": "@@ -516,7 +516,7 @@ impl Field {\n             VariantDef::Variant(it) => it.parent.id.into(),\n         };\n         let substs = TyBuilder::type_params_subst(db, generic_def_id);\n-        let ty = db.field_types(var_id)[self.id].clone().subst(&substs);\n+        let ty = db.field_types(var_id)[self.id].clone().substitute(&Interner, &substs);\n         Type::new(db, self.parent.module(db).id.krate(), var_id, ty)\n     }\n \n@@ -702,7 +702,7 @@ impl_from!(Struct, Union, Enum for Adt);\n impl Adt {\n     pub fn has_non_default_type_params(self, db: &dyn HirDatabase) -> bool {\n         let subst = db.generic_defaults(self.into());\n-        subst.iter().any(|ty| ty.value.is_unknown())\n+        subst.iter().any(|ty| ty.skip_binders().is_unknown())\n     }\n \n     /// Turns this ADT into a type. Any type parameters of the ADT will be\n@@ -1089,7 +1089,7 @@ pub struct TypeAlias {\n impl TypeAlias {\n     pub fn has_non_default_type_params(self, db: &dyn HirDatabase) -> bool {\n         let subst = db.generic_defaults(self.id.into());\n-        subst.iter().any(|ty| ty.value.is_unknown())\n+        subst.iter().any(|ty| ty.skip_binders().is_unknown())\n     }\n \n     pub fn module(self, db: &dyn HirDatabase) -> Module {\n@@ -1503,7 +1503,7 @@ impl TypeParam {\n         let krate = self.id.parent.module(db.upcast()).krate();\n         let ty = params.get(local_idx)?.clone();\n         let subst = TyBuilder::type_params_subst(db, self.id.parent);\n-        let ty = ty.subst(&subst.prefix(local_idx));\n+        let ty = ty.substitute(&Interner, &subst.prefix(local_idx));\n         Some(Type::new_with_resolver_inner(db, krate, &resolver, ty))\n     }\n }\n@@ -1916,7 +1916,7 @@ impl Type {\n             .iter()\n             .map(|(local_id, ty)| {\n                 let def = Field { parent: variant_id.into(), id: local_id };\n-                let ty = ty.clone().subst(substs);\n+                let ty = ty.clone().substitute(&Interner, substs);\n                 (def, self.derived(ty))\n             })\n             .collect()"}, {"sha": "7955bf0b52feb89a82a3a71c0801cf5b2797dae3", "filename": "crates/hir/src/semantics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c91b5376835ab54cd4bca02953625ef1f1fabeba/crates%2Fhir%2Fsrc%2Fsemantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c91b5376835ab54cd4bca02953625ef1f1fabeba/crates%2Fhir%2Fsrc%2Fsemantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsemantics.rs?ref=c91b5376835ab54cd4bca02953625ef1f1fabeba", "patch": "@@ -494,9 +494,9 @@ impl<'db> SemanticsImpl<'db> {\n     fn resolve_method_call_as_callable(&self, call: &ast::MethodCallExpr) -> Option<Callable> {\n         // FIXME: this erases Substs\n         let func = self.resolve_method_call(call)?;\n-        let ty = self.db.value_ty(func.into());\n+        let (ty, _) = self.db.value_ty(func.into()).into_value_and_skipped_binders();\n         let resolver = self.analyze(call.syntax()).resolver;\n-        let ty = Type::new_with_resolver(self.db, &resolver, ty.value)?;\n+        let ty = Type::new_with_resolver(self.db, &resolver, ty)?;\n         let mut res = ty.as_callable(self.db)?;\n         res.is_bound_method = true;\n         Some(res)"}, {"sha": "4ce1c20800b05edaa0032447494fd77fc5d9e0d4", "filename": "crates/hir/src/source_analyzer.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c91b5376835ab54cd4bca02953625ef1f1fabeba/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c91b5376835ab54cd4bca02953625ef1f1fabeba/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs?ref=c91b5376835ab54cd4bca02953625ef1f1fabeba", "patch": "@@ -20,7 +20,7 @@ use hir_def::{\n use hir_expand::{hygiene::Hygiene, name::AsName, HirFileId, InFile};\n use hir_ty::{\n     diagnostics::{record_literal_missing_fields, record_pattern_missing_fields},\n-    InferenceResult, Substitution, TyLoweringContext,\n+    InferenceResult, Interner, Substitution, TyLoweringContext,\n };\n use syntax::{\n     ast::{self, AstNode},\n@@ -339,7 +339,7 @@ impl SourceAnalyzer {\n             .into_iter()\n             .map(|local_id| {\n                 let field = FieldId { parent: variant, local_id };\n-                let ty = field_types[local_id].clone().subst(substs);\n+                let ty = field_types[local_id].clone().substitute(&Interner, substs);\n                 (field.into(), Type::new_with_resolver_inner(db, krate, &self.resolver, ty))\n             })\n             .collect()"}, {"sha": "9b2c6975a36df9063941ef79081b91e3d0cd1905", "filename": "crates/hir_ty/src/builder.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c91b5376835ab54cd4bca02953625ef1f1fabeba/crates%2Fhir_ty%2Fsrc%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c91b5376835ab54cd4bca02953625ef1f1fabeba/crates%2Fhir_ty%2Fsrc%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fbuilder.rs?ref=c91b5376835ab54cd4bca02953625ef1f1fabeba", "patch": "@@ -139,7 +139,8 @@ impl TyBuilder<hir_def::AdtId> {\n             } else {\n                 // each default can depend on the previous parameters\n                 let subst_so_far = Substitution::intern(self.vec.clone());\n-                self.vec.push(default_ty.clone().subst(&subst_so_far).cast(&Interner));\n+                self.vec\n+                    .push(default_ty.clone().substitute(&Interner, &subst_so_far).cast(&Interner));\n             }\n         }\n         self\n@@ -194,13 +195,13 @@ impl TyBuilder<TypeAliasId> {\n \n impl<T: TypeWalk + HasInterner<Interner = Interner>> TyBuilder<Binders<T>> {\n     fn subst_binders(b: Binders<T>) -> Self {\n-        let param_count = b.num_binders;\n+        let param_count = b.binders.len(&Interner);\n         TyBuilder::new(b, param_count)\n     }\n \n     pub fn build(self) -> T {\n         let (b, subst) = self.build_internal();\n-        b.subst(&subst)\n+        b.substitute(&Interner, &subst)\n     }\n }\n "}, {"sha": "db278d0db23df7511fec57f9d1e6f1680f9beb5a", "filename": "crates/hir_ty/src/diagnostics/expr.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c91b5376835ab54cd4bca02953625ef1f1fabeba/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c91b5376835ab54cd4bca02953625ef1f1fabeba/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fexpr.rs?ref=c91b5376835ab54cd4bca02953625ef1f1fabeba", "patch": "@@ -245,7 +245,8 @@ impl<'a, 'b> ExprValidator<'a, 'b> {\n                     Some(callee) => callee,\n                     None => return,\n                 };\n-                let sig = db.callable_item_signature(callee.into()).value;\n+                let sig =\n+                    db.callable_item_signature(callee.into()).into_value_and_skipped_binders().0;\n \n                 (sig, args)\n             }"}, {"sha": "f31e6b10876a5df1cd87b3b254a312410eb6fc90", "filename": "crates/hir_ty/src/display.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c91b5376835ab54cd4bca02953625ef1f1fabeba/crates%2Fhir_ty%2Fsrc%2Fdisplay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c91b5376835ab54cd4bca02953625ef1f1fabeba/crates%2Fhir_ty%2Fsrc%2Fdisplay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdisplay.rs?ref=c91b5376835ab54cd4bca02953625ef1f1fabeba", "patch": "@@ -352,8 +352,8 @@ impl HirDisplay for Ty {\n                             let data = (*datas)\n                                 .as_ref()\n                                 .map(|rpit| rpit.impl_traits[idx as usize].bounds.clone());\n-                            let bounds = data.subst(parameters);\n-                            bounds.value\n+                            let bounds = data.substitute(&Interner, parameters);\n+                            bounds.into_value_and_skipped_binders().0\n                         } else {\n                             Vec::new()\n                         }\n@@ -397,7 +397,7 @@ impl HirDisplay for Ty {\n             }\n             TyKind::FnDef(def, parameters) => {\n                 let def = from_chalk(f.db, *def);\n-                let sig = f.db.callable_item_signature(def).subst(parameters);\n+                let sig = f.db.callable_item_signature(def).substitute(&Interner, parameters);\n                 match def {\n                     CallableDefId::FunctionId(ff) => {\n                         write!(f, \"fn {}\", f.db.function_data(ff).name)?\n@@ -482,7 +482,7 @@ impl HirDisplay for Ty {\n                                         (_, Some(default_parameter)) => {\n                                             let actual_default = default_parameter\n                                                 .clone()\n-                                                .subst(&parameters.prefix(i));\n+                                                .substitute(&Interner, &parameters.prefix(i));\n                                             if parameter.assert_ty_ref(&Interner) != &actual_default\n                                             {\n                                                 default_from = i + 1;\n@@ -542,8 +542,8 @@ impl HirDisplay for Ty {\n                         let data = (*datas)\n                             .as_ref()\n                             .map(|rpit| rpit.impl_traits[idx as usize].bounds.clone());\n-                        let bounds = data.subst(&parameters);\n-                        write_bounds_like_dyn_trait_with_prefix(\"impl\", &bounds.value, f)?;\n+                        let bounds = data.substitute(&Interner, &parameters);\n+                        write_bounds_like_dyn_trait_with_prefix(\"impl\", bounds.skip_binders(), f)?;\n                         // FIXME: it would maybe be good to distinguish this from the alias type (when debug printing), and to show the substitution\n                     }\n                     ImplTraitId::AsyncBlockTypeImplTrait(..) => {\n@@ -595,7 +595,7 @@ impl HirDisplay for Ty {\n                         let bounds =\n                             f.db.generic_predicates(id.parent)\n                                 .into_iter()\n-                                .map(|pred| pred.clone().subst(&substs))\n+                                .map(|pred| pred.clone().substitute(&Interner, &substs))\n                                 .filter(|wc| match &wc.skip_binders() {\n                                     WhereClause::Implemented(tr) => {\n                                         tr.self_type_parameter(&Interner) == self\n@@ -629,8 +629,8 @@ impl HirDisplay for Ty {\n                         let data = (*datas)\n                             .as_ref()\n                             .map(|rpit| rpit.impl_traits[idx as usize].bounds.clone());\n-                        let bounds = data.subst(&opaque_ty.substitution);\n-                        write_bounds_like_dyn_trait_with_prefix(\"impl\", &bounds.value, f)?;\n+                        let bounds = data.substitute(&Interner, &opaque_ty.substitution);\n+                        write_bounds_like_dyn_trait_with_prefix(\"impl\", bounds.skip_binders(), f)?;\n                     }\n                     ImplTraitId::AsyncBlockTypeImplTrait(..) => {\n                         write!(f, \"{{async block}}\")?;"}, {"sha": "1c3faf5cb62da94638e54a0668769947917a965d", "filename": "crates/hir_ty/src/infer.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c91b5376835ab54cd4bca02953625ef1f1fabeba/crates%2Fhir_ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c91b5376835ab54cd4bca02953625ef1f1fabeba/crates%2Fhir_ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer.rs?ref=c91b5376835ab54cd4bca02953625ef1f1fabeba", "patch": "@@ -470,25 +470,25 @@ impl<'a> InferenceContext<'a> {\n             TypeNs::AdtId(AdtId::StructId(strukt)) => {\n                 let substs = ctx.substs_from_path(path, strukt.into(), true);\n                 let ty = self.db.ty(strukt.into());\n-                let ty = self.insert_type_vars(ty.subst(&substs));\n+                let ty = self.insert_type_vars(ty.substitute(&Interner, &substs));\n                 forbid_unresolved_segments((ty, Some(strukt.into())), unresolved)\n             }\n             TypeNs::AdtId(AdtId::UnionId(u)) => {\n                 let substs = ctx.substs_from_path(path, u.into(), true);\n                 let ty = self.db.ty(u.into());\n-                let ty = self.insert_type_vars(ty.subst(&substs));\n+                let ty = self.insert_type_vars(ty.substitute(&Interner, &substs));\n                 forbid_unresolved_segments((ty, Some(u.into())), unresolved)\n             }\n             TypeNs::EnumVariantId(var) => {\n                 let substs = ctx.substs_from_path(path, var.into(), true);\n                 let ty = self.db.ty(var.parent.into());\n-                let ty = self.insert_type_vars(ty.subst(&substs));\n+                let ty = self.insert_type_vars(ty.substitute(&Interner, &substs));\n                 forbid_unresolved_segments((ty, Some(var.into())), unresolved)\n             }\n             TypeNs::SelfType(impl_id) => {\n                 let generics = crate::utils::generics(self.db.upcast(), impl_id.into());\n                 let substs = generics.type_params_subst(self.db);\n-                let ty = self.db.impl_self_ty(impl_id).subst(&substs);\n+                let ty = self.db.impl_self_ty(impl_id).substitute(&Interner, &substs);\n                 match unresolved {\n                     None => {\n                         let variant = ty_variant(&ty);"}, {"sha": "6966d26e7f0e4df09102e8da45ac1cca3b013728", "filename": "crates/hir_ty/src/infer/expr.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c91b5376835ab54cd4bca02953625ef1f1fabeba/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c91b5376835ab54cd4bca02953625ef1f1fabeba/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs?ref=c91b5376835ab54cd4bca02953625ef1f1fabeba", "patch": "@@ -419,7 +419,7 @@ impl<'a> InferenceContext<'a> {\n                         self.result.record_field_resolutions.insert(field.expr, field_def);\n                     }\n                     let field_ty = field_def.map_or(self.err_ty(), |it| {\n-                        field_types[it.local_id].clone().subst(&substs)\n+                        field_types[it.local_id].clone().substitute(&Interner, &substs)\n                     });\n                     self.infer_expr_coerce(field.expr, &Expectation::has_type(field_ty));\n                 }\n@@ -462,7 +462,7 @@ impl<'a> InferenceContext<'a> {\n                                 Some(\n                                     self.db.field_types((*s).into())[field.local_id]\n                                         .clone()\n-                                        .subst(&parameters),\n+                                        .substitute(&Interner, &parameters),\n                                 )\n                             } else {\n                                 None\n@@ -476,7 +476,7 @@ impl<'a> InferenceContext<'a> {\n                                 Some(\n                                     self.db.field_types((*u).into())[field.local_id]\n                                         .clone()\n-                                        .subst(&parameters),\n+                                        .substitute(&Interner, &parameters),\n                                 )\n                             } else {\n                                 None\n@@ -849,10 +849,10 @@ impl<'a> InferenceContext<'a> {\n                 self.write_method_resolution(tgt_expr, func);\n                 (ty, self.db.value_ty(func.into()), Some(generics(self.db.upcast(), func.into())))\n             }\n-            None => (receiver_ty, Binders::new(0, self.err_ty()), None),\n+            None => (receiver_ty, Binders::empty(&Interner, self.err_ty()), None),\n         };\n         let substs = self.substs_for_method_call(def_generics, generic_args, &derefed_receiver_ty);\n-        let method_ty = method_ty.subst(&substs);\n+        let method_ty = method_ty.substitute(&Interner, &substs);\n         let method_ty = self.insert_type_vars(method_ty);\n         self.register_obligations_for_call(&method_ty);\n         let (expected_receiver_ty, param_tys, ret_ty) = match method_ty.callable_sig(self.db) {\n@@ -949,9 +949,11 @@ impl<'a> InferenceContext<'a> {\n             let def: CallableDefId = from_chalk(self.db, *fn_def);\n             let generic_predicates = self.db.generic_predicates(def.into());\n             for predicate in generic_predicates.iter() {\n-                let (predicate, binders) =\n-                    predicate.clone().subst(parameters).into_value_and_skipped_binders();\n-                always!(binders == 0); // quantified where clauses not yet handled\n+                let (predicate, binders) = predicate\n+                    .clone()\n+                    .substitute(&Interner, parameters)\n+                    .into_value_and_skipped_binders();\n+                always!(binders.len(&Interner) == 0); // quantified where clauses not yet handled\n                 self.push_obligation(predicate.cast(&Interner));\n             }\n             // add obligation for trait implementation, if this is a trait method"}, {"sha": "252ae914ab6cebe40f6994d66dbec66c8df58f84", "filename": "crates/hir_ty/src/infer/pat.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c91b5376835ab54cd4bca02953625ef1f1fabeba/crates%2Fhir_ty%2Fsrc%2Finfer%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c91b5376835ab54cd4bca02953625ef1f1fabeba/crates%2Fhir_ty%2Fsrc%2Finfer%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Fpat.rs?ref=c91b5376835ab54cd4bca02953625ef1f1fabeba", "patch": "@@ -49,7 +49,9 @@ impl<'a> InferenceContext<'a> {\n             let expected_ty = var_data\n                 .as_ref()\n                 .and_then(|d| d.field(&Name::new_tuple_field(i)))\n-                .map_or(self.err_ty(), |field| field_tys[field].clone().subst(&substs));\n+                .map_or(self.err_ty(), |field| {\n+                    field_tys[field].clone().substitute(&Interner, &substs)\n+                });\n             let expected_ty = self.normalize_associated_types_in(expected_ty);\n             self.infer_pat(subpat, &expected_ty, default_bm);\n         }\n@@ -83,8 +85,9 @@ impl<'a> InferenceContext<'a> {\n                 self.result.record_pat_field_resolutions.insert(subpat.pat, field_def);\n             }\n \n-            let expected_ty = matching_field\n-                .map_or(self.err_ty(), |field| field_tys[field].clone().subst(&substs));\n+            let expected_ty = matching_field.map_or(self.err_ty(), |field| {\n+                field_tys[field].clone().substitute(&Interner, &substs)\n+            });\n             let expected_ty = self.normalize_associated_types_in(expected_ty);\n             self.infer_pat(subpat.pat, &expected_ty, default_bm);\n         }"}, {"sha": "14f7051735c0334e4abfc3d6ae5924b58712ae8d", "filename": "crates/hir_ty/src/infer/path.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c91b5376835ab54cd4bca02953625ef1f1fabeba/crates%2Fhir_ty%2Fsrc%2Finfer%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c91b5376835ab54cd4bca02953625ef1f1fabeba/crates%2Fhir_ty%2Fsrc%2Finfer%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Fpath.rs?ref=c91b5376835ab54cd4bca02953625ef1f1fabeba", "patch": "@@ -81,9 +81,9 @@ impl<'a> InferenceContext<'a> {\n             ValueNs::ImplSelf(impl_id) => {\n                 let generics = crate::utils::generics(self.db.upcast(), impl_id.into());\n                 let substs = generics.type_params_subst(self.db);\n-                let ty = self.db.impl_self_ty(impl_id).subst(&substs);\n+                let ty = self.db.impl_self_ty(impl_id).substitute(&Interner, &substs);\n                 if let Some((AdtId::StructId(struct_id), substs)) = ty.as_adt() {\n-                    let ty = self.db.value_ty(struct_id.into()).subst(&substs);\n+                    let ty = self.db.value_ty(struct_id.into()).substitute(&Interner, &substs);\n                     return Some(ty);\n                 } else {\n                     // FIXME: diagnostic, invalid Self reference\n@@ -243,7 +243,8 @@ impl<'a> InferenceContext<'a> {\n                         let impl_substs = TyBuilder::subst_for_def(self.db, impl_id)\n                             .fill(iter::repeat_with(|| self.table.new_type_var()))\n                             .build();\n-                        let impl_self_ty = self.db.impl_self_ty(impl_id).subst(&impl_substs);\n+                        let impl_self_ty =\n+                            self.db.impl_self_ty(impl_id).substitute(&Interner, &impl_substs);\n                         self.unify(&impl_self_ty, &ty);\n                         Some(impl_substs)\n                     }"}, {"sha": "c90a16720d97f5d7f09d93bdb7a31dd8a84921ca", "filename": "crates/hir_ty/src/infer/unify.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/c91b5376835ab54cd4bca02953625ef1f1fabeba/crates%2Fhir_ty%2Fsrc%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c91b5376835ab54cd4bca02953625ef1f1fabeba/crates%2Fhir_ty%2Fsrc%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Funify.rs?ref=c91b5376835ab54cd4bca02953625ef1f1fabeba", "patch": "@@ -108,19 +108,22 @@ impl<'a, 'b> Canonicalizer<'a, 'b> {\n }\n \n impl<T> Canonicalized<T> {\n-    pub(super) fn decanonicalize_ty(&self, mut ty: Ty) -> Ty {\n-        ty.walk_mut_binders(\n+    pub(super) fn decanonicalize_ty(&self, ty: Ty) -> Ty {\n+        ty.fold_binders(\n             &mut |ty, binders| {\n-                if let &mut TyKind::BoundVar(bound) = ty.interned_mut() {\n+                if let TyKind::BoundVar(bound) = ty.kind(&Interner) {\n                     if bound.debruijn >= binders {\n                         let (v, k) = self.free_vars[bound.index];\n-                        *ty = TyKind::InferenceVar(v, k).intern(&Interner);\n+                        TyKind::InferenceVar(v, k).intern(&Interner)\n+                    } else {\n+                        ty\n                     }\n+                } else {\n+                    ty\n                 }\n             },\n             DebruijnIndex::INNERMOST,\n-        );\n-        ty\n+        )\n     }\n \n     pub(super) fn apply_solution(\n@@ -149,7 +152,7 @@ impl<T> Canonicalized<T> {\n             // eagerly replace projections in the type; we may be getting types\n             // e.g. from where clauses where this hasn't happened yet\n             let ty = ctx.normalize_associated_types_in(\n-                ty.assert_ty_ref(&Interner).clone().subst_bound_vars(&new_vars),\n+                new_vars.apply(ty.assert_ty_ref(&Interner).clone(), &Interner),\n             );\n             ctx.table.unify(&TyKind::InferenceVar(v, k).intern(&Interner), &ty);\n         }\n@@ -170,8 +173,8 @@ pub(crate) fn unify(tys: &Canonical<(Ty, Ty)>) -> Option<Substitution> {\n             // fallback to Unknown in the end (kind of hacky, as below)\n             .map(|_| table.new_type_var()),\n     );\n-    let ty1_with_vars = tys.value.0.clone().subst_bound_vars(&vars);\n-    let ty2_with_vars = tys.value.1.clone().subst_bound_vars(&vars);\n+    let ty1_with_vars = vars.apply(tys.value.0.clone(), &Interner);\n+    let ty2_with_vars = vars.apply(tys.value.1.clone(), &Interner);\n     if !table.unify(&ty1_with_vars, &ty2_with_vars) {\n         return None;\n     }"}, {"sha": "daf379ef8791e1d12218658a21b245e5af0474f1", "filename": "crates/hir_ty/src/lib.rs", "status": "modified", "additions": 30, "deletions": 45, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/c91b5376835ab54cd4bca02953625ef1f1fabeba/crates%2Fhir_ty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c91b5376835ab54cd4bca02953625ef1f1fabeba/crates%2Fhir_ty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Flib.rs?ref=c91b5376835ab54cd4bca02953625ef1f1fabeba", "patch": "@@ -66,6 +66,8 @@ pub type ClosureId = chalk_ir::ClosureId<Interner>;\n pub type OpaqueTyId = chalk_ir::OpaqueTyId<Interner>;\n pub type PlaceholderIndex = chalk_ir::PlaceholderIndex;\n \n+pub type VariableKind = chalk_ir::VariableKind<Interner>;\n+pub type VariableKinds = chalk_ir::VariableKinds<Interner>;\n pub type CanonicalVarKinds = chalk_ir::CanonicalVarKinds<Interner>;\n \n pub type ChalkTraitId = chalk_ir::TraitId<Interner>;\n@@ -118,52 +120,34 @@ pub fn param_idx(db: &dyn HirDatabase, id: TypeParamId) -> Option<usize> {\n }\n \n impl<T> Binders<T> {\n-    pub fn new(num_binders: usize, value: T) -> Self {\n-        Self { num_binders, value }\n-    }\n-\n     pub fn wrap_empty(value: T) -> Self\n     where\n         T: TypeWalk,\n     {\n-        Self { num_binders: 0, value: value.shift_bound_vars(DebruijnIndex::ONE) }\n-    }\n-\n-    pub fn as_ref(&self) -> Binders<&T> {\n-        Binders { num_binders: self.num_binders, value: &self.value }\n-    }\n-\n-    pub fn map<U>(self, f: impl FnOnce(T) -> U) -> Binders<U> {\n-        Binders { num_binders: self.num_binders, value: f(self.value) }\n-    }\n-\n-    pub fn filter_map<U>(self, f: impl FnOnce(T) -> Option<U>) -> Option<Binders<U>> {\n-        Some(Binders { num_binders: self.num_binders, value: f(self.value)? })\n-    }\n-\n-    pub fn skip_binders(&self) -> &T {\n-        &self.value\n-    }\n-\n-    pub fn into_value_and_skipped_binders(self) -> (T, usize) {\n-        (self.value, self.num_binders)\n-    }\n-}\n-\n-impl<T: Clone> Binders<&T> {\n-    pub fn cloned(&self) -> Binders<T> {\n-        Binders { num_binders: self.num_binders, value: self.value.clone() }\n+        Binders::empty(&Interner, value.shifted_in_from(DebruijnIndex::ONE))\n     }\n }\n \n impl<T: TypeWalk> Binders<T> {\n     /// Substitutes all variables.\n-    pub fn subst(self, subst: &Substitution) -> T {\n-        assert_eq!(subst.len(&Interner), self.num_binders);\n-        self.value.subst_bound_vars(subst)\n+    pub fn substitute(self, interner: &Interner, subst: &Substitution) -> T {\n+        let (value, binders) = self.into_value_and_skipped_binders();\n+        assert_eq!(subst.len(interner), binders.len(interner));\n+        value.subst_bound_vars(subst)\n     }\n }\n \n+pub fn make_only_type_binders<T>(num_vars: usize, value: T) -> Binders<T> {\n+    Binders::new(\n+        VariableKinds::from_iter(\n+            &Interner,\n+            std::iter::repeat(chalk_ir::VariableKind::Ty(chalk_ir::TyVariableKind::General))\n+                .take(num_vars),\n+        ),\n+        value,\n+    )\n+}\n+\n impl TraitRef {\n     pub fn self_type_parameter(&self, interner: &Interner) -> &Ty {\n         &self.substitution.at(interner, 0).assert_ty_ref(interner)\n@@ -225,7 +209,8 @@ impl CallableSig {\n             params_and_return: fn_ptr\n                 .substs\n                 .clone()\n-                .shift_bound_vars_out(DebruijnIndex::ONE)\n+                .shifted_out_to(DebruijnIndex::ONE)\n+                .expect(\"unexpected lifetime vars in fn ptr\")\n                 .interned()\n                 .iter()\n                 .map(|arg| arg.assert_ty_ref(&Interner).clone())\n@@ -334,12 +319,12 @@ impl Ty {\n     /// If this is a `dyn Trait` type, this returns the `Trait` part.\n     fn dyn_trait_ref(&self) -> Option<&TraitRef> {\n         match self.kind(&Interner) {\n-            TyKind::Dyn(dyn_ty) => {\n-                dyn_ty.bounds.value.interned().get(0).and_then(|b| match b.skip_binders() {\n+            TyKind::Dyn(dyn_ty) => dyn_ty.bounds.skip_binders().interned().get(0).and_then(|b| {\n+                match b.skip_binders() {\n                     WhereClause::Implemented(trait_ref) => Some(trait_ref),\n                     _ => None,\n-                })\n-            }\n+                }\n+            }),\n             _ => None,\n         }\n     }\n@@ -378,7 +363,7 @@ impl Ty {\n             TyKind::FnDef(def, parameters) => {\n                 let callable_def = db.lookup_intern_callable_def((*def).into());\n                 let sig = db.callable_item_signature(callable_def);\n-                Some(sig.subst(&parameters))\n+                Some(sig.substitute(&Interner, &parameters))\n             }\n             TyKind::Closure(.., substs) => {\n                 let sig_param = substs.at(&Interner, 0).assert_ty_ref(&Interner);\n@@ -429,8 +414,8 @@ impl Ty {\n                             // This is only used by type walking.\n                             // Parameters will be walked outside, and projection predicate is not used.\n                             // So just provide the Future trait.\n-                            let impl_bound = Binders::new(\n-                                0,\n+                            let impl_bound = Binders::empty(\n+                                &Interner,\n                                 WhereClause::Implemented(TraitRef {\n                                     trait_id: to_chalk_trait_id(future_trait),\n                                     substitution: Substitution::empty(&Interner),\n@@ -452,14 +437,14 @@ impl Ty {\n                             let data = (*it)\n                                 .as_ref()\n                                 .map(|rpit| rpit.impl_traits[idx as usize].bounds.clone());\n-                            data.subst(&opaque_ty.substitution)\n+                            data.substitute(&Interner, &opaque_ty.substitution)\n                         })\n                     }\n                     // It always has an parameter for Future::Output type.\n                     ImplTraitId::AsyncBlockTypeImplTrait(..) => unreachable!(),\n                 };\n \n-                predicates.map(|it| it.value)\n+                predicates.map(|it| it.into_value_and_skipped_binders().0)\n             }\n             TyKind::Placeholder(idx) => {\n                 let id = from_placeholder_idx(db, *idx);\n@@ -471,7 +456,7 @@ impl Ty {\n                         let predicates = db\n                             .generic_predicates(id.parent)\n                             .into_iter()\n-                            .map(|pred| pred.clone().subst(&substs))\n+                            .map(|pred| pred.clone().substitute(&Interner, &substs))\n                             .filter(|wc| match &wc.skip_binders() {\n                                 WhereClause::Implemented(tr) => {\n                                     tr.self_type_parameter(&Interner) == self"}, {"sha": "48c26f471f1f1c3fe9c6dcfdca4a098bc4814824", "filename": "crates/hir_ty/src/lower.rs", "status": "modified", "additions": 70, "deletions": 65, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/c91b5376835ab54cd4bca02953625ef1f1fabeba/crates%2Fhir_ty%2Fsrc%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c91b5376835ab54cd4bca02953625ef1f1fabeba/crates%2Fhir_ty%2Fsrc%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Flower.rs?ref=c91b5376835ab54cd4bca02953625ef1f1fabeba", "patch": "@@ -31,7 +31,7 @@ use crate::{\n     traits::chalk::{Interner, ToChalk},\n     utils::{\n         all_super_trait_refs, associated_type_by_name_including_super_traits, generics,\n-        variant_data,\n+        variant_data, Generics,\n     },\n     AliasEq, AliasTy, Binders, BoundVar, CallableSig, DebruijnIndex, DynTy, FnPointer, FnSig,\n     ImplTraitId, OpaqueTy, PolyFnSig, ProjectionTy, QuantifiedWhereClause, QuantifiedWhereClauses,\n@@ -196,7 +196,7 @@ impl<'a> TyLoweringContext<'a> {\n                         bounds.iter().flat_map(|b| ctx.lower_type_bound(b, self_ty.clone(), false)),\n                     )\n                 });\n-                let bounds = Binders::new(1, bounds);\n+                let bounds = crate::make_only_type_binders(1, bounds);\n                 TyKind::Dyn(DynTy { bounds }).intern(&Interner)\n             }\n             TypeRef::ImplTrait(bounds) => {\n@@ -209,9 +209,9 @@ impl<'a> TyLoweringContext<'a> {\n                         // this dance is to make sure the data is in the right\n                         // place even if we encounter more opaque types while\n                         // lowering the bounds\n-                        self.opaque_type_data\n-                            .borrow_mut()\n-                            .push(ReturnTypeImplTrait { bounds: Binders::new(1, Vec::new()) });\n+                        self.opaque_type_data.borrow_mut().push(ReturnTypeImplTrait {\n+                            bounds: crate::make_only_type_binders(1, Vec::new()),\n+                        });\n                         // We don't want to lower the bounds inside the binders\n                         // we're currently in, because they don't end up inside\n                         // those binders. E.g. when we have `impl Trait<impl\n@@ -380,7 +380,7 @@ impl<'a> TyLoweringContext<'a> {\n                     TyKind::Error.intern(&Interner)\n                 } else {\n                     let dyn_ty = DynTy {\n-                        bounds: Binders::new(\n+                        bounds: crate::make_only_type_binders(\n                             1,\n                             QuantifiedWhereClauses::from_iter(\n                                 &Interner,\n@@ -414,15 +414,15 @@ impl<'a> TyLoweringContext<'a> {\n                     TypeParamLoweringMode::Placeholder => generics.type_params_subst(self.db),\n                     TypeParamLoweringMode::Variable => generics.bound_vars_subst(self.in_binders),\n                 };\n-                self.db.impl_self_ty(impl_id).subst(&substs)\n+                self.db.impl_self_ty(impl_id).substitute(&Interner, &substs)\n             }\n             TypeNs::AdtSelfType(adt) => {\n                 let generics = generics(self.db.upcast(), adt.into());\n                 let substs = match self.type_param_mode {\n                     TypeParamLoweringMode::Placeholder => generics.type_params_subst(self.db),\n                     TypeParamLoweringMode::Variable => generics.bound_vars_subst(self.in_binders),\n                 };\n-                self.db.ty(adt.into()).subst(&substs)\n+                self.db.ty(adt.into()).substitute(&Interner, &substs)\n             }\n \n             TypeNs::AdtId(it) => self.lower_path_inner(resolved_segment, it.into(), infer_args),\n@@ -477,13 +477,13 @@ impl<'a> TyLoweringContext<'a> {\n                                     ),\n                                 );\n                                 let s = generics.type_params_subst(self.db);\n-                                t.substitution.clone().subst_bound_vars(&s)\n+                                s.apply(t.substitution.clone(), &Interner)\n                             }\n                             TypeParamLoweringMode::Variable => t.substitution.clone(),\n                         };\n                         // We need to shift in the bound vars, since\n                         // associated_type_shorthand_candidates does not do that\n-                        let substs = substs.shift_bound_vars(self.in_binders);\n+                        let substs = substs.shifted_in_from(self.in_binders);\n                         // FIXME handle type parameters on the segment\n                         return Some(\n                             TyKind::Alias(AliasTy::Projection(ProjectionTy {\n@@ -516,7 +516,7 @@ impl<'a> TyLoweringContext<'a> {\n             TyDefId::TypeAliasId(it) => Some(it.into()),\n         };\n         let substs = self.substs_from_path_segment(segment, generic_def, infer_args, None);\n-        self.db.ty(typeable).subst(&substs)\n+        self.db.ty(typeable).substitute(&Interner, &substs)\n     }\n \n     /// Collect generic arguments from a path into a `Substs`. See also\n@@ -620,7 +620,7 @@ impl<'a> TyLoweringContext<'a> {\n                 for default_ty in defaults.iter().skip(substs.len()) {\n                     // each default can depend on the previous parameters\n                     let substs_so_far = Substitution::from_iter(&Interner, substs.clone());\n-                    substs.push(default_ty.clone().subst(&substs_so_far));\n+                    substs.push(default_ty.clone().substitute(&Interner, &substs_so_far));\n                 }\n             }\n         }\n@@ -787,7 +787,7 @@ impl<'a> TyLoweringContext<'a> {\n         let predicates = self.with_shifted_in(DebruijnIndex::ONE, |ctx| {\n             bounds.iter().flat_map(|b| ctx.lower_type_bound(b, self_ty.clone(), false)).collect()\n         });\n-        ReturnTypeImplTrait { bounds: Binders::new(1, predicates) }\n+        ReturnTypeImplTrait { bounds: crate::make_only_type_binders(1, predicates) }\n     }\n }\n \n@@ -831,17 +831,20 @@ pub fn associated_type_shorthand_candidates<R>(\n     };\n \n     match res {\n-        // FIXME: how to correctly handle higher-ranked bounds here?\n-        TypeNs::SelfType(impl_id) => {\n-            search(db.impl_trait(impl_id)?.value.shift_bound_vars_out(DebruijnIndex::ONE))\n-        }\n+        TypeNs::SelfType(impl_id) => search(\n+            // we're _in_ the impl -- the binders get added back later. Correct,\n+            // but it would be nice to make this more explicit\n+            db.impl_trait(impl_id)?.into_value_and_skipped_binders().0,\n+        ),\n         TypeNs::GenericParam(param_id) => {\n             let predicates = db.generic_predicates_for_param(param_id);\n-            let res = predicates.iter().find_map(|pred| match &pred.value.value {\n+            let res = predicates.iter().find_map(|pred| match pred.skip_binders().skip_binders() {\n                 // FIXME: how to correctly handle higher-ranked bounds here?\n-                WhereClause::Implemented(tr) => {\n-                    search(tr.clone().shift_bound_vars_out(DebruijnIndex::ONE))\n-                }\n+                WhereClause::Implemented(tr) => search(\n+                    tr.clone()\n+                        .shifted_out_to(DebruijnIndex::ONE)\n+                        .expect(\"FIXME unexpected higher-ranked trait bound\"),\n+                ),\n                 _ => None,\n             });\n             if let res @ Some(_) = res {\n@@ -881,7 +884,7 @@ pub(crate) fn field_types_query(\n     let ctx =\n         TyLoweringContext::new(db, &resolver).with_type_param_mode(TypeParamLoweringMode::Variable);\n     for (field_id, field_data) in var_data.fields().iter() {\n-        res.insert(field_id, Binders::new(generics.len(), ctx.lower_ty(&field_data.type_ref)))\n+        res.insert(field_id, make_binders(&generics, ctx.lower_ty(&field_data.type_ref)))\n     }\n     Arc::new(res)\n }\n@@ -915,9 +918,7 @@ pub(crate) fn generic_predicates_for_param_query(\n             },\n             WherePredicate::Lifetime { .. } => false,\n         })\n-        .flat_map(|pred| {\n-            ctx.lower_where_predicate(pred, true).map(|p| Binders::new(generics.len(), p))\n-        })\n+        .flat_map(|pred| ctx.lower_where_predicate(pred, true).map(|p| make_binders(&generics, p)))\n         .collect()\n }\n \n@@ -988,9 +989,7 @@ pub(crate) fn generic_predicates_query(\n     let generics = generics(db.upcast(), def);\n     resolver\n         .where_predicates_in_scope()\n-        .flat_map(|pred| {\n-            ctx.lower_where_predicate(pred, false).map(|p| Binders::new(generics.len(), p))\n-        })\n+        .flat_map(|pred| ctx.lower_where_predicate(pred, false).map(|p| make_binders(&generics, p)))\n         .collect()\n }\n \n@@ -1012,22 +1011,24 @@ pub(crate) fn generic_defaults_query(\n                 p.default.as_ref().map_or(TyKind::Error.intern(&Interner), |t| ctx.lower_ty(t));\n \n             // Each default can only refer to previous parameters.\n-            ty.walk_mut_binders(\n-                &mut |ty, binders| match ty.interned_mut() {\n+            ty = ty.fold_binders(\n+                &mut |ty, binders| match ty.kind(&Interner) {\n                     TyKind::BoundVar(BoundVar { debruijn, index }) if *debruijn == binders => {\n                         if *index >= idx {\n                             // type variable default referring to parameter coming\n                             // after it. This is forbidden (FIXME: report\n                             // diagnostic)\n-                            *ty = TyKind::Error.intern(&Interner);\n+                            TyKind::Error.intern(&Interner)\n+                        } else {\n+                            ty\n                         }\n                     }\n-                    _ => {}\n+                    _ => ty,\n                 },\n                 DebruijnIndex::INNERMOST,\n             );\n \n-            Binders::new(idx, ty)\n+            crate::make_only_type_binders(idx, ty)\n         })\n         .collect();\n \n@@ -1040,23 +1041,22 @@ fn fn_sig_for_fn(db: &dyn HirDatabase, def: FunctionId) -> PolyFnSig {\n     let ctx_params = TyLoweringContext::new(db, &resolver)\n         .with_impl_trait_mode(ImplTraitLoweringMode::Variable)\n         .with_type_param_mode(TypeParamLoweringMode::Variable);\n-    let params = data.params.iter().map(|tr| (&ctx_params).lower_ty(tr)).collect::<Vec<_>>();\n+    let params = data.params.iter().map(|tr| ctx_params.lower_ty(tr)).collect::<Vec<_>>();\n     let ctx_ret = TyLoweringContext::new(db, &resolver)\n         .with_impl_trait_mode(ImplTraitLoweringMode::Opaque)\n         .with_type_param_mode(TypeParamLoweringMode::Variable);\n-    let ret = (&ctx_ret).lower_ty(&data.ret_type);\n+    let ret = ctx_ret.lower_ty(&data.ret_type);\n     let generics = generics(db.upcast(), def.into());\n-    let num_binders = generics.len();\n-    Binders::new(num_binders, CallableSig::from_params_and_return(params, ret, data.is_varargs()))\n+    make_binders(&generics, CallableSig::from_params_and_return(params, ret, data.is_varargs()))\n }\n \n /// Build the declared type of a function. This should not need to look at the\n /// function body.\n fn type_for_fn(db: &dyn HirDatabase, def: FunctionId) -> Binders<Ty> {\n     let generics = generics(db.upcast(), def.into());\n     let substs = generics.bound_vars_subst(DebruijnIndex::INNERMOST);\n-    Binders::new(\n-        substs.len(&Interner),\n+    make_binders(\n+        &generics,\n         TyKind::FnDef(CallableDefId::FunctionId(def).to_chalk(db), substs).intern(&Interner),\n     )\n }\n@@ -1069,7 +1069,7 @@ fn type_for_const(db: &dyn HirDatabase, def: ConstId) -> Binders<Ty> {\n     let ctx =\n         TyLoweringContext::new(db, &resolver).with_type_param_mode(TypeParamLoweringMode::Variable);\n \n-    Binders::new(generics.len(), ctx.lower_ty(&data.type_ref))\n+    make_binders(&generics, ctx.lower_ty(&data.type_ref))\n }\n \n /// Build the declared type of a static.\n@@ -1078,7 +1078,7 @@ fn type_for_static(db: &dyn HirDatabase, def: StaticId) -> Binders<Ty> {\n     let resolver = def.resolver(db.upcast());\n     let ctx = TyLoweringContext::new(db, &resolver);\n \n-    Binders::new(0, ctx.lower_ty(&data.type_ref))\n+    Binders::empty(&Interner, ctx.lower_ty(&data.type_ref))\n }\n \n fn fn_sig_for_struct_constructor(db: &dyn HirDatabase, def: StructId) -> PolyFnSig {\n@@ -1088,8 +1088,8 @@ fn fn_sig_for_struct_constructor(db: &dyn HirDatabase, def: StructId) -> PolyFnS\n     let ctx =\n         TyLoweringContext::new(db, &resolver).with_type_param_mode(TypeParamLoweringMode::Variable);\n     let params = fields.iter().map(|(_, field)| ctx.lower_ty(&field.type_ref)).collect::<Vec<_>>();\n-    let ret = type_for_adt(db, def.into());\n-    Binders::new(ret.num_binders, CallableSig::from_params_and_return(params, ret.value, false))\n+    let (ret, binders) = type_for_adt(db, def.into()).into_value_and_skipped_binders();\n+    Binders::new(binders, CallableSig::from_params_and_return(params, ret, false))\n }\n \n /// Build the type of a tuple struct constructor.\n@@ -1100,8 +1100,8 @@ fn type_for_struct_constructor(db: &dyn HirDatabase, def: StructId) -> Binders<T\n     }\n     let generics = generics(db.upcast(), def.into());\n     let substs = generics.bound_vars_subst(DebruijnIndex::INNERMOST);\n-    Binders::new(\n-        substs.len(&Interner),\n+    make_binders(\n+        &generics,\n         TyKind::FnDef(CallableDefId::StructId(def).to_chalk(db), substs).intern(&Interner),\n     )\n }\n@@ -1114,8 +1114,8 @@ fn fn_sig_for_enum_variant_constructor(db: &dyn HirDatabase, def: EnumVariantId)\n     let ctx =\n         TyLoweringContext::new(db, &resolver).with_type_param_mode(TypeParamLoweringMode::Variable);\n     let params = fields.iter().map(|(_, field)| ctx.lower_ty(&field.type_ref)).collect::<Vec<_>>();\n-    let ret = type_for_adt(db, def.parent.into());\n-    Binders::new(ret.num_binders, CallableSig::from_params_and_return(params, ret.value, false))\n+    let (ret, binders) = type_for_adt(db, def.parent.into()).into_value_and_skipped_binders();\n+    Binders::new(binders, CallableSig::from_params_and_return(params, ret, false))\n }\n \n /// Build the type of a tuple enum variant constructor.\n@@ -1127,17 +1127,17 @@ fn type_for_enum_variant_constructor(db: &dyn HirDatabase, def: EnumVariantId) -\n     }\n     let generics = generics(db.upcast(), def.parent.into());\n     let substs = generics.bound_vars_subst(DebruijnIndex::INNERMOST);\n-    Binders::new(\n-        substs.len(&Interner),\n+    make_binders(\n+        &generics,\n         TyKind::FnDef(CallableDefId::EnumVariantId(def).to_chalk(db), substs).intern(&Interner),\n     )\n }\n \n fn type_for_adt(db: &dyn HirDatabase, adt: AdtId) -> Binders<Ty> {\n+    let generics = generics(db.upcast(), adt.into());\n     let b = TyBuilder::adt(db, adt);\n-    let num_binders = b.remaining();\n     let ty = b.fill_with_bound_vars(DebruijnIndex::INNERMOST, 0).build();\n-    Binders::new(num_binders, ty)\n+    make_binders(&generics, ty)\n }\n \n fn type_for_type_alias(db: &dyn HirDatabase, t: TypeAliasId) -> Binders<Ty> {\n@@ -1146,11 +1146,11 @@ fn type_for_type_alias(db: &dyn HirDatabase, t: TypeAliasId) -> Binders<Ty> {\n     let ctx =\n         TyLoweringContext::new(db, &resolver).with_type_param_mode(TypeParamLoweringMode::Variable);\n     if db.type_alias_data(t).is_extern {\n-        Binders::new(0, TyKind::Foreign(crate::to_foreign_def_id(t)).intern(&Interner))\n+        Binders::empty(&Interner, TyKind::Foreign(crate::to_foreign_def_id(t)).intern(&Interner))\n     } else {\n         let type_ref = &db.type_alias_data(t).type_ref;\n         let inner = ctx.lower_ty(type_ref.as_deref().unwrap_or(&TypeRef::Error));\n-        Binders::new(generics.len(), inner)\n+        make_binders(&generics, inner)\n     }\n }\n \n@@ -1209,19 +1209,21 @@ impl_from!(FunctionId, StructId, UnionId, EnumVariantId, ConstId, StaticId for V\n /// namespace.\n pub(crate) fn ty_query(db: &dyn HirDatabase, def: TyDefId) -> Binders<Ty> {\n     match def {\n-        TyDefId::BuiltinType(it) => Binders::new(0, TyBuilder::builtin(it)),\n+        TyDefId::BuiltinType(it) => Binders::empty(&Interner, TyBuilder::builtin(it)),\n         TyDefId::AdtId(it) => type_for_adt(db, it),\n         TyDefId::TypeAliasId(it) => type_for_type_alias(db, it),\n     }\n }\n \n pub(crate) fn ty_recover(db: &dyn HirDatabase, _cycle: &[String], def: &TyDefId) -> Binders<Ty> {\n-    let num_binders = match *def {\n-        TyDefId::BuiltinType(_) => 0,\n-        TyDefId::AdtId(it) => generics(db.upcast(), it.into()).len(),\n-        TyDefId::TypeAliasId(it) => generics(db.upcast(), it.into()).len(),\n+    let generics = match *def {\n+        TyDefId::BuiltinType(_) => {\n+            return Binders::empty(&Interner, TyKind::Error.intern(&Interner))\n+        }\n+        TyDefId::AdtId(it) => generics(db.upcast(), it.into()),\n+        TyDefId::TypeAliasId(it) => generics(db.upcast(), it.into()),\n     };\n-    Binders::new(num_binders, TyKind::Error.intern(&Interner))\n+    make_binders(&generics, TyKind::Error.intern(&Interner))\n }\n \n pub(crate) fn value_ty_query(db: &dyn HirDatabase, def: ValueTyDefId) -> Binders<Ty> {\n@@ -1241,7 +1243,7 @@ pub(crate) fn impl_self_ty_query(db: &dyn HirDatabase, impl_id: ImplId) -> Binde\n     let generics = generics(db.upcast(), impl_id.into());\n     let ctx =\n         TyLoweringContext::new(db, &resolver).with_type_param_mode(TypeParamLoweringMode::Variable);\n-    Binders::new(generics.len(), ctx.lower_ty(&impl_data.self_ty))\n+    make_binders(&generics, ctx.lower_ty(&impl_data.self_ty))\n }\n \n pub(crate) fn const_param_ty_query(db: &dyn HirDatabase, def: ConstParamId) -> Ty {\n@@ -1259,17 +1261,17 @@ pub(crate) fn impl_self_ty_recover(\n     impl_id: &ImplId,\n ) -> Binders<Ty> {\n     let generics = generics(db.upcast(), (*impl_id).into());\n-    Binders::new(generics.len(), TyKind::Error.intern(&Interner))\n+    make_binders(&generics, TyKind::Error.intern(&Interner))\n }\n \n pub(crate) fn impl_trait_query(db: &dyn HirDatabase, impl_id: ImplId) -> Option<Binders<TraitRef>> {\n     let impl_data = db.impl_data(impl_id);\n     let resolver = impl_id.resolver(db.upcast());\n     let ctx =\n         TyLoweringContext::new(db, &resolver).with_type_param_mode(TypeParamLoweringMode::Variable);\n-    let self_ty = db.impl_self_ty(impl_id);\n+    let (self_ty, binders) = db.impl_self_ty(impl_id).into_value_and_skipped_binders();\n     let target_trait = impl_data.target_trait.as_ref()?;\n-    Some(Binders::new(self_ty.num_binders, ctx.lower_trait_ref(target_trait, Some(self_ty.value))?))\n+    Some(Binders::new(binders, ctx.lower_trait_ref(target_trait, Some(self_ty))?))\n }\n \n pub(crate) fn return_type_impl_traits(\n@@ -1284,13 +1286,12 @@ pub(crate) fn return_type_impl_traits(\n         .with_type_param_mode(TypeParamLoweringMode::Variable);\n     let _ret = (&ctx_ret).lower_ty(&data.ret_type);\n     let generics = generics(db.upcast(), def.into());\n-    let num_binders = generics.len();\n     let return_type_impl_traits =\n         ReturnTypeImplTraits { impl_traits: ctx_ret.opaque_type_data.into_inner() };\n     if return_type_impl_traits.impl_traits.is_empty() {\n         None\n     } else {\n-        Some(Arc::new(Binders::new(num_binders, return_type_impl_traits)))\n+        Some(Arc::new(make_binders(&generics, return_type_impl_traits)))\n     }\n }\n \n@@ -1300,3 +1301,7 @@ pub(crate) fn lower_to_chalk_mutability(m: hir_def::type_ref::Mutability) -> Mut\n         hir_def::type_ref::Mutability::Mut => Mutability::Mut,\n     }\n }\n+\n+fn make_binders<T>(generics: &Generics, value: T) -> Binders<T> {\n+    crate::make_only_type_binders(generics.len(), value)\n+}"}, {"sha": "19a1fa793be4737459622cf8d2a79dc871f96684", "filename": "crates/hir_ty/src/method_resolution.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c91b5376835ab54cd4bca02953625ef1f1fabeba/crates%2Fhir_ty%2Fsrc%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c91b5376835ab54cd4bca02953625ef1f1fabeba/crates%2Fhir_ty%2Fsrc%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fmethod_resolution.rs?ref=c91b5376835ab54cd4bca02953625ef1f1fabeba", "patch": "@@ -102,11 +102,11 @@ impl TraitImpls {\n         for (_module_id, module_data) in crate_def_map.modules() {\n             for impl_id in module_data.scope.impls() {\n                 let target_trait = match db.impl_trait(impl_id) {\n-                    Some(tr) => tr.value.hir_trait_id(),\n+                    Some(tr) => tr.skip_binders().hir_trait_id(),\n                     None => continue,\n                 };\n                 let self_ty = db.impl_self_ty(impl_id);\n-                let self_ty_fp = TyFingerprint::for_impl(&self_ty.value);\n+                let self_ty_fp = TyFingerprint::for_impl(self_ty.skip_binders());\n                 impls\n                     .map\n                     .entry(target_trait)\n@@ -201,7 +201,7 @@ impl InherentImpls {\n                 }\n \n                 let self_ty = db.impl_self_ty(impl_id);\n-                if let Some(fp) = TyFingerprint::for_impl(&self_ty.value) {\n+                if let Some(fp) = TyFingerprint::for_impl(self_ty.skip_binders()) {\n                     map.entry(fp).or_default().push(impl_id);\n                 }\n             }\n@@ -712,7 +712,7 @@ pub(crate) fn inherent_impl_substs(\n     let vars = TyBuilder::subst_for_def(db, impl_id)\n         .fill_with_bound_vars(DebruijnIndex::INNERMOST, self_ty.binders.len(&Interner))\n         .build();\n-    let self_ty_with_vars = db.impl_self_ty(impl_id).subst(&vars);\n+    let self_ty_with_vars = db.impl_self_ty(impl_id).substitute(&Interner, &vars);\n     let mut kinds = self_ty.binders.interned().to_vec();\n     kinds.extend(\n         iter::repeat(chalk_ir::WithKind::new(\n@@ -774,7 +774,7 @@ fn transform_receiver_ty(\n         AssocContainerId::ModuleId(_) => unreachable!(),\n     };\n     let sig = db.callable_item_signature(function_id.into());\n-    Some(sig.value.params()[0].clone().subst_bound_vars(&substs))\n+    Some(sig.map(|s| s.params()[0].clone()).substitute(&Interner, &substs))\n }\n \n pub fn implements_trait("}, {"sha": "dff87ef70e45dd354bda26132a027503c7037e89", "filename": "crates/hir_ty/src/traits/chalk.rs", "status": "modified", "additions": 24, "deletions": 23, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/c91b5376835ab54cd4bca02953625ef1f1fabeba/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c91b5376835ab54cd4bca02953625ef1f1fabeba/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk.rs?ref=c91b5376835ab54cd4bca02953625ef1f1fabeba", "patch": "@@ -184,16 +184,21 @@ impl<'a> chalk_solve::RustIrDatabase<Interner> for ChalkContext<'a> {\n                     .db\n                     .return_type_impl_traits(func)\n                     .expect(\"impl trait id without impl traits\");\n-                let data = &datas.value.impl_traits[idx as usize];\n+                let (datas, binders) = (*datas).as_ref().into_value_and_skipped_binders();\n+                let data = &datas.impl_traits[idx as usize];\n                 let bound = OpaqueTyDatumBound {\n                     bounds: make_binders(\n-                        data.bounds.value.iter().cloned().map(|b| b.to_chalk(self.db)).collect(),\n+                        data.bounds\n+                            .skip_binders()\n+                            .iter()\n+                            .cloned()\n+                            .map(|b| b.to_chalk(self.db))\n+                            .collect(),\n                         1,\n                     ),\n                     where_clauses: make_binders(vec![], 0),\n                 };\n-                let num_vars = datas.num_binders;\n-                make_binders(bound, num_vars)\n+                chalk_ir::Binders::new(binders, bound)\n             }\n             crate::ImplTraitId::AsyncBlockTypeImplTrait(..) => {\n                 if let Some((future_trait, future_output)) = self\n@@ -535,7 +540,8 @@ fn impl_def_datum(\n         .impl_trait(impl_id)\n         // ImplIds for impls where the trait ref can't be resolved should never reach Chalk\n         .expect(\"invalid impl passed to Chalk\")\n-        .value;\n+        .into_value_and_skipped_binders()\n+        .0;\n     let impl_data = db.impl_data(impl_id);\n \n     let generic_params = generics(db.upcast(), impl_id.into());\n@@ -605,18 +611,22 @@ fn type_alias_associated_ty_value(\n         _ => panic!(\"assoc ty value should be in impl\"),\n     };\n \n-    let trait_ref = db.impl_trait(impl_id).expect(\"assoc ty value should not exist\").value; // we don't return any assoc ty values if the impl'd trait can't be resolved\n+    let trait_ref = db\n+        .impl_trait(impl_id)\n+        .expect(\"assoc ty value should not exist\")\n+        .into_value_and_skipped_binders()\n+        .0; // we don't return any assoc ty values if the impl'd trait can't be resolved\n \n     let assoc_ty = db\n         .trait_data(trait_ref.hir_trait_id())\n         .associated_type_by_name(&type_alias_data.name)\n         .expect(\"assoc ty value should not exist\"); // validated when building the impl data as well\n-    let ty = db.ty(type_alias.into());\n-    let value_bound = rust_ir::AssociatedTyValueBound { ty: ty.value.to_chalk(db) };\n+    let (ty, binders) = db.ty(type_alias.into()).into_value_and_skipped_binders();\n+    let value_bound = rust_ir::AssociatedTyValueBound { ty: ty.to_chalk(db) };\n     let value = rust_ir::AssociatedTyValue {\n         impl_id: impl_id.to_chalk(db),\n         associated_ty_id: to_assoc_type_id(assoc_ty),\n-        value: make_binders(value_bound, ty.num_binders),\n+        value: chalk_ir::Binders::new(binders, value_bound),\n     };\n     Arc::new(value)\n }\n@@ -628,20 +638,15 @@ pub(crate) fn fn_def_datum_query(\n ) -> Arc<FnDefDatum> {\n     let callable_def: CallableDefId = from_chalk(db, fn_def_id);\n     let generic_params = generics(db.upcast(), callable_def.into());\n-    let sig = db.callable_item_signature(callable_def);\n+    let (sig, binders) = db.callable_item_signature(callable_def).into_value_and_skipped_binders();\n     let bound_vars = generic_params.bound_vars_subst(DebruijnIndex::INNERMOST);\n     let where_clauses = convert_where_clauses(db, callable_def.into(), &bound_vars);\n     let bound = rust_ir::FnDefDatumBound {\n         // Note: Chalk doesn't actually use this information yet as far as I am aware, but we provide it anyway\n         inputs_and_output: make_binders(\n             rust_ir::FnDefInputsAndOutputDatum {\n-                argument_types: sig\n-                    .value\n-                    .params()\n-                    .iter()\n-                    .map(|ty| ty.clone().to_chalk(db))\n-                    .collect(),\n-                return_type: sig.value.ret().clone().to_chalk(db),\n+                argument_types: sig.params().iter().map(|ty| ty.clone().to_chalk(db)).collect(),\n+                return_type: sig.ret().clone().to_chalk(db),\n             }\n             .shifted_in(&Interner),\n             0,\n@@ -650,12 +655,8 @@ pub(crate) fn fn_def_datum_query(\n     };\n     let datum = FnDefDatum {\n         id: fn_def_id,\n-        sig: chalk_ir::FnSig {\n-            abi: (),\n-            safety: chalk_ir::Safety::Safe,\n-            variadic: sig.value.is_varargs,\n-        },\n-        binders: make_binders(bound, sig.num_binders),\n+        sig: chalk_ir::FnSig { abi: (), safety: chalk_ir::Safety::Safe, variadic: sig.is_varargs },\n+        binders: chalk_ir::Binders::new(binders, bound),\n     };\n     Arc::new(datum)\n }"}, {"sha": "c3b148cab7c49cee769511d5b23644f2623d59a8", "filename": "crates/hir_ty/src/traits/chalk/mapping.rs", "status": "modified", "additions": 16, "deletions": 17, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/c91b5376835ab54cd4bca02953625ef1f1fabeba/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk%2Fmapping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c91b5376835ab54cd4bca02953625ef1f1fabeba/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk%2Fmapping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk%2Fmapping.rs?ref=c91b5376835ab54cd4bca02953625ef1f1fabeba", "patch": "@@ -93,12 +93,13 @@ impl ToChalk for Ty {\n             TyKind::BoundVar(idx) => chalk_ir::TyKind::BoundVar(idx).intern(&Interner),\n             TyKind::InferenceVar(..) => panic!(\"uncanonicalized infer ty\"),\n             TyKind::Dyn(dyn_ty) => {\n+                let (bounds, binders) = dyn_ty.bounds.into_value_and_skipped_binders();\n                 let where_clauses = chalk_ir::QuantifiedWhereClauses::from_iter(\n                     &Interner,\n-                    dyn_ty.bounds.value.interned().iter().cloned().map(|p| p.to_chalk(db)),\n+                    bounds.interned().iter().cloned().map(|p| p.to_chalk(db)),\n                 );\n                 let bounded_ty = chalk_ir::DynTy {\n-                    bounds: make_binders(where_clauses, 1),\n+                    bounds: chalk_ir::Binders::new(binders, where_clauses),\n                     lifetime: LifetimeData::Static.intern(&Interner),\n                 };\n                 chalk_ir::TyKind::Dyn(bounded_ty).intern(&Interner)\n@@ -148,7 +149,7 @@ impl ToChalk for Ty {\n                     .map(|c| from_chalk(db, c.clone()));\n                 TyKind::Dyn(crate::DynTy {\n                     bounds: crate::Binders::new(\n-                        1,\n+                        where_clauses.bounds.binders.clone(),\n                         crate::QuantifiedWhereClauses::from_iter(&Interner, bounds),\n                     ),\n                 })\n@@ -486,19 +487,13 @@ where\n     type Chalk = chalk_ir::Binders<T::Chalk>;\n \n     fn to_chalk(self, db: &dyn HirDatabase) -> chalk_ir::Binders<T::Chalk> {\n-        chalk_ir::Binders::new(\n-            chalk_ir::VariableKinds::from_iter(\n-                &Interner,\n-                std::iter::repeat(chalk_ir::VariableKind::Ty(chalk_ir::TyVariableKind::General))\n-                    .take(self.num_binders),\n-            ),\n-            self.value.to_chalk(db),\n-        )\n+        let (value, binders) = self.into_value_and_skipped_binders();\n+        chalk_ir::Binders::new(binders, value.to_chalk(db))\n     }\n \n     fn from_chalk(db: &dyn HirDatabase, binders: chalk_ir::Binders<T::Chalk>) -> crate::Binders<T> {\n         let (v, b) = binders.into_value_and_skipped_binders();\n-        crate::Binders::new(b.len(&Interner), from_chalk(db, v))\n+        crate::Binders::new(b, from_chalk(db, v))\n     }\n }\n \n@@ -524,7 +519,7 @@ pub(super) fn convert_where_clauses(\n     let generic_predicates = db.generic_predicates(def);\n     let mut result = Vec::with_capacity(generic_predicates.len());\n     for pred in generic_predicates.iter() {\n-        result.push(pred.clone().subst(substs).to_chalk(db));\n+        result.push(pred.clone().substitute(&Interner, substs).to_chalk(db));\n     }\n     result\n }\n@@ -536,8 +531,9 @@ pub(super) fn generic_predicate_to_inline_bound(\n ) -> Option<chalk_ir::Binders<rust_ir::InlineBound<Interner>>> {\n     // An InlineBound is like a GenericPredicate, except the self type is left out.\n     // We don't have a special type for this, but Chalk does.\n-    let self_ty_shifted_in = self_ty.clone().shift_bound_vars(DebruijnIndex::ONE);\n-    match &pred.value {\n+    let self_ty_shifted_in = self_ty.clone().shifted_in_from(DebruijnIndex::ONE);\n+    let (pred, binders) = pred.as_ref().into_value_and_skipped_binders();\n+    match pred {\n         WhereClause::Implemented(trait_ref) => {\n             if trait_ref.self_type_parameter(&Interner) != &self_ty_shifted_in {\n                 // we can only convert predicates back to type bounds if they\n@@ -549,7 +545,7 @@ pub(super) fn generic_predicate_to_inline_bound(\n                 .map(|ty| ty.clone().to_chalk(db).cast(&Interner))\n                 .collect();\n             let trait_bound = rust_ir::TraitBound { trait_id: trait_ref.trait_id, args_no_self };\n-            Some(make_binders(rust_ir::InlineBound::TraitBound(trait_bound), pred.num_binders))\n+            Some(chalk_ir::Binders::new(binders, rust_ir::InlineBound::TraitBound(trait_bound)))\n         }\n         WhereClause::AliasEq(AliasEq { alias: AliasTy::Projection(projection_ty), ty }) => {\n             if projection_ty.self_type_parameter(&Interner) != &self_ty_shifted_in {\n@@ -566,7 +562,10 @@ pub(super) fn generic_predicate_to_inline_bound(\n                 associated_ty_id: projection_ty.associated_ty_id,\n                 parameters: Vec::new(), // FIXME we don't support generic associated types yet\n             };\n-            Some(make_binders(rust_ir::InlineBound::AliasEqBound(alias_eq_bound), pred.num_binders))\n+            Some(chalk_ir::Binders::new(\n+                binders,\n+                rust_ir::InlineBound::AliasEqBound(alias_eq_bound),\n+            ))\n         }\n         _ => None,\n     }"}, {"sha": "46c705a76f71e1a0c58232c31c55c0ac9ebf9409", "filename": "crates/hir_ty/src/types.rs", "status": "modified", "additions": 64, "deletions": 5, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/c91b5376835ab54cd4bca02953625ef1f1fabeba/crates%2Fhir_ty%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c91b5376835ab54cd4bca02953625ef1f1fabeba/crates%2Fhir_ty%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftypes.rs?ref=c91b5376835ab54cd4bca02953625ef1f1fabeba", "patch": "@@ -12,7 +12,7 @@ use smallvec::SmallVec;\n \n use crate::{\n     AssocTypeId, CanonicalVarKinds, ChalkTraitId, ClosureId, FnDefId, FnSig, ForeignDefId,\n-    InferenceVar, Interner, OpaqueTyId, PlaceholderIndex,\n+    InferenceVar, Interner, OpaqueTyId, PlaceholderIndex, TypeWalk, VariableKinds,\n };\n \n #[derive(Clone, PartialEq, Eq, Debug, Hash)]\n@@ -286,7 +286,11 @@ impl Substitution {\n         Substitution(elements.into_iter().casted(interner).collect())\n     }\n \n-    // We can hopefully add this to Chalk\n+    pub fn apply<T: TypeWalk>(&self, value: T, _interner: &Interner) -> T {\n+        value.subst_bound_vars(self)\n+    }\n+\n+    // Temporary helper functions, to be removed\n     pub fn intern(interned: SmallVec<[GenericArg; 2]>) -> Substitution {\n         Substitution(interned)\n     }\n@@ -296,10 +300,65 @@ impl Substitution {\n     }\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash)]\n+#[derive(Clone, PartialEq, Eq, Hash)]\n pub struct Binders<T> {\n-    pub num_binders: usize,\n-    pub value: T,\n+    /// The binders that quantify over the value.\n+    pub binders: VariableKinds,\n+    value: T,\n+}\n+\n+impl<T> Binders<T> {\n+    pub fn new(binders: VariableKinds, value: T) -> Self {\n+        Self { binders, value }\n+    }\n+\n+    pub fn empty(_interner: &Interner, value: T) -> Self {\n+        crate::make_only_type_binders(0, value)\n+    }\n+\n+    pub fn as_ref(&self) -> Binders<&T> {\n+        Binders { binders: self.binders.clone(), value: &self.value }\n+    }\n+\n+    pub fn map<U>(self, f: impl FnOnce(T) -> U) -> Binders<U> {\n+        Binders { binders: self.binders, value: f(self.value) }\n+    }\n+\n+    pub fn filter_map<U>(self, f: impl FnOnce(T) -> Option<U>) -> Option<Binders<U>> {\n+        Some(Binders { binders: self.binders, value: f(self.value)? })\n+    }\n+\n+    pub fn skip_binders(&self) -> &T {\n+        &self.value\n+    }\n+\n+    pub fn into_value_and_skipped_binders(self) -> (T, VariableKinds) {\n+        (self.value, self.binders)\n+    }\n+\n+    /// Returns the number of binders.\n+    pub fn len(&self, interner: &Interner) -> usize {\n+        self.binders.len(interner)\n+    }\n+\n+    // Temporary helper function, to be removed\n+    pub fn skip_binders_mut(&mut self) -> &mut T {\n+        &mut self.value\n+    }\n+}\n+\n+impl<T: Clone> Binders<&T> {\n+    pub fn cloned(&self) -> Binders<T> {\n+        Binders::new(self.binders.clone(), self.value.clone())\n+    }\n+}\n+\n+impl<T: std::fmt::Debug> std::fmt::Debug for Binders<T> {\n+    fn fmt(&self, fmt: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {\n+        let Binders { ref binders, ref value } = *self;\n+        write!(fmt, \"for{:?} \", binders.inner_debug(&Interner))?;\n+        std::fmt::Debug::fmt(value, fmt)\n+    }\n }\n \n /// A trait with type parameters. This includes the `Self`, so this represents a concrete type implementing the trait."}, {"sha": "d11708299d22189af6bffd0bd1a313e5fc196b5b", "filename": "crates/hir_ty/src/utils.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c91b5376835ab54cd4bca02953625ef1f1fabeba/crates%2Fhir_ty%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c91b5376835ab54cd4bca02953625ef1f1fabeba/crates%2Fhir_ty%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Futils.rs?ref=c91b5376835ab54cd4bca02953625ef1f1fabeba", "patch": "@@ -66,13 +66,15 @@ fn direct_super_trait_refs(db: &dyn HirDatabase, trait_ref: &TraitRef) -> Vec<Tr\n         .filter_map(|pred| {\n             pred.as_ref().filter_map(|pred| match pred.skip_binders() {\n                 // FIXME: how to correctly handle higher-ranked bounds here?\n-                WhereClause::Implemented(tr) => {\n-                    Some(tr.clone().shift_bound_vars_out(DebruijnIndex::ONE))\n-                }\n+                WhereClause::Implemented(tr) => Some(\n+                    tr.clone()\n+                        .shifted_out_to(DebruijnIndex::ONE)\n+                        .expect(\"FIXME unexpected higher-ranked trait bound\"),\n+                ),\n                 _ => None,\n             })\n         })\n-        .map(|pred| pred.subst(&trait_ref.substitution))\n+        .map(|pred| pred.substitute(&Interner, &trait_ref.substitution))\n         .collect()\n }\n \n@@ -103,6 +105,8 @@ pub(super) fn all_super_traits(db: &dyn DefDatabase, trait_: TraitId) -> Vec<Tra\n /// we have `Self: Trait<u32, i32>` and `Trait<T, U>: OtherTrait<U>` we'll get\n /// `Self: OtherTrait<i32>`.\n pub(super) fn all_super_trait_refs(db: &dyn HirDatabase, trait_ref: TraitRef) -> Vec<TraitRef> {\n+    // FIXME: replace by Chalk's `super_traits`, maybe make this a query\n+\n     // we need to take care a bit here to avoid infinite loops in case of cycles\n     // (i.e. if we have `trait A: B; trait B: A;`)\n     let mut result = vec![trait_ref];"}, {"sha": "b85e6ab4d269109d25bf72086118567ea0bdbedc", "filename": "crates/hir_ty/src/walk.rs", "status": "modified", "additions": 16, "deletions": 14, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/c91b5376835ab54cd4bca02953625ef1f1fabeba/crates%2Fhir_ty%2Fsrc%2Fwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c91b5376835ab54cd4bca02953625ef1f1fabeba/crates%2Fhir_ty%2Fsrc%2Fwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fwalk.rs?ref=c91b5376835ab54cd4bca02953625ef1f1fabeba", "patch": "@@ -82,7 +82,7 @@ pub trait TypeWalk {\n                         *ty = substs.interned()[bound.index]\n                             .assert_ty_ref(&Interner)\n                             .clone()\n-                            .shift_bound_vars(binders);\n+                            .shifted_in_from(binders);\n                     }\n                 }\n             },\n@@ -92,7 +92,7 @@ pub trait TypeWalk {\n     }\n \n     /// Shifts up debruijn indices of `TyKind::Bound` vars by `n`.\n-    fn shift_bound_vars(self, n: DebruijnIndex) -> Self\n+    fn shifted_in_from(self, n: DebruijnIndex) -> Self\n     where\n         Self: Sized,\n     {\n@@ -108,20 +108,22 @@ pub trait TypeWalk {\n     }\n \n     /// Shifts debruijn indices of `TyKind::Bound` vars out (down) by `n`.\n-    fn shift_bound_vars_out(self, n: DebruijnIndex) -> Self\n+    fn shifted_out_to(self, n: DebruijnIndex) -> Option<Self>\n     where\n         Self: Sized + std::fmt::Debug,\n     {\n-        self.fold_binders(\n-            &mut |ty, binders| match ty.kind(&Interner) {\n-                TyKind::BoundVar(bound) if bound.debruijn >= binders => {\n-                    TyKind::BoundVar(bound.shifted_out_to(n).unwrap_or(bound.clone()))\n-                        .intern(&Interner)\n+        Some(self.fold_binders(\n+            &mut |ty, binders| {\n+                match ty.kind(&Interner) {\n+                    TyKind::BoundVar(bound) if bound.debruijn >= binders => {\n+                        TyKind::BoundVar(bound.shifted_out_to(n).unwrap_or(bound.clone()))\n+                            .intern(&Interner)\n+                    }\n+                    _ => ty,\n                 }\n-                _ => ty,\n             },\n             DebruijnIndex::INNERMOST,\n-        )\n+        ))\n     }\n }\n \n@@ -139,7 +141,7 @@ impl TypeWalk for Ty {\n                 }\n             }\n             TyKind::Dyn(dyn_ty) => {\n-                for p in dyn_ty.bounds.value.interned().iter() {\n+                for p in dyn_ty.bounds.skip_binders().interned().iter() {\n                     p.walk(f);\n                 }\n             }\n@@ -167,7 +169,7 @@ impl TypeWalk for Ty {\n                 p_ty.substitution.walk_mut_binders(f, binders);\n             }\n             TyKind::Dyn(dyn_ty) => {\n-                for p in make_mut_slice(dyn_ty.bounds.value.interned_mut()) {\n+                for p in make_mut_slice(dyn_ty.bounds.skip_binders_mut().interned_mut()) {\n                     p.walk_mut_binders(f, binders.shifted_in());\n                 }\n             }\n@@ -294,15 +296,15 @@ impl TypeWalk for Substitution {\n \n impl<T: TypeWalk> TypeWalk for Binders<T> {\n     fn walk(&self, f: &mut impl FnMut(&Ty)) {\n-        self.value.walk(f);\n+        self.skip_binders().walk(f);\n     }\n \n     fn walk_mut_binders(\n         &mut self,\n         f: &mut impl FnMut(&mut Ty, DebruijnIndex),\n         binders: DebruijnIndex,\n     ) {\n-        self.value.walk_mut_binders(f, binders.shifted_in())\n+        self.skip_binders_mut().walk_mut_binders(f, binders.shifted_in())\n     }\n }\n "}]}