{"sha": "52249e357d38c1133cca16e6e17d1c1b452ba52e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUyMjQ5ZTM1N2QzOGMxMTMzY2NhMTZlNmUxN2QxYzFiNDUyYmE1MmU=", "commit": {"author": {"name": "Jake Goulding", "email": "jake.goulding@gmail.com", "date": "2018-05-19T17:58:16Z"}, "committer": {"name": "Jake Goulding", "email": "jake.goulding@gmail.com", "date": "2018-05-20T01:10:24Z"}, "message": "UnsafeCell doc typos and minor flow improvements", "tree": {"sha": "7315f26021c11e8952d4d26bd8e629bf3ed59a8e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7315f26021c11e8952d4d26bd8e629bf3ed59a8e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/52249e357d38c1133cca16e6e17d1c1b452ba52e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/52249e357d38c1133cca16e6e17d1c1b452ba52e", "html_url": "https://github.com/rust-lang/rust/commit/52249e357d38c1133cca16e6e17d1c1b452ba52e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/52249e357d38c1133cca16e6e17d1c1b452ba52e/comments", "author": {"login": "shepmaster", "id": 174509, "node_id": "MDQ6VXNlcjE3NDUwOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/174509?v=4", "gravatar_id": "", "url": "https://api.github.com/users/shepmaster", "html_url": "https://github.com/shepmaster", "followers_url": "https://api.github.com/users/shepmaster/followers", "following_url": "https://api.github.com/users/shepmaster/following{/other_user}", "gists_url": "https://api.github.com/users/shepmaster/gists{/gist_id}", "starred_url": "https://api.github.com/users/shepmaster/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/shepmaster/subscriptions", "organizations_url": "https://api.github.com/users/shepmaster/orgs", "repos_url": "https://api.github.com/users/shepmaster/repos", "events_url": "https://api.github.com/users/shepmaster/events{/privacy}", "received_events_url": "https://api.github.com/users/shepmaster/received_events", "type": "User", "site_admin": false}, "committer": {"login": "shepmaster", "id": 174509, "node_id": "MDQ6VXNlcjE3NDUwOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/174509?v=4", "gravatar_id": "", "url": "https://api.github.com/users/shepmaster", "html_url": "https://github.com/shepmaster", "followers_url": "https://api.github.com/users/shepmaster/followers", "following_url": "https://api.github.com/users/shepmaster/following{/other_user}", "gists_url": "https://api.github.com/users/shepmaster/gists{/gist_id}", "starred_url": "https://api.github.com/users/shepmaster/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/shepmaster/subscriptions", "organizations_url": "https://api.github.com/users/shepmaster/orgs", "repos_url": "https://api.github.com/users/shepmaster/repos", "events_url": "https://api.github.com/users/shepmaster/events{/privacy}", "received_events_url": "https://api.github.com/users/shepmaster/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3ea24915894d49cb93eab52e65f1e4f0baa1bc32", "url": "https://api.github.com/repos/rust-lang/rust/commits/3ea24915894d49cb93eab52e65f1e4f0baa1bc32", "html_url": "https://github.com/rust-lang/rust/commit/3ea24915894d49cb93eab52e65f1e4f0baa1bc32"}], "stats": {"total": 27, "additions": 14, "deletions": 13}, "files": [{"sha": "9a46c6106db57b0b2c02974db64fac481cea3070", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/52249e357d38c1133cca16e6e17d1c1b452ba52e/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52249e357d38c1133cca16e6e17d1c1b452ba52e/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=52249e357d38c1133cca16e6e17d1c1b452ba52e", "patch": "@@ -1231,25 +1231,26 @@ impl<'a, T: ?Sized + fmt::Display> fmt::Display for RefMut<'a, T> {\n ///\n /// If you have a reference `&SomeStruct`, then normally in Rust all fields of `SomeStruct` are\n /// immutable. The compiler makes optimizations based on the knowledge that `&T` is not mutably\n-/// aliased or mutated, and that `&mut T` is unique. `UnsafeCel<T>` is the only core language\n+/// aliased or mutated, and that `&mut T` is unique. `UnsafeCell<T>` is the only core language\n /// feature to work around this restriction. All other types that allow internal mutability, such as\n-/// `Cell<T>` and `RefCell<T>` use `UnsafeCell` to wrap their internal data.\n+/// `Cell<T>` and `RefCell<T>`, use `UnsafeCell` to wrap their internal data.\n ///\n /// The `UnsafeCell` API itself is technically very simple: it gives you a raw pointer `*mut T` to\n /// its contents. It is up to _you_ as the abstraction designer to use that raw pointer correctly.\n ///\n /// The precise Rust aliasing rules are somewhat in flux, but the main points are not contentious:\n ///\n-/// - If you create a safe reference with lifetime `'a` (either a `&T` or `&mut T` reference) that\n-/// is accessible by safe code (for example, because you returned it), then you must not access\n-/// the data in any way that contradicts that reference for the remainder of `'a`. For example, that\n-/// means that if you take the `*mut T` from an `UnsafeCell<T>` and case it to an `&T`, then until\n-/// that reference's lifetime expires, the data in `T` must remain immutable (modulo any\n-/// `UnsafeCell` data found within `T`, of course). Similarly, if you create an `&mut T` reference\n-/// that is released to safe code, then you must not access the data within the `UnsafeCell` until\n-/// that reference expires.\n+/// - If you create a safe reference with lifetime `'a` (either a `&T` or `&mut T`\n+/// reference) that is accessible by safe code (for example, because you returned it),\n+/// then you must not access the data in any way that contradicts that reference for the\n+/// remainder of `'a`. For example, this means that if you take the `*mut T` from an\n+/// `UnsafeCell<T>` and cast it to an `&T`, then the data in `T` must remain immutable\n+/// (modulo any `UnsafeCell` data found within `T`, of course) until that reference's\n+/// lifetime expires. Similarly, if you create a `&mut T` reference that is released to\n+/// safe code, then you must not access the data within the `UnsafeCell` until that\n+/// reference expires.\n ///\n-/// - At all times, you must avoid data races, meaning that if multiple threads have access to\n+/// - At all times, you must avoid data races. If multiple threads have access to\n /// the same `UnsafeCell`, then any writes must have a proper happens-before relation to all other\n /// accesses (or use atomics).\n ///\n@@ -1259,10 +1260,10 @@ impl<'a, T: ?Sized + fmt::Display> fmt::Display for RefMut<'a, T> {\n /// 1. A `&T` reference can be released to safe code and there it can co-exit with other `&T`\n /// references, but not with a `&mut T`\n ///\n-/// 2. A `&mut T` reference may be released to safe code, provided neither other `&mut T` nor `&T`\n+/// 2. A `&mut T` reference may be released to safe code provided neither other `&mut T` nor `&T`\n /// co-exist with it. A `&mut T` must always be unique.\n ///\n-/// Note that while mutating or mutably aliasing the contents of an `& UnsafeCell<T>` is\n+/// Note that while mutating or mutably aliasing the contents of an `&UnsafeCell<T>` is\n /// okay (provided you enforce the invariants some other way), it is still undefined behavior\n /// to have multiple `&mut UnsafeCell<T>` aliases.\n ///"}]}