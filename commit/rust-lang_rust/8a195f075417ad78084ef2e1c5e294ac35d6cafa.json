{"sha": "8a195f075417ad78084ef2e1c5e294ac35d6cafa", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhhMTk1ZjA3NTQxN2FkNzgwODRlZjJlMWM1ZTI5NGFjMzVkNmNhZmE=", "commit": {"author": {"name": "Kang Seonghoon", "email": "public+git@mearie.org", "date": "2015-04-20T16:57:39Z"}, "committer": {"name": "Kang Seonghoon", "email": "public+git@mearie.org", "date": "2015-05-06T05:22:20Z"}, "message": "core: fixed typos and revised comments in flt2dec.", "tree": {"sha": "6e8f22bffd925b1ea00204010edaf2ff17b6a88a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6e8f22bffd925b1ea00204010edaf2ff17b6a88a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8a195f075417ad78084ef2e1c5e294ac35d6cafa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8a195f075417ad78084ef2e1c5e294ac35d6cafa", "html_url": "https://github.com/rust-lang/rust/commit/8a195f075417ad78084ef2e1c5e294ac35d6cafa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8a195f075417ad78084ef2e1c5e294ac35d6cafa/comments", "author": {"login": "lifthrasiir", "id": 323836, "node_id": "MDQ6VXNlcjMyMzgzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/323836?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lifthrasiir", "html_url": "https://github.com/lifthrasiir", "followers_url": "https://api.github.com/users/lifthrasiir/followers", "following_url": "https://api.github.com/users/lifthrasiir/following{/other_user}", "gists_url": "https://api.github.com/users/lifthrasiir/gists{/gist_id}", "starred_url": "https://api.github.com/users/lifthrasiir/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lifthrasiir/subscriptions", "organizations_url": "https://api.github.com/users/lifthrasiir/orgs", "repos_url": "https://api.github.com/users/lifthrasiir/repos", "events_url": "https://api.github.com/users/lifthrasiir/events{/privacy}", "received_events_url": "https://api.github.com/users/lifthrasiir/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lifthrasiir", "id": 323836, "node_id": "MDQ6VXNlcjMyMzgzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/323836?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lifthrasiir", "html_url": "https://github.com/lifthrasiir", "followers_url": "https://api.github.com/users/lifthrasiir/followers", "following_url": "https://api.github.com/users/lifthrasiir/following{/other_user}", "gists_url": "https://api.github.com/users/lifthrasiir/gists{/gist_id}", "starred_url": "https://api.github.com/users/lifthrasiir/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lifthrasiir/subscriptions", "organizations_url": "https://api.github.com/users/lifthrasiir/orgs", "repos_url": "https://api.github.com/users/lifthrasiir/repos", "events_url": "https://api.github.com/users/lifthrasiir/events{/privacy}", "received_events_url": "https://api.github.com/users/lifthrasiir/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "85424c4baedd689796560fcdd7b1496cd90fa2db", "url": "https://api.github.com/repos/rust-lang/rust/commits/85424c4baedd689796560fcdd7b1496cd90fa2db", "html_url": "https://github.com/rust-lang/rust/commit/85424c4baedd689796560fcdd7b1496cd90fa2db"}], "stats": {"total": 33, "additions": 18, "deletions": 15}, "files": [{"sha": "d6a5e44a1fb00372681874471c27fe5abc034d15", "filename": "src/libcore/num/flt2dec/bignum.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8a195f075417ad78084ef2e1c5e294ac35d6cafa/src%2Flibcore%2Fnum%2Fflt2dec%2Fbignum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a195f075417ad78084ef2e1c5e294ac35d6cafa/src%2Flibcore%2Fnum%2Fflt2dec%2Fbignum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fflt2dec%2Fbignum.rs?ref=8a195f075417ad78084ef2e1c5e294ac35d6cafa", "patch": "@@ -88,7 +88,7 @@ impl_full_ops! {\n     u8:  add(intrinsics::u8_add_with_overflow),  mul/div(u16);\n     u16: add(intrinsics::u16_add_with_overflow), mul/div(u32);\n     u32: add(intrinsics::u32_add_with_overflow), mul/div(u64);\n-//  u64: add(intrinsics::u64_add_with_overflow), mul/div(u128); // damn!\n+//  u64: add(intrinsics::u64_add_with_overflow), mul/div(u128); // see RFC #521 for enabling this.\n }\n \n macro_rules! define_bignum {\n@@ -103,11 +103,12 @@ macro_rules! define_bignum {\n         /// All operations available to bignums panic in the case of over/underflows.\n         /// The caller is responsible to use large enough bignum types.\n         pub struct $name {\n-            /// One plus the offset to the maximum \"digit\" in the use.\n+            /// One plus the offset to the maximum \"digit\" in use.\n             /// This does not decrease, so be aware of the computation order.\n             /// `base[size..]` should be zero.\n             size: usize,\n-            /// Digits. `[a, b, c, ...]` represents `a + b*n + c*n^2 + ...`.\n+            /// Digits. `[a, b, c, ...]` represents `a + b*2^W + c*2^(2W) + ...`\n+            /// where `W` is the number of bits in the digit type.\n             base: [$ty; $n]\n         }\n \n@@ -215,7 +216,7 @@ macro_rules! define_bignum {\n                     self.base[i] = 0;\n                 }\n \n-                // shift by `nbits` bits\n+                // shift by `bits` bits\n                 let mut sz = self.size + digits;\n                 if bits > 0 {\n                     let last = sz;\n@@ -236,8 +237,9 @@ macro_rules! define_bignum {\n                 self\n             }\n \n-            /// Multiplies itself by a number described by `other[0] + other[1] * n +\n-            /// other[2] * n^2 + ...` and returns its own mutable reference.\n+            /// Multiplies itself by a number described by `other[0] + other[1] * 2^W +\n+            /// other[2] * 2^(2W) + ...` (where `W` is the number of bits in the digit type)\n+            /// and returns its own mutable reference.\n             pub fn mul_digits<'a>(&'a mut self, other: &[$ty]) -> &'a mut $name {\n                 // the internal routine. works best when aa.len() <= bb.len().\n                 fn mul_inner(ret: &mut [$ty; $n], aa: &[$ty], bb: &[$ty]) -> usize {"}, {"sha": "d42e05a91f140f2f150c297914a93faf147f4fb9", "filename": "src/libcore/num/flt2dec/estimator.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8a195f075417ad78084ef2e1c5e294ac35d6cafa/src%2Flibcore%2Fnum%2Fflt2dec%2Festimator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a195f075417ad78084ef2e1c5e294ac35d6cafa/src%2Flibcore%2Fnum%2Fflt2dec%2Festimator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fflt2dec%2Festimator.rs?ref=8a195f075417ad78084ef2e1c5e294ac35d6cafa", "patch": "@@ -18,6 +18,8 @@\n pub fn estimate_scaling_factor(mant: u64, exp: i16) -> i16 {\n     // 2^(nbits-1) < mant <= 2^nbits if mant > 0\n     let nbits = 64 - (mant - 1).leading_zeros() as i64;\n+    // 1292913986 = floor(2^32 * log_10 2)\n+    // therefore this always underestimates (or is exact), but not much.\n     (((nbits + exp as i64) * 1292913986) >> 32) as i16\n }\n "}, {"sha": "f51dcf54a19590a812637ca1bc21531f841be32f", "filename": "src/libcore/num/flt2dec/mod.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8a195f075417ad78084ef2e1c5e294ac35d6cafa/src%2Flibcore%2Fnum%2Fflt2dec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a195f075417ad78084ef2e1c5e294ac35d6cafa/src%2Flibcore%2Fnum%2Fflt2dec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fflt2dec%2Fmod.rs?ref=8a195f075417ad78084ef2e1c5e294ac35d6cafa", "patch": "@@ -93,7 +93,7 @@ Both implementations expose two public functions:\n \n They try to fill the `u8` buffer with digits and returns the number of digits\n written and the exponent `k`. They are total for all finite `f32` and `f64`\n-inputs (Grisu internally falls back to Dragon if possible).\n+inputs (Grisu internally falls back to Dragon if necessary).\n \n The rendered digits are formatted into the actual string form with\n four functions:\n@@ -114,8 +114,8 @@ four functions:\n They all return a slice of preallocated `Part` array, which corresponds to\n the individual part of strings: a fixed string, a part of rendered digits,\n a number of zeroes or a small (`u16`) number. The caller is expected to\n-provide an enough buffer and `Part` array, and to assemble the final\n-string from parts itself.\n+provide a large enough buffer and `Part` array, and to assemble the final\n+string from resulting `Part`s itself.\n \n All algorithms and formatting functions are accompanied by extensive tests\n in `coretest::num::flt2dec` module. It also shows how to use individual\n@@ -274,7 +274,7 @@ fn digits_to_dec_str<'a>(buf: &'a [u8], exp: i16, frac_digits: usize,\n \n     // if there is the restriction on the last digit position, `buf` is assumed to be\n     // left-padded with the virtual zeroes. the number of virtual zeroes, `nzeroes`,\n-    // equals to `max(0, exp + frag_digits - buf.len())`, so that the position of\n+    // equals to `max(0, exp + frac_digits - buf.len())`, so that the position of\n     // the last digit `exp - buf.len() - nzeroes` is no more than `-frac_digits`:\n     //\n     //                       |<-virtual->|\n@@ -373,7 +373,7 @@ pub enum Sign {\n     /// Prints `-` only for the negative non-zero values.\n     Minus,        // -inf -1  0  0  1  inf nan\n     /// Prints `-` only for any negative values (including the negative zero).\n-    MinusRaw,     // -inf -1  0  0  1  inf nan\n+    MinusRaw,     // -inf -1 -0  0  1  inf nan\n     /// Prints `-` for the negative non-zero values, or `+` otherwise.\n     MinusPlus,    // -inf -1 +0 +0 +1 +inf nan\n     /// Prints `-` for any negative values (including the negative zero), or `+` otherwise.\n@@ -639,9 +639,8 @@ pub fn to_exact_fixed_str<'a, T, F>(mut format_exact: F, v: T,\n             let limit = if frac_digits < 0x8000 { -(frac_digits as i16) } else { i16::MIN };\n             let (len, exp) = format_exact(decoded, &mut buf[..maxlen], limit);\n             if exp <= limit {\n-                // `format_exact` always returns at least one digit even though the restriction\n-                // hasn't been met, so we catch this condition and treats as like zeroes.\n-                // this does not include the case that the restriction has been met\n+                // the restriction couldn't been met, so this should render like zero no matter\n+                // `exp` was. this does not include the case that the restriction has been met\n                 // only after the final rounding-up; it's a regular case with `exp = limit + 1`.\n                 debug_assert_eq!(len, 0);\n                 if frac_digits > 0 { // [0.][0000]"}, {"sha": "3d798c8726cddbc826ffe564639a6a10b73e4179", "filename": "src/libcoretest/num/flt2dec/strategy/grisu.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8a195f075417ad78084ef2e1c5e294ac35d6cafa/src%2Flibcoretest%2Fnum%2Fflt2dec%2Fstrategy%2Fgrisu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a195f075417ad78084ef2e1c5e294ac35d6cafa/src%2Flibcoretest%2Fnum%2Fflt2dec%2Fstrategy%2Fgrisu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fflt2dec%2Fstrategy%2Fgrisu.rs?ref=8a195f075417ad78084ef2e1c5e294ac35d6cafa", "patch": "@@ -66,7 +66,7 @@ fn shortest_f32_exhaustive_equivalence_test() {\n     f32_exhaustive_equivalence_test(format_shortest_opt, fallback, MAX_SIG_DIGITS);\n }\n \n-#[test] #[ignore] // is is too expensive\n+#[test] #[ignore] // it is too expensive\n fn shortest_f64_hard_random_equivalence_test() {\n     // this again probably has to use appropriate rustc flags.\n "}]}