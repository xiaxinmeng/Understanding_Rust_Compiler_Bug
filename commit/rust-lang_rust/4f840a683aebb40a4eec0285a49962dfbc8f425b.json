{"sha": "4f840a683aebb40a4eec0285a49962dfbc8f425b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRmODQwYTY4M2FlYmI0MGE0ZWVjMDI4NWE0OTk2MmRmYmM4ZjQyNWI=", "commit": {"author": {"name": "Wesley Wiser", "email": "wwiser@gmail.com", "date": "2018-01-31T03:39:23Z"}, "committer": {"name": "Wesley Wiser", "email": "wwiser@gmail.com", "date": "2018-03-07T00:58:02Z"}, "message": "Add `inline` to `TransFnAttrs`\n\nPart of #47320", "tree": {"sha": "42a46993b1e9c9ecd2658f41aa4cc29bbf3e012d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/42a46993b1e9c9ecd2658f41aa4cc29bbf3e012d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4f840a683aebb40a4eec0285a49962dfbc8f425b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4f840a683aebb40a4eec0285a49962dfbc8f425b", "html_url": "https://github.com/rust-lang/rust/commit/4f840a683aebb40a4eec0285a49962dfbc8f425b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4f840a683aebb40a4eec0285a49962dfbc8f425b/comments", "author": {"login": "wesleywiser", "id": 831192, "node_id": "MDQ6VXNlcjgzMTE5Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/831192?v=4", "gravatar_id": "", "url": "https://api.github.com/users/wesleywiser", "html_url": "https://github.com/wesleywiser", "followers_url": "https://api.github.com/users/wesleywiser/followers", "following_url": "https://api.github.com/users/wesleywiser/following{/other_user}", "gists_url": "https://api.github.com/users/wesleywiser/gists{/gist_id}", "starred_url": "https://api.github.com/users/wesleywiser/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/wesleywiser/subscriptions", "organizations_url": "https://api.github.com/users/wesleywiser/orgs", "repos_url": "https://api.github.com/users/wesleywiser/repos", "events_url": "https://api.github.com/users/wesleywiser/events{/privacy}", "received_events_url": "https://api.github.com/users/wesleywiser/received_events", "type": "User", "site_admin": false}, "committer": {"login": "wesleywiser", "id": 831192, "node_id": "MDQ6VXNlcjgzMTE5Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/831192?v=4", "gravatar_id": "", "url": "https://api.github.com/users/wesleywiser", "html_url": "https://github.com/wesleywiser", "followers_url": "https://api.github.com/users/wesleywiser/followers", "following_url": "https://api.github.com/users/wesleywiser/following{/other_user}", "gists_url": "https://api.github.com/users/wesleywiser/gists{/gist_id}", "starred_url": "https://api.github.com/users/wesleywiser/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/wesleywiser/subscriptions", "organizations_url": "https://api.github.com/users/wesleywiser/orgs", "repos_url": "https://api.github.com/users/wesleywiser/repos", "events_url": "https://api.github.com/users/wesleywiser/events{/privacy}", "received_events_url": "https://api.github.com/users/wesleywiser/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e8cd6cc23783a6a020d2c14f1a0f343a6267195d", "url": "https://api.github.com/repos/rust-lang/rust/commits/e8cd6cc23783a6a020d2c14f1a0f343a6267195d", "html_url": "https://github.com/rust-lang/rust/commit/e8cd6cc23783a6a020d2c14f1a0f343a6267195d"}], "stats": {"total": 286, "additions": 149, "deletions": 137}, "files": [{"sha": "f997a57d5d720f5b1ac7f25dbc3ce5cf2bd0d7bc", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4f840a683aebb40a4eec0285a49962dfbc8f425b/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f840a683aebb40a4eec0285a49962dfbc8f425b/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=4f840a683aebb40a4eec0285a49962dfbc8f425b", "patch": "@@ -36,6 +36,7 @@ use syntax::codemap::{self, Spanned};\n use syntax::abi::Abi;\n use syntax::ast::{self, Name, NodeId, DUMMY_NODE_ID, AsmDialect};\n use syntax::ast::{Attribute, Lit, StrStyle, FloatTy, IntTy, UintTy, MetaItem};\n+use syntax::attr::InlineAttr;\n use syntax::ext::hygiene::SyntaxContext;\n use syntax::ptr::P;\n use syntax::symbol::{Symbol, keywords};\n@@ -2214,6 +2215,7 @@ pub fn provide(providers: &mut Providers) {\n #[derive(Clone, RustcEncodable, RustcDecodable, Hash)]\n pub struct TransFnAttrs {\n     pub flags: TransFnAttrFlags,\n+    pub inline: InlineAttr,\n }\n \n bitflags! {\n@@ -2231,6 +2233,15 @@ impl TransFnAttrs {\n     pub fn new() -> TransFnAttrs {\n         TransFnAttrs {\n             flags: TransFnAttrFlags::empty(),\n+            inline: InlineAttr::None,\n+        }\n+    }\n+\n+    /// True if `#[inline]` or `#[inline(always)]` is present.\n+    pub fn requests_inline(&self) -> bool {\n+        match self.inline {\n+            InlineAttr::Hint | InlineAttr::Always => true,\n+            InlineAttr::None | InlineAttr::Never => false,\n         }\n     }\n }"}, {"sha": "4720c0ca5835f341c5d1d027dc8ce022ae410175", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4f840a683aebb40a4eec0285a49962dfbc8f425b/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f840a683aebb40a4eec0285a49962dfbc8f425b/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=4f840a683aebb40a4eec0285a49962dfbc8f425b", "patch": "@@ -19,6 +19,7 @@ use rustc_data_structures::stable_hasher::{HashStable, ToStableHashKey,\n                                            StableHasher, StableHasherResult};\n use std::mem;\n use syntax::ast;\n+use syntax::attr;\n \n impl<'gcx> HashStable<StableHashingContext<'gcx>> for DefId {\n     #[inline]\n@@ -1145,9 +1146,11 @@ impl<'hir> HashStable<StableHashingContext<'hir>> for hir::TransFnAttrs\n                                           hasher: &mut StableHasher<W>) {\n         let hir::TransFnAttrs {\n             flags,\n+            inline,\n         } = *self;\n \n         flags.hash_stable(hcx, hasher);\n+        inline.hash_stable(hcx, hasher);\n     }\n }\n \n@@ -1160,6 +1163,14 @@ impl<'hir> HashStable<StableHashingContext<'hir>> for hir::TransFnAttrFlags\n     }\n }\n \n+impl<'hir> HashStable<StableHashingContext<'hir>> for attr::InlineAttr {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'hir>,\n+                                          hasher: &mut StableHasher<W>) {\n+        mem::discriminant(self).hash_stable(hcx, hasher);\n+    }\n+}\n+\n impl_stable_hash_for!(struct hir::Freevar {\n     def,\n     span"}, {"sha": "dd581278607eea0bdd113ad7ca921125dea07869", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/4f840a683aebb40a4eec0285a49962dfbc8f425b/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f840a683aebb40a4eec0285a49962dfbc8f425b/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=4f840a683aebb40a4eec0285a49962dfbc8f425b", "patch": "@@ -15,6 +15,7 @@\n // makes all other generics or inline functions that it references\n // reachable as well.\n \n+use hir::TransFnAttrs;\n use hir::map as hir_map;\n use hir::def::Def;\n use hir::def_id::{DefId, CrateNum};\n@@ -43,8 +44,8 @@ fn generics_require_inlining(generics: &hir::Generics) -> bool {\n // Returns true if the given item must be inlined because it may be\n // monomorphized or it was marked with `#[inline]`. This will only return\n // true for functions.\n-fn item_might_be_inlined(item: &hir::Item) -> bool {\n-    if attr::requests_inline(&item.attrs) {\n+fn item_might_be_inlined(item: &hir::Item, attrs: TransFnAttrs) -> bool {\n+    if attrs.requests_inline() {\n         return true\n     }\n \n@@ -60,14 +61,15 @@ fn item_might_be_inlined(item: &hir::Item) -> bool {\n fn method_might_be_inlined<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                      impl_item: &hir::ImplItem,\n                                      impl_src: DefId) -> bool {\n-    if attr::requests_inline(&impl_item.attrs) ||\n+    let trans_fn_attrs = tcx.trans_fn_attrs(impl_item.hir_id.owner_def_id());\n+    if trans_fn_attrs.requests_inline() ||\n         generics_require_inlining(&impl_item.generics) {\n         return true\n     }\n     if let Some(impl_node_id) = tcx.hir.as_local_node_id(impl_src) {\n         match tcx.hir.find(impl_node_id) {\n             Some(hir_map::NodeItem(item)) =>\n-                item_might_be_inlined(&item),\n+                item_might_be_inlined(&item, trans_fn_attrs),\n             Some(..) | None =>\n                 span_bug!(impl_item.span, \"impl did is not an item\")\n         }\n@@ -160,7 +162,8 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n         match self.tcx.hir.find(node_id) {\n             Some(hir_map::NodeItem(item)) => {\n                 match item.node {\n-                    hir::ItemFn(..) => item_might_be_inlined(&item),\n+                    hir::ItemFn(..) =>\n+                        item_might_be_inlined(&item, self.tcx.trans_fn_attrs(def_id)),\n                     _ => false,\n                 }\n             }\n@@ -176,8 +179,9 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                 match impl_item.node {\n                     hir::ImplItemKind::Const(..) => true,\n                     hir::ImplItemKind::Method(..) => {\n+                        let attrs = self.tcx.trans_fn_attrs(def_id);\n                         if generics_require_inlining(&impl_item.generics) ||\n-                                attr::requests_inline(&impl_item.attrs) {\n+                                attrs.requests_inline() {\n                             true\n                         } else {\n                             let impl_did = self.tcx\n@@ -246,7 +250,8 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n             hir_map::NodeItem(item) => {\n                 match item.node {\n                     hir::ItemFn(.., body) => {\n-                        if item_might_be_inlined(&item) {\n+                        let def_id = self.tcx.hir.local_def_id(item.id);\n+                        if item_might_be_inlined(&item, self.tcx.trans_fn_attrs(def_id)) {\n                             self.visit_nested_body(body);\n                         }\n                     }"}, {"sha": "a5f0abb9bc05c2348fccb8e4fb1b2cb4a29d2d82", "filename": "src/librustc/ty/instance.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4f840a683aebb40a4eec0285a49962dfbc8f425b/src%2Flibrustc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f840a683aebb40a4eec0285a49962dfbc8f425b/src%2Flibrustc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finstance.rs?ref=4f840a683aebb40a4eec0285a49962dfbc8f425b", "patch": "@@ -96,7 +96,6 @@ impl<'tcx> InstanceDef<'tcx> {\n         &self,\n         tcx: TyCtxt<'a, 'tcx, 'tcx>\n     ) -> bool {\n-        use syntax::attr::requests_inline;\n         if self.is_inline(tcx) {\n             return true\n         }\n@@ -106,8 +105,8 @@ impl<'tcx> InstanceDef<'tcx> {\n             // available to normal end-users.\n             return true\n         }\n-        requests_inline(&self.attrs(tcx)[..]) ||\n-            tcx.is_const_fn(self.def_id())\n+        let trans_fn_attrs = tcx.trans_fn_attrs(self.def_id());\n+        trans_fn_attrs.requests_inline() || tcx.is_const_fn(self.def_id())\n     }\n }\n "}, {"sha": "830121b446fca3e565f0a5921f805dcbf9997289", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4f840a683aebb40a4eec0285a49962dfbc8f425b/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f840a683aebb40a4eec0285a49962dfbc8f425b/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=4f840a683aebb40a4eec0285a49962dfbc8f425b", "patch": "@@ -832,7 +832,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n         } else if let hir::ImplItemKind::Method(ref sig, body) = ast_item.node {\n             let generics = self.tcx.generics_of(def_id);\n             let types = generics.parent_types as usize + generics.types.len();\n-            let needs_inline = types > 0 || attr::requests_inline(&ast_item.attrs);\n+            let needs_inline = types > 0 || tcx.trans_fn_attrs(def_id).requests_inline();\n             let is_const_fn = sig.constness == hir::Constness::Const;\n             let ast = if is_const_fn { Some(body) } else { None };\n             let always_encode_mir = self.tcx.sess.opts.debugging_opts.always_encode_mir;\n@@ -1123,7 +1123,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n                 hir::ItemConst(..) => self.encode_optimized_mir(def_id),\n                 hir::ItemFn(_, _, constness, _, ref generics, _) => {\n                     let has_tps = generics.ty_params().next().is_some();\n-                    let needs_inline = has_tps || attr::requests_inline(&item.attrs);\n+                    let needs_inline = has_tps || tcx.trans_fn_attrs(def_id).requests_inline();\n                     let always_encode_mir = self.tcx.sess.opts.debugging_opts.always_encode_mir;\n                     if needs_inline || constness == hir::Constness::Const || always_encode_mir {\n                         self.encode_optimized_mir(def_id)"}, {"sha": "6f6f5e13c635cd1bb0de5fa92dc87d131a9d8ff0", "filename": "src/librustc_mir/monomorphize/item.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4f840a683aebb40a4eec0285a49962dfbc8f425b/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f840a683aebb40a4eec0285a49962dfbc8f425b/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs?ref=4f840a683aebb40a4eec0285a49962dfbc8f425b", "patch": "@@ -141,8 +141,7 @@ pub trait MonoItemExt<'a, 'tcx>: fmt::Debug {\n                 // creating one copy of this `#[inline]` function which may\n                 // conflict with upstream crates as it could be an exported\n                 // symbol.\n-                let attrs = instance.def.attrs(tcx);\n-                match attr::find_inline_attr(Some(tcx.sess.diagnostic()), &attrs) {\n+                match tcx.trans_fn_attrs(instance.def_id()).inline {\n                     InlineAttr::Always => InstantiationMode::LocalCopy,\n                     _ => {\n                         InstantiationMode::GloballyShared  { may_conflict: true }"}, {"sha": "485f870fccaa7f4564739ac3bd464a557fef0d37", "filename": "src/librustc_mir/transform/inline.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f840a683aebb40a4eec0285a49962dfbc8f425b/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f840a683aebb40a4eec0285a49962dfbc8f425b/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finline.rs?ref=4f840a683aebb40a4eec0285a49962dfbc8f425b", "patch": "@@ -207,7 +207,7 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n         }\n \n         let attrs = tcx.get_attrs(callsite.callee);\n-        let hint = attr::find_inline_attr(None, &attrs[..]);\n+        let hint = tcx.trans_fn_attrs(callsite.callee).inline;\n \n         let hinted = match hint {\n             // Just treat inline(always) as a hint for now,"}, {"sha": "89ce6bdbb55e2c5e29a81292c53a36d367051192", "filename": "src/librustc_trans/attributes.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4f840a683aebb40a4eec0285a49962dfbc8f425b/src%2Flibrustc_trans%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f840a683aebb40a4eec0285a49962dfbc8f425b/src%2Flibrustc_trans%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fattributes.rs?ref=4f840a683aebb40a4eec0285a49962dfbc8f425b", "patch": "@@ -103,15 +103,13 @@ pub fn set_probestack(cx: &CodegenCx, llfn: ValueRef) {\n /// Composite function which sets LLVM attributes for function depending on its AST (#[attribute])\n /// attributes.\n pub fn from_fn_attrs(cx: &CodegenCx, llfn: ValueRef, id: DefId) {\n-    use syntax::attr::*;\n-    let attrs = cx.tcx.get_attrs(id);\n-    inline(llfn, find_inline_attr(Some(cx.sess().diagnostic()), &attrs));\n+    let trans_fn_attrs = cx.tcx.trans_fn_attrs(id);\n+\n+    inline(llfn, trans_fn_attrs.inline);\n \n     set_frame_pointer_elimination(cx, llfn);\n     set_probestack(cx, llfn);\n \n-    let trans_fn_attrs = cx.tcx.trans_fn_attrs(id);\n-\n     if trans_fn_attrs.flags.contains(TransFnAttrFlags::COLD) {\n         Attribute::Cold.apply_llfn(Function, llfn);\n     }"}, {"sha": "443cece66e22613b6311853b1922a726d020c7e1", "filename": "src/librustc_trans_utils/trans_crate.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4f840a683aebb40a4eec0285a49962dfbc8f425b/src%2Flibrustc_trans_utils%2Ftrans_crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f840a683aebb40a4eec0285a49962dfbc8f425b/src%2Flibrustc_trans_utils%2Ftrans_crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans_utils%2Ftrans_crate.rs?ref=4f840a683aebb40a4eec0285a49962dfbc8f425b", "patch": "@@ -236,9 +236,7 @@ impl TransCrate for MetadataOnlyTransCrate {\n                         let _ = tcx.export_name(def_id);\n                         let _ = tcx.contains_extern_indicator(def_id);\n                         let _ = inst.def.is_inline(tcx);\n-                        let attrs = inst.def.attrs(tcx);\n-                        let _ =\n-                            ::syntax::attr::find_inline_attr(Some(tcx.sess.diagnostic()), &attrs);\n+                        let _ = tcx.trans_fn_attrs(def_id);\n                     }\n                 }\n                 _ => {}"}, {"sha": "6793f478dd6864f48d0dfebda67cdbec42f51b11", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/4f840a683aebb40a4eec0285a49962dfbc8f425b/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f840a683aebb40a4eec0285a49962dfbc8f425b/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=4f840a683aebb40a4eec0285a49962dfbc8f425b", "patch": "@@ -41,6 +41,8 @@ use util::nodemap::FxHashMap;\n use rustc_const_math::ConstInt;\n \n use syntax::{abi, ast};\n+use syntax::ast::MetaItemKind;\n+use syntax::attr::{InlineAttr, list_contains_name, mark_used};\n use syntax::codemap::Spanned;\n use syntax::symbol::{Symbol, keywords};\n use syntax_pos::{Span, DUMMY_SP};\n@@ -1742,6 +1744,39 @@ fn trans_fn_attrs<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, id: DefId) -> TransFnAt\n         } else if attr.check_name(\"naked\") {\n             trans_fn_attrs.flags |= TransFnAttrFlags::NAKED;\n         } else if attr.check_name(\"inline\") {\n+            trans_fn_attrs.inline = attrs.iter().fold(InlineAttr::None, |ia, attr| {\n+                if attr.path != \"inline\" {\n+                    return ia;\n+                }\n+                let meta = match attr.meta() {\n+                    Some(meta) => meta.node,\n+                    None => return ia,\n+                };\n+                match meta {\n+                    MetaItemKind::Word => {\n+                        mark_used(attr);\n+                        InlineAttr::Hint\n+                    }\n+                    MetaItemKind::List(ref items) => {\n+                        mark_used(attr);\n+                        if items.len() != 1 {\n+                            span_err!(tcx.sess.diagnostic(), attr.span, E0534,\n+                                        \"expected one argument\");\n+                            InlineAttr::None\n+                        } else if list_contains_name(&items[..], \"always\") {\n+                            InlineAttr::Always\n+                        } else if list_contains_name(&items[..], \"never\") {\n+                            InlineAttr::Never\n+                        } else {\n+                            span_err!(tcx.sess.diagnostic(), items[0].span, E0535,\n+                                        \"invalid argument\");\n+\n+                            InlineAttr::None\n+                        }\n+                    }\n+                    _ => ia,\n+                }\n+            });\n         }\n     }\n "}, {"sha": "a0844dc259e9bfbcbf52d4caba626a6ff868ade7", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/4f840a683aebb40a4eec0285a49962dfbc8f425b/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f840a683aebb40a4eec0285a49962dfbc8f425b/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=4f840a683aebb40a4eec0285a49962dfbc8f425b", "patch": "@@ -3705,6 +3705,75 @@ match r {\n ```\n \"##,\n \n+E0534: r##\"\n+The `inline` attribute was malformed.\n+\n+Erroneous code example:\n+\n+```ignore (compile_fail not working here; see Issue #43707)\n+#[inline()] // error: expected one argument\n+pub fn something() {}\n+\n+fn main() {}\n+```\n+\n+The parenthesized `inline` attribute requires the parameter to be specified:\n+\n+```\n+#[inline(always)]\n+fn something() {}\n+```\n+\n+or:\n+\n+```\n+#[inline(never)]\n+fn something() {}\n+```\n+\n+Alternatively, a paren-less version of the attribute may be used to hint the\n+compiler about inlining opportunity:\n+\n+```\n+#[inline]\n+fn something() {}\n+```\n+\n+For more information about the inline attribute, read:\n+https://doc.rust-lang.org/reference.html#inline-attributes\n+\"##,\n+\n+E0535: r##\"\n+An unknown argument was given to the `inline` attribute.\n+\n+Erroneous code example:\n+\n+```ignore (compile_fail not working here; see Issue #43707)\n+#[inline(unknown)] // error: invalid argument\n+pub fn something() {}\n+\n+fn main() {}\n+```\n+\n+The `inline` attribute only supports two arguments:\n+\n+ * always\n+ * never\n+\n+All other arguments given to the `inline` attribute will return this error.\n+Example:\n+\n+```\n+#[inline(never)] // ok!\n+pub fn something() {}\n+\n+fn main() {}\n+```\n+\n+For more information about the inline attribute, https:\n+read://doc.rust-lang.org/reference.html#inline-attributes\n+\"##,\n+\n E0559: r##\"\n An unknown field was specified into an enum's structure variant.\n "}, {"sha": "4818248129e70a1659a06b85c3c8c85bef99fd48", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 1, "deletions": 45, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/4f840a683aebb40a4eec0285a49962dfbc8f425b/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f840a683aebb40a4eec0285a49962dfbc8f425b/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=4f840a683aebb40a4eec0285a49962dfbc8f425b", "patch": "@@ -520,51 +520,14 @@ pub fn find_crate_name(attrs: &[Attribute]) -> Option<Symbol> {\n     first_attr_value_str_by_name(attrs, \"crate_name\")\n }\n \n-#[derive(Copy, Clone, PartialEq)]\n+#[derive(Copy, Clone, Hash, PartialEq, RustcEncodable, RustcDecodable)]\n pub enum InlineAttr {\n     None,\n     Hint,\n     Always,\n     Never,\n }\n \n-/// Determine what `#[inline]` attribute is present in `attrs`, if any.\n-pub fn find_inline_attr(diagnostic: Option<&Handler>, attrs: &[Attribute]) -> InlineAttr {\n-    attrs.iter().fold(InlineAttr::None, |ia, attr| {\n-        if attr.path != \"inline\" {\n-            return ia;\n-        }\n-        let meta = match attr.meta() {\n-            Some(meta) => meta.node,\n-            None => return ia,\n-        };\n-        match meta {\n-            MetaItemKind::Word => {\n-                mark_used(attr);\n-                InlineAttr::Hint\n-            }\n-            MetaItemKind::List(ref items) => {\n-                mark_used(attr);\n-                if items.len() != 1 {\n-                    diagnostic.map(|d|{ span_err!(d, attr.span, E0534, \"expected one argument\"); });\n-                    InlineAttr::None\n-                } else if list_contains_name(&items[..], \"always\") {\n-                    InlineAttr::Always\n-                } else if list_contains_name(&items[..], \"never\") {\n-                    InlineAttr::Never\n-                } else {\n-                    diagnostic.map(|d| {\n-                        span_err!(d, items[0].span, E0535, \"invalid argument\");\n-                    });\n-\n-                    InlineAttr::None\n-                }\n-            }\n-            _ => ia,\n-        }\n-    })\n-}\n-\n #[derive(Copy, Clone, PartialEq)]\n pub enum UnwindAttr {\n     Allowed,\n@@ -610,13 +573,6 @@ pub fn find_unwind_attr(diagnostic: Option<&Handler>, attrs: &[Attribute]) -> Op\n     })\n }\n \n-/// True if `#[inline]` or `#[inline(always)]` is present in `attrs`.\n-pub fn requests_inline(attrs: &[Attribute]) -> bool {\n-    match find_inline_attr(None, attrs) {\n-        InlineAttr::Hint | InlineAttr::Always => true,\n-        InlineAttr::None | InlineAttr::Never => false,\n-    }\n-}\n \n /// Tests if a cfg-pattern matches the cfg set\n pub fn cfg_matches(cfg: &ast::MetaItem, sess: &ParseSess, features: Option<&Features>) -> bool {"}, {"sha": "549ef88afcc63b1811be51180469f24c0d836894", "filename": "src/libsyntax/diagnostic_list.rs", "status": "modified", "additions": 0, "deletions": 69, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/4f840a683aebb40a4eec0285a49962dfbc8f425b/src%2Flibsyntax%2Fdiagnostic_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f840a683aebb40a4eec0285a49962dfbc8f425b/src%2Flibsyntax%2Fdiagnostic_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic_list.rs?ref=4f840a683aebb40a4eec0285a49962dfbc8f425b", "patch": "@@ -37,75 +37,6 @@ More details can be found in [RFC 438].\n [RFC 438]: https://github.com/rust-lang/rfcs/pull/438\n \"##,\n \n-E0534: r##\"\n-The `inline` attribute was malformed.\n-\n-Erroneous code example:\n-\n-```ignore (compile_fail not working here; see Issue #43707)\n-#[inline()] // error: expected one argument\n-pub fn something() {}\n-\n-fn main() {}\n-```\n-\n-The parenthesized `inline` attribute requires the parameter to be specified:\n-\n-```\n-#[inline(always)]\n-fn something() {}\n-```\n-\n-or:\n-\n-```\n-#[inline(never)]\n-fn something() {}\n-```\n-\n-Alternatively, a paren-less version of the attribute may be used to hint the\n-compiler about inlining opportunity:\n-\n-```\n-#[inline]\n-fn something() {}\n-```\n-\n-For more information about the inline attribute, read:\n-https://doc.rust-lang.org/reference.html#inline-attributes\n-\"##,\n-\n-E0535: r##\"\n-An unknown argument was given to the `inline` attribute.\n-\n-Erroneous code example:\n-\n-```ignore (compile_fail not working here; see Issue #43707)\n-#[inline(unknown)] // error: invalid argument\n-pub fn something() {}\n-\n-fn main() {}\n-```\n-\n-The `inline` attribute only supports two arguments:\n-\n- * always\n- * never\n-\n-All other arguments given to the `inline` attribute will return this error.\n-Example:\n-\n-```\n-#[inline(never)] // ok!\n-pub fn something() {}\n-\n-fn main() {}\n-```\n-\n-For more information about the inline attribute, https:\n-read://doc.rust-lang.org/reference.html#inline-attributes\n-\"##,\n-\n E0536: r##\"\n The `not` cfg-predicate was malformed.\n "}]}