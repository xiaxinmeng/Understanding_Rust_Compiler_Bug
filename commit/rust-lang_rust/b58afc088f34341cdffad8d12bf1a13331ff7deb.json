{"sha": "b58afc088f34341cdffad8d12bf1a13331ff7deb", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI1OGFmYzA4OGYzNDM0MWNkZmZhZDhkMTJiZjFhMTMzMzFmZjdkZWI=", "commit": {"author": {"name": "Rich Kadel", "email": "richkadel@google.com", "date": "2020-07-29T00:45:58Z"}, "committer": {"name": "Rich Kadel", "email": "richkadel@google.com", "date": "2020-07-29T00:45:58Z"}, "message": "FunctionCoverage: improve type checking with newtype_index types", "tree": {"sha": "eca5257a2fbbeb10f4b598c166221b09a2e00eb2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eca5257a2fbbeb10f4b598c166221b09a2e00eb2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b58afc088f34341cdffad8d12bf1a13331ff7deb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b58afc088f34341cdffad8d12bf1a13331ff7deb", "html_url": "https://github.com/rust-lang/rust/commit/b58afc088f34341cdffad8d12bf1a13331ff7deb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b58afc088f34341cdffad8d12bf1a13331ff7deb/comments", "author": {"login": "richkadel", "id": 3827298, "node_id": "MDQ6VXNlcjM4MjcyOTg=", "avatar_url": "https://avatars.githubusercontent.com/u/3827298?v=4", "gravatar_id": "", "url": "https://api.github.com/users/richkadel", "html_url": "https://github.com/richkadel", "followers_url": "https://api.github.com/users/richkadel/followers", "following_url": "https://api.github.com/users/richkadel/following{/other_user}", "gists_url": "https://api.github.com/users/richkadel/gists{/gist_id}", "starred_url": "https://api.github.com/users/richkadel/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/richkadel/subscriptions", "organizations_url": "https://api.github.com/users/richkadel/orgs", "repos_url": "https://api.github.com/users/richkadel/repos", "events_url": "https://api.github.com/users/richkadel/events{/privacy}", "received_events_url": "https://api.github.com/users/richkadel/received_events", "type": "User", "site_admin": false}, "committer": {"login": "richkadel", "id": 3827298, "node_id": "MDQ6VXNlcjM4MjcyOTg=", "avatar_url": "https://avatars.githubusercontent.com/u/3827298?v=4", "gravatar_id": "", "url": "https://api.github.com/users/richkadel", "html_url": "https://github.com/richkadel", "followers_url": "https://api.github.com/users/richkadel/followers", "following_url": "https://api.github.com/users/richkadel/following{/other_user}", "gists_url": "https://api.github.com/users/richkadel/gists{/gist_id}", "starred_url": "https://api.github.com/users/richkadel/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/richkadel/subscriptions", "organizations_url": "https://api.github.com/users/richkadel/orgs", "repos_url": "https://api.github.com/users/richkadel/repos", "events_url": "https://api.github.com/users/richkadel/events{/privacy}", "received_events_url": "https://api.github.com/users/richkadel/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "20f55c193dea0a893c869dd7a9cf3e2298635221", "url": "https://api.github.com/repos/rust-lang/rust/commits/20f55c193dea0a893c869dd7a9cf3e2298635221", "html_url": "https://github.com/rust-lang/rust/commit/20f55c193dea0a893c869dd7a9cf3e2298635221"}], "stats": {"total": 128, "additions": 88, "deletions": 40}, "files": [{"sha": "1fe8b9f5ab7daf685f2006fc625927ee89a12a5c", "filename": "src/librustc_codegen_ssa/coverageinfo/map.rs", "status": "modified", "additions": 86, "deletions": 40, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/b58afc088f34341cdffad8d12bf1a13331ff7deb/src%2Flibrustc_codegen_ssa%2Fcoverageinfo%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b58afc088f34341cdffad8d12bf1a13331ff7deb/src%2Flibrustc_codegen_ssa%2Fcoverageinfo%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fcoverageinfo%2Fmap.rs?ref=b58afc088f34341cdffad8d12bf1a13331ff7deb", "patch": "@@ -1,3 +1,4 @@\n+use rustc_index::vec::IndexVec;\n use rustc_middle::ty::Instance;\n use rustc_middle::ty::TyCtxt;\n use rustc_span::source_map::{Pos, SourceMap};\n@@ -7,6 +8,34 @@ use std::cmp::{Ord, Ordering};\n use std::fmt;\n use std::path::PathBuf;\n \n+rustc_index::newtype_index! {\n+    pub struct ExpressionOperandId {\n+        DEBUG_FORMAT = \"ExpressionOperandId({})\",\n+        MAX = 0xFFFF_FFFF,\n+    }\n+}\n+\n+rustc_index::newtype_index! {\n+    pub struct CounterValueReference {\n+        DEBUG_FORMAT = \"CounterValueReference({})\",\n+        MAX = 0xFFFF_FFFF,\n+    }\n+}\n+\n+rustc_index::newtype_index! {\n+    pub struct InjectedExpressionIndex {\n+        DEBUG_FORMAT = \"InjectedExpressionIndex({})\",\n+        MAX = 0xFFFF_FFFF,\n+    }\n+}\n+\n+rustc_index::newtype_index! {\n+    pub struct MappedExpressionIndex {\n+        DEBUG_FORMAT = \"MappedExpressionIndex({})\",\n+        MAX = 0xFFFF_FFFF,\n+    }\n+}\n+\n /// Aligns with [llvm::coverage::Counter::CounterKind](https://github.com/rust-lang/llvm-project/blob/rustc/10.0-2020-05-05/llvm/include/llvm/ProfileData/Coverage/CoverageMapping.h#L91)\n #[derive(Copy, Clone, Debug)]\n #[repr(C)]\n@@ -38,12 +67,12 @@ impl Counter {\n         Self { kind: CounterKind::Zero, id: 0 }\n     }\n \n-    pub fn counter_value_reference(counter_id: u32) -> Self {\n-        Self { kind: CounterKind::CounterValueReference, id: counter_id }\n+    pub fn counter_value_reference(counter_id: CounterValueReference) -> Self {\n+        Self { kind: CounterKind::CounterValueReference, id: counter_id.into() }\n     }\n \n-    pub fn expression(final_expression_index: u32) -> Self {\n-        Self { kind: CounterKind::Expression, id: final_expression_index }\n+    pub fn expression(mapped_expression_index: MappedExpressionIndex) -> Self {\n+        Self { kind: CounterKind::Expression, id: mapped_expression_index.into() }\n     }\n }\n \n@@ -143,9 +172,9 @@ impl Region {\n \n #[derive(Clone, Debug)]\n pub struct ExpressionRegion {\n-    lhs: u32,\n+    lhs: ExpressionOperandId,\n     op: ExprKind,\n-    rhs: u32,\n+    rhs: ExpressionOperandId,\n     region: Region,\n }\n \n@@ -203,8 +232,8 @@ pub struct ExpressionRegion {\n pub struct FunctionCoverage<'a> {\n     source_map: &'a SourceMap,\n     source_hash: u64,\n-    counters: Vec<Option<Region>>,\n-    expressions: Vec<Option<ExpressionRegion>>,\n+    counters: IndexVec<CounterValueReference, Option<Region>>,\n+    expressions: IndexVec<InjectedExpressionIndex, Option<ExpressionRegion>>,\n     unreachable_regions: Vec<Region>,\n }\n \n@@ -214,8 +243,8 @@ impl<'a> FunctionCoverage<'a> {\n         Self {\n             source_map: tcx.sess.source_map(),\n             source_hash: 0, // will be set with the first `add_counter()`\n-            counters: vec![None; coverageinfo.num_counters as usize],\n-            expressions: vec![None; coverageinfo.num_expressions as usize],\n+            counters: IndexVec::from_elem_n(None, coverageinfo.num_counters as usize),\n+            expressions: IndexVec::from_elem_n(None, coverageinfo.num_expressions as usize),\n             unreachable_regions: Vec::new(),\n         }\n     }\n@@ -235,7 +264,7 @@ impl<'a> FunctionCoverage<'a> {\n         } else {\n             debug_assert_eq!(source_hash, self.source_hash);\n         }\n-        self.counters[id as usize]\n+        self.counters[CounterValueReference::from(id)]\n             .replace(Region::new(self.source_map, start_byte_pos, end_byte_pos))\n             .expect_none(\"add_counter called with duplicate `id`\");\n     }\n@@ -263,7 +292,11 @@ impl<'a> FunctionCoverage<'a> {\n         start_byte_pos: u32,\n         end_byte_pos: u32,\n     ) {\n-        let expression_index = self.expression_index(id_descending_from_max);\n+        let expression_id = ExpressionOperandId::from(id_descending_from_max);\n+        let lhs = ExpressionOperandId::from(lhs);\n+        let rhs = ExpressionOperandId::from(rhs);\n+\n+        let expression_index = self.expression_index(expression_id);\n         self.expressions[expression_index]\n             .replace(ExpressionRegion {\n                 lhs,\n@@ -294,19 +327,21 @@ impl<'a> FunctionCoverage<'a> {\n         assert!(self.source_hash != 0);\n \n         let counter_regions = self.counter_regions();\n-        let (expressions, expression_regions) = self.expressions_with_regions();\n+        let (counter_expressions, expression_regions) = self.expressions_with_regions();\n         let unreachable_regions = self.unreachable_regions();\n \n         let counter_regions =\n             counter_regions.chain(expression_regions.into_iter().chain(unreachable_regions));\n-        (expressions, counter_regions)\n+        (counter_expressions, counter_regions)\n     }\n \n     fn counter_regions(&'a self) -> impl Iterator<Item = (Counter, &'a Region)> {\n-        self.counters.iter().enumerate().filter_map(|(index, entry)| {\n+        self.counters.iter_enumerated().filter_map(|(index, entry)| {\n             // Option::map() will return None to filter out missing counters. This may happen\n             // if, for example, a MIR-instrumented counter is removed during an optimization.\n-            entry.as_ref().map(|region| (Counter::counter_value_reference(index as u32), region))\n+            entry.as_ref().map(|region| {\n+                (Counter::counter_value_reference(index as CounterValueReference), region)\n+            })\n         })\n     }\n \n@@ -315,32 +350,39 @@ impl<'a> FunctionCoverage<'a> {\n     ) -> (Vec<CounterExpression>, impl Iterator<Item = (Counter, &'a Region)>) {\n         let mut counter_expressions = Vec::with_capacity(self.expressions.len());\n         let mut expression_regions = Vec::with_capacity(self.expressions.len());\n-        let mut new_indexes = vec![u32::MAX; self.expressions.len()];\n+        let mut new_indexes =\n+            IndexVec::from_elem_n(MappedExpressionIndex::from(u32::MAX), self.expressions.len());\n+        // Note, the initial value shouldn't matter since every index in use in `self.expressions`\n+        // will be set, and after that, `new_indexes` will only be accessed using those same\n+        // indexes.\n \n         // Note that an `ExpressionRegion`s at any given index can include other expressions as\n         // operands, but expression operands can only come from the subset of expressions having\n         // `expression_index`s lower than the referencing `ExpressionRegion`. Therefore, it is\n         // reasonable to look up the new index of an expression operand while the `new_indexes`\n         // vector is only complete up to the current `ExpressionIndex`.\n-        let id_to_counter = |new_indexes: &Vec<u32>, id| {\n-            if id < self.counters.len() as u32 {\n-                self.counters\n-                    .get(id as usize)\n-                    .expect(\"id is out of range\")\n-                    .as_ref()\n-                    .map(|_| Counter::counter_value_reference(id))\n-            } else {\n-                let index = self.expression_index(id);\n-                self.expressions\n-                    .get(index)\n-                    .expect(\"id is out of range\")\n-                    .as_ref()\n-                    .map(|_| Counter::expression(new_indexes[index]))\n-            }\n-        };\n+        let id_to_counter =\n+            |new_indexes: &IndexVec<InjectedExpressionIndex, MappedExpressionIndex>,\n+             id: ExpressionOperandId| {\n+                if id.index() < self.counters.len() {\n+                    let index = CounterValueReference::from(id.index());\n+                    self.counters\n+                        .get(index)\n+                        .unwrap() // pre-validated\n+                        .as_ref()\n+                        .map(|_| Counter::counter_value_reference(index))\n+                } else {\n+                    let index = self.expression_index(id);\n+                    self.expressions\n+                        .get(index)\n+                        .expect(\"expression id is out of range\")\n+                        .as_ref()\n+                        .map(|_| Counter::expression(new_indexes[index]))\n+                }\n+            };\n \n         for (original_index, expression_region) in\n-            self.expressions.iter().enumerate().filter_map(|(original_index, entry)| {\n+            self.expressions.iter_enumerated().filter_map(|(original_index, entry)| {\n                 // Option::map() will return None to filter out missing expressions. This may happen\n                 // if, for example, a MIR-instrumented expression is removed during an optimization.\n                 entry.as_ref().map(|region| (original_index, region))\n@@ -356,10 +398,11 @@ impl<'a> FunctionCoverage<'a> {\n             {\n                 // Both operands exist. `Expression` operands exist in `self.expressions` and have\n                 // been assigned a `new_index`.\n-                let final_expression_index = counter_expressions.len() as u32;\n+                let mapped_expression_index =\n+                    MappedExpressionIndex::from(counter_expressions.len());\n                 counter_expressions.push(CounterExpression::new(lhs_counter, op, rhs_counter));\n-                new_indexes[original_index] = final_expression_index;\n-                expression_regions.push((Counter::expression(final_expression_index), region));\n+                new_indexes[original_index] = mapped_expression_index;\n+                expression_regions.push((Counter::expression(mapped_expression_index), region));\n             }\n         }\n         (counter_expressions, expression_regions.into_iter())\n@@ -369,8 +412,11 @@ impl<'a> FunctionCoverage<'a> {\n         self.unreachable_regions.iter().map(|region| (Counter::zero(), region))\n     }\n \n-    fn expression_index(&self, id_descending_from_max: u32) -> usize {\n-        debug_assert!(id_descending_from_max as usize >= self.counters.len());\n-        (u32::MAX - id_descending_from_max) as usize\n+    fn expression_index(\n+        &self,\n+        id_descending_from_max: ExpressionOperandId,\n+    ) -> InjectedExpressionIndex {\n+        debug_assert!(id_descending_from_max.index() >= self.counters.len());\n+        InjectedExpressionIndex::from(u32::MAX - u32::from(id_descending_from_max))\n     }\n }"}, {"sha": "85260d30a3d7c36292b30580c427e8d392df94ba", "filename": "src/librustc_codegen_ssa/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b58afc088f34341cdffad8d12bf1a13331ff7deb/src%2Flibrustc_codegen_ssa%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b58afc088f34341cdffad8d12bf1a13331ff7deb/src%2Flibrustc_codegen_ssa%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Flib.rs?ref=b58afc088f34341cdffad8d12bf1a13331ff7deb", "patch": "@@ -8,6 +8,8 @@\n #![feature(or_patterns)]\n #![feature(trusted_len)]\n #![feature(associated_type_bounds)]\n+#![feature(const_fn)] // for rustc_index::newtype_index\n+#![feature(const_panic)] // for rustc_index::newtype_index\n #![recursion_limit = \"256\"]\n \n //! This crate contains codegen code that is used by all codegen backends (LLVM and others)."}]}