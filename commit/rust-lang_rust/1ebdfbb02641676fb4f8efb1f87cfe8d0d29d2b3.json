{"sha": "1ebdfbb02641676fb4f8efb1f87cfe8d0d29d2b3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFlYmRmYmIwMjY0MTY3NmZiNGY4ZWZiMWY4N2NmZThkMGQyOWQyYjM=", "commit": {"author": {"name": "Denis Merigoux", "email": "denis.merigoux@gmail.com", "date": "2018-10-04T13:23:10Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2018-11-16T13:08:18Z"}, "message": "Added some docs + start to &mut self builder methods", "tree": {"sha": "2400beef547971b4aa76b9bf86e8283f66b49fbc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2400beef547971b4aa76b9bf86e8283f66b49fbc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1ebdfbb02641676fb4f8efb1f87cfe8d0d29d2b3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1ebdfbb02641676fb4f8efb1f87cfe8d0d29d2b3", "html_url": "https://github.com/rust-lang/rust/commit/1ebdfbb02641676fb4f8efb1f87cfe8d0d29d2b3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1ebdfbb02641676fb4f8efb1f87cfe8d0d29d2b3/comments", "author": {"login": "denismerigoux", "id": 1766128, "node_id": "MDQ6VXNlcjE3NjYxMjg=", "avatar_url": "https://avatars.githubusercontent.com/u/1766128?v=4", "gravatar_id": "", "url": "https://api.github.com/users/denismerigoux", "html_url": "https://github.com/denismerigoux", "followers_url": "https://api.github.com/users/denismerigoux/followers", "following_url": "https://api.github.com/users/denismerigoux/following{/other_user}", "gists_url": "https://api.github.com/users/denismerigoux/gists{/gist_id}", "starred_url": "https://api.github.com/users/denismerigoux/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/denismerigoux/subscriptions", "organizations_url": "https://api.github.com/users/denismerigoux/orgs", "repos_url": "https://api.github.com/users/denismerigoux/repos", "events_url": "https://api.github.com/users/denismerigoux/events{/privacy}", "received_events_url": "https://api.github.com/users/denismerigoux/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "015e4441f5c540300477a7937a1517d407bc8436", "url": "https://api.github.com/repos/rust-lang/rust/commits/015e4441f5c540300477a7937a1517d407bc8436", "html_url": "https://github.com/rust-lang/rust/commit/015e4441f5c540300477a7937a1517d407bc8436"}], "stats": {"total": 142, "additions": 82, "deletions": 60}, "files": [{"sha": "b013545d390a89b5f87480fb82ec3105202b2c33", "filename": "src/librustc_codegen_llvm/builder.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1ebdfbb02641676fb4f8efb1f87cfe8d0d29d2b3/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ebdfbb02641676fb4f8efb1f87cfe8d0d29d2b3/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbuilder.rs?ref=1ebdfbb02641676fb4f8efb1f87cfe8d0d29d2b3", "patch": "@@ -95,7 +95,7 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         llfn: &'ll Value,\n         name: &'b str\n     ) -> Self {\n-        let bx = Builder::with_cx(cx);\n+        let mut bx = Builder::with_cx(cx);\n         let llbb = unsafe {\n             let name = SmallCStr::new(name);\n             llvm::LLVMAppendBasicBlockInContext(\n@@ -148,48 +148,48 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         }\n     }\n \n-    fn set_value_name(&self, value: &'ll Value, name: &str) {\n+    fn set_value_name(&mut self, value: &'ll Value, name: &str) {\n         let cname = SmallCStr::new(name);\n         unsafe {\n             llvm::LLVMSetValueName(value, cname.as_ptr());\n         }\n     }\n \n-    fn position_at_end(&self, llbb: &'ll BasicBlock) {\n+    fn position_at_end(&mut self, llbb: &'ll BasicBlock) {\n         unsafe {\n             llvm::LLVMPositionBuilderAtEnd(self.llbuilder, llbb);\n         }\n     }\n \n-    fn position_at_start(&self, llbb: &'ll BasicBlock) {\n+    fn position_at_start(&mut self, llbb: &'ll BasicBlock) {\n         unsafe {\n             llvm::LLVMRustPositionBuilderAtStart(self.llbuilder, llbb);\n         }\n     }\n \n-    fn ret_void(&self) {\n+    fn ret_void(&mut self) {\n         self.count_insn(\"retvoid\");\n         unsafe {\n             llvm::LLVMBuildRetVoid(self.llbuilder);\n         }\n     }\n \n-    fn ret(&self, v: &'ll Value) {\n+    fn ret(&mut self, v: &'ll Value) {\n         self.count_insn(\"ret\");\n         unsafe {\n             llvm::LLVMBuildRet(self.llbuilder, v);\n         }\n     }\n \n-    fn br(&self, dest: &'ll BasicBlock) {\n+    fn br(&mut self, dest: &'ll BasicBlock) {\n         self.count_insn(\"br\");\n         unsafe {\n             llvm::LLVMBuildBr(self.llbuilder, dest);\n         }\n     }\n \n     fn cond_br(\n-        &self,\n+        &mut self,\n         cond: &'ll Value,\n         then_llbb: &'ll BasicBlock,\n         else_llbb: &'ll BasicBlock,\n@@ -457,7 +457,7 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n     }\n \n     fn alloca(&self, ty: &'ll Type, name: &str, align: Align) -> &'ll Value {\n-        let bx = Builder::with_cx(self.cx);\n+        let mut bx = Builder::with_cx(self.cx);\n         bx.position_at_start(unsafe {\n             llvm::LLVMGetFirstBasicBlock(self.llfn())\n         });"}, {"sha": "7ea14055c3a09089b971b39b39e7e62ebc2ba9ca", "filename": "src/librustc_codegen_llvm/intrinsic.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1ebdfbb02641676fb4f8efb1f87cfe8d0d29d2b3/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ebdfbb02641676fb4f8efb1f87cfe8d0d29d2b3/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs?ref=1ebdfbb02641676fb4f8efb1f87cfe8d0d29d2b3", "patch": "@@ -832,10 +832,10 @@ fn codegen_msvc_try(\n \n         bx.set_personality_fn(bx.cx().eh_personality());\n \n-        let normal = bx.build_sibling_block(\"normal\");\n+        let mut normal = bx.build_sibling_block(\"normal\");\n         let catchswitch = bx.build_sibling_block(\"catchswitch\");\n         let catchpad = bx.build_sibling_block(\"catchpad\");\n-        let caught = bx.build_sibling_block(\"caught\");\n+        let mut caught = bx.build_sibling_block(\"caught\");\n \n         let func = llvm::get_param(bx.llfn(), 0);\n         let data = llvm::get_param(bx.llfn(), 1);\n@@ -956,8 +956,8 @@ fn codegen_gnu_try(\n         // expected to be `*mut *mut u8` for this to actually work, but that's\n         // managed by the standard library.\n \n-        let then = bx.build_sibling_block(\"then\");\n-        let catch = bx.build_sibling_block(\"catch\");\n+        let mut then = bx.build_sibling_block(\"then\");\n+        let mut catch = bx.build_sibling_block(\"catch\");\n \n         let func = llvm::get_param(bx.llfn(), 0);\n         let data = llvm::get_param(bx.llfn(), 1);"}, {"sha": "85a9e551abbe81d0a07fb7bbf5d99d329e638487", "filename": "src/librustc_codegen_llvm/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1ebdfbb02641676fb4f8efb1f87cfe8d0d29d2b3/src%2Flibrustc_codegen_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ebdfbb02641676fb4f8efb1f87cfe8d0d29d2b3/src%2Flibrustc_codegen_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Flib.rs?ref=1ebdfbb02641676fb4f8efb1f87cfe8d0d29d2b3", "patch": "@@ -129,7 +129,7 @@ mod value;\n \n pub struct LlvmCodegenBackend(());\n \n-impl BackendMethods for LlvmCodegenBackend {\n+impl ExtraBackendMethods for LlvmCodegenBackend {\n     type Module = ModuleLlvm;\n     type OngoingCodegen = OngoingCodegen;\n "}, {"sha": "8b8ea3f9ff5d7a25a1f93f3e6a46f0815b2b378c", "filename": "src/librustc_codegen_ssa/base.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1ebdfbb02641676fb4f8efb1f87cfe8d0d29d2b3/src%2Flibrustc_codegen_ssa%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ebdfbb02641676fb4f8efb1f87cfe8d0d29d2b3/src%2Flibrustc_codegen_ssa%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fbase.rs?ref=1ebdfbb02641676fb4f8efb1f87cfe8d0d29d2b3", "patch": "@@ -524,7 +524,7 @@ pub fn maybe_create_entry_wrapper<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n         cx.set_frame_pointer_elimination(llfn);\n         cx.apply_target_cpu_attr(llfn);\n \n-        let bx = Bx::new_block(&cx, llfn, \"top\");\n+        let mut bx = Bx::new_block(&cx, llfn, \"top\");\n \n         bx.insert_reference_to_gdb_debug_scripts_section_global();\n \n@@ -560,7 +560,7 @@ pub const CODEGEN_WORK_PACKAGE_KIND: time_graph::WorkPackageKind =\n     time_graph::WorkPackageKind(&[\"#DE9597\", \"#FED1D3\", \"#FDC5C7\", \"#B46668\", \"#88494B\"]);\n \n \n-pub fn codegen_crate<B: BackendMethods>(\n+pub fn codegen_crate<B: ExtraBackendMethods>(\n     backend: B,\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     rx: mpsc::Receiver<Box<dyn Any + Send>>\n@@ -785,29 +785,29 @@ pub fn codegen_crate<B: BackendMethods>(\n /// If you see this comment in the code, then it means that this workaround\n /// worked! We may yet one day track down the mysterious cause of that\n /// segfault...\n-struct AbortCodegenOnDrop<B: BackendMethods>(Option<B::OngoingCodegen>);\n+struct AbortCodegenOnDrop<B: ExtraBackendMethods>(Option<B::OngoingCodegen>);\n \n-impl<B: BackendMethods> AbortCodegenOnDrop<B> {\n+impl<B: ExtraBackendMethods> AbortCodegenOnDrop<B> {\n     fn into_inner(mut self) -> B::OngoingCodegen {\n         self.0.take().unwrap()\n     }\n }\n \n-impl<B: BackendMethods> Deref for AbortCodegenOnDrop<B> {\n+impl<B: ExtraBackendMethods> Deref for AbortCodegenOnDrop<B> {\n     type Target = B::OngoingCodegen;\n \n     fn deref(&self) -> &B::OngoingCodegen {\n         self.0.as_ref().unwrap()\n     }\n }\n \n-impl<B: BackendMethods> DerefMut for AbortCodegenOnDrop<B> {\n+impl<B: ExtraBackendMethods> DerefMut for AbortCodegenOnDrop<B> {\n     fn deref_mut(&mut self) -> &mut B::OngoingCodegen {\n         self.0.as_mut().unwrap()\n     }\n }\n \n-impl<B: BackendMethods> Drop for AbortCodegenOnDrop<B> {\n+impl<B: ExtraBackendMethods> Drop for AbortCodegenOnDrop<B> {\n     fn drop(&mut self) {\n         if let Some(codegen) = self.0.take() {\n             B::codegen_aborted(codegen);"}, {"sha": "aeaedda0b88ed2df5e0c8f3e67560ccdccf4cff8", "filename": "src/librustc_codegen_ssa/interfaces/backend.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1ebdfbb02641676fb4f8efb1f87cfe8d0d29d2b3/src%2Flibrustc_codegen_ssa%2Finterfaces%2Fbackend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ebdfbb02641676fb4f8efb1f87cfe8d0d29d2b3/src%2Flibrustc_codegen_ssa%2Finterfaces%2Fbackend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Finterfaces%2Fbackend.rs?ref=1ebdfbb02641676fb4f8efb1f87cfe8d0d29d2b3", "patch": "@@ -18,6 +18,7 @@ use rustc::mir::mono::Stats;\n use rustc::session::Session;\n use rustc::ty::TyCtxt;\n use rustc::util::time_graph::TimeGraph;\n+use rustc_codegen_utils::codegen_backend::CodegenBackend;\n use std::any::Any;\n use std::sync::mpsc::Receiver;\n use syntax_pos::symbol::InternedString;\n@@ -42,7 +43,7 @@ impl<'tcx, T> Backend<'tcx> for T where\n     Self: BackendTypes + HasTyCtxt<'tcx> + LayoutOf<Ty = Ty<'tcx>, TyLayout = TyLayout<'tcx>>\n {}\n \n-pub trait BackendMethods {\n+pub trait ExtraBackendMethods: CodegenBackend {\n     type Module;\n     type OngoingCodegen;\n "}, {"sha": "38ab019343adaaf929a3e5d4bb153eb5693f66bf", "filename": "src/librustc_codegen_ssa/interfaces/builder.rs", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/1ebdfbb02641676fb4f8efb1f87cfe8d0d29d2b3/src%2Flibrustc_codegen_ssa%2Finterfaces%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ebdfbb02641676fb4f8efb1f87cfe8d0d29d2b3/src%2Flibrustc_codegen_ssa%2Finterfaces%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Finterfaces%2Fbuilder.rs?ref=1ebdfbb02641676fb4f8efb1f87cfe8d0d29d2b3", "patch": "@@ -41,13 +41,18 @@ pub trait BuilderMethods<'a, 'tcx: 'a>:\n     fn llbb(&self) -> Self::BasicBlock;\n     fn count_insn(&self, category: &str);\n \n-    fn set_value_name(&self, value: Self::Value, name: &str);\n-    fn position_at_end(&self, llbb: Self::BasicBlock);\n-    fn position_at_start(&self, llbb: Self::BasicBlock);\n-    fn ret_void(&self);\n-    fn ret(&self, v: Self::Value);\n-    fn br(&self, dest: Self::BasicBlock);\n-    fn cond_br(&self, cond: Self::Value, then_llbb: Self::BasicBlock, else_llbb: Self::BasicBlock);\n+    fn set_value_name(&mut self, value: Self::Value, name: &str);\n+    fn position_at_end(&mut self, llbb: Self::BasicBlock);\n+    fn position_at_start(&mut self, llbb: Self::BasicBlock);\n+    fn ret_void(&mut self);\n+    fn ret(&mut self, v: Self::Value);\n+    fn br(&mut self, dest: Self::BasicBlock);\n+    fn cond_br(\n+        &mut self,\n+        cond: Self::Value,\n+        then_llbb: Self::BasicBlock,\n+        else_llbb: Self::BasicBlock,\n+    );\n     fn switch(&self, v: Self::Value, else_llbb: Self::BasicBlock, num_cases: usize) -> Self::Value;\n     fn invoke(\n         &self,"}, {"sha": "1797060f6a4a9defbb726ebc0ad985ab8bbaaf26", "filename": "src/librustc_codegen_ssa/interfaces/mod.rs", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1ebdfbb02641676fb4f8efb1f87cfe8d0d29d2b3/src%2Flibrustc_codegen_ssa%2Finterfaces%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ebdfbb02641676fb4f8efb1f87cfe8d0d29d2b3/src%2Flibrustc_codegen_ssa%2Finterfaces%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Finterfaces%2Fmod.rs?ref=1ebdfbb02641676fb4f8efb1f87cfe8d0d29d2b3", "patch": "@@ -8,6 +8,22 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+//! Interface of a Rust codegen backend\n+//!\n+//! This crate defines all the traits that have to be implemented by a codegen backend in order to\n+//! use the backend-agnostic codegen code in `rustc_codegen_ssa`.\n+//!\n+//! The interface is designed around two backend-specific data structures, the codegen context and\n+//! the builder. The codegen context is supposed to be read-only after its creation and during the\n+//! actual codegen, while the builder stores the information about the function during codegen and\n+//! is used to produce the instructions of the backend IR.\n+//!\n+//! Finaly, a third `Backend` structure has to implement methods related to how codegen information\n+//! is passed to the backend, especially for asynchronous compilation.\n+//!\n+//! The traits contain associated types that are backend-specific, such as the backend's value or\n+//! basic blocks.\n+\n mod abi;\n mod asm;\n mod backend;\n@@ -22,7 +38,7 @@ mod type_;\n \n pub use self::abi::{AbiBuilderMethods, AbiMethods};\n pub use self::asm::{AsmBuilderMethods, AsmMethods};\n-pub use self::backend::{Backend, BackendMethods, BackendTypes};\n+pub use self::backend::{Backend, BackendTypes, ExtraBackendMethods};\n pub use self::builder::BuilderMethods;\n pub use self::consts::ConstMethods;\n pub use self::debuginfo::{DebugInfoBuilderMethods, DebugInfoMethods};"}, {"sha": "290ee791a1d9cec169ea25ed7f88b21b508fd0c6", "filename": "src/librustc_codegen_ssa/interfaces/type_.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1ebdfbb02641676fb4f8efb1f87cfe8d0d29d2b3/src%2Flibrustc_codegen_ssa%2Finterfaces%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ebdfbb02641676fb4f8efb1f87cfe8d0d29d2b3/src%2Flibrustc_codegen_ssa%2Finterfaces%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Finterfaces%2Ftype_.rs?ref=1ebdfbb02641676fb4f8efb1f87cfe8d0d29d2b3", "patch": "@@ -16,7 +16,7 @@ use rustc::ty::layout::TyLayout;\n use rustc::ty::layout::{self, Align, Size};\n use rustc::ty::Ty;\n use rustc::util::nodemap::FxHashMap;\n-    use rustc_target::abi::call::{ArgType, CastTarget, FnType, Reg};\n+use rustc_target::abi::call::{ArgType, CastTarget, FnType, Reg};\n use std::cell::RefCell;\n use syntax::ast;\n "}, {"sha": "2a42ad91e3d5809e29bfd99b3d0f79b8501eb177", "filename": "src/librustc_codegen_ssa/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1ebdfbb02641676fb4f8efb1f87cfe8d0d29d2b3/src%2Flibrustc_codegen_ssa%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ebdfbb02641676fb4f8efb1f87cfe8d0d29d2b3/src%2Flibrustc_codegen_ssa%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Flib.rs?ref=1ebdfbb02641676fb4f8efb1f87cfe8d0d29d2b3", "patch": "@@ -8,10 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! # Note\n-//!\n-//! This API is completely unstable and subject to change.\n-\n #![doc(html_logo_url = \"https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n       html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n       html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n@@ -28,6 +24,10 @@\n #![allow(dead_code)]\n #![feature(quote)]\n \n+//! This crate contains codegen code that is used by all codegen backends (LLVM and others).\n+//! The backend-agnostic functions of this crate use functions defined in various traits that\n+//! have to be implemented by each backends.\n+\n #[macro_use] extern crate bitflags;\n #[macro_use] extern crate log;\n extern crate rustc_apfloat;"}, {"sha": "6fc7a266dd4d6e8dcc1ba02f79ba441175b507d3", "filename": "src/librustc_codegen_ssa/mir/block.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/1ebdfbb02641676fb4f8efb1f87cfe8d0d29d2b3/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ebdfbb02641676fb4f8efb1f87cfe8d0d29d2b3/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs?ref=1ebdfbb02641676fb4f8efb1f87cfe8d0d29d2b3", "patch": "@@ -111,7 +111,7 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         };\n \n         let funclet_br =\n-            |this: &mut Self, bx: &Bx, target: mir::BasicBlock| {\n+            |this: &mut Self, bx: &mut Bx, target: mir::BasicBlock| {\n                 let (lltarget, is_cleanupret) = lltarget(this, target);\n                 if is_cleanupret {\n                     // micro-optimization: generate a `ret` rather than a jump\n@@ -124,7 +124,7 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n \n         let do_call = |\n             this: &mut Self,\n-            bx: &Bx,\n+            bx: &mut Bx,\n             fn_ty: FnType<'tcx, Ty<'tcx>>,\n             fn_ptr: Bx::Value,\n             llargs: &[Bx::Value],\n@@ -200,7 +200,7 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             }\n \n             mir::TerminatorKind::Goto { target } => {\n-                funclet_br(self, &bx, target);\n+                funclet_br(self, &mut bx, target);\n             }\n \n             mir::TerminatorKind::SwitchInt { ref discr, switch_ty, ref values, ref targets } => {\n@@ -302,7 +302,7 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n \n                 if let ty::InstanceDef::DropGlue(_, None) = drop_fn.def {\n                     // we don't actually need to drop anything.\n-                    funclet_br(self, &bx, target);\n+                    funclet_br(self, &mut bx, target);\n                     return\n                 }\n \n@@ -332,7 +332,7 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                          bx.cx().fn_type_of_instance(&drop_fn))\n                     }\n                 };\n-                do_call(self, &bx, fn_ty, drop_fn, args,\n+                do_call(self, &mut bx, fn_ty, drop_fn, args,\n                         Some((ReturnDest::Nothing, target)),\n                         unwind);\n             }\n@@ -356,7 +356,7 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n \n                 // Don't codegen the panic block if success if known.\n                 if const_cond == Some(expected) {\n-                    funclet_br(self, &bx, target);\n+                    funclet_br(self, &mut bx, target);\n                     return;\n                 }\n \n@@ -427,7 +427,7 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 let llfn = bx.cx().get_fn(instance);\n \n                 // Codegen the actual panic invoke/call.\n-                do_call(self, &bx, fn_ty, llfn, &args, None, cleanup);\n+                do_call(self, &mut bx, fn_ty, llfn, &args, None, cleanup);\n             }\n \n             mir::TerminatorKind::DropAndReplace { .. } => {\n@@ -477,7 +477,7 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                     if let Some(destination_ref) = destination.as_ref() {\n                         let &(ref dest, target) = destination_ref;\n                         self.codegen_transmute(&bx, &args[0], dest);\n-                        funclet_br(self, &bx, target);\n+                        funclet_br(self, &mut bx, target);\n                     } else {\n                         // If we are trying to transmute to an uninhabited type,\n                         // it is likely there is no allotted destination. In fact,\n@@ -504,7 +504,7 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                     Some(ty::InstanceDef::DropGlue(_, None)) => {\n                         // empty drop glue - a nop.\n                         let &(_, target) = destination.as_ref().unwrap();\n-                        funclet_br(self, &bx, target);\n+                        funclet_br(self, &mut bx, target);\n                         return;\n                     }\n                     _ => bx.cx().new_fn_type(sig, &extra_args)\n@@ -550,7 +550,7 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                     // Codegen the actual panic invoke/call.\n                     do_call(\n                         self,\n-                        &bx,\n+                        &mut bx,\n                         fn_ty,\n                         llfn,\n                         &[msg_file_line_col],\n@@ -648,7 +648,7 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                     }\n \n                     if let Some((_, target)) = *destination {\n-                        funclet_br(self, &bx, target);\n+                        funclet_br(self, &mut bx, target);\n                     } else {\n                         bx.unreachable();\n                     }\n@@ -740,7 +740,7 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                     _ => span_bug!(span, \"no llfn for call\"),\n                 };\n \n-                do_call(self, &bx, fn_ty, fn_ptr, &llargs,\n+                do_call(self, &mut bx, fn_ty, fn_ptr, &llargs,\n                         destination.as_ref().map(|&(_, target)| (ret_dest, target)),\n                         cleanup);\n             }\n@@ -913,7 +913,7 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             span_bug!(self.mir.span, \"landing pad was not inserted?\")\n         }\n \n-        let bx = self.new_block(\"cleanup\");\n+        let mut bx = self.new_block(\"cleanup\");\n \n         let llpersonality = self.cx.eh_personality();\n         let llretty = self.landing_pad_type();\n@@ -952,7 +952,7 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         &self,\n         bb: mir::BasicBlock\n     ) -> Bx {\n-        let bx = Bx::with_cx(self.cx);\n+        let mut bx = Bx::with_cx(self.cx);\n         bx.position_at_end(self.blocks[bb]);\n         bx\n     }"}, {"sha": "dcd3f828361785a96d2f7869530505bad248f893", "filename": "src/librustc_codegen_ssa/mir/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1ebdfbb02641676fb4f8efb1f87cfe8d0d29d2b3/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ebdfbb02641676fb4f8efb1f87cfe8d0d29d2b3/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs?ref=1ebdfbb02641676fb4f8efb1f87cfe8d0d29d2b3", "patch": "@@ -214,7 +214,7 @@ pub fn codegen_mir<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n     debug!(\"fn_ty: {:?}\", fn_ty);\n     let debug_context =\n         cx.create_function_debug_context(instance, sig, llfn, mir);\n-    let bx = Bx::new_block(cx, llfn, \"start\");\n+    let mut bx = Bx::new_block(cx, llfn, \"start\");\n \n     if mir.basic_blocks().iter().any(|bb| bb.is_cleanup) {\n         bx.set_personality_fn(cx.eh_personality());\n@@ -235,7 +235,7 @@ pub fn codegen_mir<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n \n     // Compute debuginfo scopes from MIR scopes.\n     let scopes = cx.create_mir_scopes(mir, &debug_context);\n-    let (landing_pads, funclets) = create_funclets(mir, &bx, &cleanup_kinds, &block_bxs);\n+    let (landing_pads, funclets) = create_funclets(mir, &mut bx, &cleanup_kinds, &block_bxs);\n \n     let mut fx = FunctionCx {\n         instance,\n@@ -262,7 +262,7 @@ pub fn codegen_mir<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n \n     // Allocate variable and temp allocas\n     fx.locals = {\n-        let args = arg_local_refs(&bx, &fx, &fx.scopes, &memory_locals);\n+        let args = arg_local_refs(&mut bx, &fx, &fx.scopes, &memory_locals);\n \n         let allocate_local = |local| {\n             let decl = &mir.local_decls[local];\n@@ -363,7 +363,7 @@ pub fn codegen_mir<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n \n fn create_funclets<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n     mir: &'a Mir<'tcx>,\n-    bx: &Bx,\n+    bx: &mut Bx,\n     cleanup_kinds: &IndexVec<mir::BasicBlock, CleanupKind>,\n     block_bxs: &IndexVec<mir::BasicBlock, Bx::BasicBlock>)\n     -> (IndexVec<mir::BasicBlock, Option<Bx::BasicBlock>>,\n@@ -400,7 +400,7 @@ fn create_funclets<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n             //      }\n             Some(&mir::TerminatorKind::Abort) => {\n                 let cs_bx = bx.build_sibling_block(&format!(\"cs_funclet{:?}\", bb));\n-                let cp_bx = bx.build_sibling_block(&format!(\"cp_funclet{:?}\", bb));\n+                let mut cp_bx = bx.build_sibling_block(&format!(\"cp_funclet{:?}\", bb));\n                 ret_llbb = cs_bx.llbb();\n \n                 let cs = cs_bx.catch_switch(None, None, 1);\n@@ -416,7 +416,7 @@ fn create_funclets<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n                 cp_bx.br(llbb);\n             }\n             _ => {\n-                let cleanup_bx = bx.build_sibling_block(&format!(\"funclet_{:?}\", bb));\n+                let mut cleanup_bx = bx.build_sibling_block(&format!(\"funclet_{:?}\", bb));\n                 ret_llbb = cleanup_bx.llbb();\n                 funclet = cleanup_bx.cleanup_pad(None, &[]);\n                 cleanup_bx.br(llbb);\n@@ -431,7 +431,7 @@ fn create_funclets<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n /// argument's value. As arguments are places, these are always\n /// indirect.\n fn arg_local_refs<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n-    bx: &Bx,\n+    bx: &mut Bx,\n     fx: &FunctionCx<'a, 'tcx, Bx>,\n     scopes: &IndexVec<\n         mir::SourceScope,\n@@ -440,7 +440,7 @@ fn arg_local_refs<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n     memory_locals: &BitSet<mir::Local>,\n ) -> Vec<LocalRef<'tcx, Bx::Value>> {\n     let mir = fx.mir;\n-    let tcx = bx.tcx();\n+    let tcx = fx.cx.tcx();\n     let mut idx = 0;\n     let mut llarg_idx = fx.fn_ty.ret.is_indirect() as usize;\n "}, {"sha": "2efc5af1fc60eb2c2994ccbda7104f037b470acc", "filename": "src/librustc_codegen_ssa/mir/rvalue.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1ebdfbb02641676fb4f8efb1f87cfe8d0d29d2b3/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ebdfbb02641676fb4f8efb1f87cfe8d0d29d2b3/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs?ref=1ebdfbb02641676fb4f8efb1f87cfe8d0d29d2b3", "patch": "@@ -31,7 +31,7 @@ use super::place::PlaceRef;\n impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n     pub fn codegen_rvalue(\n         &mut self,\n-        bx: Bx,\n+        mut bx: Bx,\n         dest: PlaceRef<'tcx, Bx::Value>,\n         rvalue: &mir::Rvalue<'tcx>\n     ) -> Bx {\n@@ -121,8 +121,8 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 let count = bx.cx().const_usize(count);\n                 let end = dest.project_index(&bx, count).llval;\n \n-                let header_bx = bx.build_sibling_block(\"repeat_loop_header\");\n-                let body_bx = bx.build_sibling_block(\"repeat_loop_body\");\n+                let mut header_bx = bx.build_sibling_block(\"repeat_loop_header\");\n+                let mut body_bx = bx.build_sibling_block(\"repeat_loop_body\");\n                 let next_bx = bx.build_sibling_block(\"repeat_loop_next\");\n \n                 bx.br(header_bx.llbb());"}]}