{"sha": "552a8875bd5520c2e8c01ab05a12c304c730c5b9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU1MmE4ODc1YmQ1NTIwYzJlOGMwMWFiMDVhMTJjMzA0YzczMGM1Yjk=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2020-03-09T17:50:12Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2020-03-09T21:56:09Z"}, "message": "expand: Implement support for retrying macro expansions", "tree": {"sha": "c5c1a5f0326f91738981442575103352b0d114d0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c5c1a5f0326f91738981442575103352b0d114d0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/552a8875bd5520c2e8c01ab05a12c304c730c5b9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/552a8875bd5520c2e8c01ab05a12c304c730c5b9", "html_url": "https://github.com/rust-lang/rust/commit/552a8875bd5520c2e8c01ab05a12c304c730c5b9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/552a8875bd5520c2e8c01ab05a12c304c730c5b9/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eafeb9a2676e16ed322e9e0695b5ce9407f5de8d", "url": "https://api.github.com/repos/rust-lang/rust/commits/eafeb9a2676e16ed322e9e0695b5ce9407f5de8d", "html_url": "https://github.com/rust-lang/rust/commit/eafeb9a2676e16ed322e9e0695b5ce9407f5de8d"}], "stats": {"total": 178, "additions": 124, "deletions": 54}, "files": [{"sha": "b5ad67abf620106daefcee76e66de633e7b77017", "filename": "src/librustc_builtin_macros/deriving/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/552a8875bd5520c2e8c01ab05a12c304c730c5b9/src%2Flibrustc_builtin_macros%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552a8875bd5520c2e8c01ab05a12c304c730c5b9/src%2Flibrustc_builtin_macros%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fderiving%2Fmod.rs?ref=552a8875bd5520c2e8c01ab05a12c304c730c5b9", "patch": "@@ -2,7 +2,7 @@\n \n use rustc_ast::ast::{self, ItemKind, MetaItem};\n use rustc_ast::ptr::P;\n-use rustc_expand::base::{Annotatable, ExtCtxt, MultiItemModifier};\n+use rustc_expand::base::{Annotatable, ExpandResult, ExtCtxt, MultiItemModifier};\n use rustc_span::symbol::{sym, Symbol};\n use rustc_span::Span;\n \n@@ -48,13 +48,13 @@ impl MultiItemModifier for BuiltinDerive {\n         span: Span,\n         meta_item: &MetaItem,\n         item: Annotatable,\n-    ) -> Vec<Annotatable> {\n+    ) -> ExpandResult<Vec<Annotatable>, Annotatable> {\n         // FIXME: Built-in derives often forget to give spans contexts,\n         // so we are doing it here in a centralized way.\n         let span = ecx.with_def_site_ctxt(span);\n         let mut items = Vec::new();\n         (self.0)(ecx, span, meta_item, &item, &mut |a| items.push(a));\n-        items\n+        ExpandResult::Ready(items)\n     }\n }\n "}, {"sha": "3782746a57de4cfd04f328e335883ca3a3a4ec73", "filename": "src/librustc_expand/base.rs", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/552a8875bd5520c2e8c01ab05a12c304c730c5b9/src%2Flibrustc_expand%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552a8875bd5520c2e8c01ab05a12c304c730c5b9/src%2Flibrustc_expand%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fbase.rs?ref=552a8875bd5520c2e8c01ab05a12c304c730c5b9", "patch": "@@ -258,16 +258,25 @@ impl Annotatable {\n     }\n }\n \n-// `meta_item` is the annotation, and `item` is the item being modified.\n-// FIXME Decorators should follow the same pattern too.\n+/// Result of an expansion that may need to be retried.\n+/// Consider using this for non-`MultiItemModifier` expanders as well.\n+pub enum ExpandResult<T, U> {\n+    /// Expansion produced a result (possibly dummy).\n+    Ready(T),\n+    /// Expansion could not produce a result and needs to be retried.\n+    /// The string is an explanation that will be printed if we are stuck in an infinite retry loop.\n+    Retry(U, String),\n+}\n+\n+// `meta_item` is the attribute, and `item` is the item being modified.\n pub trait MultiItemModifier {\n     fn expand(\n         &self,\n         ecx: &mut ExtCtxt<'_>,\n         span: Span,\n         meta_item: &ast::MetaItem,\n         item: Annotatable,\n-    ) -> Vec<Annotatable>;\n+    ) -> ExpandResult<Vec<Annotatable>, Annotatable>;\n }\n \n impl<F> MultiItemModifier for F\n@@ -280,8 +289,8 @@ where\n         span: Span,\n         meta_item: &ast::MetaItem,\n         item: Annotatable,\n-    ) -> Vec<Annotatable> {\n-        self(ecx, span, meta_item, item)\n+    ) -> ExpandResult<Vec<Annotatable>, Annotatable> {\n+        ExpandResult::Ready(self(ecx, span, meta_item, item))\n     }\n }\n "}, {"sha": "f2af6755517f1c5664a166d8faa12195637b0350", "filename": "src/librustc_expand/expand.rs", "status": "modified", "additions": 103, "deletions": 42, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/552a8875bd5520c2e8c01ab05a12c304c730c5b9/src%2Flibrustc_expand%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552a8875bd5520c2e8c01ab05a12c304c730c5b9/src%2Flibrustc_expand%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fexpand.rs?ref=552a8875bd5520c2e8c01ab05a12c304c730c5b9", "patch": "@@ -408,7 +408,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         let mut undetermined_invocations = Vec::new();\n         let (mut progress, mut force) = (false, !self.monotonic);\n         loop {\n-            let invoc = if let Some(invoc) = invocations.pop() {\n+            let (invoc, res) = if let Some(invoc) = invocations.pop() {\n                 invoc\n             } else {\n                 self.resolve_imports();\n@@ -420,30 +420,51 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                 continue;\n             };\n \n-            let eager_expansion_root =\n-                if self.monotonic { invoc.expansion_data.id } else { orig_expansion_data.id };\n-            let res = match self.cx.resolver.resolve_macro_invocation(\n-                &invoc,\n-                eager_expansion_root,\n-                force,\n-            ) {\n-                Ok(res) => res,\n-                Err(Indeterminate) => {\n-                    undetermined_invocations.push(invoc);\n-                    continue;\n+            let res = match res {\n+                Some(res) => res,\n+                None => {\n+                    let eager_expansion_root = if self.monotonic {\n+                        invoc.expansion_data.id\n+                    } else {\n+                        orig_expansion_data.id\n+                    };\n+                    match self.cx.resolver.resolve_macro_invocation(\n+                        &invoc,\n+                        eager_expansion_root,\n+                        force,\n+                    ) {\n+                        Ok(res) => res,\n+                        Err(Indeterminate) => {\n+                            // Cannot resolve, will retry this invocation later.\n+                            undetermined_invocations.push((invoc, None));\n+                            continue;\n+                        }\n+                    }\n                 }\n             };\n \n-            progress = true;\n             let ExpansionData { depth, id: expn_id, .. } = invoc.expansion_data;\n             self.cx.current_expansion = invoc.expansion_data.clone();\n \n             // FIXME(jseyfried): Refactor out the following logic\n             let (expanded_fragment, new_invocations) = match res {\n-                InvocationRes::Single(ext) => {\n-                    let fragment = self.expand_invoc(invoc, &ext.kind);\n-                    self.collect_invocations(fragment, &[])\n-                }\n+                InvocationRes::Single(ext) => match self.expand_invoc(invoc, &ext.kind) {\n+                    ExpandResult::Ready(fragment) => self.collect_invocations(fragment, &[]),\n+                    ExpandResult::Retry(invoc, explanation) => {\n+                        if force {\n+                            // We are stuck, stop retrying and produce a dummy fragment.\n+                            let span = invoc.span();\n+                            self.cx.span_err(span, &explanation);\n+                            let fragment = invoc.fragment_kind.dummy(span);\n+                            self.collect_invocations(fragment, &[])\n+                        } else {\n+                            // Cannot expand, will retry this invocation later.\n+                            undetermined_invocations\n+                                .push((invoc, Some(InvocationRes::Single(ext))));\n+                            continue;\n+                        }\n+                    }\n+                },\n                 InvocationRes::DeriveContainer(_exts) => {\n                     // FIXME: Consider using the derive resolutions (`_exts`) immediately,\n                     // instead of enqueuing the derives to be resolved again later.\n@@ -463,21 +484,25 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                     for path in derives {\n                         let expn_id = ExpnId::fresh(None);\n                         derive_placeholders.push(NodeId::placeholder_from_expn_id(expn_id));\n-                        invocations.push(Invocation {\n-                            kind: InvocationKind::Derive { path, item: item.clone() },\n-                            fragment_kind: invoc.fragment_kind,\n-                            expansion_data: ExpansionData {\n-                                id: expn_id,\n-                                ..invoc.expansion_data.clone()\n+                        invocations.push((\n+                            Invocation {\n+                                kind: InvocationKind::Derive { path, item: item.clone() },\n+                                fragment_kind: invoc.fragment_kind,\n+                                expansion_data: ExpansionData {\n+                                    id: expn_id,\n+                                    ..invoc.expansion_data.clone()\n+                                },\n                             },\n-                        });\n+                            None,\n+                        ));\n                     }\n                     let fragment =\n                         invoc.fragment_kind.expect_from_annotatables(::std::iter::once(item));\n                     self.collect_invocations(fragment, &derive_placeholders)\n                 }\n             };\n \n+            progress = true;\n             if expanded_fragments.len() < depth {\n                 expanded_fragments.push(Vec::new());\n             }\n@@ -535,7 +560,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         &mut self,\n         mut fragment: AstFragment,\n         extra_placeholders: &[NodeId],\n-    ) -> (AstFragment, Vec<Invocation>) {\n+    ) -> (AstFragment, Vec<(Invocation, Option<InvocationRes>)>) {\n         // Resolve `$crate`s in the fragment for pretty-printing.\n         self.cx.resolver.resolve_dollar_crates();\n \n@@ -635,13 +660,17 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         self.cx.trace_macros_diag();\n     }\n \n-    fn expand_invoc(&mut self, invoc: Invocation, ext: &SyntaxExtensionKind) -> AstFragment {\n+    fn expand_invoc(\n+        &mut self,\n+        invoc: Invocation,\n+        ext: &SyntaxExtensionKind,\n+    ) -> ExpandResult<AstFragment, Invocation> {\n         if self.cx.current_expansion.depth > self.cx.ecfg.recursion_limit {\n             self.error_recursion_limit_reached();\n         }\n \n         let (fragment_kind, span) = (invoc.fragment_kind, invoc.span());\n-        match invoc.kind {\n+        ExpandResult::Ready(match invoc.kind {\n             InvocationKind::Bang { mac, .. } => match ext {\n                 SyntaxExtensionKind::Bang(expander) => {\n                     self.gate_proc_macro_expansion_kind(span, fragment_kind);\n@@ -663,7 +692,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                 }\n                 _ => unreachable!(),\n             },\n-            InvocationKind::Attr { attr, mut item, .. } => match ext {\n+            InvocationKind::Attr { attr, mut item, derives, after_derive } => match ext {\n                 SyntaxExtensionKind::Attr(expander) => {\n                     self.gate_proc_macro_input(&item);\n                     self.gate_proc_macro_attr_item(span, &item);\n@@ -679,8 +708,25 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                 SyntaxExtensionKind::LegacyAttr(expander) => {\n                     match validate_attr::parse_meta(self.cx.parse_sess, &attr) {\n                         Ok(meta) => {\n-                            let item = expander.expand(self.cx, span, &meta, item);\n-                            fragment_kind.expect_from_annotatables(item)\n+                            let items = match expander.expand(self.cx, span, &meta, item) {\n+                                ExpandResult::Ready(items) => items,\n+                                ExpandResult::Retry(item, explanation) => {\n+                                    // Reassemble the original invocation for retrying.\n+                                    return ExpandResult::Retry(\n+                                        Invocation {\n+                                            kind: InvocationKind::Attr {\n+                                                attr,\n+                                                item,\n+                                                derives,\n+                                                after_derive,\n+                                            },\n+                                            ..invoc\n+                                        },\n+                                        explanation,\n+                                    );\n+                                }\n+                            };\n+                            fragment_kind.expect_from_annotatables(items)\n                         }\n                         Err(mut err) => {\n                             err.emit();\n@@ -702,19 +748,31 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                 SyntaxExtensionKind::Derive(expander)\n                 | SyntaxExtensionKind::LegacyDerive(expander) => {\n                     if !item.derive_allowed() {\n-                        return fragment_kind.dummy(span);\n+                        return ExpandResult::Ready(fragment_kind.dummy(span));\n                     }\n                     if let SyntaxExtensionKind::Derive(..) = ext {\n                         self.gate_proc_macro_input(&item);\n                     }\n                     let meta = ast::MetaItem { kind: ast::MetaItemKind::Word, span, path };\n-                    let items = expander.expand(self.cx, span, &meta, item);\n+                    let items = match expander.expand(self.cx, span, &meta, item) {\n+                        ExpandResult::Ready(items) => items,\n+                        ExpandResult::Retry(item, explanation) => {\n+                            // Reassemble the original invocation for retrying.\n+                            return ExpandResult::Retry(\n+                                Invocation {\n+                                    kind: InvocationKind::Derive { path: meta.path, item },\n+                                    ..invoc\n+                                },\n+                                explanation,\n+                            );\n+                        }\n+                    };\n                     fragment_kind.expect_from_annotatables(items)\n                 }\n                 _ => unreachable!(),\n             },\n             InvocationKind::DeriveContainer { .. } => unreachable!(),\n-        }\n+        })\n     }\n \n     fn gate_proc_macro_attr_item(&self, span: Span, item: &Annotatable) {\n@@ -933,7 +991,7 @@ pub fn ensure_complete_parse<'a>(\n struct InvocationCollector<'a, 'b> {\n     cx: &'a mut ExtCtxt<'b>,\n     cfg: StripUnconfigured<'a>,\n-    invocations: Vec<Invocation>,\n+    invocations: Vec<(Invocation, Option<InvocationRes>)>,\n     monotonic: bool,\n }\n \n@@ -955,15 +1013,18 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n         };\n         let expn_id = ExpnId::fresh(expn_data);\n         let vis = kind.placeholder_visibility();\n-        self.invocations.push(Invocation {\n-            kind,\n-            fragment_kind,\n-            expansion_data: ExpansionData {\n-                id: expn_id,\n-                depth: self.cx.current_expansion.depth + 1,\n-                ..self.cx.current_expansion.clone()\n+        self.invocations.push((\n+            Invocation {\n+                kind,\n+                fragment_kind,\n+                expansion_data: ExpansionData {\n+                    id: expn_id,\n+                    depth: self.cx.current_expansion.depth + 1,\n+                    ..self.cx.current_expansion.clone()\n+                },\n             },\n-        });\n+            None,\n+        ));\n         placeholder(fragment_kind, NodeId::placeholder_from_expn_id(expn_id), vis)\n     }\n "}, {"sha": "cb9afa4cd4f0287c324cc0129d9476e66873c233", "filename": "src/librustc_expand/proc_macro.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/552a8875bd5520c2e8c01ab05a12c304c730c5b9/src%2Flibrustc_expand%2Fproc_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552a8875bd5520c2e8c01ab05a12c304c730c5b9/src%2Flibrustc_expand%2Fproc_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fproc_macro.rs?ref=552a8875bd5520c2e8c01ab05a12c304c730c5b9", "patch": "@@ -79,7 +79,7 @@ impl MultiItemModifier for ProcMacroDerive {\n         span: Span,\n         _meta_item: &ast::MetaItem,\n         item: Annotatable,\n-    ) -> Vec<Annotatable> {\n+    ) -> ExpandResult<Vec<Annotatable>, Annotatable> {\n         let item = match item {\n             Annotatable::Arm(..)\n             | Annotatable::Field(..)\n@@ -99,7 +99,7 @@ impl MultiItemModifier for ProcMacroDerive {\n                     \"proc-macro derives may only be \\\n                                     applied to a struct, enum, or union\",\n                 );\n-                return Vec::new();\n+                return ExpandResult::Ready(Vec::new());\n             }\n         };\n         match item.kind {\n@@ -110,7 +110,7 @@ impl MultiItemModifier for ProcMacroDerive {\n                     \"proc-macro derives may only be \\\n                                     applied to a struct, enum, or union\",\n                 );\n-                return Vec::new();\n+                return ExpandResult::Ready(Vec::new());\n             }\n         }\n \n@@ -158,7 +158,7 @@ impl MultiItemModifier for ProcMacroDerive {\n             FatalError.raise();\n         }\n \n-        items\n+        ExpandResult::Ready(items)\n     }\n }\n "}]}