{"sha": "defc7ad772123a449f7cc384dd46d88c3a45fb53", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRlZmM3YWQ3NzIxMjNhNDQ5ZjdjYzM4NGRkNDZkODhjM2E0NWZiNTM=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2019-11-09T10:16:48Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-11-09T10:16:48Z"}, "message": "Merge #2197\n\n2197: Remove typed macro parsing API r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "b0b01d1397542585802a3622fdf9491e20fa8c0b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b0b01d1397542585802a3622fdf9491e20fa8c0b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/defc7ad772123a449f7cc384dd46d88c3a45fb53", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdxpIQCRBK7hj4Ov3rIwAAdHIIAINN7Nu/I76LewlRAQarKv3G\nP+OolfgoQFUGXDDAyi86JTAF8G9qHVd2eb75H5yx/9BJfTcMEfwPwMWYatXVijnU\nO7Fzr0VcAq77C2O1dijDTuS+fmmkdF/qd9ZAf4y+7LqOHqMINI1AdBwPtm+sHq7w\ngijPb1C9cKIrPGpFYZtJNC+QLOZitj+VIGFPRTTgUbR0EoA+cWgskzhF7cUzjbL7\nXUlLwq9bv9mOLdNLfF8kSqtrmXpLTUZ+KgycdmcTWJLiZad6pyI1hlaLgN6KCurk\nAFPYuLOGQPqbUWVIWTEqIrB55mk7YNBj43WJ/Sbo0EvyU/k7LJSlUvfCALZ2BDI=\n=8gqE\n-----END PGP SIGNATURE-----\n", "payload": "tree b0b01d1397542585802a3622fdf9491e20fa8c0b\nparent 561bb979cecd786f5d311ea7bddb1e15d77a3848\nparent 70f2a21b55c1b09e575798a75807e13991f2cfec\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1573294608 +0000\ncommitter GitHub <noreply@github.com> 1573294608 +0000\n\nMerge #2197\n\n2197: Remove typed macro parsing API r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/defc7ad772123a449f7cc384dd46d88c3a45fb53", "html_url": "https://github.com/rust-lang/rust/commit/defc7ad772123a449f7cc384dd46d88c3a45fb53", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/defc7ad772123a449f7cc384dd46d88c3a45fb53/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "561bb979cecd786f5d311ea7bddb1e15d77a3848", "url": "https://api.github.com/repos/rust-lang/rust/commits/561bb979cecd786f5d311ea7bddb1e15d77a3848", "html_url": "https://github.com/rust-lang/rust/commit/561bb979cecd786f5d311ea7bddb1e15d77a3848"}, {"sha": "70f2a21b55c1b09e575798a75807e13991f2cfec", "url": "https://api.github.com/repos/rust-lang/rust/commits/70f2a21b55c1b09e575798a75807e13991f2cfec", "html_url": "https://github.com/rust-lang/rust/commit/70f2a21b55c1b09e575798a75807e13991f2cfec"}], "stats": {"total": 170, "additions": 92, "deletions": 78}, "files": [{"sha": "37ff1ce7631da55ba7eb50ce918c74dcea7811d9", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/defc7ad772123a449f7cc384dd46d88c3a45fb53/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/defc7ad772123a449f7cc384dd46d88c3a45fb53/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=defc7ad772123a449f7cc384dd46d88c3a45fb53", "patch": "@@ -1060,6 +1060,7 @@ dependencies = [\n  \"ra_arena 0.1.0\",\n  \"ra_db 0.1.0\",\n  \"ra_mbe 0.1.0\",\n+ \"ra_parser 0.1.0\",\n  \"ra_prof 0.1.0\",\n  \"ra_syntax 0.1.0\",\n  \"ra_tt 0.1.0\","}, {"sha": "8f29bf7d9f0e33d40fcfea9561a489b9518959cc", "filename": "crates/ra_hir_expand/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/defc7ad772123a449f7cc384dd46d88c3a45fb53/crates%2Fra_hir_expand%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/defc7ad772123a449f7cc384dd46d88c3a45fb53/crates%2Fra_hir_expand%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2FCargo.toml?ref=defc7ad772123a449f7cc384dd46d88c3a45fb53", "patch": "@@ -10,6 +10,7 @@ log = \"0.4.5\"\n ra_arena = { path = \"../ra_arena\" }\n ra_db = { path = \"../ra_db\" }\n ra_syntax = { path = \"../ra_syntax\" }\n+ra_parser = { path = \"../ra_parser\" }\n ra_prof = { path = \"../ra_prof\" }\n tt = { path = \"../ra_tt\", package = \"ra_tt\" }\n mbe = { path = \"../ra_mbe\", package = \"ra_mbe\" }"}, {"sha": "b4dafe1d87071303297b06e4afbd5aa901f77f71", "filename": "crates/ra_hir_expand/src/db.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/defc7ad772123a449f7cc384dd46d88c3a45fb53/crates%2Fra_hir_expand%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/defc7ad772123a449f7cc384dd46d88c3a45fb53/crates%2Fra_hir_expand%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2Fsrc%2Fdb.rs?ref=defc7ad772123a449f7cc384dd46d88c3a45fb53", "patch": "@@ -4,6 +4,7 @@ use std::sync::Arc;\n \n use mbe::MacroRules;\n use ra_db::{salsa, SourceDatabase};\n+use ra_parser::FragmentKind;\n use ra_prof::profile;\n use ra_syntax::{AstNode, Parse, SyntaxNode};\n \n@@ -108,12 +109,10 @@ pub(crate) fn parse_macro(\n         })\n         .ok()?;\n \n-    match macro_file.macro_file_kind {\n-        MacroFileKind::Items => {\n-            mbe::token_tree_to_items(&tt).ok().map(|(p, map)| (p.to_syntax(), Arc::new(map)))\n-        }\n-        MacroFileKind::Expr => {\n-            mbe::token_tree_to_expr(&tt).ok().map(|(p, map)| (p.to_syntax(), Arc::new(map)))\n-        }\n-    }\n+    let fragment_kind = match macro_file.macro_file_kind {\n+        MacroFileKind::Items => FragmentKind::Items,\n+        MacroFileKind::Expr => FragmentKind::Expr,\n+    };\n+    let (parse, rev_token_map) = mbe::token_tree_to_syntax_node(&tt, fragment_kind).ok()?;\n+    Some((parse, Arc::new(rev_token_map)))\n }"}, {"sha": "151d1d7858ed881459f464af6a3eae26339fc6d3", "filename": "crates/ra_hir_expand/src/lib.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/defc7ad772123a449f7cc384dd46d88c3a45fb53/crates%2Fra_hir_expand%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/defc7ad772123a449f7cc384dd46d88c3a45fb53/crates%2Fra_hir_expand%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2Fsrc%2Flib.rs?ref=defc7ad772123a449f7cc384dd46d88c3a45fb53", "patch": "@@ -151,19 +151,21 @@ pub struct ExpansionInfo {\n \n impl ExpansionInfo {\n     pub fn find_range(&self, from: TextRange) -> Option<(HirFileId, TextRange)> {\n-        fn look_in_rev_map(exp_map: &mbe::RevTokenMap, from: TextRange) -> Option<tt::TokenId> {\n-            exp_map.ranges.iter().find(|&it| it.0.is_subrange(&from)).map(|it| it.1)\n-        }\n-\n         let token_id = look_in_rev_map(&self.exp_map, from)?;\n-        let (token_map, file_offset, token_id) = if token_id.0 >= self.shift {\n+\n+        let (token_map, (file_id, start_offset), token_id) = if token_id.0 >= self.shift {\n             (&self.macro_arg.1, self.arg_start, tt::TokenId(token_id.0 - self.shift).into())\n         } else {\n             (&self.macro_def.1, self.def_start, token_id)\n         };\n \n         let range = token_map.relative_range_of(token_id)?;\n-        Some((file_offset.0, TextRange::offset_len(range.start() + file_offset.1, range.len())))\n+\n+        return Some((file_id, range + start_offset));\n+\n+        fn look_in_rev_map(exp_map: &mbe::RevTokenMap, from: TextRange) -> Option<tt::TokenId> {\n+            exp_map.ranges.iter().find(|&it| it.0.is_subrange(&from)).map(|it| it.1)\n+        }\n     }\n }\n "}, {"sha": "8a31d1c360aa1b25262d4717e039c34ab8d5de08", "filename": "crates/ra_mbe/src/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/defc7ad772123a449f7cc384dd46d88c3a45fb53/crates%2Fra_mbe%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/defc7ad772123a449f7cc384dd46d88c3a45fb53/crates%2Fra_mbe%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Flib.rs?ref=defc7ad772123a449f7cc384dd46d88c3a45fb53", "patch": "@@ -31,8 +31,7 @@ pub enum ExpandError {\n }\n \n pub use crate::syntax_bridge::{\n-    ast_to_token_tree, syntax_node_to_token_tree, token_tree_to_expr, token_tree_to_items,\n-    token_tree_to_macro_stmts, token_tree_to_pat, token_tree_to_ty, RevTokenMap, TokenMap,\n+    ast_to_token_tree, syntax_node_to_token_tree, token_tree_to_syntax_node, RevTokenMap, TokenMap,\n };\n \n /// This struct contains AST for a single `macro_rules` definition. What might"}, {"sha": "3f57ce3b5011f88a52cdeb68f2ac2c2696ef0442", "filename": "crates/ra_mbe/src/syntax_bridge.rs", "status": "modified", "additions": 3, "deletions": 31, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/defc7ad772123a449f7cc384dd46d88c3a45fb53/crates%2Fra_mbe%2Fsrc%2Fsyntax_bridge.rs", "raw_url": "https://github.com/rust-lang/rust/raw/defc7ad772123a449f7cc384dd46d88c3a45fb53/crates%2Fra_mbe%2Fsrc%2Fsyntax_bridge.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Fsyntax_bridge.rs?ref=defc7ad772123a449f7cc384dd46d88c3a45fb53", "patch": "@@ -1,9 +1,6 @@\n //! FIXME: write short doc here\n \n-use ra_parser::{\n-    FragmentKind::{self, *},\n-    ParseError, TreeSink,\n-};\n+use ra_parser::{FragmentKind, ParseError, TreeSink};\n use ra_syntax::{\n     ast, AstNode, AstToken, NodeOrToken, Parse, SmolStr, SyntaxKind, SyntaxKind::*, SyntaxNode,\n     SyntaxTreeBuilder, TextRange, TextUnit, T,\n@@ -55,7 +52,7 @@ pub fn syntax_node_to_token_tree(node: &SyntaxNode) -> Option<(tt::Subtree, Toke\n // * ImplItems(SmallVec<[ast::ImplItem; 1]>)\n // * ForeignItems(SmallVec<[ast::ForeignItem; 1]>\n \n-fn fragment_to_syntax_node(\n+pub fn token_tree_to_syntax_node(\n     tt: &tt::Subtree,\n     fragment_kind: FragmentKind,\n ) -> Result<(Parse<SyntaxNode>, RevTokenMap), ExpandError> {\n@@ -79,31 +76,6 @@ fn fragment_to_syntax_node(\n     Ok((parse, range_map))\n }\n \n-macro_rules! impl_token_tree_conversions {\n-    ($($(#[$attr:meta])* $name:ident => ($kind:ident, $t:ty) ),*) => {\n-        $(\n-            $(#[$attr])*\n-            pub fn $name(tt: &tt::Subtree) -> Result<(Parse<$t>, RevTokenMap), ExpandError> {\n-                let (parse, map) = fragment_to_syntax_node(tt, $kind)?;\n-                parse.cast().ok_or_else(|| crate::ExpandError::ConversionError).map(|p| (p, map))\n-            }\n-        )*\n-    }\n-}\n-\n-impl_token_tree_conversions! {\n-    /// Parses the token tree (result of macro expansion) to an expression\n-    token_tree_to_expr => (Expr, ast::Expr),\n-    /// Parses the token tree (result of macro expansion) to a Pattern\n-    token_tree_to_pat => (Pattern, ast::Pat),\n-    /// Parses the token tree (result of macro expansion) to a Type\n-    token_tree_to_ty => (Type, ast::TypeRef),\n-    /// Parses the token tree (result of macro expansion) as a sequence of stmts\n-    token_tree_to_macro_stmts => (Statements, ast::MacroStmts),\n-    /// Parses the token tree (result of macro expansion) as a sequence of items\n-    token_tree_to_items => (Items, ast::MacroItems)\n-}\n-\n impl TokenMap {\n     pub fn relative_range_of(&self, tt: tt::TokenId) -> Option<TextRange> {\n         let idx = tt.0 as usize;\n@@ -446,6 +418,6 @@ mod tests {\n             \"#,\n         );\n         let expansion = expand(&rules, \"stmts!();\");\n-        assert!(token_tree_to_expr(&expansion).is_err());\n+        assert!(token_tree_to_syntax_node(&expansion, FragmentKind::Expr).is_err());\n     }\n }"}, {"sha": "0109a4d980ec90f9c5ce68700beade2be8865930", "filename": "crates/ra_mbe/src/tests.rs", "status": "modified", "additions": 71, "deletions": 31, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/defc7ad772123a449f7cc384dd46d88c3a45fb53/crates%2Fra_mbe%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/defc7ad772123a449f7cc384dd46d88c3a45fb53/crates%2Fra_mbe%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Ftests.rs?ref=defc7ad772123a449f7cc384dd46d88c3a45fb53", "patch": "@@ -1,3 +1,4 @@\n+use ra_parser::FragmentKind;\n use ra_syntax::{ast, AstNode, NodeOrToken, WalkEvent};\n use test_utils::assert_eq_text;\n \n@@ -126,9 +127,9 @@ fn test_expr_order() {\n \"#,\n     );\n     let expanded = expand(&rules, \"foo! { 1 + 1}\");\n-    let tree = token_tree_to_items(&expanded).unwrap().0.tree();\n+    let tree = token_tree_to_syntax_node(&expanded, FragmentKind::Items).unwrap().0.syntax_node();\n \n-    let dump = format!(\"{:#?}\", tree.syntax());\n+    let dump = format!(\"{:#?}\", tree);\n     assert_eq_text!(\n         dump.trim(),\n         r#\"MACRO_ITEMS@[0; 15)\n@@ -383,9 +384,9 @@ fn test_expand_to_item_list() {\n             \",\n     );\n     let expansion = expand(&rules, \"structs!(Foo, Bar);\");\n-    let tree = token_tree_to_items(&expansion).unwrap().0.tree();\n+    let tree = token_tree_to_syntax_node(&expansion, FragmentKind::Items).unwrap().0.syntax_node();\n     assert_eq!(\n-        format!(\"{:#?}\", tree.syntax()).trim(),\n+        format!(\"{:#?}\", tree).trim(),\n         r#\"\n MACRO_ITEMS@[0; 40)\n   STRUCT_DEF@[0; 20)\n@@ -501,10 +502,11 @@ fn test_tt_to_stmts() {\n     );\n \n     let expanded = expand(&rules, \"foo!{}\");\n-    let stmts = token_tree_to_macro_stmts(&expanded).unwrap().0.tree();\n+    let stmts =\n+        token_tree_to_syntax_node(&expanded, FragmentKind::Statements).unwrap().0.syntax_node();\n \n     assert_eq!(\n-        format!(\"{:#?}\", stmts.syntax()).trim(),\n+        format!(\"{:#?}\", stmts).trim(),\n         r#\"MACRO_STMTS@[0; 15)\n   LET_STMT@[0; 7)\n     LET_KW@[0; 3) \"let\"\n@@ -754,7 +756,10 @@ fn test_all_items() {\n         }\n \"#,\n     );\n-    assert_expansion(MacroKind::Items, &rules, r#\"\n+    assert_expansion(\n+        MacroKind::Items,\n+        &rules,\n+        r#\"\n         foo! {\n             extern crate a;\n             mod b;\n@@ -770,7 +775,9 @@ fn test_all_items() {\n             extern {}\n             type T = u8;\n         }\n-\"#, r#\"extern crate a ; mod b ; mod c {} use d ; const E : i32 = 0 ; static F : i32 = 0 ; impl G {} struct H ; enum I {Foo} trait J {} fn h () {} extern {} type T = u8 ;\"#);\n+\"#,\n+        r#\"extern crate a ; mod b ; mod c {} use d ; const E : i32 = 0 ; static F : i32 = 0 ; impl G {} struct H ; enum I {Foo} trait J {} fn h () {} extern {} type T = u8 ;\"#,\n+    );\n }\n \n #[test]\n@@ -946,10 +953,10 @@ fn test_vec() {\n     );\n \n     let expansion = expand(&rules, r#\"vec![1u32,2];\"#);\n-    let tree = token_tree_to_expr(&expansion).unwrap().0.tree();\n+    let tree = token_tree_to_syntax_node(&expansion, FragmentKind::Expr).unwrap().0.syntax_node();\n \n     assert_eq!(\n-        format!(\"{:#?}\", tree.syntax()).trim(),\n+        format!(\"{:#?}\", tree).trim(),\n         r#\"BLOCK_EXPR@[0; 45)\n   BLOCK@[0; 45)\n     L_CURLY@[0; 1) \"{\"\n@@ -1088,8 +1095,12 @@ macro_rules! generate_pattern_iterators {\n \"#,\n     );\n \n-    assert_expansion(MacroKind::Items, &rules, r#\"generate_pattern_iterators ! ( double ended ; with # [ stable ( feature = \"rust1\" , since = \"1.0.0\" ) ] , Split , RSplit , & 'a str );\"#,\n-        \"fn foo () {}\");\n+    assert_expansion(\n+        MacroKind::Items,\n+        &rules,\n+        r#\"generate_pattern_iterators ! ( double ended ; with # [ stable ( feature = \"rust1\" , since = \"1.0.0\" ) ] , Split , RSplit , & 'a str );\"#,\n+        \"fn foo () {}\",\n+    );\n }\n \n #[test]\n@@ -1171,8 +1182,12 @@ fn test_impl_nonzero_fmt() {\n \"#,\n     );\n \n-    assert_expansion(MacroKind::Items, &rules, r#\"impl_nonzero_fmt! { # [stable(feature= \"nonzero\",since=\"1.28.0\")] (Debug,Display,Binary,Octal,LowerHex,UpperHex) for NonZeroU8}\"#,\n-        \"fn foo () {}\");\n+    assert_expansion(\n+        MacroKind::Items,\n+        &rules,\n+        r#\"impl_nonzero_fmt! { # [stable(feature= \"nonzero\",since=\"1.28.0\")] (Debug,Display,Binary,Octal,LowerHex,UpperHex) for NonZeroU8}\"#,\n+        \"fn foo () {}\",\n+    );\n }\n \n #[test]\n@@ -1189,8 +1204,12 @@ fn test_cfg_if_items() {\n \"#,\n     );\n \n-    assert_expansion(MacroKind::Items, &rules, r#\"__cfg_if_items ! { ( rustdoc , ) ; ( ( ) ( # [ cfg ( any ( target_os = \"redox\" , unix ) ) ] # [ stable ( feature = \"rust1\" , since = \"1.0.0\" ) ] pub use sys :: ext as unix ; # [ cfg ( windows ) ] # [ stable ( feature = \"rust1\" , since = \"1.0.0\" ) ] pub use sys :: ext as windows ; # [ cfg ( any ( target_os = \"linux\" , target_os = \"l4re\" ) ) ] pub mod linux ; ) ) , }\"#,\n-        \"__cfg_if_items ! {(rustdoc ,) ;}\");\n+    assert_expansion(\n+        MacroKind::Items,\n+        &rules,\n+        r#\"__cfg_if_items ! { ( rustdoc , ) ; ( ( ) ( # [ cfg ( any ( target_os = \"redox\" , unix ) ) ] # [ stable ( feature = \"rust1\" , since = \"1.0.0\" ) ] pub use sys :: ext as unix ; # [ cfg ( windows ) ] # [ stable ( feature = \"rust1\" , since = \"1.0.0\" ) ] pub use sys :: ext as windows ; # [ cfg ( any ( target_os = \"linux\" , target_os = \"l4re\" ) ) ] pub mod linux ; ) ) , }\"#,\n+        \"__cfg_if_items ! {(rustdoc ,) ;}\",\n+    );\n }\n \n #[test]\n@@ -1233,10 +1252,13 @@ cfg_if !   {\n \"#,\n         \"__cfg_if_items ! {() ; ((target_env = \\\"msvc\\\") ()) , ((all (target_arch = \\\"wasm32\\\" , not (target_os = \\\"emscripten\\\"))) ()) , (() (mod libunwind ; pub use libunwind :: * ;)) ,}\");\n \n-    assert_expansion(MacroKind::Items, &rules, r#\"\n+    assert_expansion(\n+        MacroKind::Items,\n+        &rules,\n+        r#\"\n cfg_if ! { @ __apply cfg ( all ( not ( any ( not ( any ( target_os = \"solaris\" , target_os = \"illumos\" ) ) ) ) ) ) , }\n \"#,\n-        \"\"\n+        \"\",\n     );\n }\n \n@@ -1291,10 +1313,13 @@ macro_rules! RIDL {\n }\"#,\n     );\n \n-    let expanded = expand(&rules, r#\"\n+    let expanded = expand(\n+        &rules,\n+        r#\"\n RIDL!{interface ID3D11Asynchronous(ID3D11AsynchronousVtbl): ID3D11DeviceChild(ID3D11DeviceChildVtbl) {\n     fn GetDataSize(&mut self) -> UINT\n-}}\"#);\n+}}\"#,\n+    );\n     assert_eq!(expanded.to_string(), \"impl ID3D11Asynchronous {pub unsafe fn GetDataSize (& mut self) -> UINT {((* self . lpVtbl) .GetDataSize) (self)}}\");\n }\n \n@@ -1340,7 +1365,8 @@ quick_error ! (SORT [enum Wrapped # [derive (Debug)]] items [\n \n #[test]\n fn test_empty_repeat_vars_in_empty_repeat_vars() {\n-    let rules = create_rules(r#\"\n+    let rules = create_rules(\n+        r#\"\n macro_rules! delegate_impl {\n     ([$self_type:ident, $self_wrap:ty, $self_map:ident]\n      pub trait $name:ident $(: $sup:ident)* $(+ $more_sup:ident)* {\n@@ -1385,9 +1411,15 @@ macro_rules! delegate_impl {\n         }\n     }\n }\n-\"#);\n+\"#,\n+    );\n \n-    assert_expansion(MacroKind::Items, &rules, r#\"delegate_impl ! {[G , & 'a mut G , deref] pub trait Data : GraphBase {@ section type type NodeWeight ;}}\"#, \"impl <> Data for & \\'a mut G where G : Data {}\");\n+    assert_expansion(\n+        MacroKind::Items,\n+        &rules,\n+        r#\"delegate_impl ! {[G , & 'a mut G , deref] pub trait Data : GraphBase {@ section type type NodeWeight ;}}\"#,\n+        \"impl <> Data for & \\'a mut G where G : Data {}\",\n+    );\n }\n \n pub(crate) fn create_rules(macro_definition: &str) -> MacroRules {\n@@ -1436,22 +1468,30 @@ pub(crate) fn assert_expansion(\n     };\n     let (expanded_tree, expected_tree) = match kind {\n         MacroKind::Items => {\n-            let expanded_tree = token_tree_to_items(&expanded).unwrap().0.tree();\n-            let expected_tree = token_tree_to_items(&expected).unwrap().0.tree();\n+            let expanded_tree =\n+                token_tree_to_syntax_node(&expanded, FragmentKind::Items).unwrap().0.syntax_node();\n+            let expected_tree =\n+                token_tree_to_syntax_node(&expected, FragmentKind::Items).unwrap().0.syntax_node();\n \n             (\n-                debug_dump_ignore_spaces(expanded_tree.syntax()).trim().to_string(),\n-                debug_dump_ignore_spaces(expected_tree.syntax()).trim().to_string(),\n+                debug_dump_ignore_spaces(&expanded_tree).trim().to_string(),\n+                debug_dump_ignore_spaces(&expected_tree).trim().to_string(),\n             )\n         }\n \n         MacroKind::Stmts => {\n-            let expanded_tree = token_tree_to_macro_stmts(&expanded).unwrap().0.tree();\n-            let expected_tree = token_tree_to_macro_stmts(&expected).unwrap().0.tree();\n+            let expanded_tree = token_tree_to_syntax_node(&expanded, FragmentKind::Statements)\n+                .unwrap()\n+                .0\n+                .syntax_node();\n+            let expected_tree = token_tree_to_syntax_node(&expected, FragmentKind::Statements)\n+                .unwrap()\n+                .0\n+                .syntax_node();\n \n             (\n-                debug_dump_ignore_spaces(expanded_tree.syntax()).trim().to_string(),\n-                debug_dump_ignore_spaces(expected_tree.syntax()).trim().to_string(),\n+                debug_dump_ignore_spaces(&expanded_tree).trim().to_string(),\n+                debug_dump_ignore_spaces(&expected_tree).trim().to_string(),\n             )\n         }\n     };"}]}