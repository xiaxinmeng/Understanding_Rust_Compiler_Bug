{"sha": "3d9db595661a96c37f4a5f9cf310c20da08efa5f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNkOWRiNTk1NjYxYTk2YzM3ZjRhNWY5Y2YzMTBjMjBkYTA4ZWZhNWY=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-03-30T22:21:56Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-03-30T23:50:19Z"}, "message": "Detect cycles that include renamed imports", "tree": {"sha": "42e3d3f1cd36e88f5094145eabfc73d5e217794b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/42e3d3f1cd36e88f5094145eabfc73d5e217794b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3d9db595661a96c37f4a5f9cf310c20da08efa5f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3d9db595661a96c37f4a5f9cf310c20da08efa5f", "html_url": "https://github.com/rust-lang/rust/commit/3d9db595661a96c37f4a5f9cf310c20da08efa5f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3d9db595661a96c37f4a5f9cf310c20da08efa5f/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "26e38d2fffbcf7fc39d733686a1277291b54535d", "url": "https://api.github.com/repos/rust-lang/rust/commits/26e38d2fffbcf7fc39d733686a1277291b54535d", "html_url": "https://github.com/rust-lang/rust/commit/26e38d2fffbcf7fc39d733686a1277291b54535d"}], "stats": {"total": 48, "additions": 32, "deletions": 16}, "files": [{"sha": "fc13ee11ae1a5598310989ad15317a04809b4fca", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3d9db595661a96c37f4a5f9cf310c20da08efa5f/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d9db595661a96c37f4a5f9cf310c20da08efa5f/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=3d9db595661a96c37f4a5f9cf310c20da08efa5f", "patch": "@@ -827,7 +827,7 @@ pub struct ModuleS<'a> {\n     // is the NodeId of the local `extern crate` item (otherwise, `extern_crate_id` is None).\n     extern_crate_id: Option<NodeId>,\n \n-    resolutions: RefCell<HashMap<(Name, Namespace), NameResolution<'a>>>,\n+    resolutions: RefCell<HashMap<(Name, Namespace), &'a RefCell<NameResolution<'a>>>>,\n     unresolved_imports: RefCell<Vec<&'a ImportDirective<'a>>>,\n \n     // The module children of this node, including normal modules and anonymous modules.\n@@ -885,7 +885,7 @@ impl<'a> ModuleS<'a> {\n \n     fn for_each_child<F: FnMut(Name, Namespace, &'a NameBinding<'a>)>(&self, mut f: F) {\n         for (&(name, ns), name_resolution) in self.resolutions.borrow().iter() {\n-            name_resolution.binding.map(|binding| f(name, ns, binding));\n+            name_resolution.borrow().binding.map(|binding| f(name, ns, binding));\n         }\n     }\n \n@@ -1117,6 +1117,7 @@ struct ResolverArenas<'a> {\n     modules: arena::TypedArena<ModuleS<'a>>,\n     name_bindings: arena::TypedArena<NameBinding<'a>>,\n     import_directives: arena::TypedArena<ImportDirective<'a>>,\n+    name_resolutions: arena::TypedArena<RefCell<NameResolution<'a>>>,\n }\n \n impl<'a> ResolverArenas<'a> {\n@@ -1130,6 +1131,9 @@ impl<'a> ResolverArenas<'a> {\n                               -> &'a ImportDirective {\n         self.import_directives.alloc(import_directive)\n     }\n+    fn alloc_name_resolution(&'a self) -> &'a RefCell<NameResolution<'a>> {\n+        self.name_resolutions.alloc(Default::default())\n+    }\n }\n \n #[derive(PartialEq)]\n@@ -1198,6 +1202,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             modules: arena::TypedArena::new(),\n             name_bindings: arena::TypedArena::new(),\n             import_directives: arena::TypedArena::new(),\n+            name_resolutions: arena::TypedArena::new(),\n         }\n     }\n "}, {"sha": "2f7de8c4aa47724df017b3f07e262c92fddbb266", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 18, "deletions": 14, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/3d9db595661a96c37f4a5f9cf310c20da08efa5f/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d9db595661a96c37f4a5f9cf310c20da08efa5f/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=3d9db595661a96c37f4a5f9cf310c20da08efa5f", "patch": "@@ -30,7 +30,7 @@ use syntax::codemap::Span;\n use syntax::util::lev_distance::find_best_match_for_name;\n \n use std::mem::replace;\n-use std::cell::Cell;\n+use std::cell::{Cell, RefCell};\n \n /// Contains data for specific types of import directives.\n #[derive(Clone, Debug)]\n@@ -194,8 +194,8 @@ impl<'a> NameResolution<'a> {\n                     None => return Some(Indeterminate),\n                 };\n                 let name = match directive.subclass {\n-                    SingleImport { source, target, .. } if source == target => target,\n-                    _ => return Some(Indeterminate),\n+                    SingleImport { source, .. } => source,\n+                    GlobImport => unreachable!(),\n                 };\n                 match target_module.resolve_name(name, ns, false) {\n                     Failed(_) => {}\n@@ -227,14 +227,19 @@ impl<'a> NameResolution<'a> {\n }\n \n impl<'a> ::ModuleS<'a> {\n+    fn resolution(&self, name: Name, ns: Namespace) -> &'a RefCell<NameResolution<'a>> {\n+        *self.resolutions.borrow_mut().entry((name, ns))\n+             .or_insert_with(|| self.arenas.alloc_name_resolution())\n+    }\n+\n     pub fn resolve_name(&self, name: Name, ns: Namespace, allow_private_imports: bool)\n                         -> ResolveResult<&'a NameBinding<'a>> {\n-        let resolutions = match self.resolutions.borrow_state() {\n-            ::std::cell::BorrowState::Unused => self.resolutions.borrow(),\n-            _ => return Failed(None), // This happens when there is a cycle of glob imports\n+        let resolution = self.resolution(name, ns);\n+        let resolution = match resolution.borrow_state() {\n+            ::std::cell::BorrowState::Unused => resolution.borrow_mut(),\n+            _ => return Failed(None), // This happens when there is a cycle of imports\n         };\n \n-        let resolution = resolutions.get(&(name, ns)).cloned().unwrap_or_default();\n         if let Some(result) = resolution.try_result(ns, allow_private_imports) {\n             // If the resolution doesn't depend on glob definability, check privacy and return.\n             return result.and_then(|binding| {\n@@ -261,7 +266,7 @@ impl<'a> ::ModuleS<'a> {\n     // Invariant: this may not be called until import resolution is complete.\n     pub fn resolve_name_in_lexical_scope(&self, name: Name, ns: Namespace)\n                                          -> Option<&'a NameBinding<'a>> {\n-        self.resolutions.borrow().get(&(name, ns)).and_then(|resolution| resolution.binding)\n+        self.resolution(name, ns).borrow().binding\n             .or_else(|| self.prelude.borrow().and_then(|prelude| {\n                 prelude.resolve_name(name, ns, false).success()\n             }))\n@@ -296,10 +301,9 @@ impl<'a> ::ModuleS<'a> {\n         self.unresolved_imports.borrow_mut().push(directive);\n         match directive.subclass {\n             SingleImport { target, .. } => {\n-                let mut resolutions = self.resolutions.borrow_mut();\n                 for &ns in &[ValueNS, TypeNS] {\n-                    resolutions.entry((target, ns)).or_insert_with(Default::default)\n-                               .single_imports.add_directive(directive);\n+                    self.resolution(target, ns).borrow_mut().single_imports\n+                                                            .add_directive(directive);\n                 }\n             }\n             // We don't add prelude imports to the globs since they only affect lexical scopes,\n@@ -314,8 +318,7 @@ impl<'a> ::ModuleS<'a> {\n     fn update_resolution<T, F>(&self, name: Name, ns: Namespace, update: F) -> T\n         where F: FnOnce(&mut NameResolution<'a>) -> T\n     {\n-        let mut resolutions = self.resolutions.borrow_mut();\n-        let resolution = resolutions.entry((name, ns)).or_insert_with(Default::default);\n+        let mut resolution = &mut *self.resolution(name, ns).borrow_mut();\n         let was_known = resolution.binding().is_some();\n \n         let t = update(resolution);\n@@ -638,7 +641,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n         target_module.glob_importers.borrow_mut().push((module_, directive));\n \n         for (&(name, ns), resolution) in target_module.resolutions.borrow().iter() {\n-            if let Some(binding) = resolution.binding() {\n+            if let Some(binding) = resolution.borrow().binding() {\n                 if binding.defined_with(DefModifiers::IMPORTABLE | DefModifiers::PUBLIC) {\n                     let _ = module_.try_define_child(name, ns, directive.import(binding, None));\n                 }\n@@ -666,6 +669,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n \n         let mut reexports = Vec::new();\n         for (&(name, ns), resolution) in module.resolutions.borrow().iter() {\n+            let resolution = resolution.borrow();\n             resolution.report_conflicts(|b1, b2| {\n                 self.resolver.report_conflict(module, name, ns, b1, b2)\n             });"}, {"sha": "4743b779ef63ee825778259a6435ff8c084a302f", "filename": "src/test/compile-fail/issue-32119.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3d9db595661a96c37f4a5f9cf310c20da08efa5f/src%2Ftest%2Fcompile-fail%2Fissue-32119.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d9db595661a96c37f4a5f9cf310c20da08efa5f/src%2Ftest%2Fcompile-fail%2Fissue-32119.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-32119.rs?ref=3d9db595661a96c37f4a5f9cf310c20da08efa5f", "patch": "@@ -17,5 +17,12 @@ mod bar { pub use super::T; }\n pub use foo::*;\n pub use bar::*;\n \n+mod baz {\n+    pub type T = ();\n+    mod foo { pub use super::T as S; }\n+    mod bar { pub use super::foo::S as T; }\n+    pub use self::bar::*;\n+}\n+\n #[rustc_error]\n fn main() {} //~ ERROR compilation successful"}]}