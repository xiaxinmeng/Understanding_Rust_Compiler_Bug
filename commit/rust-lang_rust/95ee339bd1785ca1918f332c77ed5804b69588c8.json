{"sha": "95ee339bd1785ca1918f332c77ed5804b69588c8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk1ZWUzMzliZDE3ODVjYTE5MThmMzMyYzc3ZWQ1ODA0YjY5NTg4Yzg=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-01-04T11:37:49Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-01-05T12:11:47Z"}, "message": "Stop writing code that is (unnecessarily) generic over any AstConv in collect,\njust hard-code the ccx.", "tree": {"sha": "dda8f1f3fa8fba0ac6047fc1ecccb7988ef685b3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dda8f1f3fa8fba0ac6047fc1ecccb7988ef685b3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/95ee339bd1785ca1918f332c77ed5804b69588c8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/95ee339bd1785ca1918f332c77ed5804b69588c8", "html_url": "https://github.com/rust-lang/rust/commit/95ee339bd1785ca1918f332c77ed5804b69588c8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/95ee339bd1785ca1918f332c77ed5804b69588c8/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "94c345b66c1f8c1197611f7478898f8b76052ada", "url": "https://api.github.com/repos/rust-lang/rust/commits/94c345b66c1f8c1197611f7478898f8b76052ada", "html_url": "https://github.com/rust-lang/rust/commit/94c345b66c1f8c1197611f7478898f8b76052ada"}], "stats": {"total": 87, "additions": 41, "deletions": 46}, "files": [{"sha": "867fdd36b34aa114a98fc3b8320cc3807c4a4fd5", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 41, "deletions": 46, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/95ee339bd1785ca1918f332c77ed5804b69588c8/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95ee339bd1785ca1918f332c77ed5804b69588c8/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=95ee339bd1785ca1918f332c77ed5804b69588c8", "patch": "@@ -636,7 +636,7 @@ pub fn convert(ccx: &CrateCtxt, it: &ast::Item) {\n \n             debug!(\"trait_def: ident={} trait_def={}\",\n                    it.ident.repr(ccx.tcx),\n-                   trait_def.repr(ccx.tcx()));\n+                   trait_def.repr(ccx.tcx));\n \n             for trait_method in trait_methods.iter() {\n                 let self_type = ty::mk_self_type(tcx);\n@@ -1108,14 +1108,13 @@ fn ty_generics_for_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     }\n }\n \n-fn ty_generics_for_fn_or_method<'tcx,AC>(\n-        this: &AC,\n-        generics: &ast::Generics,\n-        base_generics: ty::Generics<'tcx>)\n-        -> ty::Generics<'tcx>\n-        where AC: AstConv<'tcx> {\n+fn ty_generics_for_fn_or_method<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n+                                         generics: &ast::Generics,\n+                                         base_generics: ty::Generics<'tcx>)\n+                                         -> ty::Generics<'tcx>\n+{\n     let early_lifetimes = resolve_lifetime::early_bound_lifetimes(generics);\n-    ty_generics(this,\n+    ty_generics(ccx,\n                 subst::FnSpace,\n                 early_lifetimes[],\n                 generics.ty_params[],\n@@ -1124,11 +1123,11 @@ fn ty_generics_for_fn_or_method<'tcx,AC>(\n }\n \n // Add the Sized bound, unless the type parameter is marked as `?Sized`.\n-fn add_unsized_bound<'tcx,AC>(this: &AC,\n+fn add_unsized_bound<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n                               bounds: &mut ty::BuiltinBounds,\n                               ast_bounds: &[ast::TyParamBound],\n                               span: Span)\n-                              where AC: AstConv<'tcx> {\n+{\n     // Try to find an unbound in bounds.\n     let mut unbound = None;\n     for ab in ast_bounds.iter() {\n@@ -1137,52 +1136,51 @@ fn add_unsized_bound<'tcx,AC>(this: &AC,\n                 assert!(ptr.bound_lifetimes.is_empty());\n                 unbound = Some(ptr.trait_ref.clone());\n             } else {\n-                this.tcx().sess.span_err(span, \"type parameter has more than one relaxed default \\\n+                ccx.tcx.sess.span_err(span, \"type parameter has more than one relaxed default \\\n                                                 bound, only one is supported\");\n             }\n         }\n     }\n \n-    let kind_id = this.tcx().lang_items.require(SizedTraitLangItem);\n+    let kind_id = ccx.tcx.lang_items.require(SizedTraitLangItem);\n     match unbound {\n         Some(ref tpb) => {\n             // FIXME(#8559) currently requires the unbound to be built-in.\n-            let trait_def_id = ty::trait_ref_to_def_id(this.tcx(), tpb);\n+            let trait_def_id = ty::trait_ref_to_def_id(ccx.tcx, tpb);\n             match kind_id {\n                 Ok(kind_id) if trait_def_id != kind_id => {\n-                    this.tcx().sess.span_warn(span,\n+                    ccx.tcx.sess.span_warn(span,\n                                               \"default bound relaxed for a type parameter, but \\\n                                                this does nothing because the given bound is not \\\n                                                a default. Only `?Sized` is supported\");\n-                    ty::try_add_builtin_trait(this.tcx(),\n+                    ty::try_add_builtin_trait(ccx.tcx,\n                                               kind_id,\n                                               bounds);\n                 }\n                 _ => {}\n             }\n         }\n         _ if kind_id.is_ok() => {\n-            ty::try_add_builtin_trait(this.tcx(), kind_id.unwrap(), bounds);\n+            ty::try_add_builtin_trait(ccx.tcx, kind_id.unwrap(), bounds);\n         }\n         // No lang item for Sized, so we can't add it as a bound.\n         None => {}\n     }\n }\n \n-fn ty_generics<'tcx,AC>(this: &AC,\n+fn ty_generics<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n                         space: subst::ParamSpace,\n                         lifetime_defs: &[ast::LifetimeDef],\n                         types: &[ast::TyParam],\n                         base_generics: ty::Generics<'tcx>,\n                         where_clause: &ast::WhereClause)\n                         -> ty::Generics<'tcx>\n-                        where AC: AstConv<'tcx>\n {\n     let mut result = base_generics;\n \n     for (i, l) in lifetime_defs.iter().enumerate() {\n         let bounds = l.bounds.iter()\n-                             .map(|l| ast_region_to_region(this.tcx(), l))\n+                             .map(|l| ast_region_to_region(ccx.tcx, l))\n                              .collect();\n         let def = ty::RegionParameterDef { name: l.lifetime.name,\n                                            space: space,\n@@ -1197,33 +1195,33 @@ fn ty_generics<'tcx,AC>(this: &AC,\n \n     // Now create the real type parameters.\n     for (i, param) in types.iter().enumerate() {\n-        let def = get_or_create_type_parameter_def(this,\n+        let def = get_or_create_type_parameter_def(ccx,\n                                                    space,\n                                                    param,\n                                                    i as u32);\n         debug!(\"ty_generics: def for type param: {}, {}\",\n-               def.repr(this.tcx()),\n+               def.repr(ccx.tcx),\n                space);\n         result.types.push(space, def);\n     }\n \n     // Just for fun, also push the bounds from the type parameters\n     // into the predicates list. This is currently kind of non-DRY.\n-    create_predicates(this.tcx(), &mut result, space);\n+    create_predicates(ccx.tcx, &mut result, space);\n \n     // Add the bounds not associated with a type parameter\n     for predicate in where_clause.predicates.iter() {\n         match predicate {\n             &ast::WherePredicate::BoundPredicate(ref bound_pred) => {\n-                let ty = ast_ty_to_ty(this, &ExplicitRscope, &*bound_pred.bounded_ty);\n+                let ty = ast_ty_to_ty(ccx, &ExplicitRscope, &*bound_pred.bounded_ty);\n \n                 for bound in bound_pred.bounds.iter() {\n                     match bound {\n                         &ast::TyParamBound::TraitTyParamBound(ref poly_trait_ref, _) => {\n                             let mut projections = Vec::new();\n \n                             let trait_ref = astconv::instantiate_poly_trait_ref(\n-                                this,\n+                                ccx,\n                                 &ExplicitRscope,\n                                 poly_trait_ref,\n                                 Some(ty),\n@@ -1238,7 +1236,7 @@ fn ty_generics<'tcx,AC>(this: &AC,\n                         }\n \n                         &ast::TyParamBound::RegionTyParamBound(ref lifetime) => {\n-                            let region = ast_region_to_region(this.tcx(), lifetime);\n+                            let region = ast_region_to_region(ccx.tcx, lifetime);\n                             let pred = ty::Binder(ty::OutlivesPredicate(ty, region));\n                             result.predicates.push(space, ty::Predicate::TypeOutlives(pred))\n                         }\n@@ -1247,17 +1245,17 @@ fn ty_generics<'tcx,AC>(this: &AC,\n             }\n \n             &ast::WherePredicate::RegionPredicate(ref region_pred) => {\n-                let r1 = ast_region_to_region(this.tcx(), &region_pred.lifetime);\n+                let r1 = ast_region_to_region(ccx.tcx, &region_pred.lifetime);\n                 for bound in region_pred.bounds.iter() {\n-                    let r2 = ast_region_to_region(this.tcx(), bound);\n+                    let r2 = ast_region_to_region(ccx.tcx, bound);\n                     let pred = ty::Binder(ty::OutlivesPredicate(r1, r2));\n                     result.predicates.push(space, ty::Predicate::RegionOutlives(pred))\n                 }\n             }\n \n             &ast::WherePredicate::EqPredicate(ref eq_pred) => {\n                 // FIXME(#20041)\n-                this.tcx().sess.span_bug(eq_pred.span,\n+                ccx.tcx.sess.span_bug(eq_pred.span,\n                                          \"Equality constraints are not yet \\\n                                             implemented (#20041)\")\n             }\n@@ -1292,34 +1290,33 @@ fn ty_generics<'tcx,AC>(this: &AC,\n     }\n }\n \n-fn get_or_create_type_parameter_def<'tcx,AC>(this: &AC,\n+fn get_or_create_type_parameter_def<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n                                              space: subst::ParamSpace,\n                                              param: &ast::TyParam,\n                                              index: u32)\n                                              -> ty::TypeParameterDef<'tcx>\n-    where AC: AstConv<'tcx>\n {\n-    match this.tcx().ty_param_defs.borrow().get(&param.id) {\n+    match ccx.tcx.ty_param_defs.borrow().get(&param.id) {\n         Some(d) => { return (*d).clone(); }\n         None => { }\n     }\n \n     let param_ty = ty::ParamTy::new(space, index, param.ident.name);\n-    let bounds = compute_bounds(this,\n-                                param_ty.to_ty(this.tcx()),\n+    let bounds = compute_bounds(ccx,\n+                                param_ty.to_ty(ccx.tcx),\n                                 param.bounds[],\n                                 SizedByDefault::Yes,\n                                 param.span);\n     let default = match param.default {\n         None => None,\n         Some(ref path) => {\n-            let ty = ast_ty_to_ty(this, &ExplicitRscope, &**path);\n+            let ty = ast_ty_to_ty(ccx, &ExplicitRscope, &**path);\n             let cur_idx = index;\n \n             ty::walk_ty(ty, |t| {\n                 match t.sty {\n                     ty::ty_param(p) => if p.idx > cur_idx {\n-                        span_err!(this.tcx().sess, path.span, E0128,\n+                        span_err!(ccx.tcx.sess, path.span, E0128,\n                                   \"type parameters with a default cannot use \\\n                                    forward declared identifiers\");\n                         },\n@@ -1340,7 +1337,7 @@ fn get_or_create_type_parameter_def<'tcx,AC>(this: &AC,\n         default: default\n     };\n \n-    this.tcx().ty_param_defs.borrow_mut().insert(param.id, def.clone());\n+    ccx.tcx.ty_param_defs.borrow_mut().insert(param.id, def.clone());\n \n     def\n }\n@@ -1350,26 +1347,25 @@ enum SizedByDefault { Yes, No }\n /// Translate the AST's notion of ty param bounds (which are an enum consisting of a newtyped Ty or\n /// a region) to ty's notion of ty param bounds, which can either be user-defined traits, or the\n /// built-in trait (formerly known as kind): Send.\n-fn compute_bounds<'tcx,AC>(this: &AC,\n+fn compute_bounds<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n                            param_ty: ty::Ty<'tcx>,\n                            ast_bounds: &[ast::TyParamBound],\n                            sized_by_default: SizedByDefault,\n                            span: Span)\n                            -> ty::ParamBounds<'tcx>\n-                           where AC: AstConv<'tcx>\n {\n-    let mut param_bounds = conv_param_bounds(this,\n+    let mut param_bounds = conv_param_bounds(ccx,\n                                              span,\n                                              param_ty,\n                                              ast_bounds);\n \n     if let SizedByDefault::Yes = sized_by_default {\n-        add_unsized_bound(this,\n+        add_unsized_bound(ccx,\n                           &mut param_bounds.builtin_bounds,\n                           ast_bounds,\n                           span);\n \n-        check_bounds_compatible(this.tcx(),\n+        check_bounds_compatible(ccx.tcx,\n                                 param_ty,\n                                 &param_bounds,\n                                 span);\n@@ -1404,24 +1400,23 @@ fn check_bounds_compatible<'tcx>(tcx: &ty::ctxt<'tcx>,\n     }\n }\n \n-fn conv_param_bounds<'tcx,AC>(this: &AC,\n+fn conv_param_bounds<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n                               span: Span,\n                               param_ty: ty::Ty<'tcx>,\n                               ast_bounds: &[ast::TyParamBound])\n                               -> ty::ParamBounds<'tcx>\n-                              where AC: AstConv<'tcx>\n {\n     let astconv::PartitionedBounds { builtin_bounds,\n                                      trait_bounds,\n                                      region_bounds } =\n-        astconv::partition_bounds(this.tcx(), span, ast_bounds.as_slice());\n+        astconv::partition_bounds(ccx.tcx, span, ast_bounds.as_slice());\n \n     let mut projection_bounds = Vec::new();\n \n     let trait_bounds: Vec<ty::PolyTraitRef> =\n         trait_bounds.into_iter()\n         .map(|bound| {\n-            astconv::instantiate_poly_trait_ref(this,\n+            astconv::instantiate_poly_trait_ref(ccx,\n                                                 &ExplicitRscope,\n                                                 bound,\n                                                 Some(param_ty),\n@@ -1430,7 +1425,7 @@ fn conv_param_bounds<'tcx,AC>(this: &AC,\n         .collect();\n     let region_bounds: Vec<ty::Region> =\n         region_bounds.into_iter()\n-        .map(|r| ast_region_to_region(this.tcx(), r))\n+        .map(|r| ast_region_to_region(ccx.tcx, r))\n         .collect();\n     ty::ParamBounds {\n         region_bounds: region_bounds,"}]}