{"sha": "aa3ee1d05e4e28bf972b0de798234a8976e60974", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFhM2VlMWQwNWU0ZTI4YmY5NzJiMGRlNzk4MjM0YTg5NzZlNjA5NzQ=", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2016-08-30T08:39:05Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-08-30T08:39:05Z"}, "message": "Rollup merge of #35810 - matthew-piziak:fn-trait-example, r=steveklabnik\n\nimprove documentation for `Fn*` traits\n\nThis PR is not yet a serious attempt at contribution. Rather, I'm opening this for discussion. I can think of a few things we may want to accomplish with the documentation of the `Fn`, `FnMut`, and `FnOnce` traits:\n- the relationship between these traits and the closures that implement them\n- examples of non-closure implementations\n- the relationship between these traits and Rust's ownership semantics", "tree": {"sha": "ad04a18bf97b7a7fe11372d1b4d5a6f7b071c72a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ad04a18bf97b7a7fe11372d1b4d5a6f7b071c72a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/aa3ee1d05e4e28bf972b0de798234a8976e60974", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/aa3ee1d05e4e28bf972b0de798234a8976e60974", "html_url": "https://github.com/rust-lang/rust/commit/aa3ee1d05e4e28bf972b0de798234a8976e60974", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/aa3ee1d05e4e28bf972b0de798234a8976e60974/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ff45e6195be10e83092e3f9bafebb305c30bbb21", "url": "https://api.github.com/repos/rust-lang/rust/commits/ff45e6195be10e83092e3f9bafebb305c30bbb21", "html_url": "https://github.com/rust-lang/rust/commit/ff45e6195be10e83092e3f9bafebb305c30bbb21"}, {"sha": "67b9cd3fe136247e928d11daa12749d0488464c9", "url": "https://api.github.com/repos/rust-lang/rust/commits/67b9cd3fe136247e928d11daa12749d0488464c9", "html_url": "https://github.com/rust-lang/rust/commit/67b9cd3fe136247e928d11daa12749d0488464c9"}], "stats": {"total": 165, "additions": 165, "deletions": 0}, "files": [{"sha": "d833da5a0d230fabe576d3dc579a2a7eb6178a7a", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 165, "deletions": 0, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/aa3ee1d05e4e28bf972b0de798234a8976e60974/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa3ee1d05e4e28bf972b0de798234a8976e60974/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=aa3ee1d05e4e28bf972b0de798234a8976e60974", "patch": "@@ -68,6 +68,73 @@\n //! ```\n //!\n //! See the documentation for each trait for an example implementation.\n+//!\n+//! The [`Fn`], [`FnMut`], and [`FnOnce`] traits are implemented by types that can be\n+//! invoked like functions. Note that `Fn` takes `&self`, `FnMut` takes `&mut\n+//! self` and `FnOnce` takes `self`. These correspond to the three kinds of\n+//! methods that can be invoked on an instance: call-by-reference,\n+//! call-by-mutable-reference, and call-by-value. The most common use of these\n+//! traits is to act as bounds to higher-level functions that take functions or\n+//! closures as arguments.\n+//!\n+//! [`Fn`]: trait.Fn.html\n+//! [`FnMut`]: trait.FnMut.html\n+//! [`FnOnce`]: trait.FnOnce.html\n+//!\n+//! Taking a `Fn` as a parameter:\n+//!\n+//! ```rust\n+//! fn call_with_one<F>(func: F) -> usize\n+//!     where F: Fn(usize) -> usize\n+//! {\n+//!     func(1)\n+//! }\n+//!\n+//! let double = |x| x * 2;\n+//! assert_eq!(call_with_one(double), 2);\n+//! ```\n+//!\n+//! Taking a `FnMut` as a parameter:\n+//!\n+//! ```rust\n+//! fn do_twice<F>(mut func: F)\n+//!     where F: FnMut()\n+//! {\n+//!     func();\n+//!     func();\n+//! }\n+//!\n+//! let mut x: usize = 1;\n+//! {\n+//!     let add_two_to_x = || x += 2;\n+//!     do_twice(add_two_to_x);\n+//! }\n+//!\n+//! assert_eq!(x, 5);\n+//! ```\n+//!\n+//! Taking a `FnOnce` as a parameter:\n+//!\n+//! ```rust\n+//! fn consume_with_relish<F>(func: F)\n+//!     where F: FnOnce() -> String\n+//! {\n+//!     // `func` consumes its captured variables, so it cannot be run more\n+//!     // than once\n+//!     println!(\"Consumed: {}\", func());\n+//!\n+//!     println!(\"Delicious!\");\n+//!\n+//!     // Attempting to invoke `func()` again will throw a `use of moved\n+//!     // value` error for `func`\n+//! }\n+//!\n+//! let x = String::from(\"x\");\n+//! let consume_and_return_x = move || x;\n+//! consume_with_relish(consume_and_return_x);\n+//!\n+//! // `consume_and_return_x` can no longer be invoked at this point\n+//! ```\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n@@ -2200,6 +2267,35 @@ impl<'a, T: ?Sized> DerefMut for &'a mut T {\n }\n \n /// A version of the call operator that takes an immutable receiver.\n+///\n+/// # Examples\n+///\n+/// Closures automatically implement this trait, which allows them to be\n+/// invoked. Note, however, that `Fn` takes an immutable reference to any\n+/// captured variables. To take a mutable capture, implement [`FnMut`], and to\n+/// consume the capture, implement [`FnOnce`].\n+///\n+/// [`FnMut`]: trait.FnMut.html\n+/// [`FnOnce`]: trait.FnOnce.html\n+///\n+/// ```\n+/// let square = |x| x * x;\n+/// assert_eq!(square(5), 25);\n+/// ```\n+///\n+/// Closures can also be passed to higher-level functions through a `Fn`\n+/// parameter (or a `FnMut` or `FnOnce` parameter, which are supertraits of\n+/// `Fn`).\n+///\n+/// ```\n+/// fn call_with_one<F>(func: F) -> usize\n+///     where F: Fn(usize) -> usize {\n+///     func(1)\n+/// }\n+///\n+/// let double = |x| x * 2;\n+/// assert_eq!(call_with_one(double), 2);\n+/// ```\n #[lang = \"fn\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_paren_sugar]\n@@ -2211,6 +2307,40 @@ pub trait Fn<Args> : FnMut<Args> {\n }\n \n /// A version of the call operator that takes a mutable receiver.\n+///\n+/// # Examples\n+///\n+/// Closures that mutably capture variables automatically implement this trait,\n+/// which allows them to be invoked.\n+///\n+/// ```\n+/// let mut x = 5;\n+/// {\n+///     let mut square_x = || x *= x;\n+///     square_x();\n+/// }\n+/// assert_eq!(x, 25);\n+/// ```\n+///\n+/// Closures can also be passed to higher-level functions through a `FnMut`\n+/// parameter (or a `FnOnce` parameter, which is a supertrait of `FnMut`).\n+///\n+/// ```\n+/// fn do_twice<F>(mut func: F)\n+///     where F: FnMut()\n+/// {\n+///     func();\n+///     func();\n+/// }\n+///\n+/// let mut x: usize = 1;\n+/// {\n+///     let add_two_to_x = || x += 2;\n+///     do_twice(add_two_to_x);\n+/// }\n+///\n+/// assert_eq!(x, 5);\n+/// ```\n #[lang = \"fn_mut\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_paren_sugar]\n@@ -2222,6 +2352,41 @@ pub trait FnMut<Args> : FnOnce<Args> {\n }\n \n /// A version of the call operator that takes a by-value receiver.\n+///\n+/// # Examples\n+///\n+/// By-value closures automatically implement this trait, which allows them to\n+/// be invoked.\n+///\n+/// ```\n+/// let x = 5;\n+/// let square_x = move || x * x;\n+/// assert_eq!(square_x(), 25);\n+/// ```\n+///\n+/// By-value Closures can also be passed to higher-level functions through a\n+/// `FnOnce` parameter.\n+///\n+/// ```\n+/// fn consume_with_relish<F>(func: F)\n+///     where F: FnOnce() -> String\n+/// {\n+///     // `func` consumes its captured variables, so it cannot be run more\n+///     // than once\n+///     println!(\"Consumed: {}\", func());\n+///\n+///     println!(\"Delicious!\");\n+///\n+///     // Attempting to invoke `func()` again will throw a `use of moved\n+///     // value` error for `func`\n+/// }\n+///\n+/// let x = String::from(\"x\");\n+/// let consume_and_return_x = move || x;\n+/// consume_with_relish(consume_and_return_x);\n+///\n+/// // `consume_and_return_x` can no longer be invoked at this point\n+/// ```\n #[lang = \"fn_once\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_paren_sugar]"}]}