{"sha": "32d5f742cb0bb8dd6c1f37a88b8ec6ad0595ae1b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMyZDVmNzQyY2IwYmI4ZGQ2YzFmMzdhODhiOGVjNmFkMDU5NWFlMWI=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2015-04-14T06:42:48Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2015-04-14T09:20:21Z"}, "message": "typeck: Do high-level structural/signature checks before function body checks.\n\nThis avoids various ICEs, e.g. premature calls to cat_expr that yield\nthe dreaded \"cat_expr Errd\" ICE.", "tree": {"sha": "b63a44377b48825c415d350d6f45e5040252cad4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b63a44377b48825c415d350d6f45e5040252cad4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/32d5f742cb0bb8dd6c1f37a88b8ec6ad0595ae1b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/32d5f742cb0bb8dd6c1f37a88b8ec6ad0595ae1b", "html_url": "https://github.com/rust-lang/rust/commit/32d5f742cb0bb8dd6c1f37a88b8ec6ad0595ae1b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/32d5f742cb0bb8dd6c1f37a88b8ec6ad0595ae1b/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fd69ac160b7252b2acaebaae02535b3f8c27dfb7", "url": "https://api.github.com/repos/rust-lang/rust/commits/fd69ac160b7252b2acaebaae02535b3f8c27dfb7", "html_url": "https://github.com/rust-lang/rust/commit/fd69ac160b7252b2acaebaae02535b3f8c27dfb7"}], "stats": {"total": 115, "additions": 71, "deletions": 44}, "files": [{"sha": "905ec691c778ce9672b694cb9a3a7113b3aea38a", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 71, "deletions": 44, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/32d5f742cb0bb8dd6c1f37a88b8ec6ad0595ae1b/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32d5f742cb0bb8dd6c1f37a88b8ec6ad0595ae1b/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=32d5f742cb0bb8dd6c1f37a88b8ec6ad0595ae1b", "patch": "@@ -441,10 +441,11 @@ fn static_inherited_fields<'a, 'tcx>(ccx: &'a CrateCtxt<'a, 'tcx>)\n }\n \n struct CheckItemTypesVisitor<'a, 'tcx: 'a> { ccx: &'a CrateCtxt<'a, 'tcx> }\n+struct CheckItemBodiesVisitor<'a, 'tcx: 'a> { ccx: &'a CrateCtxt<'a, 'tcx> }\n \n impl<'a, 'tcx> Visitor<'tcx> for CheckItemTypesVisitor<'a, 'tcx> {\n     fn visit_item(&mut self, i: &'tcx ast::Item) {\n-        check_item(self.ccx, i);\n+        check_item_type(self.ccx, i);\n         visit::walk_item(self, i);\n     }\n \n@@ -460,6 +461,13 @@ impl<'a, 'tcx> Visitor<'tcx> for CheckItemTypesVisitor<'a, 'tcx> {\n     }\n }\n \n+impl<'a, 'tcx> Visitor<'tcx> for CheckItemBodiesVisitor<'a, 'tcx> {\n+    fn visit_item(&mut self, i: &'tcx ast::Item) {\n+        check_item_body(self.ccx, i);\n+        visit::walk_item(self, i);\n+    }\n+}\n+\n pub fn check_item_types(ccx: &CrateCtxt) {\n     let krate = ccx.tcx.map.krate();\n     let mut visit = wf::CheckTypeWellFormedVisitor::new(ccx);\n@@ -474,6 +482,11 @@ pub fn check_item_types(ccx: &CrateCtxt) {\n \n     ccx.tcx.sess.abort_if_errors();\n \n+    let mut visit = CheckItemBodiesVisitor { ccx: ccx };\n+    visit::walk_crate(&mut visit, krate);\n+\n+    ccx.tcx.sess.abort_if_errors();\n+\n     for drop_method_did in ccx.tcx.destructors.borrow().iter() {\n         if drop_method_did.krate == ast::LOCAL_CRATE {\n             let drop_impl_did = ccx.tcx.map.get_parent_did(drop_method_did.node);\n@@ -713,13 +726,13 @@ pub fn check_struct(ccx: &CrateCtxt, id: ast::NodeId, span: Span) {\n     }\n }\n \n-pub fn check_item<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx ast::Item) {\n-    debug!(\"check_item(it.id={}, it.ident={})\",\n+pub fn check_item_type<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx ast::Item) {\n+    debug!(\"check_item_type(it.id={}, it.ident={})\",\n            it.id,\n            ty::item_path_str(ccx.tcx, local_def(it.id)));\n     let _indenter = indenter();\n-\n     match it.node {\n+      // Consts can play a role in type-checking, so they are included here.\n       ast::ItemStatic(_, _, ref e) |\n       ast::ItemConst(_, ref e) => check_const(ccx, it.span, &**e, it.id),\n       ast::ItemEnum(ref enum_definition, _) => {\n@@ -728,16 +741,9 @@ pub fn check_item<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx ast::Item) {\n                             &enum_definition.variants,\n                             it.id);\n       }\n-      ast::ItemFn(ref decl, _, _, _, ref body) => {\n-        let fn_pty = ty::lookup_item_type(ccx.tcx, ast_util::local_def(it.id));\n-        let param_env = ParameterEnvironment::for_item(ccx.tcx, it.id);\n-        check_bare_fn(ccx, &**decl, &**body, it.id, it.span, fn_pty.ty, param_env);\n-      }\n+      ast::ItemFn(_, _, _, _, _) => {} // entirely within check_item_body\n       ast::ItemImpl(_, _, _, _, _, ref impl_items) => {\n-        debug!(\"ItemImpl {} with id {}\", token::get_ident(it.ident), it.id);\n-\n-        let impl_pty = ty::lookup_item_type(ccx.tcx, ast_util::local_def(it.id));\n-\n+          debug!(\"ItemImpl {} with id {}\", token::get_ident(it.ident), it.id);\n           match ty::impl_trait_ref(ccx.tcx, local_def(it.id)) {\n               Some(impl_trait_ref) => {\n                 check_impl_items_against_trait(ccx,\n@@ -747,39 +753,9 @@ pub fn check_item<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx ast::Item) {\n               }\n               None => { }\n           }\n-\n-        for impl_item in impl_items {\n-            match impl_item.node {\n-                ast::MethodImplItem(ref sig, ref body) => {\n-                    check_method_body(ccx, &impl_pty.generics, sig, body,\n-                                      impl_item.id, impl_item.span);\n-                }\n-                ast::TypeImplItem(_) |\n-                ast::MacImplItem(_) => {\n-                    // Nothing to do here.\n-                }\n-            }\n-        }\n-\n       }\n-      ast::ItemTrait(_, ref generics, _, ref trait_items) => {\n+      ast::ItemTrait(_, ref generics, _, _) => {\n         check_trait_on_unimplemented(ccx, generics, it);\n-        let trait_def = ty::lookup_trait_def(ccx.tcx, local_def(it.id));\n-        for trait_item in trait_items {\n-            match trait_item.node {\n-                ast::MethodTraitItem(_, None) => {\n-                    // Nothing to do, since required methods don't have\n-                    // bodies to check.\n-                }\n-                ast::MethodTraitItem(ref sig, Some(ref body)) => {\n-                    check_method_body(ccx, &trait_def.generics, sig, body,\n-                                      trait_item.id, trait_item.span);\n-                }\n-                ast::TypeTraitItem(..) => {\n-                    // Nothing to do.\n-                }\n-            }\n-        }\n       }\n       ast::ItemStruct(..) => {\n         check_struct(ccx, it.id, it.span);\n@@ -814,6 +790,57 @@ pub fn check_item<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx ast::Item) {\n     }\n }\n \n+pub fn check_item_body<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx ast::Item) {\n+    debug!(\"check_item_body(it.id={}, it.ident={})\",\n+           it.id,\n+           ty::item_path_str(ccx.tcx, local_def(it.id)));\n+    let _indenter = indenter();\n+    match it.node {\n+      ast::ItemFn(ref decl, _, _, _, ref body) => {\n+        let fn_pty = ty::lookup_item_type(ccx.tcx, ast_util::local_def(it.id));\n+        let param_env = ParameterEnvironment::for_item(ccx.tcx, it.id);\n+        check_bare_fn(ccx, &**decl, &**body, it.id, it.span, fn_pty.ty, param_env);\n+      }\n+      ast::ItemImpl(_, _, _, _, _, ref impl_items) => {\n+        debug!(\"ItemImpl {} with id {}\", token::get_ident(it.ident), it.id);\n+\n+        let impl_pty = ty::lookup_item_type(ccx.tcx, ast_util::local_def(it.id));\n+\n+        for impl_item in impl_items {\n+            match impl_item.node {\n+                ast::MethodImplItem(ref sig, ref body) => {\n+                    check_method_body(ccx, &impl_pty.generics, sig, body,\n+                                      impl_item.id, impl_item.span);\n+                }\n+                ast::TypeImplItem(_) |\n+                ast::MacImplItem(_) => {\n+                    // Nothing to do here.\n+                }\n+            }\n+        }\n+      }\n+      ast::ItemTrait(_, _, _, ref trait_items) => {\n+        let trait_def = ty::lookup_trait_def(ccx.tcx, local_def(it.id));\n+        for trait_item in trait_items {\n+            match trait_item.node {\n+                ast::MethodTraitItem(_, None) => {\n+                    // Nothing to do, since required methods don't have\n+                    // bodies to check.\n+                }\n+                ast::MethodTraitItem(ref sig, Some(ref body)) => {\n+                    check_method_body(ccx, &trait_def.generics, sig, body,\n+                                      trait_item.id, trait_item.span);\n+                }\n+                ast::TypeTraitItem(..) => {\n+                    // Nothing to do.\n+                }\n+            }\n+        }\n+      }\n+      _ => {/* nothing to do */ }\n+    }\n+}\n+\n fn check_trait_on_unimplemented<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                generics: &ast::Generics,\n                                item: &ast::Item) {"}]}