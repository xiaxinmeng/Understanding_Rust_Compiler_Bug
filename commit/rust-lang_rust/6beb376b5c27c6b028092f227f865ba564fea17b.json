{"sha": "6beb376b5c27c6b028092f227f865ba564fea17b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZiZWIzNzZiNWMyN2M2YjAyODA5MmYyMjdmODY1YmE1NjRmZWExN2I=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-04-23T19:01:53Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-04-23T19:01:53Z"}, "message": "auto merge of #13686 : alexcrichton/rust/issue-12224, r=nikomatsakis\n\nThis alters the borrow checker's requirements on invoking closures from\r\nrequiring an immutable borrow to requiring a unique immutable borrow. This means \r\nthat it is illegal to invoke a closure through a `&` pointer because there is no \r\nguarantee that is not aliased. This does not mean that a closure is required to\r\nbe in a mutable location, but rather a location which can be proven to be\r\nunique (often through a mutable pointer).\r\n                                                                                 \r\nFor example, the following code is unsound and is no longer allowed:             \r\n                                                                                 \r\n    type Fn<'a> = ||:'a;                                                         \r\n                                                                                 \r\n    fn call(f: |Fn|) {                                                           \r\n        f(|| {                                                                   \r\n            f(|| {})                                                             \r\n        });                                                                      \r\n    }                                                                            \r\n                                                                                 \r\n    fn main() {                                                                  \r\n        call(|a| {                                                               \r\n            a();                                                                 \r\n        });                                                                      \r\n    }                                                                            \r\n                                                                                 \r\nThere is no replacement for this pattern. For all closures which are stored in\r\nstructures, it was previously allowed to invoke the closure through `&self` but\r\nit now requires invocation through `&mut self`.\r\n\r\nThe standard library has a good number of violations of this new rule, but the\r\nfixes will be separated into multiple breaking change commits.\r\n                                                                                 \r\nCloses #12224", "tree": {"sha": "b52fa55b56bb4c1b21d1753c7d5c2402894d3c9b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b52fa55b56bb4c1b21d1753c7d5c2402894d3c9b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6beb376b5c27c6b028092f227f865ba564fea17b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6beb376b5c27c6b028092f227f865ba564fea17b", "html_url": "https://github.com/rust-lang/rust/commit/6beb376b5c27c6b028092f227f865ba564fea17b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6beb376b5c27c6b028092f227f865ba564fea17b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b5dd3f05fe95168b5569d0f519636149479eb6ac", "url": "https://api.github.com/repos/rust-lang/rust/commits/b5dd3f05fe95168b5569d0f519636149479eb6ac", "html_url": "https://github.com/rust-lang/rust/commit/b5dd3f05fe95168b5569d0f519636149479eb6ac"}, {"sha": "823c7eee6a040862abb5a5309693030394200e62", "url": "https://api.github.com/repos/rust-lang/rust/commits/823c7eee6a040862abb5a5309693030394200e62", "html_url": "https://github.com/rust-lang/rust/commit/823c7eee6a040862abb5a5309693030394200e62"}], "stats": {"total": 554, "additions": 360, "deletions": 194}, "files": [{"sha": "13180cdfa5b6c839e6cfdcd9ba8e5d98e5a0160d", "filename": "src/libcollections/bitv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6beb376b5c27c6b028092f227f865ba564fea17b/src%2Flibcollections%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6beb376b5c27c6b028092f227f865ba564fea17b/src%2Flibcollections%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbitv.rs?ref=6beb376b5c27c6b028092f227f865ba564fea17b", "patch": "@@ -632,7 +632,7 @@ impl<'a> RandomAccessIterator<bool> for Bits<'a> {\n     }\n \n     #[inline]\n-    fn idx(&self, index: uint) -> Option<bool> {\n+    fn idx(&mut self, index: uint) -> Option<bool> {\n         if index >= self.indexable() {\n             None\n         } else {"}, {"sha": "9204a9ca4003dc461e0964b01e3cdff306d4f067", "filename": "src/libcollections/ringbuf.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6beb376b5c27c6b028092f227f865ba564fea17b/src%2Flibcollections%2Fringbuf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6beb376b5c27c6b028092f227f865ba564fea17b/src%2Flibcollections%2Fringbuf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fringbuf.rs?ref=6beb376b5c27c6b028092f227f865ba564fea17b", "patch": "@@ -272,7 +272,7 @@ impl<'a, T> RandomAccessIterator<&'a T> for Items<'a, T> {\n     fn indexable(&self) -> uint { self.rindex - self.index }\n \n     #[inline]\n-    fn idx(&self, j: uint) -> Option<&'a T> {\n+    fn idx(&mut self, j: uint) -> Option<&'a T> {\n         if j >= self.indexable() {\n             None\n         } else {"}, {"sha": "77c94d0150862fbe17a4a4e13bf0f2adee9e014d", "filename": "src/libnum/bigint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6beb376b5c27c6b028092f227f865ba564fea17b/src%2Flibnum%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6beb376b5c27c6b028092f227f865ba564fea17b/src%2Flibnum%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnum%2Fbigint.rs?ref=6beb376b5c27c6b028092f227f865ba564fea17b", "patch": "@@ -672,7 +672,7 @@ impl ToStrRadix for BigUint {\n                 s.push_str(\"0\".repeat(l - ss.len()));\n                 s.push_str(ss);\n             }\n-            s.as_slice().trim_left_chars(&'0').to_owned()\n+            s.as_slice().trim_left_chars('0').to_owned()\n         }\n     }\n }"}, {"sha": "888a8f6bd8d856feb69273ed9f0c70e6c3d2773d", "filename": "src/librustc/front/config.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/6beb376b5c27c6b028092f227f865ba564fea17b/src%2Flibrustc%2Ffront%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6beb376b5c27c6b028092f227f865ba564fea17b/src%2Flibrustc%2Ffront%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fconfig.rs?ref=6beb376b5c27c6b028092f227f865ba564fea17b", "patch": "@@ -47,7 +47,7 @@ pub fn strip_items(krate: ast::Crate,\n     ctxt.fold_crate(krate)\n }\n \n-fn filter_view_item<'r>(cx: &Context, view_item: &'r ast::ViewItem)\n+fn filter_view_item<'r>(cx: &mut Context, view_item: &'r ast::ViewItem)\n                         -> Option<&'r ast::ViewItem> {\n     if view_item_in_cfg(cx, view_item) {\n         Some(view_item)\n@@ -72,7 +72,7 @@ fn fold_mod(cx: &mut Context, m: &ast::Mod) -> ast::Mod {\n     }\n }\n \n-fn filter_foreign_item(cx: &Context, item: @ast::ForeignItem)\n+fn filter_foreign_item(cx: &mut Context, item: @ast::ForeignItem)\n                        -> Option<@ast::ForeignItem> {\n     if foreign_item_in_cfg(cx, item) {\n         Some(item)\n@@ -144,7 +144,7 @@ fn fold_item_underscore(cx: &mut Context, item: &ast::Item_) -> ast::Item_ {\n     fold::noop_fold_item_underscore(&item, cx)\n }\n \n-fn fold_struct(cx: &Context, def: &ast::StructDef) -> @ast::StructDef {\n+fn fold_struct(cx: &mut Context, def: &ast::StructDef) -> @ast::StructDef {\n     let mut fields = def.fields.iter().map(|c| c.clone()).filter(|m| {\n         (cx.in_cfg)(m.node.attrs.as_slice())\n     });\n@@ -156,7 +156,7 @@ fn fold_struct(cx: &Context, def: &ast::StructDef) -> @ast::StructDef {\n     }\n }\n \n-fn retain_stmt(cx: &Context, stmt: @ast::Stmt) -> bool {\n+fn retain_stmt(cx: &mut Context, stmt: @ast::Stmt) -> bool {\n     match stmt.node {\n       ast::StmtDecl(decl, _) => {\n         match decl.node {\n@@ -189,23 +189,23 @@ fn fold_block(cx: &mut Context, b: ast::P<ast::Block>) -> ast::P<ast::Block> {\n     })\n }\n \n-fn item_in_cfg(cx: &Context, item: &ast::Item) -> bool {\n+fn item_in_cfg(cx: &mut Context, item: &ast::Item) -> bool {\n     return (cx.in_cfg)(item.attrs.as_slice());\n }\n \n-fn foreign_item_in_cfg(cx: &Context, item: &ast::ForeignItem) -> bool {\n+fn foreign_item_in_cfg(cx: &mut Context, item: &ast::ForeignItem) -> bool {\n     return (cx.in_cfg)(item.attrs.as_slice());\n }\n \n-fn view_item_in_cfg(cx: &Context, item: &ast::ViewItem) -> bool {\n+fn view_item_in_cfg(cx: &mut Context, item: &ast::ViewItem) -> bool {\n     return (cx.in_cfg)(item.attrs.as_slice());\n }\n \n-fn method_in_cfg(cx: &Context, meth: &ast::Method) -> bool {\n+fn method_in_cfg(cx: &mut Context, meth: &ast::Method) -> bool {\n     return (cx.in_cfg)(meth.attrs.as_slice());\n }\n \n-fn trait_method_in_cfg(cx: &Context, meth: &ast::TraitMethod) -> bool {\n+fn trait_method_in_cfg(cx: &mut Context, meth: &ast::TraitMethod) -> bool {\n     match *meth {\n         ast::Required(ref meth) => (cx.in_cfg)(meth.attrs.as_slice()),\n         ast::Provided(meth) => (cx.in_cfg)(meth.attrs.as_slice())"}, {"sha": "884fa70dc28b55dfc53e56cbf591f5bde454876f", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 33, "deletions": 25, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/6beb376b5c27c6b028092f227f865ba564fea17b/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6beb376b5c27c6b028092f227f865ba564fea17b/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=6beb376b5c27c6b028092f227f865ba564fea17b", "patch": "@@ -84,7 +84,7 @@ pub struct EncodeContext<'a> {\n     pub non_inlineable_statics: &'a RefCell<NodeSet>,\n     pub link_meta: &'a LinkMeta,\n     pub cstore: &'a cstore::CStore,\n-    pub encode_inlined_item: EncodeInlinedItem<'a>,\n+    pub encode_inlined_item: RefCell<EncodeInlinedItem<'a>>,\n     pub type_abbrevs: tyencode::abbrev_map,\n }\n \n@@ -765,8 +765,8 @@ fn encode_info_for_method(ecx: &EncodeContext,\n         if num_params > 0u ||\n                 is_default_impl ||\n                 should_inline(ast_method.attrs.as_slice()) {\n-            (ecx.encode_inlined_item)(\n-                ecx, ebml_w, IIMethodRef(local_def(parent_id), false, ast_method));\n+            encode_inlined_item(ecx, ebml_w,\n+                                IIMethodRef(local_def(parent_id), false, ast_method));\n         } else {\n             encode_symbol(ecx, ebml_w, m.def_id.node);\n         }\n@@ -775,6 +775,14 @@ fn encode_info_for_method(ecx: &EncodeContext,\n     ebml_w.end_tag();\n }\n \n+fn encode_inlined_item(ecx: &EncodeContext,\n+                       ebml_w: &mut Encoder,\n+                       ii: InlinedItemRef) {\n+    let mut eii = ecx.encode_inlined_item.borrow_mut();\n+    let eii: &mut EncodeInlinedItem = &mut *eii;\n+    (*eii)(ecx, ebml_w, ii)\n+}\n+\n fn style_fn_family(s: FnStyle) -> char {\n     match s {\n         UnsafeFn => 'u',\n@@ -880,7 +888,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         let inlineable = !ecx.non_inlineable_statics.borrow().contains(&item.id);\n \n         if inlineable {\n-            (ecx.encode_inlined_item)(ecx, ebml_w, IIItemRef(item));\n+            encode_inlined_item(ecx, ebml_w, IIItemRef(item));\n         }\n         encode_visibility(ebml_w, vis);\n         ebml_w.end_tag();\n@@ -896,7 +904,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_path(ebml_w, path);\n         encode_attributes(ebml_w, item.attrs.as_slice());\n         if tps_len > 0u || should_inline(item.attrs.as_slice()) {\n-            (ecx.encode_inlined_item)(ecx, ebml_w, IIItemRef(item));\n+            encode_inlined_item(ecx, ebml_w, IIItemRef(item));\n         } else {\n             encode_symbol(ecx, ebml_w, item.id);\n         }\n@@ -954,7 +962,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         for v in (*enum_definition).variants.iter() {\n             encode_variant_id(ebml_w, local_def(v.node.id));\n         }\n-        (ecx.encode_inlined_item)(ecx, ebml_w, IIItemRef(item));\n+        encode_inlined_item(ecx, ebml_w, IIItemRef(item));\n         encode_path(ebml_w, path);\n \n         // Encode inherent implementations for this enumeration.\n@@ -1002,7 +1010,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         needs to know*/\n         encode_struct_fields(ebml_w, fields.as_slice(), def_id);\n \n-        (ecx.encode_inlined_item)(ecx, ebml_w, IIItemRef(item));\n+        encode_inlined_item(ecx, ebml_w, IIItemRef(item));\n \n         // Encode inherent implementations for this structure.\n         encode_inherent_implementations(ecx, ebml_w, def_id);\n@@ -1175,8 +1183,8 @@ fn encode_info_for_item(ecx: &EncodeContext,\n                         encode_bounds_and_type(ebml_w, ecx, &tpt);\n                     }\n                     encode_method_sort(ebml_w, 'p');\n-                    (ecx.encode_inlined_item)(\n-                        ecx, ebml_w, IIMethodRef(def_id, true, m));\n+                    encode_inlined_item(ecx, ebml_w,\n+                                        IIMethodRef(def_id, true, m));\n                 }\n             }\n \n@@ -1212,7 +1220,7 @@ fn encode_info_for_foreign_item(ecx: &EncodeContext,\n                                &lookup_item_type(ecx.tcx,local_def(nitem.id)));\n         encode_name(ebml_w, nitem.ident.name);\n         if abi == abi::RustIntrinsic {\n-            (ecx.encode_inlined_item)(ecx, ebml_w, IIForeignRef(nitem));\n+            encode_inlined_item(ecx, ebml_w, IIForeignRef(nitem));\n         } else {\n             encode_symbol(ecx, ebml_w, nitem.id);\n         }\n@@ -1544,12 +1552,12 @@ fn encode_macro_registrar_fn(ecx: &EncodeContext, ebml_w: &mut Encoder) {\n     }\n }\n \n-struct MacroDefVisitor<'a, 'b> {\n-    ecx: &'a EncodeContext<'a>,\n-    ebml_w: &'a mut Encoder<'b>\n+struct MacroDefVisitor<'a, 'b, 'c> {\n+    ecx: &'a EncodeContext<'b>,\n+    ebml_w: &'a mut Encoder<'c>\n }\n \n-impl<'a, 'b> Visitor<()> for MacroDefVisitor<'a, 'b> {\n+impl<'a, 'b, 'c> Visitor<()> for MacroDefVisitor<'a, 'b, 'c> {\n     fn visit_item(&mut self, item: &Item, _: ()) {\n         match item.node {\n             ItemMac(..) => {\n@@ -1565,9 +1573,9 @@ impl<'a, 'b> Visitor<()> for MacroDefVisitor<'a, 'b> {\n     }\n }\n \n-fn encode_macro_defs(ecx: &EncodeContext,\n-                     krate: &Crate,\n-                     ebml_w: &mut Encoder) {\n+fn encode_macro_defs<'a>(ecx: &'a EncodeContext,\n+                         krate: &Crate,\n+                         ebml_w: &'a mut Encoder) {\n     ebml_w.start_tag(tag_exported_macros);\n     {\n         let mut visitor = MacroDefVisitor {\n@@ -1579,12 +1587,12 @@ fn encode_macro_defs(ecx: &EncodeContext,\n     ebml_w.end_tag();\n }\n \n-struct ImplVisitor<'a,'b> {\n-    ecx: &'a EncodeContext<'a>,\n-    ebml_w: &'a mut Encoder<'b>,\n+struct ImplVisitor<'a,'b,'c> {\n+    ecx: &'a EncodeContext<'b>,\n+    ebml_w: &'a mut Encoder<'c>,\n }\n \n-impl<'a,'b> Visitor<()> for ImplVisitor<'a,'b> {\n+impl<'a,'b,'c> Visitor<()> for ImplVisitor<'a,'b,'c> {\n     fn visit_item(&mut self, item: &Item, _: ()) {\n         match item.node {\n             ItemImpl(_, Some(ref trait_ref), _, _) => {\n@@ -1617,9 +1625,9 @@ impl<'a,'b> Visitor<()> for ImplVisitor<'a,'b> {\n /// * Destructors (implementations of the Drop trait).\n ///\n /// * Implementations of traits not defined in this crate.\n-fn encode_impls(ecx: &EncodeContext,\n-                krate: &Crate,\n-                ebml_w: &mut Encoder) {\n+fn encode_impls<'a>(ecx: &'a EncodeContext,\n+                    krate: &Crate,\n+                    ebml_w: &'a mut Encoder) {\n     ebml_w.start_tag(tag_impls);\n \n     {\n@@ -1744,7 +1752,7 @@ fn encode_metadata_inner(wr: &mut MemWriter, parms: EncodeParams, krate: &Crate)\n         non_inlineable_statics: non_inlineable_statics,\n         link_meta: link_meta,\n         cstore: cstore,\n-        encode_inlined_item: encode_inlined_item,\n+        encode_inlined_item: RefCell::new(encode_inlined_item),\n         type_abbrevs: RefCell::new(HashMap::new()),\n      };\n "}, {"sha": "5e0b249ce3f23606bafd85c2b24d6376106b8193", "filename": "src/librustc/metadata/filesearch.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6beb376b5c27c6b028092f227f865ba564fea17b/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6beb376b5c27c6b028092f227f865ba564fea17b/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs?ref=6beb376b5c27c6b028092f227f865ba564fea17b", "patch": "@@ -92,9 +92,9 @@ impl<'a> FileSearch<'a> {\n             match fs::readdir(lib_search_path) {\n                 Ok(files) => {\n                     let mut rslt = FileDoesntMatch;\n-                    let is_rlib = |p: & &Path| {\n+                    fn is_rlib(p: & &Path) -> bool {\n                         p.extension_str() == Some(\"rlib\")\n-                    };\n+                    }\n                     // Reading metadata out of rlibs is faster, and if we find both\n                     // an rlib and a dylib we only read one of the files of\n                     // metadata, so in the name of speed, bring all rlib files to"}, {"sha": "d0f4796683250dfe4b9ad4a6e5404aea475b4232", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6beb376b5c27c6b028092f227f865ba564fea17b/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6beb376b5c27c6b028092f227f865ba564fea17b/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=6beb376b5c27c6b028092f227f865ba564fea17b", "patch": "@@ -327,7 +327,7 @@ impl<'a> CheckLoanCtxt<'a> {\n                             self.bccx.loan_path_to_str(&*old_loan.loan_path))\n                 }\n \n-                AddrOf | AutoRef | RefBinding => {\n+                AddrOf | AutoRef | RefBinding | ClosureInvocation => {\n                     format!(\"previous borrow of `{}` occurs here\",\n                             self.bccx.loan_path_to_str(&*old_loan.loan_path))\n                 }"}, {"sha": "8bb95b798d0aa46e11446ec0a7fa0204505a54bc", "filename": "src/librustc/middle/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/6beb376b5c27c6b028092f227f865ba564fea17b/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6beb376b5c27c6b028092f227f865ba564fea17b/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=6beb376b5c27c6b028092f227f865ba564fea17b", "patch": "@@ -292,6 +292,26 @@ fn gather_loans_in_expr(this: &mut GatherLoanCtxt,\n           visit::walk_expr(this, ex, ());\n       }\n \n+      ast::ExprCall(f, _) => {\n+          let expr_ty = ty::expr_ty_adjusted(tcx, f);\n+          match ty::get(expr_ty).sty {\n+              ty::ty_closure(~ty::ClosureTy {\n+                  store: ty::RegionTraitStore(..), ..\n+              }) => {\n+                  let scope_r = ty::ReScope(ex.id);\n+                  let base_cmt = this.bccx.cat_expr(f);\n+                  this.guarantee_valid_kind(f.id,\n+                                            f.span,\n+                                            base_cmt,\n+                                            ty::UniqueImmBorrow,\n+                                            scope_r,\n+                                            ClosureInvocation);\n+              }\n+              _ => {}\n+          }\n+          visit::walk_expr(this, ex, ());\n+      }\n+\n       _ => {\n           visit::walk_expr(this, ex, ());\n       }"}, {"sha": "3de64f151917e24436ec0f05671aa25959c9f276", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6beb376b5c27c6b028092f227f865ba564fea17b/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6beb376b5c27c6b028092f227f865ba564fea17b/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=6beb376b5c27c6b028092f227f865ba564fea17b", "patch": "@@ -202,6 +202,7 @@ pub enum LoanCause {\n     AddrOf,\n     AutoRef,\n     RefBinding,\n+    ClosureInvocation,\n }\n \n #[deriving(Eq, TotalEq, Hash)]\n@@ -629,6 +630,10 @@ impl<'a> BorrowckCtxt<'a> {\n                     AddrOf | RefBinding | AutoRef => {\n                         format!(\"cannot borrow {} as mutable\", descr)\n                     }\n+                    ClosureInvocation => {\n+                        self.tcx.sess.span_bug(err.span,\n+                            \"err_mutbl with a closure invocation\");\n+                    }\n                 }\n             }\n             err_out_of_root_scope(..) => {\n@@ -677,6 +682,10 @@ impl<'a> BorrowckCtxt<'a> {\n             BorrowViolation(RefBinding) => {\n                 \"cannot borrow data mutably\"\n             }\n+\n+            BorrowViolation(ClosureInvocation) => {\n+                \"closure invocation\"\n+            }\n         };\n \n         match cause {"}, {"sha": "05a225d8953fce281575459cf42eb0ea1b48ef17", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6beb376b5c27c6b028092f227f865ba564fea17b/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6beb376b5c27c6b028092f227f865ba564fea17b/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=6beb376b5c27c6b028092f227f865ba564fea17b", "patch": "@@ -1164,7 +1164,7 @@ fn check_item_non_camel_case_types(cx: &Context, it: &ast::Item) {\n     fn is_camel_case(ident: ast::Ident) -> bool {\n         let ident = token::get_ident(ident);\n         assert!(!ident.get().is_empty());\n-        let ident = ident.get().trim_chars(&'_');\n+        let ident = ident.get().trim_chars('_');\n \n         // start with a non-lowercase letter rather than non-uppercase\n         // ones (some scripts don't have a concept of upper/lowercase)"}, {"sha": "4e2d8cf585f2cebca8af26699f4c6c1ea5485500", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/6beb376b5c27c6b028092f227f865ba564fea17b/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6beb376b5c27c6b028092f227f865ba564fea17b/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=6beb376b5c27c6b028092f227f865ba564fea17b", "patch": "@@ -1104,34 +1104,34 @@ impl<'a> SanePrivacyVisitor<'a> {\n     /// control over anything so this forbids any mention of any visibility\n     fn check_all_inherited(&self, item: &ast::Item) {\n         let tcx = self.tcx;\n-        let check_inherited = |sp: Span, vis: ast::Visibility| {\n+        fn check_inherited(tcx: &ty::ctxt, sp: Span, vis: ast::Visibility) {\n             if vis != ast::Inherited {\n                 tcx.sess.span_err(sp, \"visibility has no effect inside functions\");\n             }\n-        };\n+        }\n         let check_struct = |def: &@ast::StructDef| {\n             for f in def.fields.iter() {\n                match f.node.kind {\n-                    ast::NamedField(_, p) => check_inherited(f.span, p),\n+                    ast::NamedField(_, p) => check_inherited(tcx, f.span, p),\n                     ast::UnnamedField(..) => {}\n                 }\n             }\n         };\n-        check_inherited(item.span, item.vis);\n+        check_inherited(tcx, item.span, item.vis);\n         match item.node {\n             ast::ItemImpl(_, _, _, ref methods) => {\n                 for m in methods.iter() {\n-                    check_inherited(m.span, m.vis);\n+                    check_inherited(tcx, m.span, m.vis);\n                 }\n             }\n             ast::ItemForeignMod(ref fm) => {\n                 for i in fm.items.iter() {\n-                    check_inherited(i.span, i.vis);\n+                    check_inherited(tcx, i.span, i.vis);\n                 }\n             }\n             ast::ItemEnum(ref def, _) => {\n                 for v in def.variants.iter() {\n-                    check_inherited(v.span, v.node.vis);\n+                    check_inherited(tcx, v.span, v.node.vis);\n \n                     match v.node.kind {\n                         ast::StructVariantKind(ref s) => check_struct(s),\n@@ -1146,7 +1146,8 @@ impl<'a> SanePrivacyVisitor<'a> {\n                 for m in methods.iter() {\n                     match *m {\n                         ast::Required(..) => {}\n-                        ast::Provided(ref m) => check_inherited(m.span, m.vis),\n+                        ast::Provided(ref m) => check_inherited(tcx, m.span,\n+                                                                m.vis),\n                     }\n                 }\n             }"}, {"sha": "b59da8910af8b4ff8d00f590c46f5168a9dabdd7", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 31, "deletions": 18, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/6beb376b5c27c6b028092f227f865ba564fea17b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6beb376b5c27c6b028092f227f865ba564fea17b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=6beb376b5c27c6b028092f227f865ba564fea17b", "patch": "@@ -751,7 +751,15 @@ fn constrain_callee(rcx: &mut Rcx,\n         ty::ty_bare_fn(..) => { }\n         ty::ty_closure(ref closure_ty) => {\n             let region = match closure_ty.store {\n-                ty::RegionTraitStore(r, _) => r,\n+                ty::RegionTraitStore(r, _) => {\n+                    // While we're here, link the closure's region with a unique\n+                    // immutable borrow (gathered later in borrowck)\n+                    let mc = mc::MemCategorizationContext { typer: &*rcx };\n+                    let expr_cmt = ignore_err!(mc.cat_expr(callee_expr));\n+                    link_region(mc.typer, callee_expr.span, call_region,\n+                                ty::UniqueImmBorrow, expr_cmt);\n+                    r\n+                }\n                 ty::UniqTraitStore => ty::ReStatic\n             };\n             rcx.fcx.mk_subr(true, infer::InvokeClosure(callee_expr.span),\n@@ -874,7 +882,8 @@ fn constrain_autoderefs(rcx: &mut Rcx,\n                 {\n                     let mc = mc::MemCategorizationContext { typer: &*rcx };\n                     let self_cmt = ignore_err!(mc.cat_expr_autoderefd(deref_expr, i));\n-                    link_region(mc.typer, deref_expr.span, r, m, self_cmt);\n+                    link_region(mc.typer, deref_expr.span, r,\n+                                ty::BorrowKind::from_mutbl(m), self_cmt);\n                 }\n \n                 // Specialized version of constrain_call.\n@@ -1092,7 +1101,8 @@ fn link_pattern(mc: mc::MemCategorizationContext<&Rcx>,\n                     match mc.cat_slice_pattern(sub_cmt, slice_pat) {\n                         Ok((slice_cmt, slice_mutbl, slice_r)) => {\n                             link_region(mc.typer, sub_pat.span, slice_r,\n-                                        slice_mutbl, slice_cmt);\n+                                        ty::BorrowKind::from_mutbl(slice_mutbl),\n+                                        slice_cmt);\n                         }\n                         Err(()) => {}\n                     }\n@@ -1118,17 +1128,20 @@ fn link_autoref(rcx: &Rcx,\n \n     match *autoref {\n         ty::AutoPtr(r, m) => {\n-            link_region(mc.typer, expr.span, r, m, expr_cmt);\n+            link_region(mc.typer, expr.span, r,\n+                        ty::BorrowKind::from_mutbl(m), expr_cmt);\n         }\n \n         ty::AutoBorrowVec(r, m) | ty::AutoBorrowVecRef(r, m) => {\n             let cmt_index = mc.cat_index(expr, expr_cmt, autoderefs+1);\n-            link_region(mc.typer, expr.span, r, m, cmt_index);\n+            link_region(mc.typer, expr.span, r,\n+                        ty::BorrowKind::from_mutbl(m), cmt_index);\n         }\n \n         ty::AutoBorrowObj(r, m) => {\n             let cmt_deref = mc.cat_deref_obj(expr, expr_cmt);\n-            link_region(mc.typer, expr.span, r, m, cmt_deref);\n+            link_region(mc.typer, expr.span, r,\n+                        ty::BorrowKind::from_mutbl(m), cmt_deref);\n         }\n \n         ty::AutoUnsafe(_) => {}\n@@ -1150,7 +1163,7 @@ fn link_by_ref(rcx: &Rcx,\n     let mc = mc::MemCategorizationContext { typer: rcx };\n     let expr_cmt = ignore_err!(mc.cat_expr(expr));\n     let region_min = ty::ReScope(callee_scope);\n-    link_region(mc.typer, expr.span, region_min, ast::MutImmutable, expr_cmt);\n+    link_region(mc.typer, expr.span, region_min, ty::ImmBorrow, expr_cmt);\n }\n \n fn link_region_from_node_type(rcx: &Rcx,\n@@ -1169,18 +1182,19 @@ fn link_region_from_node_type(rcx: &Rcx,\n         let tcx = rcx.fcx.ccx.tcx;\n         debug!(\"rptr_ty={}\", ty_to_str(tcx, rptr_ty));\n         let r = ty::ty_region(tcx, span, rptr_ty);\n-        link_region(rcx, span, r, mutbl, cmt_borrowed);\n+        link_region(rcx, span, r, ty::BorrowKind::from_mutbl(mutbl),\n+                    cmt_borrowed);\n     }\n }\n \n fn link_region(rcx: &Rcx,\n                span: Span,\n                region_min: ty::Region,\n-               mutbl: ast::Mutability,\n+               kind: ty::BorrowKind,\n                cmt_borrowed: mc::cmt) {\n     /*!\n      * Informs the inference engine that a borrow of `cmt`\n-     * must have mutability `mutbl` and lifetime `region_min`.\n+     * must have the borrow kind `kind` and lifetime `region_min`.\n      * If `cmt` is a deref of a region pointer with\n      * lifetime `r_borrowed`, this will add the constraint that\n      * `region_min <= r_borrowed`.\n@@ -1190,9 +1204,9 @@ fn link_region(rcx: &Rcx,\n     // for the lifetime `region_min` for the borrow to be valid:\n     let mut cmt_borrowed = cmt_borrowed;\n     loop {\n-        debug!(\"link_region(region_min={}, mutbl={}, cmt_borrowed={})\",\n+        debug!(\"link_region(region_min={}, kind={}, cmt_borrowed={})\",\n                region_min.repr(rcx.tcx()),\n-               mutbl.repr(rcx.tcx()),\n+               kind.repr(rcx.tcx()),\n                cmt_borrowed.repr(rcx.tcx()));\n         match cmt_borrowed.cat.clone() {\n             mc::cat_deref(base, _, mc::BorrowedPtr(_, r_borrowed)) => {\n@@ -1214,7 +1228,7 @@ fn link_region(rcx: &Rcx,\n                                 adjust_upvar_borrow_kind_for_loan(\n                                     *upvar_id,\n                                     upvar_borrow,\n-                                    mutbl);\n+                                    kind);\n                                 infer::ReborrowUpvar(span, *upvar_id)\n                             }\n                             None => {\n@@ -1236,7 +1250,7 @@ fn link_region(rcx: &Rcx,\n                        r_borrowed.repr(rcx.tcx()));\n                 rcx.fcx.mk_subr(true, cause, region_min, r_borrowed);\n \n-                if mutbl == ast::MutMutable {\n+                if kind != ty::ImmBorrow {\n                     // If this is a mutable borrow, then the thing\n                     // being borrowed will have to be unique.\n                     // In user code, this means it must be an `&mut`\n@@ -1428,12 +1442,11 @@ fn link_upvar_borrow_kind_for_nested_closures(rcx: &mut Rcx,\n \n fn adjust_upvar_borrow_kind_for_loan(upvar_id: ty::UpvarId,\n                                      upvar_borrow: &mut ty::UpvarBorrow,\n-                                     mutbl: ast::Mutability) {\n+                                     kind: ty::BorrowKind) {\n     debug!(\"adjust_upvar_borrow_kind_for_loan: upvar_id={:?} kind={:?} -> {:?}\",\n-           upvar_id, upvar_borrow.kind, mutbl);\n+           upvar_id, upvar_borrow.kind, kind);\n \n-    adjust_upvar_borrow_kind(upvar_id, upvar_borrow,\n-                             ty::BorrowKind::from_mutbl(mutbl))\n+    adjust_upvar_borrow_kind(upvar_id, upvar_borrow, kind)\n }\n \n fn adjust_upvar_borrow_kind(upvar_id: ty::UpvarId,"}, {"sha": "7621a7ec4cd5efdc948a9d9e20438225a1f7429b", "filename": "src/libstd/io/net/ip.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6beb376b5c27c6b028092f227f865ba564fea17b/src%2Flibstd%2Fio%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6beb376b5c27c6b028092f227f865ba564fea17b/src%2Flibstd%2Fio%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fip.rs?ref=6beb376b5c27c6b028092f227f865ba564fea17b", "patch": "@@ -107,9 +107,9 @@ impl<'a> Parser<'a> {\n     }\n \n     // Return result of first successful parser\n-    fn read_or<T>(&mut self, parsers: &[|&mut Parser| -> Option<T>])\n+    fn read_or<T>(&mut self, parsers: &mut [|&mut Parser| -> Option<T>])\n                -> Option<T> {\n-        for pf in parsers.iter() {\n+        for pf in parsers.mut_iter() {\n             match self.read_atomically(|p: &mut Parser| (*pf)(p)) {\n                 Some(r) => return Some(r),\n                 None => {}\n@@ -305,7 +305,7 @@ impl<'a> Parser<'a> {\n     fn read_ip_addr(&mut self) -> Option<IpAddr> {\n         let ipv4_addr = |p: &mut Parser| p.read_ipv4_addr();\n         let ipv6_addr = |p: &mut Parser| p.read_ipv6_addr();\n-        self.read_or([ipv4_addr, ipv6_addr])\n+        self.read_or(&mut [ipv4_addr, ipv6_addr])\n     }\n \n     fn read_socket_addr(&mut self) -> Option<SocketAddr> {\n@@ -318,7 +318,7 @@ impl<'a> Parser<'a> {\n                 p.read_seq_3::<char, IpAddr, char>(open_br, ip_addr, clos_br)\n                         .map(|t| match t { (_, ip, _) => ip })\n             };\n-            p.read_or([ipv4_p, ipv6_p])\n+            p.read_or(&mut [ipv4_p, ipv6_p])\n         };\n         let colon = |p: &mut Parser| p.read_given_char(':');\n         let port  = |p: &mut Parser| p.read_number(10, 5, 0x10000).map(|n| n as u16);"}, {"sha": "d895331752f882a1422d38368b1e1c29b35c8796", "filename": "src/libstd/iter.rs", "status": "modified", "additions": 22, "deletions": 19, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/6beb376b5c27c6b028092f227f865ba564fea17b/src%2Flibstd%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6beb376b5c27c6b028092f227f865ba564fea17b/src%2Flibstd%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fiter.rs?ref=6beb376b5c27c6b028092f227f865ba564fea17b", "patch": "@@ -703,7 +703,7 @@ pub trait RandomAccessIterator<A>: Iterator<A> {\n     fn indexable(&self) -> uint;\n \n     /// Return an element at an index\n-    fn idx(&self, index: uint) -> Option<A>;\n+    fn idx(&mut self, index: uint) -> Option<A>;\n }\n \n /// An iterator that knows its exact length\n@@ -771,8 +771,9 @@ impl<A, T: DoubleEndedIterator<A> + RandomAccessIterator<A>> RandomAccessIterato\n     #[inline]\n     fn indexable(&self) -> uint { self.iter.indexable() }\n     #[inline]\n-    fn idx(&self, index: uint) -> Option<A> {\n-        self.iter.idx(self.indexable() - index - 1)\n+    fn idx(&mut self, index: uint) -> Option<A> {\n+        let amt = self.indexable();\n+        self.iter.idx(amt - index - 1)\n     }\n }\n \n@@ -1071,7 +1072,7 @@ impl<A, T: Clone + RandomAccessIterator<A>> RandomAccessIterator<A> for Cycle<T>\n     }\n \n     #[inline]\n-    fn idx(&self, index: uint) -> Option<A> {\n+    fn idx(&mut self, index: uint) -> Option<A> {\n         let liter = self.iter.indexable();\n         let lorig = self.orig.indexable();\n         if lorig == 0 {\n@@ -1143,7 +1144,7 @@ for Chain<T, U> {\n     }\n \n     #[inline]\n-    fn idx(&self, index: uint) -> Option<A> {\n+    fn idx(&mut self, index: uint) -> Option<A> {\n         let len = self.a.indexable();\n         if index < len {\n             self.a.idx(index)\n@@ -1221,7 +1222,7 @@ RandomAccessIterator<(A, B)> for Zip<T, U> {\n     }\n \n     #[inline]\n-    fn idx(&self, index: uint) -> Option<(A, B)> {\n+    fn idx(&mut self, index: uint) -> Option<(A, B)> {\n         match self.a.idx(index) {\n             None => None,\n             Some(x) => match self.b.idx(index) {\n@@ -1240,7 +1241,7 @@ pub struct Map<'a, A, B, T> {\n \n impl<'a, A, B, T> Map<'a, A, B, T> {\n     #[inline]\n-    fn do_map(&self, elt: Option<A>) -> Option<B> {\n+    fn do_map(&mut self, elt: Option<A>) -> Option<B> {\n         match elt {\n             Some(a) => Some((self.f)(a)),\n             _ => None\n@@ -1276,8 +1277,9 @@ impl<'a, A, B, T: RandomAccessIterator<A>> RandomAccessIterator<B> for Map<'a, A\n     }\n \n     #[inline]\n-    fn idx(&self, index: uint) -> Option<B> {\n-        self.do_map(self.iter.idx(index))\n+    fn idx(&mut self, index: uint) -> Option<B> {\n+        let elt = self.iter.idx(index);\n+        self.do_map(elt)\n     }\n }\n \n@@ -1415,7 +1417,7 @@ impl<A, T: RandomAccessIterator<A>> RandomAccessIterator<(uint, A)> for Enumerat\n     }\n \n     #[inline]\n-    fn idx(&self, index: uint) -> Option<(uint, A)> {\n+    fn idx(&mut self, index: uint) -> Option<(uint, A)> {\n         match self.iter.idx(index) {\n             Some(a) => Some((self.count + index, a)),\n             _ => None,\n@@ -1600,7 +1602,7 @@ impl<A, T: RandomAccessIterator<A>> RandomAccessIterator<A> for Skip<T> {\n     }\n \n     #[inline]\n-    fn idx(&self, index: uint) -> Option<A> {\n+    fn idx(&mut self, index: uint) -> Option<A> {\n         if index >= self.indexable() {\n             None\n         } else {\n@@ -1649,7 +1651,7 @@ impl<A, T: RandomAccessIterator<A>> RandomAccessIterator<A> for Take<T> {\n     }\n \n     #[inline]\n-    fn idx(&self, index: uint) -> Option<A> {\n+    fn idx(&mut self, index: uint) -> Option<A> {\n         if index >= self.n {\n             None\n         } else {\n@@ -1799,7 +1801,7 @@ impl<A, T: RandomAccessIterator<A>> RandomAccessIterator<A> for Fuse<T> {\n     }\n \n     #[inline]\n-    fn idx(&self, index: uint) -> Option<A> {\n+    fn idx(&mut self, index: uint) -> Option<A> {\n         self.iter.idx(index)\n     }\n }\n@@ -1822,7 +1824,7 @@ pub struct Inspect<'a, A, T> {\n \n impl<'a, A, T> Inspect<'a, A, T> {\n     #[inline]\n-    fn do_inspect(&self, elt: Option<A>) -> Option<A> {\n+    fn do_inspect(&mut self, elt: Option<A>) -> Option<A> {\n         match elt {\n             Some(ref a) => (self.f)(a),\n             None => ()\n@@ -1862,8 +1864,9 @@ for Inspect<'a, A, T> {\n     }\n \n     #[inline]\n-    fn idx(&self, index: uint) -> Option<A> {\n-        self.do_inspect(self.iter.idx(index))\n+    fn idx(&mut self, index: uint) -> Option<A> {\n+        let element = self.iter.idx(index);\n+        self.do_inspect(element)\n     }\n }\n \n@@ -2164,7 +2167,7 @@ impl<A: Clone> RandomAccessIterator<A> for Repeat<A> {\n     #[inline]\n     fn indexable(&self) -> uint { uint::MAX }\n     #[inline]\n-    fn idx(&self, _: uint) -> Option<A> { Some(self.element.clone()) }\n+    fn idx(&mut self, _: uint) -> Option<A> { Some(self.element.clone()) }\n }\n \n /// Functions for lexicographical ordering of sequences.\n@@ -2907,7 +2910,7 @@ mod tests {\n         let xs = [1, 2, 3, 4, 5];\n \n         // test .map and .inspect that don't implement Clone\n-        let it = xs.iter().inspect(|_| {});\n+        let mut it = xs.iter().inspect(|_| {});\n         assert_eq!(xs.len(), it.indexable());\n         for (i, elt) in xs.iter().enumerate() {\n             assert_eq!(Some(elt), it.idx(i));\n@@ -2919,7 +2922,7 @@ mod tests {\n     fn test_random_access_map() {\n         let xs = [1, 2, 3, 4, 5];\n \n-        let it = xs.iter().map(|x| *x);\n+        let mut it = xs.iter().map(|x| *x);\n         assert_eq!(xs.len(), it.indexable());\n         for (i, elt) in xs.iter().enumerate() {\n             assert_eq!(Some(*elt), it.idx(i));"}, {"sha": "efbb1abacfaa9d8e60dde7b32689816a3620d56a", "filename": "src/libstd/option.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6beb376b5c27c6b028092f227f865ba564fea17b/src%2Flibstd%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6beb376b5c27c6b028092f227f865ba564fea17b/src%2Flibstd%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Foption.rs?ref=6beb376b5c27c6b028092f227f865ba564fea17b", "patch": "@@ -873,9 +873,9 @@ mod tests {\n         assert_eq!(v, None);\n \n         // test that it does not take more elements than it needs\n-        let functions = [|| Some(()), || None, || fail!()];\n+        let mut functions = [|| Some(()), || None, || fail!()];\n \n-        let v: Option<~[()]> = collect(functions.iter().map(|f| (*f)()));\n+        let v: Option<~[()]> = collect(functions.mut_iter().map(|f| (*f)()));\n \n         assert_eq!(v, None);\n     }"}, {"sha": "058548eb151a26a83093cce67f87ec28983d00e2", "filename": "src/libstd/result.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6beb376b5c27c6b028092f227f865ba564fea17b/src%2Flibstd%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6beb376b5c27c6b028092f227f865ba564fea17b/src%2Flibstd%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fresult.rs?ref=6beb376b5c27c6b028092f227f865ba564fea17b", "patch": "@@ -695,9 +695,9 @@ mod tests {\n         assert_eq!(v, Err(2));\n \n         // test that it does not take more elements than it needs\n-        let functions = [|| Ok(()), || Err(1), || fail!()];\n+        let mut functions = [|| Ok(()), || Err(1), || fail!()];\n \n-        let v: Result<~[()], int> = collect(functions.iter().map(|f| (*f)()));\n+        let v: Result<~[()], int> = collect(functions.mut_iter().map(|f| (*f)()));\n         assert_eq!(v, Err(1));\n     }\n \n@@ -715,9 +715,9 @@ mod tests {\n                    Err(2));\n \n         // test that it does not take more elements than it needs\n-        let functions = [|| Ok(()), || Err(1), || fail!()];\n+        let mut functions = [|| Ok(()), || Err(1), || fail!()];\n \n-        assert_eq!(fold_(functions.iter()\n+        assert_eq!(fold_(functions.mut_iter()\n                         .map(|f| (*f)())),\n                    Err(1));\n     }"}, {"sha": "2dab0e975da3c0b4bc8bc3dbcb8ede55d571f112", "filename": "src/libstd/rt/task.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6beb376b5c27c6b028092f227f865ba564fea17b/src%2Flibstd%2Frt%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6beb376b5c27c6b028092f227f865ba564fea17b/src%2Flibstd%2Frt%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftask.rs?ref=6beb376b5c27c6b028092f227f865ba564fea17b", "patch": "@@ -109,7 +109,7 @@ impl Task {\n     /// This function is *not* meant to be abused as a \"try/catch\" block. This\n     /// is meant to be used at the absolute boundaries of a task's lifetime, and\n     /// only for that purpose.\n-    pub fn run(~self, f: ||) -> ~Task {\n+    pub fn run(~self, mut f: ||) -> ~Task {\n         // Need to put ourselves into TLS, but also need access to the unwinder.\n         // Unsafely get a handle to the task so we can continue to use it after\n         // putting it in tls (so we can invoke the unwinder)."}, {"sha": "929c47b05b923b1b18262f43c49149183b1da434", "filename": "src/libstd/slice.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/6beb376b5c27c6b028092f227f865ba564fea17b/src%2Flibstd%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6beb376b5c27c6b028092f227f865ba564fea17b/src%2Flibstd%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fslice.rs?ref=6beb376b5c27c6b028092f227f865ba564fea17b", "patch": "@@ -212,8 +212,7 @@ impl<'a, T> Iterator<&'a [T]> for RevSplits<'a, T> {\n             return Some(self.v);\n         }\n \n-        let pred = &mut self.pred;\n-        match self.v.iter().rposition(|x| (*pred)(x)) {\n+        match self.v.iter().rposition(|x| (self.pred)(x)) {\n             None => {\n                 self.finished = true;\n                 Some(self.v)\n@@ -489,7 +488,7 @@ impl<'a, T> RandomAccessIterator<&'a [T]> for Chunks<'a, T> {\n     }\n \n     #[inline]\n-    fn idx(&self, index: uint) -> Option<&'a [T]> {\n+    fn idx(&mut self, index: uint) -> Option<&'a [T]> {\n         if index < self.indexable() {\n             let lo = index * self.size;\n             let mut hi = lo + self.size;\n@@ -2101,7 +2100,7 @@ impl<'a, T> RandomAccessIterator<&'a T> for Items<'a, T> {\n     }\n \n     #[inline]\n-    fn idx(&self, index: uint) -> Option<&'a T> {\n+    fn idx(&mut self, index: uint) -> Option<&'a T> {\n         unsafe {\n             if index < self.indexable() {\n                 transmute(self.ptr.offset(index as int))\n@@ -2138,7 +2137,8 @@ impl<'a, T> Iterator<&'a mut [T]> for MutSplits<'a, T> {\n     fn next(&mut self) -> Option<&'a mut [T]> {\n         if self.finished { return None; }\n \n-        match self.v.iter().position(|x| (self.pred)(x)) {\n+        let pred = &mut self.pred;\n+        match self.v.iter().position(|x| (*pred)(x)) {\n             None => {\n                 self.finished = true;\n                 let tmp = mem::replace(&mut self.v, &mut []);\n@@ -2173,7 +2173,8 @@ impl<'a, T> DoubleEndedIterator<&'a mut [T]> for MutSplits<'a, T> {\n     fn next_back(&mut self) -> Option<&'a mut [T]> {\n         if self.finished { return None; }\n \n-        match self.v.iter().rposition(|x| (self.pred)(x)) {\n+        let pred = &mut self.pred;\n+        match self.v.iter().rposition(|x| (*pred)(x)) {\n             None => {\n                 self.finished = true;\n                 let tmp = mem::replace(&mut self.v, &mut []);\n@@ -3346,7 +3347,7 @@ mod tests {\n         assert_eq!(v.chunks(6).collect::<~[&[int]]>(), ~[&[1i,2,3,4,5]]);\n \n         assert_eq!(v.chunks(2).rev().collect::<~[&[int]]>(), ~[&[5i], &[3,4], &[1,2]]);\n-        let it = v.chunks(2);\n+        let mut it = v.chunks(2);\n         assert_eq!(it.indexable(), 3);\n         assert_eq!(it.idx(0).unwrap(), &[1,2]);\n         assert_eq!(it.idx(1).unwrap(), &[3,4]);"}, {"sha": "99f1c66e70272970539cbb3df62990817b25b1b8", "filename": "src/libstd/str.rs", "status": "modified", "additions": 60, "deletions": 50, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/6beb376b5c27c6b028092f227f865ba564fea17b/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6beb376b5c27c6b028092f227f865ba564fea17b/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=6beb376b5c27c6b028092f227f865ba564fea17b", "patch": "@@ -217,40 +217,40 @@ impl<'a, S: Str> StrVector for Vec<S> {\n /// Something that can be used to compare against a character\n pub trait CharEq {\n     /// Determine if the splitter should split at the given character\n-    fn matches(&self, char) -> bool;\n+    fn matches(&mut self, char) -> bool;\n     /// Indicate if this is only concerned about ASCII characters,\n     /// which can allow for a faster implementation.\n     fn only_ascii(&self) -> bool;\n }\n \n impl CharEq for char {\n     #[inline]\n-    fn matches(&self, c: char) -> bool { *self == c }\n+    fn matches(&mut self, c: char) -> bool { *self == c }\n \n     #[inline]\n     fn only_ascii(&self) -> bool { (*self as uint) < 128 }\n }\n \n impl<'a> CharEq for |char|: 'a -> bool {\n     #[inline]\n-    fn matches(&self, c: char) -> bool { (*self)(c) }\n+    fn matches(&mut self, c: char) -> bool { (*self)(c) }\n \n     #[inline]\n     fn only_ascii(&self) -> bool { false }\n }\n \n impl CharEq for extern \"Rust\" fn(char) -> bool {\n     #[inline]\n-    fn matches(&self, c: char) -> bool { (*self)(c) }\n+    fn matches(&mut self, c: char) -> bool { (*self)(c) }\n \n     #[inline]\n     fn only_ascii(&self) -> bool { false }\n }\n \n-impl<'a, C: CharEq> CharEq for &'a [C] {\n+impl<'a> CharEq for &'a [char] {\n     #[inline]\n-    fn matches(&self, c: char) -> bool {\n-        self.iter().any(|m| m.matches(c))\n+    fn matches(&mut self, c: char) -> bool {\n+        self.iter().any(|&mut m| m.matches(c))\n     }\n \n     #[inline]\n@@ -1981,11 +1981,11 @@ pub trait StrSlice<'a> {\n     /// # Example\n     ///\n     /// ```rust\n-    /// assert_eq!(\"11foo1bar11\".trim_chars(&'1'), \"foo1bar\")\n-    /// assert_eq!(\"12foo1bar12\".trim_chars(& &['1', '2']), \"foo1bar\")\n-    /// assert_eq!(\"123foo1bar123\".trim_chars(&|c: char| c.is_digit()), \"foo1bar\")\n+    /// assert_eq!(\"11foo1bar11\".trim_chars('1'), \"foo1bar\")\n+    /// assert_eq!(\"12foo1bar12\".trim_chars(&['1', '2']), \"foo1bar\")\n+    /// assert_eq!(\"123foo1bar123\".trim_chars(|c: char| c.is_digit()), \"foo1bar\")\n     /// ```\n-    fn trim_chars<C: CharEq>(&self, to_trim: &C) -> &'a str;\n+    fn trim_chars<C: CharEq>(&self, to_trim: C) -> &'a str;\n \n     /// Returns a string with leading `chars_to_trim` removed.\n     ///\n@@ -1996,11 +1996,11 @@ pub trait StrSlice<'a> {\n     /// # Example\n     ///\n     /// ```rust\n-    /// assert_eq!(\"11foo1bar11\".trim_left_chars(&'1'), \"foo1bar11\")\n-    /// assert_eq!(\"12foo1bar12\".trim_left_chars(& &['1', '2']), \"foo1bar12\")\n-    /// assert_eq!(\"123foo1bar123\".trim_left_chars(&|c: char| c.is_digit()), \"foo1bar123\")\n+    /// assert_eq!(\"11foo1bar11\".trim_left_chars('1'), \"foo1bar11\")\n+    /// assert_eq!(\"12foo1bar12\".trim_left_chars(&['1', '2']), \"foo1bar12\")\n+    /// assert_eq!(\"123foo1bar123\".trim_left_chars(|c: char| c.is_digit()), \"foo1bar123\")\n     /// ```\n-    fn trim_left_chars<C: CharEq>(&self, to_trim: &C) -> &'a str;\n+    fn trim_left_chars<C: CharEq>(&self, to_trim: C) -> &'a str;\n \n     /// Returns a string with trailing `chars_to_trim` removed.\n     ///\n@@ -2011,11 +2011,11 @@ pub trait StrSlice<'a> {\n     /// # Example\n     ///\n     /// ```rust\n-    /// assert_eq!(\"11foo1bar11\".trim_right_chars(&'1'), \"11foo1bar\")\n-    /// assert_eq!(\"12foo1bar12\".trim_right_chars(& &['1', '2']), \"12foo1bar\")\n-    /// assert_eq!(\"123foo1bar123\".trim_right_chars(&|c: char| c.is_digit()), \"123foo1bar\")\n+    /// assert_eq!(\"11foo1bar11\".trim_right_chars('1'), \"11foo1bar\")\n+    /// assert_eq!(\"12foo1bar12\".trim_right_chars(&['1', '2']), \"12foo1bar\")\n+    /// assert_eq!(\"123foo1bar123\".trim_right_chars(|c: char| c.is_digit()), \"123foo1bar\")\n     /// ```\n-    fn trim_right_chars<C: CharEq>(&self, to_trim: &C) -> &'a str;\n+    fn trim_right_chars<C: CharEq>(&self, to_trim: C) -> &'a str;\n \n     /// Replace all occurrences of one string with another.\n     ///\n@@ -2491,29 +2491,39 @@ impl<'a> StrSlice<'a> for &'a str {\n \n     #[inline]\n     fn trim_left(&self) -> &'a str {\n-        self.trim_left_chars(&char::is_whitespace)\n+        self.trim_left_chars(char::is_whitespace)\n     }\n \n     #[inline]\n     fn trim_right(&self) -> &'a str {\n-        self.trim_right_chars(&char::is_whitespace)\n+        self.trim_right_chars(char::is_whitespace)\n     }\n \n     #[inline]\n-    fn trim_chars<C: CharEq>(&self, to_trim: &C) -> &'a str {\n-        self.trim_left_chars(to_trim).trim_right_chars(to_trim)\n+    fn trim_chars<C: CharEq>(&self, mut to_trim: C) -> &'a str {\n+        let cur = match self.find(|c: char| !to_trim.matches(c)) {\n+            None => \"\",\n+            Some(i) => unsafe { raw::slice_bytes(*self, i, self.len()) }\n+        };\n+        match cur.rfind(|c: char| !to_trim.matches(c)) {\n+            None => \"\",\n+            Some(i) => {\n+                let right = cur.char_range_at(i).next;\n+                unsafe { raw::slice_bytes(cur, 0, right) }\n+            }\n+        }\n     }\n \n     #[inline]\n-    fn trim_left_chars<C: CharEq>(&self, to_trim: &C) -> &'a str {\n+    fn trim_left_chars<C: CharEq>(&self, mut to_trim: C) -> &'a str {\n         match self.find(|c: char| !to_trim.matches(c)) {\n             None => \"\",\n             Some(first) => unsafe { raw::slice_bytes(*self, first, self.len()) }\n         }\n     }\n \n     #[inline]\n-    fn trim_right_chars<C: CharEq>(&self, to_trim: &C) -> &'a str {\n+    fn trim_right_chars<C: CharEq>(&self, mut to_trim: C) -> &'a str {\n         match self.rfind(|c: char| !to_trim.matches(c)) {\n             None => \"\",\n             Some(last) => {\n@@ -2631,7 +2641,7 @@ impl<'a> StrSlice<'a> for &'a str {\n         unsafe { cast::transmute(*self) }\n     }\n \n-    fn find<C: CharEq>(&self, search: C) -> Option<uint> {\n+    fn find<C: CharEq>(&self, mut search: C) -> Option<uint> {\n         if search.only_ascii() {\n             self.bytes().position(|b| search.matches(b as char))\n         } else {\n@@ -2642,7 +2652,7 @@ impl<'a> StrSlice<'a> for &'a str {\n         }\n     }\n \n-    fn rfind<C: CharEq>(&self, search: C) -> Option<uint> {\n+    fn rfind<C: CharEq>(&self, mut search: C) -> Option<uint> {\n         if search.only_ascii() {\n             self.bytes().rposition(|b| search.matches(b as char))\n         } else {\n@@ -3160,40 +3170,40 @@ mod tests {\n     #[test]\n     fn test_trim_left_chars() {\n         let v: &[char] = &[];\n-        assert_eq!(\" *** foo *** \".trim_left_chars(&v), \" *** foo *** \");\n-        assert_eq!(\" *** foo *** \".trim_left_chars(& &['*', ' ']), \"foo *** \");\n-        assert_eq!(\" ***  *** \".trim_left_chars(& &['*', ' ']), \"\");\n-        assert_eq!(\"foo *** \".trim_left_chars(& &['*', ' ']), \"foo *** \");\n+        assert_eq!(\" *** foo *** \".trim_left_chars(v), \" *** foo *** \");\n+        assert_eq!(\" *** foo *** \".trim_left_chars(&['*', ' ']), \"foo *** \");\n+        assert_eq!(\" ***  *** \".trim_left_chars(&['*', ' ']), \"\");\n+        assert_eq!(\"foo *** \".trim_left_chars(&['*', ' ']), \"foo *** \");\n \n-        assert_eq!(\"11foo1bar11\".trim_left_chars(&'1'), \"foo1bar11\");\n-        assert_eq!(\"12foo1bar12\".trim_left_chars(& &['1', '2']), \"foo1bar12\");\n-        assert_eq!(\"123foo1bar123\".trim_left_chars(&|c: char| c.is_digit()), \"foo1bar123\");\n+        assert_eq!(\"11foo1bar11\".trim_left_chars('1'), \"foo1bar11\");\n+        assert_eq!(\"12foo1bar12\".trim_left_chars(&['1', '2']), \"foo1bar12\");\n+        assert_eq!(\"123foo1bar123\".trim_left_chars(|c: char| c.is_digit()), \"foo1bar123\");\n     }\n \n     #[test]\n     fn test_trim_right_chars() {\n         let v: &[char] = &[];\n-        assert_eq!(\" *** foo *** \".trim_right_chars(&v), \" *** foo *** \");\n-        assert_eq!(\" *** foo *** \".trim_right_chars(& &['*', ' ']), \" *** foo\");\n-        assert_eq!(\" ***  *** \".trim_right_chars(& &['*', ' ']), \"\");\n-        assert_eq!(\" *** foo\".trim_right_chars(& &['*', ' ']), \" *** foo\");\n+        assert_eq!(\" *** foo *** \".trim_right_chars(v), \" *** foo *** \");\n+        assert_eq!(\" *** foo *** \".trim_right_chars(&['*', ' ']), \" *** foo\");\n+        assert_eq!(\" ***  *** \".trim_right_chars(&['*', ' ']), \"\");\n+        assert_eq!(\" *** foo\".trim_right_chars(&['*', ' ']), \" *** foo\");\n \n-        assert_eq!(\"11foo1bar11\".trim_right_chars(&'1'), \"11foo1bar\");\n-        assert_eq!(\"12foo1bar12\".trim_right_chars(& &['1', '2']), \"12foo1bar\");\n-        assert_eq!(\"123foo1bar123\".trim_right_chars(&|c: char| c.is_digit()), \"123foo1bar\");\n+        assert_eq!(\"11foo1bar11\".trim_right_chars('1'), \"11foo1bar\");\n+        assert_eq!(\"12foo1bar12\".trim_right_chars(&['1', '2']), \"12foo1bar\");\n+        assert_eq!(\"123foo1bar123\".trim_right_chars(|c: char| c.is_digit()), \"123foo1bar\");\n     }\n \n     #[test]\n     fn test_trim_chars() {\n         let v: &[char] = &[];\n-        assert_eq!(\" *** foo *** \".trim_chars(&v), \" *** foo *** \");\n-        assert_eq!(\" *** foo *** \".trim_chars(& &['*', ' ']), \"foo\");\n-        assert_eq!(\" ***  *** \".trim_chars(& &['*', ' ']), \"\");\n-        assert_eq!(\"foo\".trim_chars(& &['*', ' ']), \"foo\");\n+        assert_eq!(\" *** foo *** \".trim_chars(v), \" *** foo *** \");\n+        assert_eq!(\" *** foo *** \".trim_chars(&['*', ' ']), \"foo\");\n+        assert_eq!(\" ***  *** \".trim_chars(&['*', ' ']), \"\");\n+        assert_eq!(\"foo\".trim_chars(&['*', ' ']), \"foo\");\n \n-        assert_eq!(\"11foo1bar11\".trim_chars(&'1'), \"foo1bar\");\n-        assert_eq!(\"12foo1bar12\".trim_chars(& &['1', '2']), \"foo1bar\");\n-        assert_eq!(\"123foo1bar123\".trim_chars(&|c: char| c.is_digit()), \"foo1bar\");\n+        assert_eq!(\"11foo1bar11\".trim_chars('1'), \"foo1bar\");\n+        assert_eq!(\"12foo1bar12\".trim_chars(&['1', '2']), \"foo1bar\");\n+        assert_eq!(\"123foo1bar123\".trim_chars(|c: char| c.is_digit()), \"foo1bar\");\n     }\n \n     #[test]\n@@ -4123,7 +4133,7 @@ mod bench {\n     fn split_unicode_not_ascii(b: &mut Bencher) {\n         struct NotAscii(char);\n         impl CharEq for NotAscii {\n-            fn matches(&self, c: char) -> bool {\n+            fn matches(&mut self, c: char) -> bool {\n                 let NotAscii(cc) = *self;\n                 cc == c\n             }\n@@ -4148,7 +4158,7 @@ mod bench {\n         struct NotAscii(char);\n         impl CharEq for NotAscii {\n             #[inline]\n-            fn matches(&self, c: char) -> bool {\n+            fn matches(&mut self, c: char) -> bool {\n                 let NotAscii(cc) = *self;\n                 cc == c\n             }"}, {"sha": "3d00c0ac74a6cabf340499cd2daf9440505573e2", "filename": "src/libstd/unstable/finally.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6beb376b5c27c6b028092f227f865ba564fea17b/src%2Flibstd%2Funstable%2Ffinally.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6beb376b5c27c6b028092f227f865ba564fea17b/src%2Flibstd%2Funstable%2Ffinally.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Ffinally.rs?ref=6beb376b5c27c6b028092f227f865ba564fea17b", "patch": "@@ -35,19 +35,19 @@ use ops::Drop;\n #[cfg(test)] use task::failing;\n \n pub trait Finally<T> {\n-    fn finally(&self, dtor: ||) -> T;\n+    fn finally(&mut self, dtor: ||) -> T;\n }\n \n impl<'a,T> Finally<T> for ||: 'a -> T {\n-    fn finally(&self, dtor: ||) -> T {\n-        try_finally(&mut (), (),\n-                    |_, _| (*self)(),\n+    fn finally(&mut self, dtor: ||) -> T {\n+        try_finally(&mut (), self,\n+                    |_, f| (*f)(),\n                     |_| dtor())\n     }\n }\n \n impl<T> Finally<T> for fn() -> T {\n-    fn finally(&self, dtor: ||) -> T {\n+    fn finally(&mut self, dtor: ||) -> T {\n         try_finally(&mut (), (),\n                     |_, _| (*self)(),\n                     |_| dtor())\n@@ -145,7 +145,7 @@ fn test_fail() {\n \n #[test]\n fn test_retval() {\n-    let closure: || -> int = || 10;\n+    let mut closure: || -> int = || 10;\n     let i = closure.finally(|| { });\n     assert_eq!(i, 10);\n }\n@@ -154,6 +154,6 @@ fn test_retval() {\n fn test_compact() {\n     fn do_some_fallible_work() {}\n     fn but_always_run_this_function() { }\n-    do_some_fallible_work.finally(\n-        but_always_run_this_function);\n+    let mut f = do_some_fallible_work;\n+    f.finally(but_always_run_this_function);\n }"}, {"sha": "e0b493cd8d9c0d4371e84dd50cca9223dfcb8258", "filename": "src/libsyntax/ext/deriving/clone.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6beb376b5c27c6b028092f227f865ba564fea17b/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6beb376b5c27c6b028092f227f865ba564fea17b/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs?ref=6beb376b5c27c6b028092f227f865ba564fea17b", "patch": "@@ -34,7 +34,9 @@ pub fn expand_deriving_clone(cx: &mut ExtCtxt,\n                 ret_ty: Self,\n                 inline: true,\n                 const_nonmatching: false,\n-                combine_substructure: |c, s, sub| cs_clone(\"Clone\", c, s, sub)\n+                combine_substructure: combine_substructure(|c, s, sub| {\n+                    cs_clone(\"Clone\", c, s, sub)\n+                }),\n             }\n         )\n     };"}, {"sha": "35b7e7c1a666e772cb9f249b107579a8911eabca", "filename": "src/libsyntax/ext/deriving/cmp/eq.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6beb376b5c27c6b028092f227f865ba564fea17b/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Feq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6beb376b5c27c6b028092f227f865ba564fea17b/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Feq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Feq.rs?ref=6beb376b5c27c6b028092f227f865ba564fea17b", "patch": "@@ -40,7 +40,9 @@ pub fn expand_deriving_eq(cx: &mut ExtCtxt,\n                 ret_ty: Literal(Path::new(vec!(\"bool\"))),\n                 inline: true,\n                 const_nonmatching: true,\n-                combine_substructure: $f\n+                combine_substructure: combine_substructure(|a, b, c| {\n+                    $f(a, b, c)\n+                })\n             }\n         }\n     );"}, {"sha": "afe2d3dae6a71e63a0b4c3cee718e2bec920dea9", "filename": "src/libsyntax/ext/deriving/cmp/ord.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6beb376b5c27c6b028092f227f865ba564fea17b/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6beb376b5c27c6b028092f227f865ba564fea17b/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs?ref=6beb376b5c27c6b028092f227f865ba564fea17b", "patch": "@@ -30,7 +30,9 @@ pub fn expand_deriving_ord(cx: &mut ExtCtxt,\n                 ret_ty: Literal(Path::new(vec!(\"bool\"))),\n                 inline: true,\n                 const_nonmatching: false,\n-                combine_substructure: |cx, span, substr| cs_op($op, $equal, cx, span, substr)\n+                combine_substructure: combine_substructure(|cx, span, substr| {\n+                    cs_op($op, $equal, cx, span, substr)\n+                })\n             }\n         }\n     );"}, {"sha": "d161f9668505fcccd0d0df6563d91492f06492fa", "filename": "src/libsyntax/ext/deriving/cmp/totaleq.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6beb376b5c27c6b028092f227f865ba564fea17b/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotaleq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6beb376b5c27c6b028092f227f865ba564fea17b/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotaleq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotaleq.rs?ref=6beb376b5c27c6b028092f227f865ba564fea17b", "patch": "@@ -48,7 +48,9 @@ pub fn expand_deriving_totaleq(cx: &mut ExtCtxt,\n                 ret_ty: nil_ty(),\n                 inline: true,\n                 const_nonmatching: true,\n-                combine_substructure: cs_total_eq_assert\n+                combine_substructure: combine_substructure(|a, b, c| {\n+                    cs_total_eq_assert(a, b, c)\n+                })\n             }\n         )\n     };"}, {"sha": "69c413890e902fa3cf449ab3132d7d6d024fffeb", "filename": "src/libsyntax/ext/deriving/cmp/totalord.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6beb376b5c27c6b028092f227f865ba564fea17b/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotalord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6beb376b5c27c6b028092f227f865ba564fea17b/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotalord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotalord.rs?ref=6beb376b5c27c6b028092f227f865ba564fea17b", "patch": "@@ -37,7 +37,9 @@ pub fn expand_deriving_totalord(cx: &mut ExtCtxt,\n                 ret_ty: Literal(Path::new(vec!(\"std\", \"cmp\", \"Ordering\"))),\n                 inline: true,\n                 const_nonmatching: false,\n-                combine_substructure: cs_cmp\n+                combine_substructure: combine_substructure(|a, b, c| {\n+                    cs_cmp(a, b, c)\n+                }),\n             }\n         )\n     };"}, {"sha": "6d6cdc55d4028825eeff1d001cacb9fb65290576", "filename": "src/libsyntax/ext/deriving/decodable.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6beb376b5c27c6b028092f227f865ba564fea17b/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6beb376b5c27c6b028092f227f865ba564fea17b/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs?ref=6beb376b5c27c6b028092f227f865ba564fea17b", "patch": "@@ -52,7 +52,9 @@ pub fn expand_deriving_decodable(cx: &mut ExtCtxt,\n                                           vec!(~Self, ~Literal(Path::new_local(\"__E\"))), true)),\n                 inline: false,\n                 const_nonmatching: true,\n-                combine_substructure: decodable_substructure,\n+                combine_substructure: combine_substructure(|a, b, c| {\n+                    decodable_substructure(a, b, c)\n+                }),\n             })\n     };\n "}, {"sha": "633674eff5c18438e010c723dca5d10803a1c83a", "filename": "src/libsyntax/ext/deriving/default.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6beb376b5c27c6b028092f227f865ba564fea17b/src%2Flibsyntax%2Fext%2Fderiving%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6beb376b5c27c6b028092f227f865ba564fea17b/src%2Flibsyntax%2Fext%2Fderiving%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fdefault.rs?ref=6beb376b5c27c6b028092f227f865ba564fea17b", "patch": "@@ -34,7 +34,9 @@ pub fn expand_deriving_default(cx: &mut ExtCtxt,\n                 ret_ty: Self,\n                 inline: true,\n                 const_nonmatching: false,\n-                combine_substructure: default_substructure\n+                combine_substructure: combine_substructure(|a, b, c| {\n+                    default_substructure(a, b, c)\n+                })\n             })\n     };\n     trait_def.expand(cx, mitem, item, push)"}, {"sha": "acdef8c864509e47851416f1b5a648fb8703edeb", "filename": "src/libsyntax/ext/deriving/encodable.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6beb376b5c27c6b028092f227f865ba564fea17b/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6beb376b5c27c6b028092f227f865ba564fea17b/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs?ref=6beb376b5c27c6b028092f227f865ba564fea17b", "patch": "@@ -123,7 +123,9 @@ pub fn expand_deriving_encodable(cx: &mut ExtCtxt,\n                                            true)),\n                 inline: false,\n                 const_nonmatching: true,\n-                combine_substructure: encodable_substructure,\n+                combine_substructure: combine_substructure(|a, b, c| {\n+                    encodable_substructure(a, b, c)\n+                }),\n             })\n     };\n "}, {"sha": "673745b41e865ec36219401b9dbbff193a12c572", "filename": "src/libsyntax/ext/deriving/generic.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6beb376b5c27c6b028092f227f865ba564fea17b/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6beb376b5c27c6b028092f227f865ba564fea17b/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs?ref=6beb376b5c27c6b028092f227f865ba564fea17b", "patch": "@@ -177,6 +177,8 @@ StaticEnum(<ast::EnumDef of C>, ~[(<ident of C0>, <span of C0>, Unnamed(~[<span\n \n */\n \n+use std::cell::RefCell;\n+\n use ast;\n use ast::{P, EnumDef, Expr, Ident, Generics, StructDef};\n use ast_util;\n@@ -234,7 +236,7 @@ pub struct MethodDef<'a> {\n     /// actual enum variants, i.e. can use _ => .. match.\n     pub const_nonmatching: bool,\n \n-    pub combine_substructure: CombineSubstructureFunc<'a>,\n+    pub combine_substructure: RefCell<CombineSubstructureFunc<'a>>,\n }\n \n /// All the data about the data structure/method being derived upon.\n@@ -317,6 +319,11 @@ pub type EnumNonMatchFunc<'a> =\n            &[@Expr]|: 'a\n            -> @Expr;\n \n+pub fn combine_substructure<'a>(f: CombineSubstructureFunc<'a>)\n+    -> RefCell<CombineSubstructureFunc<'a>> {\n+    RefCell::new(f)\n+}\n+\n \n impl<'a> TraitDef<'a> {\n     pub fn expand(&self,\n@@ -509,8 +516,9 @@ impl<'a> MethodDef<'a> {\n             nonself_args: nonself_args,\n             fields: fields\n         };\n-        (self.combine_substructure)(cx, trait_.span,\n-                                    &substructure)\n+        let mut f = self.combine_substructure.borrow_mut();\n+        let f: &mut CombineSubstructureFunc = &mut *f;\n+        (*f)(cx, trait_.span, &substructure)\n     }\n \n     fn get_ret_ty(&self,"}, {"sha": "9e160b0e35dfc8e292558032a8fc8fe436ff9936", "filename": "src/libsyntax/ext/deriving/hash.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6beb376b5c27c6b028092f227f865ba564fea17b/src%2Flibsyntax%2Fext%2Fderiving%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6beb376b5c27c6b028092f227f865ba564fea17b/src%2Flibsyntax%2Fext%2Fderiving%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fhash.rs?ref=6beb376b5c27c6b028092f227f865ba564fea17b", "patch": "@@ -49,7 +49,9 @@ pub fn expand_deriving_hash(cx: &mut ExtCtxt,\n                 ret_ty: nil_ty(),\n                 inline: true,\n                 const_nonmatching: false,\n-                combine_substructure: hash_substructure\n+                combine_substructure: combine_substructure(|a, b, c| {\n+                    hash_substructure(a, b, c)\n+                })\n             }\n         )\n     };"}, {"sha": "e42a3c67e34ea7201dd86aa0dd917acf80ab49b1", "filename": "src/libsyntax/ext/deriving/primitive.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6beb376b5c27c6b028092f227f865ba564fea17b/src%2Flibsyntax%2Fext%2Fderiving%2Fprimitive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6beb376b5c27c6b028092f227f865ba564fea17b/src%2Flibsyntax%2Fext%2Fderiving%2Fprimitive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fprimitive.rs?ref=6beb376b5c27c6b028092f227f865ba564fea17b", "patch": "@@ -41,7 +41,9 @@ pub fn expand_deriving_from_primitive(cx: &mut ExtCtxt,\n                 // liable to cause code-bloat\n                 inline: true,\n                 const_nonmatching: false,\n-                combine_substructure: |c, s, sub| cs_from(\"i64\", c, s, sub),\n+                combine_substructure: combine_substructure(|c, s, sub| {\n+                    cs_from(\"i64\", c, s, sub)\n+                }),\n             },\n             MethodDef {\n                 name: \"from_u64\",\n@@ -56,7 +58,9 @@ pub fn expand_deriving_from_primitive(cx: &mut ExtCtxt,\n                 // liable to cause code-bloat\n                 inline: true,\n                 const_nonmatching: false,\n-                combine_substructure: |c, s, sub| cs_from(\"u64\", c, s, sub),\n+                combine_substructure: combine_substructure(|c, s, sub| {\n+                    cs_from(\"u64\", c, s, sub)\n+                }),\n             })\n     };\n "}, {"sha": "09c3abf42b8cd9920ff54a96f64a5a94e00dd7ca", "filename": "src/libsyntax/ext/deriving/rand.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6beb376b5c27c6b028092f227f865ba564fea17b/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6beb376b5c27c6b028092f227f865ba564fea17b/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs?ref=6beb376b5c27c6b028092f227f865ba564fea17b", "patch": "@@ -43,7 +43,9 @@ pub fn expand_deriving_rand(cx: &mut ExtCtxt,\n                 ret_ty: Self,\n                 inline: false,\n                 const_nonmatching: false,\n-                combine_substructure: rand_substructure\n+                combine_substructure: combine_substructure(|a, b, c| {\n+                    rand_substructure(a, b, c)\n+                })\n             }\n         )\n     };"}, {"sha": "7098d0dd6efea4218051b6f8e678d938288eb3d9", "filename": "src/libsyntax/ext/deriving/show.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6beb376b5c27c6b028092f227f865ba564fea17b/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6beb376b5c27c6b028092f227f865ba564fea17b/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs?ref=6beb376b5c27c6b028092f227f865ba564fea17b", "patch": "@@ -44,7 +44,9 @@ pub fn expand_deriving_show(cx: &mut ExtCtxt,\n                 ret_ty: Literal(Path::new(vec!(\"std\", \"fmt\", \"Result\"))),\n                 inline: false,\n                 const_nonmatching: false,\n-                combine_substructure: show_substructure\n+                combine_substructure: combine_substructure(|a, b, c| {\n+                    show_substructure(a, b, c)\n+                })\n             }\n         )\n     };"}, {"sha": "0aeeabcaeabb0d25a96dd49ecfe2cdd559b0a3b8", "filename": "src/libsyntax/ext/deriving/zero.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6beb376b5c27c6b028092f227f865ba564fea17b/src%2Flibsyntax%2Fext%2Fderiving%2Fzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6beb376b5c27c6b028092f227f865ba564fea17b/src%2Flibsyntax%2Fext%2Fderiving%2Fzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fzero.rs?ref=6beb376b5c27c6b028092f227f865ba564fea17b", "patch": "@@ -34,7 +34,9 @@ pub fn expand_deriving_zero(cx: &mut ExtCtxt,\n                 ret_ty: Self,\n                 inline: true,\n                 const_nonmatching: false,\n-                combine_substructure: zero_substructure\n+                combine_substructure: combine_substructure(|a, b, c| {\n+                    zero_substructure(a, b, c)\n+                })\n             },\n             MethodDef {\n                 name: \"is_zero\",\n@@ -44,13 +46,13 @@ pub fn expand_deriving_zero(cx: &mut ExtCtxt,\n                 ret_ty: Literal(Path::new(vec!(\"bool\"))),\n                 inline: true,\n                 const_nonmatching: false,\n-                combine_substructure: |cx, span, substr| {\n+                combine_substructure: combine_substructure(|cx, span, substr| {\n                     cs_and(|cx, span, _, _| cx.span_bug(span,\n                                                         \"Non-matching enum \\\n                                                          variant in \\\n                                                          deriving(Zero)\"),\n                            cx, span, substr)\n-                }\n+                })\n             }\n         )\n     };"}, {"sha": "002ae5a7d28b418ab394d40247ff8aa100f4bf42", "filename": "src/test/compile-fail/borrowck-call-is-borrow-issue-12224.rs", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/6beb376b5c27c6b028092f227f865ba564fea17b/src%2Ftest%2Fcompile-fail%2Fborrowck-call-is-borrow-issue-12224.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6beb376b5c27c6b028092f227f865ba564fea17b/src%2Ftest%2Fcompile-fail%2Fborrowck-call-is-borrow-issue-12224.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-call-is-borrow-issue-12224.rs?ref=6beb376b5c27c6b028092f227f865ba564fea17b", "patch": "@@ -0,0 +1,64 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Ensure that invoking a closure counts as a unique immutable borrow\n+\n+\n+type Fn<'a> = ||:'a;\n+\n+struct Test<'a> {\n+    f: ||: 'a\n+}\n+\n+fn call(f: |Fn|) {\n+    f(|| {\n+    //~^ ERROR: closure requires unique access to `f` but it is already borrowed\n+        f(|| {})\n+    });\n+}\n+\n+fn test1() {\n+    call(|a| {\n+        a();\n+    });\n+}\n+\n+fn test2(f: &||) {\n+    (*f)(); //~ ERROR: closure invocation in a `&` reference\n+}\n+\n+fn test3(f: &mut ||) {\n+    (*f)();\n+}\n+\n+fn test4(f: &Test) {\n+    (f.f)() //~ ERROR: closure invocation in a `&` reference\n+}\n+\n+fn test5(f: &mut Test) {\n+    (f.f)()\n+}\n+\n+fn test6() {\n+    let f = || {};\n+    (|| {\n+        f();\n+    })();\n+}\n+\n+fn test7() {\n+    fn foo(_: |g: |int|, b: int|) {}\n+    let f = |g: |int|, b: int| {};\n+    f(|a| { //~ ERROR: cannot borrow `f` as immutable because previous closure\n+        foo(f); //~ ERROR: cannot move out of captured outer variable\n+    }, 3);\n+}\n+\n+fn main() {}"}, {"sha": "6556d0a51f84e356f30ad0c5848dcaad72fdd296", "filename": "src/test/compile-fail/moves-based-on-type-no-recursive-stack-closure.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6beb376b5c27c6b028092f227f865ba564fea17b/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-no-recursive-stack-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6beb376b5c27c6b028092f227f865ba564fea17b/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-no-recursive-stack-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-no-recursive-stack-closure.rs?ref=6beb376b5c27c6b028092f227f865ba564fea17b", "patch": "@@ -16,7 +16,7 @@ struct R<'a> {\n     // This struct is needed to create the\n     // otherwise infinite type of a fn that\n     // accepts itself as argument:\n-    c: |&R, bool|: 'a\n+    c: |&mut R, bool|: 'a\n }\n \n fn innocent_looking_victim() {\n@@ -28,6 +28,7 @@ fn innocent_looking_victim() {\n             match x {\n                 Some(ref msg) => {\n                     (f.c)(f, true);\n+                    //~^ ERROR: cannot borrow `*f` as mutable because\n                     println!(\"{:?}\", msg);\n                 },\n                 None => fail!(\"oops\"),\n@@ -36,9 +37,9 @@ fn innocent_looking_victim() {\n     })\n }\n \n-fn conspirator(f: |&R, bool|) {\n-    let r = R {c: f};\n-    f(&r, false) //~ ERROR use of moved value\n+fn conspirator(f: |&mut R, bool|) {\n+    let mut r = R {c: f};\n+    f(&mut r, false) //~ ERROR use of moved value\n }\n \n fn main() { innocent_looking_victim() }"}, {"sha": "202354b1326dd4879983949022a84391496ecefb", "filename": "src/test/run-pass/const-vec-of-fns.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6beb376b5c27c6b028092f227f865ba564fea17b/src%2Ftest%2Frun-pass%2Fconst-vec-of-fns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6beb376b5c27c6b028092f227f865ba564fea17b/src%2Ftest%2Frun-pass%2Fconst-vec-of-fns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-vec-of-fns.rs?ref=6beb376b5c27c6b028092f227f865ba564fea17b", "patch": "@@ -18,13 +18,13 @@\n fn f() { }\n static bare_fns: &'static [fn()] = &[f, f];\n struct S<'a>(||:'a);\n-static mut closures: &'static [S<'static>] = &[S(f), S(f)];\n+static mut closures: &'static mut [S<'static>] = &mut [S(f), S(f)];\n \n pub fn main() {\n     unsafe {\n         for &bare_fn in bare_fns.iter() { bare_fn() }\n-        for closure in closures.iter() {\n-            let S(ref closure) = *closure;\n+        for closure in closures.mut_iter() {\n+            let S(ref mut closure) = *closure;\n             (*closure)()\n         }\n     }"}, {"sha": "4144c8227dcd76aff637c38dbb8facadb9bec559", "filename": "src/test/run-pass/issue-6157.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6beb376b5c27c6b028092f227f865ba564fea17b/src%2Ftest%2Frun-pass%2Fissue-6157.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6beb376b5c27c6b028092f227f865ba564fea17b/src%2Ftest%2Frun-pass%2Fissue-6157.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-6157.rs?ref=6beb376b5c27c6b028092f227f865ba564fea17b", "patch": "@@ -8,23 +8,23 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-pub trait OpInt<'a> { fn call<'a>(&'a self, int, int) -> int; }\n+pub trait OpInt<'a> { fn call<'a>(&'a mut self, int, int) -> int; }\n \n impl<'a> OpInt<'a> for |int, int|: 'a -> int {\n-    fn call(&self, a:int, b:int) -> int {\n+    fn call(&mut self, a:int, b:int) -> int {\n         (*self)(a, b)\n     }\n }\n \n-fn squarei<'a>(x: int, op: &'a OpInt) -> int { op.call(x, x) }\n+fn squarei<'a>(x: int, op: &'a mut OpInt) -> int { op.call(x, x) }\n \n fn muli(x:int, y:int) -> int { x * y }\n \n pub fn main() {\n-    let f = |x,y| muli(x,y);\n+    let mut f = |x,y| muli(x,y);\n     {\n-        let g = &f;\n-        let h = g as &OpInt;\n+        let g = &mut f;\n+        let h = g as &mut OpInt;\n         squarei(3, h);\n     }\n }"}]}