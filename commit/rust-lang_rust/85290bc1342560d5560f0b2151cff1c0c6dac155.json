{"sha": "85290bc1342560d5560f0b2151cff1c0c6dac155", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg1MjkwYmMxMzQyNTYwZDU1NjBmMGIyMTUxY2ZmMWMwYzZkYWMxNTU=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-12-19T09:20:54Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-12-20T09:15:38Z"}, "message": "switch analysis to vfs", "tree": {"sha": "e7817987dc9dba9485659b8c2585e3c6315496c9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e7817987dc9dba9485659b8c2585e3c6315496c9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/85290bc1342560d5560f0b2151cff1c0c6dac155", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/85290bc1342560d5560f0b2151cff1c0c6dac155", "html_url": "https://github.com/rust-lang/rust/commit/85290bc1342560d5560f0b2151cff1c0c6dac155", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/85290bc1342560d5560f0b2151cff1c0c6dac155/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "815a0e577821a3876aa4c79c13200607acadcd2f", "url": "https://api.github.com/repos/rust-lang/rust/commits/815a0e577821a3876aa4c79c13200607acadcd2f", "html_url": "https://github.com/rust-lang/rust/commit/815a0e577821a3876aa4c79c13200607acadcd2f"}], "stats": {"total": 242, "additions": 142, "deletions": 100}, "files": [{"sha": "b79baf0370fd2e9d05adc7a6b392756b162d1319", "filename": "crates/ra_analysis/src/db.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/85290bc1342560d5560f0b2151cff1c0c6dac155/crates%2Fra_analysis%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85290bc1342560d5560f0b2151cff1c0c6dac155/crates%2Fra_analysis%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fdb.rs?ref=85290bc1342560d5560f0b2151cff1c0c6dac155", "patch": "@@ -63,8 +63,6 @@ salsa::database_storage! {\n             fn file_text() for ra_db::FileTextQuery;\n             fn file_relative_path() for ra_db::FileRelativePathQuery;\n             fn file_source_root() for ra_db::FileSourceRootQuery;\n-            fn source_root_files() for ra_db::SourceRootFilesQuery;\n-            fn source_root_file_by_path() for ra_db::SourceRootFileByPathQuery;\n             fn source_root() for ra_db::SourceRootQuery;\n             fn libraries() for ra_db::LibrariesQuery;\n             fn crate_graph() for ra_db::CrateGraphQuery;"}, {"sha": "51bcd5a73c8af696cf411e751c75899bc959e2cf", "filename": "crates/ra_analysis/src/imp.rs", "status": "modified", "additions": 42, "deletions": 46, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/85290bc1342560d5560f0b2151cff1c0c6dac155/crates%2Fra_analysis%2Fsrc%2Fimp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85290bc1342560d5560f0b2151cff1c0c6dac155/crates%2Fra_analysis%2Fsrc%2Fimp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fimp.rs?ref=85290bc1342560d5560f0b2151cff1c0c6dac155", "patch": "@@ -12,7 +12,6 @@ use ra_syntax::{\n };\n use ra_db::{FilesDatabase, SourceRoot, SourceRootId, WORKSPACE, SyntaxDatabase};\n use rayon::prelude::*;\n-use rustc_hash::FxHashSet;\n use salsa::{Database, ParallelDatabase};\n use hir::{\n     self,\n@@ -25,7 +24,7 @@ use crate::{\n     completion::{completions, CompletionItem},\n     db,\n     symbol_index::{SymbolIndex, SymbolsDatabase},\n-    AnalysisChange, Cancelable, CrateId, Diagnostic, FileId,\n+    AnalysisChange, RootChange, Cancelable, CrateId, Diagnostic, FileId,\n     FileSystemEdit, FilePosition, Query, SourceChange, SourceFileNodeEdit,\n     ReferenceResolution,\n };\n@@ -45,59 +44,22 @@ impl AnalysisHostImpl {\n         log::info!(\"apply_change {:?}\", change);\n         // self.gc_syntax_trees();\n \n+        for (root_id, root_change) in change.roots_changed {\n+            self.apply_root_change(root_id, root_change);\n+        }\n         for (file_id, text) in change.files_changed {\n             self.db\n                 .query_mut(ra_db::FileTextQuery)\n                 .set(file_id, Arc::new(text))\n         }\n-        if !(change.files_added.is_empty() && change.files_removed.is_empty()) {\n-            let mut source_root = SourceRoot::clone(&self.db.source_root(WORKSPACE));\n-            for (file_id, text) in change.files_added {\n-                self.db\n-                    .query_mut(ra_db::FileTextQuery)\n-                    .set(file_id, Arc::new(text));\n-                self.db\n-                    .query_mut(ra_db::FileSourceRootQuery)\n-                    .set(file_id, ra_db::WORKSPACE);\n-                source_root.files.insert(file_id);\n-            }\n-            for file_id in change.files_removed {\n-                self.db\n-                    .query_mut(ra_db::FileTextQuery)\n-                    .set(file_id, Arc::new(String::new()));\n-                source_root.files.remove(&file_id);\n-            }\n-            self.db\n-                .query_mut(ra_db::SourceRootQuery)\n-                .set(WORKSPACE, Arc::new(source_root))\n-        }\n         if !change.libraries_added.is_empty() {\n             let mut libraries = Vec::clone(&self.db.libraries());\n             for library in change.libraries_added {\n-                let source_root_id = SourceRootId(1 + libraries.len() as u32);\n-                libraries.push(source_root_id);\n-                let mut files = FxHashSet::default();\n-                for (file_id, text) in library.files {\n-                    files.insert(file_id);\n-                    log::debug!(\n-                        \"library file: {:?} {:?}\",\n-                        file_id,\n-                        library.file_resolver.debug_path(file_id)\n-                    );\n-                    self.db\n-                        .query_mut(ra_db::FileSourceRootQuery)\n-                        .set_constant(file_id, source_root_id);\n-                    self.db\n-                        .query_mut(ra_db::FileTextQuery)\n-                        .set_constant(file_id, Arc::new(text));\n-                }\n-                let source_root = SourceRoot { files };\n+                libraries.push(library.root_id);\n                 self.db\n                     .query_mut(ra_db::SourceRootQuery)\n-                    .set(source_root_id, Arc::new(source_root));\n-                self.db\n-                    .query_mut(crate::symbol_index::LibrarySymbolsQuery)\n-                    .set(source_root_id, Arc::new(library.symbol_index));\n+                    .set(library.root_id, Default::default());\n+                self.apply_root_change(library.root_id, library.root_change);\n             }\n             self.db\n                 .query_mut(ra_db::LibrariesQuery)\n@@ -110,6 +72,34 @@ impl AnalysisHostImpl {\n         }\n     }\n \n+    fn apply_root_change(&mut self, root_id: SourceRootId, root_change: RootChange) {\n+        let mut source_root = SourceRoot::clone(&self.db.source_root(root_id));\n+        for add_file in root_change.added {\n+            self.db\n+                .query_mut(ra_db::FileTextQuery)\n+                .set(add_file.file_id, add_file.text);\n+            self.db\n+                .query_mut(ra_db::FileRelativePathQuery)\n+                .set(add_file.file_id, add_file.path.clone());\n+            self.db\n+                .query_mut(ra_db::FileSourceRootQuery)\n+                .set(add_file.file_id, root_id);\n+            source_root.files.insert(add_file.path, add_file.file_id);\n+        }\n+        for remove_file in root_change.removed {\n+            self.db\n+                .query_mut(ra_db::FileTextQuery)\n+                .set(remove_file.file_id, Default::default());\n+            self.db\n+                .query_mut(ra_db::FileRelativePathQuery)\n+                .set(remove_file.file_id, Default::default());\n+            source_root.files.remove(&remove_file.path);\n+        }\n+        self.db\n+            .query_mut(ra_db::SourceRootQuery)\n+            .set(root_id, Arc::new(source_root));\n+    }\n+\n     #[allow(unused)]\n     /// Ideally, we should call this function from time to time to collect heavy\n     /// syntax trees. However, if we actually do that, everything is recomputed\n@@ -156,7 +146,13 @@ impl AnalysisImpl {\n                 .map(|&lib_id| self.db.library_symbols(lib_id))\n                 .collect()\n         } else {\n-            let files = &self.db.source_root(WORKSPACE).files;\n+            let files: Vec<FileId> = self\n+                .db\n+                .source_root(WORKSPACE)\n+                .files\n+                .values()\n+                .map(|&it| it)\n+                .collect();\n \n             /// Need to wrap Snapshot to provide `Clone` impl for `map_with`\n             struct Snap(salsa::Snapshot<db::RootDatabase>);"}, {"sha": "bfc4e0f17b2b6f0464c1fb7c15fef26eff1bf910", "filename": "crates/ra_analysis/src/lib.rs", "status": "modified", "additions": 75, "deletions": 21, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/85290bc1342560d5560f0b2151cff1c0c6dac155/crates%2Fra_analysis%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85290bc1342560d5560f0b2151cff1c0c6dac155/crates%2Fra_analysis%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Flib.rs?ref=85290bc1342560d5560f0b2151cff1c0c6dac155", "patch": "@@ -18,9 +18,9 @@ pub mod mock_analysis;\n \n use std::{fmt, sync::Arc};\n \n+use rustc_hash::FxHashMap;\n use ra_syntax::{SourceFileNode, TextRange, TextUnit};\n use ra_text_edit::AtomTextEdit;\n-use ra_db::FileResolverImp;\n use rayon::prelude::*;\n use relative_path::RelativePathBuf;\n \n@@ -39,28 +39,53 @@ pub use hir::FnSignatureInfo;\n \n pub use ra_db::{\n     Canceled, Cancelable, FilePosition,\n-    CrateGraph, CrateId, FileId, FileResolver\n+    CrateGraph, CrateId, SourceRootId, FileId, FileResolver,\n+    WORKSPACE\n };\n \n #[derive(Default)]\n pub struct AnalysisChange {\n-    files_added: Vec<(FileId, String)>,\n+    roots_changed: FxHashMap<SourceRootId, RootChange>,\n     files_changed: Vec<(FileId, String)>,\n-    files_removed: Vec<(FileId)>,\n     libraries_added: Vec<LibraryData>,\n     crate_graph: Option<CrateGraph>,\n-    file_resolver: Option<FileResolverImp>,\n+}\n+\n+#[derive(Default)]\n+struct RootChange {\n+    added: Vec<AddFile>,\n+    removed: Vec<RemoveFile>,\n+}\n+\n+#[derive(Debug)]\n+struct AddFile {\n+    file_id: FileId,\n+    path: RelativePathBuf,\n+    text: Arc<String>,\n+}\n+\n+#[derive(Debug)]\n+struct RemoveFile {\n+    file_id: FileId,\n+    path: RelativePathBuf,\n }\n \n impl fmt::Debug for AnalysisChange {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         fmt.debug_struct(\"AnalysisChange\")\n-            .field(\"files_added\", &self.files_added.len())\n+            .field(\"roots_changed\", &self.roots_changed)\n             .field(\"files_changed\", &self.files_changed.len())\n-            .field(\"files_removed\", &self.files_removed.len())\n             .field(\"libraries_added\", &self.libraries_added.len())\n             .field(\"crate_graph\", &self.crate_graph)\n-            .field(\"file_resolver\", &self.file_resolver)\n+            .finish()\n+    }\n+}\n+\n+impl fmt::Debug for RootChange {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        fmt.debug_struct(\"AnalysisChange\")\n+            .field(\"added\", &self.added.len())\n+            .field(\"removed\", &self.removed.len())\n             .finish()\n     }\n }\n@@ -69,24 +94,41 @@ impl AnalysisChange {\n     pub fn new() -> AnalysisChange {\n         AnalysisChange::default()\n     }\n-    pub fn add_file(&mut self, file_id: FileId, text: String) {\n-        self.files_added.push((file_id, text))\n+    pub fn add_file(\n+        &mut self,\n+        root_id: SourceRootId,\n+        file_id: FileId,\n+        path: RelativePathBuf,\n+        text: Arc<String>,\n+    ) {\n+        let file = AddFile {\n+            file_id,\n+            path,\n+            text,\n+        };\n+        self.roots_changed\n+            .entry(root_id)\n+            .or_default()\n+            .added\n+            .push(file);\n     }\n     pub fn change_file(&mut self, file_id: FileId, new_text: String) {\n         self.files_changed.push((file_id, new_text))\n     }\n-    pub fn remove_file(&mut self, file_id: FileId) {\n-        self.files_removed.push(file_id)\n+    pub fn remove_file(&mut self, root_id: SourceRootId, file_id: FileId, path: RelativePathBuf) {\n+        let file = RemoveFile { file_id, path };\n+        self.roots_changed\n+            .entry(root_id)\n+            .or_default()\n+            .removed\n+            .push(file);\n     }\n     pub fn add_library(&mut self, data: LibraryData) {\n         self.libraries_added.push(data)\n     }\n     pub fn set_crate_graph(&mut self, graph: CrateGraph) {\n         self.crate_graph = Some(graph);\n     }\n-    pub fn set_file_resolver(&mut self, file_resolver: Arc<FileResolver>) {\n-        self.file_resolver = Some(FileResolverImp::new(file_resolver));\n-    }\n }\n \n /// `AnalysisHost` stores the current state of the world.\n@@ -313,20 +355,32 @@ impl Analysis {\n \n #[derive(Debug)]\n pub struct LibraryData {\n-    files: Vec<(FileId, String)>,\n-    file_resolver: FileResolverImp,\n+    root_id: SourceRootId,\n+    root_change: RootChange,\n     symbol_index: SymbolIndex,\n }\n \n impl LibraryData {\n-    pub fn prepare(files: Vec<(FileId, String)>, file_resolver: Arc<FileResolver>) -> LibraryData {\n-        let symbol_index = SymbolIndex::for_files(files.par_iter().map(|(file_id, text)| {\n+    pub fn prepare(\n+        root_id: SourceRootId,\n+        files: Vec<(FileId, RelativePathBuf, Arc<String>)>,\n+    ) -> LibraryData {\n+        let symbol_index = SymbolIndex::for_files(files.par_iter().map(|(file_id, _, text)| {\n             let file = SourceFileNode::parse(text);\n             (*file_id, file)\n         }));\n+        let mut root_change = RootChange::default();\n+        root_change.added = files\n+            .into_iter()\n+            .map(|(file_id, path, text)| AddFile {\n+                file_id,\n+                path,\n+                text,\n+            })\n+            .collect();\n         LibraryData {\n-            files,\n-            file_resolver: FileResolverImp::new(file_resolver),\n+            root_id,\n+            root_change,\n             symbol_index,\n         }\n     }"}, {"sha": "691af4a48c2d135ab1e655d87b98130408b7a442", "filename": "crates/ra_analysis/src/mock_analysis.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/85290bc1342560d5560f0b2151cff1c0c6dac155/crates%2Fra_analysis%2Fsrc%2Fmock_analysis.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85290bc1342560d5560f0b2151cff1c0c6dac155/crates%2Fra_analysis%2Fsrc%2Fmock_analysis.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fmock_analysis.rs?ref=85290bc1342560d5560f0b2151cff1c0c6dac155", "patch": "@@ -4,7 +4,7 @@ use relative_path::{RelativePathBuf};\n use test_utils::{extract_offset, parse_fixture, CURSOR_MARKER};\n use ra_db::mock::FileMap;\n \n-use crate::{Analysis, AnalysisChange, AnalysisHost, FileId, FilePosition};\n+use crate::{Analysis, AnalysisChange, AnalysisHost, FileId, FilePosition, WORKSPACE};\n \n /// Mock analysis is used in test to bootstrap an AnalysisHost/Analysis\n /// from a set of in-memory files.\n@@ -82,10 +82,10 @@ impl MockAnalysis {\n         for (path, contents) in self.files.into_iter() {\n             assert!(path.starts_with('/'));\n             let path = RelativePathBuf::from_path(&path[1..]).unwrap();\n-            let file_id = file_map.add(path);\n-            change.add_file(file_id, contents);\n+            let file_id = file_map.add(path.clone());\n+            change.add_file(WORKSPACE, file_id, path, Arc::new(contents));\n         }\n-        change.set_file_resolver(Arc::new(file_map));\n+        // change.set_file_resolver(Arc::new(file_map));\n         host.apply_change(change);\n         host\n     }"}, {"sha": "51daa8e86006bb31a28cd4515a69c92dc2cf0564", "filename": "crates/ra_db/src/input.rs", "status": "modified", "additions": 7, "deletions": 15, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/85290bc1342560d5560f0b2151cff1c0c6dac155/crates%2Fra_db%2Fsrc%2Finput.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85290bc1342560d5560f0b2151cff1c0c6dac155/crates%2Fra_db%2Fsrc%2Finput.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_db%2Fsrc%2Finput.rs?ref=85290bc1342560d5560f0b2151cff1c0c6dac155", "patch": "@@ -1,10 +1,15 @@\n use std::sync::Arc;\n \n-use rustc_hash::{FxHashSet, FxHashMap};\n+use rustc_hash::{FxHashMap};\n use relative_path::RelativePathBuf;\n use ra_syntax::SmolStr;\n use salsa;\n \n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, PartialOrd, Ord)]\n+pub struct SourceRootId(pub u32);\n+\n+pub const WORKSPACE: SourceRootId = SourceRootId(0);\n+\n #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n pub struct FileId(pub u32);\n \n@@ -93,14 +98,6 @@ salsa::query_group! {\n             type FileSourceRootQuery;\n             storage input;\n         }\n-        fn source_root_files(id: SourceRootId) -> Arc<FxHashSet<FileId>> {\n-            type SourceRootFilesQuery;\n-            storage input;\n-        }\n-        fn source_root_file_by_path(id: SourceRootId, path: RelativePathBuf) -> Option<FileId> {\n-            type SourceRootFileByPathQuery;\n-            storage input;\n-        }\n         fn source_root(id: SourceRootId) -> Arc<SourceRoot> {\n             type SourceRootQuery;\n             storage input;\n@@ -116,12 +113,7 @@ salsa::query_group! {\n     }\n }\n \n-#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, PartialOrd, Ord)]\n-pub struct SourceRootId(pub u32);\n-\n #[derive(Default, Clone, Debug, PartialEq, Eq)]\n pub struct SourceRoot {\n-    pub files: FxHashSet<FileId>,\n+    pub files: FxHashMap<RelativePathBuf, FileId>,\n }\n-\n-pub const WORKSPACE: SourceRootId = SourceRootId(0);"}, {"sha": "d1db281e65e276d089fa438ad66c93aa9b283f55", "filename": "crates/ra_db/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/85290bc1342560d5560f0b2151cff1c0c6dac155/crates%2Fra_db%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85290bc1342560d5560f0b2151cff1c0c6dac155/crates%2Fra_db%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_db%2Fsrc%2Flib.rs?ref=85290bc1342560d5560f0b2151cff1c0c6dac155", "patch": "@@ -28,7 +28,7 @@ pub use crate::{\n     input::{\n         FilesDatabase, FileId, CrateId, SourceRoot, SourceRootId, CrateGraph, WORKSPACE,\n         FileTextQuery, FileSourceRootQuery, SourceRootQuery, LibrariesQuery, CrateGraphQuery,\n-        FileRelativePathQuery, SourceRootFilesQuery, SourceRootFileByPathQuery,\n+        FileRelativePathQuery\n     },\n     loc2id::{LocationIntener, NumericId},\n };"}, {"sha": "efe987bdd2545c49afc9e47a2c0712a619b46cfc", "filename": "crates/ra_db/src/mock.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/85290bc1342560d5560f0b2151cff1c0c6dac155/crates%2Fra_db%2Fsrc%2Fmock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85290bc1342560d5560f0b2151cff1c0c6dac155/crates%2Fra_db%2Fsrc%2Fmock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_db%2Fsrc%2Fmock.rs?ref=85290bc1342560d5560f0b2151cff1c0c6dac155", "patch": "@@ -1,7 +1,7 @@\n use rustc_hash::FxHashSet;\n use relative_path::{RelativePath, RelativePathBuf};\n \n-use crate::{FileId, FileResolver, SourceRoot};\n+use crate::{FileId, FileResolver};\n \n #[derive(Default, Debug, Clone)]\n pub struct FileMap(Vec<(FileId, RelativePathBuf)>);\n@@ -13,11 +13,6 @@ impl FileMap {\n         file_id\n     }\n \n-    pub fn into_source_root(self) -> SourceRoot {\n-        let files = self.files();\n-        SourceRoot { files }\n-    }\n-\n     pub fn files(&self) -> FxHashSet<FileId> {\n         self.iter().map(|(id, _)| id).collect()\n     }"}, {"sha": "f3a346152b9d783b5bd6b3c67a6d3a5aa8971665", "filename": "crates/ra_hir/src/module/imp.rs", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/85290bc1342560d5560f0b2151cff1c0c6dac155/crates%2Fra_hir%2Fsrc%2Fmodule%2Fimp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85290bc1342560d5560f0b2151cff1c0c6dac155/crates%2Fra_hir%2Fsrc%2Fmodule%2Fimp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fmodule%2Fimp.rs?ref=85290bc1342560d5560f0b2151cff1c0c6dac155", "patch": "@@ -4,6 +4,7 @@ use ra_syntax::{\n     ast::{self, NameOwner},\n     SmolStr,\n };\n+use relative_path::{RelativePathBuf, RelativePath};\n use rustc_hash::{FxHashMap, FxHashSet};\n use arrayvec::ArrayVec;\n use ra_db::{SourceRoot, SourceRootId, Cancelable, FileId};\n@@ -65,7 +66,7 @@ fn create_module_tree<'a>(\n     let mut visited = FxHashSet::default();\n \n     let source_root = db.source_root(source_root);\n-    for &file_id in source_root.files.iter() {\n+    for &file_id in source_root.files.values() {\n         let source = ModuleSource::new_file(file_id);\n         if visited.contains(&source) {\n             continue; // TODO: use explicit crate_roots here\n@@ -160,7 +161,8 @@ fn resolve_submodule(\n     let file_id = source.file_id();\n     let source_root_id = db.file_source_root(file_id);\n     let path = db.file_relative_path(file_id);\n-    let dir_path = path.parent().unwrap();\n+    let root = RelativePathBuf::default();\n+    let dir_path = path.parent().unwrap_or(&root);\n     let mod_name = path.file_stem().unwrap_or(\"unknown\");\n     let is_dir_owner = mod_name == \"mod\" || mod_name == \"lib\" || mod_name == \"main\";\n \n@@ -174,14 +176,19 @@ fn resolve_submodule(\n     } else {\n         candidates.push(file_dir_mod.clone());\n     };\n-\n+    let sr = db.source_root(source_root_id);\n     let points_to = candidates\n         .into_iter()\n-        .filter_map(|path| db.source_root_file_by_path(source_root_id, path))\n+        .filter_map(|path| sr.files.get(&path))\n+        .map(|&it| it)\n         .collect::<Vec<_>>();\n     let problem = if points_to.is_empty() {\n         Some(Problem::UnresolvedModule {\n-            candidate: if is_dir_owner { file_mod } else { file_dir_mod },\n+            candidate: RelativePath::new(\"../\").join(&if is_dir_owner {\n+                file_mod\n+            } else {\n+                file_dir_mod\n+            }),\n         })\n     } else {\n         None"}]}