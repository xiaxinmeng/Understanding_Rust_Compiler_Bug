{"sha": "0f507246e732c302fbfde83296c03c69fafdf4ad", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBmNTA3MjQ2ZTczMmMzMDJmYmZkZTgzMjk2YzAzYzY5ZmFmZGY0YWQ=", "commit": {"author": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2019-04-03T18:30:18Z"}, "committer": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2019-05-21T18:37:38Z"}, "message": "Remove MIR borrowck hack for old match scopes", "tree": {"sha": "32ed84eed98356391260dd59117fdfb63423f7c8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/32ed84eed98356391260dd59117fdfb63423f7c8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0f507246e732c302fbfde83296c03c69fafdf4ad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0f507246e732c302fbfde83296c03c69fafdf4ad", "html_url": "https://github.com/rust-lang/rust/commit/0f507246e732c302fbfde83296c03c69fafdf4ad", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0f507246e732c302fbfde83296c03c69fafdf4ad/comments", "author": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f506aea1fac0977c7215b4240f4d99b45bf7ae97", "url": "https://api.github.com/repos/rust-lang/rust/commits/f506aea1fac0977c7215b4240f4d99b45bf7ae97", "html_url": "https://github.com/rust-lang/rust/commit/f506aea1fac0977c7215b4240f4d99b45bf7ae97"}], "stats": {"total": 39, "additions": 8, "deletions": 31}, "files": [{"sha": "03d55b84f32e260f38dce78551558c77388c331f", "filename": "src/librustc_mir/dataflow/impls/mod.rs", "status": "modified", "additions": 8, "deletions": 31, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/0f507246e732c302fbfde83296c03c69fafdf4ad/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f507246e732c302fbfde83296c03c69fafdf4ad/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs?ref=0f507246e732c302fbfde83296c03c69fafdf4ad", "patch": "@@ -11,8 +11,7 @@ use super::MoveDataParamEnv;\n \n use crate::util::elaborate_drops::DropFlagState;\n \n-use super::move_paths::{HasMoveData, MoveData, MovePathIndex, InitIndex};\n-use super::move_paths::{LookupResult, InitKind};\n+use super::move_paths::{HasMoveData, MoveData, MovePathIndex, InitIndex, InitKind};\n use super::{BitDenotation, BlockSets, InitialFlow};\n \n use super::drop_flag_effects_for_function_entry;\n@@ -470,35 +469,13 @@ impl<'a, 'gcx, 'tcx> BitDenotation<'tcx> for EverInitializedPlaces<'a, 'gcx, 'tc\n         sets.gen_all(&init_loc_map[location]);\n \n         match stmt.kind {\n-            mir::StatementKind::StorageDead(local) |\n-            mir::StatementKind::StorageLive(local) => {\n-                // End inits for StorageDead and StorageLive, so that an immutable\n-                // variable can be reinitialized on the next iteration of the loop.\n-                //\n-                // FIXME(#46525): We *need* to do this for StorageLive as well as\n-                // StorageDead, because lifetimes of match bindings with guards are\n-                // weird - i.e., this code\n-                //\n-                // ```\n-                //     fn main() {\n-                //         match 0 {\n-                //             a | a\n-                //             if { println!(\"a={}\", a); false } => {}\n-                //             _ => {}\n-                //         }\n-                //     }\n-                // ```\n-                //\n-                // runs the guard twice, using the same binding for `a`, and only\n-                // storagedeads after everything ends, so if we don't regard the\n-                // storagelive as killing storage, we would have a multiple assignment\n-                // to immutable data error.\n-                if let LookupResult::Exact(mpi) =\n-                    rev_lookup.find(&mir::Place::Base(mir::PlaceBase::Local(local))) {\n-                    debug!(\"stmt {:?} at loc {:?} clears the ever initialized status of {:?}\",\n-                           stmt, location, &init_path_map[mpi]);\n-                    sets.kill_all(&init_path_map[mpi]);\n-                }\n+            mir::StatementKind::StorageDead(local) => {\n+                // End inits for StorageDead, so that an immutable variable can\n+                // be reinitialized on the next iteration of the loop.\n+                let move_path_index = rev_lookup.find_local(local);\n+                debug!(\"stmt {:?} at loc {:?} clears the ever initialized status of {:?}\",\n+                        stmt, location, &init_path_map[move_path_index]);\n+                sets.kill_all(&init_path_map[move_path_index]);\n             }\n             _ => {}\n         }"}]}