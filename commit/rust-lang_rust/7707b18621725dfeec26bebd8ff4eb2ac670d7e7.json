{"sha": "7707b18621725dfeec26bebd8ff4eb2ac670d7e7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc3MDdiMTg2MjE3MjVkZmVlYzI2YmViZDhmZjRlYjJhYzY3MGQ3ZTc=", "commit": {"author": {"name": "kennytm", "email": "kennytm@gmail.com", "date": "2017-11-27T19:16:47Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-11-27T19:16:47Z"}, "message": "Rollup merge of #46262 - udoprog:linked-list-remove-if, r=dtolnay\n\nIntroduce LinkedList::drain_filter\n\nThis introduces `LinkedList::remove_if`.\n\nThis operation embodies one of the use-cases where `LinkedList` would typically be preferred over `Vec`: random removal and retrieval.\n\nThere are a number of considerations with this:\n\nShould there be two `remove_if` methods? One where elements are only removed, one which returns a collection of removed elements.\n\nShould this be implemented using a draining iterator pattern that covers both cases? I suspect that would incur a bit of overhead (moving the element into the iterator, then into a new collection). But I'm not sure. Maybe that's an acceptable compromise to maximize flexibility.\n\nI don't feel I've had enough exposure to unsafe programming in rust to be certain the implementation is correct. This relies quite heavily on moving around copies of Shared pointers to make the code reasonable. Please help me out :).", "tree": {"sha": "b4d860a6932256e73bf6e039f7645598650bff05", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b4d860a6932256e73bf6e039f7645598650bff05"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7707b18621725dfeec26bebd8ff4eb2ac670d7e7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7707b18621725dfeec26bebd8ff4eb2ac670d7e7", "html_url": "https://github.com/rust-lang/rust/commit/7707b18621725dfeec26bebd8ff4eb2ac670d7e7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7707b18621725dfeec26bebd8ff4eb2ac670d7e7/comments", "author": {"login": "kennytm", "id": 103023, "node_id": "MDQ6VXNlcjEwMzAyMw==", "avatar_url": "https://avatars.githubusercontent.com/u/103023?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kennytm", "html_url": "https://github.com/kennytm", "followers_url": "https://api.github.com/users/kennytm/followers", "following_url": "https://api.github.com/users/kennytm/following{/other_user}", "gists_url": "https://api.github.com/users/kennytm/gists{/gist_id}", "starred_url": "https://api.github.com/users/kennytm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kennytm/subscriptions", "organizations_url": "https://api.github.com/users/kennytm/orgs", "repos_url": "https://api.github.com/users/kennytm/repos", "events_url": "https://api.github.com/users/kennytm/events{/privacy}", "received_events_url": "https://api.github.com/users/kennytm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f33edd2ed09cdbf6dff6b8de757ad63535277297", "url": "https://api.github.com/repos/rust-lang/rust/commits/f33edd2ed09cdbf6dff6b8de757ad63535277297", "html_url": "https://github.com/rust-lang/rust/commit/f33edd2ed09cdbf6dff6b8de757ad63535277297"}, {"sha": "60aa8347f51fddaaed61d8304689111f6ac3e0af", "url": "https://api.github.com/repos/rust-lang/rust/commits/60aa8347f51fddaaed61d8304689111f6ac3e0af", "html_url": "https://github.com/rust-lang/rust/commit/60aa8347f51fddaaed61d8304689111f6ac3e0af"}], "stats": {"total": 327, "additions": 327, "deletions": 0}, "files": [{"sha": "0fe3c9724224d5b8df520e47895b677e050a90e3", "filename": "src/liballoc/linked_list.rs", "status": "modified", "additions": 139, "deletions": 0, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/7707b18621725dfeec26bebd8ff4eb2ac670d7e7/src%2Fliballoc%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7707b18621725dfeec26bebd8ff4eb2ac670d7e7/src%2Fliballoc%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flinked_list.rs?ref=7707b18621725dfeec26bebd8ff4eb2ac670d7e7", "patch": "@@ -220,6 +220,28 @@ impl<T> LinkedList<T> {\n             node\n         })\n     }\n+\n+    /// Unlinks the specified node from the current list.\n+    ///\n+    /// Warning: this will not check that the provided node belongs to the current list.\n+    #[inline]\n+    unsafe fn unlink_node(&mut self, mut node: Shared<Node<T>>) {\n+        let node = node.as_mut();\n+\n+        match node.prev {\n+            Some(mut prev) => prev.as_mut().next = node.next.clone(),\n+            // this node is the head node\n+            None => self.head = node.next.clone(),\n+        };\n+\n+        match node.next {\n+            Some(mut next) => next.as_mut().prev = node.prev.clone(),\n+            // this node is the tail node\n+            None => self.tail = node.prev.clone(),\n+        };\n+\n+        self.len -= 1;\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -722,6 +744,49 @@ impl<T> LinkedList<T> {\n         second_part\n     }\n \n+    /// Creates an iterator which uses a closure to determine if an element should be removed.\n+    ///\n+    /// If the closure returns true, then the element is removed and yielded.\n+    /// If the closure returns false, it will try again, and call the closure on the next element,\n+    /// seeing if it passes the test.\n+    ///\n+    /// Note that `drain_filter` lets you mutate every element in the filter closure, regardless of\n+    /// whether you choose to keep or remove it.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Splitting a list into evens and odds, reusing the original list:\n+    ///\n+    /// ```\n+    /// #![feature(drain_filter)]\n+    /// use std::collections::LinkedList;\n+    ///\n+    /// let mut numbers: LinkedList<u32> = LinkedList::new();\n+    /// numbers.extend(&[1, 2, 3, 4, 5, 6, 8, 9, 11, 13, 14, 15]);\n+    ///\n+    /// let evens = numbers.drain_filter(|x| *x % 2 == 0).collect::<LinkedList<_>>();\n+    /// let odds = numbers;\n+    ///\n+    /// assert_eq!(evens.into_iter().collect::<Vec<_>>(), vec![2, 4, 6, 8, 14]);\n+    /// assert_eq!(odds.into_iter().collect::<Vec<_>>(), vec![1, 3, 5, 9, 11, 13, 15]);\n+    /// ```\n+    #[unstable(feature = \"drain_filter\", reason = \"recently added\", issue = \"43244\")]\n+    pub fn drain_filter<F>(&mut self, filter: F) -> DrainFilter<T, F>\n+        where F: FnMut(&mut T) -> bool\n+    {\n+        // avoid borrow issues.\n+        let it = self.head;\n+        let old_len = self.len;\n+\n+        DrainFilter {\n+            list: self,\n+            it: it,\n+            pred: filter,\n+            idx: 0,\n+            old_len: old_len,\n+        }\n+    }\n+\n     /// Returns a place for insertion at the front of the list.\n     ///\n     /// Using this method with placement syntax is equivalent to\n@@ -967,6 +1032,56 @@ impl<'a, T> IterMut<'a, T> {\n     }\n }\n \n+/// An iterator produced by calling `drain_filter` on LinkedList.\n+#[unstable(feature = \"drain_filter\", reason = \"recently added\", issue = \"43244\")]\n+pub struct DrainFilter<'a, T: 'a, F: 'a>\n+    where F: FnMut(&mut T) -> bool,\n+{\n+    list: &'a mut LinkedList<T>,\n+    it: Option<Shared<Node<T>>>,\n+    pred: F,\n+    idx: usize,\n+    old_len: usize,\n+}\n+\n+#[unstable(feature = \"drain_filter\", reason = \"recently added\", issue = \"43244\")]\n+impl<'a, T, F> Iterator for DrainFilter<'a, T, F>\n+    where F: FnMut(&mut T) -> bool,\n+{\n+    type Item = T;\n+\n+    fn next(&mut self) -> Option<T> {\n+        while let Some(mut node) = self.it {\n+            unsafe {\n+                self.it = node.as_ref().next;\n+                self.idx += 1;\n+\n+                if (self.pred)(&mut node.as_mut().element) {\n+                    self.list.unlink_node(node);\n+                    return Some(Box::from_raw(node.as_ptr()).element);\n+                }\n+            }\n+        }\n+\n+        None\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        (0, Some(self.old_len - self.idx))\n+    }\n+}\n+\n+#[unstable(feature = \"drain_filter\", reason = \"recently added\", issue = \"43244\")]\n+impl<'a, T: 'a + fmt::Debug, F> fmt::Debug for DrainFilter<'a, T, F>\n+    where F: FnMut(&mut T) -> bool\n+{\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_tuple(\"DrainFilter\")\n+         .field(&self.list)\n+         .finish()\n+    }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Iterator for IntoIter<T> {\n     type Item = T;\n@@ -1509,4 +1624,28 @@ mod tests {\n         }\n         assert_eq!(i, v.len());\n     }\n+\n+    #[test]\n+    fn drain_filter_test() {\n+        let mut m: LinkedList<u32> = LinkedList::new();\n+        m.extend(&[1, 2, 3, 4, 5, 6]);\n+        let deleted = m.drain_filter(|v| *v < 4).collect::<Vec<_>>();\n+\n+        check_links(&m);\n+\n+        assert_eq!(deleted, &[1, 2, 3]);\n+        assert_eq!(m.into_iter().collect::<Vec<_>>(), &[4, 5, 6]);\n+    }\n+\n+    #[test]\n+    fn drain_to_empty_test() {\n+        let mut m: LinkedList<u32> = LinkedList::new();\n+        m.extend(&[1, 2, 3, 4, 5, 6]);\n+        let deleted = m.drain_filter(|_| true).collect::<Vec<_>>();\n+\n+        check_links(&m);\n+\n+        assert_eq!(deleted, &[1, 2, 3, 4, 5, 6]);\n+        assert_eq!(m.into_iter().collect::<Vec<_>>(), &[]);\n+    }\n }"}, {"sha": "4e3e855105eb8523f970e3019c508a0e4fdf8c22", "filename": "src/liballoc/tests/linked_list.rs", "status": "modified", "additions": 188, "deletions": 0, "changes": 188, "blob_url": "https://github.com/rust-lang/rust/blob/7707b18621725dfeec26bebd8ff4eb2ac670d7e7/src%2Fliballoc%2Ftests%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7707b18621725dfeec26bebd8ff4eb2ac670d7e7/src%2Fliballoc%2Ftests%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Flinked_list.rs?ref=7707b18621725dfeec26bebd8ff4eb2ac670d7e7", "patch": "@@ -366,3 +366,191 @@ fn test_contains() {\n \n     assert!(!l.contains(&3));\n }\n+\n+#[test]\n+fn drain_filter_empty() {\n+    let mut list: LinkedList<i32> = LinkedList::new();\n+\n+    {\n+        let mut iter = list.drain_filter(|_| true);\n+        assert_eq!(iter.size_hint(), (0, Some(0)));\n+        assert_eq!(iter.next(), None);\n+        assert_eq!(iter.size_hint(), (0, Some(0)));\n+        assert_eq!(iter.next(), None);\n+        assert_eq!(iter.size_hint(), (0, Some(0)));\n+    }\n+\n+    assert_eq!(list.len(), 0);\n+    assert_eq!(list.into_iter().collect::<Vec<_>>(), vec![]);\n+}\n+\n+#[test]\n+fn drain_filter_zst() {\n+    let mut list: LinkedList<_> = vec![(), (), (), (), ()].into_iter().collect();\n+    let initial_len = list.len();\n+    let mut count = 0;\n+\n+    {\n+        let mut iter = list.drain_filter(|_| true);\n+        assert_eq!(iter.size_hint(), (0, Some(initial_len)));\n+        while let Some(_) = iter.next() {\n+            count += 1;\n+            assert_eq!(iter.size_hint(), (0, Some(initial_len - count)));\n+        }\n+        assert_eq!(iter.size_hint(), (0, Some(0)));\n+        assert_eq!(iter.next(), None);\n+        assert_eq!(iter.size_hint(), (0, Some(0)));\n+    }\n+\n+    assert_eq!(count, initial_len);\n+    assert_eq!(list.len(), 0);\n+    assert_eq!(list.into_iter().collect::<Vec<_>>(), vec![]);\n+}\n+\n+#[test]\n+fn drain_filter_false() {\n+    let mut list: LinkedList<_> = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10].into_iter().collect();\n+\n+    let initial_len = list.len();\n+    let mut count = 0;\n+\n+    {\n+        let mut iter = list.drain_filter(|_| false);\n+        assert_eq!(iter.size_hint(), (0, Some(initial_len)));\n+        for _ in iter.by_ref() {\n+            count += 1;\n+        }\n+        assert_eq!(iter.size_hint(), (0, Some(0)));\n+        assert_eq!(iter.next(), None);\n+        assert_eq!(iter.size_hint(), (0, Some(0)));\n+    }\n+\n+    assert_eq!(count, 0);\n+    assert_eq!(list.len(), initial_len);\n+    assert_eq!(list.into_iter().collect::<Vec<_>>(), vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);\n+}\n+\n+#[test]\n+fn drain_filter_true() {\n+    let mut list: LinkedList<_> = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10].into_iter().collect();\n+\n+    let initial_len = list.len();\n+    let mut count = 0;\n+\n+    {\n+        let mut iter = list.drain_filter(|_| true);\n+        assert_eq!(iter.size_hint(), (0, Some(initial_len)));\n+        while let Some(_) = iter.next() {\n+            count += 1;\n+            assert_eq!(iter.size_hint(), (0, Some(initial_len - count)));\n+        }\n+        assert_eq!(iter.size_hint(), (0, Some(0)));\n+        assert_eq!(iter.next(), None);\n+        assert_eq!(iter.size_hint(), (0, Some(0)));\n+    }\n+\n+    assert_eq!(count, initial_len);\n+    assert_eq!(list.len(), 0);\n+    assert_eq!(list.into_iter().collect::<Vec<_>>(), vec![]);\n+}\n+\n+#[test]\n+fn drain_filter_complex() {\n+\n+    {   //                [+xxx++++++xxxxx++++x+x++]\n+        let mut list = vec![\n+            1,\n+            2, 4, 6,\n+            7, 9, 11, 13, 15, 17,\n+            18, 20, 22, 24, 26,\n+            27, 29, 31, 33,\n+            34,\n+            35,\n+            36,\n+            37, 39\n+        ].into_iter().collect::<LinkedList<_>>();\n+\n+        let removed = list.drain_filter(|x| *x % 2 == 0).collect::<Vec<_>>();\n+        assert_eq!(removed.len(), 10);\n+        assert_eq!(removed, vec![2, 4, 6, 18, 20, 22, 24, 26, 34, 36]);\n+\n+        assert_eq!(list.len(), 14);\n+        assert_eq!(\n+            list.into_iter().collect::<Vec<_>>(),\n+            vec![1, 7, 9, 11, 13, 15, 17, 27, 29, 31, 33, 35, 37, 39]\n+        );\n+    }\n+\n+    {   // [xxx++++++xxxxx++++x+x++]\n+        let mut list = vec![\n+            2, 4, 6,\n+            7, 9, 11, 13, 15, 17,\n+            18, 20, 22, 24, 26,\n+            27, 29, 31, 33,\n+            34,\n+            35,\n+            36,\n+            37, 39\n+        ].into_iter().collect::<LinkedList<_>>();\n+\n+        let removed = list.drain_filter(|x| *x % 2 == 0).collect::<Vec<_>>();\n+        assert_eq!(removed.len(), 10);\n+        assert_eq!(removed, vec![2, 4, 6, 18, 20, 22, 24, 26, 34, 36]);\n+\n+        assert_eq!(list.len(), 13);\n+        assert_eq!(\n+            list.into_iter().collect::<Vec<_>>(),\n+            vec![7, 9, 11, 13, 15, 17, 27, 29, 31, 33, 35, 37, 39]\n+        );\n+    }\n+\n+    {   // [xxx++++++xxxxx++++x+x]\n+        let mut list = vec![\n+            2, 4, 6,\n+            7, 9, 11, 13, 15, 17,\n+            18, 20, 22, 24, 26,\n+            27, 29, 31, 33,\n+            34,\n+            35,\n+            36\n+        ].into_iter().collect::<LinkedList<_>>();\n+\n+        let removed = list.drain_filter(|x| *x % 2 == 0).collect::<Vec<_>>();\n+        assert_eq!(removed.len(), 10);\n+        assert_eq!(removed, vec![2, 4, 6, 18, 20, 22, 24, 26, 34, 36]);\n+\n+        assert_eq!(list.len(), 11);\n+        assert_eq!(\n+            list.into_iter().collect::<Vec<_>>(),\n+            vec![7, 9, 11, 13, 15, 17, 27, 29, 31, 33, 35]\n+        );\n+    }\n+\n+    {   // [xxxxxxxxxx+++++++++++]\n+        let mut list = vec![\n+            2, 4, 6, 8, 10, 12, 14, 16, 18, 20,\n+            1, 3, 5, 7, 9, 11, 13, 15, 17, 19\n+        ].into_iter().collect::<LinkedList<_>>();\n+\n+        let removed = list.drain_filter(|x| *x % 2 == 0).collect::<Vec<_>>();\n+        assert_eq!(removed.len(), 10);\n+        assert_eq!(removed, vec![2, 4, 6, 8, 10, 12, 14, 16, 18, 20]);\n+\n+        assert_eq!(list.len(), 10);\n+        assert_eq!(list.into_iter().collect::<Vec<_>>(), vec![1, 3, 5, 7, 9, 11, 13, 15, 17, 19]);\n+    }\n+\n+    {   // [+++++++++++xxxxxxxxxx]\n+        let mut list = vec![\n+            1, 3, 5, 7, 9, 11, 13, 15, 17, 19,\n+            2, 4, 6, 8, 10, 12, 14, 16, 18, 20\n+        ].into_iter().collect::<LinkedList<_>>();\n+\n+        let removed = list.drain_filter(|x| *x % 2 == 0).collect::<Vec<_>>();\n+        assert_eq!(removed.len(), 10);\n+        assert_eq!(removed, vec![2, 4, 6, 8, 10, 12, 14, 16, 18, 20]);\n+\n+        assert_eq!(list.len(), 10);\n+        assert_eq!(list.into_iter().collect::<Vec<_>>(), vec![1, 3, 5, 7, 9, 11, 13, 15, 17, 19]);\n+    }\n+}"}]}