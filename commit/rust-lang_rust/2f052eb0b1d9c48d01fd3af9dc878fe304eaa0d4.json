{"sha": "2f052eb0b1d9c48d01fd3af9dc878fe304eaa0d4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJmMDUyZWIwYjFkOWM0OGQwMWZkM2FmOWRjODc4ZmUzMDRlYWEwZDQ=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "arielb1@mail.tau.ac.il", "date": "2015-08-25T15:49:32Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "arielb1@mail.tau.ac.il", "date": "2015-08-25T15:50:26Z"}, "message": "use the parameter environment when checking dtors\n\nThis makes it more uniform. No functional changes.", "tree": {"sha": "8361eba848fbb5e41f823bda6aefec7f9bd87946", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8361eba848fbb5e41f823bda6aefec7f9bd87946"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2f052eb0b1d9c48d01fd3af9dc878fe304eaa0d4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2f052eb0b1d9c48d01fd3af9dc878fe304eaa0d4", "html_url": "https://github.com/rust-lang/rust/commit/2f052eb0b1d9c48d01fd3af9dc878fe304eaa0d4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2f052eb0b1d9c48d01fd3af9dc878fe304eaa0d4/comments", "author": null, "committer": null, "parents": [{"sha": "5c630a61c658cb7d861a60da6951ee06619337b2", "url": "https://api.github.com/repos/rust-lang/rust/commits/5c630a61c658cb7d861a60da6951ee06619337b2", "html_url": "https://github.com/rust-lang/rust/commit/5c630a61c658cb7d861a60da6951ee06619337b2"}], "stats": {"total": 219, "additions": 98, "deletions": 121}, "files": [{"sha": "0c539a5d0e0c2816b0772bed88318929619595f8", "filename": "src/librustc/middle/infer/higher_ranked/mod.rs", "status": "modified", "additions": 0, "deletions": 58, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/2f052eb0b1d9c48d01fd3af9dc878fe304eaa0d4/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f052eb0b1d9c48d01fd3af9dc878fe304eaa0d4/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=2f052eb0b1d9c48d01fd3af9dc878fe304eaa0d4", "patch": "@@ -14,7 +14,6 @@\n use super::{CombinedSnapshot, InferCtxt, HigherRankedType, SkolemizationMap};\n use super::combine::CombineFields;\n \n-use middle::subst;\n use middle::ty::{self, TypeError, Binder};\n use middle::ty_fold::{self, TypeFoldable};\n use middle::ty_relate::{Relate, RelateResult, TypeRelation};\n@@ -455,63 +454,6 @@ impl<'a,'tcx> InferCtxtExt for InferCtxt<'a,'tcx> {\n     }\n }\n \n-/// Constructs and returns a substitution that, for a given type\n-/// scheme parameterized by `generics`, will replace every generic\n-/// parameter in the type with a skolemized type/region (which one can\n-/// think of as a \"fresh constant\", except at the type/region level of\n-/// reasoning).\n-///\n-/// Since we currently represent bound/free type parameters in the\n-/// same way, this only has an effect on regions.\n-///\n-/// (Note that unlike a substitution from `ty::construct_free_substs`,\n-/// this inserts skolemized regions rather than free regions; this\n-/// allows one to use `fn leak_check` to catch attmepts to unify the\n-/// skolemized regions with e.g. the `'static` lifetime)\n-pub fn construct_skolemized_substs<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n-                                            generics: &ty::Generics<'tcx>,\n-                                            snapshot: &CombinedSnapshot)\n-                                            -> (subst::Substs<'tcx>, SkolemizationMap)\n-{\n-    let mut map = FnvHashMap();\n-\n-    // map T => T\n-    let mut types = subst::VecPerParamSpace::empty();\n-    push_types_from_defs(infcx.tcx, &mut types, generics.types.as_slice());\n-\n-    // map early- or late-bound 'a => fresh 'a\n-    let mut regions = subst::VecPerParamSpace::empty();\n-    push_region_params(infcx, &mut map, &mut regions, generics.regions.as_slice(), snapshot);\n-\n-    let substs = subst::Substs { types: types,\n-                                 regions: subst::NonerasedRegions(regions) };\n-    return (substs, map);\n-\n-    fn push_region_params<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n-                                   map: &mut SkolemizationMap,\n-                                   regions: &mut subst::VecPerParamSpace<ty::Region>,\n-                                   region_params: &[ty::RegionParameterDef],\n-                                   snapshot: &CombinedSnapshot)\n-    {\n-        for r in region_params {\n-            let br = r.to_bound_region();\n-            let skol_var = infcx.region_vars.new_skolemized(br, &snapshot.region_vars_snapshot);\n-            let sanity_check = map.insert(br, skol_var);\n-            assert!(sanity_check.is_none());\n-            regions.push(r.space, skol_var);\n-        }\n-    }\n-\n-    fn push_types_from_defs<'tcx>(tcx: &ty::ctxt<'tcx>,\n-                                  types: &mut subst::VecPerParamSpace<ty::Ty<'tcx>>,\n-                                  defs: &[ty::TypeParameterDef<'tcx>]) {\n-        for def in defs {\n-            let ty = tcx.mk_param_from_def(def);\n-            types.push(def.space, ty);\n-        }\n-    }\n-}\n-\n pub fn skolemize_late_bound_regions<'a,'tcx,T>(infcx: &InferCtxt<'a,'tcx>,\n                                                binder: &ty::Binder<T>,\n                                                snapshot: &CombinedSnapshot)"}, {"sha": "158ef745de33f84543d8dac2b780142e34ca82c2", "filename": "src/librustc/middle/infer/mod.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2f052eb0b1d9c48d01fd3af9dc878fe304eaa0d4/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f052eb0b1d9c48d01fd3af9dc878fe304eaa0d4/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs?ref=2f052eb0b1d9c48d01fd3af9dc878fe304eaa0d4", "patch": "@@ -948,15 +948,6 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         })\n     }\n \n-    pub fn construct_skolemized_subst(&self,\n-                                      generics: &ty::Generics<'tcx>,\n-                                      snapshot: &CombinedSnapshot)\n-                                      -> (subst::Substs<'tcx>, SkolemizationMap) {\n-        /*! See `higher_ranked::construct_skolemized_subst` */\n-\n-        higher_ranked::construct_skolemized_substs(self, generics, snapshot)\n-    }\n-\n     pub fn skolemize_late_bound_regions<T>(&self,\n                                            value: &ty::Binder<T>,\n                                            snapshot: &CombinedSnapshot)"}, {"sha": "d81f8e0ae9093e55d7f1fa97d23900a56a260212", "filename": "src/librustc/middle/infer/region_inference/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f052eb0b1d9c48d01fd3af9dc878fe304eaa0d4/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f052eb0b1d9c48d01fd3af9dc878fe304eaa0d4/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs?ref=2f052eb0b1d9c48d01fd3af9dc878fe304eaa0d4", "patch": "@@ -373,7 +373,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n \n         let sc = self.skolemization_count.get();\n         self.skolemization_count.set(sc + 1);\n-        ReSkolemized(sc, br)\n+        ReSkolemized(ty::SkolemizedRegionVid { index: sc }, br)\n     }\n \n     pub fn new_bound(&self, debruijn: ty::DebruijnIndex) -> Region {"}, {"sha": "cb00e3b9baf25c528007624587930a3dccba0999", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 62, "deletions": 2, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/2f052eb0b1d9c48d01fd3af9dc878fe304eaa0d4/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f052eb0b1d9c48d01fd3af9dc878fe304eaa0d4/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=2f052eb0b1d9c48d01fd3af9dc878fe304eaa0d4", "patch": "@@ -1502,7 +1502,62 @@ pub struct DebruijnIndex {\n     pub depth: u32,\n }\n \n-/// Representation of regions:\n+/// Representation of regions.\n+///\n+/// Unlike types, most region variants are \"fictitious\", not concrete,\n+/// regions. Among these, `ReStatic`, `ReEmpty` and `ReScope` are the only\n+/// ones representing concrete regions.\n+///\n+/// ## Bound Regions\n+///\n+/// These are regions that are stored behind a binder and must be substituted\n+/// with some concrete region before being used. There are 2 kind of\n+/// bound regions: early-bound, which are bound in a TypeScheme/TraitDef,\n+/// and are substituted by a Substs,  and late-bound, which are part of\n+/// higher-ranked types (e.g. `for<'a> fn(&'a ())`) and are substituted by\n+/// the likes of `liberate_late_bound_regions`. The distinction exists\n+/// because higher-ranked lifetimes aren't supported in all places. See [1][2].\n+///\n+/// Unlike TyParam-s, bound regions are not supposed to exist \"in the wild\"\n+/// outside their binder, e.g. in types passed to type inference, and\n+/// should first be substituted (by skolemized regions, free regions,\n+/// or region variables).\n+///\n+/// ## Skolemized and Free Regions\n+///\n+/// One often wants to work with bound regions without knowing their precise\n+/// identity. For example, when checking a function, the lifetime of a borrow\n+/// can end up being assigned to some region parameter. In these cases,\n+/// it must be ensured that bounds on the region can't be accidentally\n+/// assumed without being checked.\n+///\n+/// The process of doing that is called \"skolemization\". The bound regions\n+/// are replaced by skolemized markers, which don't satisfy any relation\n+/// not explicity provided.\n+///\n+/// There are 2 kinds of skolemized regions in rustc: `ReFree` and\n+/// `ReSkolemized`. When checking an item's body, `ReFree` is supposed\n+/// to be used. These also support explicit bounds: both the internally-stored\n+/// *scope*, which the region is assumed to outlive, as well as other\n+/// relations stored in the `FreeRegionMap`. Note that these relations\n+/// aren't checked when you `make_subregion` (or `mk_eqty`), only by\n+/// `resolve_regions_and_report_errors`.\n+///\n+/// When working with higher-ranked types, some region relations aren't\n+/// yet known, so you can't just call `resolve_regions_and_report_errors`.\n+/// `ReSkolemized` is designed for this purpose. In these contexts,\n+/// there's also the risk that some inference variable laying around will\n+/// get unified with your skolemized region: if you want to check whether\n+/// `for<'a> Foo<'_>: 'a`, and you substitute your bound region `'a`\n+/// with a skolemized region `'%a`, the variable `'_` would just be\n+/// instantiated to the skolemized region `'%a`, which is wrong because\n+/// the inference variable is supposed to satisfy the relation\n+/// *for every value of the skolemized region*. To ensure that doesn't\n+/// happen, you can use `leak_check`. This is more clearly explained\n+/// by infer/higher_ranked/README.md.\n+///\n+/// [1] http://smallcultfollowing.com/babysteps/blog/2013/10/29/intermingled-parameter-lists/\n+/// [2] http://smallcultfollowing.com/babysteps/blog/2013/11/04/intermingled-parameter-lists/\n #[derive(Clone, PartialEq, Eq, Hash, Copy)]\n pub enum Region {\n     // Region bound in a type or fn declaration which will be\n@@ -1532,7 +1587,7 @@ pub enum Region {\n \n     /// A skolemized region - basically the higher-ranked version of ReFree.\n     /// Should not exist after typeck.\n-    ReSkolemized(u32, BoundRegion),\n+    ReSkolemized(SkolemizedRegionVid, BoundRegion),\n \n     /// Empty lifetime is for data that is never accessed.\n     /// Bottom in the region lattice. We treat ReEmpty somewhat\n@@ -2168,6 +2223,11 @@ pub struct RegionVid {\n     pub index: u32\n }\n \n+#[derive(Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct SkolemizedRegionVid {\n+    pub index: u32\n+}\n+\n #[derive(Clone, Copy, PartialEq, Eq, Hash)]\n pub enum InferTy {\n     TyVar(TyVid),"}, {"sha": "ac51f46a7e94354daec181af74c57a6b39f84704", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f052eb0b1d9c48d01fd3af9dc878fe304eaa0d4/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f052eb0b1d9c48d01fd3af9dc878fe304eaa0d4/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=2f052eb0b1d9c48d01fd3af9dc878fe304eaa0d4", "patch": "@@ -418,7 +418,7 @@ impl fmt::Debug for ty::Region {\n             }\n \n             ty::ReSkolemized(id, ref bound_region) => {\n-                write!(f, \"ReSkolemized({}, {:?})\", id, bound_region)\n+                write!(f, \"ReSkolemized({}, {:?})\", id.index, bound_region)\n             }\n \n             ty::ReEmpty => write!(f, \"ReEmpty\")"}, {"sha": "a8c77f863b7008175a9df4d2a601aebf1f55d5ed", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 29, "deletions": 47, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/2f052eb0b1d9c48d01fd3af9dc878fe304eaa0d4/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f052eb0b1d9c48d01fd3af9dc878fe304eaa0d4/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=2f052eb0b1d9c48d01fd3af9dc878fe304eaa0d4", "patch": "@@ -11,9 +11,11 @@\n use check::regionck::{self, Rcx};\n \n use middle::def_id::{DefId, LOCAL_CRATE};\n+use middle::free_region::FreeRegionMap;\n use middle::infer;\n use middle::region;\n use middle::subst::{self, Subst};\n+use middle::traits;\n use middle::ty::{self, Ty};\n use util::nodemap::FnvHashSet;\n \n@@ -75,61 +77,41 @@ fn ensure_drop_params_and_item_params_correspond<'tcx>(\n     drop_impl_ty: &ty::Ty<'tcx>,\n     self_type_did: DefId) -> Result<(), ()>\n {\n-    // New strategy based on review suggestion from nikomatsakis.\n-    //\n-    // (In the text and code below, \"named\" denotes \"struct/enum\", and\n-    // \"generic params\" denotes \"type and region params\")\n-    //\n-    // 1. Create fresh skolemized type/region \"constants\" for each of\n-    //    the named type's generic params.  Instantiate the named type\n-    //    with the fresh constants, yielding `named_skolem`.\n-    //\n-    // 2. Create unification variables for each of the Drop impl's\n-    //    generic params.  Instantiate the impl's Self's type with the\n-    //    unification-vars, yielding `drop_unifier`.\n-    //\n-    // 3. Attempt to unify Self_unif with Type_skolem.  If unification\n-    //    succeeds, continue (i.e. with the predicate checks).\n-\n-    let ty::TypeScheme { generics: ref named_type_generics,\n-                         ty: named_type } =\n-        tcx.lookup_item_type(self_type_did);\n-\n-    let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, None, false);\n-\n-    infcx.commit_if_ok(|snapshot| {\n-        let (named_type_to_skolem, skol_map) =\n-            infcx.construct_skolemized_subst(named_type_generics, snapshot);\n-        let named_type_skolem = named_type.subst(tcx, &named_type_to_skolem);\n-\n-        let drop_impl_span = tcx.map.def_id_span(drop_impl_did, codemap::DUMMY_SP);\n-        let drop_to_unifier =\n-            infcx.fresh_substs_for_generics(drop_impl_span, drop_impl_generics);\n-        let drop_unifier = drop_impl_ty.subst(tcx, &drop_to_unifier);\n-\n-        if let Ok(()) = infer::mk_eqty(&infcx, true, infer::TypeOrigin::Misc(drop_impl_span),\n-                                       named_type_skolem, drop_unifier) {\n-            // Even if we did manage to equate the types, the process\n-            // may have just gathered unsolvable region constraints\n-            // like `R == 'static` (represented as a pair of subregion\n-            // constraints) for some skolemization constant R.\n-            //\n-            // However, the leak_check method allows us to confirm\n-            // that no skolemized regions escaped (i.e. were related\n-            // to other regions in the constraint graph).\n-            if let Ok(()) = infcx.leak_check(&skol_map, snapshot) {\n-                return Ok(())\n-            }\n-        }\n+    assert!(drop_impl_did.is_local() && self_type_did.is_local());\n+\n+    // check that the impl type can be made to match the trait type.\n+\n+    let impl_param_env = ty::ParameterEnvironment::for_item(tcx, self_type_did.node);\n+    let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, Some(impl_param_env), true);\n+\n+    let named_type = tcx.lookup_item_type(self_type_did).ty;\n+    let named_type = named_type.subst(tcx, &infcx.parameter_environment.free_substs);\n \n+    let drop_impl_span = tcx.map.def_id_span(drop_impl_did, codemap::DUMMY_SP);\n+    let fresh_impl_substs =\n+        infcx.fresh_substs_for_generics(drop_impl_span, drop_impl_generics);\n+    let fresh_impl_self_ty = drop_impl_ty.subst(tcx, &fresh_impl_substs);\n+\n+    if let Err(_) = infer::mk_eqty(&infcx, true, infer::TypeOrigin::Misc(drop_impl_span),\n+                                   named_type, fresh_impl_self_ty) {\n         span_err!(tcx.sess, drop_impl_span, E0366,\n                   \"Implementations of Drop cannot be specialized\");\n         let item_span = tcx.map.span(self_type_did.node);\n         tcx.sess.span_note(item_span,\n                            \"Use same sequence of generic type and region \\\n                             parameters that is on the struct/enum definition\");\n         return Err(());\n-    })\n+    }\n+\n+    if let Err(ref errors) = infcx.fulfillment_cx.borrow_mut().select_all_or_error(&infcx) {\n+        // this could be reached when we get lazy normalization\n+        traits::report_fulfillment_errors(&infcx, errors);\n+        return Err(());\n+    }\n+\n+    let free_regions = FreeRegionMap::new();\n+    infcx.resolve_regions_and_report_errors(&free_regions, drop_impl_did.node);\n+    Ok(())\n }\n \n /// Confirms that every predicate imposed by dtor_predicates is"}, {"sha": "b12e26fddf6d20a86175441a6aaab8bb8428040f", "filename": "src/test/compile-fail/reject-specialized-drops-8142.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2f052eb0b1d9c48d01fd3af9dc878fe304eaa0d4/src%2Ftest%2Fcompile-fail%2Freject-specialized-drops-8142.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f052eb0b1d9c48d01fd3af9dc878fe304eaa0d4/src%2Ftest%2Fcompile-fail%2Freject-specialized-drops-8142.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Freject-specialized-drops-8142.rs?ref=2f052eb0b1d9c48d01fd3af9dc878fe304eaa0d4", "patch": "@@ -37,7 +37,9 @@ impl<'al,'adds_bnd>     Drop for L<'al,'adds_bnd> where 'adds_bnd:'al {    // RE\n impl<'ml>               Drop for M<'ml>         { fn drop(&mut self) { } } // ACCEPT\n \n impl                    Drop for N<'static>     { fn drop(&mut self) { } } // REJECT\n-//~^ ERROR Implementations of Drop cannot be specialized\n+//~^ ERROR mismatched types\n+//~| expected `N<'n>`\n+//~|    found `N<'static>`\n \n impl<Cok_nobound> Drop for O<Cok_nobound> { fn drop(&mut self) { } } // ACCEPT\n \n@@ -57,9 +59,9 @@ impl<'t,Bt:'t>    Drop for T<'t,Bt>       { fn drop(&mut self) { } } // ACCEPT\n impl              Drop for U              { fn drop(&mut self) { } } // ACCEPT\n \n impl<One>         Drop for V<One,One>     { fn drop(&mut self) { } } // REJECT\n-//~^ERROR Implementations of Drop cannot be specialized\n+//~^ ERROR Implementations of Drop cannot be specialized\n \n impl<'lw>         Drop for W<'lw,'lw>     { fn drop(&mut self) { } } // REJECT\n-//~^ERROR Implementations of Drop cannot be specialized\n+//~^ ERROR cannot infer an appropriate lifetime\n \n pub fn main() { }"}]}