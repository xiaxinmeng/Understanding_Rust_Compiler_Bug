{"sha": "c8ddb0f070db3bebfdc4f581cee1dc212a86bb80", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM4ZGRiMGYwNzBkYjNiZWJmZGM0ZjU4MWNlZTFkYzIxMmE4NmJiODA=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-05-05T10:03:20Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-05-14T03:28:17Z"}, "message": "Extract PathCollector", "tree": {"sha": "1b4fe1186a675d9a21d61742746206787940b505", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1b4fe1186a675d9a21d61742746206787940b505"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c8ddb0f070db3bebfdc4f581cee1dc212a86bb80", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c8ddb0f070db3bebfdc4f581cee1dc212a86bb80", "html_url": "https://github.com/rust-lang/rust/commit/c8ddb0f070db3bebfdc4f581cee1dc212a86bb80", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c8ddb0f070db3bebfdc4f581cee1dc212a86bb80/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cea73bfb1596f1e5e1f3a6faa9863d2983a3ccea", "url": "https://api.github.com/repos/rust-lang/rust/commits/cea73bfb1596f1e5e1f3a6faa9863d2983a3ccea", "html_url": "https://github.com/rust-lang/rust/commit/cea73bfb1596f1e5e1f3a6faa9863d2983a3ccea"}], "stats": {"total": 124, "additions": 68, "deletions": 56}, "files": [{"sha": "798c35874eeb1b76cd9d9b4248fd76d5e72f19d2", "filename": "src/librustc_trans/save/dump_csv.rs", "status": "modified", "additions": 14, "deletions": 54, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/c8ddb0f070db3bebfdc4f581cee1dc212a86bb80/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8ddb0f070db3bebfdc4f581cee1dc212a86bb80/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs?ref=c8ddb0f070db3bebfdc4f581cee1dc212a86bb80", "patch": "@@ -27,7 +27,8 @@\n //! the format of the output away from extracting it from the compiler.\n //! DumpCsvVisitor walks the AST and processes it.\n \n-use super::{escape, generated_code, recorder, SaveContext};\n+\n+use super::{escape, generated_code, recorder, SaveContext, PathCollector};\n \n use session::Session;\n \n@@ -59,9 +60,6 @@ pub struct DumpCsvVisitor<'l, 'tcx: 'l> {\n     sess: &'l Session,\n     analysis: &'l ty::CrateAnalysis<'tcx>,\n \n-    collected_paths: Vec<(NodeId, ast::Path, bool, recorder::Row)>,\n-    collecting: bool,\n-\n     span: SpanUtils<'l>,\n     fmt: FmtStrs<'l>,\n \n@@ -79,8 +77,6 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n                 err_count: Cell::new(0)\n             }),\n             analysis: analysis,\n-            collected_paths: vec![],\n-            collecting: false,\n             span: SpanUtils {\n                 sess: sess,\n                 err_count: Cell::new(0)\n@@ -281,12 +277,11 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n \n     fn process_formals(&mut self, formals: &Vec<ast::Arg>, qualname: &str) {\n         for arg in formals {\n-            assert!(self.collected_paths.is_empty() && !self.collecting);\n-            self.collecting = true;\n-            self.visit_pat(&*arg.pat);\n-            self.collecting = false;\n+            self.visit_pat(&arg.pat);\n+            let mut collector = PathCollector::new();\n+            collector.visit_pat(&arg.pat);\n             let span_utils = self.span.clone();\n-            for &(id, ref p, _, _) in &self.collected_paths {\n+            for &(id, ref p, _, _) in &collector.collected_paths {\n                 let typ =\n                     ppaux::ty_to_string(\n                         &self.analysis.ty_cx,\n@@ -300,7 +295,6 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n                                     &path_to_string(p),\n                                     &typ[..]);\n             }\n-            self.collected_paths.clear();\n         }\n     }\n \n@@ -1026,7 +1020,6 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n \n         match p.node {\n             ast::PatStruct(ref path, ref fields, _) => {\n-                self.collected_paths.push((p.id, path.clone(), false, recorder::StructRef));\n                 visit::walk_path(self, path);\n \n                 let def = self.analysis.ty_cx.def_map.borrow().get(&p.id).unwrap().full_def();\n@@ -1063,32 +1056,6 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n                     }\n                 }\n             }\n-            ast::PatEnum(ref path, _) |\n-            ast::PatQPath(_, ref path) => {\n-                self.collected_paths.push((p.id, path.clone(), false, recorder::VarRef));\n-                visit::walk_pat(self, p);\n-            }\n-            ast::PatIdent(bm, ref path1, ref optional_subpattern) => {\n-                let immut = match bm {\n-                    // Even if the ref is mut, you can't change the ref, only\n-                    // the data pointed at, so showing the initialising expression\n-                    // is still worthwhile.\n-                    ast::BindByRef(_) => true,\n-                    ast::BindByValue(mt) => {\n-                        match mt {\n-                            ast::MutMutable => false,\n-                            ast::MutImmutable => true,\n-                        }\n-                    }\n-                };\n-                // collect path for either visit_local or visit_arm\n-                let path = ast_util::ident_to_path(path1.span,path1.node);\n-                self.collected_paths.push((p.id, path, immut, recorder::VarRef));\n-                match *optional_subpattern {\n-                    None => {}\n-                    Some(ref subpattern) => self.visit_pat(&**subpattern)\n-                }\n-            }\n             _ => visit::walk_pat(self, p)\n         }\n     }\n@@ -1421,23 +1388,20 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DumpCsvVisitor<'l, 'tcx> {\n \n     fn visit_pat(&mut self, p: &ast::Pat) {\n         self.process_pat(p);\n-        if !self.collecting {\n-            self.collected_paths.clear();\n-        }\n     }\n \n     fn visit_arm(&mut self, arm: &ast::Arm) {\n-        assert!(self.collected_paths.is_empty() && !self.collecting);\n-        self.collecting = true;\n+        let mut collector = PathCollector::new();\n         for pattern in &arm.pats {\n             // collect paths from the arm's patterns\n-            self.visit_pat(&**pattern);\n+            collector.visit_pat(&pattern);\n+            self.visit_pat(&pattern);\n         }\n \n         // This is to get around borrow checking, because we need mut self to call process_path.\n         let mut paths_to_process = vec![];\n         // process collected paths\n-        for &(id, ref p, ref immut, ref_kind) in &self.collected_paths {\n+        for &(id, ref p, ref immut, ref_kind) in &collector.collected_paths {\n             let def_map = self.analysis.ty_cx.def_map.borrow();\n             if !def_map.contains_key(&id) {\n                 self.sess.span_bug(p.span,\n@@ -1475,8 +1439,6 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DumpCsvVisitor<'l, 'tcx> {\n         for &(id, ref path, ref_kind) in &paths_to_process {\n             self.process_path(id, path.span, path, ref_kind);\n         }\n-        self.collecting = false;\n-        self.collected_paths.clear();\n         visit::walk_expr_opt(self, &arm.guard);\n         self.visit_expr(&*arm.body);\n     }\n@@ -1496,14 +1458,13 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DumpCsvVisitor<'l, 'tcx> {\n \n         // The local could declare multiple new vars, we must walk the\n         // pattern and collect them all.\n-        assert!(self.collected_paths.is_empty() && !self.collecting);\n-        self.collecting = true;\n-        self.visit_pat(&*l.pat);\n-        self.collecting = false;\n+        let mut collector = PathCollector::new();\n+        collector.visit_pat(&l.pat);\n+        self.visit_pat(&l.pat);\n \n         let value = self.span.snippet(l.span);\n \n-        for &(id, ref p, ref immut, _) in &self.collected_paths {\n+        for &(id, ref p, ref immut, _) in &collector.collected_paths {\n             let value = if *immut { value.to_string() } else { \"<mutable>\".to_string() };\n             let types = self.analysis.ty_cx.node_types();\n             let typ = ppaux::ty_to_string(&self.analysis.ty_cx, *types.get(&id).unwrap());\n@@ -1518,7 +1479,6 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DumpCsvVisitor<'l, 'tcx> {\n                                   &value[..],\n                                   &typ[..]);\n         }\n-        self.collected_paths.clear();\n \n         // Just walk the initialiser and type (don't want to walk the pattern again).\n         visit::walk_ty_opt(self, &l.ty);"}, {"sha": "dc1c36bd0011188f5f10e0e016ccb981526f6a0b", "filename": "src/librustc_trans/save/mod.rs", "status": "modified", "additions": 54, "deletions": 2, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/c8ddb0f070db3bebfdc4f581cee1dc212a86bb80/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8ddb0f070db3bebfdc4f581cee1dc212a86bb80/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fmod.rs?ref=c8ddb0f070db3bebfdc4f581cee1dc212a86bb80", "patch": "@@ -15,10 +15,12 @@ use std::env;\n use std::fs::{self, File};\n use std::path::{Path, PathBuf};\n \n-use syntax::{attr, visit};\n+use syntax::{attr};\n use syntax::ast::{self, NodeId, DefId};\n-use syntax::parse::token::keywords;\n+use syntax::ast_util;\n use syntax::codemap::*;\n+use syntax::parse::token::keywords;\n+use syntax::visit::{self, Visitor};\n \n use self::span_utils::SpanUtils;\n \n@@ -94,10 +96,60 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n     }\n \n     pub fn get_data_for_id(&self, id: &NodeId) -> Data {\n+        // TODO\n         unimplemented!();        \n     }\n }\n \n+// An AST visitor for collecting paths from patterns.\n+struct PathCollector {\n+    // TODO bool -> ast::mutable\n+    // TODO recorder -> var kind new enum\n+    // The Row field identifies the kind of formal variable.\n+    collected_paths: Vec<(NodeId, ast::Path, bool, recorder::Row)>,\n+}\n+\n+impl PathCollector {\n+    fn new() -> PathCollector {\n+        PathCollector {\n+            collected_paths: vec![],\n+        }\n+    }\n+}\n+\n+impl<'v> Visitor<'v> for PathCollector {\n+    fn visit_pat(&mut self, p: &ast::Pat) {\n+        match p.node {\n+            ast::PatStruct(ref path, _, _) => {\n+                self.collected_paths.push((p.id, path.clone(), false, recorder::StructRef));\n+            }\n+            ast::PatEnum(ref path, _) |\n+            ast::PatQPath(_, ref path) => {\n+                self.collected_paths.push((p.id, path.clone(), false, recorder::VarRef));\n+            }\n+            ast::PatIdent(bm, ref path1, _) => {\n+                let immut = match bm {\n+                    // Even if the ref is mut, you can't change the ref, only\n+                    // the data pointed at, so showing the initialising expression\n+                    // is still worthwhile.\n+                    ast::BindByRef(_) => true,\n+                    ast::BindByValue(mt) => {\n+                        match mt {\n+                            ast::MutMutable => false,\n+                            ast::MutImmutable => true,\n+                        }\n+                    }\n+                };\n+                // collect path for either visit_local or visit_arm\n+                let path = ast_util::ident_to_path(path1.span,path1.node);\n+                self.collected_paths.push((p.id, path, immut, recorder::VarRef));\n+            }\n+            _ => {}\n+        }\n+        visit::walk_pat(self, p);\n+    }\n+}\n+\n #[allow(deprecated)]\n pub fn process_crate(sess: &Session,\n                      krate: &ast::Crate,"}]}