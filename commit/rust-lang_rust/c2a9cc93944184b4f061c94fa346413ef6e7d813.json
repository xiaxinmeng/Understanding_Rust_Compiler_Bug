{"sha": "c2a9cc93944184b4f061c94fa346413ef6e7d813", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMyYTljYzkzOTQ0MTg0YjRmMDYxYzk0ZmEzNDY0MTNlZjZlN2Q4MTM=", "commit": {"author": {"name": "Kevin Cantu", "email": "me@kevincantu.org", "date": "2012-06-09T08:08:26Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-06-09T19:58:12Z"}, "message": "Add the Alioth k-nucleotide benchmark\n\nThis is not particularly well performing yet (60x slower than C++ or\nworse).  I think the slicing and the copies made for the hashmap\nare mostly responsible, but YMMV.\n\nBy default shootout-fasta writes to stdout and shootout-k-nucleotide\nreads from stdin.  To use an intermediate file with a fixed name,\nset RUST_BENCH...", "tree": {"sha": "3810700a6eee2b7522f1f567c702991dce164bb0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3810700a6eee2b7522f1f567c702991dce164bb0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c2a9cc93944184b4f061c94fa346413ef6e7d813", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c2a9cc93944184b4f061c94fa346413ef6e7d813", "html_url": "https://github.com/rust-lang/rust/commit/c2a9cc93944184b4f061c94fa346413ef6e7d813", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c2a9cc93944184b4f061c94fa346413ef6e7d813/comments", "author": {"login": "killerswan", "id": 195060, "node_id": "MDQ6VXNlcjE5NTA2MA==", "avatar_url": "https://avatars.githubusercontent.com/u/195060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/killerswan", "html_url": "https://github.com/killerswan", "followers_url": "https://api.github.com/users/killerswan/followers", "following_url": "https://api.github.com/users/killerswan/following{/other_user}", "gists_url": "https://api.github.com/users/killerswan/gists{/gist_id}", "starred_url": "https://api.github.com/users/killerswan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/killerswan/subscriptions", "organizations_url": "https://api.github.com/users/killerswan/orgs", "repos_url": "https://api.github.com/users/killerswan/repos", "events_url": "https://api.github.com/users/killerswan/events{/privacy}", "received_events_url": "https://api.github.com/users/killerswan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c1859d4cd0cd356de3e8daadaff34492d51fd934", "url": "https://api.github.com/repos/rust-lang/rust/commits/c1859d4cd0cd356de3e8daadaff34492d51fd934", "html_url": "https://github.com/rust-lang/rust/commit/c1859d4cd0cd356de3e8daadaff34492d51fd934"}], "stats": {"total": 218, "additions": 207, "deletions": 11}, "files": [{"sha": "52bc9c8d61c3d621175cb6bdabf38d003dea0267", "filename": "src/test/bench/shootout-fasta.rs", "status": "modified", "additions": 20, "deletions": 11, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/c2a9cc93944184b4f061c94fa346413ef6e7d813/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2a9cc93944184b4f061c94fa346413ef6e7d813/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fasta.rs?ref=c2a9cc93944184b4f061c94fa346413ef6e7d813", "patch": "@@ -10,6 +10,7 @@ import vec;\n import uint;\n import int;\n import str;\n+import io::writer_util;\n \n fn LINE_LENGTH() -> uint { ret 60u; }\n \n@@ -42,46 +43,53 @@ fn select_random(r: u32, genelist: [aminoacids]) -> char {\n     ret bisect(genelist, 0u, vec::len::<aminoacids>(genelist) - 1u, r);\n }\n \n-fn make_random_fasta(id: str, desc: str, genelist: [aminoacids], n: int) {\n-    log(debug, \">\" + id + \" \" + desc);\n+fn make_random_fasta(wr: io::writer, id: str, desc: str, genelist: [aminoacids], n: int) {\n+    wr.write_line(\">\" + id + \" \" + desc);\n     let rng = @{mut last: std::rand::rng().next()};\n     let mut op: str = \"\";\n     for uint::range(0u, n as uint) {|_i|\n         str::push_char(op, select_random(myrandom_next(rng, 100u32),\n                                          genelist));\n         if str::len(op) >= LINE_LENGTH() {\n-            log(debug, op);\n+            wr.write_line(op);\n             op = \"\";\n         }\n     }\n-    if str::len(op) > 0u { log(debug, op); }\n+    if str::len(op) > 0u { wr.write_line(op); }\n }\n \n-fn make_repeat_fasta(id: str, desc: str, s: str, n: int) unsafe {\n-    log(debug, \">\" + id + \" \" + desc);\n+fn make_repeat_fasta(wr: io::writer, id: str, desc: str, s: str, n: int) unsafe {\n+    wr.write_line(\">\" + id + \" \" + desc);\n     let mut op: str = \"\";\n     let sl: uint = str::len(s);\n     for uint::range(0u, n as uint) {|i|\n         str::unsafe::push_byte(op, s[i % sl]);\n         if str::len(op) >= LINE_LENGTH() {\n-            log(debug, op);\n+            wr.write_line(op);\n             op = \"\";\n         }\n     }\n-    if str::len(op) > 0u { log(debug, op); }\n+    if str::len(op) > 0u { wr.write_line(op); }\n }\n \n fn acid(ch: char, prob: u32) -> aminoacids { ret {ch: ch, prob: prob}; }\n \n fn main(args: [str]) {\n     let args = if os::getenv(\"RUST_BENCH\").is_some() {\n+        // alioth tests k-nucleotide with this data at 25,000,000\n         [\"\", \"300000\"]\n     } else if args.len() <= 1u {\n         [\"\", \"1000\"]\n     } else {\n         args\n     };\n \n+    let writer = if os::getenv(\"RUST_BENCH\").is_some() {\n+        result::get(io::file_writer(\"./shootout-fasta.data\", [io::truncate, io::create]))\n+    } else {\n+        io::stdout()\n+    };\n+\n     let n = int::from_str(args[1]).get();\n \n     let iub: [aminoacids] =\n@@ -101,7 +109,8 @@ fn main(args: [str]) {\n             \"GCTACTCGGGAGGCTGAGGCAGGAGAATCGCTTGAACCCGGG\" +\n             \"AGGCGGAGGTTGCAGTGAGCCGAGATCGCGCCACTGCACTCC\" +\n             \"AGCCTGGGCGACAGAGCGAGACTCCGTCTCAAAAA\";\n-    make_repeat_fasta(\"ONE\", \"Homo sapiens alu\", alu, n * 2);\n-    make_random_fasta(\"TWO\", \"IUB ambiguity codes\", iub, n * 3);\n-    make_random_fasta(\"THREE\", \"Homo sapiens frequency\", homosapiens, n * 5);\n+    make_repeat_fasta(writer, \"ONE\", \"Homo sapiens alu\", alu, n * 2);\n+    make_random_fasta(writer, \"TWO\", \"IUB ambiguity codes\", iub, n * 3);\n+    make_random_fasta(writer, \"THREE\",\n+                      \"Homo sapiens frequency\", homosapiens, n * 5);\n }"}, {"sha": "4af3b95f0a04591b03d884d46400afc1832c7445", "filename": "src/test/bench/shootout-k-nucleotide.rs", "status": "added", "additions": 187, "deletions": 0, "changes": 187, "blob_url": "https://github.com/rust-lang/rust/blob/c2a9cc93944184b4f061c94fa346413ef6e7d813/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2a9cc93944184b4f061c94fa346413ef6e7d813/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs?ref=c2a9cc93944184b4f061c94fa346413ef6e7d813", "patch": "@@ -0,0 +1,187 @@\n+// multi tasking k-nucleotide\n+\n+import io::reader_util;\n+\n+use std;\n+import std::map;\n+import std::map::hashmap;\n+import std::sort;\n+\n+// given a map, print a sorted version of it\n+fn sort_and_fmt(mm: hashmap<[u8], uint>, total: uint) -> str { \n+   fn pct(xx: uint, yy: uint) -> float {\n+      ret (xx as float) * 100f / (yy as float);\n+   }\n+\n+   fn le_by_val<TT: copy, UU: copy>(kv0: (TT,UU), kv1: (TT,UU)) -> bool {\n+      let (_, v0) = kv0;\n+      let (_, v1) = kv1;\n+      ret v0 >= v1;\n+   }\n+\n+   fn le_by_key<TT: copy, UU: copy>(kv0: (TT,UU), kv1: (TT,UU)) -> bool {\n+      let (k0, _) = kv0;\n+      let (k1, _) = kv1;\n+      ret k0 <= k1;\n+   }\n+\n+   // sort by key, then by value\n+   fn sortKV<TT: copy, UU: copy>(orig: [(TT,UU)]) -> [(TT,UU)] {\n+      ret sort::merge_sort(le_by_val, sort::merge_sort(le_by_key, orig));\n+   }\n+\n+   let mut pairs = [];\n+\n+   // map -> [(k,%)]\n+   mm.each(fn&(key: [u8], val: uint) -> bool {\n+      pairs += [(key, pct(val, total))];\n+      ret true;\n+   });\n+\n+   let pairs_sorted = sortKV(pairs);\n+   \n+   let mut buffer = \"\";\n+\n+   pairs_sorted.each(fn&(kv: ([u8], float)) -> bool unsafe {\n+      let (k,v) = kv;\n+      buffer += (#fmt[\"%s %0.3f\\n\", str::to_upper(str::unsafe::from_bytes(k)), v]);\n+      ret true;\n+   });\n+\n+   ret buffer;\n+}\n+\n+// given a map, search for the frequency of a pattern\n+fn find(mm: hashmap<[u8], uint>, key: str) -> uint {\n+   alt mm.find(str::bytes(str::to_lower(key))) {\n+      option::none      { ret 0u; }\n+      option::some(num) { ret num; }\n+   }\n+}\n+\n+// given a map, increment the counter for a key\n+fn update_freq(mm: hashmap<[u8], uint>, key: [u8]) {\n+   alt mm.find(key) {\n+      option::none      { mm.insert(key, 1u      ); }\n+      option::some(val) { mm.insert(key, 1u + val); }\n+   }\n+}\n+\n+// given a [u8], for each window call a function\n+// i.e., for \"hello\" and windows of size four,\n+// run it(\"hell\") and it(\"ello\"), then return \"llo\"\n+fn windows_with_carry(bb: [const u8], nn: uint, it: fn(window: [u8])) -> [u8] {\n+   let mut ii = 0u;\n+\n+   let len = vec::len(bb);\n+   while ii < len - (nn - 1u) {\n+      it(vec::slice(bb, ii, ii+nn));\n+      ii += 1u;\n+   }\n+\n+   ret vec::slice(bb, len - (nn - 1u), len); \n+}\n+\n+fn make_sequence_processor(sz: uint, from_parent: comm::port<[u8]>, to_parent: comm::chan<str>) {\n+   \n+   let freqs: hashmap<[u8], uint> = map::bytes_hash();\n+   let mut carry: [u8] = [];\n+   let mut total: uint = 0u;\n+\n+   let mut line: [u8];\n+\n+   loop {\n+\n+      line = comm::recv(from_parent);\n+      if line == [] { break; }\n+\n+      carry = windows_with_carry(carry + line, sz, { |window|\n+         update_freq(freqs, window);\n+         total += 1u;\n+      });\n+   }\n+\n+   let buffer = alt sz { \n+       1u { sort_and_fmt(freqs, total) }\n+       2u { sort_and_fmt(freqs, total) }\n+       3u { #fmt[\"%u\\t%s\", find(freqs, \"GGT\"), \"GGT\"] }\n+       4u { #fmt[\"%u\\t%s\", find(freqs, \"GGTA\"), \"GGTA\"] }\n+       6u { #fmt[\"%u\\t%s\", find(freqs, \"GGTATT\"), \"GGTATT\"] }\n+      12u { #fmt[\"%u\\t%s\", find(freqs, \"GGTATTTTAATT\"), \"GGTATTTTAATT\"] }\n+      18u { #fmt[\"%u\\t%s\", find(freqs, \"GGTATTTTAATTTATAGT\"), \"GGTATTTTAATTTATAGT\"] }\n+        _ { \"\" }\n+   };\n+\n+   //comm::send(to_parent, #fmt[\"yay{%u}\", sz]);\n+   comm::send(to_parent, buffer);\n+}\n+\n+// given a FASTA file on stdin, process sequence THREE\n+fn main(args: [str]) {\n+   let rdr = if os::getenv(\"RUST_BENCH\").is_some() {\n+      result::get(io::file_reader(\"./shootout-fasta.data\"))\n+   } else {\n+      io::stdin()\n+   };\n+\n+\n+\n+   // initialize each sequence sorter\n+   let sizes = [1u,2u,3u,4u,6u,12u,18u];\n+   let from_child = vec::map (sizes, { |_sz|     comm::port() });\n+   let to_parent  = vec::mapi(sizes, { |ii, _sz| comm::chan(from_child[ii]) });\n+   let to_child   = vec::mapi(sizes, fn@(ii: uint, sz: uint) -> comm::chan<[u8]> {\n+      ret task::spawn_listener { |from_parent|\n+         make_sequence_processor(sz, from_parent, to_parent[ii]);\n+      };\n+   });\n+         \n+   \n+   // latch stores true after we've started\n+   // reading the sequence of interest\n+   let mut proc_mode = false;\n+\n+   while !rdr.eof() {\n+      let line: str = rdr.read_line();\n+\n+      if str::len(line) == 0u { cont; }\n+\n+      alt (line[0], proc_mode) {\n+\n+         // start processing if this is the one\n+         ('>' as u8, false) {\n+            alt str::find_str_from(line, \"THREE\", 1u) {\n+               option::some(_) { proc_mode = true; }\n+               option::none    { }\n+            }\n+         }\n+\n+         // break our processing\n+         ('>' as u8, true) { break; }\n+\n+         // process the sequence for k-mers\n+         (_, true) {\n+            let line_bytes = str::bytes(line);\n+\n+            for sizes.eachi { |ii, _sz|\n+               let mut lb = line_bytes;\n+               comm::send(to_child[ii], lb);\n+            }\n+         }\n+\n+         // whatever\n+         _ { }\n+      }\n+   }\n+\n+   // finish...\n+   for sizes.eachi { |ii, _sz|\n+      comm::send(to_child[ii], []);\n+   }\n+\n+   // now fetch and print result messages\n+   for sizes.eachi { |ii, _sz|\n+      io::println(comm::recv(from_child[ii]));\n+   }\n+}\n+"}]}