{"sha": "0ebfb8227c190609e80af3fb52b9813c4b282cc0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBlYmZiODIyN2MxOTA2MDllODBhZjNmYjUyYjk4MTNjNGIyODJjYzA=", "commit": {"author": {"name": "Brian Anderson", "email": "andersrb@gmail.com", "date": "2011-02-13T05:49:04Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-02-14T16:31:52Z"}, "message": "Add support for unsigned binops. Closes #57", "tree": {"sha": "c5cbe15ad6f58065d2d344d1fde83728c050a2d8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c5cbe15ad6f58065d2d344d1fde83728c050a2d8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0ebfb8227c190609e80af3fb52b9813c4b282cc0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0ebfb8227c190609e80af3fb52b9813c4b282cc0", "html_url": "https://github.com/rust-lang/rust/commit/0ebfb8227c190609e80af3fb52b9813c4b282cc0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0ebfb8227c190609e80af3fb52b9813c4b282cc0/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bd56dd9f2aca1967c92d3cc613dcc199c878026c", "url": "https://api.github.com/repos/rust-lang/rust/commits/bd56dd9f2aca1967c92d3cc613dcc199c878026c", "html_url": "https://github.com/rust-lang/rust/commit/bd56dd9f2aca1967c92d3cc613dcc199c878026c"}], "stats": {"total": 96, "additions": 80, "deletions": 16}, "files": [{"sha": "3457864cca75421d5812ea9996148ccebeb5b398", "filename": "src/Makefile", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ebfb8227c190609e80af3fb52b9813c4b282cc0/src%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/0ebfb8227c190609e80af3fb52b9813c4b282cc0/src%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FMakefile?ref=0ebfb8227c190609e80af3fb52b9813c4b282cc0", "patch": "@@ -408,6 +408,7 @@ TASK_XFAILS := test/run-pass/task-comm-8.rs \\\n TEST_XFAILS_BOOT :=  $(TASK_XFAILS) \\\n                     $(NOMINAL_TAG_XFAILS) \\\n                     $(CONST_TAG_XFAILS) \\\n+                    test/run-pass/arith-unsigned.rs \\\n                     test/run-pass/child-outlives-parent.rs \\\n                     test/run-pass/clone-with-exterior.rs \\\n                     test/run-pass/constrained-type.rs \\\n@@ -450,6 +451,7 @@ TEST_XFAILS_RUSTC := $(filter-out \\\n                         arith-0.rs \\\n                         arith-1.rs \\\n                         arith-2.rs \\\n+                        arith-unsigned.rs \\\n                         auto-instantiate.rs \\\n                         autoderef-full-lval.rs \\\n                         bind-exterior.rs \\"}, {"sha": "c1a4aa6f62a4e3f3b2e5e11356f3ea40335a9dff", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 54, "deletions": 16, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/0ebfb8227c190609e80af3fb52b9813c4b282cc0/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ebfb8227c190609e80af3fb52b9813c4b282cc0/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=0ebfb8227c190609e80af3fb52b9813c4b282cc0", "patch": "@@ -1840,33 +1840,67 @@ fn trans_unary(@block_ctxt cx, ast.unop op,\n \n // FIXME: implement proper structural comparison.\n \n-fn trans_compare(@block_ctxt cx, ast.binop op,\n+fn trans_compare(@block_ctxt cx, ast.binop op, @ty.t intype,\n                  ValueRef lhs, ValueRef rhs) -> ValueRef {\n     auto cmp = lib.llvm.LLVMIntEQ;\n     alt (op) {\n         case (ast.eq) { cmp = lib.llvm.LLVMIntEQ; }\n         case (ast.ne) { cmp = lib.llvm.LLVMIntNE; }\n \n-        // FIXME (issue #57): switch by signedness.\n-        case (ast.lt) { cmp = lib.llvm.LLVMIntSLT; }\n-        case (ast.le) { cmp = lib.llvm.LLVMIntSLE; }\n-        case (ast.ge) { cmp = lib.llvm.LLVMIntSGE; }\n-        case (ast.gt) { cmp = lib.llvm.LLVMIntSGT; }\n+        case (ast.lt) {\n+            if (ty.type_is_signed(intype)) {\n+                cmp = lib.llvm.LLVMIntSLT;\n+            } else {\n+                cmp = lib.llvm.LLVMIntULT;\n+            }\n+        }\n+        case (ast.le) {\n+            if (ty.type_is_signed(intype)) {\n+                cmp = lib.llvm.LLVMIntSLE;\n+            } else {\n+                cmp = lib.llvm.LLVMIntULE;\n+            }\n+        }\n+        case (ast.gt) {\n+            if (ty.type_is_signed(intype)) {\n+                cmp = lib.llvm.LLVMIntSGT;\n+            } else {\n+                cmp = lib.llvm.LLVMIntUGT;\n+            }\n+        }\n+        case (ast.ge) {\n+            if (ty.type_is_signed(intype)) {\n+                cmp = lib.llvm.LLVMIntSGE;\n+            } else {\n+                cmp = lib.llvm.LLVMIntUGE;\n+            }\n+        }\n     }\n     ret cx.build.ICmp(cmp, lhs, rhs);\n }\n \n-fn trans_eager_binop(@block_ctxt cx, ast.binop op,\n+fn trans_eager_binop(@block_ctxt cx, ast.binop op, @ty.t intype,\n                      ValueRef lhs, ValueRef rhs) -> ValueRef {\n \n     alt (op) {\n         case (ast.add) { ret cx.build.Add(lhs, rhs); }\n         case (ast.sub) { ret cx.build.Sub(lhs, rhs); }\n \n-        // FIXME (issue #57): switch by signedness.\n         case (ast.mul) { ret cx.build.Mul(lhs, rhs); }\n-        case (ast.div) { ret cx.build.SDiv(lhs, rhs); }\n-        case (ast.rem) { ret cx.build.SRem(lhs, rhs); }\n+        case (ast.div) {\n+            if (ty.type_is_signed(intype)) {\n+                ret cx.build.SDiv(lhs, rhs);\n+            } else {\n+                ret cx.build.UDiv(lhs, rhs);\n+            }\n+        }\n+        case (ast.rem) {\n+            if (ty.type_is_signed(intype)) {\n+                ret cx.build.SRem(lhs, rhs);\n+            } else {\n+                ret cx.build.URem(lhs, rhs);\n+            }\n+        }\n \n         case (ast.bitor) { ret cx.build.Or(lhs, rhs); }\n         case (ast.bitand) { ret cx.build.And(lhs, rhs); }\n@@ -1875,7 +1909,7 @@ fn trans_eager_binop(@block_ctxt cx, ast.binop op,\n         case (ast.lsr) { ret cx.build.LShr(lhs, rhs); }\n         case (ast.asr) { ret cx.build.AShr(lhs, rhs); }\n         case (_) {\n-            ret trans_compare(cx, op, lhs, rhs);\n+            ret trans_compare(cx, op, intype, lhs, rhs);\n         }\n     }\n     fail;\n@@ -1950,10 +1984,12 @@ fn trans_binary(@block_ctxt cx, ast.binop op,\n         case (_) {\n             // Remaining cases are eager:\n             auto lhs = trans_expr(cx, a);\n-            lhs = autoderef(lhs.bcx, lhs.val, ty.expr_ty(a));\n+            auto lhty = ty.expr_ty(a);\n+            lhs = autoderef(lhs.bcx, lhs.val, lhty);\n             auto rhs = trans_expr(lhs.bcx, b);\n-            rhs = autoderef(rhs.bcx, rhs.val, ty.expr_ty(b));\n-            ret res(rhs.bcx, trans_eager_binop(rhs.bcx, op,\n+            auto rhty = ty.expr_ty(b);\n+            rhs = autoderef(rhs.bcx, rhs.val, rhty);\n+            ret res(rhs.bcx, trans_eager_binop(rhs.bcx, op, lhty,\n                                                lhs.val, rhs.val));\n         }\n     }\n@@ -2142,7 +2178,8 @@ fn trans_pat_match(@block_ctxt cx, @ast.pat pat, ValueRef llval,\n \n         case (ast.pat_lit(?lt, ?ann)) {\n             auto lllit = trans_lit(cx.fcx.ccx, *lt, ann);\n-            auto lleq = trans_compare(cx, ast.eq, llval, lllit);\n+            auto lltype = ty.ann_to_type(ann);\n+            auto lleq = trans_compare(cx, ast.eq, lltype, llval, lllit);\n \n             auto matched_cx = new_sub_block_ctxt(cx, \"matched_cx\");\n             cx.build.CondBr(lleq, matched_cx.llbb, next_cx.llbb);\n@@ -3035,7 +3072,8 @@ fn trans_expr(@block_ctxt cx, @ast.expr e) -> result {\n             auto lhs_val = load_scalar_or_boxed(lhs_res.res.bcx,\n                                                 lhs_res.res.val, t);\n             auto rhs_res = trans_expr(lhs_res.res.bcx, src);\n-            auto v = trans_eager_binop(rhs_res.bcx, op, lhs_val, rhs_res.val);\n+            auto v = trans_eager_binop(rhs_res.bcx, op, t,\n+                                       lhs_val, rhs_res.val);\n             // FIXME: calculate copy init-ness in typestate.\n             ret copy_ty(rhs_res.bcx, DROP_EXISTING,\n                         lhs_res.res.val, v, t);"}, {"sha": "3fac37142f80a95fbac221de2686b67af2568d3d", "filename": "src/test/run-pass/arith-unsigned.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/0ebfb8227c190609e80af3fb52b9813c4b282cc0/src%2Ftest%2Frun-pass%2Farith-unsigned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ebfb8227c190609e80af3fb52b9813c4b282cc0/src%2Ftest%2Frun-pass%2Farith-unsigned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Farith-unsigned.rs?ref=0ebfb8227c190609e80af3fb52b9813c4b282cc0", "patch": "@@ -0,0 +1,24 @@\n+// Unsigned integer operations\n+\n+fn main() {\n+  check (0u8 < 255u8);\n+  check (0u8 <= 255u8);\n+  check (255u8 > 0u8);\n+  check (255u8 >= 0u8);\n+  check (250u8 / 10u8 == 25u8);\n+  check (255u8 % 10u8 == 5u8);\n+  check (0u16 < 60000u16);\n+  check (0u16 <= 60000u16);\n+  check (60000u16 > 0u16);\n+  check (60000u16 >= 0u16);\n+  check (60000u16 / 10u16 == 6000u16);\n+  check (60005u16 % 10u16 == 5u16);\n+  check (0u32 < 4000000000u32);\n+  check (0u32 <= 4000000000u32);\n+  check (4000000000u32 > 0u32);\n+  check (4000000000u32 >= 0u32);\n+  check (4000000000u32 / 10u32 == 400000000u32);\n+  check (4000000005u32 % 10u32 == 5u32);\n+\n+  // 64-bit numbers have some flakiness yet. Not tested\n+}"}]}