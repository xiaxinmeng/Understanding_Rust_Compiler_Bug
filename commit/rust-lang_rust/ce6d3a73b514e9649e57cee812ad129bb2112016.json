{"sha": "ce6d3a73b514e9649e57cee812ad129bb2112016", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNlNmQzYTczYjUxNGU5NjQ5ZTU3Y2VlODEyYWQxMjliYjIxMTIwMTY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-06-15T04:10:24Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-06-15T04:10:24Z"}, "message": "Auto merge of #72080 - matthewjasper:uniform-impl-trait, r=nikomatsakis\n\nClean up type alias impl trait implementation\n\n- Removes special case for top-level impl trait\n- Removes associated opaque types\n- Forbid lifetime elision in let position impl trait. This is consistent with the behavior for inferred types.\n- Handle lifetimes in type alias impl trait more uniformly with other parameters\n\ncc #69323\ncc #63063\nCloses #57188\nCloses #62988\nCloses #69136\nCloses #73061", "tree": {"sha": "39b78deb20d2b50a0eaec85d605bb015e6cfa35a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/39b78deb20d2b50a0eaec85d605bb015e6cfa35a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ce6d3a73b514e9649e57cee812ad129bb2112016", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ce6d3a73b514e9649e57cee812ad129bb2112016", "html_url": "https://github.com/rust-lang/rust/commit/ce6d3a73b514e9649e57cee812ad129bb2112016", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ce6d3a73b514e9649e57cee812ad129bb2112016/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4fb54ed484e2239a3e9eff3be17df00d2a162be3", "url": "https://api.github.com/repos/rust-lang/rust/commits/4fb54ed484e2239a3e9eff3be17df00d2a162be3", "html_url": "https://github.com/rust-lang/rust/commit/4fb54ed484e2239a3e9eff3be17df00d2a162be3"}, {"sha": "8b10d42ebe7843bcaed58dcbbc8836a0f27b54c9", "url": "https://api.github.com/repos/rust-lang/rust/commits/8b10d42ebe7843bcaed58dcbbc8836a0f27b54c9", "html_url": "https://github.com/rust-lang/rust/commit/8b10d42ebe7843bcaed58dcbbc8836a0f27b54c9"}], "stats": {"total": 1774, "additions": 923, "deletions": 851}, "files": [{"sha": "62406552e318f1e6a7b07905a5db01acfd2fb0b0", "filename": "src/librustc_ast/ast.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Flibrustc_ast%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Flibrustc_ast%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast%2Fast.rs?ref=ce6d3a73b514e9649e57cee812ad129bb2112016", "patch": "@@ -1860,15 +1860,6 @@ impl TyKind {\n     pub fn is_unit(&self) -> bool {\n         if let TyKind::Tup(ref tys) = *self { tys.is_empty() } else { false }\n     }\n-\n-    /// HACK(type_alias_impl_trait, Centril): A temporary crutch used\n-    /// in lowering to avoid making larger changes there and beyond.\n-    pub fn opaque_top_hack(&self) -> Option<&GenericBounds> {\n-        match self {\n-            Self::ImplTrait(_, bounds) => Some(bounds),\n-            _ => None,\n-        }\n-    }\n }\n \n /// Syntax used to declare a trait object."}, {"sha": "8cfbd408e22b3878078f479eb88d249a2cfd929c", "filename": "src/librustc_ast_lowering/item.rs", "status": "modified", "additions": 38, "deletions": 42, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Flibrustc_ast_lowering%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Flibrustc_ast_lowering%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_lowering%2Fitem.rs?ref=ce6d3a73b514e9649e57cee812ad129bb2112016", "patch": "@@ -1,12 +1,13 @@\n use super::{AnonymousLifetimeMode, LoweringContext, ParamMode};\n-use super::{ImplTraitContext, ImplTraitPosition, ImplTraitTypeIdVisitor};\n+use super::{ImplTraitContext, ImplTraitPosition};\n use crate::Arena;\n \n use rustc_ast::ast::*;\n use rustc_ast::attr;\n use rustc_ast::node_id::NodeMap;\n use rustc_ast::ptr::P;\n use rustc_ast::visit::{self, AssocCtxt, Visitor};\n+use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n@@ -165,13 +166,6 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             }\n             ItemKind::MacroDef(..) => SmallVec::new(),\n             ItemKind::Fn(..) | ItemKind::Impl { of_trait: None, .. } => smallvec![i.id],\n-            ItemKind::Static(ref ty, ..) | ItemKind::Const(_, ref ty, ..) => {\n-                let mut ids = smallvec![i.id];\n-                if self.sess.features_untracked().impl_trait_in_bindings {\n-                    ImplTraitTypeIdVisitor { ids: &mut ids }.visit_ty(ty);\n-                }\n-                ids\n-            }\n             _ => smallvec![i.id],\n         };\n \n@@ -292,23 +286,25 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             ItemKind::Mod(ref m) => hir::ItemKind::Mod(self.lower_mod(m)),\n             ItemKind::ForeignMod(ref nm) => hir::ItemKind::ForeignMod(self.lower_foreign_mod(nm)),\n             ItemKind::GlobalAsm(ref ga) => hir::ItemKind::GlobalAsm(self.lower_global_asm(ga)),\n-            ItemKind::TyAlias(_, ref gen, _, Some(ref ty)) => match ty.kind.opaque_top_hack() {\n-                None => {\n-                    let ty = self.lower_ty(ty, ImplTraitContext::disallowed());\n-                    let generics = self.lower_generics(gen, ImplTraitContext::disallowed());\n-                    hir::ItemKind::TyAlias(ty, generics)\n-                }\n-                Some(bounds) => {\n-                    let ctx = || ImplTraitContext::OpaqueTy(None, hir::OpaqueTyOrigin::Misc);\n-                    let ty = hir::OpaqueTy {\n-                        generics: self.lower_generics(gen, ctx()),\n-                        bounds: self.lower_param_bounds(bounds, ctx()),\n-                        impl_trait_fn: None,\n-                        origin: hir::OpaqueTyOrigin::TypeAlias,\n-                    };\n-                    hir::ItemKind::OpaqueTy(ty)\n-                }\n-            },\n+            ItemKind::TyAlias(_, ref gen, _, Some(ref ty)) => {\n+                // We lower\n+                //\n+                // type Foo = impl Trait\n+                //\n+                // to\n+                //\n+                // type Foo = Foo1\n+                // opaque type Foo1: Trait\n+                let ty = self.lower_ty(\n+                    ty,\n+                    ImplTraitContext::OtherOpaqueTy {\n+                        capturable_lifetimes: &mut FxHashSet::default(),\n+                        origin: hir::OpaqueTyOrigin::Misc,\n+                    },\n+                );\n+                let generics = self.lower_generics(gen, ImplTraitContext::disallowed());\n+                hir::ItemKind::TyAlias(ty, generics)\n+            }\n             ItemKind::TyAlias(_, ref generics, _, None) => {\n                 let ty = self.arena.alloc(self.ty(span, hir::TyKind::Err));\n                 let generics = self.lower_generics(generics, ImplTraitContext::disallowed());\n@@ -438,8 +434,13 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         span: Span,\n         body: Option<&Expr>,\n     ) -> (&'hir hir::Ty<'hir>, hir::BodyId) {\n+        let mut capturable_lifetimes;\n         let itctx = if self.sess.features_untracked().impl_trait_in_bindings {\n-            ImplTraitContext::OpaqueTy(None, hir::OpaqueTyOrigin::Misc)\n+            capturable_lifetimes = FxHashSet::default();\n+            ImplTraitContext::OtherOpaqueTy {\n+                capturable_lifetimes: &mut capturable_lifetimes,\n+                origin: hir::OpaqueTyOrigin::Misc,\n+            }\n         } else {\n             ImplTraitContext::Disallowed(ImplTraitPosition::Binding)\n         };\n@@ -844,16 +845,16 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                         let ty = self.arena.alloc(self.ty(i.span, hir::TyKind::Err));\n                         hir::ImplItemKind::TyAlias(ty)\n                     }\n-                    Some(ty) => match ty.kind.opaque_top_hack() {\n-                        None => {\n-                            let ty = self.lower_ty(ty, ImplTraitContext::disallowed());\n-                            hir::ImplItemKind::TyAlias(ty)\n-                        }\n-                        Some(bs) => {\n-                            let bs = self.lower_param_bounds(bs, ImplTraitContext::disallowed());\n-                            hir::ImplItemKind::OpaqueTy(bs)\n-                        }\n-                    },\n+                    Some(ty) => {\n+                        let ty = self.lower_ty(\n+                            ty,\n+                            ImplTraitContext::OtherOpaqueTy {\n+                                capturable_lifetimes: &mut FxHashSet::default(),\n+                                origin: hir::OpaqueTyOrigin::Misc,\n+                            },\n+                        );\n+                        hir::ImplItemKind::TyAlias(ty)\n+                    }\n                 };\n                 (generics, kind)\n             }\n@@ -887,12 +888,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             defaultness,\n             kind: match &i.kind {\n                 AssocItemKind::Const(..) => hir::AssocItemKind::Const,\n-                AssocItemKind::TyAlias(.., ty) => {\n-                    match ty.as_deref().and_then(|ty| ty.kind.opaque_top_hack()) {\n-                        None => hir::AssocItemKind::Type,\n-                        Some(_) => hir::AssocItemKind::OpaqueTy,\n-                    }\n-                }\n+                AssocItemKind::TyAlias(..) => hir::AssocItemKind::Type,\n                 AssocItemKind::Fn(_, sig, ..) => {\n                     hir::AssocItemKind::Fn { has_self: sig.decl.has_self() }\n                 }"}, {"sha": "d7946ad009415cfab41058a8dc7e893bc057f20e", "filename": "src/librustc_ast_lowering/lib.rs", "status": "modified", "additions": 120, "deletions": 28, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Flibrustc_ast_lowering%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Flibrustc_ast_lowering%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_lowering%2Flib.rs?ref=ce6d3a73b514e9649e57cee812ad129bb2112016", "patch": "@@ -224,11 +224,30 @@ enum ImplTraitContext<'b, 'a> {\n     /// Example: `fn foo() -> impl Debug`, where `impl Debug` is conceptually\n     /// equivalent to a new opaque type like `type T = impl Debug; fn foo() -> T`.\n     ///\n-    /// We optionally store a `DefId` for the parent item here so we can look up necessary\n-    /// information later. It is `None` when no information about the context should be stored\n-    /// (e.g., for consts and statics).\n-    OpaqueTy(Option<DefId> /* fn def-ID */, hir::OpaqueTyOrigin),\n-\n+    ReturnPositionOpaqueTy {\n+        /// `DefId` for the parent function, used to look up necessary\n+        /// information later.\n+        fn_def_id: DefId,\n+        /// Origin: Either OpaqueTyOrigin::FnReturn or OpaqueTyOrigin::AsyncFn,\n+        origin: hir::OpaqueTyOrigin,\n+    },\n+    /// Impl trait in type aliases, consts and statics.\n+    OtherOpaqueTy {\n+        /// Set of lifetimes that this opaque type can capture, if it uses\n+        /// them. This includes lifetimes bound since we entered this context.\n+        /// For example, in\n+        ///\n+        /// type A<'b> = impl for<'a> Trait<'a, Out = impl Sized + 'a>;\n+        ///\n+        /// the inner opaque type captures `'a` because it uses it. It doesn't\n+        /// need to capture `'b` because it already inherits the lifetime\n+        /// parameter from `A`.\n+        // FIXME(impl_trait): but `required_region_bounds` will ICE later\n+        // anyway.\n+        capturable_lifetimes: &'b mut FxHashSet<hir::LifetimeName>,\n+        /// Origin: Either OpaqueTyOrigin::Misc or OpaqueTyOrigin::Binding,\n+        origin: hir::OpaqueTyOrigin,\n+    },\n     /// `impl Trait` is not accepted in this position.\n     Disallowed(ImplTraitPosition),\n }\n@@ -253,7 +272,12 @@ impl<'a> ImplTraitContext<'_, 'a> {\n         use self::ImplTraitContext::*;\n         match self {\n             Universal(params) => Universal(params),\n-            OpaqueTy(fn_def_id, origin) => OpaqueTy(*fn_def_id, *origin),\n+            ReturnPositionOpaqueTy { fn_def_id, origin } => {\n+                ReturnPositionOpaqueTy { fn_def_id: *fn_def_id, origin: *origin }\n+            }\n+            OtherOpaqueTy { capturable_lifetimes, origin } => {\n+                OtherOpaqueTy { capturable_lifetimes, origin: *origin }\n+            }\n             Disallowed(pos) => Disallowed(*pos),\n         }\n     }\n@@ -1001,6 +1025,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 hir::TypeBindingKind::Equality { ty: self.lower_ty(ty, itctx) }\n             }\n             AssocTyConstraintKind::Bound { ref bounds } => {\n+                let mut capturable_lifetimes;\n                 // Piggy-back on the `impl Trait` context to figure out the correct behavior.\n                 let (desugar_to_impl_trait, itctx) = match itctx {\n                     // We are in the return position:\n@@ -1010,7 +1035,8 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     // so desugar to\n                     //\n                     //     fn foo() -> impl Iterator<Item = impl Debug>\n-                    ImplTraitContext::OpaqueTy(..) => (true, itctx),\n+                    ImplTraitContext::ReturnPositionOpaqueTy { .. }\n+                    | ImplTraitContext::OtherOpaqueTy { .. } => (true, itctx),\n \n                     // We are in the argument position, but within a dyn type:\n                     //\n@@ -1028,7 +1054,14 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     //\n                     // FIXME: this is only needed until `impl Trait` is allowed in type aliases.\n                     ImplTraitContext::Disallowed(_) if self.is_in_dyn_type => {\n-                        (true, ImplTraitContext::OpaqueTy(None, hir::OpaqueTyOrigin::Misc))\n+                        capturable_lifetimes = FxHashSet::default();\n+                        (\n+                            true,\n+                            ImplTraitContext::OtherOpaqueTy {\n+                                capturable_lifetimes: &mut capturable_lifetimes,\n+                                origin: hir::OpaqueTyOrigin::Misc,\n+                            },\n+                        )\n                     }\n \n                     // We are in the parameter position, but not within a dyn type:\n@@ -1270,10 +1303,31 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             TyKind::ImplTrait(def_node_id, ref bounds) => {\n                 let span = t.span;\n                 match itctx {\n-                    ImplTraitContext::OpaqueTy(fn_def_id, origin) => {\n-                        self.lower_opaque_impl_trait(span, fn_def_id, origin, def_node_id, |this| {\n-                            this.lower_param_bounds(bounds, itctx)\n-                        })\n+                    ImplTraitContext::ReturnPositionOpaqueTy { fn_def_id, origin } => self\n+                        .lower_opaque_impl_trait(\n+                            span,\n+                            Some(fn_def_id),\n+                            origin,\n+                            def_node_id,\n+                            None,\n+                            |this| this.lower_param_bounds(bounds, itctx),\n+                        ),\n+                    ImplTraitContext::OtherOpaqueTy { ref capturable_lifetimes, origin } => {\n+                        // Reset capturable lifetimes, any nested impl trait\n+                        // types will inherit lifetimes from this opaque type,\n+                        // so don't need to capture them again.\n+                        let nested_itctx = ImplTraitContext::OtherOpaqueTy {\n+                            capturable_lifetimes: &mut FxHashSet::default(),\n+                            origin,\n+                        };\n+                        self.lower_opaque_impl_trait(\n+                            span,\n+                            None,\n+                            origin,\n+                            def_node_id,\n+                            Some(capturable_lifetimes),\n+                            |this| this.lower_param_bounds(bounds, nested_itctx),\n+                        )\n                     }\n                     ImplTraitContext::Universal(in_band_ty_params) => {\n                         // Add a definition for the in-band `Param`.\n@@ -1351,6 +1405,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         fn_def_id: Option<DefId>,\n         origin: hir::OpaqueTyOrigin,\n         opaque_ty_node_id: NodeId,\n+        capturable_lifetimes: Option<&FxHashSet<hir::LifetimeName>>,\n         lower_bounds: impl FnOnce(&mut Self) -> hir::GenericBounds<'hir>,\n     ) -> hir::TyKind<'hir> {\n         debug!(\n@@ -1371,12 +1426,16 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n \n         let hir_bounds = self.with_hir_id_owner(opaque_ty_node_id, lower_bounds);\n \n-        let (lifetimes, lifetime_defs) =\n-            self.lifetimes_from_impl_trait_bounds(opaque_ty_node_id, opaque_ty_def_id, &hir_bounds);\n+        let (lifetimes, lifetime_defs) = self.lifetimes_from_impl_trait_bounds(\n+            opaque_ty_node_id,\n+            opaque_ty_def_id,\n+            &hir_bounds,\n+            capturable_lifetimes,\n+        );\n \n-        debug!(\"lower_opaque_impl_trait: lifetimes={:#?}\", lifetimes,);\n+        debug!(\"lower_opaque_impl_trait: lifetimes={:#?}\", lifetimes);\n \n-        debug!(\"lower_opaque_impl_trait: lifetime_defs={:#?}\", lifetime_defs,);\n+        debug!(\"lower_opaque_impl_trait: lifetime_defs={:#?}\", lifetime_defs);\n \n         self.with_hir_id_owner(opaque_ty_node_id, move |lctx| {\n             let opaque_ty_item = hir::OpaqueTy {\n@@ -1395,7 +1454,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 lctx.generate_opaque_type(opaque_ty_node_id, opaque_ty_item, span, opaque_ty_span);\n \n             // `impl Trait` now just becomes `Foo<'a, 'b, ..>`.\n-            hir::TyKind::Def(hir::ItemId { id: opaque_ty_id }, lifetimes)\n+            hir::TyKind::OpaqueDef(hir::ItemId { id: opaque_ty_id }, lifetimes)\n         })\n     }\n \n@@ -1433,6 +1492,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         opaque_ty_id: NodeId,\n         parent_def_id: LocalDefId,\n         bounds: hir::GenericBounds<'hir>,\n+        lifetimes_to_include: Option<&FxHashSet<hir::LifetimeName>>,\n     ) -> (&'hir [hir::GenericArg<'hir>], &'hir [hir::GenericParam<'hir>]) {\n         debug!(\n             \"lifetimes_from_impl_trait_bounds(opaque_ty_id={:?}, \\\n@@ -1453,6 +1513,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             already_defined_lifetimes: FxHashSet<hir::LifetimeName>,\n             output_lifetimes: Vec<hir::GenericArg<'hir>>,\n             output_lifetime_params: Vec<hir::GenericParam<'hir>>,\n+            lifetimes_to_include: Option<&'r FxHashSet<hir::LifetimeName>>,\n         }\n \n         impl<'r, 'a, 'v, 'hir> intravisit::Visitor<'v> for ImplTraitLifetimeCollector<'r, 'a, 'hir> {\n@@ -1538,6 +1599,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n \n                 if !self.currently_bound_lifetimes.contains(&name)\n                     && !self.already_defined_lifetimes.contains(&name)\n+                    && self.lifetimes_to_include.map_or(true, |lifetimes| lifetimes.contains(&name))\n                 {\n                     self.already_defined_lifetimes.insert(name);\n \n@@ -1591,6 +1653,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             already_defined_lifetimes: FxHashSet::default(),\n             output_lifetimes: Vec::new(),\n             output_lifetime_params: Vec::new(),\n+            lifetimes_to_include,\n         };\n \n         for bound in bounds {\n@@ -1614,15 +1677,16 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 visitor.visit_ty(ty);\n             }\n         }\n-        let parent_def_id = self.current_hir_id_owner.last().unwrap().0;\n         let ty = l.ty.as_ref().map(|t| {\n+            let mut capturable_lifetimes;\n             self.lower_ty(\n                 t,\n                 if self.sess.features_untracked().impl_trait_in_bindings {\n-                    ImplTraitContext::OpaqueTy(\n-                        Some(parent_def_id.to_def_id()),\n-                        hir::OpaqueTyOrigin::Misc,\n-                    )\n+                    capturable_lifetimes = FxHashSet::default();\n+                    ImplTraitContext::OtherOpaqueTy {\n+                        capturable_lifetimes: &mut capturable_lifetimes,\n+                        origin: hir::OpaqueTyOrigin::Binding,\n+                    }\n                 } else {\n                     ImplTraitContext::Disallowed(ImplTraitPosition::Binding)\n                 },\n@@ -1725,7 +1789,10 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 FnRetTy::Ty(ref ty) => {\n                     let context = match in_band_ty_params {\n                         Some((def_id, _)) if impl_trait_return_allow => {\n-                            ImplTraitContext::OpaqueTy(Some(def_id), hir::OpaqueTyOrigin::FnReturn)\n+                            ImplTraitContext::ReturnPositionOpaqueTy {\n+                                fn_def_id: def_id,\n+                                origin: hir::OpaqueTyOrigin::FnReturn,\n+                            }\n                         }\n                         _ => ImplTraitContext::disallowed(),\n                     };\n@@ -1944,7 +2011,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         // Foo = impl Trait` is, internally, created as a child of the\n         // async fn, so the *type parameters* are inherited.  It's\n         // only the lifetime parameters that we must supply.\n-        let opaque_ty_ref = hir::TyKind::Def(hir::ItemId { id: opaque_ty_id }, generic_args);\n+        let opaque_ty_ref = hir::TyKind::OpaqueDef(hir::ItemId { id: opaque_ty_id }, generic_args);\n         let opaque_ty = self.ty(opaque_ty_span, opaque_ty_ref);\n         hir::FnRetTy::Return(self.arena.alloc(opaque_ty))\n     }\n@@ -1962,8 +2029,10 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 // Not `OpaqueTyOrigin::AsyncFn`: that's only used for the\n                 // `impl Future` opaque type that `async fn` implicitly\n                 // generates.\n-                let context =\n-                    ImplTraitContext::OpaqueTy(Some(fn_def_id), hir::OpaqueTyOrigin::FnReturn);\n+                let context = ImplTraitContext::ReturnPositionOpaqueTy {\n+                    fn_def_id,\n+                    origin: hir::OpaqueTyOrigin::FnReturn,\n+                };\n                 self.lower_ty(ty, context)\n             }\n             FnRetTy::Default(ret_ty_span) => self.arena.alloc(self.ty_tup(*ret_ty_span, &[])),\n@@ -2113,7 +2182,10 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     default: default.as_ref().map(|x| {\n                         self.lower_ty(\n                             x,\n-                            ImplTraitContext::OpaqueTy(None, hir::OpaqueTyOrigin::Misc),\n+                            ImplTraitContext::OtherOpaqueTy {\n+                                capturable_lifetimes: &mut FxHashSet::default(),\n+                                origin: hir::OpaqueTyOrigin::Misc,\n+                            },\n                         )\n                     }),\n                     synthetic: param\n@@ -2169,8 +2241,28 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             &NodeMap::default(),\n             itctx.reborrow(),\n         );\n+\n         let trait_ref = self.with_in_scope_lifetime_defs(&p.bound_generic_params, |this| {\n-            this.lower_trait_ref(&p.trait_ref, itctx)\n+            // Any impl Trait types defined within this scope can capture\n+            // lifetimes bound on this predicate.\n+            let lt_def_names = p.bound_generic_params.iter().filter_map(|param| match param.kind {\n+                GenericParamKind::Lifetime { .. } => Some(hir::LifetimeName::Param(\n+                    ParamName::Plain(param.ident.normalize_to_macros_2_0()),\n+                )),\n+                _ => None,\n+            });\n+            if let ImplTraitContext::OtherOpaqueTy { ref mut capturable_lifetimes, .. } = itctx {\n+                capturable_lifetimes.extend(lt_def_names.clone());\n+            }\n+\n+            let res = this.lower_trait_ref(&p.trait_ref, itctx.reborrow());\n+\n+            if let ImplTraitContext::OtherOpaqueTy { ref mut capturable_lifetimes, .. } = itctx {\n+                for param in lt_def_names {\n+                    capturable_lifetimes.remove(&param);\n+                }\n+            }\n+            res\n         });\n \n         hir::PolyTraitRef { bound_generic_params, trait_ref, span: p.span }"}, {"sha": "af1860ca6bfea962a2f7a96b651aed60f8f5fcf2", "filename": "src/librustc_hir/def.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Flibrustc_hir%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Flibrustc_hir%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Fdef.rs?ref=ce6d3a73b514e9649e57cee812ad129bb2112016", "patch": "@@ -54,15 +54,11 @@ pub enum DefKind {\n     /// Refers to the variant itself, `DefKind::Ctor` refers to its constructor if it exists.\n     Variant,\n     Trait,\n-    /// `type Foo = impl Bar;`\n-    OpaqueTy,\n     /// `type Foo = Bar;`\n     TyAlias,\n     ForeignTy,\n     TraitAlias,\n     AssocTy,\n-    /// `type Foo = impl Bar;`\n-    AssocOpaqueTy,\n     TyParam,\n \n     // Value namespace\n@@ -83,6 +79,7 @@ pub enum DefKind {\n     Use,\n     ForeignMod,\n     AnonConst,\n+    OpaqueTy,\n     Field,\n     LifetimeParam,\n     GlobalAsm,\n@@ -115,7 +112,6 @@ impl DefKind {\n             DefKind::TyAlias => \"type alias\",\n             DefKind::TraitAlias => \"trait alias\",\n             DefKind::AssocTy => \"associated type\",\n-            DefKind::AssocOpaqueTy => \"associated opaque type\",\n             DefKind::Union => \"union\",\n             DefKind::Trait => \"trait\",\n             DefKind::ForeignTy => \"foreign type\",\n@@ -143,7 +139,6 @@ impl DefKind {\n         match *self {\n             DefKind::AssocTy\n             | DefKind::AssocConst\n-            | DefKind::AssocOpaqueTy\n             | DefKind::AssocFn\n             | DefKind::Enum\n             | DefKind::OpaqueTy\n@@ -168,7 +163,6 @@ impl DefKind {\n             | DefKind::ForeignTy\n             | DefKind::TraitAlias\n             | DefKind::AssocTy\n-            | DefKind::AssocOpaqueTy\n             | DefKind::TyParam => ns == Namespace::TypeNS,\n \n             DefKind::Fn"}, {"sha": "634ab32a285427f04902a80c12fa165e84b01282", "filename": "src/librustc_hir/hir.rs", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Flibrustc_hir%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Flibrustc_hir%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Fhir.rs?ref=ce6d3a73b514e9649e57cee812ad129bb2112016", "patch": "@@ -1921,14 +1921,12 @@ pub enum ImplItemKind<'hir> {\n     Fn(FnSig<'hir>, BodyId),\n     /// An associated type.\n     TyAlias(&'hir Ty<'hir>),\n-    /// An associated `type = impl Trait`.\n-    OpaqueTy(GenericBounds<'hir>),\n }\n \n impl ImplItemKind<'_> {\n     pub fn namespace(&self) -> Namespace {\n         match self {\n-            ImplItemKind::OpaqueTy(..) | ImplItemKind::TyAlias(..) => Namespace::TypeNS,\n+            ImplItemKind::TyAlias(..) => Namespace::TypeNS,\n             ImplItemKind::Const(..) | ImplItemKind::Fn(..) => Namespace::ValueNS,\n         }\n     }\n@@ -2018,13 +2016,13 @@ pub struct OpaqueTy<'hir> {\n /// From whence the opaque type came.\n #[derive(Copy, Clone, RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n pub enum OpaqueTyOrigin {\n-    /// `type Foo = impl Trait;`\n-    TypeAlias,\n     /// `-> impl Trait`\n     FnReturn,\n     /// `async fn`\n     AsyncFn,\n-    /// Impl trait in bindings, consts, statics, bounds.\n+    /// `let _: impl Trait = ...`\n+    Binding,\n+    /// Impl trait in type aliases, consts, statics, bounds.\n     Misc,\n }\n \n@@ -2050,12 +2048,12 @@ pub enum TyKind<'hir> {\n     ///\n     /// Type parameters may be stored in each `PathSegment`.\n     Path(QPath<'hir>),\n-    /// A type definition itself. This is currently only used for the `type Foo = impl Trait`\n-    /// item that `impl Trait` in return position desugars to.\n+    /// A opaque type definition itself. This is currently only used for the\n+    /// `opaque type Foo: Trait` item that `impl Trait` in desugars to.\n     ///\n-    /// The generic argument list contains the lifetimes (and in the future possibly parameters)\n-    /// that are actually bound on the `impl Trait`.\n-    Def(ItemId, &'hir [GenericArg<'hir>]),\n+    /// The generic argument list contains the lifetimes (and in the future\n+    /// possibly parameters) that are actually bound on the `impl Trait`.\n+    OpaqueDef(ItemId, &'hir [GenericArg<'hir>]),\n     /// A trait object type `Bound1 + Bound2 + Bound3`\n     /// where `Bound` is a trait or a lifetime.\n     TraitObject(&'hir [PolyTraitRef<'hir>], Lifetime),\n@@ -2616,7 +2614,6 @@ pub enum AssocItemKind {\n     Const,\n     Fn { has_self: bool },\n     Type,\n-    OpaqueTy,\n }\n \n #[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]"}, {"sha": "23d642731da4db4ce1f754596551b4a7dd01dcf8", "filename": "src/librustc_hir/intravisit.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Flibrustc_hir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Flibrustc_hir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Fintravisit.rs?ref=ce6d3a73b514e9649e57cee812ad129bb2112016", "patch": "@@ -690,7 +690,7 @@ pub fn walk_ty<'v, V: Visitor<'v>>(visitor: &mut V, typ: &'v Ty<'v>) {\n         TyKind::Path(ref qpath) => {\n             visitor.visit_qpath(qpath, typ.hir_id, typ.span);\n         }\n-        TyKind::Def(item_id, lifetimes) => {\n+        TyKind::OpaqueDef(item_id, lifetimes) => {\n             visitor.visit_nested_item(item_id);\n             walk_list!(visitor, visit_generic_arg, lifetimes);\n         }\n@@ -1007,10 +1007,6 @@ pub fn walk_impl_item<'v, V: Visitor<'v>>(visitor: &mut V, impl_item: &'v ImplIt\n             visitor.visit_id(impl_item.hir_id);\n             visitor.visit_ty(ty);\n         }\n-        ImplItemKind::OpaqueTy(bounds) => {\n-            visitor.visit_id(impl_item.hir_id);\n-            walk_list!(visitor, visit_param_bound, bounds);\n-        }\n     }\n }\n "}, {"sha": "c16b7c63e31471a2303708433f38b110eaa39458", "filename": "src/librustc_hir_pretty/lib.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Flibrustc_hir_pretty%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Flibrustc_hir_pretty%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir_pretty%2Flib.rs?ref=ce6d3a73b514e9649e57cee812ad129bb2112016", "patch": "@@ -407,7 +407,7 @@ impl<'a> State<'a> {\n                     &f.param_names[..],\n                 );\n             }\n-            hir::TyKind::Def(..) => {}\n+            hir::TyKind::OpaqueDef(..) => self.s.word(\"/*impl Trait*/\"),\n             hir::TyKind::Path(ref qpath) => self.print_qpath(qpath, false),\n             hir::TyKind::TraitObject(bounds, ref lifetime) => {\n                 let mut first = true;\n@@ -1003,12 +1003,6 @@ impl<'a> State<'a> {\n             hir::ImplItemKind::TyAlias(ref ty) => {\n                 self.print_associated_type(ii.ident, &ii.generics, None, Some(ty));\n             }\n-            hir::ImplItemKind::OpaqueTy(bounds) => {\n-                self.word_space(\"type\");\n-                self.print_ident(ii.ident);\n-                self.print_bounds(\"= impl\", bounds);\n-                self.s.word(\";\");\n-            }\n         }\n         self.ann.post(self, AnnNode::SubItem(ii.hir_id))\n     }"}, {"sha": "2ee95174dffe67b089bca3422a34c0eacfa0b4ba", "filename": "src/librustc_incremental/persist/dirty_clean.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs?ref=ce6d3a73b514e9649e57cee812ad129bb2112016", "patch": "@@ -336,7 +336,6 @@ impl DirtyCleanVisitor<'tcx> {\n                 ImplItemKind::Fn(..) => (\"Node::ImplItem\", LABELS_FN_IN_IMPL),\n                 ImplItemKind::Const(..) => (\"NodeImplConst\", LABELS_CONST_IN_IMPL),\n                 ImplItemKind::TyAlias(..) => (\"NodeImplType\", LABELS_CONST_IN_IMPL),\n-                ImplItemKind::OpaqueTy(..) => (\"NodeImplType\", LABELS_CONST_IN_IMPL),\n             },\n             _ => self.tcx.sess.span_fatal(\n                 attr.span,"}, {"sha": "12f7a9c0ca50228bc316da2cd03c8e860887a2a1", "filename": "src/librustc_infer/infer/error_reporting/mod.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fmod.rs?ref=ce6d3a73b514e9649e57cee812ad129bb2112016", "patch": "@@ -224,9 +224,7 @@ fn trait_item_scope_tag(item: &hir::TraitItem<'_>) -> &'static str {\n fn impl_item_scope_tag(item: &hir::ImplItem<'_>) -> &'static str {\n     match item.kind {\n         hir::ImplItemKind::Fn(..) => \"method body\",\n-        hir::ImplItemKind::Const(..)\n-        | hir::ImplItemKind::OpaqueTy(..)\n-        | hir::ImplItemKind::TyAlias(..) => \"associated item\",\n+        hir::ImplItemKind::Const(..) | hir::ImplItemKind::TyAlias(..) => \"associated item\",\n     }\n }\n "}, {"sha": "a56401ebb90f089ecaecfe29bb2d18ff5f7c8b23", "filename": "src/librustc_infer/infer/error_reporting/nice_region_error/named_anon_conflict.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs?ref=ce6d3a73b514e9649e57cee812ad129bb2112016", "patch": "@@ -84,7 +84,8 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n                 rustc_hir::intravisit::walk_ty(&mut v, ty);\n \n                 debug!(\"try_report_named_anon_conflict: ret ty {:?}\", ty);\n-                if sub == &ty::ReStatic && (matches!(ty.kind, TyKind::Def(_, _)) || v.0.len() == 1)\n+                if sub == &ty::ReStatic\n+                    && (matches!(ty.kind, TyKind::OpaqueDef(_, _)) || v.0.len() == 1)\n                 {\n                     debug!(\"try_report_named_anon_conflict: impl Trait + 'static\");\n                     // This is an `impl Trait` or `dyn Trait` return that evaluates de need of"}, {"sha": "efe60ce1b8889d83c21d82dd0694281bbca4b9db", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=ce6d3a73b514e9649e57cee812ad129bb2112016", "patch": "@@ -1102,6 +1102,10 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeAliasBounds {\n             hir::ItemKind::TyAlias(ref ty, ref generics) => (&*ty, generics),\n             _ => return,\n         };\n+        if let hir::TyKind::OpaqueDef(..) = ty.kind {\n+            // Bounds are respected for `type X = impl Trait`\n+            return;\n+        }\n         let mut suggested_changing_assoc_types = false;\n         // There must not be a where clause\n         if !type_alias_generics.where_clause.predicates.is_empty() {"}, {"sha": "44944a9fb265a2050e2270161e40489d77231b0b", "filename": "src/librustc_metadata/rmeta/decoder.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs?ref=ce6d3a73b514e9649e57cee812ad129bb2112016", "patch": "@@ -579,7 +579,6 @@ impl EntryKind {\n             EntryKind::ConstParam => DefKind::ConstParam,\n             EntryKind::OpaqueTy => DefKind::OpaqueTy,\n             EntryKind::AssocType(_) => DefKind::AssocTy,\n-            EntryKind::AssocOpaqueTy(_) => DefKind::AssocOpaqueTy,\n             EntryKind::Mod(_) => DefKind::Mod,\n             EntryKind::Variant(_) => DefKind::Variant,\n             EntryKind::Trait(_) => DefKind::Trait,\n@@ -1145,7 +1144,6 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n                 (ty::AssocKind::Fn, data.container, data.has_self)\n             }\n             EntryKind::AssocType(container) => (ty::AssocKind::Type, container, false),\n-            EntryKind::AssocOpaqueTy(container) => (ty::AssocKind::OpaqueTy, container, false),\n             _ => bug!(\"cannot get associated-item of `{:?}`\", def_key),\n         };\n "}, {"sha": "1dc22c10c8e7a3eca4530c86f6b2fc111ee0c717", "filename": "src/librustc_metadata/rmeta/encoder.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs?ref=ce6d3a73b514e9649e57cee812ad129bb2112016", "patch": "@@ -874,7 +874,6 @@ impl EncodeContext<'tcx> {\n                 }))\n             }\n             ty::AssocKind::Type => EntryKind::AssocType(container),\n-            ty::AssocKind::OpaqueTy => span_bug!(ast_item.span, \"opaque type in trait\"),\n         });\n         record!(self.tables.visibility[def_id] <- trait_item.vis);\n         record!(self.tables.span[def_id] <- ast_item.span);\n@@ -892,7 +891,6 @@ impl EncodeContext<'tcx> {\n                     self.encode_item_type(def_id);\n                 }\n             }\n-            ty::AssocKind::OpaqueTy => unreachable!(),\n         }\n         if trait_item.kind == ty::AssocKind::Fn {\n             record!(self.tables.fn_sig[def_id] <- tcx.fn_sig(def_id));\n@@ -957,7 +955,6 @@ impl EncodeContext<'tcx> {\n                     has_self: impl_item.fn_has_self_parameter,\n                 }))\n             }\n-            ty::AssocKind::OpaqueTy => EntryKind::AssocOpaqueTy(container),\n             ty::AssocKind::Type => EntryKind::AssocType(container)\n         });\n         record!(self.tables.visibility[def_id] <- impl_item.vis);\n@@ -989,7 +986,7 @@ impl EncodeContext<'tcx> {\n                 let always_encode_mir = self.tcx.sess.opts.debugging_opts.always_encode_mir;\n                 needs_inline || is_const_fn || always_encode_mir\n             }\n-            hir::ImplItemKind::OpaqueTy(..) | hir::ImplItemKind::TyAlias(..) => false,\n+            hir::ImplItemKind::TyAlias(..) => false,\n         };\n         if mir {\n             self.encode_optimized_mir(def_id.expect_local());\n@@ -1786,7 +1783,7 @@ impl<'tcx, 'v> ParItemLikeVisitor<'v> for PrefetchVisitor<'tcx> {\n                     self.prefetch_mir(def_id)\n                 }\n             }\n-            hir::ImplItemKind::OpaqueTy(..) | hir::ImplItemKind::TyAlias(..) => (),\n+            hir::ImplItemKind::TyAlias(..) => (),\n         }\n     }\n }"}, {"sha": "626a436b4006037a89656c27b7937b829dd4beec", "filename": "src/librustc_metadata/rmeta/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Flibrustc_metadata%2Frmeta%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Flibrustc_metadata%2Frmeta%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fmod.rs?ref=ce6d3a73b514e9649e57cee812ad129bb2112016", "patch": "@@ -308,7 +308,6 @@ enum EntryKind {\n     Impl(Lazy<ImplData>),\n     AssocFn(Lazy<AssocFnData>),\n     AssocType(AssocContainer),\n-    AssocOpaqueTy(AssocContainer),\n     AssocConst(AssocContainer, mir::ConstQualifs, Lazy<RenderedConst>),\n     TraitAlias,\n }"}, {"sha": "d1cfc4867a2fe0f5c57007177e17cbc8b21ccb7f", "filename": "src/librustc_middle/hir/map/mod.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Flibrustc_middle%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Flibrustc_middle%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fhir%2Fmap%2Fmod.rs?ref=ce6d3a73b514e9649e57cee812ad129bb2112016", "patch": "@@ -228,7 +228,6 @@ impl<'hir> Map<'hir> {\n                 ImplItemKind::Const(..) => DefKind::AssocConst,\n                 ImplItemKind::Fn(..) => DefKind::AssocFn,\n                 ImplItemKind::TyAlias(..) => DefKind::AssocTy,\n-                ImplItemKind::OpaqueTy(..) => DefKind::AssocOpaqueTy,\n             },\n             Node::Variant(_) => DefKind::Variant,\n             Node::Ctor(variant_data) => {\n@@ -672,6 +671,8 @@ impl<'hir> Map<'hir> {\n             if let Node::Item(Item {\n                 kind:\n                     ItemKind::Fn(..)\n+                    | ItemKind::Const(..)\n+                    | ItemKind::Static(..)\n                     | ItemKind::Mod(..)\n                     | ItemKind::Enum(..)\n                     | ItemKind::Struct(..)\n@@ -700,11 +701,7 @@ impl<'hir> Map<'hir> {\n                 return CRATE_HIR_ID;\n             }\n             match self.get(scope) {\n-                Node::Item(Item {\n-                    kind: ItemKind::OpaqueTy(OpaqueTy { impl_trait_fn: None, .. }),\n-                    ..\n-                })\n-                | Node::Block(_) => {}\n+                Node::Block(_) => {}\n                 _ => break,\n             }\n         }\n@@ -1025,9 +1022,6 @@ fn hir_id_to_string(map: &Map<'_>, id: HirId) -> String {\n             ImplItemKind::TyAlias(_) => {\n                 format!(\"assoc type {} in {}{}\", ii.ident, path_str(), id_str)\n             }\n-            ImplItemKind::OpaqueTy(_) => {\n-                format!(\"assoc opaque type {} in {}{}\", ii.ident, path_str(), id_str)\n-            }\n         },\n         Some(Node::TraitItem(ti)) => {\n             let kind = match ti.kind {"}, {"sha": "f4961617b81c6e8365a4ee6ec6be635b19c5ba7b", "filename": "src/librustc_middle/traits/specialization_graph.rs", "status": "modified", "additions": 2, "deletions": 15, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Flibrustc_middle%2Ftraits%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Flibrustc_middle%2Ftraits%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Ftraits%2Fspecialization_graph.rs?ref=ce6d3a73b514e9649e57cee812ad129bb2112016", "patch": "@@ -100,24 +100,11 @@ impl<'tcx> Node {\n         trait_item_kind: ty::AssocKind,\n         trait_def_id: DefId,\n     ) -> Option<ty::AssocItem> {\n-        use crate::ty::AssocKind::*;\n-\n         tcx.associated_items(self.def_id())\n             .filter_by_name_unhygienic(trait_item_name.name)\n             .find(move |impl_item| {\n-                match (trait_item_kind, impl_item.kind) {\n-                | (Const, Const)\n-                | (Fn, Fn)\n-                | (Type, Type)\n-                | (Type, OpaqueTy)  // assoc. types can be made opaque in impls\n-                => tcx.hygienic_eq(impl_item.ident, trait_item_name, trait_def_id),\n-\n-                | (Const, _)\n-                | (Fn, _)\n-                | (Type, _)\n-                | (OpaqueTy, _)\n-                => false,\n-            }\n+                trait_item_kind == impl_item.kind\n+                    && tcx.hygienic_eq(impl_item.ident, trait_item_name, trait_def_id)\n             })\n             .copied()\n     }"}, {"sha": "be3bf748225b9885097f4c6e07379e49a9782079", "filename": "src/librustc_middle/ty/error.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Flibrustc_middle%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Flibrustc_middle%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Ferror.rs?ref=ce6d3a73b514e9649e57cee812ad129bb2112016", "patch": "@@ -814,7 +814,7 @@ fn foo(&self) -> Self::T { String::new() }\n                 // FIXME: account for `#![feature(specialization)]`\n                 for item in &items[..] {\n                     match item.kind {\n-                        hir::AssocItemKind::Type | hir::AssocItemKind::OpaqueTy => {\n+                        hir::AssocItemKind::Type => {\n                             // FIXME: account for returning some type in a trait fn impl that has\n                             // an assoc type as a return type (#72076).\n                             if let hir::Defaultness::Default { has_value: true } = item.defaultness\n@@ -838,7 +838,7 @@ fn foo(&self) -> Self::T { String::new() }\n             })) => {\n                 for item in &items[..] {\n                     match item.kind {\n-                        hir::AssocItemKind::Type | hir::AssocItemKind::OpaqueTy => {\n+                        hir::AssocItemKind::Type => {\n                             if self.type_of(self.hir().local_def_id(item.id.hir_id)) == found {\n                                 db.span_label(item.span, \"expected this associated type\");\n                                 return true;"}, {"sha": "93ef73171993c0522fd161cda065e54c821fdf7d", "filename": "src/librustc_middle/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 19, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Flibrustc_middle%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Flibrustc_middle%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fmod.rs?ref=ce6d3a73b514e9649e57cee812ad129bb2112016", "patch": "@@ -198,14 +198,13 @@ pub struct AssocItem {\n pub enum AssocKind {\n     Const,\n     Fn,\n-    OpaqueTy,\n     Type,\n }\n \n impl AssocKind {\n     pub fn namespace(&self) -> Namespace {\n         match *self {\n-            ty::AssocKind::OpaqueTy | ty::AssocKind::Type => Namespace::TypeNS,\n+            ty::AssocKind::Type => Namespace::TypeNS,\n             ty::AssocKind::Const | ty::AssocKind::Fn => Namespace::ValueNS,\n         }\n     }\n@@ -215,22 +214,11 @@ impl AssocKind {\n             AssocKind::Const => DefKind::AssocConst,\n             AssocKind::Fn => DefKind::AssocFn,\n             AssocKind::Type => DefKind::AssocTy,\n-            AssocKind::OpaqueTy => DefKind::AssocOpaqueTy,\n         }\n     }\n }\n \n impl AssocItem {\n-    /// Tests whether the associated item admits a non-trivial implementation\n-    /// for !\n-    pub fn relevant_for_never(&self) -> bool {\n-        match self.kind {\n-            AssocKind::OpaqueTy | AssocKind::Const | AssocKind::Type => true,\n-            // FIXME(canndrew): Be more thorough here, check if any argument is uninhabited.\n-            AssocKind::Fn => !self.fn_has_self_parameter,\n-        }\n-    }\n-\n     pub fn signature(&self, tcx: TyCtxt<'_>) -> String {\n         match self.kind {\n             ty::AssocKind::Fn => {\n@@ -241,8 +229,6 @@ impl AssocItem {\n                 tcx.fn_sig(self.def_id).skip_binder().to_string()\n             }\n             ty::AssocKind::Type => format!(\"type {};\", self.ident),\n-            // FIXME(type_alias_impl_trait): we should print bounds here too.\n-            ty::AssocKind::OpaqueTy => format!(\"type {};\", self.ident),\n             ty::AssocKind::Const => {\n                 format!(\"const {}: {:?};\", self.ident, tcx.type_of(self.def_id))\n             }\n@@ -2581,10 +2567,6 @@ impl<'tcx> TyCtxt<'tcx> {\n             .filter(|item| item.kind == AssocKind::Fn && item.defaultness.has_value())\n     }\n \n-    pub fn trait_relevant_for_never(self, did: DefId) -> bool {\n-        self.associated_items(did).in_definition_order().any(|item| item.relevant_for_never())\n-    }\n-\n     pub fn opt_item_name(self, def_id: DefId) -> Option<Ident> {\n         def_id\n             .as_local()"}, {"sha": "5707127340d87fa92bec7359fc80fcb08cf0635b", "filename": "src/librustc_mir/borrow_check/type_check/free_region_relations.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Ffree_region_relations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Ffree_region_relations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Ffree_region_relations.rs?ref=ce6d3a73b514e9649e57cee812ad129bb2112016", "patch": "@@ -259,7 +259,13 @@ impl UniversalRegionRelationsBuilder<'cx, 'tcx> {\n                     .param_env\n                     .and(type_op::normalize::Normalize::new(ty))\n                     .fully_perform(self.infcx)\n-                    .unwrap_or_else(|_| bug!(\"failed to normalize {:?}\", ty));\n+                    .unwrap_or_else(|_| {\n+                        self.infcx\n+                            .tcx\n+                            .sess\n+                            .delay_span_bug(DUMMY_SP, &format!(\"failed to normalize {:?}\", ty));\n+                        (self.infcx.tcx.types.err, None)\n+                    });\n                 let constraints2 = self.add_implied_bounds(ty);\n                 normalized_inputs_and_output.push(ty);\n                 constraints1.into_iter().chain(constraints2)"}, {"sha": "80681c143750fc7e8fe091158cfc49a891aa7c35", "filename": "src/librustc_passes/check_attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Flibrustc_passes%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Flibrustc_passes%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fcheck_attr.rs?ref=ce6d3a73b514e9649e57cee812ad129bb2112016", "patch": "@@ -37,7 +37,7 @@ fn target_from_impl_item<'tcx>(tcx: TyCtxt<'tcx>, impl_item: &hir::ImplItem<'_>)\n                 Target::Method(MethodKind::Inherent)\n             }\n         }\n-        hir::ImplItemKind::TyAlias(..) | hir::ImplItemKind::OpaqueTy(..) => Target::AssocTy,\n+        hir::ImplItemKind::TyAlias(..) => Target::AssocTy,\n     }\n }\n "}, {"sha": "503fbb64db83dbbd6267e1e5871ef02b59dd5d3c", "filename": "src/librustc_passes/dead.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Flibrustc_passes%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Flibrustc_passes%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fdead.rs?ref=ce6d3a73b514e9649e57cee812ad129bb2112016", "patch": "@@ -304,7 +304,7 @@ impl<'a, 'tcx> Visitor<'tcx> for MarkSymbolVisitor<'a, 'tcx> {\n     }\n \n     fn visit_ty(&mut self, ty: &'tcx hir::Ty<'tcx>) {\n-        if let TyKind::Def(item_id, _) = ty.kind {\n+        if let TyKind::OpaqueDef(item_id, _) = ty.kind {\n             let item = self.tcx.hir().expect_item(item_id.id);\n             intravisit::walk_item(self, item);\n         }\n@@ -668,7 +668,7 @@ impl Visitor<'tcx> for DeadVisitor<'tcx> {\n                 }\n                 self.visit_nested_body(body_id)\n             }\n-            hir::ImplItemKind::OpaqueTy(..) | hir::ImplItemKind::TyAlias(..) => {}\n+            hir::ImplItemKind::TyAlias(..) => {}\n         }\n     }\n "}, {"sha": "2419e6965968ed0213aa8b0de268143491acf723", "filename": "src/librustc_passes/layout_test.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Flibrustc_passes%2Flayout_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Flibrustc_passes%2Flayout_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Flayout_test.rs?ref=ce6d3a73b514e9649e57cee812ad129bb2112016", "patch": "@@ -27,8 +27,7 @@ impl ItemLikeVisitor<'tcx> for LayoutTest<'tcx> {\n             ItemKind::TyAlias(..)\n             | ItemKind::Enum(..)\n             | ItemKind::Struct(..)\n-            | ItemKind::Union(..)\n-            | ItemKind::OpaqueTy(..) => {\n+            | ItemKind::Union(..) => {\n                 for attr in self.tcx.get_attrs(item_def_id.to_def_id()).iter() {\n                     if attr.check_name(sym::rustc_layout) {\n                         self.dump_layout_of(item_def_id, item, attr);\n@@ -83,9 +82,11 @@ impl LayoutTest<'tcx> {\n                         }\n \n                         sym::debug => {\n+                            let normalized_ty =\n+                                self.tcx.normalize_erasing_regions(param_env.with_reveal_all(), ty);\n                             self.tcx.sess.span_err(\n                                 item.span,\n-                                &format!(\"layout_of({:?}) = {:#?}\", ty, *ty_layout),\n+                                &format!(\"layout_of({:?}) = {:#?}\", normalized_ty, *ty_layout),\n                             );\n                         }\n "}, {"sha": "c9a4428c007aae7a68dd9feadad207b17938038f", "filename": "src/librustc_passes/reachable.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Flibrustc_passes%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Flibrustc_passes%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Freachable.rs?ref=ce6d3a73b514e9649e57cee812ad129bb2112016", "patch": "@@ -180,7 +180,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                             }\n                         }\n                     }\n-                    hir::ImplItemKind::OpaqueTy(..) | hir::ImplItemKind::TyAlias(_) => false,\n+                    hir::ImplItemKind::TyAlias(_) => false,\n                 }\n             }\n             Some(_) => false,\n@@ -289,7 +289,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                         self.visit_nested_body(body)\n                     }\n                 }\n-                hir::ImplItemKind::OpaqueTy(..) | hir::ImplItemKind::TyAlias(_) => {}\n+                hir::ImplItemKind::TyAlias(_) => {}\n             },\n             Node::Expr(&hir::Expr { kind: hir::ExprKind::Closure(.., body, _, _), .. }) => {\n                 self.visit_nested_body(body);"}, {"sha": "3c1b56a9ef40ae4986ee48881bf89cbf2813578b", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 2, "deletions": 12, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=ce6d3a73b514e9649e57cee812ad129bb2112016", "patch": "@@ -615,7 +615,6 @@ impl EmbargoVisitor<'tcx> {\n             // public, or are not namespaced at all.\n             DefKind::AssocConst\n             | DefKind::AssocTy\n-            | DefKind::AssocOpaqueTy\n             | DefKind::ConstParam\n             | DefKind::Ctor(_, _)\n             | DefKind::Enum\n@@ -1333,11 +1332,7 @@ impl<'a, 'tcx> Visitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n             _ => None,\n         };\n         let def = def.filter(|(kind, _)| match kind {\n-            DefKind::AssocFn\n-            | DefKind::AssocConst\n-            | DefKind::AssocTy\n-            | DefKind::AssocOpaqueTy\n-            | DefKind::Static => true,\n+            DefKind::AssocFn | DefKind::AssocConst | DefKind::AssocTy | DefKind::Static => true,\n             _ => false,\n         });\n         if let Some((kind, def_id)) = def {\n@@ -1602,9 +1597,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n                             hir::ImplItemKind::Const(..) | hir::ImplItemKind::Fn(..) => {\n                                 self.access_levels.is_reachable(impl_item_ref.id.hir_id)\n                             }\n-                            hir::ImplItemKind::OpaqueTy(..) | hir::ImplItemKind::TyAlias(_) => {\n-                                false\n-                            }\n+                            hir::ImplItemKind::TyAlias(_) => false,\n                         }\n                     });\n \n@@ -1952,9 +1945,6 @@ impl<'a, 'tcx> PrivateItemsInPublicInterfacesVisitor<'a, 'tcx> {\n         let (check_ty, is_assoc_ty) = match assoc_item_kind {\n             AssocItemKind::Const | AssocItemKind::Fn { .. } => (true, false),\n             AssocItemKind::Type => (defaultness.has_value(), true),\n-            // `ty()` for opaque types is the underlying type,\n-            // it's not a part of interface, so we skip it.\n-            AssocItemKind::OpaqueTy => (false, true),\n         };\n         check.in_assoc_ty = is_assoc_ty;\n         check.generics().predicates();"}, {"sha": "e633bd1843e85d292411a45c65dbb0a5220d12f0", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=ce6d3a73b514e9649e57cee812ad129bb2112016", "patch": "@@ -746,12 +746,11 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n             }\n \n             // These items live in the type namespace.\n-            ItemKind::TyAlias(_, _, _, ref ty) => {\n-                let def_kind = match ty.as_deref().and_then(|ty| ty.kind.opaque_top_hack()) {\n-                    None => DefKind::TyAlias,\n-                    Some(_) => DefKind::OpaqueTy,\n-                };\n-                let res = Res::Def(def_kind, self.r.definitions.local_def_id(item.id).to_def_id());\n+            ItemKind::TyAlias(..) => {\n+                let res = Res::Def(\n+                    DefKind::TyAlias,\n+                    self.r.definitions.local_def_id(item.id).to_def_id(),\n+                );\n                 self.r.define(parent, ident, TypeNS, (res, vis, sp, expansion));\n             }\n \n@@ -917,8 +916,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                 | DefKind::ForeignTy\n                 | DefKind::OpaqueTy\n                 | DefKind::TraitAlias\n-                | DefKind::AssocTy\n-                | DefKind::AssocOpaqueTy,\n+                | DefKind::AssocTy,\n                 _,\n             )\n             | Res::PrimTy(..)"}, {"sha": "5bbf8703f0b60d1b7ec8b6a9cc1492a0c61e7b7a", "filename": "src/librustc_resolve/late/lifetimes.rs", "status": "modified", "additions": 28, "deletions": 51, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Flibrustc_resolve%2Flate%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Flibrustc_resolve%2Flate%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate%2Flifetimes.rs?ref=ce6d3a73b514e9649e57cee812ad129bb2112016", "patch": "@@ -258,6 +258,9 @@ enum Elide {\n     Exact(Region),\n     /// Less or more than one lifetime were found, error on unspecified.\n     Error(Vec<ElisionFailureInfo>),\n+    /// Forbid lifetime elision inside of a larger scope where it would be\n+    /// permitted. For example, in let position impl trait.\n+    Forbid,\n }\n \n #[derive(Clone, Debug)]\n@@ -396,15 +399,12 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 let scope = Scope::Elision { elide: Elide::Exact(Region::Static), s: ROOT_SCOPE };\n                 self.with(scope, |_, this| intravisit::walk_item(this, item));\n             }\n-            hir::ItemKind::OpaqueTy(hir::OpaqueTy { impl_trait_fn: Some(_), .. }) => {\n-                // Currently opaque type declarations are just generated from `impl Trait`\n-                // items. Doing anything on this node is irrelevant, as we currently don't need\n-                // it.\n+            hir::ItemKind::OpaqueTy(hir::OpaqueTy { .. }) => {\n+                // Opaque types are visited when we visit the\n+                // `TyKind::OpaqueDef`, so that they have the lifetimes from\n+                // their parent opaque_ty in scope.\n             }\n             hir::ItemKind::TyAlias(_, ref generics)\n-            | hir::ItemKind::OpaqueTy(hir::OpaqueTy {\n-                impl_trait_fn: None, ref generics, ..\n-            })\n             | hir::ItemKind::Enum(_, ref generics)\n             | hir::ItemKind::Struct(_, ref generics)\n             | hir::ItemKind::Union(_, ref generics)\n@@ -557,23 +557,35 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 };\n                 self.with(scope, |_, this| this.visit_ty(&mt.ty));\n             }\n-            hir::TyKind::Def(item_id, lifetimes) => {\n+            hir::TyKind::OpaqueDef(item_id, lifetimes) => {\n                 // Resolve the lifetimes in the bounds to the lifetime defs in the generics.\n                 // `fn foo<'a>() -> impl MyTrait<'a> { ... }` desugars to\n                 // `type MyAnonTy<'b> = impl MyTrait<'b>;`\n                 //                 ^                  ^ this gets resolved in the scope of\n                 //                                      the opaque_ty generics\n-                let (generics, bounds) = match self.tcx.hir().expect_item(item_id.id).kind {\n+                let opaque_ty = self.tcx.hir().expect_item(item_id.id);\n+                let (generics, bounds) = match opaque_ty.kind {\n                     // Named opaque `impl Trait` types are reached via `TyKind::Path`.\n                     // This arm is for `impl Trait` in the types of statics, constants and locals.\n                     hir::ItemKind::OpaqueTy(hir::OpaqueTy { impl_trait_fn: None, .. }) => {\n                         intravisit::walk_ty(self, ty);\n+\n+                        // Elided lifetimes are not allowed in non-return\n+                        // position impl Trait\n+                        let scope = Scope::Elision { elide: Elide::Forbid, s: self.scope };\n+                        self.with(scope, |_, this| {\n+                            intravisit::walk_item(this, opaque_ty);\n+                        });\n+\n                         return;\n                     }\n                     // RPIT (return position impl trait)\n-                    hir::ItemKind::OpaqueTy(hir::OpaqueTy { ref generics, bounds, .. }) => {\n-                        (generics, bounds)\n-                    }\n+                    hir::ItemKind::OpaqueTy(hir::OpaqueTy {\n+                        impl_trait_fn: Some(_),\n+                        ref generics,\n+                        bounds,\n+                        ..\n+                    }) => (generics, bounds),\n                     ref i => bug!(\"`impl Trait` pointed to non-opaque type?? {:#?}\", i),\n                 };\n \n@@ -797,43 +809,6 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     this.visit_ty(ty);\n                 });\n             }\n-            OpaqueTy(bounds) => {\n-                let generics = &impl_item.generics;\n-                let mut index = self.next_early_index();\n-                let mut next_early_index = index;\n-                debug!(\"visit_ty: index = {}\", index);\n-                let lifetimes = generics\n-                    .params\n-                    .iter()\n-                    .filter_map(|param| match param.kind {\n-                        GenericParamKind::Lifetime { .. } => {\n-                            Some(Region::early(&self.tcx.hir(), &mut index, param))\n-                        }\n-                        GenericParamKind::Type { .. } => {\n-                            next_early_index += 1;\n-                            None\n-                        }\n-                        GenericParamKind::Const { .. } => {\n-                            next_early_index += 1;\n-                            None\n-                        }\n-                    })\n-                    .collect();\n-\n-                let scope = Scope::Binder {\n-                    lifetimes,\n-                    next_early_index,\n-                    s: self.scope,\n-                    track_lifetime_uses: true,\n-                    opaque_type_parent: true,\n-                };\n-                self.with(scope, |_old_scope, this| {\n-                    this.visit_generics(generics);\n-                    for bound in bounds {\n-                        this.visit_param_bound(bound);\n-                    }\n-                });\n-            }\n             Const(_, _) => {\n                 // Only methods and types support generics.\n                 assert!(impl_item.generics.params.is_empty());\n@@ -2367,6 +2342,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                             }\n                             break Some(e);\n                         }\n+                        Elide::Forbid => break None,\n                     };\n                     for lifetime_ref in lifetime_refs {\n                         self.insert_lifetime(lifetime_ref, lifetime);\n@@ -2667,8 +2643,9 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 // going to make a fresh name, so we cannot\n                 // necessarily replace a single-use lifetime with\n                 // `'_`.\n-                Scope::Elision { elide: Elide::Exact(_), .. } => break false,\n-                Scope::Elision { elide: Elide::Error(_), .. } => break false,\n+                Scope::Elision {\n+                    elide: Elide::Exact(_) | Elide::Error(_) | Elide::Forbid, ..\n+                } => break false,\n \n                 Scope::ObjectLifetimeDefault { s, .. } => scope = s,\n             }"}, {"sha": "e63e31e03c9f021c95cf89c119349934247b4f7d", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=ce6d3a73b514e9649e57cee812ad129bb2112016", "patch": "@@ -1102,7 +1102,6 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n                     impl_item.span,\n                 );\n             }\n-            hir::ImplItemKind::OpaqueTy(..) => {}\n             hir::ImplItemKind::TyAlias(ref ty) => {\n                 // FIXME: uses of the assoc type should ideally point to this\n                 // 'def' and the name here should be a ref to the def in the\n@@ -1380,7 +1379,7 @@ impl<'l, 'tcx> Visitor<'tcx> for DumpVisitor<'l, 'tcx> {\n                     v.visit_expr(&map.body(anon_const.body).value)\n                 });\n             }\n-            hir::TyKind::Def(item_id, _) => {\n+            hir::TyKind::OpaqueDef(item_id, _) => {\n                 let item = self.tcx.hir().item(item_id.id);\n                 self.nest_tables(self.tcx.hir().local_def_id(item_id.id), |v| v.visit_item(item));\n             }"}, {"sha": "12d2c8c7eb9a4c3be9db74681298a41b1bbab158", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=ce6d3a73b514e9649e57cee812ad129bb2112016", "patch": "@@ -698,7 +698,6 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n                 | HirDefKind::TyAlias\n                 | HirDefKind::ForeignTy\n                 | HirDefKind::TraitAlias\n-                | HirDefKind::AssocOpaqueTy\n                 | HirDefKind::AssocTy\n                 | HirDefKind::Trait\n                 | HirDefKind::OpaqueTy"}, {"sha": "cd2a5deeb2d727c6448a747a0eabc4bdaeb64702", "filename": "src/librustc_save_analysis/sig.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Flibrustc_save_analysis%2Fsig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Flibrustc_save_analysis%2Fsig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fsig.rs?ref=ce6d3a73b514e9649e57cee812ad129bb2112016", "patch": "@@ -324,7 +324,7 @@ impl<'hir> Sig for hir::Ty<'hir> {\n                 let text = format!(\"[{}; {}]\", nested_ty.text, expr);\n                 Ok(replace_text(nested_ty, text))\n             }\n-            hir::TyKind::Def(item_id, _) => {\n+            hir::TyKind::OpaqueDef(item_id, _) => {\n                 let item = scx.tcx.hir().item(item_id.id);\n                 item.make(offset, Some(item_id.id), scx)\n             }"}, {"sha": "d53a0ec9ef884ff336a6c2f2199795b79f3e2039", "filename": "src/librustc_trait_selection/opaque_types.rs", "status": "modified", "additions": 44, "deletions": 52, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Flibrustc_trait_selection%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Flibrustc_trait_selection%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Fopaque_types.rs?ref=ce6d3a73b514e9649e57cee812ad129bb2112016", "patch": "@@ -11,7 +11,7 @@ use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKi\n use rustc_infer::infer::{self, InferCtxt, InferOk};\n use rustc_middle::ty::fold::{BottomUpFolder, TypeFoldable, TypeFolder, TypeVisitor};\n use rustc_middle::ty::subst::{GenericArg, GenericArgKind, InternalSubsts, SubstsRef};\n-use rustc_middle::ty::{self, GenericParamDefKind, Ty, TyCtxt};\n+use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_session::config::nightly_options;\n use rustc_span::Span;\n \n@@ -133,9 +133,9 @@ pub trait InferCtxtExt<'tcx> {\n     fn generate_member_constraint(\n         &self,\n         concrete_ty: Ty<'tcx>,\n-        opaque_type_generics: &ty::Generics,\n         opaque_defn: &OpaqueTypeDecl<'tcx>,\n         opaque_type_def_id: DefId,\n+        first_own_region_index: usize,\n     );\n \n     /*private*/\n@@ -405,7 +405,24 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n \n         debug!(\"constrain_opaque_type: concrete_ty={:?}\", concrete_ty);\n \n-        let opaque_type_generics = tcx.generics_of(def_id);\n+        let first_own_region = match opaque_defn.origin {\n+            hir::OpaqueTyOrigin::FnReturn | hir::OpaqueTyOrigin::AsyncFn => {\n+                // We lower\n+                //\n+                // fn foo<'l0..'ln>() -> impl Trait<'l0..'lm>\n+                //\n+                // into\n+                //\n+                // type foo::<'p0..'pn>::Foo<'q0..'qm>\n+                // fn foo<l0..'ln>() -> foo::<'static..'static>::Foo<'l0..'lm>.\n+                //\n+                // For these types we onlt iterate over `'l0..lm` below.\n+                tcx.generics_of(def_id).parent_count\n+            }\n+            // These opaque type inherit all lifetime parameters from their\n+            // parent, so we have to check them all.\n+            hir::OpaqueTyOrigin::Binding | hir::OpaqueTyOrigin::Misc => 0,\n+        };\n \n         let span = tcx.def_span(def_id);\n \n@@ -427,12 +444,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 });\n             }\n             if let GenerateMemberConstraints::IfNoStaticBound = mode {\n-                self.generate_member_constraint(\n-                    concrete_ty,\n-                    opaque_type_generics,\n-                    opaque_defn,\n-                    def_id,\n-                );\n+                self.generate_member_constraint(concrete_ty, opaque_defn, def_id, first_own_region);\n             }\n             return;\n         }\n@@ -445,29 +457,27 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         // `['a]` for the first impl trait and `'b` for the\n         // second.\n         let mut least_region = None;\n-        for param in &opaque_type_generics.params {\n-            match param.kind {\n-                GenericParamDefKind::Lifetime => {}\n-                _ => continue,\n-            }\n \n-            // Get the value supplied for this region from the substs.\n-            let subst_arg = opaque_defn.substs.region_at(param.index as usize);\n+        for subst_arg in &opaque_defn.substs[first_own_region..] {\n+            let subst_region = match subst_arg.unpack() {\n+                GenericArgKind::Lifetime(r) => r,\n+                GenericArgKind::Type(_) | GenericArgKind::Const(_) => continue,\n+            };\n \n             // Compute the least upper bound of it with the other regions.\n             debug!(\"constrain_opaque_types: least_region={:?}\", least_region);\n-            debug!(\"constrain_opaque_types: subst_arg={:?}\", subst_arg);\n+            debug!(\"constrain_opaque_types: subst_region={:?}\", subst_region);\n             match least_region {\n-                None => least_region = Some(subst_arg),\n+                None => least_region = Some(subst_region),\n                 Some(lr) => {\n-                    if free_region_relations.sub_free_regions(self.tcx, lr, subst_arg) {\n+                    if free_region_relations.sub_free_regions(self.tcx, lr, subst_region) {\n                         // keep the current least region\n-                    } else if free_region_relations.sub_free_regions(self.tcx, subst_arg, lr) {\n-                        // switch to `subst_arg`\n-                        least_region = Some(subst_arg);\n+                    } else if free_region_relations.sub_free_regions(self.tcx, subst_region, lr) {\n+                        // switch to `subst_region`\n+                        least_region = Some(subst_region);\n                     } else {\n                         // There are two regions (`lr` and\n-                        // `subst_arg`) which are not relatable. We\n+                        // `subst_region`) which are not relatable. We\n                         // can't find a best choice. Therefore,\n                         // instead of creating a single bound like\n                         // `'r: 'a` (which is our preferred choice),\n@@ -476,13 +486,13 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                         // regions that appear in the impl trait.\n \n                         // For now, enforce a feature gate outside of async functions.\n-                        self.member_constraint_feature_gate(opaque_defn, def_id, lr, subst_arg);\n+                        self.member_constraint_feature_gate(opaque_defn, def_id, lr, subst_region);\n \n                         return self.generate_member_constraint(\n                             concrete_ty,\n-                            opaque_type_generics,\n                             opaque_defn,\n                             def_id,\n+                            first_own_region,\n                         );\n                     }\n                 }\n@@ -494,12 +504,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n \n         if let GenerateMemberConstraints::IfNoStaticBound = mode {\n             if least_region != tcx.lifetimes.re_static {\n-                self.generate_member_constraint(\n-                    concrete_ty,\n-                    opaque_type_generics,\n-                    opaque_defn,\n-                    def_id,\n-                );\n+                self.generate_member_constraint(concrete_ty, opaque_defn, def_id, first_own_region);\n             }\n         }\n         concrete_ty.visit_with(&mut ConstrainOpaqueTypeRegionVisitor {\n@@ -518,22 +523,20 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n     fn generate_member_constraint(\n         &self,\n         concrete_ty: Ty<'tcx>,\n-        opaque_type_generics: &ty::Generics,\n         opaque_defn: &OpaqueTypeDecl<'tcx>,\n         opaque_type_def_id: DefId,\n+        first_own_region: usize,\n     ) {\n         // Create the set of choice regions: each region in the hidden\n         // type can be equal to any of the region parameters of the\n         // opaque type definition.\n         let choice_regions: Lrc<Vec<ty::Region<'tcx>>> = Lrc::new(\n-            opaque_type_generics\n-                .params\n+            opaque_defn.substs[first_own_region..]\n                 .iter()\n-                .filter(|param| match param.kind {\n-                    GenericParamDefKind::Lifetime => true,\n-                    GenericParamDefKind::Type { .. } | GenericParamDefKind::Const => false,\n+                .filter_map(|arg| match arg.unpack() {\n+                    GenericArgKind::Lifetime(r) => Some(r),\n+                    GenericArgKind::Type(_) | GenericArgKind::Const(_) => None,\n                 })\n-                .map(|param| opaque_defn.substs.region_at(param.index as usize))\n                 .chain(std::iter::once(self.tcx.lifetimes.re_static))\n                 .collect(),\n         );\n@@ -574,7 +577,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n             hir::OpaqueTyOrigin::AsyncFn => return false,\n \n             // Otherwise, generate the label we'll use in the error message.\n-            hir::OpaqueTyOrigin::TypeAlias\n+            hir::OpaqueTyOrigin::Binding\n             | hir::OpaqueTyOrigin::FnReturn\n             | hir::OpaqueTyOrigin::Misc => \"impl Trait\",\n         };\n@@ -1064,21 +1067,10 @@ impl<'a, 'tcx> Instantiator<'a, 'tcx> {\n                                     ),\n                                     origin,\n                                 ),\n-                                _ => (def_scope_default(), hir::OpaqueTyOrigin::TypeAlias),\n-                            },\n-                            Some(Node::ImplItem(item)) => match item.kind {\n-                                hir::ImplItemKind::OpaqueTy(_) => (\n-                                    may_define_opaque_type(\n-                                        tcx,\n-                                        self.parent_def_id.expect_local(),\n-                                        opaque_hir_id,\n-                                    ),\n-                                    hir::OpaqueTyOrigin::TypeAlias,\n-                                ),\n-                                _ => (def_scope_default(), hir::OpaqueTyOrigin::TypeAlias),\n+                                _ => (def_scope_default(), hir::OpaqueTyOrigin::Misc),\n                             },\n                             _ => bug!(\n-                                \"expected (impl) item, found {}\",\n+                                \"expected item, found {}\",\n                                 tcx.hir().node_to_string(opaque_hir_id),\n                             ),\n                         };"}, {"sha": "9492c3c340995091fb75041c1833ab4eae55d3fc", "filename": "src/librustc_trait_selection/traits/project.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Flibrustc_trait_selection%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Flibrustc_trait_selection%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fproject.rs?ref=ce6d3a73b514e9649e57cee812ad129bb2112016", "patch": "@@ -25,7 +25,7 @@ use rustc_errors::ErrorReported;\n use rustc_hir::def_id::DefId;\n use rustc_hir::lang_items::{FnOnceTraitLangItem, GeneratorTraitLangItem};\n use rustc_middle::ty::fold::{TypeFoldable, TypeFolder};\n-use rustc_middle::ty::subst::{InternalSubsts, Subst};\n+use rustc_middle::ty::subst::Subst;\n use rustc_middle::ty::util::IntTypeExt;\n use rustc_middle::ty::{self, ToPolyTraitRef, ToPredicate, Ty, TyCtxt, WithConstness};\n use rustc_span::symbol::{sym, Ident};\n@@ -1477,12 +1477,7 @@ fn confirm_impl_candidate<'cx, 'tcx>(\n     let substs = obligation.predicate.substs.rebase_onto(tcx, trait_def_id, substs);\n     let substs =\n         translate_substs(selcx.infcx(), param_env, impl_def_id, substs, assoc_ty.defining_node);\n-    let ty = if let ty::AssocKind::OpaqueTy = assoc_ty.item.kind {\n-        let item_substs = InternalSubsts::identity_for_item(tcx, assoc_ty.item.def_id);\n-        tcx.mk_opaque(assoc_ty.item.def_id, item_substs)\n-    } else {\n-        tcx.type_of(assoc_ty.item.def_id)\n-    };\n+    let ty = tcx.type_of(assoc_ty.item.def_id);\n     if substs.len() != tcx.generics_of(assoc_ty.item.def_id).count() {\n         tcx.sess\n             .delay_span_bug(DUMMY_SP, \"impl item and trait item have different parameter counts\");\n@@ -1515,7 +1510,7 @@ fn assoc_ty_def(\n     // cycle error if the specialization graph is currently being built.\n     let impl_node = specialization_graph::Node::Impl(impl_def_id);\n     for item in impl_node.items(tcx) {\n-        if matches!(item.kind, ty::AssocKind::Type | ty::AssocKind::OpaqueTy)\n+        if matches!(item.kind, ty::AssocKind::Type)\n             && tcx.hygienic_eq(item.ident, assoc_ty_name, trait_def_id)\n         {\n             return Ok(specialization_graph::LeafDef {"}, {"sha": "99094246a637861154157420e102c85d54658f71", "filename": "src/librustc_ty/ty.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Flibrustc_ty%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Flibrustc_ty%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ty%2Fty.rs?ref=ce6d3a73b514e9649e57cee812ad129bb2112016", "patch": "@@ -85,7 +85,6 @@ fn associated_item_from_trait_item_ref(\n         hir::AssocItemKind::Const => (ty::AssocKind::Const, false),\n         hir::AssocItemKind::Fn { has_self } => (ty::AssocKind::Fn, has_self),\n         hir::AssocItemKind::Type => (ty::AssocKind::Type, false),\n-        hir::AssocItemKind::OpaqueTy => bug!(\"only impls can have opaque types\"),\n     };\n \n     ty::AssocItem {\n@@ -110,7 +109,6 @@ fn associated_item_from_impl_item_ref(\n         hir::AssocItemKind::Const => (ty::AssocKind::Const, false),\n         hir::AssocItemKind::Fn { has_self } => (ty::AssocKind::Fn, has_self),\n         hir::AssocItemKind::Type => (ty::AssocKind::Type, false),\n-        hir::AssocItemKind::OpaqueTy => (ty::AssocKind::OpaqueTy, false),\n     };\n \n     ty::AssocItem {"}, {"sha": "267f3d9f3ef6e6dc02dbfe7436bc375181174a30", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 22, "deletions": 5, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=ce6d3a73b514e9649e57cee812ad129bb2112016", "patch": "@@ -2838,9 +2838,16 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 let opt_self_ty = maybe_qself.as_ref().map(|qself| self.ast_ty_to_ty(qself));\n                 self.res_to_ty(opt_self_ty, path, false)\n             }\n-            hir::TyKind::Def(item_id, ref lifetimes) => {\n-                let did = tcx.hir().local_def_id(item_id.id);\n-                self.impl_trait_ty_to_ty(did.to_def_id(), lifetimes)\n+            hir::TyKind::OpaqueDef(item_id, ref lifetimes) => {\n+                let opaque_ty = tcx.hir().expect_item(item_id.id);\n+                let def_id = tcx.hir().local_def_id(item_id.id).to_def_id();\n+\n+                match opaque_ty.kind {\n+                    hir::ItemKind::OpaqueTy(hir::OpaqueTy { impl_trait_fn, .. }) => {\n+                        self.impl_trait_ty_to_ty(def_id, lifetimes, impl_trait_fn.is_some())\n+                    }\n+                    ref i => bug!(\"`impl Trait` pointed to non-opaque type?? {:#?}\", i),\n+                }\n             }\n             hir::TyKind::Path(hir::QPath::TypeRelative(ref qself, ref segment)) => {\n                 debug!(\"ast_ty_to_ty: qself={:?} segment={:?}\", qself, segment);\n@@ -2893,6 +2900,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         &self,\n         def_id: DefId,\n         lifetimes: &[hir::GenericArg<'_>],\n+        replace_parent_lifetimes: bool,\n     ) -> Ty<'tcx> {\n         debug!(\"impl_trait_ty_to_ty(def_id={:?}, lifetimes={:?})\", def_id, lifetimes);\n         let tcx = self.tcx();\n@@ -2914,9 +2922,18 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     _ => bug!(),\n                 }\n             } else {\n-                // Replace all parent lifetimes with `'static`.\n                 match param.kind {\n-                    GenericParamDefKind::Lifetime => tcx.lifetimes.re_static.into(),\n+                    // For RPIT (return position impl trait), only lifetimes\n+                    // mentioned in the impl Trait predicate are captured by\n+                    // the opaque type, so the lifetime parameters from the\n+                    // parent item need to be replaced with `'static`.\n+                    //\n+                    // For `impl Trait` in the types of statics, constants,\n+                    // locals and type aliases. These capture all parent\n+                    // lifetimes, so they can use their identity subst.\n+                    GenericParamDefKind::Lifetime if replace_parent_lifetimes => {\n+                        tcx.lifetimes.re_static.into()\n+                    }\n                     _ => tcx.mk_param_from_def(param),\n                 }\n             }"}, {"sha": "15ec92568fb4d1fcaec17a639d232d9098ccd901", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=ce6d3a73b514e9649e57cee812ad129bb2112016", "patch": "@@ -1494,7 +1494,7 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n         let mut is_object_safe = false;\n         if let hir::FnRetTy::Return(ty) = fn_output {\n             // Get the return type.\n-            if let hir::TyKind::Def(..) = ty.kind {\n+            if let hir::TyKind::OpaqueDef(..) = ty.kind {\n                 let ty = AstConv::ast_ty_to_ty(fcx, ty);\n                 // Get the `impl Trait`'s `DefId`.\n                 if let ty::Opaque(def_id, _) = ty.kind {"}, {"sha": "5f8fcaadfdb0b2fc66081a7e26f67fa05259c6a2", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=ce6d3a73b514e9649e57cee812ad129bb2112016", "patch": "@@ -1165,6 +1165,6 @@ fn assoc_item_kind_str(impl_item: &ty::AssocItem) -> &'static str {\n     match impl_item.kind {\n         ty::AssocKind::Const => \"const\",\n         ty::AssocKind::Fn => \"method\",\n-        ty::AssocKind::Type | ty::AssocKind::OpaqueTy => \"type\",\n+        ty::AssocKind::Type => \"type\",\n     }\n }"}, {"sha": "a2e6c8793cbddab06539bf75a896cfb21c6854f5", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=ce6d3a73b514e9649e57cee812ad129bb2112016", "patch": "@@ -1556,7 +1556,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n         match self.mode {\n             Mode::MethodCall => item.fn_has_self_parameter,\n             Mode::Path => match item.kind {\n-                ty::AssocKind::OpaqueTy | ty::AssocKind::Type => false,\n+                ty::AssocKind::Type => false,\n                 ty::AssocKind::Fn | ty::AssocKind::Const => true,\n             },\n         }"}, {"sha": "67bdd04d3715c8fc17ae2a2c2011034f71e5058d", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=ce6d3a73b514e9649e57cee812ad129bb2112016", "patch": "@@ -158,9 +158,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             let path = self.tcx.def_path_str(trait_ref.def_id);\n \n                             let ty = match item.kind {\n-                                ty::AssocKind::Const\n-                                | ty::AssocKind::Type\n-                                | ty::AssocKind::OpaqueTy => rcvr_ty,\n+                                ty::AssocKind::Const | ty::AssocKind::Type => rcvr_ty,\n                                 ty::AssocKind::Fn => self\n                                     .tcx\n                                     .fn_sig(item.def_id)"}, {"sha": "7b8f18021968827735d93babc8c11281e3a0c5fd", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=ce6d3a73b514e9649e57cee812ad129bb2112016", "patch": "@@ -1943,7 +1943,6 @@ fn check_specialization_validity<'tcx>(\n     let kind = match impl_item.kind {\n         hir::ImplItemKind::Const(..) => ty::AssocKind::Const,\n         hir::ImplItemKind::Fn(..) => ty::AssocKind::Fn,\n-        hir::ImplItemKind::OpaqueTy(..) => ty::AssocKind::OpaqueTy,\n         hir::ImplItemKind::TyAlias(_) => ty::AssocKind::Type,\n     };\n \n@@ -2114,7 +2113,7 @@ fn check_impl_items_against_trait<'tcx>(\n                         err.emit()\n                     }\n                 }\n-                hir::ImplItemKind::OpaqueTy(..) | hir::ImplItemKind::TyAlias(_) => {\n+                hir::ImplItemKind::TyAlias(_) => {\n                     let opt_trait_span = tcx.hir().span_if_local(ty_trait_item.def_id);\n                     if ty_trait_item.kind == ty::AssocKind::Type {\n                         compare_ty_impl(\n@@ -2367,8 +2366,6 @@ fn suggestion_signature(assoc: &ty::AssocItem, tcx: TyCtxt<'_>) -> String {\n             )\n         }\n         ty::AssocKind::Type => format!(\"type {} = Type;\", assoc.ident),\n-        // FIXME(type_alias_impl_trait): we should print bounds here too.\n-        ty::AssocKind::OpaqueTy => format!(\"type {} = Type;\", assoc.ident),\n         ty::AssocKind::Const => {\n             let ty = tcx.type_of(assoc.def_id);\n             let val = expr::ty_kind_suggestion(ty).unwrap_or(\"value\");"}, {"sha": "f3297ed67434758441bc026443e54aab1384d847", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 93, "deletions": 98, "changes": 191, "blob_url": "https://github.com/rust-lang/rust/blob/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=ce6d3a73b514e9649e57cee812ad129bb2112016", "patch": "@@ -316,9 +316,6 @@ fn check_associated_item(\n                     fcx.register_wf_obligation(ty.into(), span, code.clone());\n                 }\n             }\n-            ty::AssocKind::OpaqueTy => {\n-                // Do nothing: opaque types check themselves.\n-            }\n         }\n \n         implied_bounds\n@@ -804,14 +801,14 @@ fn check_where_clauses<'tcx, 'fcx>(\n             traits::Obligation::new(cause, fcx.param_env, pred)\n         });\n \n-    let mut predicates = predicates.instantiate_identity(fcx.tcx);\n+    let predicates = predicates.instantiate_identity(fcx.tcx);\n \n-    if let Some((return_ty, span)) = return_ty {\n-        let opaque_types = check_opaque_types(tcx, fcx, def_id.expect_local(), span, return_ty);\n-        for _ in 0..opaque_types.len() {\n-            predicates.spans.push(span);\n+    if let Some((mut return_ty, span)) = return_ty {\n+        if return_ty.has_infer_types_or_consts() {\n+            fcx.select_obligations_where_possible(false, |_| {});\n+            return_ty = fcx.resolve_vars_if_possible(&return_ty);\n         }\n-        predicates.predicates.extend(opaque_types);\n+        check_opaque_types(tcx, fcx, def_id.expect_local(), span, return_ty);\n     }\n \n     let predicates = fcx.normalize_associated_types_in(span, &predicates);\n@@ -883,119 +880,117 @@ fn check_opaque_types<'fcx, 'tcx>(\n     fn_def_id: LocalDefId,\n     span: Span,\n     ty: Ty<'tcx>,\n-) -> Vec<ty::Predicate<'tcx>> {\n+) {\n     trace!(\"check_opaque_types(ty={:?})\", ty);\n-    let mut substituted_predicates = Vec::new();\n     ty.fold_with(&mut ty::fold::BottomUpFolder {\n         tcx: fcx.tcx,\n         ty_op: |ty| {\n             if let ty::Opaque(def_id, substs) = ty.kind {\n                 trace!(\"check_opaque_types: opaque_ty, {:?}, {:?}\", def_id, substs);\n                 let generics = tcx.generics_of(def_id);\n-                // Only check named `impl Trait` types defined in this crate.\n-                // FIXME(eddyb) is  `generics.parent.is_none()` correct? It seems\n-                // potentially risky wrt associated types in `impl`s.\n-                if generics.parent.is_none() && def_id.is_local() {\n-                    let opaque_hir_id = tcx.hir().as_local_hir_id(def_id.expect_local());\n-                    if may_define_opaque_type(tcx, fn_def_id, opaque_hir_id) {\n-                        trace!(\"check_opaque_types: may define, generics={:#?}\", generics);\n-                        let mut seen_params: FxHashMap<_, Vec<_>> = FxHashMap::default();\n-                        for (i, arg) in substs.iter().enumerate() {\n-                            let arg_is_param = match arg.unpack() {\n-                                GenericArgKind::Type(ty) => matches!(ty.kind, ty::Param(_)),\n-\n-                                GenericArgKind::Lifetime(region) => {\n-                                    if let ty::ReStatic = region {\n-                                        tcx.sess\n-                                            .struct_span_err(\n-                                                span,\n-                                                \"non-defining opaque type use in defining scope\",\n-                                            )\n-                                            .span_label(\n-                                                tcx.def_span(generics.param_at(i, tcx).def_id),\n-                                                \"cannot use static lifetime; use a bound lifetime \\\n-                                                 instead or remove the lifetime parameter from the \\\n-                                                 opaque type\",\n-                                            )\n-                                            .emit();\n-                                        continue;\n-                                    }\n-\n-                                    true\n-                                }\n-\n-                                GenericArgKind::Const(ct) => {\n-                                    matches!(ct.val, ty::ConstKind::Param(_))\n-                                }\n-                            };\n-\n-                            if arg_is_param {\n-                                seen_params.entry(arg).or_default().push(i);\n-                            } else {\n-                                // Prevent `fn foo() -> Foo<u32>` from being defining.\n-                                let opaque_param = generics.param_at(i, tcx);\n+\n+                let opaque_hir_id = if let Some(local_id) = def_id.as_local() {\n+                    tcx.hir().as_local_hir_id(local_id)\n+                } else {\n+                    // Opaque types from other crates won't have defining uses in this crate.\n+                    return ty;\n+                };\n+                if let hir::ItemKind::OpaqueTy(hir::OpaqueTy { impl_trait_fn: Some(_), .. }) =\n+                    tcx.hir().expect_item(opaque_hir_id).kind\n+                {\n+                    // No need to check return position impl trait (RPIT)\n+                    // because for type and const parameters they are correct\n+                    // by construction: we convert\n+                    //\n+                    // fn foo<P0..Pn>() -> impl Trait\n+                    //\n+                    // into\n+                    //\n+                    // type Foo<P0...Pn>\n+                    // fn foo<P0..Pn>() -> Foo<P0...Pn>.\n+                    //\n+                    // For lifetime parameters we convert\n+                    //\n+                    // fn foo<'l0..'ln>() -> impl Trait<'l0..'lm>\n+                    //\n+                    // into\n+                    //\n+                    // type foo::<'p0..'pn>::Foo<'q0..'qm>\n+                    // fn foo<l0..'ln>() -> foo::<'static..'static>::Foo<'l0..'lm>.\n+                    //\n+                    // which would error here on all of the `'static` args.\n+                    return ty;\n+                }\n+                if !may_define_opaque_type(tcx, fn_def_id, opaque_hir_id) {\n+                    return ty;\n+                }\n+                trace!(\"check_opaque_types: may define, generics={:#?}\", generics);\n+                let mut seen_params: FxHashMap<_, Vec<_>> = FxHashMap::default();\n+                for (i, arg) in substs.iter().enumerate() {\n+                    let arg_is_param = match arg.unpack() {\n+                        GenericArgKind::Type(ty) => matches!(ty.kind, ty::Param(_)),\n+\n+                        GenericArgKind::Lifetime(region) => {\n+                            if let ty::ReStatic = region {\n                                 tcx.sess\n                                     .struct_span_err(\n                                         span,\n                                         \"non-defining opaque type use in defining scope\",\n                                     )\n-                                    .span_note(\n-                                        tcx.def_span(opaque_param.def_id),\n-                                        &format!(\n-                                            \"used non-generic {} `{}` for generic parameter\",\n-                                            opaque_param.kind.descr(),\n-                                            arg,\n-                                        ),\n-                                    )\n-                                    .emit();\n-                            }\n-                        } // for (arg, param)\n-\n-                        for (_, indices) in seen_params {\n-                            if indices.len() > 1 {\n-                                let descr = generics.param_at(indices[0], tcx).kind.descr();\n-                                let spans: Vec<_> = indices\n-                                    .into_iter()\n-                                    .map(|i| tcx.def_span(generics.param_at(i, tcx).def_id))\n-                                    .collect();\n-                                tcx.sess\n-                                    .struct_span_err(\n-                                        span,\n-                                        \"non-defining opaque type use in defining scope\",\n+                                    .span_label(\n+                                        tcx.def_span(generics.param_at(i, tcx).def_id),\n+                                        \"cannot use static lifetime; use a bound lifetime \\\n+                                                 instead or remove the lifetime parameter from the \\\n+                                                 opaque type\",\n                                     )\n-                                    .span_note(spans, &format!(\"{} used multiple times\", descr))\n                                     .emit();\n+                                continue;\n                             }\n-                        }\n-                    } // if may_define_opaque_type\n \n-                    // Now register the bounds on the parameters of the opaque type\n-                    // so the parameters given by the function need to fulfill them.\n-                    //\n-                    //     type Foo<T: Bar> = impl Baz + 'static;\n-                    //     fn foo<U>() -> Foo<U> { .. *}\n-                    //\n-                    // becomes\n-                    //\n-                    //     type Foo<T: Bar> = impl Baz + 'static;\n-                    //     fn foo<U: Bar>() -> Foo<U> { .. *}\n-                    let predicates = tcx.predicates_of(def_id);\n-                    trace!(\"check_opaque_types: may define, predicates={:#?}\", predicates,);\n-                    for &(pred, _) in predicates.predicates {\n-                        let substituted_pred = pred.subst(fcx.tcx, substs);\n-                        // Avoid duplication of predicates that contain no parameters, for example.\n-                        if !predicates.predicates.iter().any(|&(p, _)| p == substituted_pred) {\n-                            substituted_predicates.push(substituted_pred);\n+                            true\n                         }\n+\n+                        GenericArgKind::Const(ct) => matches!(ct.val, ty::ConstKind::Param(_)),\n+                    };\n+\n+                    if arg_is_param {\n+                        seen_params.entry(arg).or_default().push(i);\n+                    } else {\n+                        // Prevent `fn foo() -> Foo<u32>` from being defining.\n+                        let opaque_param = generics.param_at(i, tcx);\n+                        tcx.sess\n+                            .struct_span_err(span, \"non-defining opaque type use in defining scope\")\n+                            .span_note(\n+                                tcx.def_span(opaque_param.def_id),\n+                                &format!(\n+                                    \"used non-generic {} `{}` for generic parameter\",\n+                                    opaque_param.kind.descr(),\n+                                    arg,\n+                                ),\n+                            )\n+                            .emit();\n                     }\n-                } // if is_named_opaque_type\n+                } // for (arg, param)\n+\n+                for (_, indices) in seen_params {\n+                    if indices.len() > 1 {\n+                        let descr = generics.param_at(indices[0], tcx).kind.descr();\n+                        let spans: Vec<_> = indices\n+                            .into_iter()\n+                            .map(|i| tcx.def_span(generics.param_at(i, tcx).def_id))\n+                            .collect();\n+                        tcx.sess\n+                            .struct_span_err(span, \"non-defining opaque type use in defining scope\")\n+                            .span_note(spans, &format!(\"{} used multiple times\", descr))\n+                            .emit();\n+                    }\n+                }\n             } // if let Opaque\n             ty\n         },\n         lt_op: |lt| lt,\n         ct_op: |ct| ct,\n     });\n-    substituted_predicates\n }\n \n const HELP_FOR_SELF_TYPE: &str = \"consider changing to `self`, `&self`, `&mut self`, `self: Box<Self>`, \\"}, {"sha": "159d3d7a538a668e18c5b20910e3e0f06caa7c8c", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=ce6d3a73b514e9649e57cee812ad129bb2112016", "patch": "@@ -460,7 +460,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n             let mut skip_add = false;\n \n             if let ty::Opaque(defin_ty_def_id, _substs) = definition_ty.kind {\n-                if let hir::OpaqueTyOrigin::TypeAlias = opaque_defn.origin {\n+                if let hir::OpaqueTyOrigin::Misc = opaque_defn.origin {\n                     if def_id == defin_ty_def_id {\n                         debug!(\n                             \"skipping adding concrete definition for opaque type {:?} {:?}\","}, {"sha": "1d59d749634ee1cae5ac8913cf7ba5c8f6bdf596", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 8, "deletions": 43, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=ce6d3a73b514e9649e57cee812ad129bb2112016", "patch": "@@ -742,7 +742,7 @@ fn convert_impl_item(tcx: TyCtxt<'_>, impl_item_id: hir::HirId) {\n         hir::ImplItemKind::Fn(..) => {\n             tcx.ensure().fn_sig(def_id);\n         }\n-        hir::ImplItemKind::TyAlias(_) | hir::ImplItemKind::OpaqueTy(_) => {\n+        hir::ImplItemKind::TyAlias(_) => {\n             // Account for `type T = _;`\n             let mut visitor = PlaceholderHirTyCollector::default();\n             visitor.visit_impl_item(impl_item);\n@@ -1202,22 +1202,11 @@ fn generics_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::Generics {\n             ItemKind::OpaqueTy(hir::OpaqueTy { impl_trait_fn, .. }) => {\n                 impl_trait_fn.or_else(|| {\n                     let parent_id = tcx.hir().get_parent_item(hir_id);\n-                    if parent_id != hir_id && parent_id != CRATE_HIR_ID {\n-                        debug!(\"generics_of: parent of opaque ty {:?} is {:?}\", def_id, parent_id);\n-                        // If this 'impl Trait' is nested inside another 'impl Trait'\n-                        // (e.g. `impl Foo<MyType = impl Bar<A>>`), we need to use the 'parent'\n-                        // 'impl Trait' for its generic parameters, since we can reference them\n-                        // from the 'child' 'impl Trait'\n-                        if let Node::Item(hir::Item { kind: ItemKind::OpaqueTy(..), .. }) =\n-                            tcx.hir().get(parent_id)\n-                        {\n-                            Some(tcx.hir().local_def_id(parent_id).to_def_id())\n-                        } else {\n-                            None\n-                        }\n-                    } else {\n-                        None\n-                    }\n+                    assert!(parent_id != hir_id && parent_id != CRATE_HIR_ID);\n+                    debug!(\"generics_of: parent of opaque ty {:?} is {:?}\", def_id, parent_id);\n+                    // Opaque types are always nested within another item, and\n+                    // inherit the generics of the item.\n+                    Some(tcx.hir().local_def_id(parent_id).to_def_id())\n                 })\n             }\n             _ => None,\n@@ -1428,7 +1417,7 @@ fn is_suggestable_infer_ty(ty: &hir::Ty<'_>) -> bool {\n         Slice(ty) | Array(ty, _) => is_suggestable_infer_ty(ty),\n         Tup(tys) => tys.iter().any(is_suggestable_infer_ty),\n         Ptr(mut_ty) | Rptr(_, mut_ty) => is_suggestable_infer_ty(mut_ty.ty),\n-        Def(_, generic_args) => are_suggestable_generic_args(generic_args),\n+        OpaqueDef(_, generic_args) => are_suggestable_generic_args(generic_args),\n         Path(hir::QPath::TypeRelative(ty, segment)) => {\n             is_suggestable_infer_ty(ty) || are_suggestable_generic_args(segment.generic_args().args)\n         }\n@@ -1715,31 +1704,7 @@ fn explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericPredicat\n     let ast_generics = match node {\n         Node::TraitItem(item) => &item.generics,\n \n-        Node::ImplItem(item) => match item.kind {\n-            ImplItemKind::OpaqueTy(ref bounds) => {\n-                ty::print::with_no_queries(|| {\n-                    let substs = InternalSubsts::identity_for_item(tcx, def_id);\n-                    let opaque_ty = tcx.mk_opaque(def_id, substs);\n-                    debug!(\n-                        \"explicit_predicates_of({:?}): created opaque type {:?}\",\n-                        def_id, opaque_ty\n-                    );\n-\n-                    // Collect the bounds, i.e., the `A + B + 'c` in `impl A + B + 'c`.\n-                    let bounds = AstConv::compute_bounds(\n-                        &icx,\n-                        opaque_ty,\n-                        bounds,\n-                        SizedByDefault::Yes,\n-                        tcx.def_span(def_id),\n-                    );\n-\n-                    predicates.extend(bounds.predicates(tcx, opaque_ty));\n-                    &item.generics\n-                })\n-            }\n-            _ => &item.generics,\n-        },\n+        Node::ImplItem(item) => &item.generics,\n \n         Node::Item(item) => {\n             match item.kind {"}, {"sha": "549a20531e2994b5d6688ec43938d2b6ce096f4b", "filename": "src/librustc_typeck/collect/type_of.rs", "status": "modified", "additions": 61, "deletions": 30, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Flibrustc_typeck%2Fcollect%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Flibrustc_typeck%2Fcollect%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect%2Ftype_of.rs?ref=ce6d3a73b514e9649e57cee812ad129bb2112016", "patch": "@@ -64,13 +64,6 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n                     icx.to_ty(ty)\n                 }\n             }\n-            ImplItemKind::OpaqueTy(_) => {\n-                if tcx.impl_trait_ref(tcx.hir().get_parent_did(hir_id).to_def_id()).is_none() {\n-                    report_assoc_ty_on_inherent_impl(tcx, item.span);\n-                }\n-\n-                find_opaque_ty_constraints(tcx, def_id.expect_local())\n-            }\n             ImplItemKind::TyAlias(ref ty) => {\n                 if tcx.impl_trait_ref(tcx.hir().get_parent_did(hir_id).to_def_id()).is_none() {\n                     report_assoc_ty_on_inherent_impl(tcx, item.span);\n@@ -107,26 +100,17 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n                     let substs = InternalSubsts::identity_for_item(tcx, def_id);\n                     tcx.mk_adt(def, substs)\n                 }\n+                ItemKind::OpaqueTy(OpaqueTy { origin: hir::OpaqueTyOrigin::Binding, .. }) => {\n+                    let_position_impl_trait_type(tcx, def_id.expect_local())\n+                }\n                 ItemKind::OpaqueTy(OpaqueTy { impl_trait_fn: None, .. }) => {\n                     find_opaque_ty_constraints(tcx, def_id.expect_local())\n                 }\n                 // Opaque types desugared from `impl Trait`.\n-                ItemKind::OpaqueTy(OpaqueTy { impl_trait_fn: Some(owner), origin, .. }) => {\n-                    let concrete_types = match origin {\n-                        OpaqueTyOrigin::FnReturn | OpaqueTyOrigin::AsyncFn => {\n-                            &tcx.mir_borrowck(owner.expect_local()).concrete_opaque_types\n-                        }\n-                        OpaqueTyOrigin::Misc => {\n-                            // We shouldn't leak borrowck results through impl trait in bindings.\n-                            // For example, we shouldn't be able to tell if `x` in\n-                            // `let x: impl Sized + 'a = &()` has type `&'static ()` or `&'a ()`.\n-                            &tcx.typeck_tables_of(owner.expect_local()).concrete_opaque_types\n-                        }\n-                        OpaqueTyOrigin::TypeAlias => {\n-                            span_bug!(item.span, \"Type alias impl trait shouldn't have an owner\")\n-                        }\n-                    };\n-                    let concrete_ty = concrete_types\n+                ItemKind::OpaqueTy(OpaqueTy { impl_trait_fn: Some(owner), .. }) => {\n+                    let concrete_ty = tcx\n+                        .mir_borrowck(owner.expect_local())\n+                        .concrete_opaque_types\n                         .get(&def_id)\n                         .map(|opaque| opaque.concrete_type)\n                         .unwrap_or_else(|| {\n@@ -155,13 +139,6 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n                             }\n                         });\n                     debug!(\"concrete_ty = {:?}\", concrete_ty);\n-                    if concrete_ty.has_erased_regions() {\n-                        // FIXME(impl_trait_in_bindings) Handle this case.\n-                        tcx.sess.span_fatal(\n-                            item.span,\n-                            \"lifetimes in impl Trait types in bindings are not currently supported\",\n-                        );\n-                    }\n                     concrete_ty\n                 }\n                 ItemKind::Trait(..)\n@@ -596,6 +573,60 @@ fn find_opaque_ty_constraints(tcx: TyCtxt<'_>, def_id: LocalDefId) -> Ty<'_> {\n     }\n }\n \n+/// Retrieve the inferred concrete type for let position impl trait.\n+///\n+/// This is different to other kinds of impl trait because:\n+///\n+/// 1. We know which function contains the defining use (the function that\n+///    contains the let statement)\n+/// 2. We do not currently allow (free) lifetimes in the return type. `let`\n+///    statements in some statically unreachable code are removed from the MIR\n+///    by the time we borrow check, and it's not clear how we should handle\n+///    those.\n+fn let_position_impl_trait_type(tcx: TyCtxt<'_>, opaque_ty_id: LocalDefId) -> Ty<'_> {\n+    let scope = tcx.hir().get_defining_scope(tcx.hir().as_local_hir_id(opaque_ty_id));\n+    let scope_def_id = tcx.hir().local_def_id(scope);\n+\n+    let opaque_ty_def_id = opaque_ty_id.to_def_id();\n+\n+    let owner_tables = tcx.typeck_tables_of(scope_def_id);\n+    let concrete_ty = owner_tables\n+        .concrete_opaque_types\n+        .get(&opaque_ty_def_id)\n+        .map(|opaque| opaque.concrete_type)\n+        .unwrap_or_else(|| {\n+            tcx.sess.delay_span_bug(\n+                DUMMY_SP,\n+                &format!(\n+                    \"owner {:?} has no opaque type for {:?} in its tables\",\n+                    scope_def_id, opaque_ty_id\n+                ),\n+            );\n+            if let Some(ErrorReported) = owner_tables.tainted_by_errors {\n+                // Some error in the owner fn prevented us from populating the\n+                // `concrete_opaque_types` table.\n+                tcx.types.err\n+            } else {\n+                // We failed to resolve the opaque type or it resolves to\n+                // itself. Return the non-revealed type, which should result in\n+                // E0720.\n+                tcx.mk_opaque(\n+                    opaque_ty_def_id,\n+                    InternalSubsts::identity_for_item(tcx, opaque_ty_def_id),\n+                )\n+            }\n+        });\n+    debug!(\"concrete_ty = {:?}\", concrete_ty);\n+    if concrete_ty.has_erased_regions() {\n+        // FIXME(impl_trait_in_bindings) Handle this case.\n+        tcx.sess.span_fatal(\n+            tcx.hir().span(tcx.hir().as_local_hir_id(opaque_ty_id)),\n+            \"lifetimes in impl Trait types in bindings are not currently supported\",\n+        );\n+    }\n+    concrete_ty\n+}\n+\n fn infer_placeholder_type(\n     tcx: TyCtxt<'_>,\n     def_id: LocalDefId,"}, {"sha": "37d383db68ab6ae917ca7efb6d2c086031c1513b", "filename": "src/librustc_typeck/impl_wf_check.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Flibrustc_typeck%2Fimpl_wf_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Flibrustc_typeck%2Fimpl_wf_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fimpl_wf_check.rs?ref=ce6d3a73b514e9649e57cee812ad129bb2112016", "patch": "@@ -140,13 +140,6 @@ fn enforce_impl_params_are_constrained(\n                         Vec::new()\n                     }\n                 }\n-                ty::AssocKind::OpaqueTy => {\n-                    // We don't know which lifetimes appear in the actual\n-                    // opaque type, so use all of the lifetimes that appear\n-                    // in the type's predicates.\n-                    let predicates = tcx.predicates_of(def_id).instantiate_identity(tcx);\n-                    cgp::parameters_for(&predicates, true)\n-                }\n                 ty::AssocKind::Fn | ty::AssocKind::Const => Vec::new(),\n             }\n         })"}, {"sha": "adb2ae9a5d660766984c58170ac41f3b73596132", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=ce6d3a73b514e9649e57cee812ad129bb2112016", "patch": "@@ -1138,10 +1138,6 @@ impl Clean<Item> for hir::ImplItem<'_> {\n                 let item_type = type_.def_id().and_then(|did| inline::build_ty(cx, did));\n                 TypedefItem(Typedef { type_, generics: Generics::default(), item_type }, true)\n             }\n-            hir::ImplItemKind::OpaqueTy(ref bounds) => OpaqueTyItem(\n-                OpaqueTy { bounds: bounds.clean(cx), generics: Generics::default() },\n-                true,\n-            ),\n         };\n         let local_did = cx.tcx.hir().local_def_id(self.hir_id);\n         Item {\n@@ -1308,7 +1304,6 @@ impl Clean<Item> for ty::AssocItem {\n                     )\n                 }\n             }\n-            ty::AssocKind::OpaqueTy => unimplemented!(),\n         };\n \n         let visibility = match self.container {\n@@ -1356,7 +1351,7 @@ impl Clean<Type> for hir::Ty<'_> {\n                 Array(box ty.clean(cx), length)\n             }\n             TyKind::Tup(ref tys) => Tuple(tys.clean(cx)),\n-            TyKind::Def(item_id, _) => {\n+            TyKind::OpaqueDef(item_id, _) => {\n                 let item = cx.tcx.hir().expect_item(item_id.id);\n                 if let hir::ItemKind::OpaqueTy(ref ty) = item.kind {\n                     ImplTrait(ty.bounds.clean(cx))"}, {"sha": "e05a3bc6d91807673ae47ea45433ed8f8d37d90e", "filename": "src/test/rustdoc/auxiliary/issue-73061.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Ftest%2Frustdoc%2Fauxiliary%2Fissue-73061.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Ftest%2Frustdoc%2Fauxiliary%2Fissue-73061.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fauxiliary%2Fissue-73061.rs?ref=ce6d3a73b514e9649e57cee812ad129bb2112016", "patch": "@@ -0,0 +1,17 @@\n+//edition:2018\n+\n+#![feature(type_alias_impl_trait)]\n+\n+pub trait Foo {\n+    type X: std::future::Future<Output = ()>;\n+    fn x(&self) -> Self::X;\n+}\n+\n+pub struct F;\n+\n+impl Foo for F {\n+    type X = impl std::future::Future<Output = ()>;\n+    fn x(&self) -> Self::X {\n+        async {}\n+    }\n+}"}, {"sha": "2700f2370eec8e85ffa10c2138315d3cb9a74bf5", "filename": "src/test/rustdoc/issue-73061-cross-crate-opaque-assoc-type.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Ftest%2Frustdoc%2Fissue-73061-cross-crate-opaque-assoc-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Ftest%2Frustdoc%2Fissue-73061-cross-crate-opaque-assoc-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fissue-73061-cross-crate-opaque-assoc-type.rs?ref=ce6d3a73b514e9649e57cee812ad129bb2112016", "patch": "@@ -0,0 +1,14 @@\n+// Regression test for ICE #73061\n+\n+// aux-build:issue-73061.rs\n+\n+extern crate issue_73061;\n+\n+pub struct Z;\n+\n+impl issue_73061::Foo for Z {\n+    type X = <issue_73061::F as issue_73061::Foo>::X;\n+    fn x(&self) -> Self::X {\n+        issue_73061::F.x()\n+    }\n+}"}, {"sha": "8b5c5219430b6e9f517af3e7b91d32942d2573e0", "filename": "src/test/ui/associated-type-bounds/duplicate.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fduplicate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fduplicate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fduplicate.rs?ref=ce6d3a73b514e9649e57cee812ad129bb2112016", "patch": "@@ -108,18 +108,12 @@ type TAW3<T> where T: Iterator<Item: 'static, Item: 'static> = T;\n type ETAI1<T: Iterator<Item: Copy, Item: Send>> = impl Copy;\n //~^ ERROR the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified [E0719]\n //~| ERROR could not find defining uses\n-//~| ERROR could not find defining uses\n-//~| ERROR could not find defining uses\n type ETAI2<T: Iterator<Item: Copy, Item: Copy>> = impl Copy;\n //~^ ERROR the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified [E0719]\n //~| ERROR could not find defining uses\n-//~| ERROR could not find defining uses\n-//~| ERROR could not find defining uses\n type ETAI3<T: Iterator<Item: 'static, Item: 'static>> = impl Copy;\n //~^ ERROR the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified [E0719]\n //~| ERROR could not find defining uses\n-//~| ERROR could not find defining uses\n-//~| ERROR could not find defining uses\n type ETAI4 = impl Iterator<Item: Copy, Item: Send>;\n //~^ ERROR the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified [E0719]\n //~| ERROR could not find defining uses"}, {"sha": "712211e60cbace04c98d1dac8d42b2f0efae431a", "filename": "src/test/ui/associated-type-bounds/duplicate.stderr", "status": "modified", "additions": 81, "deletions": 117, "changes": 198, "blob_url": "https://github.com/rust-lang/rust/blob/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fduplicate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fduplicate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fduplicate.stderr?ref=ce6d3a73b514e9649e57cee812ad129bb2112016", "patch": "@@ -223,30 +223,6 @@ LL | fn FAPIT3(_: impl Iterator<Item: 'static, Item: 'static>) {}\n    |                            |\n    |                            `Item` bound here first\n \n-error[E0719]: the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:62:42\n-   |\n-LL | fn FRPIT1() -> impl Iterator<Item: Copy, Item: Send> { iter::empty() }\n-   |                              ----------  ^^^^^^^^^^ re-bound here\n-   |                              |\n-   |                              `Item` bound here first\n-\n-error[E0719]: the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:64:42\n-   |\n-LL | fn FRPIT2() -> impl Iterator<Item: Copy, Item: Copy> { iter::empty() }\n-   |                              ----------  ^^^^^^^^^^ re-bound here\n-   |                              |\n-   |                              `Item` bound here first\n-\n-error[E0719]: the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:66:45\n-   |\n-LL | fn FRPIT3() -> impl Iterator<Item: 'static, Item: 'static> { iter::empty() }\n-   |                              -------------  ^^^^^^^^^^^^^ re-bound here\n-   |                              |\n-   |                              `Item` bound here first\n-\n error[E0719]: the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified\n   --> $DIR/duplicate.rs:75:39\n    |\n@@ -367,12 +343,6 @@ LL | type TAW3<T> where T: Iterator<Item: 'static, Item: 'static> = T;\n    |                                |\n    |                                `Item` bound here first\n \n-error: could not find defining uses\n-  --> $DIR/duplicate.rs:108:1\n-   |\n-LL | type ETAI1<T: Iterator<Item: Copy, Item: Send>> = impl Copy;\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-\n error[E0719]: the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified\n   --> $DIR/duplicate.rs:108:36\n    |\n@@ -381,352 +351,346 @@ LL | type ETAI1<T: Iterator<Item: Copy, Item: Send>> = impl Copy;\n    |                        |\n    |                        `Item` bound here first\n \n+error[E0719]: the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified\n+  --> $DIR/duplicate.rs:62:42\n+   |\n+LL | fn FRPIT1() -> impl Iterator<Item: Copy, Item: Send> { iter::empty() }\n+   |                              ----------  ^^^^^^^^^^ re-bound here\n+   |                              |\n+   |                              `Item` bound here first\n+\n+error[E0719]: the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified\n+  --> $DIR/duplicate.rs:64:42\n+   |\n+LL | fn FRPIT2() -> impl Iterator<Item: Copy, Item: Copy> { iter::empty() }\n+   |                              ----------  ^^^^^^^^^^ re-bound here\n+   |                              |\n+   |                              `Item` bound here first\n+\n+error[E0719]: the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified\n+  --> $DIR/duplicate.rs:66:45\n+   |\n+LL | fn FRPIT3() -> impl Iterator<Item: 'static, Item: 'static> { iter::empty() }\n+   |                              -------------  ^^^^^^^^^^^^^ re-bound here\n+   |                              |\n+   |                              `Item` bound here first\n+\n error: could not find defining uses\n-  --> $DIR/duplicate.rs:113:1\n+  --> $DIR/duplicate.rs:108:51\n    |\n-LL | type ETAI2<T: Iterator<Item: Copy, Item: Copy>> = impl Copy;\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | type ETAI1<T: Iterator<Item: Copy, Item: Send>> = impl Copy;\n+   |                                                   ^^^^^^^^^\n \n error[E0719]: the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:113:36\n+  --> $DIR/duplicate.rs:111:36\n    |\n LL | type ETAI2<T: Iterator<Item: Copy, Item: Copy>> = impl Copy;\n    |                        ----------  ^^^^^^^^^^ re-bound here\n    |                        |\n    |                        `Item` bound here first\n \n error: could not find defining uses\n-  --> $DIR/duplicate.rs:118:1\n+  --> $DIR/duplicate.rs:111:51\n    |\n-LL | type ETAI3<T: Iterator<Item: 'static, Item: 'static>> = impl Copy;\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | type ETAI2<T: Iterator<Item: Copy, Item: Copy>> = impl Copy;\n+   |                                                   ^^^^^^^^^\n \n error[E0719]: the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:118:39\n+  --> $DIR/duplicate.rs:114:39\n    |\n LL | type ETAI3<T: Iterator<Item: 'static, Item: 'static>> = impl Copy;\n    |                        -------------  ^^^^^^^^^^^^^ re-bound here\n    |                        |\n    |                        `Item` bound here first\n \n error: could not find defining uses\n-  --> $DIR/duplicate.rs:123:1\n+  --> $DIR/duplicate.rs:114:57\n+   |\n+LL | type ETAI3<T: Iterator<Item: 'static, Item: 'static>> = impl Copy;\n+   |                                                         ^^^^^^^^^\n+\n+error: could not find defining uses\n+  --> $DIR/duplicate.rs:117:14\n    |\n LL | type ETAI4 = impl Iterator<Item: Copy, Item: Send>;\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0719]: the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:123:40\n+  --> $DIR/duplicate.rs:117:40\n    |\n LL | type ETAI4 = impl Iterator<Item: Copy, Item: Send>;\n    |                            ----------  ^^^^^^^^^^ re-bound here\n    |                            |\n    |                            `Item` bound here first\n \n error: could not find defining uses\n-  --> $DIR/duplicate.rs:128:1\n+  --> $DIR/duplicate.rs:122:14\n    |\n LL | type ETAI5 = impl Iterator<Item: Copy, Item: Copy>;\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0719]: the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:128:40\n+  --> $DIR/duplicate.rs:122:40\n    |\n LL | type ETAI5 = impl Iterator<Item: Copy, Item: Copy>;\n    |                            ----------  ^^^^^^^^^^ re-bound here\n    |                            |\n    |                            `Item` bound here first\n \n error: could not find defining uses\n-  --> $DIR/duplicate.rs:133:1\n+  --> $DIR/duplicate.rs:127:14\n    |\n LL | type ETAI6 = impl Iterator<Item: 'static, Item: 'static>;\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0719]: the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:133:43\n+  --> $DIR/duplicate.rs:127:43\n    |\n LL | type ETAI6 = impl Iterator<Item: 'static, Item: 'static>;\n    |                            -------------  ^^^^^^^^^^^^^ re-bound here\n    |                            |\n    |                            `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:139:36\n+  --> $DIR/duplicate.rs:133:36\n    |\n LL | trait TRI1<T: Iterator<Item: Copy, Item: Send>> {}\n    |                        ----------  ^^^^^^^^^^ re-bound here\n    |                        |\n    |                        `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:141:36\n+  --> $DIR/duplicate.rs:135:36\n    |\n LL | trait TRI2<T: Iterator<Item: Copy, Item: Copy>> {}\n    |                        ----------  ^^^^^^^^^^ re-bound here\n    |                        |\n    |                        `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:143:39\n+  --> $DIR/duplicate.rs:137:39\n    |\n LL | trait TRI3<T: Iterator<Item: 'static, Item: 'static>> {}\n    |                        -------------  ^^^^^^^^^^^^^ re-bound here\n    |                        |\n    |                        `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:145:34\n+  --> $DIR/duplicate.rs:139:34\n    |\n LL | trait TRS1: Iterator<Item: Copy, Item: Send> {}\n    |                      ----------  ^^^^^^^^^^ re-bound here\n    |                      |\n    |                      `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:147:34\n+  --> $DIR/duplicate.rs:141:34\n    |\n LL | trait TRS2: Iterator<Item: Copy, Item: Copy> {}\n    |                      ----------  ^^^^^^^^^^ re-bound here\n    |                      |\n    |                      `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:149:37\n+  --> $DIR/duplicate.rs:143:37\n    |\n LL | trait TRS3: Iterator<Item: 'static, Item: 'static> {}\n    |                      -------------  ^^^^^^^^^^^^^ re-bound here\n    |                      |\n    |                      `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:151:45\n+  --> $DIR/duplicate.rs:145:45\n    |\n LL | trait TRW1<T> where T: Iterator<Item: Copy, Item: Send> {}\n    |                                 ----------  ^^^^^^^^^^ re-bound here\n    |                                 |\n    |                                 `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:153:45\n+  --> $DIR/duplicate.rs:147:45\n    |\n LL | trait TRW2<T> where T: Iterator<Item: Copy, Item: Copy> {}\n    |                                 ----------  ^^^^^^^^^^ re-bound here\n    |                                 |\n    |                                 `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:155:48\n+  --> $DIR/duplicate.rs:149:48\n    |\n LL | trait TRW3<T> where T: Iterator<Item: 'static, Item: 'static> {}\n    |                                 -------------  ^^^^^^^^^^^^^ re-bound here\n    |                                 |\n    |                                 `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:157:46\n+  --> $DIR/duplicate.rs:151:46\n    |\n LL | trait TRSW1 where Self: Iterator<Item: Copy, Item: Send> {}\n    |                                  ----------  ^^^^^^^^^^ re-bound here\n    |                                  |\n    |                                  `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:157:46\n+  --> $DIR/duplicate.rs:151:46\n    |\n LL | trait TRSW1 where Self: Iterator<Item: Copy, Item: Send> {}\n    |                                  ----------  ^^^^^^^^^^ re-bound here\n    |                                  |\n    |                                  `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:160:46\n+  --> $DIR/duplicate.rs:154:46\n    |\n LL | trait TRSW2 where Self: Iterator<Item: Copy, Item: Copy> {}\n    |                                  ----------  ^^^^^^^^^^ re-bound here\n    |                                  |\n    |                                  `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:160:46\n+  --> $DIR/duplicate.rs:154:46\n    |\n LL | trait TRSW2 where Self: Iterator<Item: Copy, Item: Copy> {}\n    |                                  ----------  ^^^^^^^^^^ re-bound here\n    |                                  |\n    |                                  `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:163:49\n+  --> $DIR/duplicate.rs:157:49\n    |\n LL | trait TRSW3 where Self: Iterator<Item: 'static, Item: 'static> {}\n    |                                  -------------  ^^^^^^^^^^^^^ re-bound here\n    |                                  |\n    |                                  `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:163:49\n+  --> $DIR/duplicate.rs:157:49\n    |\n LL | trait TRSW3 where Self: Iterator<Item: 'static, Item: 'static> {}\n    |                                  -------------  ^^^^^^^^^^^^^ re-bound here\n    |                                  |\n    |                                  `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:166:43\n+  --> $DIR/duplicate.rs:160:43\n    |\n LL | trait TRA1 { type A: Iterator<Item: Copy, Item: Send>; }\n    |                               ----------  ^^^^^^^^^^ re-bound here\n    |                               |\n    |                               `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:168:43\n+  --> $DIR/duplicate.rs:162:43\n    |\n LL | trait TRA2 { type A: Iterator<Item: Copy, Item: Copy>; }\n    |                               ----------  ^^^^^^^^^^ re-bound here\n    |                               |\n    |                               `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:170:46\n+  --> $DIR/duplicate.rs:164:46\n    |\n LL | trait TRA3 { type A: Iterator<Item: 'static, Item: 'static>; }\n    |                               -------------  ^^^^^^^^^^^^^ re-bound here\n    |                               |\n    |                               `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:173:40\n+  --> $DIR/duplicate.rs:167:40\n    |\n LL | type TADyn1 = dyn Iterator<Item: Copy, Item: Send>;\n    |                            ----------  ^^^^^^^^^^ re-bound here\n    |                            |\n    |                            `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:177:44\n+  --> $DIR/duplicate.rs:171:44\n    |\n LL | type TADyn2 = Box<dyn Iterator<Item: Copy, Item: Copy>>;\n    |                                ----------  ^^^^^^^^^^ re-bound here\n    |                                |\n    |                                `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:181:43\n+  --> $DIR/duplicate.rs:175:43\n    |\n LL | type TADyn3 = dyn Iterator<Item: 'static, Item: 'static>;\n    |                            -------------  ^^^^^^^^^^^^^ re-bound here\n    |                            |\n    |                            `Item` bound here first\n \n error: could not find defining uses\n-  --> $DIR/duplicate.rs:108:24\n-   |\n-LL | type ETAI1<T: Iterator<Item: Copy, Item: Send>> = impl Copy;\n-   |                        ^^^^^^^^^^\n-\n-error: could not find defining uses\n-  --> $DIR/duplicate.rs:108:36\n-   |\n-LL | type ETAI1<T: Iterator<Item: Copy, Item: Send>> = impl Copy;\n-   |                                    ^^^^^^^^^^\n-\n-error: could not find defining uses\n-  --> $DIR/duplicate.rs:113:24\n-   |\n-LL | type ETAI2<T: Iterator<Item: Copy, Item: Copy>> = impl Copy;\n-   |                        ^^^^^^^^^^\n-\n-error: could not find defining uses\n-  --> $DIR/duplicate.rs:113:36\n-   |\n-LL | type ETAI2<T: Iterator<Item: Copy, Item: Copy>> = impl Copy;\n-   |                                    ^^^^^^^^^^\n-\n-error: could not find defining uses\n-  --> $DIR/duplicate.rs:118:24\n-   |\n-LL | type ETAI3<T: Iterator<Item: 'static, Item: 'static>> = impl Copy;\n-   |                        ^^^^^^^^^^^^^\n-\n-error: could not find defining uses\n-  --> $DIR/duplicate.rs:118:39\n-   |\n-LL | type ETAI3<T: Iterator<Item: 'static, Item: 'static>> = impl Copy;\n-   |                                       ^^^^^^^^^^^^^\n-\n-error: could not find defining uses\n-  --> $DIR/duplicate.rs:123:28\n+  --> $DIR/duplicate.rs:117:28\n    |\n LL | type ETAI4 = impl Iterator<Item: Copy, Item: Send>;\n    |                            ^^^^^^^^^^\n \n error: could not find defining uses\n-  --> $DIR/duplicate.rs:123:40\n+  --> $DIR/duplicate.rs:117:40\n    |\n LL | type ETAI4 = impl Iterator<Item: Copy, Item: Send>;\n    |                                        ^^^^^^^^^^\n \n error: could not find defining uses\n-  --> $DIR/duplicate.rs:128:28\n+  --> $DIR/duplicate.rs:122:28\n    |\n LL | type ETAI5 = impl Iterator<Item: Copy, Item: Copy>;\n    |                            ^^^^^^^^^^\n \n error: could not find defining uses\n-  --> $DIR/duplicate.rs:128:40\n+  --> $DIR/duplicate.rs:122:40\n    |\n LL | type ETAI5 = impl Iterator<Item: Copy, Item: Copy>;\n    |                                        ^^^^^^^^^^\n \n error: could not find defining uses\n-  --> $DIR/duplicate.rs:133:28\n+  --> $DIR/duplicate.rs:127:28\n    |\n LL | type ETAI6 = impl Iterator<Item: 'static, Item: 'static>;\n    |                            ^^^^^^^^^^^^^\n \n error: could not find defining uses\n-  --> $DIR/duplicate.rs:133:43\n+  --> $DIR/duplicate.rs:127:43\n    |\n LL | type ETAI6 = impl Iterator<Item: 'static, Item: 'static>;\n    |                                           ^^^^^^^^^^^^^\n \n error: could not find defining uses\n-  --> $DIR/duplicate.rs:173:28\n+  --> $DIR/duplicate.rs:167:28\n    |\n LL | type TADyn1 = dyn Iterator<Item: Copy, Item: Send>;\n    |                            ^^^^^^^^^^\n \n error: could not find defining uses\n-  --> $DIR/duplicate.rs:173:40\n+  --> $DIR/duplicate.rs:167:40\n    |\n LL | type TADyn1 = dyn Iterator<Item: Copy, Item: Send>;\n    |                                        ^^^^^^^^^^\n \n error: could not find defining uses\n-  --> $DIR/duplicate.rs:177:32\n+  --> $DIR/duplicate.rs:171:32\n    |\n LL | type TADyn2 = Box<dyn Iterator<Item: Copy, Item: Copy>>;\n    |                                ^^^^^^^^^^\n \n error: could not find defining uses\n-  --> $DIR/duplicate.rs:177:44\n+  --> $DIR/duplicate.rs:171:44\n    |\n LL | type TADyn2 = Box<dyn Iterator<Item: Copy, Item: Copy>>;\n    |                                            ^^^^^^^^^^\n \n error: could not find defining uses\n-  --> $DIR/duplicate.rs:181:28\n+  --> $DIR/duplicate.rs:175:28\n    |\n LL | type TADyn3 = dyn Iterator<Item: 'static, Item: 'static>;\n    |                            ^^^^^^^^^^^^^\n \n error: could not find defining uses\n-  --> $DIR/duplicate.rs:181:43\n+  --> $DIR/duplicate.rs:175:43\n    |\n LL | type TADyn3 = dyn Iterator<Item: 'static, Item: 'static>;\n    |                                           ^^^^^^^^^^^^^\n \n-error: aborting due to 96 previous errors; 1 warning emitted\n+error: aborting due to 90 previous errors; 1 warning emitted\n \n For more information about this error, try `rustc --explain E0719`."}, {"sha": "3b6c9791722bb152585bc47c17bb64ee6205dae9", "filename": "src/test/ui/feature-gates/feature-gate-type_alias_impl_trait.rs", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-type_alias_impl_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-type_alias_impl_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-type_alias_impl_trait.rs?ref=ce6d3a73b514e9649e57cee812ad129bb2112016", "patch": "@@ -9,10 +9,14 @@ trait Bar {\n \n impl Bar for () {\n     type Baa = impl Debug; //~ ERROR `impl Trait` in type aliases is unstable\n-    fn define() -> Self::Baa { 0 }\n+    fn define() -> Self::Baa {\n+        0\n+    }\n }\n \n-fn define() -> Foo { 0 }\n+fn define() -> Foo {\n+    0\n+}\n \n trait TraitWithDefault {\n     type Assoc = impl Debug;\n@@ -26,20 +30,20 @@ type NestedFree = (Vec<impl Debug>, impl Debug, impl Iterator<Item = impl Debug>\n //~| ERROR `impl Trait` in type aliases is unstable\n //~| ERROR `impl Trait` in type aliases is unstable\n //~| ERROR `impl Trait` in type aliases is unstable\n-//~| ERROR `impl Trait` not allowed outside of function\n-//~| ERROR `impl Trait` not allowed outside of function\n-//~| ERROR `impl Trait` not allowed outside of function\n+\n+fn define_multiple() -> NestedFree {\n+    (vec![true], 0u8, 0i32..1)\n+}\n \n impl Bar for u8 {\n-    type Baa = (Vec<impl Debug>, impl Debug, impl Iterator<Item = impl Debug>);\n+    type Baa = (Vec<impl Debug>, impl Debug, impl Iterator<Item = impl Debug> + Debug);\n     //~^ ERROR `impl Trait` in type aliases is unstable\n     //~| ERROR `impl Trait` in type aliases is unstable\n     //~| ERROR `impl Trait` in type aliases is unstable\n     //~| ERROR `impl Trait` in type aliases is unstable\n-    //~| ERROR `impl Trait` not allowed outside of function\n-    //~| ERROR `impl Trait` not allowed outside of function\n-    //~| ERROR `impl Trait` not allowed outside of function\n-    fn define() -> Self::Baa { (vec![true], 0u8, 0i32..1) }\n+    fn define() -> Self::Baa {\n+        (vec![true], 0u8, 0i32..1)\n+    }\n }\n \n fn main() {}"}, {"sha": "8bab0d0c4a95c24ed3757b8e710ef7e0296ebe99", "filename": "src/test/ui/feature-gates/feature-gate-type_alias_impl_trait.stderr", "status": "modified", "additions": 17, "deletions": 53, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-type_alias_impl_trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-type_alias_impl_trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-type_alias_impl_trait.stderr?ref=ce6d3a73b514e9649e57cee812ad129bb2112016", "patch": "@@ -17,7 +17,7 @@ LL |     type Baa = impl Debug;\n    = help: add `#![feature(type_alias_impl_trait)]` to the crate attributes to enable\n \n error[E0658]: associated type defaults are unstable\n-  --> $DIR/feature-gate-type_alias_impl_trait.rs:18:5\n+  --> $DIR/feature-gate-type_alias_impl_trait.rs:22:5\n    |\n LL |     type Assoc = impl Debug;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -26,7 +26,7 @@ LL |     type Assoc = impl Debug;\n    = help: add `#![feature(associated_type_defaults)]` to the crate attributes to enable\n \n error[E0658]: `impl Trait` in type aliases is unstable\n-  --> $DIR/feature-gate-type_alias_impl_trait.rs:18:18\n+  --> $DIR/feature-gate-type_alias_impl_trait.rs:22:18\n    |\n LL |     type Assoc = impl Debug;\n    |                  ^^^^^^^^^^\n@@ -35,7 +35,7 @@ LL |     type Assoc = impl Debug;\n    = help: add `#![feature(type_alias_impl_trait)]` to the crate attributes to enable\n \n error[E0658]: `impl Trait` in type aliases is unstable\n-  --> $DIR/feature-gate-type_alias_impl_trait.rs:24:24\n+  --> $DIR/feature-gate-type_alias_impl_trait.rs:28:24\n    |\n LL | type NestedFree = (Vec<impl Debug>, impl Debug, impl Iterator<Item = impl Debug>);\n    |                        ^^^^^^^^^^\n@@ -44,7 +44,7 @@ LL | type NestedFree = (Vec<impl Debug>, impl Debug, impl Iterator<Item = impl D\n    = help: add `#![feature(type_alias_impl_trait)]` to the crate attributes to enable\n \n error[E0658]: `impl Trait` in type aliases is unstable\n-  --> $DIR/feature-gate-type_alias_impl_trait.rs:24:37\n+  --> $DIR/feature-gate-type_alias_impl_trait.rs:28:37\n    |\n LL | type NestedFree = (Vec<impl Debug>, impl Debug, impl Iterator<Item = impl Debug>);\n    |                                     ^^^^^^^^^^\n@@ -53,7 +53,7 @@ LL | type NestedFree = (Vec<impl Debug>, impl Debug, impl Iterator<Item = impl D\n    = help: add `#![feature(type_alias_impl_trait)]` to the crate attributes to enable\n \n error[E0658]: `impl Trait` in type aliases is unstable\n-  --> $DIR/feature-gate-type_alias_impl_trait.rs:24:49\n+  --> $DIR/feature-gate-type_alias_impl_trait.rs:28:49\n    |\n LL | type NestedFree = (Vec<impl Debug>, impl Debug, impl Iterator<Item = impl Debug>);\n    |                                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -62,7 +62,7 @@ LL | type NestedFree = (Vec<impl Debug>, impl Debug, impl Iterator<Item = impl D\n    = help: add `#![feature(type_alias_impl_trait)]` to the crate attributes to enable\n \n error[E0658]: `impl Trait` in type aliases is unstable\n-  --> $DIR/feature-gate-type_alias_impl_trait.rs:24:70\n+  --> $DIR/feature-gate-type_alias_impl_trait.rs:28:70\n    |\n LL | type NestedFree = (Vec<impl Debug>, impl Debug, impl Iterator<Item = impl Debug>);\n    |                                                                      ^^^^^^^^^^\n@@ -71,84 +71,48 @@ LL | type NestedFree = (Vec<impl Debug>, impl Debug, impl Iterator<Item = impl D\n    = help: add `#![feature(type_alias_impl_trait)]` to the crate attributes to enable\n \n error[E0658]: `impl Trait` in type aliases is unstable\n-  --> $DIR/feature-gate-type_alias_impl_trait.rs:34:21\n+  --> $DIR/feature-gate-type_alias_impl_trait.rs:39:21\n    |\n-LL |     type Baa = (Vec<impl Debug>, impl Debug, impl Iterator<Item = impl Debug>);\n+LL |     type Baa = (Vec<impl Debug>, impl Debug, impl Iterator<Item = impl Debug> + Debug);\n    |                     ^^^^^^^^^^\n    |\n    = note: see issue #63063 <https://github.com/rust-lang/rust/issues/63063> for more information\n    = help: add `#![feature(type_alias_impl_trait)]` to the crate attributes to enable\n \n error[E0658]: `impl Trait` in type aliases is unstable\n-  --> $DIR/feature-gate-type_alias_impl_trait.rs:34:34\n+  --> $DIR/feature-gate-type_alias_impl_trait.rs:39:34\n    |\n-LL |     type Baa = (Vec<impl Debug>, impl Debug, impl Iterator<Item = impl Debug>);\n+LL |     type Baa = (Vec<impl Debug>, impl Debug, impl Iterator<Item = impl Debug> + Debug);\n    |                                  ^^^^^^^^^^\n    |\n    = note: see issue #63063 <https://github.com/rust-lang/rust/issues/63063> for more information\n    = help: add `#![feature(type_alias_impl_trait)]` to the crate attributes to enable\n \n error[E0658]: `impl Trait` in type aliases is unstable\n-  --> $DIR/feature-gate-type_alias_impl_trait.rs:34:46\n+  --> $DIR/feature-gate-type_alias_impl_trait.rs:39:46\n    |\n-LL |     type Baa = (Vec<impl Debug>, impl Debug, impl Iterator<Item = impl Debug>);\n-   |                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     type Baa = (Vec<impl Debug>, impl Debug, impl Iterator<Item = impl Debug> + Debug);\n+   |                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: see issue #63063 <https://github.com/rust-lang/rust/issues/63063> for more information\n    = help: add `#![feature(type_alias_impl_trait)]` to the crate attributes to enable\n \n error[E0658]: `impl Trait` in type aliases is unstable\n-  --> $DIR/feature-gate-type_alias_impl_trait.rs:34:67\n+  --> $DIR/feature-gate-type_alias_impl_trait.rs:39:67\n    |\n-LL |     type Baa = (Vec<impl Debug>, impl Debug, impl Iterator<Item = impl Debug>);\n+LL |     type Baa = (Vec<impl Debug>, impl Debug, impl Iterator<Item = impl Debug> + Debug);\n    |                                                                   ^^^^^^^^^^\n    |\n    = note: see issue #63063 <https://github.com/rust-lang/rust/issues/63063> for more information\n    = help: add `#![feature(type_alias_impl_trait)]` to the crate attributes to enable\n \n error[E0562]: `impl Trait` not allowed outside of function and inherent method return types\n-  --> $DIR/feature-gate-type_alias_impl_trait.rs:18:18\n+  --> $DIR/feature-gate-type_alias_impl_trait.rs:22:18\n    |\n LL |     type Assoc = impl Debug;\n    |                  ^^^^^^^^^^\n \n-error[E0562]: `impl Trait` not allowed outside of function and inherent method return types\n-  --> $DIR/feature-gate-type_alias_impl_trait.rs:24:24\n-   |\n-LL | type NestedFree = (Vec<impl Debug>, impl Debug, impl Iterator<Item = impl Debug>);\n-   |                        ^^^^^^^^^^\n-\n-error[E0562]: `impl Trait` not allowed outside of function and inherent method return types\n-  --> $DIR/feature-gate-type_alias_impl_trait.rs:24:37\n-   |\n-LL | type NestedFree = (Vec<impl Debug>, impl Debug, impl Iterator<Item = impl Debug>);\n-   |                                     ^^^^^^^^^^\n-\n-error[E0562]: `impl Trait` not allowed outside of function and inherent method return types\n-  --> $DIR/feature-gate-type_alias_impl_trait.rs:24:49\n-   |\n-LL | type NestedFree = (Vec<impl Debug>, impl Debug, impl Iterator<Item = impl Debug>);\n-   |                                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-\n-error[E0562]: `impl Trait` not allowed outside of function and inherent method return types\n-  --> $DIR/feature-gate-type_alias_impl_trait.rs:34:21\n-   |\n-LL |     type Baa = (Vec<impl Debug>, impl Debug, impl Iterator<Item = impl Debug>);\n-   |                     ^^^^^^^^^^\n-\n-error[E0562]: `impl Trait` not allowed outside of function and inherent method return types\n-  --> $DIR/feature-gate-type_alias_impl_trait.rs:34:34\n-   |\n-LL |     type Baa = (Vec<impl Debug>, impl Debug, impl Iterator<Item = impl Debug>);\n-   |                                  ^^^^^^^^^^\n-\n-error[E0562]: `impl Trait` not allowed outside of function and inherent method return types\n-  --> $DIR/feature-gate-type_alias_impl_trait.rs:34:46\n-   |\n-LL |     type Baa = (Vec<impl Debug>, impl Debug, impl Iterator<Item = impl Debug>);\n-   |                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-\n-error: aborting due to 19 previous errors\n+error: aborting due to 13 previous errors\n \n Some errors have detailed explanations: E0562, E0658.\n For more information about an error, try `rustc --explain E0562`."}, {"sha": "cf2773f4ef59dc921a6e919aab056bb13c89f94a", "filename": "src/test/ui/impl-trait/auto-trait.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Ftest%2Fui%2Fimpl-trait%2Fauto-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Ftest%2Fui%2Fimpl-trait%2Fauto-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fauto-trait.rs?ref=ce6d3a73b514e9649e57cee812ad129bb2112016", "patch": "@@ -2,22 +2,24 @@\n // the purposes of coherence checking\n #![feature(type_alias_impl_trait)]\n \n-trait OpaqueTrait { }\n-impl<T> OpaqueTrait for T { }\n+trait OpaqueTrait {}\n+impl<T> OpaqueTrait for T {}\n type OpaqueType = impl OpaqueTrait;\n-fn mk_opaque() -> OpaqueType { () }\n+fn mk_opaque() -> OpaqueType {\n+    ()\n+}\n \n #[derive(Debug)]\n struct D<T>(T);\n \n-trait AnotherTrait { }\n-impl<T: Send> AnotherTrait for T { }\n+trait AnotherTrait {}\n+impl<T: Send> AnotherTrait for T {}\n \n // This is in error, because we cannot assume that `OpaqueType: !Send`.\n // (We treat opaque types as \"foreign types\" that could grow more impls\n // in the future.)\n impl AnotherTrait for D<OpaqueType> {\n-    //~^ ERROR conflicting implementations of trait `AnotherTrait` for type `D<OpaqueType>`\n+    //~^ ERROR conflicting implementations of trait `AnotherTrait` for type `D<impl OpaqueTrait>`\n }\n \n fn main() {}"}, {"sha": "16fe1b56b50c6beeba9a7ccd2bddf0f7e1ddbf43", "filename": "src/test/ui/impl-trait/auto-trait.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Ftest%2Fui%2Fimpl-trait%2Fauto-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Ftest%2Fui%2Fimpl-trait%2Fauto-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fauto-trait.stderr?ref=ce6d3a73b514e9649e57cee812ad129bb2112016", "patch": "@@ -1,11 +1,11 @@\n-error[E0119]: conflicting implementations of trait `AnotherTrait` for type `D<OpaqueType>`:\n-  --> $DIR/auto-trait.rs:19:1\n+error[E0119]: conflicting implementations of trait `AnotherTrait` for type `D<impl OpaqueTrait>`:\n+  --> $DIR/auto-trait.rs:21:1\n    |\n-LL | impl<T: Send> AnotherTrait for T { }\n+LL | impl<T: Send> AnotherTrait for T {}\n    | -------------------------------- first implementation here\n ...\n LL | impl AnotherTrait for D<OpaqueType> {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `D<OpaqueType>`\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `D<impl OpaqueTrait>`\n \n error: aborting due to previous error\n "}, {"sha": "5131509cdf03e0ceb7b7959eed48c23b1428b49c", "filename": "src/test/ui/impl-trait/issue-55872-1.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872-1.stderr?ref=ce6d3a73b514e9649e57cee812ad129bb2112016", "patch": "@@ -1,8 +1,8 @@\n error[E0277]: the trait bound `S: std::marker::Copy` is not satisfied in `(S, T)`\n-  --> $DIR/issue-55872-1.rs:12:5\n+  --> $DIR/issue-55872-1.rs:12:14\n    |\n LL |     type E = impl Copy;\n-   |     ^^^^^^^^^^^^^^^^^^^ within `(S, T)`, the trait `std::marker::Copy` is not implemented for `S`\n+   |              ^^^^^^^^^ within `(S, T)`, the trait `std::marker::Copy` is not implemented for `S`\n    |\n    = note: required because it appears within the type `(S, T)`\n    = note: the return type of a function must have a statically known size\n@@ -12,10 +12,10 @@ LL | impl<S: Default + std::marker::Copy> Bar for S {\n    |                 ^^^^^^^^^^^^^^^^^^^\n \n error[E0277]: the trait bound `T: std::marker::Copy` is not satisfied in `(S, T)`\n-  --> $DIR/issue-55872-1.rs:12:5\n+  --> $DIR/issue-55872-1.rs:12:14\n    |\n LL |     type E = impl Copy;\n-   |     ^^^^^^^^^^^^^^^^^^^ within `(S, T)`, the trait `std::marker::Copy` is not implemented for `T`\n+   |              ^^^^^^^^^ within `(S, T)`, the trait `std::marker::Copy` is not implemented for `T`\n    |\n    = note: required because it appears within the type `(S, T)`\n    = note: the return type of a function must have a statically known size"}, {"sha": "649109e4c932412e03eb3a703fa9992117b714e4", "filename": "src/test/ui/impl-trait/issue-55872-2.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872-2.stderr?ref=ce6d3a73b514e9649e57cee812ad129bb2112016", "patch": "@@ -1,8 +1,8 @@\n error[E0277]: the trait bound `impl std::future::Future: std::marker::Copy` is not satisfied\n-  --> $DIR/issue-55872-2.rs:13:5\n+  --> $DIR/issue-55872-2.rs:13:14\n    |\n LL |     type E = impl Copy;\n-   |     ^^^^^^^^^^^^^^^^^^^ the trait `std::marker::Copy` is not implemented for `impl std::future::Future`\n+   |              ^^^^^^^^^ the trait `std::marker::Copy` is not implemented for `impl std::future::Future`\n    |\n    = note: the return type of a function must have a statically known size\n "}, {"sha": "2ef86f03d340c60892feeee1d5099ed85f4a0dfa", "filename": "src/test/ui/impl-trait/issue-60473.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-60473.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-60473.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-60473.rs?ref=ce6d3a73b514e9649e57cee812ad129bb2112016", "patch": "@@ -5,13 +5,11 @@\n \n struct A<'a>(&'a ());\n \n-trait Trait<T> {\n-}\n+trait Trait<T> {}\n \n-impl<T> Trait<T> for () {\n-}\n+impl<T> Trait<T> for () {}\n \n fn main() {\n-    let x: impl Trait<A> = (); // FIXME: The error doesn't seem correct.\n-    //~^ ERROR: opaque type expands to a recursive type\n+    let x: impl Trait<A> = ();\n+    //~^ ERROR: missing lifetime specifier\n }"}, {"sha": "367b5db5d2dceefe43b8a7ca83b44eb497cba621", "filename": "src/test/ui/impl-trait/issue-60473.stderr", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-60473.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-60473.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-60473.stderr?ref=ce6d3a73b514e9649e57cee812ad129bb2112016", "patch": "@@ -1,11 +1,15 @@\n-error[E0720]: opaque type expands to a recursive type\n-  --> $DIR/issue-60473.rs:15:12\n+error[E0106]: missing lifetime specifier\n+  --> $DIR/issue-60473.rs:13:23\n    |\n-LL |     let x: impl Trait<A> = (); // FIXME: The error doesn't seem correct.\n-   |            ^^^^^^^^^^^^^ expands to a recursive type\n+LL |     let x: impl Trait<A> = ();\n+   |                       ^ expected named lifetime parameter\n+   |\n+help: consider introducing a named lifetime parameter\n+   |\n+LL | fn main<'a>() {\n+LL |     let x: impl Trait<A<'a>> = ();\n    |\n-   = note: type resolves to itself\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0720`.\n+For more information about this error, try `rustc --explain E0106`."}, {"sha": "efa67558bd7c17446cb3054042e076e05523aecb", "filename": "src/test/ui/impl-trait/issue-67166.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-67166.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-67166.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-67166.rs?ref=ce6d3a73b514e9649e57cee812ad129bb2112016", "patch": "@@ -4,8 +4,8 @@\n #![allow(incomplete_features)]\n \n pub fn run() {\n-    let _foo: Box<impl Copy + '_> = Box::new(()); // FIXME: The error doesn't much make sense.\n-    //~^ ERROR: opaque type expands to a recursive type\n+    let _foo: Box<impl Copy + '_> = Box::new(());\n+    //~^ ERROR: missing lifetime specifier\n }\n \n fn main() {}"}, {"sha": "14c78684e3e2fb48898b30e551dfaad751b20287", "filename": "src/test/ui/impl-trait/issue-67166.stderr", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-67166.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-67166.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-67166.stderr?ref=ce6d3a73b514e9649e57cee812ad129bb2112016", "patch": "@@ -1,11 +1,15 @@\n-error[E0720]: opaque type expands to a recursive type\n-  --> $DIR/issue-67166.rs:7:19\n+error[E0106]: missing lifetime specifier\n+  --> $DIR/issue-67166.rs:7:31\n    |\n-LL |     let _foo: Box<impl Copy + '_> = Box::new(()); // FIXME: The error doesn't much make sense.\n-   |                   ^^^^^^^^^^^^^^ expands to a recursive type\n+LL |     let _foo: Box<impl Copy + '_> = Box::new(());\n+   |                               ^^ expected named lifetime parameter\n+   |\n+help: consider introducing a named lifetime parameter\n+   |\n+LL | pub fn run<'a>() {\n+LL |     let _foo: Box<impl Copy + 'a> = Box::new(());\n    |\n-   = note: type resolves to itself\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0720`.\n+For more information about this error, try `rustc --explain E0106`."}, {"sha": "d173fe83fb7913c35699f933005570245680faac", "filename": "src/test/ui/impl-trait/negative-reasoning.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Ftest%2Fui%2Fimpl-trait%2Fnegative-reasoning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Ftest%2Fui%2Fimpl-trait%2Fnegative-reasoning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fnegative-reasoning.rs?ref=ce6d3a73b514e9649e57cee812ad129bb2112016", "patch": "@@ -2,21 +2,22 @@\n // other trait\n #![feature(type_alias_impl_trait)]\n \n-trait OpaqueTrait { }\n-impl<T> OpaqueTrait for T { }\n+trait OpaqueTrait {}\n+impl<T> OpaqueTrait for T {}\n type OpaqueType = impl OpaqueTrait;\n-fn mk_opaque() -> OpaqueType { () }\n+fn mk_opaque() -> OpaqueType {\n+    ()\n+}\n \n #[derive(Debug)]\n struct D<T>(T);\n \n-trait AnotherTrait { }\n-impl<T: std::fmt::Debug> AnotherTrait for T { }\n-\n+trait AnotherTrait {}\n+impl<T: std::fmt::Debug> AnotherTrait for T {}\n \n // This is in error, because we cannot assume that `OpaqueType: !Debug`\n impl AnotherTrait for D<OpaqueType> {\n-    //~^ ERROR conflicting implementations of trait `AnotherTrait` for type `D<OpaqueType>`\n+    //~^ ERROR conflicting implementations of trait `AnotherTrait` for type `D<impl OpaqueTrait>`\n }\n \n fn main() {}"}, {"sha": "e43d8c857b2570c2840d5fd16623572157c11faa", "filename": "src/test/ui/impl-trait/negative-reasoning.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Ftest%2Fui%2Fimpl-trait%2Fnegative-reasoning.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Ftest%2Fui%2Fimpl-trait%2Fnegative-reasoning.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fnegative-reasoning.stderr?ref=ce6d3a73b514e9649e57cee812ad129bb2112016", "patch": "@@ -1,13 +1,13 @@\n-error[E0119]: conflicting implementations of trait `AnotherTrait` for type `D<OpaqueType>`:\n-  --> $DIR/negative-reasoning.rs:18:1\n+error[E0119]: conflicting implementations of trait `AnotherTrait` for type `D<impl OpaqueTrait>`:\n+  --> $DIR/negative-reasoning.rs:19:1\n    |\n-LL | impl<T: std::fmt::Debug> AnotherTrait for T { }\n+LL | impl<T: std::fmt::Debug> AnotherTrait for T {}\n    | ------------------------------------------- first implementation here\n ...\n LL | impl AnotherTrait for D<OpaqueType> {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `D<OpaqueType>`\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `D<impl OpaqueTrait>`\n    |\n-   = note: upstream crates may add a new impl of trait `std::fmt::Debug` for type `OpaqueType` in future versions\n+   = note: upstream crates may add a new impl of trait `std::fmt::Debug` for type `impl OpaqueTrait` in future versions\n \n error: aborting due to previous error\n "}, {"sha": "7addc006e190022f3654044e9cc613d446933f2d", "filename": "src/test/ui/impl-trait/where-allowed.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Ftest%2Fui%2Fimpl-trait%2Fwhere-allowed.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Ftest%2Fui%2Fimpl-trait%2Fwhere-allowed.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fwhere-allowed.stderr?ref=ce6d3a73b514e9649e57cee812ad129bb2112016", "patch": "@@ -256,16 +256,16 @@ LL |     let _in_return_in_local_variable = || -> impl Fn() { || {} };\n    |                                              ^^^^^^^^^\n \n error: could not find defining uses\n-  --> $DIR/where-allowed.rs:155:1\n+  --> $DIR/where-allowed.rs:119:16\n    |\n-LL | type InTypeAlias<R> = impl Debug;\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     type Out = impl Debug;\n+   |                ^^^^^^^^^^\n \n error: could not find defining uses\n-  --> $DIR/where-allowed.rs:119:5\n+  --> $DIR/where-allowed.rs:155:23\n    |\n-LL |     type Out = impl Debug;\n-   |     ^^^^^^^^^^^^^^^^^^^^^^\n+LL | type InTypeAlias<R> = impl Debug;\n+   |                       ^^^^^^^^^^\n \n error: aborting due to 42 previous errors\n "}, {"sha": "cebe834824a6121657964960694a54e2b9dc2ea0", "filename": "src/test/ui/issues/issue-60662.stdout", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Ftest%2Fui%2Fissues%2Fissue-60662.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Ftest%2Fui%2Fissues%2Fissue-60662.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-60662.stdout?ref=ce6d3a73b514e9649e57cee812ad129bb2112016", "patch": "@@ -10,5 +10,5 @@ extern crate std;\n trait Animal { }\n \n fn main() {\n-              pub type ServeFut = impl Animal;\n+              pub type ServeFut = /*impl Trait*/;\n           }"}, {"sha": "ae04612a4dd69aa536f27640786b8821dd773b0b", "filename": "src/test/ui/lint/inline-trait-and-foreign-items.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Ftest%2Fui%2Flint%2Finline-trait-and-foreign-items.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Ftest%2Fui%2Flint%2Finline-trait-and-foreign-items.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Finline-trait-and-foreign-items.stderr?ref=ce6d3a73b514e9649e57cee812ad129bb2112016", "patch": "@@ -62,10 +62,10 @@ LL |     type U = impl Trait;\n    |     -------------------- not a function or closure\n \n error: could not find defining uses\n-  --> $DIR/inline-trait-and-foreign-items.rs:26:5\n+  --> $DIR/inline-trait-and-foreign-items.rs:26:14\n    |\n LL |     type U = impl Trait;\n-   |     ^^^^^^^^^^^^^^^^^^^^\n+   |              ^^^^^^^^^^\n \n error: aborting due to 6 previous errors; 2 warnings emitted\n "}, {"sha": "3cbc084ecae7cbd524c932b2790525204039fd67", "filename": "src/test/ui/lint/opaque-ty-ffi-unsafe.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Ftest%2Fui%2Flint%2Fopaque-ty-ffi-unsafe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Ftest%2Fui%2Flint%2Fopaque-ty-ffi-unsafe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fopaque-ty-ffi-unsafe.rs?ref=ce6d3a73b514e9649e57cee812ad129bb2112016", "patch": "@@ -1,5 +1,4 @@\n #![feature(type_alias_impl_trait)]\n-\n #![deny(improper_ctypes)]\n \n type A = impl Fn();\n@@ -10,7 +9,7 @@ pub fn ret_closure() -> A {\n \n extern \"C\" {\n     pub fn a(_: A);\n-    //~^ ERROR `extern` block uses type `A`, which is not FFI-safe\n+//~^ ERROR `extern` block uses type `impl std::ops::Fn<()>`, which is not FFI-safe\n }\n \n fn main() {}"}, {"sha": "06dfb7b8fbeca49e84e219087db025355baa352b", "filename": "src/test/ui/lint/opaque-ty-ffi-unsafe.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Ftest%2Fui%2Flint%2Fopaque-ty-ffi-unsafe.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Ftest%2Fui%2Flint%2Fopaque-ty-ffi-unsafe.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fopaque-ty-ffi-unsafe.stderr?ref=ce6d3a73b514e9649e57cee812ad129bb2112016", "patch": "@@ -1,11 +1,11 @@\n-error: `extern` block uses type `A`, which is not FFI-safe\n-  --> $DIR/opaque-ty-ffi-unsafe.rs:12:17\n+error: `extern` block uses type `impl std::ops::Fn<()>`, which is not FFI-safe\n+  --> $DIR/opaque-ty-ffi-unsafe.rs:11:17\n    |\n LL |     pub fn a(_: A);\n    |                 ^ not FFI-safe\n    |\n note: the lint level is defined here\n-  --> $DIR/opaque-ty-ffi-unsafe.rs:3:9\n+  --> $DIR/opaque-ty-ffi-unsafe.rs:2:9\n    |\n LL | #![deny(improper_ctypes)]\n    |         ^^^^^^^^^^^^^^^"}, {"sha": "cd7c37cb04b22a44114f4171aafabcac5039021f", "filename": "src/test/ui/privacy/private-in-public-assoc-ty.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Ftest%2Fui%2Fprivacy%2Fprivate-in-public-assoc-ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Ftest%2Fui%2Fprivacy%2Fprivate-in-public-assoc-ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Fprivate-in-public-assoc-ty.rs?ref=ce6d3a73b514e9649e57cee812ad129bb2112016", "patch": "@@ -9,7 +9,9 @@ mod m {\n     trait PrivTr {}\n     impl PrivTr for Priv {}\n     pub trait PubTrAux1<T> {}\n-    pub trait PubTrAux2 { type A; }\n+    pub trait PubTrAux2 {\n+        type A;\n+    }\n     impl<T> PubTrAux1<T> for u8 {}\n     impl PubTrAux2 for u8 {\n         type A = Priv;\n@@ -41,8 +43,9 @@ mod m {\n \n         type Exist = impl PrivTr;\n         //~^ ERROR private trait `m::PrivTr` in public interface\n-        //~| ERROR private trait `m::PrivTr` in public interface\n-        fn infer_exist() -> Self::Exist { Priv }\n+        fn infer_exist() -> Self::Exist {\n+            Priv\n+        }\n     }\n }\n "}, {"sha": "1a3ca3f16ed4cccfa5574bbf6382d55200a6358d", "filename": "src/test/ui/privacy/private-in-public-assoc-ty.stderr", "status": "modified", "additions": 8, "deletions": 17, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Ftest%2Fui%2Fprivacy%2Fprivate-in-public-assoc-ty.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Ftest%2Fui%2Fprivacy%2Fprivate-in-public-assoc-ty.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Fprivate-in-public-assoc-ty.stderr?ref=ce6d3a73b514e9649e57cee812ad129bb2112016", "patch": "@@ -1,5 +1,5 @@\n error[E0446]: private type `m::Priv` in public interface\n-  --> $DIR/private-in-public-assoc-ty.rs:15:9\n+  --> $DIR/private-in-public-assoc-ty.rs:17:9\n    |\n LL |     struct Priv;\n    |     - `m::Priv` declared as private\n@@ -8,7 +8,7 @@ LL |         type A = Priv;\n    |         ^^^^^^^^^^^^^^ can't leak private type\n \n warning: private trait `m::PrivTr` in public interface (error E0445)\n-  --> $DIR/private-in-public-assoc-ty.rs:21:5\n+  --> $DIR/private-in-public-assoc-ty.rs:23:5\n    |\n LL | /     pub trait PubTr {\n LL | |\n@@ -24,7 +24,7 @@ LL | |     }\n    = note: for more information, see issue #34537 <https://github.com/rust-lang/rust/issues/34537>\n \n warning: private type `m::Priv` in public interface (error E0446)\n-  --> $DIR/private-in-public-assoc-ty.rs:21:5\n+  --> $DIR/private-in-public-assoc-ty.rs:23:5\n    |\n LL | /     pub trait PubTr {\n LL | |\n@@ -39,7 +39,7 @@ LL | |     }\n    = note: for more information, see issue #34537 <https://github.com/rust-lang/rust/issues/34537>\n \n warning: private type `m::Priv` in public interface (error E0446)\n-  --> $DIR/private-in-public-assoc-ty.rs:21:5\n+  --> $DIR/private-in-public-assoc-ty.rs:23:5\n    |\n LL | /     pub trait PubTr {\n LL | |\n@@ -54,7 +54,7 @@ LL | |     }\n    = note: for more information, see issue #34537 <https://github.com/rust-lang/rust/issues/34537>\n \n error[E0446]: private type `m::Priv` in public interface\n-  --> $DIR/private-in-public-assoc-ty.rs:32:9\n+  --> $DIR/private-in-public-assoc-ty.rs:34:9\n    |\n LL |     struct Priv;\n    |     - `m::Priv` declared as private\n@@ -63,7 +63,7 @@ LL |         type Alias4 = Priv;\n    |         ^^^^^^^^^^^^^^^^^^^ can't leak private type\n \n error[E0446]: private type `m::Priv` in public interface\n-  --> $DIR/private-in-public-assoc-ty.rs:39:9\n+  --> $DIR/private-in-public-assoc-ty.rs:41:9\n    |\n LL |     struct Priv;\n    |     - `m::Priv` declared as private\n@@ -72,24 +72,15 @@ LL |         type Alias1 = Priv;\n    |         ^^^^^^^^^^^^^^^^^^^ can't leak private type\n \n error[E0445]: private trait `m::PrivTr` in public interface\n-  --> $DIR/private-in-public-assoc-ty.rs:42:9\n+  --> $DIR/private-in-public-assoc-ty.rs:44:9\n    |\n LL |     trait PrivTr {}\n    |     - `m::PrivTr` declared as private\n ...\n LL |         type Exist = impl PrivTr;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^ can't leak private trait\n \n-error[E0445]: private trait `m::PrivTr` in public interface\n-  --> $DIR/private-in-public-assoc-ty.rs:42:9\n-   |\n-LL |     trait PrivTr {}\n-   |     - `m::PrivTr` declared as private\n-...\n-LL |         type Exist = impl PrivTr;\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^ can't leak private trait\n-\n-error: aborting due to 5 previous errors; 3 warnings emitted\n+error: aborting due to 4 previous errors; 3 warnings emitted\n \n Some errors have detailed explanations: E0445, E0446.\n For more information about an error, try `rustc --explain E0445`."}, {"sha": "3af6d0a3e076e74dcfb886c0e0d77e79037a64a2", "filename": "src/test/ui/save-analysis/issue-68621.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Ftest%2Fui%2Fsave-analysis%2Fissue-68621.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Ftest%2Fui%2Fsave-analysis%2Fissue-68621.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsave-analysis%2Fissue-68621.stderr?ref=ce6d3a73b514e9649e57cee812ad129bb2112016", "patch": "@@ -1,8 +1,8 @@\n error: could not find defining uses\n-  --> $DIR/issue-68621.rs:14:5\n+  --> $DIR/issue-68621.rs:14:19\n    |\n LL |     type Future = impl Trait;\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                   ^^^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "9ebf63468e77373be22996651048ddd9b400f14b", "filename": "src/test/ui/type-alias-impl-trait/bound_reduction2.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fbound_reduction2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fbound_reduction2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fbound_reduction2.stderr?ref=ce6d3a73b514e9649e57cee812ad129bb2112016", "patch": "@@ -1,8 +1,8 @@\n error[E0277]: the trait bound `T: TraitWithAssoc` is not satisfied\n-  --> $DIR/bound_reduction2.rs:10:1\n+  --> $DIR/bound_reduction2.rs:10:15\n    |\n LL | type Foo<V> = impl Trait<V>;\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `TraitWithAssoc` is not implemented for `T`\n+   |               ^^^^^^^^^^^^^ the trait `TraitWithAssoc` is not implemented for `T`\n    |\n help: consider further restricting this bound\n    |"}, {"sha": "21c2e8a9db618ceffe81427738ab2ddc426244b6", "filename": "src/test/ui/type-alias-impl-trait/declared_but_never_defined.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fdeclared_but_never_defined.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fdeclared_but_never_defined.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fdeclared_but_never_defined.stderr?ref=ce6d3a73b514e9649e57cee812ad129bb2112016", "patch": "@@ -1,8 +1,8 @@\n error: could not find defining uses\n-  --> $DIR/declared_but_never_defined.rs:6:1\n+  --> $DIR/declared_but_never_defined.rs:6:12\n    |\n LL | type Bar = impl std::fmt::Debug;\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |            ^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "c0cb94b15d033135ca3af397b52eac6c922ac320", "filename": "src/test/ui/type-alias-impl-trait/declared_but_not_defined_in_scope.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fdeclared_but_not_defined_in_scope.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fdeclared_but_not_defined_in_scope.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fdeclared_but_not_defined_in_scope.stderr?ref=ce6d3a73b514e9649e57cee812ad129bb2112016", "patch": "@@ -1,8 +1,8 @@\n error: could not find defining uses\n-  --> $DIR/declared_but_not_defined_in_scope.rs:7:5\n+  --> $DIR/declared_but_not_defined_in_scope.rs:7:20\n    |\n LL |     pub type Boo = impl ::std::fmt::Debug;\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                    ^^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "76654d7a718b8175f77b0fdfb44e16c2c77b2338", "filename": "src/test/ui/type-alias-impl-trait/generic_type_does_not_live_long_enough.nll.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_type_does_not_live_long_enough.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_type_does_not_live_long_enough.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_type_does_not_live_long_enough.nll.stderr?ref=ce6d3a73b514e9649e57cee812ad129bb2112016", "patch": "@@ -13,10 +13,10 @@ LL |     let z: i32 = x;\n    |            expected due to this\n ...\n LL | type WrongGeneric<T> = impl 'static;\n-   | ------------------------------------ the found opaque type\n+   |                        ------------ the found opaque type\n    |\n    = note:     expected type `i32`\n-           found opaque type `WrongGeneric::<&{integer}>`\n+           found opaque type `impl Sized`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "18d8daa05e63d168fb413a3ca948c39316897749", "filename": "src/test/ui/type-alias-impl-trait/generic_type_does_not_live_long_enough.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_type_does_not_live_long_enough.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_type_does_not_live_long_enough.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_type_does_not_live_long_enough.stderr?ref=ce6d3a73b514e9649e57cee812ad129bb2112016", "patch": "@@ -13,16 +13,16 @@ LL |     let z: i32 = x;\n    |            expected due to this\n ...\n LL | type WrongGeneric<T> = impl 'static;\n-   | ------------------------------------ the found opaque type\n+   |                        ------------ the found opaque type\n    |\n    = note:     expected type `i32`\n-           found opaque type `WrongGeneric::<&{integer}>`\n+           found opaque type `impl Sized`\n \n error[E0310]: the parameter type `T` may not live long enough\n-  --> $DIR/generic_type_does_not_live_long_enough.rs:9:1\n+  --> $DIR/generic_type_does_not_live_long_enough.rs:9:24\n    |\n LL | type WrongGeneric<T> = impl 'static;\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ...so that the type `T` will meet its required lifetime bounds\n+   |                        ^^^^^^^^^^^^ ...so that the type `T` will meet its required lifetime bounds\n ...\n LL | fn wrong_generic<T>(t: T) -> WrongGeneric<T> {\n    |                  - help: consider adding an explicit lifetime bound...: `T: 'static`"}, {"sha": "911f592f73f27d0781ab3c3fe41e3daf77095d3f", "filename": "src/test/ui/type-alias-impl-trait/generic_underconstrained.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_underconstrained.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_underconstrained.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_underconstrained.stderr?ref=ce6d3a73b514e9649e57cee812ad129bb2112016", "patch": "@@ -5,10 +5,10 @@ LL | type Underconstrained<T: Trait> = impl 'static;\n    |                                   ^^^^^^^^^^^^\n \n error[E0277]: the trait bound `T: Trait` is not satisfied\n-  --> $DIR/generic_underconstrained.rs:6:1\n+  --> $DIR/generic_underconstrained.rs:6:35\n    |\n LL | type Underconstrained<T: Trait> = impl 'static;\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Trait` is not implemented for `T`\n+   |                                   ^^^^^^^^^^^^ the trait `Trait` is not implemented for `T`\n    |\n    = note: the return type of a function must have a statically known size\n help: consider restricting type parameter `T`"}, {"sha": "247d68ef2a1f0edd078cf7fe2ee4e54a0e7e65b8", "filename": "src/test/ui/type-alias-impl-trait/generic_underconstrained2.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_underconstrained2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_underconstrained2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_underconstrained2.stderr?ref=ce6d3a73b514e9649e57cee812ad129bb2112016", "patch": "@@ -11,10 +11,10 @@ LL | type Underconstrained2<T: std::fmt::Debug> = impl 'static;\n    |                                              ^^^^^^^^^^^^\n \n error[E0277]: `U` doesn't implement `std::fmt::Debug`\n-  --> $DIR/generic_underconstrained2.rs:5:1\n+  --> $DIR/generic_underconstrained2.rs:5:45\n    |\n LL | type Underconstrained<T: std::fmt::Debug> = impl 'static;\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `U` cannot be formatted using `{:?}` because it doesn't implement `std::fmt::Debug`\n+   |                                             ^^^^^^^^^^^^ `U` cannot be formatted using `{:?}` because it doesn't implement `std::fmt::Debug`\n ...\n LL |     5u32\n    |     ---- this returned value is of type `u32`\n@@ -27,10 +27,10 @@ LL | fn underconstrained<U: std::fmt::Debug>(_: U) -> Underconstrained<U> {\n    |                      ^^^^^^^^^^^^^^^^^\n \n error[E0277]: `V` doesn't implement `std::fmt::Debug`\n-  --> $DIR/generic_underconstrained2.rs:14:1\n+  --> $DIR/generic_underconstrained2.rs:14:46\n    |\n LL | type Underconstrained2<T: std::fmt::Debug> = impl 'static;\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `V` cannot be formatted using `{:?}` because it doesn't implement `std::fmt::Debug`\n+   |                                              ^^^^^^^^^^^^ `V` cannot be formatted using `{:?}` because it doesn't implement `std::fmt::Debug`\n ...\n LL |     5u32\n    |     ---- this returned value is of type `u32`"}, {"sha": "bc6543a9229db7ea8f2511646d820f79a2a81fb5", "filename": "src/test/ui/type-alias-impl-trait/impl-with-unconstrained-param.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fimpl-with-unconstrained-param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fimpl-with-unconstrained-param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fimpl-with-unconstrained-param.rs?ref=ce6d3a73b514e9649e57cee812ad129bb2112016", "patch": "@@ -0,0 +1,18 @@\n+// Ensure that we don't ICE if associated type impl trait is used in an impl\n+// with an unconstrained type parameter.\n+\n+#![feature(type_alias_impl_trait)]\n+\n+trait X {\n+    type I;\n+    fn f() -> Self::I;\n+}\n+\n+impl<T> X for () {\n+    type I = impl Sized;\n+    //~^ ERROR could not find defining uses\n+    fn f() -> Self::I {}\n+    //~^ ERROR type annotations needed\n+}\n+\n+fn main() {}"}, {"sha": "e8b677113dba779ad5703c4c21a4ddcd920374d4", "filename": "src/test/ui/type-alias-impl-trait/impl-with-unconstrained-param.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fimpl-with-unconstrained-param.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fimpl-with-unconstrained-param.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fimpl-with-unconstrained-param.stderr?ref=ce6d3a73b514e9649e57cee812ad129bb2112016", "patch": "@@ -0,0 +1,15 @@\n+error[E0282]: type annotations needed\n+  --> $DIR/impl-with-unconstrained-param.rs:14:23\n+   |\n+LL |     fn f() -> Self::I {}\n+   |                       ^^ cannot infer type for type parameter `T`\n+\n+error: could not find defining uses\n+  --> $DIR/impl-with-unconstrained-param.rs:12:14\n+   |\n+LL |     type I = impl Sized;\n+   |              ^^^^^^^^^^\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0282`."}, {"sha": "3a7a5da075f11b841922ceeca209f97ebf952537", "filename": "src/test/ui/type-alias-impl-trait/issue-57188-associate-impl-capture.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-57188-associate-impl-capture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-57188-associate-impl-capture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-57188-associate-impl-capture.rs?ref=ce6d3a73b514e9649e57cee812ad129bb2112016", "patch": "@@ -0,0 +1,24 @@\n+// Regression test for #57188\n+\n+// check-pass\n+\n+#![feature(type_alias_impl_trait)]\n+\n+struct Baz<'a> {\n+    source: &'a str,\n+}\n+\n+trait Foo<'a> {\n+    type T: Iterator<Item = Baz<'a>> + 'a;\n+    fn foo(source: &'a str) -> Self::T;\n+}\n+\n+struct Bar;\n+impl<'a> Foo<'a> for Bar {\n+    type T = impl Iterator<Item = Baz<'a>> + 'a;\n+    fn foo(source: &'a str) -> Self::T {\n+        std::iter::once(Baz { source })\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "cc121ac89fb8d756033655c89870fb82000950dc", "filename": "src/test/ui/type-alias-impl-trait/issue-57611-trait-alias.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-57611-trait-alias.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-57611-trait-alias.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-57611-trait-alias.stderr?ref=ce6d3a73b514e9649e57cee812ad129bb2112016", "patch": "@@ -1,19 +1,19 @@\n error[E0631]: type mismatch in closure arguments\n-  --> $DIR/issue-57611-trait-alias.rs:17:5\n+  --> $DIR/issue-57611-trait-alias.rs:17:16\n    |\n LL |     type Bar = impl Baz<Self, Self>;\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected signature of `for<'r> fn(&'r X) -> _`\n+   |                ^^^^^^^^^^^^^^^^^^^^ expected signature of `for<'r> fn(&'r X) -> _`\n ...\n LL |         |x| x\n    |         ----- found signature of `fn(_) -> _`\n    |\n    = note: the return type of a function must have a statically known size\n \n error[E0271]: type mismatch resolving `for<'r> <[closure@$DIR/issue-57611-trait-alias.rs:21:9: 21:14] as std::ops::FnOnce<(&'r X,)>>::Output == &'r X`\n-  --> $DIR/issue-57611-trait-alias.rs:17:5\n+  --> $DIR/issue-57611-trait-alias.rs:17:16\n    |\n LL |     type Bar = impl Baz<Self, Self>;\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected bound lifetime parameter, found concrete lifetime\n+   |                ^^^^^^^^^^^^^^^^^^^^ expected bound lifetime parameter, found concrete lifetime\n    |\n    = note: the return type of a function must have a statically known size\n "}, {"sha": "bf2d612fcdb411511500d8dc3b6494582a040522", "filename": "src/test/ui/type-alias-impl-trait/issue-60371.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-60371.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-60371.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-60371.stderr?ref=ce6d3a73b514e9649e57cee812ad129bb2112016", "patch": "@@ -8,20 +8,20 @@ LL |     type Item = impl Bug;\n    = help: add `#![feature(type_alias_impl_trait)]` to the crate attributes to enable\n \n error[E0277]: the trait bound `(): Bug` is not satisfied\n-  --> $DIR/issue-60371.rs:8:5\n+  --> $DIR/issue-60371.rs:8:17\n    |\n LL |     type Item = impl Bug;\n-   |     ^^^^^^^^^^^^^^^^^^^^^ the trait `Bug` is not implemented for `()`\n+   |                 ^^^^^^^^ the trait `Bug` is not implemented for `()`\n    |\n    = help: the following implementations were found:\n              <&() as Bug>\n    = note: the return type of a function must have a statically known size\n \n error: could not find defining uses\n-  --> $DIR/issue-60371.rs:8:5\n+  --> $DIR/issue-60371.rs:8:17\n    |\n LL |     type Item = impl Bug;\n-   |     ^^^^^^^^^^^^^^^^^^^^^\n+   |                 ^^^^^^^^\n \n error: aborting due to 3 previous errors\n "}, {"sha": "78def0d1136de8c5e7d0c0afde4b3a57ce2bbe2e", "filename": "src/test/ui/type-alias-impl-trait/issue-60564.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-60564.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-60564.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-60564.rs?ref=ce6d3a73b514e9649e57cee812ad129bb2112016", "patch": "@@ -17,11 +17,8 @@ where\n {\n     type BitsIter = IterBitsIter<T, E, u8>;\n     fn iter_bits(self, n: u8) -> Self::BitsIter {\n-    //~^ ERROR non-defining opaque type use in defining scope\n-    //~| ERROR non-defining opaque type use in defining scope\n-        (0u8..n)\n-            .rev()\n-            .map(move |shift| ((self >> T::from(shift)) & T::from(1)).try_into().unwrap())\n+        //~^ ERROR non-defining opaque type use in defining scope\n+        (0u8..n).rev().map(move |shift| ((self >> T::from(shift)) & T::from(1)).try_into().unwrap())\n     }\n }\n "}, {"sha": "66fa862ef9d7aa5e827a55eb8ed456a1d53f7baf", "filename": "src/test/ui/type-alias-impl-trait/issue-60564.stderr", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-60564.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-60564.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-60564.stderr?ref=ce6d3a73b514e9649e57cee812ad129bb2112016", "patch": "@@ -1,15 +1,3 @@\n-error: non-defining opaque type use in defining scope\n-  --> $DIR/issue-60564.rs:19:34\n-   |\n-LL |     fn iter_bits(self, n: u8) -> Self::BitsIter {\n-   |                                  ^^^^^^^^^^^^^^\n-   |\n-note: used non-generic type `_` for generic parameter\n-  --> $DIR/issue-60564.rs:8:22\n-   |\n-LL | type IterBitsIter<T, E, I> = impl std::iter::Iterator<Item = I>;\n-   |                      ^\n-\n error: non-defining opaque type use in defining scope\n   --> $DIR/issue-60564.rs:19:34\n    |\n@@ -22,5 +10,5 @@ note: used non-generic type `u8` for generic parameter\n LL | type IterBitsIter<T, E, I> = impl std::iter::Iterator<Item = I>;\n    |                         ^\n \n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n "}, {"sha": "36779a0ce89c33b5839222c6721502834216a0c0", "filename": "src/test/ui/type-alias-impl-trait/issue-62000-associate-impl-trait-lifetimes.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-62000-associate-impl-trait-lifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-62000-associate-impl-trait-lifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-62000-associate-impl-trait-lifetimes.rs?ref=ce6d3a73b514e9649e57cee812ad129bb2112016", "patch": "@@ -0,0 +1,38 @@\n+// Regression test for #62988\n+\n+// check-pass\n+\n+#![feature(type_alias_impl_trait)]\n+\n+trait MyTrait {\n+    type AssocType: Send;\n+    fn ret(&self) -> Self::AssocType;\n+}\n+\n+impl MyTrait for () {\n+    type AssocType = impl Send;\n+    fn ret(&self) -> Self::AssocType {\n+        ()\n+    }\n+}\n+\n+impl<'a> MyTrait for &'a () {\n+    type AssocType = impl Send;\n+    fn ret(&self) -> Self::AssocType {\n+        ()\n+    }\n+}\n+\n+trait MyLifetimeTrait<'a> {\n+    type AssocType: Send + 'a;\n+    fn ret(&self) -> Self::AssocType;\n+}\n+\n+impl<'a> MyLifetimeTrait<'a> for &'a () {\n+    type AssocType = impl Send + 'a;\n+    fn ret(&self) -> Self::AssocType {\n+        *self\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "d07f64c3312d3da03062d1c52df0d967411aa971", "filename": "src/test/ui/type-alias-impl-trait/issue-63279.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-63279.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-63279.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-63279.stderr?ref=ce6d3a73b514e9649e57cee812ad129bb2112016", "patch": "@@ -1,10 +1,10 @@\n error[E0271]: type mismatch resolving `<[closure@$DIR/issue-63279.rs:8:5: 8:28] as std::ops::FnOnce<()>>::Output == ()`\n-  --> $DIR/issue-63279.rs:5:1\n+  --> $DIR/issue-63279.rs:5:16\n    |\n LL | type Closure = impl FnOnce();\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected opaque type, found `()`\n+   |                ^^^^^^^^^^^^^ expected opaque type, found `()`\n    |\n-   = note: expected opaque type `Closure`\n+   = note: expected opaque type `impl std::ops::FnOnce<()>`\n                 found unit type `()`\n    = note: the return type of a function must have a statically known size\n "}, {"sha": "6732902c09a504d7aef29f1291d36a998cfe3a8e", "filename": "src/test/ui/type-alias-impl-trait/issue-69136-inner-lifetime-resolve-error.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-69136-inner-lifetime-resolve-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-69136-inner-lifetime-resolve-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-69136-inner-lifetime-resolve-error.rs?ref=ce6d3a73b514e9649e57cee812ad129bb2112016", "patch": "@@ -0,0 +1,22 @@\n+// Regression test for #69136\n+\n+#![feature(type_alias_impl_trait)]\n+\n+trait SomeTrait {}\n+\n+impl SomeTrait for () {}\n+\n+trait WithAssoc<A> {\n+    type AssocType;\n+}\n+\n+impl<T> WithAssoc<T> for () {\n+    type AssocType = ();\n+}\n+\n+type Return<A> = impl WithAssoc<A, AssocType = impl SomeTrait + 'a>;\n+//~^ ERROR use of undeclared lifetime name `'a`\n+\n+fn my_fun() -> Return<()> {}\n+\n+fn main() {}"}, {"sha": "fe45e39d938f009e1b340cd155fbc6fb322cbe0b", "filename": "src/test/ui/type-alias-impl-trait/issue-69136-inner-lifetime-resolve-error.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-69136-inner-lifetime-resolve-error.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-69136-inner-lifetime-resolve-error.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-69136-inner-lifetime-resolve-error.stderr?ref=ce6d3a73b514e9649e57cee812ad129bb2112016", "patch": "@@ -0,0 +1,11 @@\n+error[E0261]: use of undeclared lifetime name `'a`\n+  --> $DIR/issue-69136-inner-lifetime-resolve-error.rs:17:65\n+   |\n+LL | type Return<A> = impl WithAssoc<A, AssocType = impl SomeTrait + 'a>;\n+   |             -                                                   ^^ undeclared lifetime\n+   |             |\n+   |             help: consider introducing lifetime `'a` here: `'a,`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0261`."}, {"sha": "a6916eda8b093c294a61ed786ee52b87d4f26688", "filename": "src/test/ui/type-alias-impl-trait/issue-69136-inner-lifetime-resolve-ok.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-69136-inner-lifetime-resolve-ok.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-69136-inner-lifetime-resolve-ok.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-69136-inner-lifetime-resolve-ok.rs?ref=ce6d3a73b514e9649e57cee812ad129bb2112016", "patch": "@@ -0,0 +1,23 @@\n+// Test-pass variant of #69136\n+\n+// check-pass\n+\n+#![feature(type_alias_impl_trait)]\n+\n+trait SomeTrait {}\n+\n+impl SomeTrait for () {}\n+\n+trait WithAssoc {\n+    type AssocType;\n+}\n+\n+impl WithAssoc for () {\n+    type AssocType = ();\n+}\n+\n+type Return<'a> = impl WithAssoc<AssocType = impl Sized + 'a>;\n+\n+fn my_fun<'a>() -> Return<'a> {}\n+\n+fn main() {}"}, {"sha": "4fbbf3475280355f7a93983c669e399efc80bef4", "filename": "src/test/ui/type-alias-impl-trait/never_reveal_concrete_type.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fnever_reveal_concrete_type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fnever_reveal_concrete_type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fnever_reveal_concrete_type.stderr?ref=ce6d3a73b514e9649e57cee812ad129bb2112016", "patch": "@@ -2,17 +2,17 @@ error[E0308]: mismatched types\n   --> $DIR/never_reveal_concrete_type.rs:13:27\n    |\n LL | type NoReveal = impl std::fmt::Debug;\n-   | ------------------------------------- the found opaque type\n+   |                 -------------------- the found opaque type\n ...\n LL |     let _: &'static str = x;\n    |            ------------   ^ expected `&str`, found opaque type\n    |            |\n    |            expected due to this\n    |\n    = note: expected reference `&'static str`\n-            found opaque type `NoReveal`\n+            found opaque type `impl std::fmt::Debug`\n \n-error[E0605]: non-primitive cast: `NoReveal` as `&'static str`\n+error[E0605]: non-primitive cast: `impl std::fmt::Debug` as `&'static str`\n   --> $DIR/never_reveal_concrete_type.rs:14:13\n    |\n LL |     let _ = x as &'static str;"}, {"sha": "61025e846921e3dfc7c39d65c1178c702a95df40", "filename": "src/test/ui/type-alias-impl-trait/no_inferrable_concrete_type.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fno_inferrable_concrete_type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fno_inferrable_concrete_type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fno_inferrable_concrete_type.stderr?ref=ce6d3a73b514e9649e57cee812ad129bb2112016", "patch": "@@ -1,8 +1,8 @@\n error: could not find defining uses\n-  --> $DIR/no_inferrable_concrete_type.rs:6:1\n+  --> $DIR/no_inferrable_concrete_type.rs:6:12\n    |\n LL | type Foo = impl Copy;\n-   | ^^^^^^^^^^^^^^^^^^^^^\n+   |            ^^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "d237cc6238ae176478321c77e558c5f890ca5644", "filename": "src/test/ui/type-alias-impl-trait/no_revealing_outside_defining_module.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fno_revealing_outside_defining_module.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fno_revealing_outside_defining_module.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fno_revealing_outside_defining_module.stderr?ref=ce6d3a73b514e9649e57cee812ad129bb2112016", "patch": "@@ -2,28 +2,28 @@ error[E0308]: mismatched types\n   --> $DIR/no_revealing_outside_defining_module.rs:15:19\n    |\n LL |     pub type Boo = impl ::std::fmt::Debug;\n-   |     -------------------------------------- the found opaque type\n+   |                    ---------------------- the found opaque type\n ...\n LL |     let _: &str = bomp();\n    |            ----   ^^^^^^ expected `&str`, found opaque type\n    |            |\n    |            expected due to this\n    |\n    = note: expected reference `&str`\n-            found opaque type `Boo`\n+            found opaque type `impl std::fmt::Debug`\n \n error[E0308]: mismatched types\n   --> $DIR/no_revealing_outside_defining_module.rs:19:5\n    |\n LL |     pub type Boo = impl ::std::fmt::Debug;\n-   |     -------------------------------------- the expected opaque type\n+   |                    ---------------------- the expected opaque type\n ...\n LL | fn bomp() -> boo::Boo {\n-   |              -------- expected `Boo` because of return type\n+   |              -------- expected `impl std::fmt::Debug` because of return type\n LL |     \"\"\n    |     ^^ expected opaque type, found `&str`\n    |\n-   = note: expected opaque type `Boo`\n+   = note: expected opaque type `impl std::fmt::Debug`\n                 found reference `&'static str`\n \n error: aborting due to 2 previous errors"}, {"sha": "726f4ea6e00f71c5006f71ec819b6db13d0544f8", "filename": "src/test/ui/type-alias-impl-trait/type-alias-impl-trait-with-cycle-error.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Ftype-alias-impl-trait-with-cycle-error.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Ftype-alias-impl-trait-with-cycle-error.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Ftype-alias-impl-trait-with-cycle-error.stderr?ref=ce6d3a73b514e9649e57cee812ad129bb2112016", "patch": "@@ -1,8 +1,8 @@\n error: could not find defining uses\n-  --> $DIR/type-alias-impl-trait-with-cycle-error.rs:3:1\n+  --> $DIR/type-alias-impl-trait-with-cycle-error.rs:3:12\n    |\n LL | type Foo = impl Fn() -> Foo;\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |            ^^^^^^^^^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "3947cc4d27055f5972f5b183beba416da1604957", "filename": "src/test/ui/type-alias-impl-trait/type-alias-impl-trait-with-cycle-error2.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Ftype-alias-impl-trait-with-cycle-error2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Ftype-alias-impl-trait-with-cycle-error2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Ftype-alias-impl-trait-with-cycle-error2.stderr?ref=ce6d3a73b514e9649e57cee812ad129bb2112016", "patch": "@@ -1,8 +1,8 @@\n error: could not find defining uses\n-  --> $DIR/type-alias-impl-trait-with-cycle-error2.rs:7:1\n+  --> $DIR/type-alias-impl-trait-with-cycle-error2.rs:7:12\n    |\n LL | type Foo = impl Bar<Foo, Item = Foo>;\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "fd954801dc047c95593dab02422e2cb882b4ad43", "filename": "src/test/ui/type-alias-impl-trait/type-alias-nested-impl-trait.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Ftype-alias-nested-impl-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Ftype-alias-nested-impl-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Ftype-alias-nested-impl-trait.rs?ref=ce6d3a73b514e9649e57cee812ad129bb2112016", "patch": "@@ -0,0 +1,14 @@\n+// run-pass\n+\n+#![feature(type_alias_impl_trait)]\n+\n+use std::iter::{once, Chain};\n+\n+type I<A> = Chain<A, impl Iterator<Item = &'static str>>;\n+fn test2<A: Iterator<Item = &'static str>>(x: A) -> I<A> {\n+    x.chain(once(\"5\"))\n+}\n+\n+fn main() {\n+    assert_eq!(vec![\"1\", \"3\", \"5\"], test2([\"1\", \"3\"].iter().cloned()).collect::<Vec<_>>());\n+}"}, {"sha": "318d0b69d57b7924ae7dd9adb8f138689bf838b2", "filename": "src/tools/clippy/clippy_lints/src/lifetimes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flifetimes.rs?ref=ce6d3a73b514e9649e57cee812ad129bb2112016", "patch": "@@ -379,7 +379,7 @@ impl<'a, 'tcx> Visitor<'tcx> for RefVisitor<'a, 'tcx> {\n             TyKind::Path(ref path) => {\n                 self.collect_anonymous_lifetimes(path, ty);\n             },\n-            TyKind::Def(item, _) => {\n+            TyKind::OpaqueDef(item, _) => {\n                 let map = self.cx.tcx.hir();\n                 if let ItemKind::OpaqueTy(ref exist_ty) = map.expect_item(item.id).kind {\n                     for bound in exist_ty.bounds {"}, {"sha": "03ab274d9ca9c9cc741445741b58b07f8da75436", "filename": "src/tools/clippy/clippy_lints/src/manual_async_fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_async_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_async_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_async_fn.rs?ref=ce6d3a73b514e9649e57cee812ad129bb2112016", "patch": "@@ -99,7 +99,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ManualAsyncFn {\n \n fn future_trait_ref<'tcx>(cx: &LateContext<'_, 'tcx>, ty: &'tcx Ty<'tcx>) -> Option<&'tcx TraitRef<'tcx>> {\n     if_chain! {\n-        if let TyKind::Def(item_id, _) = ty.kind;\n+        if let TyKind::OpaqueDef(item_id, _) = ty.kind;\n         let item = cx.tcx.hir().item(item_id.id);\n         if let ItemKind::OpaqueTy(opaque) = &item.kind;\n         if opaque.bounds.len() == 1;"}, {"sha": "0fd1e87f9e415c7b343b378310881a48fecc5728", "filename": "src/tools/clippy/clippy_lints/src/missing_doc.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_doc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_doc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_doc.rs?ref=ce6d3a73b514e9649e57cee812ad129bb2112016", "patch": "@@ -187,7 +187,6 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDoc {\n             hir::ImplItemKind::Const(..) => \"an associated constant\",\n             hir::ImplItemKind::Fn(..) => \"a method\",\n             hir::ImplItemKind::TyAlias(_) => \"an associated type\",\n-            hir::ImplItemKind::OpaqueTy(_) => \"an existential type\",\n         };\n         self.check_missing_docs_attrs(cx, &impl_item.attrs, impl_item.span, desc);\n     }"}, {"sha": "1802470b1841e72c63f0b58da84a6d86ba82b896", "filename": "src/tools/clippy/clippy_lints/src/missing_inline.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_inline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_inline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_inline.rs?ref=ce6d3a73b514e9649e57cee812ad129bb2112016", "patch": "@@ -142,7 +142,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingInline {\n \n         let desc = match impl_item.kind {\n             hir::ImplItemKind::Fn(..) => \"a method\",\n-            hir::ImplItemKind::Const(..) | hir::ImplItemKind::TyAlias(_) | hir::ImplItemKind::OpaqueTy(_) => return,\n+            hir::ImplItemKind::Const(..) | hir::ImplItemKind::TyAlias(_) => return,\n         };\n \n         let def_id = cx.tcx.hir().local_def_id(impl_item.hir_id);"}, {"sha": "7a84f1c986aa7dc4d059d7cf9314eb0ac187e460", "filename": "src/tools/clippy/clippy_lints/src/utils/hir_utils.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fhir_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fhir_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fhir_utils.rs?ref=ce6d3a73b514e9649e57cee812ad129bb2112016", "patch": "@@ -710,7 +710,7 @@ impl<'a, 'tcx> SpanlessHash<'a, 'tcx> {\n                     segment.ident.name.hash(&mut self.s);\n                 },\n             },\n-            TyKind::Def(_, arg_list) => {\n+            TyKind::OpaqueDef(_, arg_list) => {\n                 for arg in *arg_list {\n                     match arg {\n                         GenericArg::Lifetime(ref l) => self.hash_lifetime(l),"}, {"sha": "afde971f9df4ef67cf9e403147d815d702eafbf1", "filename": "src/tools/clippy/clippy_lints/src/utils/inspector.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finspector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce6d3a73b514e9649e57cee812ad129bb2112016/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finspector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finspector.rs?ref=ce6d3a73b514e9649e57cee812ad129bb2112016", "patch": "@@ -63,7 +63,6 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for DeepCodeInspector {\n             },\n             hir::ImplItemKind::Fn(..) => println!(\"method\"),\n             hir::ImplItemKind::TyAlias(_) => println!(\"associated type\"),\n-            hir::ImplItemKind::OpaqueTy(_) => println!(\"existential type\"),\n         }\n     }\n     // fn check_trait_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx"}]}