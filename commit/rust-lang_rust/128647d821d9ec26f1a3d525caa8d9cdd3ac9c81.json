{"sha": "128647d821d9ec26f1a3d525caa8d9cdd3ac9c81", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEyODY0N2Q4MjFkOWVjMjZmMWEzZDUyNWNhYThkOWNkZDNhYzljODE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-07-31T14:50:01Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-07-31T14:50:01Z"}, "message": "Auto merge of #4308 - jakubadamw:use-self-variant-scope, r=flip1995\n\nExtend the `use_self` lint to suggest uses of `Self::Variant`\n\nFixes #4296.\n\nchangelog: Extend the `use_self` lint to suggest uses of `Self::Variant`", "tree": {"sha": "81be9147660b7fb8a8d56fceee4c97f5de20c54d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/81be9147660b7fb8a8d56fceee4c97f5de20c54d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/128647d821d9ec26f1a3d525caa8d9cdd3ac9c81", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/128647d821d9ec26f1a3d525caa8d9cdd3ac9c81", "html_url": "https://github.com/rust-lang/rust/commit/128647d821d9ec26f1a3d525caa8d9cdd3ac9c81", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/128647d821d9ec26f1a3d525caa8d9cdd3ac9c81/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c3e913650e9850ccbb605ddc0d1a612fa70947d2", "url": "https://api.github.com/repos/rust-lang/rust/commits/c3e913650e9850ccbb605ddc0d1a612fa70947d2", "html_url": "https://github.com/rust-lang/rust/commit/c3e913650e9850ccbb605ddc0d1a612fa70947d2"}, {"sha": "2a13e83f2baafed62db958aa202666a4182c4fb5", "url": "https://api.github.com/repos/rust-lang/rust/commits/2a13e83f2baafed62db958aa202666a4182c4fb5", "html_url": "https://github.com/rust-lang/rust/commit/2a13e83f2baafed62db958aa202666a4182c4fb5"}], "stats": {"total": 259, "additions": 156, "deletions": 103}, "files": [{"sha": "e23673f275d3a47f4637126f8bc4beac446e2c5a", "filename": "clippy_dev/src/fmt.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/128647d821d9ec26f1a3d525caa8d9cdd3ac9c81/clippy_dev%2Fsrc%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/128647d821d9ec26f1a3d525caa8d9cdd3ac9c81/clippy_dev%2Fsrc%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_dev%2Fsrc%2Ffmt.rs?ref=128647d821d9ec26f1a3d525caa8d9cdd3ac9c81", "patch": "@@ -15,13 +15,13 @@ pub enum CliError {\n \n impl From<io::Error> for CliError {\n     fn from(error: io::Error) -> Self {\n-        CliError::IoError(error)\n+        Self::IoError(error)\n     }\n }\n \n impl From<walkdir::Error> for CliError {\n     fn from(error: walkdir::Error) -> Self {\n-        CliError::WalkDirError(error)\n+        Self::WalkDirError(error)\n     }\n }\n "}, {"sha": "c23f2fbc01164a2938742681eafad6424747bfd1", "filename": "clippy_lints/src/checked_conversions.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/128647d821d9ec26f1a3d525caa8d9cdd3ac9c81/clippy_lints%2Fsrc%2Fchecked_conversions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/128647d821d9ec26f1a3d525caa8d9cdd3ac9c81/clippy_lints%2Fsrc%2Fchecked_conversions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fchecked_conversions.rs?ref=128647d821d9ec26f1a3d525caa8d9cdd3ac9c81", "patch": "@@ -160,12 +160,12 @@ impl ConversionType {\n     /// Creates a conversion type if the type is allowed & conversion is valid\n     fn try_new(from: &str, to: &str) -> Option<Self> {\n         if UINTS.contains(&from) {\n-            Some(ConversionType::FromUnsigned)\n+            Some(Self::FromUnsigned)\n         } else if SINTS.contains(&from) {\n             if UINTS.contains(&to) {\n-                Some(ConversionType::SignedToUnsigned)\n+                Some(Self::SignedToUnsigned)\n             } else if SINTS.contains(&to) {\n-                Some(ConversionType::SignedToSigned)\n+                Some(Self::SignedToSigned)\n             } else {\n                 None\n             }"}, {"sha": "d18474abdcd4834de7a357da9199f1061dc4d379", "filename": "clippy_lints/src/consts.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/128647d821d9ec26f1a3d525caa8d9cdd3ac9c81/clippy_lints%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/128647d821d9ec26f1a3d525caa8d9cdd3ac9c81/clippy_lints%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fconsts.rs?ref=128647d821d9ec26f1a3d525caa8d9cdd3ac9c81", "patch": "@@ -48,27 +48,27 @@ pub enum Constant {\n impl PartialEq for Constant {\n     fn eq(&self, other: &Self) -> bool {\n         match (self, other) {\n-            (&Constant::Str(ref ls), &Constant::Str(ref rs)) => ls == rs,\n-            (&Constant::Binary(ref l), &Constant::Binary(ref r)) => l == r,\n-            (&Constant::Char(l), &Constant::Char(r)) => l == r,\n-            (&Constant::Int(l), &Constant::Int(r)) => l == r,\n-            (&Constant::F64(l), &Constant::F64(r)) => {\n+            (&Self::Str(ref ls), &Self::Str(ref rs)) => ls == rs,\n+            (&Self::Binary(ref l), &Self::Binary(ref r)) => l == r,\n+            (&Self::Char(l), &Self::Char(r)) => l == r,\n+            (&Self::Int(l), &Self::Int(r)) => l == r,\n+            (&Self::F64(l), &Self::F64(r)) => {\n                 // We want `Fw32 == FwAny` and `FwAny == Fw64`, and by transitivity we must have\n                 // `Fw32 == Fw64`, so don\u2019t compare them.\n                 // `to_bits` is required to catch non-matching 0.0, -0.0, and NaNs.\n                 l.to_bits() == r.to_bits()\n             },\n-            (&Constant::F32(l), &Constant::F32(r)) => {\n+            (&Self::F32(l), &Self::F32(r)) => {\n                 // We want `Fw32 == FwAny` and `FwAny == Fw64`, and by transitivity we must have\n                 // `Fw32 == Fw64`, so don\u2019t compare them.\n                 // `to_bits` is required to catch non-matching 0.0, -0.0, and NaNs.\n                 f64::from(l).to_bits() == f64::from(r).to_bits()\n             },\n-            (&Constant::Bool(l), &Constant::Bool(r)) => l == r,\n-            (&Constant::Vec(ref l), &Constant::Vec(ref r)) | (&Constant::Tuple(ref l), &Constant::Tuple(ref r)) => {\n+            (&Self::Bool(l), &Self::Bool(r)) => l == r,\n+            (&Self::Vec(ref l), &Self::Vec(ref r)) | (&Self::Tuple(ref l), &Self::Tuple(ref r)) => {\n                 l == r\n             },\n-            (&Constant::Repeat(ref lv, ref ls), &Constant::Repeat(ref rv, ref rs)) => ls == rs && lv == rv,\n+            (&Self::Repeat(ref lv, ref ls), &Self::Repeat(ref rv, ref rs)) => ls == rs && lv == rv,\n             // TODO: are there inter-type equalities?\n             _ => false,\n         }\n@@ -82,38 +82,38 @@ impl Hash for Constant {\n     {\n         std::mem::discriminant(self).hash(state);\n         match *self {\n-            Constant::Str(ref s) => {\n+            Self::Str(ref s) => {\n                 s.hash(state);\n             },\n-            Constant::Binary(ref b) => {\n+            Self::Binary(ref b) => {\n                 b.hash(state);\n             },\n-            Constant::Char(c) => {\n+            Self::Char(c) => {\n                 c.hash(state);\n             },\n-            Constant::Int(i) => {\n+            Self::Int(i) => {\n                 i.hash(state);\n             },\n-            Constant::F32(f) => {\n+            Self::F32(f) => {\n                 f64::from(f).to_bits().hash(state);\n             },\n-            Constant::F64(f) => {\n+            Self::F64(f) => {\n                 f.to_bits().hash(state);\n             },\n-            Constant::Bool(b) => {\n+            Self::Bool(b) => {\n                 b.hash(state);\n             },\n-            Constant::Vec(ref v) | Constant::Tuple(ref v) => {\n+            Self::Vec(ref v) | Self::Tuple(ref v) => {\n                 v.hash(state);\n             },\n-            Constant::Repeat(ref c, l) => {\n+            Self::Repeat(ref c, l) => {\n                 c.hash(state);\n                 l.hash(state);\n             },\n-            Constant::RawPtr(u) => {\n+            Self::RawPtr(u) => {\n                 u.hash(state);\n             },\n-            Constant::Err(ref s) => {\n+            Self::Err(ref s) => {\n                 s.hash(state);\n             },\n         }\n@@ -123,25 +123,25 @@ impl Hash for Constant {\n impl Constant {\n     pub fn partial_cmp(tcx: TyCtxt<'_>, cmp_type: Ty<'_>, left: &Self, right: &Self) -> Option<Ordering> {\n         match (left, right) {\n-            (&Constant::Str(ref ls), &Constant::Str(ref rs)) => Some(ls.cmp(rs)),\n-            (&Constant::Char(ref l), &Constant::Char(ref r)) => Some(l.cmp(r)),\n-            (&Constant::Int(l), &Constant::Int(r)) => {\n+            (&Self::Str(ref ls), &Self::Str(ref rs)) => Some(ls.cmp(rs)),\n+            (&Self::Char(ref l), &Self::Char(ref r)) => Some(l.cmp(r)),\n+            (&Self::Int(l), &Self::Int(r)) => {\n                 if let ty::Int(int_ty) = cmp_type.sty {\n                     Some(sext(tcx, l, int_ty).cmp(&sext(tcx, r, int_ty)))\n                 } else {\n                     Some(l.cmp(&r))\n                 }\n             },\n-            (&Constant::F64(l), &Constant::F64(r)) => l.partial_cmp(&r),\n-            (&Constant::F32(l), &Constant::F32(r)) => l.partial_cmp(&r),\n-            (&Constant::Bool(ref l), &Constant::Bool(ref r)) => Some(l.cmp(r)),\n-            (&Constant::Tuple(ref l), &Constant::Tuple(ref r)) | (&Constant::Vec(ref l), &Constant::Vec(ref r)) => l\n+            (&Self::F64(l), &Self::F64(r)) => l.partial_cmp(&r),\n+            (&Self::F32(l), &Self::F32(r)) => l.partial_cmp(&r),\n+            (&Self::Bool(ref l), &Self::Bool(ref r)) => Some(l.cmp(r)),\n+            (&Self::Tuple(ref l), &Self::Tuple(ref r)) | (&Self::Vec(ref l), &Self::Vec(ref r)) => l\n                 .iter()\n                 .zip(r.iter())\n                 .map(|(li, ri)| Self::partial_cmp(tcx, cmp_type, li, ri))\n                 .find(|r| r.map_or(true, |o| o != Ordering::Equal))\n                 .unwrap_or_else(|| Some(l.len().cmp(&r.len()))),\n-            (&Constant::Repeat(ref lv, ref ls), &Constant::Repeat(ref rv, ref rs)) => {\n+            (&Self::Repeat(ref lv, ref ls), &Self::Repeat(ref rv, ref rs)) => {\n                 match Self::partial_cmp(tcx, cmp_type, lv, rv) {\n                     Some(Equal) => Some(ls.cmp(rs)),\n                     x => x,"}, {"sha": "e996bac3911e2a7a076be48db06795fd9f1131ff", "filename": "clippy_lints/src/excessive_precision.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/128647d821d9ec26f1a3d525caa8d9cdd3ac9c81/clippy_lints%2Fsrc%2Fexcessive_precision.rs", "raw_url": "https://github.com/rust-lang/rust/raw/128647d821d9ec26f1a3d525caa8d9cdd3ac9c81/clippy_lints%2Fsrc%2Fexcessive_precision.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fexcessive_precision.rs?ref=128647d821d9ec26f1a3d525caa8d9cdd3ac9c81", "patch": "@@ -143,20 +143,20 @@ impl FloatFormat {\n     fn new(s: &str) -> Self {\n         s.chars()\n             .find_map(|x| match x {\n-                'e' => Some(FloatFormat::LowerExp),\n-                'E' => Some(FloatFormat::UpperExp),\n+                'e' => Some(Self::LowerExp),\n+                'E' => Some(Self::UpperExp),\n                 _ => None,\n             })\n-            .unwrap_or(FloatFormat::Normal)\n+            .unwrap_or(Self::Normal)\n     }\n     fn format<T>(&self, f: T) -> String\n     where\n         T: fmt::UpperExp + fmt::LowerExp + fmt::Display,\n     {\n         match self {\n-            FloatFormat::LowerExp => format!(\"{:e}\", f),\n-            FloatFormat::UpperExp => format!(\"{:E}\", f),\n-            FloatFormat::Normal => format!(\"{}\", f),\n+            Self::LowerExp => format!(\"{:e}\", f),\n+            Self::UpperExp => format!(\"{:E}\", f),\n+            Self::Normal => format!(\"{}\", f),\n         }\n     }\n }"}, {"sha": "9cc957f1499e70fa52d7e8a20b8e296a3d3e3419", "filename": "clippy_lints/src/literal_representation.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/128647d821d9ec26f1a3d525caa8d9cdd3ac9c81/clippy_lints%2Fsrc%2Fliteral_representation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/128647d821d9ec26f1a3d525caa8d9cdd3ac9c81/clippy_lints%2Fsrc%2Fliteral_representation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fliteral_representation.rs?ref=128647d821d9ec26f1a3d525caa8d9cdd3ac9c81", "patch": "@@ -115,8 +115,8 @@ impl Radix {\n     /// Returns a reasonable digit group size for this radix.\n     crate fn suggest_grouping(&self) -> usize {\n         match *self {\n-            Radix::Binary | Radix::Hexadecimal => 4,\n-            Radix::Octal | Radix::Decimal => 3,\n+            Self::Binary | Self::Hexadecimal => 4,\n+            Self::Octal | Self::Decimal => 3,\n         }\n     }\n }\n@@ -285,7 +285,7 @@ enum WarningType {\n impl WarningType {\n     crate fn display(&self, grouping_hint: &str, cx: &EarlyContext<'_>, span: syntax_pos::Span) {\n         match self {\n-            WarningType::MistypedLiteralSuffix => span_lint_and_sugg(\n+            Self::MistypedLiteralSuffix => span_lint_and_sugg(\n                 cx,\n                 MISTYPED_LITERAL_SUFFIXES,\n                 span,\n@@ -294,7 +294,7 @@ impl WarningType {\n                 grouping_hint.to_string(),\n                 Applicability::MaybeIncorrect,\n             ),\n-            WarningType::UnreadableLiteral => span_lint_and_sugg(\n+            Self::UnreadableLiteral => span_lint_and_sugg(\n                 cx,\n                 UNREADABLE_LITERAL,\n                 span,\n@@ -303,7 +303,7 @@ impl WarningType {\n                 grouping_hint.to_owned(),\n                 Applicability::MachineApplicable,\n             ),\n-            WarningType::LargeDigitGroups => span_lint_and_sugg(\n+            Self::LargeDigitGroups => span_lint_and_sugg(\n                 cx,\n                 LARGE_DIGIT_GROUPS,\n                 span,\n@@ -312,7 +312,7 @@ impl WarningType {\n                 grouping_hint.to_owned(),\n                 Applicability::MachineApplicable,\n             ),\n-            WarningType::InconsistentDigitGrouping => span_lint_and_sugg(\n+            Self::InconsistentDigitGrouping => span_lint_and_sugg(\n                 cx,\n                 INCONSISTENT_DIGIT_GROUPING,\n                 span,\n@@ -321,7 +321,7 @@ impl WarningType {\n                 grouping_hint.to_owned(),\n                 Applicability::MachineApplicable,\n             ),\n-            WarningType::DecimalRepresentation => span_lint_and_sugg(\n+            Self::DecimalRepresentation => span_lint_and_sugg(\n                 cx,\n                 DECIMAL_LITERAL_REPRESENTATION,\n                 span,"}, {"sha": "02dfb3e32aad7fcd9cecb61c8a8587b0b6855b75", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/128647d821d9ec26f1a3d525caa8d9cdd3ac9c81/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/128647d821d9ec26f1a3d525caa8d9cdd3ac9c81/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=128647d821d9ec26f1a3d525caa8d9cdd3ac9c81", "patch": "@@ -2505,14 +2505,14 @@ impl SelfKind {\n         let is_actually_self = |ty| is_self_ty(ty) || SpanlessEq::new(cx).eq_ty(ty, self_ty);\n         if is_self(arg) {\n             match self {\n-                SelfKind::Value => is_actually_self(ty),\n-                SelfKind::Ref | SelfKind::RefMut => {\n+                Self::Value => is_actually_self(ty),\n+                Self::Ref | Self::RefMut => {\n                     if allow_value_for_ref && is_actually_self(ty) {\n                         return true;\n                     }\n                     match ty.node {\n                         hir::TyKind::Rptr(_, ref mt_ty) => {\n-                            let mutability_match = if self == SelfKind::Ref {\n+                            let mutability_match = if self == Self::Ref {\n                                 mt_ty.mutbl == hir::MutImmutable\n                             } else {\n                                 mt_ty.mutbl == hir::MutMutable\n@@ -2526,20 +2526,20 @@ impl SelfKind {\n             }\n         } else {\n             match self {\n-                SelfKind::Value => false,\n-                SelfKind::Ref => is_as_ref_or_mut_trait(ty, self_ty, generics, &paths::ASREF_TRAIT),\n-                SelfKind::RefMut => is_as_ref_or_mut_trait(ty, self_ty, generics, &paths::ASMUT_TRAIT),\n-                SelfKind::No => true,\n+                Self::Value => false,\n+                Self::Ref => is_as_ref_or_mut_trait(ty, self_ty, generics, &paths::ASREF_TRAIT),\n+                Self::RefMut => is_as_ref_or_mut_trait(ty, self_ty, generics, &paths::ASMUT_TRAIT),\n+                Self::No => true,\n             }\n         }\n     }\n \n     fn description(self) -> &'static str {\n         match self {\n-            SelfKind::Value => \"self by value\",\n-            SelfKind::Ref => \"self by reference\",\n-            SelfKind::RefMut => \"self by mutable reference\",\n-            SelfKind::No => \"no self\",\n+            Self::Value => \"self by value\",\n+            Self::Ref => \"self by reference\",\n+            Self::RefMut => \"self by mutable reference\",\n+            Self::No => \"no self\",\n         }\n     }\n }\n@@ -2609,17 +2609,17 @@ fn single_segment_ty(ty: &hir::Ty) -> Option<&hir::PathSegment> {\n impl Convention {\n     fn check(&self, other: &str) -> bool {\n         match *self {\n-            Convention::Eq(this) => this == other,\n-            Convention::StartsWith(this) => other.starts_with(this) && this != other,\n+            Self::Eq(this) => this == other,\n+            Self::StartsWith(this) => other.starts_with(this) && this != other,\n         }\n     }\n }\n \n impl fmt::Display for Convention {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> Result<(), fmt::Error> {\n         match *self {\n-            Convention::Eq(this) => this.fmt(f),\n-            Convention::StartsWith(this) => this.fmt(f).and_then(|_| '*'.fmt(f)),\n+            Self::Eq(this) => this.fmt(f),\n+            Self::StartsWith(this) => this.fmt(f).and_then(|_| '*'.fmt(f)),\n         }\n     }\n }\n@@ -2636,11 +2636,11 @@ impl OutType {\n     fn matches(self, cx: &LateContext<'_, '_>, ty: &hir::FunctionRetTy) -> bool {\n         let is_unit = |ty: &hir::Ty| SpanlessEq::new(cx).eq_ty_kind(&ty.node, &hir::TyKind::Tup(vec![].into()));\n         match (self, ty) {\n-            (OutType::Unit, &hir::DefaultReturn(_)) => true,\n-            (OutType::Unit, &hir::Return(ref ty)) if is_unit(ty) => true,\n-            (OutType::Bool, &hir::Return(ref ty)) if is_bool(ty) => true,\n-            (OutType::Any, &hir::Return(ref ty)) if !is_unit(ty) => true,\n-            (OutType::Ref, &hir::Return(ref ty)) => matches!(ty.node, hir::TyKind::Rptr(_, _)),\n+            (Self::Unit, &hir::DefaultReturn(_)) => true,\n+            (Self::Unit, &hir::Return(ref ty)) if is_unit(ty) => true,\n+            (Self::Bool, &hir::Return(ref ty)) if is_bool(ty) => true,\n+            (Self::Any, &hir::Return(ref ty)) if !is_unit(ty) => true,\n+            (Self::Ref, &hir::Return(ref ty)) => matches!(ty.node, hir::TyKind::Rptr(_, _)),\n             _ => false,\n         }\n     }"}, {"sha": "644660100b8b891442f9f4309386b3092686b783", "filename": "clippy_lints/src/non_copy_const.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/128647d821d9ec26f1a3d525caa8d9cdd3ac9c81/clippy_lints%2Fsrc%2Fnon_copy_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/128647d821d9ec26f1a3d525caa8d9cdd3ac9c81/clippy_lints%2Fsrc%2Fnon_copy_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnon_copy_const.rs?ref=128647d821d9ec26f1a3d525caa8d9cdd3ac9c81", "patch": "@@ -84,6 +84,7 @@ declare_clippy_lint! {\n     \"referencing const with interior mutability\"\n }\n \n+#[allow(dead_code)]\n #[derive(Copy, Clone)]\n enum Source {\n     Item { item: Span },\n@@ -94,12 +95,12 @@ enum Source {\n impl Source {\n     fn lint(&self) -> (&'static Lint, &'static str, Span) {\n         match self {\n-            Source::Item { item } | Source::Assoc { item, .. } => (\n+            Self::Item { item } | Self::Assoc { item, .. } => (\n                 DECLARE_INTERIOR_MUTABLE_CONST,\n                 \"a const item should never be interior mutable\",\n                 *item,\n             ),\n-            Source::Expr { expr } => (\n+            Self::Expr { expr } => (\n                 BORROW_INTERIOR_MUTABLE_CONST,\n                 \"a const item with interior mutability should not be borrowed\",\n                 *expr,"}, {"sha": "ffd6d4ca0f56ab9609e810d4e60a72bf0f4c1c46", "filename": "clippy_lints/src/ptr_offset_with_cast.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/128647d821d9ec26f1a3d525caa8d9cdd3ac9c81/clippy_lints%2Fsrc%2Fptr_offset_with_cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/128647d821d9ec26f1a3d525caa8d9cdd3ac9c81/clippy_lints%2Fsrc%2Fptr_offset_with_cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fptr_offset_with_cast.rs?ref=128647d821d9ec26f1a3d525caa8d9cdd3ac9c81", "patch": "@@ -133,17 +133,17 @@ enum Method {\n impl Method {\n     fn suggestion(self) -> &'static str {\n         match self {\n-            Method::Offset => \"add\",\n-            Method::WrappingOffset => \"wrapping_add\",\n+            Self::Offset => \"add\",\n+            Self::WrappingOffset => \"wrapping_add\",\n         }\n     }\n }\n \n impl fmt::Display for Method {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match self {\n-            Method::Offset => write!(f, \"offset\"),\n-            Method::WrappingOffset => write!(f, \"wrapping_offset\"),\n+            Self::Offset => write!(f, \"offset\"),\n+            Self::WrappingOffset => write!(f, \"wrapping_offset\"),\n         }\n     }\n }"}, {"sha": "31d4c36585f36be2e3862d7fd6614f3090acfa2d", "filename": "clippy_lints/src/types.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/128647d821d9ec26f1a3d525caa8d9cdd3ac9c81/clippy_lints%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/128647d821d9ec26f1a3d525caa8d9cdd3ac9c81/clippy_lints%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes.rs?ref=128647d821d9ec26f1a3d525caa8d9cdd3ac9c81", "patch": "@@ -1725,10 +1725,10 @@ impl PartialEq for FullInt {\n impl PartialOrd for FullInt {\n     fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n         Some(match (self, other) {\n-            (&FullInt::S(s), &FullInt::S(o)) => s.cmp(&o),\n-            (&FullInt::U(s), &FullInt::U(o)) => s.cmp(&o),\n-            (&FullInt::S(s), &FullInt::U(o)) => Self::cmp_s_u(s, o),\n-            (&FullInt::U(s), &FullInt::S(o)) => Self::cmp_s_u(o, s).reverse(),\n+            (&Self::S(s), &Self::S(o)) => s.cmp(&o),\n+            (&Self::U(s), &Self::U(o)) => s.cmp(&o),\n+            (&Self::S(s), &Self::U(o)) => Self::cmp_s_u(s, o),\n+            (&Self::U(s), &Self::S(o)) => Self::cmp_s_u(o, s).reverse(),\n         })\n     }\n }"}, {"sha": "3f93e019c66755398e4f70e63a339ee63b527e70", "filename": "clippy_lints/src/use_self.rs", "status": "modified", "additions": 38, "deletions": 20, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/128647d821d9ec26f1a3d525caa8d9cdd3ac9c81/clippy_lints%2Fsrc%2Fuse_self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/128647d821d9ec26f1a3d525caa8d9cdd3ac9c81/clippy_lints%2Fsrc%2Fuse_self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fuse_self.rs?ref=128647d821d9ec26f1a3d525caa8d9cdd3ac9c81", "patch": "@@ -51,9 +51,11 @@ declare_lint_pass!(UseSelf => [USE_SELF]);\n \n const SEGMENTS_MSG: &str = \"segments should be composed of at least 1 element\";\n \n-fn span_use_self_lint(cx: &LateContext<'_, '_>, path: &Path) {\n+fn span_use_self_lint(cx: &LateContext<'_, '_>, path: &Path, last_segment: Option<&PathSegment>) {\n+    let last_segment = last_segment.unwrap_or_else(|| path.segments.last().expect(SEGMENTS_MSG));\n+\n     // Path segments only include actual path, no methods or fields.\n-    let last_path_span = path.segments.last().expect(SEGMENTS_MSG).ident.span;\n+    let last_path_span = last_segment.ident.span;\n     // Only take path up to the end of last_path_span.\n     let span = path.span.with_hi(last_path_span.hi());\n \n@@ -80,22 +82,18 @@ impl<'a, 'tcx> Visitor<'tcx> for TraitImplTyVisitor<'a, 'tcx> {\n         let trait_ty = self.trait_type_walker.next();\n         let impl_ty = self.impl_type_walker.next();\n \n-        if let TyKind::Path(QPath::Resolved(_, path)) = &t.node {\n+        if_chain! {\n+            if let TyKind::Path(QPath::Resolved(_, path)) = &t.node;\n+\n             // The implementation and trait types don't match which means that\n             // the concrete type was specified by the implementation\n-            if impl_ty != trait_ty {\n-                if let Some(impl_ty) = impl_ty {\n-                    if self.item_type == impl_ty {\n-                        let is_self_ty = if let def::Res::SelfTy(..) = path.res {\n-                            true\n-                        } else {\n-                            false\n-                        };\n-\n-                        if !is_self_ty {\n-                            span_use_self_lint(self.cx, path);\n-                        }\n-                    }\n+            if impl_ty != trait_ty;\n+            if let Some(impl_ty) = impl_ty;\n+            if self.item_type == impl_ty;\n+            then {\n+                match path.res {\n+                    def::Res::SelfTy(..) => {},\n+                    _ => span_use_self_lint(self.cx, path, None)\n                 }\n             }\n         }\n@@ -220,15 +218,35 @@ struct UseSelfVisitor<'a, 'tcx> {\n \n impl<'a, 'tcx> Visitor<'tcx> for UseSelfVisitor<'a, 'tcx> {\n     fn visit_path(&mut self, path: &'tcx Path, _id: HirId) {\n+        if path.segments.len() >= 2 {\n+            let last_but_one = &path.segments[path.segments.len() - 2];\n+            if last_but_one.ident.name != kw::SelfUpper {\n+                let enum_def_id = match path.res {\n+                    Res::Def(DefKind::Variant, variant_def_id) =>\n+                        self.cx.tcx.parent(variant_def_id),\n+                    Res::Def(DefKind::Ctor(def::CtorOf::Variant, _), ctor_def_id) => {\n+                        let variant_def_id = self.cx.tcx.parent(ctor_def_id);\n+                        variant_def_id.and_then(|def_id| self.cx.tcx.parent(def_id))\n+                    }\n+                    _ => None\n+                };\n+\n+                if self.item_path.res.opt_def_id() == enum_def_id {\n+                    span_use_self_lint(self.cx, path, Some(last_but_one));\n+                }\n+            }\n+        }\n+\n         if path.segments.last().expect(SEGMENTS_MSG).ident.name != kw::SelfUpper {\n             if self.item_path.res == path.res {\n-                span_use_self_lint(self.cx, path);\n-            } else if let Res::Def(DefKind::Ctor(def::CtorOf::Struct, CtorKind::Fn), ctor_did) = path.res {\n-                if self.item_path.res.opt_def_id() == self.cx.tcx.parent(ctor_did) {\n-                    span_use_self_lint(self.cx, path);\n+                span_use_self_lint(self.cx, path, None);\n+            } else if let Res::Def(DefKind::Ctor(def::CtorOf::Struct, CtorKind::Fn), ctor_def_id) = path.res {\n+                if self.item_path.res.opt_def_id() == self.cx.tcx.parent(ctor_def_id) {\n+                    span_use_self_lint(self.cx, path, None);\n                 }\n             }\n         }\n+\n         walk_path(self, path);\n     }\n "}, {"sha": "0c5db79dfd877ca218659a6edcbde246cb22a628", "filename": "clippy_lints/src/utils/conf.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/128647d821d9ec26f1a3d525caa8d9cdd3ac9c81/clippy_lints%2Fsrc%2Futils%2Fconf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/128647d821d9ec26f1a3d525caa8d9cdd3ac9c81/clippy_lints%2Fsrc%2Futils%2Fconf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fconf.rs?ref=128647d821d9ec26f1a3d525caa8d9cdd3ac9c81", "patch": "@@ -44,15 +44,15 @@ pub enum Error {\n impl fmt::Display for Error {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> Result<(), fmt::Error> {\n         match *self {\n-            Error::Io(ref err) => err.fmt(f),\n-            Error::Toml(ref err) => err.fmt(f),\n+            Self::Io(ref err) => err.fmt(f),\n+            Self::Toml(ref err) => err.fmt(f),\n         }\n     }\n }\n \n impl From<io::Error> for Error {\n     fn from(e: io::Error) -> Self {\n-        Error::Io(e)\n+        Self::Io(e)\n     }\n }\n "}, {"sha": "ac2a1708b65e6e3c409467fd754fe38e82fb59e9", "filename": "tests/ui/use_self.fixed", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/128647d821d9ec26f1a3d525caa8d9cdd3ac9c81/tests%2Fui%2Fuse_self.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/128647d821d9ec26f1a3d525caa8d9cdd3ac9c81/tests%2Fui%2Fuse_self.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fuse_self.fixed?ref=128647d821d9ec26f1a3d525caa8d9cdd3ac9c81", "patch": "@@ -265,13 +265,21 @@ mod nesting {\n \n     enum Enum {\n         A,\n+        B(u64),\n+        C { field: bool }\n     }\n     impl Enum {\n         fn method() {\n             #[allow(unused_imports)]\n             use self::Enum::*; // Issue 3425\n             static STATIC: Enum = Enum::A; // Can't use Self as type\n         }\n+\n+        fn method2() {\n+            let _ = Self::B(42);\n+            let _ = Self::C { field: true };\n+            let _ = Self::A;\n+        }\n     }\n }\n "}, {"sha": "21b5833e56ee27189f69057bd9b5b4df478482ae", "filename": "tests/ui/use_self.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/128647d821d9ec26f1a3d525caa8d9cdd3ac9c81/tests%2Fui%2Fuse_self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/128647d821d9ec26f1a3d525caa8d9cdd3ac9c81/tests%2Fui%2Fuse_self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fuse_self.rs?ref=128647d821d9ec26f1a3d525caa8d9cdd3ac9c81", "patch": "@@ -265,13 +265,21 @@ mod nesting {\n \n     enum Enum {\n         A,\n+        B(u64),\n+        C { field: bool }\n     }\n     impl Enum {\n         fn method() {\n             #[allow(unused_imports)]\n             use self::Enum::*; // Issue 3425\n             static STATIC: Enum = Enum::A; // Can't use Self as type\n         }\n+\n+        fn method2() {\n+            let _ = Enum::B(42);\n+            let _ = Enum::C { field: true };\n+            let _ = Enum::A;\n+        }\n     }\n }\n "}, {"sha": "12dd672e3f4b50456d4b2461f87ad3b86a23b7c8", "filename": "tests/ui/use_self.stderr", "status": "modified", "additions": 22, "deletions": 4, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/128647d821d9ec26f1a3d525caa8d9cdd3ac9c81/tests%2Fui%2Fuse_self.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/128647d821d9ec26f1a3d525caa8d9cdd3ac9c81/tests%2Fui%2Fuse_self.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fuse_self.stderr?ref=128647d821d9ec26f1a3d525caa8d9cdd3ac9c81", "patch": "@@ -175,22 +175,40 @@ LL |                     Bar { foo: Foo {} }\n    |                     ^^^ help: use the applicable keyword: `Self`\n \n error: unnecessary structure name repetition\n-  --> $DIR/use_self.rs:304:13\n+  --> $DIR/use_self.rs:279:21\n+   |\n+LL |             let _ = Enum::B(42);\n+   |                     ^^^^ help: use the applicable keyword: `Self`\n+\n+error: unnecessary structure name repetition\n+  --> $DIR/use_self.rs:280:21\n+   |\n+LL |             let _ = Enum::C { field: true };\n+   |                     ^^^^ help: use the applicable keyword: `Self`\n+\n+error: unnecessary structure name repetition\n+  --> $DIR/use_self.rs:281:21\n+   |\n+LL |             let _ = Enum::A;\n+   |                     ^^^^ help: use the applicable keyword: `Self`\n+\n+error: unnecessary structure name repetition\n+  --> $DIR/use_self.rs:312:13\n    |\n LL |             nested::A::fun_1();\n    |             ^^^^^^^^^ help: use the applicable keyword: `Self`\n \n error: unnecessary structure name repetition\n-  --> $DIR/use_self.rs:305:13\n+  --> $DIR/use_self.rs:313:13\n    |\n LL |             nested::A::A;\n    |             ^^^^^^^^^ help: use the applicable keyword: `Self`\n \n error: unnecessary structure name repetition\n-  --> $DIR/use_self.rs:307:13\n+  --> $DIR/use_self.rs:315:13\n    |\n LL |             nested::A {};\n    |             ^^^^^^^^^ help: use the applicable keyword: `Self`\n \n-error: aborting due to 31 previous errors\n+error: aborting due to 34 previous errors\n "}]}