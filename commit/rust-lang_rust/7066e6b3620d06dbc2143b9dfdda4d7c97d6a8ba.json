{"sha": "7066e6b3620d06dbc2143b9dfdda4d7c97d6a8ba", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcwNjZlNmIzNjIwZDA2ZGJjMjE0M2I5ZGZkZGE0ZDdjOTdkNmE4YmE=", "commit": {"author": {"name": "Vladyslav Katasonov", "email": "cpud47@gmail.com", "date": "2021-02-16T21:42:58Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-03-02T13:25:24Z"}, "message": "strip useless methods, and unary ops in suggest_name", "tree": {"sha": "ccfc2aa51bc29e0828c381ad5549098f18fb5114", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ccfc2aa51bc29e0828c381ad5549098f18fb5114"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7066e6b3620d06dbc2143b9dfdda4d7c97d6a8ba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7066e6b3620d06dbc2143b9dfdda4d7c97d6a8ba", "html_url": "https://github.com/rust-lang/rust/commit/7066e6b3620d06dbc2143b9dfdda4d7c97d6a8ba", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7066e6b3620d06dbc2143b9dfdda4d7c97d6a8ba/comments", "author": {"login": "cpud36", "id": 4218373, "node_id": "MDQ6VXNlcjQyMTgzNzM=", "avatar_url": "https://avatars.githubusercontent.com/u/4218373?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cpud36", "html_url": "https://github.com/cpud36", "followers_url": "https://api.github.com/users/cpud36/followers", "following_url": "https://api.github.com/users/cpud36/following{/other_user}", "gists_url": "https://api.github.com/users/cpud36/gists{/gist_id}", "starred_url": "https://api.github.com/users/cpud36/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cpud36/subscriptions", "organizations_url": "https://api.github.com/users/cpud36/orgs", "repos_url": "https://api.github.com/users/cpud36/repos", "events_url": "https://api.github.com/users/cpud36/events{/privacy}", "received_events_url": "https://api.github.com/users/cpud36/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "afc68277f69572944fd81d61b126732ab29b5d17", "url": "https://api.github.com/repos/rust-lang/rust/commits/afc68277f69572944fd81d61b126732ab29b5d17", "html_url": "https://github.com/rust-lang/rust/commit/afc68277f69572944fd81d61b126732ab29b5d17"}], "stats": {"total": 121, "additions": 114, "deletions": 7}, "files": [{"sha": "d37c62642911e2a930a59938184e958b2e59f076", "filename": "crates/ide_assists/src/utils/suggest_name.rs", "status": "modified", "additions": 114, "deletions": 7, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/7066e6b3620d06dbc2143b9dfdda4d7c97d6a8ba/crates%2Fide_assists%2Fsrc%2Futils%2Fsuggest_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7066e6b3620d06dbc2143b9dfdda4d7c97d6a8ba/crates%2Fide_assists%2Fsrc%2Futils%2Fsuggest_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Futils%2Fsuggest_name.rs?ref=7066e6b3620d06dbc2143b9dfdda4d7c97d6a8ba", "patch": "@@ -29,6 +29,29 @@ const WRAPPER_TYPES: &[&str] = &[\"Box\", \"Option\", \"Result\"];\n /// `args.into_config()` -> `config`\n /// `bytes.to_vec()` -> `vec`\n const USELESS_METHOD_PREFIXES: &[&str] = &[\"into_\", \"as_\", \"to_\"];\n+/// Useless methods that are stripped from expression\n+///\n+/// # Examples\n+/// `var.name().to_string()` -> `var.name()`\n+const USELESS_METHODS: &[&str] = &[\n+    \"to_string\",\n+    \"as_str\",\n+    \"to_owned\",\n+    \"as_ref\",\n+    \"clone\",\n+    \"cloned\",\n+    \"expect\",\n+    \"expect_none\",\n+    \"unwrap\",\n+    \"unwrap_none\",\n+    \"unwrap_or\",\n+    \"unwrap_or_default\",\n+    \"unwrap_or_else\",\n+    \"unwrap_unchecked\",\n+    \"iter\",\n+    \"into_iter\",\n+    \"iter_mut\",\n+];\n \n /// Suggest name of variable for given expression\n ///\n@@ -49,10 +72,39 @@ const USELESS_METHOD_PREFIXES: &[&str] = &[\"into_\", \"as_\", \"to_\"];\n ///\n /// Currently it sticks to the first name found.\n pub(crate) fn variable(expr: &ast::Expr, sema: &Semantics<'_, RootDatabase>) -> String {\n-    from_param(expr, sema)\n-        .or_else(|| from_call(expr))\n-        .or_else(|| from_type(expr, sema))\n-        .unwrap_or_else(|| \"var_name\".to_string())\n+    // `from_param` does not benifit from stripping\n+    // it need the largest context possible\n+    // so we check firstmost\n+    if let Some(name) = from_param(expr, sema) {\n+        return name;\n+    }\n+\n+    let mut next_expr = Some(expr.clone());\n+    while let Some(expr) = next_expr {\n+        let name = from_call(&expr).or_else(|| from_type(&expr, sema));\n+        if let Some(name) = name {\n+            return name;\n+        }\n+\n+        match expr {\n+            ast::Expr::RefExpr(inner) => next_expr = inner.expr(),\n+            ast::Expr::BoxExpr(inner) => next_expr = inner.expr(),\n+            ast::Expr::AwaitExpr(inner) => next_expr = inner.expr(),\n+            // ast::Expr::BlockExpr(block) => expr = block.tail_expr(),\n+            ast::Expr::CastExpr(inner) => next_expr = inner.expr(),\n+            ast::Expr::MethodCallExpr(method) if is_useless_method(&method) => {\n+                next_expr = method.receiver();\n+            }\n+            ast::Expr::ParenExpr(inner) => next_expr = inner.expr(),\n+            ast::Expr::TryExpr(inner) => next_expr = inner.expr(),\n+            ast::Expr::PrefixExpr(prefix) if prefix.op_kind() == Some(ast::PrefixOp::Deref) => {\n+                next_expr = prefix.expr()\n+            }\n+            _ => break,\n+        }\n+    }\n+\n+    \"var_name\".to_string()\n }\n \n fn normalize(name: &str) -> Option<String> {\n@@ -76,6 +128,16 @@ fn is_valid_name(name: &str) -> bool {\n     }\n }\n \n+fn is_useless_method(method: &ast::MethodCallExpr) -> bool {\n+    let ident = method.name_ref().and_then(|it| it.ident_token());\n+\n+    if let Some(ident) = ident {\n+        USELESS_METHODS.contains(&ident.text())\n+    } else {\n+        false\n+    }\n+}\n+\n fn from_call(expr: &ast::Expr) -> Option<String> {\n     from_func_call(expr).or_else(|| from_method_call(expr))\n }\n@@ -99,15 +161,20 @@ fn from_method_call(expr: &ast::Expr) -> Option<String> {\n         _ => return None,\n     };\n     let ident = method.name_ref()?.ident_token()?;\n-    let name = normalize(ident.text())?;\n+    let mut name = ident.text();\n+\n+    if USELESS_METHODS.contains(&name) {\n+        return None;\n+    }\n \n     for prefix in USELESS_METHOD_PREFIXES {\n         if let Some(suffix) = name.strip_prefix(prefix) {\n-            return Some(suffix.to_string());\n+            name = suffix;\n+            break;\n         }\n     }\n \n-    Some(name)\n+    normalize(&name)\n }\n \n fn from_param(expr: &ast::Expr, sema: &Semantics<'_, RootDatabase>) -> Option<String> {\n@@ -767,4 +834,44 @@ mod tests {\n             );\n         }\n     }\n+\n+    mod variable {\n+        use super::*;\n+\n+        #[test]\n+        fn ref_call() {\n+            check_name_suggestion(\n+                |e, c| Some(variable(e, c)),\n+                r#\"\n+                fn foo() {\n+                    $0&bar(1, 3)$0\n+                }\"#,\n+                \"bar\",\n+            );\n+        }\n+\n+        #[test]\n+        fn name_to_string() {\n+            check_name_suggestion(\n+                |e, c| Some(variable(e, c)),\n+                r#\"\n+                fn foo() {\n+                    $0function.name().to_string()$0\n+                }\"#,\n+                \"name\",\n+            );\n+        }\n+\n+        #[test]\n+        fn nested_useless_method() {\n+            check_name_suggestion(\n+                |e, c| Some(variable(e, c)),\n+                r#\"\n+                fn foo() {\n+                    $0function.name().as_ref().unwrap().to_string()$0\n+                }\"#,\n+                \"name\",\n+            );\n+        }\n+    }\n }"}]}