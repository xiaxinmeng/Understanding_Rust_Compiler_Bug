{"sha": "6e5198cd6dc0572ffaddcdea29d5541085ec5300", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZlNTE5OGNkNmRjMDU3MmZmYWRkY2RlYTI5ZDU1NDEwODVlYzUzMDA=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-09-10T17:09:43Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-09-10T17:26:41Z"}, "message": "add fragmets to expansion", "tree": {"sha": "43ab118e6a00130814f012fe0386f0f421c2ef34", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/43ab118e6a00130814f012fe0386f0f421c2ef34"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6e5198cd6dc0572ffaddcdea29d5541085ec5300", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6e5198cd6dc0572ffaddcdea29d5541085ec5300", "html_url": "https://github.com/rust-lang/rust/commit/6e5198cd6dc0572ffaddcdea29d5541085ec5300", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6e5198cd6dc0572ffaddcdea29d5541085ec5300/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9d3c78e2eee6635772c99d7351b621cefb08bac5", "url": "https://api.github.com/repos/rust-lang/rust/commits/9d3c78e2eee6635772c99d7351b621cefb08bac5", "html_url": "https://github.com/rust-lang/rust/commit/9d3c78e2eee6635772c99d7351b621cefb08bac5"}], "stats": {"total": 78, "additions": 42, "deletions": 36}, "files": [{"sha": "db05c625375c1f9888a53956bbe66f6b6fd8393b", "filename": "crates/ra_mbe/src/mbe_expander.rs", "status": "modified", "additions": 40, "deletions": 33, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/6e5198cd6dc0572ffaddcdea29d5541085ec5300/crates%2Fra_mbe%2Fsrc%2Fmbe_expander.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e5198cd6dc0572ffaddcdea29d5541085ec5300/crates%2Fra_mbe%2Fsrc%2Fmbe_expander.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Fmbe_expander.rs?ref=6e5198cd6dc0572ffaddcdea29d5541085ec5300", "patch": "@@ -81,21 +81,26 @@ struct Bindings {\n \n #[derive(Debug)]\n enum Binding {\n-    Simple(tt::TokenTree),\n+    Fragment(Fragment),\n     Nested(Vec<Binding>),\n     Empty,\n }\n \n+#[derive(Debug, Clone)]\n+enum Fragment {\n+    /// token fragments are just copy-pasted into the output\n+    Tokens(tt::TokenTree),\n+    /// Ast fragments are inserted with fake delimiters, so as to make things\n+    /// like `$i * 2` where `$i = 1 + 1` work as expectd.\n+    Ast(tt::TokenTree),\n+}\n+\n impl Bindings {\n     fn push_optional(&mut self, name: &SmolStr) {\n         // FIXME: Do we have a better way to represent an empty token ?\n         // Insert an empty subtree for empty token\n-        self.inner.insert(\n-            name.clone(),\n-            Binding::Simple(\n-                tt::Subtree { delimiter: tt::Delimiter::None, token_trees: vec![] }.into(),\n-            ),\n-        );\n+        let tt = tt::Subtree { delimiter: tt::Delimiter::None, token_trees: vec![] }.into();\n+        self.inner.insert(name.clone(), Binding::Fragment(Fragment::Tokens(tt)));\n     }\n \n     fn push_empty(&mut self, name: &SmolStr) {\n@@ -106,13 +111,13 @@ impl Bindings {\n         self.inner.contains_key(name)\n     }\n \n-    fn get(&self, name: &SmolStr, nesting: &[usize]) -> Result<&tt::TokenTree, ExpandError> {\n+    fn get(&self, name: &SmolStr, nesting: &[usize]) -> Result<&Fragment, ExpandError> {\n         let mut b = self.inner.get(name).ok_or_else(|| {\n             ExpandError::BindingError(format!(\"could not find binding `{}`\", name))\n         })?;\n         for &idx in nesting.iter() {\n             b = match b {\n-                Binding::Simple(_) => break,\n+                Binding::Fragment(_) => break,\n                 Binding::Nested(bs) => bs.get(idx).ok_or_else(|| {\n                     ExpandError::BindingError(format!(\"could not find nested binding `{}`\", name))\n                 })?,\n@@ -125,7 +130,7 @@ impl Bindings {\n             };\n         }\n         match b {\n-            Binding::Simple(it) => Ok(it),\n+            Binding::Fragment(it) => Ok(it),\n             Binding::Nested(_) => Err(ExpandError::BindingError(format!(\n                 \"expected simple binding, found nested binding `{}`\",\n                 name\n@@ -195,8 +200,8 @@ fn match_lhs(pattern: &crate::Subtree, input: &mut TtCursor) -> Result<Bindings,\n                 crate::Leaf::Var(crate::Var { text, kind }) => {\n                     let kind = kind.as_ref().ok_or(ExpandError::UnexpectedToken)?;\n                     match match_meta_var(kind.as_str(), input)? {\n-                        Some(tt) => {\n-                            res.inner.insert(text.clone(), Binding::Simple(tt));\n+                        Some(fragment) => {\n+                            res.inner.insert(text.clone(), Binding::Fragment(fragment));\n                         }\n                         None => res.push_optional(text),\n                     }\n@@ -292,7 +297,7 @@ fn match_lhs(pattern: &crate::Subtree, input: &mut TtCursor) -> Result<Bindings,\n     Ok(res)\n }\n \n-fn match_meta_var(kind: &str, input: &mut TtCursor) -> Result<Option<tt::TokenTree>, ExpandError> {\n+fn match_meta_var(kind: &str, input: &mut TtCursor) -> Result<Option<Fragment>, ExpandError> {\n     let fragment = match kind {\n         \"path\" => Path,\n         \"expr\" => Expr,\n@@ -303,7 +308,7 @@ fn match_meta_var(kind: &str, input: &mut TtCursor) -> Result<Option<tt::TokenTr\n         \"meta\" => MetaItem,\n         \"item\" => Item,\n         _ => {\n-            let binding = match kind {\n+            let tt = match kind {\n                 \"ident\" => {\n                     let ident = input.eat_ident().ok_or(ExpandError::UnexpectedToken)?.clone();\n                     tt::Leaf::from(ident).into()\n@@ -321,11 +326,12 @@ fn match_meta_var(kind: &str, input: &mut TtCursor) -> Result<Option<tt::TokenTr\n                 },\n                 _ => return Err(ExpandError::UnexpectedToken),\n             };\n-            return Ok(Some(binding));\n+            return Ok(Some(Fragment::Tokens(tt)));\n         }\n     };\n-    let binding = input.eat_fragment(fragment).ok_or(ExpandError::UnexpectedToken)?;\n-    Ok(Some(binding))\n+    let tt = input.eat_fragment(fragment).ok_or(ExpandError::UnexpectedToken)?;\n+    let fragment = if kind == \"expr\" { Fragment::Ast(tt) } else { Fragment::Tokens(tt) };\n+    Ok(Some(fragment))\n }\n \n #[derive(Debug)]\n@@ -342,7 +348,7 @@ fn expand_subtree(\n     let mut buf: Vec<tt::TokenTree> = Vec::new();\n     for tt in template.token_trees.iter() {\n         let tt = expand_tt(tt, ctx)?;\n-        push_tt(&mut buf, tt);\n+        push_fragment(&mut buf, tt);\n     }\n \n     Ok(tt::Subtree { delimiter: template.delimiter, token_trees: buf })\n@@ -362,10 +368,7 @@ fn reduce_single_token(mut subtree: tt::Subtree) -> tt::TokenTree {\n     }\n }\n \n-fn expand_tt(\n-    template: &crate::TokenTree,\n-    ctx: &mut ExpandCtx,\n-) -> Result<tt::TokenTree, ExpandError> {\n+fn expand_tt(template: &crate::TokenTree, ctx: &mut ExpandCtx) -> Result<Fragment, ExpandError> {\n     let res: tt::TokenTree = match template {\n         crate::TokenTree::Subtree(subtree) => expand_subtree(subtree, ctx)?.into(),\n         crate::TokenTree::Repeat(repeat) => {\n@@ -492,20 +495,24 @@ fn expand_tt(\n                     }\n                     .into()\n                 } else {\n-                    let tkn = ctx.bindings.get(&v.text, &ctx.nesting)?.clone();\n+                    let fragment = ctx.bindings.get(&v.text, &ctx.nesting)?.clone();\n                     ctx.var_expanded = true;\n-\n-                    if let tt::TokenTree::Subtree(subtree) = tkn {\n-                        reduce_single_token(subtree)\n-                    } else {\n-                        tkn\n+                    match fragment {\n+                        Fragment::Tokens(tt) => {\n+                            if let tt::TokenTree::Subtree(subtree) = tt {\n+                                reduce_single_token(subtree)\n+                            } else {\n+                                tt\n+                            }\n+                        }\n+                        Fragment::Ast(_) => return Ok(fragment),\n                     }\n                 }\n             }\n             crate::Leaf::Literal(l) => tt::Leaf::from(tt::Literal { text: l.text.clone() }).into(),\n         },\n     };\n-    Ok(res)\n+    Ok(Fragment::Tokens(res))\n }\n \n #[cfg(test)]\n@@ -579,10 +586,10 @@ mod tests {\n     }\n }\n \n-fn push_tt(buf: &mut Vec<tt::TokenTree>, tt: tt::TokenTree) {\n-    match tt {\n-        tt::TokenTree::Subtree(tt) => push_subtree(buf, tt),\n-        _ => buf.push(tt),\n+fn push_fragment(buf: &mut Vec<tt::TokenTree>, fragment: Fragment) {\n+    match fragment {\n+        Fragment::Tokens(tt::TokenTree::Subtree(tt)) => push_subtree(buf, tt),\n+        Fragment::Tokens(tt) | Fragment::Ast(tt) => buf.push(tt),\n     }\n }\n "}, {"sha": "0f07e935dce04e02e8679311684b36ff158e2f2b", "filename": "crates/ra_mbe/src/tests.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6e5198cd6dc0572ffaddcdea29d5541085ec5300/crates%2Fra_mbe%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e5198cd6dc0572ffaddcdea29d5541085ec5300/crates%2Fra_mbe%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Ftests.rs?ref=6e5198cd6dc0572ffaddcdea29d5541085ec5300", "patch": "@@ -657,7 +657,6 @@ fn test_expr() {\n }\n \n #[test]\n-#[ignore]\n fn test_expr_order() {\n     let rules = create_rules(\n         r#\"\n@@ -668,9 +667,9 @@ fn test_expr_order() {\n         }\n \"#,\n     );\n-\n+    let dump = format!(\"{:#?}\", expand_to_items(&rules, \"foo! { 1 + 1  }\").syntax());\n     assert_eq_text!(\n-        &format!(\"{:#?}\", expand_to_items(&rules, \"foo! { 1 + 1  }\").syntax()),\n+        dump.trim(),\n         r#\"MACRO_ITEMS@[0; 15)\n   FN_DEF@[0; 15)\n     FN_KW@[0; 2) \"fn\""}]}