{"sha": "ce342f522c10eef8799f2b91b7f39947d40f93ce", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNlMzQyZjUyMmMxMGVlZjg3OTlmMmI5MWI3ZjM5OTQ3ZDQwZjkzY2U=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-10-18T17:02:13Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-10-18T17:02:13Z"}, "message": "auto merge of #18041 : arielb1/rust/no-size-overflow, r=pnkfelix\n\nShould fix #17913.\r\n\r\nAlso clean-up u64/u32-ness. I really should split this commit and add tests (I have no idea how to add them).", "tree": {"sha": "4d73e7388e74acda5c1f1142e726cee91be7929f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4d73e7388e74acda5c1f1142e726cee91be7929f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ce342f522c10eef8799f2b91b7f39947d40f93ce", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ce342f522c10eef8799f2b91b7f39947d40f93ce", "html_url": "https://github.com/rust-lang/rust/commit/ce342f522c10eef8799f2b91b7f39947d40f93ce", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ce342f522c10eef8799f2b91b7f39947d40f93ce/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d670919aa43d186317a89a375f4a5b7170fc08a8", "url": "https://api.github.com/repos/rust-lang/rust/commits/d670919aa43d186317a89a375f4a5b7170fc08a8", "html_url": "https://github.com/rust-lang/rust/commit/d670919aa43d186317a89a375f4a5b7170fc08a8"}, {"sha": "ccdf8d5b527538d8959b5c76bba917b5326027a8", "url": "https://api.github.com/repos/rust-lang/rust/commits/ccdf8d5b527538d8959b5c76bba917b5326027a8", "html_url": "https://github.com/rust-lang/rust/commit/ccdf8d5b527538d8959b5c76bba917b5326027a8"}], "stats": {"total": 530, "additions": 388, "deletions": 142}, "files": [{"sha": "224f843ded66a3dc7b4077ba8900e8586a382ad9", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ce342f522c10eef8799f2b91b7f39947d40f93ce/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce342f522c10eef8799f2b91b7f39947d40f93ce/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=ce342f522c10eef8799f2b91b7f39947d40f93ce", "patch": "@@ -1090,7 +1090,7 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     let sw = if kind == Switch {\n         build::Switch(bcx, test_val, else_cx.llbb, opts.len())\n     } else {\n-        C_int(ccx, 0) // Placeholder for when not using a switch\n+        C_int(ccx, 0i) // Placeholder for when not using a switch\n     };\n \n     let defaults = enter_default(else_cx, dm, m, col, val);"}, {"sha": "7ec0f8716c11cbaea6598fd62e4f5daede170462", "filename": "src/librustc/middle/trans/adt.rs", "status": "modified", "additions": 97, "deletions": 54, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/ce342f522c10eef8799f2b91b7f39947d40f93ce/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce342f522c10eef8799f2b91b7f39947d40f93ce/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs?ref=ce342f522c10eef8799f2b91b7f39947d40f93ce", "patch": "@@ -45,7 +45,6 @@\n \n #![allow(unsigned_negate)]\n \n-use libc::c_ulonglong;\n use std::collections::Map;\n use std::num::Int;\n use std::rc::Rc;\n@@ -132,7 +131,7 @@ pub struct Struct {\n     // If the struct is DST, then the size and alignment do not take into\n     // account the unsized fields of the struct.\n     pub size: u64,\n-    pub align: u64,\n+    pub align: u32,\n     pub sized: bool,\n     pub packed: bool,\n     pub fields: Vec<ty::t>\n@@ -164,7 +163,7 @@ pub fn represent_type(cx: &CrateContext, t: ty::t) -> Rc<Repr> {\n fn represent_type_uncached(cx: &CrateContext, t: ty::t) -> Repr {\n     match ty::get(t).sty {\n         ty::ty_tup(ref elems) => {\n-            return Univariant(mk_struct(cx, elems.as_slice(), false), false)\n+            return Univariant(mk_struct(cx, elems.as_slice(), false, t), false)\n         }\n         ty::ty_struct(def_id, ref substs) => {\n             let fields = ty::lookup_struct_fields(cx.tcx(), def_id);\n@@ -175,12 +174,12 @@ fn represent_type_uncached(cx: &CrateContext, t: ty::t) -> Repr {\n             let dtor = ty::ty_dtor(cx.tcx(), def_id).has_drop_flag();\n             if dtor { ftys.push(ty::mk_bool()); }\n \n-            return Univariant(mk_struct(cx, ftys.as_slice(), packed), dtor)\n+            return Univariant(mk_struct(cx, ftys.as_slice(), packed, t), dtor)\n         }\n         ty::ty_unboxed_closure(def_id, _) => {\n             let upvars = ty::unboxed_closure_upvars(cx.tcx(), def_id);\n             let upvar_types = upvars.iter().map(|u| u.ty).collect::<Vec<_>>();\n-            return Univariant(mk_struct(cx, upvar_types.as_slice(), false),\n+            return Univariant(mk_struct(cx, upvar_types.as_slice(), false, t),\n                               false)\n         }\n         ty::ty_enum(def_id, ref substs) => {\n@@ -195,7 +194,8 @@ fn represent_type_uncached(cx: &CrateContext, t: ty::t) -> Repr {\n                 // (Typechecking will reject discriminant-sizing attrs.)\n                 assert_eq!(hint, attr::ReprAny);\n                 let ftys = if dtor { vec!(ty::mk_bool()) } else { vec!() };\n-                return Univariant(mk_struct(cx, ftys.as_slice(), false), dtor);\n+                return Univariant(mk_struct(cx, ftys.as_slice(), false, t),\n+                                  dtor);\n             }\n \n             if !dtor && cases.iter().all(|c| c.tys.len() == 0) {\n@@ -226,15 +226,17 @@ fn represent_type_uncached(cx: &CrateContext, t: ty::t) -> Repr {\n                 assert_eq!(hint, attr::ReprAny);\n                 let mut ftys = cases.get(0).tys.clone();\n                 if dtor { ftys.push(ty::mk_bool()); }\n-                return Univariant(mk_struct(cx, ftys.as_slice(), false), dtor);\n+                return Univariant(mk_struct(cx, ftys.as_slice(), false, t),\n+                                  dtor);\n             }\n \n             if !dtor && cases.len() == 2 && hint == attr::ReprAny {\n                 // Nullable pointer optimization\n                 let mut discr = 0;\n                 while discr < 2 {\n-                    if cases.get(1 - discr).is_zerolen(cx) {\n-                        let st = mk_struct(cx, cases.get(discr).tys.as_slice(), false);\n+                    if cases.get(1 - discr).is_zerolen(cx, t) {\n+                        let st = mk_struct(cx, cases.get(discr).tys.as_slice(),\n+                                           false, t);\n                         match cases.get(discr).find_ptr() {\n                             Some(ThinPointer(_)) if st.fields.len() == 1 => {\n                                 return RawNullablePointer {\n@@ -264,11 +266,15 @@ fn represent_type_uncached(cx: &CrateContext, t: ty::t) -> Repr {\n                                      slo: 0, shi: (cases.len() - 1) as i64 };\n             let ity = range_to_inttype(cx, hint, &bounds);\n \n-            return General(ity, cases.iter().map(|c| {\n+            let fields : Vec<_> = cases.iter().map(|c| {\n                 let mut ftys = vec!(ty_of_inttype(ity)).append(c.tys.as_slice());\n                 if dtor { ftys.push(ty::mk_bool()); }\n-                mk_struct(cx, ftys.as_slice(), false)\n-            }).collect(), dtor);\n+                mk_struct(cx, ftys.as_slice(), false, t)\n+            }).collect();\n+\n+            ensure_enum_fits_in_address_space(cx, ity, fields.as_slice(), t);\n+\n+            General(ity, fields, dtor)\n         }\n         _ => cx.sess().bug(format!(\"adt::represent_type called on non-ADT type: {}\",\n                            ty_to_string(cx.tcx(), t)).as_slice())\n@@ -289,8 +295,8 @@ pub enum PointerField {\n }\n \n impl Case {\n-    fn is_zerolen(&self, cx: &CrateContext) -> bool {\n-        mk_struct(cx, self.tys.as_slice(), false).size == 0\n+    fn is_zerolen(&self, cx: &CrateContext, scapegoat: ty::t) -> bool {\n+        mk_struct(cx, self.tys.as_slice(), false, scapegoat).size == 0\n     }\n \n     fn find_ptr(&self) -> Option<PointerField> {\n@@ -345,29 +351,25 @@ fn get_cases(tcx: &ty::ctxt, def_id: ast::DefId, substs: &subst::Substs) -> Vec<\n     }).collect()\n }\n \n-fn mk_struct(cx: &CrateContext, tys: &[ty::t], packed: bool) -> Struct {\n-    if tys.iter().all(|&ty| ty::type_is_sized(cx.tcx(), ty)) {\n-        let lltys = tys.iter().map(|&ty| type_of::sizing_type_of(cx, ty)).collect::<Vec<_>>();\n-        let llty_rec = Type::struct_(cx, lltys.as_slice(), packed);\n-        Struct {\n-            size: machine::llsize_of_alloc(cx, llty_rec),\n-            align: machine::llalign_of_min(cx, llty_rec),\n-            sized: true,\n-            packed: packed,\n-            fields: Vec::from_slice(tys),\n-        }\n+fn mk_struct(cx: &CrateContext, tys: &[ty::t], packed: bool, scapegoat: ty::t) -> Struct {\n+    let sized = tys.iter().all(|&ty| ty::type_is_sized(cx.tcx(), ty));\n+    let lltys : Vec<Type> = if sized {\n+        tys.iter()\n+           .map(|&ty| type_of::sizing_type_of(cx, ty)).collect()\n     } else {\n-        // Ignore any dynamically sized fields.\n-        let lltys = tys.iter().filter(|&ty| ty::type_is_sized(cx.tcx(), *ty))\n-            .map(|&ty| type_of::sizing_type_of(cx, ty)).collect::<Vec<_>>();\n-        let llty_rec = Type::struct_(cx, lltys.as_slice(), packed);\n-        Struct {\n-            size: machine::llsize_of_alloc(cx, llty_rec),\n-            align: machine::llalign_of_min(cx, llty_rec),\n-            sized: false,\n-            packed: packed,\n-            fields: Vec::from_slice(tys),\n-        }\n+        tys.iter().filter(|&ty| ty::type_is_sized(cx.tcx(), *ty))\n+           .map(|&ty| type_of::sizing_type_of(cx, ty)).collect()\n+    };\n+\n+    ensure_struct_fits_in_address_space(cx, lltys.as_slice(), packed, scapegoat);\n+\n+    let llty_rec = Type::struct_(cx, lltys.as_slice(), packed);\n+    Struct {\n+        size: machine::llsize_of_alloc(cx, llty_rec),\n+        align: machine::llalign_of_min(cx, llty_rec),\n+        sized: sized,\n+        packed: packed,\n+        fields: Vec::from_slice(tys),\n     }\n }\n \n@@ -463,6 +465,51 @@ pub fn ty_of_inttype(ity: IntType) -> ty::t {\n     }\n }\n \n+// LLVM doesn't like types that don't fit in the address space\n+fn ensure_struct_fits_in_address_space(ccx: &CrateContext,\n+                                       fields: &[Type],\n+                                       packed: bool,\n+                                       scapegoat: ty::t) {\n+    let mut offset = 0;\n+    for &llty in fields.iter() {\n+        // Invariant: offset < ccx.max_obj_size() <= 1<<61\n+        if !packed {\n+            let type_align = machine::llalign_of_min(ccx, llty);\n+            offset = roundup(offset, type_align);\n+        }\n+        // type_align is a power-of-2, so still offset < ccx.max_obj_size()\n+        // llsize_of_alloc(ccx, llty) is also less than ccx.max_obj_size()\n+        // so the sum is less than 1<<62 (and therefore can't overflow).\n+        offset += machine::llsize_of_alloc(ccx, llty);\n+\n+        if offset >= ccx.max_obj_size() {\n+            ccx.report_overbig_object(scapegoat);\n+        }\n+    }\n+}\n+\n+fn union_size_and_align(sts: &[Struct]) -> (machine::llsize, machine::llalign) {\n+    let size = sts.iter().map(|st| st.size).max().unwrap();\n+    let most_aligned = sts.iter().max_by(|st| st.align).unwrap();\n+    (size, most_aligned.align)\n+}\n+\n+fn ensure_enum_fits_in_address_space(ccx: &CrateContext,\n+                                     discr: IntType,\n+                                     fields: &[Struct],\n+                                     scapegoat: ty::t) {\n+    let discr_size = machine::llsize_of_alloc(ccx, ll_inttype(ccx, discr));\n+    let (field_size, field_align) = union_size_and_align(fields);\n+\n+    // field_align < 1<<32, discr_size <= 8, field_size < MAX_OBJ_SIZE <= 1<<61\n+    // so the sum is less than 1<<62 (and can't overflow).\n+    let total_size = roundup(discr_size, field_align) + field_size;\n+\n+    if total_size >= ccx.max_obj_size() {\n+        ccx.report_overbig_object(scapegoat);\n+    }\n+}\n+\n \n /**\n  * LLVM-level types are a little complicated.\n@@ -525,13 +572,12 @@ fn generic_type_of(cx: &CrateContext,\n             // of the size.\n             //\n             // FIXME #10604: this breaks when vector types are present.\n-            let size = sts.iter().map(|st| st.size).max().unwrap();\n-            let most_aligned = sts.iter().max_by(|st| st.align).unwrap();\n-            let align = most_aligned.align;\n+            let (size, align) = union_size_and_align(sts.as_slice());\n+            let align_s = align as u64;\n             let discr_ty = ll_inttype(cx, ity);\n-            let discr_size = machine::llsize_of_alloc(cx, discr_ty) as u64;\n-            let align_units = (size + align - 1) / align - 1;\n-            let pad_ty = match align {\n+            let discr_size = machine::llsize_of_alloc(cx, discr_ty);\n+            let align_units = (size + align_s - 1) / align_s - 1;\n+            let pad_ty = match align_s {\n                 1 => Type::array(&Type::i8(cx), align_units),\n                 2 => Type::array(&Type::i16(cx), align_units),\n                 4 => Type::array(&Type::i32(cx), align_units),\n@@ -541,10 +587,10 @@ fn generic_type_of(cx: &CrateContext,\n                                                               align_units),\n                 _ => fail!(\"unsupported enum alignment: {}\", align)\n             };\n-            assert_eq!(machine::llalign_of_min(cx, pad_ty) as u64, align);\n-            assert_eq!(align % discr_size, 0);\n+            assert_eq!(machine::llalign_of_min(cx, pad_ty), align);\n+            assert_eq!(align_s % discr_size, 0);\n             let fields = vec!(discr_ty,\n-                           Type::array(&discr_ty, align / discr_size - 1),\n+                           Type::array(&discr_ty, align_s / discr_size - 1),\n                            pad_ty);\n             match name {\n                 None => Type::struct_(cx, fields.as_slice(), false),\n@@ -653,9 +699,7 @@ fn load_discr(bcx: Block, ity: IntType, ptr: ValueRef, min: Disr, max: Disr)\n     } else {\n         // llvm::ConstantRange can deal with ranges that wrap around,\n         // so an overflow on (max + 1) is fine.\n-        LoadRangeAssert(bcx, ptr, min as c_ulonglong,\n-                        (max + 1) as c_ulonglong,\n-                        /* signed: */ True)\n+        LoadRangeAssert(bcx, ptr, min, (max+1), /* signed: */ True)\n     }\n }\n \n@@ -974,11 +1018,11 @@ fn compute_struct_field_offsets(ccx: &CrateContext, st: &Struct) -> Vec<u64> {\n     for &ty in st.fields.iter() {\n         let llty = type_of::sizing_type_of(ccx, ty);\n         if !st.packed {\n-            let type_align = type_of::align_of(ccx, ty) as u64;\n+            let type_align = type_of::align_of(ccx, ty);\n             offset = roundup(offset, type_align);\n         }\n         offsets.push(offset);\n-        offset += machine::llsize_of_alloc(ccx, llty) as u64;\n+        offset += machine::llsize_of_alloc(ccx, llty);\n     }\n     assert_eq!(st.fields.len(), offsets.len());\n     offsets\n@@ -1005,8 +1049,7 @@ fn build_const_struct(ccx: &CrateContext, st: &Struct, vals: &[ValueRef])\n     let mut cfields = Vec::new();\n     for (&val, &target_offset) in vals.iter().zip(target_offsets.iter()) {\n         if !st.packed {\n-            let val_align = machine::llalign_of_min(ccx, val_ty(val))\n-                /*bad*/as u64;\n+            let val_align = machine::llalign_of_min(ccx, val_ty(val));\n             offset = roundup(offset, val_align);\n         }\n         if offset != target_offset {\n@@ -1015,7 +1058,7 @@ fn build_const_struct(ccx: &CrateContext, st: &Struct, vals: &[ValueRef])\n         }\n         assert!(!is_undef(val));\n         cfields.push(val);\n-        offset += machine::llsize_of_alloc(ccx, val_ty(val)) as u64;\n+        offset += machine::llsize_of_alloc(ccx, val_ty(val));\n     }\n \n     assert!(st.sized && offset <= st.size);\n@@ -1032,7 +1075,7 @@ fn padding(ccx: &CrateContext, size: u64) -> ValueRef {\n \n // FIXME this utility routine should be somewhere more general\n #[inline]\n-fn roundup(x: u64, a: u64) -> u64 { ((x + (a - 1)) / a) * a }\n+fn roundup(x: u64, a: u32) -> u64 { let a = a as u64; ((x + (a - 1)) / a) * a }\n \n /// Get the discriminant of a constant value.  (Not currently used.)\n pub fn const_get_discrim(ccx: &CrateContext, r: &Repr, val: ValueRef)"}, {"sha": "2a3ccc26e5baa710a948c90feb16a368329fc66d", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ce342f522c10eef8799f2b91b7f39947d40f93ce/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce342f522c10eef8799f2b91b7f39947d40f93ce/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=ce342f522c10eef8799f2b91b7f39947d40f93ce", "patch": "@@ -398,7 +398,7 @@ pub fn malloc_raw_dyn_proc<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, t: ty::t) -> Resu\n \n     let llty = type_of(bcx.ccx(), t);\n     let size = llsize_of(bcx.ccx(), llty);\n-    let llalign = C_uint(ccx, llalign_of_min(bcx.ccx(), llty) as uint);\n+    let llalign = C_uint(ccx, llalign_of_min(bcx.ccx(), llty));\n \n     // Allocate space and store the destructor pointer:\n     let Result {bcx: bcx, val: llbox} = malloc_raw_dyn(bcx, ptr_llty, t, size, llalign);"}, {"sha": "025b5f368ecae3bdbd0c5cc3b67cd74a5cf62032", "filename": "src/librustc/middle/trans/build.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ce342f522c10eef8799f2b91b7f39947d40f93ce/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce342f522c10eef8799f2b91b7f39947d40f93ce/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs?ref=ce342f522c10eef8799f2b91b7f39947d40f93ce", "patch": "@@ -21,7 +21,7 @@ use syntax::codemap::Span;\n use middle::trans::builder::Builder;\n use middle::trans::type_::Type;\n \n-use libc::{c_uint, c_ulonglong, c_char};\n+use libc::{c_uint, c_char};\n \n pub fn terminate(cx: Block, _: &str) {\n     debug!(\"terminate({})\", cx.to_str());\n@@ -380,8 +380,8 @@ pub fn AtomicLoad(cx: Block, pointer_val: ValueRef, order: AtomicOrdering) -> Va\n }\n \n \n-pub fn LoadRangeAssert(cx: Block, pointer_val: ValueRef, lo: c_ulonglong,\n-                       hi: c_ulonglong, signed: llvm::Bool) -> ValueRef {\n+pub fn LoadRangeAssert(cx: Block, pointer_val: ValueRef, lo: u64,\n+                       hi: u64, signed: llvm::Bool) -> ValueRef {\n     if cx.unreachable.get() {\n         let ccx = cx.fcx.ccx;\n         let ty = val_ty(pointer_val);"}, {"sha": "0c0dee4c3f75d91e12adedc7847e3085791eefce", "filename": "src/librustc/middle/trans/builder.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ce342f522c10eef8799f2b91b7f39947d40f93ce/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce342f522c10eef8799f2b91b7f39947d40f93ce/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs?ref=ce342f522c10eef8799f2b91b7f39947d40f93ce", "patch": "@@ -19,7 +19,7 @@ use middle::trans::common::*;\n use middle::trans::machine::llalign_of_pref;\n use middle::trans::type_::Type;\n use std::collections::HashMap;\n-use libc::{c_uint, c_ulonglong, c_char};\n+use libc::{c_uint, c_char};\n use std::string::String;\n use syntax::codemap::Span;\n \n@@ -477,8 +477,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     }\n \n \n-    pub fn load_range_assert(&self, ptr: ValueRef, lo: c_ulonglong,\n-                           hi: c_ulonglong, signed: llvm::Bool) -> ValueRef {\n+    pub fn load_range_assert(&self, ptr: ValueRef, lo: u64,\n+                             hi: u64, signed: llvm::Bool) -> ValueRef {\n         let value = self.load(ptr);\n \n         unsafe {\n@@ -490,7 +490,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n             llvm::LLVMSetMetadata(value, llvm::MD_range as c_uint,\n                                   llvm::LLVMMDNodeInContext(self.ccx.llcx(),\n-                                                            v.as_ptr(), v.len() as c_uint));\n+                                                            v.as_ptr(),\n+                                                            v.len() as c_uint));\n         }\n \n         value"}, {"sha": "810a6f2e8d4396a79090caacda8e935a5608a47d", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 37, "deletions": 7, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/ce342f522c10eef8799f2b91b7f39947d40f93ce/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce342f522c10eef8799f2b91b7f39947d40f93ce/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=ce342f522c10eef8799f2b91b7f39947d40f93ce", "patch": "@@ -26,6 +26,7 @@ use middle::trans::build;\n use middle::trans::cleanup;\n use middle::trans::datum;\n use middle::trans::debuginfo;\n+use middle::trans::machine;\n use middle::trans::type_::Type;\n use middle::trans::type_of;\n use middle::traits;\n@@ -39,7 +40,7 @@ use util::nodemap::{DefIdMap, NodeMap};\n \n use arena::TypedArena;\n use std::collections::HashMap;\n-use libc::{c_uint, c_longlong, c_ulonglong, c_char};\n+use libc::{c_uint, c_char};\n use std::c_str::ToCStr;\n use std::cell::{Cell, RefCell};\n use std::rc::Rc;\n@@ -594,14 +595,43 @@ pub fn C_u64(ccx: &CrateContext, i: u64) -> ValueRef {\n     C_integral(Type::i64(ccx), i, false)\n }\n \n-pub fn C_int(ccx: &CrateContext, i: int) -> ValueRef {\n-    C_integral(ccx.int_type(), i as u64, true)\n+pub fn C_int<I: AsI64>(ccx: &CrateContext, i: I) -> ValueRef {\n+    let v = i.as_i64();\n+\n+    match machine::llbitsize_of_real(ccx, ccx.int_type()) {\n+        32 => assert!(v < (1<<31) && v >= -(1<<31)),\n+        64 => {},\n+        n => fail!(\"unsupported target size: {}\", n)\n+    }\n+\n+    C_integral(ccx.int_type(), v as u64, true)\n }\n \n-pub fn C_uint(ccx: &CrateContext, i: uint) -> ValueRef {\n-    C_integral(ccx.int_type(), i as u64, false)\n+pub fn C_uint<I: AsU64>(ccx: &CrateContext, i: I) -> ValueRef {\n+    let v = i.as_u64();\n+\n+    match machine::llbitsize_of_real(ccx, ccx.int_type()) {\n+        32 => assert!(v < (1<<32)),\n+        64 => {},\n+        n => fail!(\"unsupported target size: {}\", n)\n+    }\n+\n+    C_integral(ccx.int_type(), v, false)\n }\n \n+pub trait AsI64 { fn as_i64(self) -> i64; }\n+pub trait AsU64 { fn as_u64(self) -> u64; }\n+\n+// FIXME: remove the intptr conversions, because they\n+// are host-architecture-dependent\n+impl AsI64 for i64 { fn as_i64(self) -> i64 { self as i64 }}\n+impl AsI64 for i32 { fn as_i64(self) -> i64 { self as i64 }}\n+impl AsI64 for int { fn as_i64(self) -> i64 { self as i64 }}\n+\n+impl AsU64 for u64  { fn as_u64(self) -> u64 { self as u64 }}\n+impl AsU64 for u32  { fn as_u64(self) -> u64 { self as u64 }}\n+impl AsU64 for uint { fn as_u64(self) -> u64 { self as u64 }}\n+\n pub fn C_u8(ccx: &CrateContext, i: uint) -> ValueRef {\n     C_integral(Type::i8(ccx), i as u64, false)\n }\n@@ -716,13 +746,13 @@ pub fn is_const(v: ValueRef) -> bool {\n     }\n }\n \n-pub fn const_to_int(v: ValueRef) -> c_longlong {\n+pub fn const_to_int(v: ValueRef) -> i64 {\n     unsafe {\n         llvm::LLVMConstIntGetSExtValue(v)\n     }\n }\n \n-pub fn const_to_uint(v: ValueRef) -> c_ulonglong {\n+pub fn const_to_uint(v: ValueRef) -> u64 {\n     unsafe {\n         llvm::LLVMConstIntGetZExtValue(v)\n     }"}, {"sha": "683e1b30c8ca21dd6b2cb69952c3d3e2a74f66d0", "filename": "src/librustc/middle/trans/context.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ce342f522c10eef8799f2b91b7f39947d40f93ce/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce342f522c10eef8799f2b91b7f39947d40f93ce/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs?ref=ce342f522c10eef8799f2b91b7f39947d40f93ce", "patch": "@@ -25,6 +25,7 @@ use middle::trans::debuginfo;\n use middle::trans::monomorphize::MonoId;\n use middle::trans::type_::{Type, TypeNames};\n use middle::ty;\n+use util::ppaux::Repr;\n use util::sha2::Sha256;\n use util::nodemap::{NodeMap, NodeSet, DefIdMap};\n \n@@ -711,6 +712,16 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n     pub fn trait_cache(&self) -> &RefCell<HashMap<Rc<ty::TraitRef>, traits::Vtable<()>>> {\n         &self.local.trait_cache\n     }\n+\n+    pub fn max_obj_size(&self) -> u64 {\n+        1<<31 /* FIXME #18069: select based on architecture */\n+    }\n+\n+    pub fn report_overbig_object(&self, obj: ty::t) -> ! {\n+        self.sess().fatal(\n+            format!(\"the type `{}` is too big for the current architecture\",\n+                    obj.repr(self.tcx())).as_slice())\n+    }\n }\n \n fn declare_intrinsic(ccx: &CrateContext, key: & &'static str) -> Option<ValueRef> {"}, {"sha": "17d213b491152de2179efa237e4325b32b8cc737", "filename": "src/librustc/middle/trans/controlflow.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ce342f522c10eef8799f2b91b7f39947d40f93ce/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce342f522c10eef8799f2b91b7f39947d40f93ce/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs?ref=ce342f522c10eef8799f2b91b7f39947d40f93ce", "patch": "@@ -499,7 +499,7 @@ pub fn trans_fail<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let loc = bcx.sess().codemap().lookup_char_pos(sp.lo);\n     let filename = token::intern_and_get_ident(loc.file.name.as_slice());\n     let filename = C_str_slice(ccx, filename);\n-    let line = C_int(ccx, loc.line as int);\n+    let line = C_uint(ccx, loc.line);\n     let expr_file_line_const = C_struct(ccx, &[v_str, filename, line], false);\n     let expr_file_line = consts::const_addr_of(ccx, expr_file_line_const, ast::MutImmutable);\n     let args = vec!(expr_file_line);\n@@ -526,7 +526,7 @@ pub fn trans_fail_bounds_check<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     // Invoke the lang item\n     let filename = C_str_slice(ccx,  filename);\n-    let line = C_int(ccx, loc.line as int);\n+    let line = C_uint(ccx, loc.line);\n     let file_line_const = C_struct(ccx, &[filename, line], false);\n     let file_line = consts::const_addr_of(ccx, file_line_const, ast::MutImmutable);\n     let args = vec!(file_line, index, len);"}, {"sha": "7a187b2112bee607019cf6bbb3e073aa0c54c0e7", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ce342f522c10eef8799f2b91b7f39947d40f93ce/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce342f522c10eef8799f2b91b7f39947d40f93ce/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=ce342f522c10eef8799f2b91b7f39947d40f93ce", "patch": "@@ -202,7 +202,7 @@ use middle::ty;\n use middle::pat_util;\n use util::ppaux;\n \n-use libc::{c_uint, c_ulonglong, c_longlong};\n+use libc::c_uint;\n use std::c_str::{CString, ToCStr};\n use std::cell::{Cell, RefCell};\n use std::collections::HashMap;\n@@ -2384,7 +2384,7 @@ fn prepare_enum_metadata(cx: &CrateContext,\n                     llvm::LLVMDIBuilderCreateEnumerator(\n                         DIB(cx),\n                         name,\n-                        v.disr_val as c_ulonglong)\n+                        v.disr_val as u64)\n                 }\n             })\n         })\n@@ -2663,9 +2663,9 @@ fn fixed_vec_metadata(cx: &CrateContext,\n \n     let subrange = unsafe {\n         llvm::LLVMDIBuilderGetOrCreateSubrange(\n-        DIB(cx),\n-        0,\n-        len as c_longlong)\n+            DIB(cx),\n+            0,\n+            len as i64)\n     };\n \n     let subscripts = create_DIArray(DIB(cx), [subrange]);\n@@ -3072,11 +3072,11 @@ fn span_start(cx: &CrateContext, span: Span) -> codemap::Loc {\n }\n \n fn size_and_align_of(cx: &CrateContext, llvm_type: Type) -> (u64, u64) {\n-    (machine::llsize_of_alloc(cx, llvm_type), machine::llalign_of_min(cx, llvm_type))\n+    (machine::llsize_of_alloc(cx, llvm_type), machine::llalign_of_min(cx, llvm_type) as u64)\n }\n \n-fn bytes_to_bits(bytes: u64) -> c_ulonglong {\n-    (bytes * 8) as c_ulonglong\n+fn bytes_to_bits(bytes: u64) -> u64 {\n+    bytes * 8\n }\n \n #[inline]"}, {"sha": "aa00de85890c68aab35e12f610e629ad786cd680", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ce342f522c10eef8799f2b91b7f39947d40f93ce/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce342f522c10eef8799f2b91b7f39947d40f93ce/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=ce342f522c10eef8799f2b91b7f39947d40f93ce", "patch": "@@ -1548,7 +1548,7 @@ fn trans_uniq_expr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     assert!(ty::type_is_sized(bcx.tcx(), contents_ty));\n     let llty = type_of::type_of(bcx.ccx(), contents_ty);\n     let size = llsize_of(bcx.ccx(), llty);\n-    let align = C_uint(bcx.ccx(), type_of::align_of(bcx.ccx(), contents_ty) as uint);\n+    let align = C_uint(bcx.ccx(), type_of::align_of(bcx.ccx(), contents_ty));\n     let llty_ptr = llty.ptr_to();\n     let Result { bcx, val } = malloc_raw_dyn(bcx, llty_ptr, box_ty, size, align);\n     // Unique boxes do not allocate for zero-size types. The standard library"}, {"sha": "f6373ecc04c81fb1890588997d945b63398c8f0d", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ce342f522c10eef8799f2b91b7f39947d40f93ce/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce342f522c10eef8799f2b91b7f39947d40f93ce/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=ce342f522c10eef8799f2b91b7f39947d40f93ce", "patch": "@@ -476,7 +476,7 @@ pub fn trans_native_call<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             let llalign = cmp::min(llforeign_align, llrust_align);\n             debug!(\"llrust_size={}\", llrust_size);\n             base::call_memcpy(bcx, llretptr_i8, llscratch_i8,\n-                              C_uint(ccx, llrust_size as uint), llalign as u32);\n+                              C_uint(ccx, llrust_size), llalign as u32);\n         }\n     }\n "}, {"sha": "5ed619ad295e02f271b144f1d01d9157b57ac18e", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ce342f522c10eef8799f2b91b7f39947d40f93ce/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce342f522c10eef8799f2b91b7f39947d40f93ce/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=ce342f522c10eef8799f2b91b7f39947d40f93ce", "patch": "@@ -56,9 +56,9 @@ pub fn trans_exchange_free_dyn<'blk, 'tcx>(cx: Block<'blk, 'tcx>, v: ValueRef,\n }\n \n pub fn trans_exchange_free<'blk, 'tcx>(cx: Block<'blk, 'tcx>, v: ValueRef,\n-                                       size: u64, align: u64) -> Block<'blk, 'tcx> {\n-    trans_exchange_free_dyn(cx, v, C_uint(cx.ccx(), size as uint),\n-                            C_uint(cx.ccx(), align as uint))\n+                                       size: u64, align: u32) -> Block<'blk, 'tcx> {\n+    trans_exchange_free_dyn(cx, v, C_uint(cx.ccx(), size),\n+                                   C_uint(cx.ccx(), align))\n }\n \n pub fn trans_exchange_free_ty<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, ptr: ValueRef,\n@@ -301,8 +301,8 @@ fn size_and_align_of_dst(bcx: Block, t :ty::t, info: ValueRef) -> (ValueRef, Val\n            bcx.ty_to_string(t), bcx.val_to_string(info));\n     if ty::type_is_sized(bcx.tcx(), t) {\n         let sizing_type = sizing_type_of(bcx.ccx(), t);\n-        let size = C_uint(bcx.ccx(), llsize_of_alloc(bcx.ccx(), sizing_type) as uint);\n-        let align = C_uint(bcx.ccx(), align_of(bcx.ccx(), t) as uint);\n+        let size = C_uint(bcx.ccx(), llsize_of_alloc(bcx.ccx(), sizing_type));\n+        let align = C_uint(bcx.ccx(), align_of(bcx.ccx(), t));\n         return (size, align);\n     }\n     match ty::get(t).sty {\n@@ -313,8 +313,8 @@ fn size_and_align_of_dst(bcx: Block, t :ty::t, info: ValueRef) -> (ValueRef, Val\n             assert!(!ty::type_is_simd(bcx.tcx(), t));\n             let repr = adt::represent_type(ccx, t);\n             let sizing_type = adt::sizing_type_of(ccx, &*repr, true);\n-            let sized_size = C_uint(ccx, llsize_of_alloc(ccx, sizing_type) as uint);\n-            let sized_align = C_uint(ccx, llalign_of_min(ccx, sizing_type) as uint);\n+            let sized_size = C_uint(ccx, llsize_of_alloc(ccx, sizing_type));\n+            let sized_align = C_uint(ccx, llalign_of_min(ccx, sizing_type));\n \n             // Recurse to get the size of the dynamically sized field (must be\n             // the last field).\n@@ -344,7 +344,7 @@ fn size_and_align_of_dst(bcx: Block, t :ty::t, info: ValueRef) -> (ValueRef, Val\n             // times the unit size.\n             let llunit_ty = sizing_type_of(bcx.ccx(), unit_ty);\n             let unit_size = llsize_of_alloc(bcx.ccx(), llunit_ty);\n-            (Mul(bcx, info, C_uint(bcx.ccx(), unit_size as uint)), C_uint(bcx.ccx(), 8))\n+            (Mul(bcx, info, C_uint(bcx.ccx(), unit_size)), C_uint(bcx.ccx(), 8u))\n         }\n         _ => bcx.sess().bug(format!(\"Unexpected unsized type, found {}\",\n                                     bcx.ty_to_string(t)).as_slice())"}, {"sha": "1dbacf98e530655d7668271eb0f4504abe883250", "filename": "src/librustc/middle/trans/intrinsic.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ce342f522c10eef8799f2b91b7f39947d40f93ce/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce342f522c10eef8799f2b91b7f39947d40f93ce/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs?ref=ce342f522c10eef8799f2b91b7f39947d40f93ce", "patch": "@@ -239,16 +239,16 @@ pub fn trans_intrinsic_call<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>, node: ast::N\n         (_, \"size_of\") => {\n             let tp_ty = *substs.types.get(FnSpace, 0);\n             let lltp_ty = type_of::type_of(ccx, tp_ty);\n-            C_uint(ccx, machine::llsize_of_real(ccx, lltp_ty) as uint)\n+            C_uint(ccx, machine::llsize_of_real(ccx, lltp_ty))\n         }\n         (_, \"min_align_of\") => {\n             let tp_ty = *substs.types.get(FnSpace, 0);\n-            C_uint(ccx, type_of::align_of(ccx, tp_ty) as uint)\n+            C_uint(ccx, type_of::align_of(ccx, tp_ty))\n         }\n         (_, \"pref_align_of\") => {\n             let tp_ty = *substs.types.get(FnSpace, 0);\n             let lltp_ty = type_of::type_of(ccx, tp_ty);\n-            C_uint(ccx, machine::llalign_of_pref(ccx, lltp_ty) as uint)\n+            C_uint(ccx, machine::llalign_of_pref(ccx, lltp_ty))\n         }\n         (_, \"move_val_init\") => {\n             // Create a datum reflecting the value being moved."}, {"sha": "f576dcc60c01a4217b5ab6abc623124bffb4d84c", "filename": "src/librustc/middle/trans/machine.rs", "status": "modified", "additions": 21, "deletions": 14, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/ce342f522c10eef8799f2b91b7f39947d40f93ce/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce342f522c10eef8799f2b91b7f39947d40f93ce/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmachine.rs?ref=ce342f522c10eef8799f2b91b7f39947d40f93ce", "patch": "@@ -10,28 +10,34 @@\n \n // Information concerning the machine representation of various types.\n \n+#![allow(non_camel_case_types)]\n+\n use llvm;\n use llvm::{ValueRef};\n use llvm::False;\n use middle::trans::common::*;\n \n use middle::trans::type_::Type;\n \n+pub type llbits = u64;\n+pub type llsize = u64;\n+pub type llalign = u32;\n+\n // ______________________________________________________________________\n // compute sizeof / alignof\n \n // Returns the number of bytes clobbered by a Store to this type.\n-pub fn llsize_of_store(cx: &CrateContext, ty: Type) -> u64 {\n+pub fn llsize_of_store(cx: &CrateContext, ty: Type) -> llsize {\n     unsafe {\n-        return llvm::LLVMStoreSizeOfType(cx.td().lltd, ty.to_ref()) as u64;\n+        return llvm::LLVMStoreSizeOfType(cx.td().lltd, ty.to_ref());\n     }\n }\n \n // Returns the number of bytes between successive elements of type T in an\n // array of T. This is the \"ABI\" size. It includes any ABI-mandated padding.\n-pub fn llsize_of_alloc(cx: &CrateContext, ty: Type) -> u64 {\n+pub fn llsize_of_alloc(cx: &CrateContext, ty: Type) -> llsize {\n     unsafe {\n-        return llvm::LLVMABISizeOfType(cx.td().lltd, ty.to_ref()) as u64;\n+        return llvm::LLVMABISizeOfType(cx.td().lltd, ty.to_ref());\n     }\n }\n \n@@ -43,9 +49,9 @@ pub fn llsize_of_alloc(cx: &CrateContext, ty: Type) -> u64 {\n // that LLVM *does* distinguish between e.g. a 1-bit value and an 8-bit value\n // at the codegen level! In general you should prefer `llbitsize_of_real`\n // below.\n-pub fn llsize_of_real(cx: &CrateContext, ty: Type) -> u64 {\n+pub fn llsize_of_real(cx: &CrateContext, ty: Type) -> llsize {\n     unsafe {\n-        let nbits = llvm::LLVMSizeOfTypeInBits(cx.td().lltd, ty.to_ref()) as u64;\n+        let nbits = llvm::LLVMSizeOfTypeInBits(cx.td().lltd, ty.to_ref());\n         if nbits & 7 != 0 {\n             // Not an even number of bytes, spills into \"next\" byte.\n             1 + (nbits >> 3)\n@@ -56,9 +62,9 @@ pub fn llsize_of_real(cx: &CrateContext, ty: Type) -> u64 {\n }\n \n /// Returns the \"real\" size of the type in bits.\n-pub fn llbitsize_of_real(cx: &CrateContext, ty: Type) -> u64 {\n+pub fn llbitsize_of_real(cx: &CrateContext, ty: Type) -> llbits {\n     unsafe {\n-        llvm::LLVMSizeOfTypeInBits(cx.td().lltd, ty.to_ref()) as u64\n+        llvm::LLVMSizeOfTypeInBits(cx.td().lltd, ty.to_ref())\n     }\n }\n \n@@ -71,7 +77,7 @@ pub fn llsize_of(cx: &CrateContext, ty: Type) -> ValueRef {\n     // there's no need for that contrivance.  The instruction\n     // selection DAG generator would flatten that GEP(1) node into a\n     // constant of the type's alloc size, so let's save it some work.\n-    return C_uint(cx, llsize_of_alloc(cx, ty) as uint);\n+    return C_uint(cx, llsize_of_alloc(cx, ty));\n }\n \n // Returns the \"default\" size of t (see above), or 1 if the size would\n@@ -89,18 +95,18 @@ pub fn nonzero_llsize_of(cx: &CrateContext, ty: Type) -> ValueRef {\n // The preferred alignment may be larger than the alignment used when\n // packing the type into structs. This will be used for things like\n // allocations inside a stack frame, which LLVM has a free hand in.\n-pub fn llalign_of_pref(cx: &CrateContext, ty: Type) -> u64 {\n+pub fn llalign_of_pref(cx: &CrateContext, ty: Type) -> llalign {\n     unsafe {\n-        return llvm::LLVMPreferredAlignmentOfType(cx.td().lltd, ty.to_ref()) as u64;\n+        return llvm::LLVMPreferredAlignmentOfType(cx.td().lltd, ty.to_ref());\n     }\n }\n \n // Returns the minimum alignment of a type required by the platform.\n // This is the alignment that will be used for struct fields, arrays,\n // and similar ABI-mandated things.\n-pub fn llalign_of_min(cx: &CrateContext, ty: Type) -> u64 {\n+pub fn llalign_of_min(cx: &CrateContext, ty: Type) -> llalign {\n     unsafe {\n-        return llvm::LLVMABIAlignmentOfType(cx.td().lltd, ty.to_ref()) as u64;\n+        return llvm::LLVMABIAlignmentOfType(cx.td().lltd, ty.to_ref());\n     }\n }\n \n@@ -116,6 +122,7 @@ pub fn llalign_of(cx: &CrateContext, ty: Type) -> ValueRef {\n \n pub fn llelement_offset(cx: &CrateContext, struct_ty: Type, element: uint) -> u64 {\n     unsafe {\n-        return llvm::LLVMOffsetOfElement(cx.td().lltd, struct_ty.to_ref(), element as u32) as u64;\n+        return llvm::LLVMOffsetOfElement(cx.td().lltd, struct_ty.to_ref(),\n+                                         element as u32);\n     }\n }"}, {"sha": "b0ce5a214649ece794470941b416c974a8e3b0f7", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ce342f522c10eef8799f2b91b7f39947d40f93ce/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce342f522c10eef8799f2b91b7f39947d40f93ce/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=ce342f522c10eef8799f2b91b7f39947d40f93ce", "patch": "@@ -648,9 +648,9 @@ pub fn get_vtable(bcx: Block,\n \n     let size_ty = sizing_type_of(ccx, trait_ref.self_ty());\n     let size = machine::llsize_of_alloc(ccx, size_ty);\n-    let ll_size = C_uint(ccx, size as uint);\n+    let ll_size = C_uint(ccx, size);\n     let align = align_of(ccx, trait_ref.self_ty());\n-    let ll_align = C_uint(ccx, align as uint);\n+    let ll_align = C_uint(ccx, align);\n \n     // Generate a destructor for the vtable.\n     let drop_glue = glue::get_drop_glue(ccx, box_ty);"}, {"sha": "0dcc69a6686567ed96ae6a3033e8c5a8294f11bb", "filename": "src/librustc/middle/trans/tvec.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ce342f522c10eef8799f2b91b7f39947d40f93ce/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce342f522c10eef8799f2b91b7f39947d40f93ce/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=ce342f522c10eef8799f2b91b7f39947d40f93ce", "patch": "@@ -74,10 +74,10 @@ pub fn make_drop_glue_unboxed<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             let unit_size = llsize_of_alloc(ccx, llty);\n             if unit_size != 0 {\n                 let len = get_len(bcx, vptr);\n-                let not_empty = ICmp(bcx, llvm::IntNE, len, C_uint(ccx, 0));\n+                let not_empty = ICmp(bcx, llvm::IntNE, len, C_uint(ccx, 0u));\n                 with_cond(bcx, not_empty, |bcx| {\n-                    let llalign = C_uint(ccx, machine::llalign_of_min(ccx, llty) as uint);\n-                    let size = Mul(bcx, C_uint(ccx, unit_size as uint), len);\n+                    let llalign = C_uint(ccx, machine::llalign_of_min(ccx, llty));\n+                    let size = Mul(bcx, C_uint(ccx, unit_size), len);\n                     glue::trans_exchange_free_dyn(bcx, dataptr, size, llalign)\n                 })\n             } else {\n@@ -461,7 +461,7 @@ pub fn iter_vec_loop<'a, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let loop_counter = {\n         // i = 0\n         let i = alloca(loop_bcx, bcx.ccx().int_type(), \"__i\");\n-        Store(loop_bcx, C_uint(bcx.ccx(), 0), i);\n+        Store(loop_bcx, C_uint(bcx.ccx(), 0u), i);\n \n         Br(loop_bcx, cond_bcx.llbb);\n         i\n@@ -489,7 +489,7 @@ pub fn iter_vec_loop<'a, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     { // i += 1\n         let i = Load(inc_bcx, loop_counter);\n-        let plusone = Add(inc_bcx, i, C_uint(bcx.ccx(), 1));\n+        let plusone = Add(inc_bcx, i, C_uint(bcx.ccx(), 1u));\n         Store(inc_bcx, plusone, loop_counter);\n \n         Br(inc_bcx, cond_bcx.llbb);\n@@ -532,7 +532,7 @@ pub fn iter_vec_raw<'a, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         CondBr(header_bcx, not_yet_at_end, body_bcx.llbb, next_bcx.llbb);\n         let body_bcx = f(body_bcx, data_ptr, vt.unit_ty);\n         AddIncomingToPhi(data_ptr, InBoundsGEP(body_bcx, data_ptr,\n-                                               [C_int(bcx.ccx(), 1)]),\n+                                               [C_int(bcx.ccx(), 1i)]),\n                          body_bcx.llbb);\n         Br(body_bcx, header_bcx.llbb);\n         next_bcx"}, {"sha": "b5f2ef419a0f784bc7ef143fd6f038e9d64d0003", "filename": "src/librustc/middle/trans/type_of.rs", "status": "modified", "additions": 45, "deletions": 23, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/ce342f522c10eef8799f2b91b7f39947d40f93ce/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce342f522c10eef8799f2b91b7f39947d40f93ce/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=ce342f522c10eef8799f2b91b7f39947d40f93ce", "patch": "@@ -24,6 +24,20 @@ use middle::trans::type_::Type;\n use syntax::abi;\n use syntax::ast;\n \n+use std::num::CheckedMul;\n+\n+// LLVM doesn't like objects that are too big. Issue #17913\n+fn ensure_array_fits_in_address_space(ccx: &CrateContext,\n+                                      llet: Type,\n+                                      size: machine::llsize,\n+                                      scapegoat: ty::t) {\n+    let esz = machine::llsize_of_alloc(ccx, llet);\n+    match esz.checked_mul(&size) {\n+        Some(n) if n < ccx.max_obj_size() => {}\n+        _ => { ccx.report_overbig_object(scapegoat) }\n+    }\n+}\n+\n pub fn arg_is_indirect(ccx: &CrateContext, arg_ty: ty::t) -> bool {\n     !type_is_immediate(ccx, arg_ty)\n }\n@@ -186,7 +200,10 @@ pub fn sizing_type_of(cx: &CrateContext, t: ty::t) -> Type {\n         ty::ty_closure(..) => Type::struct_(cx, [Type::i8p(cx), Type::i8p(cx)], false),\n \n         ty::ty_vec(ty, Some(size)) => {\n-            Type::array(&sizing_type_of(cx, ty), size as u64)\n+            let llty = sizing_type_of(cx, ty);\n+            let size = size as u64;\n+            ensure_array_fits_in_address_space(cx, llty, size, t);\n+            Type::array(&llty, size)\n         }\n \n         ty::ty_tup(..) | ty::ty_enum(..) | ty::ty_unboxed_closure(..) => {\n@@ -196,9 +213,10 @@ pub fn sizing_type_of(cx: &CrateContext, t: ty::t) -> Type {\n \n         ty::ty_struct(..) => {\n             if ty::type_is_simd(cx.tcx(), t) {\n-                let et = ty::simd_type(cx.tcx(), t);\n-                let n = ty::simd_size(cx.tcx(), t);\n-                Type::vector(&type_of(cx, et), n as u64)\n+                let llet = type_of(cx, ty::simd_type(cx.tcx(), t));\n+                let n = ty::simd_size(cx.tcx(), t) as u64;\n+                ensure_array_fits_in_address_space(cx, llet, n, t);\n+                Type::vector(&llet, n)\n             } else {\n                 let repr = adt::represent_type(cx, t);\n                 adt::sizing_type_of(cx, &*repr, false)\n@@ -282,21 +300,21 @@ pub fn type_of(cx: &CrateContext, t: ty::t) -> Type {\n       ty::ty_uint(t) => Type::uint_from_ty(cx, t),\n       ty::ty_float(t) => Type::float_from_ty(cx, t),\n       ty::ty_enum(did, ref substs) => {\n-        // Only create the named struct, but don't fill it in. We\n-        // fill it in *after* placing it into the type cache. This\n-        // avoids creating more than one copy of the enum when one\n-        // of the enum's variants refers to the enum itself.\n-        let repr = adt::represent_type(cx, t);\n-        let tps = substs.types.get_slice(subst::TypeSpace);\n-        let name = llvm_type_name(cx, an_enum, did, tps);\n-        adt::incomplete_type_of(cx, &*repr, name.as_slice())\n+          // Only create the named struct, but don't fill it in. We\n+          // fill it in *after* placing it into the type cache. This\n+          // avoids creating more than one copy of the enum when one\n+          // of the enum's variants refers to the enum itself.\n+          let repr = adt::represent_type(cx, t);\n+          let tps = substs.types.get_slice(subst::TypeSpace);\n+          let name = llvm_type_name(cx, an_enum, did, tps);\n+          adt::incomplete_type_of(cx, &*repr, name.as_slice())\n       }\n       ty::ty_unboxed_closure(did, _) => {\n-        // Only create the named struct, but don't fill it in. We\n-        // fill it in *after* placing it into the type cache.\n-        let repr = adt::represent_type(cx, t);\n-        let name = llvm_type_name(cx, an_unboxed_closure, did, []);\n-        adt::incomplete_type_of(cx, &*repr, name.as_slice())\n+          // Only create the named struct, but don't fill it in. We\n+          // fill it in *after* placing it into the type cache.\n+          let repr = adt::represent_type(cx, t);\n+          let name = llvm_type_name(cx, an_unboxed_closure, did, []);\n+          adt::incomplete_type_of(cx, &*repr, name.as_slice())\n       }\n \n       ty::ty_uniq(ty) | ty::ty_rptr(_, ty::mt{ty, ..}) | ty::ty_ptr(ty::mt{ty, ..}) => {\n@@ -315,8 +333,11 @@ pub fn type_of(cx: &CrateContext, t: ty::t) -> Type {\n           }\n       }\n \n-      ty::ty_vec(ty, Some(n)) => {\n-          Type::array(&type_of(cx, ty), n as u64)\n+      ty::ty_vec(ty, Some(size)) => {\n+          let size = size as u64;\n+          let llty = type_of(cx, ty);\n+          ensure_array_fits_in_address_space(cx, llty, size, t);\n+          Type::array(&llty, size)\n       }\n       ty::ty_vec(ty, None) => {\n           type_of(cx, ty)\n@@ -341,9 +362,10 @@ pub fn type_of(cx: &CrateContext, t: ty::t) -> Type {\n       }\n       ty::ty_struct(did, ref substs) => {\n           if ty::type_is_simd(cx.tcx(), t) {\n-              let et = ty::simd_type(cx.tcx(), t);\n-              let n = ty::simd_size(cx.tcx(), t);\n-              Type::vector(&type_of(cx, et), n as u64)\n+              let llet = type_of(cx, ty::simd_type(cx.tcx(), t));\n+              let n = ty::simd_size(cx.tcx(), t) as u64;\n+              ensure_array_fits_in_address_space(cx, llet, n, t);\n+              Type::vector(&llet, n)\n           } else {\n               // Only create the named struct, but don't fill it in. We fill it\n               // in *after* placing it into the type cache. This prevents\n@@ -398,7 +420,7 @@ pub fn type_of(cx: &CrateContext, t: ty::t) -> Type {\n     return llty;\n }\n \n-pub fn align_of(cx: &CrateContext, t: ty::t) -> u64 {\n+pub fn align_of(cx: &CrateContext, t: ty::t) -> machine::llalign {\n     let llty = sizing_type_of(cx, t);\n     machine::llalign_of_min(cx, llty)\n }"}, {"sha": "03399e739084abeb190c7866ec1348d2d5279177", "filename": "src/librustc_llvm/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ce342f522c10eef8799f2b91b7f39947d40f93ce/src%2Flibrustc_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce342f522c10eef8799f2b91b7f39947d40f93ce/src%2Flibrustc_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Flib.rs?ref=ce342f522c10eef8799f2b91b7f39947d40f93ce", "patch": "@@ -1458,7 +1458,7 @@ extern {\n \n     /** Distance between successive elements in an array of T.\n     Includes ABI padding. */\n-    pub fn LLVMABISizeOfType(TD: TargetDataRef, Ty: TypeRef) -> c_uint;\n+    pub fn LLVMABISizeOfType(TD: TargetDataRef, Ty: TypeRef) -> c_ulonglong;\n \n     /** Returns the preferred alignment of a type. */\n     pub fn LLVMPreferredAlignmentOfType(TD: TargetDataRef, Ty: TypeRef)"}, {"sha": "b23d0716e6ddbb12a2786f6985b474f95819f385", "filename": "src/test/compile-fail/huge-array-simple.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ce342f522c10eef8799f2b91b7f39947d40f93ce/src%2Ftest%2Fcompile-fail%2Fhuge-array-simple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce342f522c10eef8799f2b91b7f39947d40f93ce/src%2Ftest%2Fcompile-fail%2Fhuge-array-simple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fhuge-array-simple.rs?ref=ce342f522c10eef8799f2b91b7f39947d40f93ce", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// error-pattern: too big for the current\n+\n+fn main() {\n+   let fat : [u8, ..(1<<61)+(1<<31)] = [0, ..(1<<61)+(1<<31)];\n+}"}, {"sha": "4b91564154b6ae72958627f5d2d9030a763ee7a2", "filename": "src/test/compile-fail/huge-array.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ce342f522c10eef8799f2b91b7f39947d40f93ce/src%2Ftest%2Fcompile-fail%2Fhuge-array.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce342f522c10eef8799f2b91b7f39947d40f93ce/src%2Ftest%2Fcompile-fail%2Fhuge-array.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fhuge-array.rs?ref=ce342f522c10eef8799f2b91b7f39947d40f93ce", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// error-pattern: ..1518599999\n+\n+fn generic<T: Copy>(t: T) {\n+    let s: [T, ..1518600000] = [t, ..1518600000];\n+}\n+\n+fn main() {\n+    let x: [u8, ..1518599999] = [0, ..1518599999];\n+    generic::<[u8, ..1518599999]>(x);\n+}"}, {"sha": "92f9c41e7ea30643435440d097d0cb0a0f8cee44", "filename": "src/test/compile-fail/huge-enum.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ce342f522c10eef8799f2b91b7f39947d40f93ce/src%2Ftest%2Fcompile-fail%2Fhuge-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce342f522c10eef8799f2b91b7f39947d40f93ce/src%2Ftest%2Fcompile-fail%2Fhuge-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fhuge-enum.rs?ref=ce342f522c10eef8799f2b91b7f39947d40f93ce", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// error-pattern: Option\n+\n+// FIXME: work properly with higher limits\n+\n+fn main() {\n+    let big: Option<[u32, ..(1<<29)-1]> = None;\n+}"}, {"sha": "a10c61d6606d04895e98444e871dd05d29f7b3db", "filename": "src/test/compile-fail/huge-struct.rs", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/ce342f522c10eef8799f2b91b7f39947d40f93ce/src%2Ftest%2Fcompile-fail%2Fhuge-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce342f522c10eef8799f2b91b7f39947d40f93ce/src%2Ftest%2Fcompile-fail%2Fhuge-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fhuge-struct.rs?ref=ce342f522c10eef8799f2b91b7f39947d40f93ce", "patch": "@@ -0,0 +1,54 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// error-pattern: too big for the current\n+\n+struct S32<T> {\n+    v0: T,\n+    v1: T,\n+    v2: T,\n+    v3: T,\n+    v4: T,\n+    v5: T,\n+    v6: T,\n+    v7: T,\n+    v8: T,\n+    u9: T,\n+    v10: T,\n+    v11: T,\n+    v12: T,\n+    v13: T,\n+    v14: T,\n+    v15: T,\n+    v16: T,\n+    v17: T,\n+    v18: T,\n+    v19: T,\n+    v20: T,\n+    v21: T,\n+    v22: T,\n+    v23: T,\n+    v24: T,\n+    u25: T,\n+    v26: T,\n+    v27: T,\n+    v28: T,\n+    v29: T,\n+    v30: T,\n+    v31: T,\n+}\n+\n+struct S1k<T> { val: S32<S32<T>> }\n+\n+struct S1M<T> { val: S1k<S1k<T>> }\n+\n+fn main() {\n+    let fat: Option<S1M<S1M<S1M<u32>>>> = None;\n+}"}, {"sha": "81f9ed991ebe5629437163a8b79006cd6f6bb7ca", "filename": "src/test/compile-fail/issue-17913.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/ce342f522c10eef8799f2b91b7f39947d40f93ce/src%2Ftest%2Fcompile-fail%2Fissue-17913.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce342f522c10eef8799f2b91b7f39947d40f93ce/src%2Ftest%2Fcompile-fail%2Fissue-17913.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17913.rs?ref=ce342f522c10eef8799f2b91b7f39947d40f93ce", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// error-pattern: too big for the current architecture\n+\n+#[cfg(target_word_size = \"64\")]\n+fn main() {\n+    let n = 0u;\n+    let a = box [&n,..0xF000000000000000u];\n+    println!(\"{}\", a[0xFFFFFFu]);\n+}\n+\n+#[cfg(target_word_size = \"32\")]\n+fn main() {\n+    let n = 0u;\n+    let a = box [&n,..0xFFFFFFFFu];\n+    println!(\"{}\", a[0xFFFFFFu]);\n+}"}, {"sha": "05a7388b5e2c401136a88adaa3d2442fd937d237", "filename": "src/test/run-pass/vec-fixed-length.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ce342f522c10eef8799f2b91b7f39947d40f93ce/src%2Ftest%2Frun-pass%2Fvec-fixed-length.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce342f522c10eef8799f2b91b7f39947d40f93ce/src%2Ftest%2Frun-pass%2Fvec-fixed-length.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvec-fixed-length.rs?ref=ce342f522c10eef8799f2b91b7f39947d40f93ce", "patch": "@@ -20,7 +20,8 @@ pub fn main() {\n     assert_eq!(size_of::<[u8, ..4]>(), 4u);\n \n     // FIXME #10183\n-    if cfg!(target_word_size = \"64\") {\n-        assert_eq!(size_of::<[u8, ..(1 << 32)]>(), (1u << 32));\n-    }\n+    // FIXME #18069\n+    //if cfg!(target_word_size = \"64\") {\n+    //    assert_eq!(size_of::<[u8, ..(1 << 32)]>(), (1u << 32));\n+    //}\n }"}]}