{"sha": "ef70925f5f4f89f56f113c11bca44fd1a7764d50", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVmNzA5MjVmNWY0Zjg5ZjU2ZjExM2MxMWJjYTQ0ZmQxYTc3NjRkNTA=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-11-11T09:52:14Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-11-11T09:52:14Z"}, "message": "Refactor highlighting to use classify_name", "tree": {"sha": "6c3ff58d750bf23678b2d124c4e4aba3b4c04e0c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6c3ff58d750bf23678b2d124c4e4aba3b4c04e0c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ef70925f5f4f89f56f113c11bca44fd1a7764d50", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ef70925f5f4f89f56f113c11bca44fd1a7764d50", "html_url": "https://github.com/rust-lang/rust/commit/ef70925f5f4f89f56f113c11bca44fd1a7764d50", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ef70925f5f4f89f56f113c11bca44fd1a7764d50/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4deba88c33c470f084c531fa979fe5684d37f757", "url": "https://api.github.com/repos/rust-lang/rust/commits/4deba88c33c470f084c531fa979fe5684d37f757", "html_url": "https://github.com/rust-lang/rust/commit/4deba88c33c470f084c531fa979fe5684d37f757"}], "stats": {"total": 145, "additions": 73, "deletions": 72}, "files": [{"sha": "1ee68abe20e8d150a20272a6a5c8497cac7d2aa7", "filename": "crates/ra_ide_api/src/syntax_highlighting.rs", "status": "modified", "additions": 73, "deletions": 72, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/ef70925f5f4f89f56f113c11bca44fd1a7764d50/crates%2Fra_ide_api%2Fsrc%2Fsyntax_highlighting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef70925f5f4f89f56f113c11bca44fd1a7764d50/crates%2Fra_ide_api%2Fsrc%2Fsyntax_highlighting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fsyntax_highlighting.rs?ref=ef70925f5f4f89f56f113c11bca44fd1a7764d50", "patch": "@@ -9,12 +9,15 @@ use ra_syntax::{\n     ast::{self, NameOwner},\n     AstNode, Direction, SmolStr, SyntaxElement, SyntaxKind,\n     SyntaxKind::*,\n-    TextRange, T,\n+    SyntaxNode, TextRange, T,\n };\n \n use crate::{\n     db::RootDatabase,\n-    references::{classify_name_ref, NameKind::*},\n+    references::{\n+        classify_name, classify_name_ref,\n+        NameKind::{self, *},\n+    },\n     FileId,\n };\n \n@@ -100,81 +103,43 @@ pub(crate) fn highlight(db: &RootDatabase, file_id: FileId) -> Vec<HighlightedRa\n                 if node.ancestors().any(|it| it.kind() == ATTR) {\n                     continue;\n                 }\n-                if let Some(name_ref) = node.as_node().cloned().and_then(ast::NameRef::cast) {\n-                    let name_kind = classify_name_ref(db, file_id, &name_ref).map(|d| d.kind);\n-                    match name_kind {\n-                        Some(Macro(_)) => \"macro\",\n-                        Some(Field(_)) => \"field\",\n-                        Some(AssocItem(hir::AssocItem::Function(_))) => \"function\",\n-                        Some(AssocItem(hir::AssocItem::Const(_))) => \"constant\",\n-                        Some(AssocItem(hir::AssocItem::TypeAlias(_))) => \"type\",\n-                        Some(Def(hir::ModuleDef::Module(_))) => \"module\",\n-                        Some(Def(hir::ModuleDef::Function(_))) => \"function\",\n-                        Some(Def(hir::ModuleDef::Adt(_))) => \"type\",\n-                        Some(Def(hir::ModuleDef::EnumVariant(_))) => \"constant\",\n-                        Some(Def(hir::ModuleDef::Const(_))) => \"constant\",\n-                        Some(Def(hir::ModuleDef::Static(_))) => \"constant\",\n-                        Some(Def(hir::ModuleDef::Trait(_))) => \"type\",\n-                        Some(Def(hir::ModuleDef::TypeAlias(_))) => \"type\",\n-                        Some(Def(hir::ModuleDef::BuiltinType(_))) => \"type\",\n-                        Some(SelfType(_)) => \"type\",\n-                        Some(Pat((_, ptr))) => {\n-                            let pat = ptr.to_node(&root);\n-                            if let Some(name) = pat.name() {\n-                                let text = name.text();\n-                                let shadow_count =\n-                                    bindings_shadow_count.entry(text.clone()).or_default();\n-                                binding_hash =\n-                                    Some(calc_binding_hash(file_id, &text, *shadow_count))\n-                            }\n \n-                            let analyzer =\n-                                hir::SourceAnalyzer::new(db, file_id, name_ref.syntax(), None);\n-                            if is_variable_mutable(db, &analyzer, ptr.to_node(&root)) {\n-                                \"variable.mut\"\n-                            } else {\n-                                \"variable\"\n-                            }\n-                        }\n-                        Some(SelfParam(_)) => \"type\",\n-                        Some(GenericParam(_)) => \"type\",\n-                        None => \"text\",\n+                let name_ref = node.as_node().cloned().and_then(ast::NameRef::cast).unwrap();\n+                let name_kind = classify_name_ref(db, file_id, &name_ref).map(|d| d.kind);\n+\n+                if let Some(Pat((_, ptr))) = &name_kind {\n+                    let pat = ptr.to_node(&root);\n+                    if let Some(name) = pat.name() {\n+                        let text = name.text();\n+                        let shadow_count = bindings_shadow_count.entry(text.clone()).or_default();\n+                        binding_hash = Some(calc_binding_hash(file_id, &text, *shadow_count))\n                     }\n-                } else {\n-                    \"text\"\n-                }\n+                };\n+\n+                name_kind\n+                    .map_or(\"text\", |it| highlight_name(db, file_id, name_ref.syntax(), &root, it))\n             }\n             NAME => {\n-                if let Some(name) = node.as_node().cloned().and_then(ast::Name::cast) {\n-                    let analyzer = hir::SourceAnalyzer::new(db, file_id, name.syntax(), None);\n-                    if let Some(pat) = name.syntax().ancestors().find_map(ast::BindPat::cast) {\n-                        if let Some(name) = pat.name() {\n-                            let text = name.text();\n-                            let shadow_count =\n-                                bindings_shadow_count.entry(text.clone()).or_default();\n-                            *shadow_count += 1;\n-                            binding_hash = Some(calc_binding_hash(file_id, &text, *shadow_count))\n-                        }\n-\n-                        if is_variable_mutable(db, &analyzer, pat) {\n-                            \"variable.mut\"\n-                        } else {\n-                            \"variable\"\n-                        }\n-                    } else {\n-                        name.syntax()\n-                            .parent()\n-                            .map(|x| match x.kind() {\n-                                TYPE_PARAM | STRUCT_DEF | ENUM_DEF | TRAIT_DEF | TYPE_ALIAS_DEF => {\n-                                    \"type\"\n-                                }\n-                                RECORD_FIELD_DEF => \"field\",\n-                                _ => \"function\",\n-                            })\n-                            .unwrap_or(\"function\")\n+                let name = node.as_node().cloned().and_then(ast::Name::cast).unwrap();\n+                let name_kind = classify_name(db, file_id, &name).map(|d| d.kind);\n+\n+                if let Some(Pat((_, ptr))) = &name_kind {\n+                    let pat = ptr.to_node(&root);\n+                    if let Some(name) = pat.name() {\n+                        let text = name.text();\n+                        let shadow_count = bindings_shadow_count.entry(text.clone()).or_default();\n+                        *shadow_count += 1;\n+                        binding_hash = Some(calc_binding_hash(file_id, &text, *shadow_count))\n                     }\n-                } else {\n-                    \"text\"\n+                };\n+\n+                match name_kind {\n+                    Some(name_kind) => highlight_name(db, file_id, name.syntax(), &root, name_kind),\n+                    None => name.syntax().parent().map_or(\"function\", |x| match x.kind() {\n+                        TYPE_PARAM | STRUCT_DEF | ENUM_DEF | TRAIT_DEF | TYPE_ALIAS_DEF => \"type\",\n+                        RECORD_FIELD_DEF => \"field\",\n+                        _ => \"function\",\n+                    }),\n                 }\n             }\n             INT_NUMBER | FLOAT_NUMBER | CHAR | BYTE => \"literal\",\n@@ -272,6 +237,42 @@ pub(crate) fn highlight_as_html(db: &RootDatabase, file_id: FileId, rainbow: boo\n     buf\n }\n \n+fn highlight_name(\n+    db: &RootDatabase,\n+    file_id: FileId,\n+    node: &SyntaxNode,\n+    root: &SyntaxNode,\n+    name_kind: NameKind,\n+) -> &'static str {\n+    match name_kind {\n+        Macro(_) => \"macro\",\n+        Field(_) => \"field\",\n+        AssocItem(hir::AssocItem::Function(_)) => \"function\",\n+        AssocItem(hir::AssocItem::Const(_)) => \"constant\",\n+        AssocItem(hir::AssocItem::TypeAlias(_)) => \"type\",\n+        Def(hir::ModuleDef::Module(_)) => \"module\",\n+        Def(hir::ModuleDef::Function(_)) => \"function\",\n+        Def(hir::ModuleDef::Adt(_)) => \"type\",\n+        Def(hir::ModuleDef::EnumVariant(_)) => \"constant\",\n+        Def(hir::ModuleDef::Const(_)) => \"constant\",\n+        Def(hir::ModuleDef::Static(_)) => \"constant\",\n+        Def(hir::ModuleDef::Trait(_)) => \"type\",\n+        Def(hir::ModuleDef::TypeAlias(_)) => \"type\",\n+        Def(hir::ModuleDef::BuiltinType(_)) => \"type\",\n+        SelfType(_) => \"type\",\n+        SelfParam(_) => \"type\",\n+        GenericParam(_) => \"type\",\n+        Pat((_, ptr)) => {\n+            let analyzer = hir::SourceAnalyzer::new(db, file_id, node, None);\n+            if is_variable_mutable(db, &analyzer, ptr.to_node(&root)) {\n+                \"variable.mut\"\n+            } else {\n+                \"variable\"\n+            }\n+        }\n+    }\n+}\n+\n //FIXME: like, real html escaping\n fn html_escape(text: &str) -> String {\n     text.replace(\"<\", \"&lt;\").replace(\">\", \"&gt;\")"}]}