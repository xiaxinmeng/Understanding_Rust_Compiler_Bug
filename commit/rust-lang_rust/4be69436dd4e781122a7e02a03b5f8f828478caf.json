{"sha": "4be69436dd4e781122a7e02a03b5f8f828478caf", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRiZTY5NDM2ZGQ0ZTc4MTEyMmE3ZTAyYTAzYjVmOGY4Mjg0NzhjYWY=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-08-14T16:46:19Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-08-14T16:46:19Z"}, "message": "Merge #9897\n\n9897: internal: remove old editing API r=matklad a=matklad\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "ea129c06195073b06584d17d56a996491080d349", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ea129c06195073b06584d17d56a996491080d349"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4be69436dd4e781122a7e02a03b5f8f828478caf", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhF/NbCRBK7hj4Ov3rIwAA1RQIABcy0f/n84POQ/BO/RAy+Q02\nMIdkhkov4GdFdTepvrVDVEP6Ljg4aZfIhGFyOzvxHp7caY1h3ingmYegy4c59zIX\nq9pltx/+lGkOtznL2RbOHPq+h6PZtVZaQJZYSqSCzJ6zNTUxjiB0t39sd1gw6EvQ\nX26MExxwdEss7DpGtkl6lFbyd+cj8zJW5ZK6nWWQ1qEphk/IFcI7dsNkyqpb2x87\n7f9Z13Kv7FQ6MS3s18Lrg5/BN3yxC/9xcDdIjcPVcE3vj0U3sjY8h2vTOg6bzwlz\nCiwZPtr1oK2yCV52Jt96nUzAHhX1/ujUT1z5HCCDARy3xOs0SIYib0s2WVrDtZw=\n=3v7+\n-----END PGP SIGNATURE-----\n", "payload": "tree ea129c06195073b06584d17d56a996491080d349\nparent d7374ab8822f42ff45584a29bd3bcfa47313f908\nparent a26b1c3923b29d6787bbcb107eea0be60529eaa1\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1628959579 +0000\ncommitter GitHub <noreply@github.com> 1628959579 +0000\n\nMerge #9897\n\n9897: internal: remove old editing API r=matklad a=matklad\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4be69436dd4e781122a7e02a03b5f8f828478caf", "html_url": "https://github.com/rust-lang/rust/commit/4be69436dd4e781122a7e02a03b5f8f828478caf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4be69436dd4e781122a7e02a03b5f8f828478caf/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d7374ab8822f42ff45584a29bd3bcfa47313f908", "url": "https://api.github.com/repos/rust-lang/rust/commits/d7374ab8822f42ff45584a29bd3bcfa47313f908", "html_url": "https://github.com/rust-lang/rust/commit/d7374ab8822f42ff45584a29bd3bcfa47313f908"}, {"sha": "a26b1c3923b29d6787bbcb107eea0be60529eaa1", "url": "https://api.github.com/repos/rust-lang/rust/commits/a26b1c3923b29d6787bbcb107eea0be60529eaa1", "html_url": "https://github.com/rust-lang/rust/commit/a26b1c3923b29d6787bbcb107eea0be60529eaa1"}], "stats": {"total": 82, "additions": 36, "deletions": 46}, "files": [{"sha": "1ec0e0a5da397b3cd5e7f14caeae73b09c00b07c", "filename": "crates/ide_assists/src/handlers/convert_to_guarded_return.rs", "status": "modified", "additions": 36, "deletions": 46, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/4be69436dd4e781122a7e02a03b5f8f828478caf/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fconvert_to_guarded_return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4be69436dd4e781122a7e02a03b5f8f828478caf/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fconvert_to_guarded_return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fconvert_to_guarded_return.rs?ref=4be69436dd4e781122a7e02a03b5f8f828478caf", "patch": "@@ -1,15 +1,14 @@\n-use std::{iter::once, ops::RangeInclusive};\n+use std::iter::once;\n \n use syntax::{\n-    algo::replace_children,\n     ast::{\n         self,\n         edit::{AstNodeEdit, IndentLevel},\n         make,\n     },\n-    AstNode,\n-    SyntaxKind::{FN, LOOP_EXPR, L_CURLY, R_CURLY, WHILE_EXPR, WHITESPACE},\n-    SyntaxNode,\n+    ted, AstNode,\n+    SyntaxKind::{FN, LOOP_EXPR, WHILE_EXPR, WHITESPACE},\n+    T,\n };\n \n use crate::{\n@@ -53,17 +52,16 @@ pub(crate) fn convert_to_guarded_return(acc: &mut Assists, ctx: &AssistContext)\n         None => None, // No IfLet, supported.\n         Some(ast::Pat::TupleStructPat(pat)) if pat.fields().count() == 1 => {\n             let path = pat.path()?;\n-            match path.qualifier() {\n-                None => {\n-                    let bound_ident = pat.fields().next().unwrap();\n-                    if ast::IdentPat::can_cast(bound_ident.syntax().kind()) {\n-                        Some((path, bound_ident))\n-                    } else {\n-                        return None;\n-                    }\n-                }\n-                Some(_) => return None,\n+            if path.qualifier().is_some() {\n+                return None;\n+            }\n+\n+            let bound_ident = pat.fields().next().unwrap();\n+            if !ast::IdentPat::can_cast(bound_ident.syntax().kind()) {\n+                return None;\n             }\n+\n+            Some((path, bound_ident))\n         }\n         Some(_) => return None, // Unsupported IfLet.\n     };\n@@ -96,20 +94,21 @@ pub(crate) fn convert_to_guarded_return(acc: &mut Assists, ctx: &AssistContext)\n         _ => return None,\n     };\n \n-    if then_block.syntax().first_child_or_token().map(|t| t.kind() == L_CURLY).is_none() {\n+    if then_block.syntax().first_child_or_token().map(|t| t.kind() == T!['{']).is_none() {\n         return None;\n     }\n \n-    then_block.syntax().last_child_or_token().filter(|t| t.kind() == R_CURLY)?;\n+    then_block.syntax().last_child_or_token().filter(|t| t.kind() == T!['}'])?;\n \n     let target = if_expr.syntax().text_range();\n     acc.add(\n         AssistId(\"convert_to_guarded_return\", AssistKind::RefactorRewrite),\n         \"Convert to guarded return\",\n         target,\n         |edit| {\n+            let if_expr = edit.make_mut(if_expr);\n             let if_indent_level = IndentLevel::from_node(if_expr.syntax());\n-            let new_block = match if_let_pat {\n+            let replacement = match if_let_pat {\n                 None => {\n                     // If.\n                     let new_expr = {\n@@ -119,7 +118,7 @@ pub(crate) fn convert_to_guarded_return(acc: &mut Assists, ctx: &AssistContext)\n                         make::expr_if(make::condition(cond, None), then_branch, None)\n                             .indent(if_indent_level)\n                     };\n-                    replace(new_expr.syntax(), &then_block, &parent_block, &if_expr)\n+                    new_expr.syntax().clone_for_update()\n                 }\n                 Some((path, bound_ident)) => {\n                     // If-let.\n@@ -148,41 +147,32 @@ pub(crate) fn convert_to_guarded_return(acc: &mut Assists, ctx: &AssistContext)\n \n                     let let_stmt = make::let_stmt(bound_ident, None, Some(match_expr));\n                     let let_stmt = let_stmt.indent(if_indent_level);\n-                    replace(let_stmt.syntax(), &then_block, &parent_block, &if_expr)\n+                    let_stmt.syntax().clone_for_update()\n                 }\n             };\n-            edit.replace_ast(parent_block, ast::BlockExpr::cast(new_block).unwrap());\n-\n-            fn replace(\n-                new_expr: &SyntaxNode,\n-                then_block: &ast::BlockExpr,\n-                parent_block: &ast::BlockExpr,\n-                if_expr: &ast::IfExpr,\n-            ) -> SyntaxNode {\n-                let then_block_items = then_block.dedent(IndentLevel(1));\n-                let end_of_then = then_block_items.syntax().last_child_or_token().unwrap();\n-                let end_of_then =\n-                    if end_of_then.prev_sibling_or_token().map(|n| n.kind()) == Some(WHITESPACE) {\n-                        end_of_then.prev_sibling_or_token().unwrap()\n-                    } else {\n-                        end_of_then\n-                    };\n-                let mut then_statements = new_expr.children_with_tokens().chain(\n+\n+            let then_block_items = then_block.dedent(IndentLevel(1)).clone_for_update();\n+\n+            let end_of_then = then_block_items.syntax().last_child_or_token().unwrap();\n+            let end_of_then =\n+                if end_of_then.prev_sibling_or_token().map(|n| n.kind()) == Some(WHITESPACE) {\n+                    end_of_then.prev_sibling_or_token().unwrap()\n+                } else {\n+                    end_of_then\n+                };\n+\n+            let then_statements = replacement\n+                .children_with_tokens()\n+                .chain(\n                     then_block_items\n                         .syntax()\n                         .children_with_tokens()\n                         .skip(1)\n                         .take_while(|i| *i != end_of_then),\n-                );\n-                replace_children(\n-                    parent_block.syntax(),\n-                    RangeInclusive::new(\n-                        if_expr.clone().syntax().clone().into(),\n-                        if_expr.syntax().clone().into(),\n-                    ),\n-                    &mut then_statements,\n                 )\n-            }\n+                .collect();\n+\n+            ted::replace_with_many(if_expr.syntax(), then_statements)\n         },\n     )\n }"}]}