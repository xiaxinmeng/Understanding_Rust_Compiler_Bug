{"sha": "cbdce423201f1b155c46f3ec690a644cf3b4ba53", "node_id": "C_kwDOAAsO6NoAKGNiZGNlNDIzMjAxZjFiMTU1YzQ2ZjNlYzY5MGE2NDRjZjNiNGJhNTM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-25T06:14:15Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-25T06:14:15Z"}, "message": "Auto merge of #97382 - Dylan-DPC:rollup-2t4ov4z, r=Dylan-DPC\n\nRollup of 5 pull requests\n\nSuccessful merges:\n\n - #93604 (Make llvm-libunwind a per-target option)\n - #97026 (Change orderings of `Debug` for the Atomic types to `Relaxed`.)\n - #97105 (Add tests for lint on type dependent on consts)\n - #97323 (Introduce stricter checks for might_permit_raw_init under a debug flag )\n - #97379 (Add aliases for `current_dir`)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "cef7952def48410cda70c688087adbb77b4974c8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cef7952def48410cda70c688087adbb77b4974c8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cbdce423201f1b155c46f3ec690a644cf3b4ba53", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cbdce423201f1b155c46f3ec690a644cf3b4ba53", "html_url": "https://github.com/rust-lang/rust/commit/cbdce423201f1b155c46f3ec690a644cf3b4ba53", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cbdce423201f1b155c46f3ec690a644cf3b4ba53/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9fadabc879e0b16214e8216c1a63a597d1d5d36b", "url": "https://api.github.com/repos/rust-lang/rust/commits/9fadabc879e0b16214e8216c1a63a597d1d5d36b", "html_url": "https://github.com/rust-lang/rust/commit/9fadabc879e0b16214e8216c1a63a597d1d5d36b"}, {"sha": "70bdfc1d799b84b05905397044c45da51d0c2661", "url": "https://api.github.com/repos/rust-lang/rust/commits/70bdfc1d799b84b05905397044c45da51d0c2661", "html_url": "https://github.com/rust-lang/rust/commit/70bdfc1d799b84b05905397044c45da51d0c2661"}], "stats": {"total": 581, "additions": 401, "deletions": 180}, "files": [{"sha": "6937e658ed5ee8a8abe7e5909637fe6611251905", "filename": "compiler/rustc_codegen_cranelift/src/intrinsics/mod.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/cbdce423201f1b155c46f3ec690a644cf3b4ba53/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbdce423201f1b155c46f3ec690a644cf3b4ba53/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fmod.rs?ref=cbdce423201f1b155c46f3ec690a644cf3b4ba53", "patch": "@@ -58,6 +58,7 @@ pub(crate) use llvm::codegen_llvm_intrinsic_call;\n use rustc_middle::ty::print::with_no_trimmed_paths;\n use rustc_middle::ty::subst::SubstsRef;\n use rustc_span::symbol::{kw, sym, Symbol};\n+use rustc_target::abi::InitKind;\n \n use crate::prelude::*;\n use cranelift_codegen::ir::AtomicRmwOp;\n@@ -671,7 +672,12 @@ fn codegen_regular_intrinsic_call<'tcx>(\n                 return;\n             }\n \n-            if intrinsic == sym::assert_zero_valid && !layout.might_permit_raw_init(fx, /*zero:*/ true) {\n+            if intrinsic == sym::assert_zero_valid\n+                && !layout.might_permit_raw_init(\n+                    fx,\n+                    InitKind::Zero,\n+                    fx.tcx.sess.opts.debugging_opts.strict_init_checks) {\n+\n                 with_no_trimmed_paths!({\n                     crate::base::codegen_panic(\n                         fx,\n@@ -682,7 +688,12 @@ fn codegen_regular_intrinsic_call<'tcx>(\n                 return;\n             }\n \n-            if intrinsic == sym::assert_uninit_valid && !layout.might_permit_raw_init(fx, /*zero:*/ false) {\n+            if intrinsic == sym::assert_uninit_valid\n+                && !layout.might_permit_raw_init(\n+                    fx,\n+                    InitKind::Uninit,\n+                    fx.tcx.sess.opts.debugging_opts.strict_init_checks) {\n+\n                 with_no_trimmed_paths!({\n                     crate::base::codegen_panic(\n                         fx,"}, {"sha": "03ef6d50d44cdf84343b067fe659f0759586552a", "filename": "compiler/rustc_codegen_ssa/src/mir/block.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cbdce423201f1b155c46f3ec690a644cf3b4ba53/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbdce423201f1b155c46f3ec690a644cf3b4ba53/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs?ref=cbdce423201f1b155c46f3ec690a644cf3b4ba53", "patch": "@@ -22,7 +22,7 @@ use rustc_span::source_map::Span;\n use rustc_span::{sym, Symbol};\n use rustc_symbol_mangling::typeid_for_fnabi;\n use rustc_target::abi::call::{ArgAbi, FnAbi, PassMode};\n-use rustc_target::abi::{self, HasDataLayout, WrappingRange};\n+use rustc_target::abi::{self, HasDataLayout, InitKind, WrappingRange};\n use rustc_target::spec::abi::Abi;\n \n /// Used by `FunctionCx::codegen_terminator` for emitting common patterns\n@@ -521,6 +521,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         source_info: mir::SourceInfo,\n         target: Option<mir::BasicBlock>,\n         cleanup: Option<mir::BasicBlock>,\n+        strict_validity: bool,\n     ) -> bool {\n         // Emit a panic or a no-op for `assert_*` intrinsics.\n         // These are intrinsics that compile to panics so that we can get a message\n@@ -543,8 +544,8 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             let layout = bx.layout_of(ty);\n             let do_panic = match intrinsic {\n                 Inhabited => layout.abi.is_uninhabited(),\n-                ZeroValid => !layout.might_permit_raw_init(bx, /*zero:*/ true),\n-                UninitValid => !layout.might_permit_raw_init(bx, /*zero:*/ false),\n+                ZeroValid => !layout.might_permit_raw_init(bx, InitKind::Zero, strict_validity),\n+                UninitValid => !layout.might_permit_raw_init(bx, InitKind::Uninit, strict_validity),\n             };\n             if do_panic {\n                 let msg_str = with_no_visible_paths!({\n@@ -678,6 +679,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             source_info,\n             target,\n             cleanup,\n+            self.cx.tcx().sess.opts.debugging_opts.strict_init_checks,\n         ) {\n             return;\n         }"}, {"sha": "bf1cf816ddd0b3385286ab71efdadb03cc73bdd0", "filename": "compiler/rustc_const_eval/src/interpret/intrinsics.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/cbdce423201f1b155c46f3ec690a644cf3b4ba53/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbdce423201f1b155c46f3ec690a644cf3b4ba53/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs?ref=cbdce423201f1b155c46f3ec690a644cf3b4ba53", "patch": "@@ -15,7 +15,7 @@ use rustc_middle::ty::layout::LayoutOf as _;\n use rustc_middle::ty::subst::SubstsRef;\n use rustc_middle::ty::{Ty, TyCtxt};\n use rustc_span::symbol::{sym, Symbol};\n-use rustc_target::abi::{Abi, Align, Primitive, Size};\n+use rustc_target::abi::{Abi, Align, InitKind, Primitive, Size};\n \n use super::{\n     util::ensure_monomorphic_enough, CheckInAllocMsg, ImmTy, InterpCx, Machine, OpTy, PlaceTy,\n@@ -408,7 +408,11 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     )?;\n                 }\n                 if intrinsic_name == sym::assert_zero_valid\n-                    && !layout.might_permit_raw_init(self, /*zero:*/ true)\n+                    && !layout.might_permit_raw_init(\n+                        self,\n+                        InitKind::Zero,\n+                        self.tcx.sess.opts.debugging_opts.strict_init_checks,\n+                    )\n                 {\n                     M::abort(\n                         self,\n@@ -419,7 +423,11 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     )?;\n                 }\n                 if intrinsic_name == sym::assert_uninit_valid\n-                    && !layout.might_permit_raw_init(self, /*zero:*/ false)\n+                    && !layout.might_permit_raw_init(\n+                        self,\n+                        InitKind::Uninit,\n+                        self.tcx.sess.opts.debugging_opts.strict_init_checks,\n+                    )\n                 {\n                     M::abort(\n                         self,"}, {"sha": "66198dff2ae3df518f64c290f6a16e368905035f", "filename": "compiler/rustc_session/src/options.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbdce423201f1b155c46f3ec690a644cf3b4ba53/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbdce423201f1b155c46f3ec690a644cf3b4ba53/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Foptions.rs?ref=cbdce423201f1b155c46f3ec690a644cf3b4ba53", "patch": "@@ -1495,6 +1495,8 @@ options! {\n         \"hash algorithm of source files in debug info (`md5`, `sha1`, or `sha256`)\"),\n     stack_protector: StackProtector = (StackProtector::None, parse_stack_protector, [TRACKED],\n         \"control stack smash protection strategy (`rustc --print stack-protector-strategies` for details)\"),\n+    strict_init_checks: bool = (false, parse_bool, [TRACKED],\n+        \"control if mem::uninitialized and mem::zeroed panic on more UB\"),\n     strip: Strip = (Strip::None, parse_strip, [UNTRACKED],\n         \"tell the linker which information to strip (`none` (default), `debuginfo` or `symbols`)\"),\n     split_dwarf_kind: SplitDwarfKind = (SplitDwarfKind::Split, parse_split_dwarf_kind, [UNTRACKED],"}, {"sha": "a771369c80789448c90f8c7cc726fd2721528382", "filename": "compiler/rustc_target/src/abi/mod.rs", "status": "modified", "additions": 47, "deletions": 12, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/cbdce423201f1b155c46f3ec690a644cf3b4ba53/compiler%2Frustc_target%2Fsrc%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbdce423201f1b155c46f3ec690a644cf3b4ba53/compiler%2Frustc_target%2Fsrc%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fmod.rs?ref=cbdce423201f1b155c46f3ec690a644cf3b4ba53", "patch": "@@ -894,6 +894,15 @@ impl Scalar {\n             Scalar::Union { .. } => true,\n         }\n     }\n+\n+    /// Returns `true` if this type can be left uninit.\n+    #[inline]\n+    pub fn is_uninit_valid(&self) -> bool {\n+        match *self {\n+            Scalar::Initialized { .. } => false,\n+            Scalar::Union { .. } => true,\n+        }\n+    }\n }\n \n /// Describes how the fields of a type are located in memory.\n@@ -1355,6 +1364,14 @@ pub struct PointeeInfo {\n     pub address_space: AddressSpace,\n }\n \n+/// Used in `might_permit_raw_init` to indicate the kind of initialisation\n+/// that is checked to be valid\n+#[derive(Copy, Clone, Debug)]\n+pub enum InitKind {\n+    Zero,\n+    Uninit,\n+}\n+\n /// Trait that needs to be implemented by the higher-level type representation\n /// (e.g. `rustc_middle::ty::Ty`), to provide `rustc_target::abi` functionality.\n pub trait TyAbiInterface<'a, C>: Sized {\n@@ -1461,26 +1478,37 @@ impl<'a, Ty> TyAndLayout<'a, Ty> {\n \n     /// Determines if this type permits \"raw\" initialization by just transmuting some\n     /// memory into an instance of `T`.\n-    /// `zero` indicates if the memory is zero-initialized, or alternatively\n-    /// left entirely uninitialized.\n+    ///\n+    /// `init_kind` indicates if the memory is zero-initialized or left uninitialized.\n+    ///\n+    /// `strict` is an opt-in debugging flag added in #97323 that enables more checks.\n+    ///\n     /// This is conservative: in doubt, it will answer `true`.\n     ///\n     /// FIXME: Once we removed all the conservatism, we could alternatively\n     /// create an all-0/all-undef constant and run the const value validator to see if\n     /// this is a valid value for the given type.\n-    pub fn might_permit_raw_init<C>(self, cx: &C, zero: bool) -> bool\n+    pub fn might_permit_raw_init<C>(self, cx: &C, init_kind: InitKind, strict: bool) -> bool\n     where\n         Self: Copy,\n         Ty: TyAbiInterface<'a, C>,\n         C: HasDataLayout,\n     {\n         let scalar_allows_raw_init = move |s: Scalar| -> bool {\n-            if zero {\n-                // The range must contain 0.\n-                s.valid_range(cx).contains(0)\n-            } else {\n-                // The range must include all values.\n-                s.is_always_valid(cx)\n+            match init_kind {\n+                InitKind::Zero => {\n+                    // The range must contain 0.\n+                    s.valid_range(cx).contains(0)\n+                }\n+                InitKind::Uninit => {\n+                    if strict {\n+                        // The type must be allowed to be uninit (which means \"is a union\").\n+                        s.is_uninit_valid()\n+                    } else {\n+                        // The range must include all values.\n+                        s.is_always_valid(cx)\n+                    }\n+                }\n             }\n         };\n \n@@ -1500,12 +1528,19 @@ impl<'a, Ty> TyAndLayout<'a, Ty> {\n         // If we have not found an error yet, we need to recursively descend into fields.\n         match &self.fields {\n             FieldsShape::Primitive | FieldsShape::Union { .. } => {}\n-            FieldsShape::Array { .. } => {\n-                // FIXME(#66151): For now, we are conservative and do not check arrays.\n+            FieldsShape::Array { count, .. } => {\n+                // FIXME(#66151): For now, we are conservative and do not check arrays by default.\n+                if strict\n+                    && *count > 0\n+                    && !self.field(cx, 0).might_permit_raw_init(cx, init_kind, strict)\n+                {\n+                    // Found non empty array with a type that is unhappy about this kind of initialization\n+                    return false;\n+                }\n             }\n             FieldsShape::Arbitrary { offsets, .. } => {\n                 for idx in 0..offsets.len() {\n-                    if !self.field(cx, idx).might_permit_raw_init(cx, zero) {\n+                    if !self.field(cx, idx).might_permit_raw_init(cx, init_kind, strict) {\n                         // We found a field that is unhappy with this kind of initialization.\n                         return false;\n                     }"}, {"sha": "539e94993ae675fbc3de6ea920bf5d8cf964efd6", "filename": "compiler/rustc_trait_selection/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cbdce423201f1b155c46f3ec690a644cf3b4ba53/compiler%2Frustc_trait_selection%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbdce423201f1b155c46f3ec690a644cf3b4ba53/compiler%2Frustc_trait_selection%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Flib.rs?ref=cbdce423201f1b155c46f3ec690a644cf3b4ba53", "patch": "@@ -20,6 +20,7 @@\n #![feature(label_break_value)]\n #![feature(let_chains)]\n #![feature(let_else)]\n+#![feature(if_let_guard)]\n #![feature(never_type)]\n #![recursion_limit = \"512\"] // For rustdoc\n "}, {"sha": "0dea2c3d8bfe8e0a9692c2c0bbf6f5bf339dd294", "filename": "compiler/rustc_trait_selection/src/traits/const_evaluatable.rs", "status": "modified", "additions": 132, "deletions": 134, "changes": 266, "blob_url": "https://github.com/rust-lang/rust/blob/cbdce423201f1b155c46f3ec690a644cf3b4ba53/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbdce423201f1b155c46f3ec690a644cf3b4ba53/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs?ref=cbdce423201f1b155c46f3ec690a644cf3b4ba53", "patch": "@@ -39,150 +39,148 @@ pub fn is_const_evaluatable<'cx, 'tcx>(\n     let tcx = infcx.tcx;\n \n     if tcx.features().generic_const_exprs {\n-        match AbstractConst::new(tcx, uv)? {\n-            // We are looking at a generic abstract constant.\n-            Some(ct) => {\n-                if satisfied_from_param_env(tcx, ct, param_env)? {\n-                    return Ok(());\n-                }\n-\n-                // We were unable to unify the abstract constant with\n-                // a constant found in the caller bounds, there are\n-                // now three possible cases here.\n-                #[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord)]\n-                enum FailureKind {\n-                    /// The abstract const still references an inference\n-                    /// variable, in this case we return `TooGeneric`.\n-                    MentionsInfer,\n-                    /// The abstract const references a generic parameter,\n-                    /// this means that we emit an error here.\n-                    MentionsParam,\n-                    /// The substs are concrete enough that we can simply\n-                    /// try and evaluate the given constant.\n-                    Concrete,\n-                }\n-                let mut failure_kind = FailureKind::Concrete;\n-                walk_abstract_const::<!, _>(tcx, ct, |node| match node.root(tcx) {\n-                    Node::Leaf(leaf) => {\n-                        if leaf.has_infer_types_or_consts() {\n-                            failure_kind = FailureKind::MentionsInfer;\n-                        } else if leaf.has_param_types_or_consts() {\n-                            failure_kind = cmp::min(failure_kind, FailureKind::MentionsParam);\n-                        }\n-\n-                        ControlFlow::CONTINUE\n+        if let Some(ct) = AbstractConst::new(tcx, uv)? {\n+            if satisfied_from_param_env(tcx, ct, param_env)? {\n+                return Ok(());\n+            }\n+\n+            // We were unable to unify the abstract constant with\n+            // a constant found in the caller bounds, there are\n+            // now three possible cases here.\n+            #[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord)]\n+            enum FailureKind {\n+                /// The abstract const still references an inference\n+                /// variable, in this case we return `TooGeneric`.\n+                MentionsInfer,\n+                /// The abstract const references a generic parameter,\n+                /// this means that we emit an error here.\n+                MentionsParam,\n+                /// The substs are concrete enough that we can simply\n+                /// try and evaluate the given constant.\n+                Concrete,\n+            }\n+            let mut failure_kind = FailureKind::Concrete;\n+            walk_abstract_const::<!, _>(tcx, ct, |node| match node.root(tcx) {\n+                Node::Leaf(leaf) => {\n+                    if leaf.has_infer_types_or_consts() {\n+                        failure_kind = FailureKind::MentionsInfer;\n+                    } else if leaf.has_param_types_or_consts() {\n+                        failure_kind = cmp::min(failure_kind, FailureKind::MentionsParam);\n                     }\n-                    Node::Cast(_, _, ty) => {\n-                        if ty.has_infer_types_or_consts() {\n-                            failure_kind = FailureKind::MentionsInfer;\n-                        } else if ty.has_param_types_or_consts() {\n-                            failure_kind = cmp::min(failure_kind, FailureKind::MentionsParam);\n-                        }\n \n-                        ControlFlow::CONTINUE\n-                    }\n-                    Node::Binop(_, _, _) | Node::UnaryOp(_, _) | Node::FunctionCall(_, _) => {\n-                        ControlFlow::CONTINUE\n+                    ControlFlow::CONTINUE\n+                }\n+                Node::Cast(_, _, ty) => {\n+                    if ty.has_infer_types_or_consts() {\n+                        failure_kind = FailureKind::MentionsInfer;\n+                    } else if ty.has_param_types_or_consts() {\n+                        failure_kind = cmp::min(failure_kind, FailureKind::MentionsParam);\n                     }\n-                });\n \n-                match failure_kind {\n-                    FailureKind::MentionsInfer => {\n-                        return Err(NotConstEvaluatable::MentionsInfer);\n-                    }\n-                    FailureKind::MentionsParam => {\n-                        return Err(NotConstEvaluatable::MentionsParam);\n-                    }\n-                    FailureKind::Concrete => {\n-                        // Dealt with below by the same code which handles this\n-                        // without the feature gate.\n-                    }\n+                    ControlFlow::CONTINUE\n                 }\n-            }\n-            None => {\n-                // If we are dealing with a concrete constant, we can\n-                // reuse the old code path and try to evaluate\n-                // the constant.\n-            }\n-        }\n-    }\n+                Node::Binop(_, _, _) | Node::UnaryOp(_, _) | Node::FunctionCall(_, _) => {\n+                    ControlFlow::CONTINUE\n+                }\n+            });\n \n-    let future_compat_lint = || {\n-        if let Some(local_def_id) = uv.def.did.as_local() {\n-            infcx.tcx.struct_span_lint_hir(\n-                lint::builtin::CONST_EVALUATABLE_UNCHECKED,\n-                infcx.tcx.hir().local_def_id_to_hir_id(local_def_id),\n-                span,\n-                |err| {\n-                    err.build(\"cannot use constants which depend on generic parameters in types\")\n-                        .emit();\n-                },\n-            );\n-        }\n-    };\n-\n-    // FIXME: We should only try to evaluate a given constant here if it is fully concrete\n-    // as we don't want to allow things like `[u8; std::mem::size_of::<*mut T>()]`.\n-    //\n-    // We previously did not check this, so we only emit a future compat warning if\n-    // const evaluation succeeds and the given constant is still polymorphic for now\n-    // and hopefully soon change this to an error.\n-    //\n-    // See #74595 for more details about this.\n-    let concrete = infcx.const_eval_resolve(param_env, uv.expand(), Some(span));\n-\n-    if concrete.is_ok() && uv.substs.has_param_types_or_consts() {\n-        match infcx.tcx.def_kind(uv.def.did) {\n-            DefKind::AnonConst | DefKind::InlineConst => {\n-                let mir_body = infcx.tcx.mir_for_ctfe_opt_const_arg(uv.def);\n-\n-                if mir_body.is_polymorphic {\n-                    future_compat_lint();\n+            match failure_kind {\n+                FailureKind::MentionsInfer => {\n+                    return Err(NotConstEvaluatable::MentionsInfer);\n+                }\n+                FailureKind::MentionsParam => {\n+                    return Err(NotConstEvaluatable::MentionsParam);\n                 }\n+                // returned below\n+                FailureKind::Concrete => {}\n             }\n-            _ => future_compat_lint(),\n         }\n-    }\n-\n-    // If we're evaluating a foreign constant, under a nightly compiler without generic\n-    // const exprs, AND it would've passed if that expression had been evaluated with\n-    // generic const exprs, then suggest using generic const exprs.\n-    if concrete.is_err()\n-        && tcx.sess.is_nightly_build()\n-        && !uv.def.did.is_local()\n-        && !tcx.features().generic_const_exprs\n-        && let Ok(Some(ct)) = AbstractConst::new(tcx, uv)\n-        && satisfied_from_param_env(tcx, ct, param_env) == Ok(true)\n-    {\n-        tcx.sess\n-            .struct_span_fatal(\n-                // Slightly better span than just using `span` alone\n-                if span == rustc_span::DUMMY_SP { tcx.def_span(uv.def.did) } else { span },\n-                \"failed to evaluate generic const expression\",\n-            )\n-            .note(\"the crate this constant originates from uses `#![feature(generic_const_exprs)]`\")\n-            .span_suggestion_verbose(\n-                rustc_span::DUMMY_SP,\n-                \"consider enabling this feature\",\n-                \"#![feature(generic_const_exprs)]\\n\".to_string(),\n-                rustc_errors::Applicability::MaybeIncorrect,\n-            )\n-            .emit()\n-    }\n-\n-    debug!(?concrete, \"is_const_evaluatable\");\n-    match concrete {\n-        Err(ErrorHandled::TooGeneric) => Err(match uv.has_infer_types_or_consts() {\n-            true => NotConstEvaluatable::MentionsInfer,\n-            false => NotConstEvaluatable::MentionsParam,\n-        }),\n-        Err(ErrorHandled::Linted) => {\n-            let reported =\n-                infcx.tcx.sess.delay_span_bug(span, \"constant in type had error reported as lint\");\n-            Err(NotConstEvaluatable::Error(reported))\n+        let concrete = infcx.const_eval_resolve(param_env, uv.expand(), Some(span));\n+        match concrete {\n+            Err(ErrorHandled::TooGeneric) => Err(if !uv.has_infer_types_or_consts() {\n+                infcx\n+                    .tcx\n+                    .sess\n+                    .delay_span_bug(span, &format!(\"unexpected `TooGeneric` for {:?}\", uv));\n+                NotConstEvaluatable::MentionsParam\n+            } else {\n+                NotConstEvaluatable::MentionsInfer\n+            }),\n+            Err(ErrorHandled::Linted) => {\n+                let reported = infcx\n+                    .tcx\n+                    .sess\n+                    .delay_span_bug(span, \"constant in type had error reported as lint\");\n+                Err(NotConstEvaluatable::Error(reported))\n+            }\n+            Err(ErrorHandled::Reported(e)) => Err(NotConstEvaluatable::Error(e)),\n+            Ok(_) => Ok(()),\n+        }\n+    } else {\n+        // FIXME: We should only try to evaluate a given constant here if it is fully concrete\n+        // as we don't want to allow things like `[u8; std::mem::size_of::<*mut T>()]`.\n+        //\n+        // We previously did not check this, so we only emit a future compat warning if\n+        // const evaluation succeeds and the given constant is still polymorphic for now\n+        // and hopefully soon change this to an error.\n+        //\n+        // See #74595 for more details about this.\n+        let concrete = infcx.const_eval_resolve(param_env, uv.expand(), Some(span));\n+\n+        match concrete {\n+          // If we're evaluating a foreign constant, under a nightly compiler without generic\n+          // const exprs, AND it would've passed if that expression had been evaluated with\n+          // generic const exprs, then suggest using generic const exprs.\n+          Err(_) if tcx.sess.is_nightly_build()\n+            && let Ok(Some(ct)) = AbstractConst::new(tcx, uv)\n+            && satisfied_from_param_env(tcx, ct, param_env) == Ok(true) => {\n+              tcx.sess\n+                  .struct_span_fatal(\n+                      // Slightly better span than just using `span` alone\n+                      if span == rustc_span::DUMMY_SP { tcx.def_span(uv.def.did) } else { span },\n+                      \"failed to evaluate generic const expression\",\n+                  )\n+                  .note(\"the crate this constant originates from uses `#![feature(generic_const_exprs)]`\")\n+                  .span_suggestion_verbose(\n+                      rustc_span::DUMMY_SP,\n+                      \"consider enabling this feature\",\n+                      \"#![feature(generic_const_exprs)]\\n\".to_string(),\n+                      rustc_errors::Applicability::MaybeIncorrect,\n+                  )\n+                  .emit()\n+            }\n+\n+            Err(ErrorHandled::TooGeneric) => Err(if uv.has_infer_types_or_consts() {\n+                NotConstEvaluatable::MentionsInfer\n+                } else {\n+                NotConstEvaluatable::MentionsParam\n+            }),\n+            Err(ErrorHandled::Linted) => {\n+                let reported =\n+                    infcx.tcx.sess.delay_span_bug(span, \"constant in type had error reported as lint\");\n+                Err(NotConstEvaluatable::Error(reported))\n+            }\n+            Err(ErrorHandled::Reported(e)) => Err(NotConstEvaluatable::Error(e)),\n+            Ok(_) => {\n+              if uv.substs.has_param_types_or_consts() {\n+                  assert!(matches!(infcx.tcx.def_kind(uv.def.did), DefKind::AnonConst));\n+                  let mir_body = infcx.tcx.mir_for_ctfe_opt_const_arg(uv.def);\n+\n+                  if mir_body.is_polymorphic {\n+                      let Some(local_def_id) = uv.def.did.as_local() else { return Ok(()) };\n+                      tcx.struct_span_lint_hir(\n+                          lint::builtin::CONST_EVALUATABLE_UNCHECKED,\n+                          tcx.hir().local_def_id_to_hir_id(local_def_id),\n+                          span,\n+                          |err| {\n+                              err.build(\"cannot use constants which depend on generic parameters in types\").emit();\n+                        })\n+                  }\n+              }\n+\n+              Ok(())\n+            },\n         }\n-        Err(ErrorHandled::Reported(e)) => Err(NotConstEvaluatable::Error(e)),\n-        Ok(_) => Ok(()),\n     }\n }\n "}, {"sha": "a810e8c0e12d6e02cb8b7b99b39eb587faf6f615", "filename": "config.toml.example", "status": "modified", "additions": 15, "deletions": 10, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/cbdce423201f1b155c46f3ec690a644cf3b4ba53/config.toml.example", "raw_url": "https://github.com/rust-lang/rust/raw/cbdce423201f1b155c46f3ec690a644cf3b4ba53/config.toml.example", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/config.toml.example?ref=cbdce423201f1b155c46f3ec690a644cf3b4ba53", "patch": "@@ -605,16 +605,9 @@ changelog-seen = 2\n # development of NLL\n #test-compare-mode = false\n \n-# Use LLVM libunwind as the implementation for Rust's unwinder.\n-# Accepted values are 'in-tree' (formerly true), 'system' or 'no' (formerly false).\n-# This option only applies for Linux and Fuchsia targets.\n-# On Linux target, if crt-static is not enabled, 'no' means dynamic link to\n-# `libgcc_s.so`, 'in-tree' means static link to the in-tree build of llvm libunwind\n-# and 'system' means dynamic link to `libunwind.so`. If crt-static is enabled,\n-# the behavior is depend on the libc. On musl target, 'no' and 'in-tree' both\n-# means static link to the in-tree build of llvm libunwind, and 'system' means\n-# static link to `libunwind.a` provided by system. Due to the limitation of glibc,\n-# it must link to `libgcc_eh.a` to get a working output, and this option have no effect.\n+# Global default for llvm-libunwind for all targets. See the target-specific\n+# documentation for llvm-libunwind below. Note that the target-specific\n+# option will override this if set.\n #llvm-libunwind = 'no'\n \n # Enable Windows Control Flow Guard checks in the standard library.\n@@ -671,6 +664,18 @@ changelog-seen = 2\n # not, you can specify an explicit file name for it.\n #llvm-filecheck = \"/path/to/llvm-version/bin/FileCheck\"\n \n+# Use LLVM libunwind as the implementation for Rust's unwinder.\n+# Accepted values are 'in-tree' (formerly true), 'system' or 'no' (formerly false).\n+# This option only applies for Linux and Fuchsia targets.\n+# On Linux target, if crt-static is not enabled, 'no' means dynamic link to\n+# `libgcc_s.so`, 'in-tree' means static link to the in-tree build of llvm libunwind\n+# and 'system' means dynamic link to `libunwind.so`. If crt-static is enabled,\n+# the behavior is depend on the libc. On musl target, 'no' and 'in-tree' both\n+# means static link to the in-tree build of llvm libunwind, and 'system' means\n+# static link to `libunwind.a` provided by system. Due to the limitation of glibc,\n+# it must link to `libgcc_eh.a` to get a working output, and this option have no effect.\n+#llvm-libunwind = 'no' if Linux, 'in-tree' if Fuchsia\n+\n # If this target is for Android, this option will be required to specify where\n # the NDK for the target lives. This is used to find the C compiler to link and\n # build native code."}, {"sha": "43cfb1bb6407a7582b21ee4fb16d830281392a84", "filename": "library/core/src/sync/atomic.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cbdce423201f1b155c46f3ec690a644cf3b4ba53/library%2Fcore%2Fsrc%2Fsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbdce423201f1b155c46f3ec690a644cf3b4ba53/library%2Fcore%2Fsrc%2Fsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fsync%2Fatomic.rs?ref=cbdce423201f1b155c46f3ec690a644cf3b4ba53", "patch": "@@ -1517,7 +1517,7 @@ macro_rules! atomic_int {\n         #[$stable_debug]\n         impl fmt::Debug for $atomic_type {\n             fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-                fmt::Debug::fmt(&self.load(Ordering::SeqCst), f)\n+                fmt::Debug::fmt(&self.load(Ordering::Relaxed), f)\n             }\n         }\n \n@@ -2996,15 +2996,15 @@ pub fn compiler_fence(order: Ordering) {\n #[stable(feature = \"atomic_debug\", since = \"1.3.0\")]\n impl fmt::Debug for AtomicBool {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        fmt::Debug::fmt(&self.load(Ordering::SeqCst), f)\n+        fmt::Debug::fmt(&self.load(Ordering::Relaxed), f)\n     }\n }\n \n #[cfg(target_has_atomic_load_store = \"ptr\")]\n #[stable(feature = \"atomic_debug\", since = \"1.3.0\")]\n impl<T> fmt::Debug for AtomicPtr<T> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        fmt::Debug::fmt(&self.load(Ordering::SeqCst), f)\n+        fmt::Debug::fmt(&self.load(Ordering::Relaxed), f)\n     }\n }\n "}, {"sha": "463f714064c61f34c9ef216f05505930a24090d2", "filename": "library/std/src/env.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cbdce423201f1b155c46f3ec690a644cf3b4ba53/library%2Fstd%2Fsrc%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbdce423201f1b155c46f3ec690a644cf3b4ba53/library%2Fstd%2Fsrc%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fenv.rs?ref=cbdce423201f1b155c46f3ec690a644cf3b4ba53", "patch": "@@ -49,6 +49,9 @@ use crate::sys::os as os_imp;\n ///     Ok(())\n /// }\n /// ```\n+#[doc(alias = \"pwd\")]\n+#[doc(alias = \"getcwd\")]\n+#[doc(alias = \"GetCurrentDirectory\")]\n #[stable(feature = \"env\", since = \"1.0.0\")]\n pub fn current_dir() -> io::Result<PathBuf> {\n     os_imp::getcwd()"}, {"sha": "0b430f64e1edc94ee2622f7b4a9b5b750ff76bff", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbdce423201f1b155c46f3ec690a644cf3b4ba53/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbdce423201f1b155c46f3ec690a644cf3b4ba53/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=cbdce423201f1b155c46f3ec690a644cf3b4ba53", "patch": "@@ -176,7 +176,7 @@ fn copy_third_party_objects(\n \n     if target == \"x86_64-fortanix-unknown-sgx\"\n         || target.contains(\"pc-windows-gnullvm\")\n-        || builder.config.llvm_libunwind == LlvmLibunwind::InTree\n+        || builder.config.llvm_libunwind(target) == LlvmLibunwind::InTree\n             && (target.contains(\"linux\") || target.contains(\"fuchsia\"))\n     {\n         let libunwind_path ="}, {"sha": "843d276cd7a88d201beaa91bfcc11755914ce5b3", "filename": "src/bootstrap/config.rs", "status": "modified", "additions": 18, "deletions": 5, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/cbdce423201f1b155c46f3ec690a644cf3b4ba53/src%2Fbootstrap%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbdce423201f1b155c46f3ec690a644cf3b4ba53/src%2Fbootstrap%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.rs?ref=cbdce423201f1b155c46f3ec690a644cf3b4ba53", "patch": "@@ -67,7 +67,6 @@ pub struct Config {\n     pub rustc_error_format: Option<String>,\n     pub json_output: bool,\n     pub test_compare_mode: bool,\n-    pub llvm_libunwind: LlvmLibunwind,\n     pub color: Color,\n     pub patch_binaries_for_nix: bool,\n \n@@ -151,6 +150,7 @@ pub struct Config {\n     pub rust_profile_generate: Option<String>,\n     pub llvm_profile_use: Option<String>,\n     pub llvm_profile_generate: bool,\n+    pub llvm_libunwind_default: Option<LlvmLibunwind>,\n \n     pub build: TargetSelection,\n     pub hosts: Vec<TargetSelection>,\n@@ -342,6 +342,7 @@ pub struct Target {\n     pub llvm_config: Option<PathBuf>,\n     /// Some(path to FileCheck) if one was specified.\n     pub llvm_filecheck: Option<PathBuf>,\n+    pub llvm_libunwind: Option<LlvmLibunwind>,\n     pub cc: Option<PathBuf>,\n     pub cxx: Option<PathBuf>,\n     pub ar: Option<PathBuf>,\n@@ -680,6 +681,7 @@ define_config! {\n         linker: Option<String> = \"linker\",\n         llvm_config: Option<String> = \"llvm-config\",\n         llvm_filecheck: Option<String> = \"llvm-filecheck\",\n+        llvm_libunwind: Option<String> = \"llvm-libunwind\",\n         android_ndk: Option<String> = \"android-ndk\",\n         sanitizers: Option<bool> = \"sanitizers\",\n         profiler: Option<bool> = \"profiler\",\n@@ -1043,10 +1045,6 @@ impl Config {\n             set(&mut config.rust_rpath, rust.rpath);\n             set(&mut config.jemalloc, rust.jemalloc);\n             set(&mut config.test_compare_mode, rust.test_compare_mode);\n-            config.llvm_libunwind = rust\n-                .llvm_libunwind\n-                .map(|v| v.parse().expect(\"failed to parse rust.llvm-libunwind\"))\n-                .unwrap_or_default();\n             set(&mut config.backtrace, rust.backtrace);\n             set(&mut config.channel, rust.channel);\n             config.description = rust.description;\n@@ -1069,6 +1067,9 @@ impl Config {\n             config.rust_thin_lto_import_instr_limit = rust.thin_lto_import_instr_limit;\n             set(&mut config.rust_remap_debuginfo, rust.remap_debuginfo);\n             set(&mut config.control_flow_guard, rust.control_flow_guard);\n+            config.llvm_libunwind_default = rust\n+                .llvm_libunwind\n+                .map(|v| v.parse().expect(\"failed to parse rust.llvm-libunwind\"));\n \n             if let Some(ref backends) = rust.codegen_backends {\n                 config.rust_codegen_backends =\n@@ -1095,6 +1096,10 @@ impl Config {\n                 if let Some(ref s) = cfg.llvm_filecheck {\n                     target.llvm_filecheck = Some(config.src.join(s));\n                 }\n+                target.llvm_libunwind = cfg\n+                    .llvm_libunwind\n+                    .as_ref()\n+                    .map(|v| v.parse().expect(\"failed to parse rust.llvm-libunwind\"));\n                 if let Some(ref s) = cfg.android_ndk {\n                     target.ndk = Some(config.src.join(s));\n                 }\n@@ -1328,6 +1333,14 @@ impl Config {\n         self.rust_codegen_backends.contains(&INTERNER.intern_str(\"llvm\"))\n     }\n \n+    pub fn llvm_libunwind(&self, target: TargetSelection) -> LlvmLibunwind {\n+        self.target_config\n+            .get(&target)\n+            .and_then(|t| t.llvm_libunwind)\n+            .or(self.llvm_libunwind_default)\n+            .unwrap_or(LlvmLibunwind::No)\n+    }\n+\n     pub fn submodules(&self, rust_info: &GitInfo) -> bool {\n         self.submodules.unwrap_or(rust_info.is_git())\n     }"}, {"sha": "591f9a1ca50d3a36f083efc4c412fa5d76309881", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbdce423201f1b155c46f3ec690a644cf3b4ba53/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbdce423201f1b155c46f3ec690a644cf3b4ba53/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=cbdce423201f1b155c46f3ec690a644cf3b4ba53", "patch": "@@ -720,7 +720,7 @@ impl Build {\n     fn std_features(&self, target: TargetSelection) -> String {\n         let mut features = \"panic-unwind\".to_string();\n \n-        match self.config.llvm_libunwind {\n+        match self.config.llvm_libunwind(target) {\n             LlvmLibunwind::InTree => features.push_str(\" llvm-libunwind\"),\n             LlvmLibunwind::System => features.push_str(\" system-llvm-libunwind\"),\n             LlvmLibunwind::No => {}"}, {"sha": "4cd86fecd7e9b763de28ce0dd2670ab14a88538e", "filename": "src/test/ui/const-generics/generic_const_exprs/dependence_lint.full.stderr", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/cbdce423201f1b155c46f3ec690a644cf3b4ba53/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fdependence_lint.full.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cbdce423201f1b155c46f3ec690a644cf3b4ba53/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fdependence_lint.full.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fdependence_lint.full.stderr?ref=cbdce423201f1b155c46f3ec690a644cf3b4ba53", "patch": "@@ -0,0 +1,39 @@\n+error: generic parameters may not be used in const operations\n+  --> $DIR/dependence_lint.rs:13:32\n+   |\n+LL |     let _: [u8; size_of::<*mut T>()]; // error on stable, error with gce\n+   |                                ^ cannot perform const operation using `T`\n+   |\n+   = note: type parameters may not be used in const expressions\n+   = help: use `#![feature(generic_const_exprs)]` to allow generic const expressions\n+\n+error: generic parameters may not be used in const operations\n+  --> $DIR/dependence_lint.rs:20:37\n+   |\n+LL |     let _: [u8; if true { size_of::<T>() } else { 3 }]; // error on stable, error with gce\n+   |                                     ^ cannot perform const operation using `T`\n+   |\n+   = note: type parameters may not be used in const expressions\n+   = help: use `#![feature(generic_const_exprs)]` to allow generic const expressions\n+\n+warning: cannot use constants which depend on generic parameters in types\n+  --> $DIR/dependence_lint.rs:9:9\n+   |\n+LL |     [0; size_of::<*mut T>()]; // lint on stable, error with `generic_const_exprs`\n+   |         ^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(const_evaluatable_unchecked)]` on by default\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #76200 <https://github.com/rust-lang/rust/issues/76200>\n+\n+warning: cannot use constants which depend on generic parameters in types\n+  --> $DIR/dependence_lint.rs:16:9\n+   |\n+LL |     [0; if false { size_of::<T>() } else { 3 }]; // lint on stable, error with gce\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #76200 <https://github.com/rust-lang/rust/issues/76200>\n+\n+error: aborting due to 2 previous errors; 2 warnings emitted\n+"}, {"sha": "b13bcdb2c4786f392f2bc6004561ef02b2a5df0d", "filename": "src/test/ui/const-generics/generic_const_exprs/dependence_lint.gce.stderr", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/cbdce423201f1b155c46f3ec690a644cf3b4ba53/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fdependence_lint.gce.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cbdce423201f1b155c46f3ec690a644cf3b4ba53/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fdependence_lint.gce.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fdependence_lint.gce.stderr?ref=cbdce423201f1b155c46f3ec690a644cf3b4ba53", "patch": "@@ -0,0 +1,34 @@\n+error: overly complex generic constant\n+  --> $DIR/dependence_lint.rs:16:9\n+   |\n+LL |     [0; if false { size_of::<T>() } else { 3 }]; // lint on stable, error with gce\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ control flow is not supported in generic constants\n+   |\n+   = help: consider moving this anonymous constant into a `const` function\n+\n+error: overly complex generic constant\n+  --> $DIR/dependence_lint.rs:20:17\n+   |\n+LL |     let _: [u8; if true { size_of::<T>() } else { 3 }]; // error on stable, error with gce\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ control flow is not supported in generic constants\n+   |\n+   = help: consider moving this anonymous constant into a `const` function\n+\n+error: unconstrained generic constant\n+  --> $DIR/dependence_lint.rs:13:12\n+   |\n+LL |     let _: [u8; size_of::<*mut T>()]; // error on stable, error with gce\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: try adding a `where` bound using this expression: `where [(); size_of::<*mut T>()]:`\n+\n+error: unconstrained generic constant\n+  --> $DIR/dependence_lint.rs:9:9\n+   |\n+LL |     [0; size_of::<*mut T>()]; // lint on stable, error with `generic_const_exprs`\n+   |         ^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: try adding a `where` bound using this expression: `where [(); size_of::<*mut T>()]:`\n+\n+error: aborting due to 4 previous errors\n+"}, {"sha": "dcdfd75def9063c2b635867e9db06526e3331ea0", "filename": "src/test/ui/const-generics/generic_const_exprs/dependence_lint.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/cbdce423201f1b155c46f3ec690a644cf3b4ba53/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fdependence_lint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbdce423201f1b155c46f3ec690a644cf3b4ba53/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fdependence_lint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fdependence_lint.rs?ref=cbdce423201f1b155c46f3ec690a644cf3b4ba53", "patch": "@@ -0,0 +1,25 @@\n+// revisions: full gce\n+\n+#![cfg_attr(gce, feature(generic_const_exprs))]\n+#![allow(incomplete_features)]\n+\n+use std::mem::size_of;\n+\n+fn foo<T>() {\n+    [0; size_of::<*mut T>()]; // lint on stable, error with `generic_const_exprs`\n+    //[gce]~^ ERROR unconstrained\n+    //[full]~^^ WARNING cannot use constants\n+    //[full]~| WARNING this was previously accepted\n+    let _: [u8; size_of::<*mut T>()]; // error on stable, error with gce\n+    //[full]~^ ERROR generic parameters may not be used\n+    //[gce]~^^ ERROR unconstrained generic\n+    [0; if false { size_of::<T>() } else { 3 }]; // lint on stable, error with gce\n+    //[gce]~^ ERROR overly complex\n+    //[full]~^^ WARNING cannot use constants\n+    //[full]~| WARNING this was previously accepted\n+    let _: [u8; if true { size_of::<T>() } else { 3 }]; // error on stable, error with gce\n+    //[full]~^ ERROR generic parameters may not be used\n+    //[gce]~^^ ERROR overly complex\n+}\n+\n+fn main() {}"}, {"sha": "db8dc6ed4434e589bfe4e3fea7653ebbdea3cb4b", "filename": "src/test/ui/const-generics/generic_const_exprs/no_dependence.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/cbdce423201f1b155c46f3ec690a644cf3b4ba53/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fno_dependence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbdce423201f1b155c46f3ec690a644cf3b4ba53/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fno_dependence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fno_dependence.rs?ref=cbdce423201f1b155c46f3ec690a644cf3b4ba53", "patch": "@@ -0,0 +1,13 @@\n+// check-pass\n+#![feature(generic_const_exprs)]\n+#![allow(incomplete_features)]\n+\n+fn two_args<const N: usize, const M: usize>() -> [u8; M + 2] {\n+    [0; M + 2]\n+}\n+\n+fn yay<const N: usize>() -> [u8; 4] {\n+     two_args::<N, 2>() // no lint\n+}\n+\n+fn main() {}"}, {"sha": "3ffd35ecdb8da7b8543b82313ecd61ed5bc24455", "filename": "src/test/ui/intrinsics/panic-uninitialized-zeroed.rs", "status": "modified", "additions": 38, "deletions": 6, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/cbdce423201f1b155c46f3ec690a644cf3b4ba53/src%2Ftest%2Fui%2Fintrinsics%2Fpanic-uninitialized-zeroed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbdce423201f1b155c46f3ec690a644cf3b4ba53/src%2Ftest%2Fui%2Fintrinsics%2Fpanic-uninitialized-zeroed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fintrinsics%2Fpanic-uninitialized-zeroed.rs?ref=cbdce423201f1b155c46f3ec690a644cf3b4ba53", "patch": "@@ -1,8 +1,9 @@\n // run-pass\n // needs-unwind\n // ignore-wasm32-bare compiled with panic=abort by default\n-// revisions: mir thir\n+// revisions: mir thir strict\n // [thir]compile-flags: -Zthir-unsafeck\n+// [strict]compile-flags: -Zstrict-init-checks\n // ignore-tidy-linelength\n \n // This test checks panic emitted from `mem::{uninitialized,zeroed}`.\n@@ -54,6 +55,8 @@ enum LR_NonZero {\n     Right(num::NonZeroI64),\n }\n \n+struct ZeroSized;\n+\n fn test_panic_msg<T>(op: impl (FnOnce() -> T) + panic::UnwindSafe, msg: &str) {\n     let err = panic::catch_unwind(op).err();\n     assert_eq!(\n@@ -228,11 +231,40 @@ fn main() {\n         let _val = mem::zeroed::<[!; 0]>();\n         let _val = mem::uninitialized::<MaybeUninit<bool>>();\n         let _val = mem::uninitialized::<[!; 0]>();\n+        let _val = mem::uninitialized::<()>();\n+        let _val = mem::uninitialized::<ZeroSized>();\n+\n+        if cfg!(strict) {\n+            test_panic_msg(\n+                || mem::uninitialized::<i32>(),\n+                \"attempted to leave type `i32` uninitialized, which is invalid\"\n+            );\n+\n+            test_panic_msg(\n+                || mem::uninitialized::<*const ()>(),\n+                \"attempted to leave type `*const ()` uninitialized, which is invalid\"\n+            );\n+\n+            test_panic_msg(\n+                || mem::uninitialized::<[i32; 1]>(),\n+                \"attempted to leave type `[i32; 1]` uninitialized, which is invalid\"\n+            );\n+\n+            test_panic_msg(\n+                || mem::zeroed::<NonNull<()>>(),\n+                \"attempted to zero-initialize type `core::ptr::non_null::NonNull<()>`, which is invalid\"\n+            );\n \n-        // These are UB because they have not been officially blessed, but we await the resolution\n-        // of <https://github.com/rust-lang/unsafe-code-guidelines/issues/71> before doing\n-        // anything about that.\n-        let _val = mem::uninitialized::<i32>();\n-        let _val = mem::uninitialized::<*const ()>();\n+            test_panic_msg(\n+                || mem::zeroed::<[NonNull<()>; 1]>(),\n+                \"attempted to zero-initialize type `[core::ptr::non_null::NonNull<()>; 1]`, which is invalid\"\n+            );\n+        } else {\n+            // These are UB because they have not been officially blessed, but we await the resolution\n+            // of <https://github.com/rust-lang/unsafe-code-guidelines/issues/71> before doing\n+            // anything about that.\n+            let _val = mem::uninitialized::<i32>();\n+            let _val = mem::uninitialized::<*const ()>();\n+        }\n     }\n }"}]}