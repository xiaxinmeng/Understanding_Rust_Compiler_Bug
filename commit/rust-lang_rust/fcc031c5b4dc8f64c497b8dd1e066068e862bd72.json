{"sha": "fcc031c5b4dc8f64c497b8dd1e066068e862bd72", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZjYzAzMWM1YjRkYzhmNjRjNDk3YjhkZDFlMDY2MDY4ZTg2MmJkNzI=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-08-25T04:26:19Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-08-27T22:54:43Z"}, "message": "Convert std::io to istrs. Issue #855", "tree": {"sha": "d31401261cbe92f9d5039c193dfcb66b3767e018", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d31401261cbe92f9d5039c193dfcb66b3767e018"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fcc031c5b4dc8f64c497b8dd1e066068e862bd72", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fcc031c5b4dc8f64c497b8dd1e066068e862bd72", "html_url": "https://github.com/rust-lang/rust/commit/fcc031c5b4dc8f64c497b8dd1e066068e862bd72", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fcc031c5b4dc8f64c497b8dd1e066068e862bd72/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "20178b9312675f4889bd656916a1f32cbacc94d6", "url": "https://api.github.com/repos/rust-lang/rust/commits/20178b9312675f4889bd656916a1f32cbacc94d6", "html_url": "https://github.com/rust-lang/rust/commit/20178b9312675f4889bd656916a1f32cbacc94d6"}], "stats": {"total": 363, "additions": 203, "deletions": 160}, "files": [{"sha": "08f00479871e9c244209f75d862e89c7a0449fed", "filename": "src/comp/driver/rustc.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/fcc031c5b4dc8f64c497b8dd1e066068e862bd72/src%2Fcomp%2Fdriver%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fcc031c5b4dc8f64c497b8dd1e066068e862bd72/src%2Fcomp%2Fdriver%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Frustc.rs?ref=fcc031c5b4dc8f64c497b8dd1e066068e862bd72", "patch": "@@ -100,7 +100,7 @@ fn parse_input_src(sess: session::session, cfg: &ast::crate_cfg, infile: str)\n    -> {crate: @ast::crate, src: str} {\n     let srcbytes =\n         if infile != \"-\" {\n-            io::file_reader(infile)\n+            io::file_reader(istr::from_estr(infile))\n         } else { io::stdin() }.read_whole_stream();\n     let src = str::unsafe_from_bytes(srcbytes);\n     let crate =\n@@ -238,18 +238,21 @@ fn pretty_print_input(sess: session::session, cfg: ast::crate_cfg, input: str,\n       ppm_normal. { ann = pprust::no_ann(); }\n     }\n     pprust::print_crate(sess.get_codemap(), crate, input,\n-                        io::string_reader(src), io::stdout(), ann);\n+                        io::string_reader(istr::from_estr(src)),\n+                        io::stdout(), ann);\n }\n \n fn version(argv0: str) {\n     let vers = \"unknown version\";\n     let env_vers = #env[\"CFG_VERSION\"];\n     if str::byte_len(env_vers) != 0u { vers = env_vers; }\n-    io::stdout().write_str(#fmt[\"%s %s\\n\", argv0, vers]);\n+    io::stdout().write_str(\n+        istr::from_estr(#fmt[\"%s %s\\n\", argv0, vers]));\n }\n \n fn usage(argv0: str) {\n-    io::stdout().write_str(#fmt[\"usage: %s [options] <input>\\n\", argv0] +\n+    io::stdout().write_str(istr::from_estr(\n+        #fmt[\"usage: %s [options] <input>\\n\", argv0] +\n                                \"\n options:\n \n@@ -283,7 +286,7 @@ options:\n     --test             build test harness\n     --gc               garbage collect shared data (experimental/temporary)\n \n-\");\n+\"));\n }\n \n fn get_os(triple: str) -> session::os {"}, {"sha": "e06f0ca455f1c9dca55aa848f4c2de6dc91626fa", "filename": "src/comp/metadata/creader.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fcc031c5b4dc8f64c497b8dd1e066068e862bd72/src%2Fcomp%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fcc031c5b4dc8f64c497b8dd1e066068e862bd72/src%2Fcomp%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fcreader.rs?ref=fcc031c5b4dc8f64c497b8dd1e066068e862bd72", "patch": "@@ -86,7 +86,8 @@ fn list_file_metadata(path: str, out: io::writer) {\n     alt get_metadata_section(path) {\n       option::some(bytes) { decoder::list_crate_metadata(bytes, out); }\n       option::none. {\n-        out.write_str(\"Could not find metadata in \" + path + \".\\n\");\n+        out.write_str(\n+            istr::from_estr(\"Could not find metadata in \" + path + \".\\n\"));\n       }\n     }\n }"}, {"sha": "522aba23b6fc044e4c71b9bd6f837d27d11441c1", "filename": "src/comp/metadata/decoder.rs", "status": "modified", "additions": 16, "deletions": 11, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/fcc031c5b4dc8f64c497b8dd1e066068e862bd72/src%2Fcomp%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fcc031c5b4dc8f64c497b8dd1e066068e862bd72/src%2Fcomp%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fdecoder.rs?ref=fcc031c5b4dc8f64c497b8dd1e066068e862bd72", "patch": "@@ -4,6 +4,7 @@ import std::ebml;\n import std::vec;\n import std::option;\n import std::str;\n+import std::istr;\n import std::io;\n import std::map::hashmap;\n import syntax::ast;\n@@ -346,18 +347,20 @@ fn get_attributes(md: &ebml::doc) -> [ast::attribute] {\n \n fn list_meta_items(meta_items: &ebml::doc, out: io::writer) {\n     for mi: @ast::meta_item in get_meta_items(meta_items) {\n-        out.write_str(#fmt[\"%s\\n\", pprust::meta_item_to_str(*mi)]);\n+        out.write_str(\n+            istr::from_estr(#fmt[\"%s\\n\", pprust::meta_item_to_str(*mi)]));\n     }\n }\n \n fn list_crate_attributes(md: &ebml::doc, out: io::writer) {\n-    out.write_str(\"=Crate Attributes=\\n\");\n+    out.write_str(~\"=Crate Attributes=\\n\");\n \n     for attr: ast::attribute in get_attributes(md) {\n-        out.write_str(#fmt[\"%s\\n\", pprust::attribute_to_str(attr)]);\n+        out.write_str(\n+            istr::from_estr(#fmt[\"%s\\n\", pprust::attribute_to_str(attr)]));\n     }\n \n-    out.write_str(\"\\n\\n\");\n+    out.write_str(~\"\\n\\n\");\n }\n \n fn get_crate_attributes(data: @[u8]) -> [ast::attribute] {\n@@ -380,17 +383,18 @@ fn get_crate_deps(data: @[u8]) -> [crate_dep] {\n }\n \n fn list_crate_deps(data: @[u8], out: io::writer) {\n-    out.write_str(\"=External Dependencies=\\n\");\n+    out.write_str(~\"=External Dependencies=\\n\");\n \n     for dep: crate_dep in get_crate_deps(data) {\n-        out.write_str(#fmt[\"%d %s\\n\", dep.cnum, dep.ident]);\n+        out.write_str(\n+            istr::from_estr(#fmt[\"%d %s\\n\", dep.cnum, dep.ident]));\n     }\n \n-    out.write_str(\"\\n\");\n+    out.write_str(~\"\\n\");\n }\n \n fn list_crate_items(bytes: &@[u8], md: &ebml::doc, out: io::writer) {\n-    out.write_str(\"=Items=\\n\");\n+    out.write_str(~\"=Items=\\n\");\n     let paths = ebml::get_doc(md, tag_paths);\n     let items = ebml::get_doc(md, tag_items);\n     let index = ebml::get_doc(paths, tag_index);\n@@ -403,11 +407,12 @@ fn list_crate_items(bytes: &@[u8], md: &ebml::doc, out: io::writer) {\n             let def = ebml::doc_at(bytes, data.pos);\n             let did_doc = ebml::get_doc(def, tag_def_id);\n             let did = parse_def_id(ebml::doc_data(did_doc));\n-            out.write_str(#fmt[\"%s (%s)\\n\", data.path,\n-                               describe_def(items, did)]);\n+            out.write_str(\n+                istr::from_estr(#fmt[\"%s (%s)\\n\", data.path,\n+                                     describe_def(items, did)]));\n         }\n     }\n-    out.write_str(\"\\n\");\n+    out.write_str(~\"\\n\");\n }\n \n fn list_crate_metadata(bytes: &@[u8], out: io::writer) {"}, {"sha": "12db17936dd778e378208fb5eec1ae8b384cacbc", "filename": "src/comp/metadata/encoder.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fcc031c5b4dc8f64c497b8dd1e066068e862bd72/src%2Fcomp%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fcc031c5b4dc8f64c497b8dd1e066068e862bd72/src%2Fcomp%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fencoder.rs?ref=fcc031c5b4dc8f64c497b8dd1e066068e862bd72", "patch": "@@ -2,6 +2,7 @@\n \n import std::vec;\n import std::str;\n+import std::istr;\n import std::uint;\n import std::io;\n import std::option;\n@@ -435,7 +436,9 @@ fn encode_index<T>(ebml_w: &ebml::writer, buckets: &[@[entry<T>]],\n     ebml::end_tag(ebml_w);\n }\n \n-fn write_str(writer: &io::writer, s: &str) { writer.write_str(s); }\n+fn write_str(writer: &io::writer, s: &str) {\n+    writer.write_str(istr::from_estr(s));\n+}\n \n fn write_int(writer: &io::writer, n: &int) {\n     writer.write_be_uint(n as uint, 4u);\n@@ -616,15 +619,15 @@ fn encode_metadata(cx: &@crate_ctxt, crate: &@crate) -> str {\n     // remaining % 4 bytes.\n \n     buf_w.write([0u8, 0u8, 0u8, 0u8]);\n-    ret string_w.get_str();\n+    ret istr::to_estr(string_w.get_str());\n }\n \n // Get the encoded string for a type\n fn encoded_ty(tcx: &ty::ctxt, t: ty::t) -> str {\n     let cx = @{ds: def_to_str, tcx: tcx, abbrevs: tyencode::ac_no_abbrevs};\n     let sw = io::string_writer();\n     tyencode::enc_ty(sw.get_writer(), cx, t);\n-    ret sw.get_str();\n+    ret istr::to_estr(sw.get_str());\n }\n \n "}, {"sha": "399ab85fd3031725598f2866fe5a024929d855d3", "filename": "src/comp/metadata/tyencode.rs", "status": "modified", "additions": 40, "deletions": 36, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/fcc031c5b4dc8f64c497b8dd1e066068e862bd72/src%2Fcomp%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fcc031c5b4dc8f64c497b8dd1e066068e862bd72/src%2Fcomp%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Ftyencode.rs?ref=fcc031c5b4dc8f64c497b8dd1e066068e862bd72", "patch": "@@ -46,15 +46,15 @@ fn enc_ty(w: &io::writer, cx: &@ctxt, t: ty::t) {\n           none. {\n             let sw = io::string_writer();\n             enc_sty(sw.get_writer(), cx, ty::struct(cx.tcx, t));\n-            result_str = sw.get_str();\n+            result_str = istr::to_estr(sw.get_str());\n             cx.tcx.short_names_cache.insert(t, result_str);\n           }\n         }\n-        w.write_str(result_str);\n+        w.write_str(istr::from_estr(result_str));\n       }\n       ac_use_abbrevs(abbrevs) {\n         alt abbrevs.find(t) {\n-          some(a) { w.write_str(a.s); ret; }\n+          some(a) { w.write_str(istr::from_estr(a.s)); ret; }\n           none. {\n             let pos = w.get_buf_writer().tell();\n             enc_sty(w, cx, ty::struct(cx.tcx, t));\n@@ -100,30 +100,30 @@ fn enc_sty(w: &io::writer, cx: &@ctxt, st: &ty::sty) {\n       ty::ty_float. { w.write_char('l'); }\n       ty::ty_machine(mach) {\n         alt mach {\n-          ty_u8. { w.write_str(\"Mb\"); }\n-          ty_u16. { w.write_str(\"Mw\"); }\n-          ty_u32. { w.write_str(\"Ml\"); }\n-          ty_u64. { w.write_str(\"Md\"); }\n-          ty_i8. { w.write_str(\"MB\"); }\n-          ty_i16. { w.write_str(\"MW\"); }\n-          ty_i32. { w.write_str(\"ML\"); }\n-          ty_i64. { w.write_str(\"MD\"); }\n-          ty_f32. { w.write_str(\"Mf\"); }\n-          ty_f64. { w.write_str(\"MF\"); }\n+          ty_u8. { w.write_str(~\"Mb\"); }\n+          ty_u16. { w.write_str(~\"Mw\"); }\n+          ty_u32. { w.write_str(~\"Ml\"); }\n+          ty_u64. { w.write_str(~\"Md\"); }\n+          ty_i8. { w.write_str(~\"MB\"); }\n+          ty_i16. { w.write_str(~\"MW\"); }\n+          ty_i32. { w.write_str(~\"ML\"); }\n+          ty_i64. { w.write_str(~\"MD\"); }\n+          ty_f32. { w.write_str(~\"Mf\"); }\n+          ty_f64. { w.write_str(~\"MF\"); }\n         }\n       }\n       ty::ty_char. { w.write_char('c'); }\n       ty::ty_str. { w.write_char('s'); }\n       ty::ty_istr. { w.write_char('S'); }\n       ty::ty_tag(def, tys) {\n-        w.write_str(\"t[\");\n-        w.write_str(cx.ds(def));\n+        w.write_str(~\"t[\");\n+        w.write_str(istr::from_estr(cx.ds(def)));\n         w.write_char('|');\n         for t: ty::t in tys { enc_ty(w, cx, t); }\n         w.write_char(']');\n       }\n       ty::ty_tup(ts) {\n-        w.write_str(\"T[\");\n+        w.write_str(~\"T[\");\n         for t in ts { enc_ty(w, cx, t); }\n         w.write_char(']');\n       }\n@@ -132,9 +132,9 @@ fn enc_sty(w: &io::writer, cx: &@ctxt, st: &ty::sty) {\n       ty::ty_ptr(mt) { w.write_char('*'); enc_mt(w, cx, mt); }\n       ty::ty_vec(mt) { w.write_char('I'); enc_mt(w, cx, mt); }\n       ty::ty_rec(fields) {\n-        w.write_str(\"R[\");\n+        w.write_str(~\"R[\");\n         for field: ty::field in fields {\n-            w.write_str(field.ident);\n+            w.write_str(istr::from_estr(field.ident));\n             w.write_char('=');\n             enc_mt(w, cx, field.mt);\n         }\n@@ -156,42 +156,42 @@ fn enc_sty(w: &io::writer, cx: &@ctxt, st: &ty::sty) {\n         enc_ty_fn(w, cx, args, out, return, []);\n       }\n       ty::ty_obj(methods) {\n-        w.write_str(\"O[\");\n+        w.write_str(~\"O[\");\n         for m: ty::method in methods {\n             enc_proto(w, m.proto);\n-            w.write_str(m.ident);\n+            w.write_str(istr::from_estr(m.ident));\n             enc_ty_fn(w, cx, m.inputs, m.output, m.cf, m.constrs);\n         }\n         w.write_char(']');\n       }\n       ty::ty_res(def, ty, tps) {\n-        w.write_str(\"r[\");\n-        w.write_str(cx.ds(def));\n+        w.write_str(~\"r[\");\n+        w.write_str(istr::from_estr(cx.ds(def)));\n         w.write_char('|');\n         enc_ty(w, cx, ty);\n         for t: ty::t in tps { enc_ty(w, cx, t); }\n         w.write_char(']');\n       }\n       ty::ty_var(id) {\n         w.write_char('X');\n-        w.write_str(istr::to_estr(int::str(id)));\n+        w.write_str(int::str(id));\n       }\n       ty::ty_native(def) {\n         w.write_char('E');\n-        w.write_str(cx.ds(def));\n+        w.write_str(istr::from_estr(cx.ds(def)));\n         w.write_char('|');\n       }\n       ty::ty_param(id, k) {\n         alt k {\n-          kind_unique. { w.write_str(\"pu\"); }\n-          kind_shared. { w.write_str(\"ps\"); }\n-          kind_pinned. { w.write_str(\"pp\"); }\n+          kind_unique. { w.write_str(~\"pu\"); }\n+          kind_shared. { w.write_str(~\"ps\"); }\n+          kind_pinned. { w.write_str(~\"pp\"); }\n         }\n-        w.write_str(istr::to_estr(uint::str(id)));\n+        w.write_str(uint::str(id));\n       }\n       ty::ty_type. { w.write_char('Y'); }\n       ty::ty_constr(ty, cs) {\n-        w.write_str(\"A[\");\n+        w.write_str(~\"A[\");\n         enc_ty(w, cx, ty);\n         for tc: @ty::type_constr in cs { enc_ty_constr(w, cx, tc); }\n         w.write_char(']');\n@@ -235,34 +235,38 @@ fn enc_ty_fn(w: &io::writer, cx: &@ctxt, args: &[ty::arg], out: ty::t,\n \n // FIXME less copy-and-paste\n fn enc_constr(w: &io::writer, cx: &@ctxt, c: &@ty::constr) {\n-    w.write_str(path_to_str(c.node.path));\n+    w.write_str(istr::from_estr(path_to_str(c.node.path)));\n     w.write_char('(');\n-    w.write_str(cx.ds(c.node.id));\n+    w.write_str(istr::from_estr(cx.ds(c.node.id)));\n     w.write_char('|');\n     let semi = false;\n     for a: @constr_arg in c.node.args {\n         if semi { w.write_char(';'); } else { semi = true; }\n         alt a.node {\n           carg_base. { w.write_char('*'); }\n           carg_ident(i) { w.write_uint(i); }\n-          carg_lit(l) { w.write_str(lit_to_str(l)); }\n+          carg_lit(l) {\n+            w.write_str(istr::from_estr(lit_to_str(l)));\n+          }\n         }\n     }\n     w.write_char(')');\n }\n \n fn enc_ty_constr(w: &io::writer, cx: &@ctxt, c: &@ty::type_constr) {\n-    w.write_str(path_to_str(c.node.path));\n+    w.write_str(istr::from_estr(path_to_str(c.node.path)));\n     w.write_char('(');\n-    w.write_str(cx.ds(c.node.id));\n+    w.write_str(istr::from_estr(cx.ds(c.node.id)));\n     w.write_char('|');\n     let semi = false;\n     for a: @ty::ty_constr_arg in c.node.args {\n         if semi { w.write_char(';'); } else { semi = true; }\n         alt a.node {\n           carg_base. { w.write_char('*'); }\n-          carg_ident(p) { w.write_str(path_to_str(p)); }\n-          carg_lit(l) { w.write_str(lit_to_str(l)); }\n+          carg_ident(p) {\n+            w.write_str(istr::from_estr(path_to_str(p))); }\n+          carg_lit(l) {\n+            w.write_str(istr::from_estr(lit_to_str(l))); }\n         }\n     }\n     w.write_char(')');"}, {"sha": "d9aff69acfa36fb52097532e98c59a89ab34580e", "filename": "src/comp/syntax/codemap.rs", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/fcc031c5b4dc8f64c497b8dd1e066068e862bd72/src%2Fcomp%2Fsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fcc031c5b4dc8f64c497b8dd1e066068e862bd72/src%2Fcomp%2Fsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fcodemap.rs?ref=fcc031c5b4dc8f64c497b8dd1e066068e862bd72", "patch": "@@ -1,6 +1,7 @@\n import std::vec;\n import std::uint;\n import std::str;\n+import std::istr;\n import std::term;\n import std::io;\n import std::option;\n@@ -108,13 +109,13 @@ fn emit_diagnostic(sp: &option::t<span>, msg: &str, kind: &str, color: u8,\n       }\n       none. { }\n     }\n-    io::stdout().write_str(ss);\n+    io::stdout().write_str(istr::from_estr(ss));\n     if term::color_supported() {\n         term::fg(io::stdout().get_buf_writer(), color);\n     }\n-    io::stdout().write_str(#fmt[\"%s:\", kind]);\n+    io::stdout().write_str(istr::from_estr(#fmt[\"%s:\", kind]));\n     if term::color_supported() { term::reset(io::stdout().get_buf_writer()); }\n-    io::stdout().write_str(#fmt[\" %s\\n\", msg]);\n+    io::stdout().write_str(istr::from_estr(#fmt[\" %s\\n\", msg]));\n \n     maybe_highlight_lines(sp, cm, maybe_lines);\n }\n@@ -130,7 +131,8 @@ fn maybe_highlight_lines(sp: &option::t<span>, cm: &codemap,\n \n         // FIXME: reading in the entire file is the worst possible way to\n         //        get access to the necessary lines.\n-        let file = io::read_whole_file_str(lines.name);\n+        let file = istr::to_estr(\n+            io::read_whole_file_str(istr::from_estr(lines.name)));\n         let fm = get_filemap(cm, lines.name);\n \n         // arbitrarily only print up to six lines of the error\n@@ -143,18 +145,19 @@ fn maybe_highlight_lines(sp: &option::t<span>, cm: &codemap,\n         }\n         // Print the offending lines\n         for line: uint in display_lines {\n-            io::stdout().write_str(#fmt[\"%s:%u \", fm.name, line + 1u]);\n+            io::stdout().write_str(\n+                istr::from_estr(#fmt[\"%s:%u \", fm.name, line + 1u]));\n             let s = get_line(fm, line as int, file);\n             if !str::ends_with(s, \"\\n\") { s += \"\\n\"; }\n-            io::stdout().write_str(s);\n+            io::stdout().write_str(istr::from_estr(s));\n         }\n         if elided {\n             let last_line = display_lines[vec::len(display_lines) - 1u];\n             let s = #fmt[\"%s:%u \", fm.name, last_line + 1u];\n             let indent = str::char_len(s);\n-            let out = \"\";\n-            while indent > 0u { out += \" \"; indent -= 1u; }\n-            out += \"...\\n\";\n+            let out = ~\"\";\n+            while indent > 0u { out += ~\" \"; indent -= 1u; }\n+            out += ~\"...\\n\";\n             io::stdout().write_str(out);\n         }\n \n@@ -180,7 +183,7 @@ fn maybe_highlight_lines(sp: &option::t<span>, cm: &codemap,\n                 let width = hi.col - lo.col - 1u;\n                 while width > 0u { str::push_char(s, '~'); width -= 1u; }\n             }\n-            io::stdout().write_str(s + \"\\n\");\n+            io::stdout().write_str(istr::from_estr(s + \"\\n\"));\n         }\n       }\n       _ { }"}, {"sha": "3cf240097dc9bb3d92dd7a292c58372cb1b1dc4e", "filename": "src/comp/syntax/ext/log_syntax.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fcc031c5b4dc8f64c497b8dd1e066068e862bd72/src%2Fcomp%2Fsyntax%2Fext%2Flog_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fcc031c5b4dc8f64c497b8dd1e066068e862bd72/src%2Fcomp%2Fsyntax%2Fext%2Flog_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Flog_syntax.rs?ref=fcc031c5b4dc8f64c497b8dd1e066068e862bd72", "patch": "@@ -1,12 +1,14 @@\n import std::option;\n import base::*;\n import syntax::ast;\n+import std::istr;\n \n fn expand_syntax_ext(cx: &ext_ctxt, sp: codemap::span, arg: @ast::expr,\n                      _body: option::t<str>) -> @ast::expr {\n \n     cx.print_backtrace();\n-    std::io::stdout().write_line(print::pprust::expr_to_str(arg));\n+    std::io::stdout().write_line(\n+        istr::from_estr(print::pprust::expr_to_str(arg)));\n \n     //trivial expression\n     ret @{id: cx.next_id(), node: ast::expr_rec([], option::none), span: sp};"}, {"sha": "b5d71a6ee9c89f969ddf9b8379b3f99ad46a91df", "filename": "src/comp/syntax/parse/parser.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fcc031c5b4dc8f64c497b8dd1e066068e862bd72/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fcc031c5b4dc8f64c497b8dd1e066068e862bd72/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs?ref=fcc031c5b4dc8f64c497b8dd1e066068e862bd72", "patch": "@@ -63,7 +63,7 @@ type parser =\n fn new_parser_from_file(sess: parse_sess, cfg: ast::crate_cfg, path: str,\n                         chpos: uint, byte_pos: uint, ftype: file_type) ->\n    parser {\n-    let src = io::read_whole_file_str(path);\n+    let src = istr::to_estr(io::read_whole_file_str(istr::from_estr(path)));\n     let filemap = codemap::new_filemap(path, chpos, byte_pos);\n     sess.cm.files += [filemap];\n     let itr = @interner::mk(str::hash, str::eq);"}, {"sha": "3ad514fdb2ed29c187e2fd28152f62ddc8e3683f", "filename": "src/comp/syntax/print/pp.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fcc031c5b4dc8f64c497b8dd1e066068e862bd72/src%2Fcomp%2Fsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fcc031c5b4dc8f64c497b8dd1e066068e862bd72/src%2Fcomp%2Fsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fprint%2Fpp.rs?ref=fcc031c5b4dc8f64c497b8dd1e066068e862bd72", "patch": "@@ -2,7 +2,7 @@\n import std::io;\n import std::vec;\n import std::str;\n-\n+import std::istr;\n \n /*\n  * This pretty-printer is a direct reimplementation of Philip Karlton's\n@@ -391,7 +391,7 @@ obj printer(out: io::writer,\n     }\n     fn print_newline(amount: int) {\n         log #fmt[\"NEWLINE %d\", amount];\n-        out.write_str(\"\\n\");\n+        out.write_str(~\"\\n\");\n         pending_indentation = 0;\n         self.indent(amount);\n     }\n@@ -407,10 +407,10 @@ obj printer(out: io::writer,\n     }\n     fn write_str(s: str) {\n         while pending_indentation > 0 {\n-            out.write_str(\" \");\n+            out.write_str(~\" \");\n             pending_indentation -= 1;\n         }\n-        out.write_str(s);\n+        out.write_str(istr::from_estr(s));\n     }\n     fn print(x: token, L: int) {\n         log #fmt[\"print %s %d (remaining line space=%d)\", tok_str(x), L,"}, {"sha": "9dcd56407f7429ef64889a30c20179450e1b8ab4", "filename": "src/comp/syntax/print/pprust.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fcc031c5b4dc8f64c497b8dd1e066068e862bd72/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fcc031c5b4dc8f64c497b8dd1e066068e862bd72/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs?ref=fcc031c5b4dc8f64c497b8dd1e066068e862bd72", "patch": "@@ -112,7 +112,7 @@ fn fun_to_str(f: &ast::_fn, name: str, params: &[ast::ty_param]) -> str {\n     let s = rust_printer(writer.get_writer());\n     print_fn(s, f.decl, f.proto, name, params, f.decl.constraints);\n     eof(s.s);\n-    ret writer.get_str();\n+    ret istr::to_estr(writer.get_str());\n }\n \n fn block_to_str(blk: &ast::blk) -> str {\n@@ -126,7 +126,7 @@ fn block_to_str(blk: &ast::blk) -> str {\n     ibox(s, 0u);\n     print_block(s, blk);\n     eof(s.s);\n-    ret writer.get_str();\n+    ret istr::to_estr(writer.get_str());\n }\n \n fn meta_item_to_str(mi: &ast::meta_item) -> str {\n@@ -1621,7 +1621,7 @@ fn to_str<T>(t: &T, f: fn(&ps, &T)) -> str {\n     let s = rust_printer(writer.get_writer());\n     f(s, t);\n     eof(s.s);\n-    ret writer.get_str();\n+    ret istr::to_estr(writer.get_str());\n }\n \n fn next_comment(s: &ps) -> option::t<lexer::cmnt> {"}, {"sha": "c6656014525b9f8b03d323c5106fcfd14398b77d", "filename": "src/etc/combine-tests.py", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fcc031c5b4dc8f64c497b8dd1e066068e862bd72/src%2Fetc%2Fcombine-tests.py", "raw_url": "https://github.com/rust-lang/rust/raw/fcc031c5b4dc8f64c497b8dd1e066068e862bd72/src%2Fetc%2Fcombine-tests.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fcombine-tests.py?ref=fcc031c5b4dc8f64c497b8dd1e066068e862bd72", "patch": "@@ -58,7 +58,7 @@ def scrub(b):\n for t in stage2_tests:\n     p = os.path.join(\"test\", \"run-pass\", t)\n     p = p.replace(\"\\\\\", \"\\\\\\\\\")\n-    d.write(\"    out.write_str(\\\"run-pass [stage2]: %s\\\\n\\\");\\n\" % p)\n+    d.write(\"    out.write_str(~\\\"run-pass [stage2]: %s\\\\n\\\");\\n\" % p)\n     if t in take_args:\n         d.write(\"    t_%d::main([\\\"arg0\\\"]);\\n\" % i)\n     else:"}, {"sha": "99d633427be7883f90a09541b1b4240d6f27803b", "filename": "src/fuzzer/fuzzer.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/fcc031c5b4dc8f64c497b8dd1e066068e862bd72/src%2Ffuzzer%2Ffuzzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fcc031c5b4dc8f64c497b8dd1e066068e862bd72/src%2Ffuzzer%2Ffuzzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffuzzer%2Ffuzzer.rs?ref=fcc031c5b4dc8f64c497b8dd1e066068e862bd72", "patch": "@@ -22,13 +22,13 @@ import rustc::syntax::parse::parser;\n import rustc::syntax::print::pprust;\n \n fn write_file(filename: &str, content: &str) {\n-    io::file_writer(filename, [io::create, io::truncate]).write_str(content);\n+    io::file_writer(istr::from_estr(filename), [io::create, io::truncate]).write_str(istr::from_estr(content));\n     // Work around https://github.com/graydon/rust/issues/726\n     std::run::run_program(~\"chmod\", [~\"644\", istr::from_estr(filename)]);\n }\n \n fn file_contains(filename: &str, needle: &str) -> bool {\n-    let contents = io::read_whole_file_str(filename);\n+    let contents = istr::to_estr(io::read_whole_file_str(istr::from_estr(filename)));\n     ret str::find(contents, needle) != -1;\n }\n \n@@ -154,7 +154,7 @@ fn devnull() -> io::writer { std::io::string_writer().get_writer() }\n fn as_str(f: fn(io::writer)) -> str {\n     let w = std::io::string_writer();\n     f(w.get_writer());\n-    ret w.get_str();\n+    ret istr::to_estr(w.get_str());\n }\n \n fn check_variants_of_ast(crate: &ast::crate, codemap: &codemap::codemap,\n@@ -171,7 +171,7 @@ fn check_variants_of_ast(crate: &ast::crate, codemap: &codemap::codemap,\n                 // string for stability is easier and ok for now.\n                 let str3 =\n                     as_str(bind pprust::print_crate(codemap, crate2, filename,\n-                                                    io::string_reader(\"\"), _,\n+                                                    io::string_reader(~\"\"), _,\n                                                     pprust::no_ann()));\n                 // 1u would be sane here, but the pretty-printer currently has lots of whitespace and paren issues,\n                 // and https://github.com/graydon/rust/issues/766 is hilarious.\n@@ -254,7 +254,7 @@ fn parse_and_print(code: &str) -> str {\n     //write_file(filename, code);\n     let crate = parser::parse_crate_from_source_str(filename, code, [], sess);\n     ret as_str(bind pprust::print_crate(sess.cm, crate, filename,\n-                                        io::string_reader(code), _,\n+                                        io::string_reader(istr::from_estr(code)), _,\n                                         pprust::no_ann()));\n }\n \n@@ -340,7 +340,7 @@ fn check_convergence(files: &[str]) {\n     log_err #fmt[\"pp convergence tests: %u files\", vec::len(files)];\n     for file in files {\n         if !file_is_confusing(file) {\n-            let s = io::read_whole_file_str(file);\n+            let s = istr::to_estr(io::read_whole_file_str(istr::from_estr(file)));\n             if !content_is_confusing(s) {\n                 log_err #fmt[\"pp converge: %s\", file];\n                 // Change from 7u to 2u when https://github.com/graydon/rust/issues/759 is fixed\n@@ -353,7 +353,7 @@ fn check_convergence(files: &[str]) {\n fn check_variants(files: &[str]) {\n     for file in files {\n         if !file_is_confusing(file) {\n-            let s = io::read_whole_file_str(file);\n+            let s = istr::to_estr(io::read_whole_file_str(istr::from_estr(file)));\n             if content_is_dangerous_to_modify(s) || content_is_confusing(s) {\n                 cont;\n             }\n@@ -362,7 +362,7 @@ fn check_variants(files: &[str]) {\n             let crate =\n                 parser::parse_crate_from_source_str(file, s, [], sess);\n             log_err as_str(bind pprust::print_crate(sess.cm, crate, file,\n-                                                    io::string_reader(s), _,\n+                                                    io::string_reader(istr::from_estr(s)), _,\n                                                     pprust::no_ann()));\n             check_variants_of_ast(*crate, sess.cm, file);\n         }"}, {"sha": "4be9d380c8db1c7bd3cdead1863a50be80321826", "filename": "src/lib/io.rs", "status": "modified", "additions": 35, "deletions": 30, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/fcc031c5b4dc8f64c497b8dd1e066068e862bd72/src%2Flib%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fcc031c5b4dc8f64c497b8dd1e066068e862bd72/src%2Flib%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fio.rs?ref=fcc031c5b4dc8f64c497b8dd1e066068e862bd72", "patch": "@@ -39,8 +39,8 @@ type reader =\n         fn read_bytes(uint) -> [u8];\n         fn read_char() -> char;\n         fn eof() -> bool;\n-        fn read_line() -> str;\n-        fn read_c_str() -> str;\n+        fn read_line() -> istr;\n+        fn read_c_str() -> istr;\n         fn read_le_uint(uint) -> uint;\n         fn read_le_int(uint) -> int;\n         fn read_be_uint(uint) -> uint;\n@@ -104,7 +104,7 @@ obj new_reader(rdr: buf_reader) {\n         ret val as char;\n     }\n     fn eof() -> bool { ret rdr.eof(); }\n-    fn read_line() -> str {\n+    fn read_line() -> istr {\n         let buf: [u8] = [];\n         // No break yet in rustc\n \n@@ -115,16 +115,16 @@ obj new_reader(rdr: buf_reader) {\n                 go_on = false;\n             } else { buf += [ch as u8]; }\n         }\n-        ret str::unsafe_from_bytes(buf);\n+        ret istr::unsafe_from_bytes(buf);\n     }\n-    fn read_c_str() -> str {\n+    fn read_c_str() -> istr {\n         let buf: [u8] = [];\n         let go_on = true;\n         while go_on {\n             let ch = rdr.read_byte();\n             if ch < 1 { go_on = false; } else { buf += [ch as u8]; }\n         }\n-        ret str::unsafe_from_bytes(buf);\n+        ret istr::unsafe_from_bytes(buf);\n     }\n \n     // FIXME deal with eof?\n@@ -172,8 +172,10 @@ fn stdin() -> reader {\n     ret new_reader(FILE_buf_reader(rustrt::rust_get_stdin(), option::none));\n }\n \n-fn file_reader(path: str) -> reader {\n-    let f = os::libc::fopen(str::buf(path), str::buf(\"r\"));\n+fn file_reader(path: &istr) -> reader {\n+    let path = istr::to_estr(path);\n+    let mode = \"r\";\n+    let f = os::libc::fopen(str::buf(path), str::buf(mode));\n     if f as uint == 0u { log_err \"error opening \" + path; fail; }\n     ret new_reader(FILE_buf_reader(f, option::some(@FILE_res(f))));\n }\n@@ -213,8 +215,8 @@ fn new_byte_buf_reader(buf: &[u8]) -> buf_reader {\n     ret byte_buf_reader(@{buf: buf, mutable pos: 0u});\n }\n \n-fn string_reader(s: &str) -> reader {\n-    ret new_reader(new_byte_buf_reader(str::bytes(s)));\n+fn string_reader(s: &istr) -> reader {\n+    ret new_reader(new_byte_buf_reader(istr::bytes(s)));\n }\n \n \n@@ -273,7 +275,8 @@ obj fd_buf_writer(fd: int, res: option::t<@fd_res>) {\n     }\n }\n \n-fn file_buf_writer(path: str, flags: &[fileflag]) -> buf_writer {\n+fn file_buf_writer(path: &istr, flags: &[fileflag]) -> buf_writer {\n+    let path = istr::to_estr(path);\n     let fflags: int =\n         os::libc_constants::O_WRONLY() | os::libc_constants::O_BINARY();\n     for f: fileflag in flags {\n@@ -301,8 +304,8 @@ type writer =\n     // function will be provided for general encoded string output\n     obj {\n         fn get_buf_writer() -> buf_writer;\n-        fn write_str(str);\n-        fn write_line(str);\n+        fn write_str(&istr);\n+        fn write_line(&istr);\n         fn write_char(char);\n         fn write_int(int);\n         fn write_uint(uint);\n@@ -327,20 +330,20 @@ fn uint_to_be_bytes(n: uint, size: uint) -> [u8] {\n \n obj new_writer(out: buf_writer) {\n     fn get_buf_writer() -> buf_writer { ret out; }\n-    fn write_str(s: str) { out.write(str::bytes(s)); }\n-    fn write_line(s: str) {\n-        out.write(str::bytes(s));\n-        out.write(str::bytes(\"\\n\"));\n+    fn write_str(s: &istr) { out.write(istr::bytes(s)); }\n+    fn write_line(s: &istr) {\n+        out.write(istr::bytes(s));\n+        out.write(istr::bytes(~\"\\n\"));\n     }\n     fn write_char(ch: char) {\n         // FIXME needlessly consy\n \n-        out.write(str::bytes(str::from_char(ch)));\n+        out.write(istr::bytes(istr::from_char(ch)));\n     }\n-    fn write_int(n: int) { out.write(str::bytes(\n-        istr::to_estr(int::to_str(n, 10u)))); }\n-    fn write_uint(n: uint) { out.write(str::bytes(\n-        istr::to_estr(uint::to_str(n, 10u)))); }\n+    fn write_int(n: int) { out.write(istr::bytes(\n+        int::to_str(n, 10u))); }\n+    fn write_uint(n: uint) { out.write(istr::bytes(\n+        uint::to_str(n, 10u))); }\n     fn write_bytes(bytes: &[u8]) { out.write(bytes); }\n     fn write_le_uint(n: uint, size: uint) {\n         out.write(uint_to_le_bytes(n, size));\n@@ -353,14 +356,16 @@ obj new_writer(out: buf_writer) {\n     }\n }\n \n-fn file_writer(path: str, flags: &[fileflag]) -> writer {\n+fn file_writer(path: &istr, flags: &[fileflag]) -> writer {\n     ret new_writer(file_buf_writer(path, flags));\n }\n \n \n // FIXME: fileflags\n-fn buffered_file_buf_writer(path: str) -> buf_writer {\n-    let f = os::libc::fopen(str::buf(path), str::buf(\"w\"));\n+fn buffered_file_buf_writer(path: &istr) -> buf_writer {\n+    let path = istr::to_estr(path);\n+    let mode = \"w\";\n+    let f = os::libc::fopen(str::buf(path), str::buf(mode));\n     if f as uint == 0u { log_err \"error opening \" + path; fail; }\n     ret FILE_writer(f, option::some(@FILE_res(f)));\n }\n@@ -372,7 +377,7 @@ fn stdout() -> writer { ret new_writer(fd_buf_writer(1, option::none)); }\n type str_writer =\n     obj {\n         fn get_writer() -> writer;\n-        fn get_str() -> str;\n+        fn get_str() -> istr;\n     };\n \n type mutable_byte_buf = @{mutable buf: [mutable u8], mutable pos: uint};\n@@ -415,7 +420,7 @@ fn string_writer() -> str_writer {\n     let buf: mutable_byte_buf = @{mutable buf: b, mutable pos: 0u};\n     obj str_writer_wrap(wr: writer, buf: mutable_byte_buf) {\n         fn get_writer() -> writer { ret wr; }\n-        fn get_str() -> str { ret str::unsafe_from_bytes(buf.buf); }\n+        fn get_str() -> istr { ret istr::unsafe_from_bytes(buf.buf); }\n     }\n     ret str_writer_wrap(new_writer(byte_buf_writer(buf)), buf);\n }\n@@ -435,11 +440,11 @@ fn seek_in_buf(offset: int, pos: uint, len: uint, whence: seek_style) ->\n     ret bpos as uint;\n }\n \n-fn read_whole_file_str(file: &str) -> str {\n-    str::unsafe_from_bytes(read_whole_file(file))\n+fn read_whole_file_str(file: &istr) -> istr {\n+    istr::unsafe_from_bytes(read_whole_file(file))\n }\n \n-fn read_whole_file(file: &str) -> [u8] {\n+fn read_whole_file(file: &istr) -> [u8] {\n \n     // FIXME: There's a lot of copying here\n     file_reader(file).read_whole_stream()"}, {"sha": "5c087b648140c68038a323e58ef7a13a8481346e", "filename": "src/lib/test.rs", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/fcc031c5b4dc8f64c497b8dd1e066068e862bd72/src%2Flib%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fcc031c5b4dc8f64c497b8dd1e066068e862bd72/src%2Flib%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Ftest.rs?ref=fcc031c5b4dc8f64c497b8dd1e066068e862bd72", "patch": "@@ -119,26 +119,30 @@ fn run_tests_console_(opts: &test_opts, tests: &[test_desc],\n         alt event {\n           te_filtered(filtered_tests) {\n             st.total = vec::len(filtered_tests);\n-            st.out.write_line(#fmt[\"\\nrunning %u tests\", st.total]);\n+            st.out.write_line(\n+                istr::from_estr(#fmt[\"\\nrunning %u tests\", st.total]));\n+          }\n+          te_wait(test) {\n+            st.out.write_str(\n+                istr::from_estr(#fmt[\"test %s ... \", test.name]));\n           }\n-          te_wait(test) { st.out.write_str(#fmt[\"test %s ... \", test.name]); }\n           te_result(test, result) {\n             alt result {\n               tr_ok. {\n                 st.passed += 1u;\n                 write_ok(st.out, st.use_color);\n-                st.out.write_line(\"\");\n+                st.out.write_line(~\"\");\n               }\n               tr_failed. {\n                 st.failed += 1u;\n                 write_failed(st.out, st.use_color);\n-                st.out.write_line(\"\");\n+                st.out.write_line(~\"\");\n                 st.failures += [test];\n               }\n               tr_ignored. {\n                 st.ignored += 1u;\n                 write_ignored(st.out, st.use_color);\n-                st.out.write_line(\"\");\n+                st.out.write_line(~\"\");\n               }\n             }\n           }\n@@ -160,20 +164,22 @@ fn run_tests_console_(opts: &test_opts, tests: &[test_desc],\n     let success = st.failed == 0u;\n \n     if !success {\n-        st.out.write_line(\"\\nfailures:\");\n+        st.out.write_line(~\"\\nfailures:\");\n         for test: test_desc in st.failures {\n             let testname = test.name; // Satisfy alias analysis\n-            st.out.write_line(#fmt[\"    %s\", testname]);\n+            st.out.write_line(istr::from_estr(#fmt[\"    %s\", testname]));\n         }\n     }\n \n-    st.out.write_str(#fmt[\"\\nresult: \"]);\n+    st.out.write_str(istr::from_estr(#fmt[\"\\nresult: \"]));\n     if success {\n         // There's no parallelism at this point so it's safe to use color\n         write_ok(st.out, true);\n     } else { write_failed(st.out, true); }\n-    st.out.write_str(#fmt[\". %u passed; %u failed; %u ignored\\n\\n\", st.passed,\n-                          st.failed, st.ignored]);\n+    st.out.write_str(\n+        istr::from_estr(\n+            #fmt[\". %u passed; %u failed; %u ignored\\n\\n\", st.passed,\n+                          st.failed, st.ignored]));\n \n     ret success;\n \n@@ -194,7 +200,7 @@ fn run_tests_console_(opts: &test_opts, tests: &[test_desc],\n         if use_color && term::color_supported() {\n             term::fg(out.get_buf_writer(), color);\n         }\n-        out.write_str(word);\n+        out.write_str(istr::from_estr(word));\n         if use_color && term::color_supported() {\n             term::reset(out.get_buf_writer());\n         }"}, {"sha": "9a09e9d0bd0d3029485a5a2a7cb2a3b65ca0910c", "filename": "src/test/bench/shootout-pfib.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fcc031c5b4dc8f64c497b8dd1e066068e862bd72/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fcc031c5b4dc8f64c497b8dd1e066068e862bd72/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-pfib.rs?ref=fcc031c5b4dc8f64c497b8dd1e066068e862bd72", "patch": "@@ -107,8 +107,10 @@ fn main(argv: [str]) {\n \n                     let elapsed = stop - start;\n \n-                    out.write_line(#fmt[\"%d\\t%d\\t%s\", n, fibn,\n-                                        istr::to_estr(u64::str(elapsed))]);\n+                    out.write_line(\n+                        istr::from_estr(\n+                            #fmt[\"%d\\t%d\\t%s\", n, fibn,\n+                                 istr::to_estr(u64::str(elapsed))]));\n                 }\n             }\n         }"}, {"sha": "0f1db55e886a0787ebe33b399f8576085f60e54e", "filename": "src/test/bench/task-perf-word-count-generic.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fcc031c5b4dc8f64c497b8dd1e066068e862bd72/src%2Ftest%2Fbench%2Ftask-perf-word-count-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fcc031c5b4dc8f64c497b8dd1e066068e862bd72/src%2Ftest%2Fbench%2Ftask-perf-word-count-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-word-count-generic.rs?ref=fcc031c5b4dc8f64c497b8dd1e066068e862bd72", "patch": "@@ -31,7 +31,7 @@ import std::comm::recv;\n import std::comm::send;\n \n fn map(filename: &[u8], emit: &map_reduce::putter<[u8], int>) {\n-    let f = io::file_reader(str::unsafe_from_bytes(filename));\n+    let f = io::file_reader(istr::unsafe_from_bytes(filename));\n \n     while true {\n         alt read_word(f) {\n@@ -202,7 +202,8 @@ fn main(argv: [str]) {\n     if vec::len(argv) < 2u {\n         let out = io::stdout();\n \n-        out.write_line(#fmt[\"Usage: %s <filename> ...\", argv[0]]);\n+        out.write_line(\n+            istr::from_estr(#fmt[\"Usage: %s <filename> ...\", argv[0]]));\n \n         // TODO: run something just to make sure the code hasn't\n         // broken yet. This is the unit test mode of this program."}, {"sha": "e5355fdc9557aca45a03f40b6adc12476f5e9052", "filename": "src/test/bench/task-perf-word-count.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fcc031c5b4dc8f64c497b8dd1e066068e862bd72/src%2Ftest%2Fbench%2Ftask-perf-word-count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fcc031c5b4dc8f64c497b8dd1e066068e862bd72/src%2Ftest%2Fbench%2Ftask-perf-word-count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-word-count.rs?ref=fcc031c5b4dc8f64c497b8dd1e066068e862bd72", "patch": "@@ -14,6 +14,7 @@ import option = std::option::t;\n import std::option::some;\n import std::option::none;\n import std::str;\n+import std::istr;\n import std::map;\n import std::vec;\n import std::io;\n@@ -30,7 +31,7 @@ import std::comm::recv;\n import std::comm::send;\n \n fn map(filename: str, emit: map_reduce::putter) {\n-    let f = io::file_reader(filename);\n+    let f = io::file_reader(istr::from_estr(filename));\n \n \n     while true {\n@@ -196,7 +197,8 @@ fn main(argv: [str]) {\n     if vec::len(argv) < 2u {\n         let out = io::stdout();\n \n-        out.write_line(#fmt[\"Usage: %s <filename> ...\", argv[0]]);\n+        out.write_line(istr::from_estr(\n+            #fmt[\"Usage: %s <filename> ...\", argv[0]]));\n \n         // TODO: run something just to make sure the code hasn't\n         // broken yet. This is the unit test mode of this program."}, {"sha": "0d1121e4b6bb34ab0e3c563bc39cfadcefcedfe5", "filename": "src/test/compiletest/header.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fcc031c5b4dc8f64c497b8dd1e066068e862bd72/src%2Ftest%2Fcompiletest%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fcc031c5b4dc8f64c497b8dd1e066068e862bd72/src%2Ftest%2Fcompiletest%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompiletest%2Fheader.rs?ref=fcc031c5b4dc8f64c497b8dd1e066068e862bd72", "patch": "@@ -71,9 +71,9 @@ fn is_test_ignored(config: &config, testfile: &str) -> bool {\n }\n \n iter iter_header(testfile: &str) -> str {\n-    let rdr = io::file_reader(testfile);\n+    let rdr = io::file_reader(istr::from_estr(testfile));\n     while !rdr.eof() {\n-        let ln = rdr.read_line();\n+        let ln = istr::to_estr(rdr.read_line());\n \n         // Assume that any directives will be found before the first\n         // module or function. This doesn't seem to be an optimization"}, {"sha": "0e4c2c87d837c9a6857cea7ec8322310bdd540fd", "filename": "src/test/compiletest/procsrv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fcc031c5b4dc8f64c497b8dd1e066068e862bd72/src%2Ftest%2Fcompiletest%2Fprocsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fcc031c5b4dc8f64c497b8dd1e066068e862bd72/src%2Ftest%2Fcompiletest%2Fprocsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompiletest%2Fprocsrv.rs?ref=fcc031c5b4dc8f64c497b8dd1e066068e862bd72", "patch": "@@ -73,7 +73,7 @@ fn run(handle: &handle, lib_path: &str, prog: &str, args: &[str],\n fn writeclose(fd: int, s: &option::t<str>) {\n     if option::is_some(s) {\n         let writer = io::new_writer(io::fd_buf_writer(fd, option::none));\n-        writer.write_str(option::get(s));\n+        writer.write_str(istr::from_estr(option::get(s)));\n     }\n \n     os::libc::close(fd);"}, {"sha": "a4e1b26b7ed3c5b19e9894e5c2d1057ae23cdcad", "filename": "src/test/compiletest/runtest.rs", "status": "modified", "additions": 18, "deletions": 14, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/fcc031c5b4dc8f64c497b8dd1e066068e862bd72/src%2Ftest%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fcc031c5b4dc8f64c497b8dd1e066068e862bd72/src%2Ftest%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompiletest%2Fruntest.rs?ref=fcc031c5b4dc8f64c497b8dd1e066068e862bd72", "patch": "@@ -23,7 +23,7 @@ fn run(cx: &cx, _testfile: -[u8]) {\n     let testfile = str::unsafe_from_bytes(_testfile);\n     if cx.config.verbose {\n         // We're going to be dumping a lot of info. Start on a new line.\n-        io::stdout().write_str(\"\\n\\n\");\n+        io::stdout().write_str(~\"\\n\\n\");\n     }\n     log #fmt[\"running %s\", testfile];\n     let props = load_props(testfile);\n@@ -87,7 +87,8 @@ fn run_pretty_test(cx: &cx, props: &test_props, testfile: &str) {\n     let rounds =\n         alt props.pp_exact { option::some(_) { 1 } option::none. { 2 } };\n \n-    let srcs = [io::read_whole_file_str(testfile)];\n+    let srcs = [istr::to_estr(io::read_whole_file_str(\n+        istr::from_estr(testfile)))];\n \n     let round = 0;\n     while round < rounds {\n@@ -108,7 +109,7 @@ fn run_pretty_test(cx: &cx, props: &test_props, testfile: &str) {\n           option::some(file) {\n             let filepath = fs::connect(fs::dirname(\n                 istr::from_estr(testfile)), istr::from_estr(file));\n-            io::read_whole_file_str(istr::to_estr(filepath))\n+            istr::to_estr(io::read_whole_file_str(filepath))\n           }\n           option::none. { srcs[vec::len(srcs) - 2u] }\n         };\n@@ -159,7 +160,7 @@ actual:\\n\\\n ------------------------------------------\\n\\\n \\n\",\n                      expected, actual];\n-            io::stdout().write_str(msg);\n+            io::stdout().write_str(istr::from_estr(msg));\n             fail;\n         }\n     }\n@@ -329,8 +330,9 @@ fn dump_output(config: &config, testfile: &str, out: &str, err: &str) {\n fn dump_output_file(config: &config, testfile: &str, out: &str,\n                     extension: &str) {\n     let outfile = make_out_name(config, testfile, extension);\n-    let writer = io::file_writer(outfile, [io::create, io::truncate]);\n-    writer.write_str(out);\n+    let writer = io::file_writer(istr::from_estr(outfile),\n+                                 [io::create, io::truncate]);\n+    writer.write_str(istr::from_estr(out));\n }\n \n // FIXME (726): Can't use file_writer on mac\n@@ -361,21 +363,23 @@ fn maybe_dump_to_stdout(config: &config, out: &str, err: &str) {\n         let sep1 = #fmt[\"------%s------------------------------\", \"stdout\"];\n         let sep2 = #fmt[\"------%s------------------------------\", \"stderr\"];\n         let sep3 = \"------------------------------------------\";\n-        io::stdout().write_line(sep1);\n-        io::stdout().write_line(out);\n-        io::stdout().write_line(sep2);\n-        io::stdout().write_line(err);\n-        io::stdout().write_line(sep3);\n+        io::stdout().write_line(istr::from_estr(sep1));\n+        io::stdout().write_line(istr::from_estr(out));\n+        io::stdout().write_line(istr::from_estr(sep2));\n+        io::stdout().write_line(istr::from_estr(err));\n+        io::stdout().write_line(istr::from_estr(sep3));\n     }\n }\n \n-fn error(err: &str) { io::stdout().write_line(#fmt[\"\\nerror: %s\", err]); }\n+fn error(err: &str) {\n+    io::stdout().write_line(istr::from_estr(#fmt[\"\\nerror: %s\", err]));\n+}\n \n fn fatal(err: &str) -> ! { error(err); fail; }\n \n fn fatal_procres(err: &str, procres: procres) -> ! {\n     let msg =\n-        #fmt[\"\\n\\\n+        istr::from_estr(#fmt[\"\\n\\\n error: %s\\n\\\n command: %s\\n\\\n stdout:\\n\\\n@@ -387,7 +391,7 @@ stderr:\\n\\\n %s\\n\\\n ------------------------------------------\\n\\\n \\n\",\n-             err, procres.cmdline, procres.stdout, procres.stderr];\n+             err, procres.cmdline, procres.stdout, procres.stderr]);\n     io::stdout().write_str(msg);\n     fail;\n }"}, {"sha": "9bbcd6c7e99de412e1f1d894006689f17728c298", "filename": "src/test/compiletest/util.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fcc031c5b4dc8f64c497b8dd1e066068e862bd72/src%2Ftest%2Fcompiletest%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fcc031c5b4dc8f64c497b8dd1e066068e862bd72/src%2Ftest%2Fcompiletest%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompiletest%2Futil.rs?ref=fcc031c5b4dc8f64c497b8dd1e066068e862bd72", "patch": "@@ -25,5 +25,7 @@ fn lib_path_env_var() -> str { \"PATH\" }\n \n fn logv(config: &config, s: &str) {\n     log s;\n-    if config.verbose { io::stdout().write_line(s); }\n+    if config.verbose {\n+        io::stdout().write_line(std::istr::from_estr(s));\n+    }\n }"}, {"sha": "679466cbece0b6cbf4a44c916500f982e3825bae", "filename": "src/test/stdtest/io.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fcc031c5b4dc8f64c497b8dd1e066068e862bd72/src%2Ftest%2Fstdtest%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fcc031c5b4dc8f64c497b8dd1e066068e862bd72/src%2Ftest%2Fstdtest%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Fio.rs?ref=fcc031c5b4dc8f64c497b8dd1e066068e862bd72", "patch": "@@ -1,25 +1,25 @@\n // -*- rust -*-\n use std;\n import std::io;\n-import std::str;\n+import std::istr;\n \n #[cfg(target_os = \"linux\")]\n #[cfg(target_os = \"win32\")]\n #[test]\n fn test_simple() {\n-    let tmpfile: str = \"test/run-pass/lib-io-test-simple.tmp\";\n+    let tmpfile: istr = ~\"test/run-pass/lib-io-test-simple.tmp\";\n     log tmpfile;\n-    let frood: str = \"A hoopy frood who really knows where his towel is.\";\n+    let frood: istr = ~\"A hoopy frood who really knows where his towel is.\";\n     log frood;\n     {\n         let out: io::writer =\n             io::file_writer(tmpfile, [io::create, io::truncate]);\n         out.write_str(frood);\n     }\n     let inp: io::reader = io::file_reader(tmpfile);\n-    let frood2: str = inp.read_c_str();\n+    let frood2: istr = inp.read_c_str();\n     log frood2;\n-    assert (str::eq(frood, frood2));\n+    assert (istr::eq(frood, frood2));\n }\n \n // FIXME (726)"}, {"sha": "d3e88b13738f5ae27c827c366b6ed35f586c9878", "filename": "src/test/stdtest/run.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fcc031c5b4dc8f64c497b8dd1e066068e862bd72/src%2Ftest%2Fstdtest%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fcc031c5b4dc8f64c497b8dd1e066068e862bd72/src%2Ftest%2Fstdtest%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Frun.rs?ref=fcc031c5b4dc8f64c497b8dd1e066068e862bd72", "patch": "@@ -3,7 +3,7 @@ import std::run;\n import std::os;\n import std::io;\n import std::option;\n-import std::str;\n+import std::istr;\n import std::vec;\n \n // Regression test for memory leaks\n@@ -36,7 +36,7 @@ fn test_pipes() {\n     os::libc::close(pipe_err.out);\n \n     if pid == -1 { fail; }\n-    let expected = \"test\";\n+    let expected = ~\"test\";\n     writeclose(pipe_in.out, expected);\n     let actual = readclose(pipe_out.in);\n     readclose(pipe_err.in);\n@@ -46,21 +46,21 @@ fn test_pipes() {\n     log actual;\n     assert (expected == actual);\n \n-    fn writeclose(fd: int, s: &str) {\n+    fn writeclose(fd: int, s: &istr) {\n         let writer = io::new_writer(io::fd_buf_writer(fd, option::none));\n         writer.write_str(s);\n \n         os::libc::close(fd);\n     }\n \n-    fn readclose(fd: int) -> str {\n+    fn readclose(fd: int) -> istr {\n         // Copied from run::program_output\n         let file = os::fd_FILE(fd);\n         let reader = io::new_reader(io::FILE_buf_reader(file, option::none));\n-        let buf = \"\";\n+        let buf = ~\"\";\n         while !reader.eof() {\n             let bytes = reader.read_bytes(4096u);\n-            buf += str::unsafe_from_bytes(bytes);\n+            buf += istr::unsafe_from_bytes(bytes);\n         }\n         os::libc::fclose(file);\n         ret buf;"}]}