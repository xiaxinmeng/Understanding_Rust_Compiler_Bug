{"sha": "60ba5c70fcba9a9ce3a9b86d9511e4df6ed4f22e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYwYmE1YzcwZmNiYTlhOWNlM2E5Yjg2ZDk1MTFlNGRmNmVkNGYyMmU=", "commit": {"author": {"name": "Yuki Okushi", "email": "huyuumi.dev@gmail.com", "date": "2019-11-13T13:09:25Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-11-13T13:09:25Z"}, "message": "Rollup merge of #66330 - Nadrieril:nonexhaustive-constructor, r=varkor\n\nImprove non-exhaustiveness handling in usefulness checking\n\nThe comments around code paths for the `non_exhaustive` feature mention stuff like \"we act as if the type had an extra unmatcheable constructor\". So I thought I'd make this explicit by defining a special constructor that does exactly this.\nThis makes those code paths a bit more legible and less prone to error.", "tree": {"sha": "eb2fd449d6429fb005a4029972deb2babd1165e3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eb2fd449d6429fb005a4029972deb2babd1165e3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/60ba5c70fcba9a9ce3a9b86d9511e4df6ed4f22e", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdzACFCRBK7hj4Ov3rIwAAdHIIABOREnnN8700T6A8r0U2hdzd\nMO6cB9c1ikunWX/KbhpnmwYQjictlMOsPqPXHzfiSoq9/TV6pQHFbwODxnG4uq7F\ntPVK0FJrOS7ugCaf0XS7T1utLruv+J+UNAXQrg8iCEgIe2fRMQ9g+InEhuqS1o7I\niX/ZuFndfFa8ccI1bd3jCsKaZ2UUSXNPjBpMVV1aqM2wK7Z5NCnH4ngpuoRKXwjr\np5CefFIEnn0zQ3kBZmoVq07cRLwWYRjYRV+Yq7MK6aY3cbxLSEIHLCQIZg1Vpbsu\nI53bMmZJQv5sn5/jHdq15VwA2NkA8i08u7LL6dQrdFmcjkm653lc/zwoweMZbPo=\n=9Gnj\n-----END PGP SIGNATURE-----\n", "payload": "tree eb2fd449d6429fb005a4029972deb2babd1165e3\nparent 1cbd34faf226f55265822773a6a24892dfe3d044\nparent e398d897b09f69bc4b5a1ab531db1c8742001bff\nauthor Yuki Okushi <huyuumi.dev@gmail.com> 1573650565 +0900\ncommitter GitHub <noreply@github.com> 1573650565 +0900\n\nRollup merge of #66330 - Nadrieril:nonexhaustive-constructor, r=varkor\n\nImprove non-exhaustiveness handling in usefulness checking\n\nThe comments around code paths for the `non_exhaustive` feature mention stuff like \"we act as if the type had an extra unmatcheable constructor\". So I thought I'd make this explicit by defining a special constructor that does exactly this.\nThis makes those code paths a bit more legible and less prone to error.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/60ba5c70fcba9a9ce3a9b86d9511e4df6ed4f22e", "html_url": "https://github.com/rust-lang/rust/commit/60ba5c70fcba9a9ce3a9b86d9511e4df6ed4f22e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/60ba5c70fcba9a9ce3a9b86d9511e4df6ed4f22e/comments", "author": {"login": "JohnTitor", "id": 25030997, "node_id": "MDQ6VXNlcjI1MDMwOTk3", "avatar_url": "https://avatars.githubusercontent.com/u/25030997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JohnTitor", "html_url": "https://github.com/JohnTitor", "followers_url": "https://api.github.com/users/JohnTitor/followers", "following_url": "https://api.github.com/users/JohnTitor/following{/other_user}", "gists_url": "https://api.github.com/users/JohnTitor/gists{/gist_id}", "starred_url": "https://api.github.com/users/JohnTitor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JohnTitor/subscriptions", "organizations_url": "https://api.github.com/users/JohnTitor/orgs", "repos_url": "https://api.github.com/users/JohnTitor/repos", "events_url": "https://api.github.com/users/JohnTitor/events{/privacy}", "received_events_url": "https://api.github.com/users/JohnTitor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1cbd34faf226f55265822773a6a24892dfe3d044", "url": "https://api.github.com/repos/rust-lang/rust/commits/1cbd34faf226f55265822773a6a24892dfe3d044", "html_url": "https://github.com/rust-lang/rust/commit/1cbd34faf226f55265822773a6a24892dfe3d044"}, {"sha": "e398d897b09f69bc4b5a1ab531db1c8742001bff", "url": "https://api.github.com/repos/rust-lang/rust/commits/e398d897b09f69bc4b5a1ab531db1c8742001bff", "html_url": "https://github.com/rust-lang/rust/commit/e398d897b09f69bc4b5a1ab531db1c8742001bff"}], "stats": {"total": 367, "additions": 185, "deletions": 182}, "files": [{"sha": "8e574cc961b2b0d5ae9b4cdc2800f1e8cf72cdb1", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 185, "deletions": 182, "changes": 367, "blob_url": "https://github.com/rust-lang/rust/blob/60ba5c70fcba9a9ce3a9b86d9511e4df6ed4f22e/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60ba5c70fcba9a9ce3a9b86d9511e4df6ed4f22e/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=60ba5c70fcba9a9ce3a9b86d9511e4df6ed4f22e", "patch": "@@ -560,13 +560,6 @@ impl<'a, 'tcx> MatchCheckCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn is_non_exhaustive_enum(&self, ty: Ty<'tcx>) -> bool {\n-        match ty.kind {\n-            ty::Adt(adt_def, ..) => adt_def.is_variant_list_non_exhaustive(),\n-            _ => false,\n-        }\n-    }\n-\n     fn is_local(&self, ty: Ty<'tcx>) -> bool {\n         match ty.kind {\n             ty::Adt(adt_def, ..) => adt_def.did.is_local(),\n@@ -590,13 +583,16 @@ enum Constructor<'tcx> {\n     FixedLenSlice(u64),\n     /// Slice patterns. Captures any array constructor of `length >= i + j`.\n     VarLenSlice(u64, u64),\n+    /// Fake extra constructor for enums that aren't allowed to be matched exhaustively.\n+    NonExhaustive,\n }\n \n // Ignore spans when comparing, they don't carry semantic information as they are only for lints.\n impl<'tcx> std::cmp::PartialEq for Constructor<'tcx> {\n     fn eq(&self, other: &Self) -> bool {\n         match (self, other) {\n             (Constructor::Single, Constructor::Single) => true,\n+            (Constructor::NonExhaustive, Constructor::NonExhaustive) => true,\n             (Constructor::Variant(a), Constructor::Variant(b)) => a == b,\n             (Constructor::ConstantValue(a, _), Constructor::ConstantValue(b, _)) => a == b,\n             (\n@@ -771,6 +767,8 @@ impl<'tcx> Constructor<'tcx> {\n                 // ranges have been omitted.\n                 remaining_ctors\n             }\n+            // This constructor is never covered by anything else\n+            NonExhaustive => vec![NonExhaustive],\n         }\n     }\n \n@@ -781,65 +779,68 @@ impl<'tcx> Constructor<'tcx> {\n         ty: Ty<'tcx>,\n     ) -> Vec<Pat<'tcx>> {\n         debug!(\"wildcard_subpatterns({:#?}, {:?})\", self, ty);\n-        match ty.kind {\n-            ty::Tuple(ref fs) => {\n-                fs.into_iter().map(|t| t.expect_ty()).map(Pat::wildcard_from_ty).collect()\n-            }\n-            ty::Slice(ty) | ty::Array(ty, _) => match *self {\n-                FixedLenSlice(length) => (0..length).map(|_| Pat::wildcard_from_ty(ty)).collect(),\n-                VarLenSlice(prefix, suffix) => {\n-                    (0..prefix + suffix).map(|_| Pat::wildcard_from_ty(ty)).collect()\n+\n+        match self {\n+            Single | Variant(_) => match ty.kind {\n+                ty::Tuple(ref fs) => {\n+                    fs.into_iter().map(|t| t.expect_ty()).map(Pat::wildcard_from_ty).collect()\n                 }\n-                ConstantValue(..) => vec![],\n-                _ => bug!(\"bad slice pattern {:?} {:?}\", self, ty),\n-            },\n-            ty::Ref(_, rty, _) => vec![Pat::wildcard_from_ty(rty)],\n-            ty::Adt(adt, substs) => {\n-                if adt.is_box() {\n-                    // Use T as the sub pattern type of Box<T>.\n-                    vec![Pat::wildcard_from_ty(substs.type_at(0))]\n-                } else {\n-                    let variant = &adt.variants[self.variant_index_for_adt(cx, adt)];\n-                    let is_non_exhaustive =\n-                        variant.is_field_list_non_exhaustive() && !cx.is_local(ty);\n-                    variant\n-                        .fields\n-                        .iter()\n-                        .map(|field| {\n-                            let is_visible =\n-                                adt.is_enum() || field.vis.is_accessible_from(cx.module, cx.tcx);\n-                            let is_uninhabited = cx.is_uninhabited(field.ty(cx.tcx, substs));\n-                            match (is_visible, is_non_exhaustive, is_uninhabited) {\n-                                // Treat all uninhabited types in non-exhaustive variants as\n-                                // `TyErr`.\n-                                (_, true, true) => cx.tcx.types.err,\n-                                // Treat all non-visible fields as `TyErr`. They can't appear in\n-                                // any other pattern from this match (because they are private), so\n-                                // their type does not matter - but we don't want to know they are\n-                                // uninhabited.\n-                                (false, ..) => cx.tcx.types.err,\n-                                (true, ..) => {\n-                                    let ty = field.ty(cx.tcx, substs);\n-                                    match ty.kind {\n-                                        // If the field type returned is an array of an unknown\n-                                        // size return an TyErr.\n-                                        ty::Array(_, len)\n-                                            if len\n-                                                .try_eval_usize(cx.tcx, cx.param_env)\n-                                                .is_none() =>\n-                                        {\n-                                            cx.tcx.types.err\n+                ty::Ref(_, rty, _) => vec![Pat::wildcard_from_ty(rty)],\n+                ty::Adt(adt, substs) => {\n+                    if adt.is_box() {\n+                        // Use T as the sub pattern type of Box<T>.\n+                        vec![Pat::wildcard_from_ty(substs.type_at(0))]\n+                    } else {\n+                        let variant = &adt.variants[self.variant_index_for_adt(cx, adt)];\n+                        let is_non_exhaustive =\n+                            variant.is_field_list_non_exhaustive() && !cx.is_local(ty);\n+                        variant\n+                            .fields\n+                            .iter()\n+                            .map(|field| {\n+                                let is_visible = adt.is_enum()\n+                                    || field.vis.is_accessible_from(cx.module, cx.tcx);\n+                                let is_uninhabited = cx.is_uninhabited(field.ty(cx.tcx, substs));\n+                                match (is_visible, is_non_exhaustive, is_uninhabited) {\n+                                    // Treat all uninhabited types in non-exhaustive variants as\n+                                    // `TyErr`.\n+                                    (_, true, true) => cx.tcx.types.err,\n+                                    // Treat all non-visible fields as `TyErr`. They can't appear\n+                                    // in any other pattern from this match (because they are\n+                                    // private), so their type does not matter - but we don't want\n+                                    // to know they are uninhabited.\n+                                    (false, ..) => cx.tcx.types.err,\n+                                    (true, ..) => {\n+                                        let ty = field.ty(cx.tcx, substs);\n+                                        match ty.kind {\n+                                            // If the field type returned is an array of an unknown\n+                                            // size return an TyErr.\n+                                            ty::Array(_, len)\n+                                                if len\n+                                                    .try_eval_usize(cx.tcx, cx.param_env)\n+                                                    .is_none() =>\n+                                            {\n+                                                cx.tcx.types.err\n+                                            }\n+                                            _ => ty,\n                                         }\n-                                        _ => ty,\n                                     }\n                                 }\n-                            }\n-                        })\n-                        .map(Pat::wildcard_from_ty)\n-                        .collect()\n+                            })\n+                            .map(Pat::wildcard_from_ty)\n+                            .collect()\n+                    }\n                 }\n-            }\n-            _ => vec![],\n+                _ => vec![],\n+            },\n+            FixedLenSlice(_) | VarLenSlice(..) => match ty.kind {\n+                ty::Slice(ty) | ty::Array(ty, _) => {\n+                    let arity = self.arity(cx, ty);\n+                    (0..arity).map(|_| Pat::wildcard_from_ty(ty)).collect()\n+                }\n+                _ => bug!(\"bad slice pattern {:?} {:?}\", self, ty),\n+            },\n+            ConstantValue(..) | ConstantRange(..) | NonExhaustive => vec![],\n         }\n     }\n \n@@ -850,19 +851,19 @@ impl<'tcx> Constructor<'tcx> {\n     /// A struct pattern's arity is the number of fields it contains, etc.\n     fn arity<'a>(&self, cx: &MatchCheckCtxt<'a, 'tcx>, ty: Ty<'tcx>) -> u64 {\n         debug!(\"Constructor::arity({:#?}, {:?})\", self, ty);\n-        match ty.kind {\n-            ty::Tuple(ref fs) => fs.len() as u64,\n-            ty::Slice(..) | ty::Array(..) => match *self {\n-                FixedLenSlice(length) => length,\n-                VarLenSlice(prefix, suffix) => prefix + suffix,\n-                ConstantValue(..) => 0,\n-                _ => bug!(\"bad slice pattern {:?} {:?}\", self, ty),\n+        match self {\n+            Single | Variant(_) => match ty.kind {\n+                ty::Tuple(ref fs) => fs.len() as u64,\n+                ty::Slice(..) | ty::Array(..) => bug!(\"bad slice pattern {:?} {:?}\", self, ty),\n+                ty::Ref(..) => 1,\n+                ty::Adt(adt, _) => {\n+                    adt.variants[self.variant_index_for_adt(cx, adt)].fields.len() as u64\n+                }\n+                _ => 0,\n             },\n-            ty::Ref(..) => 1,\n-            ty::Adt(adt, _) => {\n-                adt.variants[self.variant_index_for_adt(cx, adt)].fields.len() as u64\n-            }\n-            _ => 0,\n+            FixedLenSlice(length) => *length,\n+            VarLenSlice(prefix, suffix) => prefix + suffix,\n+            ConstantValue(..) | ConstantRange(..) | NonExhaustive => 0,\n         }\n     }\n \n@@ -886,53 +887,50 @@ impl<'tcx> Constructor<'tcx> {\n         pats: impl IntoIterator<Item = Pat<'tcx>>,\n     ) -> Pat<'tcx> {\n         let mut subpatterns = pats.into_iter();\n-        let pat = match ty.kind {\n-            ty::Adt(..) | ty::Tuple(..) => {\n-                let subpatterns = subpatterns\n-                    .enumerate()\n-                    .map(|(i, p)| FieldPat { field: Field::new(i), pattern: p })\n-                    .collect();\n-\n-                if let ty::Adt(adt, substs) = ty.kind {\n-                    if adt.is_enum() {\n-                        PatKind::Variant {\n-                            adt_def: adt,\n-                            substs,\n-                            variant_index: self.variant_index_for_adt(cx, adt),\n-                            subpatterns,\n+\n+        let pat = match self {\n+            Single | Variant(_) => match ty.kind {\n+                ty::Adt(..) | ty::Tuple(..) => {\n+                    let subpatterns = subpatterns\n+                        .enumerate()\n+                        .map(|(i, p)| FieldPat { field: Field::new(i), pattern: p })\n+                        .collect();\n+\n+                    if let ty::Adt(adt, substs) = ty.kind {\n+                        if adt.is_enum() {\n+                            PatKind::Variant {\n+                                adt_def: adt,\n+                                substs,\n+                                variant_index: self.variant_index_for_adt(cx, adt),\n+                                subpatterns,\n+                            }\n+                        } else {\n+                            PatKind::Leaf { subpatterns }\n                         }\n                     } else {\n                         PatKind::Leaf { subpatterns }\n                     }\n-                } else {\n-                    PatKind::Leaf { subpatterns }\n-                }\n-            }\n-\n-            ty::Ref(..) => PatKind::Deref { subpattern: subpatterns.nth(0).unwrap() },\n-\n-            ty::Slice(_) | ty::Array(..) => match self {\n-                FixedLenSlice(_) => {\n-                    PatKind::Slice { prefix: subpatterns.collect(), slice: None, suffix: vec![] }\n                 }\n-                VarLenSlice(prefix_len, _suffix_len) => {\n-                    let prefix = subpatterns.by_ref().take(*prefix_len as usize).collect();\n-                    let suffix = subpatterns.collect();\n-                    let wild = Pat::wildcard_from_ty(ty);\n-                    PatKind::Slice { prefix, slice: Some(wild), suffix }\n-                }\n-                _ => bug!(\"bad slice pattern {:?} {:?}\", self, ty),\n-            },\n-\n-            _ => match *self {\n-                ConstantValue(value, _) => PatKind::Constant { value },\n-                ConstantRange(lo, hi, ty, end, _) => PatKind::Range(PatRange {\n-                    lo: ty::Const::from_bits(cx.tcx, lo, ty::ParamEnv::empty().and(ty)),\n-                    hi: ty::Const::from_bits(cx.tcx, hi, ty::ParamEnv::empty().and(ty)),\n-                    end,\n-                }),\n+                ty::Ref(..) => PatKind::Deref { subpattern: subpatterns.nth(0).unwrap() },\n+                ty::Slice(_) | ty::Array(..) => bug!(\"bad slice pattern {:?} {:?}\", self, ty),\n                 _ => PatKind::Wild,\n             },\n+            FixedLenSlice(_) => {\n+                PatKind::Slice { prefix: subpatterns.collect(), slice: None, suffix: vec![] }\n+            }\n+            &VarLenSlice(prefix_len, _) => {\n+                let prefix = subpatterns.by_ref().take(prefix_len as usize).collect();\n+                let suffix = subpatterns.collect();\n+                let wild = Pat::wildcard_from_ty(ty);\n+                PatKind::Slice { prefix, slice: Some(wild), suffix }\n+            }\n+            &ConstantValue(value, _) => PatKind::Constant { value },\n+            &ConstantRange(lo, hi, ty, end, _) => PatKind::Range(PatRange {\n+                lo: ty::Const::from_bits(cx.tcx, lo, ty::ParamEnv::empty().and(ty)),\n+                hi: ty::Const::from_bits(cx.tcx, hi, ty::ParamEnv::empty().and(ty)),\n+                end,\n+            }),\n+            NonExhaustive => PatKind::Wild,\n         };\n \n         Pat { ty, span: DUMMY_SP, kind: Box::new(pat) }\n@@ -1128,7 +1126,7 @@ fn all_constructors<'a, 'tcx>(\n     pcx: PatCtxt<'tcx>,\n ) -> Vec<Constructor<'tcx>> {\n     debug!(\"all_constructors({:?})\", pcx.ty);\n-    let ctors = match pcx.ty.kind {\n+    match pcx.ty.kind {\n         ty::Bool => [true, false]\n             .iter()\n             .map(|&b| ConstantValue(ty::Const::from_bool(cx.tcx, b), pcx.span))\n@@ -1145,17 +1143,49 @@ fn all_constructors<'a, 'tcx>(\n                 vec![VarLenSlice(0, 0)]\n             }\n         }\n-        ty::Adt(def, substs) if def.is_enum() => def\n-            .variants\n-            .iter()\n-            .filter(|v| {\n-                !cx.tcx.features().exhaustive_patterns\n-                    || !v\n-                        .uninhabited_from(cx.tcx, substs, def.adt_kind())\n-                        .contains(cx.tcx, cx.module)\n-            })\n-            .map(|v| Variant(v.def_id))\n-            .collect(),\n+        ty::Adt(def, substs) if def.is_enum() => {\n+            let ctors: Vec<_> = def\n+                .variants\n+                .iter()\n+                .filter(|v| {\n+                    !cx.tcx.features().exhaustive_patterns\n+                        || !v\n+                            .uninhabited_from(cx.tcx, substs, def.adt_kind())\n+                            .contains(cx.tcx, cx.module)\n+                })\n+                .map(|v| Variant(v.def_id))\n+                .collect();\n+\n+            // If our scrutinee is *privately* an empty enum, we must treat it as though it had an\n+            // \"unknown\" constructor (in that case, all other patterns obviously can't be variants)\n+            // to avoid exposing its emptyness. See the `match_privately_empty` test for details.\n+            // FIXME: currently the only way I know of something can be a privately-empty enum is\n+            // when the exhaustive_patterns feature flag is not present, so this is only needed for\n+            // that case.\n+            let is_privately_empty = ctors.is_empty() && !cx.is_uninhabited(pcx.ty);\n+            // If the enum is declared as `#[non_exhaustive]`, we treat it as if it had an\n+            // additionnal \"unknown\" constructor.\n+            let is_declared_nonexhaustive =\n+                def.is_variant_list_non_exhaustive() && !cx.is_local(pcx.ty);\n+\n+            if is_privately_empty || is_declared_nonexhaustive {\n+                // There is no point in enumerating all possible variants, because the user can't\n+                // actually match against them themselves. So we return only the fictitious\n+                // constructor.\n+                // E.g., in an example like:\n+                // ```\n+                //     let err: io::ErrorKind = ...;\n+                //     match err {\n+                //         io::ErrorKind::NotFound => {},\n+                //     }\n+                // ```\n+                // we don't want to show every possible IO error, but instead have only `_` as the\n+                // witness.\n+                vec![NonExhaustive]\n+            } else {\n+                ctors\n+            }\n+        }\n         ty::Char => {\n             vec![\n                 // The valid Unicode Scalar Value ranges.\n@@ -1175,6 +1205,15 @@ fn all_constructors<'a, 'tcx>(\n                 ),\n             ]\n         }\n+        ty::Int(_) | ty::Uint(_)\n+            if pcx.ty.is_ptr_sized_integral()\n+                && !cx.tcx.features().precise_pointer_size_matching =>\n+        {\n+            // `usize`/`isize` are not allowed to be matched exhaustively unless the\n+            // `precise_pointer_size_matching` feature is enabled. So we treat those types like\n+            // `#[non_exhaustive]` enums by returning a special unmatcheable constructor.\n+            vec![NonExhaustive]\n+        }\n         ty::Int(ity) => {\n             let bits = Integer::from_attr(&cx.tcx, SignedInt(ity)).size().bits() as u128;\n             let min = 1u128 << (bits - 1);\n@@ -1193,8 +1232,7 @@ fn all_constructors<'a, 'tcx>(\n                 vec![Single]\n             }\n         }\n-    };\n-    ctors\n+    }\n }\n \n /// An inclusive interval, used for precise integer exhaustiveness checking.\n@@ -1592,48 +1630,22 @@ pub fn is_useful<'p, 'a, 'tcx>(\n         let all_ctors = all_constructors(cx, pcx);\n         debug!(\"all_ctors = {:#?}\", all_ctors);\n \n-        let is_privately_empty = all_ctors.is_empty() && !cx.is_uninhabited(pcx.ty);\n-        let is_declared_nonexhaustive = cx.is_non_exhaustive_enum(pcx.ty) && !cx.is_local(pcx.ty);\n-\n         // `missing_ctors` is the set of constructors from the same type as the\n         // first column of `matrix` that are matched only by wildcard patterns\n         // from the first column.\n         //\n         // Therefore, if there is some pattern that is unmatched by `matrix`,\n         // it will still be unmatched if the first constructor is replaced by\n         // any of the constructors in `missing_ctors`\n-        //\n-        // However, if our scrutinee is *privately* an empty enum, we\n-        // must treat it as though it had an \"unknown\" constructor (in\n-        // that case, all other patterns obviously can't be variants)\n-        // to avoid exposing its emptyness. See the `match_privately_empty`\n-        // test for details.\n-        //\n-        // FIXME: currently the only way I know of something can\n-        // be a privately-empty enum is when the exhaustive_patterns\n-        // feature flag is not present, so this is only\n-        // needed for that case.\n-\n-        // Missing constructors are those that are not matched by any\n-        // non-wildcard patterns in the current column. To determine if\n-        // the set is empty, we can check that `.peek().is_none()`, so\n-        // we only fully construct them on-demand, because they're rarely used and can be big.\n-        let missing_ctors = MissingConstructors::new(cx.tcx, cx.param_env, all_ctors, used_ctors);\n \n-        debug!(\n-            \"missing_ctors.empty()={:#?} is_privately_empty={:#?} is_declared_nonexhaustive={:#?}\",\n-            missing_ctors.is_empty(),\n-            is_privately_empty,\n-            is_declared_nonexhaustive\n-        );\n+        // Missing constructors are those that are not matched by any non-wildcard patterns in the\n+        // current column. We only fully construct them on-demand, because they're rarely used and\n+        // can be big.\n+        let missing_ctors = MissingConstructors::new(cx.tcx, cx.param_env, all_ctors, used_ctors);\n \n-        // For privately empty and non-exhaustive enums, we work as if there were an \"extra\"\n-        // `_` constructor for the type, so we can never match over all constructors.\n-        let is_non_exhaustive = is_privately_empty\n-            || is_declared_nonexhaustive\n-            || (pcx.ty.is_ptr_sized_integral() && !cx.tcx.features().precise_pointer_size_matching);\n+        debug!(\"missing_ctors.empty()={:#?}\", missing_ctors.is_empty(),);\n \n-        if missing_ctors.is_empty() && !is_non_exhaustive {\n+        if missing_ctors.is_empty() {\n             let (all_ctors, _) = missing_ctors.into_inner();\n             split_grouped_constructors(cx.tcx, cx.param_env, pcx, all_ctors, matrix, DUMMY_SP, None)\n                 .into_iter()\n@@ -1662,26 +1674,9 @@ pub fn is_useful<'p, 'a, 'tcx>(\n             //\n             // we can report 3 witnesses: `S`, `E`, and `W`.\n             //\n-            // However, there are 2 cases where we don't want\n+            // However, there is a case where we don't want\n             // to do this and instead report a single `_` witness:\n-            //\n-            // 1) If the user is matching against a non-exhaustive\n-            // enum, there is no point in enumerating all possible\n-            // variants, because the user can't actually match\n-            // against them themselves, e.g., in an example like:\n-            // ```\n-            //     let err: io::ErrorKind = ...;\n-            //     match err {\n-            //         io::ErrorKind::NotFound => {},\n-            //     }\n-            // ```\n-            // we don't want to show every possible IO error,\n-            // but instead have `_` as the witness (this is\n-            // actually *required* if the user specified *all*\n-            // IO errors, but is probably what we want in every\n-            // case).\n-            //\n-            // 2) If the user didn't actually specify a constructor\n+            // if the user didn't actually specify a constructor\n             // in this arm, e.g., in\n             // ```\n             //     let x: (Direction, Direction, bool) = ...;\n@@ -1691,7 +1686,7 @@ pub fn is_useful<'p, 'a, 'tcx>(\n             // `(<direction-1>, <direction-2>, true)` - we are\n             // satisfied with `(_, _, true)`. In this case,\n             // `used_ctors` is empty.\n-            if is_non_exhaustive || missing_ctors.all_ctors_are_missing() {\n+            if missing_ctors.all_ctors_are_missing() {\n                 // All constructors are unused. Add a wild pattern\n                 // rather than each individual constructor.\n                 usefulness.apply_wildcard(pcx.ty)\n@@ -2218,13 +2213,21 @@ fn patterns_for_variant<'p, 'a: 'p, 'tcx>(\n /// fields filled with wild patterns.\n fn specialize_one_pattern<'p, 'a: 'p, 'q: 'p, 'tcx>(\n     cx: &mut MatchCheckCtxt<'a, 'tcx>,\n-    pat: &'q Pat<'tcx>,\n+    mut pat: &'q Pat<'tcx>,\n     constructor: &Constructor<'tcx>,\n     ctor_wild_subpatterns: &[&'p Pat<'tcx>],\n ) -> Option<PatStack<'p, 'tcx>> {\n+    while let PatKind::AscribeUserType { ref subpattern, .. } = *pat.kind {\n+        pat = subpattern;\n+    }\n+\n+    if let NonExhaustive = constructor {\n+        // Only a wildcard pattern can match the special extra constructor\n+        return if pat.is_wildcard() { Some(PatStack::default()) } else { None };\n+    }\n+\n     let result = match *pat.kind {\n-        PatKind::AscribeUserType { ref subpattern, .. } => PatStack::from_pattern(subpattern)\n-            .specialize_constructor(cx, constructor, ctor_wild_subpatterns),\n+        PatKind::AscribeUserType { .. } => bug!(), // Handled above\n \n         PatKind::Binding { .. } | PatKind::Wild => {\n             Some(PatStack::from_slice(ctor_wild_subpatterns))"}]}