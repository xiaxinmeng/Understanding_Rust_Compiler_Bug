{"sha": "7582a482c68ab641764d39a0c3428d9b7ce39603", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc1ODJhNDgyYzY4YWI2NDE3NjRkMzlhMGMzNDI4ZDliN2NlMzk2MDM=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-10-11T03:52:20Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-10-11T03:52:20Z"}, "message": "Copyedit sections 7 and 8 of the tutorial", "tree": {"sha": "7e7ca9da783d0e9def49a441acbf363932e0723b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7e7ca9da783d0e9def49a441acbf363932e0723b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7582a482c68ab641764d39a0c3428d9b7ce39603", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7582a482c68ab641764d39a0c3428d9b7ce39603", "html_url": "https://github.com/rust-lang/rust/commit/7582a482c68ab641764d39a0c3428d9b7ce39603", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7582a482c68ab641764d39a0c3428d9b7ce39603/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1a8b00a03a45c19a47165ce037ae703e4e71f202", "url": "https://api.github.com/repos/rust-lang/rust/commits/1a8b00a03a45c19a47165ce037ae703e4e71f202", "html_url": "https://github.com/rust-lang/rust/commit/1a8b00a03a45c19a47165ce037ae703e4e71f202"}], "stats": {"total": 145, "additions": 75, "deletions": 70}, "files": [{"sha": "01ca36f9e9b091a93f2546d4a0a39bb45f4b3d74", "filename": "doc/tutorial.md", "status": "modified", "additions": 75, "deletions": 70, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/7582a482c68ab641764d39a0c3428d9b7ce39603/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/7582a482c68ab641764d39a0c3428d9b7ce39603/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=7582a482c68ab641764d39a0c3428d9b7ce39603", "patch": "@@ -1010,22 +1010,22 @@ generics](#generics).\n \n # The Rust memory model\n \n-At this junction let's take a detour to explain the concepts involved\n+At this junction, let's take a detour to explain the concepts involved\n in Rust's memory model. We've seen some of Rust's pointer sigils (`@`,\n `~`, and `&`) float by in a few examples, and we aren't going to get\n much further without explaining them. Rust has a very particular\n approach to memory management that plays a significant role in shaping\n-the \"feel\" of the language. Understanding the memory landscape will\n-illuminate several of Rust's unique features as we encounter them.\n+the subjective experience of programming in the\n+language. Understanding the memory landscape will illuminate several\n+of Rust's unique features as we encounter them.\n \n Rust has three competing goals that inform its view of memory:\n \n-* Memory safety: Memory that is managed by and is accessible to the\n-  Rust language must be guaranteed to be valid. Under normal\n-  circumstances it must be impossible for Rust to trigger a\n-  segmentation fault or leak memory.\n-* Performance: High-performance low-level code must be able to employ\n-  a number of allocation strategies. Tracing garbage collection must be\n+* Memory safety: Memory that the Rust language can observe must be\n+  guaranteed to be valid. Under normal circumstances, it must be\n+  impossible for Rust to trigger a segmentation fault or leak memory.\n+* Performance: High-performance low-level code must be able to use\n+  a number of different allocation strategies. Tracing garbage collection must be\n   optional and, if it is not desired, memory safety must not be compromised.\n   Less performance-critical, high-level code should be able to employ a single,\n   garbage-collection-based, heap allocation strategy.\n@@ -1034,7 +1034,7 @@ Rust has three competing goals that inform its view of memory:\n \n ## How performance considerations influence the memory model\n \n-Most languages that offer strong memory safety guarantees rely upon a\n+Most languages that offer strong memory safety guarantees rely on a\n garbage-collected heap to manage all of the objects. This approach is\n straightforward both in concept and in implementation, but has\n significant costs. Languages that follow this path tend to\n@@ -1044,18 +1044,20 @@ boxes_: memory allocated on the heap whose lifetime is managed\n by the garbage collector.\n \n By comparison, languages like C++ offer very precise control over\n-where objects are allocated. In particular, it is common to put them\n+where objects are allocated. In particular, it is common to allocate them\n directly on the stack, avoiding expensive heap allocation. In Rust\n-this is possible as well, and the compiler will use a clever _pointer\n-lifetime analysis_ to ensure that no variable can refer to stack\n+this is possible as well, and the compiler uses a [clever _pointer\n+lifetime analysis_][borrow] to ensure that no variable can refer to stack\n objects after they are destroyed.\n \n+[borrow]: tutorial-borrowed-ptr.html\n+\n ## How concurrency considerations influence the memory model\n \n Memory safety in a concurrent environment involves avoiding race\n conditions between two threads of execution accessing the same\n-memory. Even high-level languages often require programmers to\n-correctly employ locking to ensure that a program is free of races.\n+memory. Even high-level languages often require programmers to make\n+correct use of locking to ensure that a program is free of races.\n \n Rust starts from the position that memory cannot be shared between\n tasks. Experience in other languages has proven that isolating each\n@@ -1064,28 +1066,30 @@ easy for programmers to reason about. Heap isolation has the\n additional benefit that garbage collection must only be done\n per-heap. Rust never \"stops the world\" to reclaim memory.\n \n-Complete isolation of heaps between tasks would, however, mean that any data\n-transferred between tasks must be copied. While this is a fine and\n-useful way to implement communication between tasks, it is also very\n-inefficient for large data structures.  Because of this, Rust also\n-employs a global _exchange heap_. Objects allocated in the exchange\n-heap have _ownership semantics_, meaning that there is only a single\n-variable that refers to them. For this reason, they are referred to as\n-_owned boxes_. All tasks may allocate objects on the exchange heap,\n-then transfer ownership of those objects to other tasks, avoiding\n-expensive copies.\n+Complete isolation of heaps between tasks would, however, mean that\n+any data transferred between tasks must be copied. While this is a\n+fine and useful way to implement communication between tasks, it is\n+also very inefficient for large data structures. To reduce the amount\n+of copying, Rust also uses a global _exchange heap_. Objects allocated\n+in the exchange heap have _ownership semantics_, meaning that there is\n+only a single variable that refers to them. For this reason, they are\n+referred to as _owned boxes_. All tasks may allocate objects on the\n+exchange heap, then transfer ownership of those objects to other\n+tasks, avoiding expensive copies.\n \n # Boxes and pointers\n \n-In contrast to a lot of modern languages, aggregate types like structs\n-and enums are _not_ represented as pointers to allocated memory in\n-Rust. They are, as in C and C++, represented directly. This means that\n-if you `let x = Point {x: 1f, y: 1f};`, you are creating a struct on the\n-stack. If you then copy it into a data structure, the whole struct is\n-copied, not just a pointer.\n+Many modern languages have a so-called \"uniform representation\" for\n+aggregate types like structs and enums, so as to represent these types\n+as pointers to heap memory by default. In contrast, Rust, like C and\n+C++, represents such types directly. Another way to say this is that\n+aggregate data in Rust are *unboxed*. This means that if you `let x =\n+Point {x: 1f, y: 1f};`, you are creating a struct on the stack. If you\n+then copy it into a data structure, you copy the entire struct, not\n+just a pointer.\n \n For small structs like `Point`, this is usually more efficient than\n-allocating memory and going through a pointer. But for big structs, or\n+allocating memory and indirecting through a pointer. But for big structs, or\n those with mutable fields, it can be useful to have a single copy on\n the stack or on the heap, and refer to that through a pointer.\n \n@@ -1100,16 +1104,15 @@ All pointer types can be dereferenced with the `*` unary operator.\n > ***Note***: You may also hear managed boxes referred to as 'shared\n > boxes' or 'shared pointers', and owned boxes as 'unique boxes/pointers'.\n > Borrowed pointers are sometimes called 'region pointers'. The preferred\n-> terminology is as presented here.\n+> terminology is what we present here.\n \n ## Managed boxes\n \n-Managed boxes are pointers to heap-allocated, garbage collected memory.\n-Creating a managed box is done by simply applying the unary `@`\n-operator to an expression. The result of the expression will be boxed,\n-resulting in a box of the right type. Copying a shared box, as happens\n-during assignment, only copies a pointer, never the contents of the\n-box.\n+Managed boxes are pointers to heap-allocated, garbage collected\n+memory.  Applying the unary `@` operator to an expression creates a\n+managed box. The resulting box contains the result of the\n+expression. Copying a shared box, as happens during assignment, only\n+copies a pointer, never the contents of the box.\n \n ~~~~\n let x: @int = @10; // New box\n@@ -1119,8 +1122,8 @@ let y = x; // Copy of a pointer to the same box\n // then the allocation will be freed.\n ~~~~\n \n-Any type that contains managed boxes or other managed types is\n-considered _managed_.\n+A _managed_ type is either of the form `@T` for some type `T`, or any\n+type that contains managed boxes or other managed types.\n \n ~~~\n // A linked list node\n@@ -1148,19 +1151,19 @@ node3.prev = SomeNode(node2);\n \n Managed boxes never cross task boundaries.\n \n-> ***Note:*** managed boxes are currently reclaimed through reference\n-> counting and cycle collection, but we will switch to a tracing\n-> garbage collector eventually.\n+> ***Note:*** Currently, the Rust compiler generates code to reclaim\n+> managed boxes through reference counting and a cycle collector, but\n+> we will switch to a tracing garbage collector eventually.\n \n ## Owned boxes\n \n-In contrast to managed boxes, owned boxes have a single owning memory\n-slot and thus two owned boxes may not refer to the same memory. All\n-owned boxes across all tasks are allocated on a single _exchange\n-heap_, where their uniquely owned nature allows them to be passed\n-between tasks efficiently.\n+In contrast with managed boxes, owned boxes have a single owning\n+memory slot and thus two owned boxes may not refer to the same\n+memory. All owned boxes across all tasks are allocated on a single\n+_exchange heap_, where their uniquely owned nature allows tasks to\n+exchange them efficiently.\n \n-Because owned boxes are uniquely owned, copying them involves allocating\n+Because owned boxes are uniquely owned, copying them requires allocating\n a new owned box and duplicating the contents. Copying owned boxes\n is expensive so the compiler will complain if you do so without writing\n the word `copy`.\n@@ -1180,11 +1183,11 @@ let z = *x + *y;\n assert z == 20;\n ~~~~\n \n-This is where the 'move' operator comes in. It is similar to\n-`copy`, but it de-initializes its source. Thus, the owned box can move\n-from `x` to `y`, without violating the constraint that it only has a\n-single owner (if you used assignment instead of the move operator, the\n-box would, in principle, be copied).\n+This is where the 'move' operator comes in. It is similar to `copy`,\n+but it de-initializes its source. Thus, the owned box can move from\n+`x` to `y`, without violating the constraint that it only has a single\n+owner (using assignment instead of the move operator would, in\n+principle, copy the box).\n \n ~~~~ {.xfail-test}\n let x = ~10;\n@@ -1198,16 +1201,16 @@ to other tasks. The sending task will give up ownership of the box,\n and won't be able to access it afterwards. The receiving task will\n become the sole owner of the box.\n \n-> ***Note:*** this discussion of copying vs moving does not account\n+> ***Note:*** This discussion of copying vs. moving does not account\n > for the \"last use\" rules that automatically promote copy operations\n-> to moves. Last use is expected to be removed from the language in\n+> to moves. We plan to remove last use from the language in\n > favor of explicit moves.\n \n ## Borrowed pointers\n \n Rust borrowed pointers are a general purpose reference/pointer type,\n similar to the C++ reference type, but guaranteed to point to valid\n-memory. In contrast to owned pointers, where the holder of a unique\n+memory. In contrast with owned pointers, where the holder of a unique\n pointer is the owner of the pointed-to memory, borrowed pointers never\n imply ownership. Pointers may be borrowed from any type, in which case\n the pointer is guaranteed not to outlive the value it points to.\n@@ -1220,9 +1223,9 @@ struct Point {\n }\n ~~~~\n \n-We can use this simple definition to allocate points in many ways. For\n-example, in this code, each of these three local variables contains a\n-point, but allocated in a different place:\n+We can use this simple definition to allocate points in many different\n+ways. For example, in this code, each of these three local variables\n+contains a point, but allocated in a different location:\n \n ~~~\n # struct Point { x: float, y: float }\n@@ -1306,7 +1309,8 @@ let sum = *managed + *owned + *borrowed;\n ~~~\n \n Dereferenced mutable pointers may appear on the left hand side of\n-assignments, in which case the value they point to is modified.\n+assignments. Such an assignment modifies the value that the pointer\n+points to.\n \n ~~~\n let managed = @mut 10;\n@@ -1321,8 +1325,8 @@ let borrowed = &mut value;\n ~~~\n \n Pointers have high operator precedence, but lower precedence than the\n-dot operator used for field and method access. This can lead to some\n-awkward code filled with parenthesis.\n+dot operator used for field and method access. This precedence order\n+can sometimes make code awkward and parenthesis-filled.\n \n ~~~\n # struct Point { x: float, y: float }\n@@ -1334,9 +1338,9 @@ let rect = &Rectangle(*start, *end);\n let area = (*rect).area();\n ~~~\n \n-To combat this ugliness the dot operator performs _automatic pointer\n-dereferencing_ on the receiver (the value on the left hand side of the\n-dot), so in most cases dereferencing the receiver is not necessary.\n+To combat this ugliness the dot operator applies _automatic pointer\n+dereferencing_ to the receiver (the value on the left hand side of the\n+dot), so in most cases, explicitly dereferencing the receiver is not necessary.\n \n ~~~\n # struct Point { x: float, y: float }\n@@ -1348,16 +1352,17 @@ let rect = &Rectangle(*start, *end);\n let area = rect.area();\n ~~~\n \n-Auto-dereferencing is performed through any number of pointers. If you\n-felt inclined you could write something silly like\n+You can write an expression that dereferences any number of pointers\n+automatically. For example, if you felt inclined, you could write\n+something silly like\n \n ~~~\n # struct Point { x: float, y: float }\n let point = &@~Point { x: 10f, y: 20f };\n io::println(fmt!(\"%f\", point.x));\n ~~~\n \n-The indexing operator (`[]`) is also auto-dereferencing.\n+The indexing operator (`[]`) also auto-dereferences.\n \n # Vectors and strings\n "}]}