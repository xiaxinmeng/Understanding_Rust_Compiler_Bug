{"sha": "590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU5MGFlMGVjNGQwYzc4MmY3Y2Y5N2NmZjc0NzRkYzQwMTJjMWI2MTU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-09-27T10:05:38Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-09-27T10:05:38Z"}, "message": "Auto merge of #64813 - varkor:node-to-kind, r=Centril\n\nRename `*.node` to `*.kind`, and `hair::Pattern*` to `hair::Pat*`\n\nIn both `ast::Expr` and `hir::Expr`:\n\n- Rename `Expr.node` to `Expr.kind`.\n- Rename `Pat.node` to `Pat.kind`.\n- Rename `ImplItem.node` to `ImplItem.kind`.\n- Rename `Lit.node` to `Lit.kind`.\n- Rename `TraitItem.node` to `TraitItem.kind`.\n- Rename `Ty.node` to `Ty.kind`.\n- Rename `Stmt.node` to `Stmt.kind`.\n- Rename `Item.node` to `Item.kind`.\n- Rename `ForeignItem.node` to `ForeignItem.kind`.\n- Rename `MetaItem.node` to `MetaItem.kind`.\n\nAlso:\n- Rename `hair::FieldPattern` to `hair::FieldPat`.\n- Rename `hair::PatternKind` to `hair::PatKind`.\n- Rename `hair::PatternRange` to `hair::PatRange`.\n- Rename `PatternContext` to `PatCtxt`.\n- Rename `PatternTypeProjection` to `PatTyProj`.\n- Rename `hair::Pattern` to `hair::Pat`.\n\nThese two sets of changes are grouped together to aid with merging. The only changes are renamings.\n\nr? @petrochenkov", "tree": {"sha": "6599f55c2c1113952f9a1d369773392252304b6e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6599f55c2c1113952f9a1d369773392252304b6e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "html_url": "https://github.com/rust-lang/rust/commit/590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "59367b074f1523353dddefa678ffe3cac9fd4e50", "url": "https://api.github.com/repos/rust-lang/rust/commits/59367b074f1523353dddefa678ffe3cac9fd4e50", "html_url": "https://github.com/rust-lang/rust/commit/59367b074f1523353dddefa678ffe3cac9fd4e50"}, {"sha": "80b63ddca59b16ca503f2f8306e9200102745426", "url": "https://api.github.com/repos/rust-lang/rust/commits/80b63ddca59b16ca503f2f8306e9200102745426", "html_url": "https://github.com/rust-lang/rust/commit/80b63ddca59b16ca503f2f8306e9200102745426"}], "stats": {"total": 3161, "additions": 1574, "deletions": 1587}, "files": [{"sha": "c946118b1ea195ebb827067cc1bbd41d0aac2a46", "filename": "src/librustc/hir/check_attr.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fcheck_attr.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -65,7 +65,7 @@ impl Display for Target {\n \n impl Target {\n     pub(crate) fn from_item(item: &hir::Item) -> Target {\n-        match item.node {\n+        match item.kind {\n             hir::ItemKind::ExternCrate(..) => Target::ExternCrate,\n             hir::ItemKind::Use(..) => Target::Use,\n             hir::ItemKind::Static(..) => Target::Static,\n@@ -262,7 +262,7 @@ impl CheckAttrVisitor<'tcx> {\n \n     fn check_stmt_attributes(&self, stmt: &hir::Stmt) {\n         // When checking statements ignore expressions, they will be checked later\n-        if let hir::StmtKind::Local(ref l) = stmt.node {\n+        if let hir::StmtKind::Local(ref l) = stmt.kind {\n             for attr in l.attrs.iter() {\n                 if attr.check_name(sym::inline) {\n                     self.check_inline(attr, &stmt.span, Target::Statement);\n@@ -280,7 +280,7 @@ impl CheckAttrVisitor<'tcx> {\n     }\n \n     fn check_expr_attributes(&self, expr: &hir::Expr) {\n-        let target = match expr.node {\n+        let target = match expr.kind {\n             hir::ExprKind::Closure(..) => Target::Closure,\n             _ => Target::Expression,\n         };\n@@ -333,7 +333,7 @@ impl Visitor<'tcx> for CheckAttrVisitor<'tcx> {\n }\n \n fn is_c_like_enum(item: &hir::Item) -> bool {\n-    if let hir::ItemKind::Enum(ref def, _) = item.node {\n+    if let hir::ItemKind::Enum(ref def, _) = item.kind {\n         for variant in &def.variants {\n             match variant.data {\n                 hir::VariantData::Unit(..) => { /* continue */ }"}, {"sha": "d1ebdd2f086ab3b55164ef706f314140ca08dab2", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -465,7 +465,7 @@ pub fn walk_param<'v, V: Visitor<'v>>(visitor: &mut V, param: &'v Param) {\n pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item) {\n     visitor.visit_vis(&item.vis);\n     visitor.visit_ident(item.ident);\n-    match item.node {\n+    match item.kind {\n         ItemKind::ExternCrate(orig_name) => {\n             visitor.visit_id(item.hir_id);\n             if let Some(orig_name) = orig_name {\n@@ -594,7 +594,7 @@ pub fn walk_variant<'v, V: Visitor<'v>>(visitor: &mut V,\n pub fn walk_ty<'v, V: Visitor<'v>>(visitor: &mut V, typ: &'v Ty) {\n     visitor.visit_id(typ.hir_id);\n \n-    match typ.node {\n+    match typ.kind {\n         TyKind::Slice(ref ty) => {\n             visitor.visit_ty(ty)\n         }\n@@ -696,7 +696,7 @@ pub fn walk_assoc_type_binding<'v, V: Visitor<'v>>(visitor: &mut V,\n \n pub fn walk_pat<'v, V: Visitor<'v>>(visitor: &mut V, pattern: &'v Pat) {\n     visitor.visit_id(pattern.hir_id);\n-    match pattern.node {\n+    match pattern.kind {\n         PatKind::TupleStruct(ref qpath, ref children, _) => {\n             visitor.visit_qpath(qpath, pattern.hir_id, pattern.span);\n             walk_list!(visitor, visit_pat, children);\n@@ -743,7 +743,7 @@ pub fn walk_foreign_item<'v, V: Visitor<'v>>(visitor: &mut V, foreign_item: &'v\n     visitor.visit_vis(&foreign_item.vis);\n     visitor.visit_ident(foreign_item.ident);\n \n-    match foreign_item.node {\n+    match foreign_item.kind {\n         ForeignItemKind::Fn(ref function_declaration, ref param_names, ref generics) => {\n             visitor.visit_generics(generics);\n             visitor.visit_fn_decl(function_declaration);\n@@ -856,7 +856,7 @@ pub fn walk_trait_item<'v, V: Visitor<'v>>(visitor: &mut V, trait_item: &'v Trai\n     visitor.visit_ident(trait_item.ident);\n     walk_list!(visitor, visit_attribute, &trait_item.attrs);\n     visitor.visit_generics(&trait_item.generics);\n-    match trait_item.node {\n+    match trait_item.kind {\n         TraitItemKind::Const(ref ty, default) => {\n             visitor.visit_id(trait_item.hir_id);\n             visitor.visit_ty(ty);\n@@ -905,7 +905,7 @@ pub fn walk_impl_item<'v, V: Visitor<'v>>(visitor: &mut V, impl_item: &'v ImplIt\n         ref defaultness,\n         ref attrs,\n         ref generics,\n-        ref node,\n+        ref kind,\n         span: _,\n     } = *impl_item;\n \n@@ -914,7 +914,7 @@ pub fn walk_impl_item<'v, V: Visitor<'v>>(visitor: &mut V, impl_item: &'v ImplIt\n     visitor.visit_defaultness(defaultness);\n     walk_list!(visitor, visit_attribute, attrs);\n     visitor.visit_generics(generics);\n-    match *node {\n+    match *kind {\n         ImplItemKind::Const(ref ty, body) => {\n             visitor.visit_id(impl_item.hir_id);\n             visitor.visit_ty(ty);\n@@ -974,7 +974,7 @@ pub fn walk_block<'v, V: Visitor<'v>>(visitor: &mut V, block: &'v Block) {\n \n pub fn walk_stmt<'v, V: Visitor<'v>>(visitor: &mut V, statement: &'v Stmt) {\n     visitor.visit_id(statement.hir_id);\n-    match statement.node {\n+    match statement.kind {\n         StmtKind::Local(ref local) => visitor.visit_local(local),\n         StmtKind::Item(item) => visitor.visit_nested_item(item),\n         StmtKind::Expr(ref expression) |\n@@ -992,7 +992,7 @@ pub fn walk_anon_const<'v, V: Visitor<'v>>(visitor: &mut V, constant: &'v AnonCo\n pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr) {\n     visitor.visit_id(expression.hir_id);\n     walk_list!(visitor, visit_attribute, expression.attrs.iter());\n-    match expression.node {\n+    match expression.kind {\n         ExprKind::Box(ref subexpression) => {\n             visitor.visit_expr(subexpression)\n         }"}, {"sha": "d0a9d967a649d7037091f84bce2d0ccd9982cf3a", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 40, "deletions": 39, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -346,7 +346,7 @@ struct ImplTraitTypeIdVisitor<'a> { ids: &'a mut SmallVec<[NodeId; 1]> }\n \n impl<'a, 'b> Visitor<'a> for ImplTraitTypeIdVisitor<'b> {\n     fn visit_ty(&mut self, ty: &'a Ty) {\n-        match ty.node {\n+        match ty.kind {\n             | TyKind::Typeof(_)\n             | TyKind::BareFn(_)\n             => return,\n@@ -425,7 +425,7 @@ impl<'a> LoweringContext<'a> {\n \n         impl<'tcx, 'interner> Visitor<'tcx> for MiscCollector<'tcx, 'interner> {\n             fn visit_pat(&mut self, p: &'tcx Pat) {\n-                if let PatKind::Paren(..) | PatKind::Rest = p.node {\n+                if let PatKind::Paren(..) | PatKind::Rest = p.kind {\n                     // Doesn't generate a HIR node\n                 } else if let Some(owner) = self.hir_id_owner {\n                     self.lctx.lower_node_id_with_owner(p.id, owner);\n@@ -437,7 +437,7 @@ impl<'a> LoweringContext<'a> {\n             fn visit_item(&mut self, item: &'tcx Item) {\n                 let hir_id = self.lctx.allocate_hir_id_counter(item.id);\n \n-                match item.node {\n+                match item.kind {\n                     ItemKind::Struct(_, ref generics)\n                     | ItemKind::Union(_, ref generics)\n                     | ItemKind::Enum(_, ref generics)\n@@ -469,7 +469,7 @@ impl<'a> LoweringContext<'a> {\n             fn visit_trait_item(&mut self, item: &'tcx TraitItem) {\n                 self.lctx.allocate_hir_id_counter(item.id);\n \n-                match item.node {\n+                match item.kind {\n                     TraitItemKind::Method(_, None) => {\n                         // Ignore patterns in trait methods without bodies\n                         self.with_hir_id_owner(None, |this| {\n@@ -497,7 +497,7 @@ impl<'a> LoweringContext<'a> {\n             }\n \n             fn visit_ty(&mut self, t: &'tcx Ty) {\n-                match t.node {\n+                match t.kind {\n                     // Mirrors the case in visit::walk_ty\n                     TyKind::BareFn(ref f) => {\n                         walk_list!(\n@@ -1104,7 +1104,7 @@ impl<'a> LoweringContext<'a> {\n                         let ty = this.lower_ty(\n                             &Ty {\n                                 id: this.sess.next_node_id(),\n-                                node: TyKind::ImplTrait(impl_trait_node_id, bounds.clone()),\n+                                kind: TyKind::ImplTrait(impl_trait_node_id, bounds.clone()),\n                                 span: constraint.span,\n                             },\n                             itctx,\n@@ -1165,14 +1165,14 @@ impl<'a> LoweringContext<'a> {\n         let id = self.lower_node_id(t.id);\n         let qpath = self.lower_qpath(t.id, qself, path, param_mode, itctx);\n         let ty = self.ty_path(id, t.span, qpath);\n-        if let hir::TyKind::TraitObject(..) = ty.node {\n+        if let hir::TyKind::TraitObject(..) = ty.kind {\n             self.maybe_lint_bare_trait(t.span, t.id, qself.is_none() && path.is_global());\n         }\n         ty\n     }\n \n     fn lower_ty_direct(&mut self, t: &Ty, mut itctx: ImplTraitContext<'_>) -> hir::Ty {\n-        let kind = match t.node {\n+        let kind = match t.kind {\n             TyKind::Infer => hir::TyKind::Infer,\n             TyKind::Err => hir::TyKind::Err,\n             TyKind::Slice(ref ty) => hir::TyKind::Slice(self.lower_ty(ty, itctx)),\n@@ -1345,7 +1345,7 @@ impl<'a> LoweringContext<'a> {\n         };\n \n         hir::Ty {\n-            node: kind,\n+            kind,\n             span: t.span,\n             hir_id: self.lower_node_id(t.id),\n         }\n@@ -1445,7 +1445,7 @@ impl<'a> LoweringContext<'a> {\n             hir_id: opaque_ty_id,\n             ident: Ident::invalid(),\n             attrs: Default::default(),\n-            node: opaque_ty_item_kind,\n+            kind: opaque_ty_item_kind,\n             vis: respan(span.shrink_to_lo(), hir::VisibilityKind::Inherited),\n             span: opaque_ty_span,\n         };\n@@ -1505,7 +1505,7 @@ impl<'a> LoweringContext<'a> {\n \n             fn visit_ty(&mut self, t: &'v hir::Ty) {\n                 // Don't collect elided lifetimes used inside of `fn()` syntax.\n-                if let hir::TyKind::BareFn(_) = t.node {\n+                if let hir::TyKind::BareFn(_) = t.kind {\n                     let old_collect_elided_lifetimes = self.collect_elided_lifetimes;\n                     self.collect_elided_lifetimes = false;\n \n@@ -2026,7 +2026,7 @@ impl<'a> LoweringContext<'a> {\n                     .map(|ty| this.lower_ty_direct(ty, ImplTraitContext::disallowed()))\n                     .collect();\n                 let mk_tup = |this: &mut Self, tys, span| {\n-                    hir::Ty { node: hir::TyKind::Tup(tys), hir_id: this.next_id(), span }\n+                    hir::Ty { kind: hir::TyKind::Tup(tys), hir_id: this.next_id(), span }\n                 };\n                 (\n                     hir::GenericArgs {\n@@ -2095,7 +2095,7 @@ impl<'a> LoweringContext<'a> {\n     fn lower_fn_params_to_names(&mut self, decl: &FnDecl) -> hir::HirVec<Ident> {\n         decl.inputs\n             .iter()\n-            .map(|param| match param.pat.node {\n+            .map(|param| match param.pat.kind {\n                 PatKind::Ident(_, ident, _) => ident,\n                 _ => Ident::new(kw::Invalid, param.pat.span),\n             })\n@@ -2172,23 +2172,23 @@ impl<'a> LoweringContext<'a> {\n             implicit_self: decl.inputs.get(0).map_or(\n                 hir::ImplicitSelfKind::None,\n                 |arg| {\n-                    let is_mutable_pat = match arg.pat.node {\n+                    let is_mutable_pat = match arg.pat.kind {\n                         PatKind::Ident(BindingMode::ByValue(mt), _, _) |\n                         PatKind::Ident(BindingMode::ByRef(mt), _, _) =>\n                             mt == Mutability::Mutable,\n                         _ => false,\n                     };\n \n-                    match arg.ty.node {\n+                    match arg.ty.kind {\n                         TyKind::ImplicitSelf if is_mutable_pat => hir::ImplicitSelfKind::Mut,\n                         TyKind::ImplicitSelf => hir::ImplicitSelfKind::Imm,\n                         // Given we are only considering `ImplicitSelf` types, we needn't consider\n                         // the case where we have a mutable pattern to a reference as that would\n                         // no longer be an `ImplicitSelf`.\n-                        TyKind::Rptr(_, ref mt) if mt.ty.node.is_implicit_self() &&\n+                        TyKind::Rptr(_, ref mt) if mt.ty.kind.is_implicit_self() &&\n                             mt.mutbl == ast::Mutability::Mutable =>\n                                 hir::ImplicitSelfKind::MutRef,\n-                        TyKind::Rptr(_, ref mt) if mt.ty.node.is_implicit_self() =>\n+                        TyKind::Rptr(_, ref mt) if mt.ty.kind.is_implicit_self() =>\n                             hir::ImplicitSelfKind::ImmRef,\n                         _ => hir::ImplicitSelfKind::None,\n                     }\n@@ -2403,7 +2403,7 @@ impl<'a> LoweringContext<'a> {\n         let opaque_ty_ref = hir::TyKind::Def(hir::ItemId { id: opaque_ty_id }, generic_args.into());\n \n         hir::FunctionRetTy::Return(P(hir::Ty {\n-            node: opaque_ty_ref,\n+            kind: opaque_ty_ref,\n             span,\n             hir_id: self.next_id(),\n         }))\n@@ -2424,7 +2424,7 @@ impl<'a> LoweringContext<'a> {\n             FunctionRetTy::Default(ret_ty_span) => {\n                 P(hir::Ty {\n                     hir_id: self.next_id(),\n-                    node: hir::TyKind::Tup(hir_vec![]),\n+                    kind: hir::TyKind::Tup(hir_vec![]),\n                     span: *ret_ty_span,\n                 })\n             }\n@@ -2660,7 +2660,7 @@ impl<'a> LoweringContext<'a> {\n \n         for (index, stmt) in b.stmts.iter().enumerate() {\n             if index == b.stmts.len() - 1 {\n-                if let StmtKind::Expr(ref e) = stmt.node {\n+                if let StmtKind::Expr(ref e) = stmt.kind {\n                     expr = Some(P(self.lower_expr(e)));\n                 } else {\n                     stmts.extend(self.lower_stmt(stmt));\n@@ -2688,7 +2688,7 @@ impl<'a> LoweringContext<'a> {\n     }\n \n     fn lower_pat(&mut self, p: &Pat) -> P<hir::Pat> {\n-        let node = match p.node {\n+        let node = match p.kind {\n             PatKind::Wild => hir::PatKind::Wild,\n             PatKind::Ident(ref binding_mode, ident, ref sub) => {\n                 let lower_sub = |this: &mut Self| sub.as_ref().map(|x| this.lower_pat(x));\n@@ -2805,7 +2805,7 @@ impl<'a> LoweringContext<'a> {\n         let mut iter = pats.iter();\n         while let Some(pat) = iter.next() {\n             // Interpret the first `((ref mut?)? x @)? ..` pattern as a subslice pattern.\n-            match pat.node {\n+            match pat.kind {\n                 PatKind::Rest => {\n                     prev_rest_span = Some(pat.span);\n                     slice = Some(self.pat_wild_with_node_id_of(pat));\n@@ -2827,7 +2827,7 @@ impl<'a> LoweringContext<'a> {\n \n         while let Some(pat) = iter.next() {\n             // There was a previous subslice pattern; make sure we don't allow more.\n-            let rest_span = match pat.node {\n+            let rest_span = match pat.kind {\n                 PatKind::Rest => Some(pat.span),\n                 PatKind::Ident(.., Some(ref sub)) if sub.is_rest() => {\n                     // The `HirValidator` is merciless; add a `_` pattern to avoid ICEs.\n@@ -2884,10 +2884,10 @@ impl<'a> LoweringContext<'a> {\n     }\n \n     /// Construct a `Pat` with the `HirId` of `p.id` lowered.\n-    fn pat_with_node_id_of(&mut self, p: &Pat, node: hir::PatKind) -> P<hir::Pat> {\n+    fn pat_with_node_id_of(&mut self, p: &Pat, kind: hir::PatKind) -> P<hir::Pat> {\n         P(hir::Pat {\n             hir_id: self.lower_node_id(p.id),\n-            node,\n+            kind,\n             span: p.span,\n         })\n     }\n@@ -2931,7 +2931,7 @@ impl<'a> LoweringContext<'a> {\n     }\n \n     fn lower_stmt(&mut self, s: &Stmt) -> SmallVec<[hir::Stmt; 1]> {\n-        let node = match s.node {\n+        let kind = match s.kind {\n             StmtKind::Local(ref l) => {\n                 let (l, item_ids) = self.lower_local(l);\n                 let mut ids: SmallVec<[hir::Stmt; 1]> = item_ids\n@@ -2944,7 +2944,7 @@ impl<'a> LoweringContext<'a> {\n                 ids.push({\n                     hir::Stmt {\n                         hir_id: self.lower_node_id(s.id),\n-                        node: hir::StmtKind::Local(P(l)),\n+                        kind: hir::StmtKind::Local(P(l)),\n                         span: s.span,\n                     }\n                 });\n@@ -2962,7 +2962,7 @@ impl<'a> LoweringContext<'a> {\n \n                         hir::Stmt {\n                             hir_id,\n-                            node: hir::StmtKind::Item(item_id),\n+                            kind: hir::StmtKind::Item(item_id),\n                             span: s.span,\n                         }\n                     })\n@@ -2974,7 +2974,7 @@ impl<'a> LoweringContext<'a> {\n         };\n         smallvec![hir::Stmt {\n             hir_id: self.lower_node_id(s.id),\n-            node,\n+            kind,\n             span: s.span,\n         }]\n     }\n@@ -3011,8 +3011,8 @@ impl<'a> LoweringContext<'a> {\n \n     // Helper methods for building HIR.\n \n-    fn stmt(&mut self, span: Span, node: hir::StmtKind) -> hir::Stmt {\n-        hir::Stmt { span, node, hir_id: self.next_id() }\n+    fn stmt(&mut self, span: Span, kind: hir::StmtKind) -> hir::Stmt {\n+        hir::Stmt { span, kind, hir_id: self.next_id() }\n     }\n \n     fn stmt_expr(&mut self, span: Span, expr: hir::Expr) -> hir::Stmt {\n@@ -3112,7 +3112,7 @@ impl<'a> LoweringContext<'a> {\n         (\n             P(hir::Pat {\n                 hir_id,\n-                node: hir::PatKind::Binding(bm, hir_id, ident.with_span_pos(span), None),\n+                kind: hir::PatKind::Binding(bm, hir_id, ident.with_span_pos(span), None),\n                 span,\n             }),\n             hir_id\n@@ -3123,10 +3123,10 @@ impl<'a> LoweringContext<'a> {\n         self.pat(span, hir::PatKind::Wild)\n     }\n \n-    fn pat(&mut self, span: Span, pat: hir::PatKind) -> P<hir::Pat> {\n+    fn pat(&mut self, span: Span, kind: hir::PatKind) -> P<hir::Pat> {\n         P(hir::Pat {\n             hir_id: self.next_id(),\n-            node: pat,\n+            kind,\n             span,\n         })\n     }\n@@ -3164,7 +3164,7 @@ impl<'a> LoweringContext<'a> {\n     }\n \n     fn ty_path(&mut self, mut hir_id: hir::HirId, span: Span, qpath: hir::QPath) -> hir::Ty {\n-        let node = match qpath {\n+        let kind = match qpath {\n             hir::QPath::Resolved(None, path) => {\n                 // Turn trait object paths into `TyKind::TraitObject` instead.\n                 match path.res {\n@@ -3188,9 +3188,10 @@ impl<'a> LoweringContext<'a> {\n             }\n             _ => hir::TyKind::Path(qpath),\n         };\n+\n         hir::Ty {\n             hir_id,\n-            node,\n+            kind,\n             span,\n         }\n     }\n@@ -3378,7 +3379,7 @@ pub fn is_range_literal(sess: &Session, expr: &hir::Expr) -> bool {\n         }\n     };\n \n-    match expr.node {\n+    match expr.kind {\n         // All built-in range literals but `..=` and `..` desugar to `Struct`s.\n         ExprKind::Struct(ref qpath, _, _) => {\n             if let QPath::Resolved(None, ref path) = **qpath {\n@@ -3393,8 +3394,8 @@ pub fn is_range_literal(sess: &Session, expr: &hir::Expr) -> bool {\n \n         // `..=` desugars into `::std::ops::RangeInclusive::new(...)`.\n         ExprKind::Call(ref func, _) => {\n-            if let ExprKind::Path(QPath::TypeRelative(ref ty, ref segment)) = func.node {\n-                if let TyKind::Path(QPath::Resolved(None, ref path)) = ty.node {\n+            if let ExprKind::Path(QPath::TypeRelative(ref ty, ref segment)) = func.kind {\n+                if let TyKind::Path(QPath::Resolved(None, ref path)) = ty.kind {\n                     let new_call = segment.ident.as_str() == \"new\";\n                     return is_range_path(&path) && is_lit(sess, &expr.span) && new_call;\n                 }"}, {"sha": "caecc162c7866a63b0d8d3ea2da3ffb8b83e91c2", "filename": "src/librustc/hir/lowering/expr.rs", "status": "modified", "additions": 12, "deletions": 17, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -17,7 +17,7 @@ impl LoweringContext<'_> {\n     }\n \n     pub(super) fn lower_expr(&mut self, e: &Expr) -> hir::Expr {\n-        let kind = match e.node {\n+        let kind = match e.kind {\n             ExprKind::Box(ref inner) => hir::ExprKind::Box(P(self.lower_expr(inner))),\n             ExprKind::Array(ref exprs) => hir::ExprKind::Array(self.lower_exprs(exprs)),\n             ExprKind::Repeat(ref expr, ref count) => {\n@@ -54,7 +54,7 @@ impl LoweringContext<'_> {\n                 let ohs = P(self.lower_expr(ohs));\n                 hir::ExprKind::Unary(op, ohs)\n             }\n-            ExprKind::Lit(ref l) => hir::ExprKind::Lit(respan(l.span, l.node.clone())),\n+            ExprKind::Lit(ref l) => hir::ExprKind::Lit(respan(l.span, l.kind.clone())),\n             ExprKind::Cast(ref expr, ref ty) => {\n                 let expr = P(self.lower_expr(expr));\n                 hir::ExprKind::Cast(expr, self.lower_ty(ty, ImplTraitContext::disallowed()))\n@@ -184,7 +184,7 @@ impl LoweringContext<'_> {\n \n         hir::Expr {\n             hir_id: self.lower_node_id(e.id),\n-            node: kind,\n+            kind,\n             span: e.span,\n             attrs: e.attrs.clone(),\n         }\n@@ -282,7 +282,7 @@ impl LoweringContext<'_> {\n \n         // Handle then + scrutinee:\n         let then_expr = self.lower_block_expr(then);\n-        let (then_pat, scrutinee, desugar) = match cond.node {\n+        let (then_pat, scrutinee, desugar) = match cond.kind {\n             // `<pat> => <then>`:\n             ExprKind::Let(ref pat, ref scrutinee) => {\n                 let scrutinee = self.lower_expr(scrutinee);\n@@ -332,7 +332,7 @@ impl LoweringContext<'_> {\n \n         // Handle then + scrutinee:\n         let then_expr = self.lower_block_expr(body);\n-        let (then_pat, scrutinee, desugar, source) = match cond.node {\n+        let (then_pat, scrutinee, desugar, source) = match cond.kind {\n             ExprKind::Let(ref pat, ref scrutinee) => {\n                 // to:\n                 //\n@@ -459,7 +459,7 @@ impl LoweringContext<'_> {\n         });\n \n         // `static || -> <ret_ty> { body }`:\n-        let generator_node = hir::ExprKind::Closure(\n+        let generator_kind = hir::ExprKind::Closure(\n             capture_clause,\n             decl,\n             body_id,\n@@ -468,7 +468,7 @@ impl LoweringContext<'_> {\n         );\n         let generator = hir::Expr {\n             hir_id: self.lower_node_id(closure_node_id),\n-            node: generator_node,\n+            kind: generator_kind,\n             span,\n             attrs: ThinVec::new(),\n         };\n@@ -625,7 +625,7 @@ impl LoweringContext<'_> {\n         // loop { .. }\n         let loop_expr = P(hir::Expr {\n             hir_id: loop_hir_id,\n-            node: hir::ExprKind::Loop(\n+            kind: hir::ExprKind::Loop(\n                 loop_block,\n                 None,\n                 hir::LoopSource::Loop,\n@@ -1135,14 +1135,14 @@ impl LoweringContext<'_> {\n         ));\n \n         // `[opt_ident]: loop { ... }`\n-        let loop_expr = hir::ExprKind::Loop(\n+        let kind = hir::ExprKind::Loop(\n             loop_block,\n             self.lower_label(opt_label),\n             hir::LoopSource::ForLoop,\n         );\n         let loop_expr = P(hir::Expr {\n             hir_id: self.lower_node_id(e.id),\n-            node: loop_expr,\n+            kind,\n             span: e.span,\n             attrs: ThinVec::new(),\n         });\n@@ -1443,15 +1443,10 @@ impl LoweringContext<'_> {\n     pub(super) fn expr(\n         &mut self,\n         span: Span,\n-        node: hir::ExprKind,\n+        kind: hir::ExprKind,\n         attrs: ThinVec<Attribute>\n     ) -> hir::Expr {\n-        hir::Expr {\n-            hir_id: self.next_id(),\n-            node,\n-            span,\n-            attrs,\n-        }\n+        hir::Expr { hir_id: self.next_id(), kind, span, attrs }\n     }\n \n     fn field(&mut self, ident: Ident, expr: P<hir::Expr>, span: Span) -> hir::Field {"}, {"sha": "7159db736a7115b5f05fa1ace63ff3d15d0db07b", "filename": "src/librustc/hir/lowering/item.rs", "status": "modified", "additions": 23, "deletions": 24, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc%2Fhir%2Flowering%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc%2Fhir%2Flowering%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering%2Fitem.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -73,7 +73,7 @@ impl<'tcx, 'interner> Visitor<'tcx> for ItemLowerer<'tcx, 'interner> {\n         if let Some(hir_id) = item_hir_id {\n             self.lctx.with_parent_item_lifetime_defs(hir_id, |this| {\n                 let this = &mut ItemLowerer { lctx: this };\n-                if let ItemKind::Impl(.., ref opt_trait_ref, _, _) = item.node {\n+                if let ItemKind::Impl(.., ref opt_trait_ref, _, _) = item.kind {\n                     this.with_trait_impl_ref(opt_trait_ref, |this| {\n                         visit::walk_item(this, item)\n                     });\n@@ -119,7 +119,7 @@ impl LoweringContext<'_> {\n     ) -> T {\n         let old_len = self.in_scope_lifetimes.len();\n \n-        let parent_generics = match self.items.get(&parent_hir_id).unwrap().node {\n+        let parent_generics = match self.items.get(&parent_hir_id).unwrap().kind {\n             hir::ItemKind::Impl(_, _, _, ref generics, ..)\n             | hir::ItemKind::Trait(_, _, ref generics, ..) => {\n                 &generics.params[..]\n@@ -168,7 +168,7 @@ impl LoweringContext<'_> {\n     }\n \n     pub(super) fn lower_item_id(&mut self, i: &Item) -> SmallVec<[hir::ItemId; 1]> {\n-        let node_ids = match i.node {\n+        let node_ids = match i.kind {\n             ItemKind::Use(ref use_tree) => {\n                 let mut vec = smallvec![i.id];\n                 self.lower_item_id_use_tree(use_tree, i.id, &mut vec);\n@@ -235,7 +235,7 @@ impl LoweringContext<'_> {\n         }\n         let attrs = attrs.into();\n \n-        if let ItemKind::MacroDef(ref def) = i.node {\n+        if let ItemKind::MacroDef(ref def) = i.kind {\n             if !def.legacy || attr::contains_name(&i.attrs, sym::macro_export) {\n                 let body = self.lower_token_stream(def.stream());\n                 let hir_id = self.lower_node_id(i.id);\n@@ -254,13 +254,13 @@ impl LoweringContext<'_> {\n             return None;\n         }\n \n-        let node = self.lower_item_kind(i.id, &mut ident, &attrs, &mut vis, &i.node);\n+        let kind = self.lower_item_kind(i.id, &mut ident, &attrs, &mut vis, &i.kind);\n \n         Some(hir::Item {\n             hir_id: self.lower_node_id(i.id),\n             ident,\n             attrs,\n-            node,\n+            kind,\n             vis,\n             span: i.span,\n         })\n@@ -542,24 +542,23 @@ impl LoweringContext<'_> {\n                         let res = this.lower_res(res);\n                         let path =\n                             this.lower_path_extra(res, &path, ParamMode::Explicit, None);\n-                        let item = hir::ItemKind::Use(P(path), hir::UseKind::Single);\n+                        let kind = hir::ItemKind::Use(P(path), hir::UseKind::Single);\n                         let vis = this.rebuild_vis(&vis);\n \n                         this.insert_item(\n                             hir::Item {\n                                 hir_id: new_id,\n                                 ident,\n                                 attrs: attrs.into_iter().cloned().collect(),\n-                                node: item,\n+                                kind,\n                                 vis,\n                                 span,\n                             },\n                         );\n                     });\n                 }\n \n-                let path =\n-                    P(self.lower_path_extra(ret_res, &path, ParamMode::Explicit, None));\n+                let path = P(self.lower_path_extra(ret_res, &path, ParamMode::Explicit, None));\n                 hir::ItemKind::Use(path, hir::UseKind::Single)\n             }\n             UseTreeKind::Glob => {\n@@ -623,7 +622,7 @@ impl LoweringContext<'_> {\n                         let mut vis = this.rebuild_vis(&vis);\n                         let mut ident = *ident;\n \n-                        let item = this.lower_use_tree(use_tree,\n+                        let kind = this.lower_use_tree(use_tree,\n                                                        &prefix,\n                                                        id,\n                                                        &mut vis,\n@@ -635,7 +634,7 @@ impl LoweringContext<'_> {\n                                 hir_id: new_hir_id,\n                                 ident,\n                                 attrs: attrs.into_iter().cloned().collect(),\n-                                node: item,\n+                                kind,\n                                 vis,\n                                 span: use_tree.span,\n                             },\n@@ -712,7 +711,7 @@ impl LoweringContext<'_> {\n             hir_id: self.lower_node_id(i.id),\n             ident: i.ident,\n             attrs: self.lower_attrs(&i.attrs),\n-            node: match i.node {\n+            kind: match i.kind {\n                 ForeignItemKind::Fn(ref fdec, ref generics) => {\n                     let (generics, (fn_dec, fn_args)) = self.add_in_band_defs(\n                         generics,\n@@ -789,7 +788,7 @@ impl LoweringContext<'_> {\n     }\n \n     fn lower_struct_field(&mut self, (index, f): (usize, &StructField)) -> hir::StructField {\n-        let ty = if let TyKind::Path(ref qself, ref path) = f.ty.node {\n+        let ty = if let TyKind::Path(ref qself, ref path) = f.ty.kind {\n             let t = self.lower_path_ty(\n                 &f.ty,\n                 qself,\n@@ -818,7 +817,7 @@ impl LoweringContext<'_> {\n     fn lower_trait_item(&mut self, i: &TraitItem) -> hir::TraitItem {\n         let trait_item_def_id = self.resolver.definitions().local_def_id(i.id);\n \n-        let (generics, node) = match i.node {\n+        let (generics, kind) = match i.kind {\n             TraitItemKind::Const(ref ty, ref default) => (\n                 self.lower_generics(&i.generics, ImplTraitContext::disallowed()),\n                 hir::TraitItemKind::Const(\n@@ -852,14 +851,14 @@ impl LoweringContext<'_> {\n             }\n             TraitItemKind::Type(ref bounds, ref default) => {\n                 let generics = self.lower_generics(&i.generics, ImplTraitContext::disallowed());\n-                let node = hir::TraitItemKind::Type(\n+                let kind = hir::TraitItemKind::Type(\n                     self.lower_param_bounds(bounds, ImplTraitContext::disallowed()),\n                     default\n                         .as_ref()\n                         .map(|x| self.lower_ty(x, ImplTraitContext::disallowed())),\n                 );\n \n-                (generics, node)\n+                (generics, kind)\n             },\n             TraitItemKind::Macro(..) => bug!(\"macro item shouldn't exist at this point\"),\n         };\n@@ -869,13 +868,13 @@ impl LoweringContext<'_> {\n             ident: i.ident,\n             attrs: self.lower_attrs(&i.attrs),\n             generics,\n-            node,\n+            kind,\n             span: i.span,\n         }\n     }\n \n     fn lower_trait_item_ref(&mut self, i: &TraitItem) -> hir::TraitItemRef {\n-        let (kind, has_default) = match i.node {\n+        let (kind, has_default) = match i.kind {\n             TraitItemKind::Const(_, ref default) => {\n                 (hir::AssocItemKind::Const, default.is_some())\n             }\n@@ -902,7 +901,7 @@ impl LoweringContext<'_> {\n     fn lower_impl_item(&mut self, i: &ImplItem) -> hir::ImplItem {\n         let impl_item_def_id = self.resolver.definitions().local_def_id(i.id);\n \n-        let (generics, node) = match i.node {\n+        let (generics, kind) = match i.kind {\n             ImplItemKind::Const(ref ty, ref expr) => (\n                 self.lower_generics(&i.generics, ImplTraitContext::disallowed()),\n                 hir::ImplItemKind::Const(\n@@ -946,7 +945,7 @@ impl LoweringContext<'_> {\n             generics,\n             vis: self.lower_visibility(&i.vis, None),\n             defaultness: self.lower_defaultness(i.defaultness, true /* [1] */),\n-            node,\n+            kind,\n             span: i.span,\n         }\n \n@@ -960,7 +959,7 @@ impl LoweringContext<'_> {\n             span: i.span,\n             vis: self.lower_visibility(&i.vis, Some(i.id)),\n             defaultness: self.lower_defaultness(i.defaultness, true /* [1] */),\n-            kind: match i.node {\n+            kind: match i.kind {\n                 ImplItemKind::Const(..) => hir::AssocItemKind::Const,\n                 ImplItemKind::TyAlias(..) => hir::AssocItemKind::Type,\n                 ImplItemKind::OpaqueTy(..) => hir::AssocItemKind::OpaqueTy,\n@@ -1133,7 +1132,7 @@ impl LoweringContext<'_> {\n \n                 // Check if this is a binding pattern, if so, we can optimize and avoid adding a\n                 // `let <pat> = __argN;` statement. In this case, we do not rename the parameter.\n-                let (ident, is_simple_parameter) = match parameter.pat.node {\n+                let (ident, is_simple_parameter) = match parameter.pat.kind {\n                     hir::PatKind::Binding(hir::BindingAnnotation::Unannotated, _, ident, _) =>\n                         (ident, true),\n                     _ => {\n@@ -1343,7 +1342,7 @@ impl LoweringContext<'_> {\n                             );\n                         };\n                         // Check if the where clause type is a plain type parameter.\n-                        match bound_pred.bounded_ty.node {\n+                        match bound_pred.bounded_ty.kind {\n                             TyKind::Path(None, ref path)\n                                 if path.segments.len() == 1\n                                     && bound_pred.bound_generic_params.is_empty() =>"}, {"sha": "f670d5abe85e4b59f05fd53c9d8bd22df403d395", "filename": "src/librustc/hir/map/blocks.rs", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -37,19 +37,25 @@ trait MaybeFnLike { fn is_fn_like(&self) -> bool; }\n \n impl MaybeFnLike for ast::Item {\n     fn is_fn_like(&self) -> bool {\n-        match self.node { ast::ItemKind::Fn(..) => true, _ => false, }\n+        match self.kind {\n+            ast::ItemKind::Fn(..) => true,\n+            _ => false,\n+        }\n     }\n }\n \n impl MaybeFnLike for ast::ImplItem {\n     fn is_fn_like(&self) -> bool {\n-        match self.node { ast::ImplItemKind::Method(..) => true, _ => false, }\n+        match self.kind {\n+            ast::ImplItemKind::Method(..) => true,\n+            _ => false,\n+        }\n     }\n }\n \n impl MaybeFnLike for ast::TraitItem {\n     fn is_fn_like(&self) -> bool {\n-        match self.node {\n+        match self.kind {\n             ast::TraitItemKind::Method(_, ast::TraitMethod::Provided(_)) => true,\n             _ => false,\n         }\n@@ -58,7 +64,7 @@ impl MaybeFnLike for ast::TraitItem {\n \n impl MaybeFnLike for ast::Expr {\n     fn is_fn_like(&self) -> bool {\n-        match self.node {\n+        match self.kind {\n             ast::ExprKind::Closure(..) => true,\n             _ => false,\n         }\n@@ -212,7 +218,7 @@ impl<'a> FnLikeNode<'a> {\n         C: FnOnce(ClosureParts<'a>) -> A,\n     {\n         match self.node {\n-            map::Node::Item(i) => match i.node {\n+            map::Node::Item(i) => match i.kind {\n                 ast::ItemKind::Fn(ref decl, header, ref generics, block) =>\n                     item_fn(ItemFnParts {\n                         id: i.hir_id,\n@@ -227,21 +233,21 @@ impl<'a> FnLikeNode<'a> {\n                     }),\n                 _ => bug!(\"item FnLikeNode that is not fn-like\"),\n             },\n-            map::Node::TraitItem(ti) => match ti.node {\n+            map::Node::TraitItem(ti) => match ti.kind {\n                 ast::TraitItemKind::Method(ref sig, ast::TraitMethod::Provided(body)) => {\n                     method(ti.hir_id, ti.ident, sig, None, body, ti.span, &ti.attrs)\n                 }\n                 _ => bug!(\"trait method FnLikeNode that is not fn-like\"),\n             },\n             map::Node::ImplItem(ii) => {\n-                match ii.node {\n+                match ii.kind {\n                     ast::ImplItemKind::Method(ref sig, body) => {\n                         method(ii.hir_id, ii.ident, sig, Some(&ii.vis), body, ii.span, &ii.attrs)\n                     }\n                     _ => bug!(\"impl method FnLikeNode that is not fn-like\")\n                 }\n             },\n-            map::Node::Expr(e) => match e.node {\n+            map::Node::Expr(e) => match e.kind {\n                 ast::ExprKind::Closure(_, ref decl, block, _fn_decl_span, _gen) =>\n                     closure(ClosureParts::new(&decl, block, e.hir_id, e.span, &e.attrs)),\n                 _ => bug!(\"expr FnLikeNode that is not fn-like\"),"}, {"sha": "c69d682b6f796462633036a553566daa87e20ab7", "filename": "src/librustc/hir/map/collector.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -378,7 +378,7 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n         self.with_dep_node_owner(i.hir_id.owner, i, |this| {\n             this.insert(i.span, i.hir_id, Node::Item(i));\n             this.with_parent(i.hir_id, |this| {\n-                if let ItemKind::Struct(ref struct_def, _) = i.node {\n+                if let ItemKind::Struct(ref struct_def, _) = i.kind {\n                     // If this is a tuple or unit-like struct, register the constructor.\n                     if let Some(ctor_hir_id) = struct_def.ctor_hir_id() {\n                         this.insert(i.span, ctor_hir_id, Node::Ctor(struct_def));\n@@ -427,7 +427,7 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n     }\n \n     fn visit_pat(&mut self, pat: &'hir Pat) {\n-        let node = if let PatKind::Binding(..) = pat.node {\n+        let node = if let PatKind::Binding(..) = pat.kind {\n             Node::Binding(pat)\n         } else {\n             Node::Pat(pat)"}, {"sha": "1997e2aab35e8173b0d662ef0bfe7667bd7f8241", "filename": "src/librustc/hir/map/def_collector.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -101,7 +101,7 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n \n         // Pick the def data. This need not be unique, but the more\n         // information we encapsulate into, the better\n-        let def_data = match i.node {\n+        let def_data = match i.kind {\n             ItemKind::Impl(..) => DefPathData::Impl,\n             ItemKind::Mod(..) if i.ident.name == kw::Invalid => {\n                 return visit::walk_item(self, i);\n@@ -138,7 +138,7 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n         let def = self.create_def(i.id, def_data, i.span);\n \n         self.with_parent(def, |this| {\n-            match i.node {\n+            match i.kind {\n                 ItemKind::Struct(ref struct_def, _) | ItemKind::Union(ref struct_def, _) => {\n                     // If this is a unit or tuple-like struct, register the constructor.\n                     if let Some(ctor_hir_id) = struct_def.ctor_id() {\n@@ -157,7 +157,7 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n     }\n \n     fn visit_foreign_item(&mut self, foreign_item: &'a ForeignItem) {\n-        if let ForeignItemKind::Macro(_) = foreign_item.node {\n+        if let ForeignItemKind::Macro(_) = foreign_item.kind {\n             return self.visit_macro_invoc(foreign_item.id);\n         }\n \n@@ -214,7 +214,7 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n     }\n \n     fn visit_trait_item(&mut self, ti: &'a TraitItem) {\n-        let def_data = match ti.node {\n+        let def_data = match ti.kind {\n             TraitItemKind::Method(..) | TraitItemKind::Const(..) =>\n                 DefPathData::ValueNs(ti.ident.as_interned_str()),\n             TraitItemKind::Type(..) => {\n@@ -228,7 +228,7 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n     }\n \n     fn visit_impl_item(&mut self, ii: &'a ImplItem) {\n-        let def_data = match ii.node {\n+        let def_data = match ii.kind {\n             ImplItemKind::Method(MethodSig {\n                 ref header,\n                 ref decl,\n@@ -257,7 +257,7 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n     }\n \n     fn visit_pat(&mut self, pat: &'a Pat) {\n-        match pat.node {\n+        match pat.kind {\n             PatKind::Mac(..) => return self.visit_macro_invoc(pat.id),\n             _ => visit::walk_pat(self, pat),\n         }\n@@ -271,7 +271,7 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n     }\n \n     fn visit_expr(&mut self, expr: &'a Expr) {\n-        let parent_def = match expr.node {\n+        let parent_def = match expr.kind {\n             ExprKind::Mac(..) => return self.visit_macro_invoc(expr.id),\n             ExprKind::Closure(_, asyncness, ..) => {\n                 // Async closures desugar to closures inside of closures, so\n@@ -292,7 +292,7 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n     }\n \n     fn visit_ty(&mut self, ty: &'a Ty) {\n-        match ty.node {\n+        match ty.kind {\n             TyKind::Mac(..) => return self.visit_macro_invoc(ty.id),\n             TyKind::ImplTrait(node_id, _) => {\n                 self.create_def(node_id, DefPathData::ImplTrait, ty.span);\n@@ -303,7 +303,7 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n     }\n \n     fn visit_stmt(&mut self, stmt: &'a Stmt) {\n-        match stmt.node {\n+        match stmt.kind {\n             StmtKind::Mac(..) => self.visit_macro_invoc(stmt.id),\n             _ => visit::walk_stmt(self, stmt),\n         }\n@@ -312,7 +312,7 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n     fn visit_token(&mut self, t: Token) {\n         if let token::Interpolated(nt) = t.kind {\n             if let token::NtExpr(ref expr) = *nt {\n-                if let ExprKind::Mac(..) = expr.node {\n+                if let ExprKind::Mac(..) = expr.kind {\n                     self.visit_macro_invoc(expr.id);\n                 }\n             }"}, {"sha": "d4efe0297b67180ad3e10367f71516d307953488", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 49, "deletions": 49, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -50,28 +50,28 @@ impl<'hir> Entry<'hir> {\n     fn fn_decl(&self) -> Option<&'hir FnDecl> {\n         match self.node {\n             Node::Item(ref item) => {\n-                match item.node {\n+                match item.kind {\n                     ItemKind::Fn(ref fn_decl, _, _, _) => Some(fn_decl),\n                     _ => None,\n                 }\n             }\n \n             Node::TraitItem(ref item) => {\n-                match item.node {\n+                match item.kind {\n                     TraitItemKind::Method(ref method_sig, _) => Some(&method_sig.decl),\n                     _ => None\n                 }\n             }\n \n             Node::ImplItem(ref item) => {\n-                match item.node {\n+                match item.kind {\n                     ImplItemKind::Method(ref method_sig, _) => Some(&method_sig.decl),\n                     _ => None,\n                 }\n             }\n \n             Node::Expr(ref expr) => {\n-                match expr.node {\n+                match expr.kind {\n                     ExprKind::Closure(_, ref fn_decl, ..) => Some(fn_decl),\n                     _ => None,\n                 }\n@@ -84,7 +84,7 @@ impl<'hir> Entry<'hir> {\n     fn associated_body(self) -> Option<BodyId> {\n         match self.node {\n             Node::Item(item) => {\n-                match item.node {\n+                match item.kind {\n                     ItemKind::Const(_, body) |\n                     ItemKind::Static(.., body) |\n                     ItemKind::Fn(_, _, _, body) => Some(body),\n@@ -93,15 +93,15 @@ impl<'hir> Entry<'hir> {\n             }\n \n             Node::TraitItem(item) => {\n-                match item.node {\n+                match item.kind {\n                     TraitItemKind::Const(_, Some(body)) |\n                     TraitItemKind::Method(_, TraitMethod::Provided(body)) => Some(body),\n                     _ => None\n                 }\n             }\n \n             Node::ImplItem(item) => {\n-                match item.node {\n+                match item.kind {\n                     ImplItemKind::Const(_, body) |\n                     ImplItemKind::Method(_, body) => Some(body),\n                     _ => None,\n@@ -111,7 +111,7 @@ impl<'hir> Entry<'hir> {\n             Node::AnonConst(constant) => Some(constant.body),\n \n             Node::Expr(expr) => {\n-                match expr.node {\n+                match expr.kind {\n                     ExprKind::Closure(.., body, _, _) => Some(body),\n                     _ => None,\n                 }\n@@ -293,7 +293,7 @@ impl<'hir> Map<'hir> {\n \n         Some(match node {\n             Node::Item(item) => {\n-                match item.node {\n+                match item.kind {\n                     ItemKind::Static(..) => DefKind::Static,\n                     ItemKind::Const(..) => DefKind::Const,\n                     ItemKind::Fn(..) => DefKind::Fn,\n@@ -313,21 +313,21 @@ impl<'hir> Map<'hir> {\n                 }\n             }\n             Node::ForeignItem(item) => {\n-                match item.node {\n+                match item.kind {\n                     ForeignItemKind::Fn(..) => DefKind::Fn,\n                     ForeignItemKind::Static(..) => DefKind::Static,\n                     ForeignItemKind::Type => DefKind::ForeignTy,\n                 }\n             }\n             Node::TraitItem(item) => {\n-                match item.node {\n+                match item.kind {\n                     TraitItemKind::Const(..) => DefKind::AssocConst,\n                     TraitItemKind::Method(..) => DefKind::Method,\n                     TraitItemKind::Type(..) => DefKind::AssocTy,\n                 }\n             }\n             Node::ImplItem(item) => {\n-                match item.node {\n+                match item.kind {\n                     ImplItemKind::Const(..) => DefKind::AssocConst,\n                     ImplItemKind::Method(..) => DefKind::Method,\n                     ImplItemKind::TyAlias(..) => DefKind::AssocTy,\n@@ -453,22 +453,22 @@ impl<'hir> Map<'hir> {\n \n     pub fn body_owner_kind(&self, id: HirId) -> BodyOwnerKind {\n         match self.get(id) {\n-            Node::Item(&Item { node: ItemKind::Const(..), .. }) |\n-            Node::TraitItem(&TraitItem { node: TraitItemKind::Const(..), .. }) |\n-            Node::ImplItem(&ImplItem { node: ImplItemKind::Const(..), .. }) |\n+            Node::Item(&Item { kind: ItemKind::Const(..), .. }) |\n+            Node::TraitItem(&TraitItem { kind: TraitItemKind::Const(..), .. }) |\n+            Node::ImplItem(&ImplItem { kind: ImplItemKind::Const(..), .. }) |\n             Node::AnonConst(_) => {\n                 BodyOwnerKind::Const\n             }\n             Node::Ctor(..) |\n-            Node::Item(&Item { node: ItemKind::Fn(..), .. }) |\n-            Node::TraitItem(&TraitItem { node: TraitItemKind::Method(..), .. }) |\n-            Node::ImplItem(&ImplItem { node: ImplItemKind::Method(..), .. }) => {\n+            Node::Item(&Item { kind: ItemKind::Fn(..), .. }) |\n+            Node::TraitItem(&TraitItem { kind: TraitItemKind::Method(..), .. }) |\n+            Node::ImplItem(&ImplItem { kind: ImplItemKind::Method(..), .. }) => {\n                 BodyOwnerKind::Fn\n             }\n-            Node::Item(&Item { node: ItemKind::Static(_, m, _), .. }) => {\n+            Node::Item(&Item { kind: ItemKind::Static(_, m, _), .. }) => {\n                 BodyOwnerKind::Static(m)\n             }\n-            Node::Expr(&Expr { node: ExprKind::Closure(..), .. }) => {\n+            Node::Expr(&Expr { kind: ExprKind::Closure(..), .. }) => {\n                 BodyOwnerKind::Closure\n             }\n             node => bug!(\"{:#?} is not a body node\", node),\n@@ -477,17 +477,17 @@ impl<'hir> Map<'hir> {\n \n     pub fn ty_param_owner(&self, id: HirId) -> HirId {\n         match self.get(id) {\n-            Node::Item(&Item { node: ItemKind::Trait(..), .. }) |\n-            Node::Item(&Item { node: ItemKind::TraitAlias(..), .. }) => id,\n+            Node::Item(&Item { kind: ItemKind::Trait(..), .. }) |\n+            Node::Item(&Item { kind: ItemKind::TraitAlias(..), .. }) => id,\n             Node::GenericParam(_) => self.get_parent_node(id),\n             _ => bug!(\"ty_param_owner: {} not a type parameter\", self.node_to_string(id))\n         }\n     }\n \n     pub fn ty_param_name(&self, id: HirId) -> Name {\n         match self.get(id) {\n-            Node::Item(&Item { node: ItemKind::Trait(..), .. }) |\n-            Node::Item(&Item { node: ItemKind::TraitAlias(..), .. }) => kw::SelfUpper,\n+            Node::Item(&Item { kind: ItemKind::Trait(..), .. }) |\n+            Node::Item(&Item { kind: ItemKind::TraitAlias(..), .. }) => kw::SelfUpper,\n             Node::GenericParam(param) => param.name.ident().name,\n             _ => bug!(\"ty_param_name: {} not a type parameter\", self.node_to_string(id)),\n         }\n@@ -517,7 +517,7 @@ impl<'hir> Map<'hir> {\n         match self.find_entry(hir_id).unwrap().node {\n             Node::Item(&Item {\n                 span,\n-                node: ItemKind::Mod(ref m),\n+                kind: ItemKind::Mod(ref m),\n                 ..\n             }) => (m, span, hir_id),\n             Node::Crate => (&self.forest.krate.module, self.forest.krate.span, hir_id),\n@@ -568,7 +568,7 @@ impl<'hir> Map<'hir> {\n                 Node::ImplItem(ref impl_item) => Some(&impl_item.generics),\n                 Node::TraitItem(ref trait_item) => Some(&trait_item.generics),\n                 Node::Item(ref item) => {\n-                    match item.node {\n+                    match item.kind {\n                         ItemKind::Fn(_, _, ref generics, _) |\n                         ItemKind::TyAlias(_, ref generics) |\n                         ItemKind::Enum(_, ref generics) |\n@@ -634,7 +634,7 @@ impl<'hir> Map<'hir> {\n             Some(Node::TraitItem(_)) |\n             Some(Node::ImplItem(_)) => true,\n             Some(Node::Expr(e)) => {\n-                match e.node {\n+                match e.kind {\n                     ExprKind::Closure(..) => true,\n                     _ => false,\n                 }\n@@ -649,24 +649,24 @@ impl<'hir> Map<'hir> {\n         let parent_id = self.get_parent_item(hir_id);\n         match self.get(parent_id) {\n             Node::Item(&Item {\n-                node: ItemKind::Const(..),\n+                kind: ItemKind::Const(..),\n                 ..\n             })\n             | Node::TraitItem(&TraitItem {\n-                node: TraitItemKind::Const(..),\n+                kind: TraitItemKind::Const(..),\n                 ..\n             })\n             | Node::ImplItem(&ImplItem {\n-                node: ImplItemKind::Const(..),\n+                kind: ImplItemKind::Const(..),\n                 ..\n             })\n             | Node::AnonConst(_)\n             | Node::Item(&Item {\n-                node: ItemKind::Static(..),\n+                kind: ItemKind::Static(..),\n                 ..\n             }) => true,\n             Node::Item(&Item {\n-                node: ItemKind::Fn(_, header, ..),\n+                kind: ItemKind::Fn(_, header, ..),\n                 ..\n             }) => header.constness == Constness::Const,\n             _ => false,\n@@ -676,7 +676,7 @@ impl<'hir> Map<'hir> {\n     /// Wether `hir_id` corresponds to a `mod` or a crate.\n     pub fn is_hir_id_module(&self, hir_id: HirId) -> bool {\n         match self.lookup(hir_id) {\n-            Some(Entry { node: Node::Item(Item { node: ItemKind::Mod(_), .. }), .. }) |\n+            Some(Entry { node: Node::Item(Item { kind: ItemKind::Mod(_), .. }), .. }) |\n             Some(Entry { node: Node::Crate, .. }) => true,\n             _ => false,\n         }\n@@ -749,15 +749,15 @@ impl<'hir> Map<'hir> {\n                 Node::Item(_) |\n                 Node::ForeignItem(_) |\n                 Node::TraitItem(_) |\n-                Node::Expr(Expr { node: ExprKind::Closure(..), ..}) |\n+                Node::Expr(Expr { kind: ExprKind::Closure(..), ..}) |\n                 Node::ImplItem(_) => true,\n                 _ => false,\n             }\n         };\n         let match_non_returning_block = |node: &Node<'_>| {\n             match *node {\n                 Node::Expr(ref expr) => {\n-                    match expr.node {\n+                    match expr.kind {\n                         ExprKind::Loop(..) | ExprKind::Ret(..) => true,\n                         _ => false,\n                     }\n@@ -796,7 +796,7 @@ impl<'hir> Map<'hir> {\n     /// module parent is in this map.\n     pub fn get_module_parent_node(&self, hir_id: HirId) -> HirId {\n         match self.walk_parent_nodes(hir_id, |node| match *node {\n-            Node::Item(&Item { node: ItemKind::Mod(_), .. }) => true,\n+            Node::Item(&Item { kind: ItemKind::Mod(_), .. }) => true,\n             _ => false,\n         }, |_| false) {\n             Ok(id) => id,\n@@ -808,7 +808,7 @@ impl<'hir> Map<'hir> {\n     pub fn get_enclosing_scope(&self, hir_id: HirId) -> Option<HirId> {\n         self.walk_parent_nodes(hir_id, |node| match *node {\n             Node::Item(i) => {\n-                match i.node {\n+                match i.kind {\n                     ItemKind::Fn(..)\n                     | ItemKind::Mod(..)\n                     | ItemKind::Enum(..)\n@@ -820,19 +820,19 @@ impl<'hir> Map<'hir> {\n                 }\n             },\n             Node::ForeignItem(fi) => {\n-                match fi.node {\n+                match fi.kind {\n                     ForeignItemKind::Fn(..) => true,\n                     _ => false,\n                 }\n             },\n             Node::TraitItem(ti) => {\n-                match ti.node {\n+                match ti.kind {\n                     TraitItemKind::Method(..) => true,\n                     _ => false,\n                 }\n             },\n             Node::ImplItem(ii) => {\n-                match ii.node {\n+                match ii.kind {\n                     ImplItemKind::Method(..) => true,\n                     _ => false,\n                 }\n@@ -852,7 +852,7 @@ impl<'hir> Map<'hir> {\n             }\n             match self.get(scope) {\n                 Node::Item(i) => {\n-                    match i.node {\n+                    match i.kind {\n                         ItemKind::OpaqueTy(OpaqueTy { impl_trait_fn: None, .. }) => {}\n                         _ => break,\n                     }\n@@ -872,7 +872,7 @@ impl<'hir> Map<'hir> {\n         let parent = self.get_parent_item(hir_id);\n         if let Some(entry) = self.find_entry(parent) {\n             if let Entry {\n-                node: Node::Item(Item { node: ItemKind::ForeignMod(ref nm), .. }), .. } = entry\n+                node: Node::Item(Item { kind: ItemKind::ForeignMod(ref nm), .. }), .. } = entry\n             {\n                 self.read(hir_id); // reveals some of the content of a node\n                 return nm.abi;\n@@ -905,7 +905,7 @@ impl<'hir> Map<'hir> {\n     pub fn expect_variant_data(&self, id: HirId) -> &'hir VariantData {\n         match self.find(id) {\n             Some(Node::Item(i)) => {\n-                match i.node {\n+                match i.kind {\n                     ItemKind::Struct(ref struct_def, _) |\n                     ItemKind::Union(ref struct_def, _) => struct_def,\n                     _ => bug!(\"struct ID bound to non-struct {}\", self.node_to_string(id))\n@@ -948,7 +948,7 @@ impl<'hir> Map<'hir> {\n             Node::Field(f) => f.ident.name,\n             Node::Lifetime(lt) => lt.name.ident().name,\n             Node::GenericParam(param) => param.name.ident().name,\n-            Node::Binding(&Pat { node: PatKind::Binding(_, _, l, _), .. }) => l.name,\n+            Node::Binding(&Pat { kind: PatKind::Binding(_, _, l, _), .. }) => l.name,\n             Node::Ctor(..) => self.name(self.get_parent_item(id)),\n             _ => bug!(\"no name for {}\", self.node_to_string(id))\n         }\n@@ -968,7 +968,7 @@ impl<'hir> Map<'hir> {\n             Some(Node::Variant(ref v)) => Some(&v.attrs[..]),\n             Some(Node::Field(ref f)) => Some(&f.attrs[..]),\n             Some(Node::Expr(ref e)) => Some(&*e.attrs),\n-            Some(Node::Stmt(ref s)) => Some(s.node.attrs()),\n+            Some(Node::Stmt(ref s)) => Some(s.kind.attrs()),\n             Some(Node::Arm(ref a)) => Some(&*a.attrs),\n             Some(Node::GenericParam(param)) => Some(&param.attrs[..]),\n             // Unit/tuple structs/variants take the attributes straight from\n@@ -1123,7 +1123,7 @@ impl<'a> NodesMatchingSuffix<'a> {\n             }\n \n             fn item_is_mod(item: &Item) -> bool {\n-                match item.node {\n+                match item.kind {\n                     ItemKind::Mod(_) => true,\n                     _ => false,\n                 }\n@@ -1286,7 +1286,7 @@ fn hir_id_to_string(map: &Map<'_>, id: HirId, include_id: bool) -> String {\n \n     match map.find(id) {\n         Some(Node::Item(item)) => {\n-            let item_str = match item.node {\n+            let item_str = match item.kind {\n                 ItemKind::ExternCrate(..) => \"extern crate\",\n                 ItemKind::Use(..) => \"use\",\n                 ItemKind::Static(..) => \"static\",\n@@ -1310,7 +1310,7 @@ fn hir_id_to_string(map: &Map<'_>, id: HirId, include_id: bool) -> String {\n             format!(\"foreign item {}{}\", path_str(), id_str)\n         }\n         Some(Node::ImplItem(ii)) => {\n-            match ii.node {\n+            match ii.kind {\n                 ImplItemKind::Const(..) => {\n                     format!(\"assoc const {} in {}{}\", ii.ident, path_str(), id_str)\n                 }\n@@ -1326,7 +1326,7 @@ fn hir_id_to_string(map: &Map<'_>, id: HirId, include_id: bool) -> String {\n             }\n         }\n         Some(Node::TraitItem(ti)) => {\n-            let kind = match ti.node {\n+            let kind = match ti.kind {\n                 TraitItemKind::Const(..) => \"assoc constant\",\n                 TraitItemKind::Method(..) => \"trait method\",\n                 TraitItemKind::Type(..) => \"assoc type\","}, {"sha": "01cb5cc9bc105610738d037d9f7b29e7ccd9e53c", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -479,7 +479,7 @@ impl GenericArgs {\n                 match arg {\n                     GenericArg::Lifetime(_) => {}\n                     GenericArg::Type(ref ty) => {\n-                        if let TyKind::Tup(ref tys) = ty.node {\n+                        if let TyKind::Tup(ref tys) = ty.kind {\n                             return tys;\n                         }\n                         break;\n@@ -869,7 +869,7 @@ pub struct Block {\n pub struct Pat {\n     #[stable_hasher(ignore)]\n     pub hir_id: HirId,\n-    pub node: PatKind,\n+    pub kind: PatKind,\n     pub span: Span,\n }\n \n@@ -888,7 +888,7 @@ impl Pat {\n         }\n \n         use PatKind::*;\n-        match &self.node {\n+        match &self.kind {\n             Wild | Lit(_) | Range(..) | Binding(.., None) | Path(_) => true,\n             Box(s) | Ref(s, _) | Binding(.., Some(s)) => s.walk_short_(it),\n             Struct(_, fields, _) => fields.iter().all(|field| field.pat.walk_short_(it)),\n@@ -919,7 +919,7 @@ impl Pat {\n         }\n \n         use PatKind::*;\n-        match &self.node {\n+        match &self.kind {\n             Wild | Lit(_) | Range(..) | Binding(.., None) | Path(_) => {},\n             Box(s) | Ref(s, _) | Binding(.., Some(s)) => s.walk_(it),\n             Struct(_, fields, _) => fields.iter().for_each(|field| field.pat.walk_(it)),\n@@ -1221,7 +1221,7 @@ impl UnOp {\n #[derive(RustcEncodable, RustcDecodable)]\n pub struct Stmt {\n     pub hir_id: HirId,\n-    pub node: StmtKind,\n+    pub kind: StmtKind,\n     pub span: Span,\n }\n \n@@ -1295,7 +1295,7 @@ impl Arm {\n     // HACK(or_patterns; Centril | dlrobertson): Remove this and\n     // correctly handle each case in which this method is used.\n     pub fn top_pats_hack(&self) -> &[P<Pat>] {\n-        match &self.pat.node {\n+        match &self.pat.kind {\n             PatKind::Or(pats) => pats,\n             _ => std::slice::from_ref(&self.pat),\n         }\n@@ -1434,7 +1434,7 @@ pub struct AnonConst {\n #[derive(RustcEncodable, RustcDecodable)]\n pub struct Expr {\n     pub hir_id: HirId,\n-    pub node: ExprKind,\n+    pub kind: ExprKind,\n     pub attrs: ThinVec<Attribute>,\n     pub span: Span,\n }\n@@ -1445,7 +1445,7 @@ static_assert_size!(Expr, 72);\n \n impl Expr {\n     pub fn precedence(&self) -> ExprPrecedence {\n-        match self.node {\n+        match self.kind {\n             ExprKind::Box(_) => ExprPrecedence::Box,\n             ExprKind::Array(_) => ExprPrecedence::Array,\n             ExprKind::Call(..) => ExprPrecedence::Call,\n@@ -1478,7 +1478,7 @@ impl Expr {\n     }\n \n     pub fn is_place_expr(&self) -> bool {\n-         match self.node {\n+         match self.kind {\n             ExprKind::Path(QPath::Resolved(_, ref path)) => {\n                 match path.res {\n                     Res::Local(..)\n@@ -1830,7 +1830,7 @@ pub struct TraitItem {\n     pub hir_id: HirId,\n     pub attrs: HirVec<Attribute>,\n     pub generics: Generics,\n-    pub node: TraitItemKind,\n+    pub kind: TraitItemKind,\n     pub span: Span,\n }\n \n@@ -1873,7 +1873,7 @@ pub struct ImplItem {\n     pub defaultness: Defaultness,\n     pub attrs: HirVec<Attribute>,\n     pub generics: Generics,\n-    pub node: ImplItemKind,\n+    pub kind: ImplItemKind,\n     pub span: Span,\n }\n \n@@ -1939,7 +1939,7 @@ impl TypeBinding {\n #[derive(RustcEncodable, RustcDecodable)]\n pub struct Ty {\n     pub hir_id: HirId,\n-    pub node: TyKind,\n+    pub kind: TyKind,\n     pub span: Span,\n }\n \n@@ -2416,7 +2416,7 @@ pub struct Item {\n     pub ident: Ident,\n     pub hir_id: HirId,\n     pub attrs: HirVec<Attribute>,\n-    pub node: ItemKind,\n+    pub kind: ItemKind,\n     pub vis: Visibility,\n     pub span: Span,\n }\n@@ -2581,7 +2581,7 @@ pub struct ForeignItem {\n     #[stable_hasher(project(name))]\n     pub ident: Ident,\n     pub attrs: HirVec<Attribute>,\n-    pub node: ForeignItemKind,\n+    pub kind: ForeignItemKind,\n     pub hir_id: HirId,\n     pub span: Span,\n     pub vis: Visibility,"}, {"sha": "feb0d97822c42a604f6ad5cc67e880d96163b286", "filename": "src/librustc/hir/pat_util.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc%2Fhir%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc%2Fhir%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fpat_util.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -45,7 +45,7 @@ impl<T: ExactSizeIterator> EnumerateAndAdjustIterator for T {\n \n impl hir::Pat {\n     pub fn is_refutable(&self) -> bool {\n-        match self.node {\n+        match self.kind {\n             PatKind::Lit(_) |\n             PatKind::Range(..) |\n             PatKind::Path(hir::QPath::Resolved(Some(..), _)) |\n@@ -68,7 +68,7 @@ impl hir::Pat {\n     /// `match foo() { Some(a) => (), None => () }`\n     pub fn each_binding(&self, mut f: impl FnMut(hir::BindingAnnotation, HirId, Span, ast::Ident)) {\n         self.walk(|p| {\n-            if let PatKind::Binding(binding_mode, _, ident, _) = p.node {\n+            if let PatKind::Binding(binding_mode, _, ident, _) = p.kind {\n                 f(binding_mode, p.hir_id, p.span, ident);\n             }\n             true\n@@ -83,7 +83,7 @@ impl hir::Pat {\n         &self,\n         f: &mut impl FnMut(hir::BindingAnnotation, HirId, Span, ast::Ident),\n     ) {\n-        self.walk(|p| match &p.node {\n+        self.walk(|p| match &p.kind {\n             PatKind::Or(ps) => {\n                 ps[0].each_binding_or_first(f);\n                 false\n@@ -99,7 +99,7 @@ impl hir::Pat {\n     /// Checks if the pattern contains any patterns that bind something to\n     /// an ident, e.g., `foo`, or `Foo(foo)` or `foo @ Bar(..)`.\n     pub fn contains_bindings(&self) -> bool {\n-        self.satisfies(|p| match p.node {\n+        self.satisfies(|p| match p.kind {\n             PatKind::Binding(..) => true,\n             _ => false,\n         })\n@@ -108,7 +108,7 @@ impl hir::Pat {\n     /// Checks if the pattern contains any patterns that bind something to\n     /// an ident or wildcard, e.g., `foo`, or `Foo(_)`, `foo @ Bar(..)`,\n     pub fn contains_bindings_or_wild(&self) -> bool {\n-        self.satisfies(|p| match p.node {\n+        self.satisfies(|p| match p.kind {\n             PatKind::Binding(..) | PatKind::Wild => true,\n             _ => false,\n         })\n@@ -129,7 +129,7 @@ impl hir::Pat {\n     }\n \n     pub fn simple_ident(&self) -> Option<ast::Ident> {\n-        match self.node {\n+        match self.kind {\n             PatKind::Binding(hir::BindingAnnotation::Unannotated, _, ident, None) |\n             PatKind::Binding(hir::BindingAnnotation::Mutable, _, ident, None) => Some(ident),\n             _ => None,\n@@ -139,7 +139,7 @@ impl hir::Pat {\n     /// Returns variants that are necessary to exist for the pattern to match.\n     pub fn necessary_variants(&self) -> Vec<DefId> {\n         let mut variants = vec![];\n-        self.walk(|p| match &p.node {\n+        self.walk(|p| match &p.kind {\n             PatKind::Or(_) => false,\n             PatKind::Path(hir::QPath::Resolved(_, path)) |\n             PatKind::TupleStruct(hir::QPath::Resolved(_, path), ..) |"}, {"sha": "91f2c5a0aaf856be21ccc28b00e2ea6c7b8dcc2f", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 22, "deletions": 23, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -286,7 +286,7 @@ impl<'a> State<'a> {\n     pub fn print_type(&mut self, ty: &hir::Ty) {\n         self.maybe_print_comment(ty.span.lo());\n         self.ibox(0);\n-        match ty.node {\n+        match ty.kind {\n             hir::TyKind::Slice(ref ty) => {\n                 self.s.word(\"[\");\n                 self.print_type(&ty);\n@@ -372,7 +372,7 @@ impl<'a> State<'a> {\n         self.hardbreak_if_not_bol();\n         self.maybe_print_comment(item.span.lo());\n         self.print_outer_attributes(&item.attrs);\n-        match item.node {\n+        match item.kind {\n             hir::ForeignItemKind::Fn(ref decl, ref arg_names, ref generics) => {\n                 self.head(\"\");\n                 self.print_fn(decl,\n@@ -474,7 +474,7 @@ impl<'a> State<'a> {\n         self.maybe_print_comment(item.span.lo());\n         self.print_outer_attributes(&item.attrs);\n         self.ann.pre(self, AnnNode::Item(item));\n-        match item.node {\n+        match item.kind {\n             hir::ItemKind::ExternCrate(orig_name) => {\n                 self.head(visibility_qualified(&item.vis, \"extern crate\"));\n                 if let Some(orig_name) = orig_name {\n@@ -858,7 +858,7 @@ impl<'a> State<'a> {\n         self.hardbreak_if_not_bol();\n         self.maybe_print_comment(ti.span.lo());\n         self.print_outer_attributes(&ti.attrs);\n-        match ti.node {\n+        match ti.kind {\n             hir::TraitItemKind::Const(ref ty, default) => {\n                 let vis = Spanned { span: syntax_pos::DUMMY_SP,\n                                     node: hir::VisibilityKind::Inherited };\n@@ -896,7 +896,7 @@ impl<'a> State<'a> {\n         self.print_outer_attributes(&ii.attrs);\n         self.print_defaultness(ii.defaultness);\n \n-        match ii.node {\n+        match ii.kind {\n             hir::ImplItemKind::Const(ref ty, expr) => {\n                 self.print_associated_const(ii.ident, &ty, Some(expr), &ii.vis);\n             }\n@@ -944,7 +944,7 @@ impl<'a> State<'a> {\n \n     pub fn print_stmt(&mut self, st: &hir::Stmt) {\n         self.maybe_print_comment(st.span.lo());\n-        match st.node {\n+        match st.kind {\n             hir::StmtKind::Local(ref loc) => {\n                 self.print_local(loc.init.as_deref(), |this| this.print_local_decl(&loc));\n             }\n@@ -961,7 +961,7 @@ impl<'a> State<'a> {\n                 self.s.word(\";\");\n             }\n         }\n-        if stmt_ends_with_semi(&st.node) {\n+        if stmt_ends_with_semi(&st.kind) {\n             self.s.word(\";\");\n         }\n         self.maybe_print_trailing_comment(st.span, None)\n@@ -1035,7 +1035,7 @@ impl<'a> State<'a> {\n     /// Print an expr using syntax that's acceptable in a condition position, such as the `cond` in\n     /// `if cond { ... }`.\n     pub fn print_expr_as_cond(&mut self, expr: &hir::Expr) {\n-        let needs_par = match expr.node {\n+        let needs_par = match expr.kind {\n             // These cases need parens due to the parse error observed in #26461: `if return {}`\n             // parses as the erroneous construct `if (return {})`, not `if (return) {}`.\n             hir::ExprKind::Closure(..) |\n@@ -1119,11 +1119,10 @@ impl<'a> State<'a> {\n     }\n \n     fn print_expr_call(&mut self, func: &hir::Expr, args: &[hir::Expr]) {\n-        let prec =\n-            match func.node {\n-                hir::ExprKind::Field(..) => parser::PREC_FORCE_PAREN,\n-                _ => parser::PREC_POSTFIX,\n-            };\n+        let prec = match func.kind {\n+            hir::ExprKind::Field(..) => parser::PREC_FORCE_PAREN,\n+            _ => parser::PREC_POSTFIX,\n+        };\n \n         self.print_expr_maybe_paren(func, prec);\n         self.print_call_post(args)\n@@ -1161,7 +1160,7 @@ impl<'a> State<'a> {\n             Fixity::None => (prec + 1, prec + 1),\n         };\n \n-        let left_prec = match (&lhs.node, op.node) {\n+        let left_prec = match (&lhs.kind, op.node) {\n             // These cases need parens: `x as i32 < y` has the parser thinking that `i32 < y` is\n             // the beginning of a path type. It starts trying to parse `x as (i32 < y ...` instead\n             // of `(x as i32) < ...`. We need to convince it _not_ to do that.\n@@ -1200,7 +1199,7 @@ impl<'a> State<'a> {\n         self.print_outer_attributes(&expr.attrs);\n         self.ibox(INDENT_UNIT);\n         self.ann.pre(self, AnnNode::Expr(expr));\n-        match expr.node {\n+        match expr.kind {\n             hir::ExprKind::Box(ref expr) => {\n                 self.word_space(\"box\");\n                 self.print_expr_maybe_paren(expr, parser::PREC_PREFIX);\n@@ -1618,7 +1617,7 @@ impl<'a> State<'a> {\n         self.ann.pre(self, AnnNode::Pat(pat));\n         // Pat isn't normalized, but the beauty of it\n         // is that it doesn't matter\n-        match pat.node {\n+        match pat.kind {\n             PatKind::Wild => self.s.word(\"_\"),\n             PatKind::Binding(binding_mode, _, ident, ref sub) => {\n                 match binding_mode {\n@@ -1711,7 +1710,7 @@ impl<'a> State<'a> {\n                 self.pclose();\n             }\n             PatKind::Box(ref inner) => {\n-                let is_range_inner = match inner.node {\n+                let is_range_inner = match inner.kind {\n                     PatKind::Range(..) => true,\n                     _ => false,\n                 };\n@@ -1725,7 +1724,7 @@ impl<'a> State<'a> {\n                 }\n             }\n             PatKind::Ref(ref inner, mutbl) => {\n-                let is_range_inner = match inner.node {\n+                let is_range_inner = match inner.kind {\n                     PatKind::Range(..) => true,\n                     _ => false,\n                 };\n@@ -1758,7 +1757,7 @@ impl<'a> State<'a> {\n                     if !before.is_empty() {\n                         self.word_space(\",\");\n                     }\n-                    if let PatKind::Wild = p.node {\n+                    if let PatKind::Wild = p.kind {\n                         // Print nothing.\n                     } else {\n                         self.print_pat(&p);\n@@ -1803,7 +1802,7 @@ impl<'a> State<'a> {\n         }\n         self.word_space(\"=>\");\n \n-        match arm.body.node {\n+        match arm.body.kind {\n             hir::ExprKind::Block(ref blk, opt_label) => {\n                 if let Some(label) = opt_label {\n                     self.print_ident(label.ident);\n@@ -1881,7 +1880,7 @@ impl<'a> State<'a> {\n             s.ann.nested(s, Nested::BodyParamPat(body_id, i));\n             i += 1;\n \n-            if let hir::TyKind::Infer = ty.node {\n+            if let hir::TyKind::Infer = ty.kind {\n                 // Print nothing.\n             } else {\n                 s.s.word(\":\");\n@@ -2222,7 +2221,7 @@ impl<'a> State<'a> {\n //\n // Duplicated from `parse::classify`, but adapted for the HIR.\n fn expr_requires_semi_to_be_stmt(e: &hir::Expr) -> bool {\n-    match e.node {\n+    match e.kind {\n         hir::ExprKind::Match(..) |\n         hir::ExprKind::Block(..) |\n         hir::ExprKind::Loop(..) => false,\n@@ -2273,7 +2272,7 @@ fn bin_op_to_assoc_op(op: hir::BinOpKind) -> AssocOp {\n /// parens or other delimiters, e.g., `X { y: 1 }`, `X { y: 1 }.method()`, `foo == X { y: 1 }` and\n /// `X { y: 1 } == foo` all do, but `(X { y: 1 }) == foo` does not.\n fn contains_exterior_struct_lit(value: &hir::Expr) -> bool {\n-    match value.node {\n+    match value.kind {\n         hir::ExprKind::Struct(..) => true,\n \n         hir::ExprKind::Assign(ref lhs, ref rhs) |"}, {"sha": "5c5f7f6120082d1d83c1344347a2160f52c1be23", "filename": "src/librustc/hir/upvars.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc%2Fhir%2Fupvars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc%2Fhir%2Fupvars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fupvars.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -47,7 +47,7 @@ impl Visitor<'tcx> for LocalCollector {\n     }\n \n     fn visit_pat(&mut self, pat: &'tcx hir::Pat) {\n-        if let hir::PatKind::Binding(_, hir_id, ..) = pat.node {\n+        if let hir::PatKind::Binding(_, hir_id, ..) = pat.kind {\n             self.locals.insert(hir_id);\n         }\n         intravisit::walk_pat(self, pat);\n@@ -82,7 +82,7 @@ impl Visitor<'tcx> for CaptureCollector<'a, 'tcx> {\n     }\n \n     fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n-        if let hir::ExprKind::Closure(..) = expr.node {\n+        if let hir::ExprKind::Closure(..) = expr.kind {\n             let closure_def_id = self.tcx.hir().local_def_id(expr.hir_id);\n             if let Some(upvars) = self.tcx.upvars(closure_def_id) {\n                 // Every capture of a closure expression is a local in scope,"}, {"sha": "8e74f1e11eb511b23719a5157bfb5baceda3e908", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -144,11 +144,11 @@ impl<'a> HashStable<StableHashingContext<'a>> for hir::Ty {\n         hcx.while_hashing_hir_bodies(true, |hcx| {\n             let hir::Ty {\n                 hir_id: _,\n-                ref node,\n+                ref kind,\n                 ref span,\n             } = *self;\n \n-            node.hash_stable(hcx, hasher);\n+            kind.hash_stable(hcx, hasher);\n             span.hash_stable(hcx, hasher);\n         })\n     }\n@@ -158,7 +158,7 @@ impl_stable_hash_for_spanned!(hir::BinOpKind);\n \n impl_stable_hash_for!(struct hir::Stmt {\n     hir_id,\n-    node,\n+    kind,\n     span,\n });\n \n@@ -173,12 +173,12 @@ impl<'a> HashStable<StableHashingContext<'a>> for hir::Expr {\n             let hir::Expr {\n                 hir_id: _,\n                 ref span,\n-                ref node,\n+                ref kind,\n                 ref attrs\n             } = *self;\n \n             span.hash_stable(hcx, hasher);\n-            node.hash_stable(hcx, hasher);\n+            kind.hash_stable(hcx, hasher);\n             attrs.hash_stable(hcx, hasher);\n         })\n     }\n@@ -200,15 +200,15 @@ impl<'a> HashStable<StableHashingContext<'a>> for hir::TraitItem {\n             ident,\n             ref attrs,\n             ref generics,\n-            ref node,\n+            ref kind,\n             span\n         } = *self;\n \n         hcx.hash_hir_item_like(|hcx| {\n             ident.name.hash_stable(hcx, hasher);\n             attrs.hash_stable(hcx, hasher);\n             generics.hash_stable(hcx, hasher);\n-            node.hash_stable(hcx, hasher);\n+            kind.hash_stable(hcx, hasher);\n             span.hash_stable(hcx, hasher);\n         });\n     }\n@@ -226,7 +226,7 @@ impl<'a> HashStable<StableHashingContext<'a>> for hir::ImplItem {\n             defaultness,\n             ref attrs,\n             ref generics,\n-            ref node,\n+            ref kind,\n             span\n         } = *self;\n \n@@ -236,7 +236,7 @@ impl<'a> HashStable<StableHashingContext<'a>> for hir::ImplItem {\n             defaultness.hash_stable(hcx, hasher);\n             attrs.hash_stable(hcx, hasher);\n             generics.hash_stable(hcx, hasher);\n-            node.hash_stable(hcx, hasher);\n+            kind.hash_stable(hcx, hasher);\n             span.hash_stable(hcx, hasher);\n         });\n     }\n@@ -312,15 +312,15 @@ impl<'a> HashStable<StableHashingContext<'a>> for hir::Item {\n             ident,\n             ref attrs,\n             hir_id: _,\n-            ref node,\n+            ref kind,\n             ref vis,\n             span\n         } = *self;\n \n         hcx.hash_hir_item_like(|hcx| {\n             ident.name.hash_stable(hcx, hasher);\n             attrs.hash_stable(hcx, hasher);\n-            node.hash_stable(hcx, hasher);\n+            kind.hash_stable(hcx, hasher);\n             vis.hash_stable(hcx, hasher);\n             span.hash_stable(hcx, hasher);\n         });"}, {"sha": "91c6c968f9853dd8d589e3785000510933f66584", "filename": "src/librustc/ich/impls_syntax.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_syntax.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -142,7 +142,7 @@ impl_stable_hash_for!(enum ::syntax::ast::LitIntType {\n });\n \n impl_stable_hash_for!(struct ::syntax::ast::Lit {\n-    node,\n+    kind,\n     token,\n     span\n });\n@@ -361,7 +361,7 @@ impl_stable_hash_for!(enum ::syntax::ast::NestedMetaItem {\n \n impl_stable_hash_for!(struct ::syntax::ast::MetaItem {\n     path,\n-    node,\n+    kind,\n     span\n });\n "}, {"sha": "d31b527a55b6951e6e4663744a6e52b9ba98cba5", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -90,7 +90,7 @@ impl<'tcx> TyCtxt<'tcx> {\n                 let span = scope.span(self, region_scope_tree);\n                 let tag = match self.hir().find(scope.hir_id(region_scope_tree)) {\n                     Some(Node::Block(_)) => \"block\",\n-                    Some(Node::Expr(expr)) => match expr.node {\n+                    Some(Node::Expr(expr)) => match expr.kind {\n                         hir::ExprKind::Call(..) => \"call\",\n                         hir::ExprKind::MethodCall(..) => \"method call\",\n                         hir::ExprKind::Match(.., hir::MatchSource::IfLetDesugar { .. }) => \"if let\",\n@@ -248,7 +248,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n \n     fn item_scope_tag(item: &hir::Item) -> &'static str {\n-        match item.node {\n+        match item.kind {\n             hir::ItemKind::Impl(..) => \"impl\",\n             hir::ItemKind::Struct(..) => \"struct\",\n             hir::ItemKind::Union(..) => \"union\",\n@@ -260,14 +260,14 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n \n     fn trait_item_scope_tag(item: &hir::TraitItem) -> &'static str {\n-        match item.node {\n+        match item.kind {\n             hir::TraitItemKind::Method(..) => \"method body\",\n             hir::TraitItemKind::Const(..) | hir::TraitItemKind::Type(..) => \"associated item\",\n         }\n     }\n \n     fn impl_item_scope_tag(item: &hir::ImplItem) -> &'static str {\n-        match item.node {\n+        match item.kind {\n             hir::ImplItemKind::Method(..) => \"method body\",\n             hir::ImplItemKind::Const(..)\n             | hir::ImplItemKind::OpaqueTy(..)\n@@ -639,7 +639,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 hir::MatchSource::TryDesugar => {\n                     if let Some(ty::error::ExpectedFound { expected, .. }) = exp_found {\n                         let discrim_expr = self.tcx.hir().expect_expr(discrim_hir_id);\n-                        let discrim_ty = if let hir::ExprKind::Call(_, args) = &discrim_expr.node {\n+                        let discrim_ty = if let hir::ExprKind::Call(_, args) = &discrim_expr.kind {\n                             let arg_expr = args.first().expect(\"try desugaring call w/out arg\");\n                             self.in_progress_tables.and_then(|tables| {\n                                 tables.borrow().expr_ty_opt(arg_expr)"}, {"sha": "1df60dfc63ef367e6a8d0c034d13c221ace3a35f", "filename": "src/librustc/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -92,10 +92,10 @@ impl<'a, 'tcx> Visitor<'tcx> for FindLocalByTypeVisitor<'a, 'tcx> {\n \n     fn visit_expr(&mut self, expr: &'tcx Expr) {\n         if let (ExprKind::Closure(_, _fn_decl, _id, _sp, _), Some(_)) = (\n-            &expr.node,\n+            &expr.kind,\n             self.node_matches_type(expr.hir_id),\n         ) {\n-            self.found_closure = Some(&expr.node);\n+            self.found_closure = Some(&expr.kind);\n         }\n         intravisit::walk_expr(self, expr);\n     }\n@@ -114,7 +114,7 @@ fn closure_return_type_suggestion(\n         FunctionRetTy::DefaultReturn(_) => (\"-> \", \" \"),\n         _ => (\"\", \"\"),\n     };\n-    let suggestion = match body.value.node {\n+    let suggestion = match body.value.kind {\n         ExprKind::Block(..) => {\n             vec![(output.span(), format!(\"{}{}{}\", arrow, ret, post))]\n         }"}, {"sha": "9c362a5e20791973fa3d360b6d26b6211fe7c63f", "filename": "src/librustc/infer/error_reporting/nice_region_error/find_anon_type.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -31,15 +31,15 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n             if let Some(hir_id) = self.tcx().hir().as_local_hir_id(def_id) {\n                 let fndecl = match self.tcx().hir().get(hir_id) {\n                     Node::Item(&hir::Item {\n-                        node: hir::ItemKind::Fn(ref fndecl, ..),\n+                        kind: hir::ItemKind::Fn(ref fndecl, ..),\n                         ..\n                     }) => &fndecl,\n                     Node::TraitItem(&hir::TraitItem {\n-                        node: hir::TraitItemKind::Method(ref m, ..),\n+                        kind: hir::TraitItemKind::Method(ref m, ..),\n                         ..\n                     })\n                     | Node::ImplItem(&hir::ImplItem {\n-                        node: hir::ImplItemKind::Method(ref m, ..),\n+                        kind: hir::ImplItemKind::Method(ref m, ..),\n                         ..\n                     }) => &m.decl,\n                     _ => return None,\n@@ -98,7 +98,7 @@ impl Visitor<'tcx> for FindNestedTypeVisitor<'tcx> {\n     }\n \n     fn visit_ty(&mut self, arg: &'tcx hir::Ty) {\n-        match arg.node {\n+        match arg.kind {\n             hir::TyKind::BareFn(_) => {\n                 self.current_index.shift_in(1);\n                 intravisit::walk_ty(self, arg);"}, {"sha": "a9a2c15d7d99b6d83b936f56a08cf8d316daecae", "filename": "src/librustc/infer/error_reporting/nice_region_error/named_anon_conflict.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -87,7 +87,7 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n                 return None;\n             }\n             if let FunctionRetTy::Return(ty) = &fndecl.output {\n-                if let (TyKind::Def(_, _), ty::ReStatic) = (&ty.node, sub) {\n+                if let (TyKind::Def(_, _), ty::ReStatic) = (&ty.kind, sub) {\n                     // This is an impl Trait return that evaluates de need of 'static.\n                     // We handle this case better in `static_impl_trait`.\n                     return None;"}, {"sha": "9231e4f779eb768ab5a1a351ac46b149840b7c70", "filename": "src/librustc/infer/error_reporting/nice_region_error/outlives_closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Foutlives_closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Foutlives_closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Foutlives_closure.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -50,7 +50,7 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n                 let hir = &self.tcx().hir();\n                 if let Some(hir_id) = hir.as_local_hir_id(free_region.scope) {\n                     if let Node::Expr(Expr {\n-                        node: Closure(_, _, _, closure_span, None),\n+                        kind: Closure(_, _, _, closure_span, None),\n                         ..\n                     }) = hir.get(hir_id) {\n                         let sup_sp = sup_origin.span();"}, {"sha": "3b3649fd8112fce75ae0a4489c7ceb1a6e1e1e91", "filename": "src/librustc/infer/opaque_types/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -1036,7 +1036,7 @@ impl<'a, 'tcx> Instantiator<'a, 'tcx> {\n                                                 .local_def_id(opaque_parent_hir_id)\n                         };\n                         let (in_definition_scope, origin) = match tcx.hir().find(opaque_hir_id) {\n-                            Some(Node::Item(item)) => match item.node {\n+                            Some(Node::Item(item)) => match item.kind {\n                                 // Anonymous `impl Trait`\n                                 hir::ItemKind::OpaqueTy(hir::OpaqueTy {\n                                     impl_trait_fn: Some(parent),\n@@ -1060,7 +1060,7 @@ impl<'a, 'tcx> Instantiator<'a, 'tcx> {\n                                     (def_scope_default(), hir::OpaqueTyOrigin::TypeAlias)\n                                 }\n                             },\n-                            Some(Node::ImplItem(item)) => match item.node {\n+                            Some(Node::ImplItem(item)) => match item.kind {\n                                 hir::ImplItemKind::OpaqueTy(_) => (\n                                     may_define_opaque_type(\n                                         tcx,"}, {"sha": "fa73a3c6c4628bb1ee29573913a7f0a44b4f10d7", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -981,7 +981,7 @@ for LateContextAndPass<'a, 'tcx, T> {\n \n     fn visit_item(&mut self, it: &'tcx hir::Item) {\n         let generics = self.context.generics.take();\n-        self.context.generics = it.node.generics();\n+        self.context.generics = it.kind.generics();\n         self.with_lint_attrs(it.hir_id, &it.attrs, |cx| {\n             cx.with_param_env(it.hir_id, |cx| {\n                 lint_callback!(cx, check_item, it);"}, {"sha": "a08722e940295b137e326cf530523097a1777210", "filename": "src/librustc/lint/internal.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc%2Flint%2Finternal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc%2Flint%2Finternal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Finternal.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -94,7 +94,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TyTyKind {\n     }\n \n     fn check_ty(&mut self, cx: &LateContext<'_, '_>, ty: &'tcx Ty) {\n-        match &ty.node {\n+        match &ty.kind {\n             TyKind::Path(qpath) => {\n                 if let QPath::Resolved(_, path) = qpath {\n                     if let Some(last) = path.segments.iter().last() {\n@@ -169,7 +169,7 @@ fn lint_ty_kind_usage(cx: &LateContext<'_, '_>, segment: &PathSegment) -> bool {\n }\n \n fn is_ty_or_ty_ctxt(cx: &LateContext<'_, '_>, ty: &Ty) -> Option<String> {\n-    match &ty.node {\n+    match &ty.kind {\n         TyKind::Path(qpath) => {\n             if let QPath::Resolved(_, path) = qpath {\n                 let did = path.res.opt_def_id()?;\n@@ -218,7 +218,7 @@ declare_lint_pass!(LintPassImpl => [LINT_PASS_IMPL_WITHOUT_MACRO]);\n \n impl EarlyLintPass for LintPassImpl {\n     fn check_item(&mut self, cx: &EarlyContext<'_>, item: &Item) {\n-        if let ItemKind::Impl(_, _, _, _, Some(lint_pass), _, _) = &item.node {\n+        if let ItemKind::Impl(_, _, _, _, Some(lint_pass), _, _) = &item.kind {\n             if let Some(last) = lint_pass.path.segments.last() {\n                 if last.ident.name == sym::LintPass {\n                     let expn_data = lint_pass.path.span.ctxt().outer_expn_data();"}, {"sha": "16d19e41db4f4422d35fc478047b8dfc1923cef9", "filename": "src/librustc/lint/levels.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc%2Flint%2Flevels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc%2Flint%2Flevels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Flevels.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -218,15 +218,15 @@ impl<'a> LintLevelsBuilder<'a> {\n             let mut reason = None;\n             let tail_li = &metas[metas.len()-1];\n             if let Some(item) = tail_li.meta_item() {\n-                match item.node {\n+                match item.kind {\n                     ast::MetaItemKind::Word => {}  // actual lint names handled later\n                     ast::MetaItemKind::NameValue(ref name_value) => {\n                         if item.path == sym::reason {\n                             // found reason, reslice meta list to exclude it\n                             metas = &metas[0..metas.len()-1];\n                             // FIXME (#55112): issue unused-attributes lint if we thereby\n                             // don't have any lint names (`#[level(reason = \"foo\")]`)\n-                            if let ast::LitKind::Str(rationale, _) = name_value.node {\n+                            if let ast::LitKind::Str(rationale, _) = name_value.kind {\n                                 if !self.sess.features_untracked().lint_reasons {\n                                     feature_gate::emit_feature_err(\n                                         &self.sess.parse_sess,\n@@ -264,7 +264,7 @@ impl<'a> LintLevelsBuilder<'a> {\n                         let mut err = bad_attr(sp);\n                         let mut add_label = true;\n                         if let Some(item) = li.meta_item() {\n-                            if let ast::MetaItemKind::NameValue(_) = item.node {\n+                            if let ast::MetaItemKind::NameValue(_) = item.kind {\n                                 if item.path == sym::reason {\n                                     err.span_label(sp, \"reason in lint attribute must come last\");\n                                     add_label = false;"}, {"sha": "7c75a1447e26d6630b5bed4e9f3e92210863871c", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -133,7 +133,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n             _ => span_bug!(lhs.span, \"non-ADT in struct pattern\")\n         };\n         for pat in pats {\n-            if let PatKind::Wild = pat.pat.node {\n+            if let PatKind::Wild = pat.pat.kind {\n                 continue;\n             }\n             let index = self.tcx.field_index(pat.hir_id, self.tables);\n@@ -166,7 +166,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n         self.inherited_pub_visibility = false;\n         match node {\n             Node::Item(item) => {\n-                match item.node {\n+                match item.kind {\n                     hir::ItemKind::Struct(..) | hir::ItemKind::Union(..) => {\n                         let def_id = self.tcx.hir().local_def_id(item.hir_id);\n                         let def = self.tcx.adt_def(def_id);\n@@ -236,7 +236,7 @@ impl<'a, 'tcx> Visitor<'tcx> for MarkSymbolVisitor<'a, 'tcx> {\n     }\n \n     fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n-        match expr.node {\n+        match expr.kind {\n             hir::ExprKind::Path(ref qpath @ hir::QPath::TypeRelative(..)) => {\n                 let res = self.tables.qpath_res(qpath, expr.hir_id);\n                 self.handle_res(res);\n@@ -269,7 +269,7 @@ impl<'a, 'tcx> Visitor<'tcx> for MarkSymbolVisitor<'a, 'tcx> {\n     }\n \n     fn visit_pat(&mut self, pat: &'tcx hir::Pat) {\n-        match pat.node {\n+        match pat.kind {\n             PatKind::Struct(ref path, ref fields, _) => {\n                 let res = self.tables.qpath_res(path, pat.hir_id);\n                 self.handle_field_pattern_match(pat, res, fields);\n@@ -292,7 +292,7 @@ impl<'a, 'tcx> Visitor<'tcx> for MarkSymbolVisitor<'a, 'tcx> {\n     }\n \n     fn visit_ty(&mut self, ty: &'tcx hir::Ty) {\n-        match ty.node {\n+        match ty.kind {\n             TyKind::Def(item_id, _) => {\n                 let item = self.tcx.hir().expect_item(item_id.id);\n                 intravisit::walk_item(self, item);\n@@ -369,7 +369,7 @@ impl<'v, 'k, 'tcx> ItemLikeVisitor<'v> for LifeSeeder<'k, 'tcx> {\n         if allow_dead_code {\n             self.worklist.push(item.hir_id);\n         }\n-        match item.node {\n+        match item.kind {\n             hir::ItemKind::Enum(ref enum_def, _) => {\n                 if allow_dead_code {\n                     self.worklist.extend(enum_def.variants.iter().map(|variant| variant.id));\n@@ -384,7 +384,7 @@ impl<'v, 'k, 'tcx> ItemLikeVisitor<'v> for LifeSeeder<'k, 'tcx> {\n             hir::ItemKind::Trait(.., ref trait_item_refs) => {\n                 for trait_item_ref in trait_item_refs {\n                     let trait_item = self.krate.trait_item(trait_item_ref.id);\n-                    match trait_item.node {\n+                    match trait_item.kind {\n                         hir::TraitItemKind::Const(_, Some(_)) |\n                         hir::TraitItemKind::Method(_, hir::TraitMethod::Provided(_)) => {\n                             if has_allow_dead_code_or_lang_attr(self.tcx,\n@@ -482,7 +482,7 @@ struct DeadVisitor<'tcx> {\n \n impl DeadVisitor<'tcx> {\n     fn should_warn_about_item(&mut self, item: &hir::Item) -> bool {\n-        let should_warn = match item.node {\n+        let should_warn = match item.kind {\n             hir::ItemKind::Static(..)\n             | hir::ItemKind::Const(..)\n             | hir::ItemKind::Fn(..)\n@@ -571,7 +571,7 @@ impl Visitor<'tcx> for DeadVisitor<'tcx> {\n         if self.should_warn_about_item(item) {\n             // For items that have a definition with a signature followed by a\n             // block, point only at the signature.\n-            let span = match item.node {\n+            let span = match item.kind {\n                 hir::ItemKind::Fn(..) |\n                 hir::ItemKind::Mod(..) |\n                 hir::ItemKind::Enum(..) |\n@@ -581,15 +581,15 @@ impl Visitor<'tcx> for DeadVisitor<'tcx> {\n                 hir::ItemKind::Impl(..) => self.tcx.sess.source_map().def_span(item.span),\n                 _ => item.span,\n             };\n-            let participle = match item.node {\n+            let participle = match item.kind {\n                 hir::ItemKind::Struct(..) => \"constructed\", // Issue #52325\n                 _ => \"used\"\n             };\n             self.warn_dead_code(\n                 item.hir_id,\n                 span,\n                 item.ident.name,\n-                item.node.descriptive_variant(),\n+                item.kind.descriptive_variant(),\n                 participle,\n             );\n         } else {\n@@ -613,7 +613,7 @@ impl Visitor<'tcx> for DeadVisitor<'tcx> {\n     fn visit_foreign_item(&mut self, fi: &'tcx hir::ForeignItem) {\n         if self.should_warn_about_foreign_item(fi) {\n             self.warn_dead_code(fi.hir_id, fi.span, fi.ident.name,\n-                                fi.node.descriptive_variant(), \"used\");\n+                                fi.kind.descriptive_variant(), \"used\");\n         }\n         intravisit::walk_foreign_item(self, fi);\n     }\n@@ -626,7 +626,7 @@ impl Visitor<'tcx> for DeadVisitor<'tcx> {\n     }\n \n     fn visit_impl_item(&mut self, impl_item: &'tcx hir::ImplItem) {\n-        match impl_item.node {\n+        match impl_item.kind {\n             hir::ImplItemKind::Const(_, body_id) => {\n                 if !self.symbol_is_live(impl_item.hir_id) {\n                     self.warn_dead_code(impl_item.hir_id,\n@@ -652,7 +652,7 @@ impl Visitor<'tcx> for DeadVisitor<'tcx> {\n \n     // Overwrite so that we don't warn the trait item itself.\n     fn visit_trait_item(&mut self, trait_item: &'tcx hir::TraitItem) {\n-        match trait_item.node {\n+        match trait_item.kind {\n             hir::TraitItemKind::Const(_, Some(body_id)) |\n             hir::TraitItemKind::Method(_, hir::TraitMethod::Provided(body_id)) => {\n                 self.visit_nested_body(body_id)"}, {"sha": "660fe14ba07001c4a143ccd7817c439dd08e2bd6", "filename": "src/librustc/middle/entry.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc%2Fmiddle%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc%2Fmiddle%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fentry.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -80,7 +80,7 @@ fn entry_fn(tcx: TyCtxt<'_>, cnum: CrateNum) -> Option<(DefId, EntryFnType)> {\n // Beware, this is duplicated in `libsyntax/entry.rs`, so make sure to keep\n // them in sync.\n fn entry_point_type(item: &Item, at_root: bool) -> EntryPointType {\n-    match item.node {\n+    match item.kind {\n         ItemKind::Fn(..) => {\n             if attr::contains_name(&item.attrs, sym::start) {\n                 EntryPointType::Start"}, {"sha": "45b660f5c67f6e3efe7260ec09dd8ee0bb5390ae", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -397,7 +397,7 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n \n         self.walk_adjustment(expr);\n \n-        match expr.node {\n+        match expr.kind {\n             hir::ExprKind::Path(_) => { }\n \n             hir::ExprKind::Type(ref subexpr, _) => {\n@@ -590,7 +590,7 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n     }\n \n     fn walk_stmt(&mut self, stmt: &hir::Stmt) {\n-        match stmt.node {\n+        match stmt.kind {\n             hir::StmtKind::Local(ref local) => {\n                 self.walk_local(&local);\n             }\n@@ -812,7 +812,7 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n         debug!(\"determine_pat_move_mode cmt_discr={:?} pat={:?}\", cmt_discr, pat);\n \n         return_if_err!(self.mc.cat_pattern(cmt_discr, pat, |cmt_pat, pat| {\n-            if let PatKind::Binding(..) = pat.node {\n+            if let PatKind::Binding(..) = pat.kind {\n                 let bm = *self.mc.tables.pat_binding_modes()\n                                         .get(pat.hir_id)\n                                         .expect(\"missing binding mode\");\n@@ -839,7 +839,7 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n         let tcx = self.tcx();\n         let ExprUseVisitor { ref mc, ref mut delegate, param_env } = *self;\n         return_if_err!(mc.cat_pattern(cmt_discr.clone(), pat, |cmt_pat, pat| {\n-            if let PatKind::Binding(_, canonical_id, ..) = pat.node {\n+            if let PatKind::Binding(_, canonical_id, ..) = pat.kind {\n                 debug!(\n                     \"walk_pat: binding cmt_pat={:?} pat={:?} match_mode={:?}\",\n                     cmt_pat,\n@@ -885,7 +885,7 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n         // to the above loop's visit of than the bindings that form\n         // the leaves of the pattern tree structure.\n         return_if_err!(mc.cat_pattern(cmt_discr, pat, |cmt_pat, pat| {\n-            let qpath = match pat.node {\n+            let qpath = match pat.kind {\n                 PatKind::Path(ref qpath) |\n                 PatKind::TupleStruct(ref qpath, ..) |\n                 PatKind::Struct(ref qpath, ..) => qpath,"}, {"sha": "ecca62349c985d96303b8b217cbccbf45818ed6f", "filename": "src/librustc/middle/intrinsicck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -150,7 +150,7 @@ impl Visitor<'tcx> for ExprVisitor<'tcx> {\n     }\n \n     fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n-        let res = if let hir::ExprKind::Path(ref qpath) = expr.node {\n+        let res = if let hir::ExprKind::Path(ref qpath) = expr.kind {\n             self.tables.qpath_res(qpath, expr.hir_id)\n         } else {\n             Res::Err"}, {"sha": "2d726fcd176124c5c99b4f3d00dc38f6a52f283d", "filename": "src/librustc/middle/lib_features.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc%2Fmiddle%2Flib_features.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc%2Fmiddle%2Flib_features.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flib_features.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -59,7 +59,7 @@ impl LibFeatureCollector<'tcx> {\n             attr.check_name(**stab_attr)\n         }) {\n             let meta_item = attr.meta();\n-            if let Some(MetaItem { node: MetaItemKind::List(ref metas), .. }) = meta_item {\n+            if let Some(MetaItem { kind: MetaItemKind::List(ref metas), .. }) = meta_item {\n                 let mut feature = None;\n                 let mut since = None;\n                 for meta in metas {"}, {"sha": "a654a26eb0b768ab89154b0288e334a65010c39b", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -372,7 +372,7 @@ fn visit_fn<'tcx>(\n     let body = ir.tcx.hir().body(body_id);\n \n     for param in &body.params {\n-        let is_shorthand = match param.pat.node {\n+        let is_shorthand = match param.pat.kind {\n             crate::hir::PatKind::Struct(..) => true,\n             _ => false,\n         };\n@@ -412,7 +412,7 @@ fn add_from_pat(ir: &mut IrMaps<'_>, pat: &P<hir::Pat>) {\n     pats.push_back(pat);\n     while let Some(pat) = pats.pop_front() {\n         use crate::hir::PatKind::*;\n-        match &pat.node {\n+        match &pat.kind {\n             Binding(.., inner_pat) => {\n                 pats.extend(inner_pat.iter());\n             }\n@@ -456,7 +456,7 @@ fn visit_arm<'tcx>(ir: &mut IrMaps<'tcx>, arm: &'tcx hir::Arm) {\n }\n \n fn visit_expr<'tcx>(ir: &mut IrMaps<'tcx>, expr: &'tcx Expr) {\n-    match expr.node {\n+    match expr.kind {\n       // live nodes required for uses or definitions of variables:\n       hir::ExprKind::Path(hir::QPath::Resolved(_, ref path)) => {\n         debug!(\"expr {}: path that leads to {:?}\", expr.hir_id, path.res);\n@@ -947,7 +947,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n     fn propagate_through_stmt(&mut self, stmt: &hir::Stmt, succ: LiveNode)\n                               -> LiveNode {\n-        match stmt.node {\n+        match stmt.kind {\n             hir::StmtKind::Local(ref local) => {\n                 // Note: we mark the variable as defined regardless of whether\n                 // there is an initializer.  Initially I had thought to only mark\n@@ -991,7 +991,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                               -> LiveNode {\n         debug!(\"propagate_through_expr: {}\", self.ir.tcx.hir().hir_to_pretty_string(expr.hir_id));\n \n-        match expr.node {\n+        match expr.kind {\n             // Interesting cases with control flow or which gen/kill\n             hir::ExprKind::Path(hir::QPath::Resolved(_, ref path)) => {\n                 self.access_path(expr.hir_id, path, succ, ACC_READ | ACC_USE)\n@@ -1259,7 +1259,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         // these errors are detected in the later pass borrowck.  We\n         // just ignore such cases and treat them as reads.\n \n-        match expr.node {\n+        match expr.kind {\n             hir::ExprKind::Path(_) => succ,\n             hir::ExprKind::Field(ref e, _) => self.propagate_through_expr(&e, succ),\n             _ => self.propagate_through_expr(expr, succ)\n@@ -1268,7 +1268,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n     // see comment on propagate_through_place()\n     fn write_place(&mut self, expr: &Expr, succ: LiveNode, acc: u32) -> LiveNode {\n-        match expr.node {\n+        match expr.kind {\n             hir::ExprKind::Path(hir::QPath::Resolved(_, ref path)) => {\n                 self.access_path(expr.hir_id, path, succ, acc)\n             }\n@@ -1377,7 +1377,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Liveness<'a, 'tcx> {\n }\n \n fn check_expr<'tcx>(this: &mut Liveness<'_, 'tcx>, expr: &'tcx Expr) {\n-    match expr.node {\n+    match expr.kind {\n         hir::ExprKind::Assign(ref l, _) => {\n             this.check_place(&l);\n         }\n@@ -1420,7 +1420,7 @@ fn check_expr<'tcx>(this: &mut Liveness<'_, 'tcx>, expr: &'tcx Expr) {\n \n impl<'tcx> Liveness<'_, 'tcx> {\n     fn check_place(&mut self, expr: &'tcx Expr) {\n-        match expr.node {\n+        match expr.kind {\n             hir::ExprKind::Path(hir::QPath::Resolved(_, ref path)) => {\n                 if let Res::Local(var_hid) = path.res {\n                     let upvars = self.ir.tcx.upvars(self.ir.body_owner);"}, {"sha": "c6a46f60927e8fe660e8506e6a1858db2d3894d8", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -271,7 +271,7 @@ impl MutabilityCategory {\n         id: hir::HirId,\n     ) -> MutabilityCategory {\n         let ret = match tcx.hir().get(id) {\n-            Node::Binding(p) => match p.node {\n+            Node::Binding(p) => match p.kind {\n                 PatKind::Binding(..) => {\n                     let bm = *tables.pat_binding_modes()\n                                     .get(p.hir_id)\n@@ -486,7 +486,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n \n         // This code detects whether we are looking at a `ref x`,\n         // and if so, figures out what the type *being borrowed* is.\n-        let ret_ty = match pat.node {\n+        let ret_ty = match pat.kind {\n             PatKind::Binding(..) => {\n                 let bm = *self.tables\n                               .pat_binding_modes()\n@@ -577,7 +577,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n         debug!(\"cat_expr: id={} expr={:?}\", expr.hir_id, expr);\n \n         let expr_ty = self.expr_ty(expr)?;\n-        match expr.node {\n+        match expr.kind {\n             hir::ExprKind::Unary(hir::UnDeref, ref e_base) => {\n                 if self.tables.is_method_call(expr) {\n                     self.cat_overloaded_place(expr, e_base, NoteNone)\n@@ -1212,7 +1212,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n         // that (where the `ref` on `x` is implied).\n         op(cmt.clone(), pat);\n \n-        match pat.node {\n+        match pat.kind {\n             PatKind::TupleStruct(ref qpath, ref subpats, ddpos) => {\n                 let res = self.tables.qpath_res(qpath, pat.hir_id);\n                 let (cmt, expected_len) = match res {"}, {"sha": "8be64bf64b5e91c8bcc3d07751c45396fced3621", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -32,7 +32,7 @@ fn item_might_be_inlined(tcx: TyCtxt<'tcx>, item: &hir::Item, attrs: CodegenFnAt\n         return true\n     }\n \n-    match item.node {\n+    match item.kind {\n         hir::ItemKind::Fn(_, header, ..) if header.is_const() => {\n             return true;\n         }\n@@ -55,7 +55,7 @@ fn method_might_be_inlined(\n     if codegen_fn_attrs.requests_inline() || generics.requires_monomorphization(tcx) {\n         return true\n     }\n-    if let hir::ImplItemKind::Method(method_sig, _) = &impl_item.node {\n+    if let hir::ImplItemKind::Method(method_sig, _) = &impl_item.kind {\n         if method_sig.header.is_const() {\n             return true\n         }\n@@ -100,7 +100,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ReachableContext<'a, 'tcx> {\n     }\n \n     fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n-        let res = match expr.node {\n+        let res = match expr.kind {\n             hir::ExprKind::Path(ref qpath) => {\n                 Some(self.tables.qpath_res(qpath, expr.hir_id))\n             }\n@@ -157,22 +157,22 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n \n         match self.tcx.hir().find(hir_id) {\n             Some(Node::Item(item)) => {\n-                match item.node {\n+                match item.kind {\n                     hir::ItemKind::Fn(..) =>\n                         item_might_be_inlined(self.tcx, &item, self.tcx.codegen_fn_attrs(def_id)),\n                     _ => false,\n                 }\n             }\n             Some(Node::TraitItem(trait_method)) => {\n-                match trait_method.node {\n+                match trait_method.kind {\n                     hir::TraitItemKind::Const(_, ref default) => default.is_some(),\n                     hir::TraitItemKind::Method(_, hir::TraitMethod::Provided(_)) => true,\n                     hir::TraitItemKind::Method(_, hir::TraitMethod::Required(_)) |\n                     hir::TraitItemKind::Type(..) => false,\n                 }\n             }\n             Some(Node::ImplItem(impl_item)) => {\n-                match impl_item.node {\n+                match impl_item.kind {\n                     hir::ImplItemKind::Const(..) => true,\n                     hir::ImplItemKind::Method(..) => {\n                         let attrs = self.tcx.codegen_fn_attrs(def_id);\n@@ -187,7 +187,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                             // type of the impl require inlining, this method\n                             // does too.\n                             let impl_hir_id = self.tcx.hir().as_local_hir_id(impl_did).unwrap();\n-                            match self.tcx.hir().expect_item(impl_hir_id).node {\n+                            match self.tcx.hir().expect_item(impl_hir_id).kind {\n                                 hir::ItemKind::Impl(..) => {\n                                     let generics = self.tcx.generics_of(impl_did);\n                                     generics.requires_monomorphization(self.tcx)\n@@ -225,7 +225,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n             // If we are building an executable, only explicitly extern\n             // types need to be exported.\n             if let Node::Item(item) = *node {\n-                let reachable = if let hir::ItemKind::Fn(_, header, ..) = item.node {\n+                let reachable = if let hir::ItemKind::Fn(_, header, ..) = item.kind {\n                     header.abi != Abi::Rust\n                 } else {\n                     false\n@@ -249,7 +249,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n \n         match *node {\n             Node::Item(item) => {\n-                match item.node {\n+                match item.kind {\n                     hir::ItemKind::Fn(.., body) => {\n                         let def_id = self.tcx.hir().local_def_id(item.hir_id);\n                         if item_might_be_inlined(self.tcx,\n@@ -286,7 +286,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                 }\n             }\n             Node::TraitItem(trait_method) => {\n-                match trait_method.node {\n+                match trait_method.kind {\n                     hir::TraitItemKind::Const(_, None) |\n                     hir::TraitItemKind::Method(_, hir::TraitMethod::Required(_)) => {\n                         // Keep going, nothing to get exported\n@@ -299,7 +299,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                 }\n             }\n             Node::ImplItem(impl_item) => {\n-                match impl_item.node {\n+                match impl_item.kind {\n                     hir::ImplItemKind::Const(_, body) => {\n                         self.visit_nested_body(body);\n                     }\n@@ -313,7 +313,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                     hir::ImplItemKind::TyAlias(_) => {}\n                 }\n             }\n-            Node::Expr(&hir::Expr { node: hir::ExprKind::Closure(.., body, _, _), .. }) => {\n+            Node::Expr(&hir::Expr { kind: hir::ExprKind::Closure(.., body, _, _), .. }) => {\n                 self.visit_nested_body(body);\n             }\n             // Nothing to recurse on for these\n@@ -361,7 +361,7 @@ impl<'a, 'tcx> ItemLikeVisitor<'tcx> for CollectPrivateImplItemsVisitor<'a, 'tcx\n         }\n \n         // We need only trait impls here, not inherent impls, and only non-exported ones\n-        if let hir::ItemKind::Impl(.., Some(ref trait_ref), _, ref impl_item_refs) = item.node {\n+        if let hir::ItemKind::Impl(.., Some(ref trait_ref), _, ref impl_item_refs) = item.kind {\n             if !self.access_levels.is_reachable(item.hir_id) {\n                 self.worklist.extend(impl_item_refs.iter().map(|ii_ref| ii_ref.id.hir_id));\n "}, {"sha": "28bf88321ae668fd4ff193d9a3fa6e00b5e70d6e", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -796,7 +796,7 @@ fn resolve_block<'tcx>(visitor: &mut RegionResolutionVisitor<'tcx>, blk: &'tcx h\n         // index information.)\n \n         for (i, statement) in blk.stmts.iter().enumerate() {\n-            match statement.node {\n+            match statement.kind {\n                 hir::StmtKind::Local(..) |\n                 hir::StmtKind::Item(..) => {\n                     // Each declaration introduces a subscope for bindings\n@@ -850,7 +850,7 @@ fn resolve_pat<'tcx>(visitor: &mut RegionResolutionVisitor<'tcx>, pat: &'tcx hir\n     visitor.record_child_scope(Scope { id: pat.hir_id.local_id, data: ScopeData::Node });\n \n     // If this is a binding then record the lifetime of that binding.\n-    if let PatKind::Binding(..) = pat.node {\n+    if let PatKind::Binding(..) = pat.kind {\n         record_var_lifetime(visitor, pat.hir_id.local_id, pat.span);\n     }\n \n@@ -893,7 +893,7 @@ fn resolve_expr<'tcx>(visitor: &mut RegionResolutionVisitor<'tcx>, expr: &'tcx h\n         let mut terminating = |id: hir::ItemLocalId| {\n             terminating_scopes.insert(id);\n         };\n-        match expr.node {\n+        match expr.kind {\n             // Conditional or repeating scopes are always terminating\n             // scopes, meaning that temporaries cannot outlive them.\n             // This ensures fixed size stacks.\n@@ -996,7 +996,7 @@ fn resolve_expr<'tcx>(visitor: &mut RegionResolutionVisitor<'tcx>, expr: &'tcx h\n     // properly, we can't miss any types.\n \n \n-    match expr.node {\n+    match expr.kind {\n         // Manually recurse over closures, because they are the only\n         // case of nested bodies that share the parent environment.\n         hir::ExprKind::Closure(.., body, _, _) => {\n@@ -1053,7 +1053,7 @@ fn resolve_expr<'tcx>(visitor: &mut RegionResolutionVisitor<'tcx>, expr: &'tcx h\n \n     debug!(\"resolve_expr post-increment {}, expr = {:?}\", visitor.expr_and_pat_count, expr);\n \n-    if let hir::ExprKind::Yield(_, source) = &expr.node {\n+    if let hir::ExprKind::Yield(_, source) = &expr.kind {\n         // Mark this expr's scope and all parent scopes as containing `yield`.\n         let mut scope = Scope { id: expr.hir_id.local_id, data: ScopeData::Node };\n         loop {\n@@ -1198,7 +1198,7 @@ fn resolve_local<'tcx>(\n         // In the former case (the implicit ref version), the temporary is created by the\n         // & expression, and its lifetime would be extended to the end of the block (due\n         // to a different rule, not the below code).\n-        match pat.node {\n+        match pat.kind {\n             PatKind::Binding(hir::BindingAnnotation::Ref, ..) |\n             PatKind::Binding(hir::BindingAnnotation::RefMut, ..) => true,\n \n@@ -1240,7 +1240,7 @@ fn resolve_local<'tcx>(\n         expr: &hir::Expr,\n         blk_id: Option<Scope>,\n     ) {\n-        match expr.node {\n+        match expr.kind {\n             hir::ExprKind::AddrOf(_, ref subexpr) => {\n                 record_rvalue_scope_if_borrow_expr(visitor, &subexpr, blk_id);\n                 record_rvalue_scope(visitor, &subexpr, blk_id);\n@@ -1300,7 +1300,7 @@ fn resolve_local<'tcx>(\n             // outer expression.\n             visitor.scope_tree.record_rvalue_scope(expr.hir_id.local_id, blk_scope);\n \n-            match expr.node {\n+            match expr.kind {\n                 hir::ExprKind::AddrOf(_, ref subexpr) |\n                 hir::ExprKind::Unary(hir::UnDeref, ref subexpr) |\n                 hir::ExprKind::Field(ref subexpr, _) |"}, {"sha": "94a85a97d36c9801f33301ccff749795a62ff038", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 32, "deletions": 33, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -459,7 +459,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n     }\n \n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n-        match item.node {\n+        match item.kind {\n             hir::ItemKind::Fn(ref decl, _, ref generics, _) => {\n                 self.visit_early_late(None, decl, generics, |this| {\n                     intravisit::walk_item(this, item);\n@@ -504,12 +504,12 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n             | hir::ItemKind::Impl(_, _, _, ref generics, ..) => {\n                 // Impls permit `'_` to be used and it is equivalent to \"some fresh lifetime name\".\n                 // This is not true for other kinds of items.x\n-                let track_lifetime_uses = match item.node {\n+                let track_lifetime_uses = match item.kind {\n                     hir::ItemKind::Impl(..) => true,\n                     _ => false,\n                 };\n                 // These kinds of items have only early-bound lifetime parameters.\n-                let mut index = if sub_items_have_self_param(&item.node) {\n+                let mut index = if sub_items_have_self_param(&item.kind) {\n                     1 // Self comes before lifetimes\n                 } else {\n                     0\n@@ -541,7 +541,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n     }\n \n     fn visit_foreign_item(&mut self, item: &'tcx hir::ForeignItem) {\n-        match item.node {\n+        match item.kind {\n             hir::ForeignItemKind::Fn(ref decl, _, ref generics) => {\n                 self.visit_early_late(None, decl, generics, |this| {\n                     intravisit::walk_foreign_item(this, item);\n@@ -558,8 +558,8 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n \n     fn visit_ty(&mut self, ty: &'tcx hir::Ty) {\n         debug!(\"visit_ty: id={:?} ty={:?}\", ty.hir_id, ty);\n-        debug!(\"visit_ty: ty.node={:?}\", ty.node);\n-        match ty.node {\n+        debug!(\"visit_ty: ty.kind={:?}\", ty.kind);\n+        match ty.kind {\n             hir::TyKind::BareFn(ref c) => {\n                 let next_early_index = self.next_early_index();\n                 let was_in_fn_syntax = self.is_in_fn_syntax;\n@@ -637,8 +637,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 // `type MyAnonTy<'b> = impl MyTrait<'b>;`\n                 //                 ^                  ^ this gets resolved in the scope of\n                 //                                      the opaque_ty generics\n-                let (generics, bounds) = match self.tcx.hir().expect_item(item_id.id).node\n-                {\n+                let (generics, bounds) = match self.tcx.hir().expect_item(item_id.id).kind {\n                     // Named opaque `impl Trait` types are reached via `TyKind::Path`.\n                     // This arm is for `impl Trait` in the types of statics, constants and locals.\n                     hir::ItemKind::OpaqueTy(hir::OpaqueTy {\n@@ -778,7 +777,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n \n     fn visit_trait_item(&mut self, trait_item: &'tcx hir::TraitItem) {\n         use self::hir::TraitItemKind::*;\n-        match trait_item.node {\n+        match trait_item.kind {\n             Method(ref sig, _) => {\n                 let tcx = self.tcx;\n                 self.visit_early_late(\n@@ -830,7 +829,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n \n     fn visit_impl_item(&mut self, impl_item: &'tcx hir::ImplItem) {\n         use self::hir::ImplItemKind::*;\n-        match impl_item.node {\n+        match impl_item.kind {\n             Method(ref sig, _) => {\n                 let tcx = self.tcx;\n                 self.visit_early_late(\n@@ -1214,7 +1213,7 @@ fn extract_labels(ctxt: &mut LifetimeContext<'_, '_>, body: &hir::Body) {\n     }\n \n     fn expression_label(ex: &hir::Expr) -> Option<ast::Ident> {\n-        if let hir::ExprKind::Loop(_, Some(label), _) = ex.node {\n+        if let hir::ExprKind::Loop(_, Some(label), _) = ex.kind {\n             Some(label.ident)\n         } else {\n             None\n@@ -1263,7 +1262,7 @@ fn extract_labels(ctxt: &mut LifetimeContext<'_, '_>, body: &hir::Body) {\n fn compute_object_lifetime_defaults(tcx: TyCtxt<'_>) -> HirIdMap<Vec<ObjectLifetimeDefault>> {\n     let mut map = HirIdMap::default();\n     for item in tcx.hir().krate().items.values() {\n-        match item.node {\n+        match item.kind {\n             hir::ItemKind::Struct(_, ref generics)\n             | hir::ItemKind::Union(_, ref generics)\n             | hir::ItemKind::Enum(_, ref generics)\n@@ -1352,7 +1351,7 @@ fn object_lifetime_defaults_for_item(\n                         continue;\n                     }\n \n-                    let res = match data.bounded_ty.node {\n+                    let res = match data.bounded_ty.kind {\n                         hir::TyKind::Path(hir::QPath::Resolved(None, ref path)) => path.res,\n                         _ => continue,\n                     };\n@@ -1487,7 +1486,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         let mut elide_use = None;\n         let mut find_arg_use_span = |inputs: &hir::HirVec<hir::Ty>| {\n             for input in inputs {\n-                match input.node {\n+                match input.kind {\n                     hir::TyKind::Rptr(lt, _) => {\n                         if lt.name.ident() == name {\n                             // include the trailing whitespace between the lifetime and type names\n@@ -1525,12 +1524,12 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             {\n                 match parent {\n                     Node::Item(item) => {\n-                        if let hir::ItemKind::Fn(decl, _, _, _) = &item.node {\n+                        if let hir::ItemKind::Fn(decl, _, _, _) = &item.kind {\n                             find_arg_use_span(&decl.inputs);\n                         }\n                     },\n                     Node::ImplItem(impl_item) => {\n-                        if let hir::ImplItemKind::Method(sig, _) = &impl_item.node {\n+                        if let hir::ImplItemKind::Method(sig, _) = &impl_item.kind {\n                             find_arg_use_span(&sig.decl.inputs);\n                         }\n                     }\n@@ -1733,10 +1732,10 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         let mut index = 0;\n         if let Some(parent_id) = parent_id {\n             let parent = self.tcx.hir().expect_item(parent_id);\n-            if sub_items_have_self_param(&parent.node) {\n+            if sub_items_have_self_param(&parent.kind) {\n                 index += 1; // Self comes before lifetimes\n             }\n-            match parent.node {\n+            match parent.kind {\n                 hir::ItemKind::Trait(_, _, ref generics, ..)\n                 | hir::ItemKind::Impl(_, _, _, ref generics, ..) => {\n                     index += generics.params.len() as u32;\n@@ -1867,15 +1866,15 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 let fn_id = self.tcx.hir().body_owner(body_id);\n                 match self.tcx.hir().get(fn_id) {\n                     Node::Item(&hir::Item {\n-                        node: hir::ItemKind::Fn(..),\n+                        kind: hir::ItemKind::Fn(..),\n                         ..\n                     })\n                     | Node::TraitItem(&hir::TraitItem {\n-                        node: hir::TraitItemKind::Method(..),\n+                        kind: hir::TraitItemKind::Method(..),\n                         ..\n                     })\n                     | Node::ImplItem(&hir::ImplItem {\n-                        node: hir::ImplItemKind::Method(..),\n+                        kind: hir::ImplItemKind::Method(..),\n                         ..\n                     }) => {\n                         let scope = self.tcx.hir().local_def_id(fn_id);\n@@ -2165,18 +2164,18 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         let body = match self.tcx.hir().get(parent) {\n             // `fn` definitions and methods.\n             Node::Item(&hir::Item {\n-                node: hir::ItemKind::Fn(.., body),\n+                kind: hir::ItemKind::Fn(.., body),\n                 ..\n             }) => Some(body),\n \n             Node::TraitItem(&hir::TraitItem {\n-                node: hir::TraitItemKind::Method(_, ref m),\n+                kind: hir::TraitItemKind::Method(_, ref m),\n                 ..\n             }) => {\n                 if let hir::ItemKind::Trait(.., ref trait_items) = self.tcx\n                     .hir()\n                     .expect_item(self.tcx.hir().get_parent_item(parent))\n-                    .node\n+                    .kind\n                 {\n                     assoc_item_kind = trait_items\n                         .iter()\n@@ -2190,13 +2189,13 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             }\n \n             Node::ImplItem(&hir::ImplItem {\n-                node: hir::ImplItemKind::Method(_, body),\n+                kind: hir::ImplItemKind::Method(_, body),\n                 ..\n             }) => {\n                 if let hir::ItemKind::Impl(.., ref self_ty, ref impl_items) = self.tcx\n                     .hir()\n                     .expect_item(self.tcx.hir().get_parent_item(parent))\n-                    .node\n+                    .kind\n                 {\n                     impl_self = Some(self_ty);\n                     assoc_item_kind = impl_items\n@@ -2270,8 +2269,8 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 }\n \n                 fn visit_ty(&mut self, ty: &'a hir::Ty) {\n-                    if let hir::TyKind::Rptr(lifetime_ref, ref mt) = ty.node {\n-                        if let hir::TyKind::Path(hir::QPath::Resolved(None, ref path)) = mt.ty.node\n+                    if let hir::TyKind::Rptr(lifetime_ref, ref mt) = ty.kind {\n+                        if let hir::TyKind::Path(hir::QPath::Resolved(None, ref path)) = mt.ty.kind\n                         {\n                             if self.is_self_ty(path.res) {\n                                 if let Some(lifetime) = self.map.defs.get(&lifetime_ref.hir_id) {\n@@ -2286,7 +2285,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n \n             let mut visitor = SelfVisitor {\n                 map: self.map,\n-                impl_self: impl_self.map(|ty| &ty.node),\n+                impl_self: impl_self.map(|ty| &ty.kind),\n                 lifetime: Set1::Empty,\n             };\n             visitor.visit_ty(&inputs[0]);\n@@ -2364,10 +2363,10 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             }\n \n             fn visit_ty(&mut self, ty: &hir::Ty) {\n-                if let hir::TyKind::BareFn(_) = ty.node {\n+                if let hir::TyKind::BareFn(_) = ty.kind {\n                     self.outer_index.shift_in(1);\n                 }\n-                match ty.node {\n+                match ty.kind {\n                     hir::TyKind::TraitObject(ref bounds, ref lifetime) => {\n                         for bound in bounds {\n                             self.visit_poly_trait_ref(bound, hir::TraitBoundModifier::None);\n@@ -2384,7 +2383,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                         intravisit::walk_ty(self, ty);\n                     }\n                 }\n-                if let hir::TyKind::BareFn(_) = ty.node {\n+                if let hir::TyKind::BareFn(_) = ty.kind {\n                     self.outer_index.shift_out(1);\n                 }\n             }\n@@ -2991,7 +2990,7 @@ fn insert_late_bound_lifetimes(\n         }\n \n         fn visit_ty(&mut self, ty: &'v hir::Ty) {\n-            match ty.node {\n+            match ty.kind {\n                 hir::TyKind::Path(hir::QPath::Resolved(Some(_), _))\n                 | hir::TyKind::Path(hir::QPath::TypeRelative(..)) => {\n                     // ignore lifetimes appearing in associated type"}, {"sha": "9e053ce4e69c277232f445abc283d4b52fe16dab", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -246,7 +246,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Annotator<'a, 'tcx> {\n     fn visit_item(&mut self, i: &'tcx Item) {\n         let orig_in_trait_impl = self.in_trait_impl;\n         let mut kind = AnnotationKind::Required;\n-        match i.node {\n+        match i.kind {\n             // Inherent impls and foreign modules serve only as containers for other items,\n             // they don't have their own stability. They still can be annotated as unstable\n             // and propagate this unstability to children, but this annotation is completely\n@@ -344,14 +344,14 @@ impl<'a, 'tcx> Visitor<'tcx> for MissingStabilityAnnotations<'a, 'tcx> {\n     }\n \n     fn visit_item(&mut self, i: &'tcx Item) {\n-        match i.node {\n+        match i.kind {\n             // Inherent impls and foreign modules serve only as containers for other items,\n             // they don't have their own stability. They still can be annotated as unstable\n             // and propagate this unstability to children, but this annotation is completely\n             // optional. They inherit stability from their parents when unannotated.\n             hir::ItemKind::Impl(.., None, _, _) | hir::ItemKind::ForeignMod(..) => {}\n \n-            _ => self.check_missing_stability(i.hir_id, i.span, i.node.descriptive_variant())\n+            _ => self.check_missing_stability(i.hir_id, i.span, i.kind.descriptive_variant())\n         }\n \n         intravisit::walk_item(self, i)\n@@ -382,7 +382,7 @@ impl<'a, 'tcx> Visitor<'tcx> for MissingStabilityAnnotations<'a, 'tcx> {\n     }\n \n     fn visit_foreign_item(&mut self, i: &'tcx hir::ForeignItem) {\n-        self.check_missing_stability(i.hir_id, i.span, i.node.descriptive_variant());\n+        self.check_missing_stability(i.hir_id, i.span, i.kind.descriptive_variant());\n         intravisit::walk_foreign_item(self, i);\n     }\n \n@@ -797,7 +797,7 @@ impl Visitor<'tcx> for Checker<'tcx> {\n     }\n \n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n-        match item.node {\n+        match item.kind {\n             hir::ItemKind::ExternCrate(_) => {\n                 // compiler-generated `extern crate` items have a dummy span.\n                 if item.span.is_dummy() { return }"}, {"sha": "73b731b07619dc68a31337551bcb9a272ed7257d", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -1879,11 +1879,11 @@ pub fn parse_cfgspecs(cfgspecs: Vec<String>) -> FxHashSet<(String, Option<String\n                     if meta_item.path.segments.len() != 1 {\n                         error!(\"argument key must be an identifier\");\n                     }\n-                    match &meta_item.node {\n+                    match &meta_item.kind {\n                         MetaItemKind::List(..) => {\n                             error!(r#\"expected `key` or `key=\"value\"`\"#);\n                         }\n-                        MetaItemKind::NameValue(lit) if !lit.node.is_str() => {\n+                        MetaItemKind::NameValue(lit) if !lit.kind.is_str() => {\n                             error!(\"argument value must be a string\");\n                         }\n                         MetaItemKind::NameValue(..) | MetaItemKind::Word => {"}, {"sha": "1ce5d72ba848e0e9f2f24373ff4efa55294550fd", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -956,7 +956,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             let parent_node = self.tcx.hir().get_parent_node(hir_id);\n             if let Some(Node::Local(ref local)) = self.tcx.hir().find(parent_node) {\n                 if let Some(ref expr) = local.init {\n-                    if let hir::ExprKind::Index(_, _) = expr.node {\n+                    if let hir::ExprKind::Index(_, _) = expr.kind {\n                         if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(expr.span) {\n                             err.span_suggestion(\n                                 expr.span,\n@@ -1001,7 +1001,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     Ok(EvaluationResult::EvaluatedToAmbig) => {\n                         if let Some(hir::Node::Item(hir::Item {\n                             ident,\n-                            node: hir::ItemKind::Fn(.., body_id),\n+                            kind: hir::ItemKind::Fn(.., body_id),\n                             ..\n                         })) = self.tcx.hir().get_if_local(def_id) {\n                             let body = self.tcx.hir().body(*body_id);\n@@ -1010,7 +1010,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                                 \"{}({})\",\n                                 ident,\n                                 body.params.iter()\n-                                    .map(|arg| match &arg.pat.node {\n+                                    .map(|arg| match &arg.pat.kind {\n                                         hir::PatKind::Binding(_, _, ident, None)\n                                         if ident.name != kw::SelfLower => ident.to_string(),\n                                         _ => \"_\".to_string(),\n@@ -1106,11 +1106,11 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         let parent_node = hir.get_parent_node(obligation.cause.body_id);\n         let node = hir.find(parent_node);\n         if let Some(hir::Node::Item(hir::Item {\n-            node: hir::ItemKind::Fn(decl, _, _, body_id),\n+            kind: hir::ItemKind::Fn(decl, _, _, body_id),\n             ..\n         })) = node {\n             let body = hir.body(*body_id);\n-            if let hir::ExprKind::Block(blk, _) = &body.value.node {\n+            if let hir::ExprKind::Block(blk, _) = &body.value.kind {\n                 if decl.output.span().overlaps(span) && blk.expr.is_none() &&\n                     \"()\" == &trait_ref.self_ty().to_string()\n                 {\n@@ -1134,14 +1134,14 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     pub fn get_fn_like_arguments(&self, node: Node<'_>) -> (Span, Vec<ArgKind>) {\n         match node {\n             Node::Expr(&hir::Expr {\n-                node: hir::ExprKind::Closure(_, ref _decl, id, span, _),\n+                kind: hir::ExprKind::Closure(_, ref _decl, id, span, _),\n                 ..\n             }) => {\n                 (self.tcx.sess.source_map().def_span(span),\n                  self.tcx.hir().body(id).params.iter()\n                     .map(|arg| {\n                         if let hir::Pat {\n-                            node: hir::PatKind::Tuple(ref args, _),\n+                            kind: hir::PatKind::Tuple(ref args, _),\n                             span,\n                             ..\n                         } = *arg.pat {\n@@ -1163,21 +1163,21 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             }\n             Node::Item(&hir::Item {\n                 span,\n-                node: hir::ItemKind::Fn(ref decl, ..),\n+                kind: hir::ItemKind::Fn(ref decl, ..),\n                 ..\n             }) |\n             Node::ImplItem(&hir::ImplItem {\n                 span,\n-                node: hir::ImplItemKind::Method(hir::MethodSig { ref decl, .. }, _),\n+                kind: hir::ImplItemKind::Method(hir::MethodSig { ref decl, .. }, _),\n                 ..\n             }) |\n             Node::TraitItem(&hir::TraitItem {\n                 span,\n-                node: hir::TraitItemKind::Method(hir::MethodSig { ref decl, .. }, _),\n+                kind: hir::TraitItemKind::Method(hir::MethodSig { ref decl, .. }, _),\n                 ..\n             }) => {\n                 (self.tcx.sess.source_map().def_span(span), decl.inputs.iter()\n-                        .map(|arg| match arg.clone().node {\n+                        .map(|arg| match arg.clone().kind {\n                     hir::TyKind::Tup(ref tys) => ArgKind::Tuple(\n                         Some(arg.span),\n                         vec![(\"_\".to_owned(), \"_\".to_owned()); tys.len()]"}, {"sha": "6d0347563d0037bcebcfbaadbc27b3ed5dd68173", "filename": "src/librustc/traits/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Futil.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -654,7 +654,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         match self.hir().as_local_hir_id(node_item_def_id) {\n             Some(hir_id) => {\n                 let item = self.hir().expect_item(hir_id);\n-                if let hir::ItemKind::Impl(_, _, defaultness, ..) = item.node {\n+                if let hir::ItemKind::Impl(_, _, defaultness, ..) = item.kind {\n                     defaultness.is_default()\n                 } else {\n                     false"}, {"sha": "3c511cb4d188d20085e39b40e69f61a890fa5e96", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -603,7 +603,7 @@ impl<'tcx> TypeckTables<'tcx> {\n     pub fn is_method_call(&self, expr: &hir::Expr) -> bool {\n         // Only paths and method calls/overloaded operators have\n         // entries in type_dependent_defs, ignore the former here.\n-        if let hir::ExprKind::Path(_) = expr.node {\n+        if let hir::ExprKind::Path(_) = expr.kind {\n             return false;\n         }\n \n@@ -1141,7 +1141,7 @@ impl<'tcx> TyCtxt<'tcx> {\n                 None => return Bound::Unbounded,\n             };\n             for meta in attr.meta_item_list().expect(\"rustc_layout_scalar_valid_range takes args\") {\n-                match meta.literal().expect(\"attribute takes lit\").node {\n+                match meta.literal().expect(\"attribute takes lit\").kind {\n                     ast::LitKind::Int(a, _) => return Bound::Included(a),\n                     _ => span_bug!(attr.span, \"rustc_layout_scalar_valid_range expects int arg\"),\n                 }\n@@ -1543,7 +1543,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         let hir_id = self.hir().as_local_hir_id(scope_def_id).unwrap();\n         match self.hir().get(hir_id) {\n             Node::Item(item) => {\n-                match item.node {\n+                match item.kind {\n                     ItemKind::Fn(..) => { /* `type_of_def_id()` will work */ }\n                     _ => {\n                         return None;"}, {"sha": "f107af0cd07ecbf8abd489978cc52d88fd7fbdfa", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -3164,7 +3164,7 @@ fn associated_item(tcx: TyCtxt<'_>, def_id: DefId) -> AssocItem {\n     let parent_id = tcx.hir().get_parent_item(id);\n     let parent_def_id = tcx.hir().local_def_id(parent_id);\n     let parent_item = tcx.hir().expect_item(parent_id);\n-    match parent_item.node {\n+    match parent_item.kind {\n         hir::ItemKind::Impl(.., ref impl_item_refs) => {\n             if let Some(impl_item_ref) = impl_item_refs.iter().find(|i| i.id.hir_id == id) {\n                 let assoc_item = tcx.associated_item_from_impl_item_ref(parent_def_id,\n@@ -3189,7 +3189,7 @@ fn associated_item(tcx: TyCtxt<'_>, def_id: DefId) -> AssocItem {\n \n     span_bug!(parent_item.span,\n               \"unexpected parent of trait or impl item or item not found: {:?}\",\n-              parent_item.node)\n+              parent_item.kind)\n }\n \n #[derive(Clone, HashStable)]\n@@ -3221,7 +3221,7 @@ fn adt_sized_constraint(tcx: TyCtxt<'_>, def_id: DefId) -> AdtSizedConstraint<'_\n fn associated_item_def_ids(tcx: TyCtxt<'_>, def_id: DefId) -> &[DefId] {\n     let id = tcx.hir().as_local_hir_id(def_id).unwrap();\n     let item = tcx.hir().expect_item(id);\n-    match item.node {\n+    match item.kind {\n         hir::ItemKind::Trait(.., ref trait_item_refs) => {\n             tcx.arena.alloc_from_iter(\n                 trait_item_refs.iter()\n@@ -3262,7 +3262,7 @@ fn trait_of_item(tcx: TyCtxt<'_>, def_id: DefId) -> Option<DefId> {\n pub fn is_impl_trait_defn(tcx: TyCtxt<'_>, def_id: DefId) -> Option<DefId> {\n     if let Some(hir_id) = tcx.hir().as_local_hir_id(def_id) {\n         if let Node::Item(item) = tcx.hir().get(hir_id) {\n-            if let hir::ItemKind::OpaqueTy(ref opaque_ty) = item.node {\n+            if let hir::ItemKind::OpaqueTy(ref opaque_ty) = item.kind {\n                 return opaque_ty.impl_trait_fn;\n             }\n         }"}, {"sha": "dd2aeb4276faacd46ac8dabee260bb6a3703adaa", "filename": "src/librustc_ast_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_ast_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_ast_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -177,7 +177,7 @@ pub fn check_loans<'a, 'tcx>(\n     let hir_id = bccx.tcx.hir().as_local_hir_id(def_id).unwrap();\n     let movable_generator = !match bccx.tcx.hir().get(hir_id) {\n         Node::Expr(&hir::Expr {\n-            node: hir::ExprKind::Closure(.., Some(hir::GeneratorMovability::Static)),\n+            kind: hir::ExprKind::Closure(.., Some(hir::GeneratorMovability::Static)),\n             ..\n         }) => true,\n         _ => false,"}, {"sha": "40e28299a5c0a15eac451b9565c236298d125dc7", "filename": "src/librustc_ast_borrowck/borrowck/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_ast_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_ast_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_borrowck%2Fborrowck%2Fmod.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -338,7 +338,7 @@ pub enum LoanPathElem<'tcx> {\n fn closure_to_block(closure_id: LocalDefId, tcx: TyCtxt<'_>) -> HirId {\n     let closure_id = tcx.hir().local_def_id_to_hir_id(closure_id);\n     match tcx.hir().get(closure_id) {\n-        Node::Expr(expr) => match expr.node {\n+        Node::Expr(expr) => match expr.kind {\n             hir::ExprKind::Closure(.., body_id, _, _) => {\n                 body_id.hir_id\n             }"}, {"sha": "ec7f40f8c9718f1c2fc09a6e6c6eaf382da169fb", "filename": "src/librustc_ast_borrowck/cfg/construct.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_ast_borrowck%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_ast_borrowck%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_borrowck%2Fcfg%2Fconstruct.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -99,7 +99,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n     }\n \n     fn stmt(&mut self, stmt: &hir::Stmt, pred: CFGIndex) -> CFGIndex {\n-        let exit = match stmt.node {\n+        let exit = match stmt.kind {\n             hir::StmtKind::Local(ref local) => {\n                 let init_exit = self.opt_expr(&local.init, pred);\n                 self.pat(&local.pat, init_exit)\n@@ -114,7 +114,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n     }\n \n     fn pat(&mut self, pat: &hir::Pat, pred: CFGIndex) -> CFGIndex {\n-        match pat.node {\n+        match pat.kind {\n             PatKind::Binding(.., None) |\n             PatKind::Path(_) |\n             PatKind::Lit(..) |\n@@ -163,7 +163,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n     }\n \n     fn expr(&mut self, expr: &hir::Expr, pred: CFGIndex) -> CFGIndex {\n-        match expr.node {\n+        match expr.kind {\n             hir::ExprKind::Block(ref blk, _) => {\n                 let blk_exit = self.block(&blk, pred);\n                 self.add_ast_node(expr.hir_id.local_id, &[blk_exit])"}, {"sha": "cba5ee3260c16a8ed58d9cd4aad28d56500b6280", "filename": "src/librustc_codegen_llvm/consts.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fconsts.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -230,7 +230,7 @@ impl CodegenCx<'ll, 'tcx> {\n             let llty = self.layout_of(ty).llvm_type(self);\n             let (g, attrs) = match self.tcx.hir().get(id) {\n                 Node::Item(&hir::Item {\n-                    ref attrs, span, node: hir::ItemKind::Static(..), ..\n+                    ref attrs, span, kind: hir::ItemKind::Static(..), ..\n                 }) => {\n                     let sym_str = sym.as_str();\n                     if self.get_declared_value(&sym_str).is_some() {\n@@ -249,7 +249,7 @@ impl CodegenCx<'ll, 'tcx> {\n                 }\n \n                 Node::ForeignItem(&hir::ForeignItem {\n-                    ref attrs, span, node: hir::ForeignItemKind::Static(..), ..\n+                    ref attrs, span, kind: hir::ForeignItemKind::Static(..), ..\n                 }) => {\n                     let fn_attrs = self.tcx.codegen_fn_attrs(def_id);\n                     (check_and_apply_linkage(&self, &fn_attrs, ty, sym, span), attrs)"}, {"sha": "d634b73430a583f2e7a0b46e86fe09a89ea5155f", "filename": "src/librustc_codegen_ssa/back/symbol_export.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -94,14 +94,14 @@ fn reachable_non_generics_provider(\n \n                 // Only consider nodes that actually have exported symbols.\n                 Node::Item(&hir::Item {\n-                    node: hir::ItemKind::Static(..),\n+                    kind: hir::ItemKind::Static(..),\n                     ..\n                 }) |\n                 Node::Item(&hir::Item {\n-                    node: hir::ItemKind::Fn(..), ..\n+                    kind: hir::ItemKind::Fn(..), ..\n                 }) |\n                 Node::ImplItem(&hir::ImplItem {\n-                    node: hir::ImplItemKind::Method(..),\n+                    kind: hir::ImplItemKind::Method(..),\n                     ..\n                 }) => {\n                     let def_id = tcx.hir().local_def_id(hir_id);\n@@ -367,7 +367,7 @@ fn symbol_export_level(tcx: TyCtxt<'_>, sym_def_id: DefId) -> SymbolExportLevel\n         // Emscripten cannot export statics, so reduce their export level here\n         if tcx.sess.target.target.options.is_like_emscripten {\n             if let Some(Node::Item(&hir::Item {\n-                node: hir::ItemKind::Static(..),\n+                kind: hir::ItemKind::Static(..),\n                 ..\n             })) = tcx.hir().get_if_local(sym_def_id) {\n                 return SymbolExportLevel::Rust;"}, {"sha": "10177d2997a76ffbd81a82e27cad229ced5d11d5", "filename": "src/librustc_codegen_ssa/mono_item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_codegen_ssa%2Fmono_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_codegen_ssa%2Fmono_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmono_item.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -30,7 +30,7 @@ impl<'a, 'tcx: 'a> MonoItemExt<'a, 'tcx> for MonoItem<'tcx> {\n             }\n             MonoItem::GlobalAsm(hir_id) => {\n                 let item = cx.tcx().hir().expect_item(hir_id);\n-                if let hir::ItemKind::GlobalAsm(ref ga) = item.node {\n+                if let hir::ItemKind::GlobalAsm(ref ga) = item.kind {\n                     cx.codegen_global_asm(ga);\n                 } else {\n                     span_bug!(item.span, \"Mismatch between hir::Item type and MonoItem type\")"}, {"sha": "774a5af1b1ca804d25b11a12aa294a4b28fc305a", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -700,7 +700,7 @@ impl RustcDefaultCalls {\n                     let mut cfgs = sess.parse_sess.config.iter().filter_map(|&(name, ref value)| {\n                         let gated_cfg = GatedCfg::gate(&ast::MetaItem {\n                             path: ast::Path::from_ident(ast::Ident::with_dummy_span(name)),\n-                            node: ast::MetaItemKind::Word,\n+                            kind: ast::MetaItemKind::Word,\n                             span: DUMMY_SP,\n                         });\n "}, {"sha": "abe0ffb0e02c5366367c02d159ed2f15ac978976", "filename": "src/librustc_incremental/persist/dirty_clean.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -327,7 +327,7 @@ impl DirtyCleanVisitor<'tcx> {\n         let node = self.tcx.hir().get(item_id);\n         let (name, labels) = match node {\n             HirNode::Item(item) => {\n-                match item.node {\n+                match item.kind {\n                     // note: these are in the same order as hir::Item_;\n                     // FIXME(michaelwoerister): do commented out ones\n \n@@ -391,20 +391,20 @@ impl DirtyCleanVisitor<'tcx> {\n                         &format!(\n                             \"clean/dirty auto-assertions not yet defined \\\n                              for Node::Item.node={:?}\",\n-                            item.node\n+                            item.kind\n                         )\n                     ),\n                 }\n             },\n             HirNode::TraitItem(item) => {\n-                match item.node {\n+                match item.kind {\n                     TraitItemKind::Method(..) => (\"Node::TraitItem\", LABELS_FN_IN_TRAIT),\n                     TraitItemKind::Const(..) => (\"NodeTraitConst\", LABELS_CONST_IN_TRAIT),\n                     TraitItemKind::Type(..) => (\"NodeTraitType\", LABELS_CONST_IN_TRAIT),\n                 }\n             },\n             HirNode::ImplItem(item) => {\n-                match item.node {\n+                match item.kind {\n                     ImplItemKind::Method(..) => (\"Node::ImplItem\", LABELS_FN_IN_IMPL),\n                     ImplItemKind::Const(..) => (\"NodeImplConst\", LABELS_CONST_IN_IMPL),\n                     ImplItemKind::TyAlias(..) => (\"NodeImplType\", LABELS_CONST_IN_IMPL),"}, {"sha": "72df875fc8f4f4e80269f0fd73f08e604f21d25f", "filename": "src/librustc_interface/util.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_interface%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_interface%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Futil.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -556,7 +556,7 @@ pub fn collect_crate_types(session: &Session, attrs: &[ast::Attribute]) -> Vec<c\n                             sym::bin\n                         ];\n \n-                        if let ast::MetaItemKind::NameValue(spanned) = a.meta().unwrap().node {\n+                        if let ast::MetaItemKind::NameValue(spanned) = a.meta().unwrap().kind {\n                             let span = spanned.span;\n                             let lev_candidate = find_best_match_for_name(\n                                 crate_types.iter(),\n@@ -738,7 +738,7 @@ impl<'a> ReplaceBodyWithLoop<'a> {\n     fn should_ignore_fn(ret_ty: &ast::FnDecl) -> bool {\n         if let ast::FunctionRetTy::Ty(ref ty) = ret_ty.output {\n             fn involves_impl_trait(ty: &ast::Ty) -> bool {\n-                match ty.node {\n+                match ty.kind {\n                     ast::TyKind::ImplTrait(..) => true,\n                     ast::TyKind::Slice(ref subty) |\n                     ast::TyKind::Array(ref subty, _) |\n@@ -796,7 +796,7 @@ impl<'a> MutVisitor for ReplaceBodyWithLoop<'a> {\n     }\n \n     fn flat_map_trait_item(&mut self, i: ast::TraitItem) -> SmallVec<[ast::TraitItem; 1]> {\n-        let is_const = match i.node {\n+        let is_const = match i.kind {\n             ast::TraitItemKind::Const(..) => true,\n             ast::TraitItemKind::Method(ast::MethodSig { ref decl, ref header, .. }, _) =>\n                 header.constness.node == ast::Constness::Const || Self::should_ignore_fn(decl),\n@@ -806,7 +806,7 @@ impl<'a> MutVisitor for ReplaceBodyWithLoop<'a> {\n     }\n \n     fn flat_map_impl_item(&mut self, i: ast::ImplItem) -> SmallVec<[ast::ImplItem; 1]> {\n-        let is_const = match i.node {\n+        let is_const = match i.kind {\n             ast::ImplItemKind::Const(..) => true,\n             ast::ImplItemKind::Method(ast::MethodSig { ref decl, ref header, .. }, _) =>\n                 header.constness.node == ast::Constness::Const || Self::should_ignore_fn(decl),\n@@ -834,21 +834,21 @@ impl<'a> MutVisitor for ReplaceBodyWithLoop<'a> {\n         fn block_to_stmt(b: ast::Block, sess: &Session) -> ast::Stmt {\n             let expr = P(ast::Expr {\n                 id: sess.next_node_id(),\n-                node: ast::ExprKind::Block(P(b), None),\n+                kind: ast::ExprKind::Block(P(b), None),\n                 span: syntax_pos::DUMMY_SP,\n                 attrs: ThinVec::new(),\n             });\n \n             ast::Stmt {\n                 id: sess.next_node_id(),\n-                node: ast::StmtKind::Expr(expr),\n+                kind: ast::StmtKind::Expr(expr),\n                 span: syntax_pos::DUMMY_SP,\n             }\n         }\n \n         let empty_block = stmt_to_block(BlockCheckMode::Default, None, self.sess);\n         let loop_expr = P(ast::Expr {\n-            node: ast::ExprKind::Loop(P(empty_block), None),\n+            kind: ast::ExprKind::Loop(P(empty_block), None),\n             id: self.sess.next_node_id(),\n             span: syntax_pos::DUMMY_SP,\n                 attrs: ThinVec::new(),\n@@ -857,7 +857,7 @@ impl<'a> MutVisitor for ReplaceBodyWithLoop<'a> {\n         let loop_stmt = ast::Stmt {\n             id: self.sess.next_node_id(),\n             span: syntax_pos::DUMMY_SP,\n-            node: ast::StmtKind::Expr(loop_expr),\n+            kind: ast::StmtKind::Expr(loop_expr),\n         };\n \n         if self.within_static_or_const {"}, {"sha": "d0a7eab071c311de1e85c66bc8ed89829c15cfac", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 37, "deletions": 37, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -67,17 +67,17 @@ declare_lint_pass!(WhileTrue => [WHILE_TRUE]);\n \n /// Traverse through any amount of parenthesis and return the first non-parens expression.\n fn pierce_parens(mut expr: &ast::Expr) -> &ast::Expr {\n-    while let ast::ExprKind::Paren(sub) = &expr.node {\n+    while let ast::ExprKind::Paren(sub) = &expr.kind {\n         expr = sub;\n     }\n     expr\n }\n \n impl EarlyLintPass for WhileTrue {\n     fn check_expr(&mut self, cx: &EarlyContext<'_>, e: &ast::Expr) {\n-        if let ast::ExprKind::While(cond, ..) = &e.node {\n-            if let ast::ExprKind::Lit(ref lit) = pierce_parens(cond).node {\n-                if let ast::LitKind::Bool(true) = lit.node {\n+        if let ast::ExprKind::While(cond, ..) = &e.kind {\n+            if let ast::ExprKind::Lit(ref lit) = pierce_parens(cond).kind {\n+                if let ast::LitKind::Bool(true) = lit.kind {\n                     if !lit.span.from_expansion() {\n                         let msg = \"denote infinite loops with `loop { ... }`\";\n                         let condition_span = cx.sess.source_map().def_span(e.span);\n@@ -117,7 +117,7 @@ impl BoxPointers {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for BoxPointers {\n     fn check_item(&mut self, cx: &LateContext<'_, '_>, it: &hir::Item) {\n-        match it.node {\n+        match it.kind {\n             hir::ItemKind::Fn(..) |\n             hir::ItemKind::TyAlias(..) |\n             hir::ItemKind::Enum(..) |\n@@ -130,7 +130,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for BoxPointers {\n         }\n \n         // If it's a struct, we also have to check the fields' types\n-        match it.node {\n+        match it.kind {\n             hir::ItemKind::Struct(ref struct_def, _) |\n             hir::ItemKind::Union(ref struct_def, _) => {\n                 for struct_field in struct_def.fields() {\n@@ -159,7 +159,7 @@ declare_lint_pass!(NonShorthandFieldPatterns => [NON_SHORTHAND_FIELD_PATTERNS]);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonShorthandFieldPatterns {\n     fn check_pat(&mut self, cx: &LateContext<'_, '_>, pat: &hir::Pat) {\n-        if let PatKind::Struct(ref qpath, ref field_pats, _) = pat.node {\n+        if let PatKind::Struct(ref qpath, ref field_pats, _) = pat.kind {\n             let variant = cx.tables.pat_ty(pat).ty_adt_def()\n                                    .expect(\"struct pattern type is not an ADT\")\n                                    .variant_of_res(cx.tables.qpath_res(qpath, pat.hir_id));\n@@ -173,7 +173,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonShorthandFieldPatterns {\n                     // (Issue #49588)\n                     continue;\n                 }\n-                if let PatKind::Binding(_, _, ident, None) = fieldpat.pat.node {\n+                if let PatKind::Binding(_, _, ident, None) = fieldpat.pat.kind {\n                     if cx.tcx.find_field_index(ident, &variant) ==\n                        Some(cx.tcx.field_index(fieldpat.hir_id, cx.tables)) {\n                         let mut err = cx.struct_span_lint(NON_SHORTHAND_FIELD_PATTERNS,\n@@ -224,7 +224,7 @@ impl EarlyLintPass for UnsafeCode {\n     }\n \n     fn check_expr(&mut self, cx: &EarlyContext<'_>, e: &ast::Expr) {\n-        if let ast::ExprKind::Block(ref blk, _) = e.node {\n+        if let ast::ExprKind::Block(ref blk, _) = e.kind {\n             // Don't warn about generated blocks; that'll just pollute the output.\n             if blk.rules == ast::BlockCheckMode::Unsafe(ast::UserProvided) {\n                 self.report_unsafe(cx, blk.span, \"usage of an `unsafe` block\");\n@@ -233,7 +233,7 @@ impl EarlyLintPass for UnsafeCode {\n     }\n \n     fn check_item(&mut self, cx: &EarlyContext<'_>, it: &ast::Item) {\n-        match it.node {\n+        match it.kind {\n             ast::ItemKind::Trait(_, ast::Unsafety::Unsafe, ..) => {\n                 self.report_unsafe(cx, it.span, \"declaration of an `unsafe` trait\")\n             }\n@@ -268,7 +268,7 @@ impl EarlyLintPass for UnsafeCode {\n     }\n \n     fn check_trait_item(&mut self, cx: &EarlyContext<'_>, item: &ast::TraitItem) {\n-        if let ast::TraitItemKind::Method(ref sig, None) = item.node {\n+        if let ast::TraitItemKind::Method(ref sig, None) = item.kind {\n             if sig.header.unsafety == ast::Unsafety::Unsafe {\n                 self.report_unsafe(cx, item.span, \"declaration of an `unsafe` method\")\n             }\n@@ -391,7 +391,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDoc {\n     }\n \n     fn check_item(&mut self, cx: &LateContext<'_, '_>, it: &hir::Item) {\n-        let desc = match it.node {\n+        let desc = match it.kind {\n             hir::ItemKind::Fn(..) => \"a function\",\n             hir::ItemKind::Mod(..) => \"a module\",\n             hir::ItemKind::Enum(..) => \"an enum\",\n@@ -440,7 +440,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDoc {\n             return;\n         }\n \n-        let desc = match trait_item.node {\n+        let desc = match trait_item.kind {\n             hir::TraitItemKind::Const(..) => \"an associated constant\",\n             hir::TraitItemKind::Method(..) => \"a trait method\",\n             hir::TraitItemKind::Type(..) => \"an associated type\",\n@@ -459,7 +459,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDoc {\n             return;\n         }\n \n-        let desc = match impl_item.node {\n+        let desc = match impl_item.kind {\n             hir::ImplItemKind::Const(..) => \"an associated constant\",\n             hir::ImplItemKind::Method(..) => \"a method\",\n             hir::ImplItemKind::TyAlias(_) => \"an associated type\",\n@@ -504,7 +504,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingCopyImplementations {\n         if !cx.access_levels.is_reachable(item.hir_id) {\n             return;\n         }\n-        let (def, ty) = match item.node {\n+        let (def, ty) = match item.kind {\n             hir::ItemKind::Struct(_, ref ast_generics) => {\n                 if !ast_generics.params.is_empty() {\n                     return;\n@@ -563,7 +563,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDebugImplementations {\n             return;\n         }\n \n-        match item.node {\n+        match item.kind {\n             hir::ItemKind::Struct(..) |\n             hir::ItemKind::Union(..) |\n             hir::ItemKind::Enum(..) => {}\n@@ -611,10 +611,10 @@ declare_lint_pass!(\n \n impl EarlyLintPass for AnonymousParameters {\n     fn check_trait_item(&mut self, cx: &EarlyContext<'_>, it: &ast::TraitItem) {\n-        match it.node {\n+        match it.kind {\n             ast::TraitItemKind::Method(ref sig, _) => {\n                 for arg in sig.decl.inputs.iter() {\n-                    match arg.pat.node {\n+                    match arg.pat.kind {\n                         ast::PatKind::Ident(_, ident, None) => {\n                             if ident.name == kw::Invalid {\n                                 let ty_snip = cx\n@@ -766,13 +766,13 @@ impl UnusedDocComment {\n \n impl EarlyLintPass for UnusedDocComment {\n     fn check_item(&mut self, cx: &EarlyContext<'_>, item: &ast::Item) {\n-        if let ast::ItemKind::Mac(..) = item.node {\n+        if let ast::ItemKind::Mac(..) = item.kind {\n             self.warn_if_doc(cx, item.span, \"macro expansions\", true, &item.attrs);\n         }\n     }\n \n     fn check_stmt(&mut self, cx: &EarlyContext<'_>, stmt: &ast::Stmt) {\n-        let (kind, is_macro_expansion) = match stmt.node {\n+        let (kind, is_macro_expansion) = match stmt.kind {\n             ast::StmtKind::Local(..) => (\"statements\", false),\n             ast::StmtKind::Item(..) => (\"inner items\", false),\n             ast::StmtKind::Mac(..) => (\"macro expansions\", true),\n@@ -781,7 +781,7 @@ impl EarlyLintPass for UnusedDocComment {\n             ast::StmtKind::Expr(..) => return,\n         };\n \n-        self.warn_if_doc(cx, stmt.span, kind, is_macro_expansion, stmt.node.attrs());\n+        self.warn_if_doc(cx, stmt.span, kind, is_macro_expansion, stmt.kind.attrs());\n     }\n \n     fn check_arm(&mut self, cx: &EarlyContext<'_>, arm: &ast::Arm) {\n@@ -809,7 +809,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for PluginAsLibrary {\n             return;\n         }\n \n-        match it.node {\n+        match it.kind {\n             hir::ItemKind::ExternCrate(..) => (),\n             _ => return,\n         };\n@@ -849,7 +849,7 @@ declare_lint_pass!(InvalidNoMangleItems => [NO_MANGLE_CONST_ITEMS, NO_MANGLE_GEN\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for InvalidNoMangleItems {\n     fn check_item(&mut self, cx: &LateContext<'_, '_>, it: &hir::Item) {\n-        match it.node {\n+        match it.kind {\n             hir::ItemKind::Fn(.., ref generics, _) => {\n                 if let Some(no_mangle_attr) = attr::find_by_name(&it.attrs, sym::no_mangle) {\n                     for param in &generics.params {\n@@ -932,7 +932,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MutableTransmutes {\n             (cx: &LateContext<'a, 'tcx>,\n              expr: &hir::Expr)\n              -> Option<(Ty<'tcx>, Ty<'tcx>)> {\n-            let def = if let hir::ExprKind::Path(ref qpath) = expr.node {\n+            let def = if let hir::ExprKind::Path(ref qpath) = expr.kind {\n                 cx.tables.qpath_res(qpath, expr.hir_id)\n             } else {\n                 return None;\n@@ -992,7 +992,7 @@ declare_lint_pass!(\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnionsWithDropFields {\n     fn check_item(&mut self, ctx: &LateContext<'_, '_>, item: &hir::Item) {\n-        if let hir::ItemKind::Union(ref vdata, _) = item.node {\n+        if let hir::ItemKind::Union(ref vdata, _) = item.kind {\n             for field in vdata.fields() {\n                 let field_ty = ctx.tcx.type_of(\n                     ctx.tcx.hir().local_def_id(field.hir_id));\n@@ -1090,7 +1090,7 @@ impl TypeAliasBounds {\n         match *qpath {\n             hir::QPath::TypeRelative(ref ty, _) => {\n                 // If this is a type variable, we found a `T::Assoc`.\n-                match ty.node {\n+                match ty.kind {\n                     hir::TyKind::Path(hir::QPath::Resolved(None, ref path)) => {\n                         match path.res {\n                             Res::Def(DefKind::TyParam, _) => true,\n@@ -1137,7 +1137,7 @@ impl TypeAliasBounds {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeAliasBounds {\n     fn check_item(&mut self, cx: &LateContext<'_, '_>, item: &hir::Item) {\n-        let (ty, type_alias_generics) = match item.node {\n+        let (ty, type_alias_generics) = match item.kind {\n             hir::ItemKind::TyAlias(ref ty, ref generics) => (&*ty, generics),\n             _ => return,\n         };\n@@ -1204,7 +1204,7 @@ fn check_const(cx: &LateContext<'_, '_>, body_id: hir::BodyId) {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedBrokenConst {\n     fn check_item(&mut self, cx: &LateContext<'_, '_>, it: &hir::Item) {\n-        match it.node {\n+        match it.kind {\n             hir::ItemKind::Const(_, body_id) => {\n                 check_const(cx, body_id);\n             },\n@@ -1321,15 +1321,15 @@ impl EarlyLintPass for EllipsisInclusiveRangePatterns {\n         /// If `pat` is a `...` pattern, return the start and end of the range, as well as the span\n         /// corresponding to the ellipsis.\n         fn matches_ellipsis_pat(pat: &ast::Pat) -> Option<(&P<Expr>, &P<Expr>, Span)> {\n-            match &pat.node {\n+            match &pat.kind {\n                 PatKind::Range(a, b, Spanned { span, node: RangeEnd::Included(DotDotDot), .. }) => {\n                     Some((a, b, *span))\n                 }\n                 _ => None,\n             }\n         }\n \n-        let (parenthesise, endpoints) = match &pat.node {\n+        let (parenthesise, endpoints) = match &pat.kind {\n             PatKind::Ref(subpat, _) => (true, matches_ellipsis_pat(&subpat)),\n             _ => (false, matches_ellipsis_pat(pat)),\n         };\n@@ -1395,7 +1395,7 @@ impl UnnameableTestItems {\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnnameableTestItems {\n     fn check_item(&mut self, cx: &LateContext<'_, '_>, it: &hir::Item) {\n         if self.items_nameable {\n-            if let hir::ItemKind::Mod(..) = it.node {}\n+            if let hir::ItemKind::Mod(..) = it.kind {}\n             else {\n                 self.items_nameable = false;\n                 self.boundary = it.hir_id;\n@@ -1684,7 +1684,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ExplicitOutlivesRequirements {\n         let def_id = cx.tcx.hir().local_def_id(item.hir_id);\n         if let hir::ItemKind::Struct(_, ref hir_generics)\n             | hir::ItemKind::Enum(_, ref hir_generics)\n-            | hir::ItemKind::Union(_, ref hir_generics) = item.node\n+            | hir::ItemKind::Union(_, ref hir_generics) = item.kind\n         {\n             let inferred_outlives = cx.tcx.inferred_outlives_of(def_id);\n             if inferred_outlives.is_empty() {\n@@ -1750,7 +1750,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ExplicitOutlivesRequirements {\n                     hir::WherePredicate::BoundPredicate(predicate) => {\n                         // FIXME we can also infer bounds on associated types,\n                         // and should check for them here.\n-                        match predicate.bounded_ty.node {\n+                        match predicate.bounded_ty.kind {\n                             hir::TyKind::Path(hir::QPath::Resolved(\n                                 None,\n                                 ref path,\n@@ -1812,7 +1812,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ExplicitOutlivesRequirements {\n                 // generics, except for tuple struct, which have the `where`\n                 // after the fields of the struct.\n                 let full_where_span = if let hir::ItemKind::Struct(hir::VariantData::Tuple(..), _)\n-                        = item.node\n+                        = item.kind\n                 {\n                     where_span\n                 } else {\n@@ -1900,7 +1900,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for InvalidValue {\n         fn is_zero(expr: &hir::Expr) -> bool {\n             use hir::ExprKind::*;\n             use syntax::ast::LitKind::*;\n-            match &expr.node {\n+            match &expr.kind {\n                 Lit(lit) =>\n                     if let Int(i, _) = lit.node {\n                         i == 0\n@@ -1923,8 +1923,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for InvalidValue {\n             const TRANSMUTE_PATH: &[Symbol] =\n                 &[sym::core, sym::intrinsics, kw::Invalid, sym::transmute];\n \n-            if let hir::ExprKind::Call(ref path_expr, ref args) = expr.node {\n-                if let hir::ExprKind::Path(ref qpath) = path_expr.node {\n+            if let hir::ExprKind::Call(ref path_expr, ref args) = expr.kind {\n+                if let hir::ExprKind::Path(ref qpath) = path_expr.kind {\n                     let def_id = cx.tables.qpath_res(qpath, path_expr.hir_id).opt_def_id()?;\n \n                     if cx.match_def_path(def_id, ZEROED_PATH) {"}, {"sha": "dceb79fd30985d7aa341d372df2b47993e65a96b", "filename": "src/librustc_lint/nonstandard_style.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_lint%2Fnonstandard_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_lint%2Fnonstandard_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fnonstandard_style.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -136,7 +136,7 @@ impl EarlyLintPass for NonCamelCaseTypes {\n             return;\n         }\n \n-        match it.node {\n+        match it.kind {\n             ast::ItemKind::TyAlias(..) |\n             ast::ItemKind::Enum(..) |\n             ast::ItemKind::Struct(..) |\n@@ -258,7 +258,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonSnakeCase {\n                 .and_then(|attr| attr.meta())\n                 .and_then(|meta| {\n                     meta.name_value_literal().and_then(|lit| {\n-                        if let ast::LitKind::Str(name, ..) = lit.node {\n+                        if let ast::LitKind::Str(name, ..) = lit.kind {\n                             // Discard the double quotes surrounding the literal.\n                             let sp = cx.sess().source_map().span_to_snippet(lit.span)\n                                 .ok()\n@@ -326,13 +326,13 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonSnakeCase {\n     }\n \n     fn check_item(&mut self, cx: &LateContext<'_, '_>, it: &hir::Item) {\n-        if let hir::ItemKind::Mod(_) = it.node {\n+        if let hir::ItemKind::Mod(_) = it.kind {\n             self.check_snake_case(cx, \"module\", &it.ident);\n         }\n     }\n \n     fn check_trait_item(&mut self, cx: &LateContext<'_, '_>, item: &hir::TraitItem) {\n-        if let hir::TraitItemKind::Method(_, hir::TraitMethod::Required(pnames)) = &item.node {\n+        if let hir::TraitItemKind::Method(_, hir::TraitMethod::Required(pnames)) = &item.kind {\n             self.check_snake_case(cx, \"trait method\", &item.ident);\n             for param_name in pnames {\n                 self.check_snake_case(cx, \"variable\", param_name);\n@@ -341,7 +341,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonSnakeCase {\n     }\n \n     fn check_pat(&mut self, cx: &LateContext<'_, '_>, p: &hir::Pat) {\n-        if let &PatKind::Binding(_, _, ident, _) = &p.node {\n+        if let &PatKind::Binding(_, _, ident, _) = &p.kind {\n             self.check_snake_case(cx, \"variable\", &ident);\n         }\n     }\n@@ -387,7 +387,7 @@ impl NonUpperCaseGlobals {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonUpperCaseGlobals {\n     fn check_item(&mut self, cx: &LateContext<'_, '_>, it: &hir::Item) {\n-        match it.node {\n+        match it.kind {\n             hir::ItemKind::Static(..) if !attr::contains_name(&it.attrs, sym::no_mangle) => {\n                 NonUpperCaseGlobals::check_upper_case(cx, \"static variable\", &it.ident);\n             }\n@@ -399,20 +399,20 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonUpperCaseGlobals {\n     }\n \n     fn check_trait_item(&mut self, cx: &LateContext<'_, '_>, ti: &hir::TraitItem) {\n-        if let hir::TraitItemKind::Const(..) = ti.node {\n+        if let hir::TraitItemKind::Const(..) = ti.kind {\n             NonUpperCaseGlobals::check_upper_case(cx, \"associated constant\", &ti.ident);\n         }\n     }\n \n     fn check_impl_item(&mut self, cx: &LateContext<'_, '_>, ii: &hir::ImplItem) {\n-        if let hir::ImplItemKind::Const(..) = ii.node {\n+        if let hir::ImplItemKind::Const(..) = ii.kind {\n             NonUpperCaseGlobals::check_upper_case(cx, \"associated constant\", &ii.ident);\n         }\n     }\n \n     fn check_pat(&mut self, cx: &LateContext<'_, '_>, p: &hir::Pat) {\n         // Lint for constants that look like binding identifiers (#7526)\n-        if let PatKind::Path(hir::QPath::Resolved(None, ref path)) = p.node {\n+        if let PatKind::Path(hir::QPath::Resolved(None, ref path)) = p.kind {\n             if let Res::Def(DefKind::Const, _) = path.res {\n                 if path.segments.len() == 1 {\n                     NonUpperCaseGlobals::check_upper_case("}, {"sha": "0adf1eeb410b02caa36ef22a71a7192676fd7b6f", "filename": "src/librustc_lint/redundant_semicolon.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_lint%2Fredundant_semicolon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_lint%2Fredundant_semicolon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fredundant_semicolon.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -12,8 +12,8 @@ declare_lint_pass!(RedundantSemicolon => [REDUNDANT_SEMICOLON]);\n \n impl EarlyLintPass for RedundantSemicolon {\n     fn check_stmt(&mut self, cx: &EarlyContext<'_>, stmt: &Stmt) {\n-        if let StmtKind::Semi(expr) = &stmt.node {\n-            if let ExprKind::Tup(ref v) = &expr.node {\n+        if let StmtKind::Semi(expr) = &stmt.kind {\n+            if let ExprKind::Tup(ref v) = &expr.kind {\n                 if v.is_empty() {\n                     // Strings of excess semicolons are encoded as empty tuple expressions\n                     // during the parsing stage, so we check for empty tuple expressions"}, {"sha": "e4567dc8265d84cfca08c0393631aae3a7d4172c", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -72,7 +72,7 @@ fn lint_overflowing_range_endpoint<'a, 'tcx>(\n ) -> bool {\n     // We only want to handle exclusive (`..`) ranges,\n     // which are represented as `ExprKind::Struct`.\n-    if let ExprKind::Struct(_, eps, _) = &parent_expr.node {\n+    if let ExprKind::Struct(_, eps, _) = &parent_expr.kind {\n         if eps.len() != 2 {\n             return false;\n         }\n@@ -279,7 +279,7 @@ fn lint_int_literal<'a, 'tcx>(\n \n         let par_id = cx.tcx.hir().get_parent_node(e.hir_id);\n         if let Node::Expr(par_e) = cx.tcx.hir().get(par_id) {\n-            if let hir::ExprKind::Struct(..) = par_e.node {\n+            if let hir::ExprKind::Struct(..) = par_e.kind {\n                 if is_range_literal(cx.sess(), par_e)\n                     && lint_overflowing_range_endpoint(cx, lit, v, max, e, par_e, t)\n                 {\n@@ -318,7 +318,7 @@ fn lint_uint_literal<'a, 'tcx>(\n     if lit_val < min || lit_val > max {\n         let parent_id = cx.tcx.hir().get_parent_node(e.hir_id);\n         if let Node::Expr(par_e) = cx.tcx.hir().get(parent_id) {\n-            match par_e.node {\n+            match par_e.kind {\n                 hir::ExprKind::Cast(..) => {\n                     if let ty::Char = cx.tables.expr_ty(par_e).kind {\n                         let mut err = cx.struct_span_lint(\n@@ -400,7 +400,7 @@ fn lint_literal<'a, 'tcx>(\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx hir::Expr) {\n-        match e.node {\n+        match e.kind {\n             hir::ExprKind::Unary(hir::UnNeg, ref expr) => {\n                 // propagate negation, if the negation itself isn't negated\n                 if self.negated_expr_id != e.hir_id {\n@@ -445,7 +445,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n                         l: &hir::Expr,\n                         r: &hir::Expr)\n                         -> bool {\n-            let (lit, expr, swap) = match (&l.node, &r.node) {\n+            let (lit, expr, swap) = match (&l.kind, &r.kind) {\n                 (&hir::ExprKind::Lit(_), _) => (l, r, true),\n                 (_, &hir::ExprKind::Lit(_)) => (r, l, false),\n                 _ => return true,\n@@ -456,7 +456,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n             match cx.tables.node_type(expr.hir_id).kind {\n                 ty::Int(int_ty) => {\n                     let (min, max) = int_ty_range(int_ty);\n-                    let lit_val: i128 = match lit.node {\n+                    let lit_val: i128 = match lit.kind {\n                         hir::ExprKind::Lit(ref li) => {\n                             match li.node {\n                                 ast::LitKind::Int(v, ast::LitIntType::Signed(_)) |\n@@ -470,7 +470,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n                 }\n                 ty::Uint(uint_ty) => {\n                     let (min, max) :(u128, u128) = uint_ty_range(uint_ty);\n-                    let lit_val: u128 = match lit.node {\n+                    let lit_val: u128 = match lit.kind {\n                         hir::ExprKind::Lit(ref li) => {\n                             match li.node {\n                                 ast::LitKind::Int(v, _) => v,\n@@ -978,7 +978,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ImproperCTypes {\n         if let Abi::Rust | Abi::RustCall | Abi::RustIntrinsic | Abi::PlatformIntrinsic = abi {\n             // Don't worry about types in internal ABIs.\n         } else {\n-            match it.node {\n+            match it.kind {\n                 hir::ForeignItemKind::Fn(ref decl, _, _) => {\n                     vis.check_foreign_fn(it.hir_id, decl);\n                 }\n@@ -995,7 +995,7 @@ declare_lint_pass!(VariantSizeDifferences => [VARIANT_SIZE_DIFFERENCES]);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for VariantSizeDifferences {\n     fn check_item(&mut self, cx: &LateContext<'_, '_>, it: &hir::Item) {\n-        if let hir::ItemKind::Enum(ref enum_definition, _) = it.node {\n+        if let hir::ItemKind::Enum(ref enum_definition, _) = it.kind {\n             let item_def_id = cx.tcx.hir().local_def_id(it.hir_id);\n             let t = cx.tcx.type_of(item_def_id);\n             let ty = cx.tcx.erase_regions(&t);"}, {"sha": "3b3995832cb4cb1f9663c6bad8ae604fbc8e3a7e", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -38,12 +38,12 @@ declare_lint_pass!(UnusedResults => [UNUSED_MUST_USE, UNUSED_RESULTS]);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedResults {\n     fn check_stmt(&mut self, cx: &LateContext<'_, '_>, s: &hir::Stmt) {\n-        let expr = match s.node {\n+        let expr = match s.kind {\n             hir::StmtKind::Semi(ref expr) => &**expr,\n             _ => return,\n         };\n \n-        if let hir::ExprKind::Ret(..) = expr.node {\n+        if let hir::ExprKind::Ret(..) = expr.kind {\n             return;\n         }\n \n@@ -52,9 +52,9 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedResults {\n \n         let mut fn_warned = false;\n         let mut op_warned = false;\n-        let maybe_def_id = match expr.node {\n+        let maybe_def_id = match expr.kind {\n             hir::ExprKind::Call(ref callee, _) => {\n-                match callee.node {\n+                match callee.kind {\n                     hir::ExprKind::Path(ref qpath) => {\n                         match cx.tables.qpath_res(qpath, callee.hir_id) {\n                             Res::Def(DefKind::Fn, def_id)\n@@ -80,7 +80,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedResults {\n             return;\n         }\n \n-        let must_use_op = match expr.node {\n+        let must_use_op = match expr.kind {\n             // Hardcoding operators here seemed more expedient than the\n             // refactoring that would be needed to look up the `#[must_use]`\n             // attribute which does exist on the comparison trait methods\n@@ -193,7 +193,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedResults {\n                 }\n                 ty::Tuple(ref tys) => {\n                     let mut has_emitted = false;\n-                    let spans = if let hir::ExprKind::Tup(comps) = &expr.node {\n+                    let spans = if let hir::ExprKind::Tup(comps) = &expr.kind {\n                         debug_assert_eq!(comps.len(), tys.len());\n                         comps.iter().map(|e| e.span).collect()\n                     } else {\n@@ -269,8 +269,8 @@ declare_lint_pass!(PathStatements => [PATH_STATEMENTS]);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for PathStatements {\n     fn check_stmt(&mut self, cx: &LateContext<'_, '_>, s: &hir::Stmt) {\n-        if let hir::StmtKind::Semi(ref expr) = s.node {\n-            if let hir::ExprKind::Path(_) = expr.node {\n+        if let hir::StmtKind::Semi(ref expr) = s.kind {\n+            if let hir::ExprKind::Path(_) = expr.kind {\n                 cx.span_lint(PATH_STATEMENTS, s.span, \"path statement with no effect\");\n             }\n         }\n@@ -363,7 +363,7 @@ declare_lint_pass!(UnusedParens => [UNUSED_PARENS]);\n impl UnusedParens {\n \n     fn is_expr_parens_necessary(inner: &ast::Expr, followed_by_block: bool) -> bool {\n-        followed_by_block && match inner.node {\n+        followed_by_block && match inner.kind {\n             ast::ExprKind::Ret(_) | ast::ExprKind::Break(..) => true,\n             _ => parser::contains_exterior_struct_lit(&inner),\n         }\n@@ -376,7 +376,7 @@ impl UnusedParens {\n                                      followed_by_block: bool,\n                                      left_pos: Option<BytePos>,\n                                      right_pos: Option<BytePos>) {\n-        match value.node {\n+        match value.kind {\n             ast::ExprKind::Paren(ref inner) => {\n                 if !Self::is_expr_parens_necessary(inner, followed_by_block) &&\n                     value.attrs.is_empty() {\n@@ -416,8 +416,8 @@ impl UnusedParens {\n     ) {\n         use ast::{PatKind, BindingMode::ByValue, Mutability::Mutable};\n \n-        if let PatKind::Paren(inner) = &value.node {\n-            match inner.node {\n+        if let PatKind::Paren(inner) = &value.kind {\n+            match inner.kind {\n                 // The lint visitor will visit each subpattern of `p`. We do not want to lint\n                 // any range pattern no matter where it occurs in the pattern. For something like\n                 // `&(a..=b)`, there is a recursive `check_pat` on `a` and `b`, but we will assume\n@@ -501,7 +501,7 @@ impl UnusedParens {\n impl EarlyLintPass for UnusedParens {\n     fn check_expr(&mut self, cx: &EarlyContext<'_>, e: &ast::Expr) {\n         use syntax::ast::ExprKind::*;\n-        let (value, msg, followed_by_block, left_pos, right_pos) = match e.node {\n+        let (value, msg, followed_by_block, left_pos, right_pos) = match e.kind {\n             Let(ref pat, ..) => {\n                 self.check_unused_parens_pat(cx, pat, false, false);\n                 return;\n@@ -566,7 +566,7 @@ impl EarlyLintPass for UnusedParens {\n \n     fn check_pat(&mut self, cx: &EarlyContext<'_>, p: &ast::Pat) {\n         use ast::{PatKind::*, Mutability};\n-        match &p.node {\n+        match &p.kind {\n             // Do not lint on `(..)` as that will result in the other arms being useless.\n             Paren(_)\n             // The other cases do not contain sub-patterns.\n@@ -587,7 +587,7 @@ impl EarlyLintPass for UnusedParens {\n     }\n \n     fn check_stmt(&mut self, cx: &EarlyContext<'_>, s: &ast::Stmt) {\n-        if let ast::StmtKind::Local(ref local) = s.node {\n+        if let ast::StmtKind::Local(ref local) = s.kind {\n             self.check_unused_parens_pat(cx, &local.pat, false, false);\n \n             if let Some(ref value) = local.init {\n@@ -647,7 +647,7 @@ impl UnusedImportBraces {\n \n impl EarlyLintPass for UnusedImportBraces {\n     fn check_item(&mut self, cx: &EarlyContext<'_>, item: &ast::Item) {\n-        if let ast::ItemKind::Use(ref use_tree) = item.node {\n+        if let ast::ItemKind::Use(ref use_tree) = item.kind {\n             self.check_use_tree(cx, use_tree, item);\n         }\n     }\n@@ -663,7 +663,7 @@ declare_lint_pass!(UnusedAllocation => [UNUSED_ALLOCATION]);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedAllocation {\n     fn check_expr(&mut self, cx: &LateContext<'_, '_>, e: &hir::Expr) {\n-        match e.node {\n+        match e.kind {\n             hir::ExprKind::Box(_) => {}\n             _ => return,\n         }"}, {"sha": "0a2a481bb1500d5e5541b687d94ef45d2c414f64", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -999,7 +999,7 @@ impl<'a> CrateLoader<'a> {\n     pub fn process_extern_crate(\n         &mut self, item: &ast::Item, definitions: &Definitions,\n     ) -> CrateNum {\n-        match item.node {\n+        match item.kind {\n             ast::ItemKind::ExternCrate(orig_name) => {\n                 debug!(\"resolving extern crate stmt. ident: {} orig_name: {:?}\",\n                        item.ident, orig_name);"}, {"sha": "8a7e599ebeb63bf21ec425e4bbf37e2c7f5281ad", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -479,7 +479,7 @@ impl cstore::CStore {\n             id: ast::DUMMY_NODE_ID,\n             span: local_span,\n             attrs: attrs.iter().cloned().collect(),\n-            node: ast::ItemKind::MacroDef(ast::MacroDef {\n+            kind: ast::ItemKind::MacroDef(ast::MacroDef {\n                 tokens: body.into(),\n                 legacy: def.legacy,\n             }),"}, {"sha": "0bb4f52be14c29d7a4b79ebc3de62446bc4a5a29", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 34, "deletions": 35, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -862,7 +862,7 @@ impl EncodeContext<'tcx> {\n         let kind = match trait_item.kind {\n             ty::AssocKind::Const => {\n                 let const_qualif =\n-                    if let hir::TraitItemKind::Const(_, Some(body)) = ast_item.node {\n+                    if let hir::TraitItemKind::Const(_, Some(body)) = ast_item.kind {\n                         self.const_qualif(0, body)\n                     } else {\n                         ConstQualif { mir: 0, ast_promotable: false }\n@@ -875,7 +875,7 @@ impl EncodeContext<'tcx> {\n                 EntryKind::AssocConst(container, const_qualif, rendered_const)\n             }\n             ty::AssocKind::Method => {\n-                let fn_data = if let hir::TraitItemKind::Method(method_sig, m) = &ast_item.node {\n+                let fn_data = if let hir::TraitItemKind::Method(method_sig, m) = &ast_item.kind {\n                     let param_names = match *m {\n                         hir::TraitMethod::Required(ref names) => {\n                             self.encode_fn_param_names(names)\n@@ -970,7 +970,7 @@ impl EncodeContext<'tcx> {\n \n         let kind = match impl_item.kind {\n             ty::AssocKind::Const => {\n-                if let hir::ImplItemKind::Const(_, body_id) = ast_item.node {\n+                if let hir::ImplItemKind::Const(_, body_id) = ast_item.kind {\n                     let mir = self.tcx.at(ast_item.span).mir_const_qualif(def_id).0;\n \n                     EntryKind::AssocConst(container,\n@@ -981,7 +981,7 @@ impl EncodeContext<'tcx> {\n                 }\n             }\n             ty::AssocKind::Method => {\n-                let fn_data = if let hir::ImplItemKind::Method(ref sig, body) = ast_item.node {\n+                let fn_data = if let hir::ImplItemKind::Method(ref sig, body) = ast_item.kind {\n                     FnData {\n                         asyncness: sig.header.asyncness,\n                         constness: sig.header.constness,\n@@ -1001,21 +1001,20 @@ impl EncodeContext<'tcx> {\n             ty::AssocKind::Type => EntryKind::AssocType(container)\n         };\n \n-        let mir =\n-            match ast_item.node {\n-                hir::ImplItemKind::Const(..) => true,\n-                hir::ImplItemKind::Method(ref sig, _) => {\n-                    let generics = self.tcx.generics_of(def_id);\n-                    let needs_inline = (generics.requires_monomorphization(self.tcx) ||\n-                                        tcx.codegen_fn_attrs(def_id).requests_inline()) &&\n-                                        !self.metadata_output_only();\n-                    let is_const_fn = sig.header.constness == hir::Constness::Const;\n-                    let always_encode_mir = self.tcx.sess.opts.debugging_opts.always_encode_mir;\n-                    needs_inline || is_const_fn || always_encode_mir\n-                },\n-                hir::ImplItemKind::OpaqueTy(..) |\n-                hir::ImplItemKind::TyAlias(..) => false,\n-            };\n+        let mir = match ast_item.kind {\n+            hir::ImplItemKind::Const(..) => true,\n+            hir::ImplItemKind::Method(ref sig, _) => {\n+                let generics = self.tcx.generics_of(def_id);\n+                let needs_inline = (generics.requires_monomorphization(self.tcx) ||\n+                                    tcx.codegen_fn_attrs(def_id).requests_inline()) &&\n+                                    !self.metadata_output_only();\n+                let is_const_fn = sig.header.constness == hir::Constness::Const;\n+                let always_encode_mir = self.tcx.sess.opts.debugging_opts.always_encode_mir;\n+                needs_inline || is_const_fn || always_encode_mir\n+            },\n+            hir::ImplItemKind::OpaqueTy(..) |\n+            hir::ImplItemKind::TyAlias(..) => false,\n+        };\n \n         Entry {\n             kind,\n@@ -1047,7 +1046,7 @@ impl EncodeContext<'tcx> {\n         self.tcx.dep_graph.with_ignore(|| {\n             let body = self.tcx.hir().body(body_id);\n             self.lazy(body.params.iter().map(|arg| {\n-                match arg.pat.node {\n+                match arg.pat.kind {\n                     PatKind::Binding(_, _, ident, _) => ident.name,\n                     _ => kw::Invalid,\n                 }\n@@ -1118,7 +1117,7 @@ impl EncodeContext<'tcx> {\n \n         debug!(\"EncodeContext::encode_info_for_item({:?})\", def_id);\n \n-        let kind = match item.node {\n+        let kind = match item.kind {\n             hir::ItemKind::Static(_, hir::MutMutable, _) => EntryKind::MutStatic,\n             hir::ItemKind::Static(_, hir::MutImmutable, _) => EntryKind::ImmStatic,\n             hir::ItemKind::Const(_, body_id) => {\n@@ -1234,7 +1233,7 @@ impl EncodeContext<'tcx> {\n             hir::ItemKind::Use(..) => bug!(\"cannot encode info for item {:?}\", item),\n         };\n \n-        let mir = match item.node {\n+        let mir = match item.kind {\n             hir::ItemKind::Static(..) | hir::ItemKind::Const(..) => true,\n             hir::ItemKind::Fn(_, header, ..) => {\n                 let generics = tcx.generics_of(def_id);\n@@ -1253,7 +1252,7 @@ impl EncodeContext<'tcx> {\n             visibility: self.lazy(ty::Visibility::from_hir(&item.vis, item.hir_id, tcx)),\n             span: self.lazy(item.span),\n             attributes: self.encode_attributes(&item.attrs),\n-            children: match item.node {\n+            children: match item.kind {\n                 hir::ItemKind::ForeignMod(ref fm) => {\n                     self.lazy(fm.items\n                         .iter()\n@@ -1287,7 +1286,7 @@ impl EncodeContext<'tcx> {\n             stability: self.encode_stability(def_id),\n             deprecation: self.encode_deprecation(def_id),\n \n-            ty: match item.node {\n+            ty: match item.kind {\n                 hir::ItemKind::Static(..) |\n                 hir::ItemKind::Const(..) |\n                 hir::ItemKind::Fn(..) |\n@@ -1300,14 +1299,14 @@ impl EncodeContext<'tcx> {\n                 _ => None,\n             },\n             inherent_impls: self.encode_inherent_implementations(def_id),\n-            variances: match item.node {\n+            variances: match item.kind {\n                 hir::ItemKind::Enum(..) |\n                 hir::ItemKind::Struct(..) |\n                 hir::ItemKind::Union(..) |\n                 hir::ItemKind::Fn(..) => self.encode_variances_of(def_id),\n                 _ => Lazy::empty(),\n             },\n-            generics: match item.node {\n+            generics: match item.kind {\n                 hir::ItemKind::Static(..) |\n                 hir::ItemKind::Const(..) |\n                 hir::ItemKind::Fn(..) |\n@@ -1321,7 +1320,7 @@ impl EncodeContext<'tcx> {\n                 hir::ItemKind::TraitAlias(..) => Some(self.encode_generics(def_id)),\n                 _ => None,\n             },\n-            predicates: match item.node {\n+            predicates: match item.kind {\n                 hir::ItemKind::Static(..) |\n                 hir::ItemKind::Const(..) |\n                 hir::ItemKind::Fn(..) |\n@@ -1341,7 +1340,7 @@ impl EncodeContext<'tcx> {\n             // so only encode it in that case as an efficiency\n             // hack. (No reason not to expand it in the future if\n             // necessary.)\n-            predicates_defined_on: match item.node {\n+            predicates_defined_on: match item.kind {\n                 hir::ItemKind::Trait(..) |\n                 hir::ItemKind::TraitAlias(..) => Some(self.encode_predicates_defined_on(def_id)),\n                 _ => None, // not *wrong* for other kinds of items, but not needed\n@@ -1678,7 +1677,7 @@ impl EncodeContext<'tcx> {\n \n         debug!(\"EncodeContext::encode_info_for_foreign_item({:?})\", def_id);\n \n-        let kind = match nitem.node {\n+        let kind = match nitem.kind {\n             hir::ForeignItemKind::Fn(_, ref names, _) => {\n                 let data = FnData {\n                     asyncness: hir::IsAsync::NotAsync,\n@@ -1704,7 +1703,7 @@ impl EncodeContext<'tcx> {\n \n             ty: Some(self.encode_item_type(def_id)),\n             inherent_impls: Lazy::empty(),\n-            variances: match nitem.node {\n+            variances: match nitem.kind {\n                 hir::ForeignItemKind::Fn(..) => self.encode_variances_of(def_id),\n                 _ => Lazy::empty(),\n             },\n@@ -1729,7 +1728,7 @@ impl Visitor<'tcx> for EncodeContext<'tcx> {\n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n         intravisit::walk_item(self, item);\n         let def_id = self.tcx.hir().local_def_id(item.hir_id);\n-        match item.node {\n+        match item.kind {\n             hir::ItemKind::ExternCrate(_) |\n             hir::ItemKind::Use(..) => {} // ignore these\n             _ => self.record(def_id, EncodeContext::encode_info_for_item, (def_id, item)),\n@@ -1800,7 +1799,7 @@ impl EncodeContext<'tcx> {\n     }\n \n     fn encode_info_for_ty(&mut self, ty: &hir::Ty) {\n-        match ty.node {\n+        match ty.kind {\n             hir::TyKind::Array(_, ref length) => {\n                 let def_id = self.tcx.hir().local_def_id(length.hir_id);\n                 self.record(def_id, EncodeContext::encode_info_for_anon_const, def_id);\n@@ -1810,7 +1809,7 @@ impl EncodeContext<'tcx> {\n     }\n \n     fn encode_info_for_expr(&mut self, expr: &hir::Expr) {\n-        match expr.node {\n+        match expr.kind {\n             hir::ExprKind::Closure(..) => {\n                 let def_id = self.tcx.hir().local_def_id(expr.hir_id);\n                 self.record(def_id, EncodeContext::encode_info_for_closure, def_id);\n@@ -1825,7 +1824,7 @@ impl EncodeContext<'tcx> {\n     /// normally in the visitor walk.\n     fn encode_addl_info_for_item(&mut self, item: &hir::Item) {\n         let def_id = self.tcx.hir().local_def_id(item.hir_id);\n-        match item.node {\n+        match item.kind {\n             hir::ItemKind::Static(..) |\n             hir::ItemKind::Const(..) |\n             hir::ItemKind::Fn(..) |\n@@ -1894,7 +1893,7 @@ struct ImplVisitor<'tcx> {\n \n impl<'tcx, 'v> ItemLikeVisitor<'v> for ImplVisitor<'tcx> {\n     fn visit_item(&mut self, item: &hir::Item) {\n-        if let hir::ItemKind::Impl(..) = item.node {\n+        if let hir::ItemKind::Impl(..) = item.kind {\n             let impl_id = self.tcx.hir().local_def_id(item.hir_id);\n             if let Some(trait_ref) = self.tcx.impl_trait_ref(impl_id) {\n                 self.impls"}, {"sha": "8a4f6e6f17a5112733fc69a4ffe2e3dcd082e4fd", "filename": "src/librustc_metadata/foreign_modules.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_metadata%2Fforeign_modules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_metadata%2Fforeign_modules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fforeign_modules.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -19,7 +19,7 @@ struct Collector<'tcx> {\n \n impl ItemLikeVisitor<'tcx> for Collector<'tcx> {\n     fn visit_item(&mut self, it: &'tcx hir::Item) {\n-        let fm = match it.node {\n+        let fm = match it.kind {\n             hir::ItemKind::ForeignMod(ref fm) => fm,\n             _ => return,\n         };"}, {"sha": "527d4421fca656d9a9a4250eba539713f707fe66", "filename": "src/librustc_metadata/link_args.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_metadata%2Flink_args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_metadata%2Flink_args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flink_args.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -27,7 +27,7 @@ struct Collector {\n \n impl<'tcx> ItemLikeVisitor<'tcx> for Collector {\n     fn visit_item(&mut self, it: &'tcx hir::Item) {\n-        let fm = match it.node {\n+        let fm = match it.kind {\n             hir::ItemKind::ForeignMod(ref fm) => fm,\n             _ => return,\n         };"}, {"sha": "fe215d9c7999ea66c453d20689fa2da730f2fafc", "filename": "src/librustc_metadata/native_libs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_metadata%2Fnative_libs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_metadata%2Fnative_libs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fnative_libs.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -35,7 +35,7 @@ struct Collector<'tcx> {\n \n impl ItemLikeVisitor<'tcx> for Collector<'tcx> {\n     fn visit_item(&mut self, it: &'tcx hir::Item) {\n-        let fm = match it.node {\n+        let fm = match it.kind {\n             hir::ItemKind::ForeignMod(ref fm) => fm,\n             _ => return,\n         };"}, {"sha": "7d5d58ed284685385936a8f0f85995f75bb7e4fb", "filename": "src/librustc_mir/borrow_check/conflict_errors.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_mir%2Fborrow_check%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_mir%2Fborrow_check%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fconflict_errors.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -1842,7 +1842,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                             // Need to use the `rustc::ty` types to compare against the\n                             // `return_region`. Then use the `rustc::hir` type to get only\n                             // the lifetime span.\n-                            if let hir::TyKind::Rptr(lifetime, _) = &fn_decl.inputs[index].node {\n+                            if let hir::TyKind::Rptr(lifetime, _) = &fn_decl.inputs[index].kind {\n                                 // With access to the lifetime, we can get\n                                 // the span of it.\n                                 arguments.push((*argument, lifetime.span));\n@@ -1863,7 +1863,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 let return_ty = *sig.output().skip_binder();\n                 let mut return_span = fn_decl.output.span();\n                 if let hir::FunctionRetTy::Return(ty) = &fn_decl.output {\n-                    if let hir::TyKind::Rptr(lifetime, _) = ty.node {\n+                    if let hir::TyKind::Rptr(lifetime, _) = ty.kind {\n                         return_span = lifetime.span;\n                     }\n                 }"}, {"sha": "dc7e4b220658851df3c88386e59d1353e5ad381f", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -890,7 +890,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             def_id, target_place, places\n         );\n         let hir_id = self.infcx.tcx.hir().as_local_hir_id(def_id)?;\n-        let expr = &self.infcx.tcx.hir().expect_expr(hir_id).node;\n+        let expr = &self.infcx.tcx.hir().expect_expr(hir_id).kind;\n         debug!(\"closure_span: hir_id={:?} expr={:?}\", hir_id, expr);\n         if let hir::ExprKind::Closure(\n             .., args_span, _"}, {"sha": "067ab080713c4127196218202e4fcf069b34ea04", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -235,7 +235,7 @@ fn do_mir_borrowck<'a, 'tcx>(\n \n     let movable_generator = match tcx.hir().get(id) {\n         Node::Expr(&hir::Expr {\n-            node: hir::ExprKind::Closure(.., Some(hir::GeneratorMovability::Static)),\n+            kind: hir::ExprKind::Closure(.., Some(hir::GeneratorMovability::Static)),\n             ..\n         }) => false,\n         _ => true,"}, {"sha": "33520b6755ca47378637ea7c0a4c59609c6f0776", "filename": "src/librustc_mir/borrow_check/mutability_errors.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -338,7 +338,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                         _,\n                         upvar_ident,\n                         _,\n-                    ) = pat.node\n+                    ) = pat.kind\n                     {\n                         err.span_suggestion(\n                             upvar_ident.span,\n@@ -642,7 +642,7 @@ fn annotate_struct_field(\n                 if let hir::TyKind::Rptr(lifetime, hir::MutTy {\n                     mutbl: hir::Mutability::MutImmutable,\n                     ref ty\n-                }) = field.ty.node {\n+                }) = field.ty.kind {\n                     // Get the snippets in two parts - the named lifetime (if there is one) and\n                     // type being referenced, that way we can reconstruct the snippet without loss\n                     // of detail."}, {"sha": "c4b508e030f39ac76611088214ac28db0b0b3058", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting/region_name.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -292,7 +292,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n                     if let DefiningTy::Closure(def_id, substs) = def_ty {\n                         let args_span = if let hir::ExprKind::Closure(_, _, _, span, _) =\n-                            tcx.hir().expect_expr(mir_hir_id).node\n+                            tcx.hir().expect_expr(mir_hir_id).kind\n                         {\n                             span\n                         } else {\n@@ -425,7 +425,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         let mir_hir_id = infcx.tcx.hir().as_local_hir_id(mir_def_id)?;\n         let fn_decl = infcx.tcx.hir().fn_decl_by_hir_id(mir_hir_id)?;\n         let argument_hir_ty: &hir::Ty = &fn_decl.inputs[argument_index];\n-        match argument_hir_ty.node {\n+        match argument_hir_ty.kind {\n             // This indicates a variable with no type annotation, like\n             // `|x|`... in that case, we can't highlight the type but\n             // must highlight the variable.\n@@ -527,7 +527,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             &mut vec![(argument_ty, argument_hir_ty)];\n \n         while let Some((ty, hir_ty)) = search_stack.pop() {\n-            match (&ty.kind, &hir_ty.node) {\n+            match (&ty.kind, &hir_ty.kind) {\n                 // Check if the `argument_ty` is `&'X ..` where `'X`\n                 // is the region we are looking for -- if so, and we have a `&T`\n                 // on the RHS, then we want to highlight the `&` like so:\n@@ -758,7 +758,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n         let (return_span, mir_description) = match tcx.hir().get(mir_hir_id) {\n             hir::Node::Expr(hir::Expr {\n-                node: hir::ExprKind::Closure(_, return_ty, _, span, gen_move),\n+                kind: hir::ExprKind::Closure(_, return_ty, _, span, gen_move),\n                 ..\n             }) => (\n                 match return_ty.output {\n@@ -772,7 +772,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 },\n             ),\n             hir::Node::ImplItem(hir::ImplItem {\n-                node: hir::ImplItemKind::Method(method_sig, _),\n+                kind: hir::ImplItemKind::Method(method_sig, _),\n                 ..\n             }) => (method_sig.decl.output.span(), \"\"),\n             _ => (body.span, \"\"),\n@@ -821,7 +821,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n         let yield_span = match tcx.hir().get(mir_hir_id) {\n             hir::Node::Expr(hir::Expr {\n-                node: hir::ExprKind::Closure(_, _, _, span, _),\n+                kind: hir::ExprKind::Closure(_, _, _, span, _),\n                 ..\n             }) => (\n                 tcx.sess.source_map().end_point(*span)"}, {"sha": "7353ca9285ddb10b3cfce5133f24d2f0f8ebf8a4", "filename": "src/librustc_mir/build/block.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fblock.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -98,7 +98,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     initializer,\n                     lint_level\n                 } => {\n-                    let ignores_expr_result = if let PatternKind::Wild = *pattern.kind {\n+                    let ignores_expr_result = if let PatKind::Wild = *pattern.kind {\n                         true\n                     } else {\n                         false"}, {"sha": "0cd32acdb665b8cd608be717e0b2bdc1ebef0280", "filename": "src/librustc_mir/build/expr/stmt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fstmt.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -159,7 +159,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     if let ExprKind::Block { body } = expr.kind {\n                         if let Some(tail_expr) = &body.expr {\n                             let mut expr = tail_expr;\n-                            while let rustc::hir::ExprKind::Block(subblock, _label) = &expr.node {\n+                            while let rustc::hir::ExprKind::Block(subblock, _label) = &expr.kind {\n                                 if let Some(subtail_expr) = &subblock.expr {\n                                     expr = subtail_expr\n                                 } else {"}, {"sha": "8db06aa375e238066ac010bbfaadf5437fee6fad", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -298,12 +298,12 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     pub(super) fn expr_into_pattern(\n         &mut self,\n         mut block: BasicBlock,\n-        irrefutable_pat: Pattern<'tcx>,\n+        irrefutable_pat: Pat<'tcx>,\n         initializer: ExprRef<'tcx>,\n     ) -> BlockAnd<()> {\n         match *irrefutable_pat.kind {\n             // Optimize the case of `let x = ...` to write directly into `x`\n-            PatternKind::Binding {\n+            PatKind::Binding {\n                 mode: BindingMode::ByValue,\n                 var,\n                 subpattern: None,\n@@ -336,9 +336,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             // test works with uninitialized values in a rather\n             // dubious way, so it may be that the test is kind of\n             // broken.\n-            PatternKind::AscribeUserType {\n-                subpattern: Pattern {\n-                    kind: box PatternKind::Binding {\n+            PatKind::AscribeUserType {\n+                subpattern: Pat {\n+                    kind: box PatKind::Binding {\n                         mode: BindingMode::ByValue,\n                         var,\n                         subpattern: None,\n@@ -414,7 +414,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     pub fn place_into_pattern(\n         &mut self,\n         block: BasicBlock,\n-        irrefutable_pat: Pattern<'tcx>,\n+        irrefutable_pat: Pat<'tcx>,\n         initializer: &Place<'tcx>,\n         set_match_place: bool,\n     ) -> BlockAnd<()> {\n@@ -486,7 +486,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         &mut self,\n         mut visibility_scope: Option<SourceScope>,\n         scope_span: Span,\n-        pattern: &Pattern<'tcx>,\n+        pattern: &Pat<'tcx>,\n         has_guard: ArmHasGuard,\n         opt_match_place: Option<(Option<&Place<'tcx>>, Span)>,\n     ) -> Option<SourceScope> {\n@@ -556,7 +556,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n     pub(super) fn visit_bindings(\n         &mut self,\n-        pattern: &Pattern<'tcx>,\n+        pattern: &Pat<'tcx>,\n         pattern_user_ty: UserTypeProjections,\n         f: &mut impl FnMut(\n             &mut Self,\n@@ -571,7 +571,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     ) {\n         debug!(\"visit_bindings: pattern={:?} pattern_user_ty={:?}\", pattern, pattern_user_ty);\n         match *pattern.kind {\n-            PatternKind::Binding {\n+            PatKind::Binding {\n                 mutability,\n                 name,\n                 mode,\n@@ -586,12 +586,12 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 }\n             }\n \n-            PatternKind::Array {\n+            PatKind::Array {\n                 ref prefix,\n                 ref slice,\n                 ref suffix,\n             }\n-            | PatternKind::Slice {\n+            | PatKind::Slice {\n                 ref prefix,\n                 ref slice,\n                 ref suffix,\n@@ -609,13 +609,13 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 }\n             }\n \n-            PatternKind::Constant { .. } | PatternKind::Range { .. } | PatternKind::Wild => {}\n+            PatKind::Constant { .. } | PatKind::Range { .. } | PatKind::Wild => {}\n \n-            PatternKind::Deref { ref subpattern } => {\n+            PatKind::Deref { ref subpattern } => {\n                 self.visit_bindings(subpattern, pattern_user_ty.deref(), f);\n             }\n \n-            PatternKind::AscribeUserType {\n+            PatKind::AscribeUserType {\n                 ref subpattern,\n                 ascription: hair::pattern::Ascription {\n                     ref user_ty,\n@@ -644,22 +644,22 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 self.visit_bindings(subpattern, subpattern_user_ty, f)\n             }\n \n-            PatternKind::Leaf { ref subpatterns } => {\n+            PatKind::Leaf { ref subpatterns } => {\n                 for subpattern in subpatterns {\n                     let subpattern_user_ty = pattern_user_ty.clone().leaf(subpattern.field);\n                     debug!(\"visit_bindings: subpattern_user_ty={:?}\", subpattern_user_ty);\n                     self.visit_bindings(&subpattern.pattern, subpattern_user_ty, f);\n                 }\n             }\n \n-            PatternKind::Variant { adt_def, substs: _, variant_index, ref subpatterns } => {\n+            PatKind::Variant { adt_def, substs: _, variant_index, ref subpatterns } => {\n                 for subpattern in subpatterns {\n                     let subpattern_user_ty = pattern_user_ty.clone().variant(\n                         adt_def, variant_index, subpattern.field);\n                     self.visit_bindings(&subpattern.pattern, subpattern_user_ty, f);\n                 }\n             }\n-            PatternKind::Or { ref pats } => {\n+            PatKind::Or { ref pats } => {\n                 for pat in pats {\n                     self.visit_bindings(&pat, pattern_user_ty.clone(), f);\n                 }\n@@ -708,7 +708,7 @@ struct Binding<'tcx> {\n struct Ascription<'tcx> {\n     span: Span,\n     source: Place<'tcx>,\n-    user_ty: PatternTypeProjection<'tcx>,\n+    user_ty: PatTyProj<'tcx>,\n     variance: ty::Variance,\n }\n \n@@ -718,7 +718,7 @@ pub struct MatchPair<'pat, 'tcx> {\n     place: Place<'tcx>,\n \n     // ... must match this pattern.\n-    pattern: &'pat Pattern<'tcx>,\n+    pattern: &'pat Pat<'tcx>,\n }\n \n #[derive(Clone, Debug, PartialEq)]\n@@ -760,7 +760,7 @@ enum TestKind<'tcx> {\n     },\n \n     /// Test whether the value falls within an inclusive or exclusive range\n-    Range(PatternRange<'tcx>),\n+    Range(PatRange<'tcx>),\n \n     /// Test length of the slice is equal to len\n     Len {\n@@ -1339,7 +1339,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n }\n \n ///////////////////////////////////////////////////////////////////////////\n-// Pattern binding - used for `let` and function parameters as well.\n+// Pat binding - used for `let` and function parameters as well.\n \n impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// Initializes each of the bindings from the candidate by"}, {"sha": "3826e5e3ba5e6c062c8e2ddacdcbd7256e594bd8", "filename": "src/librustc_mir/build/matches/simplify.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -57,7 +57,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                                  -> Result<(), MatchPair<'pat, 'tcx>> {\n         let tcx = self.hir.tcx();\n         match *match_pair.pattern.kind {\n-            PatternKind::AscribeUserType {\n+            PatKind::AscribeUserType {\n                 ref subpattern,\n                 ascription: hair::pattern::Ascription {\n                     variance,\n@@ -79,12 +79,12 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 Ok(())\n             }\n \n-            PatternKind::Wild => {\n+            PatKind::Wild => {\n                 // nothing left to do\n                 Ok(())\n             }\n \n-            PatternKind::Binding { name, mutability, mode, var, ty, ref subpattern } => {\n+            PatKind::Binding { name, mutability, mode, var, ty, ref subpattern } => {\n                 candidate.bindings.push(Binding {\n                     name,\n                     mutability,\n@@ -103,12 +103,12 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 Ok(())\n             }\n \n-            PatternKind::Constant { .. } => {\n+            PatKind::Constant { .. } => {\n                 // FIXME normalize patterns when possible\n                 Err(match_pair)\n             }\n \n-            PatternKind::Range(PatternRange { lo, hi, end }) => {\n+            PatKind::Range(PatRange { lo, hi, end }) => {\n                 let (range, bias) = match lo.ty.kind {\n                     ty::Char => {\n                         (Some(('\\u{0000}' as u128, '\\u{10FFFF}' as u128, Size::from_bits(32))), 0)\n@@ -144,7 +144,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 Err(match_pair)\n             }\n \n-            PatternKind::Slice { ref prefix, ref slice, ref suffix } => {\n+            PatKind::Slice { ref prefix, ref slice, ref suffix } => {\n                 if prefix.is_empty() && slice.is_some() && suffix.is_empty() {\n                     // irrefutable\n                     self.prefix_slice_suffix(&mut candidate.match_pairs,\n@@ -158,7 +158,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 }\n             }\n \n-            PatternKind::Variant { adt_def, substs, variant_index, ref subpatterns } => {\n+            PatKind::Variant { adt_def, substs, variant_index, ref subpatterns } => {\n                 let irrefutable = adt_def.variants.iter_enumerated().all(|(i, v)| {\n                     i == variant_index || {\n                         self.hir.tcx().features().exhaustive_patterns &&\n@@ -174,7 +174,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 }\n             }\n \n-            PatternKind::Array { ref prefix, ref slice, ref suffix } => {\n+            PatKind::Array { ref prefix, ref slice, ref suffix } => {\n                 self.prefix_slice_suffix(&mut candidate.match_pairs,\n                                          &match_pair.place,\n                                          prefix,\n@@ -183,20 +183,20 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 Ok(())\n             }\n \n-            PatternKind::Leaf { ref subpatterns } => {\n+            PatKind::Leaf { ref subpatterns } => {\n                 // tuple struct, match subpats (if any)\n                 candidate.match_pairs\n                          .extend(self.field_match_pairs(match_pair.place, subpatterns));\n                 Ok(())\n             }\n \n-            PatternKind::Deref { ref subpattern } => {\n+            PatKind::Deref { ref subpattern } => {\n                 let place = match_pair.place.deref();\n                 candidate.match_pairs.push(MatchPair::new(place, subpattern));\n                 Ok(())\n             }\n \n-            PatternKind::Or { .. } => {\n+            PatKind::Or { .. } => {\n                 Err(match_pair)\n             }\n         }"}, {"sha": "d8bb0b4f6cc57d3c091912d254d1795e1630d683", "filename": "src/librustc_mir/build/matches/test.rs", "status": "modified", "additions": 39, "deletions": 39, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -26,7 +26,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// It is a bug to call this with a simplifiable pattern.\n     pub fn test<'pat>(&mut self, match_pair: &MatchPair<'pat, 'tcx>) -> Test<'tcx> {\n         match *match_pair.pattern.kind {\n-            PatternKind::Variant { ref adt_def, substs: _, variant_index: _, subpatterns: _ } => {\n+            PatKind::Variant { ref adt_def, substs: _, variant_index: _, subpatterns: _ } => {\n                 Test {\n                     span: match_pair.pattern.span,\n                     kind: TestKind::Switch {\n@@ -36,7 +36,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 }\n             }\n \n-            PatternKind::Constant { .. } if is_switch_ty(match_pair.pattern.ty) => {\n+            PatKind::Constant { .. } if is_switch_ty(match_pair.pattern.ty) => {\n                 // For integers, we use a `SwitchInt` match, which allows\n                 // us to handle more cases.\n                 Test {\n@@ -52,7 +52,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 }\n             }\n \n-            PatternKind::Constant { value } => {\n+            PatKind::Constant { value } => {\n                 Test {\n                     span: match_pair.pattern.span,\n                     kind: TestKind::Eq {\n@@ -62,7 +62,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 }\n             }\n \n-            PatternKind::Range(range) => {\n+            PatKind::Range(range) => {\n                 assert_eq!(range.lo.ty, match_pair.pattern.ty);\n                 assert_eq!(range.hi.ty, match_pair.pattern.ty);\n                 Test {\n@@ -71,7 +71,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 }\n             }\n \n-            PatternKind::Slice { ref prefix, ref slice, ref suffix } => {\n+            PatKind::Slice { ref prefix, ref slice, ref suffix } => {\n                 let len = prefix.len() + suffix.len();\n                 let op = if slice.is_some() {\n                     BinOp::Ge\n@@ -84,13 +84,13 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 }\n             }\n \n-            PatternKind::AscribeUserType { .. } |\n-            PatternKind::Array { .. } |\n-            PatternKind::Wild |\n-            PatternKind::Or { .. } |\n-            PatternKind::Binding { .. } |\n-            PatternKind::Leaf { .. } |\n-            PatternKind::Deref { .. } => {\n+            PatKind::AscribeUserType { .. } |\n+            PatKind::Array { .. } |\n+            PatKind::Wild |\n+            PatKind::Or { .. } |\n+            PatKind::Binding { .. } |\n+            PatKind::Leaf { .. } |\n+            PatKind::Deref { .. } => {\n                 self.error_simplifyable(match_pair)\n             }\n         }\n@@ -110,7 +110,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         };\n \n         match *match_pair.pattern.kind {\n-            PatternKind::Constant { value } => {\n+            PatKind::Constant { value } => {\n                 indices.entry(value)\n                        .or_insert_with(|| {\n                            options.push(value.eval_bits(\n@@ -120,22 +120,22 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                        });\n                 true\n             }\n-            PatternKind::Variant { .. } => {\n+            PatKind::Variant { .. } => {\n                 panic!(\"you should have called add_variants_to_switch instead!\");\n             }\n-            PatternKind::Range(range) => {\n+            PatKind::Range(range) => {\n                 // Check that none of the switch values are in the range.\n                 self.values_not_contained_in_range(range, indices)\n                     .unwrap_or(false)\n             }\n-            PatternKind::Slice { .. } |\n-            PatternKind::Array { .. } |\n-            PatternKind::Wild |\n-            PatternKind::Or { .. } |\n-            PatternKind::Binding { .. } |\n-            PatternKind::AscribeUserType { .. } |\n-            PatternKind::Leaf { .. } |\n-            PatternKind::Deref { .. } => {\n+            PatKind::Slice { .. } |\n+            PatKind::Array { .. } |\n+            PatKind::Wild |\n+            PatKind::Or { .. } |\n+            PatKind::Binding { .. } |\n+            PatKind::AscribeUserType { .. } |\n+            PatKind::Leaf { .. } |\n+            PatKind::Deref { .. } => {\n                 // don't know how to add these patterns to a switch\n                 false\n             }\n@@ -154,7 +154,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         };\n \n         match *match_pair.pattern.kind {\n-            PatternKind::Variant { adt_def: _ , variant_index,  .. } => {\n+            PatKind::Variant { adt_def: _ , variant_index,  .. } => {\n                 // We have a pattern testing for variant `variant_index`\n                 // set the corresponding index to true\n                 variants.insert(variant_index);\n@@ -283,7 +283,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 }\n             }\n \n-            TestKind::Range(PatternRange { ref lo, ref hi, ref end }) => {\n+            TestKind::Range(PatRange { ref lo, ref hi, ref end }) => {\n                 let lower_bound_success = self.cfg.start_new_block();\n                 let target_blocks = make_target_blocks(self);\n \n@@ -533,7 +533,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             // If we are performing a variant switch, then this\n             // informs variant patterns, but nothing else.\n             (&TestKind::Switch { adt_def: tested_adt_def, .. },\n-             &PatternKind::Variant { adt_def, variant_index, ref subpatterns, .. }) => {\n+             &PatKind::Variant { adt_def, variant_index, ref subpatterns, .. }) => {\n                 assert_eq!(adt_def, tested_adt_def);\n                 self.candidate_after_variant_switch(match_pair_index,\n                                                     adt_def,\n@@ -548,18 +548,18 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             // If we are performing a switch over integers, then this informs integer\n             // equality, but nothing else.\n             //\n-            // FIXME(#29623) we could use PatternKind::Range to rule\n+            // FIXME(#29623) we could use PatKind::Range to rule\n             // things out here, in some cases.\n             (&TestKind::SwitchInt { switch_ty: _, options: _, ref indices },\n-             &PatternKind::Constant { ref value })\n+             &PatKind::Constant { ref value })\n             if is_switch_ty(match_pair.pattern.ty) => {\n                 let index = indices[value];\n                 self.candidate_without_match_pair(match_pair_index, candidate);\n                 Some(index)\n             }\n \n             (&TestKind::SwitchInt { switch_ty: _, ref options, ref indices },\n-             &PatternKind::Range(range)) => {\n+             &PatKind::Range(range)) => {\n                 let not_contained = self\n                     .values_not_contained_in_range(range, indices)\n                     .unwrap_or(false);\n@@ -577,7 +577,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             (&TestKind::SwitchInt { .. }, _) => None,\n \n             (&TestKind::Len { len: test_len, op: BinOp::Eq },\n-             &PatternKind::Slice { ref prefix, ref slice, ref suffix }) => {\n+             &PatKind::Slice { ref prefix, ref slice, ref suffix }) => {\n                 let pat_len = (prefix.len() + suffix.len()) as u64;\n                 match (test_len.cmp(&pat_len), slice) {\n                     (Ordering::Equal, &None) => {\n@@ -610,7 +610,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             }\n \n             (&TestKind::Len { len: test_len, op: BinOp::Ge },\n-             &PatternKind::Slice { ref prefix, ref slice, ref suffix }) => {\n+             &PatKind::Slice { ref prefix, ref slice, ref suffix }) => {\n                 // the test is `$actual_len >= test_len`\n                 let pat_len = (prefix.len() + suffix.len()) as u64;\n                 match (test_len.cmp(&pat_len), slice) {\n@@ -644,7 +644,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             }\n \n             (&TestKind::Range(test),\n-             &PatternKind::Range(pat)) => {\n+             &PatKind::Range(pat)) => {\n                 if test == pat {\n                     self.candidate_without_match_pair(\n                         match_pair_index,\n@@ -683,7 +683,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 }\n             }\n \n-            (&TestKind::Range(range), &PatternKind::Constant { value }) => {\n+            (&TestKind::Range(range), &PatKind::Constant { value }) => {\n                 if self.const_range_contains(range, value) == Some(false) {\n                     // `value` is not contained in the testing range,\n                     // so `value` can be matched only if this test fails.\n@@ -722,9 +722,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     fn candidate_after_slice_test<'pat>(&mut self,\n                                         match_pair_index: usize,\n                                         candidate: &mut Candidate<'pat, 'tcx>,\n-                                        prefix: &'pat [Pattern<'tcx>],\n-                                        opt_slice: Option<&'pat Pattern<'tcx>>,\n-                                        suffix: &'pat [Pattern<'tcx>]) {\n+                                        prefix: &'pat [Pat<'tcx>],\n+                                        opt_slice: Option<&'pat Pat<'tcx>>,\n+                                        suffix: &'pat [Pat<'tcx>]) {\n         let removed_place = candidate.match_pairs.remove(match_pair_index).place;\n         self.prefix_slice_suffix(\n             &mut candidate.match_pairs,\n@@ -739,7 +739,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         match_pair_index: usize,\n         adt_def: &'tcx ty::AdtDef,\n         variant_index: VariantIdx,\n-        subpatterns: &'pat [FieldPattern<'tcx>],\n+        subpatterns: &'pat [FieldPat<'tcx>],\n         candidate: &mut Candidate<'pat, 'tcx>,\n     ) {\n         let match_pair = candidate.match_pairs.remove(match_pair_index);\n@@ -771,7 +771,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n     fn const_range_contains(\n         &self,\n-        range: PatternRange<'tcx>,\n+        range: PatRange<'tcx>,\n         value: &'tcx ty::Const<'tcx>,\n     ) -> Option<bool> {\n         use std::cmp::Ordering::*;\n@@ -790,7 +790,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n     fn values_not_contained_in_range(\n         &self,\n-        range: PatternRange<'tcx>,\n+        range: PatRange<'tcx>,\n         indices: &FxHashMap<&'tcx ty::Const<'tcx>, usize>,\n     ) -> Option<bool> {\n         for &val in indices.keys() {"}, {"sha": "83fb924af63812529feea8778f3f73b7c656c3b8", "filename": "src/librustc_mir/build/matches/util.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Futil.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -8,7 +8,7 @@ use std::convert::TryInto;\n impl<'a, 'tcx> Builder<'a, 'tcx> {\n     pub fn field_match_pairs<'pat>(&mut self,\n                                    place: Place<'tcx>,\n-                                   subpatterns: &'pat [FieldPattern<'tcx>])\n+                                   subpatterns: &'pat [FieldPat<'tcx>])\n                                    -> Vec<MatchPair<'pat, 'tcx>> {\n         subpatterns.iter()\n                    .map(|fieldpat| {\n@@ -22,9 +22,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     pub fn prefix_slice_suffix<'pat>(&mut self,\n                                      match_pairs: &mut Vec<MatchPair<'pat, 'tcx>>,\n                                      place: &Place<'tcx>,\n-                                     prefix: &'pat [Pattern<'tcx>],\n-                                     opt_slice: Option<&'pat Pattern<'tcx>>,\n-                                     suffix: &'pat [Pattern<'tcx>]) {\n+                                     prefix: &'pat [Pat<'tcx>],\n+                                     opt_slice: Option<&'pat Pat<'tcx>>,\n+                                     suffix: &'pat [Pat<'tcx>]) {\n         let min_length = prefix.len() + suffix.len();\n         let min_length = min_length.try_into().unwrap();\n \n@@ -101,7 +101,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n }\n \n impl<'pat, 'tcx> MatchPair<'pat, 'tcx> {\n-    pub fn new(place: Place<'tcx>, pattern: &'pat Pattern<'tcx>) -> MatchPair<'pat, 'tcx> {\n+    pub fn new(place: Place<'tcx>, pattern: &'pat Pat<'tcx>) -> MatchPair<'pat, 'tcx> {\n         MatchPair {\n             place,\n             pattern,"}, {"sha": "f1e045302eced66b802b9ce3d89f70ce17580be4", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -1,7 +1,7 @@\n use crate::build;\n use crate::build::scope::DropKind;\n use crate::hair::cx::Cx;\n-use crate::hair::{LintLevel, BindingMode, PatternKind};\n+use crate::hair::{LintLevel, BindingMode, PatKind};\n use crate::transform::MirSource;\n use crate::util as mir_util;\n use rustc::hir;\n@@ -27,17 +27,17 @@ pub fn mir_build(tcx: TyCtxt<'_>, def_id: DefId) -> Body<'_> {\n \n     // Figure out what primary body this item has.\n     let (body_id, return_ty_span) = match tcx.hir().get(id) {\n-        Node::Expr(hir::Expr { node: hir::ExprKind::Closure(_, decl, body_id, _, _), .. })\n-        | Node::Item(hir::Item { node: hir::ItemKind::Fn(decl, _, _, body_id), .. })\n+        Node::Expr(hir::Expr { kind: hir::ExprKind::Closure(_, decl, body_id, _, _), .. })\n+        | Node::Item(hir::Item { kind: hir::ItemKind::Fn(decl, _, _, body_id), .. })\n         | Node::ImplItem(\n             hir::ImplItem {\n-                node: hir::ImplItemKind::Method(hir::MethodSig { decl, .. }, body_id),\n+                kind: hir::ImplItemKind::Method(hir::MethodSig { decl, .. }, body_id),\n                 ..\n             }\n         )\n         | Node::TraitItem(\n             hir::TraitItem {\n-                node: hir::TraitItemKind::Method(\n+                kind: hir::TraitItemKind::Method(\n                     hir::MethodSig { decl, .. },\n                     hir::TraitMethod::Provided(body_id),\n                 ),\n@@ -46,11 +46,11 @@ pub fn mir_build(tcx: TyCtxt<'_>, def_id: DefId) -> Body<'_> {\n         ) => {\n             (*body_id, decl.output.span())\n         }\n-        Node::Item(hir::Item { node: hir::ItemKind::Static(ty, _, body_id), .. })\n-        | Node::Item(hir::Item { node: hir::ItemKind::Const(ty, body_id), .. })\n-        | Node::ImplItem(hir::ImplItem { node: hir::ImplItemKind::Const(ty, body_id), .. })\n+        Node::Item(hir::Item { kind: hir::ItemKind::Static(ty, _, body_id), .. })\n+        | Node::Item(hir::Item { kind: hir::ItemKind::Const(ty, body_id), .. })\n+        | Node::ImplItem(hir::ImplItem { kind: hir::ImplItemKind::Const(ty, body_id), .. })\n         | Node::TraitItem(\n-            hir::TraitItem { node: hir::TraitItemKind::Const(ty, Some(body_id)), .. }\n+            hir::TraitItem { kind: hir::TraitItemKind::Const(ty, Some(body_id)), .. }\n         ) => {\n             (*body_id, ty.span)\n         }\n@@ -559,7 +559,7 @@ where\n             };\n             let mut mutability = Mutability::Not;\n             if let Some(Node::Binding(pat)) = tcx_hir.find(var_hir_id) {\n-                if let hir::PatKind::Binding(_, _, ident, _) = pat.node {\n+                if let hir::PatKind::Binding(_, _, ident, _) = pat.kind {\n                     debuginfo.debug_name = ident.name;\n                     if let Some(&bm) = hir.tables.pat_binding_modes().get(pat.hir_id) {\n                         if bm == ty::BindByValue(hir::MutMutable) {\n@@ -827,7 +827,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 self.set_correct_source_scope_for_arg(arg.hir_id, original_source_scope, span);\n                 match *pattern.kind {\n                     // Don't introduce extra copies for simple bindings\n-                    PatternKind::Binding {\n+                    PatKind::Binding {\n                         mutability,\n                         var,\n                         mode: BindingMode::ByValue,"}, {"sha": "33d67dcf914480f5d2bf344a5b83490bf5de4d43", "filename": "src/librustc_mir/hair/cx/block.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -49,7 +49,7 @@ fn mirror_stmts<'a, 'tcx>(\n     for (index, stmt) in stmts.iter().enumerate() {\n         let hir_id = stmt.hir_id;\n         let opt_dxn_ext = cx.region_scope_tree.opt_destruction_scope(hir_id.local_id);\n-        match stmt.node {\n+        match stmt.kind {\n             hir::StmtKind::Expr(ref expr) |\n             hir::StmtKind::Semi(ref expr) => {\n                 result.push(StmtRef::Mirror(Box::new(Stmt {\n@@ -78,12 +78,12 @@ fn mirror_stmts<'a, 'tcx>(\n                 if let Some(ty) = &local.ty {\n                     if let Some(&user_ty) = cx.tables.user_provided_types().get(ty.hir_id) {\n                         debug!(\"mirror_stmts: user_ty={:?}\", user_ty);\n-                        pattern = Pattern {\n+                        pattern = Pat {\n                             ty: pattern.ty,\n                             span: pattern.span,\n-                            kind: Box::new(PatternKind::AscribeUserType {\n+                            kind: Box::new(PatKind::AscribeUserType {\n                                 ascription: hair::pattern::Ascription {\n-                                    user_ty: PatternTypeProjection::from_user_type(user_ty),\n+                                    user_ty: PatTyProj::from_user_type(user_ty),\n                                     user_ty_span: ty.span,\n                                     variance: ty::Variance::Covariant,\n                                 },"}, {"sha": "da1b9ed7693e6650ca9f10dba03ab1b229f5aa5b", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -204,7 +204,7 @@ fn make_mirror_unadjusted<'a, 'tcx>(\n     let expr_ty = cx.tables().expr_ty(expr);\n     let temp_lifetime = cx.region_scope_tree.temporary_scope(expr.hir_id.local_id);\n \n-    let kind = match expr.node {\n+    let kind = match expr.kind {\n         // Here comes the interesting stuff:\n         hir::ExprKind::MethodCall(_, method_span, ref args) => {\n             // Rewrite a.b(c) into UFCS form like Trait::b(a, c)\n@@ -247,7 +247,7 @@ fn make_mirror_unadjusted<'a, 'tcx>(\n                 }\n             } else {\n                 let adt_data = if let hir::ExprKind::Path(hir::QPath::Resolved(_, ref path)) =\n-                    fun.node\n+                    fun.kind\n                 {\n                     // Tuple-like ADTs are represented as ExprKind::Call. We convert them here.\n                     expr_ty.ty_adt_def().and_then(|adt_def| {\n@@ -427,7 +427,7 @@ fn make_mirror_unadjusted<'a, 'tcx>(\n             if cx.tables().is_method_call(expr) {\n                 overloaded_operator(cx, expr, vec![arg.to_ref()])\n             } else {\n-                if let hir::ExprKind::Lit(ref lit) = arg.node {\n+                if let hir::ExprKind::Lit(ref lit) = arg.kind {\n                     ExprKind::Literal {\n                         literal: cx.const_eval_literal(&lit.node, expr_ty, lit.span, true),\n                         user_ty: None,\n@@ -639,7 +639,7 @@ fn make_mirror_unadjusted<'a, 'tcx>(\n                 // }\n                 // The correct solution would be to add symbolic computations to miri,\n                 // so we wouldn't have to compute and store the actual value\n-                let var = if let hir::ExprKind::Path(ref qpath) = source.node {\n+                let var = if let hir::ExprKind::Path(ref qpath) = source.kind {\n                     let res = cx.tables().qpath_res(qpath, source.hir_id);\n                     cx\n                         .tables()"}, {"sha": "f7cd29f2e67ef591e02af4607b812c2961cf5feb", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -153,16 +153,13 @@ impl<'a, 'tcx> Cx<'a, 'tcx> {\n         }\n     }\n \n-    pub fn pattern_from_hir(&mut self, p: &hir::Pat) -> Pattern<'tcx> {\n+    pub fn pattern_from_hir(&mut self, p: &hir::Pat) -> Pat<'tcx> {\n         let tcx = self.tcx.global_tcx();\n         let p = match tcx.hir().get(p.hir_id) {\n             Node::Pat(p) | Node::Binding(p) => p,\n             node => bug!(\"pattern became {:?}\", node)\n         };\n-        Pattern::from_hir(tcx,\n-                          self.param_env.and(self.identity_substs),\n-                          self.tables(),\n-                          p)\n+        Pat::from_hir(tcx, self.param_env.and(self.identity_substs), self.tables(), p)\n     }\n \n     pub fn trait_method(&mut self,"}, {"sha": "a76377d24bdf95bf1b4a52600c0c5cf6a1c33e11", "filename": "src/librustc_mir/hair/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fmod.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -20,8 +20,8 @@ pub mod cx;\n mod constant;\n \n pub mod pattern;\n-pub use self::pattern::{BindingMode, Pattern, PatternKind, PatternRange, FieldPattern};\n-pub(crate) use self::pattern::PatternTypeProjection;\n+pub use self::pattern::{BindingMode, Pat, PatKind, PatRange, FieldPat};\n+pub(crate) use self::pattern::PatTyProj;\n \n mod util;\n \n@@ -83,7 +83,7 @@ pub enum StmtKind<'tcx> {\n         /// `let <PAT> = ...`\n         ///\n         /// if a type is included, it is added as an ascription pattern\n-        pattern: Pattern<'tcx>,\n+        pattern: Pat<'tcx>,\n \n         /// let pat: ty = <INIT> ...\n         initializer: Option<ExprRef<'tcx>>,\n@@ -293,7 +293,7 @@ pub struct FruInfo<'tcx> {\n \n #[derive(Clone, Debug)]\n pub struct Arm<'tcx> {\n-    pub pattern: Pattern<'tcx>,\n+    pub pattern: Pat<'tcx>,\n     pub guard: Option<Guard<'tcx>>,\n     pub body: ExprRef<'tcx>,\n     pub lint_level: LintLevel,\n@@ -304,9 +304,9 @@ pub struct Arm<'tcx> {\n impl Arm<'tcx> {\n     // HACK(or_patterns; Centril | dlrobertson): Remove this and\n     // correctly handle each case in which this method is used.\n-    pub fn top_pats_hack(&self) -> &[Pattern<'tcx>] {\n+    pub fn top_pats_hack(&self) -> &[Pat<'tcx>] {\n         match &*self.pattern.kind {\n-            PatternKind::Or { pats } => pats,\n+            PatKind::Or { pats } => pats,\n             _ => std::slice::from_ref(&self.pattern),\n         }\n     }"}, {"sha": "75a84f6ec648b6dec057bc4fb00705574679817c", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 89, "deletions": 91, "changes": 180, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -163,7 +163,7 @@ use self::WitnessPreference::*;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::indexed_vec::Idx;\n \n-use super::{FieldPattern, Pattern, PatternKind, PatternRange};\n+use super::{FieldPat, Pat, PatKind, PatRange};\n use super::{PatternFoldable, PatternFolder, compare_const_vals};\n \n use rustc::hir::def_id::DefId;\n@@ -188,9 +188,7 @@ use std::ops::RangeInclusive;\n use std::u128;\n use std::convert::TryInto;\n \n-pub fn expand_pattern<'a, 'tcx>(cx: &MatchCheckCtxt<'a, 'tcx>, pat: Pattern<'tcx>)\n-                                -> &'a Pattern<'tcx>\n-{\n+pub fn expand_pattern<'a, 'tcx>(cx: &MatchCheckCtxt<'a, 'tcx>, pat: Pat<'tcx>) -> &'a Pat<'tcx> {\n     cx.pattern_arena.alloc(LiteralExpander { tcx: cx.tcx }.fold_pattern(&pat))\n }\n \n@@ -243,43 +241,43 @@ impl LiteralExpander<'tcx> {\n }\n \n impl PatternFolder<'tcx> for LiteralExpander<'tcx> {\n-    fn fold_pattern(&mut self, pat: &Pattern<'tcx>) -> Pattern<'tcx> {\n+    fn fold_pattern(&mut self, pat: &Pat<'tcx>) -> Pat<'tcx> {\n         debug!(\"fold_pattern {:?} {:?} {:?}\", pat, pat.ty.kind, pat.kind);\n         match (&pat.ty.kind, &*pat.kind) {\n             (\n                 &ty::Ref(_, rty, _),\n-                &PatternKind::Constant { value: Const {\n+                &PatKind::Constant { value: Const {\n                     val,\n                     ty: ty::TyS { kind: ty::Ref(_, crty, _), .. },\n                 } },\n             ) => {\n-                Pattern {\n+                Pat {\n                     ty: pat.ty,\n                     span: pat.span,\n-                    kind: box PatternKind::Deref {\n-                        subpattern: Pattern {\n+                    kind: box PatKind::Deref {\n+                        subpattern: Pat {\n                             ty: rty,\n                             span: pat.span,\n-                            kind: box PatternKind::Constant { value: self.tcx.mk_const(Const {\n+                            kind: box PatKind::Constant { value: self.tcx.mk_const(Const {\n                                 val: self.fold_const_value_deref(*val, rty, crty),\n                                 ty: rty,\n                             }) },\n                         }\n                     }\n                 }\n             }\n-            (_, &PatternKind::Binding { subpattern: Some(ref s), .. }) => {\n+            (_, &PatKind::Binding { subpattern: Some(ref s), .. }) => {\n                 s.fold_with(self)\n             }\n             _ => pat.super_fold_with(self)\n         }\n     }\n }\n \n-impl<'tcx> Pattern<'tcx> {\n+impl<'tcx> Pat<'tcx> {\n     fn is_wildcard(&self) -> bool {\n         match *self.kind {\n-            PatternKind::Binding { subpattern: None, .. } | PatternKind::Wild =>\n+            PatKind::Binding { subpattern: None, .. } | PatKind::Wild =>\n                 true,\n             _ => false\n         }\n@@ -288,14 +286,14 @@ impl<'tcx> Pattern<'tcx> {\n \n /// A 2D matrix. Nx1 matrices are very common, which is why `SmallVec[_; 2]`\n /// works well for each row.\n-pub struct Matrix<'p, 'tcx>(Vec<SmallVec<[&'p Pattern<'tcx>; 2]>>);\n+pub struct Matrix<'p, 'tcx>(Vec<SmallVec<[&'p Pat<'tcx>; 2]>>);\n \n impl<'p, 'tcx> Matrix<'p, 'tcx> {\n     pub fn empty() -> Self {\n         Matrix(vec![])\n     }\n \n-    pub fn push(&mut self, row: SmallVec<[&'p Pattern<'tcx>; 2]>) {\n+    pub fn push(&mut self, row: SmallVec<[&'p Pat<'tcx>; 2]>) {\n         self.0.push(row)\n     }\n }\n@@ -344,9 +342,9 @@ impl<'p, 'tcx> fmt::Debug for Matrix<'p, 'tcx> {\n     }\n }\n \n-impl<'p, 'tcx> FromIterator<SmallVec<[&'p Pattern<'tcx>; 2]>> for Matrix<'p, 'tcx> {\n+impl<'p, 'tcx> FromIterator<SmallVec<[&'p Pat<'tcx>; 2]>> for Matrix<'p, 'tcx> {\n     fn from_iter<T>(iter: T) -> Self\n-        where T: IntoIterator<Item=SmallVec<[&'p Pattern<'tcx>; 2]>>\n+        where T: IntoIterator<Item=SmallVec<[&'p Pat<'tcx>; 2]>>\n     {\n         Matrix(iter.into_iter().collect())\n     }\n@@ -362,8 +360,8 @@ pub struct MatchCheckCtxt<'a, 'tcx> {\n     /// statement.\n     pub module: DefId,\n     param_env: ty::ParamEnv<'tcx>,\n-    pub pattern_arena: &'a TypedArena<Pattern<'tcx>>,\n-    pub byte_array_map: FxHashMap<*const Pattern<'tcx>, Vec<&'a Pattern<'tcx>>>,\n+    pub pattern_arena: &'a TypedArena<Pat<'tcx>>,\n+    pub byte_array_map: FxHashMap<*const Pat<'tcx>, Vec<&'a Pat<'tcx>>>,\n }\n \n impl<'a, 'tcx> MatchCheckCtxt<'a, 'tcx> {\n@@ -395,9 +393,9 @@ impl<'a, 'tcx> MatchCheckCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn is_non_exhaustive_variant<'p>(&self, pattern: &'p Pattern<'tcx>) -> bool {\n+    fn is_non_exhaustive_variant<'p>(&self, pattern: &'p Pat<'tcx>) -> bool {\n         match *pattern.kind {\n-            PatternKind::Variant { adt_def, variant_index, .. } => {\n+            PatKind::Variant { adt_def, variant_index, .. } => {\n                 let ref variant = adt_def.variants[variant_index];\n                 variant.is_field_list_non_exhaustive()\n             }\n@@ -476,7 +474,7 @@ pub enum WitnessPreference {\n }\n \n #[derive(Copy, Clone, Debug)]\n-struct PatternContext<'tcx> {\n+struct PatCtxt<'tcx> {\n     ty: Ty<'tcx>,\n     max_slice_length: u64,\n }\n@@ -514,10 +512,10 @@ struct PatternContext<'tcx> {\n ///\n /// The final `Pair(Some(_), true)` is then the resulting witness.\n #[derive(Clone, Debug)]\n-pub struct Witness<'tcx>(Vec<Pattern<'tcx>>);\n+pub struct Witness<'tcx>(Vec<Pat<'tcx>>);\n \n impl<'tcx> Witness<'tcx> {\n-    pub fn single_pattern(self) -> Pattern<'tcx> {\n+    pub fn single_pattern(self) -> Pat<'tcx> {\n         assert_eq!(self.0.len(), 1);\n         self.0.into_iter().next().unwrap()\n     }\n@@ -531,10 +529,10 @@ impl<'tcx> Witness<'tcx> {\n     {\n         let sub_pattern_tys = constructor_sub_pattern_tys(cx, ctor, ty);\n         self.0.extend(sub_pattern_tys.into_iter().map(|ty| {\n-            Pattern {\n+            Pat {\n                 ty,\n                 span: DUMMY_SP,\n-                kind: box PatternKind::Wild,\n+                kind: box PatKind::Wild,\n             }\n         }));\n         self.apply_constructor(cx, ctor, ty)\n@@ -569,34 +567,34 @@ impl<'tcx> Witness<'tcx> {\n                 ty::Adt(..) |\n                 ty::Tuple(..) => {\n                     let pats = pats.enumerate().map(|(i, p)| {\n-                        FieldPattern {\n+                        FieldPat {\n                             field: Field::new(i),\n                             pattern: p\n                         }\n                     }).collect();\n \n                     if let ty::Adt(adt, substs) = ty.kind {\n                         if adt.is_enum() {\n-                            PatternKind::Variant {\n+                            PatKind::Variant {\n                                 adt_def: adt,\n                                 substs,\n                                 variant_index: ctor.variant_index_for_adt(cx, adt),\n                                 subpatterns: pats\n                             }\n                         } else {\n-                            PatternKind::Leaf { subpatterns: pats }\n+                            PatKind::Leaf { subpatterns: pats }\n                         }\n                     } else {\n-                        PatternKind::Leaf { subpatterns: pats }\n+                        PatKind::Leaf { subpatterns: pats }\n                     }\n                 }\n \n                 ty::Ref(..) => {\n-                    PatternKind::Deref { subpattern: pats.nth(0).unwrap() }\n+                    PatKind::Deref { subpattern: pats.nth(0).unwrap() }\n                 }\n \n                 ty::Slice(_) | ty::Array(..) => {\n-                    PatternKind::Slice {\n+                    PatKind::Slice {\n                         prefix: pats.collect(),\n                         slice: None,\n                         suffix: vec![]\n@@ -605,19 +603,19 @@ impl<'tcx> Witness<'tcx> {\n \n                 _ => {\n                     match *ctor {\n-                        ConstantValue(value) => PatternKind::Constant { value },\n-                        ConstantRange(lo, hi, ty, end) => PatternKind::Range(PatternRange {\n+                        ConstantValue(value) => PatKind::Constant { value },\n+                        ConstantRange(lo, hi, ty, end) => PatKind::Range(PatRange {\n                             lo: ty::Const::from_bits(cx.tcx, lo, ty::ParamEnv::empty().and(ty)),\n                             hi: ty::Const::from_bits(cx.tcx, hi, ty::ParamEnv::empty().and(ty)),\n                             end,\n                         }),\n-                        _ => PatternKind::Wild,\n+                        _ => PatKind::Wild,\n                     }\n                 }\n             }\n         };\n \n-        self.0.push(Pattern {\n+        self.0.push(Pat {\n             ty,\n             span: DUMMY_SP,\n             kind: Box::new(pat),\n@@ -636,7 +634,7 @@ impl<'tcx> Witness<'tcx> {\n /// `Option<!>`, we do not include `Some(_)` in the returned list of constructors.\n fn all_constructors<'a, 'tcx>(\n     cx: &mut MatchCheckCtxt<'a, 'tcx>,\n-    pcx: PatternContext<'tcx>,\n+    pcx: PatCtxt<'tcx>,\n ) -> Vec<Constructor<'tcx>> {\n     debug!(\"all_constructors({:?})\", pcx.ty);\n     let ctors = match pcx.ty.kind {\n@@ -710,7 +708,7 @@ fn all_constructors<'a, 'tcx>(\n \n fn max_slice_length<'p, 'a, 'tcx, I>(cx: &mut MatchCheckCtxt<'a, 'tcx>, patterns: I) -> u64\n where\n-    I: Iterator<Item = &'p Pattern<'tcx>>,\n+    I: Iterator<Item = &'p Pat<'tcx>>,\n     'tcx: 'p,\n {\n     // The exhaustiveness-checking paper does not include any details on\n@@ -783,7 +781,7 @@ where\n \n     for row in patterns {\n         match *row.kind {\n-            PatternKind::Constant { value } => {\n+            PatKind::Constant { value } => {\n                 // extract the length of an array/slice from a constant\n                 match (value.val, &value.ty.kind) {\n                     (_, ty::Array(_, n)) => max_fixed_len = cmp::max(\n@@ -797,11 +795,11 @@ where\n                     _ => {},\n                 }\n             }\n-            PatternKind::Slice { ref prefix, slice: None, ref suffix } => {\n+            PatKind::Slice { ref prefix, slice: None, ref suffix } => {\n                 let fixed_len = prefix.len() as u64 + suffix.len() as u64;\n                 max_fixed_len = cmp::max(max_fixed_len, fixed_len);\n             }\n-            PatternKind::Slice { ref prefix, slice: Some(_), ref suffix } => {\n+            PatKind::Slice { ref prefix, slice: Some(_), ref suffix } => {\n                 max_prefix_len = cmp::max(max_prefix_len, prefix.len() as u64);\n                 max_suffix_len = cmp::max(max_suffix_len, suffix.len() as u64);\n             }\n@@ -874,18 +872,18 @@ impl<'tcx> IntRange<'tcx> {\n     fn from_pat(\n         tcx: TyCtxt<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n-        mut pat: &Pattern<'tcx>,\n+        mut pat: &Pat<'tcx>,\n     ) -> Option<IntRange<'tcx>> {\n         let range = loop {\n             match pat.kind {\n-                box PatternKind::Constant { value } => break ConstantValue(value),\n-                box PatternKind::Range(PatternRange { lo, hi, end }) => break ConstantRange(\n+                box PatKind::Constant { value } => break ConstantValue(value),\n+                box PatKind::Range(PatRange { lo, hi, end }) => break ConstantRange(\n                     lo.eval_bits(tcx, param_env, lo.ty),\n                     hi.eval_bits(tcx, param_env, hi.ty),\n                     lo.ty,\n                     end,\n                 ),\n-                box PatternKind::AscribeUserType { ref subpattern, .. } => {\n+                box PatKind::AscribeUserType { ref subpattern, .. } => {\n                     pat = subpattern;\n                 },\n                 _ => return None,\n@@ -1058,7 +1056,7 @@ fn compute_missing_ctors<'tcx>(\n /// inputs that will match `v` but not any of the sets in `m`.\n ///\n /// All the patterns at each column of the `matrix ++ v` matrix must\n-/// have the same type, except that wildcard (PatternKind::Wild) patterns\n+/// have the same type, except that wildcard (PatKind::Wild) patterns\n /// with type `TyErr` are also allowed, even if the \"type of the column\"\n /// is not `TyErr`. That is used to represent private fields, as using their\n /// real type would assert that they are inhabited.\n@@ -1070,7 +1068,7 @@ fn compute_missing_ctors<'tcx>(\n pub fn is_useful<'p, 'a, 'tcx>(\n     cx: &mut MatchCheckCtxt<'a, 'tcx>,\n     matrix: &Matrix<'p, 'tcx>,\n-    v: &[&Pattern<'tcx>],\n+    v: &[&Pat<'tcx>],\n     witness: WitnessPreference,\n ) -> Usefulness<'tcx> {\n     let &Matrix(ref rows) = matrix;\n@@ -1094,7 +1092,7 @@ pub fn is_useful<'p, 'a, 'tcx>(\n \n     assert!(rows.iter().all(|r| r.len() == v.len()));\n \n-    let pcx = PatternContext {\n+    let pcx = PatCtxt {\n         // TyErr is used to represent the type of wildcard patterns matching\n         // against inaccessible (private) fields of structs, so that we won't\n         // be able to observe whether the types of the struct's fields are\n@@ -1247,10 +1245,10 @@ pub fn is_useful<'p, 'a, 'tcx>(\n                         // All constructors are unused. Add wild patterns\n                         // rather than each individual constructor.\n                         pats.into_iter().map(|mut witness| {\n-                            witness.0.push(Pattern {\n+                            witness.0.push(Pat {\n                                 ty: pcx.ty,\n                                 span: DUMMY_SP,\n-                                kind: box PatternKind::Wild,\n+                                kind: box PatKind::Wild,\n                             });\n                             witness\n                         }).collect()\n@@ -1285,18 +1283,18 @@ pub fn is_useful<'p, 'a, 'tcx>(\n fn is_useful_specialized<'p, 'a, 'tcx>(\n     cx: &mut MatchCheckCtxt<'a, 'tcx>,\n     &Matrix(ref m): &Matrix<'p, 'tcx>,\n-    v: &[&Pattern<'tcx>],\n+    v: &[&Pat<'tcx>],\n     ctor: Constructor<'tcx>,\n     lty: Ty<'tcx>,\n     witness: WitnessPreference,\n ) -> Usefulness<'tcx> {\n     debug!(\"is_useful_specialized({:#?}, {:#?}, {:?})\", v, ctor, lty);\n     let sub_pat_tys = constructor_sub_pattern_tys(cx, &ctor, lty);\n     let wild_patterns_owned: Vec<_> = sub_pat_tys.iter().map(|ty| {\n-        Pattern {\n+        Pat {\n             ty,\n             span: DUMMY_SP,\n-            kind: box PatternKind::Wild,\n+            kind: box PatKind::Wild,\n         }\n     }).collect();\n     let wild_patterns: Vec<_> = wild_patterns_owned.iter().collect();\n@@ -1325,41 +1323,41 @@ fn is_useful_specialized<'p, 'a, 'tcx>(\n ///\n /// Returns `None` in case of a catch-all, which can't be specialized.\n fn pat_constructors<'tcx>(cx: &mut MatchCheckCtxt<'_, 'tcx>,\n-                          pat: &Pattern<'tcx>,\n-                          pcx: PatternContext<'tcx>)\n+                          pat: &Pat<'tcx>,\n+                          pcx: PatCtxt<'tcx>)\n                           -> Option<Vec<Constructor<'tcx>>>\n {\n     match *pat.kind {\n-        PatternKind::AscribeUserType { ref subpattern, .. } =>\n+        PatKind::AscribeUserType { ref subpattern, .. } =>\n             pat_constructors(cx, subpattern, pcx),\n-        PatternKind::Binding { .. } | PatternKind::Wild => None,\n-        PatternKind::Leaf { .. } | PatternKind::Deref { .. } => Some(vec![Single]),\n-        PatternKind::Variant { adt_def, variant_index, .. } => {\n+        PatKind::Binding { .. } | PatKind::Wild => None,\n+        PatKind::Leaf { .. } | PatKind::Deref { .. } => Some(vec![Single]),\n+        PatKind::Variant { adt_def, variant_index, .. } => {\n             Some(vec![Variant(adt_def.variants[variant_index].def_id)])\n         }\n-        PatternKind::Constant { value } => Some(vec![ConstantValue(value)]),\n-        PatternKind::Range(PatternRange { lo, hi, end }) =>\n+        PatKind::Constant { value } => Some(vec![ConstantValue(value)]),\n+        PatKind::Range(PatRange { lo, hi, end }) =>\n             Some(vec![ConstantRange(\n                 lo.eval_bits(cx.tcx, cx.param_env, lo.ty),\n                 hi.eval_bits(cx.tcx, cx.param_env, hi.ty),\n                 lo.ty,\n                 end,\n             )]),\n-        PatternKind::Array { .. } => match pcx.ty.kind {\n+        PatKind::Array { .. } => match pcx.ty.kind {\n             ty::Array(_, length) => Some(vec![\n                 Slice(length.eval_usize(cx.tcx, cx.param_env))\n             ]),\n             _ => span_bug!(pat.span, \"bad ty {:?} for array pattern\", pcx.ty)\n         },\n-        PatternKind::Slice { ref prefix, ref slice, ref suffix } => {\n+        PatKind::Slice { ref prefix, ref slice, ref suffix } => {\n             let pat_len = prefix.len() as u64 + suffix.len() as u64;\n             if slice.is_some() {\n                 Some((pat_len..pcx.max_slice_length+1).map(Slice).collect())\n             } else {\n                 Some(vec![Slice(pat_len)])\n             }\n         }\n-        PatternKind::Or { .. } => {\n+        PatKind::Or { .. } => {\n             bug!(\"support for or-patterns has not been fully implemented yet.\");\n         }\n     }\n@@ -1446,9 +1444,9 @@ fn slice_pat_covered_by_const<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     _span: Span,\n     const_val: &'tcx ty::Const<'tcx>,\n-    prefix: &[Pattern<'tcx>],\n-    slice: &Option<Pattern<'tcx>>,\n-    suffix: &[Pattern<'tcx>],\n+    prefix: &[Pat<'tcx>],\n+    slice: &Option<Pat<'tcx>>,\n+    suffix: &[Pat<'tcx>],\n     param_env: ty::ParamEnv<'tcx>,\n ) -> Result<bool, ErrorReported> {\n     let data: &[u8] = match (const_val.val, &const_val.ty.kind) {\n@@ -1481,7 +1479,7 @@ fn slice_pat_covered_by_const<'tcx>(\n             data[data.len()-suffix.len()..].iter().zip(suffix))\n     {\n         match pat.kind {\n-            box PatternKind::Constant { value } => {\n+            box PatKind::Constant { value } => {\n                 let b = value.eval_bits(tcx, param_env, pat.ty);\n                 assert_eq!(b as u8 as u128, b);\n                 if b as u8 != *ch {\n@@ -1625,8 +1623,8 @@ fn constructor_intersects_pattern<'p, 'tcx>(\n     tcx: TyCtxt<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     ctor: &Constructor<'tcx>,\n-    pat: &'p Pattern<'tcx>,\n-) -> Option<SmallVec<[&'p Pattern<'tcx>; 2]>> {\n+    pat: &'p Pat<'tcx>,\n+) -> Option<SmallVec<[&'p Pat<'tcx>; 2]>> {\n     if should_treat_range_exhaustively(tcx, ctor) {\n         match (IntRange::from_ctor(tcx, param_env, ctor), IntRange::from_pat(tcx, param_env, pat)) {\n             (Some(ctor), Some(pat)) => {\n@@ -1654,11 +1652,11 @@ fn constructor_covered_by_range<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     ctor: &Constructor<'tcx>,\n-    pat: &Pattern<'tcx>,\n+    pat: &Pat<'tcx>,\n ) -> Result<bool, ErrorReported> {\n     let (from, to, end, ty) = match pat.kind {\n-        box PatternKind::Constant { value } => (value, value, RangeEnd::Included, value.ty),\n-        box PatternKind::Range(PatternRange { lo, hi, end }) => (lo, hi, end, lo.ty),\n+        box PatKind::Constant { value } => (value, value, RangeEnd::Included, value.ty),\n+        box PatKind::Range(PatRange { lo, hi, end }) => (lo, hi, end, lo.ty),\n         _ => bug!(\"`constructor_covered_by_range` called with {:?}\", pat),\n     };\n     trace!(\"constructor_covered_by_range {:#?}, {:#?}, {:#?}, {}\", ctor, from, to, ty);\n@@ -1714,9 +1712,9 @@ fn constructor_covered_by_range<'tcx>(\n }\n \n fn patterns_for_variant<'p, 'tcx>(\n-    subpatterns: &'p [FieldPattern<'tcx>],\n-    wild_patterns: &[&'p Pattern<'tcx>])\n-    -> SmallVec<[&'p Pattern<'tcx>; 2]>\n+    subpatterns: &'p [FieldPat<'tcx>],\n+    wild_patterns: &[&'p Pat<'tcx>])\n+    -> SmallVec<[&'p Pat<'tcx>; 2]>\n {\n     let mut result = SmallVec::from_slice(wild_patterns);\n \n@@ -1738,37 +1736,37 @@ fn patterns_for_variant<'p, 'tcx>(\n /// fields filled with wild patterns.\n fn specialize<'p, 'a: 'p, 'tcx>(\n     cx: &mut MatchCheckCtxt<'a, 'tcx>,\n-    r: &[&'p Pattern<'tcx>],\n+    r: &[&'p Pat<'tcx>],\n     constructor: &Constructor<'tcx>,\n-    wild_patterns: &[&'p Pattern<'tcx>],\n-) -> Option<SmallVec<[&'p Pattern<'tcx>; 2]>> {\n+    wild_patterns: &[&'p Pat<'tcx>],\n+) -> Option<SmallVec<[&'p Pat<'tcx>; 2]>> {\n     let pat = &r[0];\n \n     let head = match *pat.kind {\n-        PatternKind::AscribeUserType { ref subpattern, .. } => {\n+        PatKind::AscribeUserType { ref subpattern, .. } => {\n             specialize(cx, ::std::slice::from_ref(&subpattern), constructor, wild_patterns)\n         }\n \n-        PatternKind::Binding { .. } | PatternKind::Wild => {\n+        PatKind::Binding { .. } | PatKind::Wild => {\n             Some(SmallVec::from_slice(wild_patterns))\n         }\n \n-        PatternKind::Variant { adt_def, variant_index, ref subpatterns, .. } => {\n+        PatKind::Variant { adt_def, variant_index, ref subpatterns, .. } => {\n             let ref variant = adt_def.variants[variant_index];\n             Some(Variant(variant.def_id))\n                 .filter(|variant_constructor| variant_constructor == constructor)\n                 .map(|_| patterns_for_variant(subpatterns, wild_patterns))\n         }\n \n-        PatternKind::Leaf { ref subpatterns } => {\n+        PatKind::Leaf { ref subpatterns } => {\n             Some(patterns_for_variant(subpatterns, wild_patterns))\n         }\n \n-        PatternKind::Deref { ref subpattern } => {\n+        PatKind::Deref { ref subpattern } => {\n             Some(smallvec![subpattern])\n         }\n \n-        PatternKind::Constant { value } => {\n+        PatKind::Constant { value } => {\n             match *constructor {\n                 Slice(..) => {\n                     // we extract an `Option` for the pointer because slices of zero elements don't\n@@ -1827,10 +1825,10 @@ fn specialize<'p, 'a: 'p, 'tcx>(\n                             ).ok()?;\n                             let scalar = scalar.not_undef().ok()?;\n                             let value = ty::Const::from_scalar(cx.tcx, scalar, ty);\n-                            let pattern = Pattern {\n+                            let pattern = Pat {\n                                 ty,\n                                 span: pat.span,\n-                                kind: box PatternKind::Constant { value },\n+                                kind: box PatKind::Constant { value },\n                             };\n                             Some(&*cx.pattern_arena.alloc(pattern))\n                         }).collect()\n@@ -1847,15 +1845,15 @@ fn specialize<'p, 'a: 'p, 'tcx>(\n             }\n         }\n \n-        PatternKind::Range { .. } => {\n+        PatKind::Range { .. } => {\n             // If the constructor is a:\n             //      Single value: add a row if the pattern contains the constructor.\n             //      Range: add a row if the constructor intersects the pattern.\n             constructor_intersects_pattern(cx.tcx, cx.param_env, constructor, pat)\n         }\n \n-        PatternKind::Array { ref prefix, ref slice, ref suffix } |\n-        PatternKind::Slice { ref prefix, ref slice, ref suffix } => {\n+        PatKind::Array { ref prefix, ref slice, ref suffix } |\n+        PatKind::Slice { ref prefix, ref slice, ref suffix } => {\n             match *constructor {\n                 Slice(..) => {\n                     let pat_len = prefix.len() + suffix.len();\n@@ -1888,7 +1886,7 @@ fn specialize<'p, 'a: 'p, 'tcx>(\n             }\n         }\n \n-        PatternKind::Or { .. } => {\n+        PatKind::Or { .. } => {\n             bug!(\"support for or-patterns has not been fully implemented yet.\");\n         }\n     };"}, {"sha": "4572519683d4f20ed0a50f255b151553f6677bd5", "filename": "src/librustc_mir/hair/pattern/check_match.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -2,7 +2,7 @@ use super::_match::{MatchCheckCtxt, Matrix, expand_pattern, is_useful};\n use super::_match::Usefulness::*;\n use super::_match::WitnessPreference::*;\n \n-use super::{Pattern, PatternContext, PatternError, PatternKind};\n+use super::{PatCtxt, PatternError, PatKind};\n \n use rustc::middle::borrowck::SignalledError;\n use rustc::session::Session;\n@@ -14,7 +14,7 @@ use rustc_errors::{Applicability, DiagnosticBuilder};\n use rustc::hir::def::*;\n use rustc::hir::def_id::DefId;\n use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n-use rustc::hir::{self, Pat, PatKind};\n+use rustc::hir::{self, Pat};\n \n use smallvec::smallvec;\n use std::slice;\n@@ -59,7 +59,7 @@ impl<'tcx> Visitor<'tcx> for MatchVisitor<'_, 'tcx> {\n     fn visit_expr(&mut self, ex: &'tcx hir::Expr) {\n         intravisit::walk_expr(self, ex);\n \n-        if let hir::ExprKind::Match(ref scrut, ref arms, source) = ex.node {\n+        if let hir::ExprKind::Match(ref scrut, ref arms, source) = ex.kind {\n             self.check_match(scrut, arms, source);\n         }\n     }\n@@ -88,7 +88,7 @@ impl<'tcx> Visitor<'tcx> for MatchVisitor<'_, 'tcx> {\n     }\n }\n \n-impl PatternContext<'_, '_> {\n+impl PatCtxt<'_, '_> {\n     fn report_inlining_errors(&self, pat_span: Span) {\n         for error in &self.errors {\n             match *error {\n@@ -152,7 +152,7 @@ impl<'tcx> MatchVisitor<'_, 'tcx> {\n \n             let inlined_arms : Vec<(Vec<_>, _)> = arms.iter().map(|arm| (\n                 arm.top_pats_hack().iter().map(|pat| {\n-                    let mut patcx = PatternContext::new(self.tcx,\n+                    let mut patcx = PatCtxt::new(self.tcx,\n                                                         self.param_env.and(self.identity_substs),\n                                                         self.tables);\n                     patcx.include_lint_checks();\n@@ -249,7 +249,7 @@ impl<'tcx> MatchVisitor<'_, 'tcx> {\n     fn check_irrefutable(&self, pat: &'tcx Pat, origin: &str) {\n         let module = self.tcx.hir().get_module_parent(pat.hir_id);\n         MatchCheckCtxt::create_and_enter(self.tcx, self.param_env, module, |ref mut cx| {\n-            let mut patcx = PatternContext::new(self.tcx,\n+            let mut patcx = PatCtxt::new(self.tcx,\n                                                 self.param_env.and(self.identity_substs),\n                                                 self.tables);\n             patcx.include_lint_checks();\n@@ -270,8 +270,8 @@ impl<'tcx> MatchVisitor<'_, 'tcx> {\n                 \"refutable pattern in {}: {} not covered\",\n                 origin, joined_patterns\n             );\n-            err.span_label(pat.span, match &pat.node {\n-                PatKind::Path(hir::QPath::Resolved(None, path))\n+            err.span_label(pat.span, match &pat.kind {\n+                hir::PatKind::Path(hir::QPath::Resolved(None, path))\n                     if path.segments.len() == 1 && path.segments[0].args.is_none() => {\n                     format!(\"interpreted as {} {} pattern, not new variable\",\n                             path.res.article(), path.res.descr())\n@@ -286,7 +286,7 @@ impl<'tcx> MatchVisitor<'_, 'tcx> {\n \n fn check_for_bindings_named_same_as_variants(cx: &MatchVisitor<'_, '_>, pat: &Pat) {\n     pat.walk(|p| {\n-        if let PatKind::Binding(_, _, ident, None) = p.node {\n+        if let hir::PatKind::Binding(_, _, ident, None) = p.kind {\n             if let Some(&bm) = cx.tables.pat_binding_modes().get(p.hir_id) {\n                 if bm != ty::BindByValue(hir::MutImmutable) {\n                     // Nothing to check.\n@@ -321,11 +321,11 @@ fn check_for_bindings_named_same_as_variants(cx: &MatchVisitor<'_, '_>, pat: &Pa\n \n /// Checks for common cases of \"catchall\" patterns that may not be intended as such.\n fn pat_is_catchall(pat: &Pat) -> bool {\n-    match pat.node {\n-        PatKind::Binding(.., None) => true,\n-        PatKind::Binding(.., Some(ref s)) => pat_is_catchall(s),\n-        PatKind::Ref(ref s, _) => pat_is_catchall(s),\n-        PatKind::Tuple(ref v, _) => v.iter().all(|p| {\n+    match pat.kind {\n+        hir::PatKind::Binding(.., None) => true,\n+        hir::PatKind::Binding(.., Some(ref s)) => pat_is_catchall(s),\n+        hir::PatKind::Ref(ref s, _) => pat_is_catchall(s),\n+        hir::PatKind::Tuple(ref v, _) => v.iter().all(|p| {\n             pat_is_catchall(&p)\n         }),\n         _ => false\n@@ -335,7 +335,7 @@ fn pat_is_catchall(pat: &Pat) -> bool {\n // Check for unreachable patterns\n fn check_arms<'tcx>(\n     cx: &mut MatchCheckCtxt<'_, 'tcx>,\n-    arms: &[(Vec<(&Pattern<'tcx>, &hir::Pat)>, Option<&hir::Expr>)],\n+    arms: &[(Vec<(&super::Pat<'tcx>, &hir::Pat)>, Option<&hir::Expr>)],\n     source: hir::MatchSource,\n ) {\n     let mut seen = Matrix::empty();\n@@ -420,8 +420,8 @@ fn check_not_useful(\n     cx: &mut MatchCheckCtxt<'_, 'tcx>,\n     ty: Ty<'tcx>,\n     matrix: &Matrix<'_, 'tcx>,\n-) -> Result<(), Vec<Pattern<'tcx>>> {\n-    let wild_pattern = Pattern { ty, span: DUMMY_SP, kind: box PatternKind::Wild };\n+) -> Result<(), Vec<super::Pat<'tcx>>> {\n+    let wild_pattern = super::Pat { ty, span: DUMMY_SP, kind: box PatKind::Wild };\n     match is_useful(cx, matrix, &[&wild_pattern], ConstructWitness) {\n         NotUseful => Ok(()), // This is good, wildcard pattern isn't reachable.\n         UsefulWithWitness(pats) => Err(if pats.is_empty() {\n@@ -458,7 +458,7 @@ fn check_exhaustive<'tcx>(\n     .emit();\n }\n \n-fn joined_uncovered_patterns(witnesses: &[Pattern<'_>]) -> String {\n+fn joined_uncovered_patterns(witnesses: &[super::Pat<'_>]) -> String {\n     const LIMIT: usize = 3;\n     match witnesses {\n         [] => bug!(),\n@@ -475,7 +475,7 @@ fn joined_uncovered_patterns(witnesses: &[Pattern<'_>]) -> String {\n     }\n }\n \n-fn pattern_not_convered_label(witnesses: &[Pattern<'_>], joined_patterns: &str) -> String {\n+fn pattern_not_convered_label(witnesses: &[super::Pat<'_>], joined_patterns: &str) -> String {\n     format!(\"pattern{} {} not covered\", rustc_errors::pluralise!(witnesses.len()), joined_patterns)\n }\n \n@@ -484,7 +484,7 @@ fn adt_defined_here(\n     cx: &MatchCheckCtxt<'_, '_>,\n     err: &mut DiagnosticBuilder<'_>,\n     ty: Ty<'_>,\n-    witnesses: &[Pattern<'_>],\n+    witnesses: &[super::Pat<'_>],\n ) {\n     let ty = ty.peel_refs();\n     if let ty::Adt(def, _) = ty.kind {\n@@ -500,13 +500,13 @@ fn adt_defined_here(\n     }\n }\n \n-fn maybe_point_at_variant(ty: Ty<'_>, patterns: &[Pattern<'_>]) -> Vec<Span> {\n+fn maybe_point_at_variant(ty: Ty<'_>, patterns: &[super::Pat<'_>]) -> Vec<Span> {\n     let mut covered = vec![];\n     if let ty::Adt(def, _) = ty.kind {\n         // Don't point at variants that have already been covered due to other patterns to avoid\n         // visual clutter.\n         for pattern in patterns {\n-            use PatternKind::{AscribeUserType, Deref, Variant, Or, Leaf};\n+            use PatKind::{AscribeUserType, Deref, Variant, Or, Leaf};\n             match &*pattern.kind {\n                 AscribeUserType { subpattern, .. } | Deref { subpattern } => {\n                     covered.extend(maybe_point_at_variant(ty, slice::from_ref(&subpattern)));\n@@ -568,7 +568,7 @@ fn check_legality_of_move_bindings(cx: &mut MatchVisitor<'_, '_>, has_guard: boo\n     };\n \n     pat.walk(|p| {\n-        if let PatKind::Binding(.., sub) = &p.node {\n+        if let hir::PatKind::Binding(.., sub) = &p.kind {\n             if let Some(&bm) = cx.tables.pat_binding_modes().get(p.hir_id) {\n                 if let ty::BindByValue(..) = bm {\n                     let pat_ty = cx.tables.node_type(p.hir_id);\n@@ -618,8 +618,8 @@ impl<'v> Visitor<'v> for AtBindingPatternVisitor<'_, '_, '_> {\n     }\n \n     fn visit_pat(&mut self, pat: &Pat) {\n-        match pat.node {\n-            PatKind::Binding(.., ref subpat) => {\n+        match pat.kind {\n+            hir::PatKind::Binding(.., ref subpat) => {\n                 if !self.bindings_allowed {\n                     struct_span_err!(self.cx.tcx.sess, pat.span, E0303,\n                                      \"pattern bindings are not allowed after an `@`\")"}, {"sha": "4d2fee3d160ede89a684f6a4b7f39bc21959991b", "filename": "src/librustc_mir/hair/pattern/mod.rs", "status": "modified", "additions": 166, "deletions": 166, "changes": 332, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -19,7 +19,7 @@ use rustc::ty::{self, Region, TyCtxt, AdtDef, Ty, UserType, DefIdTree};\n use rustc::ty::{CanonicalUserType, CanonicalUserTypeAnnotation, CanonicalUserTypeAnnotations};\n use rustc::ty::subst::{SubstsRef, GenericArg};\n use rustc::ty::layout::{VariantIdx, Size};\n-use rustc::hir::{self, PatKind, RangeEnd};\n+use rustc::hir::{self, RangeEnd};\n use rustc::hir::def::{CtorOf, Res, DefKind, CtorKind};\n use rustc::hir::pat_util::EnumerateAndAdjustIterator;\n use rustc::hir::ptr::P;\n@@ -48,25 +48,25 @@ pub enum BindingMode {\n }\n \n #[derive(Clone, Debug)]\n-pub struct FieldPattern<'tcx> {\n+pub struct FieldPat<'tcx> {\n     pub field: Field,\n-    pub pattern: Pattern<'tcx>,\n+    pub pattern: Pat<'tcx>,\n }\n \n #[derive(Clone, Debug)]\n-pub struct Pattern<'tcx> {\n+pub struct Pat<'tcx> {\n     pub ty: Ty<'tcx>,\n     pub span: Span,\n-    pub kind: Box<PatternKind<'tcx>>,\n+    pub kind: Box<PatKind<'tcx>>,\n }\n \n \n #[derive(Copy, Clone, Debug, PartialEq)]\n-pub struct PatternTypeProjection<'tcx> {\n+pub struct PatTyProj<'tcx> {\n     pub user_ty: CanonicalUserType<'tcx>,\n }\n \n-impl<'tcx> PatternTypeProjection<'tcx> {\n+impl<'tcx> PatTyProj<'tcx> {\n     pub(crate) fn from_user_type(user_annotation: CanonicalUserType<'tcx>) -> Self {\n         Self {\n             user_ty: user_annotation,\n@@ -92,7 +92,7 @@ impl<'tcx> PatternTypeProjection<'tcx> {\n \n #[derive(Copy, Clone, Debug, PartialEq)]\n pub struct Ascription<'tcx> {\n-    pub user_ty: PatternTypeProjection<'tcx>,\n+    pub user_ty: PatTyProj<'tcx>,\n     /// Variance to use when relating the type `user_ty` to the **type of the value being\n     /// matched**. Typically, this is `Variance::Covariant`, since the value being matched must\n     /// have a type that is some subtype of the ascribed type.\n@@ -116,12 +116,12 @@ pub struct Ascription<'tcx> {\n }\n \n #[derive(Clone, Debug)]\n-pub enum PatternKind<'tcx> {\n+pub enum PatKind<'tcx> {\n     Wild,\n \n     AscribeUserType {\n         ascription: Ascription<'tcx>,\n-        subpattern: Pattern<'tcx>,\n+        subpattern: Pat<'tcx>,\n     },\n \n     /// `x`, `ref x`, `x @ P`, etc.\n@@ -131,7 +131,7 @@ pub enum PatternKind<'tcx> {\n         mode: BindingMode,\n         var: hir::HirId,\n         ty: Ty<'tcx>,\n-        subpattern: Option<Pattern<'tcx>>,\n+        subpattern: Option<Pat<'tcx>>,\n     },\n \n     /// `Foo(...)` or `Foo{...}` or `Foo`, where `Foo` is a variant name from an ADT with\n@@ -140,57 +140,57 @@ pub enum PatternKind<'tcx> {\n         adt_def: &'tcx AdtDef,\n         substs: SubstsRef<'tcx>,\n         variant_index: VariantIdx,\n-        subpatterns: Vec<FieldPattern<'tcx>>,\n+        subpatterns: Vec<FieldPat<'tcx>>,\n     },\n \n     /// `(...)`, `Foo(...)`, `Foo{...}`, or `Foo`, where `Foo` is a variant name from an ADT with\n     /// a single variant.\n     Leaf {\n-        subpatterns: Vec<FieldPattern<'tcx>>,\n+        subpatterns: Vec<FieldPat<'tcx>>,\n     },\n \n     /// `box P`, `&P`, `&mut P`, etc.\n     Deref {\n-        subpattern: Pattern<'tcx>,\n+        subpattern: Pat<'tcx>,\n     },\n \n     Constant {\n         value: &'tcx ty::Const<'tcx>,\n     },\n \n-    Range(PatternRange<'tcx>),\n+    Range(PatRange<'tcx>),\n \n     /// Matches against a slice, checking the length and extracting elements.\n     /// irrefutable when there is a slice pattern and both `prefix` and `suffix` are empty.\n     /// e.g., `&[ref xs @ ..]`.\n     Slice {\n-        prefix: Vec<Pattern<'tcx>>,\n-        slice: Option<Pattern<'tcx>>,\n-        suffix: Vec<Pattern<'tcx>>,\n+        prefix: Vec<Pat<'tcx>>,\n+        slice: Option<Pat<'tcx>>,\n+        suffix: Vec<Pat<'tcx>>,\n     },\n \n     /// Fixed match against an array; irrefutable.\n     Array {\n-        prefix: Vec<Pattern<'tcx>>,\n-        slice: Option<Pattern<'tcx>>,\n-        suffix: Vec<Pattern<'tcx>>,\n+        prefix: Vec<Pat<'tcx>>,\n+        slice: Option<Pat<'tcx>>,\n+        suffix: Vec<Pat<'tcx>>,\n     },\n \n     /// An or-pattern, e.g. `p | q`.\n     /// Invariant: `pats.len() >= 2`.\n     Or {\n-        pats: Vec<Pattern<'tcx>>,\n+        pats: Vec<Pat<'tcx>>,\n     },\n }\n \n #[derive(Copy, Clone, Debug, PartialEq)]\n-pub struct PatternRange<'tcx> {\n+pub struct PatRange<'tcx> {\n     pub lo: &'tcx ty::Const<'tcx>,\n     pub hi: &'tcx ty::Const<'tcx>,\n     pub end: RangeEnd,\n }\n \n-impl<'tcx> fmt::Display for Pattern<'tcx> {\n+impl<'tcx> fmt::Display for Pat<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         // Printing lists is a chore.\n         let mut first = true;\n@@ -205,10 +205,10 @@ impl<'tcx> fmt::Display for Pattern<'tcx> {\n         let mut start_or_comma = || start_or_continue(\", \");\n \n         match *self.kind {\n-            PatternKind::Wild => write!(f, \"_\"),\n-            PatternKind::AscribeUserType { ref subpattern, .. } =>\n+            PatKind::Wild => write!(f, \"_\"),\n+            PatKind::AscribeUserType { ref subpattern, .. } =>\n                 write!(f, \"{}: _\", subpattern),\n-            PatternKind::Binding { mutability, name, mode, ref subpattern, .. } => {\n+            PatKind::Binding { mutability, name, mode, ref subpattern, .. } => {\n                 let is_mut = match mode {\n                     BindingMode::ByValue => mutability == Mutability::Mut,\n                     BindingMode::ByRef(bk) => {\n@@ -225,10 +225,10 @@ impl<'tcx> fmt::Display for Pattern<'tcx> {\n                 }\n                 Ok(())\n             }\n-            PatternKind::Variant { ref subpatterns, .. } |\n-            PatternKind::Leaf { ref subpatterns } => {\n+            PatKind::Variant { ref subpatterns, .. } |\n+            PatKind::Leaf { ref subpatterns } => {\n                 let variant = match *self.kind {\n-                    PatternKind::Variant { adt_def, variant_index, .. } => {\n+                    PatKind::Variant { adt_def, variant_index, .. } => {\n                         Some(&adt_def.variants[variant_index])\n                     }\n                     _ => if let ty::Adt(adt, _) = self.ty.kind {\n@@ -252,7 +252,7 @@ impl<'tcx> fmt::Display for Pattern<'tcx> {\n \n                         let mut printed = 0;\n                         for p in subpatterns {\n-                            if let PatternKind::Wild = *p.pattern.kind {\n+                            if let PatKind::Wild = *p.pattern.kind {\n                                 continue;\n                             }\n                             let name = variant.fields[p.field.index()].ident;\n@@ -294,7 +294,7 @@ impl<'tcx> fmt::Display for Pattern<'tcx> {\n \n                 Ok(())\n             }\n-            PatternKind::Deref { ref subpattern } => {\n+            PatKind::Deref { ref subpattern } => {\n                 match self.ty.kind {\n                     ty::Adt(def, _) if def.is_box() => write!(f, \"box \")?,\n                     ty::Ref(_, _, mutbl) => {\n@@ -307,27 +307,27 @@ impl<'tcx> fmt::Display for Pattern<'tcx> {\n                 }\n                 write!(f, \"{}\", subpattern)\n             }\n-            PatternKind::Constant { value } => {\n+            PatKind::Constant { value } => {\n                 write!(f, \"{}\", value)\n             }\n-            PatternKind::Range(PatternRange { lo, hi, end }) => {\n+            PatKind::Range(PatRange { lo, hi, end }) => {\n                 write!(f, \"{}\", lo)?;\n                 match end {\n                     RangeEnd::Included => write!(f, \"..=\")?,\n                     RangeEnd::Excluded => write!(f, \"..\")?,\n                 }\n                 write!(f, \"{}\", hi)\n             }\n-            PatternKind::Slice { ref prefix, ref slice, ref suffix } |\n-            PatternKind::Array { ref prefix, ref slice, ref suffix } => {\n+            PatKind::Slice { ref prefix, ref slice, ref suffix } |\n+            PatKind::Array { ref prefix, ref slice, ref suffix } => {\n                 write!(f, \"[\")?;\n                 for p in prefix {\n                     write!(f, \"{}{}\", start_or_comma(), p)?;\n                 }\n                 if let Some(ref slice) = *slice {\n                     write!(f, \"{}\", start_or_comma())?;\n                     match *slice.kind {\n-                        PatternKind::Wild => {}\n+                        PatKind::Wild => {}\n                         _ => write!(f, \"{}\", slice)?\n                     }\n                     write!(f, \"..\")?;\n@@ -337,7 +337,7 @@ impl<'tcx> fmt::Display for Pattern<'tcx> {\n                 }\n                 write!(f, \"]\")\n             }\n-            PatternKind::Or { ref pats } => {\n+            PatKind::Or { ref pats } => {\n                 for pat in pats {\n                     write!(f, \"{}{}\", start_or_continue(\" | \"), pat)?;\n                 }\n@@ -347,7 +347,7 @@ impl<'tcx> fmt::Display for Pattern<'tcx> {\n     }\n }\n \n-pub struct PatternContext<'a, 'tcx> {\n+pub struct PatCtxt<'a, 'tcx> {\n     pub tcx: TyCtxt<'tcx>,\n     pub param_env: ty::ParamEnv<'tcx>,\n     pub tables: &'a ty::TypeckTables<'tcx>,\n@@ -356,31 +356,31 @@ pub struct PatternContext<'a, 'tcx> {\n     include_lint_checks: bool,\n }\n \n-impl<'a, 'tcx> Pattern<'tcx> {\n+impl<'a, 'tcx> Pat<'tcx> {\n     pub fn from_hir(\n         tcx: TyCtxt<'tcx>,\n         param_env_and_substs: ty::ParamEnvAnd<'tcx, SubstsRef<'tcx>>,\n         tables: &'a ty::TypeckTables<'tcx>,\n         pat: &'tcx hir::Pat,\n     ) -> Self {\n-        let mut pcx = PatternContext::new(tcx, param_env_and_substs, tables);\n+        let mut pcx = PatCtxt::new(tcx, param_env_and_substs, tables);\n         let result = pcx.lower_pattern(pat);\n         if !pcx.errors.is_empty() {\n             let msg = format!(\"encountered errors lowering pattern: {:?}\", pcx.errors);\n             tcx.sess.delay_span_bug(pat.span, &msg);\n         }\n-        debug!(\"Pattern::from_hir({:?}) = {:?}\", pat, result);\n+        debug!(\"Pat::from_hir({:?}) = {:?}\", pat, result);\n         result\n     }\n }\n \n-impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n+impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n     pub fn new(\n         tcx: TyCtxt<'tcx>,\n         param_env_and_substs: ty::ParamEnvAnd<'tcx, SubstsRef<'tcx>>,\n         tables: &'a ty::TypeckTables<'tcx>,\n     ) -> Self {\n-        PatternContext {\n+        PatCtxt {\n             tcx,\n             param_env: param_env_and_substs.param_env,\n             tables,\n@@ -395,7 +395,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n         self\n     }\n \n-    pub fn lower_pattern(&mut self, pat: &'tcx hir::Pat) -> Pattern<'tcx> {\n+    pub fn lower_pattern(&mut self, pat: &'tcx hir::Pat) -> Pat<'tcx> {\n         // When implicit dereferences have been inserted in this pattern, the unadjusted lowered\n         // pattern has the type that results *after* dereferencing. For example, in this code:\n         //\n@@ -412,7 +412,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n         // `vec![&&Option<i32>, &Option<i32>]`.\n         //\n         // Applying the adjustments, we want to instead output `&&Some(n)` (as a HAIR pattern). So\n-        // we wrap the unadjusted pattern in `PatternKind::Deref` repeatedly, consuming the\n+        // we wrap the unadjusted pattern in `PatKind::Deref` repeatedly, consuming the\n         // adjustments in *reverse order* (last-in-first-out, so that the last `Deref` inserted\n         // gets the least-dereferenced type).\n         let unadjusted_pat = self.lower_pattern_unadjusted(pat);\n@@ -424,10 +424,10 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n             .rev()\n             .fold(unadjusted_pat, |pat, ref_ty| {\n                     debug!(\"{:?}: wrapping pattern with type {:?}\", pat, ref_ty);\n-                    Pattern {\n+                    Pat {\n                         span: pat.span,\n                         ty: ref_ty,\n-                        kind: Box::new(PatternKind::Deref { subpattern: pat }),\n+                        kind: Box::new(PatKind::Deref { subpattern: pat }),\n                     }\n                 },\n             )\n@@ -436,30 +436,30 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n     fn lower_range_expr(\n         &mut self,\n         expr: &'tcx hir::Expr,\n-    ) -> (PatternKind<'tcx>, Option<Ascription<'tcx>>) {\n+    ) -> (PatKind<'tcx>, Option<Ascription<'tcx>>) {\n         match self.lower_lit(expr) {\n-            PatternKind::AscribeUserType {\n+            PatKind::AscribeUserType {\n                 ascription: lo_ascription,\n-                subpattern: Pattern { kind: box kind, .. },\n+                subpattern: Pat { kind: box kind, .. },\n             } => (kind, Some(lo_ascription)),\n             kind => (kind, None),\n         }\n     }\n \n-    fn lower_pattern_unadjusted(&mut self, pat: &'tcx hir::Pat) -> Pattern<'tcx> {\n+    fn lower_pattern_unadjusted(&mut self, pat: &'tcx hir::Pat) -> Pat<'tcx> {\n         let mut ty = self.tables.node_type(pat.hir_id);\n \n-        let kind = match pat.node {\n-            PatKind::Wild => PatternKind::Wild,\n+        let kind = match pat.kind {\n+            hir::PatKind::Wild => PatKind::Wild,\n \n-            PatKind::Lit(ref value) => self.lower_lit(value),\n+            hir::PatKind::Lit(ref value) => self.lower_lit(value),\n \n-            PatKind::Range(ref lo_expr, ref hi_expr, end) => {\n+            hir::PatKind::Range(ref lo_expr, ref hi_expr, end) => {\n                 let (lo, lo_ascription) = self.lower_range_expr(lo_expr);\n                 let (hi, hi_ascription) = self.lower_range_expr(hi_expr);\n \n                 let mut kind = match (lo, hi) {\n-                    (PatternKind::Constant { value: lo }, PatternKind::Constant { value: hi }) => {\n+                    (PatKind::Constant { value: lo }, PatKind::Constant { value: hi }) => {\n                         assert_eq!(lo.ty, ty);\n                         assert_eq!(hi.ty, ty);\n                         let cmp = compare_const_vals(\n@@ -471,21 +471,21 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                         );\n                         match (end, cmp) {\n                             (RangeEnd::Excluded, Some(Ordering::Less)) =>\n-                                PatternKind::Range(PatternRange { lo, hi, end }),\n+                                PatKind::Range(PatRange { lo, hi, end }),\n                             (RangeEnd::Excluded, _) => {\n                                 span_err!(\n                                     self.tcx.sess,\n                                     lo_expr.span,\n                                     E0579,\n                                     \"lower range bound must be less than upper\",\n                                 );\n-                                PatternKind::Wild\n+                                PatKind::Wild\n                             }\n                             (RangeEnd::Included, Some(Ordering::Equal)) => {\n-                                PatternKind::Constant { value: lo }\n+                                PatKind::Constant { value: lo }\n                             }\n                             (RangeEnd::Included, Some(Ordering::Less)) => {\n-                                PatternKind::Range(PatternRange { lo, hi, end })\n+                                PatKind::Range(PatRange { lo, hi, end })\n                             }\n                             (RangeEnd::Included, _) => {\n                                 let mut err = struct_span_err!(\n@@ -506,7 +506,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                                               to be less than or equal to the end of the range.\");\n                                 }\n                                 err.emit();\n-                                PatternKind::Wild\n+                                PatKind::Wild\n                             }\n                         }\n                     },\n@@ -519,7 +519,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                             ),\n                         );\n \n-                        PatternKind::Wild\n+                        PatKind::Wild\n                     },\n                 };\n \n@@ -528,30 +528,30 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                 // constants somewhere. Have them on the range pattern.\n                 for ascription in &[lo_ascription, hi_ascription] {\n                     if let Some(ascription) = ascription {\n-                        kind = PatternKind::AscribeUserType {\n+                        kind = PatKind::AscribeUserType {\n                             ascription: *ascription,\n-                            subpattern: Pattern { span: pat.span, ty, kind: Box::new(kind), },\n+                            subpattern: Pat { span: pat.span, ty, kind: Box::new(kind), },\n                         };\n                     }\n                 }\n \n                 kind\n             }\n \n-            PatKind::Path(ref qpath) => {\n+            hir::PatKind::Path(ref qpath) => {\n                 return self.lower_path(qpath, pat.hir_id, pat.span);\n             }\n \n-            PatKind::Ref(ref subpattern, _) |\n-            PatKind::Box(ref subpattern) => {\n-                PatternKind::Deref { subpattern: self.lower_pattern(subpattern) }\n+            hir::PatKind::Ref(ref subpattern, _) |\n+            hir::PatKind::Box(ref subpattern) => {\n+                PatKind::Deref { subpattern: self.lower_pattern(subpattern) }\n             }\n \n-            PatKind::Slice(ref prefix, ref slice, ref suffix) => {\n+            hir::PatKind::Slice(ref prefix, ref slice, ref suffix) => {\n                 match ty.kind {\n                     ty::Ref(_, ty, _) =>\n-                        PatternKind::Deref {\n-                            subpattern: Pattern {\n+                        PatKind::Deref {\n+                            subpattern: Pat {\n                                 ty,\n                                 span: pat.span,\n                                 kind: Box::new(self.slice_or_array_pattern(\n@@ -562,7 +562,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                     ty::Array(..) =>\n                         self.slice_or_array_pattern(pat.span, ty, prefix, slice, suffix),\n                     ty::Error => { // Avoid ICE\n-                        return Pattern { span: pat.span, ty, kind: Box::new(PatternKind::Wild) };\n+                        return Pat { span: pat.span, ty, kind: Box::new(PatKind::Wild) };\n                     }\n                     _ =>\n                         span_bug!(\n@@ -572,32 +572,32 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                 }\n             }\n \n-            PatKind::Tuple(ref subpatterns, ddpos) => {\n+            hir::PatKind::Tuple(ref subpatterns, ddpos) => {\n                 match ty.kind {\n                     ty::Tuple(ref tys) => {\n                         let subpatterns =\n                             subpatterns.iter()\n                                        .enumerate_and_adjust(tys.len(), ddpos)\n-                                       .map(|(i, subpattern)| FieldPattern {\n+                                       .map(|(i, subpattern)| FieldPat {\n                                             field: Field::new(i),\n                                             pattern: self.lower_pattern(subpattern)\n                                        })\n                                        .collect();\n \n-                        PatternKind::Leaf { subpatterns }\n+                        PatKind::Leaf { subpatterns }\n                     }\n                     ty::Error => { // Avoid ICE (#50577)\n-                        return Pattern { span: pat.span, ty, kind: Box::new(PatternKind::Wild) };\n+                        return Pat { span: pat.span, ty, kind: Box::new(PatKind::Wild) };\n                     }\n                     _ => span_bug!(pat.span, \"unexpected type for tuple pattern: {:?}\", ty),\n                 }\n             }\n \n-            PatKind::Binding(_, id, ident, ref sub) => {\n+            hir::PatKind::Binding(_, id, ident, ref sub) => {\n                 let var_ty = self.tables.node_type(pat.hir_id);\n                 if let ty::Error = var_ty.kind {\n                     // Avoid ICE\n-                    return Pattern { span: pat.span, ty, kind: Box::new(PatternKind::Wild) };\n+                    return Pat { span: pat.span, ty, kind: Box::new(PatKind::Wild) };\n                 };\n                 let bm = *self.tables.pat_binding_modes().get(pat.hir_id)\n                                                          .expect(\"missing binding mode\");\n@@ -624,7 +624,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                     }\n                 }\n \n-                PatternKind::Binding {\n+                PatKind::Binding {\n                     mutability,\n                     mode,\n                     name: ident.name,\n@@ -634,12 +634,12 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                 }\n             }\n \n-            PatKind::TupleStruct(ref qpath, ref subpatterns, ddpos) => {\n+            hir::PatKind::TupleStruct(ref qpath, ref subpatterns, ddpos) => {\n                 let res = self.tables.qpath_res(qpath, pat.hir_id);\n                 let adt_def = match ty.kind {\n                     ty::Adt(adt_def, _) => adt_def,\n                     ty::Error => { // Avoid ICE (#50585)\n-                        return Pattern { span: pat.span, ty, kind: Box::new(PatternKind::Wild) };\n+                        return Pat { span: pat.span, ty, kind: Box::new(PatKind::Wild) };\n                     }\n                     _ => span_bug!(pat.span,\n                                    \"tuple struct pattern not applied to an ADT {:?}\",\n@@ -650,7 +650,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                 let subpatterns =\n                         subpatterns.iter()\n                                    .enumerate_and_adjust(variant_def.fields.len(), ddpos)\n-                                   .map(|(i, field)| FieldPattern {\n+                                   .map(|(i, field)| FieldPat {\n                                        field: Field::new(i),\n                                        pattern: self.lower_pattern(field),\n                                    })\n@@ -659,12 +659,12 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                 self.lower_variant_or_leaf(res, pat.hir_id, pat.span, ty, subpatterns)\n             }\n \n-            PatKind::Struct(ref qpath, ref fields, _) => {\n+            hir::PatKind::Struct(ref qpath, ref fields, _) => {\n                 let res = self.tables.qpath_res(qpath, pat.hir_id);\n                 let subpatterns =\n                     fields.iter()\n                           .map(|field| {\n-                              FieldPattern {\n+                              FieldPat {\n                                   field: Field::new(self.tcx.field_index(field.hir_id,\n                                                                          self.tables)),\n                                   pattern: self.lower_pattern(&field.pat),\n@@ -675,35 +675,35 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                 self.lower_variant_or_leaf(res, pat.hir_id, pat.span, ty, subpatterns)\n             }\n \n-            PatKind::Or(ref pats) => {\n-                PatternKind::Or {\n+            hir::PatKind::Or(ref pats) => {\n+                PatKind::Or {\n                     pats: pats.iter().map(|p| self.lower_pattern(p)).collect(),\n                 }\n             }\n         };\n \n-        Pattern {\n+        Pat {\n             span: pat.span,\n             ty,\n             kind: Box::new(kind),\n         }\n     }\n \n-    fn lower_patterns(&mut self, pats: &'tcx [P<hir::Pat>]) -> Vec<Pattern<'tcx>> {\n+    fn lower_patterns(&mut self, pats: &'tcx [P<hir::Pat>]) -> Vec<Pat<'tcx>> {\n         pats.iter().map(|p| self.lower_pattern(p)).collect()\n     }\n \n-    fn lower_opt_pattern(&mut self, pat: &'tcx Option<P<hir::Pat>>) -> Option<Pattern<'tcx>>\n+    fn lower_opt_pattern(&mut self, pat: &'tcx Option<P<hir::Pat>>) -> Option<Pat<'tcx>>\n     {\n         pat.as_ref().map(|p| self.lower_pattern(p))\n     }\n \n     fn flatten_nested_slice_patterns(\n         &mut self,\n-        prefix: Vec<Pattern<'tcx>>,\n-        slice: Option<Pattern<'tcx>>,\n-        suffix: Vec<Pattern<'tcx>>)\n-        -> (Vec<Pattern<'tcx>>, Option<Pattern<'tcx>>, Vec<Pattern<'tcx>>)\n+        prefix: Vec<Pat<'tcx>>,\n+        slice: Option<Pat<'tcx>>,\n+        suffix: Vec<Pat<'tcx>>)\n+        -> (Vec<Pat<'tcx>>, Option<Pat<'tcx>>, Vec<Pat<'tcx>>)\n     {\n         let orig_slice = match slice {\n             Some(orig_slice) => orig_slice,\n@@ -715,8 +715,8 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n         // dance because of intentional borrow-checker stupidity.\n         let kind = *orig_slice.kind;\n         match kind {\n-            PatternKind::Slice { prefix, slice, mut suffix } |\n-            PatternKind::Array { prefix, slice, mut suffix } => {\n+            PatKind::Slice { prefix, slice, mut suffix } |\n+            PatKind::Array { prefix, slice, mut suffix } => {\n                 let mut orig_prefix = orig_prefix;\n \n                 orig_prefix.extend(prefix);\n@@ -725,7 +725,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                 (orig_prefix, slice, suffix)\n             }\n             _ => {\n-                (orig_prefix, Some(Pattern {\n+                (orig_prefix, Some(Pat {\n                     kind: box kind, ..orig_slice\n                 }), orig_suffix)\n             }\n@@ -739,7 +739,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n         prefix: &'tcx [P<hir::Pat>],\n         slice: &'tcx Option<P<hir::Pat>>,\n         suffix: &'tcx [P<hir::Pat>])\n-        -> PatternKind<'tcx>\n+        -> PatKind<'tcx>\n     {\n         let prefix = self.lower_patterns(prefix);\n         let slice = self.lower_opt_pattern(slice);\n@@ -750,14 +750,14 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n         match ty.kind {\n             ty::Slice(..) => {\n                 // matching a slice or fixed-length array\n-                PatternKind::Slice { prefix: prefix, slice: slice, suffix: suffix }\n+                PatKind::Slice { prefix: prefix, slice: slice, suffix: suffix }\n             }\n \n             ty::Array(_, len) => {\n                 // fixed-length array\n                 let len = len.eval_usize(self.tcx, self.param_env);\n                 assert!(len >= prefix.len() as u64 + suffix.len() as u64);\n-                PatternKind::Array { prefix: prefix, slice: slice, suffix: suffix }\n+                PatKind::Array { prefix: prefix, slice: slice, suffix: suffix }\n             }\n \n             _ => {\n@@ -772,8 +772,8 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n         hir_id: hir::HirId,\n         span: Span,\n         ty: Ty<'tcx>,\n-        subpatterns: Vec<FieldPattern<'tcx>>,\n-    ) -> PatternKind<'tcx> {\n+        subpatterns: Vec<FieldPat<'tcx>>,\n+    ) -> PatKind<'tcx> {\n         let res = match res {\n             Res::Def(DefKind::Ctor(CtorOf::Variant, ..), variant_ctor_id) => {\n                 let variant_id = self.tcx.parent(variant_ctor_id).unwrap();\n@@ -791,18 +791,18 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                         ty::Adt(_, substs) |\n                         ty::FnDef(_, substs) => substs,\n                         ty::Error => {  // Avoid ICE (#50585)\n-                            return PatternKind::Wild;\n+                            return PatKind::Wild;\n                         }\n                         _ => bug!(\"inappropriate type for def: {:?}\", ty),\n                     };\n-                    PatternKind::Variant {\n+                    PatKind::Variant {\n                         adt_def,\n                         substs,\n                         variant_index: adt_def.variant_index_with_id(variant_id),\n                         subpatterns,\n                     }\n                 } else {\n-                    PatternKind::Leaf { subpatterns }\n+                    PatKind::Leaf { subpatterns }\n                 }\n             }\n \n@@ -813,25 +813,25 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n             | Res::Def(DefKind::AssocTy, _)\n             | Res::SelfTy(..)\n             | Res::SelfCtor(..) => {\n-                PatternKind::Leaf { subpatterns }\n+                PatKind::Leaf { subpatterns }\n             }\n \n             _ => {\n                 self.errors.push(PatternError::NonConstPath(span));\n-                PatternKind::Wild\n+                PatKind::Wild\n             }\n         };\n \n         if let Some(user_ty) = self.user_substs_applied_to_ty_of_hir_id(hir_id) {\n             debug!(\"lower_variant_or_leaf: kind={:?} user_ty={:?} span={:?}\", kind, user_ty, span);\n-            kind = PatternKind::AscribeUserType {\n-                subpattern: Pattern {\n+            kind = PatKind::AscribeUserType {\n+                subpattern: Pat {\n                     span,\n                     ty,\n                     kind: Box::new(kind),\n                 },\n                 ascription: Ascription {\n-                    user_ty: PatternTypeProjection::from_user_type(user_ty),\n+                    user_ty: PatTyProj::from_user_type(user_ty),\n                     user_ty_span: span,\n                     variance: ty::Variance::Covariant,\n                 },\n@@ -848,7 +848,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                   qpath: &hir::QPath,\n                   id: hir::HirId,\n                   span: Span)\n-                  -> Pattern<'tcx> {\n+                  -> Pat<'tcx> {\n         let ty = self.tables.node_type(id);\n         let res = self.tables.qpath_res(qpath, id);\n         let is_associated_const = match res {\n@@ -878,11 +878,11 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n \n                                 let user_provided_types = self.tables().user_provided_types();\n                                 return if let Some(u_ty) = user_provided_types.get(id) {\n-                                    let user_ty = PatternTypeProjection::from_user_type(*u_ty);\n-                                    Pattern {\n+                                    let user_ty = PatTyProj::from_user_type(*u_ty);\n+                                    Pat {\n                                         span,\n                                         kind: Box::new(\n-                                            PatternKind::AscribeUserType {\n+                                            PatKind::AscribeUserType {\n                                                 subpattern: pattern,\n                                                 ascription: Ascription {\n                                                     /// Note that use `Contravariant` here. See the\n@@ -904,7 +904,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                                     span,\n                                     \"could not evaluate constant pattern\",\n                                 );\n-                                PatternKind::Wild\n+                                PatKind::Wild\n                             }\n                         }\n                     },\n@@ -914,14 +914,14 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                         } else {\n                             PatternError::StaticInPattern(span)\n                         });\n-                        PatternKind::Wild\n+                        PatKind::Wild\n                     },\n                 }\n             }\n             _ => self.lower_variant_or_leaf(res, id, span, ty, vec![]),\n         };\n \n-        Pattern {\n+        Pat {\n             span,\n             ty,\n             kind: Box::new(kind),\n@@ -932,8 +932,8 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n     /// The special case for negation exists to allow things like `-128_i8`\n     /// which would overflow if we tried to evaluate `128_i8` and then negate\n     /// afterwards.\n-    fn lower_lit(&mut self, expr: &'tcx hir::Expr) -> PatternKind<'tcx> {\n-        match expr.node {\n+    fn lower_lit(&mut self, expr: &'tcx hir::Expr) -> PatKind<'tcx> {\n+        match expr.kind {\n             hir::ExprKind::Lit(ref lit) => {\n                 let ty = self.tables.expr_ty(expr);\n                 match lit_to_const(&lit.node, self.tcx, ty, false) {\n@@ -946,15 +946,15 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                     },\n                     Err(LitToConstError::UnparseableFloat) => {\n                         self.errors.push(PatternError::FloatBug);\n-                        PatternKind::Wild\n+                        PatKind::Wild\n                     },\n-                    Err(LitToConstError::Reported) => PatternKind::Wild,\n+                    Err(LitToConstError::Reported) => PatKind::Wild,\n                 }\n             },\n             hir::ExprKind::Path(ref qpath) => *self.lower_path(qpath, expr.hir_id, expr.span).kind,\n             hir::ExprKind::Unary(hir::UnNeg, ref expr) => {\n                 let ty = self.tables.expr_ty(expr);\n-                let lit = match expr.node {\n+                let lit = match expr.kind {\n                     hir::ExprKind::Lit(ref lit) => lit,\n                     _ => span_bug!(expr.span, \"not a literal: {:?}\", expr),\n                 };\n@@ -968,9 +968,9 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                     },\n                     Err(LitToConstError::UnparseableFloat) => {\n                         self.errors.push(PatternError::FloatBug);\n-                        PatternKind::Wild\n+                        PatKind::Wild\n                     },\n-                    Err(LitToConstError::Reported) => PatternKind::Wild,\n+                    Err(LitToConstError::Reported) => PatKind::Wild,\n                 }\n             }\n             _ => span_bug!(expr.span, \"not a literal: {:?}\", expr),\n@@ -986,7 +986,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n         cv: &'tcx ty::Const<'tcx>,\n         id: hir::HirId,\n         span: Span,\n-    ) -> Pattern<'tcx> {\n+    ) -> Pat<'tcx> {\n         // This method is just a warpper handling a validity check; the heavy lifting is\n         // performed by the recursive const_to_pat_inner method, which is not meant to be\n         // invoked except by this method.\n@@ -1057,7 +1057,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n         // value, so that we will not subsequently issue an irrelevant\n         // lint for the same const value.\n         saw_const_match_error: &mut bool,\n-    ) -> Pattern<'tcx> {\n+    ) -> Pat<'tcx> {\n \n         let mut adt_subpattern = |i, variant_opt| {\n             let field = Field::new(i);\n@@ -1069,7 +1069,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n         let mut adt_subpatterns = |n, variant_opt| {\n             (0..n).map(|i| {\n                 let field = Field::new(i);\n-                FieldPattern {\n+                FieldPat {\n                     field,\n                     pattern: adt_subpattern(i, variant_opt),\n                 }\n@@ -1085,15 +1085,15 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                     span,\n                     \"floating-point types cannot be used in patterns\",\n                 );\n-                PatternKind::Constant {\n+                PatKind::Constant {\n                     value: cv,\n                 }\n             }\n             ty::Adt(adt_def, _) if adt_def.is_union() => {\n                 // Matching on union fields is unsafe, we can't hide it in constants\n                 *saw_const_match_error = true;\n                 self.tcx.sess.span_err(span, \"cannot use unions in constant patterns\");\n-                PatternKind::Wild\n+                PatKind::Wild\n             }\n             // keep old code until future-compat upgraded to errors.\n             ty::Adt(adt_def, _) if !self.tcx.has_attr(adt_def.did, sym::structural_match) => {\n@@ -1106,13 +1106,13 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                 );\n                 *saw_const_match_error = true;\n                 self.tcx.sess.span_err(span, &msg);\n-                PatternKind::Wild\n+                PatKind::Wild\n             }\n             // keep old code until future-compat upgraded to errors.\n             ty::Ref(_, ty::TyS { kind: ty::Adt(adt_def, _), .. }, _)\n             if !self.tcx.has_attr(adt_def.did, sym::structural_match) => {\n                 // HACK(estebank): Side-step ICE #53708, but anything other than erroring here\n-                // would be wrong. Returnging `PatternKind::Wild` is not technically correct.\n+                // would be wrong. Returnging `PatKind::Wild` is not technically correct.\n                 let path = self.tcx.def_path_str(adt_def.did);\n                 let msg = format!(\n                     \"to use a constant of type `{}` in a pattern, \\\n@@ -1122,15 +1122,15 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                 );\n                 *saw_const_match_error = true;\n                 self.tcx.sess.span_err(span, &msg);\n-                PatternKind::Wild\n+                PatKind::Wild\n             }\n             ty::Adt(adt_def, substs) if adt_def.is_enum() => {\n                 let variant_index = const_variant_index(self.tcx, self.param_env, cv);\n                 let subpatterns = adt_subpatterns(\n                     adt_def.variants[variant_index].fields.len(),\n                     Some(variant_index),\n                 );\n-                PatternKind::Variant {\n+                PatKind::Variant {\n                     adt_def,\n                     substs,\n                     variant_index,\n@@ -1139,17 +1139,17 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n             }\n             ty::Adt(adt_def, _) => {\n                 let struct_var = adt_def.non_enum_variant();\n-                PatternKind::Leaf {\n+                PatKind::Leaf {\n                     subpatterns: adt_subpatterns(struct_var.fields.len(), None),\n                 }\n             }\n             ty::Tuple(fields) => {\n-                PatternKind::Leaf {\n+                PatKind::Leaf {\n                     subpatterns: adt_subpatterns(fields.len(), None),\n                 }\n             }\n             ty::Array(_, n) => {\n-                PatternKind::Array {\n+                PatKind::Array {\n                     prefix: (0..n.eval_usize(self.tcx, self.param_env))\n                         .map(|i| adt_subpattern(i as usize, None))\n                         .collect(),\n@@ -1158,13 +1158,13 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                 }\n             }\n             _ => {\n-                PatternKind::Constant {\n+                PatKind::Constant {\n                     value: cv,\n                 }\n             }\n         };\n \n-        Pattern {\n+        Pat {\n             span,\n             ty: cv.ty,\n             kind: Box::new(kind),\n@@ -1293,7 +1293,7 @@ fn search_for_adt_without_structural_match<'tcx>(tcx: TyCtxt<'tcx>,\n     }\n }\n \n-impl UserAnnotatedTyHelpers<'tcx> for PatternContext<'_, 'tcx> {\n+impl UserAnnotatedTyHelpers<'tcx> for PatCtxt<'_, 'tcx> {\n     fn tcx(&self) -> TyCtxt<'tcx> {\n         self.tcx\n     }\n@@ -1313,11 +1313,11 @@ pub trait PatternFoldable<'tcx> : Sized {\n }\n \n pub trait PatternFolder<'tcx> : Sized {\n-    fn fold_pattern(&mut self, pattern: &Pattern<'tcx>) -> Pattern<'tcx> {\n+    fn fold_pattern(&mut self, pattern: &Pat<'tcx>) -> Pat<'tcx> {\n         pattern.super_fold_with(self)\n     }\n \n-    fn fold_pattern_kind(&mut self, kind: &PatternKind<'tcx>) -> PatternKind<'tcx> {\n+    fn fold_pattern_kind(&mut self, kind: &PatKind<'tcx>) -> PatKind<'tcx> {\n         kind.super_fold_with(self)\n     }\n }\n@@ -1358,116 +1358,116 @@ CloneImpls!{ <'tcx>\n     Span, Field, Mutability, ast::Name, hir::HirId, usize, ty::Const<'tcx>,\n     Region<'tcx>, Ty<'tcx>, BindingMode, &'tcx AdtDef,\n     SubstsRef<'tcx>, &'tcx GenericArg<'tcx>, UserType<'tcx>,\n-    UserTypeProjection, PatternTypeProjection<'tcx>\n+    UserTypeProjection, PatTyProj<'tcx>\n }\n \n-impl<'tcx> PatternFoldable<'tcx> for FieldPattern<'tcx> {\n+impl<'tcx> PatternFoldable<'tcx> for FieldPat<'tcx> {\n     fn super_fold_with<F: PatternFolder<'tcx>>(&self, folder: &mut F) -> Self {\n-        FieldPattern {\n+        FieldPat {\n             field: self.field.fold_with(folder),\n             pattern: self.pattern.fold_with(folder)\n         }\n     }\n }\n \n-impl<'tcx> PatternFoldable<'tcx> for Pattern<'tcx> {\n+impl<'tcx> PatternFoldable<'tcx> for Pat<'tcx> {\n     fn fold_with<F: PatternFolder<'tcx>>(&self, folder: &mut F) -> Self {\n         folder.fold_pattern(self)\n     }\n \n     fn super_fold_with<F: PatternFolder<'tcx>>(&self, folder: &mut F) -> Self {\n-        Pattern {\n+        Pat {\n             ty: self.ty.fold_with(folder),\n             span: self.span.fold_with(folder),\n             kind: self.kind.fold_with(folder)\n         }\n     }\n }\n \n-impl<'tcx> PatternFoldable<'tcx> for PatternKind<'tcx> {\n+impl<'tcx> PatternFoldable<'tcx> for PatKind<'tcx> {\n     fn fold_with<F: PatternFolder<'tcx>>(&self, folder: &mut F) -> Self {\n         folder.fold_pattern_kind(self)\n     }\n \n     fn super_fold_with<F: PatternFolder<'tcx>>(&self, folder: &mut F) -> Self {\n         match *self {\n-            PatternKind::Wild => PatternKind::Wild,\n-            PatternKind::AscribeUserType {\n+            PatKind::Wild => PatKind::Wild,\n+            PatKind::AscribeUserType {\n                 ref subpattern,\n                 ascription: Ascription {\n                     variance,\n                     ref user_ty,\n                     user_ty_span,\n                 },\n-            } => PatternKind::AscribeUserType {\n+            } => PatKind::AscribeUserType {\n                 subpattern: subpattern.fold_with(folder),\n                 ascription: Ascription {\n                     user_ty: user_ty.fold_with(folder),\n                     variance,\n                     user_ty_span,\n                 },\n             },\n-            PatternKind::Binding {\n+            PatKind::Binding {\n                 mutability,\n                 name,\n                 mode,\n                 var,\n                 ty,\n                 ref subpattern,\n-            } => PatternKind::Binding {\n+            } => PatKind::Binding {\n                 mutability: mutability.fold_with(folder),\n                 name: name.fold_with(folder),\n                 mode: mode.fold_with(folder),\n                 var: var.fold_with(folder),\n                 ty: ty.fold_with(folder),\n                 subpattern: subpattern.fold_with(folder),\n             },\n-            PatternKind::Variant {\n+            PatKind::Variant {\n                 adt_def,\n                 substs,\n                 variant_index,\n                 ref subpatterns,\n-            } => PatternKind::Variant {\n+            } => PatKind::Variant {\n                 adt_def: adt_def.fold_with(folder),\n                 substs: substs.fold_with(folder),\n                 variant_index,\n                 subpatterns: subpatterns.fold_with(folder)\n             },\n-            PatternKind::Leaf {\n+            PatKind::Leaf {\n                 ref subpatterns,\n-            } => PatternKind::Leaf {\n+            } => PatKind::Leaf {\n                 subpatterns: subpatterns.fold_with(folder),\n             },\n-            PatternKind::Deref {\n+            PatKind::Deref {\n                 ref subpattern,\n-            } => PatternKind::Deref {\n+            } => PatKind::Deref {\n                 subpattern: subpattern.fold_with(folder),\n             },\n-            PatternKind::Constant {\n+            PatKind::Constant {\n                 value\n-            } => PatternKind::Constant {\n+            } => PatKind::Constant {\n                 value,\n             },\n-            PatternKind::Range(range) => PatternKind::Range(range),\n-            PatternKind::Slice {\n+            PatKind::Range(range) => PatKind::Range(range),\n+            PatKind::Slice {\n                 ref prefix,\n                 ref slice,\n                 ref suffix,\n-            } => PatternKind::Slice {\n+            } => PatKind::Slice {\n                 prefix: prefix.fold_with(folder),\n                 slice: slice.fold_with(folder),\n                 suffix: suffix.fold_with(folder)\n             },\n-            PatternKind::Array {\n+            PatKind::Array {\n                 ref prefix,\n                 ref slice,\n                 ref suffix\n-            } => PatternKind::Array {\n+            } => PatKind::Array {\n                 prefix: prefix.fold_with(folder),\n                 slice: slice.fold_with(folder),\n                 suffix: suffix.fold_with(folder)\n             },\n-            PatternKind::Or { ref pats } => PatternKind::Or { pats: pats.fold_with(folder) },\n+            PatKind::Or { ref pats } => PatKind::Or { pats: pats.fold_with(folder) },\n         }\n     }\n }"}, {"sha": "853fcb1beabf574b8e45976fe0758885bfa018ec", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -200,7 +200,7 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, 'tcx, M\n                         if let Some((&var_hir_id, _)) = upvars.get_index(field) {\n                             let node = self.ecx.tcx.hir().get(var_hir_id);\n                             if let hir::Node::Binding(pat) = node {\n-                                if let hir::PatKind::Binding(_, _, ident, _) = pat.node {\n+                                if let hir::PatKind::Binding(_, _, ident, _) = pat.kind {\n                                     name = Some(ident.name);\n                                 }\n                             }"}, {"sha": "cc8f4759e183791d20e2f3e52370c380495ba93d", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -981,7 +981,7 @@ struct RootCollector<'a, 'tcx> {\n \n impl ItemLikeVisitor<'v> for RootCollector<'_, 'v> {\n     fn visit_item(&mut self, item: &'v hir::Item) {\n-        match item.node {\n+        match item.kind {\n             hir::ItemKind::ExternCrate(..) |\n             hir::ItemKind::Use(..)         |\n             hir::ItemKind::ForeignMod(..)  |\n@@ -1058,7 +1058,7 @@ impl ItemLikeVisitor<'v> for RootCollector<'_, 'v> {\n     }\n \n     fn visit_impl_item(&mut self, ii: &'v hir::ImplItem) {\n-        match ii.node {\n+        match ii.kind {\n             hir::ImplItemKind::Method(hir::MethodSig { .. }, _) => {\n                 let def_id = self.tcx.hir().local_def_id(ii.hir_id);\n                 self.push_if_root(def_id);\n@@ -1141,7 +1141,7 @@ fn create_mono_items_for_default_impls<'tcx>(\n     item: &'tcx hir::Item,\n     output: &mut Vec<MonoItem<'tcx>>,\n ) {\n-    match item.node {\n+    match item.kind {\n         hir::ItemKind::Impl(_, _, _, ref generics, .., ref impl_item_refs) => {\n             for param in &generics.params {\n                 match param.kind {"}, {"sha": "acd53ac68ae3f27d4290f8f20f9ee72217808fce", "filename": "src/librustc_mir/transform/check_unsafety.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -577,7 +577,7 @@ fn is_enclosed(\n         if used_unsafe.contains(&parent_id) {\n             Some((\"block\".to_string(), parent_id))\n         } else if let Some(Node::Item(&hir::Item {\n-            node: hir::ItemKind::Fn(_, header, _, _),\n+            kind: hir::ItemKind::Fn(_, header, _, _),\n             ..\n         })) = tcx.hir().find(parent_id) {\n             match header.unsafety {"}, {"sha": "7423a668f94d242884983ad49025adf33049e1f0", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -1768,7 +1768,7 @@ fn args_required_const(tcx: TyCtxt<'_>, def_id: DefId) -> Option<FxHashSet<usize\n     let attr = attrs.iter().find(|a| a.check_name(sym::rustc_args_required_const))?;\n     let mut ret = FxHashSet::default();\n     for meta in attr.meta_item_list()? {\n-        match meta.literal()?.node {\n+        match meta.literal()?.kind {\n             LitKind::Int(a, _) => { ret.insert(a as usize); }\n             _ => return None,\n         }"}, {"sha": "0339b85ca55e31029b9335a3b86ab473b83caa44", "filename": "src/librustc_passes/ast_validation.rs", "status": "modified", "additions": 16, "deletions": 19, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -107,7 +107,7 @@ impl<'a> AstValidator<'a> {\n                 // rust-lang/rust#57979: bug in old `visit_generic_args` called\n                 // `walk_ty` rather than `visit_ty`, skipping outer `impl Trait`\n                 // if it happened to occur at `ty`.\n-                if let TyKind::ImplTrait(..) = ty.node {\n+                if let TyKind::ImplTrait(..) = ty.kind {\n                     self.warning_period_57979_didnt_record_next_impl_trait = true;\n                 }\n             }\n@@ -126,7 +126,7 @@ impl<'a> AstValidator<'a> {\n         // rust-lang/rust#57979: bug in old `visit_generic_args` called\n         // `walk_ty` rather than `visit_ty`, skippping outer `impl Trait`\n         // if it happened to occur at `ty`.\n-        if let TyKind::ImplTrait(..) = ty.node {\n+        if let TyKind::ImplTrait(..) = ty.kind {\n             self.warning_period_57979_didnt_record_next_impl_trait = true;\n         }\n         self.visit_ty(ty);\n@@ -149,7 +149,7 @@ impl<'a> AstValidator<'a> {\n \n     // Mirrors `visit::walk_ty`, but tracks relevant state.\n     fn walk_ty(&mut self, t: &'a Ty) {\n-        match t.node {\n+        match t.kind {\n             TyKind::ImplTrait(..) => {\n                 let outer_impl_trait = self.outer_impl_trait(t.span);\n                 self.with_impl_trait(Some(outer_impl_trait), |this| visit::walk_ty(this, t))\n@@ -231,7 +231,7 @@ impl<'a> AstValidator<'a> {\n \n     fn check_decl_no_pat<ReportFn: Fn(Span, bool)>(&self, decl: &FnDecl, report_err: ReportFn) {\n         for arg in &decl.inputs {\n-            match arg.pat.node {\n+            match arg.pat.kind {\n                 PatKind::Ident(BindingMode::ByValue(Mutability::Immutable), _, None) |\n                 PatKind::Wild => {}\n                 PatKind::Ident(BindingMode::ByValue(Mutability::Mutable), _, None) =>\n@@ -286,11 +286,11 @@ impl<'a> AstValidator<'a> {\n     // m!(S);\n     // ```\n     fn check_expr_within_pat(&self, expr: &Expr, allow_paths: bool) {\n-        match expr.node {\n+        match expr.kind {\n             ExprKind::Lit(..) | ExprKind::Err => {}\n             ExprKind::Path(..) if allow_paths => {}\n             ExprKind::Unary(UnOp::Neg, ref inner)\n-                if match inner.node { ExprKind::Lit(_) => true, _ => false } => {}\n+                if match inner.kind { ExprKind::Lit(_) => true, _ => false } => {}\n             _ => self.err_handler().span_err(expr.span, \"arbitrary expressions aren't allowed \\\n                                                          in patterns\")\n         }\n@@ -442,7 +442,7 @@ fn validate_generics_order<'a>(\n \n impl<'a> Visitor<'a> for AstValidator<'a> {\n     fn visit_expr(&mut self, expr: &'a Expr) {\n-        match &expr.node {\n+        match &expr.kind {\n             ExprKind::Closure(_, _, _, fn_decl, _, _) => {\n                 self.check_fn_decl(fn_decl);\n             }\n@@ -456,7 +456,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n     }\n \n     fn visit_ty(&mut self, ty: &'a Ty) {\n-        match ty.node {\n+        match ty.kind {\n             TyKind::BareFn(ref bfty) => {\n                 self.check_fn_decl(&bfty.decl);\n                 self.check_decl_no_pat(&bfty.decl, |span, _| {\n@@ -538,10 +538,10 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n             self.has_proc_macro_decls = true;\n         }\n \n-        match item.node {\n+        match item.kind {\n             ItemKind::Impl(unsafety, polarity, _, _, Some(..), ref ty, ref impl_items) => {\n                 self.invalid_visibility(&item.vis, None);\n-                if let TyKind::Err = ty.node {\n+                if let TyKind::Err = ty.kind {\n                     self.err_handler()\n                         .struct_span_err(item.span, \"`impl Trait for .. {}` is an obsolete syntax\")\n                         .help(\"use `auto trait Trait {}` instead\").emit();\n@@ -551,7 +551,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                 }\n                 for impl_item in impl_items {\n                     self.invalid_visibility(&impl_item.vis, None);\n-                    if let ImplItemKind::Method(ref sig, _) = impl_item.node {\n+                    if let ImplItemKind::Method(ref sig, _) = impl_item.kind {\n                         self.check_trait_fn_not_const(sig.header.constness);\n                         self.check_trait_fn_not_async(impl_item.span, sig.header.asyncness.node);\n                     }\n@@ -628,7 +628,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                 }\n                 self.no_questions_in_bounds(bounds, \"supertraits\", true);\n                 for trait_item in trait_items {\n-                    if let TraitItemKind::Method(ref sig, ref block) = trait_item.node {\n+                    if let TraitItemKind::Method(ref sig, ref block) = trait_item.kind {\n                         self.check_fn_decl(&sig.decl);\n                         self.check_trait_fn_not_async(trait_item.span, sig.header.asyncness.node);\n                         self.check_trait_fn_not_const(sig.header.constness);\n@@ -682,7 +682,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n     }\n \n     fn visit_foreign_item(&mut self, fi: &'a ForeignItem) {\n-        match fi.node {\n+        match fi.kind {\n             ForeignItemKind::Fn(ref decl, _) => {\n                 self.check_fn_decl(decl);\n                 self.check_decl_no_pat(decl, |span, _| {\n@@ -786,7 +786,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n     }\n \n     fn visit_pat(&mut self, pat: &'a Pat) {\n-        match pat.node {\n+        match pat.kind {\n             PatKind::Lit(ref expr) => {\n                 self.check_expr_within_pat(expr, false);\n             }\n@@ -832,11 +832,8 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n     }\n \n     fn visit_impl_item(&mut self, ii: &'a ImplItem) {\n-        match ii.node {\n-            ImplItemKind::Method(ref sig, _) => {\n-                self.check_fn_decl(&sig.decl);\n-            }\n-            _ => {}\n+        if let ImplItemKind::Method(ref sig, _) = ii.kind {\n+            self.check_fn_decl(&sig.decl);\n         }\n         visit::walk_impl_item(self, ii);\n     }"}, {"sha": "06683c16e4a9bee0b0e73455bc58440f55ab0f51", "filename": "src/librustc_passes/layout_test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_passes%2Flayout_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_passes%2Flayout_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Flayout_test.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -31,7 +31,7 @@ impl ItemLikeVisitor<'tcx> for VarianceTest<'tcx> {\n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n         let item_def_id = self.tcx.hir().local_def_id(item.hir_id);\n \n-        if let ItemKind::TyAlias(..) = item.node {\n+        if let ItemKind::TyAlias(..) = item.kind {\n             for attr in self.tcx.get_attrs(item_def_id).iter() {\n                 if attr.check_name(sym::rustc_layout) {\n                     self.dump_layout_of(item_def_id, item, attr);"}, {"sha": "6c9e018fafc4ff85ba2af0a654a84dcc4bad2279", "filename": "src/librustc_passes/loops.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_passes%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_passes%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Floops.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -54,7 +54,7 @@ impl<'a, 'hir> Visitor<'hir> for CheckLoopVisitor<'a, 'hir> {\n     }\n \n     fn visit_expr(&mut self, e: &'hir hir::Expr) {\n-        match e.node {\n+        match e.kind {\n             hir::ExprKind::Loop(ref b, _, source) => {\n                 self.with_context(Loop(source), |v| v.visit_block(&b));\n             }\n@@ -99,7 +99,7 @@ impl<'a, 'hir> Visitor<'hir> for CheckLoopVisitor<'a, 'hir> {\n                     let loop_kind = if loop_id == hir::DUMMY_HIR_ID {\n                         None\n                     } else {\n-                        Some(match self.hir_map.expect_expr(loop_id).node {\n+                        Some(match self.hir_map.expect_expr(loop_id).kind {\n                             hir::ExprKind::Loop(_, _, source) => source,\n                             ref r => span_bug!(e.span,\n                                                \"break label resolved to a non-loop: {:?}\", r),"}, {"sha": "a93ca7847d68a9597366d1b657621429f557ce16", "filename": "src/librustc_passes/rvalue_promotion.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_passes%2Frvalue_promotion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_passes%2Frvalue_promotion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Frvalue_promotion.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -212,7 +212,7 @@ impl<'a, 'tcx> CheckCrateVisitor<'a, 'tcx> {\n     }\n \n     fn check_stmt(&mut self, stmt: &'tcx hir::Stmt) -> Promotability {\n-        match stmt.node {\n+        match stmt.kind {\n             hir::StmtKind::Local(ref local) => {\n                 if self.remove_mut_rvalue_borrow(&local.pat) {\n                     if let Some(init) = &local.init {\n@@ -280,7 +280,7 @@ fn check_expr_kind<'a, 'tcx>(\n         _ => Promotable\n     };\n \n-    let node_result = match e.node {\n+    let kind_result = match e.kind {\n         hir::ExprKind::Box(ref expr) => {\n             let _ = v.check_expr(&expr);\n             NotPromotable\n@@ -376,7 +376,7 @@ fn check_expr_kind<'a, 'tcx>(\n             }\n             let mut callee = &**callee;\n             loop {\n-                callee = match callee.node {\n+                callee = match callee.kind {\n                     hir::ExprKind::Block(ref block, _) => match block.expr {\n                         Some(ref tail) => &tail,\n                         None => break\n@@ -385,7 +385,7 @@ fn check_expr_kind<'a, 'tcx>(\n                 };\n             }\n             // The callee is an arbitrary expression, it doesn't necessarily have a definition.\n-            let def = if let hir::ExprKind::Path(ref qpath) = callee.node {\n+            let def = if let hir::ExprKind::Path(ref qpath) = callee.kind {\n                 v.tables.qpath_res(qpath, callee.hir_id)\n             } else {\n                 Res::Err\n@@ -553,7 +553,7 @@ fn check_expr_kind<'a, 'tcx>(\n             NotPromotable\n         }\n     };\n-    ty_result & node_result\n+    ty_result & kind_result\n }\n \n /// Checks the adjustments of an expression."}, {"sha": "01559a95c9c31d83a7bdf826da85a9be157aed01", "filename": "src/librustc_plugin/build.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_plugin%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_plugin%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin%2Fbuild.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -15,7 +15,7 @@ struct RegistrarFinder {\n \n impl<'v> ItemLikeVisitor<'v> for RegistrarFinder {\n     fn visit_item(&mut self, item: &hir::Item) {\n-        if let hir::ItemKind::Fn(..) = item.node {\n+        if let hir::ItemKind::Fn(..) = item.kind {\n             if attr::contains_name(&item.attrs, sym::plugin_registrar) {\n                 self.registrars.push((item.hir_id, item.span));\n             }"}, {"sha": "f44692b7aea7d6193dff4f35d160d017c00d5e7a", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -240,7 +240,7 @@ fn def_id_visibility<'tcx>(\n                 }\n                 Node::ImplItem(impl_item) => {\n                     match tcx.hir().get(tcx.hir().get_parent_item(hir_id)) {\n-                        Node::Item(item) => match &item.node {\n+                        Node::Item(item) => match &item.kind {\n                             hir::ItemKind::Impl(.., None, _, _) => &impl_item.vis,\n                             hir::ItemKind::Impl(.., Some(trait_ref), _, _)\n                                 => return def_id_visibility(tcx, trait_ref.path.res.def_id()),\n@@ -572,7 +572,7 @@ impl EmbargoVisitor<'tcx> {\n                 if let ty::Visibility::Public = vis {\n                     let item = self.tcx.hir().expect_item(hir_id);\n                     if let hir::ItemKind::Struct(ref struct_def, _)\n-                        | hir::ItemKind::Union(ref struct_def, _) = item.node\n+                        | hir::ItemKind::Union(ref struct_def, _) = item.kind\n                     {\n                         for field in struct_def.fields() {\n                             let field_vis = ty::Visibility::from_hir(\n@@ -630,12 +630,12 @@ impl EmbargoVisitor<'tcx> {\n                 .and_then(|def_id| self.tcx.hir().as_local_hir_id(def_id))\n                 .map(|module_hir_id| self.tcx.hir().expect_item(module_hir_id))\n              {\n-                if let hir::ItemKind::Mod(m) = &item.node {\n+                if let hir::ItemKind::Mod(m) = &item.kind {\n                     for item_id in m.item_ids.as_ref() {\n                         let item = self.tcx.hir().expect_item(item_id.id);\n                         let def_id = self.tcx.hir().local_def_id(item_id.id);\n                         if !self.tcx.hygienic_eq(segment.ident, item.ident, def_id) { continue; }\n-                        if let hir::ItemKind::Use(..) = item.node {\n+                        if let hir::ItemKind::Use(..) = item.kind {\n                             self.update(item.hir_id, Some(AccessLevel::Exported));\n                         }\n                     }\n@@ -653,7 +653,7 @@ impl Visitor<'tcx> for EmbargoVisitor<'tcx> {\n     }\n \n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n-        let inherited_item_level = match item.node {\n+        let inherited_item_level = match item.kind {\n             hir::ItemKind::Impl(..) =>\n                 Option::<AccessLevel>::of_impl(item.hir_id, self.tcx, &self.access_levels),\n             // Foreign modules inherit level from parents.\n@@ -673,7 +673,7 @@ impl Visitor<'tcx> for EmbargoVisitor<'tcx> {\n         let item_level = self.update(item.hir_id, inherited_item_level);\n \n         // Update levels of nested things.\n-        match item.node {\n+        match item.kind {\n             hir::ItemKind::Enum(ref def, _) => {\n                 for variant in &def.variants {\n                     let variant_level = self.update(variant.id, item_level);\n@@ -727,7 +727,7 @@ impl Visitor<'tcx> for EmbargoVisitor<'tcx> {\n         }\n \n         // Mark all items in interfaces of reachable items as reachable.\n-        match item.node {\n+        match item.kind {\n             // The interface is empty.\n             hir::ItemKind::ExternCrate(..) => {}\n             // All nested items are checked by `visit_item`.\n@@ -1028,7 +1028,7 @@ impl<'a, 'tcx> Visitor<'tcx> for NamePrivacyVisitor<'a, 'tcx> {\n     }\n \n     fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n-        match expr.node {\n+        match expr.kind {\n             hir::ExprKind::Struct(ref qpath, ref fields, ref base) => {\n                 let res = self.tables.qpath_res(qpath, expr.hir_id);\n                 let adt = self.tables.expr_ty(expr).ty_adt_def().unwrap();\n@@ -1062,7 +1062,7 @@ impl<'a, 'tcx> Visitor<'tcx> for NamePrivacyVisitor<'a, 'tcx> {\n     }\n \n     fn visit_pat(&mut self, pat: &'tcx hir::Pat) {\n-        match pat.node {\n+        match pat.kind {\n             PatKind::Struct(ref qpath, ref fields, _) => {\n                 let res = self.tables.qpath_res(qpath, pat.hir_id);\n                 let adt = self.tables.pat_ty(pat).ty_adt_def().unwrap();\n@@ -1197,7 +1197,7 @@ impl<'a, 'tcx> Visitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n             // Do not check nested expressions if the error already happened.\n             return;\n         }\n-        match expr.node {\n+        match expr.kind {\n             hir::ExprKind::Assign(.., ref rhs) | hir::ExprKind::Match(ref rhs, ..) => {\n                 // Do not report duplicate errors for `x = y` and `match x { ... }`.\n                 if self.check_expr_pat_type(rhs.hir_id, rhs.span) {\n@@ -1389,14 +1389,14 @@ impl<'a, 'b, 'tcx, 'v> Visitor<'v> for ObsoleteCheckTypeForPrivatenessVisitor<'a\n     }\n \n     fn visit_ty(&mut self, ty: &hir::Ty) {\n-        if let hir::TyKind::Path(hir::QPath::Resolved(_, ref path)) = ty.node {\n+        if let hir::TyKind::Path(hir::QPath::Resolved(_, ref path)) = ty.kind {\n             if self.inner.path_is_private_type(path) {\n                 self.contains_private = true;\n                 // Found what we're looking for, so let's stop working.\n                 return\n             }\n         }\n-        if let hir::TyKind::Path(_) = ty.node {\n+        if let hir::TyKind::Path(_) = ty.kind {\n             if self.at_outer_type {\n                 self.outer_type_is_public_path = true;\n             }\n@@ -1417,7 +1417,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n     }\n \n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n-        match item.node {\n+        match item.kind {\n             // Contents of a private mod can be re-exported, so we need\n             // to check internals.\n             hir::ItemKind::Mod(_) => {}\n@@ -1489,7 +1489,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n                     impl_item_refs.iter()\n                                  .any(|impl_item_ref| {\n                                      let impl_item = self.tcx.hir().impl_item(impl_item_ref.id);\n-                                     match impl_item.node {\n+                                     match impl_item.kind {\n                                          hir::ImplItemKind::Const(..) |\n                                          hir::ImplItemKind::Method(..) => {\n                                              self.access_levels.is_reachable(\n@@ -1515,7 +1515,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n                                 // don't erroneously report errors for private\n                                 // types in private items.\n                                 let impl_item = self.tcx.hir().impl_item(impl_item_ref.id);\n-                                match impl_item.node {\n+                                match impl_item.kind {\n                                     hir::ImplItemKind::Const(..) |\n                                     hir::ImplItemKind::Method(..)\n                                         if self.item_is_public(&impl_item.hir_id, &impl_item.vis) =>\n@@ -1548,7 +1548,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n                             // Those in 3. are warned with this call.\n                             for impl_item_ref in impl_item_refs {\n                                 let impl_item = self.tcx.hir().impl_item(impl_item_ref.id);\n-                                if let hir::ImplItemKind::TyAlias(ref ty) = impl_item.node {\n+                                if let hir::ImplItemKind::TyAlias(ref ty) = impl_item.kind {\n                                     self.visit_ty(ty);\n                                 }\n                             }\n@@ -1628,7 +1628,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n     }\n \n     fn visit_ty(&mut self, t: &'tcx hir::Ty) {\n-        if let hir::TyKind::Path(hir::QPath::Resolved(_, ref path)) = t.node {\n+        if let hir::TyKind::Path(hir::QPath::Resolved(_, ref path)) = t.kind {\n             if self.path_is_private_type(path) {\n                 self.old_error_set.insert(t.hir_id);\n             }\n@@ -1853,7 +1853,7 @@ impl<'a, 'tcx> Visitor<'tcx> for PrivateItemsInPublicInterfacesVisitor<'a, 'tcx>\n         let tcx = self.tcx;\n         let item_visibility = ty::Visibility::from_hir(&item.vis, item.hir_id, tcx);\n \n-        match item.node {\n+        match item.kind {\n             // Crates are always public.\n             hir::ItemKind::ExternCrate(..) => {}\n             // All nested items are checked by `visit_item`."}, {"sha": "f76aa95dd2cc8e40642dfc89669714dfe40a819d", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -309,7 +309,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n \n     fn block_needs_anonymous_module(&mut self, block: &Block) -> bool {\n         // If any statements are items, we need to create an anonymous module\n-        block.stmts.iter().any(|statement| match statement.node {\n+        block.stmts.iter().any(|statement| match statement.kind {\n             StmtKind::Item(_) | StmtKind::Mac(_) => true,\n             _ => false,\n         })\n@@ -588,7 +588,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n         let sp = item.span;\n         let vis = self.resolve_visibility(&item.vis);\n \n-        match item.node {\n+        match item.kind {\n             ItemKind::Use(ref use_tree) => {\n                 self.build_reduced_graph_for_use_tree(\n                     // This particular use tree\n@@ -813,7 +813,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n \n     /// Constructs the reduced graph for one foreign item.\n     fn build_reduced_graph_for_foreign_item(&mut self, item: &ForeignItem) {\n-        let (res, ns) = match item.node {\n+        let (res, ns) = match item.kind {\n             ForeignItemKind::Fn(..) => {\n                 (Res::Def(DefKind::Fn, self.r.definitions.local_def_id(item.id)), ValueNS)\n             }\n@@ -936,15 +936,15 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                     span_err!(self.r.session, item.span, E0468,\n                         \"an `extern crate` loading macros must be at the crate root\");\n                 }\n-                if let ItemKind::ExternCrate(Some(orig_name)) = item.node {\n+                if let ItemKind::ExternCrate(Some(orig_name)) = item.kind {\n                     if orig_name == kw::SelfLower {\n                         self.r.session.span_err(attr.span,\n                             \"`macro_use` is not supported on `extern crate self`\");\n                     }\n                 }\n                 let ill_formed = |span| span_err!(self.r.session, span, E0466, \"bad macro import\");\n                 match attr.meta() {\n-                    Some(meta) => match meta.node {\n+                    Some(meta) => match meta.kind {\n                         MetaItemKind::Word => {\n                             import_all = Some(meta.span);\n                             break;\n@@ -1064,7 +1064,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n     fn define_macro(&mut self, item: &ast::Item) -> LegacyScope<'a> {\n         let parent_scope = &self.parent_scope;\n         let expansion = parent_scope.expansion;\n-        let (ext, ident, span, is_legacy) = match &item.node {\n+        let (ext, ident, span, is_legacy) = match &item.kind {\n             ItemKind::MacroDef(def) => {\n                 let ext = Lrc::new(self.r.compile_macro(item, self.r.session.edition()));\n                 (ext, item.ident, item.span, def.legacy)\n@@ -1122,7 +1122,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n macro_rules! method {\n     ($visit:ident: $ty:ty, $invoc:path, $walk:ident) => {\n         fn $visit(&mut self, node: &'b $ty) {\n-            if let $invoc(..) = node.node {\n+            if let $invoc(..) = node.kind {\n                 self.visit_invoc(node.id);\n             } else {\n                 visit::$walk(self, node);\n@@ -1138,7 +1138,7 @@ impl<'a, 'b> Visitor<'b> for BuildReducedGraphVisitor<'a, 'b> {\n     method!(visit_ty:        ast::Ty,       ast::TyKind::Mac,         walk_ty);\n \n     fn visit_item(&mut self, item: &'b Item) {\n-        let macro_use = match item.node {\n+        let macro_use = match item.kind {\n             ItemKind::MacroDef(..) => {\n                 self.parent_scope.legacy = self.define_macro(item);\n                 return\n@@ -1161,15 +1161,15 @@ impl<'a, 'b> Visitor<'b> for BuildReducedGraphVisitor<'a, 'b> {\n     }\n \n     fn visit_stmt(&mut self, stmt: &'b ast::Stmt) {\n-        if let ast::StmtKind::Mac(..) = stmt.node {\n+        if let ast::StmtKind::Mac(..) = stmt.kind {\n             self.parent_scope.legacy = self.visit_invoc(stmt.id);\n         } else {\n             visit::walk_stmt(self, stmt);\n         }\n     }\n \n     fn visit_foreign_item(&mut self, foreign_item: &'b ForeignItem) {\n-        if let ForeignItemKind::Macro(_) = foreign_item.node {\n+        if let ForeignItemKind::Macro(_) = foreign_item.kind {\n             self.visit_invoc(foreign_item.id);\n             return;\n         }\n@@ -1190,14 +1190,14 @@ impl<'a, 'b> Visitor<'b> for BuildReducedGraphVisitor<'a, 'b> {\n     fn visit_trait_item(&mut self, item: &'b TraitItem) {\n         let parent = self.parent_scope.module;\n \n-        if let TraitItemKind::Macro(_) = item.node {\n+        if let TraitItemKind::Macro(_) = item.kind {\n             self.visit_invoc(item.id);\n             return\n         }\n \n         // Add the item to the trait info.\n         let item_def_id = self.r.definitions.local_def_id(item.id);\n-        let (res, ns) = match item.node {\n+        let (res, ns) = match item.kind {\n             TraitItemKind::Const(..) => (Res::Def(DefKind::AssocConst, item_def_id), ValueNS),\n             TraitItemKind::Method(ref sig, _) => {\n                 if sig.decl.has_self() {\n@@ -1219,7 +1219,7 @@ impl<'a, 'b> Visitor<'b> for BuildReducedGraphVisitor<'a, 'b> {\n     fn visit_token(&mut self, t: Token) {\n         if let token::Interpolated(nt) = t.kind {\n             if let token::NtExpr(ref expr) = *nt {\n-                if let ast::ExprKind::Mac(..) = expr.node {\n+                if let ast::ExprKind::Mac(..) = expr.kind {\n                     self.visit_invoc(expr.id);\n                 }\n             }"}, {"sha": "737589acf8d8146fece502646e89af09d8b2230e", "filename": "src/librustc_resolve/check_unused.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_resolve%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_resolve%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fcheck_unused.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -103,7 +103,7 @@ impl<'a, 'b> Visitor<'a> for UnusedImportCheckVisitor<'a, 'b> {\n         // whether they're used or not. Also ignore imports with a dummy span\n         // because this means that they were generated in some fashion by the\n         // compiler and we don't need to consider them.\n-        if let ast::ItemKind::Use(..) = item.node {\n+        if let ast::ItemKind::Use(..) = item.kind {\n             if item.vis.node.is_pub() || item.span.is_dummy() {\n                 return;\n             }"}, {"sha": "33a85c6c77026bd786cee1b857ca2620052e9d2b", "filename": "src/librustc_resolve/late.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_resolve%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_resolve%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -221,7 +221,7 @@ impl<'a> PathSource<'a> {\n                 ValueNS => \"method or associated constant\",\n                 MacroNS => bug!(\"associated macro\"),\n             },\n-            PathSource::Expr(parent) => match parent.map(|p| &p.node) {\n+            PathSource::Expr(parent) => match parent.map(|p| &p.kind) {\n                 // \"function\" here means \"anything callable\" rather than `DefKind::Fn`,\n                 // this is not precise but usually more helpful than just \"value\".\n                 Some(&ExprKind::Call(..)) => \"function\",\n@@ -384,7 +384,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LateResolutionVisitor<'a, '_> {\n         self.resolve_local(local);\n     }\n     fn visit_ty(&mut self, ty: &'tcx Ty) {\n-        match ty.node {\n+        match ty.kind {\n             TyKind::Path(ref qself, ref path) => {\n                 self.smart_resolve_path(ty.id, qself.as_ref(), path, PathSource::Type);\n             }\n@@ -406,7 +406,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LateResolutionVisitor<'a, '_> {\n         visit::walk_poly_trait_ref(self, tref, m);\n     }\n     fn visit_foreign_item(&mut self, foreign_item: &'tcx ForeignItem) {\n-        let generic_params = match foreign_item.node {\n+        let generic_params = match foreign_item.kind {\n             ForeignItemKind::Fn(_, ref generics) => {\n                 HasGenericParams(generics, ItemRibKind)\n             }\n@@ -700,9 +700,9 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n \n     fn resolve_item(&mut self, item: &Item) {\n         let name = item.ident.name;\n-        debug!(\"(resolving item) resolving {} ({:?})\", name, item.node);\n+        debug!(\"(resolving item) resolving {} ({:?})\", name, item.kind);\n \n-        match item.node {\n+        match item.kind {\n             ItemKind::TyAlias(_, ref generics) |\n             ItemKind::OpaqueTy(_, ref generics) |\n             ItemKind::Fn(_, _, ref generics, _) => {\n@@ -740,7 +740,7 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n                                     AssocItemRibKind,\n                                 );\n                                 this.with_generic_param_rib(generic_params, |this| {\n-                                    match trait_item.node {\n+                                    match trait_item.kind {\n                                         TraitItemKind::Const(ref ty, ref default) => {\n                                             this.visit_ty(ty);\n \n@@ -938,7 +938,7 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n     ) -> T {\n         let trait_assoc_types = replace(\n             &mut self.current_trait_assoc_types,\n-            trait_items.iter().filter_map(|item| match &item.node {\n+            trait_items.iter().filter_map(|item| match &item.kind {\n                 TraitItemKind::Type(bounds, _) if bounds.len() == 0 => Some(item.ident),\n                 _ => None,\n             }).collect(),\n@@ -1035,7 +1035,7 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n                                                                           AssocItemRibKind);\n                                     this.with_generic_param_rib(generic_params, |this| {\n                                         use crate::ResolutionError::*;\n-                                        match impl_item.node {\n+                                        match impl_item.kind {\n                                             ImplItemKind::Const(..) => {\n                                                 debug!(\n                                                     \"resolve_implementation ImplItemKind::Const\",\n@@ -1146,7 +1146,7 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n         let mut binding_map = FxHashMap::default();\n \n         pat.walk(&mut |pat| {\n-            match pat.node {\n+            match pat.kind {\n                 PatKind::Ident(binding_mode, ident, ref sub_pat)\n                     if sub_pat.is_some() || self.is_base_res_local(pat.id) =>\n                 {\n@@ -1246,7 +1246,7 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n \n     /// Check the consistency of the outermost or-patterns.\n     fn check_consistent_bindings_top(&mut self, pat: &Pat) {\n-        pat.walk(&mut |pat| match pat.node {\n+        pat.walk(&mut |pat| match pat.kind {\n             PatKind::Or(ref ps) => {\n                 self.check_consistent_bindings(ps);\n                 false\n@@ -1308,8 +1308,8 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n     ) {\n         // Visit all direct subpatterns of this pattern.\n         pat.walk(&mut |pat| {\n-            debug!(\"resolve_pattern pat={:?} node={:?}\", pat, pat.node);\n-            match pat.node {\n+            debug!(\"resolve_pattern pat={:?} node={:?}\", pat, pat.kind);\n+            match pat.kind {\n                 PatKind::Ident(bmode, ident, ref sub) => {\n                     // First try to resolve the identifier as some existing entity,\n                     // then fall back to a fresh binding.\n@@ -1804,8 +1804,8 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n \n         // Descend into the block.\n         for stmt in &block.stmts {\n-            if let StmtKind::Item(ref item) = stmt.node {\n-                if let ItemKind::MacroDef(..) = item.node {\n+            if let StmtKind::Item(ref item) = stmt.kind {\n+                if let ItemKind::MacroDef(..) = item.kind {\n                     num_macro_definition_ribs += 1;\n                     let res = self.r.definitions.local_def_id(item.id);\n                     self.ribs[ValueNS].push(Rib::new(MacroDefinition(res)));\n@@ -1836,7 +1836,7 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n         self.record_candidate_traits_for_expr_if_necessary(expr);\n \n         // Next, resolve the node.\n-        match expr.node {\n+        match expr.kind {\n             ExprKind::Path(ref qself, ref path) => {\n                 self.smart_resolve_path(expr.id, qself.as_ref(), path, PathSource::Expr(parent));\n                 visit::walk_expr(self, expr);\n@@ -1968,7 +1968,7 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n     }\n \n     fn record_candidate_traits_for_expr_if_necessary(&mut self, expr: &Expr) {\n-        match expr.node {\n+        match expr.kind {\n             ExprKind::Field(_, ident) => {\n                 // FIXME(#6890): Even though you can't treat a method like a\n                 // field, we need to add any trait methods we find that match"}, {"sha": "0d35cc53ac6f38037ad162ccf5c7389f7c43c013", "filename": "src/librustc_resolve/late/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_resolve%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_resolve%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate%2Fdiagnostics.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -325,7 +325,7 @@ impl<'a> LateResolutionVisitor<'a, '_> {\n         let ns = source.namespace();\n         let is_expected = &|res| source.is_expected(res);\n \n-        let path_sep = |err: &mut DiagnosticBuilder<'_>, expr: &Expr| match expr.node {\n+        let path_sep = |err: &mut DiagnosticBuilder<'_>, expr: &Expr| match expr.kind {\n             ExprKind::Field(_, ident) => {\n                 err.span_suggestion(\n                     expr.span,\n@@ -472,7 +472,7 @@ impl<'a> LateResolutionVisitor<'a, '_> {\n         where FilterFn: Fn(Res) -> bool\n     {\n         fn extract_node_id(t: &Ty) -> Option<NodeId> {\n-            match t.node {\n+            match t.kind {\n                 TyKind::Path(None, _) => Some(t.id),\n                 TyKind::Rptr(_, ref mut_ty) => extract_node_id(&mut_ty.ty),\n                 // This doesn't handle the remaining `Ty` variants as they are not"}, {"sha": "bf86a374338402e29dce5cc72ab08bcf60d488d2", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -290,7 +290,7 @@ impl<'tcx> Visitor<'tcx> for UsePlacementFinder {\n         }\n         // find a use statement\n         for item in &module.items {\n-            match item.node {\n+            match item.kind {\n                 ItemKind::Use(..) => {\n                     // don't suggest placing a use before the prelude\n                     // import or other generated ones"}, {"sha": "edd2db3c8f738bb2546d704d3010e1d17585e231", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -385,7 +385,7 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n             }\n \n             if let ast::FunctionRetTy::Ty(ref ret_ty) = decl.output {\n-                if let ast::TyKind::ImplTrait(..) = ret_ty.node {\n+                if let ast::TyKind::ImplTrait(..) = ret_ty.kind {\n                     // FIXME: Opaque type desugaring prevents us from easily\n                     // processing trait bounds. See `visit_ty` for more details.\n                 } else {\n@@ -472,13 +472,13 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n         let qualname = format!(\"::{}\",\n             self.tcx.def_path_str(self.tcx.hir().local_def_id_from_node_id(item.id)));\n \n-        let kind = match item.node {\n+        let kind = match item.kind {\n             ast::ItemKind::Struct(_, _) => DefKind::Struct,\n             ast::ItemKind::Union(_, _) => DefKind::Union,\n             _ => unreachable!(),\n         };\n \n-        let (value, fields) = match item.node {\n+        let (value, fields) = match item.kind {\n             ast::ItemKind::Struct(ast::VariantData::Struct(ref fields, ..), ..) |\n             ast::ItemKind::Union(ast::VariantData::Struct(ref fields, ..), ..) => {\n                 let include_priv_fields = !self.save_ctxt.config.pub_only;\n@@ -864,7 +864,7 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n     }\n \n     fn process_pat(&mut self, p: &'l ast::Pat) {\n-        match p.node {\n+        match p.kind {\n             PatKind::Struct(ref _path, ref fields, _) => {\n                 // FIXME do something with _path?\n                 let hir_id = self.tcx.hir().node_to_hir_id(p.id);\n@@ -1007,7 +1007,7 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n     fn process_trait_item(&mut self, trait_item: &'l ast::TraitItem, trait_id: DefId) {\n         self.process_macro_use(trait_item.span);\n         let vis_span = trait_item.span.shrink_to_lo();\n-        match trait_item.node {\n+        match trait_item.kind {\n             ast::TraitItemKind::Const(ref ty, ref expr) => {\n                 self.process_assoc_const(\n                     trait_item.id,\n@@ -1078,7 +1078,7 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n \n     fn process_impl_item(&mut self, impl_item: &'l ast::ImplItem, impl_id: DefId) {\n         self.process_macro_use(impl_item.span);\n-        match impl_item.node {\n+        match impl_item.kind {\n             ast::ImplItemKind::Const(ref ty, ref expr) => {\n                 self.process_assoc_const(\n                     impl_item.id,\n@@ -1276,7 +1276,7 @@ impl<'l, 'tcx> Visitor<'l> for DumpVisitor<'l, 'tcx> {\n     fn visit_item(&mut self, item: &'l ast::Item) {\n         use syntax::ast::ItemKind::*;\n         self.process_macro_use(item.span);\n-        match item.node {\n+        match item.kind {\n             Use(ref use_tree) => {\n                 let prefix = ast::Path {\n                     segments: vec![],\n@@ -1421,7 +1421,7 @@ impl<'l, 'tcx> Visitor<'l> for DumpVisitor<'l, 'tcx> {\n \n     fn visit_ty(&mut self, t: &'l ast::Ty) {\n         self.process_macro_use(t.span);\n-        match t.node {\n+        match t.kind {\n             ast::TyKind::Path(_, ref path) => {\n                 if generated_code(t.span) {\n                     return;\n@@ -1461,9 +1461,9 @@ impl<'l, 'tcx> Visitor<'l> for DumpVisitor<'l, 'tcx> {\n     }\n \n     fn visit_expr(&mut self, ex: &'l ast::Expr) {\n-        debug!(\"visit_expr {:?}\", ex.node);\n+        debug!(\"visit_expr {:?}\", ex.kind);\n         self.process_macro_use(ex.span);\n-        match ex.node {\n+        match ex.kind {\n             ast::ExprKind::Struct(ref path, ref fields, ref base) => {\n                 let expr_hir_id = self.save_ctxt.tcx.hir().node_to_hir_id(ex.id);\n                 let hir_expr = self.save_ctxt.tcx.hir().expect_expr(expr_hir_id);\n@@ -1509,7 +1509,7 @@ impl<'l, 'tcx> Visitor<'l> for DumpVisitor<'l, 'tcx> {\n             }\n             ast::ExprKind::ForLoop(ref pattern, ref subexpression, ref block, _) => {\n                 self.process_var_decl(pattern);\n-                debug!(\"for loop, walk sub-expr: {:?}\", subexpression.node);\n+                debug!(\"for loop, walk sub-expr: {:?}\", subexpression.kind);\n                 self.visit_expr(subexpression);\n                 visit::walk_block(self, block);\n             }\n@@ -1570,7 +1570,7 @@ impl<'l, 'tcx> Visitor<'l> for DumpVisitor<'l, 'tcx> {\n         let hir_id = self.tcx.hir().node_to_hir_id(item.id);\n         let access = access_from!(self.save_ctxt, item, hir_id);\n \n-        match item.node {\n+        match item.kind {\n             ast::ForeignItemKind::Fn(ref decl, ref generics) => {\n                 if let Some(fn_data) = self.save_ctxt.get_extern_item_data(item) {\n                     down_cast_data!(fn_data, DefData, item.span);"}, {"sha": "e3c898610cde0c8be1575cef14ab6c76d2c09441", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -130,7 +130,7 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n     pub fn get_extern_item_data(&self, item: &ast::ForeignItem) -> Option<Data> {\n         let qualname = format!(\"::{}\",\n             self.tcx.def_path_str(self.tcx.hir().local_def_id_from_node_id(item.id)));\n-        match item.node {\n+        match item.kind {\n             ast::ForeignItemKind::Fn(ref decl, ref generics) => {\n                 filter!(self.span_utils, item.ident.span);\n \n@@ -177,7 +177,7 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n     }\n \n     pub fn get_item_data(&self, item: &ast::Item) -> Option<Data> {\n-        match item.node {\n+        match item.kind {\n             ast::ItemKind::Fn(ref decl, .., ref generics, _) => {\n                 let qualname = format!(\"::{}\",\n                     self.tcx.def_path_str(self.tcx.hir().local_def_id_from_node_id(item.id)));\n@@ -301,7 +301,7 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n                 }))\n             }\n             ast::ItemKind::Impl(.., ref trait_ref, ref typ, ref impls) => {\n-                if let ast::TyKind::Path(None, ref path) = typ.node {\n+                if let ast::TyKind::Path(None, ref path) = typ.kind {\n                     // Common case impl for a struct or something basic.\n                     if generated_code(path.span) {\n                         return None;\n@@ -396,7 +396,7 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n         let (qualname, parent_scope, decl_id, docs, attributes) =\n             match self.tcx.impl_of_method(self.tcx.hir().local_def_id_from_node_id(id)) {\n                 Some(impl_id) => match self.tcx.hir().get_if_local(impl_id) {\n-                    Some(Node::Item(item)) => match item.node {\n+                    Some(Node::Item(item)) => match item.kind {\n                         hir::ItemKind::Impl(.., ref ty, _) => {\n                             let mut qualname = String::from(\"<\");\n                             qualname.push_str(&self.tcx.hir().hir_to_pretty_string(ty.hir_id));\n@@ -518,7 +518,7 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n         if ty.is_none() || ty.unwrap().kind == ty::Error {\n             return None;\n         }\n-        match expr.node {\n+        match expr.kind {\n             ast::ExprKind::Field(ref sub_ex, ident) => {\n                 let sub_ex_hir_id = self.tcx.hir().node_to_hir_id(sub_ex.id);\n                 let hir_node = match self.tcx.hir().find(sub_ex_hir_id) {\n@@ -612,7 +612,7 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n             Node::TraitRef(tr) => tr.path.res,\n \n             Node::Item(&hir::Item {\n-                node: hir::ItemKind::Use(ref path, _),\n+                kind: hir::ItemKind::Use(ref path, _),\n                 ..\n             }) |\n             Node::Visibility(&Spanned {\n@@ -629,37 +629,37 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n             }\n \n             Node::Expr(&hir::Expr {\n-                node: hir::ExprKind::Struct(ref qpath, ..),\n+                kind: hir::ExprKind::Struct(ref qpath, ..),\n                 ..\n             }) => {\n                 self.tables.qpath_res(qpath, hir_id)\n             }\n \n             Node::Expr(&hir::Expr {\n-                node: hir::ExprKind::Path(ref qpath),\n+                kind: hir::ExprKind::Path(ref qpath),\n                 ..\n             }) |\n             Node::Pat(&hir::Pat {\n-                node: hir::PatKind::Path(ref qpath),\n+                kind: hir::PatKind::Path(ref qpath),\n                 ..\n             }) |\n             Node::Pat(&hir::Pat {\n-                node: hir::PatKind::Struct(ref qpath, ..),\n+                kind: hir::PatKind::Struct(ref qpath, ..),\n                 ..\n             }) |\n             Node::Pat(&hir::Pat {\n-                node: hir::PatKind::TupleStruct(ref qpath, ..),\n+                kind: hir::PatKind::TupleStruct(ref qpath, ..),\n                 ..\n             }) |\n             Node::Ty(&hir::Ty {\n-                node: hir::TyKind::Path(ref qpath),\n+                kind: hir::TyKind::Path(ref qpath),\n                 ..\n             }) => {\n                 self.tables.qpath_res(qpath, hir_id)\n             }\n \n             Node::Binding(&hir::Pat {\n-                node: hir::PatKind::Binding(_, canonical_id, ..),\n+                kind: hir::PatKind::Binding(_, canonical_id, ..),\n                 ..\n             }) => Res::Local(canonical_id),\n \n@@ -965,7 +965,7 @@ impl<'l> PathCollector<'l> {\n \n impl<'l> Visitor<'l> for PathCollector<'l> {\n     fn visit_pat(&mut self, p: &'l ast::Pat) {\n-        match p.node {\n+        match p.kind {\n             PatKind::Struct(ref path, ..) => {\n                 self.collected_paths.push((p.id, path));\n             }"}, {"sha": "203bd4d4167e2f8467099164ad59fd4e35647dd7", "filename": "src/librustc_save_analysis/sig.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_save_analysis%2Fsig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_save_analysis%2Fsig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fsig.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -160,7 +160,7 @@ fn text_sig(text: String) -> Signature {\n impl Sig for ast::Ty {\n     fn make(&self, offset: usize, _parent_id: Option<NodeId>, scx: &SaveContext<'_, '_>) -> Result {\n         let id = Some(self.id);\n-        match self.node {\n+        match self.kind {\n             ast::TyKind::Slice(ref ty) => {\n                 let nested = ty.make(offset + 1, id, scx)?;\n                 let text = format!(\"[{}]\", nested.text);\n@@ -324,7 +324,7 @@ impl Sig for ast::Item {\n     fn make(&self, offset: usize, _parent_id: Option<NodeId>, scx: &SaveContext<'_, '_>) -> Result {\n         let id = Some(self.id);\n \n-        match self.node {\n+        match self.kind {\n             ast::ItemKind::Static(ref ty, m, ref expr) => {\n                 let mut text = \"static \".to_owned();\n                 if m == ast::Mutability::Mutable {\n@@ -765,7 +765,7 @@ impl Sig for ast::Variant {\n impl Sig for ast::ForeignItem {\n     fn make(&self, offset: usize, _parent_id: Option<NodeId>, scx: &SaveContext<'_, '_>) -> Result {\n         let id = Some(self.id);\n-        match self.node {\n+        match self.kind {\n             ast::ForeignItemKind::Fn(ref decl, ref generics) => {\n                 let mut text = String::new();\n                 text.push_str(\"fn \");"}, {"sha": "a2fbf8128b5d129f01577ea73cbaf8bfedf662f1", "filename": "src/librustc_traits/lowering/environment.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_traits%2Flowering%2Fenvironment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_traits%2Flowering%2Fenvironment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Flowering%2Fenvironment.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -195,24 +195,24 @@ crate fn environment(tcx: TyCtxt<'_>, def_id: DefId) -> Environment<'_> {\n     };\n \n     let node_kind = match node {\n-        Node::TraitItem(item) => match item.node {\n+        Node::TraitItem(item) => match item.kind {\n             TraitItemKind::Method(..) => NodeKind::Fn,\n             _ => NodeKind::Other,\n         }\n \n-        Node::ImplItem(item) => match item.node {\n+        Node::ImplItem(item) => match item.kind {\n             ImplItemKind::Method(..) => NodeKind::Fn,\n             _ => NodeKind::Other,\n         }\n \n-        Node::Item(item) => match item.node {\n+        Node::Item(item) => match item.kind {\n             ItemKind::Impl(.., Some(..), _, _) => NodeKind::TraitImpl,\n             ItemKind::Impl(.., None, _, _) => NodeKind::InherentImpl,\n             ItemKind::Fn(..) => NodeKind::Fn,\n             _ => NodeKind::Other,\n         }\n \n-        Node::ForeignItem(item) => match item.node {\n+        Node::ForeignItem(item) => match item.kind {\n             ForeignItemKind::Fn(..) => NodeKind::Fn,\n             _ => NodeKind::Other,\n         }"}, {"sha": "6f1d854481a10e90fd516aea00bd5b4358baebf5", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -2075,11 +2075,11 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n     /// internal notion of a type.\n     pub fn ast_ty_to_ty(&self, ast_ty: &hir::Ty) -> Ty<'tcx> {\n         debug!(\"ast_ty_to_ty(id={:?}, ast_ty={:?} ty_ty={:?})\",\n-               ast_ty.hir_id, ast_ty, ast_ty.node);\n+               ast_ty.hir_id, ast_ty, ast_ty.kind);\n \n         let tcx = self.tcx();\n \n-        let result_ty = match ast_ty.node {\n+        let result_ty = match ast_ty.kind {\n             hir::TyKind::Slice(ref ty) => {\n                 tcx.mk_slice(self.ast_ty_to_ty(&ty))\n             }\n@@ -2123,7 +2123,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 debug!(\"ast_ty_to_ty: qself={:?} segment={:?}\", qself, segment);\n                 let ty = self.ast_ty_to_ty(qself);\n \n-                let res = if let hir::TyKind::Path(hir::QPath::Resolved(_, ref path)) = qself.node {\n+                let res = if let hir::TyKind::Path(hir::QPath::Resolved(_, ref path)) = qself.kind {\n                     path.res\n                 } else {\n                     Res::Err\n@@ -2175,13 +2175,13 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n     pub fn const_param_def_id(&self, expr: &hir::Expr) -> Option<DefId> {\n         // Unwrap a block, so that e.g. `{ P }` is recognised as a parameter. Const arguments\n         // currently have to be wrapped in curly brackets, so it's necessary to special-case.\n-        let expr = match &expr.node {\n+        let expr = match &expr.kind {\n             ExprKind::Block(block, _) if block.stmts.is_empty() && block.expr.is_some() =>\n                 block.expr.as_ref().unwrap(),\n             _ => expr,\n         };\n \n-        match &expr.node {\n+        match &expr.kind {\n             ExprKind::Path(hir::QPath::Resolved(_, path)) => match path.res {\n                 Res::Def(DefKind::ConstParam, did) => Some(did),\n                 _ => None,\n@@ -2270,7 +2270,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                      expected_ty: Option<Ty<'tcx>>)\n                      -> Ty<'tcx>\n     {\n-        match ty.node {\n+        match ty.kind {\n             hir::TyKind::Infer if expected_ty.is_some() => {\n                 self.record_ty(ty.hir_id, expected_ty.unwrap(), ty.span);\n                 expected_ty.unwrap()"}, {"sha": "13b6b1b8aa08dc332652e09e851a404e2dcfbd40", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -135,7 +135,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     }\n                 }\n             } else {\n-                let arm_span = if let hir::ExprKind::Block(blk, _) = &arm.body.node {\n+                let arm_span = if let hir::ExprKind::Block(blk, _) = &arm.body.kind {\n                     // Point at the block expr instead of the entire block\n                     blk.expr.as_ref().map(|e| e.span).unwrap_or(arm.body.span)\n                 } else {\n@@ -219,7 +219,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         coercion.coerce_forced_unit(self, &cause, &mut |err| {\n             if let Some((span, msg)) = &ret_reason {\n                 err.span_label(*span, msg.as_str());\n-            } else if let ExprKind::Block(block, _) = &then_expr.node {\n+            } else if let ExprKind::Block(block, _) = &then_expr.kind {\n                 if let Some(expr) = &block.expr {\n                     err.span_label(expr.span, \"found here\".to_string());\n                 }\n@@ -248,7 +248,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 ),\n             );\n             if let (Some(expr), Item(hir::Item {\n-                node: hir::ItemKind::Fn(..), ..\n+                kind: hir::ItemKind::Fn(..), ..\n             })) = (&block.expr, parent) {\n                 // check that the `if` expr without `else` is the fn body's expr\n                 if expr.span == span {\n@@ -300,7 +300,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         };\n \n         let mut remove_semicolon = None;\n-        let error_sp = if let ExprKind::Block(block, _) = &else_expr.node {\n+        let error_sp = if let ExprKind::Block(block, _) = &else_expr.kind {\n             if let Some(expr) = &block.expr {\n                 expr.span\n             } else if let Some(stmt) = block.stmts.last() {\n@@ -345,7 +345,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         };\n \n         // Compute `Span` of `then` part of `if`-expression.\n-        let then_sp = if let ExprKind::Block(block, _) = &then_expr.node {\n+        let then_sp = if let ExprKind::Block(block, _) = &then_expr.kind {\n             if let Some(expr) = &block.expr {\n                 expr.span\n             } else if let Some(stmt) = block.stmts.last() {"}, {"sha": "4d8ec6fb0b83da7c5da758a210bc444633fb8235", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -247,7 +247,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let hir_id = self.tcx.hir().get_parent_node(hir_id);\n         let parent_node = self.tcx.hir().get(hir_id);\n         if let (\n-            hir::Node::Expr(hir::Expr { node: hir::ExprKind::Closure(_, _, _, sp, ..), .. }),\n+            hir::Node::Expr(hir::Expr { kind: hir::ExprKind::Closure(_, _, _, sp, ..), .. }),\n             hir::ExprKind::Block(..),\n         ) = (parent_node, callee_node) {\n             let start = sp.shrink_to_lo();\n@@ -278,13 +278,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 let mut unit_variant = None;\n                 if let &ty::Adt(adt_def, ..) = t {\n                     if adt_def.is_enum() {\n-                        if let hir::ExprKind::Call(ref expr, _) = call_expr.node {\n+                        if let hir::ExprKind::Call(ref expr, _) = call_expr.kind {\n                             unit_variant = Some(self.tcx.hir().hir_to_pretty_string(expr.hir_id))\n                         }\n                     }\n                 }\n \n-                if let hir::ExprKind::Call(ref callee, _) = call_expr.node {\n+                if let hir::ExprKind::Call(ref callee, _) = call_expr.kind {\n                     let mut err = type_error_struct!(\n                         self.tcx.sess,\n                         callee.span,\n@@ -300,7 +300,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     self.identify_bad_closure_def_and_call(\n                         &mut err,\n                         call_expr.hir_id,\n-                        &callee.node,\n+                        &callee.kind,\n                         callee.span,\n                     );\n \n@@ -318,7 +318,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     }\n \n                     let mut inner_callee_path = None;\n-                    let def = match callee.node {\n+                    let def = match callee.kind {\n                         hir::ExprKind::Path(ref qpath) => {\n                             self.tables.borrow().qpath_res(qpath, callee.hir_id)\n                         }\n@@ -337,7 +337,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                     Applicability::MaybeIncorrect,\n                                 );\n                             }\n-                            if let hir::ExprKind::Path(ref inner_qpath) = inner_callee.node {\n+                            if let hir::ExprKind::Path(ref inner_qpath) = inner_callee.kind {\n                                 inner_callee_path = Some(inner_qpath);\n                                 self.tables\n                                     .borrow()\n@@ -375,8 +375,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     err.emit();\n                 } else {\n                     bug!(\n-                        \"call_expr.node should be an ExprKind::Call, got {:?}\",\n-                        call_expr.node\n+                        \"call_expr.kind should be an ExprKind::Call, got {:?}\",\n+                        call_expr.kind\n                     );\n                 }\n "}, {"sha": "6818d5f521d009ff0fe0d03fd4bec57e0ff634ec", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -425,7 +425,7 @@ fn extract_spans_for_error_reporting<'a, 'tcx>(\n     let impl_m_hir_id = tcx.hir().as_local_hir_id(impl_m.def_id).unwrap();\n     let (impl_m_output, impl_m_iter) = match tcx.hir()\n                                                 .expect_impl_item(impl_m_hir_id)\n-                                                .node {\n+                                                .kind {\n         ImplItemKind::Method(ref impl_m_sig, _) => {\n             (&impl_m_sig.decl.output, impl_m_sig.decl.inputs.iter())\n         }\n@@ -437,15 +437,15 @@ fn extract_spans_for_error_reporting<'a, 'tcx>(\n             if let Some(trait_m_hir_id) = tcx.hir().as_local_hir_id(trait_m.def_id) {\n                 let trait_m_iter = match tcx.hir()\n                                             .expect_trait_item(trait_m_hir_id)\n-                                            .node {\n+                                            .kind {\n                     TraitItemKind::Method(ref trait_m_sig, _) => {\n                         trait_m_sig.decl.inputs.iter()\n                     }\n                     _ => bug!(\"{:?} is not a TraitItemKind::Method\", trait_m),\n                 };\n \n                 impl_m_iter.zip(trait_m_iter).find(|&(ref impl_arg, ref trait_arg)| {\n-                    match (&impl_arg.node, &trait_arg.node) {\n+                    match (&impl_arg.kind, &trait_arg.kind) {\n                         (&hir::TyKind::Rptr(_, ref impl_mt), &hir::TyKind::Rptr(_, ref trait_mt)) |\n                         (&hir::TyKind::Ptr(ref impl_mt), &hir::TyKind::Ptr(ref trait_mt)) => {\n                             impl_mt.mutbl != trait_mt.mutbl\n@@ -463,7 +463,7 @@ fn extract_spans_for_error_reporting<'a, 'tcx>(\n         TypeError::Sorts(ExpectedFound { .. }) => {\n             if let Some(trait_m_hir_id) = tcx.hir().as_local_hir_id(trait_m.def_id) {\n                 let (trait_m_output, trait_m_iter) =\n-                    match tcx.hir().expect_trait_item(trait_m_hir_id).node {\n+                    match tcx.hir().expect_trait_item(trait_m_hir_id).kind {\n                         TraitItemKind::Method(ref trait_m_sig, _) => {\n                             (&trait_m_sig.decl.output, trait_m_sig.decl.inputs.iter())\n                         }\n@@ -715,7 +715,7 @@ fn compare_number_of_method_arguments<'tcx>(\n     if trait_number_args != impl_number_args {\n         let trait_m_hir_id = tcx.hir().as_local_hir_id(trait_m.def_id);\n         let trait_span = if let Some(trait_id) = trait_m_hir_id {\n-            match tcx.hir().expect_trait_item(trait_id).node {\n+            match tcx.hir().expect_trait_item(trait_id).kind {\n                 TraitItemKind::Method(ref trait_m_sig, _) => {\n                     let pos = if trait_number_args > 0 {\n                         trait_number_args - 1\n@@ -740,7 +740,7 @@ fn compare_number_of_method_arguments<'tcx>(\n             trait_item_span\n         };\n         let impl_m_hir_id = tcx.hir().as_local_hir_id(impl_m.def_id).unwrap();\n-        let impl_span = match tcx.hir().expect_impl_item(impl_m_hir_id).node {\n+        let impl_span = match tcx.hir().expect_impl_item(impl_m_hir_id).kind {\n             ImplItemKind::Method(ref impl_m_sig, _) => {\n                 let pos = if impl_number_args > 0 {\n                     impl_number_args - 1\n@@ -883,7 +883,7 @@ fn compare_synthetic_generics<'tcx>(\n                     (|| {\n                         let impl_m = tcx.hir().as_local_hir_id(impl_m.def_id)?;\n                         let impl_m = tcx.hir().impl_item(hir::ImplItemId { hir_id: impl_m });\n-                        let input_tys = match impl_m.node {\n+                        let input_tys = match impl_m.kind {\n                             hir::ImplItemKind::Method(ref sig, _) => &sig.decl.inputs,\n                             _ => unreachable!(),\n                         };\n@@ -892,7 +892,7 @@ fn compare_synthetic_generics<'tcx>(\n                             fn visit_ty(&mut self, ty: &'v hir::Ty) {\n                                 hir::intravisit::walk_ty(self, ty);\n                                 if let hir::TyKind::Path(\n-                                    hir::QPath::Resolved(None, ref path)) = ty.node\n+                                    hir::QPath::Resolved(None, ref path)) = ty.kind\n                                 {\n                                     if let Res::Def(DefKind::TyParam, def_id) = path.res {\n                                         if def_id == self.1 {\n@@ -1014,7 +1014,7 @@ pub fn compare_const_impl<'tcx>(\n                    trait_ty);\n \n             // Locate the Span containing just the type of the offending impl\n-            match tcx.hir().expect_impl_item(impl_c_hir_id).node {\n+            match tcx.hir().expect_impl_item(impl_c_hir_id).kind {\n                 ImplItemKind::Const(ref ty, _) => cause.span = ty.span,\n                 _ => bug!(\"{:?} is not a impl const\", impl_c),\n             }\n@@ -1029,7 +1029,7 @@ pub fn compare_const_impl<'tcx>(\n             let trait_c_hir_id = tcx.hir().as_local_hir_id(trait_c.def_id);\n             let trait_c_span = trait_c_hir_id.map(|trait_c_hir_id| {\n                 // Add a label to the Span containing just the type of the const\n-                match tcx.hir().expect_trait_item(trait_c_hir_id).node {\n+                match tcx.hir().expect_trait_item(trait_c_hir_id).kind {\n                     TraitItemKind::Const(ref ty, _) => ty.span,\n                     _ => bug!(\"{:?} is not a trait const\", trait_c),\n                 }"}, {"sha": "2ea0afb1793562d47582a6e71143dc9d8c8e2fd5", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -135,7 +135,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     /// Returns whether the expected type is `bool` and the expression is `x = y`.\n     pub fn is_assign_to_bool(&self, expr: &hir::Expr, expected: Ty<'tcx>) -> bool {\n-        if let hir::ExprKind::Assign(..) = expr.node {\n+        if let hir::ExprKind::Assign(..) = expr.kind {\n             return expected == self.tcx.types.bool;\n         }\n         false\n@@ -236,7 +236,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         &self,\n         expr: &hir::Expr,\n     ) -> Option<(Span, &'static str, String)> {\n-        let path = match expr.node {\n+        let path = match expr.kind {\n             hir::ExprKind::Path(hir::QPath::Resolved(_, ref path)) => path,\n             _ => return None\n         };\n@@ -255,7 +255,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let param_parent = self.tcx.hir().get_parent_node(*param_hir_id);\n         let (expr_hir_id, closure_fn_decl) = match self.tcx.hir().find(param_parent) {\n             Some(Node::Expr(\n-                hir::Expr { hir_id, node: hir::ExprKind::Closure(_, decl, ..), .. }\n+                hir::Expr { hir_id, kind: hir::ExprKind::Closure(_, decl, ..), .. }\n             )) => (hir_id, decl),\n             _ => return None\n         };\n@@ -265,7 +265,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let closure_params_len = closure_fn_decl.inputs.len();\n         let (method_path, method_span, method_expr) = match (hir, closure_params_len) {\n             (Some(Node::Expr(\n-                hir::Expr { node: hir::ExprKind::MethodCall(path, span, expr), .. }\n+                hir::Expr { kind: hir::ExprKind::MethodCall(path, span, expr), .. }\n             )), 1) => (path, span, expr),\n             _ => return None\n         };\n@@ -298,7 +298,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         if let Some(parent) = self.tcx.hir().find(parent_id) {\n             // Account for fields\n             if let Node::Expr(hir::Expr {\n-                node: hir::ExprKind::Struct(_, fields, ..), ..\n+                kind: hir::ExprKind::Struct(_, fields, ..), ..\n             }) = parent {\n                 if let Ok(src) = cm.span_to_snippet(sp) {\n                     for field in fields {\n@@ -351,11 +351,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // and make a good suggestion, so don't bother.\n         let is_macro = sp.from_expansion();\n \n-        match (&expr.node, &expected.kind, &checked_ty.kind) {\n+        match (&expr.kind, &expected.kind, &checked_ty.kind) {\n             (_, &ty::Ref(_, exp, _), &ty::Ref(_, check, _)) => match (&exp.kind, &check.kind) {\n                 (&ty::Str, &ty::Array(arr, _)) |\n                 (&ty::Str, &ty::Slice(arr)) if arr == self.tcx.types.u8 => {\n-                    if let hir::ExprKind::Lit(_) = expr.node {\n+                    if let hir::ExprKind::Lit(_) = expr.kind {\n                         if let Ok(src) = cm.span_to_snippet(sp) {\n                             if src.starts_with(\"b\\\"\") {\n                                 return Some((sp,\n@@ -367,7 +367,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 },\n                 (&ty::Array(arr, _), &ty::Str) |\n                 (&ty::Slice(arr), &ty::Str) if arr == self.tcx.types.u8 => {\n-                    if let hir::ExprKind::Lit(_) = expr.node {\n+                    if let hir::ExprKind::Lit(_) = expr.kind {\n                         if let Ok(src) = cm.span_to_snippet(sp) {\n                             if src.starts_with(\"\\\"\") {\n                                 return Some((sp,\n@@ -398,7 +398,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 };\n                 if self.can_coerce(ref_ty, expected) {\n                     let mut sugg_sp = sp;\n-                    if let hir::ExprKind::MethodCall(segment, _sp, args) = &expr.node {\n+                    if let hir::ExprKind::MethodCall(segment, _sp, args) = &expr.kind {\n                         let clone_trait = self.tcx.lang_items().clone_trait().unwrap();\n                         if let ([arg], Some(true), \"clone\") = (\n                             &args[..],\n@@ -414,7 +414,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         }\n                     }\n                     if let Ok(src) = cm.span_to_snippet(sugg_sp) {\n-                        let needs_parens = match expr.node {\n+                        let needs_parens = match expr.kind {\n                             // parenthesize if needed (Issue #46756)\n                             hir::ExprKind::Cast(_, _) |\n                             hir::ExprKind::Binary(_, _, _) => true,\n@@ -437,7 +437,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             String::new()\n                         };\n                         if let Some(hir::Node::Expr(hir::Expr {\n-                            node: hir::ExprKind::Assign(left_expr, _),\n+                            kind: hir::ExprKind::Assign(left_expr, _),\n                             ..\n                         })) = self.tcx.hir().find(\n                             self.tcx.hir().get_parent_node(expr.hir_id),\n@@ -571,7 +571,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         let mut prefix = String::new();\n         if let Some(hir::Node::Expr(hir::Expr {\n-            node: hir::ExprKind::Struct(_, fields, _),\n+            kind: hir::ExprKind::Struct(_, fields, _),\n             ..\n         })) = self.tcx.hir().find(self.tcx.hir().get_parent_node(expr.hir_id)) {\n             // `expr` is a literal field for a struct, only suggest if appropriate\n@@ -587,16 +587,16 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 return false;\n             }\n         }\n-        if let hir::ExprKind::Call(path, args) = &expr.node {\n+        if let hir::ExprKind::Call(path, args) = &expr.kind {\n             if let (\n                 hir::ExprKind::Path(hir::QPath::TypeRelative(base_ty, path_segment)),\n                 1,\n-            ) = (&path.node, args.len()) {\n+            ) = (&path.kind, args.len()) {\n                 // `expr` is a conversion like `u32::from(val)`, do not suggest anything (#63697).\n                 if let (\n                     hir::TyKind::Path(hir::QPath::Resolved(None, base_ty_path)),\n                     sym::from,\n-                ) = (&base_ty.node, path_segment.ident.name) {\n+                ) = (&base_ty.kind, path_segment.ident.name) {\n                     if let Some(ident) = &base_ty_path.segments.iter().map(|s| s.ident).next() {\n                         match ident.name {\n                             sym::i128 | sym::i64 | sym::i32 | sym::i16 | sym::i8 |\n@@ -663,7 +663,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 if needs_paren { \")\" } else { \"\" },\n             );\n             let literal_is_ty_suffixed = |expr: &hir::Expr| {\n-                if let hir::ExprKind::Lit(lit) = &expr.node {\n+                if let hir::ExprKind::Lit(lit) = &expr.kind {\n                     lit.node.is_suffixed()\n                 } else {\n                     false"}, {"sha": "58f41ca4f88f94c481ce3721113beb38b1dc575c", "filename": "src/librustc_typeck/check/expr.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -84,7 +84,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n \n         if let Some(mut err) = self.demand_suptype_diag(expr.span, expected_ty, ty) {\n-            let expr = match &expr.node {\n+            let expr = match &expr.kind {\n                 ExprKind::DropTemps(expr) => expr,\n                 _ => expr,\n             };\n@@ -159,7 +159,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let ty = self.check_expr_kind(expr, expected, needs);\n \n         // Warn for non-block expressions with diverging children.\n-        match expr.node {\n+        match expr.kind {\n             ExprKind::Block(..) | ExprKind::Loop(..) | ExprKind::Match(..) => {},\n             ExprKind::Call(ref callee, _) =>\n                 self.warn_if_unreachable(expr.hir_id, callee.span, \"call\"),\n@@ -202,7 +202,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         );\n \n         let tcx = self.tcx;\n-        match expr.node {\n+        match expr.kind {\n             ExprKind::Box(ref subexpr) => {\n                 self.check_expr_box(subexpr, expected)\n             }\n@@ -602,7 +602,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n                 // ... except when we try to 'break rust;'.\n                 // ICE this expression in particular (see #43162).\n-                if let ExprKind::Path(QPath::Resolved(_, ref path)) = e.node {\n+                if let ExprKind::Path(QPath::Resolved(_, ref path)) = e.kind {\n                     if path.segments.len() == 1 &&\n                         path.segments[0].ident.name == sym::rust {\n                         fatally_break_rust(self.tcx.sess);\n@@ -1604,7 +1604,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         let mut needs_note = true;\n                         // If the index is an integer, we can show the actual\n                         // fixed expression:\n-                        if let ExprKind::Lit(ref lit) = idx.node {\n+                        if let ExprKind::Lit(ref lit) = idx.kind {\n                             if let ast::LitKind::Int(i, ast::LitIntType::Unsuffixed) = lit.node {\n                                 let snip = self.tcx.sess.source_map().span_to_snippet(base.span);\n                                 if let Ok(snip) = snip {"}, {"sha": "d2d3854d2758cc6311e0941ca90ed332f171ed01", "filename": "src/librustc_typeck/check/generator_interior.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_typeck%2Fcheck%2Fgenerator_interior.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_typeck%2Fcheck%2Fgenerator_interior.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fgenerator_interior.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -167,7 +167,7 @@ impl<'a, 'tcx> Visitor<'tcx> for InteriorVisitor<'a, 'tcx> {\n \n         self.expr_count += 1;\n \n-        if let PatKind::Binding(..) = pat.node {\n+        if let PatKind::Binding(..) = pat.kind {\n             let scope = self.region_scope_tree.var_scope(pat.hir_id.local_id);\n             let ty = self.fcx.tables.borrow().pat_ty(pat);\n             self.record(ty, Some(scope), None, pat.span);"}, {"sha": "d06d51dc819312c12978b7b95203d6b3cf2aa6e6", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -24,7 +24,7 @@ fn equate_intrinsic_type<'tcx>(\n ) {\n     let def_id = tcx.hir().local_def_id(it.hir_id);\n \n-    match it.node {\n+    match it.kind {\n         hir::ForeignItemKind::Fn(..) => {}\n         _ => {\n             struct_span_err!(tcx.sess, it.span, E0622,\n@@ -37,7 +37,7 @@ fn equate_intrinsic_type<'tcx>(\n \n     let i_n_tps = tcx.generics_of(def_id).own_counts().types;\n     if i_n_tps != n_tps {\n-        let span = match it.node {\n+        let span = match it.kind {\n             hir::ForeignItemKind::Fn(_, _, ref generics) => generics.span,\n             _ => bug!()\n         };"}, {"sha": "9baf06be3f6b5f47f8776b8910a13a44f50aaec0", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -436,7 +436,7 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n         let mut exprs = vec![self.self_expr];\n \n         loop {\n-            match exprs.last().unwrap().node {\n+            match exprs.last().unwrap().kind {\n                 hir::ExprKind::Field(ref expr, _) |\n                 hir::ExprKind::Index(ref expr, _) |\n                 hir::ExprKind::Unary(hir::UnDeref, ref expr) => exprs.push(&expr),\n@@ -480,7 +480,7 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n                 self.tables.borrow_mut().adjustments_mut().insert(expr.hir_id, adjustments);\n             }\n \n-            match expr.node {\n+            match expr.kind {\n                 hir::ExprKind::Index(ref base_expr, ref index_expr) => {\n                     let index_expr_ty = self.node_ty(index_expr.hir_id);\n                     self.convert_place_op_to_mutable("}, {"sha": "2d4d2e32f23dbada7d2c41f82dd02a6411655d81", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -258,7 +258,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         } else {\n                             \"f32\"\n                         };\n-                        match expr.node {\n+                        match expr.kind {\n                             ExprKind::Lit(ref lit) => {\n                                 // numeric literal\n                                 let snippet = tcx.sess.source_map().span_to_snippet(lit.span)\n@@ -446,7 +446,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         if let Ok(expr_string) = tcx.sess.source_map().span_to_snippet(expr.span) {\n                             report_function!(expr.span, expr_string);\n                         } else if let ExprKind::Path(QPath::Resolved(_, ref path)) =\n-                            expr.node\n+                            expr.kind\n                         {\n                             if let Some(segment) = path.segments.last() {\n                                 report_function!(expr.span, segment.ident);\n@@ -895,7 +895,7 @@ fn compute_all_traits(tcx: TyCtxt<'_>) -> Vec<DefId> {\n \n     impl<'v, 'a, 'tcx> itemlikevisit::ItemLikeVisitor<'v> for Visitor<'a, 'tcx> {\n         fn visit_item(&mut self, i: &'v hir::Item) {\n-            match i.node {\n+            match i.kind {\n                 hir::ItemKind::Trait(..) |\n                 hir::ItemKind::TraitAlias(..) => {\n                     let def_id = self.map.local_def_id(i.hir_id);\n@@ -999,7 +999,7 @@ impl hir::intravisit::Visitor<'tcx> for UsePlacementFinder<'tcx> {\n         // Find a `use` statement.\n         for item_id in &module.item_ids {\n             let item = self.tcx.hir().expect_item(item_id.id);\n-            match item.node {\n+            match item.kind {\n                 hir::ItemKind::Use(..) => {\n                     // Don't suggest placing a `use` before the prelude\n                     // import or other generated ones."}, {"sha": "9f2c991fdd23697fb748bec1bf1199976f2eefdb", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 43, "deletions": 43, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -792,7 +792,7 @@ fn primary_body_of(\n ) -> Option<(hir::BodyId, Option<&hir::Ty>, Option<&hir::FnHeader>, Option<&hir::FnDecl>)> {\n     match tcx.hir().get(id) {\n         Node::Item(item) => {\n-            match item.node {\n+            match item.kind {\n                 hir::ItemKind::Const(ref ty, body) |\n                 hir::ItemKind::Static(ref ty, _, body) =>\n                     Some((body, Some(ty), None, None)),\n@@ -803,7 +803,7 @@ fn primary_body_of(\n             }\n         }\n         Node::TraitItem(item) => {\n-            match item.node {\n+            match item.kind {\n                 hir::TraitItemKind::Const(ref ty, Some(body)) =>\n                     Some((body, Some(ty), None, None)),\n                 hir::TraitItemKind::Method(ref sig, hir::TraitMethod::Provided(body)) =>\n@@ -813,7 +813,7 @@ fn primary_body_of(\n             }\n         }\n         Node::ImplItem(item) => {\n-            match item.node {\n+            match item.kind {\n                 hir::ImplItemKind::Const(ref ty, body) =>\n                     Some((body, Some(ty), None, None)),\n                 hir::ImplItemKind::Method(ref sig, body) =>\n@@ -886,7 +886,7 @@ fn typeck_tables_of(tcx: TyCtxt<'_>, def_id: DefId) -> &ty::TypeckTables<'_> {\n             fcx\n         } else {\n             let fcx = FnCtxt::new(&inh, param_env, body.value.hir_id);\n-            let expected_type = body_ty.and_then(|ty| match ty.node {\n+            let expected_type = body_ty.and_then(|ty| match ty.kind {\n                 hir::TyKind::Infer => Some(AstConv::ast_ty_to_ty(&fcx, ty)),\n                 _ => None\n             }).unwrap_or_else(|| tcx.type_of(def_id));\n@@ -1032,7 +1032,7 @@ impl<'a, 'tcx> Visitor<'tcx> for GatherLocalsVisitor<'a, 'tcx> {\n \n     // Add pattern bindings.\n     fn visit_pat(&mut self, p: &'tcx hir::Pat) {\n-        if let PatKind::Binding(_, _, ident, _) = p.node {\n+        if let PatKind::Binding(_, _, ident, _) = p.kind {\n             let var_ty = self.assign(p.span, p.hir_id, None);\n \n             if !self.fcx.tcx.features().unsized_locals {\n@@ -1262,7 +1262,7 @@ fn check_fn<'a, 'tcx>(\n                     }\n \n                     if let Node::Item(item) = fcx.tcx.hir().get(fn_id) {\n-                        if let ItemKind::Fn(_, _, ref generics, _) = item.node {\n+                        if let ItemKind::Fn(_, _, ref generics, _) = item.kind {\n                             if !generics.params.is_empty() {\n                                 fcx.tcx.sess.span_err(\n                                     span,\n@@ -1310,7 +1310,7 @@ fn check_fn<'a, 'tcx>(\n                     }\n \n                     if let Node::Item(item) = fcx.tcx.hir().get(fn_id) {\n-                        if let ItemKind::Fn(_, _, ref generics, _) = item.node {\n+                        if let ItemKind::Fn(_, _, ref generics, _) = item.kind {\n                             if !generics.params.is_empty() {\n                                 fcx.tcx.sess.span_err(\n                                     span,\n@@ -1403,7 +1403,7 @@ fn check_opaque_for_inheriting_lifetimes(\n         }\n     }\n \n-    let prohibit_opaque = match item.node {\n+    let prohibit_opaque = match item.kind {\n         ItemKind::OpaqueTy(hir::OpaqueTy { origin: hir::OpaqueTyOrigin::AsyncFn, .. }) |\n         ItemKind::OpaqueTy(hir::OpaqueTy { origin: hir::OpaqueTyOrigin::FnReturn, .. }) => {\n             let mut visitor = ProhibitOpaqueVisitor {\n@@ -1421,7 +1421,7 @@ fn check_opaque_for_inheriting_lifetimes(\n \n     debug!(\"check_opaque_for_inheriting_lifetimes: prohibit_opaque={:?}\", prohibit_opaque);\n     if prohibit_opaque {\n-        let is_async = match item.node {\n+        let is_async = match item.kind {\n             ItemKind::OpaqueTy(hir::OpaqueTy { origin, .. }) => match origin {\n                 hir::OpaqueTyOrigin::AsyncFn => true,\n                 _ => false,\n@@ -1485,7 +1485,7 @@ pub fn check_item_type<'tcx>(tcx: TyCtxt<'tcx>, it: &'tcx hir::Item) {\n         tcx.def_path_str(tcx.hir().local_def_id(it.hir_id))\n     );\n     let _indenter = indenter();\n-    match it.node {\n+    match it.kind {\n         // Consts can play a role in type-checking, so they are included here.\n         hir::ItemKind::Static(..) => {\n             let def_id = tcx.hir().local_def_id(it.hir_id);\n@@ -1520,7 +1520,7 @@ pub fn check_item_type<'tcx>(tcx: TyCtxt<'tcx>, it: &'tcx hir::Item) {\n \n             for item in items.iter() {\n                 let item = tcx.hir().trait_item(item.id);\n-                if let hir::TraitItemKind::Method(sig, _) = &item.node {\n+                if let hir::TraitItemKind::Method(sig, _) = &item.kind {\n                     let abi = sig.header.abi;\n                     fn_maybe_err(tcx, item.ident.span, abi);\n                 }\n@@ -1588,7 +1588,7 @@ pub fn check_item_type<'tcx>(tcx: TyCtxt<'tcx>, it: &'tcx hir::Item) {\n                         ).emit();\n                     }\n \n-                    if let hir::ForeignItemKind::Fn(ref fn_decl, _, _) = item.node {\n+                    if let hir::ForeignItemKind::Fn(ref fn_decl, _, _) = item.kind {\n                         require_c_abi_if_c_variadic(tcx, fn_decl, m.abi, item.span);\n                     }\n                 }\n@@ -1681,7 +1681,7 @@ fn check_specialization_validity<'tcx>(\n ) {\n     let ancestors = trait_def.ancestors(tcx, impl_id);\n \n-    let kind = match impl_item.node {\n+    let kind = match impl_item.kind {\n         hir::ImplItemKind::Const(..) => ty::AssocKind::Const,\n         hir::ImplItemKind::Method(..) => ty::AssocKind::Method,\n         hir::ImplItemKind::OpaqueTy(..) => ty::AssocKind::OpaqueTy,\n@@ -1725,7 +1725,7 @@ fn check_impl_items_against_trait<'tcx>(\n         let ty_impl_item = tcx.associated_item(\n             tcx.hir().local_def_id(impl_item.hir_id));\n         let ty_trait_item = tcx.associated_items(impl_trait_ref.def_id)\n-            .find(|ac| Namespace::from(&impl_item.node) == Namespace::from(ac.kind) &&\n+            .find(|ac| Namespace::from(&impl_item.kind) == Namespace::from(ac.kind) &&\n                        tcx.hygienic_eq(ty_impl_item.ident, ac.ident, impl_trait_ref.def_id))\n             .or_else(|| {\n                 // Not compatible, but needed for the error message\n@@ -1735,7 +1735,7 @@ fn check_impl_items_against_trait<'tcx>(\n \n         // Check that impl definition matches trait definition\n         if let Some(ty_trait_item) = ty_trait_item {\n-            match impl_item.node {\n+            match impl_item.kind {\n                 hir::ImplItemKind::Const(..) => {\n                     // Find associated const definition.\n                     if ty_trait_item.kind == ty::AssocKind::Const {\n@@ -3376,7 +3376,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     self.warn_if_unreachable(arg.hir_id, arg.span, \"expression\");\n                 }\n \n-                let is_closure = match arg.node {\n+                let is_closure = match arg.kind {\n                     ExprKind::Closure(..) => true,\n                     _ => false\n                 };\n@@ -3495,8 +3495,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         errors: &mut Vec<traits::FulfillmentError<'_>>,\n         call_expr: &'tcx hir::Expr,\n     ) {\n-        if let hir::ExprKind::Call(path, _) = &call_expr.node {\n-            if let hir::ExprKind::Path(qpath) = &path.node {\n+        if let hir::ExprKind::Call(path, _) = &call_expr.kind {\n+            if let hir::ExprKind::Path(qpath) = &path.kind {\n                 if let hir::QPath::Resolved(_, path) = &qpath {\n                     for error in errors {\n                         if let ty::Predicate::Trait(predicate) = error.obligation.predicate {\n@@ -3509,7 +3509,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                 if let hir::GenericArg::Type(hir_ty) = &arg {\n                                     if let hir::TyKind::Path(\n                                         hir::QPath::TypeRelative(..),\n-                                    ) = &hir_ty.node {\n+                                    ) = &hir_ty.kind {\n                                         // Avoid ICE with associated types. As this is best\n                                         // effort only, it's ok to ignore the case. It\n                                         // would trigger in `is_send::<T::AssocType>();`\n@@ -3722,7 +3722,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             QPath::TypeRelative(ref qself, ref segment) => {\n                 let ty = self.to_ty(qself);\n \n-                let res = if let hir::TyKind::Path(QPath::Resolved(_, ref path)) = qself.node {\n+                let res = if let hir::TyKind::Path(QPath::Resolved(_, ref path)) = qself.kind {\n                     path.res\n                 } else {\n                     Res::Err\n@@ -3860,7 +3860,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     pub fn check_stmt(&self, stmt: &'tcx hir::Stmt) {\n         // Don't do all the complex logic below for `DeclItem`.\n-        match stmt.node {\n+        match stmt.kind {\n             hir::StmtKind::Item(..) => return,\n             hir::StmtKind::Local(..) | hir::StmtKind::Expr(..) | hir::StmtKind::Semi(..) => {}\n         }\n@@ -3873,7 +3873,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self.diverges.set(Diverges::Maybe);\n         self.has_errors.set(false);\n \n-        match stmt.node {\n+        match stmt.kind {\n             hir::StmtKind::Local(ref l) => {\n                 self.check_decl_local(&l);\n             }\n@@ -3912,15 +3912,15 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// //                               ^^^^ point at this instead of the whole `if` expression\n     /// ```\n     fn get_expr_coercion_span(&self, expr: &hir::Expr) -> syntax_pos::Span {\n-        if let hir::ExprKind::Match(_, arms, _) = &expr.node {\n+        if let hir::ExprKind::Match(_, arms, _) = &expr.kind {\n             let arm_spans: Vec<Span> = arms.iter().filter_map(|arm| {\n                 self.in_progress_tables\n                     .and_then(|tables| tables.borrow().node_type_opt(arm.body.hir_id))\n                     .and_then(|arm_ty| {\n                         if arm_ty.is_never() {\n                             None\n                         } else {\n-                            Some(match &arm.body.node {\n+                            Some(match &arm.body.kind {\n                                 // Point at the tail expression when possible.\n                                 hir::ExprKind::Block(block, _) => block.expr\n                                     .as_ref()\n@@ -4069,13 +4069,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let node = self.tcx.hir().get(self.tcx.hir().get_parent_item(id));\n         match node {\n             Node::Item(&hir::Item {\n-                node: hir::ItemKind::Fn(_, _, _, body_id), ..\n+                kind: hir::ItemKind::Fn(_, _, _, body_id), ..\n             }) |\n             Node::ImplItem(&hir::ImplItem {\n-                node: hir::ImplItemKind::Method(_, body_id), ..\n+                kind: hir::ImplItemKind::Method(_, body_id), ..\n             }) => {\n                 let body = self.tcx.hir().body(body_id);\n-                if let ExprKind::Block(block, _) = &body.value.node {\n+                if let ExprKind::Block(block, _) = &body.value.kind {\n                     return Some(block.span);\n                 }\n             }\n@@ -4094,20 +4094,20 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     fn get_node_fn_decl(&self, node: Node<'tcx>) -> Option<(&'tcx hir::FnDecl, ast::Ident, bool)> {\n         match node {\n             Node::Item(&hir::Item {\n-                ident, node: hir::ItemKind::Fn(ref decl, ..), ..\n+                ident, kind: hir::ItemKind::Fn(ref decl, ..), ..\n             }) => {\n                 // This is less than ideal, it will not suggest a return type span on any\n                 // method called `main`, regardless of whether it is actually the entry point,\n                 // but it will still present it as the reason for the expected type.\n                 Some((decl, ident, ident.name != sym::main))\n             }\n             Node::TraitItem(&hir::TraitItem {\n-                ident, node: hir::TraitItemKind::Method(hir::MethodSig {\n+                ident, kind: hir::TraitItemKind::Method(hir::MethodSig {\n                     ref decl, ..\n                 }, ..), ..\n             }) => Some((decl, ident, true)),\n             Node::ImplItem(&hir::ImplItem {\n-                ident, node: hir::ImplItemKind::Method(hir::MethodSig {\n+                ident, kind: hir::ImplItemKind::Method(hir::MethodSig {\n                     ref decl, ..\n                 }, ..), ..\n             }) => Some((decl, ident, false)),\n@@ -4192,27 +4192,27 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             let mut msg = \"call this function\";\n             match hir.get_if_local(def_id) {\n                 Some(Node::Item(hir::Item {\n-                    node: ItemKind::Fn(.., body_id),\n+                    kind: ItemKind::Fn(.., body_id),\n                     ..\n                 })) |\n                 Some(Node::ImplItem(hir::ImplItem {\n-                    node: hir::ImplItemKind::Method(_, body_id),\n+                    kind: hir::ImplItemKind::Method(_, body_id),\n                     ..\n                 })) |\n                 Some(Node::TraitItem(hir::TraitItem {\n-                    node: hir::TraitItemKind::Method(.., hir::TraitMethod::Provided(body_id)),\n+                    kind: hir::TraitItemKind::Method(.., hir::TraitMethod::Provided(body_id)),\n                     ..\n                 })) => {\n                     let body = hir.body(*body_id);\n                     sugg_call = body.params.iter()\n-                        .map(|param| match &param.pat.node {\n+                        .map(|param| match &param.pat.kind {\n                             hir::PatKind::Binding(_, _, ident, None)\n                             if ident.name != kw::SelfLower => ident.to_string(),\n                             _ => \"_\".to_string(),\n                         }).collect::<Vec<_>>().join(\", \");\n                 }\n                 Some(Node::Expr(hir::Expr {\n-                    node: ExprKind::Closure(_, _, body_id, closure_span, _),\n+                    kind: ExprKind::Closure(_, _, body_id, closure_span, _),\n                     span: full_closure_span,\n                     ..\n                 })) => {\n@@ -4223,7 +4223,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     msg = \"call this closure\";\n                     let body = hir.body(*body_id);\n                     sugg_call = body.params.iter()\n-                        .map(|param| match &param.pat.node {\n+                        .map(|param| match &param.pat.kind {\n                             hir::PatKind::Binding(_, _, ident, None)\n                             if ident.name != kw::SelfLower => ident.to_string(),\n                             _ => \"_\".to_string(),\n@@ -4242,11 +4242,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     }\n                 }\n                 Some(Node::ForeignItem(hir::ForeignItem {\n-                    node: hir::ForeignItemKind::Fn(_, idents, _),\n+                    kind: hir::ForeignItemKind::Fn(_, idents, _),\n                     ..\n                 })) |\n                 Some(Node::TraitItem(hir::TraitItem {\n-                    node: hir::TraitItemKind::Method(.., hir::TraitMethod::Required(idents)),\n+                    kind: hir::TraitItemKind::Method(.., hir::TraitMethod::Required(idents)),\n                     ..\n                 })) => sugg_call = idents.iter()\n                         .map(|ident| if ident.name != kw::SelfLower {\n@@ -4388,7 +4388,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         if expected.is_unit() {\n             // `BlockTailExpression` only relevant if the tail expr would be\n             // useful on its own.\n-            match expression.node {\n+            match expression.kind {\n                 ExprKind::Call(..) |\n                 ExprKind::MethodCall(..) |\n                 ExprKind::Loop(..) |\n@@ -4450,7 +4450,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             (&hir::FunctionRetTy::Return(ref ty), _, _, _) => {\n                 // Only point to return type if the expected type is the return type, as if they\n                 // are not, the expectation must have been caused by something else.\n-                debug!(\"suggest_missing_return_type: return type {:?} node {:?}\", ty, ty.node);\n+                debug!(\"suggest_missing_return_type: return type {:?} node {:?}\", ty, ty.kind);\n                 let sp = ty.span;\n                 let ty = AstConv::ast_ty_to_ty(self, ty);\n                 debug!(\"suggest_missing_return_type: return type {:?}\", ty);\n@@ -4560,7 +4560,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // Be helpful when the user wrote `{... expr;}` and\n         // taking the `;` off is enough to fix the error.\n         let last_stmt = blk.stmts.last()?;\n-        let last_expr = match last_stmt.node {\n+        let last_expr = match last_stmt.kind {\n             hir::StmtKind::Semi(ref e) => e,\n             _ => return None,\n         };\n@@ -4893,7 +4893,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         if let Node::Expr(expr) = self.tcx.hir().get(\n             self.tcx.hir().get_parent_node(hir_id))\n         {\n-            if let ExprKind::Call(ref callee, ..) = expr.node {\n+            if let ExprKind::Call(ref callee, ..) = expr.kind {\n                 if callee.hir_id == hir_id {\n                     return\n                 }\n@@ -4968,7 +4968,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         while let hir::Node::Expr(parent_expr) =\n             self.tcx.hir().get(self.tcx.hir().get_parent_node(expr_id))\n         {\n-            match &parent_expr.node {\n+            match &parent_expr.kind {\n                 hir::ExprKind::Assign(lhs, ..) | hir::ExprKind::AssignOp(_, lhs, ..) => {\n                     if lhs.hir_id == expr_id {\n                         contained_in_place = true;"}, {"sha": "53ee0777c7c1d81db03366c22b68556444d17b34", "filename": "src/librustc_typeck/check/pat.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -59,14 +59,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     ) {\n         debug!(\"check_pat(pat={:?},expected={:?},def_bm={:?})\", pat, expected, def_bm);\n \n-        let path_resolution = match &pat.node {\n+        let path_resolution = match &pat.kind {\n             PatKind::Path(qpath) => Some(self.resolve_ty_and_res_ufcs(qpath, pat.hir_id, pat.span)),\n             _ => None,\n         };\n         let is_nrp = self.is_non_ref_pat(pat, path_resolution.map(|(res, ..)| res));\n         let (expected, def_bm) = self.calc_default_binding_mode(pat, expected, def_bm, is_nrp);\n \n-        let ty = match &pat.node {\n+        let ty = match &pat.kind {\n             PatKind::Wild => expected,\n             PatKind::Lit(lt) => self.check_pat_lit(pat.span, lt, expected, discrim_span),\n             PatKind::Range(begin, end, _) => {\n@@ -193,7 +193,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // ```\n             //\n             // See issue #46688.\n-            let def_bm = match pat.node {\n+            let def_bm = match pat.kind {\n                 PatKind::Ref(..) => ty::BindByValue(hir::MutImmutable),\n                 _ => def_bm,\n             };\n@@ -204,7 +204,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// Is the pattern a \"non reference pattern\"?\n     /// When the pattern is a path pattern, `opt_path_res` must be `Some(res)`.\n     fn is_non_ref_pat(&self, pat: &'tcx Pat, opt_path_res: Option<Res>) -> bool {\n-        match pat.node {\n+        match pat.kind {\n             PatKind::Struct(..) |\n             PatKind::TupleStruct(..) |\n             PatKind::Tuple(..) |\n@@ -306,7 +306,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // Byte string patterns behave the same way as array patterns\n         // They can denote both statically and dynamically-sized byte arrays.\n         let mut pat_ty = ty;\n-        if let hir::ExprKind::Lit(ref lt) = lt.node {\n+        if let hir::ExprKind::Lit(ref lt) = lt.kind {\n             if let ast::LitKind::ByteStr(_) = lt.node {\n                 let expected_ty = self.structurally_resolved_type(span, expected);\n                 if let ty::Ref(_, r_ty, _) = expected_ty.kind {\n@@ -472,7 +472,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         expected: Ty<'tcx>,\n     ) {\n         let tcx = self.tcx;\n-        if let PatKind::Binding(..) = inner.node {\n+        if let PatKind::Binding(..) = inner.kind {\n             let binding_parent_id = tcx.hir().get_parent_node(pat.hir_id);\n             let binding_parent = tcx.hir().get(binding_parent_id);\n             debug!(\"inner {:?} pat {:?} parent {:?}\", inner, pat, binding_parent);\n@@ -505,7 +505,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     }\n \n     pub fn check_dereferencable(&self, span: Span, expected: Ty<'tcx>, inner: &Pat) -> bool {\n-        if let PatKind::Binding(..) = inner.node {\n+        if let PatKind::Binding(..) = inner.kind {\n             if let Some(mt) = self.shallow_resolve(expected).builtin_deref(true) {\n                 if let ty::Dynamic(..) = mt.ty.kind {\n                     // This is \"x = SomeTrait\" being reduced from\n@@ -617,7 +617,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                               res.descr(),\n                               hir::print::to_string(tcx.hir(), |s| s.print_qpath(qpath, false)));\n             let mut err = struct_span_err!(tcx.sess, pat.span, E0164, \"{}\", msg);\n-            match (res, &pat.node) {\n+            match (res, &pat.kind) {\n                 (Res::Def(DefKind::Fn, _), _) | (Res::Def(DefKind::Method, _), _) => {\n                     err.span_label(pat.span, \"`fn` calls are not allowed in patterns\");\n                     err.help(\"for more information, visit \\"}, {"sha": "90407780a302d8c4bc32cccfa2fab04a866928b6", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -526,7 +526,7 @@ impl<'a, 'tcx> Visitor<'tcx> for RegionCtxt<'a, 'tcx> {\n         // arguments for its type parameters are well-formed, and all the regions\n         // provided as arguments outlive the call.\n         if is_method_call {\n-            let origin = match expr.node {\n+            let origin = match expr.kind {\n                 hir::ExprKind::MethodCall(..) => infer::ParameterOrigin::MethodCall,\n                 hir::ExprKind::Unary(op, _) if op == hir::UnDeref => {\n                     infer::ParameterOrigin::OverloadedDeref\n@@ -557,7 +557,7 @@ impl<'a, 'tcx> Visitor<'tcx> for RegionCtxt<'a, 'tcx> {\n             \"regionck::visit_expr(e={:?}, repeating_scope={:?}) - visiting subexprs\",\n             expr, self.repeating_scope\n         );\n-        match expr.node {\n+        match expr.kind {\n             hir::ExprKind::Path(_) => {\n                 let substs = self.tables.borrow().node_substs(expr.hir_id);\n                 let origin = infer::ParameterOrigin::Path;\n@@ -1097,7 +1097,7 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n         ignore_err!(self.with_mc(|mc| {\n             mc.cat_pattern(discr_cmt, root_pat, |sub_cmt, sub_pat| {\n                 // `ref x` pattern\n-                if let PatKind::Binding(..) = sub_pat.node {\n+                if let PatKind::Binding(..) = sub_pat.kind {\n                     if let Some(&bm) = mc.tables.pat_binding_modes().get(sub_pat.hir_id) {\n                         if let ty::BindByReference(mutbl) = bm {\n                             self.link_region_from_node_type("}, {"sha": "71ea938a8039b6da15b1fe3472a9e1e931bfcb92", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -64,7 +64,7 @@ impl<'a, 'tcx> Visitor<'tcx> for InferBorrowKindVisitor<'a, 'tcx> {\n     }\n \n     fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n-        if let hir::ExprKind::Closure(cc, _, body_id, _, _) = expr.node {\n+        if let hir::ExprKind::Closure(cc, _, body_id, _, _) = expr.kind {\n             let body = self.fcx.tcx.hir().body(body_id);\n             self.visit_body(body);\n             self.fcx"}, {"sha": "f4ba9fc03d3d071638f21ca8f02c70b2844505f5", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -76,7 +76,7 @@ pub fn check_item_well_formed(tcx: TyCtxt<'_>, def_id: DefId) {\n            item.hir_id,\n            tcx.def_path_str(def_id));\n \n-    match item.node {\n+    match item.kind {\n         // Right now we check that every default trait implementation\n         // has an implementation of itself. Basically, a case like:\n         //\n@@ -128,7 +128,7 @@ pub fn check_item_well_formed(tcx: TyCtxt<'_>, def_id: DefId) {\n             check_item_type(tcx, item.hir_id, ty.span, false);\n         }\n         hir::ItemKind::ForeignMod(ref module) => for it in module.items.iter() {\n-            if let hir::ForeignItemKind::Static(ref ty, ..) = it.node {\n+            if let hir::ForeignItemKind::Static(ref ty, ..) = it.kind {\n                 check_item_type(tcx, it.hir_id, ty.span, true);\n             }\n         },\n@@ -167,7 +167,7 @@ pub fn check_trait_item(tcx: TyCtxt<'_>, def_id: DefId) {\n     let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n     let trait_item = tcx.hir().expect_trait_item(hir_id);\n \n-    let method_sig = match trait_item.node {\n+    let method_sig = match trait_item.kind {\n         hir::TraitItemKind::Method(ref sig, _) => Some(sig),\n         _ => None\n     };\n@@ -178,7 +178,7 @@ pub fn check_impl_item(tcx: TyCtxt<'_>, def_id: DefId) {\n     let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n     let impl_item = tcx.hir().expect_impl_item(hir_id);\n \n-    let method_sig = match impl_item.node {\n+    let method_sig = match impl_item.kind {\n         hir::ImplItemKind::Method(ref sig, _) => Some(sig),\n         _ => None\n     };\n@@ -299,7 +299,7 @@ fn check_type_defn<'tcx, F>(\n                         field.span,\n                         fcx.body_id,\n                         traits::FieldSized {\n-                            adt_kind: match item.node.adt_kind() {\n+                            adt_kind: match item.kind.adt_kind() {\n                                 Some(i) => i,\n                                 None => bug!(),\n                             },"}, {"sha": "de78c1cdfaba3ab27718ed78e4ebc4384ffd1ee3", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -134,7 +134,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n     // we observe that something like `a+b` is (known to be)\n     // operating on scalars, we clear the overload.\n     fn fix_scalar_builtin_expr(&mut self, e: &hir::Expr) {\n-        match e.node {\n+        match e.kind {\n             hir::ExprKind::Unary(hir::UnNeg, ref inner)\n             | hir::ExprKind::Unary(hir::UnNot, ref inner) => {\n                 let inner_ty = self.fcx.node_ty(inner.hir_id);\n@@ -159,7 +159,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n                     tables.type_dependent_defs_mut().remove(e.hir_id);\n                     tables.node_substs_mut().remove(e.hir_id);\n \n-                    match e.node {\n+                    match e.kind {\n                         hir::ExprKind::Binary(..) => {\n                             if !op.node.is_by_value() {\n                                 let mut adjustments = tables.adjustments_mut();\n@@ -186,7 +186,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n     // to use builtin indexing because the index type is known to be\n     // usize-ish\n     fn fix_index_builtin_expr(&mut self, e: &hir::Expr) {\n-        if let hir::ExprKind::Index(ref base, ref index) = e.node {\n+        if let hir::ExprKind::Index(ref base, ref index) = e.kind {\n             let mut tables = self.fcx.tables.borrow_mut();\n \n             // All valid indexing looks like this; might encounter non-valid indexes at this point\n@@ -241,7 +241,7 @@ impl<'cx, 'tcx> Visitor<'tcx> for WritebackCx<'cx, 'tcx> {\n \n         self.visit_node_id(e.span, e.hir_id);\n \n-        match e.node {\n+        match e.kind {\n             hir::ExprKind::Closure(_, _, body, _, _) => {\n                 let body = self.fcx.tcx.hir().body(body);\n                 for param in &body.params {\n@@ -270,7 +270,7 @@ impl<'cx, 'tcx> Visitor<'tcx> for WritebackCx<'cx, 'tcx> {\n     }\n \n     fn visit_pat(&mut self, p: &'tcx hir::Pat) {\n-        match p.node {\n+        match p.kind {\n             hir::PatKind::Binding(..) => {\n                 if let Some(&bm) = self.fcx.tables.borrow().pat_binding_modes().get(p.hir_id) {\n                     self.tables.pat_binding_modes_mut().insert(p.hir_id, bm);"}, {"sha": "7af1a342ff36edd98b532739407c13aa4910aae7", "filename": "src/librustc_typeck/check_unused.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_typeck%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_typeck%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck_unused.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -33,7 +33,7 @@ impl ItemLikeVisitor<'v> for CheckVisitor<'tcx> {\n         if item.vis.node.is_pub() || item.span.is_dummy() {\n             return;\n         }\n-        if let hir::ItemKind::Use(ref path, _) = item.node {\n+        if let hir::ItemKind::Use(ref path, _) = item.kind {\n             self.check_import(item.hir_id, path.span);\n         }\n     }\n@@ -218,7 +218,7 @@ struct ExternCrateToLint {\n \n impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for CollectExternCrateVisitor<'a, 'tcx> {\n     fn visit_item(&mut self, item: &hir::Item) {\n-        if let hir::ItemKind::ExternCrate(orig_name) = item.node {\n+        if let hir::ItemKind::ExternCrate(orig_name) = item.kind {\n             let extern_crate_def_id = self.tcx.hir().local_def_id(item.hir_id);\n             self.crates_to_lint.push(\n                 ExternCrateToLint {"}, {"sha": "64bd144dfa226103b652ebe9ccb2c7021b7bc29b", "filename": "src/librustc_typeck/coherence/builtin.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -53,7 +53,7 @@ fn visit_implementation_of_drop(tcx: TyCtxt<'_>, impl_did: DefId) {\n         // Destructors only work on nominal types.\n         if let Some(impl_hir_id) = tcx.hir().as_local_hir_id(impl_did) {\n             if let Some(Node::Item(item)) = tcx.hir().find(impl_hir_id) {\n-                let span = match item.node {\n+                let span = match item.kind {\n                     ItemKind::Impl(.., ref ty, _) => ty.span,\n                     _ => item.span,\n                 };\n@@ -99,7 +99,7 @@ fn visit_implementation_of_copy(tcx: TyCtxt<'_>, impl_did: DefId) {\n         Ok(()) => {}\n         Err(CopyImplementationError::InfrigingFields(fields)) => {\n             let item = tcx.hir().expect_item(impl_hir_id);\n-            let span = if let ItemKind::Impl(.., Some(ref tr), _, _) = item.node {\n+            let span = if let ItemKind::Impl(.., Some(ref tr), _, _) = item.kind {\n                 tr.path.span\n             } else {\n                 span\n@@ -116,7 +116,7 @@ fn visit_implementation_of_copy(tcx: TyCtxt<'_>, impl_did: DefId) {\n         }\n         Err(CopyImplementationError::NotAnAdt) => {\n             let item = tcx.hir().expect_item(impl_hir_id);\n-            let span = if let ItemKind::Impl(.., ref ty, _) = item.node {\n+            let span = if let ItemKind::Impl(.., ref ty, _) = item.kind {\n                 ty.span\n             } else {\n                 span\n@@ -481,7 +481,7 @@ pub fn coerce_unsized_info<'tcx>(gcx: TyCtxt<'tcx>, impl_did: DefId) -> CoerceUn\n                     return err_info;\n                 } else if diff_fields.len() > 1 {\n                     let item = gcx.hir().expect_item(impl_hir_id);\n-                    let span = if let ItemKind::Impl(.., Some(ref t), _, _) = item.node {\n+                    let span = if let ItemKind::Impl(.., Some(ref t), _, _) = item.kind {\n                         t.path.span\n                     } else {\n                         gcx.hir().span(impl_hir_id)"}, {"sha": "90cedb455e3dd11f8e30bf9b3338056ee7b4fd69", "filename": "src/librustc_typeck/coherence/inherent_impls.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -49,7 +49,7 @@ struct InherentCollect<'tcx> {\n \n impl ItemLikeVisitor<'v> for InherentCollect<'tcx> {\n     fn visit_item(&mut self, item: &hir::Item) {\n-        let ty = match item.node {\n+        let ty = match item.kind {\n             hir::ItemKind::Impl(.., None, ref ty, _) => ty,\n             _ => return\n         };"}, {"sha": "0aae8fbe131781862d2b9292cc9cae585d083332", "filename": "src/librustc_typeck/coherence/inherent_impls_overlap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -84,7 +84,7 @@ impl InherentOverlapChecker<'tcx> {\n \n impl ItemLikeVisitor<'v> for InherentOverlapChecker<'tcx> {\n     fn visit_item(&mut self, item: &'v hir::Item) {\n-        match item.node {\n+        match item.kind {\n             hir::ItemKind::Enum(..) |\n             hir::ItemKind::Struct(..) |\n             hir::ItemKind::Trait(..) |"}, {"sha": "667fa50a7cfa4c79a6953ef08b969a5feb893b0b", "filename": "src/librustc_typeck/coherence/orphan.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -24,7 +24,7 @@ impl ItemLikeVisitor<'v> for OrphanChecker<'tcx> {\n     fn visit_item(&mut self, item: &hir::Item) {\n         let def_id = self.tcx.hir().local_def_id(item.hir_id);\n         // \"Trait\" impl\n-        if let hir::ItemKind::Impl(.., Some(_), _, _) = item.node {\n+        if let hir::ItemKind::Impl(.., Some(_), _, _) = item.kind {\n             debug!(\"coherence2::orphan check: trait impl {}\",\n                    self.tcx.hir().node_to_string(item.hir_id));\n             let trait_ref = self.tcx.impl_trait_ref(def_id).unwrap();"}, {"sha": "b7cc6feee4453eee521e79f823dea7b4ee002965", "filename": "src/librustc_typeck/coherence/unsafety.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -71,7 +71,7 @@ impl UnsafetyChecker<'tcx> {\n \n impl ItemLikeVisitor<'v> for UnsafetyChecker<'tcx> {\n     fn visit_item(&mut self, item: &'v hir::Item) {\n-        if let hir::ItemKind::Impl(unsafety, polarity, _, ref generics, ..) = item.node {\n+        if let hir::ItemKind::Impl(unsafety, polarity, _, ref generics, ..) = item.kind {\n             self.check_unsafety_coherence(item, Some(generics), unsafety, polarity);\n         }\n     }"}, {"sha": "3ac3ce2a02c2e9c51437b7e22f2429cac885d1fe", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 59, "deletions": 59, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -135,7 +135,7 @@ impl Visitor<'tcx> for CollectItemTypesVisitor<'tcx> {\n     }\n \n     fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n-        if let hir::ExprKind::Closure(..) = expr.node {\n+        if let hir::ExprKind::Closure(..) = expr.kind {\n             let def_id = self.tcx.hir().local_def_id(expr.hir_id);\n             self.tcx.generics_of(def_id);\n             self.tcx.type_of(def_id);\n@@ -288,7 +288,7 @@ fn type_param_predicates(\n         Node::ImplItem(item) => &item.generics,\n \n         Node::Item(item) => {\n-            match item.node {\n+            match item.kind {\n                 ItemKind::Fn(.., ref generics, _)\n                 | ItemKind::Impl(_, _, _, ref generics, ..)\n                 | ItemKind::TyAlias(_, ref generics)\n@@ -312,7 +312,7 @@ fn type_param_predicates(\n             }\n         }\n \n-        Node::ForeignItem(item) => match item.node {\n+        Node::ForeignItem(item) => match item.kind {\n             ForeignItemKind::Fn(_, _, ref generics) => generics,\n             _ => return result,\n         },\n@@ -387,7 +387,7 @@ impl ItemCtxt<'tcx> {\n /// `ast_ty_to_ty`, because we want to avoid triggering an all-out\n /// conversion of the type to avoid inducing unnecessary cycles.\n fn is_param(tcx: TyCtxt<'_>, ast_ty: &hir::Ty, param_id: hir::HirId) -> bool {\n-    if let hir::TyKind::Path(hir::QPath::Resolved(None, ref path)) = ast_ty.node {\n+    if let hir::TyKind::Path(hir::QPath::Resolved(None, ref path)) = ast_ty.kind {\n         match path.res {\n             Res::SelfTy(Some(def_id), None) | Res::Def(DefKind::TyParam, def_id) => {\n                 def_id == tcx.hir().local_def_id(param_id)\n@@ -403,7 +403,7 @@ fn convert_item(tcx: TyCtxt<'_>, item_id: hir::HirId) {\n     let it = tcx.hir().expect_item(item_id);\n     debug!(\"convert: item {} with id {}\", it.ident, it.hir_id);\n     let def_id = tcx.hir().local_def_id(item_id);\n-    match it.node {\n+    match it.kind {\n         // These don't define types.\n         hir::ItemKind::ExternCrate(_)\n         | hir::ItemKind::Use(..)\n@@ -415,7 +415,7 @@ fn convert_item(tcx: TyCtxt<'_>, item_id: hir::HirId) {\n                 tcx.generics_of(def_id);\n                 tcx.type_of(def_id);\n                 tcx.predicates_of(def_id);\n-                if let hir::ForeignItemKind::Fn(..) = item.node {\n+                if let hir::ForeignItemKind::Fn(..) = item.kind {\n                     tcx.fn_sig(def_id);\n                 }\n             }\n@@ -474,7 +474,7 @@ fn convert_item(tcx: TyCtxt<'_>, item_id: hir::HirId) {\n             tcx.generics_of(def_id);\n             tcx.type_of(def_id);\n             tcx.predicates_of(def_id);\n-            if let hir::ItemKind::Fn(..) = it.node {\n+            if let hir::ItemKind::Fn(..) = it.kind {\n                 tcx.fn_sig(def_id);\n             }\n         }\n@@ -486,12 +486,12 @@ fn convert_trait_item(tcx: TyCtxt<'_>, trait_item_id: hir::HirId) {\n     let def_id = tcx.hir().local_def_id(trait_item.hir_id);\n     tcx.generics_of(def_id);\n \n-    match trait_item.node {\n+    match trait_item.kind {\n         hir::TraitItemKind::Const(..)\n         | hir::TraitItemKind::Type(_, Some(_))\n         | hir::TraitItemKind::Method(..) => {\n             tcx.type_of(def_id);\n-            if let hir::TraitItemKind::Method(..) = trait_item.node {\n+            if let hir::TraitItemKind::Method(..) = trait_item.kind {\n                 tcx.fn_sig(def_id);\n             }\n         }\n@@ -507,7 +507,7 @@ fn convert_impl_item(tcx: TyCtxt<'_>, impl_item_id: hir::HirId) {\n     tcx.generics_of(def_id);\n     tcx.type_of(def_id);\n     tcx.predicates_of(def_id);\n-    if let hir::ImplItemKind::Method(..) = tcx.hir().expect_impl_item(impl_item_id).node {\n+    if let hir::ImplItemKind::Method(..) = tcx.hir().expect_impl_item(impl_item_id).kind {\n         tcx.fn_sig(def_id);\n     }\n }\n@@ -638,7 +638,7 @@ fn adt_def(tcx: TyCtxt<'_>, def_id: DefId) -> &ty::AdtDef {\n     };\n \n     let repr = ReprOptions::new(tcx, def_id);\n-    let (kind, variants) = match item.node {\n+    let (kind, variants) = match item.kind {\n         ItemKind::Enum(ref def, _) => {\n             let mut distance_from_explicit = 0;\n             let variants = def.variants\n@@ -707,7 +707,7 @@ fn super_predicates_of(\n         _ => bug!(\"trait_node_id {} is not an item\", trait_hir_id),\n     };\n \n-    let (generics, bounds) = match item.node {\n+    let (generics, bounds) = match item.kind {\n         hir::ItemKind::Trait(.., ref generics, ref supertraits, _) => (generics, supertraits),\n         hir::ItemKind::TraitAlias(ref generics, ref supertraits) => (generics, supertraits),\n         _ => span_bug!(item.span, \"super_predicates invoked on non-trait\"),\n@@ -753,7 +753,7 @@ fn trait_def(tcx: TyCtxt<'_>, def_id: DefId) -> &ty::TraitDef {\n     let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n     let item = tcx.hir().expect_item(hir_id);\n \n-    let (is_auto, unsafety) = match item.node {\n+    let (is_auto, unsafety) = match item.kind {\n         hir::ItemKind::Trait(is_auto, unsafety, ..) => (is_auto == hir::IsAuto::Yes, unsafety),\n         hir::ItemKind::TraitAlias(..) => (false, hir::Unsafety::Normal),\n         _ => span_bug!(item.span, \"trait_def_of_item invoked on non-trait\"),\n@@ -796,7 +796,7 @@ fn has_late_bound_regions<'tcx>(tcx: TyCtxt<'tcx>, node: Node<'tcx>) -> Option<S\n             if self.has_late_bound_regions.is_some() {\n                 return;\n             }\n-            match ty.node {\n+            match ty.kind {\n                 hir::TyKind::BareFn(..) => {\n                     self.outer_index.shift_in(1);\n                     intravisit::walk_ty(self, ty);\n@@ -860,25 +860,25 @@ fn has_late_bound_regions<'tcx>(tcx: TyCtxt<'tcx>, node: Node<'tcx>) -> Option<S\n     }\n \n     match node {\n-        Node::TraitItem(item) => match item.node {\n+        Node::TraitItem(item) => match item.kind {\n             hir::TraitItemKind::Method(ref sig, _) => {\n                 has_late_bound_regions(tcx, &item.generics, &sig.decl)\n             }\n             _ => None,\n         },\n-        Node::ImplItem(item) => match item.node {\n+        Node::ImplItem(item) => match item.kind {\n             hir::ImplItemKind::Method(ref sig, _) => {\n                 has_late_bound_regions(tcx, &item.generics, &sig.decl)\n             }\n             _ => None,\n         },\n-        Node::ForeignItem(item) => match item.node {\n+        Node::ForeignItem(item) => match item.kind {\n             hir::ForeignItemKind::Fn(ref fn_decl, _, ref generics) => {\n                 has_late_bound_regions(tcx, generics, fn_decl)\n             }\n             _ => None,\n         },\n-        Node::Item(item) => match item.node {\n+        Node::Item(item) => match item.kind {\n             hir::ItemKind::Fn(ref fn_decl, .., ref generics, _) => {\n                 has_late_bound_regions(tcx, generics, fn_decl)\n             }\n@@ -915,10 +915,10 @@ fn generics_of(tcx: TyCtxt<'_>, def_id: DefId) -> &ty::Generics {\n             }\n         }\n         Node::Expr(&hir::Expr {\n-            node: hir::ExprKind::Closure(..),\n+            kind: hir::ExprKind::Closure(..),\n             ..\n         }) => Some(tcx.closure_base_def_id(def_id)),\n-        Node::Item(item) => match item.node {\n+        Node::Item(item) => match item.kind {\n             ItemKind::OpaqueTy(hir::OpaqueTy { impl_trait_fn, .. }) => impl_trait_fn,\n             _ => None,\n         },\n@@ -935,7 +935,7 @@ fn generics_of(tcx: TyCtxt<'_>, def_id: DefId) -> &ty::Generics {\n         Node::ImplItem(item) => &item.generics,\n \n         Node::Item(item) => {\n-            match item.node {\n+            match item.kind {\n                 ItemKind::Fn(.., ref generics, _) | ItemKind::Impl(_, _, _, ref generics, ..) => {\n                     generics\n                 }\n@@ -977,7 +977,7 @@ fn generics_of(tcx: TyCtxt<'_>, def_id: DefId) -> &ty::Generics {\n             }\n         }\n \n-        Node::ForeignItem(item) => match item.node {\n+        Node::ForeignItem(item) => match item.kind {\n             ForeignItemKind::Static(..) => &no_generics,\n             ForeignItemKind::Fn(_, _, ref generics) => generics,\n             ForeignItemKind::Type => &no_generics,\n@@ -1072,7 +1072,7 @@ fn generics_of(tcx: TyCtxt<'_>, def_id: DefId) -> &ty::Generics {\n     // cares about anything but the length is instantiation,\n     // and we don't do that for closures.\n     if let Node::Expr(&hir::Expr {\n-        node: hir::ExprKind::Closure(.., gen),\n+        kind: hir::ExprKind::Closure(.., gen),\n         ..\n     }) = node\n     {\n@@ -1207,14 +1207,14 @@ pub fn checked_type_of(tcx: TyCtxt<'_>, def_id: DefId, fail: bool) -> Option<Ty<\n     let icx = ItemCtxt::new(tcx, def_id);\n \n     Some(match tcx.hir().get(hir_id) {\n-        Node::TraitItem(item) => match item.node {\n+        Node::TraitItem(item) => match item.kind {\n             TraitItemKind::Method(..) => {\n                 let substs = InternalSubsts::identity_for_item(tcx, def_id);\n                 tcx.mk_fn_def(def_id, substs)\n             }\n             TraitItemKind::Const(ref ty, body_id)  => {\n                 body_id.and_then(|body_id| {\n-                    if let hir::TyKind::Infer = ty.node {\n+                    if let hir::TyKind::Infer = ty.kind {\n                         Some(infer_placeholder_type(tcx, def_id, body_id, ty.span, item.ident))\n                     } else {\n                         None\n@@ -1230,13 +1230,13 @@ pub fn checked_type_of(tcx: TyCtxt<'_>, def_id: DefId, fail: bool) -> Option<Ty<\n             }\n         },\n \n-        Node::ImplItem(item) => match item.node {\n+        Node::ImplItem(item) => match item.kind {\n             ImplItemKind::Method(..) => {\n                 let substs = InternalSubsts::identity_for_item(tcx, def_id);\n                 tcx.mk_fn_def(def_id, substs)\n             }\n             ImplItemKind::Const(ref ty, body_id) => {\n-                if let hir::TyKind::Infer = ty.node {\n+                if let hir::TyKind::Infer = ty.kind {\n                     infer_placeholder_type(tcx, def_id, body_id, ty.span, item.ident)\n                 } else {\n                     icx.to_ty(ty)\n@@ -1265,10 +1265,10 @@ pub fn checked_type_of(tcx: TyCtxt<'_>, def_id: DefId, fail: bool) -> Option<Ty<\n         },\n \n         Node::Item(item) => {\n-            match item.node {\n+            match item.kind {\n                 ItemKind::Static(ref ty, .., body_id)\n                 | ItemKind::Const(ref ty, body_id) => {\n-                    if let hir::TyKind::Infer = ty.node {\n+                    if let hir::TyKind::Infer = ty.kind {\n                         infer_placeholder_type(tcx, def_id, body_id, ty.span, item.ident)\n                     } else {\n                         icx.to_ty(ty)\n@@ -1325,13 +1325,13 @@ pub fn checked_type_of(tcx: TyCtxt<'_>, def_id: DefId, fail: bool) -> Option<Ty<\n                     span_bug!(\n                         item.span,\n                         \"compute_type_of_item: unexpected item type: {:?}\",\n-                        item.node\n+                        item.kind\n                     );\n                 }\n             }\n         }\n \n-        Node::ForeignItem(foreign_item) => match foreign_item.node {\n+        Node::ForeignItem(foreign_item) => match foreign_item.kind {\n             ForeignItemKind::Fn(..) => {\n                 let substs = InternalSubsts::identity_for_item(tcx, def_id);\n                 tcx.mk_fn_def(def_id, substs)\n@@ -1355,7 +1355,7 @@ pub fn checked_type_of(tcx: TyCtxt<'_>, def_id: DefId, fail: bool) -> Option<Ty<\n         Node::Field(field) => icx.to_ty(&field.ty),\n \n         Node::Expr(&hir::Expr {\n-            node: hir::ExprKind::Closure(.., gen),\n+            kind: hir::ExprKind::Closure(.., gen),\n             ..\n         }) => {\n             if gen.is_some() {\n@@ -1373,15 +1373,15 @@ pub fn checked_type_of(tcx: TyCtxt<'_>, def_id: DefId, fail: bool) -> Option<Ty<\n             let parent_node = tcx.hir().get(tcx.hir().get_parent_node(hir_id));\n             match parent_node {\n                 Node::Ty(&hir::Ty {\n-                    node: hir::TyKind::Array(_, ref constant),\n+                    kind: hir::TyKind::Array(_, ref constant),\n                     ..\n                 })\n                 | Node::Ty(&hir::Ty {\n-                    node: hir::TyKind::Typeof(ref constant),\n+                    kind: hir::TyKind::Typeof(ref constant),\n                     ..\n                 })\n                 | Node::Expr(&hir::Expr {\n-                    node: ExprKind::Repeat(_, ref constant),\n+                    kind: ExprKind::Repeat(_, ref constant),\n                     ..\n                 }) if constant.hir_id == hir_id =>\n                 {\n@@ -1399,22 +1399,22 @@ pub fn checked_type_of(tcx: TyCtxt<'_>, def_id: DefId, fail: bool) -> Option<Ty<\n                         .to_ty(tcx)\n                 }\n \n-                Node::Ty(&hir::Ty { node: hir::TyKind::Path(_), .. }) |\n-                Node::Expr(&hir::Expr { node: ExprKind::Struct(..), .. }) |\n-                Node::Expr(&hir::Expr { node: ExprKind::Path(_), .. }) |\n+                Node::Ty(&hir::Ty { kind: hir::TyKind::Path(_), .. }) |\n+                Node::Expr(&hir::Expr { kind: ExprKind::Struct(..), .. }) |\n+                Node::Expr(&hir::Expr { kind: ExprKind::Path(_), .. }) |\n                 Node::TraitRef(..) => {\n                     let path = match parent_node {\n                         Node::Ty(&hir::Ty {\n-                            node: hir::TyKind::Path(QPath::Resolved(_, ref path)),\n+                            kind: hir::TyKind::Path(QPath::Resolved(_, ref path)),\n                             ..\n                         })\n                         | Node::Expr(&hir::Expr {\n-                            node: ExprKind::Path(QPath::Resolved(_, ref path)),\n+                            kind: ExprKind::Path(QPath::Resolved(_, ref path)),\n                             ..\n                         }) => {\n                             Some(&**path)\n                         }\n-                        Node::Expr(&hir::Expr { node: ExprKind::Struct(ref path, ..), .. }) => {\n+                        Node::Expr(&hir::Expr { kind: ExprKind::Struct(ref path, ..), .. }) => {\n                             if let QPath::Resolved(_, ref path) = **path {\n                                 Some(&**path)\n                             } else {\n@@ -1769,7 +1769,7 @@ fn find_opaque_ty_constraints(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n \n pub fn get_infer_ret_ty(output: &'_ hir::FunctionRetTy) -> Option<&hir::Ty> {\n     if let hir::FunctionRetTy::Return(ref ty) = output {\n-        if let hir::TyKind::Infer = ty.node {\n+        if let hir::TyKind::Infer = ty.kind {\n             return Some(&**ty)\n         }\n     }\n@@ -1786,15 +1786,15 @@ fn fn_sig(tcx: TyCtxt<'_>, def_id: DefId) -> ty::PolyFnSig<'_> {\n \n     match tcx.hir().get(hir_id) {\n         TraitItem(hir::TraitItem {\n-            node: TraitItemKind::Method(MethodSig { header, decl }, TraitMethod::Provided(_)),\n+            kind: TraitItemKind::Method(MethodSig { header, decl }, TraitMethod::Provided(_)),\n             ..\n         })\n         | ImplItem(hir::ImplItem {\n-            node: ImplItemKind::Method(MethodSig { header, decl }, _),\n+            kind: ImplItemKind::Method(MethodSig { header, decl }, _),\n             ..\n         })\n         | Item(hir::Item {\n-            node: ItemKind::Fn(decl, header, _, _),\n+            kind: ItemKind::Fn(decl, header, _, _),\n             ..\n         }) => match get_infer_ret_ty(&decl.output) {\n             Some(ty) => {\n@@ -1816,14 +1816,14 @@ fn fn_sig(tcx: TyCtxt<'_>, def_id: DefId) -> ty::PolyFnSig<'_> {\n         },\n \n         TraitItem(hir::TraitItem {\n-            node: TraitItemKind::Method(MethodSig { header, decl }, _),\n+            kind: TraitItemKind::Method(MethodSig { header, decl }, _),\n             ..\n         }) => {\n             AstConv::ty_of_fn(&icx, header.unsafety, header.abi, decl)\n         },\n \n         ForeignItem(&hir::ForeignItem {\n-            node: ForeignItemKind::Fn(ref fn_decl, _, _),\n+            kind: ForeignItemKind::Fn(ref fn_decl, _, _),\n             ..\n         }) => {\n             let abi = tcx.hir().get_foreign_abi(hir_id);\n@@ -1847,7 +1847,7 @@ fn fn_sig(tcx: TyCtxt<'_>, def_id: DefId) -> ty::PolyFnSig<'_> {\n         }\n \n         Expr(&hir::Expr {\n-            node: hir::ExprKind::Closure(..),\n+            kind: hir::ExprKind::Closure(..),\n             ..\n         }) => {\n             // Closure signatures are not like other function\n@@ -1878,7 +1878,7 @@ fn impl_trait_ref(tcx: TyCtxt<'_>, def_id: DefId) -> Option<ty::TraitRef<'_>> {\n     let icx = ItemCtxt::new(tcx, def_id);\n \n     let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n-    match tcx.hir().expect_item(hir_id).node {\n+    match tcx.hir().expect_item(hir_id).kind {\n         hir::ItemKind::Impl(.., ref opt_trait_ref, _, _) => {\n             opt_trait_ref.as_ref().map(|ast_trait_ref| {\n                 let selfty = tcx.type_of(def_id);\n@@ -1893,7 +1893,7 @@ fn impl_polarity(tcx: TyCtxt<'_>, def_id: DefId) -> ty::ImplPolarity {\n     let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n     let is_rustc_reservation = tcx.has_attr(def_id, sym::rustc_reservation_impl);\n     let item = tcx.hir().expect_item(hir_id);\n-    match &item.node {\n+    match &item.kind {\n         hir::ItemKind::Impl(_, hir::ImplPolarity::Negative, ..) => {\n             if is_rustc_reservation {\n                 tcx.sess.span_err(item.span, \"reservation impls can't be negative\");\n@@ -2055,7 +2055,7 @@ fn explicit_predicates_of(\n     let ast_generics = match node {\n         Node::TraitItem(item) => &item.generics,\n \n-        Node::ImplItem(item) => match item.node {\n+        Node::ImplItem(item) => match item.kind {\n             ImplItemKind::OpaqueTy(ref bounds) => {\n                 let substs = InternalSubsts::identity_for_item(tcx, def_id);\n                 let opaque_ty = tcx.mk_opaque(def_id, substs);\n@@ -2076,7 +2076,7 @@ fn explicit_predicates_of(\n         },\n \n         Node::Item(item) => {\n-            match item.node {\n+            match item.kind {\n                 ItemKind::Impl(_, _, defaultness, ref generics, ..) => {\n                     if defaultness.is_default() {\n                         is_default_impl_trait = tcx.impl_trait_ref(def_id);\n@@ -2133,7 +2133,7 @@ fn explicit_predicates_of(\n             }\n         }\n \n-        Node::ForeignItem(item) => match item.node {\n+        Node::ForeignItem(item) => match item.kind {\n             ForeignItemKind::Static(..) => NO_GENERICS,\n             ForeignItemKind::Fn(_, _, ref generics) => generics,\n             ForeignItemKind::Type => NO_GENERICS,\n@@ -2281,7 +2281,7 @@ fn explicit_predicates_of(\n     if let Some((self_trait_ref, trait_items)) = is_trait {\n         predicates.extend(trait_items.iter().flat_map(|trait_item_ref| {\n             let trait_item = tcx.hir().trait_item(trait_item_ref.id);\n-            let bounds = match trait_item.node {\n+            let bounds = match trait_item.kind {\n                 hir::TraitItemKind::Type(ref bounds, _) => bounds,\n                 _ => return Vec::new().into_iter()\n             };\n@@ -2310,7 +2310,7 @@ fn explicit_predicates_of(\n     // in trait checking. See `setup_constraining_predicates`\n     // for details.\n     if let Node::Item(&Item {\n-        node: ItemKind::Impl(..),\n+        kind: ItemKind::Impl(..),\n         ..\n     }) = node\n     {\n@@ -2417,10 +2417,10 @@ fn is_foreign_item(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n fn static_mutability(tcx: TyCtxt<'_>, def_id: DefId) -> Option<hir::Mutability> {\n     match tcx.hir().get_if_local(def_id) {\n         Some(Node::Item(&hir::Item {\n-            node: hir::ItemKind::Static(_, mutbl, _), ..\n+            kind: hir::ItemKind::Static(_, mutbl, _), ..\n         })) |\n         Some(Node::ForeignItem( &hir::ForeignItem {\n-            node: hir::ForeignItemKind::Static(_, mutbl), ..\n+            kind: hir::ForeignItemKind::Static(_, mutbl), ..\n         })) => Some(mutbl),\n         Some(_) => None,\n         _ => bug!(\"static_mutability applied to non-local def-id {:?}\", def_id),\n@@ -2653,7 +2653,7 @@ fn codegen_fn_attrs(tcx: TyCtxt<'_>, id: DefId) -> CodegenFnAttrs {\n         if attr.path != sym::inline {\n             return ia;\n         }\n-        match attr.meta().map(|i| i.node) {\n+        match attr.meta().map(|i| i.kind) {\n             Some(MetaItemKind::Word) => {\n                 mark_used(attr);\n                 InlineAttr::Hint\n@@ -2694,7 +2694,7 @@ fn codegen_fn_attrs(tcx: TyCtxt<'_>, id: DefId) -> CodegenFnAttrs {\n             return ia;\n         }\n         let err = |sp, s| span_err!(tcx.sess.diagnostic(), sp, E0722, \"{}\", s);\n-        match attr.meta().map(|i| i.node) {\n+        match attr.meta().map(|i| i.kind) {\n             Some(MetaItemKind::Word) => {\n                 err(attr.span, \"expected one argument\");\n                 ia"}, {"sha": "ab660caa222ae800a49364888288c5ba4f29fbca", "filename": "src/librustc_typeck/impl_wf_check.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_typeck%2Fimpl_wf_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_typeck%2Fimpl_wf_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fimpl_wf_check.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -78,7 +78,7 @@ struct ImplWfCheck<'tcx> {\n \n impl ItemLikeVisitor<'tcx> for ImplWfCheck<'tcx> {\n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n-        if let hir::ItemKind::Impl(.., ref impl_item_refs) = item.node {\n+        if let hir::ItemKind::Impl(.., ref impl_item_refs) = item.kind {\n             let impl_def_id = self.tcx.hir().local_def_id(item.hir_id);\n             enforce_impl_params_are_constrained(self.tcx,\n                                                 impl_def_id,\n@@ -197,7 +197,7 @@ fn enforce_impl_items_are_distinct(tcx: TyCtxt<'_>, impl_item_refs: &[hir::ImplI\n     let mut seen_value_items = FxHashMap::default();\n     for impl_item_ref in impl_item_refs {\n         let impl_item = tcx.hir().impl_item(impl_item_ref.id);\n-        let seen_items = match impl_item.node {\n+        let seen_items = match impl_item.kind {\n             hir::ImplItemKind::TyAlias(_) => &mut seen_type_items,\n             _                          => &mut seen_value_items,\n         };"}, {"sha": "00be1c84599a355563e2feb8b205eb3b302334e3", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -162,7 +162,7 @@ fn check_main_fn_ty(tcx: TyCtxt<'_>, main_def_id: DefId) {\n     match main_t.kind {\n         ty::FnDef(..) => {\n             if let Some(Node::Item(it)) = tcx.hir().find(main_id) {\n-                if let hir::ItemKind::Fn(.., ref generics, _) = it.node {\n+                if let hir::ItemKind::Fn(.., ref generics, _) = it.kind {\n                     let mut error = false;\n                     if !generics.params.is_empty() {\n                         let msg = \"`main` function is not allowed to have generic \\\n@@ -227,7 +227,7 @@ fn check_start_fn_ty(tcx: TyCtxt<'_>, start_def_id: DefId) {\n     match start_t.kind {\n         ty::FnDef(..) => {\n             if let Some(Node::Item(it)) = tcx.hir().find(start_id) {\n-                if let hir::ItemKind::Fn(.., ref generics, _) = it.node {\n+                if let hir::ItemKind::Fn(.., ref generics, _) = it.kind {\n                     let mut error = false;\n                     if !generics.params.is_empty() {\n                         struct_span_err!(tcx.sess, generics.span, E0132,"}, {"sha": "433d04ffa64ff93ebe9f7e0dddfb16f6716092e6", "filename": "src/librustc_typeck/outlives/implicit_infer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_typeck%2Foutlives%2Fimplicit_infer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_typeck%2Foutlives%2Fimplicit_infer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Foutlives%2Fimplicit_infer.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -66,7 +66,7 @@ impl<'cx, 'tcx> ItemLikeVisitor<'tcx> for InferVisitor<'cx, 'tcx> {\n         };\n \n         let mut item_required_predicates = RequiredPredicates::default();\n-        match item.node {\n+        match item.kind {\n             hir::ItemKind::Union(..) | hir::ItemKind::Enum(..) | hir::ItemKind::Struct(..) => {\n                 let adt_def = self.tcx.adt_def(item_did);\n "}, {"sha": "cdb83eb328ac23ca27facfab41ac5b832d3b7b5c", "filename": "src/librustc_typeck/outlives/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_typeck%2Foutlives%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_typeck%2Foutlives%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Foutlives%2Fmod.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -30,7 +30,7 @@ fn inferred_outlives_of(\n         .expect(\"expected local def-id\");\n \n     match tcx.hir().get(id) {\n-        Node::Item(item) => match item.node {\n+        Node::Item(item) => match item.kind {\n             hir::ItemKind::Struct(..) | hir::ItemKind::Enum(..) | hir::ItemKind::Union(..) => {\n                 let crate_map = tcx.inferred_outlives_crate(LOCAL_CRATE);\n "}, {"sha": "4431abdaf50a0d2b33bc9b64485c34a88094dcd9", "filename": "src/librustc_typeck/variance/constraints.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -68,7 +68,7 @@ pub fn add_constraints_from_crate<'a, 'tcx>(terms_cx: TermsContext<'a, 'tcx>)\n \n impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for ConstraintContext<'a, 'tcx> {\n     fn visit_item(&mut self, item: &hir::Item) {\n-        match item.node {\n+        match item.kind {\n             hir::ItemKind::Struct(ref struct_def, _) |\n             hir::ItemKind::Union(ref struct_def, _) => {\n                 self.visit_node_helper(item.hir_id);\n@@ -94,7 +94,7 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for ConstraintContext<'a, 'tcx> {\n \n             hir::ItemKind::ForeignMod(ref foreign_mod) => {\n                 for foreign_item in &foreign_mod.items {\n-                    if let hir::ForeignItemKind::Fn(..) = foreign_item.node {\n+                    if let hir::ForeignItemKind::Fn(..) = foreign_item.kind {\n                         self.visit_node_helper(foreign_item.hir_id);\n                     }\n                 }\n@@ -105,13 +105,13 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for ConstraintContext<'a, 'tcx> {\n     }\n \n     fn visit_trait_item(&mut self, trait_item: &hir::TraitItem) {\n-        if let hir::TraitItemKind::Method(..) = trait_item.node {\n+        if let hir::TraitItemKind::Method(..) = trait_item.kind {\n             self.visit_node_helper(trait_item.hir_id);\n         }\n     }\n \n     fn visit_impl_item(&mut self, impl_item: &hir::ImplItem) {\n-        if let hir::ImplItemKind::Method(..) = impl_item.node {\n+        if let hir::ImplItemKind::Method(..) = impl_item.kind {\n             self.visit_node_helper(impl_item.hir_id);\n         }\n     }"}, {"sha": "745dbee5fd320143de5aa92d9b0461efeed9c462", "filename": "src/librustc_typeck/variance/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_typeck%2Fvariance%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_typeck%2Fvariance%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fmod.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -49,7 +49,7 @@ fn variances_of(tcx: TyCtxt<'_>, item_def_id: DefId) -> &[ty::Variance] {\n         span_bug!(tcx.hir().span(id), \"asked to compute variance for wrong kind of item\")\n     };\n     match tcx.hir().get(id) {\n-        Node::Item(item) => match item.node {\n+        Node::Item(item) => match item.kind {\n             hir::ItemKind::Enum(..) |\n             hir::ItemKind::Struct(..) |\n             hir::ItemKind::Union(..) |\n@@ -58,19 +58,19 @@ fn variances_of(tcx: TyCtxt<'_>, item_def_id: DefId) -> &[ty::Variance] {\n             _ => unsupported()\n         },\n \n-        Node::TraitItem(item) => match item.node {\n+        Node::TraitItem(item) => match item.kind {\n             hir::TraitItemKind::Method(..) => {}\n \n             _ => unsupported()\n         },\n \n-        Node::ImplItem(item) => match item.node {\n+        Node::ImplItem(item) => match item.kind {\n             hir::ImplItemKind::Method(..) => {}\n \n             _ => unsupported()\n         },\n \n-        Node::ForeignItem(item) => match item.node {\n+        Node::ForeignItem(item) => match item.kind {\n             hir::ForeignItemKind::Fn(..) => {}\n \n             _ => unsupported()"}, {"sha": "863a0b267fddd6ef5c617b81190be6643b6de9b8", "filename": "src/librustc_typeck/variance/terms.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -131,7 +131,7 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for TermsContext<'a, 'tcx> {\n         debug!(\"add_inferreds for item {}\",\n                self.tcx.hir().node_to_string(item.hir_id));\n \n-        match item.node {\n+        match item.kind {\n             hir::ItemKind::Struct(ref struct_def, _) |\n             hir::ItemKind::Union(ref struct_def, _) => {\n                 self.add_inferreds_for_item(item.hir_id);\n@@ -157,7 +157,7 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for TermsContext<'a, 'tcx> {\n \n             hir::ItemKind::ForeignMod(ref foreign_mod) => {\n                 for foreign_item in &foreign_mod.items {\n-                    if let hir::ForeignItemKind::Fn(..) = foreign_item.node {\n+                    if let hir::ForeignItemKind::Fn(..) = foreign_item.kind {\n                         self.add_inferreds_for_item(foreign_item.hir_id);\n                     }\n                 }\n@@ -168,13 +168,13 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for TermsContext<'a, 'tcx> {\n     }\n \n     fn visit_trait_item(&mut self, trait_item: &hir::TraitItem) {\n-        if let hir::TraitItemKind::Method(..) = trait_item.node {\n+        if let hir::TraitItemKind::Method(..) = trait_item.kind {\n             self.add_inferreds_for_item(trait_item.hir_id);\n         }\n     }\n \n     fn visit_impl_item(&mut self, impl_item: &hir::ImplItem) {\n-        if let hir::ImplItemKind::Method(..) = impl_item.node {\n+        if let hir::ImplItemKind::Method(..) = impl_item.kind {\n             self.add_inferreds_for_item(impl_item.hir_id);\n         }\n     }"}, {"sha": "da3b52afadffb50a6252d2e43e9cef0fac1dbe0a", "filename": "src/librustdoc/clean/cfg.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustdoc%2Fclean%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustdoc%2Fclean%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fcfg.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -68,9 +68,9 @@ impl Cfg {\n                 span: cfg.span\n             }),\n         };\n-        match cfg.node {\n+        match cfg.kind {\n             MetaItemKind::Word => Ok(Cfg::Cfg(name, None)),\n-            MetaItemKind::NameValue(ref lit) => match lit.node {\n+            MetaItemKind::NameValue(ref lit) => match lit.kind {\n                 LitKind::Str(value, _) => Ok(Cfg::Cfg(name, Some(value))),\n                 _ => Err(InvalidCfgError {\n                     // FIXME: if the main #[cfg] syntax decided to support non-string literals,"}, {"sha": "580320a735bc0bba76c4c9b6494a90bc015a8c1a", "filename": "src/librustdoc/clean/cfg/tests.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustdoc%2Fclean%2Fcfg%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustdoc%2Fclean%2Fcfg%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fcfg%2Ftests.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -17,7 +17,7 @@ fn name_value_cfg(name: &str, value: &str) -> Cfg {\n fn dummy_meta_item_word(name: &str) -> MetaItem {\n     MetaItem {\n         path: Path::from_ident(Ident::from_str(name)),\n-        node: MetaItemKind::Word,\n+        kind: MetaItemKind::Word,\n         span: DUMMY_SP,\n     }\n }\n@@ -26,7 +26,7 @@ macro_rules! dummy_meta_item_list {\n     ($name:ident, [$($list:ident),* $(,)?]) => {\n         MetaItem {\n             path: Path::from_ident(Ident::from_str(stringify!($name))),\n-            node: MetaItemKind::List(vec![\n+            kind: MetaItemKind::List(vec![\n                 $(\n                     NestedMetaItem::MetaItem(\n                         dummy_meta_item_word(stringify!($list)),\n@@ -40,7 +40,7 @@ macro_rules! dummy_meta_item_list {\n     ($name:ident, [$($list:expr),* $(,)?]) => {\n         MetaItem {\n             path: Path::from_ident(Ident::from_str(stringify!($name))),\n-            node: MetaItemKind::List(vec![\n+            kind: MetaItemKind::List(vec![\n                 $(\n                     NestedMetaItem::MetaItem($list),\n                 )*"}, {"sha": "532c5f67bf3baecf036ec5908acfba8f34e5efcb", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -333,7 +333,7 @@ pub fn build_impl(cx: &DocContext<'_>, did: DefId, attrs: Option<Attrs<'_>>,\n     }\n \n     let for_ = if let Some(hir_id) = tcx.hir().as_local_hir_id(did) {\n-        match tcx.hir().expect_item(hir_id).node {\n+        match tcx.hir().expect_item(hir_id).kind {\n             hir::ItemKind::Impl(.., ref t, _) => {\n                 t.clean(cx)\n             }\n@@ -355,7 +355,7 @@ pub fn build_impl(cx: &DocContext<'_>, did: DefId, attrs: Option<Attrs<'_>>,\n \n     let predicates = tcx.explicit_predicates_of(did);\n     let (trait_items, generics) = if let Some(hir_id) = tcx.hir().as_local_hir_id(did) {\n-        match tcx.hir().expect_item(hir_id).node {\n+        match tcx.hir().expect_item(hir_id).kind {\n             hir::ItemKind::Impl(.., ref gen, _, _, ref item_ids) => {\n                 (\n                     item_ids.iter()\n@@ -481,7 +481,7 @@ fn build_macro(cx: &DocContext<'_>, did: DefId, name: ast::Name) -> clean::ItemE\n     let imported_from = cx.tcx.original_crate_name(did.krate);\n     match cx.cstore.load_macro_untracked(did, cx.sess()) {\n         LoadedMacro::MacroDef(def) => {\n-            let matchers: hir::HirVec<Span> = if let ast::ItemKind::MacroDef(ref def) = def.node {\n+            let matchers: hir::HirVec<Span> = if let ast::ItemKind::MacroDef(ref def) = def.kind {\n                 let tts: Vec<_> = def.stream().into_trees().collect();\n                 tts.chunks(4).map(|arm| arm[0].span()).collect()\n             } else {"}, {"sha": "ce2144710581538b317625a6536598ac08559f88", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -275,7 +275,7 @@ impl Clean<ExternalCrate> for CrateNum {\n         let primitives = if root.is_local() {\n             cx.tcx.hir().krate().module.item_ids.iter().filter_map(|&id| {\n                 let item = cx.tcx.hir().expect_item(id.id);\n-                match item.node {\n+                match item.kind {\n                     hir::ItemKind::Mod(_) => {\n                         as_primitive(Res::Def(\n                             DefKind::Mod,\n@@ -319,7 +319,7 @@ impl Clean<ExternalCrate> for CrateNum {\n         let keywords = if root.is_local() {\n             cx.tcx.hir().krate().module.item_ids.iter().filter_map(|&id| {\n                 let item = cx.tcx.hir().expect_item(id.id);\n-                match item.node {\n+                match item.kind {\n                     hir::ItemKind::Mod(_) => {\n                         as_keyword(Res::Def(\n                             DefKind::Mod,\n@@ -778,11 +778,11 @@ impl Attributes {\n     fn extract_cfg(mi: &ast::MetaItem) -> Option<&ast::MetaItem> {\n         use syntax::ast::NestedMetaItem::MetaItem;\n \n-        if let ast::MetaItemKind::List(ref nmis) = mi.node {\n+        if let ast::MetaItemKind::List(ref nmis) = mi.kind {\n             if nmis.len() == 1 {\n                 if let MetaItem(ref cfg_mi) = nmis[0] {\n                     if cfg_mi.check_name(sym::cfg) {\n-                        if let ast::MetaItemKind::List(ref cfg_nmis) = cfg_mi.node {\n+                        if let ast::MetaItemKind::List(ref cfg_nmis) = cfg_mi.kind {\n                             if cfg_nmis.len() == 1 {\n                                 if let MetaItem(ref content_mi) = cfg_nmis[0] {\n                                     return Some(content_mi);\n@@ -2280,7 +2280,7 @@ impl Clean<PolyTrait> for hir::PolyTraitRef {\n \n impl Clean<Item> for hir::TraitItem {\n     fn clean(&self, cx: &DocContext<'_>) -> Item {\n-        let inner = match self.node {\n+        let inner = match self.kind {\n             hir::TraitItemKind::Const(ref ty, default) => {\n                 AssocConstItem(ty.clean(cx),\n                                     default.map(|e| print_const_expr(cx, e)))\n@@ -2321,7 +2321,7 @@ impl Clean<Item> for hir::TraitItem {\n \n impl Clean<Item> for hir::ImplItem {\n     fn clean(&self, cx: &DocContext<'_>) -> Item {\n-        let inner = match self.node {\n+        let inner = match self.kind {\n             hir::ImplItemKind::Const(ref ty, expr) => {\n                 AssocConstItem(ty.clean(cx),\n                                     Some(print_const_expr(cx, expr)))\n@@ -2835,7 +2835,7 @@ impl Clean<Type> for hir::Ty {\n     fn clean(&self, cx: &DocContext<'_>) -> Type {\n         use rustc::hir::*;\n \n-        match self.node {\n+        match self.kind {\n             TyKind::Never => Never,\n             TyKind::Ptr(ref m) => RawPointer(m.mutbl.clean(cx), box m.ty.clean(cx)),\n             TyKind::Rptr(ref l, ref m) => {\n@@ -2868,7 +2868,7 @@ impl Clean<Type> for hir::Ty {\n             TyKind::Tup(ref tys) => Tuple(tys.clean(cx)),\n             TyKind::Def(item_id, _) => {\n                 let item = cx.tcx.hir().expect_item(item_id.id);\n-                if let hir::ItemKind::OpaqueTy(ref ty) = item.node {\n+                if let hir::ItemKind::OpaqueTy(ref ty) = item.kind {\n                     ImplTrait(ty.bounds.clean(cx))\n                 } else {\n                     unreachable!()\n@@ -2889,7 +2889,7 @@ impl Clean<Type> for hir::Ty {\n                     // Substitute private type aliases\n                     if let Some(hir_id) = cx.tcx.hir().as_local_hir_id(def_id) {\n                         if !cx.renderinfo.borrow().access_levels.is_exported(def_id) {\n-                            alias = Some(&cx.tcx.hir().expect_item(hir_id).node);\n+                            alias = Some(&cx.tcx.hir().expect_item(hir_id).kind);\n                         }\n                     }\n                 };\n@@ -3031,7 +3031,7 @@ impl Clean<Type> for hir::Ty {\n             }\n             TyKind::BareFn(ref barefn) => BareFunction(box barefn.clean(cx)),\n             TyKind::Infer | TyKind::Err => Infer,\n-            TyKind::Typeof(..) => panic!(\"unimplemented type {:?}\", self.node),\n+            TyKind::Typeof(..) => panic!(\"unimplemented type {:?}\", self.kind),\n             TyKind::CVarArgs(_) => CVarArgs,\n         }\n     }\n@@ -4182,7 +4182,7 @@ fn name_from_pat(p: &hir::Pat) -> String {\n     use rustc::hir::*;\n     debug!(\"trying to get a name from pattern: {:?}\", p);\n \n-    match p.node {\n+    match p.kind {\n         PatKind::Wild => \"_\".to_string(),\n         PatKind::Binding(_, _, ident, _) => ident.to_string(),\n         PatKind::TupleStruct(ref p, ..) | PatKind::Path(ref p) => qpath_to_string(p),"}, {"sha": "6576165b6ce74ddd071e2fafa2987c7f6d2b5689", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -425,15 +425,15 @@ pub fn make_test(s: &str,\n             match parser.parse_item() {\n                 Ok(Some(item)) => {\n                     if !found_main {\n-                        if let ast::ItemKind::Fn(..) = item.node {\n+                        if let ast::ItemKind::Fn(..) = item.kind {\n                             if item.ident.name == sym::main {\n                                 found_main = true;\n                             }\n                         }\n                     }\n \n                     if !found_extern_crate {\n-                        if let ast::ItemKind::ExternCrate(original) = item.node {\n+                        if let ast::ItemKind::ExternCrate(original) = item.kind {\n                             // This code will never be reached if `cratename` is none because\n                             // `found_extern_crate` is initialized to `true` if it is none.\n                             let cratename = cratename.unwrap();\n@@ -446,7 +446,7 @@ pub fn make_test(s: &str,\n                     }\n \n                     if !found_macro {\n-                        if let ast::ItemKind::Mac(..) = item.node {\n+                        if let ast::ItemKind::Mac(..) = item.kind {\n                             found_macro = true;\n                         }\n                     }\n@@ -882,7 +882,7 @@ impl<'a, 'hir> intravisit::Visitor<'hir> for HirCollector<'a, 'hir> {\n     }\n \n     fn visit_item(&mut self, item: &'hir hir::Item) {\n-        let name = if let hir::ItemKind::Impl(.., ref ty, _) = item.node {\n+        let name = if let hir::ItemKind::Impl(.., ref ty, _) = item.kind {\n             self.map.hir_to_pretty_string(ty.hir_id)\n         } else {\n             item.ident.to_string()"}, {"sha": "b6a90e1fb988bf5f901a629dfd512bc9c49e9b61", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -320,7 +320,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         if !self.view_item_stack.insert(res_hir_id) { return false }\n \n         let ret = match tcx.hir().get(res_hir_id) {\n-            Node::Item(&hir::Item { node: hir::ItemKind::Mod(ref m), .. }) if glob => {\n+            Node::Item(&hir::Item { kind: hir::ItemKind::Mod(ref m), .. }) if glob => {\n                 let prev = mem::replace(&mut self.inlining, true);\n                 for i in &m.item_ids {\n                     let i = self.cx.tcx.hir().expect_item(i.id);\n@@ -361,7 +361,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n             self.store_path(def_id);\n         }\n \n-        match item.node {\n+        match item.kind {\n             hir::ItemKind::ForeignMod(ref fm) => {\n                 for item in &fm.items {\n                     self.visit_foreign_item(item, None, om);\n@@ -561,7 +561,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         om.foreigns.push(ForeignItem {\n             id: item.hir_id,\n             name: renamed.unwrap_or(item.ident).name,\n-            kind: &item.node,\n+            kind: &item.kind,\n             vis: &item.vis,\n             attrs: &item.attrs,\n             whence: item.span"}, {"sha": "a7f035dc9ecc7388fa8911711b92fe38729f514b", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -472,7 +472,7 @@ pub enum NestedMetaItem {\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct MetaItem {\n     pub path: Path,\n-    pub node: MetaItemKind,\n+    pub kind: MetaItemKind,\n     pub span: Span,\n }\n \n@@ -511,7 +511,7 @@ pub struct Block {\n #[derive(Clone, RustcEncodable, RustcDecodable)]\n pub struct Pat {\n     pub id: NodeId,\n-    pub node: PatKind,\n+    pub kind: PatKind,\n     pub span: Span,\n }\n \n@@ -525,7 +525,7 @@ impl Pat {\n     /// Attempt reparsing the pattern as a type.\n     /// This is intended for use by diagnostics.\n     pub(super) fn to_ty(&self) -> Option<P<Ty>> {\n-        let node = match &self.node {\n+        let kind = match &self.kind {\n             // In a type expression `_` is an inference variable.\n             PatKind::Wild => TyKind::Infer,\n             // An IDENT pattern with no binding mode would be valid as path to a type. E.g. `u32`.\n@@ -555,7 +555,7 @@ impl Pat {\n         };\n \n         Some(P(Ty {\n-            node,\n+            kind,\n             id: self.id,\n             span: self.span,\n         }))\n@@ -569,7 +569,7 @@ impl Pat {\n             return;\n         }\n \n-        match &self.node {\n+        match &self.kind {\n             PatKind::Ident(_, _, Some(p)) => p.walk(it),\n             PatKind::Struct(_, fields, _) => fields.iter().for_each(|field| field.pat.walk(it)),\n             PatKind::TupleStruct(_, s)\n@@ -591,7 +591,7 @@ impl Pat {\n \n     /// Is this a `..` pattern?\n     pub fn is_rest(&self) -> bool {\n-        match self.node {\n+        match self.kind {\n             PatKind::Rest => true,\n             _ => false,\n         }\n@@ -835,31 +835,31 @@ impl UnOp {\n #[derive(Clone, RustcEncodable, RustcDecodable)]\n pub struct Stmt {\n     pub id: NodeId,\n-    pub node: StmtKind,\n+    pub kind: StmtKind,\n     pub span: Span,\n }\n \n impl Stmt {\n     pub fn add_trailing_semicolon(mut self) -> Self {\n-        self.node = match self.node {\n+        self.kind = match self.kind {\n             StmtKind::Expr(expr) => StmtKind::Semi(expr),\n             StmtKind::Mac(mac) => {\n                 StmtKind::Mac(mac.map(|(mac, _style, attrs)| (mac, MacStmtStyle::Semicolon, attrs)))\n             }\n-            node => node,\n+            kind => kind,\n         };\n         self\n     }\n \n     pub fn is_item(&self) -> bool {\n-        match self.node {\n+        match self.kind {\n             StmtKind::Item(_) => true,\n             _ => false,\n         }\n     }\n \n     pub fn is_expr(&self) -> bool {\n-        match self.node {\n+        match self.kind {\n             StmtKind::Expr(_) => true,\n             _ => false,\n         }\n@@ -977,7 +977,7 @@ pub struct AnonConst {\n #[derive(Clone, RustcEncodable, RustcDecodable)]\n pub struct Expr {\n     pub id: NodeId,\n-    pub node: ExprKind,\n+    pub kind: ExprKind,\n     pub span: Span,\n     pub attrs: ThinVec<Attribute>,\n }\n@@ -990,12 +990,12 @@ impl Expr {\n     /// Returns `true` if this expression would be valid somewhere that expects a value;\n     /// for example, an `if` condition.\n     pub fn returns(&self) -> bool {\n-        if let ExprKind::Block(ref block, _) = self.node {\n-            match block.stmts.last().map(|last_stmt| &last_stmt.node) {\n+        if let ExprKind::Block(ref block, _) = self.kind {\n+            match block.stmts.last().map(|last_stmt| &last_stmt.kind) {\n                 // Implicit return\n                 Some(&StmtKind::Expr(_)) => true,\n                 Some(&StmtKind::Semi(ref expr)) => {\n-                    if let ExprKind::Ret(_) = expr.node {\n+                    if let ExprKind::Ret(_) = expr.kind {\n                         // Last statement is explicit return.\n                         true\n                     } else {\n@@ -1012,7 +1012,7 @@ impl Expr {\n     }\n \n     fn to_bound(&self) -> Option<GenericBound> {\n-        match &self.node {\n+        match &self.kind {\n             ExprKind::Path(None, path) => Some(GenericBound::Trait(\n                 PolyTraitRef::new(Vec::new(), path.clone(), self.span),\n                 TraitBoundModifier::None,\n@@ -1022,7 +1022,7 @@ impl Expr {\n     }\n \n     pub(super) fn to_ty(&self) -> Option<P<Ty>> {\n-        let node = match &self.node {\n+        let kind = match &self.kind {\n             ExprKind::Path(qself, path) => TyKind::Path(qself.clone(), path.clone()),\n             ExprKind::Mac(mac) => TyKind::Mac(mac.clone()),\n             ExprKind::Paren(expr) => expr.to_ty().map(TyKind::Paren)?,\n@@ -1051,14 +1051,14 @@ impl Expr {\n         };\n \n         Some(P(Ty {\n-            node,\n+            kind,\n             id: self.id,\n             span: self.span,\n         }))\n     }\n \n     pub fn precedence(&self) -> ExprPrecedence {\n-        match self.node {\n+        match self.kind {\n             ExprKind::Box(_) => ExprPrecedence::Box,\n             ExprKind::Array(_) => ExprPrecedence::Array,\n             ExprKind::Call(..) => ExprPrecedence::Call,\n@@ -1361,7 +1361,7 @@ pub struct Lit {\n     /// The \"semantic\" representation of the literal lowered from the original tokens.\n     /// Strings are unescaped, hexadecimal forms are eliminated, etc.\n     /// FIXME: Remove this and only create the semantic representation during lowering to HIR.\n-    pub node: LitKind,\n+    pub kind: LitKind,\n     pub span: Span,\n }\n \n@@ -1474,7 +1474,7 @@ pub struct TraitItem {\n     pub ident: Ident,\n     pub attrs: Vec<Attribute>,\n     pub generics: Generics,\n-    pub node: TraitItemKind,\n+    pub kind: TraitItemKind,\n     pub span: Span,\n     /// See `Item::tokens` for what this is.\n     pub tokens: Option<TokenStream>,\n@@ -1497,7 +1497,7 @@ pub struct ImplItem {\n     pub defaultness: Defaultness,\n     pub attrs: Vec<Attribute>,\n     pub generics: Generics,\n-    pub node: ImplItemKind,\n+    pub kind: ImplItemKind,\n     pub span: Span,\n     /// See `Item::tokens` for what this is.\n     pub tokens: Option<TokenStream>,\n@@ -1664,7 +1664,7 @@ pub enum AssocTyConstraintKind {\n #[derive(Clone, RustcEncodable, RustcDecodable)]\n pub struct Ty {\n     pub id: NodeId,\n-    pub node: TyKind,\n+    pub kind: TyKind,\n     pub span: Span,\n }\n \n@@ -1821,11 +1821,11 @@ pub type ExplicitSelf = Spanned<SelfKind>;\n \n impl Param {\n     pub fn to_self(&self) -> Option<ExplicitSelf> {\n-        if let PatKind::Ident(BindingMode::ByValue(mutbl), ident, _) = self.pat.node {\n+        if let PatKind::Ident(BindingMode::ByValue(mutbl), ident, _) = self.pat.kind {\n             if ident.name == kw::SelfLower {\n-                return match self.ty.node {\n+                return match self.ty.kind {\n                     TyKind::ImplicitSelf => Some(respan(self.pat.span, SelfKind::Value(mutbl))),\n-                    TyKind::Rptr(lt, MutTy { ref ty, mutbl }) if ty.node.is_implicit_self() => {\n+                    TyKind::Rptr(lt, MutTy { ref ty, mutbl }) if ty.kind.is_implicit_self() => {\n                         Some(respan(self.pat.span, SelfKind::Region(lt, mutbl)))\n                     }\n                     _ => Some(respan(\n@@ -1839,7 +1839,7 @@ impl Param {\n     }\n \n     pub fn is_self(&self) -> bool {\n-        if let PatKind::Ident(_, ident, _) = self.pat.node {\n+        if let PatKind::Ident(_, ident, _) = self.pat.kind {\n             ident.name == kw::SelfLower\n         } else {\n             false\n@@ -1850,14 +1850,14 @@ impl Param {\n         let span = eself.span.to(eself_ident.span);\n         let infer_ty = P(Ty {\n             id: DUMMY_NODE_ID,\n-            node: TyKind::ImplicitSelf,\n+            kind: TyKind::ImplicitSelf,\n             span,\n         });\n         let param = |mutbl, ty| Param {\n             attrs,\n             pat: P(Pat {\n                 id: DUMMY_NODE_ID,\n-                node: PatKind::Ident(BindingMode::ByValue(mutbl), eself_ident, None),\n+                kind: PatKind::Ident(BindingMode::ByValue(mutbl), eself_ident, None),\n                 span,\n             }),\n             span,\n@@ -1872,7 +1872,7 @@ impl Param {\n                 Mutability::Immutable,\n                 P(Ty {\n                     id: DUMMY_NODE_ID,\n-                    node: TyKind::Rptr(\n+                    kind: TyKind::Rptr(\n                         lt,\n                         MutTy {\n                             ty: infer_ty,\n@@ -2269,7 +2269,7 @@ pub struct Item {\n     pub ident: Ident,\n     pub attrs: Vec<Attribute>,\n     pub id: NodeId,\n-    pub node: ItemKind,\n+    pub kind: ItemKind,\n     pub vis: Visibility,\n     pub span: Span,\n \n@@ -2421,7 +2421,7 @@ impl ItemKind {\n pub struct ForeignItem {\n     pub ident: Ident,\n     pub attrs: Vec<Attribute>,\n-    pub node: ForeignItemKind,\n+    pub kind: ForeignItemKind,\n     pub id: NodeId,\n     pub span: Span,\n     pub vis: Visibility,"}, {"sha": "2a8e6b2cc95109c6f6ff5354734b2dddaf977f7e", "filename": "src/libsyntax/attr/builtin.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibsyntax%2Fattr%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibsyntax%2Fattr%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr%2Fbuiltin.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -36,7 +36,7 @@ impl AttributeTemplate {\n         match meta_item_kind {\n             ast::MetaItemKind::Word => self.word,\n             ast::MetaItemKind::List(..) => self.list.is_some(),\n-            ast::MetaItemKind::NameValue(lit) if lit.node.is_str() => self.name_value_str.is_some(),\n+            ast::MetaItemKind::NameValue(lit) if lit.kind.is_str() => self.name_value_str.is_some(),\n             ast::MetaItemKind::NameValue(..) => false,\n         }\n     }\n@@ -106,7 +106,7 @@ pub fn find_unwind_attr(diagnostic: Option<&Handler>, attrs: &[Attribute]) -> Op\n     attrs.iter().fold(None, |ia, attr| {\n         if attr.check_name(sym::unwind) {\n             if let Some(meta) = attr.meta() {\n-                if let MetaItemKind::List(items) = meta.node {\n+                if let MetaItemKind::List(items) = meta.kind {\n                     if items.len() == 1 {\n                         if items[0].check_name(sym::allowed) {\n                             return Some(UnwindAttr::Allowed);\n@@ -239,7 +239,7 @@ fn find_stability_generic<'a, I>(sess: &ParseSess,\n             allow_const_fn_ptr = true;\n         }\n         // attributes with data\n-        else if let Some(MetaItem { node: MetaItemKind::List(ref metas), .. }) = meta {\n+        else if let Some(MetaItem { kind: MetaItemKind::List(ref metas), .. }) = meta {\n             let meta = meta.as_ref().unwrap();\n             let get = |meta: &MetaItem, item: &mut Option<Symbol>| {\n                 if item.is_some() {\n@@ -534,17 +534,17 @@ pub fn cfg_matches(cfg: &ast::MetaItem, sess: &ParseSess, features: Option<&Feat\n         if cfg.path.segments.len() != 1 {\n             return error(cfg.path.span, \"`cfg` predicate key must be an identifier\");\n         }\n-        match &cfg.node {\n+        match &cfg.kind {\n             MetaItemKind::List(..) => {\n                 error(cfg.span, \"unexpected parentheses after `cfg` predicate key\")\n             }\n-            MetaItemKind::NameValue(lit) if !lit.node.is_str() => {\n+            MetaItemKind::NameValue(lit) if !lit.kind.is_str() => {\n                 handle_errors(\n                     sess,\n                     lit.span,\n                     AttrError::UnsupportedLiteral(\n                         \"literal in `cfg` predicate value must be a string\",\n-                        lit.node.is_bytestr()\n+                        lit.kind.is_bytestr()\n                     ),\n                 );\n                 true\n@@ -563,7 +563,7 @@ pub fn eval_condition<F>(cfg: &ast::MetaItem, sess: &ParseSess, eval: &mut F)\n                          -> bool\n     where F: FnMut(&ast::MetaItem) -> bool\n {\n-    match cfg.node {\n+    match cfg.kind {\n         ast::MetaItemKind::List(ref mis) => {\n             for mi in mis.iter() {\n                 if !mi.is_meta_item() {\n@@ -642,7 +642,7 @@ fn find_deprecation_generic<'a, I>(sess: &ParseSess,\n         }\n \n         let meta = attr.meta().unwrap();\n-        depr = match &meta.node {\n+        depr = match &meta.kind {\n             MetaItemKind::Word => Some(Deprecation { since: None, note: None }),\n             MetaItemKind::NameValue(..) => {\n                 meta.value_str().map(|note| {\n@@ -668,7 +668,7 @@ fn find_deprecation_generic<'a, I>(sess: &ParseSess,\n                                 AttrError::UnsupportedLiteral(\n                                     \"literal in `deprecated` \\\n                                     value must be a string\",\n-                                    lit.node.is_bytestr()\n+                                    lit.kind.is_bytestr()\n                                 ),\n                             );\n                         } else {\n@@ -811,14 +811,14 @@ pub fn find_repr_attrs(sess: &ParseSess, attr: &Attribute) -> Vec<ReprAttr> {\n                     let mut literal_error = None;\n                     if name == sym::align {\n                         recognised = true;\n-                        match parse_alignment(&value.node) {\n+                        match parse_alignment(&value.kind) {\n                             Ok(literal) => acc.push(ReprAlign(literal)),\n                             Err(message) => literal_error = Some(message)\n                         };\n                     }\n                     else if name == sym::packed {\n                         recognised = true;\n-                        match parse_alignment(&value.node) {\n+                        match parse_alignment(&value.kind) {\n                             Ok(literal) => acc.push(ReprPacked(literal)),\n                             Err(message) => literal_error = Some(message)\n                         };\n@@ -830,11 +830,11 @@ pub fn find_repr_attrs(sess: &ParseSess, attr: &Attribute) -> Vec<ReprAttr> {\n                 } else {\n                     if let Some(meta_item) = item.meta_item() {\n                         if meta_item.check_name(sym::align) {\n-                            if let MetaItemKind::NameValue(ref value) = meta_item.node {\n+                            if let MetaItemKind::NameValue(ref value) = meta_item.kind {\n                                 recognised = true;\n                                 let mut err = struct_span_err!(diagnostic, item.span(), E0693,\n                                     \"incorrect `repr(align)` attribute format\");\n-                                match value.node {\n+                                match value.kind {\n                                     ast::LitKind::Int(int, ast::LitIntType::Unsuffixed) => {\n                                         err.span_suggestion(\n                                             item.span(),\n@@ -941,7 +941,7 @@ crate fn check_builtin_attribute(\n                              name == sym::test || name == sym::bench;\n \n     match attr.parse_meta(sess) {\n-        Ok(meta) => if !should_skip(name) && !template.compatible(&meta.node) {\n+        Ok(meta) => if !should_skip(name) && !template.compatible(&meta.kind) {\n             let error_msg = format!(\"malformed `{}` attribute input\", name);\n             let mut msg = \"attribute must be of the form \".to_owned();\n             let mut suggestions = vec![];"}, {"sha": "122cb7fb12b246b44f742b565788a11dc849189f", "filename": "src/libsyntax/attr/mod.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibsyntax%2Fattr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibsyntax%2Fattr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr%2Fmod.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -174,7 +174,7 @@ impl Attribute {\n \n     pub fn meta_item_list(&self) -> Option<Vec<NestedMetaItem>> {\n         match self.meta() {\n-            Some(MetaItem { node: MetaItemKind::List(list), .. }) => Some(list),\n+            Some(MetaItem { kind: MetaItemKind::List(list), .. }) => Some(list),\n             _ => None\n         }\n     }\n@@ -210,16 +210,16 @@ impl MetaItem {\n     //     #[attribute(name = \"value\")]\n     //                 ^^^^^^^^^^^^^^\n     pub fn name_value_literal(&self) -> Option<&Lit> {\n-        match &self.node {\n+        match &self.kind {\n             MetaItemKind::NameValue(v) => Some(v),\n             _ => None,\n         }\n     }\n \n     pub fn value_str(&self) -> Option<Symbol> {\n-        match self.node {\n+        match self.kind {\n             MetaItemKind::NameValue(ref v) => {\n-                match v.node {\n+                match v.kind {\n                     LitKind::Str(ref s, _) => Some(*s),\n                     _ => None,\n                 }\n@@ -229,14 +229,14 @@ impl MetaItem {\n     }\n \n     pub fn meta_item_list(&self) -> Option<&[NestedMetaItem]> {\n-        match self.node {\n+        match self.kind {\n             MetaItemKind::List(ref l) => Some(&l[..]),\n             _ => None\n         }\n     }\n \n     pub fn is_word(&self) -> bool {\n-        match self.node {\n+        match self.kind {\n             MetaItemKind::Word => true,\n             _ => false,\n         }\n@@ -261,11 +261,11 @@ impl Attribute {\n         let mut tokens = self.tokens.trees().peekable();\n         Some(MetaItem {\n             path: self.path.clone(),\n-            node: if let Some(node) = MetaItemKind::from_tokens(&mut tokens) {\n+            kind: if let Some(kind) = MetaItemKind::from_tokens(&mut tokens) {\n                 if tokens.peek().is_some() {\n                     return None;\n                 }\n-                node\n+                kind\n             } else {\n                 return None;\n             },\n@@ -314,7 +314,7 @@ impl Attribute {\n     pub fn parse_meta<'a>(&self, sess: &'a ParseSess) -> PResult<'a, MetaItem> {\n         Ok(MetaItem {\n             path: self.path.clone(),\n-            node: self.parse(sess, |parser| parser.parse_meta_item_kind())?,\n+            kind: self.parse(sess, |parser| parser.parse_meta_item_kind())?,\n             span: self.span,\n         })\n     }\n@@ -336,7 +336,7 @@ impl Attribute {\n                 id: self.id,\n                 style: self.style,\n                 path: meta.path,\n-                tokens: meta.node.tokens(meta.span),\n+                tokens: meta.kind.tokens(meta.span),\n                 is_sugared_doc: true,\n                 span: self.span,\n             })\n@@ -356,15 +356,15 @@ pub fn mk_name_value_item_str(ident: Ident, str: Symbol, str_span: Span) -> Meta\n pub fn mk_name_value_item(ident: Ident, lit_kind: LitKind, lit_span: Span) -> MetaItem {\n     let lit = Lit::from_lit_kind(lit_kind, lit_span);\n     let span = ident.span.to(lit_span);\n-    MetaItem { path: Path::from_ident(ident), span, node: MetaItemKind::NameValue(lit) }\n+    MetaItem { path: Path::from_ident(ident), span, kind: MetaItemKind::NameValue(lit) }\n }\n \n pub fn mk_list_item(ident: Ident, items: Vec<NestedMetaItem>) -> MetaItem {\n-    MetaItem { path: Path::from_ident(ident), span: ident.span, node: MetaItemKind::List(items) }\n+    MetaItem { path: Path::from_ident(ident), span: ident.span, kind: MetaItemKind::List(items) }\n }\n \n pub fn mk_word_item(ident: Ident) -> MetaItem {\n-    MetaItem { path: Path::from_ident(ident), span: ident.span, node: MetaItemKind::Word }\n+    MetaItem { path: Path::from_ident(ident), span: ident.span, kind: MetaItemKind::Word }\n }\n \n pub fn mk_nested_word_item(ident: Ident) -> NestedMetaItem {\n@@ -395,12 +395,12 @@ pub fn mk_attr(style: AttrStyle, path: Path, tokens: TokenStream, span: Span) ->\n \n /// Returns an inner attribute with the given value and span.\n pub fn mk_attr_inner(item: MetaItem) -> Attribute {\n-    mk_attr(AttrStyle::Inner, item.path, item.node.tokens(item.span), item.span)\n+    mk_attr(AttrStyle::Inner, item.path, item.kind.tokens(item.span), item.span)\n }\n \n /// Returns an outer attribute with the given value and span.\n pub fn mk_attr_outer(item: MetaItem) -> Attribute {\n-    mk_attr(AttrStyle::Outer, item.path, item.node.tokens(item.span), item.span)\n+    mk_attr(AttrStyle::Outer, item.path, item.kind.tokens(item.span), item.span)\n }\n \n pub fn mk_sugared_doc_attr(text: Symbol, span: Span) -> Attribute {\n@@ -483,7 +483,7 @@ impl MetaItem {\n             idents.push(TokenTree::Token(Token::from_ast_ident(segment.ident)).into());\n             last_pos = segment.ident.span.hi();\n         }\n-        self.node.tokens(self.span).append_to_tree_and_joint_vec(&mut idents);\n+        self.kind.tokens(self.span).append_to_tree_and_joint_vec(&mut idents);\n         TokenStream::new(idents)\n     }\n \n@@ -531,14 +531,14 @@ impl MetaItem {\n             _ => return None,\n         };\n         let list_closing_paren_pos = tokens.peek().map(|tt| tt.span().hi());\n-        let node = MetaItemKind::from_tokens(tokens)?;\n-        let hi = match node {\n+        let kind = MetaItemKind::from_tokens(tokens)?;\n+        let hi = match kind {\n             MetaItemKind::NameValue(ref lit) => lit.span.hi(),\n             MetaItemKind::List(..) => list_closing_paren_pos.unwrap_or(path.span.hi()),\n             _ => path.span.hi(),\n         };\n         let span = path.span.with_hi(hi);\n-        Some(MetaItem { path, node, span })\n+        Some(MetaItem { path, kind, span })\n     }\n }\n \n@@ -702,11 +702,11 @@ impl HasAttrs for StmtKind {\n \n impl HasAttrs for Stmt {\n     fn attrs(&self) -> &[ast::Attribute] {\n-        self.node.attrs()\n+        self.kind.attrs()\n     }\n \n     fn visit_attrs<F: FnOnce(&mut Vec<ast::Attribute>)>(&mut self, f: F) {\n-        self.node.visit_attrs(f);\n+        self.kind.visit_attrs(f);\n     }\n }\n "}, {"sha": "990358c674ff76eae1e678753f767296babede75", "filename": "src/libsyntax/config.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibsyntax%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibsyntax%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fconfig.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -298,7 +298,7 @@ impl<'a> StripUnconfigured<'a> {\n     }\n \n     pub fn configure_pat(&mut self, pat: &mut P<ast::Pat>) {\n-        if let ast::PatKind::Struct(_path, fields, _etc) = &mut pat.node {\n+        if let ast::PatKind::Struct(_path, fields, _etc) = &mut pat.kind {\n             fields.flat_map_in_place(|field| self.configure(field));\n         }\n     }\n@@ -321,13 +321,13 @@ impl<'a> MutVisitor for StripUnconfigured<'a> {\n \n     fn visit_expr(&mut self, expr: &mut P<ast::Expr>) {\n         self.configure_expr(expr);\n-        self.configure_expr_kind(&mut expr.node);\n+        self.configure_expr_kind(&mut expr.kind);\n         noop_visit_expr(expr, self);\n     }\n \n     fn filter_map_expr(&mut self, expr: P<ast::Expr>) -> Option<P<ast::Expr>> {\n         let mut expr = configure!(self, expr);\n-        self.configure_expr_kind(&mut expr.node);\n+        self.configure_expr_kind(&mut expr.kind);\n         noop_visit_expr(&mut expr, self);\n         Some(expr)\n     }"}, {"sha": "34b5b1e5b5c84ce9c657425b2a3f7ec8d235f871", "filename": "src/libsyntax/entry.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibsyntax%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibsyntax%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fentry.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -13,7 +13,7 @@ pub enum EntryPointType {\n // Beware, this is duplicated in librustc/middle/entry.rs, make sure to keep\n // them in sync.\n pub fn entry_point_type(item: &Item, depth: usize) -> EntryPointType {\n-    match item.node {\n+    match item.kind {\n         ItemKind::Fn(..) => {\n             if attr::contains_name(&item.attrs, sym::start) {\n                 EntryPointType::Start"}, {"sha": "54cfb80573e5c572d35bb3f045ce9eee3421713e", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -222,7 +222,7 @@ impl Annotatable {\n \n     pub fn derive_allowed(&self) -> bool {\n         match *self {\n-            Annotatable::Item(ref item) => match item.node {\n+            Annotatable::Item(ref item) => match item.kind {\n                 ast::ItemKind::Struct(..) |\n                 ast::ItemKind::Enum(..) |\n                 ast::ItemKind::Union(..) => true,\n@@ -363,7 +363,7 @@ macro_rules! make_stmts_default {\n         $me.make_expr().map(|e| smallvec![ast::Stmt {\n             id: ast::DUMMY_NODE_ID,\n             span: e.span,\n-            node: ast::StmtKind::Expr(e),\n+            kind: ast::StmtKind::Expr(e),\n         }])\n     }\n }\n@@ -507,11 +507,11 @@ impl MacResult for MacEager {\n             return Some(p);\n         }\n         if let Some(e) = self.expr {\n-            if let ast::ExprKind::Lit(_) = e.node {\n+            if let ast::ExprKind::Lit(_) = e.kind {\n                 return Some(P(ast::Pat {\n                     id: ast::DUMMY_NODE_ID,\n                     span: e.span,\n-                    node: PatKind::Lit(e),\n+                    kind: PatKind::Lit(e),\n                 }));\n             }\n         }\n@@ -549,7 +549,7 @@ impl DummyResult {\n     pub fn raw_expr(sp: Span, is_error: bool) -> P<ast::Expr> {\n         P(ast::Expr {\n             id: ast::DUMMY_NODE_ID,\n-            node: if is_error { ast::ExprKind::Err } else { ast::ExprKind::Tup(Vec::new()) },\n+            kind: if is_error { ast::ExprKind::Err } else { ast::ExprKind::Tup(Vec::new()) },\n             span: sp,\n             attrs: ThinVec::new(),\n         })\n@@ -559,7 +559,7 @@ impl DummyResult {\n     pub fn raw_pat(sp: Span) -> ast::Pat {\n         ast::Pat {\n             id: ast::DUMMY_NODE_ID,\n-            node: PatKind::Wild,\n+            kind: PatKind::Wild,\n             span: sp,\n         }\n     }\n@@ -568,7 +568,7 @@ impl DummyResult {\n     pub fn raw_ty(sp: Span, is_error: bool) -> P<ast::Ty> {\n         P(ast::Ty {\n             id: ast::DUMMY_NODE_ID,\n-            node: if is_error { ast::TyKind::Err } else { ast::TyKind::Tup(Vec::new()) },\n+            kind: if is_error { ast::TyKind::Err } else { ast::TyKind::Tup(Vec::new()) },\n             span: sp\n         })\n     }\n@@ -602,7 +602,7 @@ impl MacResult for DummyResult {\n     fn make_stmts(self: Box<DummyResult>) -> Option<SmallVec<[ast::Stmt; 1]>> {\n         Some(smallvec![ast::Stmt {\n             id: ast::DUMMY_NODE_ID,\n-            node: ast::StmtKind::Expr(DummyResult::raw_expr(self.span, self.is_error)),\n+            kind: ast::StmtKind::Expr(DummyResult::raw_expr(self.span, self.is_error)),\n             span: self.span,\n         }])\n     }\n@@ -1098,8 +1098,8 @@ pub fn expr_to_spanned_string<'a>(\n     // We want to be able to handle e.g., `concat!(\"foo\", \"bar\")`.\n     let expr = cx.expander().fully_expand_fragment(AstFragment::Expr(expr)).make_expr();\n \n-    Err(match expr.node {\n-        ast::ExprKind::Lit(ref l) => match l.node {\n+    Err(match expr.kind {\n+        ast::ExprKind::Lit(ref l) => match l.kind {\n             ast::LitKind::Str(s, style) => return Ok((s, style, expr.span)),\n             ast::LitKind::Err(_) => None,\n             _ => Some(cx.struct_span_err(l.span, err_msg))"}, {"sha": "6b93d045588b9242b62080aecb23cf6fc3704e3d", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -54,11 +54,11 @@ impl<'a> ExtCtxt<'a> {\n         }\n     }\n \n-    pub fn ty(&self, span: Span, ty: ast::TyKind) -> P<ast::Ty> {\n+    pub fn ty(&self, span: Span, kind: ast::TyKind) -> P<ast::Ty> {\n         P(ast::Ty {\n             id: ast::DUMMY_NODE_ID,\n             span,\n-            node: ty\n+            kind,\n         })\n     }\n \n@@ -73,12 +73,12 @@ impl<'a> ExtCtxt<'a> {\n         self.ty_path(self.path_ident(span, ident))\n     }\n \n-    pub fn anon_const(&self, span: Span, expr: ast::ExprKind) -> ast::AnonConst {\n+    pub fn anon_const(&self, span: Span, kind: ast::ExprKind) -> ast::AnonConst {\n         ast::AnonConst {\n             id: ast::DUMMY_NODE_ID,\n             value: P(ast::Expr {\n                 id: ast::DUMMY_NODE_ID,\n-                node: expr,\n+                kind,\n                 span,\n                 attrs: ThinVec::new(),\n             })\n@@ -171,7 +171,7 @@ impl<'a> ExtCtxt<'a> {\n         ast::Stmt {\n             id: ast::DUMMY_NODE_ID,\n             span: expr.span,\n-            node: ast::StmtKind::Expr(expr),\n+            kind: ast::StmtKind::Expr(expr),\n         }\n     }\n \n@@ -193,7 +193,7 @@ impl<'a> ExtCtxt<'a> {\n         });\n         ast::Stmt {\n             id: ast::DUMMY_NODE_ID,\n-            node: ast::StmtKind::Local(local),\n+            kind: ast::StmtKind::Local(local),\n             span: sp,\n         }\n     }\n@@ -210,15 +210,15 @@ impl<'a> ExtCtxt<'a> {\n         });\n         ast::Stmt {\n             id: ast::DUMMY_NODE_ID,\n-            node: ast::StmtKind::Local(local),\n+            kind: ast::StmtKind::Local(local),\n             span,\n         }\n     }\n \n     pub fn stmt_item(&self, sp: Span, item: P<ast::Item>) -> ast::Stmt {\n         ast::Stmt {\n             id: ast::DUMMY_NODE_ID,\n-            node: ast::StmtKind::Item(item),\n+            kind: ast::StmtKind::Item(item),\n             span: sp,\n         }\n     }\n@@ -227,7 +227,7 @@ impl<'a> ExtCtxt<'a> {\n         self.block(expr.span, vec![ast::Stmt {\n             id: ast::DUMMY_NODE_ID,\n             span: expr.span,\n-            node: ast::StmtKind::Expr(expr),\n+            kind: ast::StmtKind::Expr(expr),\n         }])\n     }\n     pub fn block(&self, span: Span, stmts: Vec<ast::Stmt>) -> P<ast::Block> {\n@@ -239,10 +239,10 @@ impl<'a> ExtCtxt<'a> {\n         })\n     }\n \n-    pub fn expr(&self, span: Span, node: ast::ExprKind) -> P<ast::Expr> {\n+    pub fn expr(&self, span: Span, kind: ast::ExprKind) -> P<ast::Expr> {\n         P(ast::Expr {\n             id: ast::DUMMY_NODE_ID,\n-            node,\n+            kind,\n             span,\n             attrs: ThinVec::new(),\n         })\n@@ -411,8 +411,8 @@ impl<'a> ExtCtxt<'a> {\n     }\n \n \n-    pub fn pat(&self, span: Span, pat: PatKind) -> P<ast::Pat> {\n-        P(ast::Pat { id: ast::DUMMY_NODE_ID, node: pat, span })\n+    pub fn pat(&self, span: Span, kind: PatKind) -> P<ast::Pat> {\n+        P(ast::Pat { id: ast::DUMMY_NODE_ID, kind, span })\n     }\n     pub fn pat_wild(&self, span: Span) -> P<ast::Pat> {\n         self.pat(span, PatKind::Wild)\n@@ -567,14 +567,14 @@ impl<'a> ExtCtxt<'a> {\n     }\n \n     pub fn item(&self, span: Span, name: Ident,\n-            attrs: Vec<ast::Attribute>, node: ast::ItemKind) -> P<ast::Item> {\n+            attrs: Vec<ast::Attribute>, kind: ast::ItemKind) -> P<ast::Item> {\n         // FIXME: Would be nice if our generated code didn't violate\n         // Rust coding conventions\n         P(ast::Item {\n             ident: name,\n             attrs,\n             id: ast::DUMMY_NODE_ID,\n-            node,\n+            kind,\n             vis: respan(span.shrink_to_lo(), ast::VisibilityKind::Inherited),\n             span,\n             tokens: None,"}, {"sha": "02e7c6775a49d1ed45098d7d27cdbd3bcfe8fa1b", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -293,15 +293,15 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         let krate_item = AstFragment::Items(smallvec![P(ast::Item {\n             attrs: krate.attrs,\n             span: krate.span,\n-            node: ast::ItemKind::Mod(krate.module),\n+            kind: ast::ItemKind::Mod(krate.module),\n             ident: Ident::invalid(),\n             id: ast::DUMMY_NODE_ID,\n             vis: respan(krate.span.shrink_to_lo(), ast::VisibilityKind::Public),\n             tokens: None,\n         })]);\n \n         match self.fully_expand_fragment(krate_item).make_items().pop().map(P::into_inner) {\n-            Some(ast::Item { attrs, node: ast::ItemKind::Mod(module), .. }) => {\n+            Some(ast::Item { attrs, kind: ast::ItemKind::Mod(module), .. }) => {\n                 krate.attrs = attrs;\n                 krate.module = module;\n             },\n@@ -659,7 +659,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                     if !item.derive_allowed() {\n                         return fragment_kind.dummy(span);\n                     }\n-                    let meta = ast::MetaItem { node: ast::MetaItemKind::Word, span, path };\n+                    let meta = ast::MetaItem { kind: ast::MetaItemKind::Word, span, path };\n                     let items = expander.expand(self.cx, span, &meta, item);\n                     fragment_kind.expect_from_annotatables(items)\n                 }\n@@ -689,7 +689,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n     fn gate_proc_macro_attr_item(&self, span: Span, item: &Annotatable) {\n         let (kind, gate) = match *item {\n             Annotatable::Item(ref item) => {\n-                match item.node {\n+                match item.kind {\n                     ItemKind::Mod(_) if self.cx.ecfg.proc_macro_hygiene() => return,\n                     ItemKind::Mod(_) => (\"modules\", sym::proc_macro_hygiene),\n                     _ => return,\n@@ -737,7 +737,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n \n         impl<'ast, 'a> Visitor<'ast> for DisallowMacros<'a> {\n             fn visit_item(&mut self, i: &'ast ast::Item) {\n-                if let ast::ItemKind::MacroDef(_) = i.node {\n+                if let ast::ItemKind::MacroDef(_) = i.kind {\n                     emit_feature_err(\n                         self.parse_sess,\n                         sym::proc_macro_hygiene,\n@@ -1035,7 +1035,7 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n     fn visit_expr(&mut self, expr: &mut P<ast::Expr>) {\n         self.cfg.configure_expr(expr);\n         visit_clobber(expr.deref_mut(), |mut expr| {\n-            self.cfg.configure_expr_kind(&mut expr.node);\n+            self.cfg.configure_expr_kind(&mut expr.kind);\n \n             // ignore derives so they remain unused\n             let (attr, after_derive) = self.classify_nonitem(&mut expr);\n@@ -1052,7 +1052,7 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n                     .into_inner()\n             }\n \n-            if let ast::ExprKind::Mac(mac) = expr.node {\n+            if let ast::ExprKind::Mac(mac) = expr.kind {\n                 self.check_attributes(&expr.attrs);\n                 self.collect_bang(mac, expr.span, AstFragmentKind::Expr)\n                     .make_expr()\n@@ -1145,7 +1145,7 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n     fn filter_map_expr(&mut self, expr: P<ast::Expr>) -> Option<P<ast::Expr>> {\n         let expr = configure!(self, expr);\n         expr.filter_map(|mut expr| {\n-            self.cfg.configure_expr_kind(&mut expr.node);\n+            self.cfg.configure_expr_kind(&mut expr.kind);\n \n             // Ignore derives so they remain unused.\n             let (attr, after_derive) = self.classify_nonitem(&mut expr);\n@@ -1159,7 +1159,7 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n                     .map(|expr| expr.into_inner())\n             }\n \n-            if let ast::ExprKind::Mac(mac) = expr.node {\n+            if let ast::ExprKind::Mac(mac) = expr.kind {\n                 self.check_attributes(&expr.attrs);\n                 self.collect_bang(mac, expr.span, AstFragmentKind::OptExpr)\n                     .make_opt_expr()\n@@ -1172,13 +1172,13 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n \n     fn visit_pat(&mut self, pat: &mut P<ast::Pat>) {\n         self.cfg.configure_pat(pat);\n-        match pat.node {\n+        match pat.kind {\n             PatKind::Mac(_) => {}\n             _ => return noop_visit_pat(pat, self),\n         }\n \n         visit_clobber(pat, |mut pat| {\n-            match mem::replace(&mut pat.node, PatKind::Wild) {\n+            match mem::replace(&mut pat.kind, PatKind::Wild) {\n                 PatKind::Mac(mac) =>\n                     self.collect_bang(mac, pat.span, AstFragmentKind::Pat).make_pat(),\n                 _ => unreachable!(),\n@@ -1206,7 +1206,7 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n             }\n         }\n \n-        if let StmtKind::Mac(mac) = stmt.node {\n+        if let StmtKind::Mac(mac) = stmt.kind {\n             let (mac, style, attrs) = mac.into_inner();\n             self.check_attributes(&attrs);\n             let mut placeholder = self.collect_bang(mac, stmt.span, AstFragmentKind::Stmts)\n@@ -1224,9 +1224,9 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n         }\n \n         // The placeholder expander gives ids to statements, so we avoid folding the id here.\n-        let ast::Stmt { id, node, span } = stmt;\n-        noop_flat_map_stmt_kind(node, self).into_iter().map(|node| {\n-            ast::Stmt { id, node, span }\n+        let ast::Stmt { id, kind, span } = stmt;\n+        noop_flat_map_stmt_kind(kind, self).into_iter().map(|kind| {\n+            ast::Stmt { id, kind, span }\n         }).collect()\n \n     }\n@@ -1247,10 +1247,10 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n                                      AstFragmentKind::Items, after_derive).make_items();\n         }\n \n-        match item.node {\n+        match item.kind {\n             ast::ItemKind::Mac(..) => {\n                 self.check_attributes(&item.attrs);\n-                item.and_then(|item| match item.node {\n+                item.and_then(|item| match item.kind {\n                     ItemKind::Mac(mac) => self.collect(\n                         AstFragmentKind::Items, InvocationKind::Bang { mac, span: item.span }\n                     ).make_items(),\n@@ -1318,7 +1318,7 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n                                      AstFragmentKind::TraitItems, after_derive).make_trait_items()\n         }\n \n-        match item.node {\n+        match item.kind {\n             ast::TraitItemKind::Macro(mac) => {\n                 let ast::TraitItem { attrs, span, .. } = item;\n                 self.check_attributes(&attrs);\n@@ -1337,7 +1337,7 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n                                      AstFragmentKind::ImplItems, after_derive).make_impl_items();\n         }\n \n-        match item.node {\n+        match item.kind {\n             ast::ImplItemKind::Macro(mac) => {\n                 let ast::ImplItem { attrs, span, .. } = item;\n                 self.check_attributes(&attrs);\n@@ -1348,13 +1348,13 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n     }\n \n     fn visit_ty(&mut self, ty: &mut P<ast::Ty>) {\n-        match ty.node {\n+        match ty.kind {\n             ast::TyKind::Mac(_) => {}\n             _ => return noop_visit_ty(ty, self),\n         };\n \n         visit_clobber(ty, |mut ty| {\n-            match mem::replace(&mut ty.node, ast::TyKind::Err) {\n+            match mem::replace(&mut ty.kind, ast::TyKind::Err) {\n                 ast::TyKind::Mac(mac) =>\n                     self.collect_bang(mac, ty.span, AstFragmentKind::Ty).make_ty(),\n                 _ => unreachable!(),\n@@ -1378,7 +1378,7 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n                                      .make_foreign_items();\n         }\n \n-        if let ast::ForeignItemKind::Macro(mac) = foreign_item.node {\n+        if let ast::ForeignItemKind::Macro(mac) = foreign_item.kind {\n             self.check_attributes(&foreign_item.attrs);\n             return self.collect_bang(mac, foreign_item.span, AstFragmentKind::ForeignItems)\n                 .make_foreign_items();\n@@ -1504,7 +1504,7 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n                     // Check if the user erroneously used `doc(include(...))` syntax.\n                     let literal = it.meta_item_list().and_then(|list| {\n                         if list.len() == 1 {\n-                            list[0].literal().map(|literal| &literal.node)\n+                            list[0].literal().map(|literal| &literal.kind)\n                         } else {\n                             None\n                         }\n@@ -1534,7 +1534,7 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n                 id: at.id,\n                 style: at.style,\n                 path: meta.path,\n-                tokens: meta.node.tokens(meta.span),\n+                tokens: meta.kind.tokens(meta.span),\n                 is_sugared_doc: false,\n             };\n         } else {"}, {"sha": "aec4a683141203e7ba00102cb37a41fb94405192", "filename": "src/libsyntax/ext/mbe/macro_rules.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibsyntax%2Fext%2Fmbe%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibsyntax%2Fext%2Fmbe%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fmbe%2Fmacro_rules.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -302,7 +302,7 @@ pub fn compile_declarative_macro(\n     let tt_spec = ast::Ident::new(sym::tt, def.span);\n \n     // Parse the macro_rules! invocation\n-    let body = match def.node {\n+    let body = match def.kind {\n         ast::ItemKind::MacroDef(ref body) => body,\n         _ => unreachable!(),\n     };"}, {"sha": "8eecef1020d0aaf82eef2eda3134b66b685aecb0", "filename": "src/libsyntax/ext/placeholders.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibsyntax%2Fext%2Fplaceholders.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibsyntax%2Fext%2Fplaceholders.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fplaceholders.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -30,16 +30,16 @@ pub fn placeholder(kind: AstFragmentKind, id: ast::NodeId) -> AstFragment {\n     let expr_placeholder = || P(ast::Expr {\n         id, span,\n         attrs: ThinVec::new(),\n-        node: ast::ExprKind::Mac(mac_placeholder()),\n+        kind: ast::ExprKind::Mac(mac_placeholder()),\n     });\n     let ty = P(ast::Ty {\n         id,\n-        node: ast::TyKind::Mac(mac_placeholder()),\n+        kind: ast::TyKind::Mac(mac_placeholder()),\n         span,\n     });\n     let pat = P(ast::Pat {\n         id,\n-        node: ast::PatKind::Mac(mac_placeholder()),\n+        kind: ast::PatKind::Mac(mac_placeholder()),\n         span,\n     });\n \n@@ -48,34 +48,34 @@ pub fn placeholder(kind: AstFragmentKind, id: ast::NodeId) -> AstFragment {\n         AstFragmentKind::OptExpr => AstFragment::OptExpr(Some(expr_placeholder())),\n         AstFragmentKind::Items => AstFragment::Items(smallvec![P(ast::Item {\n             id, span, ident, vis, attrs,\n-            node: ast::ItemKind::Mac(mac_placeholder()),\n+            kind: ast::ItemKind::Mac(mac_placeholder()),\n             tokens: None,\n         })]),\n         AstFragmentKind::TraitItems => AstFragment::TraitItems(smallvec![ast::TraitItem {\n             id, span, ident, attrs, generics,\n-            node: ast::TraitItemKind::Macro(mac_placeholder()),\n+            kind: ast::TraitItemKind::Macro(mac_placeholder()),\n             tokens: None,\n         }]),\n         AstFragmentKind::ImplItems => AstFragment::ImplItems(smallvec![ast::ImplItem {\n             id, span, ident, vis, attrs, generics,\n-            node: ast::ImplItemKind::Macro(mac_placeholder()),\n+            kind: ast::ImplItemKind::Macro(mac_placeholder()),\n             defaultness: ast::Defaultness::Final,\n             tokens: None,\n         }]),\n         AstFragmentKind::ForeignItems =>\n             AstFragment::ForeignItems(smallvec![ast::ForeignItem {\n                 id, span, ident, vis, attrs,\n-                node: ast::ForeignItemKind::Macro(mac_placeholder()),\n+                kind: ast::ForeignItemKind::Macro(mac_placeholder()),\n             }]),\n         AstFragmentKind::Pat => AstFragment::Pat(P(ast::Pat {\n-            id, span, node: ast::PatKind::Mac(mac_placeholder()),\n+            id, span, kind: ast::PatKind::Mac(mac_placeholder()),\n         })),\n         AstFragmentKind::Ty => AstFragment::Ty(P(ast::Ty {\n-            id, span, node: ast::TyKind::Mac(mac_placeholder()),\n+            id, span, kind: ast::TyKind::Mac(mac_placeholder()),\n         })),\n         AstFragmentKind::Stmts => AstFragment::Stmts(smallvec![{\n             let mac = P((mac_placeholder(), ast::MacStmtStyle::Braces, ThinVec::new()));\n-            ast::Stmt { id, span, node: ast::StmtKind::Mac(mac) }\n+            ast::Stmt { id, span, kind: ast::StmtKind::Mac(mac) }\n         }]),\n         AstFragmentKind::Arms => AstFragment::Arms(smallvec![\n             ast::Arm {\n@@ -251,7 +251,7 @@ impl<'a, 'b> MutVisitor for PlaceholderExpander<'a, 'b> {\n     }\n \n     fn flat_map_item(&mut self, item: P<ast::Item>) -> SmallVec<[P<ast::Item>; 1]> {\n-        match item.node {\n+        match item.kind {\n             ast::ItemKind::Mac(_) => return self.remove(item.id).make_items(),\n             ast::ItemKind::MacroDef(_) => return smallvec![item],\n             _ => {}\n@@ -261,42 +261,42 @@ impl<'a, 'b> MutVisitor for PlaceholderExpander<'a, 'b> {\n     }\n \n     fn flat_map_trait_item(&mut self, item: ast::TraitItem) -> SmallVec<[ast::TraitItem; 1]> {\n-        match item.node {\n+        match item.kind {\n             ast::TraitItemKind::Macro(_) => self.remove(item.id).make_trait_items(),\n             _ => noop_flat_map_trait_item(item, self),\n         }\n     }\n \n     fn flat_map_impl_item(&mut self, item: ast::ImplItem) -> SmallVec<[ast::ImplItem; 1]> {\n-        match item.node {\n+        match item.kind {\n             ast::ImplItemKind::Macro(_) => self.remove(item.id).make_impl_items(),\n             _ => noop_flat_map_impl_item(item, self),\n         }\n     }\n \n     fn flat_map_foreign_item(&mut self, item: ast::ForeignItem) -> SmallVec<[ast::ForeignItem; 1]> {\n-        match item.node {\n+        match item.kind {\n             ast::ForeignItemKind::Macro(_) => self.remove(item.id).make_foreign_items(),\n             _ => noop_flat_map_foreign_item(item, self),\n         }\n     }\n \n     fn visit_expr(&mut self, expr: &mut P<ast::Expr>) {\n-        match expr.node {\n+        match expr.kind {\n             ast::ExprKind::Mac(_) => *expr = self.remove(expr.id).make_expr(),\n             _ => noop_visit_expr(expr, self),\n         }\n     }\n \n     fn filter_map_expr(&mut self, expr: P<ast::Expr>) -> Option<P<ast::Expr>> {\n-        match expr.node {\n+        match expr.kind {\n             ast::ExprKind::Mac(_) => self.remove(expr.id).make_opt_expr(),\n             _ => noop_filter_map_expr(expr, self),\n         }\n     }\n \n     fn flat_map_stmt(&mut self, stmt: ast::Stmt) -> SmallVec<[ast::Stmt; 1]> {\n-        let (style, mut stmts) = match stmt.node {\n+        let (style, mut stmts) = match stmt.kind {\n             ast::StmtKind::Mac(mac) => (mac.1, self.remove(stmt.id).make_stmts()),\n             _ => return noop_flat_map_stmt(stmt, self),\n         };\n@@ -311,14 +311,14 @@ impl<'a, 'b> MutVisitor for PlaceholderExpander<'a, 'b> {\n     }\n \n     fn visit_pat(&mut self, pat: &mut P<ast::Pat>) {\n-        match pat.node {\n+        match pat.kind {\n             ast::PatKind::Mac(_) => *pat = self.remove(pat.id).make_pat(),\n             _ => noop_visit_pat(pat, self),\n         }\n     }\n \n     fn visit_ty(&mut self, ty: &mut P<ast::Ty>) {\n-        match ty.node {\n+        match ty.kind {\n             ast::TyKind::Mac(_) => *ty = self.remove(ty.id).make_ty(),\n             _ => noop_visit_ty(ty, self),\n         }\n@@ -337,7 +337,7 @@ impl<'a, 'b> MutVisitor for PlaceholderExpander<'a, 'b> {\n \n     fn visit_mod(&mut self, module: &mut ast::Mod) {\n         noop_visit_mod(module, self);\n-        module.items.retain(|item| match item.node {\n+        module.items.retain(|item| match item.kind {\n             ast::ItemKind::Mac(_) if !self.cx.ecfg.keep_macs => false, // remove macro definitions\n             _ => true,\n         });"}, {"sha": "e17bbf79fd5e064d1d6e2278080c5cc7422f4564", "filename": "src/libsyntax/ext/proc_macro.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibsyntax%2Fext%2Fproc_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibsyntax%2Fext%2Fproc_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fproc_macro.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -107,7 +107,7 @@ impl MultiItemModifier for ProcMacroDerive {\n                 return Vec::new()\n             }\n         };\n-        match item.node {\n+        match item.kind {\n             ItemKind::Struct(..) |\n             ItemKind::Enum(..) |\n             ItemKind::Union(..) => {},"}, {"sha": "622b48ab9281ef5b0198b8aa51c914f930f74c13", "filename": "src/libsyntax/feature_gate/check.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibsyntax%2Ffeature_gate%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibsyntax%2Ffeature_gate%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate%2Fcheck.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -302,7 +302,7 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n     }\n \n     fn visit_item(&mut self, i: &'a ast::Item) {\n-        match i.node {\n+        match i.kind {\n             ast::ItemKind::ForeignMod(ref foreign_module) => {\n                 self.check_abi(foreign_module.abi, i.span);\n             }\n@@ -408,7 +408,7 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n     }\n \n     fn visit_foreign_item(&mut self, i: &'a ast::ForeignItem) {\n-        match i.node {\n+        match i.kind {\n             ast::ForeignItemKind::Fn(..) |\n             ast::ForeignItemKind::Static(..) => {\n                 let link_name = attr::first_attr_value_str_by_name(&i.attrs, sym::link_name);\n@@ -432,7 +432,7 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n     }\n \n     fn visit_ty(&mut self, ty: &'a ast::Ty) {\n-        match ty.node {\n+        match ty.kind {\n             ast::TyKind::BareFn(ref bare_fn_ty) => {\n                 self.check_abi(bare_fn_ty.abi, ty.span);\n             }\n@@ -447,7 +447,7 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n \n     fn visit_fn_ret_ty(&mut self, ret_ty: &'a ast::FunctionRetTy) {\n         if let ast::FunctionRetTy::Ty(ref output_ty) = *ret_ty {\n-            if let ast::TyKind::Never = output_ty.node {\n+            if let ast::TyKind::Never = output_ty.kind {\n                 // Do nothing.\n             } else {\n                 self.visit_ty(output_ty)\n@@ -456,7 +456,7 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n     }\n \n     fn visit_expr(&mut self, e: &'a ast::Expr) {\n-        match e.node {\n+        match e.kind {\n             ast::ExprKind::Box(_) => {\n                 gate_feature_post!(&self, box_syntax, e.span, EXPLAIN_BOX_SYNTAX);\n             }\n@@ -487,11 +487,11 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n     }\n \n     fn visit_pat(&mut self, pattern: &'a ast::Pat) {\n-        match &pattern.node {\n+        match &pattern.kind {\n             PatKind::Slice(pats) => {\n                 for pat in &*pats {\n                     let span = pat.span;\n-                    let inner_pat = match &pat.node {\n+                    let inner_pat = match &pat.kind {\n                         PatKind::Ident(.., Some(pat)) => pat,\n                         _ => pat,\n                     };\n@@ -559,7 +559,7 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n     }\n \n     fn visit_trait_item(&mut self, ti: &'a ast::TraitItem) {\n-        match ti.node {\n+        match ti.kind {\n             ast::TraitItemKind::Method(ref sig, ref block) => {\n                 if block.is_none() {\n                     self.check_abi(sig.header.abi, ti.span);\n@@ -600,7 +600,7 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n                               \"specialization is unstable\");\n         }\n \n-        match ii.node {\n+        match ii.kind {\n             ast::ImplItemKind::Method(..) => {}\n             ast::ImplItemKind::OpaqueTy(..) => {\n                 gate_feature_post!("}, {"sha": "43b5df38e143cbddca4d2b78801174c9092ce1a5", "filename": "src/libsyntax/mut_visit.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibsyntax%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibsyntax%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fmut_visit.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -432,9 +432,9 @@ pub fn noop_visit_ty_constraint<T: MutVisitor>(\n }\n \n pub fn noop_visit_ty<T: MutVisitor>(ty: &mut P<Ty>, vis: &mut T) {\n-    let Ty { id, node, span } = ty.deref_mut();\n+    let Ty { id, kind, span } = ty.deref_mut();\n     vis.visit_id(id);\n-    match node {\n+    match kind {\n         TyKind::Infer | TyKind::ImplicitSelf | TyKind::Err |\n             TyKind::Never | TyKind::CVarArgs => {}\n         TyKind::Slice(ty) => vis.visit_ty(ty),\n@@ -576,8 +576,8 @@ pub fn noop_visit_meta_list_item<T: MutVisitor>(li: &mut NestedMetaItem, vis: &m\n }\n \n pub fn noop_visit_meta_item<T: MutVisitor>(mi: &mut MetaItem, vis: &mut T) {\n-    let MetaItem { path: _, node, span } = mi;\n-    match node {\n+    let MetaItem { path: _, kind, span } = mi;\n+    match kind {\n         MetaItemKind::Word => {}\n         MetaItemKind::List(mis) => visit_vec(mis, |mi| vis.visit_meta_list_item(mi)),\n         MetaItemKind::NameValue(_s) => {}\n@@ -921,12 +921,12 @@ pub fn noop_visit_item_kind<T: MutVisitor>(kind: &mut ItemKind, vis: &mut T) {\n pub fn noop_flat_map_trait_item<T: MutVisitor>(mut item: TraitItem, vis: &mut T)\n     -> SmallVec<[TraitItem; 1]>\n {\n-    let TraitItem { id, ident, attrs, generics, node, span, tokens: _ } = &mut item;\n+    let TraitItem { id, ident, attrs, generics, kind, span, tokens: _ } = &mut item;\n     vis.visit_id(id);\n     vis.visit_ident(ident);\n     visit_attrs(attrs, vis);\n     vis.visit_generics(generics);\n-    match node {\n+    match kind {\n         TraitItemKind::Const(ty, default) => {\n             vis.visit_ty(ty);\n             visit_opt(default, |default| vis.visit_expr(default));\n@@ -951,14 +951,14 @@ pub fn noop_flat_map_trait_item<T: MutVisitor>(mut item: TraitItem, vis: &mut T)\n pub fn noop_flat_map_impl_item<T: MutVisitor>(mut item: ImplItem, visitor: &mut T)\n                                               -> SmallVec<[ImplItem; 1]>\n {\n-    let ImplItem { id, ident, vis, defaultness: _, attrs, generics, node, span, tokens: _ } =\n+    let ImplItem { id, ident, vis, defaultness: _, attrs, generics, kind, span, tokens: _ } =\n         &mut item;\n     visitor.visit_id(id);\n     visitor.visit_ident(ident);\n     visitor.visit_vis(vis);\n     visit_attrs(attrs, visitor);\n     visitor.visit_generics(generics);\n-    match node  {\n+    match kind  {\n         ImplItemKind::Const(ty, expr) => {\n             visitor.visit_ty(ty);\n             visitor.visit_expr(expr);\n@@ -994,7 +994,7 @@ pub fn noop_visit_crate<T: MutVisitor>(krate: &mut Crate, vis: &mut T) {\n             id: DUMMY_NODE_ID,\n             vis: respan(span.shrink_to_lo(), VisibilityKind::Public),\n             span,\n-            node: ItemKind::Mod(module),\n+            kind: ItemKind::Mod(module),\n             tokens: None,\n         });\n         let items = vis.flat_map_item(item);\n@@ -1004,8 +1004,8 @@ pub fn noop_visit_crate<T: MutVisitor>(krate: &mut Crate, vis: &mut T) {\n             let module = Mod { inner: span, items: vec![], inline: true };\n             Crate { module, attrs: vec![], span }\n         } else if len == 1 {\n-            let Item { attrs, span, node, .. } = items.into_iter().next().unwrap().into_inner();\n-            match node {\n+            let Item { attrs, span, kind, .. } = items.into_iter().next().unwrap().into_inner();\n+            match kind {\n                 ItemKind::Mod(module) => Crate { module, attrs, span },\n                 _ => panic!(\"visitor converted a module to not a module\"),\n             }\n@@ -1018,11 +1018,11 @@ pub fn noop_visit_crate<T: MutVisitor>(krate: &mut Crate, vis: &mut T) {\n // Mutates one item into possibly many items.\n pub fn noop_flat_map_item<T: MutVisitor>(mut item: P<Item>, visitor: &mut T)\n                                          -> SmallVec<[P<Item>; 1]> {\n-    let Item { ident, attrs, id, node, vis, span, tokens: _ } = item.deref_mut();\n+    let Item { ident, attrs, id, kind, vis, span, tokens: _ } = item.deref_mut();\n     visitor.visit_ident(ident);\n     visit_attrs(attrs, visitor);\n     visitor.visit_id(id);\n-    visitor.visit_item_kind(node);\n+    visitor.visit_item_kind(kind);\n     visitor.visit_vis(vis);\n     visitor.visit_span(span);\n \n@@ -1035,10 +1035,10 @@ pub fn noop_flat_map_item<T: MutVisitor>(mut item: P<Item>, visitor: &mut T)\n pub fn noop_flat_map_foreign_item<T: MutVisitor>(mut item: ForeignItem, visitor: &mut T)\n     -> SmallVec<[ForeignItem; 1]>\n {\n-    let ForeignItem { ident, attrs, node, id, span, vis } = &mut item;\n+    let ForeignItem { ident, attrs, kind, id, span, vis } = &mut item;\n     visitor.visit_ident(ident);\n     visit_attrs(attrs, visitor);\n-    match node {\n+    match kind {\n         ForeignItemKind::Fn(fdec, generics) => {\n             visitor.visit_fn_decl(fdec);\n             visitor.visit_generics(generics);\n@@ -1055,9 +1055,9 @@ pub fn noop_flat_map_foreign_item<T: MutVisitor>(mut item: ForeignItem, visitor:\n }\n \n pub fn noop_visit_pat<T: MutVisitor>(pat: &mut P<Pat>, vis: &mut T) {\n-    let Pat { id, node, span } = pat.deref_mut();\n+    let Pat { id, kind, span } = pat.deref_mut();\n     vis.visit_id(id);\n-    match node {\n+    match kind {\n         PatKind::Wild | PatKind::Rest => {}\n         PatKind::Ident(_binding_mode, ident, sub) => {\n             vis.visit_ident(ident);\n@@ -1097,8 +1097,8 @@ pub fn noop_visit_anon_const<T: MutVisitor>(AnonConst { id, value }: &mut AnonCo\n     vis.visit_expr(value);\n }\n \n-pub fn noop_visit_expr<T: MutVisitor>(Expr { node, id, span, attrs }: &mut Expr, vis: &mut T) {\n-    match node {\n+pub fn noop_visit_expr<T: MutVisitor>(Expr { kind, id, span, attrs }: &mut Expr, vis: &mut T) {\n+    match kind {\n         ExprKind::Box(expr) => vis.visit_expr(expr),\n         ExprKind::Array(exprs) => visit_exprs(exprs, vis),\n         ExprKind::Repeat(expr, count) => {\n@@ -1247,19 +1247,19 @@ pub fn noop_filter_map_expr<T: MutVisitor>(mut e: P<Expr>, vis: &mut T) -> Optio\n     Some({ vis.visit_expr(&mut e); e })\n }\n \n-pub fn noop_flat_map_stmt<T: MutVisitor>(Stmt { node, mut span, mut id }: Stmt, vis: &mut T)\n+pub fn noop_flat_map_stmt<T: MutVisitor>(Stmt { kind, mut span, mut id }: Stmt, vis: &mut T)\n     -> SmallVec<[Stmt; 1]>\n {\n     vis.visit_id(&mut id);\n     vis.visit_span(&mut span);\n-    noop_flat_map_stmt_kind(node, vis).into_iter().map(|node| {\n-        Stmt { id, node, span }\n+    noop_flat_map_stmt_kind(kind, vis).into_iter().map(|kind| {\n+        Stmt { id, kind, span }\n     }).collect()\n }\n \n-pub fn noop_flat_map_stmt_kind<T: MutVisitor>(node: StmtKind, vis: &mut T)\n+pub fn noop_flat_map_stmt_kind<T: MutVisitor>(kind: StmtKind, vis: &mut T)\n                                               -> SmallVec<[StmtKind; 1]> {\n-    match node {\n+    match kind {\n         StmtKind::Local(mut local) =>\n             smallvec![StmtKind::Local({ vis.visit_local(&mut local); local })],\n         StmtKind::Item(item) => vis.flat_map_item(item).into_iter().map(StmtKind::Item).collect(),"}, {"sha": "44688bd36b5fbb3182261e297b8a7240e9844411", "filename": "src/libsyntax/parse/attr.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibsyntax%2Fparse%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibsyntax%2Fparse%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fattr.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -179,7 +179,7 @@ impl<'a> Parser<'a> {\n         };\n         Ok(if let Some(meta) = meta {\n             self.bump();\n-            (meta.path, meta.node.tokens(meta.span))\n+            (meta.path, meta.kind.tokens(meta.span))\n         } else {\n             let path = self.parse_path(PathStyle::Mod)?;\n             let tokens = if self.check(&token::OpenDelim(DelimToken::Paren)) ||\n@@ -249,7 +249,7 @@ impl<'a> Parser<'a> {\n         let lit = self.parse_lit()?;\n         debug!(\"checking if {:?} is unusuffixed\", lit);\n \n-        if !lit.node.is_unsuffixed() {\n+        if !lit.kind.is_unsuffixed() {\n             let msg = \"suffixed literals are not allowed in attributes\";\n             self.diagnostic().struct_span_err(lit.span, msg)\n                              .help(\"instead of using a suffixed literal \\\n@@ -281,9 +281,9 @@ impl<'a> Parser<'a> {\n \n         let lo = self.token.span;\n         let path = self.parse_path(PathStyle::Mod)?;\n-        let node = self.parse_meta_item_kind()?;\n+        let kind = self.parse_meta_item_kind()?;\n         let span = lo.to(self.prev_span);\n-        Ok(ast::MetaItem { path, node, span })\n+        Ok(ast::MetaItem { path, kind, span })\n     }\n \n     crate fn parse_meta_item_kind(&mut self) -> PResult<'a, ast::MetaItemKind> {"}, {"sha": "4456068875019fd347260ce8c7b4f7abc412be23", "filename": "src/libsyntax/parse/classify.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibsyntax%2Fparse%2Fclassify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibsyntax%2Fparse%2Fclassify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fclassify.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -12,7 +12,7 @@ use crate::ast;\n ///      |x| 5\n /// isn't parsed as (if true {...} else {...} | x) | 5\n pub fn expr_requires_semi_to_be_stmt(e: &ast::Expr) -> bool {\n-    match e.node {\n+    match e.kind {\n         ast::ExprKind::If(..) |\n         ast::ExprKind::Match(..) |\n         ast::ExprKind::Block(..) |"}, {"sha": "ec5d00e0952d79925c18b2b3ad3619cdc87fce66", "filename": "src/libsyntax/parse/diagnostics.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibsyntax%2Fparse%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibsyntax%2Fparse%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fdiagnostics.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -21,11 +21,11 @@ use std::mem;\n crate fn dummy_arg(ident: Ident) -> Param {\n     let pat = P(Pat {\n         id: ast::DUMMY_NODE_ID,\n-        node: PatKind::Ident(BindingMode::ByValue(Mutability::Immutable), ident, None),\n+        kind: PatKind::Ident(BindingMode::ByValue(Mutability::Immutable), ident, None),\n         span: ident.span,\n     });\n     let ty = Ty {\n-        node: TyKind::Err,\n+        kind: TyKind::Err,\n         span: ident.span,\n         id: ast::DUMMY_NODE_ID\n     };\n@@ -135,7 +135,7 @@ impl RecoverQPath for Ty {\n     fn recovered(qself: Option<QSelf>, path: ast::Path) -> Self {\n         Self {\n             span: path.span,\n-            node: TyKind::Path(qself, path),\n+            kind: TyKind::Path(qself, path),\n             id: ast::DUMMY_NODE_ID,\n         }\n     }\n@@ -148,7 +148,7 @@ impl RecoverQPath for Pat {\n     fn recovered(qself: Option<QSelf>, path: ast::Path) -> Self {\n         Self {\n             span: path.span,\n-            node: PatKind::Path(qself, path),\n+            kind: PatKind::Path(qself, path),\n             id: ast::DUMMY_NODE_ID,\n         }\n     }\n@@ -161,7 +161,7 @@ impl RecoverQPath for Expr {\n     fn recovered(qself: Option<QSelf>, path: ast::Path) -> Self {\n         Self {\n             span: path.span,\n-            node: ExprKind::Path(qself, path),\n+            kind: ExprKind::Path(qself, path),\n             attrs: ThinVec::new(),\n             id: ast::DUMMY_NODE_ID,\n         }\n@@ -549,7 +549,7 @@ impl<'a> Parser<'a> {\n         debug_assert!(outer_op.is_comparison(),\n                       \"check_no_chained_comparison: {:?} is not comparison\",\n                       outer_op);\n-        match lhs.node {\n+        match lhs.kind {\n             ExprKind::Binary(op, _, _) if op.node.is_comparison() => {\n                 // Respan to include both operators.\n                 let op_span = op.span.to(self.token.span);\n@@ -663,7 +663,7 @@ impl<'a> Parser<'a> {\n             pprust::ty_to_string(ty)\n         );\n \n-        match ty.node {\n+        match ty.kind {\n             TyKind::Rptr(ref lifetime, ref mut_ty) => {\n                 let sum_with_parens = pprust::to_string(|s| {\n                     s.s.word(\"&\");\n@@ -761,7 +761,7 @@ impl<'a> Parser<'a> {\n             );\n             if !items.is_empty() {\n                 let previous_item = &items[items.len() - 1];\n-                let previous_item_kind_name = match previous_item.node {\n+                let previous_item_kind_name = match previous_item.kind {\n                     // Say \"braced struct\" because tuple-structs and\n                     // braceless-empty-struct declarations do take a semicolon.\n                     ItemKind::Struct(..) => Some(\"braced struct\"),\n@@ -915,7 +915,7 @@ impl<'a> Parser<'a> {\n             .unwrap_or_else(|_| pprust::expr_to_string(&expr));\n         let suggestion = format!(\"{}.await{}\", expr_str, if is_question { \"?\" } else { \"\" });\n         let sp = lo.to(hi);\n-        let app = match expr.node {\n+        let app = match expr.kind {\n             ExprKind::Try(_) => Applicability::MaybeIncorrect, // `await <expr>?`\n             _ => Applicability::MachineApplicable,\n         };\n@@ -978,7 +978,7 @@ impl<'a> Parser<'a> {\n                     .emit();\n \n                 // Unwrap `(pat)` into `pat` to avoid the `unused_parens` lint.\n-                pat.and_then(|pat| match pat.node {\n+                pat.and_then(|pat| match pat.kind {\n                     PatKind::Paren(pat) => pat,\n                     _ => P(pat),\n                 })\n@@ -1237,7 +1237,7 @@ impl<'a> Parser<'a> {\n                 Applicability::HasPlaceholders,\n             );\n             return Some(ident);\n-        } else if let PatKind::Ident(_, ident, _) = pat.node {\n+        } else if let PatKind::Ident(_, ident, _) = pat.kind {\n             if require_name && (\n                 is_trait_item ||\n                 self.token == token::Comma ||\n@@ -1283,7 +1283,7 @@ impl<'a> Parser<'a> {\n \n         // Pretend the pattern is `_`, to avoid duplicate errors from AST validation.\n         let pat = P(Pat {\n-            node: PatKind::Wild,\n+            kind: PatKind::Wild,\n             span: pat.span,\n             id: ast::DUMMY_NODE_ID\n         });\n@@ -1296,7 +1296,7 @@ impl<'a> Parser<'a> {\n         is_trait_item: bool,\n     ) -> PResult<'a, ast::Param> {\n         let sp = param.pat.span;\n-        param.ty.node = TyKind::Err;\n+        param.ty.kind = TyKind::Err;\n         let mut err = self.struct_span_err(sp, \"unexpected `self` parameter in function\");\n         if is_trait_item {\n             err.span_label(sp, \"must be the first associated function parameter\");\n@@ -1360,15 +1360,15 @@ impl<'a> Parser<'a> {\n         let mut seen_inputs = FxHashSet::default();\n         for input in fn_inputs.iter_mut() {\n             let opt_ident = if let (PatKind::Ident(_, ident, _), TyKind::Err) = (\n-                &input.pat.node, &input.ty.node,\n+                &input.pat.kind, &input.ty.kind,\n             ) {\n                 Some(*ident)\n             } else {\n                 None\n             };\n             if let Some(ident) = opt_ident {\n                 if seen_inputs.contains(&ident) {\n-                    input.pat.node = PatKind::Wild;\n+                    input.pat.kind = PatKind::Wild;\n                 }\n                 seen_inputs.insert(ident);\n             }"}, {"sha": "fcd5b2782fd61e14ca85f03f697e3a9c17af66ee", "filename": "src/libsyntax/parse/literal.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibsyntax%2Fparse%2Fliteral.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibsyntax%2Fparse%2Fliteral.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fliteral.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -255,7 +255,7 @@ impl LitKind {\n impl Lit {\n     /// Converts literal token into an AST literal.\n     fn from_lit_token(token: token::Lit, span: Span) -> Result<Lit, LitError> {\n-        Ok(Lit { token, node: LitKind::from_lit_token(token)?, span })\n+        Ok(Lit { token, kind: LitKind::from_lit_token(token)?, span })\n     }\n \n     /// Converts arbitrary token into an AST literal.\n@@ -267,7 +267,7 @@ impl Lit {\n                 lit,\n             token::Interpolated(ref nt) => {\n                 if let token::NtExpr(expr) | token::NtLiteral(expr) = &**nt {\n-                    if let ast::ExprKind::Lit(lit) = &expr.node {\n+                    if let ast::ExprKind::Lit(lit) = &expr.kind {\n                         return Ok(lit.clone());\n                     }\n                 }\n@@ -282,8 +282,8 @@ impl Lit {\n     /// Attempts to recover an AST literal from semantic literal.\n     /// This function is used when the original token doesn't exist (e.g. the literal is created\n     /// by an AST-based macro) or unavailable (e.g. from HIR pretty-printing).\n-    pub fn from_lit_kind(node: LitKind, span: Span) -> Lit {\n-        Lit { token: node.to_lit_token(), node, span }\n+    pub fn from_lit_kind(kind: LitKind, span: Span) -> Lit {\n+        Lit { token: kind.to_lit_token(), kind, span }\n     }\n \n     /// Losslessly convert an AST literal into a token stream."}, {"sha": "cc582819b6b6150a5ba60ae41253cde223e8b8cb", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -1212,7 +1212,7 @@ impl<'a> Parser<'a> {\n                 do_not_enforce_named_arguments_for_c_variadic\n             ) {\n                 Ok(param) => {\n-                    if let TyKind::CVarArgs = param.ty.node {\n+                    if let TyKind::CVarArgs = param.ty.kind {\n                         c_variadic = true;\n                         if p.token != token::CloseDelim(token::Paren) {\n                             let span = p.token.span;"}, {"sha": "c776704b285aaad47a2124282776b01a0cd2f476", "filename": "src/libsyntax/parse/parser/expr.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibsyntax%2Fparse%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibsyntax%2Fparse%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser%2Fexpr.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -210,7 +210,7 @@ impl<'a> Parser<'a> {\n             // it refers to. Interpolated identifiers are unwrapped early and never show up here\n             // as `PrevTokenKind::Interpolated` so if LHS is a single identifier we always process\n             // it as \"interpolated\", it doesn't change the answer for non-interpolated idents.\n-            let lhs_span = match (self.prev_token_kind, &lhs.node) {\n+            let lhs_span = match (self.prev_token_kind, &lhs.kind) {\n                 (PrevTokenKind::Interpolated, _) => self.prev_span,\n                 (PrevTokenKind::Ident, &ExprKind::Path(None, ref path))\n                     if path.segments.len() == 1 => self.prev_span,\n@@ -245,7 +245,7 @@ impl<'a> Parser<'a> {\n                 lhs = self.parse_assoc_op_cast(lhs, lhs_span, ExprKind::Cast)?;\n                 continue\n             } else if op == AssocOp::Colon {\n-                let maybe_path = self.could_ascription_be_path(&lhs.node);\n+                let maybe_path = self.could_ascription_be_path(&lhs.kind);\n                 self.last_type_ascription = Some((self.prev_span, maybe_path));\n \n                 lhs = self.parse_assoc_op_cast(lhs, lhs_span, ExprKind::Type)?;\n@@ -555,7 +555,7 @@ impl<'a> Parser<'a> {\n                         let span_after_type = parser_snapshot_after_type.token.span;\n                         let expr = mk_expr(self, P(Ty {\n                             span: path.span,\n-                            node: TyKind::Path(None, path),\n+                            kind: TyKind::Path(None, path),\n                             id: DUMMY_NODE_ID,\n                         }));\n \n@@ -614,7 +614,7 @@ impl<'a> Parser<'a> {\n             expr.map(|mut expr| {\n                 attrs.extend::<Vec<_>>(expr.attrs.into());\n                 expr.attrs = attrs;\n-                match expr.node {\n+                match expr.kind {\n                     ExprKind::If(..) if !expr.attrs.is_empty() => {\n                         // Just point to the first attribute in there...\n                         let span = expr.attrs[0].span;\n@@ -1190,7 +1190,7 @@ impl<'a> Parser<'a> {\n         } else {\n             P(Ty {\n                 id: DUMMY_NODE_ID,\n-                node: TyKind::Infer,\n+                kind: TyKind::Infer,\n                 span: self.prev_span,\n             })\n         };\n@@ -1242,7 +1242,7 @@ impl<'a> Parser<'a> {\n     fn parse_cond_expr(&mut self) -> PResult<'a, P<Expr>> {\n         let cond = self.parse_expr_res(Restrictions::NO_STRUCT_LITERAL, None)?;\n \n-        if let ExprKind::Let(..) = cond.node {\n+        if let ExprKind::Let(..) = cond.kind {\n             // Remove the last feature gating of a `let` expression since it's stable.\n             let last = self.sess.gated_spans.let_chains.borrow_mut().pop();\n             debug_assert_eq!(cond.span, last.unwrap());\n@@ -1779,7 +1779,7 @@ impl<'a> Parser<'a> {\n         Ok(await_expr)\n     }\n \n-    crate fn mk_expr(&self, span: Span, node: ExprKind, attrs: ThinVec<Attribute>) -> P<Expr> {\n-        P(Expr { node, span, attrs, id: DUMMY_NODE_ID })\n+    crate fn mk_expr(&self, span: Span, kind: ExprKind, attrs: ThinVec<Attribute>) -> P<Expr> {\n+        P(Expr { kind, span, attrs, id: DUMMY_NODE_ID })\n     }\n }"}, {"sha": "370030d02c717f30309d7066de0360685187aaec", "filename": "src/libsyntax/parse/parser/item.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibsyntax%2Fparse%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibsyntax%2Fparse%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser%2Fitem.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -678,7 +678,7 @@ impl<'a> Parser<'a> {\n                           self.look_ahead(1, |t| t != &token::Lt) {\n             let span = self.prev_span.between(self.token.span);\n             self.struct_span_err(span, \"missing trait in a trait impl\").emit();\n-            P(Ty { node: TyKind::Path(None, err_path(span)), span, id: DUMMY_NODE_ID })\n+            P(Ty { kind: TyKind::Path(None, err_path(span)), span, id: DUMMY_NODE_ID })\n         } else {\n             self.parse_ty()?\n         };\n@@ -715,7 +715,7 @@ impl<'a> Parser<'a> {\n                 }\n \n                 let ty_first = ty_first.into_inner();\n-                let path = match ty_first.node {\n+                let path = match ty_first.kind {\n                     // This notably includes paths passed through `ty` macro fragments (#46438).\n                     TyKind::Path(None, path) => path,\n                     _ => {\n@@ -783,7 +783,7 @@ impl<'a> Parser<'a> {\n         let lo = self.token.span;\n         let vis = self.parse_visibility(false)?;\n         let defaultness = self.parse_defaultness();\n-        let (name, node, generics) = if let Some(type_) = self.eat_type() {\n+        let (name, kind, generics) = if let Some(type_) = self.eat_type() {\n             let (name, alias, generics) = type_?;\n             let kind = match alias {\n                 AliasKind::Weak(typ) => ast::ImplItemKind::TyAlias(typ),\n@@ -802,9 +802,9 @@ impl<'a> Parser<'a> {\n             self.expect(&token::Semi)?;\n             (name, ast::ImplItemKind::Const(typ, expr), Generics::default())\n         } else {\n-            let (name, inner_attrs, generics, node) = self.parse_impl_method(&vis, at_end)?;\n+            let (name, inner_attrs, generics, kind) = self.parse_impl_method(&vis, at_end)?;\n             attrs.extend(inner_attrs);\n-            (name, node, generics)\n+            (name, kind, generics)\n         };\n \n         Ok(ImplItem {\n@@ -815,7 +815,7 @@ impl<'a> Parser<'a> {\n             defaultness,\n             attrs,\n             generics,\n-            node,\n+            kind,\n             tokens: None,\n         })\n     }\n@@ -1009,7 +1009,7 @@ impl<'a> Parser<'a> {\n                          mut attrs: Vec<Attribute>) -> PResult<'a, TraitItem> {\n         let lo = self.token.span;\n         self.eat_bad_pub();\n-        let (name, node, generics) = if self.eat_keyword(kw::Type) {\n+        let (name, kind, generics) = if self.eat_keyword(kw::Type) {\n             self.parse_trait_item_assoc_ty()?\n         } else if self.is_const_item() {\n             self.expect_keyword(kw::Const)?;\n@@ -1094,7 +1094,7 @@ impl<'a> Parser<'a> {\n             ident: name,\n             attrs,\n             generics,\n-            node,\n+            kind,\n             span: lo.to(self.prev_span),\n             tokens: None,\n         })\n@@ -1383,7 +1383,7 @@ impl<'a> Parser<'a> {\n                         id: DUMMY_NODE_ID,\n                         attrs,\n                         vis: visibility,\n-                        node: ForeignItemKind::Macro(mac),\n+                        kind: ForeignItemKind::Macro(mac),\n                     }\n                 )\n             }\n@@ -1415,7 +1415,7 @@ impl<'a> Parser<'a> {\n         Ok(ast::ForeignItem {\n             ident,\n             attrs,\n-            node: ForeignItemKind::Fn(decl, generics),\n+            kind: ForeignItemKind::Fn(decl, generics),\n             id: DUMMY_NODE_ID,\n             span: lo.to(hi),\n             vis,\n@@ -1435,7 +1435,7 @@ impl<'a> Parser<'a> {\n         Ok(ForeignItem {\n             ident,\n             attrs,\n-            node: ForeignItemKind::Static(ty, mutbl),\n+            kind: ForeignItemKind::Static(ty, mutbl),\n             id: DUMMY_NODE_ID,\n             span: lo.to(hi),\n             vis,\n@@ -1453,7 +1453,7 @@ impl<'a> Parser<'a> {\n         Ok(ast::ForeignItem {\n             ident,\n             attrs,\n-            node: ForeignItemKind::Ty,\n+            kind: ForeignItemKind::Ty,\n             id: DUMMY_NODE_ID,\n             span: lo.to(hi),\n             vis\n@@ -1526,7 +1526,7 @@ impl<'a> Parser<'a> {\n         // The user intended that the type be inferred,\n         // so treat this as if the user wrote e.g. `const A: _ = expr;`.\n         P(Ty {\n-            node: TyKind::Infer,\n+            kind: TyKind::Infer,\n             span: id.span,\n             id: ast::DUMMY_NODE_ID,\n         })\n@@ -1949,13 +1949,13 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    fn mk_item(&self, span: Span, ident: Ident, node: ItemKind, vis: Visibility,\n+    fn mk_item(&self, span: Span, ident: Ident, kind: ItemKind, vis: Visibility,\n                attrs: Vec<Attribute>) -> P<Item> {\n         P(Item {\n             ident,\n             attrs,\n             id: DUMMY_NODE_ID,\n-            node,\n+            kind,\n             vis,\n             span,\n             tokens: None,"}, {"sha": "de72f1c4d4906f66749bef670870c0478b1afa35", "filename": "src/libsyntax/parse/parser/pat.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibsyntax%2Fparse%2Fparser%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibsyntax%2Fparse%2Fparser%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser%2Fpat.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -66,7 +66,7 @@ impl<'a> Parser<'a> {\n         self.recover_leading_vert(\"not allowed in a parameter pattern\");\n         let pat = self.parse_pat_with_or(PARAM_EXPECTED, GateOr::No, RecoverComma::No)?;\n \n-        if let PatKind::Or(..) = &pat.node {\n+        if let PatKind::Or(..) = &pat.kind {\n             self.ban_illegal_fn_param_or_pat(&pat);\n         }\n \n@@ -324,7 +324,7 @@ impl<'a> Parser<'a> {\n \n     /// Ban a range pattern if it has an ambiguous interpretation.\n     fn ban_pat_range_if_ambiguous(&self, pat: &Pat) -> PResult<'a, ()> {\n-        match pat.node {\n+        match pat.kind {\n             PatKind::Range(\n                 .., Spanned { node: RangeEnd::Included(RangeSyntax::DotDotDot), .. }\n             ) => return Ok(()),\n@@ -399,12 +399,12 @@ impl<'a> Parser<'a> {\n \n         // Unwrap; If we don't have `mut $ident`, error.\n         let pat = pat.into_inner();\n-        match &pat.node {\n+        match &pat.kind {\n             PatKind::Ident(..) => {}\n             _ => self.ban_mut_general_pat(mut_span, &pat, changed_any_binding),\n         }\n \n-        Ok(pat.node)\n+        Ok(pat.kind)\n     }\n \n     /// Recover on `mut ref? ident @ pat` and suggest\n@@ -430,7 +430,7 @@ impl<'a> Parser<'a> {\n         impl MutVisitor for AddMut {\n             fn visit_pat(&mut self, pat: &mut P<Pat>) {\n                 if let PatKind::Ident(BindingMode::ByValue(ref mut m @ Mutability::Immutable), ..)\n-                    = pat.node\n+                    = pat.kind\n                 {\n                     *m = Mutability::Mutable;\n                     self.0 = true;\n@@ -890,7 +890,7 @@ impl<'a> Parser<'a> {\n         self.mk_pat(span, PatKind::Ident(bm, ident, None))\n     }\n \n-    fn mk_pat(&self, span: Span, node: PatKind) -> P<Pat> {\n-        P(Pat { node, span, id: ast::DUMMY_NODE_ID })\n+    fn mk_pat(&self, span: Span, kind: PatKind) -> P<Pat> {\n+        P(Pat { kind, span, id: ast::DUMMY_NODE_ID })\n     }\n }"}, {"sha": "463ae9124ca23e2beb4432460d4646771050d816", "filename": "src/libsyntax/parse/parser/path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibsyntax%2Fparse%2Fparser%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibsyntax%2Fparse%2Fparser%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser%2Fpath.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -114,7 +114,7 @@ impl<'a> Parser<'a> {\n     pub fn parse_path_allowing_meta(&mut self, style: PathStyle) -> PResult<'a, Path> {\n         let meta_ident = match self.token.kind {\n             token::Interpolated(ref nt) => match **nt {\n-                token::NtMeta(ref meta) => match meta.node {\n+                token::NtMeta(ref meta) => match meta.kind {\n                     ast::MetaItemKind::Word => Some(meta.path.clone()),\n                     _ => None,\n                 },"}, {"sha": "855b03ddd6f6b999580de98ce561dd6b8178c770", "filename": "src/libsyntax/parse/parser/stmt.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibsyntax%2Fparse%2Fparser%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibsyntax%2Fparse%2Fparser%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser%2Fstmt.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -44,7 +44,7 @@ impl<'a> Parser<'a> {\n         Ok(Some(if self.eat_keyword(kw::Let) {\n             Stmt {\n                 id: DUMMY_NODE_ID,\n-                node: StmtKind::Local(self.parse_local(attrs.into())?),\n+                kind: StmtKind::Local(self.parse_local(attrs.into())?),\n                 span: lo.to(self.prev_span),\n             }\n         } else if let Some(macro_def) = self.eat_macro_def(\n@@ -54,7 +54,7 @@ impl<'a> Parser<'a> {\n         )? {\n             Stmt {\n                 id: DUMMY_NODE_ID,\n-                node: StmtKind::Item(macro_def),\n+                kind: StmtKind::Item(macro_def),\n                 span: lo.to(self.prev_span),\n             }\n         // Starts like a simple path, being careful to avoid contextual keywords\n@@ -86,7 +86,7 @@ impl<'a> Parser<'a> {\n \n                 return Ok(Some(Stmt {\n                     id: DUMMY_NODE_ID,\n-                    node: StmtKind::Expr(expr),\n+                    kind: StmtKind::Expr(expr),\n                     span: lo.to(self.prev_span),\n                 }));\n             }\n@@ -107,7 +107,7 @@ impl<'a> Parser<'a> {\n                 span: lo.to(hi),\n                 prior_type_ascription: self.last_type_ascription,\n             };\n-            let node = if delim == MacDelimiter::Brace ||\n+            let kind = if delim == MacDelimiter::Brace ||\n                           self.token == token::Semi || self.token == token::Eof {\n                 StmtKind::Mac(P((mac, style, attrs.into())))\n             }\n@@ -137,7 +137,7 @@ impl<'a> Parser<'a> {\n             Stmt {\n                 id: DUMMY_NODE_ID,\n                 span: lo.to(hi),\n-                node,\n+                kind,\n             }\n         } else {\n             // FIXME: Bad copy of attrs\n@@ -150,7 +150,7 @@ impl<'a> Parser<'a> {\n                 Some(i) => Stmt {\n                     id: DUMMY_NODE_ID,\n                     span: lo.to(i.span),\n-                    node: StmtKind::Item(i),\n+                    kind: StmtKind::Item(i),\n                 },\n                 None => {\n                     let unused_attrs = |attrs: &[Attribute], s: &mut Self| {\n@@ -180,7 +180,7 @@ impl<'a> Parser<'a> {\n                         return Ok(Some(Stmt {\n                             id: DUMMY_NODE_ID,\n                             span: lo.to(last_semi),\n-                            node: StmtKind::Semi(self.mk_expr(lo.to(last_semi),\n+                            kind: StmtKind::Semi(self.mk_expr(lo.to(last_semi),\n                                 ExprKind::Tup(Vec::new()),\n                                 ThinVec::new()\n                             )),\n@@ -198,7 +198,7 @@ impl<'a> Parser<'a> {\n                     Stmt {\n                         id: DUMMY_NODE_ID,\n                         span: lo.to(e.span),\n-                        node: StmtKind::Expr(e),\n+                        kind: StmtKind::Expr(e),\n                     }\n                 }\n             }\n@@ -400,7 +400,7 @@ impl<'a> Parser<'a> {\n                     self.recover_stmt_(SemiColonMode::Ignore, BlockMode::Ignore);\n                     Some(Stmt {\n                         id: DUMMY_NODE_ID,\n-                        node: StmtKind::Expr(DummyResult::raw_expr(self.token.span, true)),\n+                        kind: StmtKind::Expr(DummyResult::raw_expr(self.token.span, true)),\n                         span: self.token.span,\n                     })\n                 }\n@@ -431,7 +431,7 @@ impl<'a> Parser<'a> {\n             None => return Ok(None),\n         };\n \n-        match stmt.node {\n+        match stmt.kind {\n             StmtKind::Expr(ref expr) if self.token != token::Eof => {\n                 // expression without semicolon\n                 if classify::expr_requires_semi_to_be_stmt(expr) {\n@@ -443,7 +443,7 @@ impl<'a> Parser<'a> {\n                         self.recover_stmt();\n                         // Don't complain about type errors in body tail after parse error (#57383).\n                         let sp = expr.span.to(self.prev_span);\n-                        stmt.node = StmtKind::Expr(DummyResult::raw_expr(sp, true));\n+                        stmt.kind = StmtKind::Expr(DummyResult::raw_expr(sp, true));\n                     }\n                 }\n             }"}, {"sha": "b4c006ca2b119e25534629393280de18760435ba", "filename": "src/libsyntax/parse/parser/ty.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibsyntax%2Fparse%2Fparser%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibsyntax%2Fparse%2Fparser%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser%2Fty.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -55,7 +55,7 @@ impl<'a> Parser<'a> {\n \n         let lo = self.token.span;\n         let mut impl_dyn_multi = false;\n-        let node = if self.eat(&token::OpenDelim(token::Paren)) {\n+        let kind = if self.eat(&token::OpenDelim(token::Paren)) {\n             // `(TYPE)` is a parenthesized type.\n             // `(TYPE,)` is a tuple with a single field of type TYPE.\n             let mut ts = vec![];\n@@ -75,7 +75,7 @@ impl<'a> Parser<'a> {\n             if ts.len() == 1 && !last_comma {\n                 let ty = ts.into_iter().nth(0).unwrap().into_inner();\n                 let maybe_bounds = allow_plus && self.token.is_like_plus();\n-                match ty.node {\n+                match ty.kind {\n                     // `(TY_BOUND_NOPAREN) + BOUND + ...`.\n                     TyKind::Path(None, ref path) if maybe_bounds => {\n                         self.parse_remaining_bounds(Vec::new(), path.clone(), lo, true)?\n@@ -211,7 +211,7 @@ impl<'a> Parser<'a> {\n         };\n \n         let span = lo.to(self.prev_span);\n-        let ty = P(Ty { node, span, id: ast::DUMMY_NODE_ID });\n+        let ty = P(Ty { kind, span, id: ast::DUMMY_NODE_ID });\n \n         // Try to recover from use of `+` with incorrect priority.\n         self.maybe_report_ambiguous_plus(allow_plus, impl_dyn_multi, &ty);"}, {"sha": "3bdb9227b4edd1cfa853a09bf7ede2024c10068f", "filename": "src/libsyntax/parse/tests.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibsyntax%2Fparse%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibsyntax%2Fparse%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftests.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -171,7 +171,7 @@ fn get_spans_of_pat_idents(src: &str) -> Vec<Span> {\n     }\n     impl<'a> crate::visit::Visitor<'a> for PatIdentVisitor {\n         fn visit_pat(&mut self, p: &'a ast::Pat) {\n-            match p.node {\n+            match p.kind {\n                 PatKind::Ident(_ , ref ident, _) => {\n                     self.spans.push(ident.span.clone());\n                 }\n@@ -272,7 +272,7 @@ fn ttdelim_span() {\n         let expr = parse_expr_from_source_str(PathBuf::from(\"foo\").into(),\n             \"foo!( fn main() { body } )\".to_string(), &sess).unwrap();\n \n-        let tts: Vec<_> = match expr.node {\n+        let tts: Vec<_> = match expr.kind {\n             ast::ExprKind::Mac(ref mac) => mac.stream().trees().collect(),\n             _ => panic!(\"not a macro\"),\n         };\n@@ -299,7 +299,7 @@ fn out_of_line_mod() {\n             &sess,\n         ).unwrap().unwrap();\n \n-        if let ast::ItemKind::Mod(ref m) = item.node {\n+        if let ast::ItemKind::Mod(ref m) = item.kind {\n             assert!(m.items.len() == 2);\n         } else {\n             panic!();"}, {"sha": "a5792dab4749cc05ea149d0637e0ebd2a67cc50c", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 38, "deletions": 41, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -662,7 +662,7 @@ pub trait PrintState<'a>: std::ops::Deref<Target = pp::Printer> + std::ops::Dere\n \n     fn print_meta_item(&mut self, item: &ast::MetaItem) {\n         self.ibox(INDENT_UNIT);\n-        match item.node {\n+        match item.kind {\n             ast::MetaItemKind::Word => self.print_path(&item.path, false, 0),\n             ast::MetaItemKind::NameValue(ref value) => {\n                 self.print_path(&item.path, false, 0);\n@@ -966,7 +966,7 @@ impl<'a> State<'a> {\n     crate fn print_type(&mut self, ty: &ast::Ty) {\n         self.maybe_print_comment(ty.span.lo());\n         self.ibox(0);\n-        match ty.node {\n+        match ty.kind {\n             ast::TyKind::Slice(ref ty) => {\n                 self.s.word(\"[\");\n                 self.print_type(ty);\n@@ -1060,7 +1060,7 @@ impl<'a> State<'a> {\n         self.hardbreak_if_not_bol();\n         self.maybe_print_comment(item.span.lo());\n         self.print_outer_attributes(&item.attrs);\n-        match item.node {\n+        match item.kind {\n             ast::ForeignItemKind::Fn(ref decl, ref generics) => {\n                 self.head(\"\");\n                 self.print_fn(decl, ast::FnHeader::default(),\n@@ -1142,7 +1142,7 @@ impl<'a> State<'a> {\n         self.maybe_print_comment(item.span.lo());\n         self.print_outer_attributes(&item.attrs);\n         self.ann.pre(self, AnnNode::Item(item));\n-        match item.node {\n+        match item.kind {\n             ast::ItemKind::ExternCrate(orig_name) => {\n                 self.head(visibility_qualified(&item.vis, \"extern crate\"));\n                 if let Some(orig_name) = orig_name {\n@@ -1550,7 +1550,7 @@ impl<'a> State<'a> {\n         self.hardbreak_if_not_bol();\n         self.maybe_print_comment(ti.span.lo());\n         self.print_outer_attributes(&ti.attrs);\n-        match ti.node {\n+        match ti.kind {\n             ast::TraitItemKind::Const(ref ty, ref default) => {\n                 self.print_associated_const(\n                     ti.ident,\n@@ -1597,7 +1597,7 @@ impl<'a> State<'a> {\n         self.maybe_print_comment(ii.span.lo());\n         self.print_outer_attributes(&ii.attrs);\n         self.print_defaultness(ii.defaultness);\n-        match ii.node {\n+        match ii.kind {\n             ast::ImplItemKind::Const(ref ty, ref expr) => {\n                 self.print_associated_const(ii.ident, ty, Some(expr), &ii.vis);\n             }\n@@ -1630,7 +1630,7 @@ impl<'a> State<'a> {\n \n     crate fn print_stmt(&mut self, st: &ast::Stmt) {\n         self.maybe_print_comment(st.span.lo());\n-        match st.node {\n+        match st.kind {\n             ast::StmtKind::Local(ref loc) => {\n                 self.print_outer_attributes(&loc.attrs);\n                 self.space_if_not_bol();\n@@ -1703,7 +1703,7 @@ impl<'a> State<'a> {\n         self.print_inner_attributes(attrs);\n \n         for (i, st) in blk.stmts.iter().enumerate() {\n-            match st.node {\n+            match st.kind {\n                 ast::StmtKind::Expr(ref expr) if i == blk.stmts.len() - 1 => {\n                     self.maybe_print_comment(st.span.lo());\n                     self.space_if_not_bol();\n@@ -1734,33 +1734,30 @@ impl<'a> State<'a> {\n     }\n \n     fn print_else(&mut self, els: Option<&ast::Expr>) {\n-        match els {\n-            Some(_else) => {\n-                match _else.node {\n-                    // Another `else if` block.\n-                    ast::ExprKind::If(ref i, ref then, ref e) => {\n-                        self.cbox(INDENT_UNIT - 1);\n-                        self.ibox(0);\n-                        self.s.word(\" else if \");\n-                        self.print_expr_as_cond(i);\n-                        self.s.space();\n-                        self.print_block(then);\n-                        self.print_else(e.as_ref().map(|e| &**e))\n-                    }\n-                    // Final `else` block.\n-                    ast::ExprKind::Block(ref b, _) => {\n-                        self.cbox(INDENT_UNIT - 1);\n-                        self.ibox(0);\n-                        self.s.word(\" else \");\n-                        self.print_block(b)\n-                    }\n-                    // Constraints would be great here!\n-                    _ => {\n-                        panic!(\"print_if saw if with weird alternative\");\n-                    }\n+        if let Some(_else) = els {\n+            match _else.kind {\n+                // Another `else if` block.\n+                ast::ExprKind::If(ref i, ref then, ref e) => {\n+                    self.cbox(INDENT_UNIT - 1);\n+                    self.ibox(0);\n+                    self.s.word(\" else if \");\n+                    self.print_expr_as_cond(i);\n+                    self.s.space();\n+                    self.print_block(then);\n+                    self.print_else(e.as_ref().map(|e| &**e))\n+                }\n+                // Final `else` block.\n+                ast::ExprKind::Block(ref b, _) => {\n+                    self.cbox(INDENT_UNIT - 1);\n+                    self.ibox(0);\n+                    self.s.word(\" else \");\n+                    self.print_block(b)\n+                }\n+                // Constraints would be great here!\n+                _ => {\n+                    panic!(\"print_if saw if with weird alternative\");\n                 }\n             }\n-            _ => {}\n         }\n     }\n \n@@ -1805,7 +1802,7 @@ impl<'a> State<'a> {\n \n     /// Does `expr` need parenthesis when printed in a condition position?\n     fn cond_needs_par(expr: &ast::Expr) -> bool {\n-        match expr.node {\n+        match expr.kind {\n             // These cases need parens due to the parse error observed in #26461: `if return {}`\n             // parses as the erroneous construct `if (return {})`, not `if (return) {}`.\n             ast::ExprKind::Closure(..) |\n@@ -1905,7 +1902,7 @@ impl<'a> State<'a> {\n                        func: &ast::Expr,\n                        args: &[P<ast::Expr>]) {\n         let prec =\n-            match func.node {\n+            match func.kind {\n                 ast::ExprKind::Field(..) => parser::PREC_FORCE_PAREN,\n                 _ => parser::PREC_POSTFIX,\n             };\n@@ -1941,7 +1938,7 @@ impl<'a> State<'a> {\n             Fixity::None => (prec + 1, prec + 1),\n         };\n \n-        let left_prec = match (&lhs.node, op.node) {\n+        let left_prec = match (&lhs.kind, op.node) {\n             // These cases need parens: `x as i32 < y` has the parser thinking that `i32 < y` is\n             // the beginning of a path type. It starts trying to parse `x as (i32 < y ...` instead\n             // of `(x as i32) < ...`. We need to convince it _not_ to do that.\n@@ -2000,7 +1997,7 @@ impl<'a> State<'a> {\n \n         self.ibox(INDENT_UNIT);\n         self.ann.pre(self, AnnNode::Expr(expr));\n-        match expr.node {\n+        match expr.kind {\n             ast::ExprKind::Box(ref expr) => {\n                 self.word_space(\"box\");\n                 self.print_expr_maybe_paren(expr, parser::PREC_PREFIX);\n@@ -2356,7 +2353,7 @@ impl<'a> State<'a> {\n         self.ann.pre(self, AnnNode::Pat(pat));\n         /* Pat isn't normalized, but the beauty of it\n          is that it doesn't matter */\n-        match pat.node {\n+        match pat.kind {\n             PatKind::Wild => self.s.word(\"_\"),\n             PatKind::Ident(binding_mode, ident, ref sub) => {\n                 match binding_mode {\n@@ -2477,7 +2474,7 @@ impl<'a> State<'a> {\n         }\n         self.word_space(\"=>\");\n \n-        match arm.body.node {\n+        match arm.body.kind {\n             ast::ExprKind::Block(ref blk, opt_label) => {\n                 if let Some(label) = opt_label {\n                     self.print_ident(label.ident);\n@@ -2763,13 +2760,13 @@ impl<'a> State<'a> {\n \n         self.print_outer_attributes_inline(&input.attrs);\n \n-        match input.ty.node {\n+        match input.ty.kind {\n             ast::TyKind::Infer if is_closure => self.print_pat(&input.pat),\n             _ => {\n                 if let Some(eself) = input.to_self() {\n                     self.print_explicit_self(&eself);\n                 } else {\n-                    let invalid = if let PatKind::Ident(_, ident, _) = input.pat.node {\n+                    let invalid = if let PatKind::Ident(_, ident, _) = input.pat.kind {\n                         ident.name == kw::Invalid\n                     } else {\n                         false"}, {"sha": "982755e868054ec159b06ba7cb7ffbffcf28f958", "filename": "src/libsyntax/util/parser.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibsyntax%2Futil%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibsyntax%2Futil%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fparser.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -375,7 +375,7 @@ crate fn needs_par_as_let_scrutinee(order: i8) -> bool {\n /// parens or other delimiters, e.g., `X { y: 1 }`, `X { y: 1 }.method()`, `foo == X { y: 1 }` and\n /// `X { y: 1 } == foo` all do, but `(X { y: 1 }) == foo` does not.\n pub fn contains_exterior_struct_lit(value: &ast::Expr) -> bool {\n-    match value.node {\n+    match value.kind {\n         ast::ExprKind::Struct(..) => true,\n \n         ast::ExprKind::Assign(ref lhs, ref rhs) |"}, {"sha": "a36783e2b642dcdbd8e5afa24dde4d2897939117", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -230,7 +230,7 @@ pub fn walk_trait_ref<'a, V: Visitor<'a>>(visitor: &mut V, trait_ref: &'a TraitR\n pub fn walk_item<'a, V: Visitor<'a>>(visitor: &mut V, item: &'a Item) {\n     visitor.visit_vis(&item.vis);\n     visitor.visit_ident(item.ident);\n-    match item.node {\n+    match item.kind {\n         ItemKind::ExternCrate(orig_name) => {\n             if let Some(orig_name) = orig_name {\n                 visitor.visit_name(item.span, orig_name);\n@@ -333,7 +333,7 @@ pub fn walk_field_pattern<'a, V: Visitor<'a>>(visitor: &mut V, fp: &'a FieldPat)\n }\n \n pub fn walk_ty<'a, V: Visitor<'a>>(visitor: &mut V, typ: &'a Ty) {\n-    match typ.node {\n+    match typ.kind {\n         TyKind::Slice(ref ty) | TyKind::Paren(ref ty) => {\n             visitor.visit_ty(ty)\n         }\n@@ -443,7 +443,7 @@ pub fn walk_assoc_ty_constraint<'a, V: Visitor<'a>>(visitor: &mut V,\n }\n \n pub fn walk_pat<'a, V: Visitor<'a>>(visitor: &mut V, pattern: &'a Pat) {\n-    match pattern.node {\n+    match pattern.kind {\n         PatKind::TupleStruct(ref path, ref elems) => {\n             visitor.visit_path(path, pattern.id);\n             walk_list!(visitor, visit_pat, elems);\n@@ -486,7 +486,7 @@ pub fn walk_foreign_item<'a, V: Visitor<'a>>(visitor: &mut V, foreign_item: &'a\n     visitor.visit_vis(&foreign_item.vis);\n     visitor.visit_ident(foreign_item.ident);\n \n-    match foreign_item.node {\n+    match foreign_item.kind {\n         ForeignItemKind::Fn(ref function_declaration, ref generics) => {\n             walk_fn_decl(visitor, function_declaration);\n             visitor.visit_generics(generics)\n@@ -589,7 +589,7 @@ pub fn walk_trait_item<'a, V: Visitor<'a>>(visitor: &mut V, trait_item: &'a Trai\n     visitor.visit_ident(trait_item.ident);\n     walk_list!(visitor, visit_attribute, &trait_item.attrs);\n     visitor.visit_generics(&trait_item.generics);\n-    match trait_item.node {\n+    match trait_item.kind {\n         TraitItemKind::Const(ref ty, ref default) => {\n             visitor.visit_ty(ty);\n             walk_list!(visitor, visit_expr, default);\n@@ -617,7 +617,7 @@ pub fn walk_impl_item<'a, V: Visitor<'a>>(visitor: &mut V, impl_item: &'a ImplIt\n     visitor.visit_ident(impl_item.ident);\n     walk_list!(visitor, visit_attribute, &impl_item.attrs);\n     visitor.visit_generics(&impl_item.generics);\n-    match impl_item.node {\n+    match impl_item.kind {\n         ImplItemKind::Const(ref ty, ref expr) => {\n             visitor.visit_ty(ty);\n             visitor.visit_expr(expr);\n@@ -656,7 +656,7 @@ pub fn walk_block<'a, V: Visitor<'a>>(visitor: &mut V, block: &'a Block) {\n }\n \n pub fn walk_stmt<'a, V: Visitor<'a>>(visitor: &mut V, statement: &'a Stmt) {\n-    match statement.node {\n+    match statement.kind {\n         StmtKind::Local(ref local) => visitor.visit_local(local),\n         StmtKind::Item(ref item) => visitor.visit_item(item),\n         StmtKind::Expr(ref expression) | StmtKind::Semi(ref expression) => {\n@@ -683,7 +683,7 @@ pub fn walk_anon_const<'a, V: Visitor<'a>>(visitor: &mut V, constant: &'a AnonCo\n pub fn walk_expr<'a, V: Visitor<'a>>(visitor: &mut V, expression: &'a Expr) {\n     walk_list!(visitor, visit_attribute, expression.attrs.iter());\n \n-    match expression.node {\n+    match expression.kind {\n         ExprKind::Box(ref subexpression) => {\n             visitor.visit_expr(subexpression)\n         }"}, {"sha": "becbf6d60a07012b3e1282e38c44eb9a88816310", "filename": "src/libsyntax_ext/asm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibsyntax_ext%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibsyntax_ext%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fasm.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -61,7 +61,7 @@ pub fn expand_asm<'cx>(cx: &'cx mut ExtCtxt<'_>,\n \n     MacEager::expr(P(ast::Expr {\n         id: ast::DUMMY_NODE_ID,\n-        node: ast::ExprKind::InlineAsm(P(inline_asm)),\n+        kind: ast::ExprKind::InlineAsm(P(inline_asm)),\n         span: cx.with_def_site_ctxt(sp),\n         attrs: ThinVec::new(),\n     }))"}, {"sha": "790fdad5b3f5820879aecc88a946be77f0825aeb", "filename": "src/libsyntax_ext/concat.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibsyntax_ext%2Fconcat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibsyntax_ext%2Fconcat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fconcat.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -18,8 +18,8 @@ pub fn expand_concat(\n     let mut missing_literal = vec![];\n     let mut has_errors = false;\n     for e in es {\n-        match e.node {\n-            ast::ExprKind::Lit(ref lit) => match lit.node {\n+        match e.kind {\n+            ast::ExprKind::Lit(ref lit) => match lit.kind {\n                 ast::LitKind::Str(ref s, _)\n                 | ast::LitKind::Float(ref s, _)\n                 | ast::LitKind::FloatUnsuffixed(ref s) => {"}, {"sha": "f6747658c070e3af4825f4500ede0811cf942b4e", "filename": "src/libsyntax_ext/concat_idents.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibsyntax_ext%2Fconcat_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibsyntax_ext%2Fconcat_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fconcat_idents.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -47,7 +47,7 @@ pub fn expand_concat_idents<'cx>(cx: &'cx mut ExtCtxt<'_>,\n         fn make_expr(self: Box<Self>) -> Option<P<ast::Expr>> {\n             Some(P(ast::Expr {\n                 id: ast::DUMMY_NODE_ID,\n-                node: ast::ExprKind::Path(None, ast::Path::from_ident(self.ident)),\n+                kind: ast::ExprKind::Path(None, ast::Path::from_ident(self.ident)),\n                 span: self.ident.span,\n                 attrs: ThinVec::new(),\n             }))\n@@ -56,7 +56,7 @@ pub fn expand_concat_idents<'cx>(cx: &'cx mut ExtCtxt<'_>,\n         fn make_ty(self: Box<Self>) -> Option<P<ast::Ty>> {\n             Some(P(ast::Ty {\n                 id: ast::DUMMY_NODE_ID,\n-                node: ast::TyKind::Path(None, ast::Path::from_ident(self.ident)),\n+                kind: ast::TyKind::Path(None, ast::Path::from_ident(self.ident)),\n                 span: self.ident.span,\n             }))\n         }"}, {"sha": "9ef2c033b0784a43baaf766d7e478684a42b115c", "filename": "src/libsyntax_ext/deriving/clone.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibsyntax_ext%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibsyntax_ext%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fclone.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -32,7 +32,7 @@ pub fn expand_deriving_clone(cx: &mut ExtCtxt<'_>,\n     let is_shallow;\n     match *item {\n         Annotatable::Item(ref annitem) => {\n-            match annitem.node {\n+            match annitem.kind {\n                 ItemKind::Struct(_, Generics { ref params, .. }) |\n                 ItemKind::Enum(_, Generics { ref params, .. }) => {\n                     let container_id = cx.current_expansion.id.expn_data().parent;"}, {"sha": "003c2423576eb5f092dc50a07847c2a37b2f5487", "filename": "src/libsyntax_ext/deriving/debug.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibsyntax_ext%2Fderiving%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibsyntax_ext%2Fderiving%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fdebug.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -131,7 +131,7 @@ fn stmt_let_undescore(cx: &mut ExtCtxt<'_>, sp: Span, expr: P<ast::Expr>) -> ast\n     });\n     ast::Stmt {\n         id: ast::DUMMY_NODE_ID,\n-        node: ast::StmtKind::Local(local),\n+        kind: ast::StmtKind::Local(local),\n         span: sp,\n     }\n }"}, {"sha": "9f75f72e820f25c8b84d58b634ea3245a3117a66", "filename": "src/libsyntax_ext/deriving/generic/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -355,7 +355,7 @@ fn find_type_parameters(\n \n     impl<'a, 'b> visit::Visitor<'a> for Visitor<'a, 'b> {\n         fn visit_ty(&mut self, ty: &'a ast::Ty) {\n-            if let ast::TyKind::Path(_, ref path) = ty.node {\n+            if let ast::TyKind::Path(_, ref path) = ty.kind {\n                 if let Some(segment) = path.segments.first() {\n                     if self.ty_param_names.contains(&segment.ident.name) {\n                         self.types.push(P(ty.clone()));\n@@ -409,7 +409,7 @@ impl<'a> TraitDef<'a> {\n                     }\n                     false\n                 });\n-                let has_no_type_params = match item.node {\n+                let has_no_type_params = match item.kind {\n                     ast::ItemKind::Struct(_, ref generics) |\n                     ast::ItemKind::Enum(_, ref generics) |\n                     ast::ItemKind::Union(_, ref generics) => {\n@@ -431,7 +431,7 @@ impl<'a> TraitDef<'a> {\n                     has_no_type_params;\n                 let use_temporaries = is_packed && is_always_copy;\n \n-                let newitem = match item.node {\n+                let newitem = match item.kind {\n                     ast::ItemKind::Struct(ref struct_def, ref generics) => {\n                         self.expand_struct_def(cx, &struct_def, item.ident, generics, from_scratch,\n                                                use_temporaries)\n@@ -530,7 +530,7 @@ impl<'a> TraitDef<'a> {\n                 defaultness: ast::Defaultness::Final,\n                 attrs: Vec::new(),\n                 generics: Generics::default(),\n-                node: ast::ImplItemKind::TyAlias(\n+                kind: ast::ImplItemKind::TyAlias(\n                     type_def.to_ty(cx, self.span, type_ident, generics)),\n                 tokens: None,\n             }\n@@ -612,7 +612,7 @@ impl<'a> TraitDef<'a> {\n \n                     for ty in tys {\n                         // if we have already handled this type, skip it\n-                        if let ast::TyKind::Path(_, ref p) = ty.node {\n+                        if let ast::TyKind::Path(_, ref p) = ty.kind {\n                             if p.segments.len() == 1 &&\n                                ty_param_names.contains(&p.segments[0].ident.name) {\n                                 continue;\n@@ -960,7 +960,7 @@ impl<'a> MethodDef<'a> {\n             vis: respan(trait_.span.shrink_to_lo(), ast::VisibilityKind::Inherited),\n             defaultness: ast::Defaultness::Final,\n             ident: method_ident,\n-            node: ast::ImplItemKind::Method(ast::MethodSig {\n+            kind: ast::ImplItemKind::Method(ast::MethodSig {\n                                                 header: ast::FnHeader {\n                                                     unsafety, abi,\n                                                     ..ast::FnHeader::default()\n@@ -1780,7 +1780,7 @@ pub fn cs_fold1<F, B>(use_foldl: bool,\n /// (for an enum, no variant has any fields)\n pub fn is_type_without_fields(item: &Annotatable) -> bool {\n     if let Annotatable::Item(ref item) = *item {\n-        match item.node {\n+        match item.kind {\n             ast::ItemKind::Enum(ref enum_def, _) => {\n                 enum_def.variants.iter().all(|v| v.data.fields().is_empty())\n             }"}, {"sha": "cd2a9b61a76df395505dc7004f95e12cd08aac0b", "filename": "src/libsyntax_ext/global_allocator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibsyntax_ext%2Fglobal_allocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibsyntax_ext%2Fglobal_allocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fglobal_allocator.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -20,7 +20,7 @@ pub fn expand(\n         vec![item]\n     };\n     let item = match item {\n-        Annotatable::Item(item) => match item.node {\n+        Annotatable::Item(item) => match item.kind {\n             ItemKind::Static(..) => item,\n             _ => return not_static(Annotatable::Item(item)),\n         }"}, {"sha": "72fb5b47c215401af843ceed2bbe527698082e39", "filename": "src/libsyntax_ext/global_asm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibsyntax_ext%2Fglobal_asm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibsyntax_ext%2Fglobal_asm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fglobal_asm.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -28,7 +28,7 @@ pub fn expand_global_asm<'cx>(cx: &'cx mut ExtCtxt<'_>,\n                 ident: ast::Ident::invalid(),\n                 attrs: Vec::new(),\n                 id: ast::DUMMY_NODE_ID,\n-                node: ast::ItemKind::GlobalAsm(P(global_asm)),\n+                kind: ast::ItemKind::GlobalAsm(P(global_asm)),\n                 vis: respan(sp.shrink_to_lo(), ast::VisibilityKind::Inherited),\n                 span: cx.with_def_site_ctxt(sp),\n                 tokens: None,"}, {"sha": "315babceae32ce5a9844bac4183738d09f48cbb9", "filename": "src/libsyntax_ext/plugin_macro_defs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibsyntax_ext%2Fplugin_macro_defs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibsyntax_ext%2Fplugin_macro_defs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fplugin_macro_defs.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -28,7 +28,7 @@ fn plugin_macro_def(name: Name, span: Span) -> P<Item> {\n         ident: Ident::new(name, span),\n         attrs: vec![rustc_builtin_macro],\n         id: DUMMY_NODE_ID,\n-        node: ItemKind::MacroDef(MacroDef { tokens: TokenStream::new(trees), legacy: true }),\n+        kind: ItemKind::MacroDef(MacroDef { tokens: TokenStream::new(trees), legacy: true }),\n         vis: respan(span, VisibilityKind::Inherited),\n         span: span,\n         tokens: None,"}, {"sha": "9b53bcb841c67893b384dab42a85cc6b5ebd2252", "filename": "src/libsyntax_ext/proc_macro_harness.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibsyntax_ext%2Fproc_macro_harness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibsyntax_ext%2Fproc_macro_harness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fproc_macro_harness.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -226,7 +226,7 @@ impl<'a> CollectProcMacros<'a> {\n \n impl<'a> Visitor<'a> for CollectProcMacros<'a> {\n     fn visit_item(&mut self, item: &'a ast::Item) {\n-        if let ast::ItemKind::MacroDef(..) = item.node {\n+        if let ast::ItemKind::MacroDef(..) = item.kind {\n             if self.is_proc_macro_crate && attr::contains_name(&item.attrs, sym::macro_export) {\n                 let msg =\n                     \"cannot export macro_rules! macros from a `proc-macro` crate type currently\";\n@@ -238,7 +238,7 @@ impl<'a> Visitor<'a> for CollectProcMacros<'a> {\n         // we're just not interested in this item.\n         //\n         // If we find one, try to locate a `#[proc_macro_derive]` attribute on it.\n-        let is_fn = match item.node {\n+        let is_fn = match item.kind {\n             ast::ItemKind::Fn(..) => true,\n             _ => false,\n         };"}, {"sha": "5d68a92579f96cf7c0af3074ad682955a32943a0", "filename": "src/libsyntax_ext/test.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibsyntax_ext%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibsyntax_ext%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Ftest.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -78,7 +78,7 @@ pub fn expand_test_or_bench(\n                 \"`#[test]` attribute is only allowed on non associated functions\").raise();\n         };\n \n-    if let ast::ItemKind::Mac(_) = item.node {\n+    if let ast::ItemKind::Mac(_) = item.kind {\n         cx.parse_sess.span_diagnostic.span_warn(item.span,\n             \"`#[test]` attribute should not be used on macros. Use `#[cfg(test)]` instead.\");\n         return vec![Annotatable::Item(item)];\n@@ -264,7 +264,7 @@ fn should_panic(cx: &ExtCtxt<'_>, i: &ast::Item) -> ShouldPanic {\n fn has_test_signature(cx: &ExtCtxt<'_>, i: &ast::Item) -> bool {\n     let has_should_panic_attr = attr::contains_name(&i.attrs, sym::should_panic);\n     let ref sd = cx.parse_sess.span_diagnostic;\n-    if let ast::ItemKind::Fn(ref decl, ref header, ref generics, _) = i.node {\n+    if let ast::ItemKind::Fn(ref decl, ref header, ref generics, _) = i.kind {\n         if header.unsafety == ast::Unsafety::Unsafe {\n             sd.span_err(\n                 i.span,\n@@ -285,7 +285,7 @@ fn has_test_signature(cx: &ExtCtxt<'_>, i: &ast::Item) -> bool {\n         // type implements the `Termination` trait as `libtest` enforces that.\n         let has_output = match decl.output {\n             ast::FunctionRetTy::Default(..) => false,\n-            ast::FunctionRetTy::Ty(ref t) if t.node.is_unit() => false,\n+            ast::FunctionRetTy::Ty(ref t) if t.kind.is_unit() => false,\n             _ => true\n         };\n \n@@ -315,7 +315,7 @@ fn has_test_signature(cx: &ExtCtxt<'_>, i: &ast::Item) -> bool {\n }\n \n fn has_bench_signature(cx: &ExtCtxt<'_>, i: &ast::Item) -> bool {\n-    let has_sig = if let ast::ItemKind::Fn(ref decl, _, _, _) = i.node {\n+    let has_sig = if let ast::ItemKind::Fn(ref decl, _, _, _) = i.kind {\n         // N.B., inadequate check, but we're running\n         // well before resolve, can't get too deep.\n         decl.inputs.len() == 1"}, {"sha": "fc1daa7d9b22ad54b50dd0189758e5efc5d2c3ed", "filename": "src/libsyntax_ext/test_harness.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibsyntax_ext%2Ftest_harness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Flibsyntax_ext%2Ftest_harness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Ftest_harness.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -85,7 +85,7 @@ impl<'a> MutVisitor for TestHarnessGenerator<'a> {\n \n         // We don't want to recurse into anything other than mods, since\n         // mods or tests inside of functions will break things\n-        if let ast::ItemKind::Mod(mut module) = item.node {\n+        if let ast::ItemKind::Mod(mut module) = item.kind {\n             let tests = mem::take(&mut self.tests);\n             noop_visit_mod(&mut module, self);\n             let mut tests = mem::replace(&mut self.tests, tests);\n@@ -111,7 +111,7 @@ impl<'a> MutVisitor for TestHarnessGenerator<'a> {\n                 }\n                 self.cx.test_cases.extend(tests);\n             }\n-            item.node = ast::ItemKind::Mod(module);\n+            item.kind = ast::ItemKind::Mod(module);\n         }\n         smallvec![P(item)]\n     }\n@@ -142,7 +142,7 @@ impl MutVisitor for EntryPointCleaner {\n             EntryPointType::MainNamed |\n             EntryPointType::MainAttr |\n             EntryPointType::Start =>\n-                item.map(|ast::Item {id, ident, attrs, node, vis, span, tokens}| {\n+                item.map(|ast::Item {id, ident, attrs, kind, vis, span, tokens}| {\n                     let allow_ident = Ident::new(sym::allow, self.def_site);\n                     let dc_nested = attr::mk_nested_word_item(\n                         Ident::from_str_and_span(\"dead_code\", self.def_site),\n@@ -159,7 +159,7 @@ impl MutVisitor for EntryPointCleaner {\n                             })\n                             .chain(iter::once(allow_dead_code))\n                             .collect(),\n-                        node,\n+                        kind,\n                         vis,\n                         span,\n                         tokens,\n@@ -295,7 +295,7 @@ fn mk_main(cx: &mut TestCtxt<'_>) -> P<ast::Item> {\n         ident: main_id,\n         attrs: vec![main_attr],\n         id: ast::DUMMY_NODE_ID,\n-        node: main,\n+        kind: main,\n         vis: respan(sp, ast::VisibilityKind::Public),\n         span: sp,\n         tokens: None,"}, {"sha": "6c5f539b87185e5b897100e737e5a72dc2d4b969", "filename": "src/test/ui-fulldeps/ast_stmt_expr_attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Ftest%2Fui-fulldeps%2Fast_stmt_expr_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Ftest%2Fui-fulldeps%2Fast_stmt_expr_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fast_stmt_expr_attr.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -83,7 +83,7 @@ fn check_expr_attrs(es: &str, expected: &[&str]) {\n fn check_stmt_attrs(es: &str, expected: &[&str]) {\n     let ps = ParseSess::new(FilePathMapping::empty());\n     let e = stmt(es, &ps).expect(\"parse error\");\n-    let actual = e.node.attrs();\n+    let actual = e.kind.attrs();\n     str_compare(es,\n                 &expected.iter().map(|r| attr(r, &ps).unwrap()).collect::<Vec<_>>(),\n                 actual,"}, {"sha": "784f71a61fd72c72615e9b0471e83d7ec440571f", "filename": "src/test/ui-fulldeps/pprust-expr-roundtrip.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Ftest%2Fui-fulldeps%2Fpprust-expr-roundtrip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Ftest%2Fui-fulldeps%2Fpprust-expr-roundtrip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fpprust-expr-roundtrip.rs?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -48,7 +48,7 @@ fn parse_expr(ps: &ParseSess, src: &str) -> Option<P<Expr>> {\n fn expr(kind: ExprKind) -> P<Expr> {\n     P(Expr {\n         id: DUMMY_NODE_ID,\n-        node: kind,\n+        kind,\n         span: DUMMY_SP,\n         attrs: ThinVec::new(),\n     })\n@@ -154,7 +154,7 @@ fn iter_exprs(depth: usize, f: &mut dyn FnMut(P<Expr>)) {\n             19 => {\n                 let pat = P(Pat {\n                     id: DUMMY_NODE_ID,\n-                    node: PatKind::Wild,\n+                    kind: PatKind::Wild,\n                     span: DUMMY_SP,\n                 });\n                 iter_exprs(depth - 1, &mut |e| g(ExprKind::Let(pat.clone(), e)))\n@@ -172,7 +172,7 @@ struct RemoveParens;\n \n impl MutVisitor for RemoveParens {\n     fn visit_expr(&mut self, e: &mut P<Expr>) {\n-        match e.node.clone() {\n+        match e.kind.clone() {\n             ExprKind::Paren(inner) => *e = inner,\n             _ => {}\n         };\n@@ -190,7 +190,7 @@ impl MutVisitor for AddParens {\n         visit_clobber(e, |e| {\n             P(Expr {\n                 id: DUMMY_NODE_ID,\n-                node: ExprKind::Paren(e),\n+                kind: ExprKind::Paren(e),\n                 span: DUMMY_SP,\n                 attrs: ThinVec::new(),\n             })"}, {"sha": "563885133a4c1adce6d14c6f37901512b3095d79", "filename": "src/test/ui/ast-json/ast-json-output.stdout", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Ftest%2Fui%2Fast-json%2Fast-json-output.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/590ae0ec4d0c782f7cf97cff7474dc4012c1b615/src%2Ftest%2Fui%2Fast-json%2Fast-json-output.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fast-json%2Fast-json-output.stdout?ref=590ae0ec4d0c782f7cf97cff7474dc4012c1b615", "patch": "@@ -1 +1 @@\n-{\"module\":{\"inner\":{\"lo\":0,\"hi\":0},\"items\":[{\"ident\":{\"name\":\"core\",\"span\":{\"lo\":0,\"hi\":0}},\"attrs\":[],\"id\":0,\"node\":{\"variant\":\"ExternCrate\",\"fields\":[null]},\"vis\":{\"node\":\"Inherited\",\"span\":{\"lo\":0,\"hi\":0}},\"span\":{\"lo\":0,\"hi\":0},\"tokens\":[{\"variant\":\"Token\",\"fields\":[{\"kind\":{\"variant\":\"Ident\",\"fields\":[\"extern\",false]},\"span\":{\"lo\":0,\"hi\":0}}]},{\"variant\":\"Token\",\"fields\":[{\"kind\":{\"variant\":\"Ident\",\"fields\":[\"crate\",false]},\"span\":{\"lo\":0,\"hi\":0}}]},{\"variant\":\"Token\",\"fields\":[{\"kind\":{\"variant\":\"Ident\",\"fields\":[\"core\",false]},\"span\":{\"lo\":0,\"hi\":0}}]},{\"variant\":\"Token\",\"fields\":[{\"kind\":\"Semi\",\"span\":{\"lo\":0,\"hi\":0}}]}]}],\"inline\":true},\"attrs\":[],\"span\":{\"lo\":0,\"hi\":0}}\n+{\"module\":{\"inner\":{\"lo\":0,\"hi\":0},\"items\":[{\"ident\":{\"name\":\"core\",\"span\":{\"lo\":0,\"hi\":0}},\"attrs\":[],\"id\":0,\"kind\":{\"variant\":\"ExternCrate\",\"fields\":[null]},\"vis\":{\"node\":\"Inherited\",\"span\":{\"lo\":0,\"hi\":0}},\"span\":{\"lo\":0,\"hi\":0},\"tokens\":[{\"variant\":\"Token\",\"fields\":[{\"kind\":{\"variant\":\"Ident\",\"fields\":[\"extern\",false]},\"span\":{\"lo\":0,\"hi\":0}}]},{\"variant\":\"Token\",\"fields\":[{\"kind\":{\"variant\":\"Ident\",\"fields\":[\"crate\",false]},\"span\":{\"lo\":0,\"hi\":0}}]},{\"variant\":\"Token\",\"fields\":[{\"kind\":{\"variant\":\"Ident\",\"fields\":[\"core\",false]},\"span\":{\"lo\":0,\"hi\":0}}]},{\"variant\":\"Token\",\"fields\":[{\"kind\":\"Semi\",\"span\":{\"lo\":0,\"hi\":0}}]}]}],\"inline\":true},\"attrs\":[],\"span\":{\"lo\":0,\"hi\":0}}"}]}