{"sha": "5232099977d07492c1b6d5e6163c70d4f6eb07df", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUyMzIwOTk5NzdkMDc0OTJjMWI2ZDVlNjE2M2M3MGQ0ZjZlYjA3ZGY=", "commit": {"author": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-03-07T11:36:04Z"}, "committer": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-03-07T11:36:04Z"}, "message": "Merge #939\n\n939: Initial implementation of project-lock.json. r=davidtwco a=davidtwco\n\nFixes #792.\r\n\r\nThis PR adds a initial implementation of project-lock.json, a build\r\nsystem agnostic method of specifying the crate graph and roots.\n\nCo-authored-by: David Wood <david@davidtw.co>", "tree": {"sha": "0660079034d3c2f30147e946f2c473d2f651eef2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0660079034d3c2f30147e946f2c473d2f651eef2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5232099977d07492c1b6d5e6163c70d4f6eb07df", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5232099977d07492c1b6d5e6163c70d4f6eb07df", "html_url": "https://github.com/rust-lang/rust/commit/5232099977d07492c1b6d5e6163c70d4f6eb07df", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5232099977d07492c1b6d5e6163c70d4f6eb07df/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "b94e1eee8341cb2a16b89711d65b382549fd2bde", "url": "https://api.github.com/repos/rust-lang/rust/commits/b94e1eee8341cb2a16b89711d65b382549fd2bde", "html_url": "https://github.com/rust-lang/rust/commit/b94e1eee8341cb2a16b89711d65b382549fd2bde"}, {"sha": "4cd757c1e32f0cf1f281b82cd55615d0e47edb24", "url": "https://api.github.com/repos/rust-lang/rust/commits/4cd757c1e32f0cf1f281b82cd55615d0e47edb24", "html_url": "https://github.com/rust-lang/rust/commit/4cd757c1e32f0cf1f281b82cd55615d0e47edb24"}], "stats": {"total": 404, "additions": 311, "deletions": 93}, "files": [{"sha": "4b89e36d176f0fa56fac879246b5de4f8aa036c4", "filename": "Cargo.lock", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5232099977d07492c1b6d5e6163c70d4f6eb07df/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/5232099977d07492c1b6d5e6163c70d4f6eb07df/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=5232099977d07492c1b6d5e6163c70d4f6eb07df", "patch": "@@ -1089,6 +1089,8 @@ dependencies = [\n  \"ra_arena 0.1.0\",\n  \"ra_db 0.1.0\",\n  \"rustc-hash 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.89 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde_json 1.0.39 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"test_utils 0.1.0\",\n  \"walkdir 2.2.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]"}, {"sha": "c6d10107d1880261994edcf42bb0aa7207b655bb", "filename": "crates/ra_batch/src/lib.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5232099977d07492c1b6d5e6163c70d4f6eb07df/crates%2Fra_batch%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5232099977d07492c1b6d5e6163c70d4f6eb07df/crates%2Fra_batch%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_batch%2Fsrc%2Flib.rs?ref=5232099977d07492c1b6d5e6163c70d4f6eb07df", "patch": "@@ -99,12 +99,7 @@ impl BatchDatabase {\n         let ws = ProjectWorkspace::discover(root.as_ref())?;\n         let mut roots = Vec::new();\n         roots.push(root.clone());\n-        for pkg in ws.cargo.packages() {\n-            roots.push(pkg.root(&ws.cargo).to_path_buf());\n-        }\n-        for krate in ws.sysroot.crates() {\n-            roots.push(krate.root_dir(&ws.sysroot).to_path_buf())\n-        }\n+        roots.extend(ws.to_roots());\n         let (mut vfs, roots) = Vfs::new(roots);\n         let mut load = |path: &Path| {\n             let vfs_file = vfs.load(path);"}, {"sha": "cdf2ec10b664487f58c05c68cbc45b8c66203d84", "filename": "crates/ra_lsp_server/src/cargo_target_spec.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/5232099977d07492c1b6d5e6163c70d4f6eb07df/crates%2Fra_lsp_server%2Fsrc%2Fcargo_target_spec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5232099977d07492c1b6d5e6163c70d4f6eb07df/crates%2Fra_lsp_server%2Fsrc%2Fcargo_target_spec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fcargo_target_spec.rs?ref=5232099977d07492c1b6d5e6163c70d4f6eb07df", "patch": "@@ -1,5 +1,5 @@\n use crate::{\n-    project_model::TargetKind,\n+    project_model::{self, TargetKind},\n     server_world::ServerWorld,\n     Result\n };\n@@ -65,14 +65,16 @@ impl CargoTargetSpec {\n         };\n         let file_id = world.analysis().crate_root(crate_id)?;\n         let path = world.vfs.read().file2path(ra_vfs::VfsFile(file_id.0.into()));\n-        let res = world.workspaces.iter().find_map(|ws| {\n-            let tgt = ws.cargo.target_by_root(&path)?;\n-            let res = CargoTargetSpec {\n-                package: tgt.package(&ws.cargo).name(&ws.cargo).to_string(),\n-                target: tgt.name(&ws.cargo).to_string(),\n-                target_kind: tgt.kind(&ws.cargo),\n-            };\n-            Some(res)\n+        let res = world.workspaces.iter().find_map(|ws| match ws {\n+            project_model::ProjectWorkspace::Cargo { cargo, .. } => {\n+                let tgt = cargo.target_by_root(&path)?;\n+                Some(CargoTargetSpec {\n+                    package: tgt.package(&cargo).name(&cargo).to_string(),\n+                    target: tgt.name(&cargo).to_string(),\n+                    target_kind: tgt.kind(&cargo),\n+                })\n+            }\n+            project_model::ProjectWorkspace::Json { .. } => None,\n         });\n         Ok(res)\n     }"}, {"sha": "7163568b9cd71ced544925d092a0c4f0200729d1", "filename": "crates/ra_lsp_server/src/server_world.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5232099977d07492c1b6d5e6163c70d4f6eb07df/crates%2Fra_lsp_server%2Fsrc%2Fserver_world.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5232099977d07492c1b6d5e6163c70d4f6eb07df/crates%2Fra_lsp_server%2Fsrc%2Fserver_world.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fserver_world.rs?ref=5232099977d07492c1b6d5e6163c70d4f6eb07df", "patch": "@@ -40,12 +40,7 @@ impl ServerWorldState {\n         let mut roots = Vec::new();\n         roots.push(root.clone());\n         for ws in workspaces.iter() {\n-            for pkg in ws.cargo.packages() {\n-                roots.push(pkg.root(&ws.cargo).to_path_buf());\n-            }\n-            for krate in ws.sysroot.crates() {\n-                roots.push(krate.root_dir(&ws.sysroot).to_path_buf())\n-            }\n+            roots.extend(ws.to_roots());\n         }\n         let (mut vfs, roots) = Vfs::new(roots);\n         let roots_to_scan = roots.len();\n@@ -185,7 +180,7 @@ impl ServerWorld {\n         } else {\n             res.push_str(\"workspaces:\\n\");\n             for w in self.workspaces.iter() {\n-                res += &format!(\"{} packages loaded\\n\", w.cargo.packages().count());\n+                res += &format!(\"{} packages loaded\\n\", w.count());\n             }\n         }\n         res.push_str(\"\\nanalysis:\\n\");"}, {"sha": "41c240139a6e8a563b09cfb4c20cccb10caa22dd", "filename": "crates/ra_lsp_server/tests/heavy_tests/main.rs", "status": "modified", "additions": 64, "deletions": 1, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/5232099977d07492c1b6d5e6163c70d4f6eb07df/crates%2Fra_lsp_server%2Ftests%2Fheavy_tests%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5232099977d07492c1b6d5e6163c70d4f6eb07df/crates%2Fra_lsp_server%2Ftests%2Fheavy_tests%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Ftests%2Fheavy_tests%2Fmain.rs?ref=5232099977d07492c1b6d5e6163c70d4f6eb07df", "patch": "@@ -12,8 +12,9 @@ use ra_lsp_server::req::{\n     CodeActionParams, CodeActionRequest, Formatting, Runnables, RunnablesParams, CompletionParams, Completion,\n };\n use serde_json::json;\n+use tempfile::TempDir;\n \n-use crate::support::project;\n+use crate::support::{project, project_with_tmpdir};\n \n const LOG: &'static str = \"\";\n \n@@ -258,3 +259,65 @@ fn main() {}\n         json!([]),\n     );\n }\n+\n+#[test]\n+fn test_missing_module_code_action_in_json_project() {\n+    let tmp_dir = TempDir::new().unwrap();\n+    let code = format!(\n+        r#\"\n+//- rust-project.json\n+{{ \n+    \"roots\": [ \"{PATH}\" ], \n+    \"crates\": [ {{ \"root_module\": \"{PATH}/src/lib.rs\", \"deps\": [], \"edition\": \"2015\" }} ] \n+}}\n+\n+//- src/lib.rs\n+mod bar;\n+\n+fn main() {}\n+\"#,\n+        PATH = tmp_dir.path().display()\n+    );\n+    let server = project_with_tmpdir(tmp_dir, &code);\n+    server.wait_for_message(\"workspace loaded\");\n+    let empty_context = || CodeActionContext { diagnostics: Vec::new(), only: None };\n+    server.request::<CodeActionRequest>(\n+        CodeActionParams {\n+            text_document: server.doc_id(\"src/lib.rs\"),\n+            range: Range::new(Position::new(0, 4), Position::new(0, 7)),\n+            context: empty_context(),\n+        },\n+        json!([\n+          {\n+            \"command\": {\n+              \"arguments\": [\n+                {\n+                  \"cursorPosition\": null,\n+                  \"label\": \"create module\",\n+                  \"workspaceEdit\": {\n+                    \"documentChanges\": [\n+                      {\n+                        \"kind\": \"create\",\n+                        \"uri\": \"file:///[..]/src/bar.rs\"\n+                      }\n+                    ]\n+                  }\n+                }\n+              ],\n+              \"command\": \"rust-analyzer.applySourceChange\",\n+              \"title\": \"create module\"\n+            },\n+            \"title\": \"create module\"\n+          }\n+        ]),\n+    );\n+\n+    server.request::<CodeActionRequest>(\n+        CodeActionParams {\n+            text_document: server.doc_id(\"src/lib.rs\"),\n+            range: Range::new(Position::new(2, 4), Position::new(2, 7)),\n+            context: empty_context(),\n+        },\n+        json!([]),\n+    );\n+}"}, {"sha": "e02d7858ec830dc334594ed162b335564f2b4dfb", "filename": "crates/ra_lsp_server/tests/heavy_tests/support.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5232099977d07492c1b6d5e6163c70d4f6eb07df/crates%2Fra_lsp_server%2Ftests%2Fheavy_tests%2Fsupport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5232099977d07492c1b6d5e6163c70d4f6eb07df/crates%2Fra_lsp_server%2Ftests%2Fheavy_tests%2Fsupport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Ftests%2Fheavy_tests%2Fsupport.rs?ref=5232099977d07492c1b6d5e6163c70d4f6eb07df", "patch": "@@ -27,12 +27,16 @@ use ra_lsp_server::{\n };\n \n pub fn project(fixture: &str) -> Server {\n+    let tmp_dir = TempDir::new().unwrap();\n+    project_with_tmpdir(tmp_dir, fixture)\n+}\n+\n+pub fn project_with_tmpdir(tmp_dir: TempDir, fixture: &str) -> Server {\n     static INIT: Once = Once::new();\n     INIT.call_once(|| {\n         let _ = Logger::with_env_or_str(crate::LOG).start().unwrap();\n     });\n \n-    let tmp_dir = TempDir::new().unwrap();\n     let mut paths = vec![];\n \n     for entry in parse_fixture(fixture) {"}, {"sha": "487cdfaf11735ad722f66f3843028af911208e90", "filename": "crates/ra_project_model/Cargo.toml", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5232099977d07492c1b6d5e6163c70d4f6eb07df/crates%2Fra_project_model%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/5232099977d07492c1b6d5e6163c70d4f6eb07df/crates%2Fra_project_model%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_project_model%2FCargo.toml?ref=5232099977d07492c1b6d5e6163c70d4f6eb07df", "patch": "@@ -17,5 +17,8 @@ cargo_metadata = \"0.7.0\"\n ra_arena = { path = \"../ra_arena\" }\n ra_db = { path = \"../ra_db\" }\n \n+serde = \"1.0.89\"\n+serde_json = \"1.0.39\"\n+\n [dev-dependencies]\n test_utils = { path = \"../test_utils\" }"}, {"sha": "9a9eb9e1fde9498928c956c9d60c52c4867b010b", "filename": "crates/ra_project_model/src/json_project.rs", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/5232099977d07492c1b6d5e6163c70d4f6eb07df/crates%2Fra_project_model%2Fsrc%2Fjson_project.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5232099977d07492c1b6d5e6163c70d4f6eb07df/crates%2Fra_project_model%2Fsrc%2Fjson_project.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_project_model%2Fsrc%2Fjson_project.rs?ref=5232099977d07492c1b6d5e6163c70d4f6eb07df", "patch": "@@ -0,0 +1,49 @@\n+use std::path::PathBuf;\n+\n+use serde::Deserialize;\n+\n+/// A root points to the directory which contains Rust crates. rust-analyzer watches all files in\n+/// all roots. Roots might be nested.\n+#[derive(Clone, Debug, Deserialize)]\n+#[serde(transparent)]\n+pub struct Root {\n+    pub(crate) path: PathBuf,\n+}\n+\n+/// A crate points to the root module of a crate and lists the dependencies of the crate. This is\n+/// useful in creating the crate graph.\n+#[derive(Clone, Debug, Deserialize)]\n+pub struct Crate {\n+    pub(crate) root_module: PathBuf,\n+    pub(crate) edition: Edition,\n+    pub(crate) deps: Vec<Dep>,\n+}\n+\n+#[derive(Clone, Copy, Debug, Deserialize)]\n+#[serde(rename = \"edition\")]\n+pub enum Edition {\n+    #[serde(rename = \"2015\")]\n+    Edition2015,\n+    #[serde(rename = \"2018\")]\n+    Edition2018,\n+}\n+\n+/// Identifies a crate by position in the crates array.\n+#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd)]\n+#[serde(transparent)]\n+pub struct CrateId(pub usize);\n+\n+/// A dependency of a crate, identified by its id in the crates array and name.\n+#[derive(Clone, Debug, Deserialize)]\n+pub struct Dep {\n+    #[serde(rename = \"crate\")]\n+    pub(crate) krate: CrateId,\n+    pub(crate) name: String,\n+}\n+\n+/// Roots and crates that compose this Rust project.\n+#[derive(Clone, Debug, Deserialize)]\n+pub struct JsonProject {\n+    pub(crate) roots: Vec<Root>,\n+    pub(crate) crates: Vec<Crate>,\n+}"}, {"sha": "c566ec0fb5fef33f2cc9f8c6d8a10e4a9428aa97", "filename": "crates/ra_project_model/src/lib.rs", "status": "modified", "additions": 174, "deletions": 69, "changes": 243, "blob_url": "https://github.com/rust-lang/rust/blob/5232099977d07492c1b6d5e6163c70d4f6eb07df/crates%2Fra_project_model%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5232099977d07492c1b6d5e6163c70d4f6eb07df/crates%2Fra_project_model%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_project_model%2Fsrc%2Flib.rs?ref=5232099977d07492c1b6d5e6163c70d4f6eb07df", "patch": "@@ -1,121 +1,226 @@\n mod cargo_workspace;\n+mod json_project;\n mod sysroot;\n \n-use std::path::{Path, PathBuf};\n+use std::{\n+    fs::File,\n+    io::BufReader,\n+    path::{Path, PathBuf},\n+};\n \n use failure::bail;\n use rustc_hash::FxHashMap;\n \n use ra_db::{CrateGraph, FileId, Edition};\n \n+use serde_json::from_reader;\n+\n pub use crate::{\n     cargo_workspace::{CargoWorkspace, Package, Target, TargetKind},\n+    json_project::JsonProject,\n     sysroot::Sysroot,\n };\n \n // TODO use proper error enum\n pub type Result<T> = ::std::result::Result<T, ::failure::Error>;\n \n #[derive(Debug, Clone)]\n-pub struct ProjectWorkspace {\n-    pub cargo: CargoWorkspace,\n-    pub sysroot: Sysroot,\n+pub enum ProjectWorkspace {\n+    /// Project workspace was discovered by running `cargo metadata` and `rustc --print sysroot`.\n+    Cargo { cargo: CargoWorkspace, sysroot: Sysroot },\n+    /// Project workspace was manually specified using a `rust-project.json` file.\n+    Json { project: JsonProject },\n }\n \n impl ProjectWorkspace {\n     pub fn discover(path: &Path) -> Result<ProjectWorkspace> {\n-        let cargo_toml = find_cargo_toml(path)?;\n-        let cargo = CargoWorkspace::from_cargo_metadata(&cargo_toml)?;\n-        let sysroot = Sysroot::discover(&cargo_toml)?;\n-        let res = ProjectWorkspace { cargo, sysroot };\n-        Ok(res)\n+        match find_rust_project_json(path) {\n+            Some(json_path) => {\n+                let file = File::open(json_path)?;\n+                let reader = BufReader::new(file);\n+                Ok(ProjectWorkspace::Json { project: from_reader(reader)? })\n+            }\n+            None => {\n+                let cargo_toml = find_cargo_toml(path)?;\n+                Ok(ProjectWorkspace::Cargo {\n+                    cargo: CargoWorkspace::from_cargo_metadata(&cargo_toml)?,\n+                    sysroot: Sysroot::discover(&cargo_toml)?,\n+                })\n+            }\n+        }\n     }\n \n-    pub fn to_crate_graph(&self, load: &mut dyn FnMut(&Path) -> Option<FileId>) -> CrateGraph {\n-        let mut crate_graph = CrateGraph::default();\n-        let mut sysroot_crates = FxHashMap::default();\n-        for krate in self.sysroot.crates() {\n-            if let Some(file_id) = load(krate.root(&self.sysroot)) {\n-                sysroot_crates\n-                    .insert(krate, crate_graph.add_crate_root(file_id, Edition::Edition2015));\n+    pub fn to_roots(&self) -> Vec<PathBuf> {\n+        match self {\n+            ProjectWorkspace::Json { project } => {\n+                let mut roots = Vec::with_capacity(project.roots.len());\n+                for root in &project.roots {\n+                    roots.push(root.path.clone());\n+                }\n+                roots\n             }\n-        }\n-        for from in self.sysroot.crates() {\n-            for to in from.deps(&self.sysroot) {\n-                let name = to.name(&self.sysroot);\n-                if let (Some(&from), Some(&to)) =\n-                    (sysroot_crates.get(&from), sysroot_crates.get(&to))\n-                {\n-                    if let Err(_) = crate_graph.add_dep(from, name.into(), to) {\n-                        log::error!(\"cyclic dependency between sysroot crates\")\n-                    }\n+            ProjectWorkspace::Cargo { cargo, sysroot } => {\n+                let mut roots =\n+                    Vec::with_capacity(cargo.packages().count() + sysroot.crates().count());\n+                for pkg in cargo.packages() {\n+                    roots.push(pkg.root(&cargo).to_path_buf());\n+                }\n+                for krate in sysroot.crates() {\n+                    roots.push(krate.root_dir(&sysroot).to_path_buf())\n                 }\n+                roots\n             }\n         }\n+    }\n \n-        let libstd = self.sysroot.std().and_then(|it| sysroot_crates.get(&it).map(|&it| it));\n-\n-        let mut pkg_to_lib_crate = FxHashMap::default();\n-        let mut pkg_crates = FxHashMap::default();\n-        // Next, create crates for each package, target pair\n-        for pkg in self.cargo.packages() {\n-            let mut lib_tgt = None;\n-            for tgt in pkg.targets(&self.cargo) {\n-                let root = tgt.root(&self.cargo);\n-                if let Some(file_id) = load(root) {\n-                    let edition = pkg.edition(&self.cargo);\n-                    let crate_id = crate_graph.add_crate_root(file_id, edition);\n-                    if tgt.kind(&self.cargo) == TargetKind::Lib {\n-                        lib_tgt = Some(crate_id);\n-                        pkg_to_lib_crate.insert(pkg, crate_id);\n+    pub fn count(&self) -> usize {\n+        match self {\n+            ProjectWorkspace::Json { project } => project.crates.len(),\n+            ProjectWorkspace::Cargo { cargo, .. } => cargo.packages().count(),\n+        }\n+    }\n+\n+    pub fn to_crate_graph(&self, load: &mut dyn FnMut(&Path) -> Option<FileId>) -> CrateGraph {\n+        let mut crate_graph = CrateGraph::default();\n+        match self {\n+            ProjectWorkspace::Json { project } => {\n+                let mut crates = FxHashMap::default();\n+                for (id, krate) in project.crates.iter().enumerate() {\n+                    let crate_id = json_project::CrateId(id);\n+                    if let Some(file_id) = load(&krate.root_module) {\n+                        let edition = match krate.edition {\n+                            json_project::Edition::Edition2015 => Edition::Edition2015,\n+                            json_project::Edition::Edition2018 => Edition::Edition2018,\n+                        };\n+                        crates.insert(crate_id, crate_graph.add_crate_root(file_id, edition));\n                     }\n-                    pkg_crates.entry(pkg).or_insert_with(Vec::new).push(crate_id);\n                 }\n-            }\n \n-            // Set deps to the std and to the lib target of the current package\n-            for &from in pkg_crates.get(&pkg).into_iter().flatten() {\n-                if let Some(to) = lib_tgt {\n-                    if to != from {\n-                        if let Err(_) = crate_graph.add_dep(from, pkg.name(&self.cargo).into(), to)\n+                for (id, krate) in project.crates.iter().enumerate() {\n+                    for dep in &krate.deps {\n+                        let from_crate_id = json_project::CrateId(id);\n+                        let to_crate_id = dep.krate;\n+                        if let (Some(&from), Some(&to)) =\n+                            (crates.get(&from_crate_id), crates.get(&to_crate_id))\n                         {\n-                            log::error!(\n-                                \"cyclic dependency between targets of {}\",\n-                                pkg.name(&self.cargo)\n-                            )\n+                            if let Err(_) = crate_graph.add_dep(from, dep.name.clone().into(), to) {\n+                                log::error!(\n+                                    \"cyclic dependency {:?} -> {:?}\",\n+                                    from_crate_id,\n+                                    to_crate_id\n+                                );\n+                            }\n                         }\n                     }\n                 }\n-                if let Some(std) = libstd {\n-                    if let Err(_) = crate_graph.add_dep(from, \"std\".into(), std) {\n-                        log::error!(\"cyclic dependency on std for {}\", pkg.name(&self.cargo))\n+            }\n+            ProjectWorkspace::Cargo { cargo, sysroot } => {\n+                let mut sysroot_crates = FxHashMap::default();\n+                for krate in sysroot.crates() {\n+                    if let Some(file_id) = load(krate.root(&sysroot)) {\n+                        sysroot_crates.insert(\n+                            krate,\n+                            crate_graph.add_crate_root(file_id, Edition::Edition2015),\n+                        );\n                     }\n                 }\n-            }\n-        }\n+                for from in sysroot.crates() {\n+                    for to in from.deps(&sysroot) {\n+                        let name = to.name(&sysroot);\n+                        if let (Some(&from), Some(&to)) =\n+                            (sysroot_crates.get(&from), sysroot_crates.get(&to))\n+                        {\n+                            if let Err(_) = crate_graph.add_dep(from, name.into(), to) {\n+                                log::error!(\"cyclic dependency between sysroot crates\")\n+                            }\n+                        }\n+                    }\n+                }\n+\n+                let libstd = sysroot.std().and_then(|it| sysroot_crates.get(&it).map(|&it| it));\n+\n+                let mut pkg_to_lib_crate = FxHashMap::default();\n+                let mut pkg_crates = FxHashMap::default();\n+                // Next, create crates for each package, target pair\n+                for pkg in cargo.packages() {\n+                    let mut lib_tgt = None;\n+                    for tgt in pkg.targets(&cargo) {\n+                        let root = tgt.root(&cargo);\n+                        if let Some(file_id) = load(root) {\n+                            let edition = pkg.edition(&cargo);\n+                            let crate_id = crate_graph.add_crate_root(file_id, edition);\n+                            if tgt.kind(&cargo) == TargetKind::Lib {\n+                                lib_tgt = Some(crate_id);\n+                                pkg_to_lib_crate.insert(pkg, crate_id);\n+                            }\n+                            pkg_crates.entry(pkg).or_insert_with(Vec::new).push(crate_id);\n+                        }\n+                    }\n \n-        // Now add a dep ednge from all targets of upstream to the lib\n-        // target of downstream.\n-        for pkg in self.cargo.packages() {\n-            for dep in pkg.dependencies(&self.cargo) {\n-                if let Some(&to) = pkg_to_lib_crate.get(&dep.pkg) {\n+                    // Set deps to the std and to the lib target of the current package\n                     for &from in pkg_crates.get(&pkg).into_iter().flatten() {\n-                        if let Err(_) = crate_graph.add_dep(from, dep.name.clone().into(), to) {\n-                            log::error!(\n-                                \"cyclic dependency {} -> {}\",\n-                                pkg.name(&self.cargo),\n-                                dep.pkg.name(&self.cargo)\n-                            )\n+                        if let Some(to) = lib_tgt {\n+                            if to != from {\n+                                if let Err(_) =\n+                                    crate_graph.add_dep(from, pkg.name(&cargo).into(), to)\n+                                {\n+                                    log::error!(\n+                                        \"cyclic dependency between targets of {}\",\n+                                        pkg.name(&cargo)\n+                                    )\n+                                }\n+                            }\n+                        }\n+                        if let Some(std) = libstd {\n+                            if let Err(_) = crate_graph.add_dep(from, \"std\".into(), std) {\n+                                log::error!(\"cyclic dependency on std for {}\", pkg.name(&cargo))\n+                            }\n+                        }\n+                    }\n+                }\n+\n+                // Now add a dep ednge from all targets of upstream to the lib\n+                // target of downstream.\n+                for pkg in cargo.packages() {\n+                    for dep in pkg.dependencies(&cargo) {\n+                        if let Some(&to) = pkg_to_lib_crate.get(&dep.pkg) {\n+                            for &from in pkg_crates.get(&pkg).into_iter().flatten() {\n+                                if let Err(_) =\n+                                    crate_graph.add_dep(from, dep.name.clone().into(), to)\n+                                {\n+                                    log::error!(\n+                                        \"cyclic dependency {} -> {}\",\n+                                        pkg.name(&cargo),\n+                                        dep.pkg.name(&cargo)\n+                                    )\n+                                }\n+                            }\n                         }\n                     }\n                 }\n             }\n         }\n-\n         crate_graph\n     }\n }\n \n+fn find_rust_project_json(path: &Path) -> Option<PathBuf> {\n+    if path.ends_with(\"rust-project.json\") {\n+        return Some(path.to_path_buf());\n+    }\n+\n+    let mut curr = Some(path);\n+    while let Some(path) = curr {\n+        let candidate = path.join(\"rust-project.json\");\n+        if candidate.exists() {\n+            return Some(candidate);\n+        }\n+        curr = path.parent();\n+    }\n+\n+    None\n+}\n+\n fn find_cargo_toml(path: &Path) -> Result<PathBuf> {\n     if path.ends_with(\"Cargo.toml\") {\n         return Ok(path.to_path_buf());"}]}