{"sha": "05cd48b008630cda27e2f1a082f9bab33d13a340", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA1Y2Q0OGIwMDg2MzBjZGEyN2UyZjFhMDgyZjliYWIzM2QxM2EzNDA=", "commit": {"author": {"name": "Andreas Liljeqvist", "email": "bonega@gmail.com", "date": "2021-08-25T13:21:45Z"}, "committer": {"name": "Andreas Liljeqvist", "email": "bonega@gmail.com", "date": "2021-09-09T08:41:17Z"}, "message": "Add methods for checking for full ranges to `Scalar` and `WrappingRange`\n\nMove *_max methods back to util\n\nchange to inline instead of inline(always)\n\nRemove valid_range_exclusive from scalar\nUse WrappingRange instead\n\nimplement always_valid_for in a safer way\n\nFix accidental edit", "tree": {"sha": "7c107af072d83ccc589979ac050394b34bcd80ff", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7c107af072d83ccc589979ac050394b34bcd80ff"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/05cd48b008630cda27e2f1a082f9bab33d13a340", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/05cd48b008630cda27e2f1a082f9bab33d13a340", "html_url": "https://github.com/rust-lang/rust/commit/05cd48b008630cda27e2f1a082f9bab33d13a340", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/05cd48b008630cda27e2f1a082f9bab33d13a340/comments", "author": {"login": "bonega", "id": 411677, "node_id": "MDQ6VXNlcjQxMTY3Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/411677?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bonega", "html_url": "https://github.com/bonega", "followers_url": "https://api.github.com/users/bonega/followers", "following_url": "https://api.github.com/users/bonega/following{/other_user}", "gists_url": "https://api.github.com/users/bonega/gists{/gist_id}", "starred_url": "https://api.github.com/users/bonega/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bonega/subscriptions", "organizations_url": "https://api.github.com/users/bonega/orgs", "repos_url": "https://api.github.com/users/bonega/repos", "events_url": "https://api.github.com/users/bonega/events{/privacy}", "received_events_url": "https://api.github.com/users/bonega/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bonega", "id": 411677, "node_id": "MDQ6VXNlcjQxMTY3Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/411677?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bonega", "html_url": "https://github.com/bonega", "followers_url": "https://api.github.com/users/bonega/followers", "following_url": "https://api.github.com/users/bonega/following{/other_user}", "gists_url": "https://api.github.com/users/bonega/gists{/gist_id}", "starred_url": "https://api.github.com/users/bonega/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bonega/subscriptions", "organizations_url": "https://api.github.com/users/bonega/orgs", "repos_url": "https://api.github.com/users/bonega/repos", "events_url": "https://api.github.com/users/bonega/events{/privacy}", "received_events_url": "https://api.github.com/users/bonega/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c5cbf7852a7692c7c51df64c09a59e7838b55202", "url": "https://api.github.com/repos/rust-lang/rust/commits/c5cbf7852a7692c7c51df64c09a59e7838b55202", "html_url": "https://github.com/rust-lang/rust/commit/c5cbf7852a7692c7c51df64c09a59e7838b55202"}], "stats": {"total": 97, "additions": 41, "deletions": 56}, "files": [{"sha": "cf21c2bb6e14cbb0df2afb9107d7de2500755d26", "filename": "compiler/rustc_codegen_llvm/src/abi.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/05cd48b008630cda27e2f1a082f9bab33d13a340/compiler%2Frustc_codegen_llvm%2Fsrc%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05cd48b008630cda27e2f1a082f9bab33d13a340/compiler%2Frustc_codegen_llvm%2Fsrc%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fabi.rs?ref=05cd48b008630cda27e2f1a082f9bab33d13a340", "patch": "@@ -541,11 +541,8 @@ impl<'tcx> FnAbiLlvmExt<'tcx> for FnAbi<'tcx, Ty<'tcx>> {\n             // become 0..0 when the type becomes i1, which would be rejected\n             // by the LLVM verifier.\n             if let Int(..) = scalar.value {\n-                if !scalar.is_bool() {\n-                    let range = scalar.valid_range_exclusive(bx);\n-                    if range.start != range.end {\n-                        bx.range_metadata(callsite, range);\n-                    }\n+                if !scalar.is_bool() && !scalar.is_always_valid_for(bx) {\n+                    bx.range_metadata(callsite, &scalar.valid_range);\n                 }\n             }\n         }"}, {"sha": "8e7be6bcca1c62e7d133b47641ce0fbd5100fe4b", "filename": "compiler/rustc_codegen_llvm/src/builder.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/05cd48b008630cda27e2f1a082f9bab33d13a340/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05cd48b008630cda27e2f1a082f9bab33d13a340/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs?ref=05cd48b008630cda27e2f1a082f9bab33d13a340", "patch": "@@ -18,12 +18,12 @@ use rustc_hir::def_id::DefId;\n use rustc_middle::ty::layout::{LayoutError, LayoutOfHelpers, TyAndLayout};\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_span::Span;\n-use rustc_target::abi::{self, Align, Size};\n+use rustc_target::abi::{self, Align, Size, WrappingRange};\n use rustc_target::spec::{HasTargetSpec, Target};\n use std::borrow::Cow;\n use std::ffi::CStr;\n use std::iter;\n-use std::ops::{Deref, Range};\n+use std::ops::Deref;\n use std::ptr;\n use tracing::debug;\n \n@@ -464,9 +464,8 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         ) {\n             match scalar.value {\n                 abi::Int(..) => {\n-                    let range = scalar.valid_range_exclusive(bx);\n-                    if range.start != range.end {\n-                        bx.range_metadata(load, range);\n+                    if !scalar.is_always_valid_for(bx) {\n+                        bx.range_metadata(load, &scalar.valid_range);\n                     }\n                 }\n                 abi::Pointer if !scalar.valid_range.contains_zero() => {\n@@ -555,7 +554,7 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         next_bx\n     }\n \n-    fn range_metadata(&mut self, load: &'ll Value, range: Range<u128>) {\n+    fn range_metadata(&mut self, load: &'ll Value, range: &WrappingRange) {\n         if self.sess().target.arch == \"amdgpu\" {\n             // amdgpu/LLVM does something weird and thinks an i64 value is\n             // split into a v2i32, halving the bitwidth LLVM expects,\n@@ -568,7 +567,7 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n             let llty = self.cx.val_ty(load);\n             let v = [\n                 self.cx.const_uint_big(llty, range.start),\n-                self.cx.const_uint_big(llty, range.end),\n+                self.cx.const_uint_big(llty, range.end.wrapping_add(1)),\n             ];\n \n             llvm::LLVMSetMetadata("}, {"sha": "93dc9850fc77d6226cb1d3930bc7732741587eee", "filename": "compiler/rustc_codegen_ssa/src/mir/block.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/05cd48b008630cda27e2f1a082f9bab33d13a340/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05cd48b008630cda27e2f1a082f9bab33d13a340/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs?ref=05cd48b008630cda27e2f1a082f9bab33d13a340", "patch": "@@ -20,7 +20,7 @@ use rustc_middle::ty::{self, Instance, Ty, TypeFoldable};\n use rustc_span::source_map::Span;\n use rustc_span::{sym, Symbol};\n use rustc_target::abi::call::{ArgAbi, FnAbi, PassMode};\n-use rustc_target::abi::{self, HasDataLayout};\n+use rustc_target::abi::{self, HasDataLayout, WrappingRange};\n use rustc_target::spec::abi::Abi;\n \n /// Used by `FunctionCx::codegen_terminator` for emitting common patterns\n@@ -1104,7 +1104,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 llval = bx.load(bx.backend_type(arg.layout), llval, align);\n                 if let abi::Abi::Scalar(ref scalar) = arg.layout.abi {\n                     if scalar.is_bool() {\n-                        bx.range_metadata(llval, 0..2);\n+                        bx.range_metadata(llval, &WrappingRange { start: 0, end: 1 });\n                     }\n                 }\n                 // We store bools as `i8` so we need to truncate to `i1`."}, {"sha": "7bc44729c26482bd5d629f8b9dbdcda268dfd9cd", "filename": "compiler/rustc_codegen_ssa/src/mir/rvalue.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/05cd48b008630cda27e2f1a082f9bab33d13a340/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05cd48b008630cda27e2f1a082f9bab33d13a340/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs?ref=05cd48b008630cda27e2f1a082f9bab33d13a340", "patch": "@@ -308,8 +308,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                                 // then `i1 1` (i.e., E::B) is effectively `i8 -1`.\n                                 signed = !scalar.is_bool() && s;\n \n-                                let er = scalar.valid_range_exclusive(bx.cx());\n-                                if er.end != er.start\n+                                if !scalar.is_always_valid_for(bx.cx())\n                                     && scalar.valid_range.end >= scalar.valid_range.start\n                                 {\n                                     // We want `table[e as usize \u00b1 k]` to not"}, {"sha": "935f2240143dfcb954b2de634d7b63c98f9f6f47", "filename": "compiler/rustc_codegen_ssa/src/traits/builder.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/05cd48b008630cda27e2f1a082f9bab33d13a340/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05cd48b008630cda27e2f1a082f9bab33d13a340/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbuilder.rs?ref=05cd48b008630cda27e2f1a082f9bab33d13a340", "patch": "@@ -16,11 +16,9 @@ use crate::MemFlags;\n use rustc_middle::ty::layout::{HasParamEnv, TyAndLayout};\n use rustc_middle::ty::Ty;\n use rustc_span::Span;\n-use rustc_target::abi::{Abi, Align, Scalar, Size};\n+use rustc_target::abi::{Abi, Align, Scalar, Size, WrappingRange};\n use rustc_target::spec::HasTargetSpec;\n \n-use std::ops::Range;\n-\n #[derive(Copy, Clone)]\n pub enum OverflowOp {\n     Add,\n@@ -158,7 +156,7 @@ pub trait BuilderMethods<'a, 'tcx>:\n         dest: PlaceRef<'tcx, Self::Value>,\n     ) -> Self;\n \n-    fn range_metadata(&mut self, load: Self::Value, range: Range<u128>);\n+    fn range_metadata(&mut self, load: Self::Value, range: &WrappingRange);\n     fn nonnull_metadata(&mut self, load: Self::Value);\n \n     fn store(&mut self, val: Self::Value, ptr: Self::Value, align: Align) -> Self::Value;"}, {"sha": "7ae3f98d834b49eee5c1a4e374fa0064310f2ba5", "filename": "compiler/rustc_const_eval/src/interpret/validity.rs", "status": "modified", "additions": 13, "deletions": 15, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/05cd48b008630cda27e2f1a082f9bab33d13a340/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05cd48b008630cda27e2f1a082f9bab33d13a340/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs?ref=05cd48b008630cda27e2f1a082f9bab33d13a340", "patch": "@@ -620,38 +620,36 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n         op: &OpTy<'tcx, M::PointerTag>,\n         scalar_layout: &ScalarAbi,\n     ) -> InterpResult<'tcx> {\n-        let value = self.read_scalar(op)?;\n-        let valid_range = scalar_layout.valid_range.clone();\n-        let WrappingRange { start: lo, end: hi } = valid_range;\n-        // Determine the allowed range\n-        // `max_hi` is as big as the size fits\n-        let max_hi = u128::MAX >> (128 - op.layout.size.bits());\n-        assert!(hi <= max_hi);\n-        // We could also write `(hi + 1) % (max_hi + 1) == lo` but `max_hi + 1` overflows for `u128`\n-        if (lo == 0 && hi == max_hi) || (hi + 1 == lo) {\n+        if scalar_layout.valid_range.is_full_for(op.layout.size) {\n             // Nothing to check\n             return Ok(());\n         }\n-        // At least one value is excluded. Get the bits.\n+        // At least one value is excluded.\n+        let valid_range = scalar_layout.valid_range.clone();\n+        let WrappingRange { start, end } = valid_range;\n+        let max_value = u128::MAX >> (128 - op.layout.size.bits());\n+        assert!(end <= max_value);\n+        // Determine the allowed range\n+        let value = self.read_scalar(op)?;\n         let value = try_validation!(\n             value.check_init(),\n             self.path,\n             err_ub!(InvalidUninitBytes(None)) => { \"{}\", value }\n-                expected { \"something {}\", wrapping_range_format(valid_range, max_hi) },\n+                expected { \"something {}\", wrapping_range_format(valid_range, max_value) },\n         );\n         let bits = match value.try_to_int() {\n             Err(_) => {\n                 // So this is a pointer then, and casting to an int failed.\n                 // Can only happen during CTFE.\n                 let ptr = self.ecx.scalar_to_ptr(value);\n-                if lo == 1 && hi == max_hi {\n+                if start == 1 && end == max_value {\n                     // Only null is the niche.  So make sure the ptr is NOT null.\n                     if self.ecx.memory.ptr_may_be_null(ptr) {\n                         throw_validation_failure!(self.path,\n                             { \"a potentially null pointer\" }\n                             expected {\n                                 \"something that cannot possibly fail to be {}\",\n-                                wrapping_range_format(valid_range, max_hi)\n+                                wrapping_range_format(valid_range, max_value)\n                             }\n                         )\n                     }\n@@ -663,7 +661,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n                         { \"a pointer\" }\n                         expected {\n                             \"something that cannot possibly fail to be {}\",\n-                            wrapping_range_format(valid_range, max_hi)\n+                            wrapping_range_format(valid_range, max_value)\n                         }\n                     )\n                 }\n@@ -676,7 +674,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n         } else {\n             throw_validation_failure!(self.path,\n                 { \"{}\", bits }\n-                expected { \"something {}\", wrapping_range_format(valid_range, max_hi) }\n+                expected { \"something {}\", wrapping_range_format(valid_range, max_value) }\n             )\n         }\n     }"}, {"sha": "4ed8149dadc57c3f7d6c9fa5577815ef73f5e5a9", "filename": "compiler/rustc_target/src/abi/mod.rs", "status": "modified", "additions": 15, "deletions": 21, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/05cd48b008630cda27e2f1a082f9bab33d13a340/compiler%2Frustc_target%2Fsrc%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05cd48b008630cda27e2f1a082f9bab33d13a340/compiler%2Frustc_target%2Fsrc%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fmod.rs?ref=05cd48b008630cda27e2f1a082f9bab33d13a340", "patch": "@@ -7,7 +7,7 @@ use std::convert::{TryFrom, TryInto};\n use std::fmt;\n use std::iter::Step;\n use std::num::NonZeroUsize;\n-use std::ops::{Add, AddAssign, Deref, Mul, Range, RangeInclusive, Sub};\n+use std::ops::{Add, AddAssign, Deref, Mul, RangeInclusive, Sub};\n use std::str::FromStr;\n \n use rustc_index::vec::{Idx, IndexVec};\n@@ -779,6 +779,14 @@ impl WrappingRange {\n         self.end = end;\n         self\n     }\n+\n+    /// Returns `true` if `size` completely fills the range.\n+    #[inline]\n+    pub fn is_full_for(&self, size: Size) -> bool {\n+        let max_value = u128::MAX >> (128 - size.bits());\n+        debug_assert!(self.start <= max_value && self.end <= max_value);\n+        (self.start == 0 && self.end == max_value) || (self.end + 1 == self.start)\n+    }\n }\n \n impl fmt::Debug for WrappingRange {\n@@ -807,21 +815,10 @@ impl Scalar {\n             && matches!(self.valid_range, WrappingRange { start: 0, end: 1 })\n     }\n \n-    /// Returns the valid range as a `x..y` range.\n-    ///\n-    /// If `x` and `y` are equal, the range is full, not empty.\n-    pub fn valid_range_exclusive<C: HasDataLayout>(&self, cx: &C) -> Range<u128> {\n-        // For a (max) value of -1, max will be `-1 as usize`, which overflows.\n-        // However, that is fine here (it would still represent the full range),\n-        // i.e., if the range is everything.\n-        let bits = self.value.size(cx).bits();\n-        assert!(bits <= 128);\n-        let mask = !0u128 >> (128 - bits);\n-        let start = self.valid_range.start;\n-        let end = self.valid_range.end;\n-        assert_eq!(start, start & mask);\n-        assert_eq!(end, end & mask);\n-        start..(end.wrapping_add(1) & mask)\n+    /// Returns `true` if all possible numbers are valid, i.e `valid_range` covers the whole layout\n+    #[inline]\n+    pub fn is_always_valid_for<C: HasDataLayout>(&self, cx: &C) -> bool {\n+        self.valid_range.is_full_for(self.value.size(cx))\n     }\n }\n \n@@ -1269,11 +1266,8 @@ impl<'a, Ty> TyAndLayout<'a, Ty> {\n                 // The range must contain 0.\n                 s.valid_range.contains_zero()\n             } else {\n-                // The range must include all values. `valid_range_exclusive` handles\n-                // the wrap-around using target arithmetic; with wrap-around then the full\n-                // range is one where `start == end`.\n-                let range = s.valid_range_exclusive(cx);\n-                range.start == range.end\n+                // The range must include all values.\n+                s.is_always_valid_for(cx)\n             }\n         };\n "}]}